(ns bitclojn.core)

(defmacro § [& _])
(defmacro ß [& _])

(defmacro def- [s i] `(def ~(vary-meta s assoc :private true) ~i))

(defmacro when' [y & w]
    (let [[_ & w] (if (= '=> (first w)) (rest w) (cons nil w))]
        `(if ~y (do ~@w) ~_)))
(defmacro let-when [x y & w]
    (let [[_ & w] (if (= '=> (first w)) (rest w) (cons nil w))]
        `(let [~@x] (if ~y (do ~@w) ~_))))

(defn -main [& args]
    )

#_(ns org.bitcoinj.core #_"AbstractBlockChain"
    (:import [java.util *]
             [java.util.concurrent *]
             [java.util.concurrent.locks *])
    (:import [com.google.common.base *]
             [com.google.common.collect *]
             [com.google.common.util.concurrent *]
             [org.slf4j *])
   (:require [org.bitcoinj.core.listeners *]
             [org.bitcoinj.store *]
             [org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>An AbstractBlockChain holds a series of {@link Block} objects, links them together, and knows how to verify that
 ; the chain follows the rules of the {@link NetworkParameters} for this chain.</p>
 ;
 ; <p>It can be connected to a {@link Wallet}, and also {@link TransactionReceivedInBlockListener}s that can receive
 ; transactions and notifications of re-organizations.</p>
 ;
 ; <p>An AbstractBlockChain implementation must be connected to a {@link BlockStore} implementation.  The chain object
 ; by itself doesn't store any data, that's delegated to the store.  Which store you use is a decision best made by
 ; reading the getting started guide, but briefly, fully validating block chains need fully validating stores.  In
 ; the lightweight SPV mode, a {@link org.bitcoinj.store.SPVBlockStore} is the right choice.</p>
 ;
 ; <p>This class implements an abstract class which makes it simple to create a BlockChain that does/doesn't do
 ; full verification.  It verifies headers and is implements most of what is required to implement SPV mode, but
 ; also provides callback hooks which can be used to do full verification.</p>
 ;
 ; <p>There are two subclasses of AbstractBlockChain that are useful: {@link BlockChain}, which is the simplest
 ; class and implements <i>simplified payment verification</i>.  This is a lightweight and efficient mode that
 ; does not verify the contents of blocks, just their headers.  A {@link FullPrunedBlockChain} paired with a
 ; {@link org.bitcoinj.store.H2FullPrunedBlockStore} implements full verification, which is equivalent to
 ; Bitcoin Core.  To learn more about the alternative security models, please consult the articles on the
 ; website.</p>
 ;
 ; <b>Theory</b>
 ;
 ; <p>The 'chain' is actually a tree although in normal operation it operates mostly as a list of {@link Block}s.
 ; When multiple new head blocks are found simultaneously, there are multiple stories of the economy competing to become
 ; the one true consensus.  This can happen naturally when two miners solve a block within a few seconds of each other,
 ; or it can happen when the chain is under attack.</p>
 ;
 ; <p>A reference to the head block of the best known chain is stored.  If you can reach the genesis block by repeatedly
 ; walking through the prevBlock pointers, then we say this is a full chain.  If you cannot reach the genesis block
 ; we say it is an orphan chain.  Orphan chains can occur when blocks are solved and received during the initial block
 ; chain download, or if we connect to a peer that doesn't send us blocks in order.</p>
 ;
 ; <p>A reorganize occurs when the blocks that make up the best known chain changes.  Note that simply adding a
 ; new block to the top of the best chain isn't as reorganize, but that a reorganize is always triggered by adding
 ; a new block that connects to some other (non best head) block.  By "best" we mean the chain representing the largest
 ; amount of work done.</p>
 ;
 ; <p>Every so often the block chain passes a difficulty transition point.  At that time, all the blocks in the last
 ; 2016 blocks are examined and a new difficulty target is calculated from them.</p>
 ;;
#_public
#_abstract
(§ class AbstractBlockChain
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars AbstractBlockChain.class))

    #_protected
    #_final
    (§ field ReentrantLock lock = Threading.lock(§ pars "blockchain"))

    ;;; Keeps a map of block hashes to StoredBlocks. ;;
    #_private
    #_final
    (§ field BlockStore blockStore)

    ;;;
     ; Tracks the top of the best known chain.
     ;
     ; Following this one down to the genesis block produces the story of the economy from the creation of Bitcoin
     ; until the present day.  The chain head can change if a new set of blocks is received that results in a chain of
     ; greater work than the one obtained by following this one down.  In that case a reorganize is triggered,
     ; potentially invalidating transactions in our wallet.
     ;;
    #_protected
    (§ field StoredBlock chainHead)

    ;; TODO: Scrap this and use a proper read/write for all of the block chain objects.
    ;; The chainHead field is read/written synchronized with this object rather than BlockChain.  However writing is
    ;; also guaranteed to happen whilst BlockChain is synchronized (see setChainHead).  The goal of this is to let
    ;; clients quickly access the chain head even whilst the block chain is downloading and thus the BlockChain is
    ;; locked most of the time.
    #_private
    #_final
    (§ field Object chainHeadLock = new Object(§ pars ))

    #_protected
    #_final
    (§ field NetworkParameters params)
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<NewBestBlockListener>> newBestBlockListeners)
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<ReorganizeListener>> reorganizeListeners)
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<TransactionReceivedInBlockListener>> transactionReceivedListeners)

    ;; Holds a block header and, optionally, a list of tx hashes or block's transactions.
    (§ class OrphanBlock
        #_final
        (§ field Block block)
        #_final
        (§ field List<Sha256Hash> filteredTxHashes)
        #_final
        (§ field Map<Sha256Hash, Transaction> filteredTxn)

        (§ constructor OrphanBlock(§ args Block block, #_nilable List<Sha256Hash> filteredTxHashes, #_nilable Map<Sha256Hash, Transaction> filteredTxn))
        (§ block
            #_final
            (§ var boolean filtered = (§ expr filteredTxHashes != nil && filteredTxn != nil))
            (§ call Preconditions.checkArgument(§ pars (§ expr block.transactions == nil && filtered) || (§ expr block.transactions != nil && !filtered)))
            (§ ass this.block = block)
            (§ ass this.filteredTxHashes = filteredTxHashes)
            (§ ass this.filteredTxn = filteredTxn)
        )
    )
    ;; Holds blocks that we have received but can't plug into the chain yet, e.g. because they were created whilst we
    ;; were downloading the block chain.
    #_private
    #_final
    (§ field LinkedHashMap<Sha256Hash, OrphanBlock> orphanBlocks = new LinkedHashMap<>(§ pars ))

    ;;; False positive estimation uses a double exponential moving average. ;;
    #_public
    #_static
    #_final
    (§ field double FP_ESTIMATOR_ALPHA = 0.0001)
    ;;; False positive estimation uses a double exponential moving average. ;;
    #_public
    #_static
    #_final
    (§ field double FP_ESTIMATOR_BETA = 0.01)

    #_private
    (§ field double falsePositiveRate)
    #_private
    (§ field double falsePositiveTrend)
    #_private
    (§ field double previousFalsePositiveRate)

    #_private
    #_final
    (§ field VersionTally versionTally)

    ;;; See {@link #AbstractBlockChain(Context, List, BlockStore)} ;;
    #_public
    (§ constructor AbstractBlockChain(§ args NetworkParameters params, List<? extends Wallet> transactionReceivedListeners, BlockStore blockStore))
        (§ throws BlockStoreException)
    (§ block
        (§ this (§ pars Context.getOrCreate(§ pars params), transactionReceivedListeners, blockStore))
    )

    ;;;
     ; Constructs a BlockChain connected to the given list of listeners (e.g. wallets) and a store.
     ;;
    #_public
    (§ constructor AbstractBlockChain(§ args Context context, List<? extends Wallet> wallets, BlockStore blockStore))
        (§ throws BlockStoreException)
    (§ block
        (§ ass this.blockStore = blockStore)
        (§ ass chainHead = blockStore.getChainHead(§ pars ))
        (§ call log.info(§ pars "chain head is at height {}:\n{}", chainHead.getHeight(§ pars ), chainHead.getHeader(§ pars )))
        (§ ass this.params = context.getParams(§ pars ))

        (§ ass this.newBestBlockListeners = new CopyOnWriteArrayList<>(§ pars ))
        (§ ass this.reorganizeListeners = new CopyOnWriteArrayList<>(§ pars ))
        (§ ass this.transactionReceivedListeners = new CopyOnWriteArrayList<>(§ pars ))
        (§ for (§ var NewBestBlockListener l) :for (§ expr wallets))
        (§ block
            (§ call addNewBestBlockListener(§ pars Threading.SAME_THREAD, l))
        )
        (§ for (§ var ReorganizeListener l) :for (§ expr wallets))
        (§ block
            (§ call addReorganizeListener(§ pars Threading.SAME_THREAD, l))
        )
        (§ for (§ var TransactionReceivedInBlockListener l) :for (§ expr wallets))
        (§ block
            (§ call addTransactionReceivedListener(§ pars Threading.SAME_THREAD, l))
        )

        (§ ass this.versionTally = new VersionTally(§ pars context.getParams(§ pars )))
        (§ call this.versionTally.initialize(§ pars blockStore, chainHead))
    )

    ;;;
     ; Add a wallet to the BlockChain.  Note that the wallet will be unaffected by any blocks received while it
     ; was not part of this BlockChain.  This method is useful if the wallet has just been created, and its keys
     ; have never been in use, or if the wallet has been loaded along with the BlockChain.  Note that adding
     ; multiple wallets is not well tested!
     ;;
    #_public
    #_final
    (§ method void addWallet(§ args Wallet wallet))
    (§ block
        (§ call addNewBestBlockListener(§ pars Threading.SAME_THREAD, wallet))
        (§ call addReorganizeListener(§ pars Threading.SAME_THREAD, wallet))
        (§ call addTransactionReceivedListener(§ pars Threading.SAME_THREAD, wallet))

        (§ var int walletHeight = wallet.getLastBlockSeenHeight(§ pars ))
        (§ var int chainHeight = getBestChainHeight(§ pars ))
        (§ if (§ expr walletHeight != chainHeight))
        (§ block
            (§ call log.warn(§ pars "Wallet/chain height mismatch: {} vs {}", walletHeight, chainHeight))
            (§ call log.warn(§ pars "Hashes: {} vs {}", wallet.getLastBlockSeenHash(§ pars ), getChainHead(§ pars ).getHeader(§ pars ).getHash(§ pars )))

            ;; This special case happens when the VM crashes because of a transaction received.  It causes the updated
            ;; block store to persist, but not the wallet.  In order to fix the issue, we roll back the block store to
            ;; the wallet height to make it look like as if the block has never been received.
            (§ if (§ expr 0 < walletHeight && walletHeight < chainHeight))
            (§ block
                (§ try )
                (§ block
                    (§ call rollbackBlockStore(§ pars walletHeight))
                    (§ call log.info(§ pars "Rolled back block store to height {}.", walletHeight))
                )
                (§ catch (§ args BlockStoreException _))
                (§ block
                    (§ call log.warn(§ pars "Rollback of block store failed, continuing with mismatched heights. This can happen due to a replay."))
                )
            )
        )
    )

    ;;; Removes a wallet from the chain. ;;
    #_public
    (§ method void removeWallet(§ args Wallet wallet))
    (§ block
        (§ call removeNewBestBlockListener(§ pars wallet))
        (§ call removeReorganizeListener(§ pars wallet))
        (§ call removeTransactionReceivedListener(§ pars wallet))
    )

    ;;; Replaced with more specific listener methods: use them instead. ;;
    #_deprecated
    #_suppress(§ opt "deprecation")
    #_public
    (§ method void addListener(§ args BlockChainListener listener))
    (§ block
        (§ call addListener(§ pars listener, Threading.USER_THREAD))
    )

    ;;; Replaced with more specific listener methods: use them instead. ;;
    #_deprecated
    #_public
    (§ method void addListener(§ args BlockChainListener listener, Executor executor))
    (§ block
        (§ call addReorganizeListener(§ pars executor, listener))
        (§ call addNewBestBlockListener(§ pars executor, listener))
        (§ call addTransactionReceivedListener(§ pars executor, listener))
    )

    #_deprecated
    #_public
    (§ method void removeListener(§ args BlockChainListener listener))
    (§ block
        (§ call removeReorganizeListener(§ pars listener))
        (§ call removeNewBestBlockListener(§ pars listener))
        (§ call removeTransactionReceivedListener(§ pars listener))
    )

    ;;;
     ; Adds a {@link NewBestBlockListener} listener to the chain.
     ;;
    #_public
    (§ method void addNewBestBlockListener(§ args NewBestBlockListener listener))
    (§ block
        (§ call addNewBestBlockListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;;
     ; Adds a {@link NewBestBlockListener} listener to the chain.
     ;;
    #_public
    #_final
    (§ method void addNewBestBlockListener(§ args Executor executor, NewBestBlockListener listener))
    (§ block
        (§ call newBestBlockListeners.add(§ pars new ListenerRegistration<>(§ pars listener, executor)))
    )

    ;;;
     ; Adds a generic {@link ReorganizeListener} listener to the chain.
     ;;
    #_public
    (§ method void addReorganizeListener(§ args ReorganizeListener listener))
    (§ block
        (§ call addReorganizeListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;;
     ; Adds a generic {@link ReorganizeListener} listener to the chain.
     ;;
    #_public
    #_final
    (§ method void addReorganizeListener(§ args Executor executor, ReorganizeListener listener))
    (§ block
        (§ call reorganizeListeners.add(§ pars new ListenerRegistration<>(§ pars listener, executor)))
    )

    ;;;
     ; Adds a generic {@link TransactionReceivedInBlockListener} listener to the chain.
     ;;
    #_public
    (§ method void addTransactionReceivedListener(§ args TransactionReceivedInBlockListener listener))
    (§ block
        (§ call addTransactionReceivedListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;;
     ; Adds a generic {@link TransactionReceivedInBlockListener} listener to the chain.
     ;;
    #_public
    #_final
    (§ method void addTransactionReceivedListener(§ args Executor executor, TransactionReceivedInBlockListener listener))
    (§ block
        (§ call transactionReceivedListeners.add(§ pars new ListenerRegistration<>(§ pars listener, executor)))
    )

    ;;;
     ; Removes the given {@link NewBestBlockListener} from the chain.
     ;;
    #_public
    (§ method void removeNewBestBlockListener(§ args NewBestBlockListener listener))
    (§ block
        (§ call ListenerRegistration.removeFromList(§ pars listener, newBestBlockListeners))
    )

    ;;;
     ; Removes the given {@link ReorganizeListener} from the chain.
     ;;
    #_public
    (§ method void removeReorganizeListener(§ args ReorganizeListener listener))
    (§ block
        (§ call ListenerRegistration.removeFromList(§ pars listener, reorganizeListeners))
    )

    ;;;
     ; Removes the given {@link TransactionReceivedInBlockListener} from the chain.
     ;;
    #_public
    (§ method void removeTransactionReceivedListener(§ args TransactionReceivedInBlockListener listener))
    (§ block
        (§ call ListenerRegistration.removeFromList(§ pars listener, transactionReceivedListeners))
    )

    ;;;
     ; Returns the {@link BlockStore} the chain was constructed with.  You can use this to iterate over the chain.
     ;;
    #_public
    (§ method BlockStore getBlockStore(§ args ))
    (§ block
        (§ return blockStore)
    )

    ;;;
     ; Adds/updates the given {@link Block} with the block store.
     ; This version is used when the transactions have not been verified.
     ; @param storedPrev The {@link StoredBlock} which immediately precedes block.
     ; @param block The {@link Block} to add/update.
     ; @return the newly created {@link StoredBlock}
     ;;
    #_protected
    #_abstract
    (§ method StoredBlock addToBlockStore(§ args StoredBlock storedPrev, Block block))
        (§ throws BlockStoreException, VerificationException)

    ;;;
     ; Adds/updates the given {@link StoredBlock} with the block store.
     ; This version is used when the transactions have already been verified to properly spend txOutputChanges.
     ; @param storedPrev The {@link StoredBlock} which immediately precedes block.
     ; @param header The {@link StoredBlock} to add/update.
     ; @param txOutputChanges The total sum of all changes made by this block to the set of open transaction outputs
     ;                        (from a call to connectTransactions), if in fully verifying mode (null otherwise).
     ; @return the newly created {@link StoredBlock}
     ;;
    #_protected
    #_abstract
    (§ method StoredBlock addToBlockStore(§ args StoredBlock storedPrev, Block header, #_nilable TransactionOutputChanges txOutputChanges))
        (§ throws BlockStoreException, VerificationException)

    ;;;
     ; Rollback the block store to a given height.  This is currently only supported by {@link BlockChain} instances.
     ;
     ; @throws BlockStoreException
     ;             if the operation fails or is unsupported.
     ;;
    #_protected
    #_abstract
    (§ method void rollbackBlockStore(§ args int height))
        (§ throws BlockStoreException)

    ;;;
     ; Called before setting chain head in memory.
     ; Should write the new head to block store and then commit any database transactions
     ; that were started by disconnectTransactions/connectTransactions.
     ;;
    #_protected
    #_abstract
    (§ method void doSetChainHead(§ args StoredBlock chainHead))
        (§ throws BlockStoreException)

    ;;;
     ; Called if we (possibly) previously called disconnectTransaction/connectTransactions,
     ; but will not be calling preSetChainHead as a block failed verification.
     ; Can be used to abort database transactions that were started by
     ; disconnectTransactions/connectTransactions.
     ;;
    #_protected
    #_abstract
    (§ method void notSettingChainHead(§ args ))
        (§ throws BlockStoreException)

    ;;;
     ; For a standard BlockChain, this should return blockStore.get(hash),
     ; for a FullPrunedBlockChain blockStore.getOnceUndoableStoredBlock(hash)
     ;;
    #_protected
    #_abstract
    (§ method StoredBlock getStoredBlockInCurrentScope(§ args Sha256Hash hash))
        (§ throws BlockStoreException)

    ;;;
     ; Processes a received block and tries to add it to the chain.  If there's something wrong with the block an
     ; exception is thrown.  If the block is OK but cannot be connected to the chain at this time, returns false.
     ; If the block can be connected to the chain, returns true.
     ; Accessing block's transactions in another thread while this method runs may result in undefined behavior.
     ;;
    #_public
    (§ method boolean add(§ args Block block))
        (§ throws VerificationException, PrunedException)
    (§ block
        (§ try )
        (§ block
            (§ return add(§ pars block, true, nil, nil))
        )
        (§ catch (§ args BlockStoreException e))
        (§ block
            ;; TODO: Figure out a better way to propagate this exception to the user.
            (§ throw (§ new RuntimeException(§ pars e)))
        )
        (§ catch (§ args VerificationException e))
        (§ block
            (§ try )
            (§ block
                (§ call notSettingChainHead(§ pars ))
            )
            (§ catch (§ args BlockStoreException e1))
            (§ block
                (§ throw (§ new RuntimeException(§ pars e1)))
            )
            (§ throw (§ new VerificationException(§ pars "Could not verify block:\n" + block, e)))
        )
    )

    ;;;
     ; Processes a received block and tries to add it to the chain.  If there's something wrong with the block an
     ; exception is thrown.  If the block is OK but cannot be connected to the chain at this time, returns false.
     ; If the block can be connected to the chain, returns true.
     ;;
    #_public
    (§ method boolean add(§ args FilteredBlock block))
        (§ throws VerificationException, PrunedException)
    (§ block
        (§ try )
        (§ block
            ;; The block has a list of hashes of transactions that matched the Bloom filter, and a list of associated
            ;; Transaction objects.  There may be fewer Transaction objects than hashes, this is expected.  It can happen
            ;; in the case where we were already around to witness the initial broadcast, so we downloaded the
            ;; transaction and sent it to the wallet before this point (the wallet may have thrown it away if it was
            ;; a false positive, as expected in any Bloom filtering scheme).  The filteredTxn list here will usually
            ;; only be full of data when we are catching up to the head of the chain and thus haven't witnessed any
            ;; of the transactions.
            (§ return add(§ pars block.getBlockHeader(§ pars ), true, block.getTransactionHashes(§ pars ), block.getAssociatedTransactions(§ pars )))
        )
        (§ catch (§ args BlockStoreException e))
        (§ block
            ;; TODO: Figure out a better way to propagate this exception to the user.
            (§ throw (§ new RuntimeException(§ pars e)))
        )
        (§ catch (§ args VerificationException e))
        (§ block
            (§ try )
            (§ block
                (§ call notSettingChainHead(§ pars ))
            )
            (§ catch (§ args BlockStoreException e1))
            (§ block
                (§ throw (§ new RuntimeException(§ pars e1)))
            )
            (§ throw (§ new VerificationException(§ pars "Could not verify block " + block.getHash(§ pars ) + "\n" + block, e)))
        )
    )

    ;;;
     ; Whether or not we are maintaining a set of unspent outputs and are verifying all transactions.
     ; Also indicates that all calls to add() should provide a block containing transactions
     ;;
    #_protected
    #_abstract
    (§ method boolean shouldVerifyTransactions(§ args ))

    ;;;
     ; Connect each transaction in block.transactions, verifying them as we go and removing spent outputs
     ; If an error is encountered in a transaction, no changes should be made to the underlying BlockStore
     ; and a VerificationException should be thrown.
     ; Only called if shouldVerifyTransactions().
     ; @throws VerificationException if an attempt was made to spend an already-spent output, or if a transaction incorrectly solved an output script.
     ; @throws BlockStoreException if the block store had an underlying error.
     ; @return The full set of all changes made to the set of open transaction outputs.
     ;;
    #_protected
    #_abstract
    (§ method TransactionOutputChanges connectTransactions(§ args int height, Block block))
        (§ throws VerificationException, BlockStoreException)

    ;;;
     ; Load newBlock from BlockStore and connect its transactions, returning changes to the set of unspent transactions.
     ; If an error is encountered in a transaction, no changes should be made to the underlying BlockStore.
     ; Only called if shouldVerifyTransactions().
     ; @throws PrunedException if newBlock does not exist as a {@link StoredUndoableBlock} in the block store.
     ; @throws VerificationException if an attempt was made to spend an already-spent output, or if a transaction incorrectly solved an output script.
     ; @throws BlockStoreException if the block store had an underlying error or newBlock does not exist in the block store at all.
     ; @return The full set of all changes made to the set of open transaction outputs.
     ;;
    #_protected
    #_abstract
    (§ method TransactionOutputChanges connectTransactions(§ args StoredBlock newBlock))
        (§ throws VerificationException, BlockStoreException, PrunedException)

    ;; filteredTxHashList contains all transactions, filteredTxn just a subset
    #_private
    (§ method boolean add(§ args Block block, boolean tryConnecting, #_nilable List<Sha256Hash> filteredTxHashList, #_nilable Map<Sha256Hash, Transaction> filteredTxn))
        (§ throws BlockStoreException, VerificationException, PrunedException)
    (§ block
        ;; TODO: Use read/write locks to ensure that during chain download properties are still low latency.
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; Quick check for duplicates to avoid an expensive check further down (in findSplit).
            ;; This can happen a lot when connecting orphan transactions due to the dumb brute force algorithm we use.
            (§ if (§ expr block.equals(§ pars getChainHead(§ pars ).getHeader(§ pars ))))
            (§ block
                (§ return true)
            )
            (§ if (§ expr tryConnecting && orphanBlocks.containsKey(§ pars block.getHash(§ pars ))))
            (§ block
                (§ return false)
            )

            ;; If we want to verify transactions (i.e. we are running with full blocks), verify that block has transactions.
            (§ if (§ expr shouldVerifyTransactions(§ pars ) && block.transactions == nil))
            (§ block
                (§ throw (§ new VerificationException(§ pars "Got a block header while running in full-block mode")))
            )

            ;; Check for already-seen block, but only for full pruned mode, where the DB is
            ;; more likely able to handle these queries quickly.
            (§ if (§ expr shouldVerifyTransactions(§ pars ) && blockStore.get(§ pars block.getHash(§ pars )) != nil))
            (§ block
                (§ return true)
            )

            #_final
            (§ var StoredBlock storedPrev)
            #_final
            (§ var int height)
            #_final
            (§ var EnumSet<Block.VerifyFlag> flags)

            ;; Prove the block is internally valid: hash is lower than target, etc.  This only checks the block contents
            ;; if there is a tx sending or receiving coins using an address in one of our wallets.  And those transactions
            ;; are only lightly verified: presence in a valid connecting block is taken as proof of validity.  See the
            ;; article here for more details: https://bitcoinj.github.io/security-model
            (§ try )
            (§ block
                (§ call block.verifyHeader(§ pars ))
                (§ ass storedPrev = getStoredBlockInCurrentScope(§ pars block.getPrevBlockHash(§ pars )))
                (§ if (§ expr storedPrev != nil))
                (§ block
                    (§ ass height = storedPrev.getHeight(§ pars ) + 1)
                )
                (§ else )
                (§ block
                    (§ ass height = Block.BLOCK_HEIGHT_UNKNOWN)
                )
                (§ ass flags = params.getBlockVerificationFlags(§ pars block, versionTally, height))
                (§ if (§ expr shouldVerifyTransactions(§ pars )))
                (§ block
                    (§ call block.verifyTransactions(§ pars height, flags))
                )
            )
            (§ catch (§ args VerificationException e))
            (§ block
                (§ call log.error(§ pars "Failed to verify block: ", e))
                (§ call log.error(§ pars block.getHashAsString(§ pars )))
                (§ throw e)
            )

            ;; Try linking it to a place in the currently known blocks.

            (§ if (§ expr storedPrev == nil))
            (§ block
                ;; We can't find the previous block.  Probably we are still in the process of downloading the chain and
                ;; a block was solved whilst we were doing it.  We put it to one side and try to connect it later when we
                ;; have more blocks.
                (§ call Preconditions.checkState(§ pars tryConnecting, "bug in tryConnectingOrphans"))
                (§ call log.warn(§ pars "Block does not connect: {} prev {}", block.getHashAsString(§ pars ), block.getPrevBlockHash(§ pars )))
                (§ call orphanBlocks.put(§ pars block.getHash(§ pars ), new OrphanBlock(§ pars block, filteredTxHashList, filteredTxn)))
                (§ return false)
            )

            (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
            ;; It connects to somewhere on the chain.  Not necessarily the top of the best known chain.
            (§ call params.checkDifficultyTransitions(§ pars storedPrev, block, blockStore))
            (§ call connectBlock(§ pars block, storedPrev, shouldVerifyTransactions(§ pars ), filteredTxHashList, filteredTxn))

            (§ if (§ expr tryConnecting))
            (§ block
                (§ call tryConnectingOrphans(§ pars ))
            )

            (§ return true)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the hashes of the currently stored orphan blocks and then deletes them from this objects storage.
     ; Used by Peer when a filter exhaustion event has occurred and thus any orphan blocks that have been downloaded
     ; might be inaccurate/incomplete.
     ;;
    #_public
    (§ method Set<Sha256Hash> drainOrphanBlocks(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var Set<Sha256Hash> hashes = new HashSet<>(§ pars orphanBlocks.keySet(§ pars )))
            (§ call orphanBlocks.clear(§ pars ))
            (§ return hashes)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;; expensiveChecks enables checks that require looking at blocks further back in the chain
    ;; than the previous one when connecting (e.g. median timestamp check)
    ;; It could be exposed, but for now we just set it to shouldVerifyTransactions()
    #_private
    (§ method void connectBlock(§ args #_final Block block, StoredBlock storedPrev, boolean expensiveChecks, #_nilable #_final List<Sha256Hash> filteredTxHashList, #_nilable #_final Map<Sha256Hash, Transaction> filteredTxn))
        (§ throws BlockStoreException, VerificationException, PrunedException)
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ var boolean filtered = (§ expr filteredTxHashList != nil && filteredTxn != nil))
        ;; Check that we aren't connecting a block that fails a checkpoint check.
        (§ if (§ expr !params.passesCheckpoint(§ pars storedPrev.getHeight(§ pars ) + 1, block.getHash(§ pars ))))
        (§ block
            (§ throw (§ new VerificationException(§ pars "Block failed checkpoint lockin at " + (§ expr storedPrev.getHeight(§ pars ) + 1))))
        )
        (§ if (§ expr shouldVerifyTransactions(§ pars )))
        (§ block
            (§ call Preconditions.checkNotNull(§ pars block.transactions))
            (§ for (§ var Transaction tx) :for (§ expr block.transactions))
            (§ block
                (§ if (§ expr !tx.isFinal(§ pars storedPrev.getHeight(§ pars ) + 1, block.getTimeSeconds(§ pars ))))
                (§ block
                    (§ throw (§ new VerificationException(§ pars "Block contains non-final transaction")))
                )
            )
        )

        (§ var StoredBlock head = getChainHead(§ pars ))
        (§ if (§ expr storedPrev.equals(§ pars head)))
        (§ block
            (§ if (§ expr filtered && 0 < filteredTxn.size(§ pars )))
            (§ block
                (§ call log.debug(§ pars "Block {} connects to top of best chain with {} transaction(s) of which we were sent {}", block.getHashAsString(§ pars ), filteredTxHashList.size(§ pars ), filteredTxn.size(§ pars )))
                (§ for (§ var Sha256Hash hash) :for (§ expr filteredTxHashList))
                (§ block
                    (§ call log.debug(§ pars "  matched tx {}", hash))
                )
            )
            (§ if (§ expr expensiveChecks && block.getTimeSeconds(§ pars ) <= getMedianTimestampOfRecentBlocks(§ pars head, blockStore)))
            (§ block
                (§ throw (§ new VerificationException(§ pars "Block's timestamp is too early")))
            )

            ;; BIP 66 & 65: Enforce block version 3/4 once they are a supermajority of blocks.
            ;; NOTE: This requires 1,000 blocks since the last checkpoint (on main net, less on test) in order to be applied.
            ;; It is also limited to stopping addition of new v2/3 blocks to the tip of the chain.
            (§ if (§ expr block.getVersion(§ pars ) == Block.BLOCK_VERSION_BIP34 || block.getVersion(§ pars ) == Block.BLOCK_VERSION_BIP66))
            (§ block
                #_final
                (§ var Integer count = versionTally.getCountAtOrAbove(§ pars block.getVersion(§ pars ) + 1))
                (§ if (§ expr count != nil && params.getMajorityRejectBlockOutdated(§ pars ) <= count))
                (§ block
                    (§ throw new VerificationException.BlockVersionOutOfDate(§ pars block.getVersion(§ pars )))
                )
            )

            ;; This block connects to the best known block, it is a normal continuation of the system.
            (§ var TransactionOutputChanges txOutChanges = nil)
            (§ if (§ expr shouldVerifyTransactions(§ pars )))
            (§ block
                (§ ass txOutChanges = connectTransactions(§ pars storedPrev.getHeight(§ pars ) + 1, block))
            )
            (§ var StoredBlock newStoredBlock = addToBlockStore(§ pars storedPrev, (§ expr block.transactions == nil) ? block :else block.cloneAsHeader(§ pars ), txOutChanges))
            (§ call versionTally.add(§ pars block.getVersion(§ pars )))
            (§ call setChainHead(§ pars newStoredBlock))
            (§ call log.debug(§ pars "Chain is now {} blocks high, running listeners", newStoredBlock.getHeight(§ pars )))
            (§ call informListenersForNewBlock(§ pars block, NewBlockType.BEST_CHAIN, filteredTxHashList, filteredTxn, newStoredBlock))
        )
        (§ else )
        (§ block
            ;; This block connects to somewhere other than the top of the best known chain.  We treat these differently.
            ;;
            ;; Note that we send the transactions to the wallet FIRST, even if we're about to re-organize this block
            ;; to become the new best chain head.  This simplifies handling of the re-org in the Wallet class.
            (§ var StoredBlock newBlock = storedPrev.build(§ pars block))
            (§ var boolean haveNewBestChain = newBlock.moreWorkThan(§ pars head))
            (§ if (§ expr haveNewBestChain))
            (§ block
                (§ call log.info(§ pars "Block is causing a re-organize"))
            )
            (§ else )
            (§ block
                (§ var StoredBlock splitPoint = findSplit(§ pars newBlock, head, blockStore))
                (§ if (§ expr splitPoint != nil && splitPoint.equals(§ pars newBlock)))
                (§ block
                    ;; newStoredBlock is a part of the same chain, there's no fork.  This happens when we receive a block
                    ;; that we already saw and linked into the chain previously, which isn't the chain head.
                    ;; Re-processing it is confusing for the wallet so just skip.
                    (§ call log.warn(§ pars "Saw duplicated block in main chain at height {}: {}", newBlock.getHeight(§ pars ), newBlock.getHeader(§ pars ).getHash(§ pars )))
                    (§ return )
                )

                (§ if (§ expr splitPoint == nil))
                (§ block
                    ;; This should absolutely never happen.
                    ;; (lets not write the full block to disk to keep any bugs which allow this to happen from writing unreasonable amounts of data to disk)
                    (§ throw (§ new VerificationException(§ pars "Block forks the chain but splitPoint is nil")))
                )
                (§ else )
                (§ block
                    ;; We aren't actually spending any transactions (yet) because we are on a fork.
                    (§ call addToBlockStore(§ pars storedPrev, block))
                    (§ var int splitPointHeight = splitPoint.getHeight(§ pars ))
                    (§ var String splitPointHash = splitPoint.getHeader(§ pars ).getHashAsString(§ pars ))
                    (§ call log.info(§ pars "Block forks the chain at height {}/block {}, but it did not cause a reorganize:\n{}", splitPointHeight, splitPointHash, newBlock.getHeader(§ pars ).getHashAsString(§ pars )))
                )
            )

            ;; We may not have any transactions if we received only a header, which can happen during fast catchup.
            ;; If we do, send them to the wallet but state that they are on a side chain so it knows not to try and
            ;; spend them until they become activated.
            (§ if (§ expr block.transactions != nil || filtered))
            (§ block
                (§ call informListenersForNewBlock(§ pars block, NewBlockType.SIDE_CHAIN, filteredTxHashList, filteredTxn, newBlock))
            )

            (§ if (§ expr haveNewBestChain))
            (§ block
                (§ call handleNewBestChain(§ pars storedPrev, newBlock, block, expensiveChecks))
            )
        )
    )

    #_private
    (§ method void informListenersForNewBlock(§ args #_final Block block, #_final NewBlockType newBlockType, #_nilable #_final List<Sha256Hash> filteredTxHashList, #_nilable #_final Map<Sha256Hash, Transaction> filteredTxn, #_final StoredBlock newStoredBlock))
        (§ throws VerificationException)
    (§ block
        ;; Notify the listeners of the new block, so the depth and workDone of stored transactions can be updated
        ;; (in the case of the listener being a wallet).  Wallets need to know how deep each transaction is, so
        ;; coinbases aren't used before maturity.
        (§ var boolean first = true)
        (§ var Set<Sha256Hash> falsePositives = Sets.newHashSet(§ pars ))
        (§ if (§ expr filteredTxHashList != nil))
        (§ block
            (§ call falsePositives.addAll(§ pars filteredTxHashList))
        )

        (§ for (§ var #_final ListenerRegistration<TransactionReceivedInBlockListener> registration) :for (§ expr transactionReceivedListeners))
        (§ block
            (§ if (§ expr registration.executor == Threading.SAME_THREAD))
            (§ block
                (§ call informListenerForNewTransactions(§ pars block, newBlockType, filteredTxHashList, filteredTxn, newStoredBlock, first, registration.listener, falsePositives))
            )
            (§ else )
            (§ block
                ;; Listener wants to be run on some other thread, so marshal it across here.
                #_final
                (§ var boolean notFirst = !first)
                (§ call registration.executor.execute(§ pars (§ new Runnable(§ pars ))
                (§ anon
                    #_override
                    #_public
                    (§ method void run(§ args ))
                    (§ block
                        (§ try )
                        (§ block
                            ;; We can't do false-positive handling when executing on another thread.
                            (§ var Set<Sha256Hash> ignoredFalsePositives = Sets.newHashSet(§ pars ))
                            (§ call informListenerForNewTransactions(§ pars block, newBlockType, filteredTxHashList, filteredTxn, newStoredBlock, notFirst, registration.listener, ignoredFalsePositives))
                        )
                        (§ catch (§ args VerificationException e))
                        (§ block
                            (§ call log.error(§ pars "Block chain listener threw exception: ", e))
                            ;; Don't attempt to relay this back to the original peer thread if this was an async listener invocation.
                            ;; TODO: Make exception reporting a global feature and use it here.
                        )
                    )
                )))
            )
            (§ ass first = false)
        )

        (§ for (§ var #_final ListenerRegistration<NewBestBlockListener> registration) :for (§ expr newBestBlockListeners))
        (§ block
            (§ if (§ expr registration.executor == Threading.SAME_THREAD))
            (§ block
                (§ if (§ expr newBlockType == NewBlockType.BEST_CHAIN))
                (§ block
                    (§ call registration.listener.notifyNewBestBlock(§ pars newStoredBlock))
                )
            )
            (§ else )
            (§ block
                ;; Listener wants to be run on some other thread, so marshal it across here.
                (§ call registration.executor.execute(§ pars (§ new Runnable(§ pars ))
                (§ anon
                    #_override
                    #_public
                    (§ method void run(§ args ))
                    (§ block
                        (§ try )
                        (§ block
                            (§ if (§ expr newBlockType == NewBlockType.BEST_CHAIN))
                            (§ block
                                (§ call registration.listener.notifyNewBestBlock(§ pars newStoredBlock))
                            )
                        )
                        (§ catch (§ args VerificationException e))
                        (§ block
                            (§ call log.error(§ pars "Block chain listener threw exception: ", e))
                            ;; Don't attempt to relay this back to the original peer thread if this was an async listener invocation.
                            ;; TODO: Make exception reporting a global feature and use it here.
                        )
                    )
                )))
            )
            (§ ass first = false)
        )

        (§ call trackFalsePositives(§ pars falsePositives.size(§ pars )))
    )

    #_private
    #_static
    (§ method void informListenerForNewTransactions(§ args Block block, NewBlockType newBlockType, #_nilable List<Sha256Hash> filteredTxHashList, #_nilable Map<Sha256Hash, Transaction> filteredTxn, StoredBlock newStoredBlock, boolean first, TransactionReceivedInBlockListener listener, Set<Sha256Hash> falsePositives))
        (§ throws VerificationException)
    (§ block
        (§ if (§ expr block.transactions != nil))
        (§ block
            ;; If this is not the first wallet, ask for the transactions to be duplicated before being given
            ;; to the wallet when relevant.  This ensures that if we have two connected wallets and a tx that
            ;; is relevant to both of them, they don't end up accidentally sharing the same object (which can
            ;; result in temporary in-memory corruption during re-orgs).  See bug 257.  We only duplicate in
            ;; the case of multiple wallets to avoid an unnecessary efficiency hit in the common case.
            (§ call sendTransactionsToListener(§ pars newStoredBlock, newBlockType, listener, 0, block.transactions, !first, falsePositives))
        )
        (§ elseif (§ expr filteredTxHashList != nil))
        (§ block
            (§ call Preconditions.checkNotNull(§ pars filteredTxn))
            ;; We must send transactions to listeners in the order they appeared in the block - thus we iterate over the
            ;; set of hashes and call sendTransactionsToListener with individual txn when they have not already been
            ;; seen in loose broadcasts - otherwise notifyTransactionIsInBlock on the hash.
            (§ var int relativityOffset = 0)
            (§ for (§ var Sha256Hash hash) :for (§ expr filteredTxHashList))
            (§ block
                (§ var Transaction tx = filteredTxn.get(§ pars hash))
                (§ if (§ expr tx != nil))
                (§ block
                    (§ call sendTransactionsToListener(§ pars newStoredBlock, newBlockType, listener, relativityOffset, Collections.singletonList(§ pars tx), !first, falsePositives))
                )
                (§ elseif (§ expr listener.notifyTransactionIsInBlock(§ pars hash, newStoredBlock, newBlockType, relativityOffset)))
                (§ block
                    (§ call falsePositives.remove(§ pars hash))
                )
                (§ ass relativityOffset = relativityOffset + 1)
            )
        )
    )

    ;;;
     ; Gets the median timestamp of the last 11 blocks.
     ;;
    #_private
    #_static
    (§ method long getMedianTimestampOfRecentBlocks(§ args StoredBlock storedBlock, BlockStore store))
        (§ throws BlockStoreException)
    (§ block
        (§ var long[] timestamps = new long[11])
        (§ var int unused = 9)
        (§ ass timestamps[10] = storedBlock.getHeader(§ pars ).getTimeSeconds(§ pars ))
        (§ for (§ var ) :for (§ expr 0 <= unused && (§ ass storedBlock = storedBlock.getPrev(§ pars store)) != nil) :for (§ ass unused = unused - 1))
        (§ block
            (§ ass timestamps[unused] = storedBlock.getHeader(§ pars ).getTimeSeconds(§ pars ))
        )

        (§ call Arrays.sort(§ pars timestamps, unused + 1, 11))
        (§ return timestamps[unused + (§ expr 11 - unused) / 2])
    )

    ;;;
     ; Disconnect each transaction in the block (after reading it from the block store).
     ; Only called if shouldVerifyTransactions().
     ; @throws PrunedException if block does not exist as a {@link StoredUndoableBlock} in the block store.
     ; @throws BlockStoreException if the block store had an underlying error or block does not exist in the block store at all.
     ;;
    #_protected
    #_abstract
    (§ method void disconnectTransactions(§ args StoredBlock block))
        (§ throws PrunedException, BlockStoreException)

    ;;;
     ; Called as part of connecting a block when the new block results in a different chain having higher total work.
     ;
     ; if (shouldVerifyTransactions)
     ;     either newChainHead needs to be in the block store as a FullStoredBlock, or (block != null && block.transactions != null)
     ;;
    #_private
    (§ method void handleNewBestChain(§ args StoredBlock storedPrev, StoredBlock newChainHead, Block block, boolean expensiveChecks))
        (§ throws BlockStoreException, VerificationException, PrunedException)
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        ;; This chain has overtaken the one we currently believe is best.  Reorganize is required.
        ;;
        ;; Firstly, calculate the block at which the chain diverged.  We only need to examine the
        ;; chain from beyond this block to find differences.

        (§ var StoredBlock head = getChainHead(§ pars ))
        #_final
        (§ var StoredBlock splitPoint = findSplit(§ pars newChainHead, head, blockStore))
        (§ call log.info(§ pars "Re-organize after split at height {}", splitPoint.getHeight(§ pars )))
        (§ call log.info(§ pars "Old chain head: {}", head.getHeader(§ pars ).getHashAsString(§ pars )))
        (§ call log.info(§ pars "New chain head: {}", newChainHead.getHeader(§ pars ).getHashAsString(§ pars )))
        (§ call log.info(§ pars "Split at block: {}", splitPoint.getHeader(§ pars ).getHashAsString(§ pars )))

        ;; Then build a list of all blocks in the old part of the chain and the new part.
        #_final
        (§ var LinkedList<StoredBlock> oldBlocks = getPartialChain(§ pars head, splitPoint, blockStore))
        #_final
        (§ var LinkedList<StoredBlock> newBlocks = getPartialChain(§ pars newChainHead, splitPoint, blockStore))

        ;; Disconnect each transaction in the previous main chain that is no longer in the new main chain.
        (§ var StoredBlock storedNewHead = splitPoint)
        (§ if (§ expr shouldVerifyTransactions(§ pars )))
        (§ block
            (§ for (§ var StoredBlock oldBlock) :for (§ expr oldBlocks))
            (§ block
                (§ try )
                (§ block
                    (§ call disconnectTransactions(§ pars oldBlock))
                )
                (§ catch (§ args PrunedException e))
                (§ block
                    ;; We threw away the data we need to re-org this deep!  We need to go back to a peer with full
                    ;; block contents and ask them for the relevant data then rebuild the indexs.  Or we could just
                    ;; give up and ask the human operator to help get us unstuck (e.g. rescan from the genesis block).
                    ;; TODO: retry adding this block when we get a block with hash e.getHash()
                    (§ throw e)
                )
            )

            (§ var StoredBlock cursor)
            ;; Walk in ascending chronological order.
            (§ for (§ var Iterator<StoredBlock> it = newBlocks.descendingIterator(§ pars )) :for (§ expr it.hasNext(§ pars )) :for (§ expr ))
            (§ block
                (§ ass cursor = it.next(§ pars ))
                (§ var Block cursorBlock = cursor.getHeader(§ pars ))
                (§ if (§ expr expensiveChecks && cursorBlock.getTimeSeconds(§ pars ) <= getMedianTimestampOfRecentBlocks(§ pars cursor.getPrev(§ pars blockStore), blockStore)))
                (§ block
                    (§ throw (§ new VerificationException(§ pars "Block's timestamp is too early during reorg")))
                )
                (§ var TransactionOutputChanges txOutChanges)
                (§ if (§ expr cursor != newChainHead || block == nil))
                (§ block
                    (§ ass txOutChanges = connectTransactions(§ pars cursor))
                )
                (§ else )
                (§ block
                    (§ ass txOutChanges = connectTransactions(§ pars newChainHead.getHeight(§ pars ), block))
                )
                (§ ass storedNewHead = addToBlockStore(§ pars storedNewHead, cursorBlock.cloneAsHeader(§ pars ), txOutChanges))
            )
        )
        (§ else )
        (§ block
            ;; (Finally) write block to block store.
            (§ ass storedNewHead = addToBlockStore(§ pars storedPrev, newChainHead.getHeader(§ pars )))
        )

        ;; Now inform the listeners.  This is necessary so the set of currently active transactions (that we can spend)
        ;; can be updated to take into account the re-organize.  We might also have received new coins we didn't have
        ;; before and our previous spends might have been undone.
        (§ for (§ var #_final ListenerRegistration<ReorganizeListener> registration) :for (§ expr reorganizeListeners))
        (§ block
            (§ if (§ expr registration.executor == Threading.SAME_THREAD))
            (§ block
                ;; Short circuit the executor so we can propagate any exceptions.
                ;; TODO: Do we really need to do this or should it be irrelevant?
                (§ call registration.listener.reorganize(§ pars splitPoint, oldBlocks, newBlocks))
            )
            (§ else )
            (§ block
                (§ call registration.executor.execute(§ pars (§ new Runnable(§ pars ))
                (§ anon
                    #_override
                    #_public
                    (§ method void run(§ args ))
                    (§ block
                        (§ try )
                        (§ block
                            (§ call registration.listener.reorganize(§ pars splitPoint, oldBlocks, newBlocks))
                        )
                        (§ catch (§ args VerificationException e))
                        (§ block
                            (§ call log.error(§ pars "Block chain listener threw exception during reorg", e))
                        )
                    )
                )))
            )
        )

        ;; Update the pointer to the best known block.
        (§ call setChainHead(§ pars storedNewHead))
    )

    ;;;
     ; Returns the set of contiguous blocks between 'higher' and 'lower'.  Higher is included, lower is not.
     ;;
    #_private
    #_static
    (§ method LinkedList<StoredBlock> getPartialChain(§ args StoredBlock higher, StoredBlock lower, BlockStore store))
        (§ throws BlockStoreException)
    (§ block
        (§ call Preconditions.checkArgument(§ pars lower.getHeight(§ pars ) < higher.getHeight(§ pars ), "higher and lower are reversed"))
        (§ var LinkedList<StoredBlock> results = new LinkedList<>(§ pars ))
        (§ var StoredBlock cursor = higher)
        (§ while (§ expr true))
        (§ block
            (§ call results.add(§ pars cursor))
            (§ ass cursor = Preconditions.checkNotNull(§ pars cursor.getPrev(§ pars store), "Ran off the end of the chain"))
            (§ if (§ expr cursor.equals(§ pars lower)))
            (§ block
                (§ break )
            )
        )
        (§ return results)
    )

    ;;;
     ; Locates the point in the chain at which newStoredBlock and chainHead diverge.  Returns null if no split point was
     ; found (i.e. they are not part of the same chain).  Returns newChainHead or chainHead if they don't actually diverge
     ; but are part of the same chain.
     ;;
    #_private
    #_static
    (§ method StoredBlock findSplit(§ args StoredBlock newChainHead, StoredBlock oldChainHead, BlockStore store))
        (§ throws BlockStoreException)
    (§ block
        (§ var StoredBlock currentChainCursor = oldChainHead)
        (§ var StoredBlock newChainCursor = newChainHead)
        ;; Loop until we find the block both chains have in common.  Example:
        ;;
        ;;    A -> B -> C -> D
        ;;         \--> E -> F -> G
        ;;
        ;; findSplit will return block B.  oldChainHead = D and newChainHead = G.
        (§ while (§ expr !currentChainCursor.equals(§ pars newChainCursor)))
        (§ block
            (§ if (§ expr newChainCursor.getHeight(§ pars ) < currentChainCursor.getHeight(§ pars )))
            (§ block
                (§ ass currentChainCursor = currentChainCursor.getPrev(§ pars store))
                (§ call Preconditions.checkNotNull(§ pars currentChainCursor, "Attempt to follow an orphan chain"))
            )
            (§ else )
            (§ block
                (§ ass newChainCursor = newChainCursor.getPrev(§ pars store))
                (§ call Preconditions.checkNotNull(§ pars newChainCursor, "Attempt to follow an orphan chain"))
            )
        )
        (§ return currentChainCursor)
    )

    ;;;
     ; @return the height of the best known chain, convenience for <tt>getChainHead().getHeight()</tt>
     ;;
    #_public
    #_final
    (§ method int getBestChainHeight(§ args ))
    (§ block
        (§ return getChainHead(§ pars ).getHeight(§ pars ))
    )

    #_public
    (§ enum NewBlockType
        (§ item BEST_CHAIN)
        (§ item SIDE_CHAIN)
    )

    #_private
    #_static
    (§ method void sendTransactionsToListener(§ args StoredBlock block, NewBlockType blockType, TransactionReceivedInBlockListener listener, int relativityOffset, List<Transaction> transactions, boolean clone, Set<Sha256Hash> falsePositives))
        (§ throws VerificationException)
    (§ block
        (§ for (§ var Transaction tx) :for (§ expr transactions))
        (§ block
            (§ try )
            (§ block
                (§ call falsePositives.remove(§ pars tx.getHash(§ pars )))
                (§ if (§ expr clone))
                (§ block
                    (§ ass tx = tx.params.getDefaultSerializer(§ pars ).makeTransaction(§ pars tx.bitcoinSerialize(§ pars )))
                )
                (§ call listener.receiveFromBlock(§ pars tx, block, blockType, relativityOffset))
                (§ ass relativityOffset = relativityOffset + 1)
            )
            (§ catch (§ args ScriptException e))
            (§ block
                ;; We don't want scripts we don't understand to break the block chain so just note that this tx was
                ;; not scanned here and continue.
                (§ call log.warn(§ pars "Failed to parse a script: " + e))
            )
            (§ catch (§ args ProtocolException e))
            (§ block
                ;; Failed to duplicate tx, should never happen.
                (§ throw (§ new RuntimeException(§ pars e)))
            )
        )
    )

    #_protected
    (§ method void setChainHead(§ args StoredBlock chainHead))
        (§ throws BlockStoreException)
    (§ block
        (§ call doSetChainHead(§ pars chainHead))
        (§ sync chainHeadLock)
        (§ block
            (§ ass this.chainHead = chainHead)
        )
    )

    ;;;
     ; For each block in orphanBlocks, see if we can now fit it on top of the chain and if so, do so.
     ;;
    #_private
    (§ method void tryConnectingOrphans(§ args ))
        (§ throws VerificationException, BlockStoreException, PrunedException)
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        ;; For each block in our orphan list, try and fit it onto the head of the chain.  If we succeed remove it
        ;; from the list and keep going.  If we changed the head of the list at the end of the round try again until
        ;; we can't fit anything else on the top.
        ;;
        ;; This algorithm is kind of crappy, we should do a topo-sort then just connect them in order, but for small
        ;; numbers of orphan blocks it does OK.

        (§ var int blocksConnectedThisRound)
        (§ do )
        (§ block
            (§ ass blocksConnectedThisRound = 0)
            (§ var Iterator<OrphanBlock> iter = orphanBlocks.values(§ pars ).iterator(§ pars ))
            (§ while (§ expr iter.hasNext(§ pars )))
            (§ block
                (§ var OrphanBlock orphanBlock = iter.next(§ pars ))
                ;; Look up the blocks previous.
                (§ var StoredBlock prev = getStoredBlockInCurrentScope(§ pars orphanBlock.block.getPrevBlockHash(§ pars )))
                (§ if (§ expr prev == nil))
                (§ block
                    ;; This is still an unconnected/orphan block.
                    (§ call log.debug(§ pars "Orphan block {} is not connectable right now", orphanBlock.block.getHash(§ pars )))
                    (§ continue )
                )
                ;; Otherwise we can connect it now.
                ;; False here ensures we don't recurse infinitely downwards when connecting huge chains.
                (§ call log.info(§ pars "Connected orphan {}", orphanBlock.block.getHash(§ pars )))
                (§ call add(§ pars orphanBlock.block, false, orphanBlock.filteredTxHashes, orphanBlock.filteredTxn))
                (§ call iter.remove(§ pars ))
                (§ ass blocksConnectedThisRound = blocksConnectedThisRound + 1)
            )
            (§ if (§ expr 0 < blocksConnectedThisRound))
            (§ block
                (§ call log.info(§ pars "Connected {} orphan blocks.", blocksConnectedThisRound))
            )
        )
        (§ again (§ expr 0 < blocksConnectedThisRound))
    )

    ;;;
     ; Returns the block at the head of the current best chain.  This is the block which represents the greatest
     ; amount of cumulative work done.
     ;;
    #_public
    (§ method StoredBlock getChainHead(§ args ))
    (§ block
        (§ sync chainHeadLock)
        (§ block
            (§ return chainHead)
        )
    )

    ;;;
     ; An orphan block is one that does not connect to the chain anywhere (i.e. we can't find its parent, therefore
     ; it's an orphan).  Typically this occurs when we are downloading the chain and didn't reach the head yet, and/or
     ; if a block is solved whilst we are downloading.  It's possible that we see a small amount of orphan blocks which
     ; chain together, this method tries walking backwards through the known orphan blocks to find the bottom-most.
     ;
     ; @return from or one of from's parents, or null if "from" does not identify an orphan block
     ;;
    #_nilable
    #_public
    (§ method Block getOrphanRoot(§ args Sha256Hash from))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var OrphanBlock cursor = orphanBlocks.get(§ pars from))
            (§ if (§ expr cursor == nil))
            (§ block
                (§ return nil)
            )
            (§ var OrphanBlock tmp)
            (§ while (§ expr (§ ass tmp = orphanBlocks.get(§ pars cursor.block.getPrevBlockHash(§ pars ))) != nil))
            (§ block
                (§ ass cursor = tmp)
            )
            (§ return cursor.block)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;; Returns true if the given block is currently in the orphan blocks list. ;;
    #_public
    (§ method boolean isOrphan(§ args Sha256Hash block))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return orphanBlocks.containsKey(§ pars block))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns an estimate of when the given block will be reached, assuming a perfect 10 minute average for each
     ; block.  This is useful for turning transaction lock times into human readable times.  Note that a height in
     ; the past will still be estimated, even though the time of solving is actually known (we won't scan backwards
     ; through the chain to obtain the right answer).
     ;;
    #_public
    (§ method Date estimateBlockTime(§ args int height))
    (§ block
        (§ sync chainHeadLock)
        (§ block
            (§ var long offset = height - chainHead.getHeight(§ pars ))
            (§ var long headTime = chainHead.getHeader(§ pars ).getTimeSeconds(§ pars ))
            (§ var long estimated = (§ expr (§ expr headTime * 1000) + (§ expr 1000 * 60 * 10 * offset)))
            (§ return (§ new Date(§ pars estimated)))
        )
    )

    ;;;
     ; Returns a future that completes when the block chain has reached the given height.  Yields the
     ; {@link StoredBlock} of the block that reaches that height first.  The future completes on a peer thread.
     ;;
    #_public
    (§ method ListenableFuture<StoredBlock> getHeightFuture(§ args #_final int height))
    (§ block
        #_final
        (§ var SettableFuture<StoredBlock> result = SettableFuture.create(§ pars ))
        (§ call addNewBestBlockListener(§ pars Threading.SAME_THREAD, new NewBestBlockListener(§ pars )
        (§ anon
            #_override
            #_public
            (§ method void notifyNewBestBlock(§ args StoredBlock block))
                (§ throws VerificationException)
            (§ block
                (§ if (§ expr height <= block.getHeight(§ pars )))
                (§ block
                    (§ call removeNewBestBlockListener(§ pars this))
                    (§ call result.set(§ pars block))
                )
            )
        )))
        (§ return result)
    )

    ;;;
     ; The false positive rate is the average over all blockchain transactions of:
     ;
     ; - 1.0 if the transaction was false-positive (was irrelevant to all listeners)
     ; - 0.0 if the transaction was relevant or filtered out
     ;;
    #_public
    (§ method double getFalsePositiveRate(§ args ))
    (§ block
        (§ return falsePositiveRate)
    )

    ;;
     ; We completed handling of a filtered block.  Update false-positive estimate based
     ; on the total number of transactions in the original block.
     ;
     ; count includes filtered transactions, transactions that were passed in and were relevant
     ; and transactions that were false positives (i.e. includes all transactions in the block).
     ;;
    #_protected
    (§ method void trackFilteredTransactions(§ args int count))
    (§ block
        ;; Track non-false-positives in batch.  Each non-false-positive counts as 0.0 towards the estimate.
        ;;
        ;; This is slightly off because we are applying false positive tracking before non-FP tracking,
        ;; which counts FP as if they came at the beginning of the block.  Assuming uniform FP
        ;; spread in a block, this will somewhat underestimate the FP rate (5% for 1000 tx block).
        (§ var double alphaDecay = Math.pow(§ pars 1 - FP_ESTIMATOR_ALPHA, count))

        ;; new_rate = alpha_decay * new_rate
        (§ ass falsePositiveRate = alphaDecay * falsePositiveRate)

        (§ var double betaDecay = Math.pow(§ pars 1 - FP_ESTIMATOR_BETA, count))

        ;; trend = beta * (new_rate - old_rate) + beta_decay * trend
        (§ ass falsePositiveTrend = FP_ESTIMATOR_BETA * count * (§ expr falsePositiveRate - previousFalsePositiveRate) + betaDecay * falsePositiveTrend)

        ;; new_rate += alpha_decay * trend
        (§ ass falsePositiveRate = falsePositiveRate + (§ expr alphaDecay * falsePositiveTrend))

        ;; stash new_rate in old_rate
        (§ ass previousFalsePositiveRate = falsePositiveRate)
    )

    ;;;Irrelevant transactions were received.  Update false-positive estimate. ;;
    (§ method void trackFalsePositives(§ args int count))
    (§ block
        ;; Track false positives in batch by adding alpha to the false positive estimate once per count.
        ;; Each false positive counts as 1.0 towards the estimate.
        (§ ass falsePositiveRate = falsePositiveRate + (§ expr FP_ESTIMATOR_ALPHA * count))
        (§ if (§ expr 0 < count))
        (§ block
            (§ ass log.debug(§ pars "{} false positives, current rate = {} trend = {}", count, falsePositiveRate, falsePositiveTrend))
        )
    )

    ;;; Resets estimates of false positives.  Used when the filter is sent to the peer. ;;
    #_public
    (§ method void resetFalsePositiveEstimate(§ args ))
    (§ block
        (§ ass falsePositiveRate = 0)
        (§ ass falsePositiveTrend = 0)
        (§ ass previousFalsePositiveRate = 0)
    )

    #_protected
    (§ method VersionTally getVersionTally(§ args ))
    (§ block
        (§ return versionTally)
    )
)

#_(ns org.bitcoinj.core #_"Address"
    (:import [java.io IOException ObjectInputStream ObjectOutputStream])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.params Networks]
             [org.bitcoinj.script Script]))

;;;
 ; <p>A Bitcoin address looks like 1MsScoe2fTJoq4ZPdQgqyhgWeoNamYPevy and is derived from an elliptic curve public key
 ; plus a set of network parameters.  Not to be confused with a {@link PeerAddress} or {@link AddressMessage}
 ; which are about network (TCP) addresses.</p>
 ;
 ; <p>A standard address is built by taking the RIPE-MD160 hash of the public key bytes, with a version prefix and a
 ; checksum suffix, then encoding it textually as base58.  The version prefix is used to both denote the network for
 ; which the address is valid (see {@link NetworkParameters}, and also to indicate how the bytes inside the address
 ; should be interpreted.  Whilst almost all addresses today are hashes of public keys, another (currently unsupported
 ; type) can contain a hash of a script instead.</p>
 ;;
#_public
(§ class Address extends VersionedChecksummedBytes
    ;;;
     ; An address is a RIPEMD160 hash of a public key, therefore is always 160 bits or 20 bytes.
     ;;
    #_public
    #_static
    #_final
    (§ field int LENGTH = 20)

    #_private
    #_transient
    (§ field NetworkParameters params)

    ;;;
     ; Construct an address from parameters, the address version, and the hash160 form.  Example:
     ;
     ; <pre>new Address(MainNetParams.get(), NetworkParameters.getAddressHeader(), Hex.decode("4a22c3c4cbb31e4d03b15550636762bda0baf85a"));</pre>
     ;;
    #_public
    (§ constructor Address(§ args NetworkParameters params, int version, byte[] hash160))
        (§ throws WrongNetworkException)
    (§ block
        (§ super (§ pars version, hash160))

        (§ call Preconditions.checkNotNull(§ pars params))
        (§ call Preconditions.checkArgument(§ pars hash160.length == 20, "Addresses are 160-bit hashes, so you must provide 20 bytes"))
        (§ if (§ expr !isAcceptableVersion(§ pars params, version)))
        (§ block
            (§ throw (§ new WrongNetworkException(§ pars version, params.getAcceptableAddressCodes(§ pars ))))
        )
        (§ ass this.params = params)
    )

    ;;; Returns an Address that represents the given P2SH script hash. ;;
    #_public
    #_static
    (§ method Address fromP2SHHash(§ args NetworkParameters params, byte[] hash160))
    (§ block
        (§ try )
        (§ block
            (§ return (§ new Address(§ pars params, params.getP2SHHeader(§ pars ), hash160)))
        )
        (§ catch (§ args WrongNetworkException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
    )

    ;;; Returns an Address that represents the script hash extracted from the given scriptPubKey. ;;
    #_public
    #_static
    (§ method Address fromP2SHScript(§ args NetworkParameters params, Script scriptPubKey))
    (§ block
        (§ call Preconditions.checkArgument(§ pars scriptPubKey.isPayToScriptHash(§ pars ), "Not a P2SH script"))
        (§ return fromP2SHHash(§ pars params, scriptPubKey.getPubKeyHash(§ pars )))
    )

    ;;;
     ; Construct an address from its Base58 representation.
     ; @param params
     ;            The expected NetworkParameters or null if you don't want validation.
     ; @param base58
     ;            The textual form of the address, such as "17kzeh4N8g49GFvdDzSf8PjaPfyoD1MndL".
     ; @throws AddressFormatException
     ;             if the given base58 doesn't parse or the checksum is invalid
     ; @throws WrongNetworkException
     ;             if the given address is valid but for a different chain (e.g. testnet vs. mainnet)
     ;;
    #_public
    #_static
    (§ method Address fromBase58(§ args #_nilable NetworkParameters params, String base58))
        (§ throws AddressFormatException)
    (§ block
        (§ return (§ new Address(§ pars params, base58)))
    )

    ;;;
     ; Construct an address from parameters and the hash160 form.  Example:
     ;
     ; <pre>new Address(MainNetParams.get(), Hex.decode("4a22c3c4cbb31e4d03b15550636762bda0baf85a"));</pre>
     ;;
    #_public
    (§ constructor Address(§ args NetworkParameters params, byte[] hash160))
    (§ block
        (§ super (§ pars params.getAddressHeader(§ pars ), hash160))

        (§ call Preconditions.checkArgument(§ pars hash160.length == 20, "Addresses are 160-bit hashes, so you must provide 20 bytes"))
        (§ ass this.params = params)
    )

    ;;; @deprecated Use {@link #fromBase58(NetworkParameters, String)} ;;
    #_deprecated
    #_public
    (§ constructor Address(§ args #_nilable NetworkParameters params, String address))
        (§ throws AddressFormatException)
    (§ block
        (§ super (§ pars address))

        (§ if (§ expr params != nil))
        (§ block
            (§ if (§ expr !isAcceptableVersion(§ pars params, version)))
            (§ block
                (§ throw (§ new WrongNetworkException(§ pars version, params.getAcceptableAddressCodes(§ pars ))))
            )
            (§ ass this.params = params)
        )
        (§ else )
        (§ block
            (§ var NetworkParameters paramsFound = nil)
            (§ for (§ var NetworkParameters p) :for (§ expr Networks.get(§ pars )))
            (§ block
                (§ if (§ expr isAcceptableVersion(§ pars p, version)))
                (§ block
                    (§ ass paramsFound = p)
                    (§ break )
                )
            )
            (§ if (§ expr paramsFound == nil))
            (§ block
                (§ throw (§ new AddressFormatException(§ pars "No network found for " + address)))
            )

            (§ ass this.params = paramsFound)
        )
    )

    ;;; The (big endian) 20 byte hash that is the core of a Bitcoin address. ;;
    #_public
    (§ method byte[] getHash160(§ args ))
    (§ block
        (§ return bytes)
    )

    ;;;
     ; Returns true if this address is a Pay-To-Script-Hash (P2SH) address.
     ; See also https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki: Address Format for pay-to-script-hash
     ;;
    #_public
    (§ method boolean isP2SHAddress(§ args ))
    (§ block
        #_final
        (§ var NetworkParameters parameters = getParameters(§ pars ))
        (§ return (§ expr parameters != nil && this.version == parameters.p2shHeader))
    )

    ;;;
     ; Examines the version byte of the address and attempts to find a matching NetworkParameters.  If you aren't sure
     ; which network the address is intended for (e.g. it was provided by a user), you can use this to decide if it is
     ; compatible with the current wallet.  You should be able to handle a null response from this method.  Note that
     ; the parameters returned is not necessarily the same as the one the Address was created with.
     ;
     ; @return a NetworkParameters representing the network the address is intended for
     ;;
    #_public
    (§ method NetworkParameters getParameters(§ args ))
    (§ block
        (§ return params)
    )

    ;;;
     ; Given an address, examines the version byte and attempts to find a matching NetworkParameters.  If you aren't sure
     ; which network the address is intended for (e.g. it was provided by a user), you can use this to decide if it is
     ; compatible with the current wallet.
     ; @return a NetworkParameters of the address
     ; @throws AddressFormatException if the string wasn't of a known version
     ;;
    #_public
    #_static
    (§ method NetworkParameters getParametersFromAddress(§ args String address))
        (§ throws AddressFormatException)
    (§ block
        (§ try )
        (§ block
            (§ return Address.fromBase58(§ pars nil, address).getParameters(§ pars ))
        )
        (§ catch (§ args WrongNetworkException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
    )

    ;;;
     ; Check if a given address version is valid given the NetworkParameters.
     ;;
    #_private
    #_static
    (§ method boolean isAcceptableVersion(§ args NetworkParameters params, int version))
    (§ block
        (§ for (§ var int v) :for (§ expr params.getAcceptableAddressCodes(§ pars )))
        (§ block
            (§ if (§ expr version == v))
            (§ block
                (§ return true)
            )
        )
        (§ return false)
    )

    ;;;
     ; This implementation narrows the return type to <code>Address</code>.
     ;;
    #_override
    #_public
    (§ method Address clone(§ args ))
        (§ throws CloneNotSupportedException)
    (§ block
        (§ return (§ cast Address)super.clone(§ pars ))
    )

    ;; Java serialization

    #_private
    (§ method void writeObject(§ args ObjectOutputStream out))
        (§ throws IOException)
    (§ block
        (§ call out.defaultWriteObject(§ pars ))
        (§ call out.writeUTF(§ pars params.id))
    )

    #_private
    (§ method void readObject(§ args ObjectInputStream in))
        (§ throws IOException, ClassNotFoundException)
    (§ block
        (§ call in.defaultReadObject(§ pars ))
        (§ ass params = NetworkParameters.fromID(§ pars in.readUTF(§ pars )))
    )
)

#_(ns org.bitcoinj.core #_"AddressFormatException")

#_public
(§ class AddressFormatException extends IllegalArgumentException
    #_public
    (§ constructor AddressFormatException(§ args ))
    (§ block
        (§ super (§ pars ))
    )

    #_public
    (§ constructor AddressFormatException(§ args String message))
    (§ block
        (§ super (§ pars message))
    )
)

#_(ns org.bitcoinj.core #_"AddressMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Collections List]))

;;;
 ; <p>Represents an "addr" message on the P2P network, which contains broadcast IP addresses of other peers.  This is
 ; one of the ways peers can find each other without using the DNS or IRC discovery mechanisms.  However storing and
 ; using addr messages is not presently implemented.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class AddressMessage extends Message
    #_private
    #_static
    #_final
    (§ field long MAX_ADDRESSES = 1024)

    #_private
    (§ field List<PeerAddress> addresses)

    ;;;
     ; Contruct a new 'addr' message.
     ; @param params NetworkParameters object.
     ; @param offset The location of the first payload byte within the array.
     ; @param parseRetain Whether to retain the backing byte array for quick reserialization.
     ; If true and the backing byte array is invalidated due to modification of a field, then
     ; the cached bytes may be repopulated and retained if the message is serialized again in the future.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    (§ constructor AddressMessage(§ args NetworkParameters params, byte[] payload, int offset, MessageSerializer setSerializer, int length))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, offset, setSerializer, length))
    )

    ;;;
     ; Contruct a new 'addr' message.
     ; @param params NetworkParameters object.
     ; @param serializer The serializer to use for this block.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    (§ constructor AddressMessage(§ args NetworkParameters params, byte[] payload, MessageSerializer serializer, int length))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, 0, serializer, length))
    )

    (§ constructor AddressMessage(§ args NetworkParameters params, byte[] payload, int offset))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, offset, params.getDefaultSerializer(§ pars ), UNKNOWN_LENGTH))
    )

    (§ constructor AddressMessage(§ args NetworkParameters params, byte[] payload))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, 0, params.getDefaultSerializer(§ pars ), UNKNOWN_LENGTH))
    )

    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ var long numAddresses = readVarInt(§ pars ))
        ;; Guard against ultra large messages that will crash us.
        (§ if (§ expr MAX_ADDRESSES < numAddresses))
        (§ block
            (§ throw (§ new ProtocolException(§ pars "Address message too large.")))
        )
        (§ ass addresses = new ArrayList<>(§ pars (§ cast int)numAddresses))
        (§ for (§ var int i = 0) :for (§ expr i < numAddresses) :for (§ ass i = i + 1))
        (§ block
            (§ var PeerAddress addr = new PeerAddress(§ pars params, payload, cursor, protocolVersion, this, serializer))
            (§ call addresses.add(§ pars addr))
            (§ ass cursor = cursor + addr.getMessageSize(§ pars ))
        )
        (§ ass length = new VarInt(§ pars addresses.size(§ pars )).getSizeInBytes(§ pars ))
        ;; The 4 byte difference is the uint32 timestamp that was introduced in version 31402.
        (§ ass length = length + (§ expr addresses.size(§ pars ) * (§ expr 31402 < protocolVersion ? PeerAddress.MESSAGE_SIZE :else PeerAddress.MESSAGE_SIZE - 4)))
    )

    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ if (§ expr addresses != nil))
        (§ block
            (§ call stream.write(§ pars (§ new VarInt(§ pars addresses.size(§ pars ))).encode(§ pars )))
            (§ for (§ var PeerAddress addr) :for (§ expr addresses))
            (§ block
                (§ call addr.bitcoinSerialize(§ pars stream))
            )
        )
    )

    ;;;
     ; @return An unmodifiableList view of the backing List of addresses.  Addresses contained within the list may be safely modified.
     ;;
    #_public
    (§ method List<PeerAddress> getAddresses(§ args ))
    (§ block
        (§ return Collections.unmodifiableList(§ pars addresses))
    )

    #_public
    (§ method void addAddress(§ args PeerAddress address))
    (§ block
        (§ call unCache(§ pars ))
        (§ call address.setParent(§ pars this))
        (§ call addresses.add(§ pars address))
        (§ if (§ expr length == UNKNOWN_LENGTH))
        (§ block
            (§ call getMessageSize(§ pars ))
        )
        (§ else )
        (§ block
            (§ ass length = length + address.getMessageSize(§ pars ))
        )
    )

    #_public
    (§ method void removeAddress(§ args int index))
    (§ block
        (§ call unCache(§ pars ))
        (§ var PeerAddress address = addresses.remove(§ pars index))
        (§ call address.setParent(§ pars nil))
        (§ if (§ expr length == UNKNOWN_LENGTH))
        (§ block
            (§ call getMessageSize(§ pars ))
        )
        (§ else )
        (§ block
            (§ ass length = length - address.getMessageSize(§ pars ))
        )
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return "addr: " + Utils.SPACE_JOINER.join(§ pars addresses))
    )
)

#_(ns org.bitcoinj.core #_"AlertMessage"
    (:import [java.util Date HashSet Set]))

;;;
 ; Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 ; The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 ; an available upgrade or a serious network problem.  Alerts have an expiration time, data that specifies what
 ; set of software versions it matches and the ability to cancel them by broadcasting another type of alert.
 ;
 ; The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 ; log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 ; For example, you could treat it as an upgrade notification specific to your app.  Satoshi designed alerts to ensure
 ; that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 ; be purely peer-to-peer.  You don't have to use this of course, and indeed it often makes more sense not to.
 ;
 ; <p>Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class AlertMessage extends Message
    #_private
    (§ field byte[] content)
    #_private
    (§ field byte[] signature)

    ;; See the getters for documentation of what each field means.
    #_private
    (§ field long version = 1)
    #_private
    (§ field Date relayUntil)
    #_private
    (§ field Date expiration)
    #_private
    (§ field long id)
    #_private
    (§ field long cancel)
    #_private
    (§ field long minVer, maxVer)
    #_private
    (§ field long priority)
    #_private
    (§ field String comment, statusBar, reserved)

    ;; Chosen arbitrarily to avoid memory blowups.
    #_private
    #_static
    #_final
    (§ field long MAX_SET_SIZE = 100)

    #_public
    (§ constructor AlertMessage(§ args NetworkParameters params, byte[] payloadBytes))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payloadBytes, 0))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return "ALERT: " + getStatusBar(§ pars ))
    )

    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
        ;; Alerts are formatted in two levels.  The top level contains two byte arrays: a signature, and a serialized
        ;; data structure containing the actual alert data.
        (§ var int startPos = cursor)
        (§ ass content = readByteArray(§ pars ))
        (§ ass signature = readByteArray(§ pars ))
        ;; Now we need to parse out the contents of the embedded structure.  Rewind back to the start of the message.
        (§ ass cursor = startPos)
        (§ call readVarInt(§ pars )) ;; Skip the length field on the content array.
        ;; We're inside the embedded structure.
        (§ ass version = readUint32(§ pars ))
        ;; Read the timestamps.  Bitcoin uses seconds since the epoch.
        (§ ass relayUntil = new Date(§ pars readUint64(§ pars ).longValue(§ pars ) * 1000))
        (§ ass expiration = new Date(§ pars readUint64(§ pars ).longValue(§ pars ) * 1000))
        (§ ass id = readUint32(§ pars ))
        (§ ass cancel = readUint32(§ pars ))
        ;; Sets are serialized as <len><item><item><item>....
        (§ var long cancelSetSize = readVarInt(§ pars ))
        (§ if (§ expr cancelSetSize < 0 || MAX_SET_SIZE < cancelSetSize))
        (§ block
            (§ throw (§ new ProtocolException(§ pars "Bad cancel set size: " + cancelSetSize)))
        )
        ;; Using a hashset here is very inefficient given that this will normally be only one item.  But Java doesn't
        ;; make it easy to do better.  What we really want is just an array-backed set.
        (§ var Set<Long> cancelSet = new HashSet<>(§ pars (§ cast int)cancelSetSize))
        (§ for (§ var long i = 0) :for (§ expr i < cancelSetSize) :for (§ ass i = i + 1))
        (§ block
            (§ call cancelSet.add(§ pars readUint32(§ pars )))
        )
        (§ ass minVer = readUint32(§ pars ))
        (§ ass maxVer = readUint32(§ pars ))
        ;; Read the subver matching set.
        (§ var long subverSetSize = readVarInt(§ pars ))
        (§ if (§ expr subverSetSize < 0 || MAX_SET_SIZE < subverSetSize))
        (§ block
            (§ throw (§ new ProtocolException(§ pars "Bad subver set size: " + subverSetSize)))
        )
        (§ var Set<String> matchingSubVers = new HashSet<>(§ pars (§ cast int)subverSetSize))
        (§ for (§ var long i = 0) :for (§ expr i < subverSetSize) :for (§ ass i = i + 1))
        (§ block
            (§ call matchingSubVers.add(§ pars readStr(§ pars )))
        )
        (§ ass priority = readUint32(§ pars ))
        (§ ass comment = readStr(§ pars ))
        (§ ass statusBar = readStr(§ pars ))
        (§ ass reserved = readStr(§ pars ))

        (§ ass length = cursor - offset)
    )

    ;;;
     ; Returns true if the digital signature attached to the message verifies.  Don't do anything with the alert if it
     ; doesn't verify, because that would allow arbitrary attackers to spam your users.
     ;;
    #_public
    (§ method boolean isSignatureValid(§ args ))
    (§ block
        (§ return ECKey.verify(§ pars Sha256Hash.hashTwice(§ pars content), signature, params.getAlertSigningKey(§ pars )))
    )

    ;;;
     ; The time at which the alert should stop being broadcast across the network.  Note that you can still receive
     ; the alert after this time from other nodes if the alert still applies to them or to you.
     ;;
    #_public
    (§ method Date getRelayUntil(§ args ))
    (§ block
        (§ return relayUntil)
    )

    #_public
    (§ method void setRelayUntil(§ args Date relayUntil))
    (§ block
        (§ ass this.relayUntil = relayUntil)
    )

    ;;;
     ; The time at which the alert ceases to be relevant.  It should not be presented to the user or app administrator
     ; after this time.
     ;;
    #_public
    (§ method Date getExpiration(§ args ))
    (§ block
        (§ return expiration)
    )

    #_public
    (§ method void setExpiration(§ args Date expiration))
    (§ block
        (§ ass this.expiration = expiration)
    )

    ;;;
     ; The numeric identifier of this alert.  Each alert should have a unique ID, but the signer can choose any number.
     ; If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     ; @return uint32
     ;;
    #_public
    (§ method long getId(§ args ))
    (§ block
        (§ return id)
    )

    #_public
    (§ method void setId(§ args long id))
    (§ block
        (§ ass this.id = id)
    )

    ;;;
     ; A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     ; @return uint32
     ;;
    #_public
    (§ method long getCancel(§ args ))
    (§ block
        (§ return cancel)
    )

    #_public
    (§ method void setCancel(§ args long cancel))
    (§ block
        (§ ass this.cancel = cancel)
    )

    ;;;
     ; The inclusive lower bound on software versions that are considered for the purposes of this alert.  Bitcoin Core
     ; compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     ; alerts could use any version numbers.
     ; @return uint32
     ;;
    #_public
    (§ method long getMinVer(§ args ))
    (§ block
        (§ return minVer)
    )

    #_public
    (§ method void setMinVer(§ args long minVer))
    (§ block
        (§ ass this.minVer = minVer)
    )

    ;;;
     ; The inclusive upper bound on software versions considered for the purposes of this alert.  Bitcoin Core
     ; compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     ; alerts could use any version numbers.
     ;;
    #_public
    (§ method long getMaxVer(§ args ))
    (§ block
        (§ return maxVer)
    )

    #_public
    (§ method void setMaxVer(§ args long maxVer))
    (§ block
        (§ ass this.maxVer = maxVer)
    )

    ;;;
     ; Provides an integer ordering amongst simultaneously active alerts.
     ; @return uint32
     ;;
    #_public
    (§ method long getPriority(§ args ))
    (§ block
        (§ return priority)
    )

    #_public
    (§ method void setPriority(§ args long priority))
    (§ block
        (§ ass this.priority = priority)
    )

    ;;;
     ; This field is unused.  It is presumably intended for the author of the alert to provide a justification for it
     ; visible to protocol developers but not users.
     ;;
    #_public
    (§ method String getComment(§ args ))
    (§ block
        (§ return comment)
    )

    #_public
    (§ method void setComment(§ args String comment))
    (§ block
        (§ ass this.comment = comment)
    )

    ;;;
     ; A string that is intended to display in the status bar of Bitcoin Core's GUI client.  It contains the user-visible
     ; message.  English only.
     ;;
    #_public
    (§ method String getStatusBar(§ args ))
    (§ block
        (§ return statusBar)
    )

    #_public
    (§ method void setStatusBar(§ args String statusBar))
    (§ block
        (§ ass this.statusBar = statusBar)
    )

    ;;;
     ; This field is never used.
     ;;
    #_public
    (§ method String getReserved(§ args ))
    (§ block
        (§ return reserved)
    )

    #_public
    (§ method void setReserved(§ args String reserved))
    (§ block
        (§ ass this.reserved = reserved)
    )

    #_public
    (§ method long getVersion(§ args ))
    (§ block
        (§ return version)
    )
)

#_(ns org.bitcoinj.core #_"Base58"
    (:import [java.math BigInteger]
             [java.util Arrays]))

;;;
 ; Base58 is a way to encode Bitcoin addresses (or arbitrary data) as alphanumeric strings.
 ;
 ; Note that this is not the same base58 as used by Flickr, which you may find referenced around the Internet.
 ;
 ; You may want to consider working with {@link VersionedChecksummedBytes} instead, which
 ; adds support for testing the prefix and suffix bytes commonly found in addresses.
 ;
 ; Satoshi explains: why base-58 instead of standard base-64 encoding?
 ; <ul>
 ; <li>Don't want 0OIl characters that look the same in some fonts and
 ;     could be used to create visually identical looking account numbers.</li>
 ; <li>A string with non-alphanumeric characters is not as easily accepted as an account number.</li>
 ; <li>E-mail usually won't line-break if there's no punctuation to break at.</li>
 ; <li>Doubleclicking selects the whole number as one word if it's all alphanumeric.</li>
 ; </ul>
 ;
 ; However, note that the encoding/decoding runs in O(n&sup2;) time, so it is not useful for large data.
 ;
 ; The basic idea of the encoding is to treat the data bytes as a large number represented using
 ; base-256 digits, convert the number to be represented using base-58 digits, preserve the exact
 ; number of leading zeros (which are otherwise lost during the mathematical operations on the
 ; numbers), and finally represent the resulting base-58 digits as alphanumeric ASCII characters.
 ;;
#_public
(§ class Base58
    #_public
    #_static
    #_final
    (§ field char[] ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz".toCharArray(§ pars ))
    #_private
    #_static
    #_final
    (§ field char ENCODED_ZERO = ALPHABET[0])
    #_private
    #_static
    #_final
    (§ field int[] INDEXES = new int[128])
    #_static
    (§ block
        (§ call Arrays.fill(§ pars INDEXES, -1))
        (§ for (§ var int i = 0) :for (§ expr i < ALPHABET.length) :for (§ ass i = i + 1))
        (§ block
            (§ ass INDEXES[ALPHABET[i]] = i)
        )
    )

    ;;;
     ; Encodes the given bytes as a base58 string (no checksum is appended).
     ;
     ; @param input the bytes to encode
     ; @return the base58-encoded string
     ;;
    #_public
    #_static
    (§ method String encode(§ args byte[] input))
    (§ block
        (§ if (§ expr input.length == 0))
        (§ block
            (§ return "")
        )

        ;; Count leading zeros.
        (§ var int zeros = 0)
        (§ while (§ expr zeros < input.length && input[zeros] == 0))
        (§ block
            (§ ass zeros = zeros + 1)
        )

        ;; Convert base-256 digits to base-58 digits (plus conversion to ASCII characters).
        (§ ass input = Arrays.copyOf(§ pars input, input.length)) ;; since we modify it in-place
        (§ var char[] encoded = new char[input.length * 2]) ;; upper bound
        (§ var int outputStart = encoded.length)
        (§ for (§ var int inputStart = zeros) :for (§ expr inputStart < input.length) :for (§ expr ))
        (§ block
            (§ ass outputStart = outputStart - 1)
            (§ ass encoded[outputStart] = ALPHABET[divmod(§ pars input, inputStart, 256, 58)])
            (§ if (§ expr input[inputStart] == 0))
            (§ block
                (§ ass inputStart = inputStart + 1) ;; optimization - skip leading zeros
            )
        )
        ;; Preserve exactly as many leading encoded zeros in output as there were leading zeros in input.
        (§ while (§ expr outputStart < encoded.length && encoded[outputStart] == ENCODED_ZERO))
        (§ block
            (§ ass outputStart = outputStart + 1)
        )
        (§ for (§ var ) :for (§ expr 0 < zeros) :for (§ ass zeros = zeros - 1))
        (§ block
            (§ ass outputStart = outputStart - 1)
            (§ ass encoded[outputStart] = ENCODED_ZERO)
        )

        ;; Return encoded string (including encoded leading zeros).
        (§ return (§ new String(§ pars encoded, outputStart, encoded.length - outputStart)))
    )

    ;;;
     ; Decodes the given base58 string into the original data bytes.
     ;
     ; @param input the base58-encoded string to decode
     ; @return the decoded data bytes
     ; @throws AddressFormatException if the given string is not a valid base58 string
     ;;
    #_public
    #_static
    (§ method byte[] decode(§ args String input))
        (§ throws AddressFormatException)
    (§ block
        (§ if (§ expr input.length(§ pars ) == 0))
        (§ block
            (§ return new byte[0])
        )

        ;; Convert the base58-encoded ASCII chars to a base58 byte sequence (base58 digits).
        (§ var byte[] input58 = new byte[input.length(§ pars )])
        (§ for (§ var int i = 0) :for (§ expr i < input.length(§ pars )) :for (§ ass i = i + 1))
        (§ block
            (§ var char c = input.charAt(§ pars i))
            (§ var int digit = (§ expr c < 128) ? INDEXES[c] :else -1)
            (§ if (§ expr digit < 0))
            (§ block
                (§ throw (§ new AddressFormatException(§ pars "Illegal character " + c + " at position " + i)))
            )
            (§ ass input58[i] = (§ cast byte)digit)
        )
        ;; Count leading zeros.
        (§ var int zeros = 0)
        (§ while (§ expr zeros < input58.length && input58[zeros] == 0))
        (§ block
            (§ ass zeros = zeros + 1)
        )
        ;; Convert base-58 digits to base-256 digits.
        (§ var byte[] decoded = new byte[input.length(§ pars )])
        (§ var int outputStart = decoded.length)
        (§ for (§ var int inputStart = zeros) :for (§ expr inputStart < input58.length) :for (§ expr ))
        (§ block
            (§ ass outputStart = outputStart - 1)
            (§ ass decoded[outputStart] = divmod(§ pars input58, inputStart, 58, 256))
            (§ if (§ expr input58[inputStart] == 0))
            (§ block
                (§ ass inputStart = inputStart + 1) ;; optimization - skip leading zeros
            )
        )
        ;; Ignore extra leading zeroes that were added during the calculation.
        (§ while (§ expr outputStart < decoded.length && decoded[outputStart] == 0))
        (§ block
            (§ ass outputStart = outputStart + 1)
        )

        ;; Return decoded data (including original number of leading zeros).
        (§ return Arrays.copyOfRange(§ pars decoded, outputStart - zeros, decoded.length))
    )

    #_public
    #_static
    (§ method BigInteger decodeToBigInteger(§ args String input))
        (§ throws AddressFormatException)
    (§ block
        (§ return (§ new BigInteger(§ pars 1, decode(§ pars input))))
    )

    ;;;
     ; Decodes the given base58 string into the original data bytes, using the checksum in the
     ; last 4 bytes of the decoded data to verify that the rest are correct.  The checksum is
     ; removed from the returned data.
     ;
     ; @param input the base58-encoded string to decode (which should include the checksum)
     ; @throws AddressFormatException if the input is not base 58 or the checksum does not validate
     ;;
    #_public
    #_static
    (§ method byte[] decodeChecked(§ args String input))
        (§ throws AddressFormatException)
    (§ block
        (§ var byte[] decoded = decode(§ pars input))
        (§ if (§ expr decoded.length < 4))
        (§ block
            (§ throw (§ new AddressFormatException(§ pars "Input too short")))
        )
        (§ var byte[] data = Arrays.copyOfRange(§ pars decoded, 0, decoded.length - 4))
        (§ var byte[] checksum = Arrays.copyOfRange(§ pars decoded, decoded.length - 4, decoded.length))
        (§ var byte[] actualChecksum = Arrays.copyOfRange(§ pars Sha256Hash.hashTwice(§ pars data), 0, 4))
        (§ if (§ expr !Arrays.equals(§ pars checksum, actualChecksum)))
        (§ block
            (§ throw (§ new AddressFormatException(§ pars "Checksum does not validate")))
        )
        (§ return data)
    )

    ;;;
     ; Divides a number, represented as an array of bytes each containing a single digit
     ; in the specified base, by the given divisor.  The given number is modified in-place
     ; to contain the quotient, and the return value is the remainder.
     ;
     ; @param number the number to divide
     ; @param firstDigit the index within the array of the first non-zero digit
     ;        (this is used for optimization by skipping the leading zeros)
     ; @param base the base in which the number's digits are represented (up to 256)
     ; @param divisor the number to divide by (up to 256)
     ; @return the remainder of the division operation
     ;;
    #_private
    #_static
    (§ method byte divmod(§ args byte[] number, int firstDigit, int base, int divisor))
    (§ block
        ;; This is just long division which accounts for the base of the input digits.
        (§ var int remainder = 0)
        (§ for (§ var int i = firstDigit) :for (§ expr i < number.length) :for (§ ass i = i + 1))
        (§ block
            (§ var int digit = (§ cast int)number[i] & 0xff)
            (§ var int temp = remainder * base + digit)
            (§ ass number[i] = (§ cast byte)(§ expr temp / divisor))
            (§ ass remainder = temp % divisor)
        )
        (§ return (§ cast byte)remainder)
    )
)

#_(ns org.bitcoinj.core #_"BitcoinSerializer"
    (:import [java.io IOException OutputStream]
             [java.nio BufferUnderflowException ByteBuffer]
             [java.util HashMap Map])
    (:import [org.slf4j Logger LoggerFactory])
    (:import #_static [org.bitcoinj.core.Utils *]))

;;;
 ; <p>Methods to serialize and de-serialize messages to the Bitcoin network format as defined in
 ; <a href="https://en.bitcoin.it/wiki/Protocol_specification">the protocol specification</a>.</p>
 ;
 ; <p>To be able to serialize and deserialize new Message subclasses the following criteria needs to be met.</p>
 ;
 ; <ul>
 ; <li>The proper Class instance needs to be mapped to its message name in the names variable below.</li>
 ; <li>There needs to be a constructor matching: NetworkParameters params, byte[] payload.</li>
 ; <li>Message.bitcoinSerializeToStream() needs to be properly subclassed.</li>
 ; </ul>
 ;;
#_public
(§ class BitcoinSerializer extends MessageSerializer
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars BitcoinSerializer.class))
    #_private
    #_static
    #_final
    (§ field int COMMAND_LEN = 12)

    #_private
    #_static
    #_final
    (§ field Map<Class<? extends Message>, String> names = new HashMap<>(§ pars ))
    #_static
    (§ block
        (§ call names.put(§ pars VersionMessage.class, "version"))
        (§ call names.put(§ pars InventoryMessage.class, "inv"))
        (§ call names.put(§ pars Block.class, "block"))
        (§ call names.put(§ pars GetDataMessage.class, "getdata"))
        (§ call names.put(§ pars Transaction.class, "tx"))
        (§ call names.put(§ pars AddressMessage.class, "addr"))
        (§ call names.put(§ pars Ping.class, "ping"))
        (§ call names.put(§ pars Pong.class, "pong"))
        (§ call names.put(§ pars VersionAck.class, "verack"))
        (§ call names.put(§ pars GetBlocksMessage.class, "getblocks"))
        (§ call names.put(§ pars GetHeadersMessage.class, "getheaders"))
        (§ call names.put(§ pars GetAddrMessage.class, "getaddr"))
        (§ call names.put(§ pars HeadersMessage.class, "headers"))
        (§ call names.put(§ pars BloomFilter.class, "filterload"))
        (§ call names.put(§ pars FilteredBlock.class, "merkleblock"))
        (§ call names.put(§ pars NotFoundMessage.class, "notfound"))
        (§ call names.put(§ pars MemoryPoolMessage.class, "mempool"))
        (§ call names.put(§ pars RejectMessage.class, "reject"))
    )

    #_private
    #_final
    (§ field NetworkParameters params)
    #_private
    #_final
    (§ field boolean parseRetain)

    ;;;
     ; Constructs a BitcoinSerializer with the given behavior.
     ;
     ; @param params           networkParams used to create Messages instances and termining packetMagic
     ; @param parseRetain      retain the backing byte array of a message for fast reserialization
     ;;
    #_public
    (§ constructor BitcoinSerializer(§ args NetworkParameters params, boolean parseRetain))
    (§ block
        (§ ass this.params = params)
        (§ ass this.parseRetain = parseRetain)
    )

    ;;;
     ; Writes message to to the output stream.
     ;;
    #_override
    #_public
    (§ method void serialize(§ args String name, byte[] message, OutputStream out))
        (§ throws IOException)
    (§ block
        (§ var byte[] header = new byte[4 + COMMAND_LEN + 4 + 4]) ;; checksum
        (§ call uint32ToByteArrayBE(§ pars params.getPacketMagic(§ pars ), header, 0))

        ;; The header array is initialized to zero by Java so we don't have to worry
        ;; about NULL terminating the string here.
        (§ for (§ var int i = 0) :for (§ expr i < name.length(§ pars ) && i < COMMAND_LEN) :for (§ ass i = i + 1))
        (§ block
            (§ ass header[4 + i] = (§ cast byte)(§ expr name.codePointAt(§ pars i) & 0xff))
        )

        (§ call Utils.uint32ToByteArrayLE(§ pars message.length, header, 4 + COMMAND_LEN))

        (§ var byte[] hash = Sha256Hash.hashTwice(§ pars message))
        (§ call System.arraycopy(§ pars hash, 0, header, 4 + COMMAND_LEN + 4, 4))
        (§ call out.write(§ pars header))
        (§ call out.write(§ pars message))

        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ call log.debug(§ pars "Sending {} message: {}", name, HEX.encode(§ pars header) + HEX.encode(§ pars message)))
        )
    )

    ;;;
     ; Writes message to to the output stream.
     ;;
    #_override
    #_public
    (§ method void serialize(§ args Message message, OutputStream out))
        (§ throws IOException)
    (§ block
        (§ var String name = names.get(§ pars message.getClass(§ pars )))
        (§ if (§ expr name == nil))
        (§ block
            (§ throw (§ new Error(§ pars "BitcoinSerializer doesn't currently know how to serialize " + message.getClass(§ pars ))))
        )

        (§ call serialize(§ pars name, message.bitcoinSerialize(§ pars ), out))
    )

    ;;;
     ; Reads a message from the given ByteBuffer and returns it.
     ;;
    #_override
    #_public
    (§ method Message deserialize(§ args ByteBuffer in))
        (§ throws ProtocolException, IOException)
    (§ block
        ;; A Bitcoin protocol message has the following format:
        ;;
        ;;   - 4 byte magic number: 0xfabfb5da for the testnet or
        ;;                          0xf9beb4d9 for production
        ;;   - 12 byte command in ASCII
        ;;   - 4 byte payload size
        ;;   - 4 byte checksum
        ;;   - Payload data
        ;;
        ;; The checksum is the first 4 bytes of a SHA256 hash of the message payload. It isn't
        ;; present for all messages, notably, the first one on a connection.
        ;;
        ;; Bitcoin Core ignores garbage before the magic header bytes. We have to do the same because
        ;; sometimes it sends us stuff that isn't part of any message.
        (§ call seekPastMagicBytes(§ pars in))
        (§ var BitcoinPacketHeader header = new BitcoinPacketHeader(§ pars in))
        ;; Now try to read the whole message.
        (§ return deserializePayload(§ pars header, in))
    )

    ;;;
     ; Deserializes only the header in case packet meta data is needed before decoding
     ; the payload.  This method assumes you have already called seekPastMagicBytes().
     ;;
    #_override
    #_public
    (§ method BitcoinPacketHeader deserializeHeader(§ args ByteBuffer in))
        (§ throws ProtocolException, IOException)
    (§ block
        (§ return (§ new BitcoinPacketHeader(§ pars in)))
    )

    ;;;
     ; Deserialize payload only.  You must provide a header, typically obtained by calling
     ; {@link BitcoinSerializer#deserializeHeader}.
     ;;
    #_override
    #_public
    (§ method Message deserializePayload(§ args BitcoinPacketHeader header, ByteBuffer in))
        (§ throws ProtocolException, BufferUnderflowException)
    (§ block
        (§ var byte[] payloadBytes = new byte[header.size])
        (§ call in.get(§ pars payloadBytes, 0, header.size))

        ;; Verify the checksum.
        (§ var byte[] hash)
        (§ ass hash = Sha256Hash.hashTwice(§ pars payloadBytes))
        (§ if (§ expr header.checksum[0] != hash[0] || header.checksum[1] != hash[1] || header.checksum[2] != hash[2] || header.checksum[3] != hash[3]))
        (§ block
            (§ throw (§ new ProtocolException(§ pars "Checksum failed to verify, actual " + HEX.encode(§ pars hash) + " vs " + HEX.encode(§ pars header.checksum))))
        )

        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ call log.debug(§ pars "Received {} byte '{}' message: {}", header.size, header.command, HEX.encode(§ pars payloadBytes)))
        )

        (§ try )
        (§ block
            (§ return makeMessage(§ pars header.command, header.size, payloadBytes, hash, header.checksum))
        )
        (§ catch (§ args Exception e))
        (§ block
            (§ throw (§ new ProtocolException(§ pars "Error deserializing message " + HEX.encode(§ pars payloadBytes) + "\n", e)))
        )
    )

    #_private
    (§ method Message makeMessage(§ args String command, int length, byte[] payloadBytes, byte[] hash, byte[] checksum))
        (§ throws ProtocolException)
    (§ block
        ;; We use an if ladder rather than reflection because reflection is very slow on Android.
        (§ if (§ expr command.equals(§ pars "version")))
        (§ block
            (§ return (§ new VersionMessage(§ pars params, payloadBytes)))
        )
        (§ if (§ expr command.equals(§ pars "inv")))
        (§ block
            (§ return makeInventoryMessage(§ pars payloadBytes, length))
        )
        (§ if (§ expr command.equals(§ pars "block")))
        (§ block
            (§ return makeBlock(§ pars payloadBytes, length))
        )
        (§ if (§ expr command.equals(§ pars "merkleblock")))
        (§ block
            (§ return makeFilteredBlock(§ pars payloadBytes))
        )
        (§ if (§ expr command.equals(§ pars "getdata")))
        (§ block
            (§ return (§ new GetDataMessage(§ pars params, payloadBytes, this, length)))
        )
        (§ if (§ expr command.equals(§ pars "getblocks")))
        (§ block
            (§ return (§ new GetBlocksMessage(§ pars params, payloadBytes)))
        )
        (§ if (§ expr command.equals(§ pars "getheaders")))
        (§ block
            (§ return (§ new GetHeadersMessage(§ pars params, payloadBytes)))
        )
        (§ if (§ expr command.equals(§ pars "tx")))
        (§ block
            (§ return makeTransaction(§ pars payloadBytes, 0, length, hash))
        )
        (§ if (§ expr command.equals(§ pars "addr")))
        (§ block
            (§ return makeAddressMessage(§ pars payloadBytes, length))
        )
        (§ if (§ expr command.equals(§ pars "ping")))
        (§ block
            (§ return (§ new Ping(§ pars params, payloadBytes)))
        )
        (§ if (§ expr command.equals(§ pars "pong")))
        (§ block
            (§ return (§ new Pong(§ pars params, payloadBytes)))
        )
        (§ if (§ expr command.equals(§ pars "verack")))
        (§ block
            (§ return (§ new VersionAck(§ pars params, payloadBytes)))
        )
        (§ if (§ expr command.equals(§ pars "headers")))
        (§ block
            (§ return (§ new HeadersMessage(§ pars params, payloadBytes)))
        )
        (§ if (§ expr command.equals(§ pars "alert")))
        (§ block
            (§ return makeAlertMessage(§ pars payloadBytes))
        )
        (§ if (§ expr command.equals(§ pars "filterload")))
        (§ block
            (§ return makeBloomFilter(§ pars payloadBytes))
        )
        (§ if (§ expr command.equals(§ pars "notfound")))
        (§ block
            (§ return (§ new NotFoundMessage(§ pars params, payloadBytes)))
        )
        (§ if (§ expr command.equals(§ pars "mempool")))
        (§ block
            (§ return (§ new MemoryPoolMessage(§ pars )))
        )
        (§ if (§ expr command.equals(§ pars "reject")))
        (§ block
            (§ return (§ new RejectMessage(§ pars params, payloadBytes)))
        )
        (§ call log.warn(§ pars "No support for deserializing message with name {}", command))
        (§ return (§ new UnknownMessage(§ pars params, command, payloadBytes)))
    )

    ;;;
     ; Get the network parameters for this serializer.
     ;;
    #_public
    (§ method NetworkParameters getParameters(§ args ))
    (§ block
        (§ return params)
    )

    ;;;
     ; Make an address message from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method AddressMessage makeAddressMessage(§ args byte[] payloadBytes, int length))
        (§ throws ProtocolException)
    (§ block
        (§ return (§ new AddressMessage(§ pars params, payloadBytes, this, length)))
    )

    ;;;
     ; Make an alert message from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method Message makeAlertMessage(§ args byte[] payloadBytes))
        (§ throws ProtocolException)
    (§ block
        (§ return (§ new AlertMessage(§ pars params, payloadBytes)))
    )

    ;;;
     ; Make a block from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method Block makeBlock(§ args #_final byte[] payloadBytes, #_final int offset, #_final int length))
        (§ throws ProtocolException)
    (§ block
        (§ return (§ new Block(§ pars params, payloadBytes, offset, this, length)))
    )

    ;;;
     ; Make an filter message from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method Message makeBloomFilter(§ args byte[] payloadBytes))
        (§ throws ProtocolException)
    (§ block
        (§ return (§ new BloomFilter(§ pars params, payloadBytes)))
    )

    ;;;
     ; Make a filtered block from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method FilteredBlock makeFilteredBlock(§ args byte[] payloadBytes))
        (§ throws ProtocolException)
    (§ block
        (§ return (§ new FilteredBlock(§ pars params, payloadBytes)))
    )

    ;;;
     ; Make an inventory message from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method InventoryMessage makeInventoryMessage(§ args byte[] payloadBytes, int length))
        (§ throws ProtocolException)
    (§ block
        (§ return (§ new InventoryMessage(§ pars params, payloadBytes, this, length)))
    )

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method Transaction makeTransaction(§ args byte[] payloadBytes, int offset, int length, byte[] hash))
        (§ throws ProtocolException)
    (§ block
        (§ var Transaction tx = new Transaction(§ pars params, payloadBytes, offset, nil, this, length))
        (§ if (§ expr hash != nil))
        (§ block
            (§ call tx.setHash(§ pars Sha256Hash.wrapReversed(§ pars hash)))
        )
        (§ return tx)
    )

    #_override
    #_public
    (§ method void seekPastMagicBytes(§ args ByteBuffer in))
        (§ throws BufferUnderflowException)
    (§ block
        (§ var int magicCursor = 3) ;; Which byte of the magic we're looking for currently.
        (§ while (§ expr true))
        (§ block
            (§ var byte b = in.get(§ pars ))
            ;; We're looking for a run of bytes that is the same as the packet magic but we want to ignore partial
            ;; magics that aren't complete.  So we keep track of where we're up to with magicCursor.
            (§ var byte expectedByte = (§ cast byte)(§ expr 0xff & params.getPacketMagic(§ pars ) >>> (§ expr magicCursor << 3)))
            (§ if (§ expr b == expectedByte))
            (§ block
                (§ ass magicCursor = magicCursor - 1)
                (§ if (§ expr magicCursor < 0))
                (§ block
                    (§ return ) ;; We found the magic sequence.
                )
            )
            (§ else )
            (§ block
                (§ ass magicCursor = 3)
            )
        )
    )

    ;;;
     ; Whether the serializer will produce cached mode Messages.
     ;;
    #_override
    #_public
    (§ method boolean isParseRetainMode(§ args ))
    (§ block
        (§ return parseRetain)
    )

    #_public
    #_static
    (§ class BitcoinPacketHeader
        ;;; The largest number of bytes that a header can represent. ;;
        #_public
        #_static
        #_final
        (§ field int HEADER_LENGTH = COMMAND_LEN + 4 + 4)

        #_public
        #_final
        (§ field byte[] header)
        #_public
        #_final
        (§ field String command)
        #_public
        #_final
        (§ field int size)
        #_public
        #_final
        (§ field byte[] checksum)

        #_public
        (§ constructor BitcoinPacketHeader(§ args ByteBuffer in))
            (§ throws ProtocolException, BufferUnderflowException)
        (§ block
            (§ ass header = new byte[HEADER_LENGTH])
            (§ call in.get(§ pars header, 0, header.length))

            (§ var int cursor = 0)

            ;; The command is a NULL terminated string, unless the command fills all twelve bytes
            ;; in which case the termination is implicit.
            (§ while (§ expr header[cursor] != 0 && cursor < COMMAND_LEN))
            (§ block
                (§ ass cursor = cursor + 1)
            )
            (§ var byte[] commandBytes = new byte[cursor])
            (§ call System.arraycopy(§ pars header, 0, commandBytes, 0, cursor))
            (§ ass command = Utils.toString(§ pars commandBytes, "US-ASCII"))
            (§ ass cursor = COMMAND_LEN)

            (§ ass size = (§ cast int)readUint32(§ pars header, cursor))
            (§ ass cursor = cursor + 4)

            (§ if (§ expr Message.MAX_SIZE < size || size < 0))
            (§ block
                (§ throw (§ new ProtocolException(§ pars "Message size too large: " + size)))
            )

            ;; Old clients don't send the checksum.
            (§ ass checksum = new byte[4])
            ;; Note that the size read above includes the checksum bytes.
            (§ call System.arraycopy(§ pars header, cursor, checksum, 0, 4))
            (§ ass cursor = cursor + 4)
        )
    )
)

#_(ns org.bitcoinj.core #_"Block"
    (:import [java.io *]
             [java.math *]
             [java.util *])
    (:import [com.google.common.annotations *]
             [com.google.common.base *]
             [com.google.common.collect *]
             [org.slf4j *])
   (:require [org.bitcoinj.script *]
             #_static [org.bitcoinj.core.Coin *]
             #_static [org.bitcoinj.core.Sha256Hash *]))

;;;
 ; <p>A block is a group of transactions, and is one of the fundamental data structures of the Bitcoin system.
 ; It records a set of {@link Transaction}s together with some data that links it into a place in the global block chain,
 ; and proves that a difficult calculation was done over its contents.
 ; See <a href="http://www.bitcoin.org/bitcoin.pdf">the Bitcoin technical paper</a> for more detail on blocks.
 ;
 ; <p>To get a block, you can either build one from the raw bytes you can get from another implementation, or request one
 ; specifically using {@link Peer#getBlock(Sha256Hash)}, or grab one from a downloaded {@link BlockChain}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class Block extends Message
    ;;;
     ; Flags used to control which elements of block validation are done on received blocks.
     ;;
    #_public
    (§ enum VerifyFlag
        ;;; Check that block height is in coinbase transaction (BIP 34). ;;
        (§ item HEIGHT_IN_COINBASE)
    )

    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars Block.class))

    ;;; How many bytes are required to represent a block header WITHOUT the trailing 00 length byte. ;;
    #_public
    #_static
    #_final
    (§ field int HEADER_SIZE = 80)

    #_static
    #_final
    (§ field long ALLOWED_TIME_DRIFT = 2 * 60 * 60) ;; Same value as Bitcoin Core.

    ;;;
     ; A constant shared by the entire network: how large in bytes a block is allowed to be.  One day we may have to
     ; upgrade everyone to change this, so Bitcoin can continue to grow.  For now it exists as an anti-DoS measure to
     ; avoid somebody creating a titanically huge but valid block and forcing everyone to download/store it forever.
     ;;
    #_public
    #_static
    #_final
    (§ field int MAX_BLOCK_SIZE = 1 * 1000 * 1000)
    ;;;
     ; A "sigop" is a signature verification operation.  Because they're expensive, we also impose a separate limit on
     ; the number in a block to prevent somebody mining a huge block that has way more sigops than normal, so is very
     ; expensive/slow to verify.
     ;;
    #_public
    #_static
    #_final
    (§ field int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE / 50)

    ;;; A value for difficultyTarget (nBits) that allows half of all possible hash solutions.  Used in unit testing. ;;
    #_public
    #_static
    #_final
    (§ field long EASIEST_DIFFICULTY_TARGET = 0x207fffff)

    ;;; Value to use if the block height is unknown. ;;
    #_public
    #_static
    #_final
    (§ field int BLOCK_HEIGHT_UNKNOWN = -1)
    ;;; Height of the first block. ;;
    #_public
    #_static
    #_final
    (§ field int BLOCK_HEIGHT_GENESIS = 0)

    #_public
    #_static
    #_final
    (§ field long BLOCK_VERSION_GENESIS = 1)
    ;;; Block version introduced in BIP 34: Height in coinbase. ;;
    #_public
    #_static
    #_final
    (§ field long BLOCK_VERSION_BIP34 = 2)
    ;;; Block version introduced in BIP 66: Strict DER signatures. ;;
    #_public
    #_static
    #_final
    (§ field long BLOCK_VERSION_BIP66 = 3)
    ;;; Block version introduced in BIP 65: OP_CHECKLOCKTIMEVERIFY ;;
    #_public
    #_static
    #_final
    (§ field long BLOCK_VERSION_BIP65 = 4)

    ;; Fields defined as part of the protocol format.
    #_private
    (§ field long version)
    #_private
    (§ field Sha256Hash prevBlockHash)
    #_private
    (§ field Sha256Hash merkleRoot)
    #_private
    (§ field long time)
    #_private
    (§ field long difficultyTarget) ;; "nBits"
    #_private
    (§ field long nonce)

    ;; TODO: Get rid of all the direct accesses to this field.  It's a long-since unnecessary holdover from the Dalvik days.
    ;;; If null, it means this object holds only the headers. ;;
    #_nilable
    (§ field List<Transaction> transactions)

    ;;; Stores the hash of the block.  If null, getHash() will recalculate it. ;;
    #_private
    (§ field Sha256Hash hash)

    #_protected
    (§ field boolean headerBytesValid)
    #_protected
    (§ field boolean transactionBytesValid)

    ;; Blocks can be encoded in a way that will use more bytes than is optimal (due to VarInts having multiple encodings).
    ;; MAX_BLOCK_SIZE must be compared to the optimal encoding, not the actual encoding, so when parsing, we keep track
    ;; of the size of the ideal encoding in addition to the actual message size (which Message needs).
    #_protected
    (§ field int optimalEncodingMessageSize)

    ;;; Special case constructor, used for the genesis node, cloneAsHeader and unit tests. ;;
    (§ constructor Block(§ args NetworkParameters params, long setVersion))
    (§ block
        (§ super (§ pars params))

        ;; Set up a few basic things.  We are not complete after this though.
        (§ ass version = setVersion)
        (§ ass difficultyTarget = 0x1d07fff8)
        (§ ass time = System.currentTimeMillis(§ pars ) / 1000)
        (§ ass prevBlockHash = Sha256Hash.ZERO_HASH)

        (§ ass length = HEADER_SIZE)
    )

    ;;;
     ; Constructs a block object from the Bitcoin wire format.
     ; @deprecated Use {@link BitcoinSerializer#makeBlock(byte[])} instead.
     ;;
    #_deprecated
    #_public
    (§ constructor Block(§ args NetworkParameters params, byte[] payloadBytes))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payloadBytes, 0, params.getDefaultSerializer(§ pars ), payloadBytes.length))
    )

    ;;;
     ; Construct a block object from the Bitcoin wire format.
     ; @param params NetworkParameters object.
     ; @param payloadBytes The payload to extract the block from.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor Block(§ args NetworkParameters params, byte[] payloadBytes, MessageSerializer serializer, int length))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payloadBytes, 0, serializer, length))
    )

    ;;;
     ; Construct a block object from the Bitcoin wire format.
     ; @param params NetworkParameters object.
     ; @param payloadBytes The payload to extract the block from.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor Block(§ args NetworkParameters params, byte[] payloadBytes, int offset, MessageSerializer serializer, int length))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payloadBytes, offset, serializer, length))
    )

    ;;;
     ; Construct a block object from the Bitcoin wire format.  Used in the case of a block
     ; contained within another message (i.e. for AuxPoW header).
     ;
     ; @param params NetworkParameters object.
     ; @param payloadBytes Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param parent The message element which contains this block, maybe null for no parent.
     ; @param serializer The serializer to use for this block.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor Block(§ args NetworkParameters params, byte[] payloadBytes, int offset, #_nilable Message parent, MessageSerializer serializer, int length))
        (§ throws ProtocolException)
    (§ block
        ;; TODO: Keep the parent.
        (§ super (§ pars params, payloadBytes, offset, serializer, length))
    )

    ;;;
     ; Construct a block initialized with all the given fields.
     ; @param params Which network the block is for.
     ; @param version This should usually be set to 1 or 2, depending on if the height is in the coinbase input.
     ; @param prevBlockHash Reference to previous block in the chain or {@link Sha256Hash#ZERO_HASH} if genesis.
     ; @param merkleRoot The root of the merkle tree formed by the transactions.
     ; @param time UNIX time when the block was mined.
     ; @param difficultyTarget Number which this block hashes lower than.
     ; @param nonce Arbitrary number to make the block hash lower than the target.
     ; @param transactions List of transactions including the coinbase.
     ;;
    #_public
    (§ constructor Block(§ args NetworkParameters params, long version, Sha256Hash prevBlockHash, Sha256Hash merkleRoot, long time, long difficultyTarget, long nonce, List<Transaction> transactions))
    (§ block
        (§ super (§ pars params))

        (§ ass this.version = version)
        (§ ass this.prevBlockHash = prevBlockHash)
        (§ ass this.merkleRoot = merkleRoot)
        (§ ass this.time = time)
        (§ ass this.difficultyTarget = difficultyTarget)
        (§ ass this.nonce = nonce)
        (§ ass this.transactions = new LinkedList<>(§ pars ))
        (§ call this.transactions.addAll(§ pars transactions))
    )

    ;;;
     ; <p>A utility method that calculates how much new Bitcoin would be created by the block at the given height.
     ; The inflation of Bitcoin is predictable and drops roughly every 4 years (210,000 blocks).  At the dawn of
     ; the system it was 50 coins per block, in late 2012 it went to 25 coins per block, and so on.  The size of
     ; a coinbase transaction is inflation plus fees.</p>
     ;
     ; The half-life is controlled by {@link org.bitcoinj.core.NetworkParameters#getSubsidyDecreaseBlockCount()}.
     ;;
    #_public
    (§ method Coin getBlockInflation(§ args int height))
    (§ block
        (§ return FIFTY_COINS.shiftRight(§ pars height / params.getSubsidyDecreaseBlockCount(§ pars )))
    )

    ;;;
     ; Parse transactions from the block.
     ;
     ; @param transactionsOffset Offset of the transactions within the block.
     ; Useful for non-Bitcoin chains where the block header may not be a fixed size.
     ;;
    #_protected
    (§ method void parseTransactions(§ args #_final int transactionsOffset))
        (§ throws ProtocolException)
    (§ block
        (§ ass cursor = transactionsOffset)
        (§ ass optimalEncodingMessageSize = HEADER_SIZE)
        (§ if (§ expr payload.length == cursor))
        (§ block
            ;; This message is just a header, it has no transactions.
            (§ ass transactionBytesValid = false)
            (§ return )
        )

        (§ var int numTransactions = (§ cast int)readVarInt(§ pars ))
        (§ ass optimalEncodingMessageSize = optimalEncodingMessageSize + VarInt.sizeOf(§ pars numTransactions))
        (§ ass transactions = new ArrayList<>(§ pars numTransactions))
        (§ for (§ var int i = 0) :for (§ expr i < numTransactions) :for (§ ass i = i + 1))
        (§ block
            (§ var Transaction tx = new Transaction(§ pars params, payload, cursor, this, serializer, UNKNOWN_LENGTH))
            ;; Label the transaction as coming from the P2P network, so code that cares where we first saw it knows.
            (§ call tx.getConfidence(§ pars ).setSource(§ pars TransactionConfidence.Source.NETWORK))
            (§ call transactions.add(§ pars tx))
            (§ ass cursor = cursor + tx.getMessageSize(§ pars ))
            (§ ass optimalEncodingMessageSize = optimalEncodingMessageSize + tx.getOptimalEncodingMessageSize(§ pars ))
        )
        (§ ass transactionBytesValid = serializer.isParseRetainMode(§ pars ))
    )

    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
        ;; header
        (§ ass cursor = offset)
        (§ ass version = readUint32(§ pars ))
        (§ ass prevBlockHash = readHash(§ pars ))
        (§ ass merkleRoot = readHash(§ pars ))
        (§ ass time = readUint32(§ pars ))
        (§ ass difficultyTarget = readUint32(§ pars ))
        (§ ass nonce = readUint32(§ pars ))
        (§ ass hash = Sha256Hash.wrapReversed(§ pars Sha256Hash.hashTwice(§ pars payload, offset, cursor - offset)))
        (§ ass headerBytesValid = serializer.isParseRetainMode(§ pars ))

        ;; transactions
        (§ call parseTransactions(§ pars offset + HEADER_SIZE))
        (§ ass length = cursor - offset)
    )

    #_public
    (§ method int getOptimalEncodingMessageSize(§ args ))
    (§ block
        (§ if (§ expr optimalEncodingMessageSize != 0))
        (§ block
            (§ return optimalEncodingMessageSize)
        )
        (§ ass optimalEncodingMessageSize = bitcoinSerialize(§ pars ).length)
        (§ return optimalEncodingMessageSize)
    )

    ;; default for testing
    (§ method void writeHeader(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        ;; try for cached write first
        (§ if (§ expr headerBytesValid && payload != nil && offset + HEADER_SIZE <= payload.length))
        (§ block
            (§ call stream.write(§ pars payload, offset, HEADER_SIZE))
            (§ return )
        )

        ;; fall back to manual write
        (§ call Utils.uint32ToByteStreamLE(§ pars version, stream))
        (§ call stream.write(§ pars prevBlockHash.getReversedBytes(§ pars )))
        (§ call stream.write(§ pars getMerkleRoot(§ pars ).getReversedBytes(§ pars )))
        (§ call Utils.uint32ToByteStreamLE(§ pars time, stream))
        (§ call Utils.uint32ToByteStreamLE(§ pars difficultyTarget, stream))
        (§ call Utils.uint32ToByteStreamLE(§ pars nonce, stream))
    )

    #_private
    (§ method void writeTransactions(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        ;; check for no transaction conditions first
        (§ if (§ expr transactions == nil))
        (§ block
            (§ return )
        )

        ;; confirmed we must have transactions either cached or as objects
        (§ if (§ expr transactionBytesValid && payload != nil && offset + length <= payload.length))
        (§ block
            (§ call stream.write(§ pars payload, offset + HEADER_SIZE, length - HEADER_SIZE))
            (§ return )
        )

        (§ if (§ expr transactions != nil))
        (§ block
            (§ call stream.write(§ pars (§ new VarInt(§ pars transactions.size(§ pars ))).encode(§ pars )))
            (§ for (§ var Transaction tx) :for (§ expr transactions))
            (§ block
                (§ call tx.bitcoinSerialize(§ pars stream))
            )
        )
    )

    ;;;
     ; Special handling to check if we have a valid byte array for both header and transactions.
     ;
     ; @throws IOException
     ;;
    #_override
    #_public
    (§ method byte[] bitcoinSerialize(§ args ))
    (§ block
        ;; we have completely cached byte array
        (§ if (§ expr headerBytesValid && transactionBytesValid))
        (§ block
            (§ call Preconditions.checkNotNull(§ pars payload, "Bytes should never be nil if headerBytesValid && transactionBytesValid"))
            (§ if (§ expr length == payload.length))
            (§ block
                (§ return payload)
            )

            ;; byte array is offset, so copy out the correct range
            (§ var byte[] buf = new byte[length])
            (§ call System.arraycopy(§ pars payload, offset, buf, 0, length))
            (§ return buf)
        )

        ;; At least one of the two cacheable components is invalid, so fall back to stream write since we can't be sure of the length.
        (§ var ByteArrayOutputStream stream = new UnsafeByteArrayOutputStream(§ pars (§ expr length == UNKNOWN_LENGTH) ? HEADER_SIZE + guessTransactionsLength(§ pars ) :else length))
        (§ try )
        (§ block
            (§ call writeHeader(§ pars stream))
            (§ call writeTransactions(§ pars stream))
        )
        (§ catch (§ args IOException e))
        (§ block
            ;; Cannot happen, we are serializing to a memory stream.
        )
        (§ return stream.toByteArray(§ pars ))
    )

    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ call writeHeader(§ pars stream))
        ;; We may only have enough data to write the header.
        (§ call writeTransactions(§ pars stream))
    )

    ;;;
     ; Provides a reasonable guess at the byte length of the transactions part of the block.
     ; The returned value will be accurate in 99% of cases and in those cases where not will probably slightly oversize.
     ;
     ; This is used to preallocate the underlying byte array for a ByteArrayOutputStream.  If the size is under the
     ; real value the only penalty is resizing of the underlying byte array.
     ;;
    #_private
    (§ method int guessTransactionsLength(§ args ))
    (§ block
        (§ if (§ expr transactionBytesValid))
        (§ block
            (§ return payload.length - HEADER_SIZE)
        )
        (§ if (§ expr transactions == nil))
        (§ block
            (§ return 0)
        )
        (§ var int len = VarInt.sizeOf(§ pars transactions.size(§ pars )))
        (§ for (§ var Transaction tx) :for (§ expr transactions))
        (§ block
            ;; 255 is just a guess at an average tx length
            (§ ass len = len + (§ expr tx.length == UNKNOWN_LENGTH ? 255 :else tx.length))
        )
        (§ return len)
    )

    #_override
    #_protected
    (§ method void unCache(§ args ))
    (§ block
        ;; Since we have alternate uncache methods to use internally, this will only ever be called by a child
        ;; transaction, so we only need to invalidate that part of the cache.
        (§ call unCacheTransactions(§ pars ))
    )

    #_private
    (§ method void unCacheHeader(§ args ))
    (§ block
        (§ ass headerBytesValid = false)
        (§ if (§ expr !transactionBytesValid))
        (§ block
            (§ ass payload = nil)
        )
        (§ ass hash = nil)
    )

    #_private
    (§ method void unCacheTransactions(§ args ))
    (§ block
        (§ ass transactionBytesValid = false)
        (§ if (§ expr !headerBytesValid))
        (§ block
            (§ ass payload = nil)
        )
        ;; Current implementation has to uncache headers as well as any change to a tx will alter the merkle root.
        ;; In future, we can go more granular and cache merkle root separately so rest of the header does not need to be rewritten.
        (§ call unCacheHeader(§ pars ))
        ;; Clear merkleRoot last as it may end up being parsed during unCacheHeader().
        (§ ass merkleRoot = nil)
    )

    ;;;
     ; Calculates the block hash by serializing the block and hashing the resulting bytes.
     ;;
    #_private
    (§ method Sha256Hash calculateHash(§ args ))
    (§ block
        (§ try )
        (§ block
            (§ var ByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(§ pars HEADER_SIZE))
            (§ call writeHeader(§ pars bos))
            (§ return Sha256Hash.wrapReversed(§ pars Sha256Hash.hashTwice(§ pars bos.toByteArray(§ pars ))))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
    )

    ;;;
     ; Returns the hash of the block (which for a valid, solved block should be below the target) in the form seen on
     ; the block explorer.  If you call this on block 1 in the mainnet chain,
     ; you will get "00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048".
     ;;
    #_public
    (§ method String getHashAsString(§ args ))
    (§ block
        (§ return getHash(§ pars ).toString(§ pars ))
    )

    ;;;
     ; Returns the hash of the block (which for a valid, solved block should be
     ; below the target).  Big endian.
     ;;
    #_override
    #_public
    (§ method Sha256Hash getHash(§ args ))
    (§ block
        (§ if (§ expr hash == nil))
        (§ block
            (§ ass hash = calculateHash(§ pars ))
        )
        (§ return hash)
    )

    ;;;
     ; The number that is one greater than the largest representable SHA-256 hash.
     ;;
    #_private
    #_static
    (§ field BigInteger LARGEST_HASH = BigInteger.ONE.shiftLeft(§ pars 256))

    ;;;
     ; Returns the work represented by this block.
     ;
     ; Work is defined as the number of tries needed to solve a block in the
     ; average case.  Consider a difficulty target that covers 5% of all possible
     ; hash values.  Then the work of the block will be 20.  As the target gets
     ; lower, the amount of work goes up.
     ;;
    #_public
    (§ method BigInteger getWork(§ args ))
        (§ throws VerificationException)
    (§ block
        (§ var BigInteger target = getDifficultyTargetAsInteger(§ pars ))
        (§ return LARGEST_HASH.divide(§ pars target.add(§ pars BigInteger.ONE)))
    )

    ;;; Returns a copy of the block, but without any transactions. ;;
    #_public
    (§ method Block cloneAsHeader(§ args ))
    (§ block
        (§ var Block block = new Block(§ pars params, BLOCK_VERSION_GENESIS))
        (§ call copyBitcoinHeaderTo(§ pars block))
        (§ return block)
    )

    ;;; Copy the block without transactions into the provided empty block. ;;
    #_protected
    #_final
    (§ method void copyBitcoinHeaderTo(§ args #_final Block block))
    (§ block
        (§ ass block.nonce = nonce)
        (§ ass block.prevBlockHash = prevBlockHash)
        (§ ass block.merkleRoot = getMerkleRoot(§ pars ))
        (§ ass block.version = version)
        (§ ass block.time = time)
        (§ ass block.difficultyTarget = difficultyTarget)
        (§ ass block.transactions = nil)
        (§ ass block.hash = getHash(§ pars ))
    )

    ;;;
     ; Returns a multi-line string containing a description of the contents of the block.
     ; Use for debugging purposes only.
     ;;
    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ var StringBuilder sb = new StringBuilder(§ pars ))
        (§ call sb.append(§ pars " block: \n"))
        (§ call sb.append(§ pars "   hash: ").append(§ pars getHashAsString(§ pars )).append(§ pars "\n"))
        (§ call sb.append(§ pars "   version: ").append(§ pars version))
        (§ var String bips = Joiner.on(§ pars ", ").skipNulls(§ pars ).join(§ pars isBIP34(§ pars ) ? "BIP34" :else nil, isBIP66(§ pars ) ? "BIP66" :else nil, isBIP65(§ pars ) ? "BIP65" :else nil))
        (§ if (§ expr !bips.isEmpty(§ pars )))
        (§ block
            (§ call sb.append(§ pars " (").append(§ pars bips).append(§ pars ")"))
        )
        (§ call sb.append(§ pars "\n"))
        (§ call sb.append(§ pars "   previous block: ").append(§ pars getPrevBlockHash(§ pars )).append(§ pars "\n"))
        (§ call sb.append(§ pars "   merkle root: ").append(§ pars getMerkleRoot(§ pars )).append(§ pars "\n"))
        (§ call sb.append(§ pars "   time: ").append(§ pars time).append(§ pars " (").append(§ pars Utils.dateTimeFormat(§ pars time * 1000)).append(§ pars ")\n"))
        (§ call sb.append(§ pars "   difficulty target (nBits): ").append(§ pars difficultyTarget).append(§ pars "\n"))
        (§ call sb.append(§ pars "   nonce: ").append(§ pars nonce).append(§ pars "\n"))
        (§ if (§ expr transactions != nil && 0 < transactions.size(§ pars )))
        (§ block
            (§ call sb.append(§ pars "   with ").append(§ pars transactions.size(§ pars )).append(§ pars " transaction(s):\n"))
            (§ for (§ var Transaction tx) :for (§ expr transactions))
            (§ block
                (§ call sb.append(§ pars tx))
            )
        )
        (§ return sb.toString(§ pars ))
    )

    ;;;
     ; <p>Finds a value of nonce that makes the blocks hash lower than the difficulty target.  This is called mining,
     ; but solve() is far too slow to do real mining with.  It exists only for unit testing purposes.
     ;
     ; <p>This can loop forever if a solution cannot be found solely by incrementing nonce.  It doesn't change
     ; extraNonce.</p>
     ;;
    #_public
    (§ method void solve(§ args ))
    (§ block
        (§ while (§ expr true))
        (§ block
            (§ try )
            (§ block
                ;; Is our proof of work valid yet?
                (§ if (§ expr checkProofOfWork(§ pars false)))
                (§ block
                    (§ return )
                )
                ;; No, so increment the nonce and try again.
                (§ call setNonce(§ pars getNonce(§ pars ) + 1))
            )
            (§ catch (§ args VerificationException e))
            (§ block
                (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
            )
        )
    )

    ;;;
     ; Returns the difficulty target as a 256 bit value that can be compared to a SHA-256 hash.  Inside a block the
     ; target is represented using a compact form.  If this form decodes to a value that is out of bounds, an exception
     ; is thrown.
     ;;
    #_public
    (§ method BigInteger getDifficultyTargetAsInteger(§ args ))
        (§ throws VerificationException)
    (§ block
        (§ var BigInteger target = Utils.decodeCompactBits(§ pars difficultyTarget))
        (§ if (§ expr target.signum(§ pars ) <= 0 || 0 < target.compareTo(§ pars params.maxTarget)))
        (§ block
            (§ throw (§ new VerificationException(§ pars "Difficulty target is bad: " + target)))
        )
        (§ return target)
    )

    ;;; Returns true if the hash of the block is OK (lower than difficulty target). ;;
    #_protected
    (§ method boolean checkProofOfWork(§ args boolean throwException))
        (§ throws VerificationException)
    (§ block
        ;; This part is key - it is what proves the block was as difficult to make as it claims
        ;; to be.  Note however that in the context of this function, the block can claim to be
        ;; as difficult as it wants to be .... if somebody was able to take control of our network
        ;; connection and fork us onto a different chain, they could send us valid blocks with
        ;; ridiculously easy difficulty and this function would accept them.
        ;;
        ;; To prevent this attack from being possible, elsewhere we check that the difficultyTarget
        ;; field is of the right value.  This requires us to have the preceeding blocks.
        (§ var BigInteger target = getDifficultyTargetAsInteger(§ pars ))

        (§ var BigInteger h = getHash(§ pars ).toBigInteger(§ pars ))
        (§ if (§ expr 0 < h.compareTo(§ pars target)))
        (§ block
            ;; Proof of work check failed!
            (§ if (§ expr throwException))
            (§ block
                (§ throw (§ new VerificationException(§ pars "Hash is higher than target: " + getHashAsString(§ pars ) + " vs " + target.toString(§ pars 16))))
            )
            (§ else )
            (§ block
                (§ return false)
            )
        )
        (§ return true)
    )

    #_private
    (§ method void checkTimestamp(§ args ))
        (§ throws VerificationException)
    (§ block
        #_final
        (§ var long allowedTime = Utils.currentTimeSeconds(§ pars ) + ALLOWED_TIME_DRIFT)
        (§ if (§ expr allowedTime < time))
        (§ block
            (§ throw (§ new VerificationException(§ pars String.format(§ pars Locale.US, "Block too far in future: %s (%d) vs allowed %s (%d)", Utils.dateTimeFormat(§ pars time * 1000), time, Utils.dateTimeFormat(§ pars allowedTime * 1000), allowedTime))))
        )
    )

    #_private
    (§ method void checkSigOps(§ args ))
        (§ throws VerificationException)
    (§ block
        ;; Check there aren't too many signature verifications in the block.  This is an anti-DoS measure, see the
        ;; comments for MAX_BLOCK_SIGOPS.
        (§ var int sigOps = 0)
        (§ for (§ var Transaction tx) :for (§ expr transactions))
        (§ block
            (§ ass sigOps = sigOps + tx.getSigOpCount(§ pars ))
        )

        (§ if (§ expr MAX_BLOCK_SIGOPS < sigOps))
        (§ block
            (§ throw (§ new VerificationException(§ pars "Block had too many Signature Operations")))
        )
    )

    #_private
    (§ method void checkMerkleRoot(§ args ))
        (§ throws VerificationException)
    (§ block
        (§ var Sha256Hash calculatedRoot = calculateMerkleRoot(§ pars ))
        (§ if (§ expr !calculatedRoot.equals(§ pars merkleRoot)))
        (§ block
            (§ call log.error(§ pars "Merkle tree did not verify"))
            (§ throw (§ new VerificationException(§ pars "Merkle hashes do not match: " + calculatedRoot + " vs " + merkleRoot)))
        )
    )

    #_private
    (§ method Sha256Hash calculateMerkleRoot(§ args ))
    (§ block
        (§ var List<byte[]> tree = buildMerkleTree(§ pars ))
        (§ return Sha256Hash.wrap(§ pars tree.get(§ pars tree.size(§ pars ) - 1)))
    )

    #_private
    (§ method List<byte[]> buildMerkleTree(§ args ))
    (§ block
        ;; The Merkle root is based on a tree of hashes calculated from the transactions:
        ;;
        ;;     root
        ;;     /  \
        ;;   A      B
        ;;  / \    / \
        ;; t1 t2  t3 t4
        ;;
        ;; The tree is represented as a list: (t1 t2 t3 t4 A B root), where each entry is a hash.
        ;;
        ;; The hashing algorithm is double SHA-256.  The leaves are a hash of the serialized contents of the transaction.
        ;; The interior nodes are hashes of the concenation of the two child hashes.
        ;;
        ;; This structure allows the creation of proof that a transaction was included into a block without having to
        ;; provide the full block contents.  Instead, you can provide only a Merkle branch.  For example to prove tx2 was
        ;; in a block you can just provide tx2, the hash(tx1) and B.  Now the other party has everything they need to
        ;; derive the root, which can be checked against the block header.  These proofs aren't used right now but
        ;; will be helpful later when we want to download partial block contents.
        ;;
        ;; Note that if the number of transactions is not even, the last tx is repeated to make it so (see tx3 above).
        ;; A tree with 5 transactions would look like this:
        ;;
        ;;          root
        ;;        /      \
        ;;      1          5
        ;;    /   \       / \
        ;;   2     3     4   4
        ;;  / \   / \   / \
        ;; t1 t2 t3 t4 t5 t5
        (§ var ArrayList<byte[]> tree = new ArrayList<>(§ pars ))
        ;; Start by adding all the hashes of the transactions as leaves of the tree.
        (§ for (§ var Transaction t) :for (§ expr transactions))
        (§ block
            (§ call tree.add(§ pars t.getHash(§ pars ).getBytes(§ pars )))
        )

        ;; Offset in the list where the currently processed level starts.
        (§ var int levelOffset = 0)
        ;; Step through each level, stopping when we reach the root (levelSize == 1).
        (§ for (§ var int levelSize = transactions.size(§ pars )) :for (§ expr 1 < levelSize) :for (§ ass levelSize = (§ expr (§ expr levelSize + 1) / 2)))
        (§ block
            ;; For each pair of nodes on that level:
            (§ for (§ var int left = 0) :for (§ expr left < levelSize) :for (§ ass left = left + 2))
            (§ block
                ;; The right hand node can be the same as the left hand, in the case where we don't have enough transactions.
                (§ var int right = Math.min(§ pars left + 1, levelSize - 1))
                (§ var byte[] leftBytes = Utils.reverseBytes(§ pars tree.get(§ pars levelOffset + left)))
                (§ var byte[] rightBytes = Utils.reverseBytes(§ pars tree.get(§ pars levelOffset + right)))
                (§ call tree.add(§ pars Utils.reverseBytes(§ pars hashTwice(§ pars leftBytes, 0, 32, rightBytes, 0, 32))))
            )
            ;; Move to the next level.
            (§ ass levelOffset = levelOffset + levelSize)
        )
        (§ return tree)
    )

    ;;;
     ; Verify the transactions on a block.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;               If provided, used to validate the coinbase input script of v2 and above blocks.
     ; @throws VerificationException if there was an error verifying the block.
     ;;
    #_private
    (§ method void checkTransactions(§ args #_final int height, #_final EnumSet<VerifyFlag> flags))
        (§ throws VerificationException)
    (§ block
        ;; The first transaction in a block must always be a coinbase transaction.
        (§ if (§ expr !transactions.get(§ pars 0).isCoinBase(§ pars )))
        (§ block
            (§ throw (§ new VerificationException(§ pars "First tx is not coinbase")))
        )

        (§ if (§ expr flags.contains(§ pars Block.VerifyFlag.HEIGHT_IN_COINBASE) && BLOCK_HEIGHT_GENESIS <= height))
        (§ block
            (§ call transactions.get(§ pars 0).checkCoinBaseHeight(§ pars height))
        )

        ;; The rest must not be.
        (§ for (§ var int i = 1) :for (§ expr i < transactions.size(§ pars )) :for (§ ass i = i + 1))
        (§ block
            (§ if (§ expr transactions.get(§ pars i).isCoinBase(§ pars )))
            (§ block
                (§ throw (§ new VerificationException(§ pars "TX " + i + " is coinbase when it should not be.")))
            )
        )
    )

    ;;;
     ; Checks the block data to ensure it follows the rules laid out in the network parameters.  Specifically,
     ; throws an exception if the proof of work is invalid, or if the timestamp is too far from what it should be.
     ; This is <b>not</b> everything that is required for a block to be valid, only what is checkable independent
     ; of the chain and without a transaction index.
     ;
     ; @throws VerificationException
     ;;
    #_public
    (§ method void verifyHeader(§ args ))
        (§ throws VerificationException)
    (§ block
        ;; Prove that this block is OK.  It might seem that we can just ignore most of these checks given that the
        ;; network is also verifying the blocks, but we cannot as it'd open us to a variety of obscure attacks.
        ;;
        ;; Firstly we need to ensure this block does in fact represent real work done.  If the difficulty is high
        ;; enough, it's probably been done by the network.
        (§ call checkProofOfWork(§ pars true))
        (§ call checkTimestamp(§ pars ))
    )

    ;;;
     ; Checks the block contents.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;               If valid, used to validate the coinbase input script of v2 and above blocks.
     ; @param flags Flags to indicate which tests should be applied (i.e. whether to test for height in the coinbase transaction).
     ; @throws VerificationException if there was an error verifying the block.
     ;;
    #_public
    (§ method void verifyTransactions(§ args #_final int height, #_final EnumSet<VerifyFlag> flags))
        (§ throws VerificationException)
    (§ block
        ;; Now we need to check that the body of the block actually matches the headers.  The network won't generate
        ;; an invalid block, but if we didn't validate this then an untrusted man-in-the-middle could obtain the next
        ;; valid block from the network and simply replace the transactions in it with their own fictional
        ;; transactions that reference spent or non-existant inputs.
        (§ if (§ expr transactions.isEmpty(§ pars )))
        (§ block
            (§ throw (§ new VerificationException(§ pars "Block had no transactions")))
        )
        (§ if (§ expr MAX_BLOCK_SIZE < this.getOptimalEncodingMessageSize(§ pars )))
        (§ block
            (§ throw (§ new VerificationException(§ pars "Block larger than MAX_BLOCK_SIZE")))
        )
        (§ call checkTransactions(§ pars height, flags))
        (§ call checkMerkleRoot(§ pars ))
        (§ call checkSigOps(§ pars ))
        (§ for (§ var Transaction transaction) :for (§ expr transactions))
        (§ block
            (§ call transaction.verify(§ pars ))
        )
    )

    ;;;
     ; Verifies both the header and that the transactions hash to the merkle root.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ; @param flags Flags to indicate which tests should be applied (i.e. whether to test for height in the coinbase transaction).
     ; @throws VerificationException if there was an error verifying the block.
     ;;
    #_public
    (§ method void verify(§ args #_final int height, #_final EnumSet<VerifyFlag> flags))
        (§ throws VerificationException)
    (§ block
        (§ call verifyHeader(§ pars ))
        (§ call verifyTransactions(§ pars height, flags))
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return getHash(§ pars ).equals(§ pars (§ expr (§ cast Block)o).getHash(§ pars )))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return getHash(§ pars ).hashCode(§ pars ))
    )

    ;;;
     ; Returns the merkle root in big endian form, calculating it from transactions if necessary.
     ;;
    #_public
    (§ method Sha256Hash getMerkleRoot(§ args ))
    (§ block
        (§ if (§ expr merkleRoot == nil))
        (§ block
            ;; TODO: Check if this is really necessary.
            (§ call unCacheHeader(§ pars ))
            (§ ass merkleRoot = calculateMerkleRoot(§ pars ))
        )
        (§ return merkleRoot)
    )

    ;;; Exists only for unit testing. ;;
    (§ method void setMerkleRoot(§ args Sha256Hash value))
    (§ block
        (§ call unCacheHeader(§ pars ))
        (§ ass merkleRoot = value)
        (§ ass hash = nil)
    )

    ;;; Adds a transaction to this block.  The nonce and merkle root are invalid after this. ;;
    #_public
    (§ method void addTransaction(§ args Transaction t))
    (§ block
        (§ call addTransaction(§ pars t, true))
    )

    ;;; Adds a transaction to this block, with or without checking the sanity of doing so. ;;
    (§ method void addTransaction(§ args Transaction t, boolean runSanityChecks))
    (§ block
        (§ call unCacheTransactions(§ pars ))
        (§ if (§ expr transactions == nil))
        (§ block
            (§ ass transactions = new ArrayList<>(§ pars ))
        )
        (§ call t.setParent(§ pars this))
        (§ if (§ expr runSanityChecks && transactions.size(§ pars ) == 0 && !t.isCoinBase(§ pars )))
        (§ block
            (§ throw (§ new RuntimeException(§ pars "Attempted to add a non-coinbase transaction as the first transaction: " + t)))
        )
        (§ if (§ expr runSanityChecks && 0 < transactions.size(§ pars ) && t.isCoinBase(§ pars )))
        (§ block
            (§ throw (§ new RuntimeException(§ pars "Attempted to add a coinbase transaction when there already is one: " + t)))
        )
        (§ call transactions.add(§ pars t))
        (§ call adjustLength(§ pars transactions.size(§ pars ), t.length))
        ;; Force a recalculation next time the values are needed.
        (§ ass merkleRoot = nil)
        (§ ass hash = nil)
    )

    ;;;
     ; Returns the version of the block data structure as defined by the Bitcoin protocol.
     ;;
    #_public
    (§ method long getVersion(§ args ))
    (§ block
        (§ return version)
    )

    ;;;
     ; Returns the hash of the previous block in the chain, as defined by the block header.
     ;;
    #_public
    (§ method Sha256Hash getPrevBlockHash(§ args ))
    (§ block
        (§ return prevBlockHash)
    )

    (§ method void setPrevBlockHash(§ args Sha256Hash prevBlockHash))
    (§ block
        (§ call unCacheHeader(§ pars ))
        (§ ass this.prevBlockHash = prevBlockHash)
        (§ ass this.hash = nil)
    )

    ;;;
     ; Returns the time at which the block was solved and broadcast, according to the clock of the solving node.
     ; This is measured in seconds since the UNIX epoch (midnight Jan 1st 1970).
     ;;
    #_public
    (§ method long getTimeSeconds(§ args ))
    (§ block
        (§ return time)
    )

    ;;;
     ; Returns the time at which the block was solved and broadcast, according to the clock of the solving node.
     ;;
    #_public
    (§ method Date getTime(§ args ))
    (§ block
        (§ return (§ new Date(§ pars getTimeSeconds(§ pars ) * 1000)))
    )

    #_public
    (§ method void setTime(§ args long time))
    (§ block
        (§ call unCacheHeader(§ pars ))
        (§ ass this.time = time)
        (§ ass this.hash = nil)
    )

    ;;;
     ; Returns the difficulty of the proof of work that this block should meet encoded <b>in compact form</b>.
     ; The {@link BlockChain} verifies that this is not too easy by looking at the length of the chain when the block is added.
     ; To find the actual value the hash should be compared against, use {@link org.bitcoinj.core.Block#getDifficultyTargetAsInteger()}.
     ; Note that this is <b>not</b> the same as the difficulty value reported by the Bitcoin "getdifficulty" RPC that you may see on various block explorers.
     ; That number is the result of applying a formula to the underlying difficulty to normalize the minimum to 1.
     ; Calculating the difficulty that way is currently unsupported.
     ;;
    #_public
    (§ method long getDifficultyTarget(§ args ))
    (§ block
        (§ return difficultyTarget)
    )

    ;;; Sets the difficulty target in compact form. ;;
    #_public
    (§ method void setDifficultyTarget(§ args long compactForm))
    (§ block
        (§ call unCacheHeader(§ pars ))
        (§ ass this.difficultyTarget = compactForm)
        (§ ass this.hash = nil)
    )

    ;;;
     ; Returns the nonce, an arbitrary value that exists only to make the hash of the block header fall below the difficulty target.
     ;;
    #_public
    (§ method long getNonce(§ args ))
    (§ block
        (§ return nonce)
    )

    ;;;
     ; Sets the nonce and clears any cached data.
     ;;
    #_public
    (§ method void setNonce(§ args long nonce))
    (§ block
        (§ call unCacheHeader(§ pars ))
        (§ ass this.nonce = nonce)
        (§ ass this.hash = nil)
    )

    ;;; Returns an immutable list of transactions held in this block, or null if this object represents just a header. ;;
    #_nilable
    #_public
    (§ method List<Transaction> getTransactions(§ args ))
    (§ block
        (§ return (§ quest (§ expr transactions == nil) ? nil :else ImmutableList.copyOf(§ pars transactions)))
    )

    ;; Used to make transactions unique.
    #_private
    #_static
    (§ field int txCounter)

    ;;; Adds a coinbase transaction to the block.  This exists for unit tests.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;;
    #_testing
    (§ method void addCoinbaseTransaction(§ args byte[] pubKeyTo, Coin value, #_final int height))
    (§ block
        (§ call unCacheTransactions(§ pars ))
        (§ ass transactions = new ArrayList<>(§ pars ))
        (§ var Transaction coinbase = new Transaction(§ pars params))
        #_final
        (§ var ScriptBuilder inputBuilder = new ScriptBuilder(§ pars ))

        (§ if (§ expr Block.BLOCK_HEIGHT_GENESIS <= height))
        (§ block
            (§ call inputBuilder.number(§ pars height))
        )
        (§ call inputBuilder.data(§ pars new byte[] (§ coll (§ cast byte)txCounter, (§ cast byte)(§ expr txCounter >> 8) )))
        (§ ass txCounter = txCounter + 1)

        ;; A real coinbase transaction has some stuff in the scriptSig like the extraNonce and difficulty.
        ;; The transactions are distinguished by every TX output going to a different key.
        ;;
        ;; Here we will do things a bit differently so a new address isn't needed every time.
        ;; We'll put a simple counter in the scriptSig, so every transaction has a different hash.
        (§ call coinbase.addInput(§ pars (§ new TransactionInput(§ pars params, coinbase, inputBuilder.build(§ pars ).getProgram(§ pars )))))
        (§ call coinbase.addOutput(§ pars (§ new TransactionOutput(§ pars params, coinbase, value, ScriptBuilder.createOutputScript(§ pars ECKey.fromPublicOnly(§ pars pubKeyTo)).getProgram(§ pars )))))
        (§ call transactions.add(§ pars coinbase))
        (§ call coinbase.setParent(§ pars this))
        (§ ass coinbase.length = coinbase.unsafeBitcoinSerialize(§ pars ).length)
        (§ call adjustLength(§ pars transactions.size(§ pars ), coinbase.length))
    )

    #_static
    #_final
    (§ field byte[] EMPTY_BYTES = new byte[32])

    ;; It's pretty weak to have this around at runtime: fix later.
    #_private
    #_static
    #_final
    (§ field byte[] pubkeyForTesting = new ECKey(§ pars ).getPubKey(§ pars ))

    ;;;
     ; Returns a solved block that builds on top of this one.  This exists for unit tests.
     ;;
    #_testing
    #_public
    (§ method Block createNextBlock(§ args Address to, long version, long time, int blockHeight))
    (§ block
        (§ return createNextBlock(§ pars to, version, nil, time, pubkeyForTesting, FIFTY_COINS, blockHeight))
    )

    ;;;
     ; Returns a solved block that builds on top of this one.  This exists for unit tests.
     ; In this variant you can specify a public key (pubkey) for use in generating coinbase blocks.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;;
    (§ method Block createNextBlock(§ args #_nilable #_final Address to, #_final long version, #_nilable TransactionOutPoint prevOut, #_final long time, #_final byte[] pubKey, #_final Coin coinbaseValue, #_final int height))
    (§ block
        (§ var Block b = new Block(§ pars params, version))
        (§ call b.setDifficultyTarget(§ pars difficultyTarget))
        (§ call b.addCoinbaseTransaction(§ pars pubKey, coinbaseValue, height))

        (§ if (§ expr to != nil))
        (§ block
            ;; Add a transaction paying 50 coins to the "to" address.
            (§ var Transaction t = new Transaction(§ pars params))
            (§ call t.addOutput(§ pars (§ new TransactionOutput(§ pars params, t, FIFTY_COINS, to))))
            ;; The input does not really need to be a valid signature, as long as it has the right general form.
            (§ var TransactionInput input)
            (§ if (§ expr prevOut == nil))
            (§ block
                (§ ass input = new TransactionInput(§ pars params, t, Script.createInputScript(§ pars EMPTY_BYTES, EMPTY_BYTES)))
                ;; Importantly, the outpoint hash cannot be zero as that's how we detect a coinbase transaction in isolation,
                ;; but it must be unique to avoid 'different' transactions looking the same.
                (§ var byte[] counter = new byte[32])
                (§ ass counter[0] = (§ cast byte)txCounter)
                (§ ass counter[1] = (§ cast byte)(§ expr txCounter >> 8))
                (§ ass txCounter = txCounter + 1)
                (§ call input.getOutpoint(§ pars ).setHash(§ pars Sha256Hash.wrap(§ pars counter)))
            )
            (§ else )
            (§ block
                (§ ass input = new TransactionInput(§ pars params, t, Script.createInputScript(§ pars EMPTY_BYTES, EMPTY_BYTES), prevOut))
            )
            (§ call t.addInput(§ pars input))
            (§ call b.addTransaction(§ pars t))
        )

        (§ call b.setPrevBlockHash(§ pars getHash(§ pars )))
        ;; Don't let timestamp go backwards.
        (§ if (§ expr time <= getTimeSeconds(§ pars )))
        (§ block
            (§ call b.setTime(§ pars getTimeSeconds(§ pars ) + 1))
        )
        (§ else )
        (§ block
            (§ call b.setTime(§ pars time))
        )
        (§ call b.solve(§ pars ))
        (§ try )
        (§ block
            (§ call b.verifyHeader(§ pars ))
        )
        (§ catch (§ args VerificationException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
        (§ if (§ expr b.getVersion(§ pars ) != version))
        (§ block
            (§ throw (§ new RuntimeException(§ pars )))
        )
        (§ return b)
    )

    #_testing
    #_public
    (§ method Block createNextBlock(§ args #_nilable Address to, TransactionOutPoint prevOut))
    (§ block
        (§ return createNextBlock(§ pars to, BLOCK_VERSION_GENESIS, prevOut, getTimeSeconds(§ pars ) + 5, pubkeyForTesting, FIFTY_COINS, BLOCK_HEIGHT_UNKNOWN))
    )

    #_testing
    #_public
    (§ method Block createNextBlock(§ args #_nilable Address to, Coin value))
    (§ block
        (§ return createNextBlock(§ pars to, BLOCK_VERSION_GENESIS, nil, getTimeSeconds(§ pars ) + 5, pubkeyForTesting, value, BLOCK_HEIGHT_UNKNOWN))
    )

    #_testing
    #_public
    (§ method Block createNextBlock(§ args #_nilable Address to))
    (§ block
        (§ return createNextBlock(§ pars to, FIFTY_COINS))
    )

    #_testing
    #_public
    (§ method Block createNextBlockWithCoinbase(§ args long version, byte[] pubKey, Coin coinbaseValue, #_final int height))
    (§ block
        (§ return createNextBlock(§ pars nil, version, (§ cast TransactionOutPoint)nil, Utils.currentTimeSeconds(§ pars ), pubKey, coinbaseValue, height))
    )

    ;;;
     ; Create a block sending 50BTC as a coinbase transaction to the public key specified.
     ; This method is intended for test use only.
     ;;
    #_testing
    (§ method Block createNextBlockWithCoinbase(§ args long version, byte[] pubKey, #_final int height))
    (§ block
        (§ return createNextBlock(§ pars nil, version, (§ cast TransactionOutPoint)nil, Utils.currentTimeSeconds(§ pars ), pubKey, FIFTY_COINS, height))
    )

    #_testing
    (§ method boolean isHeaderBytesValid(§ args ))
    (§ block
        (§ return headerBytesValid)
    )

    #_testing
    (§ method boolean isTransactionBytesValid(§ args ))
    (§ block
        (§ return transactionBytesValid)
    )

    ;;;
     ; Return whether this block contains any transactions.
     ;
     ; @return true if the block contains transactions, false otherwise (is purely a header).
     ;;
    #_public
    (§ method boolean hasTransactions(§ args ))
    (§ block
        (§ return !this.transactions.isEmpty(§ pars ))
    )

    ;;;
     ; Returns whether this block conforms to
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki">BIP34: Height in Coinbase</a>.
     ;;
    #_public
    (§ method boolean isBIP34(§ args ))
    (§ block
        (§ return (§ expr BLOCK_VERSION_BIP34 <= version))
    )

    ;;;
     ; Returns whether this block conforms to
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki">BIP66: Strict DER signatures</a>.
     ;;
    #_public
    (§ method boolean isBIP66(§ args ))
    (§ block
        (§ return (§ expr BLOCK_VERSION_BIP66 <= version))
    )

    ;;;
     ; Returns whether this block conforms to
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki">BIP65: OP_CHECKLOCKTIMEVERIFY</a>.
     ;;
    #_public
    (§ method boolean isBIP65(§ args ))
    (§ block
        (§ return (§ expr BLOCK_VERSION_BIP65 <= version))
    )
)

#_(ns org.bitcoinj.core #_"BlockChain"
    (:import [java.util ArrayList List])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.store BlockStore BlockStoreException]
             [org.bitcoinj.wallet Wallet]))

;; TODO: Rename this class to SPVBlockChain at some point.

;;;
 ; A BlockChain implements the <i>simplified payment verification</i> mode of the Bitcoin protocol.  It is the right
 ; choice to use for programs that have limited resources as it won't verify transactions signatures or attempt to store
 ; all of the block chain.  Really, this class should be called SPVBlockChain but for backwards compatibility it is not.
 ;;
#_public
(§ class BlockChain extends AbstractBlockChain
    ;;; Keeps a map of block hashes to StoredBlocks. ;;
    #_protected
    #_final
    (§ field BlockStore blockStore)

    ;;;
     ; <p>Constructs a BlockChain connected to the given wallet and store.  To obtain a {@link Wallet} you can construct
     ; one from scratch, or you can deserialize a saved wallet from disk using {@link Wallet#loadFromFile(java.io.File)}.</p>
     ;
     ; <p>For the store, you should use {@link org.bitcoinj.store.SPVBlockStore} or you could also try a
     ; {@link org.bitcoinj.store.MemoryBlockStore} if you want to hold all headers in RAM and don't care about
     ; disk serialization (this is rare).</p>
     ;;
    #_public
    (§ constructor BlockChain(§ args Context context, Wallet wallet, BlockStore blockStore))
        (§ throws BlockStoreException)
    (§ block
        (§ this (§ pars context, new ArrayList<Wallet>(§ pars ), blockStore))
        (§ call addWallet(§ pars wallet))
    )

    ;;; See {@link #BlockChain(Context, Wallet, BlockStore)}}. ;;
    #_public
    (§ constructor BlockChain(§ args NetworkParameters params, Wallet wallet, BlockStore blockStore))
        (§ throws BlockStoreException)
    (§ block
        (§ this (§ pars Context.getOrCreate(§ pars params), wallet, blockStore))
    )

    ;;;
     ; Constructs a BlockChain that has no wallet at all.  This is helpful when you don't actually care about sending
     ; and receiving coins but rather, just want to explore the network data structures.
     ;;
    #_public
    (§ constructor BlockChain(§ args Context context, BlockStore blockStore))
        (§ throws BlockStoreException)
    (§ block
        (§ this (§ pars context, new ArrayList<Wallet>(§ pars ), blockStore))
    )

    ;;; See {@link #BlockChain(Context, BlockStore)}. ;;
    #_public
    (§ constructor BlockChain(§ args NetworkParameters params, BlockStore blockStore))
        (§ throws BlockStoreException)
    (§ block
        (§ this (§ pars params, new ArrayList<Wallet>(§ pars ), blockStore))
    )

    ;;;
     ; Constructs a BlockChain connected to the given list of listeners and a store.
     ;;
    #_public
    (§ constructor BlockChain(§ args Context params, List<? extends Wallet> wallets, BlockStore blockStore))
        (§ throws BlockStoreException)
    (§ block
        (§ super (§ pars params, wallets, blockStore))
        (§ ass this.blockStore = blockStore)
    )

    ;;; See {@link #BlockChain(Context, List, BlockStore)}. ;;
    #_public
    (§ constructor BlockChain(§ args NetworkParameters params, List<? extends Wallet> wallets, BlockStore blockStore))
        (§ throws BlockStoreException)
    (§ block
        (§ this (§ pars Context.getOrCreate(§ pars params), wallets, blockStore))
    )

    #_override
    #_protected
    (§ method StoredBlock addToBlockStore(§ args StoredBlock storedPrev, Block blockHeader, TransactionOutputChanges txOutChanges))
        (§ throws BlockStoreException, VerificationException)
    (§ block
        (§ var StoredBlock newBlock = storedPrev.build(§ pars blockHeader))
        (§ call blockStore.put(§ pars newBlock))
        (§ return newBlock)
    )

    #_override
    #_protected
    (§ method StoredBlock addToBlockStore(§ args StoredBlock storedPrev, Block blockHeader))
        (§ throws BlockStoreException, VerificationException)
    (§ block
        (§ var StoredBlock newBlock = storedPrev.build(§ pars blockHeader))
        (§ call blockStore.put(§ pars newBlock))
        (§ return newBlock)
    )

    #_override
    #_protected
    (§ method void rollbackBlockStore(§ args int height))
        (§ throws BlockStoreException)
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var int currentHeight = getBestChainHeight(§ pars ))
            (§ call Preconditions.checkArgument(§ pars 0 <= height && height <= currentHeight, "Bad height: %s", height))
            (§ if (§ expr height == currentHeight))
            (§ block
                (§ return ) ;; nothing to do
            )

            ;; Look for the block we want to be the new chain head.
            (§ var StoredBlock newChainHead = blockStore.getChainHead(§ pars ))
            (§ while (§ expr height < newChainHead.getHeight(§ pars )))
            (§ block
                (§ ass newChainHead = newChainHead.getPrev(§ pars blockStore))
                (§ if (§ expr newChainHead == nil))
                (§ block
                    (§ throw (§ new BlockStoreException(§ pars "Unreachable height")))
                )
            )

            ;; Modify store directly.
            (§ call blockStore.put(§ pars newChainHead))
            (§ call this.setChainHead(§ pars newChainHead))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_override
    #_protected
    (§ method boolean shouldVerifyTransactions(§ args ))
    (§ block
        (§ return false)
    )

    #_override
    #_protected
    (§ method TransactionOutputChanges connectTransactions(§ args int height, Block block))
    (§ block
        ;; Don't have to do anything as this is only called if shouldVerifyTransactions().
        (§ throw (§ new UnsupportedOperationException(§ pars )))
    )

    #_override
    #_protected
    (§ method TransactionOutputChanges connectTransactions(§ args StoredBlock newBlock))
    (§ block
        ;; Don't have to do anything as this is only called if shouldVerifyTransactions().
        (§ throw (§ new UnsupportedOperationException(§ pars )))
    )

    #_override
    #_protected
    (§ method void disconnectTransactions(§ args StoredBlock block))
    (§ block
        ;; Don't have to do anything as this is only called if shouldVerifyTransactions().
        (§ throw (§ new UnsupportedOperationException(§ pars )))
    )

    #_override
    #_protected
    (§ method void doSetChainHead(§ args StoredBlock chainHead))
        (§ throws BlockStoreException)
    (§ block
        (§ call blockStore.setChainHead(§ pars chainHead))
    )

    #_override
    #_protected
    (§ method void notSettingChainHead(§ args ))
        (§ throws BlockStoreException)
    (§ block
        ;; We don't use DB transactions here, so we don't need to do anything.
    )

    #_override
    #_protected
    (§ method StoredBlock getStoredBlockInCurrentScope(§ args Sha256Hash hash))
        (§ throws BlockStoreException)
    (§ block
        (§ return blockStore.get(§ pars hash))
    )

    #_override
    #_public
    (§ method boolean add(§ args FilteredBlock block))
        (§ throws VerificationException, PrunedException)
    (§ block
        (§ var boolean success = super.add(§ pars block))
        (§ if (§ expr success))
        (§ block
            (§ call trackFilteredTransactions(§ pars block.getTransactionCount(§ pars )))
        )
        (§ return success)
    )
)

#_(ns org.bitcoinj.core #_"BloomFilter"
    (:import [java.io IOException OutputStream]
             #_static [java.lang.Math *]
             [java.util ArrayList Arrays List])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.collect Lists])
   (:require [org.bitcoinj.script Script ScriptChunk]))

;;;
 ; <p>A Bloom filter is a probabilistic data structure which can be sent to another client so that it can avoid
 ; sending us transactions that aren't relevant to our set of keys.  This allows for significantly more efficient
 ; use of available network bandwidth and CPU time.</p>
 ;
 ; <p>Because a Bloom filter is probabilistic, it has a configurable false positive rate.  So the filter will sometimes
 ; match transactions that weren't inserted into it, but it will never fail to match transactions that were.  This is
 ; a useful privacy feature - if you have spare bandwidth the false positive rate can be increased so the remote peer
 ; gets a noisy picture of what transactions are relevant to your wallet.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class BloomFilter extends Message
    ;;;
     ; The BLOOM_UPDATE_* constants control when the bloom filter is auto-updated by the peer using
     ; it as a filter, either never, for all outputs or only for pay-2-pubkey outputs (default).
     ;;
    #_public
    (§ enum BloomUpdate
        (§ item UPDATE_NONE) ;; 0
        (§ item UPDATE_ALL) ;; 1
        ;;; Only adds outpoints to the filter if the output is a pay-to-pubkey/pay-to-multisig script. ;;
        (§ item UPDATE_P2PUBKEY_ONLY) ;; 2
    )

    #_private
    (§ field byte[] data)
    #_private
    (§ field long hashFuncs)
    #_private
    (§ field long nTweak)
    #_private
    (§ field byte nFlags)

    ;; Same value as of Bitcoin Core.
    ;; A filter of 20,000 items and a false positive rate of 0.1% or one of 10,000 items and 0.0001% is just under 36,000 bytes.
    #_private
    #_static
    #_final
    (§ field long MAX_FILTER_SIZE = 36000)
    ;; There is little reason to ever have more hash functions than 50 given a limit of 36,000 bytes.
    #_private
    #_static
    #_final
    (§ field int MAX_HASH_FUNCS = 50)

    ;;;
     ; Construct a BloomFilter by deserializing payloadBytes.
     ;;
    #_public
    (§ constructor BloomFilter(§ args NetworkParameters params, byte[] payloadBytes))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payloadBytes, 0))
    )

    ;;;
     ; Constructs a filter with the given parameters which is updated on pay2pubkey outputs only.
     ;;
    #_public
    (§ constructor BloomFilter(§ args int elements, double falsePositiveRate, long randomNonce))
    (§ block
        (§ this (§ pars elements, falsePositiveRate, randomNonce, BloomUpdate.UPDATE_P2PUBKEY_ONLY))
    )

    ;;;
     ; <p>Constructs a new Bloom Filter which will provide approximately the given false positive rate when the given
     ; number of elements have been inserted.  If the filter would otherwise be larger than the maximum allowed size,
     ; it will be automatically downsized to the maximum size.</p>
     ;
     ; <p>To check the theoretical false positive rate of a given filter, use {@link BloomFilter#getFalsePositiveRate(int)}.</p>
     ;
     ; <p>The anonymity of which coins are yours to any peer which you send a BloomFilter to is controlled by the
     ; false positive rate.  For reference, as of block 187,000, the total number of addresses used in the chain was
     ; roughly 4.5 million.  Thus, if you use a false positive rate of 0.001 (0.1%), there will be, on average, 4,500
     ; distinct public keys/addresses which will be thought to be yours by nodes which have your bloom filter, but
     ; which are not actually yours.  Keep in mind that a remote node can do a pretty good job estimating the order of
     ; magnitude of the false positive rate of a given filter you provide it when considering the anonymity of a given
     ; filter.</p>
     ;
     ; <p>In order for filtered block download to function efficiently, the number of matched transactions in any given
     ; block should be less than (with some headroom) the maximum size of the MemoryPool used by the Peer
     ; doing the downloading (default is {@link TxConfidenceTable#MAX_SIZE}).  See the comment in processBlock(FilteredBlock)
     ; for more information on this restriction.</p>
     ;
     ; <p>randomNonce is a tweak for the hash function used to prevent some theoretical DoS attacks.
     ; It should be a random value, however secureness of the random value is of no great consequence.</p>
     ;
     ; <p>updateFlag is used to control filter behaviour on the server (remote node) side when it encounters a hit.
     ; See {@link org.bitcoinj.core.BloomFilter.BloomUpdate} for a brief description of each mode.  The purpose
     ; of this flag is to reduce network round-tripping and avoid over-dirtying the filter for the most common
     ; wallet configurations.</p>
     ;;
    #_public
    (§ constructor BloomFilter(§ args int elements, double falsePositiveRate, long randomNonce, BloomUpdate updateFlag))
    (§ block
        ;; The following formulas were stolen from Wikipedia's page on Bloom Filters (with the addition of min(..., MAX_...)).
        ;; Size required for a given number of elements and false-positive rate.
        (§ var int size = (§ cast int)(§ expr -1 / pow(§ pars log(§ pars 2), 2) * elements * log(§ pars falsePositiveRate)))
        (§ ass size = max(§ pars 1, min(§ pars size, (§ cast int)MAX_FILTER_SIZE * 8) / 8))
        (§ ass data = new byte[size])
        ;; Optimal number of hash functions for a given filter size and element count.
        (§ ass hashFuncs = (§ cast int)(§ expr data.length * 8 / (§ cast double)elements * log(§ pars 2)))
        (§ ass hashFuncs = max(§ pars 1, min(§ pars hashFuncs, MAX_HASH_FUNCS)))
        (§ ass this.nTweak = randomNonce)
        (§ ass this.nFlags = (§ cast byte)(§ expr 0xff & updateFlag.ordinal(§ pars )))
    )

    ;;;
     ; Returns the theoretical false positive rate of this filter if were to contain the given number of elements.
     ;;
    #_public
    (§ method double getFalsePositiveRate(§ args int elements))
    (§ block
        (§ return pow(§ pars 1 - pow(§ pars E, -1.0 * (§ expr hashFuncs * elements) / (§ expr data.length * 8)), hashFuncs))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return "Bloom Filter of size " + data.length + " with " + hashFuncs + " hash functions.")
    )

    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ ass data = readByteArray(§ pars ))
        (§ if (§ expr MAX_FILTER_SIZE < data.length))
        (§ block
            (§ throw new ProtocolException(§ pars "Bloom filter out of size range."))
        )
        (§ ass hashFuncs = readUint32(§ pars ))
        (§ if (§ expr MAX_HASH_FUNCS < hashFuncs))
        (§ block
            (§ throw (§ new ProtocolException(§ pars "Bloom filter hash function count out of range")))
        )
        (§ ass nTweak = readUint32(§ pars ))
        (§ ass nFlags = readBytes(§ pars 1)[0])
        (§ ass length = cursor - offset)
    )

    ;;;
     ; Serializes this message to the provided stream.  If you just want the raw bytes use bitcoinSerialize().
     ;;
    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ call stream.write(§ pars (§ new VarInt(§ pars data.length)).encode(§ pars )))
        (§ call stream.write(§ pars data))
        (§ call Utils.uint32ToByteStreamLE(§ pars hashFuncs, stream))
        (§ call Utils.uint32ToByteStreamLE(§ pars nTweak, stream))
        (§ call stream.write(§ pars nFlags))
    )

    #_private
    #_static
    (§ method int rotateLeft32(§ args int x, int r))
    (§ block
        (§ return (§ expr (§ expr x << r) | (§ expr x >>> (§ expr 32 - r))))
    )

    ;;;
     ; Applies the MurmurHash3 (x86_32) algorithm to the given data.
     ; See <a href="https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp">this C++ code</a> for the original.
     ;;
    #_public
    #_static
    (§ method int murmurHash3(§ args byte[] data, long nTweak, int hashNum, byte[] object))
    (§ block
        (§ var int h1 = (§ cast int)(§ expr hashNum * 0xfba4c795 + nTweak))
        #_final
        (§ var int c1 = 0xcc9e2d51)
        #_final
        (§ var int c2 = 0x1b873593)

        (§ var int numBlocks = (§ expr object.length / 4) * 4)

        ;; body
        (§ for (§ var int i = 0) :for (§ expr i < numBlocks) :for (§ ass i = i + 4))
        (§ block
            (§ var int k1 = (§ expr (§ expr object[i] & 0xff) | (§ expr (§ expr object[i + 1] & 0xff) << 8) | (§ expr (§ expr object[i + 2] & 0xff) << 16) | (§ expr (§ expr object[i + 3] & 0xff) << 24)))

            (§ ass k1 = k1 * c1)
            (§ ass k1 = rotateLeft32(§ pars k1, 15))
            (§ ass k1 = k1 * c2)

            (§ ass h1 = h1 :xor k1)
            (§ ass h1 = rotateLeft32(§ pars h1, 13))
            (§ ass h1 = h1 * 5 + 0xe6546b64)
        )

        (§ var int k1 = 0)
        (§ switch (§ expr object.length & 3))
        (§ block
            (§ case 3)
            (§ block
                (§ ass k1 = k1 :xor (§ expr (§ expr object[numBlocks + 2] & 0xff) << 16))
                ;; Fall through.
            )
            (§ case 2)
            (§ block
                (§ ass k1 = k1 :xor (§ expr (§ expr object[numBlocks + 1] & 0xff) << 8))
                ;; Fall through.
            )
            (§ case 1)
            (§ block
                (§ ass k1 = k1 :xor (§ expr object[numBlocks] & 0xff))
                (§ ass k1 = k1 * c1)
                (§ ass k1 = rotateLeft32(§ pars k1, 15))
                (§ ass k1 = k1 * c2)
                (§ ass h1 = h1 :xor k1)
                ;; Fall through.
            )
            (§ default )
            (§ block
                ;; Do nothing.
                (§ break )
            )
        )

        ;; finalization
        (§ ass h1 = h1 :xor object.length)
        (§ ass h1 = h1 :xor (§ expr h1 >>> 16))
        (§ ass h1 = h1 * 0x85ebca6b)
        (§ ass h1 = h1 :xor (§ expr h1 >>> 13))
        (§ ass h1 = h1 * 0xc2b2ae35)
        (§ ass h1 = h1 :xor (§ expr h1 >>> 16))

        (§ return (§ cast int)(§ expr (§ expr h1 & 0xffffffff) % (§ expr data.length * 8)))
    )

    ;;;
     ; Returns true if the given object matches the filter either because it was inserted, or because we have a false-positive.
     ;;
    #_public
    #_synchronized
    (§ method boolean contains(§ args byte[] object))
    (§ block
        (§ for (§ var int i = 0) :for (§ expr i < hashFuncs) :for (§ ass i = i + 1))
        (§ block
            (§ if (§ expr !Utils.checkBitLE(§ pars data, murmurHash3(§ pars data, nTweak, i, object))))
            (§ block
                (§ return false)
            )
        )

        (§ return true)
    )

    ;;; Insert the given arbitrary data into the filter. ;;
    #_public
    #_synchronized
    (§ method void insert(§ args byte[] object))
    (§ block
        (§ for (§ var int i = 0) :for (§ expr i < hashFuncs) :for (§ ass i = i + 1))
        (§ block
            (§ call Utils.setBitLE(§ pars data, murmurHash3(§ pars data, nTweak, i, object)))
        )
    )

    ;;; Inserts the given key and equivalent hashed form (for the address). ;;
    #_public
    #_synchronized
    (§ method void insert(§ args ECKey key))
    (§ block
        (§ call insert(§ pars key.getPubKey(§ pars )))
        (§ call insert(§ pars key.getPubKeyHash(§ pars )))
    )

    ;;;
     ; Sets this filter to match all objects.  A Bloom filter which matches everything may seem pointless, however,
     ; it is useful in order to reduce steady state bandwidth usage when you want full blocks.  Instead of receiving
     ; all transaction data twice, you will receive the vast majority of all transactions just once, at broadcast time.
     ; Solved blocks will then be send just as Merkle trees of tx hashes, meaning a constant 32 bytes of data for each
     ; transaction instead of 100-300 bytes as per usual.
     ;;
    #_public
    #_synchronized
    (§ method void setMatchAll(§ args ))
    (§ block
        (§ ass data = new byte[] (§ coll (§ cast byte)0xff ))
    )

    ;;;
     ; Copies filter into this.  Filter must have the same size, hash function count and nTweak or an
     ; IllegalArgumentException will be thrown.
     ;;
    #_public
    #_synchronized
    (§ method void merge(§ args BloomFilter filter))
    (§ block
        (§ if (§ expr !this.matchesAll(§ pars ) && !filter.matchesAll(§ pars )))
        (§ block
            (§ call Preconditions.checkArgument(§ pars filter.data.length == this.data.length && filter.hashFuncs == this.hashFuncs && filter.nTweak == this.nTweak))

            (§ for (§ var int i = 0) :for (§ expr i < data.length) :for (§ ass i = i + 1))
            (§ block
                (§ ass this.data[i] = this.data[i] | filter.data[i])
            )
        )
        (§ else )
        (§ block
            (§ ass this.data = new byte[] (§ coll (§ cast byte)0xff ))
        )
    )

    ;;;
     ; Returns true if this filter will match anything.  See {@link org.bitcoinj.core.BloomFilter#setMatchAll()}
     ; for when this can be a useful thing to do.
     ;;
    #_public
    #_synchronized
    (§ method boolean matchesAll(§ args ))
    (§ block
        (§ for (§ var byte b) :for (§ expr data))
        (§ block
            (§ if (§ expr b != (§ cast byte)0xff))
            (§ block
                (§ return false)
            )
        )
        (§ return true)
    )

    ;;;
     ; The update flag controls how application of the filter to a block modifies the filter.  See the enum javadocs
     ; for information on what occurs and when.
     ;;
    #_public
    #_synchronized
    (§ method BloomUpdate getUpdateFlag(§ args ))
    (§ block
        (§ if (§ expr nFlags == 0))
        (§ block
            (§ return BloomUpdate.UPDATE_NONE)
        )
        (§ if (§ expr nFlags == 1))
        (§ block
            (§ return BloomUpdate.UPDATE_ALL)
        )
        (§ if (§ expr nFlags == 2))
        (§ block
            (§ return BloomUpdate.UPDATE_P2PUBKEY_ONLY)
        )

        (§ throw (§ new IllegalStateException(§ pars "Unknown flag combination")))
    )

    ;;;
     ; Creates a new FilteredBlock from the given Block, using this filter to select transactions.  Matches can cause the
     ; filter to be updated with the matched element, this ensures that when a filter is applied to a block, spends of
     ; matched transactions are also matched.  However it means this filter can be mutated by the operation.  The returned
     ; filtered block already has the matched transactions associated with it.
     ;;
    #_public
    #_synchronized
    (§ method FilteredBlock applyAndUpdate(§ args Block block))
    (§ block
        (§ var List<Transaction> txns = block.getTransactions(§ pars ))
        (§ var List<Sha256Hash> txHashes = new ArrayList<>(§ pars txns.size(§ pars )))
        (§ var List<Transaction> matched = Lists.newArrayList(§ pars ))
        (§ var byte[] bits = new byte[(§ cast int)Math.ceil(§ pars txns.size(§ pars ) / 8.0)])
        (§ for (§ var int i = 0) :for (§ expr i < txns.size(§ pars )) :for (§ ass i = i + 1))
        (§ block
            (§ var Transaction tx = txns.get(§ pars i))
            (§ call txHashes.add(§ pars tx.getHash(§ pars )))
            (§ if (§ expr applyAndUpdate(§ pars tx)))
            (§ block
                (§ call Utils.setBitLE(§ pars bits, i))
                (§ call matched.add(§ pars tx))
            )
        )
        (§ var PartialMerkleTree pmt = PartialMerkleTree.buildFromLeaves(§ pars block.getParams(§ pars ), bits, txHashes))
        (§ var FilteredBlock filteredBlock = new FilteredBlock(§ pars block.getParams(§ pars ), block.cloneAsHeader(§ pars ), pmt))
        (§ for (§ var Transaction transaction) :for (§ expr matched))
        (§ block
            (§ call filteredBlock.provideTransaction(§ pars transaction))
        )
        (§ return filteredBlock)
    )

    #_public
    #_synchronized
    (§ method boolean applyAndUpdate(§ args Transaction tx))
    (§ block
        (§ if (§ expr contains(§ pars tx.getHash(§ pars ).getBytes(§ pars ))))
        (§ block
            (§ return true)
        )
        (§ var boolean found = false)
        (§ var BloomUpdate flag = getUpdateFlag(§ pars ))
        (§ for (§ var TransactionOutput output) :for (§ expr tx.getOutputs(§ pars )))
        (§ block
            (§ var Script script = output.getScriptPubKey(§ pars ))
            (§ for (§ var ScriptChunk chunk) :for (§ expr script.getChunks(§ pars )))
            (§ block
                (§ if (§ expr chunk.isPushData(§ pars ) && contains(§ pars chunk.data)))
                (§ block
                    (§ var boolean isSendingToPubKeys = script.isSentToRawPubKey(§ pars ) || script.isSentToMultiSig(§ pars ))
                    (§ if (§ expr flag == BloomUpdate.UPDATE_ALL || (§ expr flag == BloomUpdate.UPDATE_P2PUBKEY_ONLY && isSendingToPubKeys)))
                    (§ block
                        (§ call insert(§ pars output.getOutPointFor(§ pars ).unsafeBitcoinSerialize(§ pars )))
                    )
                    (§ ass found = true)
                )
            )
        )
        (§ if (§ expr found))
        (§ block
            (§ return true)
        )
        (§ for (§ var TransactionInput input) :for (§ expr tx.getInputs(§ pars )))
        (§ block
            (§ if (§ expr contains(§ pars input.getOutpoint(§ pars ).unsafeBitcoinSerialize(§ pars ))))
            (§ block
                (§ return true)
            )

            (§ for (§ var ScriptChunk chunk) :for (§ expr input.getScriptSig(§ pars ).getChunks(§ pars )))
            (§ block
                (§ if (§ expr chunk.isPushData(§ pars ) && contains(§ pars chunk.data)))
                (§ block
                    (§ return true)
                )
            )
        )
        (§ return false)
    )

    #_override
    #_public
    #_synchronized
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var BloomFilter other = (§ cast BloomFilter)o)
        (§ return (§ expr hashFuncs == other.hashFuncs && nTweak == other.nTweak && Arrays.equals(§ pars data, other.data)))
    )

    #_override
    #_public
    #_synchronized
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars hashFuncs, nTweak, Arrays.hashCode(§ pars data)))
    )
)

#_(ns org.bitcoinj.core #_"CheckpointManager"
    (:import [java.io BufferedInputStream BufferedReader DataInputStream IOException InputStream InputStreamReader]
             [java.nio ByteBuffer ByteOrder]
             [java.security DigestInputStream MessageDigest]
             [java.util Arrays Map TreeMap])
    (:import [com.google.common.base Charsets Preconditions]
             [com.google.common.hash HashCode Hasher Hashing]
             [com.google.common.io BaseEncoding]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.store BlockStore BlockStoreException FullPrunedBlockStore]))

;;;
 ; <p>Vends hard-coded {@link StoredBlock}s for blocks throughout the chain.  Checkpoints serve two purposes:</p>
 ; <ol>
 ;    <li>They act as a safety mechanism against huge re-orgs that could rewrite large chunks of history, thus
 ;    constraining the block chain to be a consensus mechanism only for recent parts of the timeline.</li>
 ;    <li>They allow synchronization to the head of the chain for new wallets/users much faster than syncing all
 ;    headers from the genesis block.</li>
 ; </ol>
 ;
 ; <p>Checkpoints are used by the SPV {@link BlockChain} to initialize fresh {@link org.bitcoinj.store.SPVBlockStore}s.
 ; They are not used by fully validating mode, which instead has a different concept of checkpoints that are used
 ; to hard-code the validity of blocks that violate BIP30 (duplicate coinbase transactions).
 ; Those "checkpoints" can be found in NetworkParameters.</p>
 ;
 ; <p>The file format consists of the string "CHECKPOINTS 1", followed by a uint32 containing the number of signatures
 ; to read.  The value may not be larger than 256 (so it could have been a byte but isn't for historical reasons).
 ; If the number of signatures is larger than zero, each 65 byte ECDSA secp256k1 signature then follows.  The signatures
 ; sign the hash of all bytes that follow the last signature.</p>
 ;
 ; <p>After the signatures come an int32 containing the number of checkpoints in the file.  Then each checkpoint follows
 ; one after the other.  A checkpoint is 12 bytes for the total work done field, 4 bytes for the height, 80 bytes
 ; for the block header and then 1 zero byte at the end (i.e. number of transactions in the block: always zero).</p>
 ;;
#_public
(§ class CheckpointManager
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars CheckpointManager.class))

    #_private
    #_static
    #_final
    (§ field String BINARY_MAGIC = "CHECKPOINTS 1")
    #_private
    #_static
    #_final
    (§ field String TEXTUAL_MAGIC = "TXT CHECKPOINTS 1")
    #_private
    #_static
    #_final
    (§ field int MAX_SIGNATURES = 256)

    ;; Map of block header time to data.
    #_protected
    #_final
    (§ field TreeMap<Long, StoredBlock> checkpoints = new TreeMap<>(§ pars ))

    #_protected
    #_final
    (§ field NetworkParameters params)
    #_protected
    #_final
    (§ field Sha256Hash dataHash)

    #_public
    #_static
    #_final
    (§ field BaseEncoding BASE64 = BaseEncoding.base64(§ pars ).omitPadding(§ pars ))

    ;;; Loads the default checkpoints bundled with bitcoinj. ;;
    #_public
    (§ constructor CheckpointManager(§ args Context context))
        (§ throws IOException)
    (§ block
        (§ this (§ pars context.getParams(§ pars ), nil))
    )

    ;;; Loads the checkpoints from the given stream. ;;
    #_public
    (§ constructor CheckpointManager(§ args NetworkParameters params, #_nilable InputStream inputStream))
        (§ throws IOException)
    (§ block
        (§ ass this.params = Preconditions.checkNotNull(§ pars params))
        (§ if (§ expr inputStream == nil))
        (§ block
            (§ ass inputStream = openStream(§ pars params))
        )
        (§ call Preconditions.checkNotNull(§ pars inputStream))
        (§ ass inputStream = new BufferedInputStream(§ pars inputStream))
        (§ call inputStream.mark(§ pars 1))
        (§ var int first = inputStream.read(§ pars ))
        (§ call inputStream.reset(§ pars ))
        (§ if (§ expr first == BINARY_MAGIC.charAt(§ pars 0)))
        (§ block
            (§ ass dataHash = readBinary(§ pars inputStream))
        )
        (§ elseif (§ expr first == TEXTUAL_MAGIC.charAt(§ pars 0)))
        (§ block
            (§ ass dataHash = readTextual(§ pars inputStream))
        )
        (§ else )
        (§ block
            (§ throw (§ new IOException(§ pars "Unsupported format.")))
        )
    )

    ;;; Returns a checkpoints stream pointing to inside the bitcoinj JAR. ;;
    #_public
    #_static
    (§ method InputStream openStream(§ args NetworkParameters params))
    (§ block
        (§ return CheckpointManager.class.getResourceAsStream(§ pars "/" + params.getId(§ pars ) + ".checkpoints.txt"))
    )

    #_private
    (§ method Sha256Hash readBinary(§ args InputStream inputStream))
        (§ throws IOException)
    (§ block
        (§ var DataInputStream dis = nil)
        (§ try )
        (§ block
            (§ var MessageDigest digest = Sha256Hash.newDigest(§ pars ))
            (§ var DigestInputStream digestInputStream = new DigestInputStream(§ pars inputStream, digest))
            (§ ass dis = new DataInputStream(§ pars digestInputStream))
            (§ call digestInputStream.on(§ pars false))
            (§ var byte[] header = new byte[BINARY_MAGIC.length(§ pars )])
            (§ call dis.readFully(§ pars header))
            (§ if (§ expr !Arrays.equals(§ pars header, BINARY_MAGIC.getBytes(§ pars "US-ASCII"))))
            (§ block
                (§ throw (§ new IOException(§ pars "Header bytes did not match expected version")))
            )
            (§ var int numSignatures = checkPositionIndex(§ pars dis.readInt(§ pars ), MAX_SIGNATURES, "Num signatures out of range"))
            (§ for (§ var int i = 0) :for (§ expr i < numSignatures) :for (§ ass i = i + 1))
            (§ block
                (§ var byte[] sig = new byte[65])
                (§ call dis.readFully(§ pars sig))
                ;; TODO: Do something with the signature here.
            )
            (§ call digestInputStream.on(§ pars true))
            (§ var int numCheckpoints = dis.readInt(§ pars ))
            (§ call Preconditions.checkState(§ pars 0 < numCheckpoints))
            #_final
            (§ var int size = StoredBlock.COMPACT_SERIALIZED_SIZE)
            (§ var ByteBuffer buffer = ByteBuffer.allocate(§ pars size))
            (§ for (§ var int i = 0) :for (§ expr i < numCheckpoints) :for (§ ass i = i + 1))
            (§ block
                (§ if (§ expr dis.read(§ pars buffer.array(§ pars ), 0, size) < size))
                (§ block
                    (§ throw (§ new IOException(§ pars "Incomplete read whilst loading checkpoints.")))
                )
                (§ var StoredBlock block = StoredBlock.deserializeCompact(§ pars params, buffer))
                (§ call buffer.position(§ pars 0))
                (§ call checkpoints.put(§ pars block.getHeader(§ pars ).getTimeSeconds(§ pars ), block))
            )
            (§ var Sha256Hash dataHash = Sha256Hash.wrap(§ pars digest.digest(§ pars )))
            (§ call log.info(§ pars "Read {} checkpoints, hash is {}", checkpoints.size(§ pars ), dataHash))
            (§ return dataHash)
        )
        (§ catch (§ args ProtocolException e))
        (§ block
            (§ throw (§ new IOException(§ pars e)))
        )
        (§ finally )
        (§ block
            (§ if (§ expr dis != nil))
            (§ block
                (§ call dis.close(§ pars ))
            )
            (§ call inputStream.close(§ pars ))
        )
    )

    #_private
    (§ method Sha256Hash readTextual(§ args InputStream inputStream))
        (§ throws IOException)
    (§ block
        (§ var Hasher hasher = Hashing.sha256(§ pars ).newHasher(§ pars ))
        (§ var BufferedReader reader = nil)
        (§ try )
        (§ block
            (§ ass reader = new BufferedReader(§ pars (§ new InputStreamReader(§ pars inputStream, Charsets.US_ASCII))))
            (§ var String magic = reader.readLine(§ pars ))
            (§ if (§ expr !TEXTUAL_MAGIC.equals(§ pars magic)))
            (§ block
                (§ throw (§ new IOException(§ pars "unexpected magic: " + magic)))
            )
            (§ var int numSigs = Integer.parseInt(§ pars reader.readLine(§ pars )))
            (§ for (§ var int i = 0) :for (§ expr i < numSigs) :for (§ ass i = i + 1))
            (§ block
                (§ call reader.readLine(§ pars )) ;; Skip sigs for now.
            )
            (§ var int numCheckpoints = Integer.parseInt(§ pars reader.readLine(§ pars )))
            (§ call Preconditions.checkState(§ pars 0 < numCheckpoints))
            ;; Hash numCheckpoints in a way compatible to the binary format.
            (§ call hasher.putBytes(§ pars ByteBuffer.allocate(§ pars 4).order(§ pars ByteOrder.BIG_ENDIAN).putInt(§ pars numCheckpoints).array(§ pars )))
            #_final
            (§ var int size = StoredBlock.COMPACT_SERIALIZED_SIZE)
            (§ var ByteBuffer buffer = ByteBuffer.allocate(§ pars size))
            (§ for (§ var int i = 0) :for (§ expr i < numCheckpoints) :for (§ ass i = i + 1))
            (§ block
                (§ var byte[] bytes = BASE64.decode(§ pars reader.readLine(§ pars )))
                (§ call hasher.putBytes(§ pars bytes))
                (§ call buffer.position(§ pars 0))
                (§ call buffer.put(§ pars bytes))
                (§ call buffer.position(§ pars 0))
                (§ var StoredBlock block = StoredBlock.deserializeCompact(§ pars params, buffer))
                (§ call checkpoints.put(§ pars block.getHeader(§ pars ).getTimeSeconds(§ pars ), block))
            )
            (§ var HashCode hash = hasher.hash(§ pars ))
            (§ call log.info(§ pars "Read {} checkpoints, hash is {}", checkpoints.size(§ pars ), hash))
            (§ return Sha256Hash.wrap(§ pars hash.asBytes(§ pars )))
        )
        (§ finally )
        (§ block
            (§ if (§ expr reader != nil))
            (§ block
                (§ call reader.close(§ pars ))
            )
        )
    )

    ;;;
     ; Returns a {@link StoredBlock} representing the last checkpoint before the given time, for example, normally
     ; you would want to know the checkpoint before the earliest wallet birthday.
     ;;
    #_public
    (§ method StoredBlock getCheckpointBefore(§ args long time))
    (§ block
        (§ try )
        (§ block
            (§ call Preconditions.checkArgument(§ pars params.getGenesisBlock(§ pars ).getTimeSeconds(§ pars ) < time))
            ;; This is thread safe because the map never changes after creation.
            (§ var Map.Entry<Long, StoredBlock> entry = checkpoints.floorEntry(§ pars time))
            (§ if (§ expr entry != nil))
            (§ block
                (§ return entry.getValue(§ pars ))
            )
            (§ var Block genesis = params.getGenesisBlock(§ pars ).cloneAsHeader(§ pars ))
            (§ return (§ new StoredBlock(§ pars genesis, genesis.getWork(§ pars ), 0)))
        )
        (§ catch (§ args VerificationException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
    )

    ;;; Returns the number of checkpoints that were loaded. ;;
    #_public
    (§ method int numCheckpoints(§ args ))
    (§ block
        (§ return checkpoints.size(§ pars ))
    )

    ;;; Returns a hash of the concatenated checkpoint data. ;;
    #_public
    (§ method Sha256Hash getDataHash(§ args ))
    (§ block
        (§ return dataHash)
    )

    ;;;
     ; <p>Convenience method that creates a CheckpointManager, loads the given data, gets the checkpoint for the given
     ; time, then inserts it into the store and sets that to be the chain head.  Useful when you have just created
     ; a new store from scratch and want to use configure it all in one go.</p>
     ;
     ; <p>Note that time is adjusted backwards by a week to account for possible clock drift in the block headers.</p>
     ;;
    #_public
    #_static
    (§ method void checkpoint(§ args NetworkParameters params, InputStream checkpoints, BlockStore store, long time))
        (§ throws IOException, BlockStoreException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars params))
        (§ call Preconditions.checkNotNull(§ pars store))
        (§ call Preconditions.checkArgument(§ pars !(§ expr store instanceof FullPrunedBlockStore), "You cannot use checkpointing with a full store."))

        (§ ass time = time - (§ expr 86400 * 7))

        (§ call Preconditions.checkArgument(§ pars 0 < time))
        (§ call log.info(§ pars "Attempting to initialize a new block store with a checkpoint for time {} ({})", time, Utils.dateTimeFormat(§ pars time * 1000)))

        (§ var BufferedInputStream stream = new BufferedInputStream(§ pars checkpoints))
        (§ var CheckpointManager manager = new CheckpointManager(§ pars params, stream))
        (§ var StoredBlock checkpoint = manager.getCheckpointBefore(§ pars time))
        (§ call store.put(§ pars checkpoint))
        (§ call store.setChainHead(§ pars checkpoint))
    )
)

#_(ns org.bitcoinj.core #_"ChildMessage")

;;;
 ; <p>Represents a Message type that can be contained within another Message.  ChildMessages that have a cached
 ; backing byte array need to invalidate their parent's caches as well as their own if they are modified.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
(§ class ChildMessage extends Message
    #_nilable
    #_protected
    (§ field Message parent)

    #_public
    (§ constructor ChildMessage(§ args NetworkParameters params))
    (§ block
        (§ super (§ pars params))
    )

    #_public
    (§ constructor ChildMessage(§ args NetworkParameters params, byte[] payload, int offset, int protocolVersion))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, offset, protocolVersion))
    )

    #_public
    (§ constructor ChildMessage(§ args NetworkParameters params, byte[] payload, int offset, int protocolVersion, Message parent, MessageSerializer setSerializer, int length))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, offset, protocolVersion, setSerializer, length))
        (§ ass this.parent = parent)
    )

    #_public
    (§ constructor ChildMessage(§ args NetworkParameters params, byte[] payload, int offset))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, offset))
    )

    #_public
    (§ constructor ChildMessage(§ args NetworkParameters params, byte[] payload, int offset, #_nilable Message parent, MessageSerializer setSerializer, int length))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, offset, setSerializer, length))
        (§ ass this.parent = parent)
    )

    #_public
    #_final
    (§ method void setParent(§ args #_nilable Message parent))
    (§ block
        (§ if (§ expr this.parent != nil && this.parent != parent && parent != nil))
        (§ block
            ;; After old parent is unlinked it won't be able to receive notice if this ChildMessage changes internally.
            ;; To be safe we invalidate the parent cache to ensure it rebuilds manually on serialization.
            (§ call this.parent.unCache(§ pars ))
        )
        (§ ass this.parent = parent)
    )

    #_override
    #_protected
    (§ method void unCache(§ args ))
    (§ block
        (§ call super.unCache(§ pars ))
        (§ if (§ expr parent != nil))
        (§ block
            (§ call parent.unCache(§ pars ))
        )
    )

    #_protected
    (§ method void adjustLength(§ args int adjustment))
    (§ block
        (§ call adjustLength(§ pars 0, adjustment))
    )

    #_override
    #_protected
    (§ method void adjustLength(§ args int newArraySize, int adjustment))
    (§ block
        (§ call super.adjustLength(§ pars newArraySize, adjustment))
        (§ if (§ expr parent != nil))
        (§ block
            (§ call parent.adjustLength(§ pars newArraySize, adjustment))
        )
    )
)

#_(ns org.bitcoinj.core #_"Coin"
    (:import [java.io Serializable]
             [java.math BigDecimal])
    (:import [com.google.common.base Preconditions]
             [com.google.common.math LongMath]
             [com.google.common.primitives Longs])
   (:require [org.bitcoinj.utils MonetaryFormat]))

;;;
 ; Represents a monetary Bitcoin value.  This class is immutable.
 ;;
#_public
#_final
(§ class Coin implements Monetary, Comparable<Coin>, Serializable
    ;;;
     ; Number of decimals for one Bitcoin.  This constant is useful for quick adapting to other coins because a lot of
     ; constants derive from it.
     ;;
    #_public
    #_static
    #_final
    (§ field int SMALLEST_UNIT_EXPONENT = 8)

    ;;;
     ; The number of satoshis equal to one bitcoin.
     ;;
    #_private
    #_static
    #_final
    (§ field long COIN_VALUE = LongMath.pow(§ pars 10, SMALLEST_UNIT_EXPONENT))

    ;;;
     ; Zero Bitcoins.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin ZERO = Coin.valueOf(§ pars 0))

    ;;;
     ; One Bitcoin.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin COIN = Coin.valueOf(§ pars COIN_VALUE))

    ;;;
     ; 0.01 Bitcoins.  This unit is not really used much.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin CENT = COIN.divide(§ pars 100))

    ;;;
     ; 0.001 Bitcoins, also known as 1 mBTC.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin MILLICOIN = COIN.divide(§ pars 1000))

    ;;;
     ; 0.000001 Bitcoins, also known as 1 µBTC or 1 uBTC.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin MICROCOIN = MILLICOIN.divide(§ pars 1000))

    ;;;
     ; A satoshi is the smallest unit that can be transferred.  100 million of them fit into a Bitcoin.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin SATOSHI = Coin.valueOf(§ pars 1))

    #_public
    #_static
    #_final
    (§ field Coin FIFTY_COINS = COIN.multiply(§ pars 50))

    ;;;
     ; Represents a monetary value of minus one satoshi.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin NEGATIVE_SATOSHI = Coin.valueOf(§ pars -1))

    ;;;
     ; The number of satoshis of this monetary value.
     ;;
    #_public
    #_final
    (§ field long value)

    #_private
    (§ constructor Coin(§ args #_final long satoshis))
    (§ block
        (§ ass this.value = satoshis)
    )

    #_public
    #_static
    (§ method Coin valueOf(§ args #_final long satoshis))
    (§ block
        (§ return (§ new Coin(§ pars satoshis)))
    )

    #_override
    #_public
    (§ method int smallestUnitExponent(§ args ))
    (§ block
        (§ return SMALLEST_UNIT_EXPONENT)
    )

    ;;;
     ; Returns the number of satoshis of this monetary value.
     ;;
    #_override
    #_public
    (§ method long getValue(§ args ))
    (§ block
        (§ return value)
    )

    ;;;
     ; Convert an amount expressed in the way humans are used to into satoshis.
     ;;
    #_public
    #_static
    (§ method Coin valueOf(§ args #_final int coins, #_final int cents))
    (§ block
        (§ call Preconditions.checkArgument(§ pars 0 <= coins && 0 <= cents && cents < 100))

        (§ return COIN.multiply(§ pars coins).add(§ pars CENT.multiply(§ pars cents)))
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify fractional satoshis, or a value out of range.
     ;;
    #_public
    #_static
    (§ method Coin parseCoin(§ args #_final String str))
    (§ block
        (§ try )
        (§ block
            (§ var long satoshis = new BigDecimal(§ pars str).movePointRight(§ pars SMALLEST_UNIT_EXPONENT).longValueExact(§ pars ))
            (§ return Coin.valueOf(§ pars satoshis))
        )
        (§ catch (§ args ArithmeticException e))
        (§ block
            (§ throw (§ new IllegalArgumentException(§ pars e))) ;; Repackage exception to honor method contract.
        )
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.  The amount is cut to satoshi precision.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify a value out of range.
     ;;
    #_public
    #_static
    (§ method Coin parseCoinInexact(§ args #_final String str))
    (§ block
        (§ try )
        (§ block
            (§ var long satoshis = new BigDecimal(§ pars str).movePointRight(§ pars SMALLEST_UNIT_EXPONENT).longValue(§ pars ))
            (§ return Coin.valueOf(§ pars satoshis))
        )
        (§ catch (§ args ArithmeticException e))
        (§ block
            (§ throw (§ new IllegalArgumentException(§ pars e))) ;; Repackage exception to honor method contract.
        )
    )

    #_public
    (§ method Coin add(§ args #_final Coin value))
    (§ block
        (§ return (§ new Coin(§ pars LongMath.checkedAdd(§ pars this.value, value.value))))
    )

    ;;; Alias for add. ;;
    #_public
    (§ method Coin plus(§ args #_final Coin value))
    (§ block
        (§ return add(§ pars value))
    )

    #_public
    (§ method Coin subtract(§ args #_final Coin value))
    (§ block
        (§ return (§ new Coin(§ pars LongMath.checkedSubtract(§ pars this.value, value.value))))
    )

    ;;; Alias for subtract. ;;
    #_public
    (§ method Coin minus(§ args #_final Coin value))
    (§ block
        (§ return subtract(§ pars value))
    )

    #_public
    (§ method Coin multiply(§ args #_final long factor))
    (§ block
        (§ return (§ new Coin(§ pars LongMath.checkedMultiply(§ pars this.value, factor))))
    )

    ;;; Alias for multiply. ;;
    #_public
    (§ method Coin times(§ args #_final long factor))
    (§ block
        (§ return multiply(§ pars factor))
    )

    ;;; Alias for multiply. ;;
    #_public
    (§ method Coin times(§ args #_final int factor))
    (§ block
        (§ return multiply(§ pars factor))
    )

    #_public
    (§ method Coin divide(§ args #_final long divisor))
    (§ block
        (§ return (§ new Coin(§ pars this.value / divisor)))
    )

    ;;; Alias for divide. ;;
    #_public
    (§ method Coin div(§ args #_final long divisor))
    (§ block
        (§ return divide(§ pars divisor))
    )

    ;;; Alias for divide. ;;
    #_public
    (§ method Coin div(§ args #_final int divisor))
    (§ block
        (§ return divide(§ pars divisor))
    )

    #_public
    (§ method Coin[] divideAndRemainder(§ args #_final long divisor))
    (§ block
        (§ return new Coin[] (§ coll new Coin(§ pars this.value / divisor), new Coin(§ pars this.value % divisor) ))
    )

    #_public
    (§ method long divide(§ args #_final Coin divisor))
    (§ block
        (§ return this.value / divisor.value)
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value greater than zero,
     ; otherwise false.
     ;;
    #_public
    (§ method boolean isPositive(§ args ))
    (§ block
        (§ return (§ expr signum(§ pars ) == 1))
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value less than zero,
     ; otherwise false.
     ;;
    #_public
    (§ method boolean isNegative(§ args ))
    (§ block
        (§ return (§ expr signum(§ pars ) == -1))
    )

    ;;;
     ; Returns true if and only if this instance represents zero monetary value,
     ; otherwise false.
     ;;
    #_public
    (§ method boolean isZero(§ args ))
    (§ block
        (§ return (§ expr signum(§ pars ) == 0))
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is greater than that
     ; of the given other Coin, otherwise false.
     ;;
    #_public
    (§ method boolean isGreaterThan(§ args Coin other))
    (§ block
        (§ return (§ expr 0 < compareTo(§ pars other)))
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is less than that
     ; of the given other Coin, otherwise false.
     ;;
    #_public
    (§ method boolean isLessThan(§ args Coin other))
    (§ block
        (§ return (§ expr compareTo(§ pars other) < 0))
    )

    #_public
    (§ method Coin shiftLeft(§ args #_final int n))
    (§ block
        (§ return (§ new Coin(§ pars this.value << n)))
    )

    #_public
    (§ method Coin shiftRight(§ args #_final int n))
    (§ block
        (§ return (§ new Coin(§ pars this.value >> n)))
    )

    #_override
    #_public
    (§ method int signum(§ args ))
    (§ block
        (§ if (§ expr this.value == 0))
        (§ block
            (§ return 0)
        )
        (§ return (§ expr this.value < 0) ? -1 :else 1)
    )

    #_public
    (§ method Coin negate(§ args ))
    (§ block
        (§ return (§ new Coin(§ pars -this.value)))
    )

    ;;;
     ; Returns the number of satoshis of this monetary value.  It's deprecated in favour of accessing {@link #value} directly.
     ;;
    #_public
    (§ method long longValue(§ args ))
    (§ block
        (§ return this.value)
    )

    #_private
    #_static
    #_final
    (§ field MonetaryFormat FRIENDLY_FORMAT = MonetaryFormat.BTC.minDecimals(§ pars 2).repeatOptionalDecimals(§ pars 1, 6).postfixCode(§ pars ))

    ;;;
     ; Returns the value as a 0.12 type string.  More digits after the decimal place will be used
     ; if necessary, but two will always be present.
     ;;
    #_public
    (§ method String toFriendlyString(§ args ))
    (§ block
        (§ return FRIENDLY_FORMAT.format(§ pars this).toString(§ pars ))
    )

    #_private
    #_static
    #_final
    (§ field MonetaryFormat PLAIN_FORMAT = MonetaryFormat.BTC.minDecimals(§ pars 0).repeatOptionalDecimals(§ pars 1, 8).noCode(§ pars ))

    ;;;
     ; Returns the value as a plain string denominated in BTC.
     ; The result is unformatted with no trailing zeroes.
     ; For instance, a value of 150000 satoshis gives an output string of "0.0015" BTC.
     ;;
    #_public
    (§ method String toPlainString(§ args ))
    (§ block
        (§ return PLAIN_FORMAT.format(§ pars this).toString(§ pars ))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return Long.toString(§ pars value))
    )

    #_override
    #_public
    (§ method boolean equals(§ args #_final Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return (§ expr this.value == (§ expr (§ cast Coin)o).value))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return (§ cast int)this.value)
    )

    #_override
    #_public
    (§ method int compareTo(§ args #_final Coin other))
    (§ block
        (§ return Longs.compare(§ pars this.value, other.value))
    )
)

#_(ns org.bitcoinj.core #_"Context"
    (:import [com.google.common.base Preconditions]
             [org.slf4j *]))

;; TODO: Finish adding Context c'tors to all the different objects so we can start deprecating the versions that take NetworkParameters.
;; TODO: Add a working directory notion to Context and make various subsystems that want to use files default to that directory (e.g. Orchid, block stores, wallet, etc).
;; TODO: Auto-register the block chain object here, and then use it in the (newly deprecated) TransactionConfidence.getDepthInBlocks() method:
;;       the new version should take an AbstractBlockChain specifically.
;;       Also use the block chain object reference from the context in PeerGroup and remove the other constructors, as it's easy to forget to wire things up.
;; TODO: Move Threading.USER_THREAD to here and leave behind just a source code stub.  Allow different instantiations of the library to use different user threads.
;; TODO: Keep a URI to where library internal data files can be found, to abstract over the lack of JAR files on Android.
;; TODO: Stash anything else that resembles global library configuration in here and use it to clean up the rest of the API without breaking people.
;; TODO: Move the TorClient into Context, so different parts of the library can read data over Tor without having to request it directly. (or maybe a general socket factory??)

;;;
 ; <p>The Context object holds various objects and pieces of configuration that are scoped to a specific instantiation of
 ; bitcoinj for a specific network.  You can get an instance of this class through calling {@link #get()}.</p>
 ;
 ; <p>Context is new in 0.13 and the library is currently in a transitional period: you should create a Context that
 ; wraps your chosen network parameters before using the rest of the library.  However if you don't, things will still
 ; work as a Context will be created for you and stashed in thread local storage.  The context is then propagated between
 ; library created threads as needed.  This automagical propagation and creation is a temporary mechanism: one day it
 ; will be removed to avoid confusing edge cases that could occur if the developer does not fully understand it e.g.
 ; in the case where multiple instances of the library are in use simultaneously.</p>
 ;;
#_public
(§ class Context
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars Context.class))

    #_public
    #_static
    #_final
    (§ field int DEFAULT_EVENT_HORIZON = 100)

    #_final
    #_private
    (§ field TxConfidenceTable confidenceTable)
    #_final
    #_private
    (§ field NetworkParameters params)
    #_final
    #_private
    (§ field int eventHorizon)
    #_final
    #_private
    (§ field boolean ensureMinRequiredFee)
    #_final
    #_private
    (§ field Coin feePerKb)

    ;;;
     ; Creates a new context object.  For now, this will be done for you by the framework.  Eventually you will be
     ; expected to do this yourself in the same manner as fetching a NetworkParameters object (at the start of your app).
     ;
     ; @param params The network parameters that will be associated with this context.
     ;;
    #_public
    (§ constructor Context(§ args NetworkParameters params))
    (§ block
        (§ this (§ pars params, DEFAULT_EVENT_HORIZON, Transaction.DEFAULT_TX_FEE, true))
    )

    ;;;
     ; Creates a new custom context object.  This is mainly meant for unit tests for now.
     ;
     ; @param params The network parameters that will be associated with this context.
     ; @param eventHorizon Number of blocks after which the library will delete data and be unable to always process reorgs (see {@link #getEventHorizon()}).
     ; @param feePerKb The default fee per 1000 bytes of transaction data to pay when completing transactions.  For details, see {@link SendRequest#feePerKb}.
     ; @param ensureMinRequiredFee Whether to ensure the minimum required fee by default when completing transactions.  For details, see {@link SendRequest#ensureMinRequiredFee}.
     ;;
    #_public
    (§ constructor Context(§ args NetworkParameters params, int eventHorizon, Coin feePerKb, boolean ensureMinRequiredFee))
    (§ block
        (§ call log.info(§ pars "Creating bitcoinj {} context.", VersionMessage.BITCOINJ_VERSION))
        (§ ass this.confidenceTable = new TxConfidenceTable(§ pars ))
        (§ ass this.params = params)
        (§ ass this.eventHorizon = eventHorizon)
        (§ ass this.ensureMinRequiredFee = ensureMinRequiredFee)
        (§ ass this.feePerKb = feePerKb)
        (§ ass lastConstructed = this)
        (§ call slot.set(§ pars this))
    )

    #_private
    #_static
    #_volatile
    (§ field Context lastConstructed)
    #_private
    #_static
    (§ field boolean isStrictMode)
    #_private
    #_static
    #_final
    (§ field ThreadLocal<Context> slot = new ThreadLocal<>(§ pars ))

    ;;;
     ; Returns the current context that is associated with the <b>calling thread</b>.  BitcoinJ is an API that has thread
     ; affinity: much like OpenGL it expects each thread that accesses it to have been configured with a global Context
     ; object.  This method returns that.  Note that to help you develop, this method will <i>also</i> propagate whichever
     ; context was created last onto the current thread, if it's missing.  However it will print an error when doing so
     ; because propagation of contexts is meant to be done manually: this is so two libraries or subsystems that
     ; independently use bitcoinj (or possibly alt coin forks of it) can operate correctly.
     ;
     ; @throws java.lang.IllegalStateException if no context exists at all or if we are in strict mode and there is no context.
     ;;
    #_public
    #_static
    (§ method Context get(§ args ))
    (§ block
        (§ var Context tls = slot.get(§ pars ))
        (§ if (§ expr tls == nil))
        (§ block
            (§ if (§ expr isStrictMode))
            (§ block
                (§ call log.error(§ pars "Thread is missing a bitcoinj context."))
                (§ call log.error(§ pars "You should use Context.propagate() or a ContextPropagatingThreadFactory."))
                (§ throw (§ new IllegalStateException(§ pars "missing context")))
            )
            (§ if (§ expr lastConstructed == nil))
            (§ block
                (§ throw (§ new IllegalStateException(§ pars "You must construct a Context object before using bitcoinj!")))
            )
            (§ call slot.set(§ pars lastConstructed))
            (§ call log.error(§ pars "Performing thread fixup: you are accessing bitcoinj via a thread that has not had any context set on it."))
            (§ call log.error(§ pars "This error has been corrected for, but doing this makes your app less robust."))
            (§ call log.error(§ pars "You should use Context.propagate() or a ContextPropagatingThreadFactory."))
            (§ call log.error(§ pars "Please refer to the user guide for more information about this."))
            (§ call log.error(§ pars "Thread name is {}.", Thread.currentThread(§ pars ).getName(§ pars )))
            ;; TODO: Actually write the user guide section about this.
            (§ return lastConstructed)
        )

        (§ return tls)
    )

    ;;;
     ; Require that new threads use {@link #propagate(Context)} or {@link org.bitcoinj.utils.ContextPropagatingThreadFactory},
     ; rather than using a heuristic for the desired context.
     ;;
    #_public
    #_static
    (§ method void enableStrictMode(§ args ))
    (§ block
        (§ ass isStrictMode = true)
    )

    ;; A temporary internal shim designed to help us migrate internally in a way that doesn't wreck source compatibility.
    #_public
    #_static
    (§ method Context getOrCreate(§ args NetworkParameters params))
    (§ block
        (§ var Context context)
        (§ try )
        (§ block
            (§ ass context = get(§ pars ))
        )
        (§ catch (§ args IllegalStateException e))
        (§ block
            (§ call log.warn(§ pars "Implicitly creating context. This is a migration step and this message will eventually go away."))
            (§ ass context = new Context(§ pars params))
            (§ return context)
        )
        (§ if (§ expr context.getParams(§ pars ) != params))
        (§ block
            (§ throw (§ new IllegalStateException(§ pars "Context does not match implicit network params: " + context.getParams(§ pars ) + " vs " + params)))
        )
        (§ return context)
    )

    ;;;
     ; Sets the given context as the current thread context.  You should use this if you create your own threads that
     ; want to create core BitcoinJ objects.  Generally, if a class can accept a Context in its constructor and might
     ; be used (even indirectly) by a thread, you will want to call this first.  Your task may be simplified by using
     ; a {@link org.bitcoinj.utils.ContextPropagatingThreadFactory}.
     ;;
    #_public
    #_static
    (§ method void propagate(§ args Context context))
    (§ block
        (§ call slot.set(§ pars Preconditions.checkNotNull(§ pars context)))
    )

    ;;;
     ; Returns the {@link TxConfidenceTable} created by this context.  The pool tracks advertised
     ; and downloaded transactions so their confidence can be measured as a proportion of how many peers announced it.
     ; With an un-tampered with internet connection, the more peers announce a transaction the more confidence you can
     ; have that it's really valid.
     ;;
    #_public
    (§ method TxConfidenceTable getConfidenceTable(§ args ))
    (§ block
        (§ return confidenceTable)
    )

    ;;;
     ; Returns the {@link org.bitcoinj.core.NetworkParameters} specified when this context was (auto) created.  The
     ; network parameters defines various hard coded constants for a specific instance of a Bitcoin network, such as
     ; main net, testnet, etc.
     ;;
    #_public
    (§ method NetworkParameters getParams(§ args ))
    (§ block
        (§ return params)
    )

    ;;;
     ; The event horizon is the number of blocks after which various bits of the library consider a transaction to be
     ; so confirmed that it's safe to delete data.  Re-orgs larger than the event horizon will not be correctly
     ; processed, so the default value is high (100).
     ;;
    #_public
    (§ method int getEventHorizon(§ args ))
    (§ block
        (§ return eventHorizon)
    )

    ;;;
     ; The default fee per 1000 bytes of transaction data to pay when completing transactions.  For details, see {@link SendRequest#feePerKb}.
     ;;
    #_public
    (§ method Coin getFeePerKb(§ args ))
    (§ block
        (§ return feePerKb)
    )

    ;;;
     ; Whether to ensure the minimum required fee by default when completing transactions.  For details, see {@link SendRequest#ensureMinRequiredFee}.
     ;;
    #_public
    (§ method boolean isEnsureMinRequiredFee(§ args ))
    (§ block
        (§ return ensureMinRequiredFee)
    )
)

#_(ns org.bitcoinj.core #_"DummySerializer"
    (:import [java.io IOException OutputStream]
             [java.nio BufferUnderflowException ByteBuffer]))

;;;
 ; Dummy serializer used ONLY for objects which do not have network parameters set.
 ;;
(§ class DummySerializer extends MessageSerializer
    #_public
    #_static
    #_final
    (§ field DummySerializer DEFAULT = new DummySerializer(§ pars ))

    #_private
    #_static
    #_final
    (§ field String DEFAULT_EXCEPTION_MESSAGE = "Dummy serializer cannot serialize/deserialize objects as it does not know which network they belong to.")

    #_public
    (§ constructor DummySerializer(§ args ))
    (§ block
    )

    #_override
    #_public
    (§ method Message deserialize(§ args ByteBuffer in))
        (§ throws UnsupportedOperationException)
    (§ block
        (§ throw (§ new UnsupportedOperationException(§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method BitcoinSerializer.BitcoinPacketHeader deserializeHeader(§ args ByteBuffer in))
        (§ throws UnsupportedOperationException)
    (§ block
        (§ throw (§ new UnsupportedOperationException(§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method Message deserializePayload(§ args BitcoinSerializer.BitcoinPacketHeader header, ByteBuffer in))
        (§ throws UnsupportedOperationException)
    (§ block
        (§ throw (§ new UnsupportedOperationException(§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method boolean isParseRetainMode(§ args ))
    (§ block
        (§ return false)
    )

    #_override
    #_public
    (§ method AddressMessage makeAddressMessage(§ args byte[] payloadBytes, int length))
        (§ throws UnsupportedOperationException)
    (§ block
        (§ throw (§ new UnsupportedOperationException(§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method Message makeAlertMessage(§ args byte[] payloadBytes))
        (§ throws UnsupportedOperationException)
    (§ block
        (§ throw (§ new UnsupportedOperationException(§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method Block makeBlock(§ args byte[] payloadBytes, int offset, int length))
        (§ throws UnsupportedOperationException)
    (§ block
        (§ throw (§ new UnsupportedOperationException(§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method Message makeBloomFilter(§ args byte[] payloadBytes))
        (§ throws UnsupportedOperationException)
    (§ block
        (§ throw (§ new UnsupportedOperationException(§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method FilteredBlock makeFilteredBlock(§ args byte[] payloadBytes))
        (§ throws UnsupportedOperationException)
    (§ block
        (§ throw (§ new UnsupportedOperationException(§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method InventoryMessage makeInventoryMessage(§ args byte[] payloadBytes, int length))
        (§ throws UnsupportedOperationException)
    (§ block
        (§ throw (§ new UnsupportedOperationException(§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method Transaction makeTransaction(§ args byte[] payloadBytes, int offset, int length, byte[] hash))
        (§ throws UnsupportedOperationException)
    (§ block
        (§ throw (§ new UnsupportedOperationException(§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method void seekPastMagicBytes(§ args ByteBuffer in))
        (§ throws BufferUnderflowException)
    (§ block
        (§ throw (§ new UnsupportedOperationException(§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method void serialize(§ args String name, byte[] message, OutputStream out))
        (§ throws IOException)
    (§ block
        (§ throw (§ new UnsupportedOperationException(§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method void serialize(§ args Message message, OutputStream out))
        (§ throws IOException)
    (§ block
        (§ throw (§ new UnsupportedOperationException(§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )
)

#_(ns org.bitcoinj.core #_"ECKey"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.math BigInteger]
             [java.nio.charset Charset]
             [java.security SecureRandom SignatureException]
             [java.util Arrays Comparator])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base MoreObjects Objects Preconditions]
             [com.google.common.primitives Ints UnsignedBytes]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.asn1 *]
             [org.spongycastle.asn1.x9 X9ECParameters X9IntegerConverter]
             [org.spongycastle.crypto AsymmetricCipherKeyPair]
             [org.spongycastle.crypto.digests SHA256Digest]
             [org.spongycastle.crypto.ec CustomNamedCurves]
             [org.spongycastle.crypto.generators ECKeyPairGenerator]
             [org.spongycastle.crypto.params *]
             [org.spongycastle.crypto.signers ECDSASigner HMacDSAKCalculator]
             [org.spongycastle.math.ec ECAlgorithms ECPoint FixedPointCombMultiplier FixedPointUtil]
             [org.spongycastle.math.ec.custom.sec SecP256K1Curve]
             [org.spongycastle.util.encoders Base64])
   (:require [org.bitcoinj.crypto *]
             [org.bitcoinj.wallet Protos Wallet]))

;; TODO: Move this class to tracking compression state itself.
;; The Bouncy Castle guys are deprecating their own tracking of the compression state.

;;;
 ; <p>Represents an elliptic curve public and (optionally) private key, usable for digital signatures but not encryption.
 ; Creating a new ECKey with the empty constructor will generate a new random keypair.  Other static methods can be used
 ; when you already have the public or private parts.  If you create a key with only the public part, you can check
 ; signatures but not create them.</p>
 ;
 ; <p>ECKey also provides access to Bitcoin Core compatible text message signing, as accessible via the UI or JSON-RPC.
 ; This is slightly different to signing raw bytes - if you want to sign your own data and it won't be exposed as
 ; text to people, you don't want to use this.  If in doubt, ask on the mailing list.</p>
 ;
 ; <p>The ECDSA algorithm supports <i>key recovery</i> in which a signature plus a couple of discriminator bits can
 ; be reversed to find the public key used to calculate it.  This can be convenient when you have a message and a
 ; signature and want to find out who signed it, rather than requiring the user to provide the expected identity.</p>
 ;
 ; <p>This class supports a variety of serialization forms.  The methods that accept/return byte arrays serialize
 ; private keys as raw byte arrays and public keys using the SEC standard byte encoding for public keys.  Signatures
 ; are encoded using ASN.1/DER inside the Bitcoin protocol.</p>
 ;
 ; <p>A key can be <i>compressed</i> or <i>uncompressed</i>.  This refers to whether the public key is represented
 ; when encoded into bytes as an (x, y) coordinate on the elliptic curve, or whether it's represented as just an X
 ; co-ordinate and an extra byte that carries a sign bit.  With the latter form the Y coordinate can be calculated
 ; dynamically, however, <b>because the binary serialization is different the address of a key changes if its
 ; compression status is changed</b>.  If you deviate from the defaults it's important to understand this: money sent
 ; to a compressed version of the key will have a different address to the same key in uncompressed form.  Whether
 ; a public key is compressed or not is recorded in the SEC binary serialisation format, and preserved in a flag in
 ; this class so round-tripping preserves state.  Unless you're working with old software or doing unusual things, you
 ; can usually ignore the compressed/uncompressed distinction.</p>
 ;;
#_public
(§ class ECKey implements EncryptableItem
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars ECKey.class))

    ;;; Sorts oldest keys first, newest last. ;;
    #_public
    #_static
    #_final
    (§ field Comparator<ECKey> AGE_COMPARATOR = new Comparator<ECKey>(§ pars )
        (§ anon
            #_override
            #_public
            (§ method int compare(§ args ECKey k1, ECKey k2))
            (§ block
                (§ if (§ expr k1.creationTimeSeconds == k2.creationTimeSeconds))
                (§ block
                    (§ return 0)
                )

                (§ return (§ expr k1.creationTimeSeconds < k2.creationTimeSeconds) ? -1 :else 1)
            )
        ))

    ;;; Compares pub key bytes using {@link com.google.common.primitives.UnsignedBytes#lexicographicalComparator()}. ;;
    #_public
    #_static
    #_final
    (§ field Comparator<ECKey> PUBKEY_COMPARATOR = new Comparator<ECKey>(§ pars )
        (§ anon
            #_private
            (§ field Comparator<byte[]> comparator = UnsignedBytes.lexicographicalComparator(§ pars ))

            #_override
            #_public
            (§ method int compare(§ args ECKey k1, ECKey k2))
            (§ block
                (§ return comparator.compare(§ pars k1.getPubKey(§ pars ), k2.getPubKey(§ pars )))
            )
        ))

    ;; The parameters of the secp256k1 curve that Bitcoin uses.
    #_private
    #_static
    #_final
    (§ field X9ECParameters CURVE_PARAMS = CustomNamedCurves.getByName(§ pars "secp256k1"))

    ;;; The parameters of the secp256k1 curve that Bitcoin uses. ;;
    #_public
    #_static
    #_final
    (§ field ECDomainParameters CURVE)

    ;;;
     ; Equal to CURVE.getN().shiftRight(1), used for canonicalising the S value of a signature.
     ; If you aren't sure what this is about, you can ignore it.
     ;;
    #_public
    #_static
    #_final
    (§ field BigInteger HALF_CURVE_ORDER)

    #_private
    #_static
    #_final
    (§ field SecureRandom secureRandom)

    #_static
    (§ block
        ;; Init proper random number generator, as some old Android installations have bugs that make it unsecure.
        (§ if (§ expr Utils.isAndroidRuntime(§ pars )))
        (§ block
            (§ call (§ new LinuxSecureRandom(§ pars )))
        )

        ;; Tell Bouncy Castle to precompute data that's needed during secp256k1 calculations.  Increasing the width
        ;; number makes calculations faster, but at a cost of extra memory usage and with decreasing returns.  12 was
        ;; picked after consulting with the BC team.
        (§ call FixedPointUtil.precompute(§ pars CURVE_PARAMS.getG(§ pars ), 12))
        (§ ass CURVE = new ECDomainParameters(§ pars CURVE_PARAMS.getCurve(§ pars ), CURVE_PARAMS.getG(§ pars ), CURVE_PARAMS.getN(§ pars ), CURVE_PARAMS.getH(§ pars )))
        (§ ass HALF_CURVE_ORDER = CURVE_PARAMS.getN(§ pars ).shiftRight(§ pars 1))
        (§ ass secureRandom = new SecureRandom(§ pars ))
    )

    ;; The two parts of the key.  If "priv" is set, "pub" can always be calculated.  If "pub" is set but not "priv", we
    ;; can only verify signatures not make them.
    #_protected
    #_final
    (§ field BigInteger priv) ;; A field element.
    #_protected
    #_final
    (§ field LazyECPoint pub)

    ;; Creation time of the key in seconds since the epoch, or zero if the key was deserialized from a version that did
    ;; not have this field.
    #_protected
    (§ field long creationTimeSeconds)

    #_protected
    (§ field KeyCrypter keyCrypter)
    #_protected
    (§ field EncryptedData encryptedPrivateKey)

    #_private
    (§ field byte[] pubKeyHash)

    ;;;
     ; Generates an entirely new keypair.  Point compression is used so the resulting public key will be 33 bytes
     ; (32 for the co-ordinate and 1 byte to represent the y bit).
     ;;
    #_public
    (§ constructor ECKey(§ args ))
    (§ block
        (§ this (§ pars secureRandom))
    )

    ;;;
     ; Generates an entirely new keypair with the given {@link SecureRandom} object.  Point compression is used so the
     ; resulting public key will be 33 bytes (32 for the co-ordinate and 1 byte to represent the y bit).
     ;;
    #_public
    (§ constructor ECKey(§ args SecureRandom secureRandom))
    (§ block
        (§ var ECKeyPairGenerator generator = new ECKeyPairGenerator(§ pars ))
        (§ var ECKeyGenerationParameters keygenParams = new ECKeyGenerationParameters(§ pars CURVE, secureRandom))
        (§ call generator.init(§ pars keygenParams))
        (§ var AsymmetricCipherKeyPair keypair = generator.generateKeyPair(§ pars ))
        (§ var ECPrivateKeyParameters privParams = (§ cast ECPrivateKeyParameters)keypair.getPrivate(§ pars ))
        (§ var ECPublicKeyParameters pubParams = (§ cast ECPublicKeyParameters)keypair.getPublic(§ pars ))
        (§ ass priv = privParams.getD(§ pars ))
        (§ ass pub = new LazyECPoint(§ pars CURVE.getCurve(§ pars ), pubParams.getQ(§ pars ).getEncoded(§ pars true)))
        (§ ass creationTimeSeconds = Utils.currentTimeSeconds(§ pars ))
    )

    #_protected
    (§ constructor ECKey(§ args #_nilable BigInteger priv, ECPoint pub))
    (§ block
        (§ this (§ pars priv, new LazyECPoint(§ pars Preconditions.checkNotNull(§ pars pub))))
    )

    #_protected
    (§ constructor ECKey(§ args #_nilable BigInteger priv, LazyECPoint pub))
    (§ block
        (§ if (§ expr priv != nil))
        (§ block
            (§ call Preconditions.checkArgument(§ pars priv.bitLength(§ pars ) <= (§ expr 32 << 3), "private key exceeds 32 bytes: {} bits", priv.bitLength(§ pars )))
            ;; Try and catch buggy callers or bad key imports, etc.  Zero and one are special because these are often
            ;; used as sentinel values and because scripting languages have a habit of auto-casting true and false to
            ;; 1 and 0 or vice-versa.  Type confusion bugs could therefore result in private keys with these values.
            (§ call Preconditions.checkArgument(§ pars !priv.equals(§ pars BigInteger.ZERO)))
            (§ call Preconditions.checkArgument(§ pars !priv.equals(§ pars BigInteger.ONE)))
        )
        (§ ass this.priv = priv)
        (§ ass this.pub = Preconditions.checkNotNull(§ pars pub))
    )

    ;;;
     ; Utility for compressing an elliptic curve point.  Returns the same point if it's already compressed.
     ; See the ECKey class docs for a discussion of point compression.
     ;;
    #_public
    #_static
    (§ method ECPoint compressPoint(§ args ECPoint point))
    (§ block
        (§ return getPointWithCompression(§ pars point, true))
    )

    #_public
    #_static
    (§ method LazyECPoint compressPoint(§ args LazyECPoint point))
    (§ block
        (§ return point.isCompressed(§ pars ) ? point :else new LazyECPoint(§ pars compressPoint(§ pars point.get(§ pars ))))
    )

    ;;;
     ; Utility for decompressing an elliptic curve point.  Returns the same point if it's already compressed.
     ; See the ECKey class docs for a discussion of point compression.
     ;;
    #_public
    #_static
    (§ method ECPoint decompressPoint(§ args ECPoint point))
    (§ block
        (§ return getPointWithCompression(§ pars point, false))
    )

    #_public
    #_static
    (§ method LazyECPoint decompressPoint(§ args LazyECPoint point))
    (§ block
        (§ return !point.isCompressed(§ pars ) ? point :else new LazyECPoint(§ pars decompressPoint(§ pars point.get(§ pars ))))
    )

    #_private
    #_static
    (§ method ECPoint getPointWithCompression(§ args ECPoint point, boolean compressed))
    (§ block
        (§ if (§ expr point.isCompressed(§ pars ) == compressed))
        (§ block
            (§ return point)
        )

        (§ ass point = point.normalize(§ pars ))
        (§ var BigInteger x = point.getAffineXCoord(§ pars ).toBigInteger(§ pars ))
        (§ var BigInteger y = point.getAffineYCoord(§ pars ).toBigInteger(§ pars ))
        (§ return CURVE.getCurve(§ pars ).createPoint(§ pars x, y, compressed))
    )

    ;;;
     ; Construct an ECKey from an ASN.1 encoded private key.  These are produced by OpenSSL and stored by Bitcoin
     ; Core in its wallet.  Note that this is slow because it requires an EC point multiply.
     ;;
    #_public
    #_static
    (§ method ECKey fromASN1(§ args byte[] asn1privkey))
    (§ block
        (§ return extractKeyFromASN1(§ pars asn1privkey))
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow).  The resulting
     ; public key is compressed.
     ;;
    #_public
    #_static
    (§ method ECKey fromPrivate(§ args BigInteger privKey))
    (§ block
        (§ return fromPrivate(§ pars privKey, true))
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow), either
     ; compressed or not.
     ;;
    #_public
    #_static
    (§ method ECKey fromPrivate(§ args BigInteger privKey, boolean compressed))
    (§ block
        (§ var ECPoint point = publicPointFromPrivate(§ pars privKey))
        (§ return (§ new ECKey(§ pars privKey, getPointWithCompression(§ pars point, compressed))))
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow).  The resulting
     ; public key is compressed.
     ;;
    #_public
    #_static
    (§ method ECKey fromPrivate(§ args byte[] privKeyBytes))
    (§ block
        (§ return fromPrivate(§ pars (§ new BigInteger(§ pars 1, privKeyBytes))))
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow), either
     ; compressed or not.
     ;;
    #_public
    #_static
    (§ method ECKey fromPrivate(§ args byte[] privKeyBytes, boolean compressed))
    (§ block
        (§ return fromPrivate(§ pars (§ new BigInteger(§ pars 1, privKeyBytes)), compressed))
    )

    ;;;
     ; Creates an ECKey that simply trusts the caller to ensure that point is really the result of multiplying the
     ; generator point by the private key.  This is used to speed things up when you know you have the right values
     ; already.  The compression state of pub will be preserved.
     ;;
    #_public
    #_static
    (§ method ECKey fromPrivateAndPrecalculatedPublic(§ args BigInteger priv, ECPoint pub))
    (§ block
        (§ return (§ new ECKey(§ pars priv, pub)))
    )

    ;;;
     ; Creates an ECKey that simply trusts the caller to ensure that point is really the result of multiplying the
     ; generator point by the private key.  This is used to speed things up when you know you have the right values
     ; already.  The compression state of the point will be preserved.
     ;;
    #_public
    #_static
    (§ method ECKey fromPrivateAndPrecalculatedPublic(§ args byte[] priv, byte[] pub))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars priv))
        (§ call Preconditions.checkNotNull(§ pars pub))
        (§ return (§ new ECKey(§ pars (§ new BigInteger(§ pars 1, priv)), CURVE.getCurve(§ pars ).decodePoint(§ pars pub))))
    )

    ;;;
     ; Creates an ECKey that cannot be used for signing, only verifying signatures, from the given point.
     ; The compression state of pub will be preserved.
     ;;
    #_public
    #_static
    (§ method ECKey fromPublicOnly(§ args ECPoint pub))
    (§ block
        (§ return (§ new ECKey(§ pars nil, pub)))
    )

    ;;;
     ; Creates an ECKey that cannot be used for signing, only verifying signatures, from the given encoded point.
     ; The compression state of pub will be preserved.
     ;;
    #_public
    #_static
    (§ method ECKey fromPublicOnly(§ args byte[] pub))
    (§ block
        (§ return (§ new ECKey(§ pars nil, CURVE.getCurve(§ pars ).decodePoint(§ pars pub))))
    )

    ;;;
     ; Returns a copy of this key, but with the public point represented in uncompressed form.  Normally you would
     ; never need this: it's for specialised scenarios or when backwards compatibility in encoded form is necessary.
     ;;
    #_public
    (§ method ECKey decompress(§ args ))
    (§ block
        (§ return pub.isCompressed(§ pars ) ? new ECKey(§ pars priv, decompressPoint(§ pars pub.get(§ pars ))) :else this)
    )

    ;;;
     ; Creates an ECKey given only the private key bytes.  This is the same as using the BigInteger constructor, but
     ; is more convenient if you are importing a key from elsewhere.  The public key will be automatically derived
     ; from the private key.
     ;;
    #_deprecated
    #_public
    (§ constructor ECKey(§ args #_nilable byte[] privKeyBytes, #_nilable byte[] pubKey))
    (§ block
        (§ this (§ pars (§ expr privKeyBytes != nil) ? new BigInteger(§ pars 1, privKeyBytes) :else nil, pubKey))
    )

    ;;;
     ; Create a new ECKey with an encrypted private key, a public key and a KeyCrypter.
     ;
     ; @param encryptedPrivateKey The encrypted private key.
     ; @param pubKey The public key.
     ; @param keyCrypter The KeyCrypter that will be used, with an AES key, to encrypt and decrypt the private key.
     ;;
    #_deprecated
    #_public
    (§ constructor ECKey(§ args EncryptedData encryptedPrivateKey, byte[] pubKey, KeyCrypter keyCrypter))
    (§ block
        (§ this (§ pars (§ cast byte[])nil, pubKey))

        (§ ass this.keyCrypter = Preconditions.checkNotNull(§ pars keyCrypter))
        (§ ass this.encryptedPrivateKey = encryptedPrivateKey)
    )

    ;;;
     ; Constructs a key that has an encrypted private component.  The given object wraps encrypted bytes and an
     ; initialization vector.  Note that the key will not be decrypted during this call: the returned ECKey is
     ; unusable for signing unless a decryption key is supplied.
     ;;
    #_public
    #_static
    (§ method ECKey fromEncrypted(§ args EncryptedData encryptedPrivateKey, KeyCrypter crypter, byte[] pubKey))
    (§ block
        (§ var ECKey key = fromPublicOnly(§ pars pubKey))
        (§ ass key.encryptedPrivateKey = Preconditions.checkNotNull(§ pars encryptedPrivateKey))
        (§ ass key.keyCrypter = Preconditions.checkNotNull(§ pars crypter))
        (§ return key)
    )

    ;;;
     ; Creates an ECKey given either the private key only, the public key only, or both.  If only the private key
     ; is supplied, the public key will be calculated from it (this is slow).  If both are supplied, it's assumed
     ; the public key already correctly matches the private key.  If only the public key is supplied, this ECKey
     ; cannot be used for signing.
     ; @param compressed If set to true and pubKey is null, the derived public key will be in compressed form.
     ;;
    #_deprecated
    #_public
    (§ constructor ECKey(§ args #_nilable BigInteger privKey, #_nilable byte[] pubKey, boolean compressed))
    (§ block
        (§ if (§ expr privKey == nil && pubKey == nil))
        (§ block
            (§ throw (§ new IllegalArgumentException(§ pars "ECKey requires at least private or public key")))
        )
        (§ ass this.priv = privKey)
        (§ if (§ expr pubKey == nil))
        (§ block
            ;; Derive public from private.
            (§ var ECPoint point = publicPointFromPrivate(§ pars privKey))
            (§ ass point = getPointWithCompression(§ pars point, compressed))
            (§ ass this.pub = new LazyECPoint(§ pars point))
        )
        (§ else )
        (§ block
            ;; We expect the pubkey to be in regular encoded form, just as a BigInteger.
            ;; Therefore the first byte is a special marker byte.
            ;; TODO: This is probably not a useful API and may be confusing.
            (§ ass this.pub = new LazyECPoint(§ pars CURVE.getCurve(§ pars ), pubKey))
        )
    )

    ;;;
     ; Creates an ECKey given either the private key only, the public key only, or both.  If only the private key
     ; is supplied, the public key will be calculated from it (this is slow).  If both are supplied, it's assumed
     ; the public key already correctly matches the public key.  If only the public key is supplied, this ECKey cannot
     ; be used for signing.
     ;;
    #_deprecated
    #_private
    (§ constructor ECKey(§ args #_nilable BigInteger privKey, #_nilable byte[] pubKey))
    (§ block
        (§ this (§ pars privKey, pubKey, false))
    )

    ;;;
     ; Returns true if this key doesn't have unencrypted access to private key bytes.  This may be because
     ; it was never given any private key bytes to begin with (a watching key), or because the key is encrypted.
     ; You can use {@link #isEncrypted()} to tell the cases apart.
     ;;
    #_public
    (§ method boolean isPubKeyOnly(§ args ))
    (§ block
        (§ return (§ expr priv == nil))
    )

    ;;;
     ; Returns true if this key has unencrypted access to private key bytes.
     ; Does the opposite of {@link #isPubKeyOnly()}.
     ;;
    #_public
    (§ method boolean hasPrivKey(§ args ))
    (§ block
        (§ return (§ expr priv != nil))
    )

    ;;; Returns true if this key is watch only, meaning it has a public key but no private key. ;;
    #_public
    (§ method boolean isWatching(§ args ))
    (§ block
        (§ return (§ expr isPubKeyOnly(§ pars ) && !isEncrypted(§ pars )))
    )

    ;;;
     ; Output this ECKey as an ASN.1 encoded private key, as understood by OpenSSL or used by Bitcoin Core
     ; in its wallet storage format.
     ; @throws org.bitcoinj.core.ECKey.MissingPrivateKeyException if the private key is missing or encrypted.
     ;;
    #_public
    (§ method byte[] toASN1(§ args ))
    (§ block
        (§ try )
        (§ block
            (§ var byte[] privKeyBytes = getPrivKeyBytes(§ pars ))
            (§ var ByteArrayOutputStream baos = new ByteArrayOutputStream(§ pars 400))

            ;; ASN1_SEQUENCE(EC_PRIVATEKEY) = {
            ;;   ASN1_SIMPLE(EC_PRIVATEKEY, version, LONG),
            ;;   ASN1_SIMPLE(EC_PRIVATEKEY, privateKey, ASN1_OCTET_STRING),
            ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, parameters, ECPKPARAMETERS, 0),
            ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, publicKey, ASN1_BIT_STRING, 1)
            ;; } ASN1_SEQUENCE_END(EC_PRIVATEKEY)
            (§ var DERSequenceGenerator seq = new DERSequenceGenerator(§ pars baos))
            (§ call seq.addObject(§ pars (§ new ASN1Integer(§ pars 1)))) ;; version
            (§ call seq.addObject(§ pars (§ new DEROctetString(§ pars privKeyBytes))))
            (§ call seq.addObject(§ pars (§ new DERTaggedObject(§ pars 0, CURVE_PARAMS.toASN1Primitive(§ pars )))))
            (§ call seq.addObject(§ pars (§ new DERTaggedObject(§ pars 1, new DERBitString(§ pars getPubKey(§ pars ))))))
            (§ call seq.close(§ pars ))
            (§ return baos.toByteArray(§ pars ))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen, writing to memory stream.
        )
    )

    ;;;
     ; Returns public key bytes from the given private key.  To convert a byte array into a BigInteger, use <tt>new BigInteger(1, bytes)</tt>.
     ;;
    #_public
    #_static
    (§ method byte[] publicKeyFromPrivate(§ args BigInteger privKey, boolean compressed))
    (§ block
        (§ return publicPointFromPrivate(§ pars privKey).getEncoded(§ pars compressed))
    )

    ;;;
     ; Returns public key point from the given private key.  To convert a byte array into a BigInteger, use <tt>new BigInteger(1, bytes)</tt>.
     ;;
    #_public
    #_static
    (§ method ECPoint publicPointFromPrivate(§ args BigInteger privKey))
    (§ block
        ;;
         ; TODO: FixedPointCombMultiplier currently doesn't support scalars longer than the group order,
         ; but that could change in future versions.
         ;;
        (§ if (§ expr CURVE.getN(§ pars ).bitLength(§ pars ) < privKey.bitLength(§ pars )))
        (§ block
            (§ ass privKey = privKey.mod(§ pars CURVE.getN(§ pars )))
        )

        (§ return (§ new FixedPointCombMultiplier(§ pars )).multiply(§ pars CURVE.getG(§ pars ), privKey))
    )

    ;;; Gets the hash160 form of the public key (as seen in addresses). ;;
    #_public
    (§ method byte[] getPubKeyHash(§ args ))
    (§ block
        (§ if (§ expr pubKeyHash == nil))
        (§ block
            (§ ass pubKeyHash = Utils.sha256hash160(§ pars this.pub.getEncoded(§ pars )))
        )

        (§ return pubKeyHash)
    )

    ;;;
     ; Gets the raw public key value.  This appears in transaction scriptSigs.  Note that this is <b>not</b> the same
     ; as the pubKeyHash/address.
     ;;
    #_public
    (§ method byte[] getPubKey(§ args ))
    (§ block
        (§ return pub.getEncoded(§ pars ))
    )

    ;;; Gets the public key in the form of an elliptic curve point object from Bouncy Castle. ;;
    #_public
    (§ method ECPoint getPubKeyPoint(§ args ))
    (§ block
        (§ return pub.get(§ pars ))
    )

    ;;;
     ; Gets the private key in the form of an integer field element.  The public key is derived by performing EC
     ; point addition this number of times (i.e. point multiplying).
     ;
     ; @throws java.lang.IllegalStateException if the private key bytes are not available.
     ;;
    #_public
    (§ method BigInteger getPrivKey(§ args ))
    (§ block
        (§ if (§ expr priv == nil))
        (§ block
            (§ throw (§ new MissingPrivateKeyException(§ pars )))
        )

        (§ return priv)
    )

    ;;;
     ; Returns whether this key is using the compressed form or not.  Compressed pubkeys are only 33 bytes, not 64.
     ;;
    #_public
    (§ method boolean isCompressed(§ args ))
    (§ block
        (§ return pub.isCompressed(§ pars ))
    )

    ;;;
     ; Returns the address that corresponds to the public part of this ECKey.  Note that an address is derived from
     ; the RIPEMD-160 hash of the public key and is not the public key itself (which is too large to be convenient).
     ;;
    #_public
    (§ method Address toAddress(§ args NetworkParameters params))
    (§ block
        (§ return (§ new Address(§ pars params, getPubKeyHash(§ pars ))))
    )

    ;;;
     ; Groups the two components that make up a signature, and provides a way to encode to DER form, which is
     ; how ECDSA signatures are represented when embedded in other data structures in the Bitcoin protocol.
     ; The raw components can be useful for doing further EC maths on them.
     ;;
    #_public
    #_static
    (§ class ECDSASignature
        ;;; The two components of the signature. ;;
        #_public
        #_final
        (§ field BigInteger r, s)

        ;;;
         ; Constructs a signature with the given components.  Does NOT automatically canonicalise the signature.
         ;;
        #_public
        (§ constructor ECDSASignature(§ args BigInteger r, BigInteger s))
        (§ block
            (§ ass this.r = r)
            (§ ass this.s = s)
        )

        ;;;
         ; Returns true if the S component is "low", that means it is below {@link ECKey#HALF_CURVE_ORDER}.  See
         ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki#Low_S_values_in_signatures">BIP62</a>.
         ;;
        #_public
        (§ method boolean isCanonical(§ args ))
        (§ block
            (§ return (§ expr s.compareTo(§ pars HALF_CURVE_ORDER) <= 0))
        )

        ;;;
         ; Will automatically adjust the S component to be less than or equal to half the curve order, if necessary.
         ; This is required because for every signature (r,s) the signature (r, -s (mod N)) is a valid signature of
         ; the same message.  However, we dislike the ability to modify the bits of a Bitcoin transaction after it's
         ; been signed, as that violates various assumed invariants.  Thus in future only one of those forms will be
         ; considered legal and the other will be banned.
         ;;
        #_public
        (§ method ECDSASignature toCanonicalised(§ args ))
        (§ block
            (§ if (§ expr !isCanonical(§ pars )))
            (§ block
                ;; The order of the curve is the number of valid points that exist on that curve.  If S is in the upper
                ;; half of the number of valid points, then bring it back to the lower half.  Otherwise, imagine that
                ;;    N = 10
                ;;    s = 8, so (-8 % 10 == 2) thus both (r, 8) and (r, 2) are valid solutions.
                ;;    10 - 8 == 2, giving us always the latter solution, which is canonical.
                (§ return (§ new ECDSASignature(§ pars r, CURVE.getN(§ pars ).subtract(§ pars s))))
            )

            (§ return this)
        )

        ;;;
         ; DER is an international standard for serializing data structures which is widely used in cryptography.
         ; It's somewhat like protocol buffers but less convenient.  This method returns a standard DER encoding
         ; of the signature, as recognized by OpenSSL and other libraries.
         ;;
        #_public
        (§ method byte[] encodeToDER(§ args ))
        (§ block
            (§ try )
            (§ block
                (§ return derByteStream(§ pars ).toByteArray(§ pars ))
            )
            (§ catch (§ args IOException e))
            (§ block
                (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
            )
        )

        #_public
        #_static
        (§ method ECDSASignature decodeFromDER(§ args byte[] bytes))
            (§ throws IllegalArgumentException)
        (§ block
            (§ var ASN1InputStream decoder = nil)
            (§ try )
            (§ block
                (§ ass decoder = new ASN1InputStream(§ pars bytes))
                (§ var DLSequence seq = (§ cast DLSequence)decoder.readObject(§ pars ))
                (§ if (§ expr seq == nil))
                (§ block
                    (§ throw (§ new IllegalArgumentException(§ pars "Reached past end of ASN.1 stream.")))
                )

                (§ var ASN1Integer r, s)
                (§ try )
                (§ block
                    (§ ass r = (§ cast ASN1Integer)seq.getObjectAt(§ pars 0))
                    (§ ass s = (§ cast ASN1Integer)seq.getObjectAt(§ pars 1))
                )
                (§ catch (§ args ClassCastException e))
                (§ block
                    (§ throw (§ new IllegalArgumentException(§ pars e)))
                )
                ;; OpenSSL deviates from the DER spec by interpreting these values as unsigned, though they should not be.
                ;; Thus, we always use the positive versions.  See http://r6.ca/blog/20111119T211504Z.html
                (§ return (§ new ECDSASignature(§ pars r.getPositiveValue(§ pars ), s.getPositiveValue(§ pars ))))
            )
            (§ catch (§ args IOException e))
            (§ block
                (§ throw (§ new IllegalArgumentException(§ pars e)))
            )
            (§ finally )
            (§ block
                (§ if (§ expr decoder != nil))
                (§ block
                    (§ try )
                    (§ block
                        (§ call decoder.close(§ pars ))
                    )
                    (§ catch (§ args IOException _))
                    (§ block
                    )
                )
            )
        )

        #_protected
        (§ method ByteArrayOutputStream derByteStream(§ args ))
            (§ throws IOException)
        (§ block
            ;; Usually 70-72 bytes.
            (§ var ByteArrayOutputStream bos = new ByteArrayOutputStream(§ pars 72))
            (§ var DERSequenceGenerator seq = new DERSequenceGenerator(§ pars bos))
            (§ call seq.addObject(§ pars (§ new ASN1Integer(§ pars r))))
            (§ call seq.addObject(§ pars (§ new ASN1Integer(§ pars s))))
            (§ call seq.close(§ pars ))
            (§ return bos)
        )

        #_override
        #_public
        (§ method boolean equals(§ args Object o))
        (§ block
            (§ if (§ expr this == o))
            (§ block
                (§ return true)
            )
            (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
            (§ block
                (§ return false)
            )
            (§ var ECDSASignature other = (§ cast ECDSASignature)o)
            (§ return (§ expr r.equals(§ pars other.r) && s.equals(§ pars other.s)))
        )

        #_override
        #_public
        (§ method int hashCode(§ args ))
        (§ block
            (§ return Objects.hashCode(§ pars r, s))
        )
    )

    ;;;
     ; Signs the given hash and returns the R and S components as BigIntegers.  In the Bitcoin protocol, they are
     ; usually encoded using ASN.1 format, so you want {@link org.bitcoinj.core.ECKey.ECDSASignature#toASN1()}
     ; instead.  However sometimes the independent components can be useful, for instance, if you're going to do
     ; further EC maths on them.
     ; @throws KeyCrypterException if this ECKey doesn't have a private part.
     ;;
    #_public
    (§ method ECDSASignature sign(§ args Sha256Hash input))
        (§ throws KeyCrypterException)
    (§ block
        (§ return sign(§ pars input, nil))
    )

    ;;;
     ; If this global variable is set to true, sign() creates a dummy signature and verify() always returns true.
     ; This is intended to help accelerate unit tests that do a lot of signing/verifying, which in the debugger
     ; can be painfully slow.
     ;;
    #_testing
    #_public
    #_static
    (§ field boolean FAKE_SIGNATURES = false)

    ;;;
     ; Signs the given hash and returns the R and S components as BigIntegers.  In the Bitcoin protocol, they are
     ; usually encoded using DER format, so you want {@link org.bitcoinj.core.ECKey.ECDSASignature#encodeToDER()}
     ; instead.  However sometimes the independent components can be useful, for instance, if you're doing to do further
     ; EC maths on them.
     ;
     ; @param aesKey The AES key to use for decryption of the private key.  If null, then no decryption is required.
     ; @throws KeyCrypterException if there's something wrong with aesKey.
     ; @throws ECKey.MissingPrivateKeyException if this key cannot sign because it's pubkey only.
     ;;
    #_public
    (§ method ECDSASignature sign(§ args Sha256Hash input, #_nilable KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (§ block
        (§ var KeyCrypter crypter = getKeyCrypter(§ pars ))
        (§ if (§ expr crypter != nil))
        (§ block
            (§ if (§ expr aesKey == nil))
            (§ block
                (§ throw (§ new KeyIsEncryptedException(§ pars )))
            )
            (§ return decrypt(§ pars aesKey).sign(§ pars input))
        )
        (§ else )
        (§ block
            ;; No decryption of private key required.
            (§ if (§ expr priv == nil))
            (§ block
                (§ throw (§ new MissingPrivateKeyException(§ pars )))
            )
        )
        (§ return doSign(§ pars input, priv))
    )

    #_protected
    (§ method ECDSASignature doSign(§ args Sha256Hash input, BigInteger privateKeyForSigning))
    (§ block
        (§ if (§ expr FAKE_SIGNATURES))
        (§ block
            (§ return TransactionSignature.dummy(§ pars ))
        )

        (§ call Preconditions.checkNotNull(§ pars privateKeyForSigning))

        (§ var ECDSASigner signer = new ECDSASigner(§ pars (§ new HMacDSAKCalculator(§ pars (§ new SHA256Digest(§ pars ))))))
        (§ var ECPrivateKeyParameters privKey = new ECPrivateKeyParameters(§ pars privateKeyForSigning, CURVE))
        (§ call signer.init(§ pars true, privKey))
        (§ var BigInteger[] components = signer.generateSignature(§ pars input.getBytes(§ pars )))
        (§ return (§ new ECDSASignature(§ pars components[0], components[1])).toCanonicalised(§ pars ))
    )

    ;;;
     ; <p>Verifies the given ECDSA signature against the message bytes using the public key bytes.</p>
     ;
     ; <p>When using native ECDSA verification, data must be 32 bytes, and no element may be
     ; larger than 520 bytes.</p>
     ;
     ; @param data      Hash of the data to verify.
     ; @param signature ASN.1 encoded signature.
     ; @param pub       The public key bytes to use.
     ;;
    #_public
    #_static
    (§ method boolean verify(§ args byte[] data, ECDSASignature signature, byte[] pub))
    (§ block
        (§ if (§ expr FAKE_SIGNATURES))
        (§ block
            (§ return true)
        )

        (§ var ECDSASigner signer = new ECDSASigner(§ pars ))
        (§ var ECPublicKeyParameters params = new ECPublicKeyParameters(§ pars CURVE.getCurve(§ pars ).decodePoint(§ pars pub), CURVE))
        (§ call signer.init(§ pars false, params))
        (§ try )
        (§ block
            (§ return signer.verifySignature(§ pars data, signature.r, signature.s))
        )
        (§ catch (§ args NullPointerException e))
        (§ block
            ;; Bouncy Castle contains a bug that can cause NPEs given specially crafted signatures.  Those signatures
            ;; are inherently invalid/attack sigs so we just fail them here rather than crash the thread.
            (§ call log.error(§ pars "Caught NPE inside bouncy castle", e))
            (§ return false)
        )
    )

    ;;;
     ; Verifies the given ASN.1 encoded ECDSA signature against a hash using the public key.
     ;
     ; @param data      Hash of the data to verify.
     ; @param signature ASN.1 encoded signature.
     ; @param pub       The public key bytes to use.
     ;;
    #_public
    #_static
    (§ method boolean verify(§ args byte[] data, byte[] signature, byte[] pub))
    (§ block
        (§ return verify(§ pars data, ECDSASignature.decodeFromDER(§ pars signature), pub))
    )

    ;;;
     ; Verifies the given ASN.1 encoded ECDSA signature against a hash using the public key.
     ;
     ; @param hash      Hash of the data to verify.
     ; @param signature ASN.1 encoded signature.
     ;;
    #_public
    (§ method boolean verify(§ args byte[] hash, byte[] signature))
    (§ block
        (§ return ECKey.verify(§ pars hash, signature, getPubKey(§ pars )))
    )

    ;;;
     ; Verifies the given R/S pair (signature) against a hash using the public key.
     ;;
    #_public
    (§ method boolean verify(§ args Sha256Hash sigHash, ECDSASignature signature))
    (§ block
        (§ return ECKey.verify(§ pars sigHash.getBytes(§ pars ), signature, getPubKey(§ pars )))
    )

    ;;;
     ; Verifies the given ASN.1 encoded ECDSA signature against a hash using the public key, and throws an exception
     ; if the signature doesn't match.
     ; @throws java.security.SignatureException if the signature does not match.
     ;;
    #_public
    (§ method void verifyOrThrow(§ args byte[] hash, byte[] signature))
        (§ throws SignatureException)
    (§ block
        (§ if (§ expr !verify(§ pars hash, signature)))
        (§ block
            (§ throw (§ new SignatureException(§ pars )))
        )
    )

    ;;;
     ; Verifies the given R/S pair (signature) against a hash using the public key, and throws an exception
     ; if the signature doesn't match.
     ; @throws java.security.SignatureException if the signature does not match.
     ;;
    #_public
    (§ method void verifyOrThrow(§ args Sha256Hash sigHash, ECDSASignature signature))
        (§ throws SignatureException)
    (§ block
        (§ if (§ expr !ECKey.verify(§ pars sigHash.getBytes(§ pars ), signature, getPubKey(§ pars ))))
        (§ block
            (§ throw (§ new SignatureException(§ pars )))
        )
    )

    ;;;
     ; Returns true if the given pubkey is canonical, i.e. the correct length taking into account compression.
     ;;
    #_public
    #_static
    (§ method boolean isPubKeyCanonical(§ args byte[] pubkey))
    (§ block
        (§ if (§ expr pubkey.length < 33))
        (§ block
            (§ return false)
        )
        ;; Uncompressed pubkey.
        (§ if (§ expr pubkey[0] == 0x04))
        (§ block
            (§ return (§ expr pubkey.length == 65))
        )
        ;; Compressed pubkey.
        (§ if (§ expr pubkey[0] == 0x02 || pubkey[0] == 0x03))
        (§ block
            (§ return (§ expr pubkey.length == 33))
        )
        (§ return false)
    )

    #_private
    #_static
    (§ method ECKey extractKeyFromASN1(§ args byte[] asn1privkey))
    (§ block
        ;; To understand this code, see the definition of the ASN.1 format for EC private keys in the OpenSSL source
        ;; code in ec_asn1.c:
        ;;
        ;; ASN1_SEQUENCE(EC_PRIVATEKEY) = {
        ;;   ASN1_SIMPLE(EC_PRIVATEKEY, version, LONG),
        ;;   ASN1_SIMPLE(EC_PRIVATEKEY, privateKey, ASN1_OCTET_STRING),
        ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, parameters, ECPKPARAMETERS, 0),
        ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, publicKey, ASN1_BIT_STRING, 1)
        ;; } ASN1_SEQUENCE_END(EC_PRIVATEKEY)
        (§ try )
        (§ block
            (§ var ASN1InputStream decoder = new ASN1InputStream(§ pars asn1privkey))
            (§ var DLSequence seq = (§ cast DLSequence)decoder.readObject(§ pars ))
            (§ call Preconditions.checkArgument(§ pars decoder.readObject(§ pars ) == nil, "Input contains extra bytes"))
            (§ call decoder.close(§ pars ))

            (§ call Preconditions.checkArgument(§ pars seq.size(§ pars ) == 4, "Input does not appear to be an ASN.1 OpenSSL EC private key"))

            (§ call Preconditions.checkArgument(§ pars (§ expr (§ cast ASN1Integer)seq.getObjectAt(§ pars 0)).getValue(§ pars ).equals(§ pars BigInteger.ONE), "Input is of wrong version"))

            (§ var byte[] privbits = (§ expr (§ expr (§ cast ASN1OctetString)seq.getObjectAt(§ pars 1)).getOctets(§ pars )))
            (§ var BigInteger privkey = new BigInteger(§ pars 1, privbits))

            (§ var ASN1TaggedObject pubkey = (§ cast ASN1TaggedObject)seq.getObjectAt(§ pars 3))
            (§ call Preconditions.checkArgument(§ pars pubkey.getTagNo(§ pars ) == 1, "Input has 'publicKey' with bad tag number"))
            (§ var byte[] pubbits = (§ expr (§ expr (§ cast DERBitString)pubkey.getObject(§ pars )).getBytes(§ pars )))
            (§ call Preconditions.checkArgument(§ pars pubbits.length == 33 || pubbits.length == 65, "Input has 'publicKey' with invalid length"))
            (§ var int encoding = pubbits[0] & 0xff)
            ;; Only allow compressed(2,3) and uncompressed(4), not infinity(0) or hybrid(6,7).
            (§ call Preconditions.checkArgument(§ pars 2 <= encoding && encoding <= 4, "Input has 'publicKey' with invalid encoding"))

            ;; Now sanity check to ensure the pubkey bytes match the privkey.
            (§ var boolean compressed = (§ expr pubbits.length == 33))
            (§ var ECKey key = new ECKey(§ pars privkey, nil, compressed))
            (§ if (§ expr !Arrays.equals(§ pars key.getPubKey(§ pars ), pubbits)))
            (§ block
                (§ throw (§ new IllegalArgumentException(§ pars "Public key in ASN.1 structure does not match private key.")))
            )
            (§ return key)
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen, reading from memory stream.
        )
    )

    ;;;
     ; Signs a text message using the standard Bitcoin messaging signing format and returns the signature as a base64
     ; encoded string.
     ;
     ; @throws IllegalStateException if this ECKey does not have the private part.
     ; @throws KeyCrypterException if this ECKey is encrypted and no AESKey is provided or it does not decrypt the ECKey.
     ;;
    #_public
    (§ method String signMessage(§ args String message))
        (§ throws KeyCrypterException)
    (§ block
        (§ return signMessage(§ pars message, nil))
    )

    ;;;
     ; Signs a text message using the standard Bitcoin messaging signing format and returns the signature as a base64
     ; encoded string.
     ;
     ; @throws IllegalStateException if this ECKey does not have the private part.
     ; @throws KeyCrypterException if this ECKey is encrypted and no AESKey is provided or it does not decrypt the ECKey.
     ;;
    #_public
    (§ method String signMessage(§ args String message, #_nilable KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (§ block
        (§ var byte[] data = Utils.formatMessageForSigning(§ pars message))
        (§ var Sha256Hash hash = Sha256Hash.twiceOf(§ pars data))
        (§ var ECDSASignature sig = sign(§ pars hash, aesKey))
        ;; Now we have to work backwards to figure out the recId needed to recover the signature.
        (§ var int recId = -1)
        (§ for (§ var int i = 0) :for (§ expr i < 4) :for (§ ass i = i + 1))
        (§ block
            (§ var ECKey k = ECKey.recoverFromSignature(§ pars i, sig, hash, isCompressed(§ pars )))
            (§ if (§ expr k != nil && k.pub.equals(§ pars pub)))
            (§ block
                (§ ass recId = i)
                (§ break )
            )
        )
        (§ if (§ expr recId == -1))
        (§ block
            (§ throw (§ new RuntimeException(§ pars "Could not construct a recoverable key. This should never happen.")))
        )
        (§ var int headerByte = recId + 27 + (§ expr isCompressed(§ pars ) ? 4 :else 0))
        (§ var byte[] sigData = new byte[65]) ;; 1 header + 32 bytes for R + 32 bytes for S
        (§ ass sigData[0] = (§ cast byte)headerByte)
        (§ call System.arraycopy(§ pars Utils.bigIntegerToBytes(§ pars sig.r, 32), 0, sigData, 1, 32))
        (§ call System.arraycopy(§ pars Utils.bigIntegerToBytes(§ pars sig.s, 32), 0, sigData, 33, 32))
        (§ return (§ new String(§ pars Base64.encode(§ pars sigData), Charset.forName(§ pars "UTF-8"))))
    )

    ;;;
     ; Given an arbitrary piece of text and a Bitcoin-format message signature encoded in base64, returns an ECKey
     ; containing the public key that was used to sign it.  This can then be compared to the expected public key to
     ; determine if the signature was correct.  These sorts of signatures are compatible with the Bitcoin-Qt/bitcoind
     ; format generated by signmessage/verifymessage RPCs and GUI menu options.  They are intended for humans to verify
     ; their communications with each other, hence the base64 format and the fact that the input is text.
     ;
     ; @param message Some piece of human readable text.
     ; @param signatureBase64 The Bitcoin-format message signature in base64.
     ; @throws SignatureException if the public key could not be recovered or if there was a signature format error.
     ;;
    #_public
    #_static
    (§ method ECKey signedMessageToKey(§ args String message, String signatureBase64))
        (§ throws SignatureException)
    (§ block
        (§ var byte[] signatureEncoded)
        (§ try )
        (§ block
            (§ ass signatureEncoded = Base64.decode(§ pars signatureBase64))
        )
        (§ catch (§ args RuntimeException e))
        (§ block
            ;; This is what you get back from Bouncy Castle if base64 doesn't decode :( ;; )
            (§ throw (§ new SignatureException(§ pars "Could not decode base64", e)))
        )
        ;; Parse the signature bytes into r/s and the selector value.
        (§ if (§ expr signatureEncoded.length < 65))
        (§ block
            (§ throw (§ new SignatureException(§ pars "Signature truncated, expected 65 bytes and got " + signatureEncoded.length)))
        )

        (§ var int header = signatureEncoded[0] & 0xff)
        ;; The header byte: 0x1B = first key with even y, 0x1C = first key with odd y,
        ;;                  0x1D = second key with even y, 0x1E = second key with odd y.
        (§ if (§ expr header < 27 || 34 < header))
        (§ block
            (§ throw (§ new SignatureException(§ pars "Header byte out of range: " + header)))
        )
        (§ var BigInteger r = new BigInteger(§ pars 1, Arrays.copyOfRange(§ pars signatureEncoded, 1, 33)))
        (§ var BigInteger s = new BigInteger(§ pars 1, Arrays.copyOfRange(§ pars signatureEncoded, 33, 65)))
        (§ var ECDSASignature sig = new ECDSASignature(§ pars r, s))
        (§ var byte[] messageBytes = Utils.formatMessageForSigning(§ pars message))
        ;; Note that the C++ code doesn't actually seem to specify any character encoding.
        ;; Presumably it's whatever JSON-SPIRIT hands back.  Assume UTF-8 for now.
        (§ var Sha256Hash messageHash = Sha256Hash.twiceOf(§ pars messageBytes))
        (§ var boolean compressed = false)
        (§ if (§ expr 31 <= header))
        (§ block
            (§ ass compressed = true)
            (§ ass header = header - 4)
        )
        (§ var int recId = header - 27)
        (§ var ECKey key = ECKey.recoverFromSignature(§ pars recId, sig, messageHash, compressed))
        (§ if (§ expr key == nil))
        (§ block
            (§ throw (§ new SignatureException(§ pars "Could not recover public key from signature")))
        )
        (§ return key)
    )

    ;;;
     ; Convenience wrapper around {@link ECKey#signedMessageToKey(String, String)}.
     ; If the key derived from the signature is not the same as this one, throws a SignatureException.
     ;;
    #_public
    (§ method void verifyMessage(§ args String message, String signatureBase64))
        (§ throws SignatureException)
    (§ block
        (§ var ECKey key = ECKey.signedMessageToKey(§ pars message, signatureBase64))
        (§ if (§ expr !key.pub.equals(§ pars pub)))
        (§ block
            (§ throw (§ new SignatureException(§ pars "Signature did not match for message")))
        )
    )

    ;;;
     ; <p>Given the components of a signature and a selector value, recover and return the public key
     ; that generated the signature according to the algorithm in SEC1v2 section 4.1.6.</p>
     ;
     ; <p>The recId is an index from 0 to 3 which indicates which of the 4 possible keys is the correct one.  Because
     ; the key recovery operation yields multiple potential keys, the correct key must either be stored alongside the
     ; signature, or you must be willing to try each recId in turn until you find one that outputs the key you are
     ; expecting.</p>
     ;
     ; <p>If this method returns null it means recovery was not possible and recId should be iterated.</p>
     ;
     ; <p>Given the above two points, a correct usage of this method is inside a for loop from 0 to 3, and if the
     ; output is null OR a key that is not the one you expect, you try again with the next recId.</p>
     ;
     ; @param recId Which possible key to recover.
     ; @param sig The R and S components of the signature, wrapped.
     ; @param message Hash of the data that was signed.
     ; @param compressed Whether or not the original pubkey was compressed.
     ; @return An ECKey containing only the public part, or null if recovery wasn't possible.
     ;;
    #_nilable
    #_public
    #_static
    (§ method ECKey recoverFromSignature(§ args int recId, ECDSASignature sig, Sha256Hash message, boolean compressed))
    (§ block
        (§ call Preconditions.checkArgument(§ pars 0 <= recId, "recId must be positive"))
        (§ call Preconditions.checkArgument(§ pars 0 <= sig.r.signum(§ pars ), "r must be positive"))
        (§ call Preconditions.checkArgument(§ pars 0 <= sig.s.signum(§ pars ), "s must be positive"))
        (§ call Preconditions.checkNotNull(§ pars message))

        ;; 1.0 For j from 0 to h   (h == recId here and the loop is outside this function)
        ;;   1.1 Let x = r + jn
        (§ var BigInteger n = CURVE.getN(§ pars )) ;; Curve order.
        (§ var BigInteger i = BigInteger.valueOf(§ pars (§ cast long)recId / 2))
        (§ var BigInteger x = sig.r.add(§ pars i.multiply(§ pars n)))
        ;;   1.2. Convert the integer x to an octet string X of length mlen using the conversion routine
        ;;        specified in Section 2.3.7, where mlen = ⌈(log2 p)/8⌉ or mlen = ⌈m/8⌉.
        ;;   1.3. Convert the octet string (16 set binary digits)||X to an elliptic curve point R using the
        ;;        conversion routine specified in Section 2.3.4. If this conversion routine outputs “invalid”,
        ;;        then do another iteration of Step 1.
        ;;
        ;; More concisely, what these points mean is to use X as a compressed public key.
        (§ var BigInteger prime = SecP256K1Curve.q)
        ;; Cannot have point co-ordinates larger than this as everything takes place modulo Q.
        (§ if (§ expr 0 <= x.compareTo(§ pars prime)))
        (§ block
            (§ return nil)
        )

        ;; Compressed keys require you to know an extra bit of data about the y-coord as there are two possibilities.
        ;; So it's encoded in the recId.
        (§ var ECPoint R = decompressKey(§ pars x, (§ expr recId & 1) == 1))
        ;;   1.4. If nR != point at infinity, then do another iteration of Step 1 (callers responsibility).
        (§ if (§ expr !R.multiply(§ pars n).isInfinity(§ pars )))
        (§ block
            (§ return nil)
        )

        ;;   1.5. Compute e from M using Steps 2 and 3 of ECDSA signature verification.
        (§ var BigInteger e = message.toBigInteger(§ pars ))
        ;;   1.6. For k from 1 to 2 do the following.   (loop is outside this function via iterating recId)
        ;;   1.6.1. Compute a candidate public key as:
        ;;               Q = mi(r) * (sR - eG)
        ;;
        ;; Where mi(x) is the modular multiplicative inverse. We transform this into the following:
        ;;               Q = (mi(r) * s ** R) + (mi(r) * -e ** G)
        ;; Where -e is the modular additive inverse of e, that is z such that z + e = 0 (mod n). In the above equation
        ;; ** is point multiplication and + is point addition (the EC group operator).
        ;;
        ;; We can find the additive inverse by subtracting e from zero then taking the mod. For example the additive
        ;; inverse of 3 modulo 11 is 8 because 3 + 8 mod 11 = 0, and -3 mod 11 = 8.
        (§ var BigInteger eInv = BigInteger.ZERO.subtract(§ pars e).mod(§ pars n))
        (§ var BigInteger rInv = sig.r.modInverse(§ pars n))
        (§ var BigInteger srInv = rInv.multiply(§ pars sig.s).mod(§ pars n))
        (§ var BigInteger eInvrInv = rInv.multiply(§ pars eInv).mod(§ pars n))
        (§ var ECPoint q = ECAlgorithms.sumOfTwoMultiplies(§ pars CURVE.getG(§ pars ), eInvrInv, R, srInv))
        (§ return ECKey.fromPublicOnly(§ pars q.getEncoded(§ pars compressed)))
    )

    ;;; Decompress a compressed public key (x co-ord and low-bit of y-coord). ;;
    #_private
    #_static
    (§ method ECPoint decompressKey(§ args BigInteger xBN, boolean yBit))
    (§ block
        (§ var X9IntegerConverter x9 = new X9IntegerConverter(§ pars ))
        (§ var byte[] compEnc = x9.integerToBytes(§ pars xBN, 1 + x9.getByteLength(§ pars CURVE.getCurve(§ pars ))))
        (§ ass compEnc[0] = (§ cast byte)(§ expr yBit ? 0x03 :else 0x02))
        (§ return CURVE.getCurve(§ pars ).decodePoint(§ pars compEnc))
    )

    ;;;
     ; Returns a 32 byte array containing the private key.
     ; @throws org.bitcoinj.core.ECKey.MissingPrivateKeyException if the private key bytes are missing/encrypted.
     ;;
    #_public
    (§ method byte[] getPrivKeyBytes(§ args ))
    (§ block
        (§ return Utils.bigIntegerToBytes(§ pars getPrivKey(§ pars ), 32))
    )

    ;;;
     ; Returns the creation time of this key or zero if the key was deserialized from a version that did not store
     ; that data.
     ;;
    #_override
    #_public
    (§ method long getCreationTimeSeconds(§ args ))
    (§ block
        (§ return creationTimeSeconds)
    )

    ;;;
     ; Sets the creation time of this key.  Zero is a convention to mean "unavailable".  This method can be useful when
     ; you have a raw key you are importing from somewhere else.
     ;;
    #_public
    (§ method void setCreationTimeSeconds(§ args long newCreationTimeSeconds))
    (§ block
        (§ if (§ expr newCreationTimeSeconds < 0))
        (§ block
            (§ throw (§ new IllegalArgumentException(§ pars "Cannot set creation time to negative value: " + newCreationTimeSeconds)))
        )
        (§ ass creationTimeSeconds = newCreationTimeSeconds)
    )

    ;;;
     ; Create an encrypted private key with the keyCrypter and the AES key supplied.
     ; This method returns a new encrypted key and leaves the original unchanged.
     ;
     ; @param keyCrypter The keyCrypter that specifies exactly how the encrypted bytes are created.
     ; @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached as it is slow to create).
     ; @return encryptedKey
     ;;
    #_public
    (§ method ECKey encrypt(§ args KeyCrypter keyCrypter, KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars keyCrypter))

        #_final
        (§ var byte[] privKeyBytes = getPrivKeyBytes(§ pars ))
        (§ var EncryptedData encryptedPrivateKey = keyCrypter.encrypt(§ pars privKeyBytes, aesKey))
        (§ var ECKey result = ECKey.fromEncrypted(§ pars encryptedPrivateKey, keyCrypter, getPubKey(§ pars )))
        (§ call result.setCreationTimeSeconds(§ pars creationTimeSeconds))
        (§ return result)
    )

    ;;;
     ; Create a decrypted private key with the keyCrypter and AES key supplied.  Note that if the aesKey is wrong, this
     ; has some chance of throwing KeyCrypterException due to the corrupted padding that will result, but it can also
     ; just yield a garbage key.
     ;
     ; @param keyCrypter The keyCrypter that specifies exactly how the decrypted bytes are created.
     ; @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached).
     ;;
    #_public
    (§ method ECKey decrypt(§ args KeyCrypter keyCrypter, KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars keyCrypter))

        ;; Check that the keyCrypter matches the one used to encrypt the keys, if set.
        (§ if (§ expr this.keyCrypter != nil && !this.keyCrypter.equals(§ pars keyCrypter)))
        (§ block
            (§ throw (§ new KeyCrypterException(§ pars "The keyCrypter being used to decrypt the key is different to the one that was used to encrypt it")))
        )

        (§ call Preconditions.checkState(§ pars encryptedPrivateKey != nil, "This key is not encrypted"))

        (§ var byte[] unencryptedPrivateKey = keyCrypter.decrypt(§ pars encryptedPrivateKey, aesKey))
        (§ var ECKey key = ECKey.fromPrivate(§ pars unencryptedPrivateKey))
        (§ if (§ expr !isCompressed(§ pars )))
        (§ block
            (§ ass key = key.decompress(§ pars ))
        )
        (§ if (§ expr !Arrays.equals(§ pars key.getPubKey(§ pars ), getPubKey(§ pars ))))
        (§ block
            (§ throw (§ new KeyCrypterException(§ pars "Provided AES key is wrong")))
        )

        (§ call key.setCreationTimeSeconds(§ pars creationTimeSeconds))
        (§ return key)
    )

    ;;;
     ; Create a decrypted private key with AES key.  Note that if the AES key is wrong, this
     ; has some chance of throwing KeyCrypterException due to the corrupted padding that will result, but it can also
     ; just yield a garbage key.
     ;
     ; @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached).
     ;;
    #_public
    (§ method ECKey decrypt(§ args KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (§ block
        #_final
        (§ var KeyCrypter crypter = getKeyCrypter(§ pars ))
        (§ if (§ expr crypter == nil))
        (§ block
            (§ throw (§ new KeyCrypterException(§ pars "No key crypter available")))
        )

        (§ return decrypt(§ pars crypter, aesKey))
    )

    ;;;
     ; Creates decrypted private key if needed.
     ;;
    #_public
    (§ method ECKey maybeDecrypt(§ args #_nilable KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (§ block
        (§ return (§ expr isEncrypted(§ pars ) && aesKey != nil) ? decrypt(§ pars aesKey) :else this)
    )

    ;;;
     ; <p>Check that it is possible to decrypt the key with the keyCrypter and that the original key is returned.</p>
     ;
     ; <p>Because it is a critical failure if the private keys cannot be decrypted successfully (resulting of loss of
     ; all bitcoins controlled by the private key) you can use this method to check when you *encrypt* a wallet that
     ; it can definitely be decrypted successfully.</p>
     ;
     ; <p>See {@link Wallet#encrypt(KeyCrypter keyCrypter, KeyParameter aesKey)} for example usage.</p>
     ;
     ; @return true if the encrypted key can be decrypted back to the original key successfully.
     ;;
    #_public
    #_static
    (§ method boolean encryptionIsReversible(§ args ECKey originalKey, ECKey encryptedKey, KeyCrypter keyCrypter, KeyParameter aesKey))
    (§ block
        (§ try )
        (§ block
            (§ var ECKey rebornUnencryptedKey = encryptedKey.decrypt(§ pars keyCrypter, aesKey))
            (§ var byte[] originalPrivateKeyBytes = originalKey.getPrivKeyBytes(§ pars ))
            (§ var byte[] rebornKeyBytes = rebornUnencryptedKey.getPrivKeyBytes(§ pars ))
            (§ if (§ expr !Arrays.equals(§ pars originalPrivateKeyBytes, rebornKeyBytes)))
            (§ block
                (§ call log.error(§ pars "The check that encryption could be reversed failed for {}", originalKey))
                (§ return false)
            )
            (§ return true)
        )
        (§ catch (§ args KeyCrypterException kce))
        (§ block
            (§ call log.error(§ pars kce.getMessage(§ pars )))
            (§ return false)
        )
    )

    ;;;
     ; Indicates whether the private key is encrypted (true) or not (false).
     ; A private key is deemed to be encrypted when there is both a KeyCrypter and the encryptedPrivateKey is non-zero.
     ;;
    #_override
    #_public
    (§ method boolean isEncrypted(§ args ))
    (§ block
        (§ return (§ expr keyCrypter != nil && encryptedPrivateKey != nil && 0 < encryptedPrivateKey.encryptedBytes.length))
    )

    #_nilable
    #_override
    #_public
    (§ method Protos.Wallet.EncryptionType getEncryptionType(§ args ))
    (§ block
        (§ return (§ expr keyCrypter != nil) ? keyCrypter.getUnderstoodEncryptionType(§ pars ) :else Protos.Wallet.EncryptionType.UNENCRYPTED)
    )

    ;;;
     ; A wrapper for {@link #getPrivKeyBytes()} that returns null if the private key bytes are missing or would have
     ; to be derived (for the HD key case).
     ;;
    #_override
    #_nilable
    #_public
    (§ method byte[] getSecretBytes(§ args ))
    (§ block
        (§ if (§ expr hasPrivKey(§ pars )))
        (§ block
            (§ return getPrivKeyBytes(§ pars ))
        )

        (§ return nil)
    )

    ;;; An alias for {@link #getEncryptedPrivateKey()}. ;;
    #_nilable
    #_override
    #_public
    (§ method EncryptedData getEncryptedData(§ args ))
    (§ block
        (§ return getEncryptedPrivateKey(§ pars ))
    )

    ;;;
     ; Returns the the encrypted private key bytes and initialisation vector for this ECKey, or null if the ECKey
     ; is not encrypted.
     ;;
    #_nilable
    #_public
    (§ method EncryptedData getEncryptedPrivateKey(§ args ))
    (§ block
        (§ return encryptedPrivateKey)
    )

    ;;;
     ; Returns the KeyCrypter that was used to encrypt to encrypt this ECKey.  You need this to decrypt the ECKey.
     ;;
    #_nilable
    #_public
    (§ method KeyCrypter getKeyCrypter(§ args ))
    (§ block
        (§ return keyCrypter)
    )

    #_public
    #_static
    (§ class MissingPrivateKeyException extends RuntimeException
    )

    #_public
    #_static
    (§ class KeyIsEncryptedException extends MissingPrivateKeyException
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || !(§ expr o instanceof ECKey)))
        (§ block
            (§ return false)
        )
        (§ var ECKey other = (§ cast ECKey)o)
        (§ return Objects.equal(§ pars this.priv, other.priv) && Objects.equal(§ pars this.pub, other.pub) && Objects.equal(§ pars this.creationTimeSeconds, other.creationTimeSeconds) && Objects.equal(§ pars this.keyCrypter, other.keyCrypter) && Objects.equal(§ pars this.encryptedPrivateKey, other.encryptedPrivateKey))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return pub.hashCode(§ pars ))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return toString(§ pars false, nil))
    )

    ;;;
     ; Produce a string rendering of the ECKey INCLUDING the private key.
     ; Unless you absolutely need the private key it is better for security reasons to just use {@link #toString()}.
     ;;
    #_public
    (§ method String toStringWithPrivate(§ args NetworkParameters params))
    (§ block
        (§ return toString(§ pars true, params))
    )

    #_public
    (§ method String getPrivateKeyAsHex(§ args ))
    (§ block
        (§ return Utils.HEX.encode(§ pars getPrivKeyBytes(§ pars )))
    )

    #_public
    (§ method String getPublicKeyAsHex(§ args ))
    (§ block
        (§ return Utils.HEX.encode(§ pars pub.getEncoded(§ pars )))
    )

    #_private
    (§ method String toString(§ args boolean includePrivate, NetworkParameters params))
    (§ block
        #_final
        (§ var MoreObjects.ToStringHelper helper = MoreObjects.toStringHelper(§ pars this).omitNullValues(§ pars ))
        (§ call helper.add(§ pars "pub HEX", getPublicKeyAsHex(§ pars )))
        (§ if (§ expr includePrivate))
        (§ block
            (§ try )
            (§ block
                (§ call helper.add(§ pars "priv HEX", getPrivateKeyAsHex(§ pars )))
            )
            (§ catch (§ args IllegalStateException _))
            (§ block
                ;; TODO: Make hasPrivKey() work for deterministic keys and fix this.
            )
            (§ catch (§ args Exception e))
            (§ block
                #_final
                (§ var String message = e.getMessage(§ pars ))
                (§ call helper.add(§ pars "priv EXCEPTION", e.getClass(§ pars ).getName(§ pars ) + (§ quest (§ expr message != nil) ? (§ expr ": " + message) :else "")))
            )
        )
        (§ if (§ expr 0 < creationTimeSeconds))
        (§ block
            (§ call helper.add(§ pars "creationTimeSeconds", creationTimeSeconds))
        )
        (§ call helper.add(§ pars "keyCrypter", keyCrypter))
        (§ if (§ expr includePrivate))
        (§ block
            (§ call helper.add(§ pars "encryptedPrivateKey", encryptedPrivateKey))
        )
        (§ call helper.add(§ pars "isEncrypted", isEncrypted(§ pars )))
        (§ call helper.add(§ pars "isPubKeyOnly", isPubKeyOnly(§ pars )))
        (§ return helper.toString(§ pars ))
    )

    #_public
    (§ method void formatKeyWithAddress(§ args boolean includePrivateKeys, StringBuilder sb, NetworkParameters params))
    (§ block
        #_final
        (§ var Address address = toAddress(§ pars params))
        (§ call sb.append(§ pars "  addr:"))
        (§ call sb.append(§ pars address.toString(§ pars )))
        (§ call sb.append(§ pars "  hash160:"))
        (§ call sb.append(§ pars Utils.HEX.encode(§ pars getPubKeyHash(§ pars ))))
        (§ if (§ expr 0 < creationTimeSeconds))
        (§ block
            (§ call sb.append(§ pars "  creationTimeSeconds:").append(§ pars creationTimeSeconds))
        )
        (§ call sb.append(§ pars "\n"))
        (§ if (§ expr includePrivateKeys))
        (§ block
            (§ call sb.append(§ pars "  "))
            (§ call sb.append(§ pars toStringWithPrivate(§ pars params)))
            (§ call sb.append(§ pars "\n"))
        )
    )
)

#_(ns org.bitcoinj.core #_"EmptyMessage"
    (:import [java.io IOException OutputStream]))

;;;
 ; <p>Parent class for header only messages that don't have a payload.
 ; Currently this includes getaddr, verack and special bitcoinj class UnknownMessage.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
(§ class EmptyMessage extends Message
    #_public
    (§ constructor EmptyMessage(§ args ))
    (§ block
        (§ ass length = 0)
    )

    #_public
    (§ constructor EmptyMessage(§ args NetworkParameters params))
    (§ block
        (§ super (§ pars params))
        (§ ass length = 0)
    )

    #_public
    (§ constructor EmptyMessage(§ args NetworkParameters params, byte[] payload, int offset))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, offset))
        (§ ass length = 0)
    )

    #_override
    #_protected
    #_final
    (§ method void bitcoinSerializeToStream(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
    )

    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
    )

    #_override
    #_public
    (§ method byte[] bitcoinSerialize(§ args ))
    (§ block
        (§ return new byte[0])
    )
)

#_(ns org.bitcoinj.core #_"FilteredBlock"
    (:import [java.io IOException OutputStream]
             [java.util *])
    (:import [com.google.common.base Objects]))

;;;
 ; <p>A FilteredBlock is used to relay a block with its transactions filtered using a {@link BloomFilter}.  It consists
 ; of the block header and a {@link PartialMerkleTree} which contains the transactions which matched the filter.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class FilteredBlock extends Message
    #_private
    (§ field Block header)

    #_private
    (§ field PartialMerkleTree merkleTree)
    #_private
    (§ field List<Sha256Hash> cachedTransactionHashes)

    ;; A set of transactions whose hashes are a subset of getTransactionHashes().
    ;; These were relayed as a part of the filteredblock getdata, i.e. likely weren't previously received as loose transactions.
    #_private
    (§ field Map<Sha256Hash, Transaction> associatedTransactions = new HashMap<>(§ pars ))

    #_public
    (§ constructor FilteredBlock(§ args NetworkParameters params, byte[] payloadBytes))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payloadBytes, 0))
    )

    #_public
    (§ constructor FilteredBlock(§ args NetworkParameters params, Block header, PartialMerkleTree pmt))
    (§ block
        (§ super (§ pars params))
        (§ ass this.header = header)
        (§ ass this.merkleTree = pmt)
    )

    #_override
    #_public
    (§ method void bitcoinSerializeToStream(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ if (§ expr header.transactions == nil))
        (§ block
            (§ call header.bitcoinSerializeToStream(§ pars stream))
        )
        (§ else )
        (§ block
            (§ call header.cloneAsHeader(§ pars ).bitcoinSerializeToStream(§ pars stream))
        )
        (§ call merkleTree.bitcoinSerializeToStream(§ pars stream))
    )

    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ var byte[] headerBytes = new byte[Block.HEADER_SIZE])
        (§ call System.arraycopy(§ pars payload, 0, headerBytes, 0, Block.HEADER_SIZE))
        (§ ass header = params.getDefaultSerializer(§ pars ).makeBlock(§ pars headerBytes))

        (§ ass merkleTree = new PartialMerkleTree(§ pars params, payload, Block.HEADER_SIZE))

        (§ ass length = Block.HEADER_SIZE + merkleTree.getMessageSize(§ pars ))
    )

    ;;;
     ; Gets a list of leaf hashes which are contained in the partial merkle tree in this filtered block.
     ;
     ; @throws ProtocolException if the partial merkle block is invalid or the merkle root of the partial merkle block doesnt match the block header.
     ;;
    #_public
    (§ method List<Sha256Hash> getTransactionHashes(§ args ))
        (§ throws VerificationException)
    (§ block
        (§ if (§ expr cachedTransactionHashes != nil))
        (§ block
            (§ return Collections.unmodifiableList(§ pars cachedTransactionHashes))
        )

        (§ var List<Sha256Hash> hashesMatched = new LinkedList<>(§ pars ))
        (§ if (§ expr header.getMerkleRoot(§ pars ).equals(§ pars merkleTree.getTxnHashAndMerkleRoot(§ pars hashesMatched))))
        (§ block
            (§ ass cachedTransactionHashes = hashesMatched)
            (§ return Collections.unmodifiableList(§ pars cachedTransactionHashes))
        )

        (§ throw (§ new VerificationException(§ pars "Merkle root of block header does not match merkle root of partial merkle tree.")))
    )

    ;;;
     ; Gets a copy of the block header.
     ;;
    #_public
    (§ method Block getBlockHeader(§ args ))
    (§ block
        (§ return header.cloneAsHeader(§ pars ))
    )

    ;;; Gets the hash of the block represented in this FilteredBlock. ;;
    #_override
    #_public
    (§ method Sha256Hash getHash(§ args ))
    (§ block
        (§ return header.getHash(§ pars ))
    )

    ;;;
     ; Provide this FilteredBlock with a transaction which is in its Merkle tree.
     ; @return false if the tx is not relevant to this FilteredBlock.
     ;;
    #_public
    (§ method boolean provideTransaction(§ args Transaction tx))
        (§ throws VerificationException)
    (§ block
        (§ var Sha256Hash hash = tx.getHash(§ pars ))
        (§ if (§ expr getTransactionHashes(§ pars ).contains(§ pars hash)))
        (§ block
            (§ call associatedTransactions.put(§ pars hash, tx))
            (§ return true)
        )
        (§ return false)
    )

    ;;; Returns the {@link PartialMerkleTree} object that provides the mathematical proof of transaction inclusion in the block. ;;
    #_public
    (§ method PartialMerkleTree getPartialMerkleTree(§ args ))
    (§ block
        (§ return merkleTree)
    )

    ;;; Gets the set of transactions which were provided using provideTransaction() which match in getTransactionHashes(). ;;
    #_public
    (§ method Map<Sha256Hash, Transaction> getAssociatedTransactions(§ args ))
    (§ block
        (§ return Collections.unmodifiableMap(§ pars associatedTransactions))
    )

    ;;; Number of transactions in this block, before it was filtered. ;;
    #_public
    (§ method int getTransactionCount(§ args ))
    (§ block
        (§ return merkleTree.getTransactionCount(§ pars ))
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var FilteredBlock other = (§ cast FilteredBlock)o)
        (§ return (§ expr associatedTransactions.equals(§ pars other.associatedTransactions) && header.equals(§ pars other.header) && merkleTree.equals(§ pars other.merkleTree)))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars associatedTransactions, header, merkleTree))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return "FilteredBlock{merkleTree=" + merkleTree + ", header=" + header + "}")
    )
)

#_(ns org.bitcoinj.core #_"FullPrunedBlockChain"
    (:import [java.util ArrayList LinkedList List ListIterator Set]
             [java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.script Script]
             [org.bitcoinj.script.Script VerifyFlag]
             [org.bitcoinj.store BlockStoreException FullPrunedBlockStore]
             [org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>A FullPrunedBlockChain works in conjunction with a {@link FullPrunedBlockStore} to verify all the rules of the
 ; Bitcoin system, with the downside being a large cost in system resources.  Fully verifying means all unspent
 ; transaction outputs are stored.  Once a transaction output is spent and that spend is buried deep enough, the data
 ; related to it is deleted to ensure disk space usage doesn't grow forever.  For this reason a pruning node cannot
 ; serve the full block chain to other clients, but it nevertheless provides the same security guarantees as Bitcoin
 ; Core does.</p>
 ;;
#_public
(§ class FullPrunedBlockChain extends AbstractBlockChain
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars FullPrunedBlockChain.class))

    ;;;
     ; Keeps a map of block hashes to StoredBlocks.
     ;;
    #_protected
    #_final
    (§ field FullPrunedBlockStore blockStore)

    ;; Whether or not to execute scriptPubKeys before accepting a transaction (i.e. check signatures).
    #_private
    (§ field boolean runScripts = true)

    ;;;
     ; Constructs a block chain connected to the given wallet and store.  To obtain a {@link Wallet} you can construct
     ; one from scratch, or you can deserialize a saved wallet from disk using {@link Wallet#loadFromFile(java.io.File)}.
     ;;
    #_public
    (§ constructor FullPrunedBlockChain(§ args Context context, Wallet wallet, FullPrunedBlockStore blockStore))
        (§ throws BlockStoreException)
    (§ block
        (§ this (§ pars context, new ArrayList<Wallet>(§ pars ), blockStore))
        (§ call addWallet(§ pars wallet))
    )

    ;;;
     ; Constructs a block chain connected to the given wallet and store.  To obtain a {@link Wallet} you can construct
     ; one from scratch, or you can deserialize a saved wallet from disk using {@link Wallet#loadFromFile(java.io.File)}.
     ;;
    #_public
    (§ constructor FullPrunedBlockChain(§ args NetworkParameters params, Wallet wallet, FullPrunedBlockStore blockStore))
        (§ throws BlockStoreException)
    (§ block
        (§ this (§ pars Context.getOrCreate(§ pars params), wallet, blockStore))
    )

    ;;;
     ; Constructs a block chain connected to the given store.
     ;;
    #_public
    (§ constructor FullPrunedBlockChain(§ args Context context, FullPrunedBlockStore blockStore))
        (§ throws BlockStoreException)
    (§ block
        (§ this (§ pars context, new ArrayList<Wallet>(§ pars ), blockStore))
    )

    ;;;
     ; See {@link #FullPrunedBlockChain(Context, Wallet, FullPrunedBlockStore)}.
     ;;
    #_public
    (§ constructor FullPrunedBlockChain(§ args NetworkParameters params, FullPrunedBlockStore blockStore))
        (§ throws BlockStoreException)
    (§ block
        (§ this (§ pars Context.getOrCreate(§ pars params), blockStore))
    )

    ;;;
     ; Constructs a block chain connected to the given list of wallets and a store.
     ;;
    #_public
    (§ constructor FullPrunedBlockChain(§ args Context context, List<Wallet> listeners, FullPrunedBlockStore blockStore))
        (§ throws BlockStoreException)
    (§ block
        (§ super (§ pars context, listeners, blockStore))
        (§ ass this.blockStore = blockStore)
        ;; Ignore upgrading for now.
        (§ ass this.chainHead = blockStore.getVerifiedChainHead(§ pars ))
    )

    ;;;
     ; See {@link #FullPrunedBlockChain(Context, List, FullPrunedBlockStore)}.
     ;;
    #_public
    (§ constructor FullPrunedBlockChain(§ args NetworkParameters params, List<Wallet> listeners, FullPrunedBlockStore blockStore))
        (§ throws BlockStoreException)
    (§ block
        (§ this (§ pars Context.getOrCreate(§ pars params), listeners, blockStore))
    )

    #_override
    #_protected
    (§ method StoredBlock addToBlockStore(§ args StoredBlock storedPrev, Block header, TransactionOutputChanges txOutChanges))
        (§ throws BlockStoreException, VerificationException)
    (§ block
        (§ var StoredBlock newBlock = storedPrev.build(§ pars header))
        (§ call blockStore.put(§ pars newBlock, new StoredUndoableBlock(§ pars newBlock.getHeader(§ pars ).getHash(§ pars ), txOutChanges)))
        (§ return newBlock)
    )

    #_override
    #_protected
    (§ method StoredBlock addToBlockStore(§ args StoredBlock storedPrev, Block block))
        (§ throws BlockStoreException, VerificationException)
    (§ block
        (§ var StoredBlock newBlock = storedPrev.build(§ pars block))
        (§ call blockStore.put(§ pars newBlock, new StoredUndoableBlock(§ pars newBlock.getHeader(§ pars ).getHash(§ pars ), block.transactions)))
        (§ return newBlock)
    )

    #_override
    #_protected
    (§ method void rollbackBlockStore(§ args int height))
        (§ throws BlockStoreException)
    (§ block
        (§ throw (§ new BlockStoreException(§ pars "Unsupported")))
    )

    #_override
    #_protected
    (§ method boolean shouldVerifyTransactions(§ args ))
    (§ block
        (§ return true)
    )

    ;;;
     ; Whether or not to run scripts whilst accepting blocks (i.e. checking signatures, for most transactions).
     ; If you're accepting data from an untrusted node, such as one found via the P2P network, this should be set
     ; to true (which is the default).  If you're downloading a chain from a node you control, script execution
     ; is redundant because you know the connected node won't relay bad data to you.  In that case it's safe to set
     ; this to false and obtain a significant speedup.
     ;;
    #_public
    (§ method void setRunScripts(§ args boolean value))
    (§ block
        (§ ass this.runScripts = value)
    )

    ;; TODO: Remove lots of duplicated code in the two connectTransactions.

    ;; TODO: Execute in order of largest transaction (by input count) first.
    (§ field ExecutorService scriptVerificationExecutor = Executors.newFixedThreadPool(§ pars Runtime.getRuntime(§ pars ).availableProcessors(§ pars ), new ContextPropagatingThreadFactory(§ pars "Script verification")))

    ;;;
     ; A job submitted to the executor which verifies signatures.
     ;;
    #_private
    #_static
    (§ class Verifier implements Callable<VerificationException>
        #_final
        (§ field Transaction tx)
        #_final
        (§ field List<Script> prevOutScripts)
        #_final
        (§ field Set<VerifyFlag> verifyFlags)

        #_public
        (§ constructor Verifier(§ args #_final Transaction tx, #_final List<Script> prevOutScripts, #_final Set<VerifyFlag> verifyFlags))
        (§ block
            (§ ass this.tx = tx)
            (§ ass this.prevOutScripts = prevOutScripts)
            (§ ass this.verifyFlags = verifyFlags)
        )

        #_nilable
        #_override
        #_public
        (§ method VerificationException call(§ args ))
            (§ throws Exception)
        (§ block
            (§ try )
            (§ block
                (§ var ListIterator<Script> prevOutIt = prevOutScripts.listIterator(§ pars ))
                (§ for (§ var int index = 0) :for (§ expr index < tx.getInputs(§ pars ).size(§ pars )) :for (§ ass index = index + 1))
                (§ block
                    (§ call tx.getInputs(§ pars ).get(§ pars index).getScriptSig(§ pars ).correctlySpends(§ pars tx, index, prevOutIt.next(§ pars ), verifyFlags))
                )
                (§ return nil)
            )
            (§ catch (§ args VerificationException e))
            (§ block
                (§ return e)
            )
        )
    )

    ;;;
     ; Get the {@link Script} from the script bytes or return Script of empty byte array.
     ;;
    #_private
    (§ method Script getScript(§ args byte[] scriptBytes))
    (§ block
        (§ try )
        (§ block
            (§ return (§ new Script(§ pars scriptBytes)))
        )
        (§ catch (§ args Exception _))
        (§ block
            (§ return (§ new Script(§ pars new byte[0])))
        )
    )

    ;;;
     ; Get the address from the {@link Script} if it exists, otherwise return empty string "".
     ;
     ; @param script The script.
     ; @return The address.
     ;;
    #_private
    (§ method String getScriptAddress(§ args #_nilable Script script))
    (§ block
        (§ var String address = "")
        (§ try )
        (§ block
            (§ if (§ expr script != nil))
            (§ block
                (§ ass address = script.getToAddress(§ pars params, true).toString(§ pars ))
            )
        )
        (§ catch (§ args Exception _))
        (§ block
        )
        (§ return address)
    )

    #_override
    #_protected
    (§ method TransactionOutputChanges connectTransactions(§ args int height, Block block))
        (§ throws VerificationException, BlockStoreException)
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ if (§ expr block.transactions == nil))
        (§ block
            (§ throw (§ new RuntimeException(§ pars "connectTransactions called with Block that didn't have transactions!")))
        )
        (§ if (§ expr !params.passesCheckpoint(§ pars height, block.getHash(§ pars ))))
        (§ block
            (§ throw (§ new VerificationException(§ pars "Block failed checkpoint lockin at " + height)))
        )

        (§ call blockStore.beginDatabaseBatchWrite(§ pars ))

        (§ var LinkedList<UTXO> txOutsSpent = new LinkedList<>(§ pars ))
        (§ var LinkedList<UTXO> txOutsCreated = new LinkedList<>(§ pars ))
        (§ var long sigOps = 0)

        (§ if (§ expr scriptVerificationExecutor.isShutdown(§ pars )))
        (§ block
            (§ ass scriptVerificationExecutor = Executors.newFixedThreadPool(§ pars Runtime.getRuntime(§ pars ).availableProcessors(§ pars )))
        )

        (§ var List<Future<VerificationException>> listScriptVerificationResults = new ArrayList<>(§ pars block.transactions.size(§ pars )))
        (§ try )
        (§ block
            (§ if (§ expr !params.isCheckpoint(§ pars height)))
            (§ block
                ;; BIP30 violator blocks are ones that contain a duplicated transaction.  They are all in the checkpoints list
                ;; and we therefore only check non-checkpoints for duplicated transactions here.  See the BIP30 document
                ;; for more details on this: https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki
                (§ for (§ var Transaction tx) :for (§ expr block.transactions))
                (§ block
                    #_final
                    (§ var Set<VerifyFlag> verifyFlags = params.getTransactionVerificationFlags(§ pars block, tx, getVersionTally(§ pars ), height))
                    (§ var Sha256Hash hash = tx.getHash(§ pars ))
                    ;; If we already have unspent outputs for this hash, we saw the tx already.
                    ;; Either the block is being added twice (bug) or the block is a BIP30 violator.
                    (§ if (§ expr blockStore.hasUnspentOutputs(§ pars hash, tx.getOutputs(§ pars ).size(§ pars ))))
                    (§ block
                        (§ throw (§ new VerificationException(§ pars "Block failed BIP30 test!")))
                    )
                    ;; We already check non-BIP16 sigops in Block.verifyTransactions(true).
                    (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag.P2SH)))
                    (§ block
                        (§ ass sigOps = sigOps + tx.getSigOpCount(§ pars ))
                    )
                )
            )
            (§ var Coin totalFees = Coin.ZERO)
            (§ var Coin coinbaseValue = nil)
            (§ for (§ var #_final Transaction tx) :for (§ expr block.transactions))
            (§ block
                (§ var boolean isCoinBase = tx.isCoinBase(§ pars ))
                (§ var Coin valueIn = Coin.ZERO)
                (§ var Coin valueOut = Coin.ZERO)
                #_final
                (§ var List<Script> prevOutScripts = new LinkedList<>(§ pars ))
                #_final
                (§ var Set<VerifyFlag> verifyFlags = params.getTransactionVerificationFlags(§ pars block, tx, getVersionTally(§ pars ), height))
                (§ if (§ expr !isCoinBase))
                (§ block
                    ;; For each input of the transaction remove the corresponding output from the set of unspent outputs.
                    (§ for (§ var int index = 0) :for (§ expr index < tx.getInputs(§ pars ).size(§ pars )) :for (§ ass index = index + 1))
                    (§ block
                        (§ var TransactionInput in = tx.getInputs(§ pars ).get(§ pars index))
                        (§ var UTXO prevOut = blockStore.getTransactionOutput(§ pars in.getOutpoint(§ pars ).getHash(§ pars ), in.getOutpoint(§ pars ).getIndex(§ pars )))
                        (§ if (§ expr prevOut == nil))
                        (§ block
                            (§ throw (§ new VerificationException(§ pars "Attempted to spend a non-existent or already spent output!")))
                        )
                        ;; Coinbases can't be spent until they mature, to avoid re-orgs destroying entire transaction chains.
                        ;; The assumption is there will ~never be re-orgs deeper than the spendable coinbase chain depth.
                        (§ if (§ expr prevOut.isCoinbase(§ pars )))
                        (§ block
                            (§ if (§ expr height - prevOut.getHeight(§ pars ) < params.getSpendableCoinbaseDepth(§ pars )))
                            (§ block
                                (§ throw (§ new VerificationException(§ pars "Tried to spend coinbase at depth " + (§ expr height - prevOut.getHeight(§ pars )))))
                            )
                        )
                        ;; TODO: Check we're not spending the genesis transaction here. Bitcoin Core won't allow it.
                        (§ ass valueIn = valueIn.add(§ pars prevOut.getValue(§ pars )))
                        (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag.P2SH)))
                        (§ block
                            (§ if (§ expr prevOut.getScript(§ pars ).isPayToScriptHash(§ pars )))
                            (§ block
                                (§ ass sigOps = sigOps + Script.getP2SHSigOpCount(§ pars in.getScriptBytes(§ pars )))
                            )
                            (§ if (§ expr Block.MAX_BLOCK_SIGOPS < sigOps))
                            (§ block
                                (§ throw (§ new VerificationException(§ pars "Too many P2SH SigOps in block")))
                            )
                        )

                        (§ call prevOutScripts.add(§ pars prevOut.getScript(§ pars )))
                        (§ call blockStore.removeUnspentTransactionOutput(§ pars prevOut))
                        (§ call txOutsSpent.add(§ pars prevOut))
                    )
                )
                (§ var Sha256Hash hash = tx.getHash(§ pars ))
                (§ for (§ var TransactionOutput out) :for (§ expr tx.getOutputs(§ pars )))
                (§ block
                    (§ ass valueOut = valueOut.add(§ pars out.getValue(§ pars )))
                    ;; For each output, add it to the set of unspent outputs so it can be consumed in future.
                    (§ var Script script = getScript(§ pars out.getScriptBytes(§ pars )))
                    (§ var UTXO newOut = new UTXO(§ pars hash, out.getIndex(§ pars ), out.getValue(§ pars ), height, isCoinBase, script, getScriptAddress(§ pars script)))
                    (§ call blockStore.addUnspentTransactionOutput(§ pars newOut))
                    (§ call txOutsCreated.add(§ pars newOut))
                )
                ;; All values were already checked for being non-negative (as it is verified in Transaction.verify()),
                ;; but we check again here just for defence in depth.  Transactions with zero output value are OK.
                (§ if (§ expr valueOut.signum(§ pars ) < 0 || 0 < valueOut.compareTo(§ pars params.getMaxMoney(§ pars ))))
                (§ block
                    (§ throw (§ new VerificationException(§ pars "Transaction output value out of range")))
                )

                (§ if (§ expr isCoinBase))
                (§ block
                    (§ ass coinbaseValue = valueOut)
                )
                (§ else )
                (§ block
                    (§ if (§ expr valueIn.compareTo(§ pars valueOut) < 0 || 0 < valueIn.compareTo(§ pars params.getMaxMoney(§ pars ))))
                    (§ block
                        (§ throw (§ new VerificationException(§ pars "Transaction input value out of range")))
                    )
                    (§ ass totalFees = totalFees.add(§ pars valueIn.subtract(§ pars valueOut)))
                )

                (§ if (§ expr !isCoinBase && runScripts))
                (§ block
                    ;; Because correctlySpends modifies transactions, this must come after we are done with tx.
                    (§ var FutureTask<VerificationException> future = new FutureTask<>(§ pars new Verifier(§ pars tx, prevOutScripts, verifyFlags)))
                    (§ call scriptVerificationExecutor.execute(§ pars future))
                    (§ call listScriptVerificationResults.add(§ pars future))
                )
            )
            (§ if (§ expr 0 < totalFees.compareTo(§ pars params.getMaxMoney(§ pars )) || block.getBlockInflation(§ pars height).add(§ pars totalFees).compareTo(§ pars coinbaseValue) < 0))
            (§ block
                (§ throw (§ new VerificationException(§ pars "Transaction fees out of range")))
            )

            (§ for (§ var Future<VerificationException> future) :for (§ expr listScriptVerificationResults))
            (§ block
                (§ var VerificationException e)
                (§ try )
                (§ block
                    (§ ass e = future.get(§ pars ))
                )
                (§ catch (§ args InterruptedException ie))
                (§ block
                    (§ throw (§ new RuntimeException(§ pars ie))) ;; Shouldn't happen.
                )
                (§ catch (§ args ExecutionException ee))
                (§ block
                    (§ call log.error(§ pars "Script.correctlySpends threw a non-normal exception: " + ee.getCause(§ pars )))
                    (§ throw (§ new VerificationException(§ pars "Bug in Script.correctlySpends, likely script malformed in some new and interesting way.", ee)))
                )
                (§ if (§ expr e != nil))
                (§ block
                    (§ throw e)
                )
            )
        )
        (§ catch (§ args VerificationException e))
        (§ block
            (§ call scriptVerificationExecutor.shutdownNow(§ pars ))
            (§ call blockStore.abortDatabaseBatchWrite(§ pars ))
            (§ throw e)
        )
        (§ catch (§ args BlockStoreException e))
        (§ block
            (§ call scriptVerificationExecutor.shutdownNow(§ pars ))
            (§ call blockStore.abortDatabaseBatchWrite(§ pars ))
            (§ throw e)
        )

        (§ return (§ new TransactionOutputChanges(§ pars txOutsCreated, txOutsSpent)))
    )

    #_override
    ;;;
     ; Used during reorgs to connect a block previously on a fork.
     ;;
    #_protected
    #_synchronized
    (§ method TransactionOutputChanges connectTransactions(§ args StoredBlock newBlock))
        (§ throws VerificationException, BlockStoreException, PrunedException)
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ if (§ expr !params.passesCheckpoint(§ pars newBlock.getHeight(§ pars ), newBlock.getHeader(§ pars ).getHash(§ pars ))))
        (§ block
            (§ throw (§ new VerificationException(§ pars "Block failed checkpoint lockin at " + newBlock.getHeight(§ pars ))))
        )

        (§ call blockStore.beginDatabaseBatchWrite(§ pars ))
        (§ var StoredUndoableBlock block = blockStore.getUndoBlock(§ pars newBlock.getHeader(§ pars ).getHash(§ pars )))
        (§ if (§ expr block == nil))
        (§ block
            ;; We're trying to re-org too deep and the data needed has been deleted.
            (§ call blockStore.abortDatabaseBatchWrite(§ pars ))
            (§ throw (§ new PrunedException(§ pars newBlock.getHeader(§ pars ).getHash(§ pars ))))
        )

        (§ var TransactionOutputChanges txOutChanges)
        (§ try )
        (§ block
            (§ var List<Transaction> transactions = block.getTransactions(§ pars ))
            (§ if (§ expr transactions != nil))
            (§ block
                (§ var LinkedList<UTXO> txOutsSpent = new LinkedList<>(§ pars ))
                (§ var LinkedList<UTXO> txOutsCreated = new LinkedList<>(§ pars ))
                (§ var long sigOps = 0)

                (§ if (§ expr !params.isCheckpoint(§ pars newBlock.getHeight(§ pars ))))
                (§ block
                    (§ for (§ var Transaction tx) :for (§ expr transactions))
                    (§ block
                        (§ var Sha256Hash hash = tx.getHash(§ pars ))
                        (§ if (§ expr blockStore.hasUnspentOutputs(§ pars hash, tx.getOutputs(§ pars ).size(§ pars ))))
                        (§ block
                            (§ throw (§ new VerificationException(§ pars "Block failed BIP30 test!")))
                        )
                    )
                )

                (§ var Coin totalFees = Coin.ZERO)
                (§ var Coin coinbaseValue = nil)

                (§ if (§ expr scriptVerificationExecutor.isShutdown(§ pars )))
                (§ block
                    (§ ass scriptVerificationExecutor = Executors.newFixedThreadPool(§ pars Runtime.getRuntime(§ pars ).availableProcessors(§ pars )))
                )

                (§ var List<Future<VerificationException>> listScriptVerificationResults = new ArrayList<>(§ pars transactions.size(§ pars )))
                (§ for (§ var #_final Transaction tx) :for (§ expr transactions))
                (§ block
                    #_final
                    (§ var Set<VerifyFlag> verifyFlags = params.getTransactionVerificationFlags(§ pars newBlock.getHeader(§ pars ), tx, getVersionTally(§ pars ), Integer.SIZE))
                    (§ var boolean isCoinBase = tx.isCoinBase(§ pars ))
                    (§ var Coin valueIn = Coin.ZERO)
                    (§ var Coin valueOut = Coin.ZERO)
                    #_final
                    (§ var List<Script> prevOutScripts = new LinkedList<>(§ pars ))

                    (§ if (§ expr !isCoinBase))
                    (§ block
                        (§ for (§ var int index = 0) :for (§ expr index < tx.getInputs(§ pars ).size(§ pars )) :for (§ ass index = index + 1))
                        (§ block
                            #_final
                            (§ var TransactionInput in = tx.getInputs(§ pars ).get(§ pars index))
                            #_final
                            (§ var UTXO prevOut = blockStore.getTransactionOutput(§ pars in.getOutpoint(§ pars ).getHash(§ pars ), in.getOutpoint(§ pars ).getIndex(§ pars )))
                            (§ if (§ expr prevOut == nil))
                            (§ block
                                (§ throw (§ new VerificationException(§ pars "Attempted spend of a non-existent or already spent output!")))
                            )
                            (§ if (§ expr prevOut.isCoinbase(§ pars ) && newBlock.getHeight(§ pars ) - prevOut.getHeight(§ pars ) < params.getSpendableCoinbaseDepth(§ pars )))
                            (§ block
                                (§ throw (§ new VerificationException(§ pars "Tried to spend coinbase at depth " + (§ expr newBlock.getHeight(§ pars ) - prevOut.getHeight(§ pars )))))
                            )
                            (§ ass valueIn = valueIn.add(§ pars prevOut.getValue(§ pars )))
                            (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag.P2SH)))
                            (§ block
                                (§ if (§ expr prevOut.getScript(§ pars ).isPayToScriptHash(§ pars )))
                                (§ block
                                    (§ ass sigOps = sigOps + Script.getP2SHSigOpCount(§ pars in.getScriptBytes(§ pars )))
                                )
                                (§ if (§ expr sigOps > Block.MAX_BLOCK_SIGOPS))
                                (§ block
                                    (§ throw (§ new VerificationException(§ pars "Too many P2SH SigOps in block")))
                                )
                            )

                            ;; TODO: Enforce DER signature format.

                            (§ call prevOutScripts.add(§ pars prevOut.getScript(§ pars )))

                            (§ call blockStore.removeUnspentTransactionOutput(§ pars prevOut))
                            (§ call txOutsSpent.add(§ pars prevOut))
                        )
                    )
                    (§ var Sha256Hash hash = tx.getHash(§ pars ))
                    (§ for (§ var TransactionOutput out) :for (§ expr tx.getOutputs(§ pars )))
                    (§ block
                        (§ ass valueOut = valueOut.add(§ pars out.getValue(§ pars )))
                        (§ var Script script = getScript(§ pars out.getScriptBytes(§ pars )))
                        (§ var UTXO newOut = new UTXO(§ pars hash, out.getIndex(§ pars ), out.getValue(§ pars ), newBlock.getHeight(§ pars ), isCoinBase, script, getScriptAddress(§ pars script)))
                        (§ call blockStore.addUnspentTransactionOutput(§ pars newOut))
                        (§ call txOutsCreated.add(§ pars newOut))
                    )
                    ;; All values were already checked for being non-negative (as it is verified in Transaction.verify())
                    ;; but we check again here just for defence in depth.  Transactions with zero output value are OK.
                    (§ if (§ expr valueOut.signum(§ pars ) < 0 || 0 < valueOut.compareTo(§ pars params.getMaxMoney(§ pars ))))
                    (§ block
                        (§ throw (§ new VerificationException(§ pars "Transaction output value out of range")))
                    )

                    (§ if (§ expr isCoinBase))
                    (§ block
                        (§ ass coinbaseValue = valueOut)
                    )
                    (§ else )
                    (§ block
                        (§ if (§ expr valueIn.compareTo(§ pars valueOut) < 0 || 0 < valueIn.compareTo(§ pars params.getMaxMoney(§ pars ))))
                        (§ block
                            (§ throw (§ new VerificationException(§ pars "Transaction input value out of range")))
                        )
                        (§ ass totalFees = totalFees.add(§ pars valueIn.subtract(§ pars valueOut)))
                    )

                    (§ if (§ expr !isCoinBase))
                    (§ block
                        ;; Because correctlySpends modifies transactions, this must come after we are done with tx.
                        (§ var FutureTask<VerificationException> future = new FutureTask<>(§ pars new Verifier(§ pars tx, prevOutScripts, verifyFlags)))
                        (§ call scriptVerificationExecutor.execute(§ pars future))
                        (§ call listScriptVerificationResults.add(§ pars future))
                    )
                )
                (§ if (§ expr 0 < totalFees.compareTo(§ pars params.getMaxMoney(§ pars )) || newBlock.getHeader(§ pars ).getBlockInflation(§ pars newBlock.getHeight(§ pars )).add(§ pars totalFees).compareTo(§ pars coinbaseValue) < 0))
                (§ block
                    (§ throw (§ new VerificationException(§ pars "Transaction fees out of range")))
                )

                (§ ass txOutChanges = new TransactionOutputChanges(§ pars txOutsCreated, txOutsSpent))
                (§ for (§ var Future<VerificationException> future) :for (§ expr listScriptVerificationResults))
                (§ block
                    (§ var VerificationException e)
                    (§ try )
                    (§ block
                        (§ ass e = future.get(§ pars ))
                    )
                    (§ catch (§ args InterruptedException ie))
                    (§ block
                        (§ throw (§ new RuntimeException(§ pars ie))) ;; Shouldn't happen.
                    )
                    (§ catch (§ args ExecutionException ee))
                    (§ block
                        (§ call log.error(§ pars "Script.correctlySpends threw a non-normal exception: " + ee.getCause(§ pars )))
                        (§ throw (§ new VerificationException(§ pars "Bug in Script.correctlySpends, likely script malformed in some new and interesting way.", ee)))
                    )
                    (§ if (§ expr e != nil))
                    (§ block
                        (§ throw e)
                    )
                )
            )
            (§ else )
            (§ block
                (§ ass txOutChanges = block.getTxOutChanges(§ pars ))
                (§ if (§ expr !params.isCheckpoint(§ pars newBlock.getHeight(§ pars ))))
                (§ block
                    (§ for (§ var UTXO out) :for (§ expr txOutChanges.txOutsCreated))
                    (§ block
                        (§ var Sha256Hash hash = out.getHash(§ pars ))
                        (§ if (§ expr blockStore.getTransactionOutput(§ pars hash, out.getIndex(§ pars )) != nil))
                        (§ block
                            (§ throw (§ new VerificationException(§ pars "Block failed BIP30 test!")))
                        )
                    )
                )
                (§ for (§ var UTXO out) :for (§ expr txOutChanges.txOutsCreated))
                (§ block
                    (§ call blockStore.addUnspentTransactionOutput(§ pars out))
                )
                (§ for (§ var UTXO out) :for (§ expr txOutChanges.txOutsSpent))
                (§ block
                    (§ call blockStore.removeUnspentTransactionOutput(§ pars out))
                )
            )
        )
        (§ catch (§ args VerificationException e))
        (§ block
            (§ call scriptVerificationExecutor.shutdownNow(§ pars ))
            (§ call blockStore.abortDatabaseBatchWrite(§ pars ))
            (§ throw e)
        )
        (§ catch (§ args BlockStoreException e))
        (§ block
            (§ call scriptVerificationExecutor.shutdownNow(§ pars ))
            (§ call blockStore.abortDatabaseBatchWrite(§ pars ))
            (§ throw e)
        )
        (§ return txOutChanges)
    )

    ;;;
     ; This is broken for blocks that do not pass BIP30, so all BIP30-failing blocks which are allowed to fail BIP30
     ; must be checkpointed.
     ;;
    #_override
    #_protected
    (§ method void disconnectTransactions(§ args StoredBlock oldBlock))
        (§ throws PrunedException, BlockStoreException)
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ call blockStore.beginDatabaseBatchWrite(§ pars ))
        (§ try )
        (§ block
            (§ var StoredUndoableBlock undoBlock = blockStore.getUndoBlock(§ pars oldBlock.getHeader(§ pars ).getHash(§ pars )))
            (§ if (§ expr undoBlock == nil))
            (§ block
                (§ throw (§ new PrunedException(§ pars oldBlock.getHeader(§ pars ).getHash(§ pars ))))
            )

            (§ var TransactionOutputChanges txOutChanges = undoBlock.getTxOutChanges(§ pars ))
            (§ for (§ var UTXO out) :for (§ expr txOutChanges.txOutsSpent))
            (§ block
                (§ call blockStore.addUnspentTransactionOutput(§ pars out))
            )
            (§ for (§ var UTXO out) :for (§ expr txOutChanges.txOutsCreated))
            (§ block
                (§ call blockStore.removeUnspentTransactionOutput(§ pars out))
            )
        )
        (§ catch (§ args PrunedException e))
        (§ block
            (§ call blockStore.abortDatabaseBatchWrite(§ pars ))
            (§ throw e)
        )
        (§ catch (§ args BlockStoreException e))
        (§ block
            (§ call blockStore.abortDatabaseBatchWrite(§ pars ))
            (§ throw e)
        )
    )

    #_override
    #_protected
    (§ method void doSetChainHead(§ args StoredBlock chainHead))
        (§ throws BlockStoreException)
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ call blockStore.setVerifiedChainHead(§ pars chainHead))
        (§ call blockStore.commitDatabaseBatchWrite(§ pars ))
    )

    #_override
    #_protected
    (§ method void notSettingChainHead(§ args ))
        (§ throws BlockStoreException)
    (§ block
        (§ call blockStore.abortDatabaseBatchWrite(§ pars ))
    )

    #_override
    #_protected
    (§ method StoredBlock getStoredBlockInCurrentScope(§ args Sha256Hash hash))
        (§ throws BlockStoreException)
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ return blockStore.getOnceUndoableStoredBlock(§ pars hash))
    )
)

#_(ns org.bitcoinj.core #_"GetAddrMessage")

;;;
 ; <p>Represents the "getaddr" P2P protocol message, which requests network {@link AddressMessage}s from a peer.
 ; Not to be confused with {@link Address} which is sort of like an account number.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class GetAddrMessage extends EmptyMessage
    #_public
    (§ constructor GetAddrMessage(§ args NetworkParameters params))
    (§ block
        (§ super (§ pars params))
    )
)

#_(ns org.bitcoinj.core #_"GetBlocksMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList List]))

;;;
 ; <p>Represents the "getblocks" P2P network message, which requests the hashes of the parts of the block chain we're missing.
 ; Those blocks can then be downloaded with a {@link GetDataMessage}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class GetBlocksMessage extends Message
    #_protected
    (§ field long version)
    #_protected
    (§ field List<Sha256Hash> locator)
    #_protected
    (§ field Sha256Hash stopHash)

    #_public
    (§ constructor GetBlocksMessage(§ args NetworkParameters params, List<Sha256Hash> locator, Sha256Hash stopHash))
    (§ block
        (§ super (§ pars params))

        (§ ass this.version = protocolVersion)
        (§ ass this.locator = locator)
        (§ ass this.stopHash = stopHash)
    )

    #_public
    (§ constructor GetBlocksMessage(§ args NetworkParameters params, byte[] payload))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, 0))
    )

    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ ass cursor = offset)
        (§ ass version = readUint32(§ pars ))
        (§ var int startCount = (§ cast int)readVarInt(§ pars ))
        (§ if (§ expr 500 < startCount))
        (§ block
            (§ throw (§ new ProtocolException(§ pars "Number of locators cannot be > 500, received: " + startCount)))
        )

        (§ ass length = cursor - offset + (§ expr (§ expr startCount + 1) * 32))
        (§ ass locator = new ArrayList<>(§ pars startCount))
        (§ for (§ var int i = 0) :for (§ expr i < startCount) :for (§ ass i = i + 1))
        (§ block
            (§ call locator.add(§ pars readHash(§ pars )))
        )
        (§ ass stopHash = readHash(§ pars ))
    )

    #_public
    (§ method List<Sha256Hash> getLocator(§ args ))
    (§ block
        (§ return locator)
    )

    #_public
    (§ method Sha256Hash getStopHash(§ args ))
    (§ block
        (§ return stopHash)
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return "getblocks: " + Utils.SPACE_JOINER.join(§ pars locator))
    )

    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        ;; Version, for some reason.
        (§ call Utils.uint32ToByteStreamLE(§ pars params.getProtocolVersionNum(§ pars NetworkParameters.ProtocolVersion.CURRENT), stream))
        ;; Then a vector of block hashes.  This is actually a "block locator", a set of block
        ;; identifiers that spans the entire chain with exponentially increasing gaps between
        ;; them, until we end up at the genesis block.  See CBlockLocator::Set().
        (§ call stream.write(§ pars (§ new VarInt(§ pars locator.size(§ pars ))).encode(§ pars )))
        (§ for (§ var Sha256Hash hash) :for (§ expr locator))
        (§ block
            ;; Have to reverse as wire format is little endian.
            (§ call stream.write(§ pars hash.getReversedBytes(§ pars )))
        )
        ;; Next, a block ID to stop at.
        (§ call stream.write(§ pars stopHash.getReversedBytes(§ pars )))
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var GetBlocksMessage other = (§ cast GetBlocksMessage)o)
        (§ return (§ expr version == other.version && stopHash.equals(§ pars other.stopHash) && locator.size(§ pars ) == other.locator.size(§ pars ) && locator.containsAll(§ pars other.locator))) ;; ignores locator ordering
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ var int hashCode = (§ cast int)version :xor "getblocks".hashCode(§ pars ) :xor stopHash.hashCode(§ pars ))
        (§ for (§ var Sha256Hash l) :for (§ expr locator))
        (§ block
            (§ ass hashCode = hashCode :xor l.hashCode(§ pars )) ;; ignores locator ordering
        )
        (§ return hashCode)
    )
)

#_(ns org.bitcoinj.core #_"GetDataMessage")

;;;
 ; <p>Represents the "getdata" P2P network message, which requests the contents of blocks or transactions given their hashes.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class GetDataMessage extends ListMessage
    #_public
    (§ constructor GetDataMessage(§ args NetworkParameters params, byte[] payloadBytes))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payloadBytes))
    )

    ;;;
     ; Deserializes a 'getdata' message.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor GetDataMessage(§ args NetworkParameters params, byte[] payload, MessageSerializer serializer, int length))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, serializer, length))
    )

    #_public
    (§ constructor GetDataMessage(§ args NetworkParameters params))
    (§ block
        (§ super (§ pars params))
    )

    #_public
    (§ method void addTransaction(§ args Sha256Hash hash))
    (§ block
        (§ call addItem(§ pars (§ new InventoryItem(§ pars InventoryItem.Type.Transaction, hash))))
    )

    #_public
    (§ method void addBlock(§ args Sha256Hash hash))
    (§ block
        (§ call addItem(§ pars (§ new InventoryItem(§ pars InventoryItem.Type.Block, hash))))
    )

    #_public
    (§ method void addFilteredBlock(§ args Sha256Hash hash))
    (§ block
        (§ call addItem(§ pars (§ new InventoryItem(§ pars InventoryItem.Type.FilteredBlock, hash))))
    )

    #_public
    (§ method Sha256Hash getHashOf(§ args int i))
    (§ block
        (§ return getItems(§ pars ).get(§ pars i).hash)
    )
)

#_(ns org.bitcoinj.core #_"GetHeadersMessage"
    (:import [java.util List]))

;;;
 ; <p>The "getheaders" command is structurally identical to "getblocks", but has different meaning.  On receiving this
 ; message a Bitcoin node returns matching blocks up to the limit, but without the bodies.  It is useful as an
 ; optimization: when your wallet does not contain any keys created before a particular time, you don't have to download
 ; the bodies for those blocks because you know there are no relevant transactions.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class GetHeadersMessage extends GetBlocksMessage
    #_public
    (§ constructor GetHeadersMessage(§ args NetworkParameters params, List<Sha256Hash> locator, Sha256Hash stopHash))
    (§ block
        (§ super (§ pars params, locator, stopHash))
    )

    #_public
    (§ constructor GetHeadersMessage(§ args NetworkParameters params, byte[] payload))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return "getheaders: " + Utils.SPACE_JOINER.join(§ pars locator))
    )

    ;;;
     ; Compares two getheaders messages.  Note that even though they are structurally identical a GetHeadersMessage
     ; will not compare equal to a GetBlocksMessage containing the same data.
     ;;
    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var GetHeadersMessage other = (§ cast GetHeadersMessage)o)
        (§ return (§ expr version == other.version && stopHash.equals(§ pars other.stopHash) && locator.size(§ pars ) == other.locator.size(§ pars ) && locator.containsAll(§ pars other.locator))) ;; ignores locator ordering
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ var int hashCode = (§ cast int)version :xor "getheaders".hashCode(§ pars ) :xor stopHash.hashCode(§ pars ))
        (§ for (§ var Sha256Hash l) :for (§ expr locator))
        (§ block
            (§ ass hashCode = hashCode :xor l.hashCode(§ pars )) ;; ignores locator ordering
        )
        (§ return hashCode)
    )
)

#_(ns org.bitcoinj.core #_"HeadersMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Arrays List])
    (:import [org.slf4j Logger LoggerFactory]))

;;;
 ; <p>A protocol message that contains a repeated series of block headers, sent in response to the "getheaders" command.
 ; This is useful when you want to traverse the chain but know you don't care about the block contents, for example,
 ; because you have a freshly created wallet with no keys.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class HeadersMessage extends Message
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars HeadersMessage.class))

    ;; The main client will never send us more than this number of headers.
    #_public
    #_static
    #_final
    (§ field int MAX_HEADERS = 2000)

    #_private
    (§ field List<Block> blockHeaders)

    #_public
    (§ constructor HeadersMessage(§ args NetworkParameters params, byte[] payload))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, 0))
    )

    #_public
    (§ constructor HeadersMessage(§ args NetworkParameters params, Block... headers))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params))
        (§ ass blockHeaders = Arrays.asList(§ pars headers))
    )

    #_public
    (§ constructor HeadersMessage(§ args NetworkParameters params, List<Block> headers))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params))
        (§ ass blockHeaders = headers)
    )

    #_override
    #_public
    (§ method void bitcoinSerializeToStream(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ call stream.write(§ pars (§ new VarInt(§ pars blockHeaders.size(§ pars ))).encode(§ pars )))
        (§ for (§ var Block header) :for (§ expr blockHeaders))
        (§ block
            (§ call header.cloneAsHeader(§ pars ).bitcoinSerializeToStream(§ pars stream))
            (§ call stream.write(§ pars 0))
        )
    )

    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ var long numHeaders = readVarInt(§ pars ))
        (§ if (§ expr MAX_HEADERS < numHeaders))
        (§ block
            (§ throw (§ new ProtocolException(§ pars "Too many headers: got " + numHeaders + " which is larger than " + MAX_HEADERS)))
        )

        (§ ass blockHeaders = new ArrayList<>(§ pars ))
        #_final
        (§ var BitcoinSerializer serializer = this.params.getSerializer(§ pars true))

        (§ for (§ var int i = 0) :for (§ expr i < numHeaders) :for (§ ass i = i + 1))
        (§ block
            #_final
            (§ var Block newBlockHeader = serializer.makeBlock(§ pars payload, cursor, UNKNOWN_LENGTH))
            (§ if (§ expr newBlockHeader.hasTransactions(§ pars )))
            (§ block
                (§ throw (§ new ProtocolException(§ pars "Block header does not end with a nil byte")))
            )

            (§ ass cursor = cursor + newBlockHeader.optimalEncodingMessageSize)
            (§ call blockHeaders.add(§ pars newBlockHeader))
        )

        (§ if (§ expr length == UNKNOWN_LENGTH))
        (§ block
            (§ ass length = cursor - offset)
        )

        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ for (§ var int i = 0) :for (§ expr i < numHeaders) :for (§ ass i = i + 1))
            (§ block
                (§ call log.debug(§ pars this.blockHeaders.get(§ pars i).toString(§ pars )))
            )
        )
    )

    #_public
    (§ method List<Block> getBlockHeaders(§ args ))
    (§ block
        (§ return blockHeaders)
    )
)

#_(ns org.bitcoinj.core #_"InsufficientMoneyException"
    (:import [com.google.common.base Preconditions]))

;;;
 ; Thrown to indicate that you don't have enough money available to perform the requested operation.
 ;;
#_public
(§ class InsufficientMoneyException extends Exception
    ;;; Contains the number of satoshis that would have been required to complete the operation. ;;
    #_nilable
    #_public
    #_final
    (§ field Coin missing)

    #_protected
    (§ constructor InsufficientMoneyException(§ args ))
    (§ block
        (§ ass this.missing = nil)
    )

    #_public
    (§ constructor InsufficientMoneyException(§ args Coin missing))
    (§ block
        (§ this (§ pars missing, "Insufficient money,  missing " + missing.toFriendlyString(§ pars )))
    )

    #_public
    (§ constructor InsufficientMoneyException(§ args Coin missing, String message))
    (§ block
        (§ super (§ pars message))
        (§ ass this.missing = Preconditions.checkNotNull(§ pars missing))
    )
)

#_(ns org.bitcoinj.core #_"InventoryItem"
    (:import [com.google.common.base Objects]))

#_public
(§ class InventoryItem
    ;;;
     ; 4 byte uint32 type field + 32 byte hash
     ;;
    #_static
    #_final
    (§ field int MESSAGE_LENGTH = 36)

    #_public
    (§ enum Type
        (§ item Error)
        (§ item Transaction)
        (§ item Block)
        (§ item FilteredBlock)
    )

    #_public
    #_final
    (§ field Type type)
    #_public
    #_final
    (§ field Sha256Hash hash)

    #_public
    (§ constructor InventoryItem(§ args Type type, Sha256Hash hash))
    (§ block
        (§ ass this.type = type)
        (§ ass this.hash = hash)
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return type + ": " + hash)
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var InventoryItem other = (§ cast InventoryItem)o)
        (§ return (§ expr type == other.type && hash.equals(§ pars other.hash)))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars type, hash))
    )
)

#_(ns org.bitcoinj.core #_"InventoryMessage"
    (:import [com.google.common.base Preconditions]))

;;;
 ; <p>Represents the "inv" P2P network message.  An inv contains a list of hashes of either blocks or transactions.
 ; It's a bandwidth optimization - on receiving some data, a (fully validating) peer sends every connected peer an inv
 ; containing the hash of what it saw.  It'll only transmit the full thing if a peer asks for it with a
 ; {@link GetDataMessage}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class InventoryMessage extends ListMessage
    ;;; A hard coded constant in the protocol. ;;
    #_public
    #_static
    #_final
    (§ field int MAX_INV_SIZE = 50000)

    #_public
    (§ constructor InventoryMessage(§ args NetworkParameters params, byte[] bytes))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, bytes))
    )

    ;;;
     ; Deserializes an 'inv' message.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor InventoryMessage(§ args NetworkParameters params, byte[] payload, MessageSerializer serializer, int length))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, serializer, length))
    )

    #_public
    (§ constructor InventoryMessage(§ args NetworkParameters params))
    (§ block
        (§ super (§ pars params))
    )

    #_public
    (§ method void addBlock(§ args Block block))
    (§ block
        (§ call addItem(§ pars (§ new InventoryItem(§ pars InventoryItem.Type.Block, block.getHash(§ pars )))))
    )

    #_public
    (§ method void addTransaction(§ args Transaction tx))
    (§ block
        (§ call addItem(§ pars (§ new InventoryItem(§ pars InventoryItem.Type.Transaction, tx.getHash(§ pars )))))
    )

    ;;; Creates a new inv message for the given transactions. ;;
    #_public
    #_static
    (§ method InventoryMessage with(§ args Transaction... txs))
    (§ block
        (§ call Preconditions.checkArgument(§ pars 0 < txs.length))
        (§ var InventoryMessage result = new InventoryMessage(§ pars txs[0].getParams(§ pars )))
        (§ for (§ var Transaction tx) :for (§ expr txs))
        (§ block
            (§ call result.addTransaction(§ pars tx))
        )
        (§ return result)
    )
)

#_(ns org.bitcoinj.core #_"ListMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Collections List]))

;;;
 ; <p>Abstract superclass of classes with list based payload, i.e. InventoryMessage and GetDataMessage.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
(§ class ListMessage extends Message
    #_public
    #_static
    #_final
    (§ field long MAX_INVENTORY_ITEMS = 50000)

    #_private
    (§ field long arrayLen)
    ;; For some reason the compiler complains if this is inside InventoryItem.
    #_protected
    (§ field List<InventoryItem> items)

    #_public
    (§ constructor ListMessage(§ args NetworkParameters params, byte[] bytes))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, bytes, 0))
    )

    #_public
    (§ constructor ListMessage(§ args NetworkParameters params, byte[] payload, MessageSerializer serializer, int length))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, 0, serializer, length))
    )

    #_public
    (§ constructor ListMessage(§ args NetworkParameters params))
    (§ block
        (§ super (§ pars params))

        (§ ass items = new ArrayList<>(§ pars ))
        (§ ass length = 1) ;; length of 0 varint
    )

    #_public
    (§ method List<InventoryItem> getItems(§ args ))
    (§ block
        (§ return Collections.unmodifiableList(§ pars items))
    )

    #_public
    (§ method void addItem(§ args InventoryItem item))
    (§ block
        (§ call unCache(§ pars ))
        (§ ass length = length - VarInt.sizeOf(§ pars items.size(§ pars )))
        (§ call items.add(§ pars item))
        (§ ass length = length + VarInt.sizeOf(§ pars items.size(§ pars )) + InventoryItem.MESSAGE_LENGTH)
    )

    #_public
    (§ method void removeItem(§ args int index))
    (§ block
        (§ call unCache(§ pars ))
        (§ ass length = length - VarInt.sizeOf(§ pars items.size(§ pars )))
        (§ call items.remove(§ pars index))
        (§ ass length = length + VarInt.sizeOf(§ pars items.size(§ pars )) - InventoryItem.MESSAGE_LENGTH)
    )

    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ ass arrayLen = readVarInt(§ pars ))
        (§ if (§ expr MAX_INVENTORY_ITEMS < arrayLen))
        (§ block
            (§ throw (§ new ProtocolException(§ pars "Too many items in INV message: " + arrayLen)))
        )
        (§ ass length = (§ cast int)(§ expr cursor - offset + (§ expr arrayLen * InventoryItem.MESSAGE_LENGTH)))

        ;; An inv is vector<CInv> where CInv is int+hash.  The int is either 1 or 2 for tx or block.
        (§ ass items = new ArrayList<>(§ pars (§ cast int)arrayLen))
        (§ for (§ var int i = 0) :for (§ expr i < arrayLen) :for (§ ass i = i + 1))
        (§ block
            (§ if (§ expr payload.length < cursor + InventoryItem.MESSAGE_LENGTH))
            (§ block
                (§ throw (§ new ProtocolException(§ pars "Ran off the end of the INV")))
            )

            (§ var int typeCode = (§ cast int)readUint32(§ pars ))
            (§ var InventoryItem.Type type)
            ;; see ppszTypeName in net.h
            (§ switch (§ expr typeCode))
            (§ block
                (§ case 0)
                (§ block
                    (§ ass type = InventoryItem.Type.Error)
                    (§ break )
                )
                (§ case 1)
                (§ block
                    (§ ass type = InventoryItem.Type.Transaction)
                    (§ break )
                )
                (§ case 2)
                (§ block
                    (§ ass type = InventoryItem.Type.Block)
                    (§ break )
                )
                (§ case 3)
                (§ block
                    (§ ass type = InventoryItem.Type.FilteredBlock)
                    (§ break )
                )
                (§ default )
                (§ block
                    (§ throw (§ new ProtocolException(§ pars "Unknown CInv type: " + typeCode)))
                )
            )
            (§ call items.add(§ pars (§ new InventoryItem(§ pars type, readHash(§ pars )))))
        )
        (§ ass payload = nil)
    )

    #_override
    #_public
    (§ method void bitcoinSerializeToStream(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ call stream.write(§ pars (§ new VarInt(§ pars items.size(§ pars ))).encode(§ pars )))
        (§ for (§ var InventoryItem i) :for (§ expr items))
        (§ block
            ;; Write out the type code.
            (§ call Utils.uint32ToByteStreamLE(§ pars i.type.ordinal(§ pars ), stream))
            ;; And now the hash.
            (§ call stream.write(§ pars i.hash.getReversedBytes(§ pars )))
        )
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return items.equals(§ pars (§ expr (§ cast ListMessage)o).items))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return items.hashCode(§ pars ))
    )
)

#_(ns org.bitcoinj.core #_"MemoryPoolMessage"
    (:import [java.io IOException OutputStream]))

;;;
 ; <p>The "mempool" message asks a remote peer to announce all transactions in its memory pool, possibly restricted by
 ; any Bloom filter set on the connection.  The list of transaction hashes comes back in an inv message.  Note that
 ; this is different to the {@link TxConfidenceTable} object which doesn't try to keep track of all pending transactions,
 ; it's just a holding area for transactions that a part of the app may find interesting.  The mempool message has
 ; no fields.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class MemoryPoolMessage extends Message
    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
    )

    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
    )
)

#_(ns org.bitcoinj.core #_"Message"
    (:import [java.io *]
             [java.math BigInteger]
             [java.util Arrays])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory]))

;;;
 ; <p>A Message is a data structure that can be serialized/deserialized using the Bitcoin serialization format.
 ; Specific types of messages that are used both in the block chain, and on the wire, are derived from this class.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
(§ class Message
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars Message.class))

    #_public
    #_static
    #_final
    (§ field int MAX_SIZE = 0x02000000) ;; 32MB

    #_public
    #_static
    #_final
    (§ field int UNKNOWN_LENGTH = Integer.MIN_VALUE)

    ;; Useful to ensure serialize/deserialize are consistent with each other.
    #_private
    #_static
    #_final
    (§ field boolean SELF_CHECK = false)

    ;; The offset is how many bytes into the provided byte array this message payload starts at.
    #_protected
    (§ field int offset)
    ;; The cursor keeps track of where we are in the byte array as we parse it.
    ;; Note that it's relative to the start of the array NOT the start of the message payload.
    #_protected
    (§ field int cursor)

    #_protected
    (§ field int length = UNKNOWN_LENGTH)

    ;; The raw message payload bytes themselves.
    #_protected
    (§ field byte[] payload)

    #_protected
    (§ field boolean recached = false)
    #_protected
    (§ field MessageSerializer serializer)

    #_protected
    (§ field int protocolVersion)

    #_protected
    (§ field NetworkParameters params)

    #_protected
    (§ constructor Message(§ args ))
    (§ block
        (§ ass serializer = DummySerializer.DEFAULT)
    )

    #_protected
    (§ constructor Message(§ args NetworkParameters params))
    (§ block
        (§ ass this.params = params)
        (§ ass serializer = params.getDefaultSerializer(§ pars ))
    )

    #_protected
    (§ constructor Message(§ args NetworkParameters params, byte[] payload, int offset, int protocolVersion))
        (§ throws ProtocolException)
    (§ block
        (§ this (§ pars params, payload, offset, protocolVersion, params.getDefaultSerializer(§ pars ), UNKNOWN_LENGTH))
    )

    ;;;
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param protocolVersion Bitcoin protocol version.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message payload if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_protected
    (§ constructor Message(§ args NetworkParameters params, byte[] payload, int offset, int protocolVersion, MessageSerializer serializer, int length))
        (§ throws ProtocolException)
    (§ block
        (§ ass this.serializer = serializer)
        (§ ass this.protocolVersion = protocolVersion)
        (§ ass this.params = params)
        (§ ass this.payload = payload)
        (§ ass this.cursor = this.offset = offset)
        (§ ass this.length = length)

        (§ call parse(§ pars ))

        (§ if (§ expr this.length == UNKNOWN_LENGTH))
        (§ block
            (§ call Preconditions.checkState(§ pars false, "Length field has not been set in constructor for %s after parse.", getClass(§ pars ).getSimpleName(§ pars )))
        )

        (§ if (§ expr SELF_CHECK))
        (§ block
            (§ call selfCheck(§ pars payload, offset))
        )

        (§ if (§ expr !serializer.isParseRetainMode(§ pars )))
        (§ block
            (§ ass this.payload = nil)
        )
    )

    #_private
    (§ method void selfCheck(§ args byte[] payload, int offset))
    (§ block
        (§ if (§ expr !(§ expr this instanceof VersionMessage)))
        (§ block
            (§ var byte[] payloadBytes = new byte[cursor - offset])
            (§ call System.arraycopy(§ pars payload, offset, payloadBytes, 0, cursor - offset))
            (§ var byte[] reserialized = bitcoinSerialize(§ pars ))
            (§ if (§ expr !Arrays.equals(§ pars reserialized, payloadBytes)))
            (§ block
                (§ throw (§ new RuntimeException(§ pars "Serialization is wrong: \n" + Utils.HEX.encode(§ pars reserialized) + " vs \n" + Utils.HEX.encode(§ pars payloadBytes))))
            )
        )
    )

    #_protected
    (§ constructor Message(§ args NetworkParameters params, byte[] payload, int offset))
        (§ throws ProtocolException)
    (§ block
        (§ this (§ pars params, payload, offset, params.getProtocolVersionNum(§ pars NetworkParameters.ProtocolVersion.CURRENT), params.getDefaultSerializer(§ pars ), UNKNOWN_LENGTH))
    )

    #_protected
    (§ constructor Message(§ args NetworkParameters params, byte[] payload, int offset, MessageSerializer serializer, int length))
        (§ throws ProtocolException)
    (§ block
        (§ this (§ pars params, payload, offset, params.getProtocolVersionNum(§ pars NetworkParameters.ProtocolVersion.CURRENT), serializer, length))
    )

    ;; These methods handle the serialization/deserialization using the custom Bitcoin protocol.

    #_protected
    #_abstract
    (§ method void parse(§ args ))
        (§ throws ProtocolException)

    ;;;
     ; <p>To be called before any change of internal values including any setters.  This ensures any cached byte array is
     ; removed.<p/>
     ; <p>Child messages of this object (e.g. Transactions belonging to a Block) will not have their internal byte caches
     ; invalidated unless they are also modified internally.</p>
     ;;
    #_protected
    (§ method void unCache(§ args ))
    (§ block
        (§ ass payload = nil)
        (§ ass recached = false)
    )

    #_protected
    (§ method void adjustLength(§ args int newArraySize, int adjustment))
    (§ block
        (§ if (§ expr length == UNKNOWN_LENGTH))
        (§ block
            (§ return )
        )
        ;; Our own length is now unknown if we have an unknown length adjustment.
        (§ if (§ expr adjustment == UNKNOWN_LENGTH))
        (§ block
            (§ ass length = UNKNOWN_LENGTH)
            (§ return )
        )
        (§ ass length = length + adjustment)
        ;; Check if we will need more bytes to encode the length prefix.
        (§ if (§ expr newArraySize == 1))
        (§ block
            (§ ass length = length + 1) ;; The assumption here is we never call adjustLength with the same arraySize as before.
        )
        (§ elseif (§ expr newArraySize != 0))
        (§ block
            (§ ass length = length + VarInt.sizeOf(§ pars newArraySize) - VarInt.sizeOf(§ pars newArraySize - 1))
        )
    )

    ;;;
     ; used for unit testing
     ;;
    #_public
    (§ method boolean isCached(§ args ))
    (§ block
        (§ return (§ expr payload != nil))
    )

    #_public
    (§ method boolean isRecached(§ args ))
    (§ block
        (§ return recached)
    )

    ;;;
     ; Returns a copy of the array returned by {@link Message#unsafeBitcoinSerialize()}, which is safe to mutate.
     ; If you need extra performance and can guarantee you won't write to the array, you can use the unsafe version.
     ;
     ; @return a freshly allocated serialized byte array.
     ;;
    #_public
    (§ method byte[] bitcoinSerialize(§ args ))
    (§ block
        (§ var byte[] bytes = unsafeBitcoinSerialize(§ pars ))
        (§ var byte[] copy = new byte[bytes.length])
        (§ call System.arraycopy(§ pars bytes, 0, copy, 0, bytes.length))
        (§ return copy)
    )

    ;;;
     ; Serialize this message to a byte array that conforms to the bitcoin wire protocol.
     ; <br/>
     ; This method may return the original byte array used to construct this message if the
     ; following conditions are met:
     ; <ol>
     ; <li>1. The message was parsed from a byte array with parseRetain = true.</li>
     ; <li>2. The message has not been modified.</li>
     ; <li>3. The array had an offset of 0 and no surplus bytes.</li>
     ; </ol>
     ;
     ; If condition 3 is not met then an copy of the relevant portion of the array will be returned.
     ; Otherwise a full serialize will occur.  For this reason you should only use this API
     ; if you can guarantee you will treat the resulting array as read only.
     ;
     ; @return a byte array owned by this object, do NOT mutate it.
     ;;
    #_public
    (§ method byte[] unsafeBitcoinSerialize(§ args ))
    (§ block
        ;; 1st attempt to use a cached array.
        (§ if (§ expr payload != nil))
        (§ block
            ;; Cached byte array is the entire message with no extras so we can return as is and avoid an array copy.
            (§ if (§ expr offset == 0 && length == payload.length))
            (§ block
                (§ return payload)
            )

            (§ var byte[] buf = new byte[length])
            (§ call System.arraycopy(§ pars payload, offset, buf, 0, length))
            (§ return buf)
        )

        ;; No cached array available so serialize parts by stream.
        (§ var ByteArrayOutputStream stream = new UnsafeByteArrayOutputStream(§ pars length < 32 ? 32 :else length + 32))
        (§ try )
        (§ block
            (§ call bitcoinSerializeToStream(§ pars stream))
        )
        (§ catch (§ args IOException _))
        (§ block
            ;; Cannot happen, we are serializing to a memory stream.
        )

        (§ if (§ expr serializer.isParseRetainMode(§ pars )))
        (§ block
            ;; A free set of steak knives!
            ;; If there happens to be a call to this method we gain an opportunity to recache
            ;; the byte array and in this case it contains no bytes from parent messages.
            ;; This give a dual benefit.  Releasing references to the larger byte array so that it
            ;; it is more likely to be GC'd.  And preventing double serializations.  E.g. calculating
            ;; merkle root calls this method.  It is will frequently happen prior to serializing the block
            ;; which means another call to bitcoinSerialize is coming.  If we didn't recache then internal
            ;; serialization would occur a 2nd time and every subsequent time the message is serialized.
            (§ ass payload = stream.toByteArray(§ pars ))
            (§ ass cursor = cursor - offset)
            (§ ass offset = 0)
            (§ ass recached = true)
            (§ ass length = payload.length)
            (§ return payload)
        )
        ;; Record length.  If this Message wasn't parsed from a byte stream it won't have length field
        ;; set (except for static length message types).  Setting it makes future streaming more efficient
        ;; because we can preallocate the ByteArrayOutputStream buffer and avoid resizing.
        (§ var byte[] buf = stream.toByteArray(§ pars ))
        (§ ass length = buf.length)
        (§ return buf)
    )

    ;;;
     ; Serialize this message to the provided OutputStream using the bitcoin wire format.
     ;
     ; @param stream
     ; @throws IOException
     ;;
    #_public
    #_final
    (§ method void bitcoinSerialize(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        ;; 1st check for cached bytes.
        (§ if (§ expr payload != nil && length != UNKNOWN_LENGTH))
        (§ block
            (§ call stream.write(§ pars payload, offset, length))
            (§ return )
        )

        (§ call bitcoinSerializeToStream(§ pars stream))
    )

    ;;;
     ; Serializes this message to the provided stream.  If you just want the raw bytes use bitcoinSerialize().
     ;;
    #_protected
    (§ method void bitcoinSerializeToStream(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ call log.error(§ pars "Error: {} class has not implemented bitcoinSerializeToStream method.  Generating message with no payload", getClass(§ pars )))
    )

    ;;;
     ; This method is a NOP for all classes except Block and Transaction.  It is only declared in Message
     ; so BitcoinSerializer can avoid 2 instanceof checks + a casting.
     ;;
    #_public
    (§ method Sha256Hash getHash(§ args ))
    (§ block
        (§ throw (§ new UnsupportedOperationException(§ pars )))
    )

    ;;;
     ; This returns a correct value by parsing the message.
     ;;
    #_public
    #_final
    (§ method int getMessageSize(§ args ))
    (§ block
        (§ if (§ expr length == UNKNOWN_LENGTH))
        (§ block
            (§ call Preconditions.checkState(§ pars false, "Length field has not been set in %s.", getClass(§ pars ).getSimpleName(§ pars )))
        )
        (§ return length)
    )

    #_protected
    (§ method long readUint32(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ try )
        (§ block
            (§ var long u = Utils.readUint32(§ pars payload, cursor))
            (§ ass cursor = cursor + 4)
            (§ return u)
        )
        (§ catch (§ args ArrayIndexOutOfBoundsException e))
        (§ block
            (§ throw (§ new ProtocolException(§ pars e)))
        )
    )

    #_protected
    (§ method long readInt64(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ try )
        (§ block
            (§ var long u = Utils.readInt64(§ pars payload, cursor))
            (§ ass cursor = cursor + 8)
            (§ return u)
        )
        (§ catch (§ args ArrayIndexOutOfBoundsException e))
        (§ block
            (§ throw (§ new ProtocolException(§ pars e)))
        )
    )

    #_protected
    (§ method BigInteger readUint64(§ args ))
        (§ throws ProtocolException)
    (§ block
        ;; Java does not have an unsigned 64 bit type. So scrape it off the wire then flip.
        (§ return (§ new BigInteger(§ pars Utils.reverseBytes(§ pars readBytes(§ pars 8)))))
    )

    #_protected
    (§ method long readVarInt(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ return readVarInt(§ pars 0))
    )

    #_protected
    (§ method long readVarInt(§ args int offset))
        (§ throws ProtocolException)
    (§ block
        (§ try )
        (§ block
            (§ var VarInt varint = new VarInt(§ pars payload, cursor + offset))
            (§ ass cursor = cursor + offset + varint.getOriginalSizeInBytes(§ pars ))
            (§ return varint.value)
        )
        (§ catch (§ args ArrayIndexOutOfBoundsException e))
        (§ block
            (§ throw (§ new ProtocolException(§ pars e)))
        )
    )

    #_protected
    (§ method byte[] readBytes(§ args int length))
        (§ throws ProtocolException)
    (§ block
        (§ if (§ expr MAX_SIZE < length))
        (§ block
            (§ throw (§ new ProtocolException(§ pars "Claimed value length too large: " + length)))
        )

        (§ try )
        (§ block
            (§ var byte[] b = new byte[length])
            (§ call System.arraycopy(§ pars payload, cursor, b, 0, length))
            (§ ass cursor = cursor + length)
            (§ return b)
        )
        (§ catch (§ args IndexOutOfBoundsException e))
        (§ block
            (§ throw (§ new ProtocolException(§ pars e)))
        )
    )

    #_protected
    (§ method byte[] readByteArray(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ var long len = readVarInt(§ pars ))
        (§ return readBytes(§ pars (§ cast int)len))
    )

    #_protected
    (§ method String readStr(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ var long length = readVarInt(§ pars ))
        (§ return (§ quest (§ expr length == 0) ? "" :else Utils.toString(§ pars readBytes(§ pars (§ cast int)length), "UTF-8"))) ;; optimization for empty strings
    )

    #_protected
    (§ method Sha256Hash readHash(§ args ))
        (§ throws ProtocolException)
    (§ block
        ;; We have to flip it around, as it's been read off the wire in little endian.
        ;; Not the most efficient way to do this but the clearest.
        (§ return Sha256Hash.wrapReversed(§ pars readBytes(§ pars 32)))
    )

    #_protected
    (§ method boolean hasMoreBytes(§ args ))
    (§ block
        (§ return (§ expr cursor < payload.length))
    )

    ;;; Network parameters this message was created with. ;;
    #_public
    (§ method NetworkParameters getParams(§ args ))
    (§ block
        (§ return params)
    )

    ;;;
     ; Set the serializer for this message when deserialized by Java.
     ;;
    #_private
    (§ method void readObject(§ args java.io.ObjectInputStream in))
        (§ throws IOException, ClassNotFoundException)
    (§ block
        (§ call in.defaultReadObject(§ pars ))
        (§ if (§ expr params != nil))
        (§ block
            (§ ass this.serializer = params.getDefaultSerializer(§ pars ))
        )
    )
)

#_(ns org.bitcoinj.core #_"MessageSerializer"
    (:import [java.io IOException OutputStream]
             [java.nio BufferUnderflowException ByteBuffer]))

;;;
 ; Generic interface for classes which serialize/deserialize messages.
 ; Implementing classes should be immutable.
 ;;
#_public
#_abstract
(§ class MessageSerializer
    ;;;
     ; Reads a message from the given ByteBuffer and returns it.
     ;;
    #_public
    #_abstract
    (§ method Message deserialize(§ args ByteBuffer in))
        (§ throws ProtocolException, IOException, UnsupportedOperationException)

    ;;;
     ; Deserializes only the header in case packet meta data is needed before decoding
     ; the payload.  This method assumes you have already called seekPastMagicBytes().
     ;;
    #_public
    #_abstract
    (§ method BitcoinSerializer.BitcoinPacketHeader deserializeHeader(§ args ByteBuffer in))
        (§ throws ProtocolException, IOException, UnsupportedOperationException)

    ;;;
     ; Deserialize payload only.  You must provide a header, typically obtained by calling
     ; {@link BitcoinSerializer#deserializeHeader}.
     ;;
    #_public
    #_abstract
    (§ method Message deserializePayload(§ args BitcoinSerializer.BitcoinPacketHeader header, ByteBuffer in))
        (§ throws ProtocolException, BufferUnderflowException, UnsupportedOperationException)

    ;;;
     ; Whether the serializer will produce cached mode Messages.
     ;;
    #_public
    #_abstract
    (§ method boolean isParseRetainMode(§ args ))

    ;;;
     ; Make an address message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    (§ method AddressMessage makeAddressMessage(§ args byte[] payloadBytes, int length))
        (§ throws ProtocolException, UnsupportedOperationException)

    ;;;
     ; Make an alert message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    (§ method Message makeAlertMessage(§ args byte[] payloadBytes))
        (§ throws ProtocolException, UnsupportedOperationException)

    ;;;
     ; Make a block from the payload, using an offset of zero and the payload
     ; length as block length.
     ;;
    #_public
    #_final
    (§ method Block makeBlock(§ args byte[] payloadBytes))
        (§ throws ProtocolException)
    (§ block
        (§ return makeBlock(§ pars payloadBytes, 0, payloadBytes.length))
    )

    ;;;
     ; Make a block from the payload, using an offset of zero and the provided
     ; length as block length.
     ;;
    #_public
    #_final
    (§ method Block makeBlock(§ args byte[] payloadBytes, int length))
        (§ throws ProtocolException)
    (§ block
        (§ return makeBlock(§ pars payloadBytes, 0, length))
    )

    ;;;
     ; Make a block from the payload, using an offset of zero and the provided
     ; length as block length.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    (§ method Block makeBlock(§ args #_final byte[] payloadBytes, #_final int offset, #_final int length))
        (§ throws ProtocolException, UnsupportedOperationException)

    ;;;
     ; Make an filter message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    (§ method Message makeBloomFilter(§ args byte[] payloadBytes))
        (§ throws ProtocolException, UnsupportedOperationException)

    ;;;
     ; Make a filtered block from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    (§ method FilteredBlock makeFilteredBlock(§ args byte[] payloadBytes))
        (§ throws ProtocolException, UnsupportedOperationException)

    ;;;
     ; Make an inventory message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    (§ method InventoryMessage makeInventoryMessage(§ args byte[] payloadBytes, int length))
        (§ throws ProtocolException, UnsupportedOperationException)

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative
     ; serialization format support.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support deserialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support deserializing transactions.
     ;;
    #_public
    #_abstract
    (§ method Transaction makeTransaction(§ args byte[] payloadBytes, int offset, int length, byte[] hash))
        (§ throws ProtocolException, UnsupportedOperationException)

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative
     ; serialization format support.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support deserialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support deserializing transactions.
     ;;
    #_public
    #_final
    (§ method Transaction makeTransaction(§ args byte[] payloadBytes))
        (§ throws ProtocolException, UnsupportedOperationException)
    (§ block
        (§ return makeTransaction(§ pars payloadBytes, 0))
    )

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative
     ; serialization format support.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support deserialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support deserializing transactions.
     ;;
    #_public
    #_final
    (§ method Transaction makeTransaction(§ args byte[] payloadBytes, int offset))
        (§ throws ProtocolException)
    (§ block
        (§ return makeTransaction(§ pars payloadBytes, offset, payloadBytes.length, nil))
    )

    #_public
    #_abstract
    (§ method void seekPastMagicBytes(§ args ByteBuffer in))
        (§ throws BufferUnderflowException)

    ;;;
     ; Writes message to to the output stream.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support serialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support serializing the given message.
     ;;
    #_public
    #_abstract
    (§ method void serialize(§ args String name, byte[] message, OutputStream out))
        (§ throws IOException, UnsupportedOperationException)

    ;;;
     ; Writes message to to the output stream.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support serialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support serializing the given message.
     ;;
    #_public
    #_abstract
    (§ method void serialize(§ args Message message, OutputStream out))
        (§ throws IOException, UnsupportedOperationException)
)

#_(ns org.bitcoinj.core #_"Monetary"
    (:import [java.io Serializable]))

;;;
 ; Classes implementing this interface represent a monetary value, such as a Bitcoin or fiat amount.
 ;;
#_public
(§ interface Monetary extends Serializable
    ;;;
     ; Returns the absolute value of exponent of the value of a "smallest unit" in scientific notation.
     ; For Bitcoin, a satoshi is worth 1E-8 so this would be 8.
     ;;
    (§ method int smallestUnitExponent(§ args ))

    ;;;
     ; Returns the number of "smallest units" of this monetary value.
     ; For Bitcoin, this would be the number of satoshis.
     ;;
    (§ method long getValue(§ args ))

    (§ method int signum(§ args ))
)

#_(ns org.bitcoinj.core #_"NetworkParameters"
    (:import [java.io *]
             [java.math *]
             [java.util *])
    (:import [com.google.common.base Objects])
   (:require [org.bitcoinj.core Block]
             #_static [org.bitcoinj.core.Coin *]
             [org.bitcoinj.core StoredBlock VerificationException]
             [org.bitcoinj.net.discovery *]
             [org.bitcoinj.params *]
             [org.bitcoinj.script *]
             [org.bitcoinj.store BlockStore BlockStoreException]
             [org.bitcoinj.utils MonetaryFormat VersionTally]))

;;;
 ; <p>NetworkParameters contains the data needed for working with an instantiation of a Bitcoin chain.</p>
 ;
 ; <p>This is an abstract class, concrete instantiations can be found in the params package.  There are four:
 ; one for the main network ({@link MainNetParams}), one for the public test network, and two others that are
 ; intended for unit testing and local app development purposes.  Although this class contains some aliases for
 ; them, you are encouraged to call the static get() methods on each specific params class directly.</p>
 ;;
#_public
#_abstract
(§ class NetworkParameters
    ;;;
     ; The alert signing key originally owned by Satoshi, and now passed on to Gavin along with a few others.
     ;;
    #_public
    #_static
    #_final
    (§ field byte[] SATOSHI_KEY = Utils.HEX.decode(§ pars "04fc9702847840aaf195de8442ebecedf5b095cdbb9bc716bda9110971b28a49e0ead8564ff0db22209e0374782c093bb899692d524e9d6a6956e7c5ecbcd68284"))

    ;;; The string returned by getId() for the main, production network where people trade things. ;;
    #_public
    #_static
    #_final
    (§ field String ID_MAINNET = "org.bitcoin.production")
    ;;; The string returned by getId() for the testnet. ;;
    #_public
    #_static
    #_final
    (§ field String ID_TESTNET = "org.bitcoin.test")
    ;;; Unit test network. ;;
    #_public
    #_static
    #_final
    (§ field String ID_UNITTESTNET = "org.bitcoinj.unittest")

    ;;; The string used by the payment protocol to represent the main net. ;;
    #_public
    #_static
    #_final
    (§ field String PAYMENT_PROTOCOL_ID_MAINNET = "main")
    ;;; The string used by the payment protocol to represent the test net. ;;
    #_public
    #_static
    #_final
    (§ field String PAYMENT_PROTOCOL_ID_TESTNET = "test")
    ;;; The string used by the payment protocol to represent unit testing (note that this is non-standard). ;;
    #_public
    #_static
    #_final
    (§ field String PAYMENT_PROTOCOL_ID_UNIT_TESTS = "unittest")

    ;; TODO: Seed nodes should be here as well.

    #_protected
    (§ field Block genesisBlock)
    #_protected
    (§ field BigInteger maxTarget)
    #_protected
    (§ field int port)
    #_protected
    (§ field long packetMagic) ;; Indicates message origin network and is used to seek to the next message when stream state is unknown.
    #_protected
    (§ field int addressHeader)
    #_protected
    (§ field int p2shHeader)
    #_protected
    (§ field int interval)
    #_protected
    (§ field int targetTimespan)
    #_protected
    (§ field byte[] alertSigningKey)
    #_protected
    (§ field int bip32HeaderPub)
    #_protected
    (§ field int bip32HeaderPriv)

    ;;; Used to check majorities for block version upgrade. ;;
    #_protected
    (§ field int majorityEnforceBlockUpgrade)
    #_protected
    (§ field int majorityRejectBlockOutdated)
    #_protected
    (§ field int majorityWindow)

    ;;;
     ; See getId().  This may be null for old deserialized wallets.  In that case we derive it heuristically
     ; by looking at the port number.
     ;;
    #_protected
    (§ field String id)

    ;;;
     ; The depth of blocks required for a coinbase transaction to be spendable.
     ;;
    #_protected
    (§ field int spendableCoinbaseDepth)
    #_protected
    (§ field int subsidyDecreaseBlockCount)

    #_protected
    (§ field int[] acceptableAddressCodes)
    #_protected
    (§ field String[] dnsSeeds)
    #_protected
    (§ field int[] addrSeeds)
    #_protected
    (§ field Map<Integer, Sha256Hash> checkpoints = new HashMap<>(§ pars ))
    #_protected
    #_transient
    (§ field MessageSerializer defaultSerializer)

    #_protected
    (§ constructor NetworkParameters(§ args ))
    (§ block
        (§ ass alertSigningKey = SATOSHI_KEY)
        (§ ass genesisBlock = createGenesis(§ pars this))
    )

    #_private
    #_static
    (§ method Block createGenesis(§ args NetworkParameters n))
    (§ block
        (§ var Block genesisBlock = new Block(§ pars n, Block.BLOCK_VERSION_GENESIS))
        (§ var Transaction t = new Transaction(§ pars n))
        (§ try )
        (§ block
            ;; A script containing the difficulty bits and the following message: "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks".
            (§ var byte[] bytes = Utils.HEX.decode(§ pars "04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73"))
            (§ call t.addInput(§ pars (§ new TransactionInput(§ pars n, t, bytes))))
            (§ var ByteArrayOutputStream scriptPubKeyBytes = new ByteArrayOutputStream(§ pars ))
            (§ call Script.writeBytes(§ pars scriptPubKeyBytes, Utils.HEX.decode(§ pars "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f")))
            (§ call scriptPubKeyBytes.write(§ pars ScriptOpCodes.OP_CHECKSIG))
            (§ call t.addOutput(§ pars (§ new TransactionOutput(§ pars n, t, FIFTY_COINS, scriptPubKeyBytes.toByteArray(§ pars )))))
        )
        (§ catch (§ args Exception e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
        (§ call genesisBlock.addTransaction(§ pars t))
        (§ return genesisBlock)
    )

    #_public
    #_static
    #_final
    (§ field int TARGET_TIMESPAN = 14 * 24 * 60 * 60) ;; 2 weeks per difficulty cycle, on average.
    #_public
    #_static
    #_final
    (§ field int TARGET_SPACING = 10 * 60) ;; 10 minutes per block.
    #_public
    #_static
    #_final
    (§ field int INTERVAL = TARGET_TIMESPAN / TARGET_SPACING)

    ;;;
     ; Blocks with a timestamp after this should enforce BIP 16, aka "Pay to script hash".  This BIP changed
     ; the network rules in a soft-forking manner, that is, blocks that don't follow the rules are accepted
     ; but not mined upon and thus will be quickly re-orged out as long as the majority are enforcing the rule.
     ;;
    #_public
    #_static
    #_final
    (§ field int BIP16_ENFORCE_TIME = 1333238400)

    ;;;
     ; The maximum number of coins to be generated.
     ;;
    #_public
    #_static
    #_final
    (§ field long MAX_COINS = 21000000)

    ;;;
     ; The maximum money to be generated.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin MAX_MONEY = COIN.multiply(§ pars MAX_COINS))

    ;;;
     ; A Java package style string acting as unique ID for these parameters.
     ;;
    #_public
    (§ method String getId(§ args ))
    (§ block
        (§ return id)
    )

    #_public
    #_abstract
    (§ method String getPaymentProtocolId(§ args ))

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return getId(§ pars ).equals(§ pars (§ expr (§ cast NetworkParameters)o).getId(§ pars )))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars getId(§ pars )))
    )

    ;;; Returns the network parameters for the given string ID or NULL if not recognized. ;;
    #_nilable
    #_public
    #_static
    (§ method NetworkParameters fromID(§ args String id))
    (§ block
        (§ if (§ expr id.equals(§ pars ID_MAINNET)))
        (§ block
            (§ return MainNetParams.get(§ pars ))
        )
        (§ if (§ expr id.equals(§ pars ID_TESTNET)))
        (§ block
            (§ return TestNet3Params.get(§ pars ))
        )
        (§ if (§ expr id.equals(§ pars ID_UNITTESTNET)))
        (§ block
            (§ return UnitTestParams.get(§ pars ))
        )
        (§ return nil)
    )

    ;;; Returns the network parameters for the given string paymentProtocolID or NULL if not recognized. ;;
    #_nilable
    #_public
    #_static
    (§ method NetworkParameters fromPmtProtocolID(§ args String pmtProtocolId))
    (§ block
        (§ if (§ expr pmtProtocolId.equals(§ pars PAYMENT_PROTOCOL_ID_MAINNET)))
        (§ block
            (§ return MainNetParams.get(§ pars ))
        )
        (§ if (§ expr pmtProtocolId.equals(§ pars PAYMENT_PROTOCOL_ID_TESTNET)))
        (§ block
            (§ return TestNet3Params.get(§ pars ))
        )
        (§ if (§ expr pmtProtocolId.equals(§ pars PAYMENT_PROTOCOL_ID_UNIT_TESTS)))
        (§ block
            (§ return UnitTestParams.get(§ pars ))
        )
        (§ return nil)
    )

    #_public
    (§ method int getSpendableCoinbaseDepth(§ args ))
    (§ block
        (§ return spendableCoinbaseDepth)
    )

    ;;;
     ; Throws an exception if the block's difficulty is not correct.
     ;
     ; @throws VerificationException if the block's difficulty is not correct.
     ;;
    #_public
    #_abstract
    (§ method void checkDifficultyTransitions(§ args StoredBlock storedPrev, Block next, #_final BlockStore blockStore))
        (§ throws VerificationException, BlockStoreException)

    ;;;
     ; Returns true if the block height is either not a checkpoint, or is a checkpoint and the hash matches.
     ;;
    #_public
    (§ method boolean passesCheckpoint(§ args int height, Sha256Hash hash))
    (§ block
        (§ var Sha256Hash checkpointHash = checkpoints.get(§ pars height))
        (§ return (§ expr checkpointHash == nil || checkpointHash.equals(§ pars hash)))
    )

    ;;;
     ; Returns true if the given height has a recorded checkpoint.
     ;;
    #_public
    (§ method boolean isCheckpoint(§ args int height))
    (§ block
        (§ var Sha256Hash checkpointHash = checkpoints.get(§ pars height))
        (§ return (§ expr checkpointHash != nil))
    )

    #_public
    (§ method int getSubsidyDecreaseBlockCount(§ args ))
    (§ block
        (§ return subsidyDecreaseBlockCount)
    )

    ;;; Returns DNS names that when resolved, give IP addresses of active peers. ;;
    #_public
    (§ method String[] getDnsSeeds(§ args ))
    (§ block
        (§ return dnsSeeds)
    )

    ;;; Returns IP address of active peers. ;;
    #_public
    (§ method int[] getAddrSeeds(§ args ))
    (§ block
        (§ return addrSeeds)
    )

    ;;;
     ; <p>Genesis block for this chain.</p>
     ;
     ; <p>The first block in every chain is a well known constant shared between all Bitcoin implemenetations.
     ; For a block to be valid, it must be eventually possible to work backwards to the genesis block by following
     ; the prevBlockHash pointers in the block headers.</p>
     ;
     ; <p>The genesis blocks for both test and main networks contain the timestamp of when they were created,
     ; and a message in the coinbase transaction.  It says,
     ; <i>"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"</i>.</p>
     ;;
    #_public
    (§ method Block getGenesisBlock(§ args ))
    (§ block
        (§ return genesisBlock)
    )

    ;;; Default TCP port on which to connect to nodes. ;;
    #_public
    (§ method int getPort(§ args ))
    (§ block
        (§ return port)
    )

    ;;; The header bytes that identify the start of a packet on this network. ;;
    #_public
    (§ method long getPacketMagic(§ args ))
    (§ block
        (§ return packetMagic)
    )

    ;;;
     ; First byte of a base58 encoded address.  See {@link org.bitcoinj.core.Address}.
     ; This is the same as acceptableAddressCodes[0] and is the one used for "normal" addresses.
     ; Other types of address may be encountered with version codes found in the acceptableAddressCodes array.
     ;;
    #_public
    (§ method int getAddressHeader(§ args ))
    (§ block
        (§ return addressHeader)
    )

    ;;;
     ; First byte of a base58 encoded P2SH address.  P2SH addresses are defined as part of BIP0013.
     ;;
    #_public
    (§ method int getP2SHHeader(§ args ))
    (§ block
        (§ return p2shHeader)
    )

    ;;;
     ; How much time in seconds is supposed to pass between "interval" blocks.  If the actual elapsed time is
     ; significantly different from this value, the network difficulty formula will produce a different value.
     ; Both test and main Bitcoin networks use 2 weeks (1209600 seconds).
     ;;
    #_public
    (§ method int getTargetTimespan(§ args ))
    (§ block
        (§ return targetTimespan)
    )

    ;;;
     ; The version codes that prefix addresses which are acceptable on this network.  Although Satoshi intended these
     ; to be used for "versioning", in fact they are today used to discriminate what kind of data is contained in the
     ; address and to prevent accidentally sending coins across chains which would destroy them.
     ;;
    #_public
    (§ method int[] getAcceptableAddressCodes(§ args ))
    (§ block
        (§ return acceptableAddressCodes)
    )

    ;;;
     ; If we are running in testnet-in-a-box mode, we allow connections to nodes with 0 non-genesis blocks.
     ;;
    #_public
    (§ method boolean allowEmptyPeerChain(§ args ))
    (§ block
        (§ return true)
    )

    ;;; How many blocks pass between difficulty adjustment periods.  Bitcoin standardises this to be 2016. ;;
    #_public
    (§ method int getInterval(§ args ))
    (§ block
        (§ return interval)
    )

    ;;; Maximum target represents the easiest allowable proof of work. ;;
    #_public
    (§ method BigInteger getMaxTarget(§ args ))
    (§ block
        (§ return maxTarget)
    )

    ;;;
     ; The key used to sign {@link org.bitcoinj.core.AlertMessage}s.
     ; You can use {@link org.bitcoinj.core.ECKey#verify(byte[], byte[], byte[])} to verify signatures using it.
     ;;
    #_public
    (§ method byte[] getAlertSigningKey(§ args ))
    (§ block
        (§ return alertSigningKey)
    )

    ;;; Returns the 4 byte header for BIP32 (HD) wallet - public key part. ;;
    #_public
    (§ method int getBip32HeaderPub(§ args ))
    (§ block
        (§ return bip32HeaderPub)
    )

    ;;; Returns the 4 byte header for BIP32 (HD) wallet - private key part. ;;
    #_public
    (§ method int getBip32HeaderPriv(§ args ))
    (§ block
        (§ return bip32HeaderPriv)
    )

    ;;;
     ; Returns the number of coins that will be produced in total, on this network.
     ; Where not applicable, a very large number of coins is returned
     ; instead (i.e. the main coin issue for Dogecoin).
     ;;
    #_public
    #_abstract
    (§ method Coin getMaxMoney(§ args ))

    ;;;
     ; Any standard (i.e. pay-to-address) output smaller than this value will
     ; most likely be rejected by the network.
     ;;
    #_public
    #_abstract
    (§ method Coin getMinNonDustOutput(§ args ))

    ;;;
     ; The monetary object for this currency.
     ;;
    #_public
    #_abstract
    (§ method MonetaryFormat getMonetaryFormat(§ args ))

    ;;;
     ; Scheme part for URIs, for example "bitcoin".
     ;;
    #_public
    #_abstract
    (§ method String getUriScheme(§ args ))

    ;;;
     ; Returns whether this network has a maximum number of coins (finite supply) or not.
     ; Always returns true for Bitcoin, but exists to be overriden for other networks.
     ;;
    #_public
    #_abstract
    (§ method boolean hasMaxMoney(§ args ))

    ;;;
     ; Return the default serializer for this network.  This is a shared serializer.
     ;;
    #_public
    #_final
    (§ method MessageSerializer getDefaultSerializer(§ args ))
    (§ block
        ;; Construct a default serializer if we don't have one.
        (§ if (§ expr this.defaultSerializer == nil))
        (§ block
            ;; Don't grab a lock unless we absolutely need it.
            (§ sync this)
            (§ block
                ;; Now we have a lock, double check there's still no serializer and create one if so.
                (§ if (§ expr this.defaultSerializer == nil))
                (§ block
                    ;; As the serializers are intended to be immutable, creating
                    ;; two due to a race condition should not be a problem, however
                    ;; to be safe we ensure only one exists for each network.
                    (§ ass this.defaultSerializer = getSerializer(§ pars false))
                )
            )
        )
        (§ return defaultSerializer)
    )

    ;;;
     ; Construct and return a custom serializer.
     ;;
    #_public
    #_abstract
    (§ method BitcoinSerializer getSerializer(§ args boolean parseRetain))

    ;;;
     ; The number of blocks in the last {@link getMajorityWindow()} blocks
     ; at which to trigger a notice to the user to upgrade their client, where
     ; the client does not understand those blocks.
     ;;
    #_public
    (§ method int getMajorityEnforceBlockUpgrade(§ args ))
    (§ block
        (§ return majorityEnforceBlockUpgrade)
    )

    ;;;
     ; The number of blocks in the last {@link getMajorityWindow()} blocks
     ; at which to enforce the requirement that all new blocks are of the
     ; newer type (i.e. outdated blocks are rejected).
     ;;
    #_public
    (§ method int getMajorityRejectBlockOutdated(§ args ))
    (§ block
        (§ return majorityRejectBlockOutdated)
    )

    ;;;
     ; The sampling window from which the version numbers of blocks are taken
     ; in order to determine if a new block version is now the majority.
     ;;
    #_public
    (§ method int getMajorityWindow(§ args ))
    (§ block
        (§ return majorityWindow)
    )

    ;;;
     ; The flags indicating which block validation tests should be applied to
     ; the given block.  Enables support for alternative blockchains which enable
     ; tests based on different criteria.
     ;
     ; @param block Block to determine flags for.
     ; @param height Height of the block, if known, null otherwise.  Returned
     ; tests should be a safe subset if block height is unknown.
     ;;
    #_public
    (§ method EnumSet<Block.VerifyFlag> getBlockVerificationFlags(§ args #_final Block block, #_final VersionTally tally, #_final Integer height))
    (§ block
        #_final
        (§ var EnumSet<Block.VerifyFlag> flags = EnumSet.noneOf(§ pars Block.VerifyFlag.class))

        (§ if (§ expr block.isBIP34(§ pars )))
        (§ block
            #_final
            (§ var Integer count = tally.getCountAtOrAbove(§ pars Block.BLOCK_VERSION_BIP34))
            (§ if (§ expr count != nil && getMajorityEnforceBlockUpgrade(§ pars ) <= count))
            (§ block
                (§ call flags.add(§ pars Block.VerifyFlag.HEIGHT_IN_COINBASE))
            )
        )

        (§ return flags)
    )

    ;;;
     ; The flags indicating which script validation tests should be applied to
     ; the given transaction.  Enables support for alternative blockchains which enable
     ; tests based on different criteria.
     ;
     ; @param block Block the transaction belongs to.
     ; @param transaction to determine flags for.
     ; @param height Height of the block, if known, null otherwise.  Returned
     ; tests should be a safe subset if block height is unknown.
     ;;
    #_public
    (§ method EnumSet<Script.VerifyFlag> getTransactionVerificationFlags(§ args #_final Block block, #_final Transaction transaction, #_final VersionTally tally, #_final Integer height))
    (§ block
        #_final
        (§ var EnumSet<Script.VerifyFlag> verifyFlags = EnumSet.noneOf(§ pars Script.VerifyFlag.class))
        (§ if (§ expr NetworkParameters.BIP16_ENFORCE_TIME <= block.getTimeSeconds(§ pars )))
        (§ block
            (§ call verifyFlags.add(§ pars Script.VerifyFlag.P2SH))
        )

        ;; Start enforcing CHECKLOCKTIMEVERIFY (BIP65) for block.nVersion=4 blocks,
        ;; when 75% of the network has been upgraded:
        (§ if (§ expr Block.BLOCK_VERSION_BIP65 <= block.getVersion(§ pars ) && this.getMajorityEnforceBlockUpgrade(§ pars ) < tally.getCountAtOrAbove(§ pars Block.BLOCK_VERSION_BIP65)))
        (§ block
            (§ call verifyFlags.add(§ pars Script.VerifyFlag.CHECKLOCKTIMEVERIFY))
        )

        (§ return verifyFlags)
    )

    #_public
    #_abstract
    (§ method int getProtocolVersionNum(§ args #_final ProtocolVersion version))

    #_public
    #_static
    (§ enum ProtocolVersion
        (§ item MINIMUM(§ pars 70000))
        (§ item PONG(§ pars 60001))
        (§ item BLOOM_FILTER(§ pars 70000))
        (§ item CURRENT(§ pars 70001))

        #_private
        #_final
        (§ field int bitcoinProtocol)

        (§ constructor ProtocolVersion(§ args #_final int bitcoinProtocol))
        (§ block
            (§ ass this.bitcoinProtocol = bitcoinProtocol)
        )

        #_public
        (§ method int getBitcoinProtocolVersion(§ args ))
        (§ block
            (§ return bitcoinProtocol)
        )
    )
)

#_(ns org.bitcoinj.core #_"NotFoundMessage"
    (:import [java.util ArrayList List]))

;;;
 ; <p>Sent by a peer when a getdata request doesn't find the requested data in the mempool.  It has the same format
 ; as an inventory message and lists the hashes of the missing items.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class NotFoundMessage extends InventoryMessage
    #_public
    #_static
    (§ field int MIN_PROTOCOL_VERSION = 70001)

    #_public
    (§ constructor NotFoundMessage(§ args NetworkParameters params))
    (§ block
        (§ super (§ pars params))
    )

    #_public
    (§ constructor NotFoundMessage(§ args NetworkParameters params, byte[] payloadBytes))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payloadBytes))
    )

    #_public
    (§ constructor NotFoundMessage(§ args NetworkParameters params, List<InventoryItem> items))
    (§ block
        (§ super (§ pars params))
        (§ ass this.items = new ArrayList<>(§ pars items))
    )
)

#_(ns org.bitcoinj.core #_"PartialMerkleTree"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Arrays List])
    (:import [com.google.common.base Objects])
    (:import #_static [org.bitcoinj.core.Utils *]))

;;;
 ; <p>A data structure that contains proofs of block inclusion for one or more transactions, in an efficient manner.</p>
 ;
 ; <p>The encoding works as follows: we traverse the tree in depth-first order, storing a bit for each traversed node,
 ; signifying whether the node is the parent of at least one matched leaf txid (or a matched txid itself).  In case we
 ; are at the leaf level, or this bit is 0, its merkle node hash is stored, and its children are not explored further.
 ; Otherwise, no hash is stored, but we recurse into both (or the only) child branch.  During decoding, the same
 ; depth-first traversal is performed, consuming bits and hashes as they were written during encoding.</p>
 ;
 ; <p>The serialization is fixed and provides a hard guarantee about the encoded size,
 ; <tt>SIZE &lt;= 10 + ceil(32.25 * N)</tt> where N represents the number of leaf nodes of the partial tree.
 ; N itself is bounded by:</p>
 ;
 ; N &lt;= total_transactions<br>
 ; N &lt;= 1 + matched_transactions * tree_height
 ;
 ; <p><pre>The serialization format:
 ;  - uint32     total_transactions (4 bytes)
 ;  - varint     number of hashes (1-3 bytes)
 ;  - uint256[]  hashes in depth-first order (&lt;= 32*N bytes)
 ;  - varint     number of bytes of flag bits (1-3 bytes)
 ;  - byte[]     flag bits, packed per 8 in a byte, least significant bit first (&lt;= 2*N-1 bits)
 ; The size constraints follow from this.</pre></p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class PartialMerkleTree extends Message
    ;; the total number of transactions in the block
    #_private
    (§ field int transactionCount)

    ;; node-is-parent-of-matched-txid bits
    #_private
    (§ field byte[] matchedChildBits)

    ;; txids and internal hashes
    #_private
    (§ field List<Sha256Hash> hashes)

    #_public
    (§ constructor PartialMerkleTree(§ args NetworkParameters params, byte[] payloadBytes, int offset))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payloadBytes, offset))
    )

    ;;;
     ; Constructs a new PMT with the given bit set (little endian) and the raw list of hashes including internal hashes,
     ; taking ownership of the list.
     ;;
    #_public
    (§ constructor PartialMerkleTree(§ args NetworkParameters params, byte[] bits, List<Sha256Hash> hashes, int origTxCount))
    (§ block
        (§ super (§ pars params))

        (§ ass this.matchedChildBits = bits)
        (§ ass this.hashes = hashes)
        (§ ass this.transactionCount = origTxCount)
    )

    ;;;
     ; Calculates a PMT given the list of leaf hashes and which leaves need to be included.  The relevant interior hashes
     ; are calculated and a new PMT returned.
     ;;
    #_public
    #_static
    (§ method PartialMerkleTree buildFromLeaves(§ args NetworkParameters params, byte[] includeBits, List<Sha256Hash> allLeafHashes))
    (§ block
        ;; Calculate height of the tree.
        (§ var int height = 0)
        (§ while (§ expr 1 < getTreeWidth(§ pars allLeafHashes.size(§ pars ), height)))
        (§ block
            (§ ass height = height + 1)
        )
        (§ var List<Boolean> bitList = new ArrayList<>(§ pars ))
        (§ var List<Sha256Hash> hashes = new ArrayList<>(§ pars ))
        (§ call traverseAndBuild(§ pars height, 0, allLeafHashes, includeBits, bitList, hashes))
        (§ var byte[] bits = new byte[(§ cast int)Math.ceil(§ pars bitList.size(§ pars ) / 8.0)])
        (§ for (§ var int i = 0) :for (§ expr i < bitList.size(§ pars )) :for (§ ass i = i + 1))
        (§ block
            (§ if (§ expr bitList.get(§ pars i)))
            (§ block
                (§ call Utils.setBitLE(§ pars bits, i))
            )
        )
        (§ return (§ new PartialMerkleTree(§ pars params, bits, hashes, allLeafHashes.size(§ pars ))))
    )

    #_override
    #_public
    (§ method void bitcoinSerializeToStream(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ call uint32ToByteStreamLE(§ pars transactionCount, stream))

        (§ call stream.write(§ pars (§ new VarInt(§ pars hashes.size(§ pars ))).encode(§ pars )))
        (§ for (§ var Sha256Hash hash) :for (§ expr hashes))
        (§ block
            (§ call stream.write(§ pars hash.getReversedBytes(§ pars )))
        )

        (§ call stream.write(§ pars (§ new VarInt(§ pars matchedChildBits.length)).encode(§ pars )))
        (§ call stream.write(§ pars matchedChildBits))
    )

    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ ass transactionCount = (§ cast int)readUint32(§ pars ))

        (§ var int nHashes = (§ cast int)readVarInt(§ pars ))
        (§ ass hashes = new ArrayList<>(§ pars nHashes))
        (§ for (§ var int i = 0) :for (§ expr i < nHashes) :for (§ ass i = i + 1))
        (§ block
            (§ call hashes.add(§ pars readHash(§ pars )))
        )

        (§ var int nFlagBytes = (§ cast int)readVarInt(§ pars ))
        (§ ass matchedChildBits = readBytes(§ pars nFlagBytes))

        (§ ass length = cursor - offset)
    )

    ;; Based on CPartialMerkleTree::TraverseAndBuild in Bitcoin Core.
    #_private
    #_static
    (§ method void traverseAndBuild(§ args int height, int pos, List<Sha256Hash> allLeafHashes, byte[] includeBits, List<Boolean> matchedChildBits, List<Sha256Hash> resultHashes))
    (§ block
        (§ var boolean parentOfMatch = false)
        ;; Is this node a parent of at least one matched hash?
        (§ for (§ var int p = pos << height) :for (§ expr p < (§ expr pos + 1) << height && p < allLeafHashes.size(§ pars )) :for (§ ass p = p + 1))
        (§ block
            (§ if (§ expr Utils.checkBitLE(§ pars includeBits, p)))
            (§ block
                (§ ass parentOfMatch = true)
                (§ break )
            )
        )
        ;; Store as a flag bit.
        (§ call matchedChildBits.add(§ pars parentOfMatch))
        (§ if (§ expr height == 0 || !parentOfMatch))
        (§ block
            ;; If at height 0, or nothing interesting below, store hash and stop.
            (§ call resultHashes.add(§ pars calcHash(§ pars height, pos, allLeafHashes)))
        )
        (§ else )
        (§ block
            ;; Otherwise descend into the subtrees.
            (§ var int h = height - 1)
            (§ var int p = pos * 2)
            (§ call traverseAndBuild(§ pars h, p, allLeafHashes, includeBits, matchedChildBits, resultHashes))
            (§ if (§ expr p + 1 < getTreeWidth(§ pars allLeafHashes.size(§ pars ), h)))
            (§ block
                (§ call traverseAndBuild(§ pars h, p + 1, allLeafHashes, includeBits, matchedChildBits, resultHashes))
            )
        )
    )

    #_private
    #_static
    (§ method Sha256Hash calcHash(§ args int height, int pos, List<Sha256Hash> hashes))
    (§ block
        ;; Hash at height 0 is just the regular tx hash itself.
        (§ if (§ expr height == 0))
        (§ block
            (§ return hashes.get(§ pars pos))
        )

        (§ var int h = height - 1)
        (§ var int p = pos * 2)
        (§ var Sha256Hash left = calcHash(§ pars h, p, hashes))
        ;; Calculate right hash if not beyond the end of the array - copy left hash otherwise.
        (§ var Sha256Hash right = (§ quest (§ expr p + 1 < getTreeWidth(§ pars hashes.size(§ pars ), h)) ? calcHash(§ pars h, p + 1, hashes) :else left))

        (§ return combineLeftRight(§ pars left.getBytes(§ pars ), right.getBytes(§ pars )))
    )

    ;; Helper function to efficiently calculate the number of nodes at given height in the merkle tree.
    #_private
    #_static
    (§ method int getTreeWidth(§ args int transactionCount, int height))
    (§ block
        (§ return (§ expr transactionCount + (§ expr 1 << height) - 1) >> height)
    )

    #_private
    #_static
    (§ class ValuesUsed
        #_public
        (§ field int bitsUsed = 0, hashesUsed = 0)
    )

    ;; Recursive function that traverses tree nodes, consuming the bits and hashes produced by TraverseAndBuild.
    ;; It returns the hash of the respective node.
    #_private
    (§ method Sha256Hash recursiveExtractHashes(§ args int height, int pos, ValuesUsed used, List<Sha256Hash> matchedHashes))
        (§ throws VerificationException)
    (§ block
        ;; overflowed bits array - failure
        (§ if (§ expr matchedChildBits.length * 8 <= used.bitsUsed))
        (§ block
            (§ throw (§ new VerificationException(§ pars "PartialMerkleTree overflowed its bits array")))
        )

        (§ var boolean parentOfMatch = checkBitLE(§ pars matchedChildBits, used.bitsUsed))
        (§ ass used.bitsUsed = used.bitsUsed + 1)

        ;; if at height 0, or nothing interesting below, use stored hash and do not descend
        (§ if (§ expr height == 0 || !parentOfMatch))
        (§ block
            ;; overflowed hash array - failure
            (§ if (§ expr hashes.size(§ pars ) <= used.hashesUsed))
            (§ block
                (§ throw (§ new VerificationException(§ pars "PartialMerkleTree overflowed its hash array")))
            )

            (§ var Sha256Hash hash = hashes.get(§ pars used.hashesUsed))
            (§ ass used.hashesUsed = used.hashesUsed + 1)
            ;; in case of height 0, we have a matched txid
            (§ if (§ expr height == 0 && parentOfMatch))
            (§ block
                (§ call matchedHashes.add(§ pars hash))
            )

            (§ return hash)
        )
        (§ else )
        (§ block
            ;; otherwise, descend into the subtrees to extract matched txids and hashes
            (§ var byte[] left = recursiveExtractHashes(§ pars height - 1, pos * 2, used, matchedHashes).getBytes(§ pars ), right)
            (§ if (§ expr pos * 2 + 1 < getTreeWidth(§ pars transactionCount, height - 1)))
            (§ block
                (§ ass right = recursiveExtractHashes(§ pars height - 1, pos * 2 + 1, used, matchedHashes).getBytes(§ pars ))
                (§ if (§ expr Arrays.equals(§ pars right, left)))
                (§ block
                    (§ throw (§ new VerificationException(§ pars "Invalid merkle tree with duplicated left/right branches")))
                )
            )
            (§ else )
            (§ block
                (§ ass right = left)
            )
            ;; and combine them before returning
            (§ return combineLeftRight(§ pars left, right))
        )
    )

    #_private
    #_static
    (§ method Sha256Hash combineLeftRight(§ args byte[] left, byte[] right))
    (§ block
        (§ return Sha256Hash.wrapReversed(§ pars Sha256Hash.hashTwice(§ pars reverseBytes(§ pars left), 0, 32, reverseBytes(§ pars right), 0, 32)))
    )

    ;;;
     ; Extracts tx hashes that are in this merkle tree and returns the merkle root of this tree.
     ;
     ; The returned root should be checked against the merkle root contained in the block header for security.
     ;
     ; @param matchedHashesOut A list which will contain the matched txn (will be cleared).
     ; @return the merkle root of this merkle tree.
     ; @throws ProtocolException if this partial merkle tree is invalid.
     ;;
    #_public
    (§ method Sha256Hash getTxnHashAndMerkleRoot(§ args List<Sha256Hash> matchedHashesOut))
        (§ throws VerificationException)
    (§ block
        (§ call matchedHashesOut.clear(§ pars ))

        ;; an empty set will not work
        (§ if (§ expr transactionCount == 0))
        (§ block
            (§ throw (§ new VerificationException(§ pars "Got a CPartialMerkleTree with 0 transactions")))
        )
        ;; check for excessively high numbers of transactions
        (§ if (§ expr Block.MAX_BLOCK_SIZE / 60 < transactionCount)) ;; 60 is the lower bound for the size of a serialized CTransaction
        (§ block
            (§ throw (§ new VerificationException(§ pars "Got a CPartialMerkleTree with more transactions than is possible")))
        )
        ;; there can never be more hashes provided than one for every txid
        (§ if (§ expr transactionCount < hashes.size(§ pars )))
        (§ block
            (§ throw (§ new VerificationException(§ pars "Got a CPartialMerkleTree with more hashes than transactions")))
        )
        ;; there must be at least one bit per node in the partial tree, and at least one node per hash
        (§ if (§ expr matchedChildBits.length * 8 < hashes.size(§ pars )))
        (§ block
            (§ throw (§ new VerificationException(§ pars "Got a CPartialMerkleTree with fewer matched bits than hashes")))
        )

        ;; calculate height of tree
        (§ var int height = 0)
        (§ while (§ expr 1 < getTreeWidth(§ pars transactionCount, height)))
        (§ block
            (§ ass height = height + 1)
        )
        ;; traverse the partial tree
        (§ var ValuesUsed used = new ValuesUsed(§ pars ))
        (§ var Sha256Hash merkleRoot = recursiveExtractHashes(§ pars height, 0, used, matchedHashesOut))
        ;; verify that all bits were consumed (except for the padding caused by serializing it as a byte sequence)
        ;; verify that all hashes were consumed
        (§ if (§ expr (§ expr used.bitsUsed + 7) / 8 != matchedChildBits.length || used.hashesUsed != hashes.size(§ pars )))
        (§ block
            (§ throw (§ new VerificationException(§ pars "Got a CPartialMerkleTree that didn't need all the data it provided")))
        )

        (§ return merkleRoot)
    )

    #_public
    (§ method int getTransactionCount(§ args ))
    (§ block
        (§ return transactionCount)
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var PartialMerkleTree other = (§ cast PartialMerkleTree)o)
        (§ return (§ expr transactionCount == other.transactionCount && hashes.equals(§ pars other.hashes) && Arrays.equals(§ pars matchedChildBits, other.matchedChildBits)))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars transactionCount, hashes, Arrays.hashCode(§ pars matchedChildBits)))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return "PartialMerkleTree{" + "transactionCount=" + transactionCount + ", matchedChildBits=" + Arrays.toString(§ pars matchedChildBits) + ", hashes=" + hashes + "}")
    )
)

#_(ns org.bitcoinj.core #_"Peer"
    (:import [java.util *]
             [java.util.concurrent CopyOnWriteArrayList CopyOnWriteArraySet Executor]
             [java.util.concurrent.atomic AtomicInteger]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.base * Objects]
             [com.google.common.collect Lists]
             [com.google.common.util.concurrent FutureCallback Futures ListenableFuture SettableFuture]
             [net.jcip.annotations GuardedBy]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core.listeners *]
             [org.bitcoinj.net StreamConnection]
             [org.bitcoinj.store BlockStore BlockStoreException]
             [org.bitcoinj.utils ListenerRegistration Threading]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>A Peer handles the high level communication with a Bitcoin node, extending a {@link PeerSocketHandler} which
 ; handles low-level message (de)serialization.</p>
 ;
 ; <p>Note that timeouts are handled by the extended
 ; {@link org.bitcoinj.net.AbstractTimeoutHandler} and timeout is automatically disabled (using
 ; {@link org.bitcoinj.net.AbstractTimeoutHandler#setTimeoutEnabled(boolean)}) once the version
 ; handshake completes.</p>
 ;;
#_public
(§ class Peer extends PeerSocketHandler
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars Peer.class))

    #_protected
    #_final
    (§ field ReentrantLock lock = Threading.lock(§ pars "peer"))

    #_private
    #_final
    (§ field NetworkParameters params)
    #_private
    #_final
    (§ field AbstractBlockChain blockChain)
    #_private
    #_final
    (§ field Context context)

    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<BlocksDownloadedEventListener>> blocksDownloadedEventListeners = new CopyOnWriteArrayList<>(§ pars ))
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<ChainDownloadStartedEventListener>> chainDownloadStartedEventListeners = new CopyOnWriteArrayList<>(§ pars ))
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<PeerConnectedEventListener>> connectedEventListeners = new CopyOnWriteArrayList<>(§ pars ))
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<PeerDisconnectedEventListener>> disconnectedEventListeners = new CopyOnWriteArrayList<>(§ pars ))
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<GetDataEventListener>> getDataEventListeners = new CopyOnWriteArrayList<>(§ pars ))
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<PreMessageReceivedEventListener>> preMessageReceivedEventListeners = new CopyOnWriteArrayList<>(§ pars ))
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<OnTransactionBroadcastListener>> onTransactionEventListeners = new CopyOnWriteArrayList<>(§ pars ))

    ;; Whether to try and download blocks and transactions from this peer.  Set to false by PeerGroup if not the
    ;; primary peer.  This is to avoid redundant work and concurrency problems with downloading the same chain
    ;; in parallel.
    #_private
    #_volatile
    (§ field boolean vDownloadData)
    ;; The version data to announce to the other side of the connections we make: useful for setting our "user agent"
    ;; equivalent and other things.
    #_private
    #_final
    (§ field VersionMessage versionMessage)
    ;; Maximum depth up to which pending transaction dependencies are downloaded, or 0 for disabled.
    #_private
    #_volatile
    (§ field int vDownloadTxDependencyDepth)
    ;; How many block messages the peer has announced to us.  Peers only announce blocks that attach to their best chain
    ;; so we can use this to calculate the height of the peers chain, by adding it to the initial height in the version
    ;; message.  This method can go wrong if the peer re-orgs onto a shorter (but harder) chain, however, this is rare.
    #_private
    #_final
    (§ field AtomicInteger blocksAnnounced = new AtomicInteger(§ pars ))
    ;; Each wallet added to the peer will be notified of downloaded transaction data.
    #_private
    #_final
    (§ field CopyOnWriteArrayList<Wallet> wallets)
    ;; A time before which we only download block headers, after that point we download block bodies.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field long fastCatchupTimeSecs)
    ;; Whether we are currently downloading headers only or block bodies.  Starts at true.  If the fast catchup time is
    ;; set AND our best block is before that date, switch to false until block headers beyond that point have been
    ;; received at which point it gets set to true again.  This isn't relevant unless vDownloadData is true.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field boolean downloadBlockBodies = true)
    ;; Whether to request filtered blocks instead of full blocks if the protocol version allows for them.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field boolean useFilteredBlocks = false)
    ;; The current Bloom filter set on the connection, used to tell the remote peer what transactions to send us.
    #_private
    #_volatile
    (§ field BloomFilter vBloomFilter)
    ;; The last filtered block we received, we're waiting to fill it out with transactions.
    #_private
    (§ field FilteredBlock currentFilteredBlock = nil)
    ;; How many filtered blocks have been received during the lifetime of this connection.  Used to decide when to
    ;; refresh the server-side side filter by sending a new one (it degrades over time as false positives are added
    ;; on the remote side, see BIP 37 for a discussion of this).
    ;; TODO: Is this still needed?  It should not be since the auto FP tracking logic was added.
    #_private
    (§ field int filteredBlocksReceived)
    ;; If non-null, we should discard incoming filtered blocks because we ran out of keys and are awaiting a new filter
    ;; to be calculated by the PeerGroup.  The discarded block hashes should be added here so we can re-request them
    ;; once we've recalculated and resent a new filter.
    #_guarded-by(§ opt "lock")
    #_nilable
    #_private
    (§ field List<Sha256Hash> awaitingFreshFilter)
    ;; How frequently to refresh the filter.  This should become dynamic in future and calculated depending on the
    ;; actual false positive rate.  For now a good value was determined empirically around January 2013.
    #_private
    #_static
    #_final
    (§ field int RESEND_BLOOM_FILTER_BLOCK_COUNT = 25000)
    ;; Keeps track of things we requested internally with getdata but didn't receive yet, so we can avoid re-requests.
    ;; It's not quite the same as getDataFutures, as this is used only for getdatas done as part of downloading
    ;; the chain and so is lighter weight (we just keep a bunch of hashes not futures).
    ;;
    ;; It is important to avoid a nasty edge case where we can end up with parallel chain downloads proceeding
    ;; simultaneously if we were to receive a newly solved block whilst parts of the chain are streaming to us.
    #_private
    #_final
    (§ field HashSet<Sha256Hash> pendingBlockDownloads = new HashSet<>(§ pars ))
    ;; Keep references to TransactionConfidence objects for transactions that were announced by a remote peer, but
    ;; which we haven't downloaded yet.  These objects are de-duplicated by the TxConfidenceTable class.
    ;; Once the tx is downloaded (by some peer), the Transaction object that is created will have a reference to
    ;; the confidence object held inside it, and it's then up to the event listeners that receive the Transaction
    ;; to keep it pinned to the root set if they care about this data.
    #_suppress(§ opt "MismatchedQueryAndUpdateOfCollection")
    #_private
    #_final
    (§ field HashSet<TransactionConfidence> pendingTxDownloads = new HashSet<>(§ pars ))
    ;; The lowest version number we're willing to accept.  Lower than this will result in an immediate disconnect.
    #_private
    #_volatile
    (§ field int vMinProtocolVersion)
    ;; When an API user explicitly requests a block or transaction from a peer, the InventoryItem is put here
    ;; whilst waiting for the response.  Is not used for downloads Peer generates itself.
    #_private
    #_static
    (§ class GetDataRequest
        #_final
        (§ field Sha256Hash hash)
        #_final
        (§ field SettableFuture future)

        #_public
        (§ constructor GetDataRequest(§ args Sha256Hash hash, SettableFuture future))
        (§ block
            (§ ass this.hash = hash)
            (§ ass this.future = future)
        )
    )
    ;; TODO: The types/locking should be rationalised a bit.
    #_private
    #_final
    (§ field CopyOnWriteArrayList<GetDataRequest> getDataFutures)
    #_guarded-by(§ opt "getAddrFutures")
    #_private
    #_final
    (§ field LinkedList<SettableFuture<AddressMessage>> getAddrFutures)

    #_private
    #_static
    #_final
    (§ field int PING_MOVING_AVERAGE_WINDOW = 20)

    ;; Outstanding pings against this peer and how long the last one took to complete.
    #_private
    #_final
    (§ field ReentrantLock lastPingTimesLock = new ReentrantLock(§ pars ))
    #_guarded-by(§ opt "lastPingTimesLock")
    #_private
    (§ field long[] lastPingTimes)
    #_private
    #_final
    (§ field CopyOnWriteArrayList<PendingPing> pendingPings)

    #_private
    #_volatile
    (§ field VersionMessage vPeerVersionMessage)

    ;; A settable future which completes (with this) when the connection is open.
    #_private
    #_final
    (§ field SettableFuture<Peer> connectionOpenFuture = SettableFuture.create(§ pars ))
    #_private
    #_final
    (§ field SettableFuture<Peer> outgoingVersionHandshakeFuture = SettableFuture.create(§ pars ))
    #_private
    #_final
    (§ field SettableFuture<Peer> incomingVersionHandshakeFuture = SettableFuture.create(§ pars ))
    #_private
    #_final
    (§ field ListenableFuture<Peer> versionHandshakeFuture = Futures.transform(§ pars Futures.allAsList(§ pars outgoingVersionHandshakeFuture, incomingVersionHandshakeFuture), new Function<List<Peer>, Peer>(§ pars )
        (§ anon
            #_override
            #_nilable
            #_public
            (§ method Peer apply(§ args #_nilable List<Peer> peers))
            (§ block
                (§ call Preconditions.checkNotNull(§ pars peers))
                (§ call Preconditions.checkState(§ pars peers.size(§ pars ) == 2 && peers.get(§ pars 0) == peers.get(§ pars 1)))
                (§ return peers.get(§ pars 0))
            )
        )))

    ;;;
     ; <p>Construct a peer that reads/writes from the given block chain.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection.  If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
    #_public
    (§ constructor Peer(§ args NetworkParameters params, VersionMessage ver, #_nilable AbstractBlockChain chain, PeerAddress remoteAddress))
    (§ block
        (§ this (§ pars params, ver, remoteAddress, chain))
    )

    ;;;
     ; <p>Construct a peer that reads/writes from the given block chain.  Transactions stored in a {@link org.bitcoinj.core.TxConfidenceTable}
     ; will have their confidence levels updated when a peer announces it, to reflect the greater likelyhood that
     ; the transaction is valid.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection.  If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
    #_public
    (§ constructor Peer(§ args NetworkParameters params, VersionMessage ver, PeerAddress remoteAddress, #_nilable AbstractBlockChain chain))
    (§ block
        (§ this (§ pars params, ver, remoteAddress, chain, Integer.MAX_VALUE))
    )

    ;;;
     ; <p>Construct a peer that reads/writes from the given block chain.  Transactions stored in a {@link org.bitcoinj.core.TxConfidenceTable}
     ; will have their confidence levels updated when a peer announces it, to reflect the greater likelyhood that
     ; the transaction is valid.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection.  If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
    #_public
    (§ constructor Peer(§ args NetworkParameters params, VersionMessage ver, PeerAddress remoteAddress, #_nilable AbstractBlockChain chain, int downloadTxDependencyDepth))
    (§ block
        (§ super (§ pars params, remoteAddress))

        (§ ass this.params = Preconditions.checkNotNull(§ pars params))
        (§ ass this.versionMessage = Preconditions.checkNotNull(§ pars ver))
        (§ ass this.vDownloadTxDependencyDepth = (§ expr chain != nil) ? downloadTxDependencyDepth :else 0)
        (§ ass this.blockChain = chain) ;; Allowed to be nil.
        (§ ass this.vDownloadData = (§ expr chain != nil))
        (§ ass this.getDataFutures = new CopyOnWriteArrayList<>(§ pars ))
        (§ ass this.getAddrFutures = new LinkedList<>(§ pars ))
        (§ ass this.fastCatchupTimeSecs = params.getGenesisBlock(§ pars ).getTimeSeconds(§ pars ))
        (§ ass this.pendingPings = new CopyOnWriteArrayList<>(§ pars ))
        (§ ass this.vMinProtocolVersion = params.getProtocolVersionNum(§ pars NetworkParameters.ProtocolVersion.PONG))
        (§ ass this.wallets = new CopyOnWriteArrayList<>(§ pars ))
        (§ ass this.context = Context.get(§ pars ))

        (§ call this.versionHandshakeFuture.addListener(§ pars (§ new Runnable(§ pars ))
        (§ anon
            #_override
            #_public
            (§ method void run(§ args ))
            (§ block
                (§ call versionHandshakeComplete(§ pars ))
            )
        ), Threading.SAME_THREAD))
    )

    ;;;
     ; <p>Construct a peer that reads/writes from the given chain.  Automatically creates a VersionMessage for you from
     ; the given software name/version strings, which should be something like "MySimpleTool", "1.0" and which will tell
     ; the remote node to relay transaction inv messages before it has received a filter.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection. If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
    #_public
    (§ constructor Peer(§ args NetworkParameters params, AbstractBlockChain blockChain, PeerAddress peerAddress, String thisSoftwareName, String thisSoftwareVersion))
    (§ block
        (§ this (§ pars params, new VersionMessage(§ pars params, blockChain.getBestChainHeight(§ pars )), blockChain, peerAddress))
        (§ call this.versionMessage.appendToSubVer(§ pars thisSoftwareName, thisSoftwareVersion, nil))
    )

    ;;; Registers a listener that is invoked when new blocks are downloaded. ;;
    #_public
    (§ method void addBlocksDownloadedEventListener(§ args BlocksDownloadedEventListener listener))
    (§ block
        (§ call addBlocksDownloadedEventListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;; Registers a listener that is invoked when new blocks are downloaded. ;;
    #_public
    (§ method void addBlocksDownloadedEventListener(§ args Executor executor, BlocksDownloadedEventListener listener))
    (§ block
        (§ call blocksDownloadedEventListeners.add(§ pars (§ new ListenerRegistration(§ pars listener, executor))))
    )

    ;;; Registers a listener that is invoked when a blockchain downloaded starts. ;;
    #_public
    (§ method void addChainDownloadStartedEventListener(§ args ChainDownloadStartedEventListener listener))
    (§ block
        (§ call addChainDownloadStartedEventListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;; Registers a listener that is invoked when a blockchain downloaded starts. ;;
    #_public
    (§ method void addChainDownloadStartedEventListener(§ args Executor executor, ChainDownloadStartedEventListener listener))
    (§ block
        (§ call chainDownloadStartedEventListeners.add(§ pars (§ new ListenerRegistration(§ pars listener, executor))))
    )

    ;;; Registers a listener that is invoked when a peer is connected. ;;
    #_public
    (§ method void addConnectedEventListener(§ args PeerConnectedEventListener listener))
    (§ block
        (§ call addConnectedEventListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;; Registers a listener that is invoked when a peer is connected. ;;
    #_public
    (§ method void addConnectedEventListener(§ args Executor executor, PeerConnectedEventListener listener))
    (§ block
        (§ call connectedEventListeners.add(§ pars (§ new ListenerRegistration(§ pars listener, executor))))
    )

    ;;; Registers a listener that is invoked when a peer is disconnected. ;;
    #_public
    (§ method void addDisconnectedEventListener(§ args PeerDisconnectedEventListener listener))
    (§ block
        (§ call addDisconnectedEventListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;; Registers a listener that is invoked when a peer is disconnected. ;;
    #_public
    (§ method void addDisconnectedEventListener(§ args Executor executor, PeerDisconnectedEventListener listener))
    (§ block
        (§ call disconnectedEventListeners.add(§ pars (§ new ListenerRegistration(§ pars listener, executor))))
    )

    ;;; Registers a listener that is called when messages are received. ;;
    #_public
    (§ method void addGetDataEventListener(§ args GetDataEventListener listener))
    (§ block
        (§ call addGetDataEventListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;; Registers a listener that is called when messages are received. ;;
    #_public
    (§ method void addGetDataEventListener(§ args Executor executor, GetDataEventListener listener))
    (§ block
        (§ call getDataEventListeners.add(§ pars new ListenerRegistration<>(§ pars listener, executor)))
    )

    ;;; Registers a listener that is called when a transaction is broadcast across the network. ;;
    #_public
    (§ method void addOnTransactionBroadcastListener(§ args OnTransactionBroadcastListener listener))
    (§ block
        (§ call addOnTransactionBroadcastListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;; Registers a listener that is called when a transaction is broadcast across the network. ;;
    #_public
    (§ method void addOnTransactionBroadcastListener(§ args Executor executor, OnTransactionBroadcastListener listener))
    (§ block
        (§ call onTransactionEventListeners.add(§ pars new ListenerRegistration<>(§ pars listener, executor)))
    )

    ;;; Registers a listener that is called immediately before a message is received. ;;
    #_public
    (§ method void addPreMessageReceivedEventListener(§ args PreMessageReceivedEventListener listener))
    (§ block
        (§ call addPreMessageReceivedEventListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;; Registers a listener that is called immediately before a message is received. ;;
    #_public
    (§ method void addPreMessageReceivedEventListener(§ args Executor executor, PreMessageReceivedEventListener listener))
    (§ block
        (§ call preMessageReceivedEventListeners.add(§ pars new ListenerRegistration<>(§ pars listener, executor)))
    )

    #_public
    (§ method boolean removeBlocksDownloadedEventListener(§ args BlocksDownloadedEventListener listener))
    (§ block
        (§ return ListenerRegistration.removeFromList(§ pars listener, blocksDownloadedEventListeners))
    )

    #_public
    (§ method boolean removeChainDownloadStartedEventListener(§ args ChainDownloadStartedEventListener listener))
    (§ block
        (§ return ListenerRegistration.removeFromList(§ pars listener, chainDownloadStartedEventListeners))
    )

    #_public
    (§ method boolean removeConnectedEventListener(§ args PeerConnectedEventListener listener))
    (§ block
        (§ return ListenerRegistration.removeFromList(§ pars listener, connectedEventListeners))
    )

    #_public
    (§ method boolean removeDisconnectedEventListener(§ args PeerDisconnectedEventListener listener))
    (§ block
        (§ return ListenerRegistration.removeFromList(§ pars listener, disconnectedEventListeners))
    )

    #_public
    (§ method boolean removeGetDataEventListener(§ args GetDataEventListener listener))
    (§ block
        (§ return ListenerRegistration.removeFromList(§ pars listener, getDataEventListeners))
    )

    #_public
    (§ method boolean removeOnTransactionBroadcastListener(§ args OnTransactionBroadcastListener listener))
    (§ block
        (§ return ListenerRegistration.removeFromList(§ pars listener, onTransactionEventListeners))
    )

    #_public
    (§ method boolean removePreMessageReceivedEventListener(§ args PreMessageReceivedEventListener listener))
    (§ block
        (§ return ListenerRegistration.removeFromList(§ pars listener, preMessageReceivedEventListeners))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ var PeerAddress addr = getAddress(§ pars ))
        ;; if null, it's a user-provided NetworkConnection object
        (§ return (§ quest (§ expr addr == nil) ? "Peer()" :else addr.toString(§ pars )))
    )

    #_override
    #_protected
    (§ method void timeoutOccurred(§ args ))
    (§ block
        (§ call super.timeoutOccurred(§ pars ))

        (§ if (§ expr !connectionOpenFuture.isDone(§ pars )))
        (§ block
            ;; Invoke the event handlers to tell listeners e.g. PeerGroup that we never managed to connect.
            (§ call connectionClosed(§ pars ))
        )
    )

    #_override
    #_public
    (§ method void connectionClosed(§ args ))
    (§ block
        (§ for (§ var #_final ListenerRegistration<PeerDisconnectedEventListener> registration) :for (§ expr disconnectedEventListeners))
        (§ block
            (§ call registration.executor.execute(§ pars (§ new Runnable(§ pars ))
            (§ anon
                #_override
                #_public
                (§ method void run(§ args ))
                (§ block
                    (§ call registration.listener.onPeerDisconnected(§ pars Peer.this, 0))
                )
            )))
        )
    )

    #_override
    #_public
    (§ method void connectionOpened(§ args ))
    (§ block
        ;; Announce ourselves.  This has to come first to connect to clients beyond v0.3.20.2 which wait to hear
        ;; from us until they send their version message back.
        (§ var PeerAddress address = getAddress(§ pars ))
        (§ call log.info(§ pars "Announcing to {} as: {}", (§ expr address == nil) ? "Peer" :else address.toSocketAddress(§ pars ), versionMessage.subVer))
        (§ call sendMessage(§ pars versionMessage))
        (§ call connectionOpenFuture.set(§ pars this))
        ;; When connecting, the remote peer sends us a version message with various bits of
        ;; useful data in it.  We need to know the peer protocol version before we can talk to it.
    )

    ;;;
     ; Provides a ListenableFuture that can be used to wait for the socket to connect.  A socket connection does not
     ; mean that protocol handshake has occurred.
     ;;
    #_public
    (§ method ListenableFuture<Peer> getConnectionOpenFuture(§ args ))
    (§ block
        (§ return connectionOpenFuture)
    )

    #_public
    (§ method ListenableFuture<Peer> getVersionHandshakeFuture(§ args ))
    (§ block
        (§ return versionHandshakeFuture)
    )

    #_override
    #_protected
    (§ method void processMessage(§ args Message m))
        (§ throws Exception)
    (§ block
        ;; Allow event listeners to filter the message stream.  Listeners are allowed to drop messages by returning null.
        (§ for (§ var ListenerRegistration<PreMessageReceivedEventListener> registration) :for (§ expr preMessageReceivedEventListeners))
        (§ block
            ;; Skip any listeners that are supposed to run in another thread as we don't want to block waiting for it,
            ;; which might cause circular deadlock.
            (§ if (§ expr registration.executor == Threading.SAME_THREAD))
            (§ block
                (§ ass m = registration.listener.onPreMessageReceived(§ pars this, m))
                (§ if (§ expr m == nil))
                (§ block
                    (§ break )
                )
            )
        )
        (§ if (§ expr m == nil))
        (§ block
            (§ return )
        )

        ;; If we are in the middle of receiving transactions as part of a filtered block push from the remote node,
        ;; and we receive something that's not a transaction, then we're done.
        (§ if (§ expr currentFilteredBlock != nil && !(§ expr m instanceof Transaction)))
        (§ block
            (§ call endFilteredBlock(§ pars currentFilteredBlock))
            (§ ass currentFilteredBlock = nil)
        )

        ;; No further communication is possible until version handshake is complete.
        (§ if (§ expr !(§ expr m instanceof VersionMessage || m instanceof VersionAck || (§ expr versionHandshakeFuture.isDone(§ pars ) && !versionHandshakeFuture.isCancelled(§ pars )))))
        (§ block
            (§ throw (§ new ProtocolException(§ pars "Received " + m.getClass(§ pars ).getSimpleName(§ pars ) + " before version handshake is complete.")))
        )

        (§ if (§ expr m instanceof Ping))
        (§ block
            (§ call processPing(§ pars (§ cast Ping)m))
        )
        (§ elseif (§ expr m instanceof Pong))
        (§ block
            (§ call processPong(§ pars (§ cast Pong)m))
        )
        (§ elseif (§ expr m instanceof NotFoundMessage))
        (§ block
            ;; This is sent to us when we did a getdata on some transactions that aren't in the peers memory pool.
            ;; Because NotFoundMessage is a subclass of InventoryMessage, the test for it must come before the next.
            (§ call processNotFoundMessage(§ pars (§ cast NotFoundMessage)m))
        )
        (§ elseif (§ expr m instanceof InventoryMessage))
        (§ block
            (§ call processInv(§ pars (§ cast InventoryMessage)m))
        )
        (§ elseif (§ expr m instanceof Block))
        (§ block
            (§ call processBlock(§ pars (§ cast Block)m))
        )
        (§ elseif (§ expr m instanceof FilteredBlock))
        (§ block
            (§ call startFilteredBlock(§ pars (§ cast FilteredBlock)m))
        )
        (§ elseif (§ expr m instanceof Transaction))
        (§ block
            (§ call processTransaction(§ pars (§ cast Transaction)m))
        )
        (§ elseif (§ expr m instanceof GetDataMessage))
        (§ block
            (§ call processGetData(§ pars (§ cast GetDataMessage)m))
        )
        (§ elseif (§ expr m instanceof AddressMessage))
        (§ block
            ;; We don't care about addresses of the network right now.  But in future,
            ;; we should save them in the wallet so we don't put too much load on the seed nodes and can
            ;; properly explore the network.
            (§ call processAddressMessage(§ pars (§ cast AddressMessage)m))
        )
        (§ elseif (§ expr m instanceof HeadersMessage))
        (§ block
            (§ call processHeaders(§ pars (§ cast HeadersMessage)m))
        )
        (§ elseif (§ expr m instanceof AlertMessage))
        (§ block
            (§ call processAlert(§ pars (§ cast AlertMessage)m))
        )
        (§ elseif (§ expr m instanceof VersionMessage))
        (§ block
            (§ call processVersionMessage(§ pars (§ cast VersionMessage)m))
        )
        (§ elseif (§ expr m instanceof VersionAck))
        (§ block
            (§ call processVersionAck(§ pars (§ cast VersionAck)m))
        )
        (§ elseif (§ expr m instanceof RejectMessage))
        (§ block
            (§ call log.error(§ pars "{} {}: Received {}", this, getPeerVersionMessage(§ pars ).subVer, m))
        )
        (§ else )
        (§ block
            (§ call log.warn(§ pars "{}: Received unhandled message: {}", this, m))
        )
    )

    #_private
    (§ method void processAddressMessage(§ args AddressMessage m))
    (§ block
        (§ var SettableFuture<AddressMessage> future)
        (§ sync getAddrFutures)
        (§ block
            (§ ass future = getAddrFutures.poll(§ pars ))
            (§ if (§ expr future == nil)) ;; Not an addr message we are waiting for.
            (§ block
                (§ return )
            )
        )
        (§ call future.set(§ pars m))
    )

    #_private
    (§ method void processVersionMessage(§ args VersionMessage m))
        (§ throws ProtocolException)
    (§ block
        (§ if (§ expr vPeerVersionMessage != nil))
        (§ block
            (§ throw (§ new ProtocolException(§ pars "Got two version messages from peer")))
        )

        (§ ass vPeerVersionMessage = m)
        ;; Switch to the new protocol version.
        (§ var long peerTime = vPeerVersionMessage.time * 1000)
        (§ call log.info(§ pars "{}: Got version={}, subVer='{}', services=0x{}, time={}, blocks={}", this, vPeerVersionMessage.clientVersion, vPeerVersionMessage.subVer, vPeerVersionMessage.localServices, String.format(§ pars Locale.US, "%tF %tT", peerTime, peerTime), vPeerVersionMessage.bestHeight))
        ;; bitcoinj is a client mode implementation.  That means there's not much point in us talking to other client
        ;; mode nodes because we can't download the data from them we need to find/verify transactions.  Some bogus
        ;; implementations claim to have a block chain in their services field but then report a height of zero, filter
        ;; them out here.
        (§ if (§ expr !vPeerVersionMessage.hasBlockChain(§ pars ) || (§ expr !params.allowEmptyPeerChain(§ pars ) && vPeerVersionMessage.bestHeight == 0)))
        (§ block
            ;; Shut down the channel gracefully.
            (§ call log.info(§ pars "{}: Peer does not have a copy of the block chain.", this))
            (§ call close(§ pars ))
            (§ return )
        )

        (§ if (§ expr vPeerVersionMessage.bestHeight < 0))
        (§ block
            ;; In this case, it's a protocol violation.
            (§ throw (§ new ProtocolException(§ pars "Peer reports invalid best height: " + vPeerVersionMessage.bestHeight)))
        )
        ;; Now it's our turn ...
        ;; Send an ACK message stating we accept the peers protocol version.
        (§ call sendMessage(§ pars (§ new VersionAck(§ pars ))))
        (§ call log.debug(§ pars "{}: Incoming version handshake complete.", this))
        (§ call incomingVersionHandshakeFuture.set(§ pars this))
    )

    #_private
    (§ method void processVersionAck(§ args VersionAck m))
        (§ throws ProtocolException)
    (§ block
        (§ if (§ expr vPeerVersionMessage == nil))
        (§ block
            (§ throw (§ new ProtocolException(§ pars "got a version ack before version")))
        )

        (§ if (§ expr outgoingVersionHandshakeFuture.isDone(§ pars )))
        (§ block
            (§ throw (§ new ProtocolException(§ pars "got more than one version ack")))
        )

        (§ call log.debug(§ pars "{}: Outgoing version handshake complete.", this))
        (§ call outgoingVersionHandshakeFuture.set(§ pars this))
    )

    #_private
    (§ method void versionHandshakeComplete(§ args ))
    (§ block
        (§ call log.debug(§ pars "{}: Handshake complete.", this))
        (§ call setTimeoutEnabled(§ pars false))
        (§ for (§ var #_final ListenerRegistration<PeerConnectedEventListener> registration) :for (§ expr connectedEventListeners))
        (§ block
            (§ call registration.executor.execute(§ pars (§ new Runnable(§ pars ))
            (§ anon
                #_override
                #_public
                (§ method void run(§ args ))
                (§ block
                    (§ call registration.listener.onPeerConnected(§ pars Peer.this, 1))
                )
            )))
        )
        ;; We check min version after onPeerConnected as channel.close() will
        ;; call onPeerDisconnected, and we should probably call onPeerConnected first.
        #_final
        (§ var int version = vMinProtocolVersion)
        (§ if (§ expr vPeerVersionMessage.clientVersion < version))
        (§ block
            (§ call log.warn(§ pars "Connected to a peer speaking protocol version {} but need {}, closing", vPeerVersionMessage.clientVersion, version))
            (§ call close(§ pars ))
        )
    )

    #_protected
    (§ method void startFilteredBlock(§ args FilteredBlock m))
    (§ block
        ;; Filtered blocks come before the data that they refer to, so stash it here and then fill it out as
        ;; messages stream in.  We'll call endFilteredBlock when a non-tx message arrives (e.g. another
        ;; FilteredBlock) or when a tx that isn't needed by that block is found.  A ping message is sent after
        ;; a getblocks, to force the non-tx message path.
        (§ ass currentFilteredBlock = m)
        ;; Potentially refresh the server side filter.  Because the remote node adds hits back into the filter
        ;; to save round-tripping back through us, the filter degrades over time as false positives get added,
        ;; triggering yet more false positives.  We refresh it every so often to get the FP rate back down.
        (§ ass filteredBlocksReceived = filteredBlocksReceived + 1)
        (§ if (§ expr filteredBlocksReceived % RESEND_BLOOM_FILTER_BLOCK_COUNT == RESEND_BLOOM_FILTER_BLOCK_COUNT - 1))
        (§ block
            (§ call sendMessage(§ pars vBloomFilter))
        )
    )

    #_protected
    (§ method void processNotFoundMessage(§ args NotFoundMessage m))
    (§ block
        ;; This is received when we previously did a getdata but the peer couldn't find what we requested in it's
        ;; memory pool.  Typically, because we are downloading dependencies of a relevant transaction and reached
        ;; the bottom of the dependency tree (where the unconfirmed transactions connect to transactions that are
        ;; in the chain).
        ;;
        ;; We go through and cancel the pending getdata futures for the items we were told weren't found.
        (§ for (§ var GetDataRequest req) :for (§ expr getDataFutures))
        (§ block
            (§ for (§ var InventoryItem item) :for (§ expr m.getItems(§ pars )))
            (§ block
                (§ if (§ expr item.hash.equals(§ pars req.hash)))
                (§ block
                    (§ call log.info(§ pars "{}: Bottomed out dep tree at {}", this, req.hash))
                    (§ call req.future.cancel(§ pars true))
                    (§ call getDataFutures.remove(§ pars req))
                    (§ break )
                )
            )
        )
    )

    #_protected
    (§ method void processAlert(§ args AlertMessage m))
    (§ block
        (§ try )
        (§ block
            (§ if (§ expr m.isSignatureValid(§ pars )))
            (§ block
                (§ call log.info(§ pars "Received alert from peer {}: {}", this, m.getStatusBar(§ pars )))
            )
            (§ else )
            (§ block
                (§ call log.warn(§ pars "Received alert with invalid signature from peer {}: {}", this, m.getStatusBar(§ pars )))
            )
        )
        (§ catch (§ args Throwable t))
        (§ block
            ;; Signature checking can FAIL on Android platforms before Gingerbread apparently due to bugs in their
            ;; BigInteger implementations!  See https://github.com/bitcoinj/bitcoinj/issues/526 for discussion.
            ;; As alerts are just optional and not that useful, we just swallow the error here.
            (§ call log.error(§ pars "Failed to check signature: bug in platform libraries?", t))
        )
    )

    #_protected
    (§ method void processHeaders(§ args HeadersMessage m))
        (§ throws ProtocolException)
    (§ block
        ;; Runs in network loop thread for this peer.
        ;;
        ;; This method can run if a peer just randomly sends us a "headers" message (should never happen), or more
        ;; likely when we've requested them as part of chain download using fast catchup.  We need to add each block to
        ;; the chain if it pre-dates the fast catchup time.  If we go past it, we can stop processing the headers and
        ;; request the full blocks from that point on instead.
        (§ var boolean downloadBlockBodies)
        (§ var long fastCatchupTimeSecs)

        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr blockChain == nil))
            (§ block
                ;; Can happen if we are receiving unrequested data, or due to programmer error.
                (§ call log.warn(§ pars "Received headers when Peer is not configured with a chain."))
                (§ return )
            )
            (§ ass fastCatchupTimeSecs = this.fastCatchupTimeSecs)
            (§ ass downloadBlockBodies = this.downloadBlockBodies)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )

        (§ try )
        (§ block
            (§ call Preconditions.checkState(§ pars !downloadBlockBodies, toString(§ pars )))

            (§ for (§ var int i = 0) :for (§ expr i < m.getBlockHeaders(§ pars ).size(§ pars )) :for (§ ass i = i + 1))
            (§ block
                (§ var Block header = m.getBlockHeaders(§ pars ).get(§ pars i))
                ;; Process headers until we pass the fast catchup time, or are about to catch up with the head
                ;; of the chain - always process the last block as a full/filtered block to kick us out of the
                ;; fast catchup mode (in which we ignore new blocks).
                (§ var boolean passedTime = (§ expr fastCatchupTimeSecs <= header.getTimeSeconds(§ pars )))
                (§ var boolean reachedTop = (§ expr vPeerVersionMessage.bestHeight <= blockChain.getBestChainHeight(§ pars )))
                (§ if (§ expr !passedTime && !reachedTop))
                (§ block
                    (§ if (§ expr !vDownloadData))
                    (§ block
                        ;; Not download peer anymore, some other peer probably became better.
                        (§ call log.info(§ pars "Lost download peer status, throwing away downloaded headers."))
                        (§ return )
                    )
                    (§ if (§ expr blockChain.add(§ pars header)))
                    (§ block
                        ;; The block was successfully linked into the chain. Notify the user of our progress.
                        (§ call invokeOnBlocksDownloaded(§ pars header, nil))
                    )
                    (§ else )
                    (§ block
                        ;; This block is unconnected - we don't know how to get from it back to the genesis block yet.
                        ;; That must mean that the peer is buggy or malicious because we specifically requested for
                        ;; headers that are part of the best chain.
                        (§ throw (§ new ProtocolException(§ pars "Got unconnected header from peer: " + header.getHashAsString(§ pars ))))
                    )
                )
                (§ else )
                (§ block
                    (§ call lock.lock(§ pars ))
                    (§ try )
                    (§ block
                        (§ call log.info(§ pars "Passed the fast catchup time ({}) at height {}, discarding {} headers and requesting full blocks", Utils.dateTimeFormat(§ pars fastCatchupTimeSecs * 1000), blockChain.getBestChainHeight(§ pars ) + 1, m.getBlockHeaders(§ pars ).size(§ pars ) - i))
                        (§ ass this.downloadBlockBodies = true)
                        ;; Prevent this request being seen as a duplicate.
                        (§ ass this.lastGetBlocksBegin = Sha256Hash.ZERO_HASH)
                        (§ call blockChainDownloadLocked(§ pars Sha256Hash.ZERO_HASH))
                    )
                    (§ finally )
                    (§ block
                        (§ call lock.unlock(§ pars ))
                    )
                    (§ return )
                )
            )
            ;; We added all headers in the message to the chain.
            ;; Request some more if we got up to the limit, otherwise we are at the end of the chain.
            (§ if (§ expr HeadersMessage.MAX_HEADERS <= m.getBlockHeaders(§ pars ).size(§ pars )))
            (§ block
                (§ call lock.lock(§ pars ))
                (§ try )
                (§ block
                    (§ call blockChainDownloadLocked(§ pars Sha256Hash.ZERO_HASH))
                )
                (§ finally )
                (§ block
                    (§ call lock.unlock(§ pars ))
                )
            )
        )
        (§ catch (§ args VerificationException e))
        (§ block
            (§ call log.warn(§ pars "Block header verification failed", e))
        )
        (§ catch (§ args PrunedException e))
        (§ block
            ;; Unreachable when in SPV mode.
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )

    #_protected
    (§ method void processGetData(§ args GetDataMessage getdata))
    (§ block
        (§ call log.info(§ pars "{}: Received getdata message: {}", getAddress(§ pars ), getdata.toString(§ pars )))
        (§ var ArrayList<Message> items = new ArrayList<>(§ pars ))
        (§ for (§ var ListenerRegistration<GetDataEventListener> registration) :for (§ expr getDataEventListeners))
        (§ block
            (§ if (§ expr registration.executor != Threading.SAME_THREAD))
            (§ block
                (§ continue )
            )
            (§ var List<Message> listenerItems = registration.listener.getData(§ pars this, getdata))
            (§ if (§ expr listenerItems == nil))
            (§ block
                (§ continue )
            )
            (§ call items.addAll(§ pars listenerItems))
        )
        (§ if (§ expr !items.isEmpty(§ pars )))
        (§ block
            (§ call log.info(§ pars "{}: Sending {} items gathered from listeners to peer", getAddress(§ pars ), items.size(§ pars )))
            (§ for (§ var Message item) :for (§ expr items))
            (§ block
                (§ call sendMessage(§ pars item))
            )
        )
    )

    #_protected
    (§ method void processTransaction(§ args #_final Transaction tx))
        (§ throws VerificationException)
    (§ block
        ;; Check a few basic syntax issues to ensure the received TX isn't nonsense.
        (§ call tx.verify(§ pars ))
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call log.debug(§ pars "{}: Received tx {}", getAddress(§ pars ), tx.getHashAsString(§ pars )))
            ;; Label the transaction as coming in from the P2P network (as opposed to being created by us, direct import,
            ;; etc).  This helps the wallet decide how to risk analyze it later.
            ;;
            ;; Additionally, by invoking tx.getConfidence(), this tx now pins the confidence data into the heap, meaning
            ;; we can stop holding a reference to the confidence object ourselves.  It's up to event listeners on the
            ;; Peer to stash the tx object somewhere if they want to keep receiving updates about network propagation
            ;; and so on.
            (§ var TransactionConfidence confidence = tx.getConfidence(§ pars ))
            (§ call confidence.setSource(§ pars TransactionConfidence.Source.NETWORK))
            (§ call pendingTxDownloads.remove(§ pars confidence))
            (§ if (§ expr maybeHandleRequestedData(§ pars tx)))
            (§ block
                (§ return )
            )

            (§ if (§ expr currentFilteredBlock != nil))
            (§ block
                (§ if (§ expr !currentFilteredBlock.provideTransaction(§ pars tx)))
                (§ block
                    ;; Got a tx that didn't fit into the filtered block, so we must have received everything.
                    (§ call endFilteredBlock(§ pars currentFilteredBlock))
                    (§ ass currentFilteredBlock = nil)
                )
                ;; Don't tell wallets or listeners about this tx as they'll learn about it when the filtered block is
                ;; fully downloaded instead.
                (§ return )
            )

            ;; It's a broadcast transaction.  Tell all wallets about this tx so they can check if it's relevant or not.
            (§ for (§ var #_final Wallet wallet) :for (§ expr wallets))
            (§ block
                (§ try )
                (§ block
                    (§ if (§ expr wallet.isPendingTransactionRelevant(§ pars tx)))
                    (§ block
                        (§ if (§ expr 0 < vDownloadTxDependencyDepth))
                        (§ block
                            ;; This transaction seems interesting to us, so let's download its dependencies.  This has
                            ;; several purposes: we can check that the sender isn't attacking us by engaging in protocol
                            ;; abuse games, like depending on a time-locked transaction that will never confirm, or
                            ;; building huge chains of unconfirmed transactions (again - so they don't confirm and the
                            ;; money can be taken back with a Finney attack).  Knowing the dependencies also lets us
                            ;; store them in a serialized wallet so we always have enough data to re-announce to the
                            ;; network and get the payment into the chain, in case the sender goes away and the network
                            ;; starts to forget.
                            ;;
                            ;; TODO: Not all the above things are implemented.
                            ;;
                            ;; Note that downloading of dependencies can end up walking around 15 minutes back even
                            ;; through transactions that have confirmed, as getdata on the remote peer also checks
                            ;; relay memory not only the mempool.  Unfortunately we have no way to know that here.
                            ;; In practice it should not matter much.
                            (§ call Futures.addCallback(§ pars downloadDependencies(§ pars tx), new FutureCallback<List<Transaction>>(§ pars )
                            (§ anon
                                #_override
                                #_public
                                (§ method void onSuccess(§ args List<Transaction> dependencies))
                                (§ block
                                    (§ try )
                                    (§ block
                                        (§ call log.info(§ pars "{}: Dependency download complete!", getAddress(§ pars )))
                                        (§ call wallet.receivePending(§ pars tx, dependencies))
                                    )
                                    (§ catch (§ args VerificationException e))
                                    (§ block
                                        (§ call log.error(§ pars "{}: Wallet failed to process pending transaction {}", getAddress(§ pars ), tx.getHash(§ pars )))
                                        (§ call log.error(§ pars "Error was: ", e))
                                        ;; Not much more we can do at this point.
                                    )
                                )

                                #_override
                                #_public
                                (§ method void onFailure(§ args Throwable throwable))
                                (§ block
                                    (§ call log.error(§ pars "Could not download dependencies of tx {}", tx.getHashAsString(§ pars )))
                                    (§ call log.error(§ pars "Error was: ", throwable))
                                    ;; Not much more we can do at this point.
                                )
                            )))
                        )
                        (§ else )
                        (§ block
                            (§ call wallet.receivePending(§ pars tx, nil))
                        )
                    )
                )
                (§ catch (§ args VerificationException e))
                (§ block
                    (§ call log.error(§ pars "Wallet failed to verify tx", e))
                    ;; Carry on, listeners may still want to know.
                )
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
        ;; Tell all listeners about this tx so they can decide whether to keep it or not.  If no listener keeps a
        ;; reference around then the memory pool will forget about it after a while too because it uses weak references.
        (§ for (§ var #_final ListenerRegistration<OnTransactionBroadcastListener> registration) :for (§ expr onTransactionEventListeners))
        (§ block
            (§ call registration.executor.execute(§ pars (§ new Runnable(§ pars ))
            (§ anon
                #_override
                #_public
                (§ method void run(§ args ))
                (§ block
                    (§ call registration.listener.onTransaction(§ pars Peer.this, tx))
                )
            )))
        )
    )

    ;;;
     ; <p>Returns a future that wraps a list of all transactions that the given transaction depends on, recursively.
     ; Only transactions in peers memory pools are included; the recursion stops at transactions that are in the
     ; current best chain.  So it doesn't make much sense to provide a tx that was already in the best chain and
     ; a precondition checks this.</p>
     ;
     ; <p>For example, if tx has 2 inputs that connect to transactions A and B, and transaction B is unconfirmed and
     ; has one input connecting to transaction C that is unconfirmed, and transaction C connects to transaction D
     ; that is in the chain, then this method will return either {B, C} or {C, B}.  No ordering is guaranteed.</p>
     ;
     ; <p>This method is useful for apps that want to learn about how long an unconfirmed transaction might take
     ; to confirm, by checking for unexpectedly time locked transactions, unusually deep dependency trees or fee-paying
     ; transactions that depend on unconfirmed free transactions.</p>
     ;
     ; <p>Note that dependencies downloaded this way will not trigger the onTransaction method of event listeners.</p>
     ;;
    #_public
    (§ method ListenableFuture<List<Transaction>> downloadDependencies(§ args Transaction tx))
    (§ block
        (§ var TransactionConfidence.ConfidenceType txConfidence = tx.getConfidence(§ pars ).getConfidenceType(§ pars ))
        (§ call Preconditions.checkArgument(§ pars txConfidence != TransactionConfidence.ConfidenceType.BUILDING))
        (§ call log.info(§ pars "{}: Downloading dependencies of {}", getAddress(§ pars ), tx.getHashAsString(§ pars )))
        #_final
        (§ var LinkedList<Transaction> results = new LinkedList<>(§ pars ))
        ;; future will be invoked when the entire dependency tree has been walked and the results compiled.
        #_final
        (§ var ListenableFuture<Object> future = downloadDependenciesInternal(§ pars vDownloadTxDependencyDepth, 0, tx, new Object(§ pars ), results))
        #_final
        (§ var SettableFuture<List<Transaction>> resultFuture = SettableFuture.create(§ pars ))
        (§ call Futures.addCallback(§ pars future, new FutureCallback<Object>(§ pars )
        (§ anon
            #_override
            #_public
            (§ method void onSuccess(§ args Object ignored))
            (§ block
                (§ call resultFuture.set(§ pars results))
            )

            #_override
            #_public
            (§ method void onFailure(§ args Throwable throwable))
            (§ block
                (§ call resultFuture.setException(§ pars throwable))
            )
        )))
        (§ return resultFuture)
    )

    ;; The marker object in the future returned is the same as the parameter.  It is arbitrary and can be anything.
    #_protected
    (§ method ListenableFuture<Object> downloadDependenciesInternal(§ args #_final int maxDepth, #_final int depth, #_final Transaction tx, #_final Object marker, #_final List<Transaction> results))
    (§ block
        #_final
        (§ var SettableFuture<Object> resultFuture = SettableFuture.create(§ pars ))
        #_final
        (§ var Sha256Hash rootTxHash = tx.getHash(§ pars ))
        ;; We want to recursively grab its dependencies.  This is so listeners can learn important information like
        ;; whether a transaction is dependent on a timelocked transaction or has an unexpectedly deep dependency tree
        ;; or depends on a no-fee transaction.

        ;; We may end up requesting transactions that we've already downloaded and thrown away here.
        (§ var Set<Sha256Hash> needToRequest = new CopyOnWriteArraySet<>(§ pars ))
        (§ for (§ var TransactionInput input) :for (§ expr tx.getInputs(§ pars )))
        (§ block
            ;; There may be multiple inputs that connect to the same transaction.
            (§ call needToRequest.add(§ pars input.getOutpoint(§ pars ).getHash(§ pars )))
        )

        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; Build the request for the missing dependencies.
            (§ var List<ListenableFuture<Transaction>> futures = Lists.newArrayList(§ pars ))
            (§ var GetDataMessage getdata = new GetDataMessage(§ pars params))

            (§ if (§ expr 1 < needToRequest.size(§ pars )))
            (§ block
                (§ call log.info(§ pars "{}: Requesting {} transactions for depth {} dep resolution", getAddress(§ pars ), needToRequest.size(§ pars ), depth + 1))
            )

            (§ for (§ var Sha256Hash hash) :for (§ expr needToRequest))
            (§ block
                (§ call getdata.addTransaction(§ pars hash))
                (§ var GetDataRequest req = new GetDataRequest(§ pars hash, SettableFuture.create(§ pars )))
                (§ call futures.add(§ pars req.future))
                (§ call getDataFutures.add(§ pars req))
            )

            (§ var ListenableFuture<List<Transaction>> successful = Futures.successfulAsList(§ pars futures))
            (§ call Futures.addCallback(§ pars successful, new FutureCallback<List<Transaction>>(§ pars )
            (§ anon
                #_override
                #_public
                (§ method void onSuccess(§ args List<Transaction> transactions))
                (§ block
                    ;; Once all transactions either were received, or we know there are no more to come, ...
                    ;; Note that transactions will contain "null" for any positions that weren't successful.
                    (§ var List<ListenableFuture<Object>> childFutures = Lists.newLinkedList(§ pars ))
                    (§ for (§ var Transaction tx) :for (§ expr transactions))
                    (§ block
                        (§ if (§ expr tx == nil))
                        (§ block
                            (§ continue )
                        )
                        (§ call log.info(§ pars "{}: Downloaded dependency of {}: {}", getAddress(§ pars ), rootTxHash, tx.getHashAsString(§ pars )))
                        (§ call results.add(§ pars tx))
                        ;; Now recurse into the dependencies of this transaction too.
                        (§ if (§ expr depth + 1 < maxDepth))
                        (§ block
                            (§ call childFutures.add(§ pars downloadDependenciesInternal(§ pars maxDepth, depth + 1, tx, marker, results)))
                        )
                    )
                    (§ if (§ expr childFutures.size(§ pars ) == 0))
                    (§ block
                        ;; Short-circuit: we're at the bottom of this part of the tree.
                        (§ call resultFuture.set(§ pars marker))
                    )
                    (§ else )
                    (§ block
                        ;; There are some children to download.  Wait until it's done (and their children, and their
                        ;; children, ...) to inform the caller that we're finished.
                        (§ call Futures.addCallback(§ pars Futures.successfulAsList(§ pars childFutures), new FutureCallback<List<Object>>(§ pars )
                        (§ anon
                            #_override
                            #_public
                            (§ method void onSuccess(§ args List<Object> objects))
                            (§ block
                                (§ call resultFuture.set(§ pars marker))
                            )

                            #_override
                            #_public
                            (§ method void onFailure(§ args Throwable throwable))
                            (§ block
                                (§ call resultFuture.setException(§ pars throwable))
                            )
                        )))
                    )
                )

                #_override
                #_public
                (§ method void onFailure(§ args Throwable throwable))
                (§ block
                    (§ call resultFuture.setException(§ pars throwable))
                )
            )))

            ;; Start the operation.
            (§ call sendMessage(§ pars getdata))
        )
        (§ catch (§ args Exception e))
        (§ block
            (§ call log.error(§ pars "{}: Couldn't send getdata in downloadDependencies({})", this, tx.getHash(§ pars ), e))
            (§ call resultFuture.setException(§ pars e))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )

        (§ return resultFuture)
    )

    #_protected
    (§ method void processBlock(§ args Block m))
    (§ block
        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ call log.debug(§ pars "{}: Received broadcast block {}", getAddress(§ pars ), m.getHashAsString(§ pars )))
        )

        ;; Was this block requested by getBlock()?
        (§ if (§ expr maybeHandleRequestedData(§ pars m)))
        (§ block
            (§ return )
        )

        (§ if (§ expr blockChain == nil))
        (§ block
            (§ call log.debug(§ pars "Received block but was not configured with an AbstractBlockChain"))
            (§ return )
        )

        ;; Did we lose download peer status after requesting block data?
        (§ if (§ expr !vDownloadData))
        (§ block
            (§ call log.debug(§ pars "{}: Received block we did not ask for: {}", getAddress(§ pars ), m.getHashAsString(§ pars )))
            (§ return )
        )

        (§ call pendingBlockDownloads.remove(§ pars m.getHash(§ pars )))

        (§ try )
        (§ block
            ;; Otherwise it's a block sent to us because the peer thought we needed it, so add it to the block chain.
            (§ if (§ expr blockChain.add(§ pars m)))
            (§ block
                ;; The block was successfully linked into the chain.  Notify the user of our progress.
                (§ call invokeOnBlocksDownloaded(§ pars m, nil))
            )
            (§ else )
            (§ block
                ;; This block is an orphan - we don't know how to get from it back to the genesis block yet.  That
                ;; must mean that there are blocks we are missing, so do another getblocks with a new block locator
                ;; to ask the peer to send them to us.  This can happen during the initial block chain download where
                ;; the peer will only send us 500 at a time and then sends us the head block expecting us to request
                ;; the others.
                ;;
                ;; We must do two things here:
                ;; (1) Request from current top of chain to the oldest ancestor of the received block in the orphan set.
                ;; (2) Filter out duplicate getblock requests (done in blockChainDownloadLocked).
                ;;
                ;; The reason for (1) is that otherwise if new blocks were solved during the middle of chain download
                ;; we'd do a blockChainDownloadLocked() on the new best chain head, which would cause us to try and grab the
                ;; chain twice (or more!) on the same connection!  The block chain would filter out the duplicates but
                ;; only at a huge speed penalty.  By finding the orphan root we ensure every getblocks looks the same
                ;; no matter how many blocks are solved, and therefore that the (2) duplicate filtering can work.
                ;;
                ;; We only do this if we are not currently downloading headers.  If we are then we don't want to kick
                ;; off a request for lots more headers in parallel.
                (§ call lock.lock(§ pars ))
                (§ try )
                (§ block
                    (§ if (§ expr downloadBlockBodies))
                    (§ block
                        #_final
                        (§ var Block orphanRoot = Preconditions.checkNotNull(§ pars blockChain.getOrphanRoot(§ pars m.getHash(§ pars ))))
                        (§ call blockChainDownloadLocked(§ pars orphanRoot.getHash(§ pars )))
                    )
                    (§ else )
                    (§ block
                        (§ call log.info(§ pars "Did not start chain download on solved block due to in-flight header download."))
                    )
                )
                (§ finally )
                (§ block
                    (§ call lock.unlock(§ pars ))
                )
            )
        )
        (§ catch (§ args VerificationException e))
        (§ block
            ;; We don't want verification failures to kill the thread.
            (§ call log.warn(§ pars "{}: Block verification failed", getAddress(§ pars ), e))
        )
        (§ catch (§ args PrunedException e))
        (§ block
            ;; Unreachable when in SPV mode.
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )

    ;; TODO: Fix this duplication.
    #_protected
    (§ method void endFilteredBlock(§ args FilteredBlock m))
    (§ block
        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ call log.debug(§ pars "{}: Received broadcast filtered block {}", getAddress(§ pars ), m.getHash(§ pars ).toString(§ pars )))
        )

        (§ if (§ expr !vDownloadData))
        (§ block
            (§ call log.debug(§ pars "{}: Received block we did not ask for: {}", getAddress(§ pars ), m.getHash(§ pars ).toString(§ pars )))
            (§ return )
        )

        (§ if (§ expr blockChain == nil))
        (§ block
            (§ call log.debug(§ pars "Received filtered block but was not configured with an AbstractBlockChain"))
            (§ return )
        )

        ;; Note that we currently do nothing about peers which maliciously do not include transactions which
        ;; actually match our filter or which simply do not send us all the transactions we need: it can be fixed
        ;; by cross-checking peers against each other.
        (§ call pendingBlockDownloads.remove(§ pars m.getBlockHeader(§ pars ).getHash(§ pars )))

        (§ try )
        (§ block
            ;; It's a block sent to us because the peer thought we needed it, so maybe add it to the block chain.
            ;; The FilteredBlock m here contains a list of hashes, and may contain Transaction objects for a subset
            ;; of the hashes (those that were sent to us by the remote peer).  Any hashes that haven't had a tx
            ;; provided in processTransaction are ones that were announced to us previously via an 'inv' so the
            ;; assumption is we have already downloaded them and either put them in the wallet, or threw them away
            ;; for being false positives.
            ;;
            ;; TODO: Fix the following protocol race.
            ;; It is possible for this code to go wrong such that we miss a confirmation.  If the remote peer announces
            ;; a relevant transaction via an 'inv' and then it immediately announces the block that confirms
            ;; the tx before we had a chance to download it+its dependencies and provide them to the wallet, then we
            ;; will add the block to the chain here without the tx being in the wallet and thus it will miss its
            ;; confirmation and become stuck forever.  The fix is to notice that there's a pending getdata for a tx
            ;; that appeared in this block and delay processing until it arrived ... it's complicated by the fact that
            ;; the data may be requested by a different peer to this one.

            ;; Ask each wallet attached to the peer/blockchain if this block exhausts the list of data items
            ;; (keys/addresses) that were used to calculate the previous filter.  If so, then it's possible this block
            ;; is only partial.  Check for discarding first so we don't check for exhaustion on blocks we already know
            ;; we're going to discard, otherwise redundant filters might end up being queued and calculated.
            (§ call lock.lock(§ pars ))
            (§ try )
            (§ block
                (§ if (§ expr awaitingFreshFilter != nil))
                (§ block
                    (§ call log.info(§ pars "Discarding block {} because we're still waiting for a fresh filter", m.getHash(§ pars )))
                    ;; We must record the hashes of blocks we discard because you cannot do getblocks twice on the same
                    ;; range of blocks and get an inv both times, due to the codepath in Bitcoin Core hitting
                    ;; CPeer::PushInventory() which checks CPeer::setInventoryKnown and thus deduplicates.
                    (§ call awaitingFreshFilter.add(§ pars m.getHash(§ pars )))
                    (§ return ) ;; Chain download process is restarted via a call to setBloomFilter.
                )

                (§ if (§ expr checkForFilterExhaustion(§ pars m)))
                (§ block
                    ;; Yes, so we must abandon the attempt to process this block and any further blocks we receive,
                    ;; then wait for the Bloom filter to be recalculated, sent to this peer and for the peer to acknowledge
                    ;; that the new filter is now in use (which we have to simulate with a ping/pong), and then we can
                    ;; safely restart the chain download with the new filter that contains a new set of lookahead keys.
                    (§ call log.info(§ pars "Bloom filter exhausted whilst processing block {}, discarding", m.getHash(§ pars )))
                    (§ ass awaitingFreshFilter = new LinkedList<>(§ pars ))
                    (§ call awaitingFreshFilter.add(§ pars m.getHash(§ pars )))
                    (§ call awaitingFreshFilter.addAll(§ pars blockChain.drainOrphanBlocks(§ pars )))
                    (§ return ) ;; Chain download process is restarted via a call to setBloomFilter.
                )
            )
            (§ finally )
            (§ block
                (§ call lock.unlock(§ pars ))
            )

            (§ if (§ expr blockChain.add(§ pars m)))
            (§ block
                ;; The block was successfully linked into the chain.  Notify the user of our progress.
                (§ call invokeOnBlocksDownloaded(§ pars m.getBlockHeader(§ pars ), m))
            )
            (§ else )
            (§ block
                ;; This block is an orphan - we don't know how to get from it back to the genesis block yet.  That
                ;; must mean that there are blocks we are missing, so do another getblocks with a new block locator
                ;; to ask the peer to send them to us.  This can happen during the initial block chain download where
                ;; the peer will only send us 500 at a time and then sends us the head block expecting us to request
                ;; the others.
                ;;
                ;; We must do two things here:
                ;; (1) Request from current top of chain to the oldest ancestor of the received block in the orphan set.
                ;; (2) Filter out duplicate getblock requests (done in blockChainDownloadLocked).
                ;;
                ;; The reason for (1) is that otherwise if new blocks were solved during the middle of chain download
                ;; we'd do a blockChainDownloadLocked() on the new best chain head, which would cause us to try and grab the
                ;; chain twice (or more!) on the same connection!  The block chain would filter out the duplicates but
                ;; only at a huge speed penalty.  By finding the orphan root we ensure every getblocks looks the same
                ;; no matter how many blocks are solved, and therefore that the (2) duplicate filtering can work.
                (§ call lock.lock(§ pars ))
                (§ try )
                (§ block
                    #_final
                    (§ var Block orphanRoot = Preconditions.checkNotNull(§ pars blockChain.getOrphanRoot(§ pars m.getHash(§ pars ))))
                    (§ call blockChainDownloadLocked(§ pars orphanRoot.getHash(§ pars )))
                )
                (§ finally )
                (§ block
                    (§ call lock.unlock(§ pars ))
                )
            )
        )
        (§ catch (§ args VerificationException e))
        (§ block
            ;; We don't want verification failures to kill the thread.
            (§ call log.warn(§ pars "{}: FilteredBlock verification failed", getAddress(§ pars ), e))
        )
        (§ catch (§ args PrunedException e))
        (§ block
            ;; We pruned away some of the data we need to properly handle this block.  We need to request the needed
            ;; data from the remote peer and fix things.  Or just give up.
            ;; TODO: Request e.getHash() and submit it to the block store before any other blocks.
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )

    #_private
    (§ method boolean checkForFilterExhaustion(§ args FilteredBlock m))
    (§ block
        (§ var boolean exhausted = false)
        (§ for (§ var Wallet wallet) :for (§ expr wallets))
        (§ block
            (§ ass exhausted = exhausted | wallet.checkForFilterExhaustion(§ pars m))
        )
        (§ return exhausted)
    )

    #_private
    (§ method boolean maybeHandleRequestedData(§ args Message m))
    (§ block
        (§ var boolean found = false)
        (§ var Sha256Hash hash = m.getHash(§ pars ))
        (§ for (§ var GetDataRequest req) :for (§ expr getDataFutures))
        (§ block
            (§ if (§ expr hash.equals(§ pars req.hash)))
            (§ block
                (§ call req.future.set(§ pars m))
                (§ call getDataFutures.remove(§ pars req))
                (§ ass found = true)
                ;; Keep going in case there are more.
            )
        )
        (§ return found)
    )

    #_private
    (§ method void invokeOnBlocksDownloaded(§ args #_final Block block, #_nilable #_final FilteredBlock fb))
    (§ block
        ;; It is possible for the peer block height difference to be negative when blocks have been solved and broadcast
        ;; since the time we first connected to the peer.  However, it's weird and unexpected to receive a callback
        ;; with negative "blocks left" in this case, so we clamp to zero so the API user doesn't have to think about it.
        #_final
        (§ var int blocksLeft = Math.max(§ pars 0, (§ cast int)vPeerVersionMessage.bestHeight - Preconditions.checkNotNull(§ pars blockChain).getBestChainHeight(§ pars )))
        (§ for (§ var #_final ListenerRegistration<BlocksDownloadedEventListener> registration) :for (§ expr blocksDownloadedEventListeners))
        (§ block
            (§ call registration.executor.execute(§ pars (§ new Runnable(§ pars ))
            (§ anon
                #_override
                #_public
                (§ method void run(§ args ))
                (§ block
                    (§ call registration.listener.onBlocksDownloaded(§ pars Peer.this, block, fb, blocksLeft))
                )
            )))
        )
    )

    #_protected
    (§ method void processInv(§ args InventoryMessage inv))
    (§ block
        (§ var List<InventoryItem> items = inv.getItems(§ pars ))

        ;; Separate out the blocks and transactions, we'll handle them differently.
        (§ var List<InventoryItem> transactions = new LinkedList<>(§ pars ))
        (§ var List<InventoryItem> blocks = new LinkedList<>(§ pars ))

        (§ for (§ var InventoryItem item) :for (§ expr items))
        (§ block
            (§ switch (§ expr item.type))
            (§ block
                (§ case Transaction)
                (§ block
                    (§ call transactions.add(§ pars item))
                    (§ break )
                )
                (§ case Block)
                (§ block
                    (§ call blocks.add(§ pars item))
                    (§ break )
                )
                (§ default )
                (§ block
                    (§ throw (§ new IllegalStateException(§ pars "Not implemented: " + item.type)))
                )
            )
        )

        #_final
        (§ var boolean downloadData = this.vDownloadData)

        (§ if (§ expr transactions.size(§ pars ) == 0 && blocks.size(§ pars ) == 1))
        (§ block
            ;; Single block announcement.  If we're downloading the chain this is just a tickle to make us continue
            ;; (the block chain download protocol is very implicit and not well thought out).  If we're not downloading
            ;; the chain then this probably means a new block was solved and the peer believes it connects to the best
            ;; chain, so count it.  This way getBestChainHeight() can be accurate.
            (§ if (§ expr downloadData && blockChain != nil))
            (§ block
                (§ if (§ expr !blockChain.isOrphan(§ pars blocks.get(§ pars 0).hash)))
                (§ block
                    (§ call blocksAnnounced.incrementAndGet(§ pars ))
                )
            )
            (§ else )
            (§ block
                (§ call blocksAnnounced.incrementAndGet(§ pars ))
            )
        )

        (§ var GetDataMessage getdata = new GetDataMessage(§ pars params))

        (§ var Iterator<InventoryItem> it = transactions.iterator(§ pars ))
        (§ while (§ expr it.hasNext(§ pars )))
        (§ block
            (§ var InventoryItem item = it.next(§ pars ))
            ;; Only download the transaction if we are the first peer that saw it be advertised.  Other peers will also
            ;; see it be advertised in inv packets asynchronously, they co-ordinate via the memory pool.  We could
            ;; potentially download transactions faster by always asking every peer for a tx when advertised, as remote
            ;; peers run at different speeds.  However to conserve bandwidth on mobile devices we try to only download a
            ;; transaction once.  This means we can miss broadcasts if the peer disconnects between sending us an inv and
            ;; sending us the transaction: currently we'll never try to re-fetch after a timeout.
            ;;
            ;; The line below can trigger confidence listeners.
            (§ var TransactionConfidence conf = context.getConfidenceTable(§ pars ).seen(§ pars item.hash, this.getAddress(§ pars )))
            (§ if (§ expr 1 < conf.numBroadcastPeers(§ pars )))
            (§ block
                ;; Some other peer already announced this so don't download.
                (§ call it.remove(§ pars ))
            )
            (§ elseif (§ expr conf.getSource(§ pars ).equals(§ pars TransactionConfidence.Source.SELF)))
            (§ block
                ;; We created this transaction ourselves, so don't download.
                (§ call it.remove(§ pars ))
            )
            (§ else )
            (§ block
                (§ call log.debug(§ pars "{}: getdata on tx {}", getAddress(§ pars ), item.hash))
                (§ call getdata.addItem(§ pars item))
                ;; Register with the garbage collector that we care about the confidence data for a while.
                (§ call pendingTxDownloads.add(§ pars conf))
            )
        )

        ;; If we are requesting filteredblocks, we have to send a ping after the getdata so that we have a clear
        ;; end to the final FilteredBlock's transactions (in the form of a pong) sent to us.
        (§ var boolean pingAfterGetData = false)

        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr 0 < blocks.size(§ pars ) && downloadData && blockChain != nil))
            (§ block
                ;; Ideally, we'd only ask for the data here if we actually needed it.  However that can imply a lot of
                ;; disk IO to figure out what we've got.  Normally peers will not send us inv for things we already have
                ;; so we just re-request it here, and if we get duplicates the block chain / wallet will filter them out.
                (§ for (§ var InventoryItem item) :for (§ expr blocks))
                (§ block
                    (§ if (§ expr blockChain.isOrphan(§ pars item.hash) && downloadBlockBodies))
                    (§ block
                        ;; If an orphan was re-advertised, ask for more blocks unless we are not currently downloading
                        ;; full block data because we have a getheaders outstanding.
                        #_final
                        (§ var Block orphanRoot = Preconditions.checkNotNull(§ pars blockChain.getOrphanRoot(§ pars item.hash)))
                        (§ call blockChainDownloadLocked(§ pars orphanRoot.getHash(§ pars )))
                    )
                    (§ else )
                    (§ block
                        ;; Don't re-request blocks we already requested.  Normally this should not happen.  However there is
                        ;; an edge case: if a block is solved and we complete the inv<->getdata<->block<->getblocks cycle
                        ;; whilst other parts of the chain are streaming in, then the new getblocks request won't match the
                        ;; previous one: whilst the stopHash is the same (because we use the orphan root), the start hash
                        ;; will be different and so the getblocks req won't be dropped as a duplicate.  We'll end up
                        ;; requesting a subset of what we already requested, which can lead to parallel chain downloads
                        ;; and other nastyness.  So we just do a quick removal of redundant getdatas here too.
                        ;;
                        ;; Note that as of June 2012 Bitcoin Core won't actually ever interleave blocks pushed as
                        ;; part of chain download with newly announced blocks, so it should always be taken care of by
                        ;; the duplicate check in blockChainDownloadLocked().  But Bitcoin Core may change in future so
                        ;; it's better to be safe here.
                        (§ if (§ expr !pendingBlockDownloads.contains(§ pars item.hash)))
                        (§ block
                            (§ if (§ expr vPeerVersionMessage.isBloomFilteringSupported(§ pars ) && useFilteredBlocks))
                            (§ block
                                (§ call getdata.addFilteredBlock(§ pars item.hash))
                                (§ ass pingAfterGetData = true)
                            )
                            (§ else )
                            (§ block
                                (§ call getdata.addItem(§ pars item))
                            )
                            (§ call pendingBlockDownloads.add(§ pars item.hash))
                        )
                    )
                )
                ;; If we're downloading the chain, doing a getdata on the last block we were told about will cause the
                ;; peer to advertize the head block to us in a single-item inv.  When we download THAT, it will be an
                ;; orphan block, meaning we'll re-enter blockChainDownloadLocked() to trigger another getblocks between the
                ;; current best block we have and the orphan block.  If more blocks arrive in the meantime they'll also
                ;; become orphan.
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )

        (§ if (§ expr !getdata.getItems(§ pars ).isEmpty(§ pars )))
        (§ block
            ;; This will cause us to receive a bunch of block or tx messages.
            (§ call sendMessage(§ pars getdata))
        )

        (§ if (§ expr pingAfterGetData))
        (§ block
            (§ call sendMessage(§ pars (§ new Ping(§ pars (§ cast long)(§ expr Math.random(§ pars ) * Long.MAX_VALUE)))))
        )
    )

    ;;;
     ; Asks the connected peer for the block of the given hash, and returns a future representing the answer.
     ; If you want the block right away and don't mind waiting for it, just call .get() on the result.  Your thread
     ; will block until the peer answers.
     ;;
    #_suppress(§ opt "unchecked")
    ;; The 'unchecked conversion' warning being suppressed here comes from the sendSingleGetData() formally returning
    ;; ListenableFuture instead of ListenableFuture<Block>.  This is okay as sendSingleGetData() actually returns
    ;; ListenableFuture<Block> in this context.  Note that sendSingleGetData() is also used for Transactions.
    #_public
    (§ method ListenableFuture<Block> getBlock(§ args Sha256Hash blockHash))
    (§ block
        ;; This does not need to be locked.
        (§ call log.info(§ pars "Request to fetch block {}", blockHash))
        (§ var GetDataMessage getdata = new GetDataMessage(§ pars params))
        (§ call getdata.addBlock(§ pars blockHash))
        (§ return sendSingleGetData(§ pars getdata))
    )

    ;;;
     ; Asks the connected peer for the given transaction from its memory pool.  Transactions in the chain cannot be
     ; retrieved this way because peers don't have a transaction ID to transaction-pos-on-disk index, and besides,
     ; in future many peers will delete old transaction data they don't need.
     ;;
    #_suppress(§ opt "unchecked")
    ;; The 'unchecked conversion' warning being suppressed here comes from the sendSingleGetData() formally returning
    ;; ListenableFuture instead of ListenableFuture<Transaction>.  This is okay as sendSingleGetData() actually returns
    ;; ListenableFuture<Transaction> in this context.  Note that sendSingleGetData() is also used for Blocks.
    #_public
    (§ method ListenableFuture<Transaction> getPeerMempoolTransaction(§ args Sha256Hash hash))
    (§ block
        ;; This does not need to be locked.
        (§ call log.info(§ pars "Request to fetch peer mempool tx  {}", hash))
        (§ var GetDataMessage getdata = new GetDataMessage(§ pars params))
        (§ call getdata.addTransaction(§ pars hash))
        (§ return sendSingleGetData(§ pars getdata))
    )

    ;;; Sends a getdata with a single item in it. ;;
    #_private
    (§ method ListenableFuture sendSingleGetData(§ args GetDataMessage getdata))
    (§ block
        ;; This does not need to be locked.
        (§ call Preconditions.checkArgument(§ pars getdata.getItems(§ pars ).size(§ pars ) == 1))
        (§ var GetDataRequest req = new GetDataRequest(§ pars getdata.getItems(§ pars ).get(§ pars 0).hash, SettableFuture.create(§ pars )))
        (§ call getDataFutures.add(§ pars req))
        (§ call sendMessage(§ pars getdata))
        (§ return req.future)
    )

    ;;; Sends a getaddr request to the peer and returns a future that completes with the answer once the peer has replied. ;;
    #_public
    (§ method ListenableFuture<AddressMessage> getAddr(§ args ))
    (§ block
        (§ var SettableFuture<AddressMessage> future = SettableFuture.create(§ pars ))
        (§ sync getAddrFutures)
        (§ block
            (§ call getAddrFutures.add(§ pars future))
        )
        (§ call sendMessage(§ pars (§ new GetAddrMessage(§ pars params))))
        (§ return future)
    )

    ;;;
     ; When downloading the block chain, the bodies will be skipped for blocks created before the given date.
     ; Any transactions relevant to the wallet will therefore not be found, but if you know your wallet has no such
     ; transactions it doesn't matter and can save a lot of bandwidth and processing time.  Note that the times of blocks
     ; isn't known until their headers are available and they are requested in chunks, so some headers may be downloaded
     ; twice using this scheme, but this optimization can still be a large win for newly created wallets.
     ;
     ; @param secondsSinceEpoch Time in seconds since the epoch or 0 to reset to always downloading block bodies.
     ;;
    #_public
    (§ method void setDownloadParameters(§ args long secondsSinceEpoch, boolean useFilteredBlocks))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr secondsSinceEpoch == 0))
            (§ block
                (§ ass fastCatchupTimeSecs = params.getGenesisBlock(§ pars ).getTimeSeconds(§ pars ))
                (§ ass downloadBlockBodies = true)
            )
            (§ else )
            (§ block
                (§ ass fastCatchupTimeSecs = secondsSinceEpoch)
                ;; If the given time is before the current chains head block time, then this has no effect (we already
                ;; downloaded everything we need).
                (§ if (§ expr blockChain != nil && blockChain.getChainHead(§ pars ).getHeader(§ pars ).getTimeSeconds(§ pars ) < fastCatchupTimeSecs))
                (§ block
                    (§ ass downloadBlockBodies = false)
                )
            )
            (§ ass this.useFilteredBlocks = useFilteredBlocks)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Links the given wallet to this peer.  If you have multiple peers, you should use a {@link PeerGroup} to manage
     ; them and use the {@link PeerGroup#addWallet(Wallet)} method instead of registering the wallet with each peer
     ; independently, otherwise the wallet will receive duplicate notifications.
     ;;
    #_public
    (§ method void addWallet(§ args Wallet wallet))
    (§ block
        (§ call wallets.add(§ pars wallet))
    )

    ;;; Unlinks the given wallet from peer.  See {@link Peer#addWallet(Wallet)}. ;;
    #_public
    (§ method void removeWallet(§ args Wallet wallet))
    (§ block
        (§ call wallets.remove(§ pars wallet))
    )

    ;; Keep track of the last request we made to the peer in blockChainDownloadLocked so we can avoid redundant and harmful
    ;; getblocks requests.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field Sha256Hash lastGetBlocksBegin, lastGetBlocksEnd)

    #_guarded-by(§ opt "lock")
    #_private
    (§ method void blockChainDownloadLocked(§ args Sha256Hash toHash))
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        ;; The block chain download process is a bit complicated.  Basically, we start with one or more blocks in a
        ;; chain that we have from a previous session.  We want to catch up to the head of the chain BUT we don't know
        ;; where that chain is up to or even if the top block we have is even still in the chain - we
        ;; might have got ourselves onto a fork that was later resolved by the network.
        ;;
        ;; To solve this, we send the peer a block locator which is just a list of block hashes.  It contains the
        ;; blocks we know about, but not all of them, just enough of them so the peer can figure out if we did end up
        ;; on a fork and if so, what the earliest still valid block we know about is likely to be.
        ;;
        ;; Once it has decided which blocks we need, it will send us an inv with up to 500 block messages.  We may
        ;; have some of them already if we already have a block chain and just need to catch up.  Once we request the
        ;; last block, if there are still more to come it sends us an "inv" containing only the hash of the head
        ;; block.
        ;;
        ;; That causes us to download the head block but then we find (in processBlock) that we can't connect
        ;; it to the chain yet because we don't have the intermediate blocks.  So we rerun this function building a
        ;; new block locator describing where we're up to.
        ;;
        ;; The getblocks with the new locator gets us another inv with another bunch of blocks.  We download them once
        ;; again.  This time when the peer sends us an inv with the head block, we already have it so we won't download
        ;; it again - but we recognize this case as special and call back into blockChainDownloadLocked to continue the
        ;; process.
        ;;
        ;; So this is a complicated process but it has the advantage that we can download a chain of enormous length
        ;; in a relatively stateless manner and with constant memory usage.
        ;;
        ;; All this is made more complicated by the desire to skip downloading the bodies of blocks that pre-date the
        ;; 'fast catchup time', which is usually set to the creation date of the earliest key in the wallet.  Because
        ;; we know there are no transactions using our keys before that date, we need only the headers.  To do that we
        ;; use the "getheaders" command.  Once we find we've gone past the target date, we throw away the downloaded
        ;; headers and then request the blocks from that point onwards.  "getheaders" does not send us an inv, it just
        ;; sends us the data we requested in a "headers" message.

        ;; TODO: Block locators should be abstracted out rather than special cased here.
        (§ var List<Sha256Hash> blockLocator = new ArrayList<>(§ pars 51))

        ;; For now, we don't do the exponential thinning as suggested here:
        ;;
        ;;   https://en.bitcoin.it/wiki/Protocol_specification#getblocks
        ;;
        ;; This is because it requires scanning all the block chain headers, which is very slow.  Instead we add the
        ;; top 100 block headers.  If there is a re-org deeper than that, we'll end up downloading the entire chain.
        ;; We must always put the genesis block as the first entry.

        (§ var BlockStore store = Preconditions.checkNotNull(§ pars blockChain).getBlockStore(§ pars ))
        (§ var StoredBlock chainHead = blockChain.getChainHead(§ pars ))
        (§ var Sha256Hash chainHeadHash = chainHead.getHeader(§ pars ).getHash(§ pars ))

        ;; Did we already make this request?  If so, don't do it again.
        (§ if (§ expr Objects.equal(§ pars lastGetBlocksBegin, chainHeadHash) && Objects.equal(§ pars lastGetBlocksEnd, toHash)))
        (§ block
            (§ call log.info(§ pars "blockChainDownloadLocked({}): ignoring duplicated request: {}", toHash, chainHeadHash))
            (§ for (§ var Sha256Hash hash) :for (§ expr pendingBlockDownloads))
            (§ block
                (§ call log.info(§ pars "Pending block download: {}", hash))
            )
            (§ call log.info(§ pars Throwables.getStackTraceAsString(§ pars (§ new Throwable(§ pars )))))
            (§ return )
        )

        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ ass log.debug(§ pars "{}: blockChainDownloadLocked({}) current head = {}", this, toHash, chainHead.getHeader(§ pars ).getHashAsString(§ pars )))
        )

        (§ var StoredBlock cursor = chainHead)
        (§ for (§ var int i = 100) :for (§ expr cursor != nil && 0 < i) :for (§ ass i = i - 1))
        (§ block
            (§ call blockLocator.add(§ pars cursor.getHeader(§ pars ).getHash(§ pars )))
            (§ try )
            (§ block
                (§ ass cursor = cursor.getPrev(§ pars store))
            )
            (§ catch (§ args BlockStoreException e))
            (§ block
                (§ call log.error(§ pars "Failed to walk the block chain whilst constructing a locator"))
                (§ throw (§ new RuntimeException(§ pars e)))
            )
        )

        ;; Only add the locator if we didn't already do so.  If the chain is < 50 blocks we already reached it.
        (§ if (§ expr cursor != nil))
        (§ block
            (§ call blockLocator.add(§ pars params.getGenesisBlock(§ pars ).getHash(§ pars )))
        )

        ;; Record that we requested this range of blocks so we can filter out duplicate requests in the event
        ;; of a block being solved during chain download.
        (§ ass lastGetBlocksBegin = chainHeadHash)
        (§ ass lastGetBlocksEnd = toHash)

        (§ if (§ expr downloadBlockBodies))
        (§ block
            (§ var GetBlocksMessage message = new GetBlocksMessage(§ pars params, blockLocator, toHash))
            (§ call sendMessage(§ pars message))
        )
        (§ else )
        (§ block
            ;; Downloading headers for a while instead of full blocks.
            (§ var GetHeadersMessage message = new GetHeadersMessage(§ pars params, blockLocator, toHash))
            (§ call sendMessage(§ pars message))
        )
    )

    ;;;
     ; Starts an asynchronous download of the block chain.  The chain download is deemed to be complete once we've
     ; downloaded the same number of blocks that the peer advertised having in its version handshake message.
     ;;
    #_public
    (§ method void startBlockChainDownload(§ args ))
    (§ block
        (§ call setDownloadData(§ pars true))
        ;; TODO: Peer might still have blocks that we don't have, and even have a heavier
        ;; chain even if the chain block count is lower.
        #_final
        (§ var int blocksLeft = getPeerBlockHeightDifference(§ pars ))
        (§ if (§ expr 0 <= blocksLeft))
        (§ block
            (§ for (§ var #_final ListenerRegistration<ChainDownloadStartedEventListener> registration) :for (§ expr chainDownloadStartedEventListeners))
            (§ block
                (§ call registration.executor.execute(§ pars (§ new Runnable(§ pars ))
                (§ anon
                    #_override
                    #_public
                    (§ method void run(§ args ))
                    (§ block
                        (§ call registration.listener.onChainDownloadStarted(§ pars Peer.this, blocksLeft))
                    )
                )))
            )
            ;; When we just want as many blocks as possible, we can set the target hash to zero.
            (§ call lock.lock(§ pars ))
            (§ try )
            (§ block
                (§ call blockChainDownloadLocked(§ pars Sha256Hash.ZERO_HASH))
            )
            (§ finally )
            (§ block
                (§ call lock.unlock(§ pars ))
            )
        )
    )

    #_private
    (§ class PendingPing
        ;; The future that will be invoked when the pong is heard back.
        #_public
        (§ field SettableFuture<Long> future)
        ;; The random nonce that lets us tell apart overlapping pings/pongs.
        #_public
        #_final
        (§ field long nonce)
        ;; Measurement of the time elapsed.
        #_public
        #_final
        (§ field long startTimeMsec)

        #_public
        (§ constructor PendingPing(§ args long nonce))
        (§ block
            (§ ass future = SettableFuture.create(§ pars ))
            (§ ass this.nonce = nonce)
            (§ ass startTimeMsec = Utils.currentTimeMillis(§ pars ))
        )

        #_public
        (§ method void complete(§ args ))
        (§ block
            (§ if (§ expr !future.isDone(§ pars )))
            (§ block
                (§ var Long elapsed = Utils.currentTimeMillis(§ pars ) - startTimeMsec)
                (§ call Peer.this.addPingTimeData(§ pars elapsed))
                (§ call log.debug(§ pars "{}: ping time is {} msec", Peer.this.toString(§ pars ), elapsed))
                (§ call future.set(§ pars elapsed))
            )
        )
    )

    ;;; Adds a ping time sample to the averaging window. ;;
    #_private
    (§ method void addPingTimeData(§ args long sample))
    (§ block
        (§ call lastPingTimesLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr lastPingTimes == nil))
            (§ block
                (§ ass lastPingTimes = new long[PING_MOVING_AVERAGE_WINDOW])
                ;; Initialize the averaging window to the first sample.
                (§ call Arrays.fill(§ pars lastPingTimes, sample))
            )
            (§ else )
            (§ block
                ;; Shift all elements backwards by one.
                (§ call System.arraycopy(§ pars lastPingTimes, 1, lastPingTimes, 0, lastPingTimes.length - 1))
                ;; And append the new sample to the end.
                (§ ass lastPingTimes[lastPingTimes.length - 1] = sample)
            )
        )
        (§ finally )
        (§ block
            (§ call lastPingTimesLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Sends the peer a ping message and returns a future that will be invoked when the pong is received back.
     ; The future provides a number which is the number of milliseconds elapsed between the ping and the pong.
     ; Once the pong is received the value returned by {@link org.bitcoinj.core.Peer#getLastPingTime()} is
     ; updated.
     ; @throws ProtocolException if the peer version is too low to support measurable pings.
     ;;
    #_public
    (§ method ListenableFuture<Long> ping(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ return ping(§ pars (§ cast long)(§ expr Math.random(§ pars ) * Long.MAX_VALUE)))
    )

    #_protected
    (§ method ListenableFuture<Long> ping(§ args long nonce))
        (§ throws ProtocolException)
    (§ block
        #_final
        (§ var VersionMessage ver = vPeerVersionMessage)
        (§ if (§ expr !ver.isPingPongSupported(§ pars )))
        (§ block
            (§ throw (§ new ProtocolException(§ pars "Peer version is too low for measurable pings: " + ver)))
        )

        (§ var PendingPing pendingPing = new PendingPing(§ pars nonce))
        (§ call pendingPings.add(§ pars pendingPing))
        (§ call sendMessage(§ pars (§ new Ping(§ pars pendingPing.nonce))))

        (§ return pendingPing.future)
    )

    ;;;
     ; Returns the elapsed time of the last ping/pong cycle.  If {@link org.bitcoinj.core.Peer#ping()} has
     ; never been called or we did not hear back the "pong" message yet, returns {@link Long#MAX_VALUE}.
     ;;
    #_public
    (§ method long getLastPingTime(§ args ))
    (§ block
        (§ call lastPingTimesLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr lastPingTimes != nil) ? lastPingTimes[lastPingTimes.length - 1] :else Long.MAX_VALUE)
        )
        (§ finally )
        (§ block
            (§ call lastPingTimesLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a moving average of the last N ping/pong cycles.  If {@link org.bitcoinj.core.Peer#ping()} has never
     ; been called or we did not hear back the "pong" message yet, returns {@link Long#MAX_VALUE}.  The moving average
     ; window is 5 buckets.
     ;;
    #_public
    (§ method long getPingTime(§ args ))
    (§ block
        (§ call lastPingTimesLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr lastPingTimes == nil))
            (§ block
                (§ return Long.MAX_VALUE)
            )
            (§ var long sum = 0)
            (§ for (§ var long i) :for (§ expr lastPingTimes))
            (§ block
                (§ ass sum = sum + i)
            )
            (§ return (§ cast long)(§ expr (§ cast double)sum / lastPingTimes.length))
        )
        (§ finally )
        (§ block
            (§ call lastPingTimesLock.unlock(§ pars ))
        )
    )

    #_private
    (§ method void processPing(§ args Ping m))
    (§ block
        (§ if (§ expr m.hasNonce(§ pars )))
        (§ block
            (§ call sendMessage(§ pars (§ new Pong(§ pars m.getNonce(§ pars )))))
        )
    )

    #_protected
    (§ method void processPong(§ args Pong m))
    (§ block
        ;; Iterates over a snapshot of the list, so we can run unlocked here.
        (§ for (§ var PendingPing ping) :for (§ expr pendingPings))
        (§ block
            (§ if (§ expr m.getNonce(§ pars ) == ping.nonce))
            (§ block
                (§ call pendingPings.remove(§ pars ping))
                ;; This line may trigger an event listener that re-runs ping().
                (§ call ping.complete(§ pars ))
                (§ return )
            )
        )
    )

    ;;;
     ; Returns the difference between our best chain height and the peers, which can either be positive if we are
     ; behind the peer, or negative if the peer is ahead of us.
     ;;
    #_public
    (§ method int getPeerBlockHeightDifference(§ args ))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars blockChain, "No block chain configured"))

        ;; Chain will overflow signed int blocks in ~41,000 years.
        (§ var int chainHeight = (§ cast int)getBestHeight(§ pars ))
        ;; chainHeight should not be zero/negative because we shouldn't have given the user a Peer that is to another
        ;; client-mode node, nor should it be unconnected.  If that happens it means the user overrode us somewhere or
        ;; there is a bug in the peer management code.
        (§ call Preconditions.checkState(§ pars params.allowEmptyPeerChain(§ pars ) || 0 < chainHeight, "Connected to peer with zero/negative chain height", chainHeight))
        (§ return chainHeight - blockChain.getBestChainHeight(§ pars ))
    )

    #_private
    (§ method boolean isNotFoundMessageSupported(§ args ))
    (§ block
        (§ return (§ expr NotFoundMessage.MIN_PROTOCOL_VERSION <= vPeerVersionMessage.clientVersion))
    )

    ;;;
     ; Returns true if this peer will try and download things it is sent in "inv" messages.
     ; Normally you only need one peer to be downloading data.  Defaults to true.
     ;;
    #_public
    (§ method boolean isDownloadData(§ args ))
    (§ block
        (§ return vDownloadData)
    )

    ;;;
     ; If set to false, the peer won't try and fetch blocks and transactions it hears about.  Normally, only one
     ; peer should download missing blocks.  Defaults to true.  Changing this value from false to true may trigger
     ; a request to the remote peer for the contents of its memory pool, if Bloom filtering is active.
     ;;
    #_public
    (§ method void setDownloadData(§ args boolean downloadData))
    (§ block
        (§ ass this.vDownloadData = downloadData)
    )

    ;;; Returns version data announced by the remote peer. ;;
    #_public
    (§ method VersionMessage getPeerVersionMessage(§ args ))
    (§ block
        (§ return vPeerVersionMessage)
    )

    ;;; Returns version data we announce to our remote peers. ;;
    #_public
    (§ method VersionMessage getVersionMessage(§ args ))
    (§ block
        (§ return versionMessage)
    )

    ;;;
     ; @return the height of the best chain as claimed by peer: sum of its ver announcement and blocks announced since.
     ;;
    #_public
    (§ method long getBestHeight(§ args ))
    (§ block
        (§ return vPeerVersionMessage.bestHeight + blocksAnnounced.get(§ pars ))
    )

    ;;;
     ; The minimum P2P protocol version that is accepted.  If the peer speaks a protocol version lower than this, it
     ; will be disconnected.
     ; @return true if the peer was disconnected as a result.
     ;;
    #_public
    (§ method boolean setMinProtocolVersion(§ args int minProtocolVersion))
    (§ block
        (§ ass this.vMinProtocolVersion = minProtocolVersion)

        (§ var VersionMessage ver = getPeerVersionMessage(§ pars ))
        (§ if (§ expr ver != nil && ver.clientVersion < minProtocolVersion))
        (§ block
            (§ call log.warn(§ pars "{}: Disconnecting due to new min protocol version {}, got: {}", this, minProtocolVersion, ver.clientVersion))
            (§ call close(§ pars ))
            (§ return true)
        )

        (§ return false)
    )

    ;;;
     ; <p>Sets a Bloom filter on this connection.  This will cause the given {@link BloomFilter} object to be sent
     ; to the remote peer and if either a memory pool has been set using the constructor or the
     ; vDownloadData property is true, a {@link MemoryPoolMessage} is sent as well to trigger downloading of any
     ; pending transactions that may be relevant.</p>
     ;
     ; <p>The Peer does not automatically request filters from any wallets added using {@link Peer#addWallet(Wallet)}.
     ; This is to allow callers to avoid redundantly recalculating the same filter repeatedly when using multiple peers
     ; and multiple wallets together.</p>
     ;
     ; <p>Therefore, you should not use this method if your app uses a {@link PeerGroup}.  It is called for you.</p>
     ;
     ; <p>If the remote peer doesn't support Bloom filtering, then this call is ignored.  Once set you presently cannot
     ; unset a filter, though the underlying p2p protocol does support it.</p>
     ;;
    #_public
    (§ method void setBloomFilter(§ args BloomFilter filter))
    (§ block
        (§ call setBloomFilter(§ pars filter, true))
    )

    ;;;
     ; <p>Sets a Bloom filter on this connection.  This will cause the given {@link BloomFilter} object to be sent
     ; to the remote peer and if requested, a {@link MemoryPoolMessage} is sent as well to trigger downloading of any
     ; pending transactions that may be relevant.</p>
     ;
     ; <p>The Peer does not automatically request filters from any wallets added using {@link Peer#addWallet(Wallet)}.
     ; This is to allow callers to avoid redundantly recalculating the same filter repeatedly when using multiple peers
     ; and multiple wallets together.</p>
     ;
     ; <p>Therefore, you should not use this method if your app uses a {@link PeerGroup}.  It is called for you.</p>
     ;
     ; <p>If the remote peer doesn't support Bloom filtering, then this call is ignored.  Once set you presently cannot
     ; unset a filter, though the underlying p2p protocol does support it.</p>
     ;;
    #_public
    (§ method void setBloomFilter(§ args BloomFilter filter, boolean andQueryMemPool))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars filter, "Clearing filters is not currently supported"))

        #_final
        (§ var VersionMessage ver = vPeerVersionMessage)
        (§ if (§ expr ver != nil && ver.isBloomFilteringSupported(§ pars )))
        (§ block
            (§ ass vBloomFilter = filter)
            (§ call log.debug(§ pars "{}: Sending Bloom filter{}", this, andQueryMemPool ? " and querying mempool" :else ""))
            (§ call sendMessage(§ pars filter))
            (§ if (§ expr andQueryMemPool))
            (§ block
                (§ call sendMessage(§ pars (§ new MemoryPoolMessage(§ pars ))))
            )
            (§ call maybeRestartChainDownload(§ pars ))
        )
    )

    #_private
    (§ method void maybeRestartChainDownload(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr awaitingFreshFilter == nil))
            (§ block
                (§ return )
            )

            (§ if (§ expr !vDownloadData))
            (§ block
                ;; This branch should be harmless but I want to know how often it happens in reality.
                (§ call log.warn(§ pars "Lost download peer status whilst awaiting fresh filter."))
                (§ return )
            )

            ;; Ping/pong to wait for blocks that are still being streamed to us to finish being downloaded and discarded.
            (§ call ping(§ pars ).addListener(§ pars (§ new Runnable(§ pars ))
            (§ anon
                #_override
                #_public
                (§ method void run(§ args ))
                (§ block
                    (§ call lock.lock(§ pars ))
                    (§ call Preconditions.checkNotNull(§ pars awaitingFreshFilter))
                    (§ var GetDataMessage getdata = new GetDataMessage(§ pars params))
                    (§ for (§ var Sha256Hash hash) :for (§ expr awaitingFreshFilter))
                    (§ block
                        (§ call getdata.addFilteredBlock(§ pars hash))
                    )
                    (§ ass awaitingFreshFilter = nil)
                    (§ call lock.unlock(§ pars ))

                    (§ call log.info(§ pars "Restarting chain download"))
                    (§ call sendMessage(§ pars getdata))
                    ;; TODO: This bizarre ping-after-getdata hack probably isn't necessary.
                    ;; It's to ensure we know when the end of a filtered block stream of txns is, but we should just be
                    ;; able to match txns with the merkleblock.  Ask Matt why it's written this way.
                    (§ call sendMessage(§ pars (§ new Ping(§ pars (§ cast long)(§ expr Math.random(§ pars ) * Long.MAX_VALUE)))))
                )
            ), Threading.SAME_THREAD))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the last {@link BloomFilter} set by {@link Peer#setBloomFilter(BloomFilter)}.  Bloom filters tell
     ; the remote node what transactions to send us, in a compact manner.
     ;;
    #_public
    (§ method BloomFilter getBloomFilter(§ args ))
    (§ block
        (§ return vBloomFilter)
    )

    ;;;
     ; Returns true if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     ; before handing the transaction off to the wallet.  The wallet can do risk analysis on pending/recent transactions
     ; to try and discover if a pending tx might be at risk of double spending.
     ;;
    #_public
    (§ method boolean isDownloadTxDependencies(§ args ))
    (§ block
        (§ return (§ expr 0 < vDownloadTxDependencyDepth))
    )

    ;;;
     ; Sets if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     ; before handing the transaction off to the wallet.  The wallet can do risk analysis on pending/recent transactions
     ; to try and discover if a pending tx might be at risk of double spending.
     ;;
    #_public
    (§ method void setDownloadTxDependencies(§ args boolean enable))
    (§ block
        (§ ass vDownloadTxDependencyDepth = enable ? Integer.MAX_VALUE :else 0)
    )

    ;;;
     ; Sets if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     ; before handing the transaction off to the wallet.  The wallet can do risk analysis on pending/recent transactions
     ; to try and discover if a pending tx might be at risk of double spending.
     ;;
    #_public
    (§ method void setDownloadTxDependencies(§ args int depth))
    (§ block
        (§ ass vDownloadTxDependencyDepth = depth)
    )
)

#_(ns org.bitcoinj.core #_"PeerAddress"
    (:import [java.io IOException OutputStream]
             [java.math BigInteger]
             [java.net InetAddress InetSocketAddress UnknownHostException])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.net InetAddresses])
    (:import #_static [org.bitcoinj.core.Utils uint32ToByteStreamLE]
             #_static [org.bitcoinj.core.Utils uint64ToByteStreamLE]
             [org.bitcoinj.params MainNetParams]))

;;;
 ; <p>A PeerAddress holds an IP address and port number representing the network location of
 ; a peer in the Bitcoin P2P network.  It exists primarily for serialization purposes.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class PeerAddress extends ChildMessage
    #_static
    #_final
    (§ field int MESSAGE_SIZE = 30)

    #_private
    (§ field InetAddress addr)
    #_private
    (§ field String hostname) ;; Used for .onion addresses.
    #_private
    (§ field int port)
    #_private
    (§ field BigInteger services)
    #_private
    (§ field long time)

    ;;;
     ; Construct a peer address from a serialized payload.
     ;;
    #_public
    (§ constructor PeerAddress(§ args NetworkParameters params, byte[] payload, int offset, int protocolVersion))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, offset, protocolVersion))
    )

    ;;;
     ; Construct a peer address from a serialized payload.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param protocolVersion Bitcoin protocol version.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor PeerAddress(§ args NetworkParameters params, byte[] payload, int offset, int protocolVersion, Message parent, MessageSerializer serializer))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, offset, protocolVersion, parent, serializer, UNKNOWN_LENGTH))
    )

    ;;;
     ; Construct a peer address from a memorized or hardcoded address.
     ;;
    #_public
    (§ constructor PeerAddress(§ args NetworkParameters params, InetAddress addr, int port, int protocolVersion, BigInteger services))
    (§ block
        (§ super (§ pars params))

        (§ ass this.addr = Preconditions.checkNotNull(§ pars addr))
        (§ ass this.port = port)
        (§ ass this.protocolVersion = protocolVersion)
        (§ ass this.services = services)

        (§ ass length = (§ expr 31402 < protocolVersion) ? MESSAGE_SIZE :else MESSAGE_SIZE - 4)
    )

    ;;;
     ; Constructs a peer address from the given IP address and port.  Version number is default for the given parameters.
     ;;
    #_public
    (§ constructor PeerAddress(§ args NetworkParameters params, InetAddress addr, int port))
    (§ block
        (§ this (§ pars params, addr, port, params.getProtocolVersionNum(§ pars NetworkParameters.ProtocolVersion.CURRENT), BigInteger.ZERO))
    )

    ;;;
     ; Constructs a peer address from the given IP address.  Port and version number are default for the given parameters.
     ;;
    #_public
    (§ constructor PeerAddress(§ args NetworkParameters params, InetAddress addr))
    (§ block
        (§ this (§ pars params, addr, params.getPort(§ pars )))
    )

    ;;;
     ; Constructs a peer address from an {@link InetSocketAddress}.  An InetSocketAddress can take in as parameters an
     ; InetAddress or a String hostname.  If you want to connect to a .onion, set the hostname to the .onion address.
     ;;
    #_public
    (§ constructor PeerAddress(§ args NetworkParameters params, InetSocketAddress addr))
    (§ block
        (§ this (§ pars params, addr.getAddress(§ pars ), addr.getPort(§ pars )))
    )

    ;;;
     ; Constructs a peer address from a stringified hostname+port.  Use this if you want to connect to a Tor .onion address.
     ;;
    #_public
    (§ constructor PeerAddress(§ args NetworkParameters params, String hostname, int port))
    (§ block
        (§ super (§ pars params))

        (§ ass this.hostname = hostname)
        (§ ass this.port = port)
        (§ ass this.protocolVersion = params.getProtocolVersionNum(§ pars NetworkParameters.ProtocolVersion.CURRENT))
        (§ ass this.services = BigInteger.ZERO)
    )

    #_public
    #_static
    (§ method PeerAddress localhost(§ args NetworkParameters params))
    (§ block
        (§ return (§ new PeerAddress(§ pars params, InetAddresses.forString(§ pars "127.0.0.1"), params.getPort(§ pars ))))
    )

    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ if (§ expr 31402 <= protocolVersion))
        (§ block
            ;; TODO: This appears to be dynamic because the client only ever sends out it's own address
            ;; so assumes itself to be up.  For a fuller implementation this needs to be dynamic only if
            ;; the address refers to this client.
            (§ var int secs = (§ cast int)Utils.currentTimeSeconds(§ pars ))
            (§ call uint32ToByteStreamLE(§ pars secs, stream))
        )
        (§ call uint64ToByteStreamLE(§ pars services, stream)) ;; nServices.
        ;; Java does not provide any utility to map an IPv4 address into IPv6 space, so we have to do it by hand.
        (§ var byte[] ipBytes = addr.getAddress(§ pars ))
        (§ if (§ expr ipBytes.length == 4))
        (§ block
            (§ var byte[] v6addr = new byte[16])
            (§ call System.arraycopy(§ pars ipBytes, 0, v6addr, 12, 4))
            (§ ass v6addr[10] = (§ cast byte)0xff)
            (§ ass v6addr[11] = (§ cast byte)0xff)
            (§ ass ipBytes = v6addr)
        )
        (§ call stream.write(§ pars ipBytes))
        ;; And write out the port.  Unlike the rest of the protocol, address and port is in big endian byte order.
        (§ call stream.write(§ pars (§ cast byte)(§ expr 0xff & port >> 8)))
        (§ call stream.write(§ pars (§ cast byte)(§ expr 0xff & port)))
    )

    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
        ;; Format of a serialized address:
        ;;   uint32 timestamp
        ;;   uint64 services (flags determining what the node can do)
        ;;   16 bytes ip address
        ;;   2 bytes port num
        (§ ass time = (§ expr 31402 < protocolVersion) ? readUint32(§ pars ) :else -1)
        (§ ass services = readUint64(§ pars ))
        (§ var byte[] addrBytes = readBytes(§ pars 16))
        (§ try )
        (§ block
            (§ ass addr = InetAddress.getByAddress(§ pars addrBytes))
        )
        (§ catch (§ args UnknownHostException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
        (§ ass port = (§ expr (§ expr (§ expr payload[cursor] & 0xff) << 8) | (§ expr payload[cursor + 1] & 0xff)))
        (§ ass cursor = cursor + 2)
        ;; The 4 byte difference is the uint32 timestamp that was introduced in version 31402.
        (§ ass length = (§ expr 31402 < protocolVersion) ? MESSAGE_SIZE :else MESSAGE_SIZE - 4)
    )

    #_public
    (§ method String getHostname(§ args ))
    (§ block
        (§ return hostname)
    )

    #_public
    (§ method InetAddress getAddr(§ args ))
    (§ block
        (§ return addr)
    )

    #_public
    (§ method InetSocketAddress getSocketAddress(§ args ))
    (§ block
        (§ return (§ new InetSocketAddress(§ pars getAddr(§ pars ), getPort(§ pars ))))
    )

    #_public
    (§ method int getPort(§ args ))
    (§ block
        (§ return port)
    )

    #_public
    (§ method BigInteger getServices(§ args ))
    (§ block
        (§ return services)
    )

    #_public
    (§ method long getTime(§ args ))
    (§ block
        (§ return time)
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return (§ expr hostname != nil) ? "[" + hostname + "]:" + port :else "[" + addr.getHostAddress(§ pars ) + "]:" + port)
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var PeerAddress other = (§ cast PeerAddress)o)
        (§ return (§ expr other.addr.equals(§ pars addr) && other.port == port && other.time == time && other.services.equals(§ pars services)))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars addr, port, time, services))
    )

    #_public
    (§ method InetSocketAddress toSocketAddress(§ args ))
    (§ block
        ;; Reconstruct the InetSocketAddress properly.
        (§ return (§ quest (§ expr hostname != nil) ? InetSocketAddress.createUnresolved(§ pars hostname, port) :else new InetSocketAddress(§ pars addr, port)))
    )
)

#_(ns org.bitcoinj.core #_"PeerException")

;;;
 ; Thrown when a problem occurs in communicating with a peer, and we should retry.
 ;;
#_public
(§ class PeerException extends Exception
    #_public
    (§ constructor PeerException(§ args String msg))
    (§ block
        (§ super (§ pars msg))
    )

    #_public
    (§ constructor PeerException(§ args Exception e))
    (§ block
        (§ super (§ pars e))
    )

    #_public
    (§ constructor PeerException(§ args String msg, Exception e))
    (§ block
        (§ super (§ pars msg, e))
    )
)

#_(ns org.bitcoinj.core #_"PeerFilterProvider")

;;;
 ; An interface which provides the information required to properly filter data downloaded from Peers.
 ; Note that an implementer is responsible for calling {@link PeerGroup#recalculateFastCatchupAndFilter(org.bitcoinj.core.PeerGroup.FilterRecalculateMode)}
 ; whenever a change occurs which effects the data provided via this interface.
 ;;
#_public
(§ interface PeerFilterProvider
    ;;;
     ; Returns the earliest timestamp (seconds since epoch) for which full/bloom-filtered blocks must be downloaded.
     ; Blocks with timestamps before this time will only have headers downloaded.  0 requires that all blocks be
     ; downloaded, and thus this should default to {@link System#currentTimeMillis()}/1000.
     ;;
    (§ method long getEarliestKeyCreationTime(§ args ))

    ;;;
     ; Called on all registered filter providers before getBloomFilterElementCount and getBloomFilter are called.
     ; Once called, the provider should ensure that the items it will want to insert into the filter don't change.
     ; The reason is that all providers will have their element counts queried, and then a filter big enough for
     ; all of them will be specified.  So the provider must use consistent state.  There is guaranteed to be
     ; a matching call to endBloomFilterCalculation that can be used to e.g. unlock a lock.
     ;;
    (§ method void beginBloomFilterCalculation(§ args ))

    ;;;
     ; Gets the number of elements that will be added to a bloom filter returned by
     ; {@link PeerFilterProvider#getBloomFilter(int, double, long)}.
     ;;
    (§ method int getBloomFilterElementCount(§ args ))

    ;;;
     ; Gets a bloom filter that contains all the necessary elements for the listener to receive relevant transactions.
     ; Default value should be an empty bloom filter with the given size, falsePositiveRate, and nTweak.
     ;;
    (§ method BloomFilter getBloomFilter(§ args int size, double falsePositiveRate, long nTweak))

    (§ method void endBloomFilterCalculation(§ args ))
)

#_(ns org.bitcoinj.core #_"PeerGroup"
    (:import [java.io *]
             [java.net *]
             [java.util *]
             [java.util.concurrent *]
             [java.util.concurrent.locks *])
    (:import [com.google.common.annotations *]
             [com.google.common.base *]
             [com.google.common.collect *]
             [com.google.common.net *]
             [com.google.common.primitives *]
             [com.google.common.util.concurrent *]
             [net.jcip.annotations *]
             [org.slf4j *])
   (:require [org.bitcoinj.core.listeners *]
             [org.bitcoinj.net *]
             [org.bitcoinj.net.discovery *]
             [org.bitcoinj.script *]
             [org.bitcoinj.utils * Threading]
             [org.bitcoinj.wallet Wallet]
             [org.bitcoinj.wallet.listeners KeyChainEventListener WalletCoinsReceivedEventListener]))

;;;
 ; <p>Runs a set of connections to the P2P network, brings up connections to replace disconnected nodes and manages
 ; the interaction between them all.  Most applications will want to use one of these.</p>
 ;
 ; <p>PeerGroup tries to maintain a constant number of connections to a set of distinct peers.
 ; Each peer runs a network listener in its own thread.  When a connection is lost, a new peer
 ; will be tried after a delay as long as the number of connections less than the maximum.</p>
 ;
 ; <p>Connections are made to addresses from a provided list.  When that list is exhausted,
 ; we start again from the head of the list.</p>
 ;
 ; <p>The PeerGroup can broadcast a transaction to the currently connected set of peers.  It can
 ; also handle download of the blockchain from peers, restarting the process when peers die.</p>
 ;
 ; <p>A PeerGroup won't do anything until you call the {@link PeerGroup#start()} method
 ; which will block until peer discovery is completed and some outbound connections
 ; have been initiated (it will return before handshaking is done, however).
 ; You should call {@link PeerGroup#stop()} when finished.  Note that not all methods
 ; of PeerGroup are safe to call from a UI thread as some may do network IO,
 ; but starting and stopping the service should be fine.</p>
 ;;
#_public
(§ class PeerGroup implements TransactionBroadcaster
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars PeerGroup.class))

    ;; All members in this class should be marked with final, volatile, @GuardedBy or a mix as appropriate to define
    ;; their thread safety semantics.  Volatile requires a Hungarian-style v prefix.

    ;; By default we don't require any services because any peer will do.
    #_private
    (§ field long requiredServices = 0)

    ;;;
     ; The default number of connections to the p2p network the library will try to build.  This is set to 12 empirically.
     ; It used to be 4, but because we divide the connection pool in two for broadcasting transactions, that meant we
     ; were only sending transactions to two peers and sometimes this wasn't reliable enough: transactions wouldn't
     ; get through.
     ;;
    #_public
    #_static
    #_final
    (§ field int DEFAULT_CONNECTIONS = 12)
    #_private
    #_volatile
    (§ field int vMaxPeersToDiscoverCount = 100)
    #_private
    #_static
    #_final
    (§ field long DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS = 5000)
    #_private
    #_volatile
    (§ field long vPeerDiscoveryTimeoutMillis = DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS)

    #_protected
    #_final
    (§ field ReentrantLock lock = Threading.lock(§ pars "peergroup"))

    #_protected
    #_final
    (§ field NetworkParameters params)
    #_nilable
    #_protected
    #_final
    (§ field AbstractBlockChain chain)

    ;; This executor is used to queue up jobs: it's used when we don't want to use locks for mutual exclusion,
    ;; typically because the job might call in to user provided code that needs/wants the freedom to use the API
    ;; however it wants, or because a job needs to be ordered relative to other jobs like that.
    #_protected
    #_final
    (§ field ListeningScheduledExecutorService executor)

    ;; Whether the peer group is currently running.  Once shut down it cannot be restarted.
    #_private
    #_volatile
    (§ field boolean vRunning)
    ;; Whether the peer group has been started or not.  An unstarted PG does not try to access the network.
    #_private
    #_volatile
    (§ field boolean vUsedUp)

    ;; Addresses to try to connect to, excluding active peers.
    #_guarded-by(§ opt "lock")
    #_private
    #_final
    (§ field PriorityQueue<PeerAddress> inactives)
    #_guarded-by(§ opt "lock")
    #_private
    #_final
    (§ field Map<PeerAddress, ExponentialBackoff> backoffMap)

    ;; Currently active peers.  This is an ordered list rather than a set to make unit tests predictable.
    #_private
    #_final
    (§ field CopyOnWriteArrayList<Peer> peers)
    ;; Currently connecting peers.
    #_private
    #_final
    (§ field CopyOnWriteArrayList<Peer> pendingPeers)
    #_private
    #_final
    (§ field ClientConnectionManager channels)

    ;; The peer that has been selected for the purposes of downloading announced data.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field Peer downloadPeer)
    ;; Callback for events related to chain download.
    #_nilable
    #_guarded-by(§ opt "lock")
    #_private
    (§ field PeerDataEventListener downloadListener)

    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<BlocksDownloadedEventListener>> peersBlocksDownloadedEventListeners = new CopyOnWriteArrayList<>(§ pars ))
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<ChainDownloadStartedEventListener>> peersChainDownloadStartedEventListeners = new CopyOnWriteArrayList<>(§ pars ))
    ;;; Callbacks for events related to peers connecting. ;;
    #_protected
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<PeerConnectedEventListener>> peerConnectedEventListeners = new CopyOnWriteArrayList<>(§ pars ))
    ;;; Callbacks for events related to peer connection/disconnection. ;;
    #_protected
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<PeerDiscoveredEventListener>> peerDiscoveredEventListeners = new CopyOnWriteArrayList<>(§ pars ))
    ;;; Callbacks for events related to peers disconnecting. ;;
    #_protected
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<PeerDisconnectedEventListener>> peerDisconnectedEventListeners = new CopyOnWriteArrayList<>(§ pars ))
    ;;; Callbacks for events related to peer data being received. ;;
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<GetDataEventListener>> peerGetDataEventListeners = new CopyOnWriteArrayList<>(§ pars ))
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<PreMessageReceivedEventListener>> peersPreMessageReceivedEventListeners = new CopyOnWriteArrayList<>(§ pars ))
    #_protected
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<OnTransactionBroadcastListener>> peersTransactionBroadastEventListeners = new CopyOnWriteArrayList<>(§ pars ))

    ;; Peer discovery sources, will be polled occasionally if there aren't enough inactives.
    #_private
    #_final
    (§ field CopyOnWriteArraySet<PeerDiscovery> peerDiscoverers)
    ;; The version message to use for new connections.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field VersionMessage versionMessage)
    ;; Maximum depth up to which pending transaction dependencies are downloaded, or 0 for disabled.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field int downloadTxDependencyDepth)
    ;; How many connections we want to have open at the current time.  If we lose connections, we'll try opening more
    ;; until we reach this count.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field int maxConnections)
    ;; Minimum protocol version we will allow ourselves to connect to: require Bloom filtering.
    #_private
    #_volatile
    (§ field int vMinRequiredProtocolVersion)

    ;;; How many milliseconds to wait after receiving a pong before sending another ping. ;;
    #_public
    #_static
    #_final
    (§ field long DEFAULT_PING_INTERVAL_MSEC = 2000)
    #_guarded-by(§ opt "lock")
    #_private
    (§ field long pingIntervalMsec = DEFAULT_PING_INTERVAL_MSEC)

    #_guarded-by(§ opt "lock")
    #_private
    (§ field boolean useLocalhostPeerWhenPossible = true)
    #_guarded-by(§ opt "lock")
    #_private
    (§ field boolean ipv6Unreachable = false)

    #_guarded-by(§ opt "lock")
    #_private
    (§ field long fastCatchupTimeSecs)
    #_private
    #_final
    (§ field CopyOnWriteArrayList<Wallet> wallets)
    #_private
    #_final
    (§ field CopyOnWriteArrayList<PeerFilterProvider> peerFilterProviders)

    ;; This event listener is added to every peer.  It's here so when we announce transactions via an "inv",
    ;; every peer can fetch them.
    #_private
    #_final
    (§ field PeerListener peerListener = new PeerListener(§ pars ))

    #_private
    (§ field int minBroadcastConnections = 0)

    #_private
    #_final
    (§ field KeyChainEventListener walletKeyEventListener = new KeyChainEventListener(§ pars )
        (§ anon
            #_override
            #_public
            (§ method void onKeysAdded(§ args List<ECKey> keys))
            (§ block
                (§ call recalculateFastCatchupAndFilter(§ pars FilterRecalculateMode.SEND_IF_CHANGED))
            )
        ))

    #_private
    #_final
    (§ field WalletCoinsReceivedEventListener walletCoinsReceivedEventListener = new WalletCoinsReceivedEventListener(§ pars )
        (§ anon
            #_override
            #_public
            (§ method void onCoinsReceived(§ args Wallet wallet, Transaction tx, Coin prevBalance, Coin newBalance))
            (§ block
                ;; We received a relevant transaction.  We MAY need to recalculate and resend the Bloom filter, but only
                ;; if we have received a transaction that includes a relevant pay-to-pubkey output.
                ;;
                ;; The reason is that pay-to-pubkey outputs, when spent, will not repeat any data we can predict in their
                ;; inputs.  So a remote peer will update the Bloom filter for us when such an output is seen matching the
                ;; existing filter, so that it includes the tx hash in which the pay-to-pubkey output was observed.  Thus
                ;; the spending transaction will always match (due to the outpoint structure).
                ;;
                ;; Unfortunately, whilst this is required for correct sync of the chain in blocks, there are two edge cases.
                ;;
                ;; (1) If a wallet receives a relevant, confirmed p2pubkey output that was not broadcast across the network,
                ;; for example in a coinbase transaction, then the node that's serving us the chain will update its filter
                ;; but the rest will not.  If another transaction then spends it, the other nodes won't match/relay it.
                ;;
                ;; (2) If we receive a p2pubkey output broadcast across the network, all currently connected nodes will see
                ;; it and update their filter themselves, but any newly connected nodes will receive the last filter we
                ;; calculated, which would not include this transaction.
                ;;
                ;; For this reason we check if the transaction contained any relevant pay to pubkeys and force a recalc
                ;; and possibly retransmit if so.  The recalculation process will end up including the tx hash into the
                ;; filter.  In case (1), we need to retransmit the filter to the connected peers.  In case (2), we don't
                ;; and shouldn't, we should just recalculate and cache the new filter for next time.

                (§ for (§ var TransactionOutput output) :for (§ expr tx.getOutputs(§ pars )))
                (§ block
                    (§ if (§ expr output.getScriptPubKey(§ pars ).isSentToRawPubKey(§ pars ) && output.isMine(§ pars wallet)))
                    (§ block
                        (§ if (§ expr tx.getConfidence(§ pars ).getConfidenceType(§ pars ) == TransactionConfidence.ConfidenceType.BUILDING))
                        (§ block
                            (§ call recalculateFastCatchupAndFilter(§ pars FilterRecalculateMode.SEND_IF_CHANGED))
                        )
                        (§ else )
                        (§ block
                            (§ call recalculateFastCatchupAndFilter(§ pars FilterRecalculateMode.DONT_SEND))
                        )
                        (§ return )
                    )
                )
            )
        ))

    ;; Exponential backoff for peers starts at 1 second and maxes at 10 minutes.
    #_private
    #_final
    (§ field ExponentialBackoff.Params peerBackoffParams = new ExponentialBackoff.Params(§ pars 1000, 1.5, 10 * 60 * 1000))
    ;; Tracks failures globally in case of a network failure.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field ExponentialBackoff groupBackoff = new ExponentialBackoff(§ pars new ExponentialBackoff.Params(§ pars 1000, 1.5, 10 * 1000)))

    ;; This is a synchronized set, so it locks on itself.  We use it to prevent TransactionBroadcast objects from
    ;; being garbage collected if nothing in the apps code holds on to them transitively.  See the discussion
    ;; in broadcastTransaction.
    #_private
    #_final
    (§ field Set<TransactionBroadcast> runningBroadcasts)

    #_private
    (§ class PeerListener implements GetDataEventListener, BlocksDownloadedEventListener
        #_public
        (§ constructor PeerListener(§ args ))
        (§ block
        )

        #_override
        #_public
        (§ method List<Message> getData(§ args Peer peer, GetDataMessage m))
        (§ block
            (§ return handleGetData(§ pars m))
        )

        #_override
        #_public
        (§ method void onBlocksDownloaded(§ args Peer peer, Block block, #_nilable FilteredBlock filteredBlock, int blocksLeft))
        (§ block
            (§ if (§ expr chain != nil))
            (§ block
                #_final
                (§ var double rate = chain.getFalsePositiveRate(§ pars ))
                #_final
                (§ var double target = bloomFilterMerger.getBloomFilterFPRate(§ pars ) * MAX_FP_RATE_INCREASE)
                (§ if (§ expr target < rate))
                (§ block
                    ;; TODO: Avoid hitting this path if the remote peer didn't acknowledge applying a new filter yet.
                    (§ if (§ expr log.isDebugEnabled(§ pars )))
                    (§ block
                        (§ call log.debug(§ pars "Force update Bloom filter due to high false positive rate ({} vs {})", rate, target))
                    )

                    (§ call recalculateFastCatchupAndFilter(§ pars FilterRecalculateMode.FORCE_SEND_FOR_REFRESH))
                )
            )
        )
    )

    #_private
    (§ class PeerStartupListener implements PeerConnectedEventListener, PeerDisconnectedEventListener
        #_override
        #_public
        (§ method void onPeerConnected(§ args Peer peer, int peerCount))
        (§ block
            (§ call handleNewPeer(§ pars peer))
        )

        #_override
        #_public
        (§ method void onPeerDisconnected(§ args Peer peer, int peerCount))
        (§ block
            ;; The channel will be automatically removed from channels.
            (§ call handlePeerDeath(§ pars peer, nil))
        )
    )

    #_private
    #_final
    (§ field PeerStartupListener startupListener = new PeerStartupListener(§ pars ))

    ;;;
     ; The default Bloom filter false positive rate, which is selected to be extremely low such that you hardly ever
     ; download false positives.  This provides maximum performance.  Although this default can be overridden to push
     ; the FP rate higher, due to <a href="https://groups.google.com/forum/#!msg/bitcoinj/Ys13qkTwcNg/9qxnhwnkeoIJ">
     ; various complexities</a> there are still ways a remote peer can deanonymize the users wallet.  This is why the
     ; FP rate is chosen for performance rather than privacy.  If a future version of bitcoinj fixes the known
     ; de-anonymization attacks this FP rate may rise again (or more likely, become expressed as a bandwidth allowance).
     ;;
    #_public
    #_static
    #_final
    (§ field double DEFAULT_BLOOM_FILTER_FP_RATE = 0.00001)
    ;;; Maximum increase in FP rate before forced refresh of the bloom filter. ;;
    #_public
    #_static
    #_final
    (§ field double MAX_FP_RATE_INCREASE = 10.0)
    ;; An object that calculates bloom filters given a list of filter providers, whilst tracking some state useful
    ;; for privacy purposes.
    #_private
    #_final
    (§ field FilterMerger bloomFilterMerger)

    ;;; The default timeout between when a connection attempt begins and version message exchange completes. ;;
    #_public
    #_static
    #_final
    (§ field int DEFAULT_CONNECT_TIMEOUT_MILLIS = 5000)
    #_private
    #_volatile
    (§ field int vConnectTimeoutMillis = DEFAULT_CONNECT_TIMEOUT_MILLIS)

    ;;; Whether bloom filter support is enabled when using a non FullPrunedBlockchain. ;;
    #_private
    #_volatile
    (§ field boolean vBloomFilteringEnabled = true)

    ;;; See {@link #PeerGroup(Context)}. ;;
    #_public
    (§ constructor PeerGroup(§ args NetworkParameters params))
    (§ block
        (§ this (§ pars params, nil))
    )

    ;;;
     ; Creates a PeerGroup with the given context.  No chain is provided so this node will report its chain height
     ; as zero to other peers.  This constructor is useful if you just want to explore the network but aren't interested
     ; in downloading block data.
     ;;
    #_public
    (§ constructor PeerGroup(§ args Context context))
    (§ block
        (§ this (§ pars context, nil))
    )

    ;;; See {@link #PeerGroup(Context, AbstractBlockChain)}. ;;
    #_public
    (§ constructor PeerGroup(§ args NetworkParameters params, #_nilable AbstractBlockChain chain))
    (§ block
        (§ this (§ pars Context.getOrCreate(§ pars params), chain, new NioClientManager(§ pars )))
    )

    ;;;
     ; Creates a PeerGroup for the given context and chain.  Blocks will be passed to the chain as they are broadcast
     ; and downloaded.  This is probably the constructor you want to use.
     ;;
    #_public
    (§ constructor PeerGroup(§ args Context context, #_nilable AbstractBlockChain chain))
    (§ block
        (§ this (§ pars context, chain, new NioClientManager(§ pars )))
    )

    ;;; See {@link #PeerGroup(Context, AbstractBlockChain, ClientConnectionManager)}. ;;
    #_public
    (§ constructor PeerGroup(§ args NetworkParameters params, #_nilable AbstractBlockChain chain, ClientConnectionManager connectionManager))
    (§ block
        (§ this (§ pars Context.getOrCreate(§ pars params), chain, connectionManager))
    )

    ;;;
     ; Creates a new PeerGroup allowing you to specify the {@link ClientConnectionManager} which is used to create new
     ; connections and keep track of existing ones.
     ;;
    #_private
    (§ constructor PeerGroup(§ args Context context, #_nilable AbstractBlockChain chain, ClientConnectionManager connectionManager))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars context))

        (§ ass this.params = context.getParams(§ pars ))
        (§ ass this.chain = chain)
        (§ ass fastCatchupTimeSecs = params.getGenesisBlock(§ pars ).getTimeSeconds(§ pars ))
        (§ ass wallets = new CopyOnWriteArrayList<>(§ pars ))
        (§ ass peerFilterProviders = new CopyOnWriteArrayList<>(§ pars ))

        (§ ass executor = createPrivateExecutor(§ pars ))

        ;; This default sentinel value will be overridden by one of two actions:
        ;;   - adding a peer discovery source sets it to the default.
        ;;   - using connectTo() will increment it by one.
        (§ ass maxConnections = 0)

        (§ var int height = (§ expr chain != nil) ? chain.getBestChainHeight(§ pars ) :else 0)
        (§ ass versionMessage = new VersionMessage(§ pars params, height))
        ;; We never request that the remote node wait for a bloom filter yet, as we have no wallets.
        (§ ass versionMessage.relayTxesBeforeFilter = true)

        (§ ass downloadTxDependencyDepth = Integer.MAX_VALUE)

        (§ ass inactives = new PriorityQueue<>(§ pars 1, new Comparator<PeerAddress>(§ pars )
        (§ anon
            #_suppress(§ opt "FieldAccessNotGuarded") ;; Only called when inactives is accessed, and lock is held then.
            #_override
            #_public
            (§ method int compare(§ args PeerAddress a, PeerAddress b))
            (§ block
                (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

                (§ var int result = backoffMap.get(§ pars a).compareTo(§ pars backoffMap.get(§ pars b)))
                ;; Sort by port if otherwise equals - for testing.
                (§ if (§ expr result == 0))
                (§ block
                    (§ ass result = Ints.compare(§ pars a.getPort(§ pars ), b.getPort(§ pars )))
                )
                (§ return result)
            )
        )))
        (§ ass backoffMap = new HashMap<>(§ pars ))
        (§ ass peers = new CopyOnWriteArrayList<>(§ pars ))
        (§ ass pendingPeers = new CopyOnWriteArrayList<>(§ pars ))
        (§ ass channels = connectionManager)
        (§ ass peerDiscoverers = new CopyOnWriteArraySet<>(§ pars ))
        (§ ass runningBroadcasts = Collections.synchronizedSet(§ pars new HashSet<TransactionBroadcast>(§ pars )))
        (§ ass bloomFilterMerger = new FilterMerger(§ pars DEFAULT_BLOOM_FILTER_FP_RATE))
        (§ ass vMinRequiredProtocolVersion = params.getProtocolVersionNum(§ pars NetworkParameters.ProtocolVersion.BLOOM_FILTER))
    )

    #_private
    (§ field CountDownLatch executorStartupLatch = new CountDownLatch(§ pars 1))

    #_protected
    (§ method ListeningScheduledExecutorService createPrivateExecutor(§ args ))
    (§ block
        (§ var ListeningScheduledExecutorService result = MoreExecutors.listeningDecorator(§ pars (§ new ScheduledThreadPoolExecutor(§ pars 1, new ContextPropagatingThreadFactory(§ pars "PeerGroup Thread")))))
        ;; Hack: jam the executor so jobs just queue up until the user calls start() on us.  For example, adding a wallet
        ;; results in a bloom filter recalc being queued, but we don't want to do that until we're actually started.
        (§ call result.execute(§ pars (§ new Runnable(§ pars ))
        (§ anon
            #_override
            #_public
            (§ method void run(§ args ))
            (§ block
                (§ call Uninterruptibles.awaitUninterruptibly(§ pars executorStartupLatch))
            )
        )))
        (§ return result)
    )

    ;;;
     ; This is how many milliseconds we wait for peer discoveries to return their results.
     ;;
    #_public
    (§ method void setPeerDiscoveryTimeoutMillis(§ args long peerDiscoveryTimeoutMillis))
    (§ block
        (§ ass this.vPeerDiscoveryTimeoutMillis = peerDiscoveryTimeoutMillis)
    )

    ;;;
     ; Adjusts the desired number of connections that we will create to peers.  Note that if there are already peers
     ; open and the new value is lower than the current number of peers, those connections will be terminated.
     ; Likewise if there aren't enough current connections to meet the new requested max size, some will be added.
     ;;
    #_public
    (§ method void setMaxConnections(§ args int maxConnections))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass this.maxConnections = maxConnections)
            (§ if (§ expr !isRunning(§ pars )))
            (§ block
                (§ return )
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )

        ;; We may now have too many or too few open connections.  Add more or drop some to get to the right amount.
        (§ var int adjustment = maxConnections - channels.getConnectedClientCount(§ pars ))
        (§ if (§ expr 0 < adjustment))
        (§ block
            (§ call triggerConnections(§ pars ))
        )

        (§ if (§ expr adjustment < 0))
        (§ block
            (§ call channels.closeConnections(§ pars -adjustment))
        )
    )

    ;;;
     ; Configure download of pending transaction dependencies.  A change of values only takes effect for newly connected peers.
     ;;
    #_public
    (§ method void setDownloadTxDependencies(§ args int depth))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass this.downloadTxDependencyDepth = depth)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_private
    (§ field Runnable triggerConnectionsJob = new Runnable(§ pars )
        (§ anon
            #_private
            (§ field boolean firstRun = true)
            #_private
            #_final
            #_static
            (§ field long MIN_PEER_DISCOVERY_INTERVAL = 1000)

            #_override
            #_public
            (§ method void run(§ args ))
            (§ block
                (§ try )
                (§ block
                    (§ call go(§ pars ))
                )
                (§ catch (§ args Throwable e))
                (§ block
                    (§ call log.error(§ pars "Exception when trying to build connections", e)) ;; The executor swallows exceptions :( ;; )
                )
            )

            #_public
            (§ method void go(§ args ))
            (§ block
                (§ if (§ expr !vRunning))
                (§ block
                    (§ return )
                )

                (§ var boolean doDiscovery = false)
                (§ var long now = Utils.currentTimeMillis(§ pars ))
                (§ call lock.lock(§ pars ))
                (§ try )
                (§ block
                    ;; First run: try and use a local node if there is one, for the additional security it can provide.
                    ;; But, not on Android as there are none for this platform: it could only be a malicious app trying
                    ;; to hijack our traffic.
                    (§ if (§ expr !Utils.isAndroidRuntime(§ pars ) && useLocalhostPeerWhenPossible && maybeCheckForLocalhostPeer(§ pars ) && firstRun))
                    (§ block
                        (§ call log.info(§ pars "Localhost peer detected, trying to use it instead of P2P discovery"))
                        (§ ass maxConnections = 0)
                        (§ call connectToLocalHost(§ pars ))
                        (§ return )
                    )

                    (§ var boolean havePeerWeCanTry = (§ expr !inactives.isEmpty(§ pars ) && backoffMap.get(§ pars inactives.peek(§ pars )).getRetryTime(§ pars ) <= now))
                    (§ ass doDiscovery = !havePeerWeCanTry)
                )
                (§ finally )
                (§ block
                    (§ ass firstRun = false)
                    (§ call lock.unlock(§ pars ))
                )

                ;; Don't hold the lock across discovery as this process can be very slow.
                (§ var boolean discoverySuccess = false)
                (§ if (§ expr doDiscovery))
                (§ block
                    (§ try )
                    (§ block
                        (§ ass discoverySuccess = (§ expr 0 < discoverPeers(§ pars )))
                    )
                    (§ catch (§ args PeerDiscoveryException e))
                    (§ block
                        (§ call log.error(§ pars "Peer discovery failure", e))
                    )
                )

                (§ var long retryTime)
                (§ var PeerAddress addrToTry)
                (§ call lock.lock(§ pars ))
                (§ try )
                (§ block
                    (§ if (§ expr doDiscovery))
                    (§ block
                        ;; Require that we have enough connections, to consider this a success,
                        ;; or we just constantly test for new peers.
                        (§ if (§ expr discoverySuccess && getMaxConnections(§ pars ) <= countConnectedAndPendingPeers(§ pars )))
                        (§ block
                            (§ call groupBackoff.trackSuccess(§ pars ))
                        )
                        (§ else )
                        (§ block
                            (§ call groupBackoff.trackFailure(§ pars ))
                        )
                    )
                    ;; Inactives is sorted by backoffMap time.
                    (§ if (§ expr inactives.isEmpty(§ pars )))
                    (§ block
                        (§ if (§ expr countConnectedAndPendingPeers(§ pars ) < getMaxConnections(§ pars )))
                        (§ block
                            (§ var long interval = Math.max(§ pars groupBackoff.getRetryTime(§ pars ) - now, MIN_PEER_DISCOVERY_INTERVAL))
                            (§ call log.info(§ pars "Peer discovery didn't provide us any more peers, will try again in " + interval + "ms."))
                            (§ call executor.schedule(§ pars this, interval, TimeUnit.MILLISECONDS))
                        )
                        (§ else )
                        (§ block
                            ;; We have enough peers and discovery provided no more, so just settle down.
                            ;; Most likely we were given a fixed set of addresses in some test scenario.
                        )
                        (§ return )
                    )
                    (§ else )
                    (§ block
                        (§ do )
                        (§ block
                            (§ ass addrToTry = inactives.poll(§ pars ))
                        )
                        (§ again (§ expr ipv6Unreachable && addrToTry.getAddr(§ pars ) instanceof Inet6Address))
                        (§ ass retryTime = backoffMap.get(§ pars addrToTry).getRetryTime(§ pars ))
                    )
                    (§ ass retryTime = Math.max(§ pars retryTime, groupBackoff.getRetryTime(§ pars )))
                    (§ if (§ expr now < retryTime))
                    (§ block
                        (§ var long delay = retryTime - now)
                        (§ call log.info(§ pars "Waiting {} msec before next connect attempt {}", delay, (§ expr addrToTry == nil) ? "" :else "to " + addrToTry))
                        (§ call inactives.add(§ pars addrToTry))
                        (§ call executor.schedule(§ pars this, delay, TimeUnit.MILLISECONDS))
                        (§ return )
                    )
                    (§ call connectTo(§ pars addrToTry, false, vConnectTimeoutMillis))
                )
                (§ finally )
                (§ block
                    (§ call lock.unlock(§ pars ))
                )
                (§ if (§ expr countConnectedAndPendingPeers(§ pars ) < getMaxConnections(§ pars )))
                (§ block
                    (§ call executor.execute(§ pars this)) ;; Try next peer immediately.
                )
            )
        ))

    #_private
    (§ method void triggerConnections(§ args ))
    (§ block
        ;; Run on a background thread due to the need to potentially retry and back off in the background.
        (§ if (§ expr !executor.isShutdown(§ pars )))
        (§ block
            (§ call executor.execute(§ pars triggerConnectionsJob))
        )
    )

    ;;; The maximum number of connections that we will create to peers. ;;
    #_public
    (§ method int getMaxConnections(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return maxConnections)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_private
    (§ method List<Message> handleGetData(§ args GetDataMessage m))
    (§ block
        ;; Scans the wallets and memory pool for transactions in the getdata message and returns them.
        ;; Runs on peer threads.
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var LinkedList<Message> transactions = new LinkedList<>(§ pars ))
            (§ var LinkedList<InventoryItem> items = new LinkedList<>(§ pars m.getItems(§ pars )))
            (§ var Iterator<InventoryItem> it = items.iterator(§ pars ))
            (§ while (§ expr it.hasNext(§ pars )))
            (§ block
                (§ var InventoryItem item = it.next(§ pars ))
                ;; Check the wallets.
                (§ for (§ var Wallet w) :for (§ expr wallets))
                (§ block
                    (§ var Transaction tx = w.getTransaction(§ pars item.hash))
                    (§ if (§ expr tx != nil))
                    (§ block
                        (§ call transactions.add(§ pars tx))
                        (§ call it.remove(§ pars ))
                        (§ break )
                    )
                )
            )
            (§ return transactions)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Sets the {@link VersionMessage} that will be announced on newly created connections.  A version message is
     ; primarily interesting because it lets you customize the "subVer" field which is used a bit like the User-Agent
     ; field from HTTP.  It means your client tells the other side what it is, see
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki">BIP 14</a>.
     ;
     ; The VersionMessage you provide is copied and the best chain height/time filled in for each new connection,
     ; therefore you don't have to worry about setting that.  The provided object is really more of a template.
     ;;
    #_public
    (§ method void setVersionMessage(§ args VersionMessage ver))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass versionMessage = ver)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the version message provided by setVersionMessage or a default if none was given.
     ;;
    #_public
    (§ method VersionMessage getVersionMessage(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return versionMessage)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Sets information that identifies this software to remote nodes.  This is a convenience wrapper for creating
     ; a new {@link VersionMessage}, calling {@link VersionMessage#appendToSubVer(String, String, String)} on it,
     ; and then calling {@link PeerGroup#setVersionMessage(VersionMessage)} on the result of that.  See the docs for
     ; {@link VersionMessage#appendToSubVer(String, String, String)} for information on what the fields should contain.
     ;;
    #_public
    (§ method void setUserAgent(§ args String name, String version, #_nilable String comments))
    (§ block
        ;; TODO: Check that height is needed here (it wasnt, but it should be, no?)
        (§ var int height = (§ expr chain != nil) ? chain.getBestChainHeight(§ pars ) :else 0)
        (§ var VersionMessage ver = new VersionMessage(§ pars params, height))
        (§ ass ver.relayTxesBeforeFilter = false)
        (§ call updateVersionMessageRelayTxesBeforeFilter(§ pars ver))
        (§ call ver.appendToSubVer(§ pars name, version, comments))
        (§ call setVersionMessage(§ pars ver))
    )

    ;; Updates the relayTxesBeforeFilter flag of ver.
    #_private
    (§ method void updateVersionMessageRelayTxesBeforeFilter(§ args VersionMessage ver))
    (§ block
        ;; We will provide the remote node with a bloom filter (i.e. they shouldn't relay yet)
        ;; if chain == null || !chain.shouldVerifyTransactions() and a wallet is added and bloom filters are enabled.
        ;; Note that the default here means that no tx invs will be received if no wallet is ever added.
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var boolean spvMode = (§ expr chain != nil && !chain.shouldVerifyTransactions(§ pars )))
            (§ var boolean willSendFilter = (§ expr spvMode && 0 < peerFilterProviders.size(§ pars ) && vBloomFilteringEnabled))
            (§ ass ver.relayTxesBeforeFilter = !willSendFilter)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Sets information that identifies this software to remote nodes.  This is a convenience wrapper for creating
     ; a new {@link VersionMessage}, calling {@link VersionMessage#appendToSubVer(String, String, String)} on it,
     ; and then calling {@link PeerGroup#setVersionMessage(VersionMessage)} on the result of that.  See the docs for
     ; {@link VersionMessage#appendToSubVer(String, String, String)} for information on what the fields should contain.
     ;;
    #_public
    (§ method void setUserAgent(§ args String name, String version))
    (§ block
        (§ call setUserAgent(§ pars name, version, nil))
    )

    ;;; See {@link Peer#addBlocksDownloadedEventListener(BlocksDownloadedEventListener)}. ;;
    #_public
    (§ method void addBlocksDownloadedEventListener(§ args BlocksDownloadedEventListener listener))
    (§ block
        (§ call addBlocksDownloadedEventListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; blocks are downloaded by the download peer.</p>
     ; @see Peer#addBlocksDownloadedEventListener(Executor, BlocksDownloadedEventListener)
     ;;
    #_public
    (§ method void addBlocksDownloadedEventListener(§ args Executor executor, BlocksDownloadedEventListener listener))
    (§ block
        (§ call peersBlocksDownloadedEventListeners.add(§ pars new ListenerRegistration<>(§ pars Preconditions.checkNotNull(§ pars listener), executor)))
        (§ for (§ var Peer peer) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ call peer.addBlocksDownloadedEventListener(§ pars executor, listener))
        )
        (§ for (§ var Peer peer) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ call peer.addBlocksDownloadedEventListener(§ pars executor, listener))
        )
    )

    ;;; See {@link Peer#addBlocksDownloadedEventListener(BlocksDownloadedEventListener)}. ;;
    #_public
    (§ method void addChainDownloadStartedEventListener(§ args ChainDownloadStartedEventListener listener))
    (§ block
        (§ call addChainDownloadStartedEventListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; chain download starts.</p>
     ;;
    #_public
    (§ method void addChainDownloadStartedEventListener(§ args Executor executor, ChainDownloadStartedEventListener listener))
    (§ block
        (§ call peersChainDownloadStartedEventListeners.add(§ pars new ListenerRegistration<>(§ pars Preconditions.checkNotNull(§ pars listener), executor)))
        (§ for (§ var Peer peer) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ call peer.addChainDownloadStartedEventListener(§ pars executor, listener))
        )
        (§ for (§ var Peer peer) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ call peer.addChainDownloadStartedEventListener(§ pars executor, listener))
        )
    )

    ;;; See {@link Peer#addConnectedEventListener(PeerConnectedEventListener)}. ;;
    #_public
    (§ method void addConnectedEventListener(§ args PeerConnectedEventListener listener))
    (§ block
        (§ call addConnectedEventListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; new peers are connected to.</p>
     ;;
    #_public
    (§ method void addConnectedEventListener(§ args Executor executor, PeerConnectedEventListener listener))
    (§ block
        (§ call peerConnectedEventListeners.add(§ pars new ListenerRegistration<>(§ pars Preconditions.checkNotNull(§ pars listener), executor)))
        (§ for (§ var Peer peer) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ call peer.addConnectedEventListener(§ pars executor, listener))
        )
        (§ for (§ var Peer peer) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ call peer.addConnectedEventListener(§ pars executor, listener))
        )
    )

    ;;; See {@link Peer#addDisconnectedEventListener(PeerDisconnectedEventListener)}. ;;
    #_public
    (§ method void addDisconnectedEventListener(§ args PeerDisconnectedEventListener listener))
    (§ block
        (§ call addDisconnectedEventListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; peers are disconnected from.</p>
     ;;
    #_public
    (§ method void addDisconnectedEventListener(§ args Executor executor, PeerDisconnectedEventListener listener))
    (§ block
        (§ call peerDisconnectedEventListeners.add(§ pars new ListenerRegistration<>(§ pars Preconditions.checkNotNull(§ pars listener), executor)))
        (§ for (§ var Peer peer) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ call peer.addDisconnectedEventListener(§ pars executor, listener))
        )
        (§ for (§ var Peer peer) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ call peer.addDisconnectedEventListener(§ pars executor, listener))
        )
    )

    ;;; See {@link Peer#addDiscoveredEventListener(PeerDiscoveredEventListener)}. ;;
    #_public
    (§ method void addDiscoveredEventListener(§ args PeerDiscoveredEventListener listener))
    (§ block
        (§ call addDiscoveredEventListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when new
     ; peers are discovered.</p>
     ;;
    #_public
    (§ method void addDiscoveredEventListener(§ args Executor executor, PeerDiscoveredEventListener listener))
    (§ block
        (§ call peerDiscoveredEventListeners.add(§ pars new ListenerRegistration<>(§ pars Preconditions.checkNotNull(§ pars listener), executor)))
    )

    ;;; See {@link Peer#addGetDataEventListener(GetDataEventListener)}. ;;
    #_public
    (§ method void addGetDataEventListener(§ args GetDataEventListener listener))
    (§ block
        (§ call addGetDataEventListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;; See {@link Peer#addGetDataEventListener(Executor, GetDataEventListener)}. ;;
    #_public
    (§ method void addGetDataEventListener(§ args #_final Executor executor, #_final GetDataEventListener listener))
    (§ block
        (§ call peerGetDataEventListeners.add(§ pars new ListenerRegistration<>(§ pars Preconditions.checkNotNull(§ pars listener), executor)))
        (§ for (§ var Peer peer) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ call peer.addGetDataEventListener(§ pars executor, listener))
        )
        (§ for (§ var Peer peer) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ call peer.addGetDataEventListener(§ pars executor, listener))
        )
    )

    ;;; See {@link Peer#addOnTransactionBroadcastListener(OnTransactionBroadcastListener)}. ;;
    #_public
    (§ method void addOnTransactionBroadcastListener(§ args OnTransactionBroadcastListener listener))
    (§ block
        (§ call addOnTransactionBroadcastListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;; See {@link Peer#addOnTransactionBroadcastListener(OnTransactionBroadcastListener)}. ;;
    #_public
    (§ method void addOnTransactionBroadcastListener(§ args Executor executor, OnTransactionBroadcastListener listener))
    (§ block
        (§ call peersTransactionBroadastEventListeners.add(§ pars new ListenerRegistration<>(§ pars Preconditions.checkNotNull(§ pars listener), executor)))
        (§ for (§ var Peer peer) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ call peer.addOnTransactionBroadcastListener(§ pars executor, listener))
        )
        (§ for (§ var Peer peer) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ call peer.addOnTransactionBroadcastListener(§ pars executor, listener))
        )
    )

    ;;; See {@link Peer#addPreMessageReceivedEventListener(PreMessageReceivedEventListener)}. ;;
    #_public
    (§ method void addPreMessageReceivedEventListener(§ args PreMessageReceivedEventListener listener))
    (§ block
        (§ call addPreMessageReceivedEventListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;; See {@link Peer#addPreMessageReceivedEventListener(Executor, PreMessageReceivedEventListener)}. ;;
    #_public
    (§ method void addPreMessageReceivedEventListener(§ args Executor executor, PreMessageReceivedEventListener listener))
    (§ block
        (§ call peersPreMessageReceivedEventListeners.add(§ pars new ListenerRegistration<>(§ pars Preconditions.checkNotNull(§ pars listener), executor)))
        (§ for (§ var Peer peer) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ call peer.addPreMessageReceivedEventListener(§ pars executor, listener))
        )
        (§ for (§ var Peer peer) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ call peer.addPreMessageReceivedEventListener(§ pars executor, listener))
        )
    )

    #_public
    (§ method boolean removeBlocksDownloadedEventListener(§ args BlocksDownloadedEventListener listener))
    (§ block
        (§ var boolean result = ListenerRegistration.removeFromList(§ pars listener, peersBlocksDownloadedEventListeners))
        (§ for (§ var Peer peer) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ call peer.removeBlocksDownloadedEventListener(§ pars listener))
        )
        (§ for (§ var Peer peer) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ call peer.removeBlocksDownloadedEventListener(§ pars listener))
        )
        (§ return result)
    )

    #_public
    (§ method boolean removeChainDownloadStartedEventListener(§ args ChainDownloadStartedEventListener listener))
    (§ block
        (§ var boolean result = ListenerRegistration.removeFromList(§ pars listener, peersChainDownloadStartedEventListeners))
        (§ for (§ var Peer peer) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ call peer.removeChainDownloadStartedEventListener(§ pars listener))
        )
        (§ for (§ var Peer peer) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ call peer.removeChainDownloadStartedEventListener(§ pars listener))
        )
        (§ return result)
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (§ method boolean removeConnectedEventListener(§ args PeerConnectedEventListener listener))
    (§ block
        (§ var boolean result = ListenerRegistration.removeFromList(§ pars listener, peerConnectedEventListeners))
        (§ for (§ var Peer peer) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ call peer.removeConnectedEventListener(§ pars listener))
        )
        (§ for (§ var Peer peer) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ call peer.removeConnectedEventListener(§ pars listener))
        )
        (§ return result)
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (§ method boolean removeDisconnectedEventListener(§ args PeerDisconnectedEventListener listener))
    (§ block
        (§ var boolean result = ListenerRegistration.removeFromList(§ pars listener, peerDisconnectedEventListeners))
        (§ for (§ var Peer peer) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ call peer.removeDisconnectedEventListener(§ pars listener))
        )
        (§ for (§ var Peer peer) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ call peer.removeDisconnectedEventListener(§ pars listener))
        )
        (§ return result)
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (§ method boolean removeDiscoveredEventListener(§ args PeerDiscoveredEventListener listener))
    (§ block
        (§ var boolean result = ListenerRegistration.removeFromList(§ pars listener, peerDiscoveredEventListeners))
        (§ return result)
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (§ method boolean removeGetDataEventListener(§ args GetDataEventListener listener))
    (§ block
        (§ var boolean result = ListenerRegistration.removeFromList(§ pars listener, peerGetDataEventListeners))
        (§ for (§ var Peer peer) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ call peer.removeGetDataEventListener(§ pars listener))
        )
        (§ for (§ var Peer peer) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ call peer.removeGetDataEventListener(§ pars listener))
        )
        (§ return result)
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (§ method boolean removeOnTransactionBroadcastListener(§ args OnTransactionBroadcastListener listener))
    (§ block
        (§ var boolean result = ListenerRegistration.removeFromList(§ pars listener, peersTransactionBroadastEventListeners))
        (§ for (§ var Peer peer) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ call peer.removeOnTransactionBroadcastListener(§ pars listener))
        )
        (§ for (§ var Peer peer) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ call peer.removeOnTransactionBroadcastListener(§ pars listener))
        )
        (§ return result)
    )

    #_public
    (§ method boolean removePreMessageReceivedEventListener(§ args PreMessageReceivedEventListener listener))
    (§ block
        (§ var boolean result = ListenerRegistration.removeFromList(§ pars listener, peersPreMessageReceivedEventListeners))
        (§ for (§ var Peer peer) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ call peer.removePreMessageReceivedEventListener(§ pars listener))
        )
        (§ for (§ var Peer peer) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ call peer.removePreMessageReceivedEventListener(§ pars listener))
        )
        (§ return result)
    )

    ;;;
     ; Returns a newly allocated list containing the currently connected peers.
     ; If all you care about is the count, use numConnectedPeers().
     ;;
    #_public
    (§ method List<Peer> getConnectedPeers(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return new ArrayList<>(§ pars peers))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a list containing Peers that did not complete connection yet.
     ;;
    #_public
    (§ method List<Peer> getPendingPeers(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return new ArrayList<>(§ pars pendingPeers))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Add an address to the list of potential peers to connect to.  It won't necessarily be used unless there's a need
     ; to build new connections to reach the max connection count.
     ;
     ; @param peerAddress IP/port to use.
     ;;
    #_public
    (§ method void addAddress(§ args PeerAddress peerAddress))
    (§ block
        (§ var int newMax)
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call addInactive(§ pars peerAddress))
            (§ ass newMax = getMaxConnections(§ pars ) + 1)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
        (§ call setMaxConnections(§ pars newMax))
    )

    #_private
    (§ method void addInactive(§ args PeerAddress peerAddress))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; Deduplicate.
            (§ if (§ expr backoffMap.containsKey(§ pars peerAddress)))
            (§ block
                (§ return )
            )
            (§ call backoffMap.put(§ pars peerAddress, new ExponentialBackoff(§ pars peerBackoffParams)))
            (§ call inactives.offer(§ pars peerAddress))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Convenience for connecting only to peers that can serve specific services.
     ; It will configure suitable peer discoveries.
     ; @param requiredServices Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     ;;
    #_public
    (§ method void setRequiredServices(§ args long requiredServices))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass this.requiredServices = requiredServices)
            (§ call peerDiscoverers.clear(§ pars ))
            (§ call addPeerDiscovery(§ pars MultiplexingDiscovery.forServices(§ pars params, requiredServices)))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;; Convenience method for addAddress(new PeerAddress(address, params.port)). ;;
    #_public
    (§ method void addAddress(§ args InetAddress address))
    (§ block
        (§ call addAddress(§ pars (§ new PeerAddress(§ pars params, address, params.getPort(§ pars )))))
    )

    ;;;
     ; Add addresses from a discovery source to the list of potential peers to connect to.
     ; If max connections has not been configured, or set to zero, then it's set to the default at this point.
     ;;
    #_public
    (§ method void addPeerDiscovery(§ args PeerDiscovery peerDiscovery))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr getMaxConnections(§ pars ) == 0))
            (§ block
                (§ call setMaxConnections(§ pars DEFAULT_CONNECTIONS))
            )
            (§ call peerDiscoverers.add(§ pars peerDiscovery))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;; Returns number of discovered peers. ;;
    #_protected
    (§ method int discoverPeers(§ args ))
        (§ throws PeerDiscoveryException)
    (§ block
        ;; Don't hold the lock whilst doing peer discovery: it can take a long time and cause high API latency.
        (§ call Preconditions.checkState(§ pars !lock.isHeldByCurrentThread(§ pars )))

        (§ var int maxPeersToDiscoverCount = this.vMaxPeersToDiscoverCount)
        (§ var long peerDiscoveryTimeoutMillis = this.vPeerDiscoveryTimeoutMillis)
        #_final
        (§ var Stopwatch watch = Stopwatch.createStarted(§ pars ))
        #_final
        (§ var List<PeerAddress> addressList = Lists.newLinkedList(§ pars ))

        (§ for (§ var PeerDiscovery peerDiscovery) :for (§ expr peerDiscoverers)) ;; COW
        (§ block
            (§ var InetSocketAddress[] addresses = peerDiscovery.getPeers(§ pars requiredServices, peerDiscoveryTimeoutMillis, TimeUnit.MILLISECONDS))
            (§ for (§ var InetSocketAddress address) :for (§ expr addresses))
            (§ block
                (§ call addressList.add(§ pars (§ new PeerAddress(§ pars params, address))))
            )
            (§ if (§ expr maxPeersToDiscoverCount <= addressList.size(§ pars )))
            (§ block
                (§ break )
            )
        )

        (§ if (§ expr !addressList.isEmpty(§ pars )))
        (§ block
            (§ for (§ var PeerAddress address) :for (§ expr addressList))
            (§ block
                (§ call addInactive(§ pars address))
            )

            #_final
            (§ var ImmutableSet<PeerAddress> peersDiscoveredSet = ImmutableSet.copyOf(§ pars addressList))
            (§ for (§ var #_final ListenerRegistration<PeerDiscoveredEventListener> registration) :for (§ expr peerDiscoveredEventListeners)) ;; COW
            (§ block
                (§ call registration.executor.execute(§ pars (§ new Runnable(§ pars ))
                (§ anon
                    #_override
                    #_public
                    (§ method void run(§ args ))
                    (§ block
                        (§ call registration.listener.onPeersDiscovered(§ pars peersDiscoveredSet))
                    )
                )))
            )
        )
        (§ call watch.stop(§ pars ))
        (§ call log.info(§ pars "Peer discovery took {} and returned {} items", watch, addressList.size(§ pars )))
        (§ return addressList.size(§ pars ))
    )

    #_testing
    (§ method void waitForJobQueue(§ args ))
    (§ block
        (§ call Futures.getUnchecked(§ pars executor.submit(§ pars Runnables.doNothing(§ pars ))))
    )

    #_private
    (§ method int countConnectedAndPendingPeers(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return peers.size(§ pars ) + pendingPeers.size(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_private
    (§ enum LocalhostCheckState
        (§ item NOT_TRIED)
        (§ item FOUND)
        (§ item FOUND_AND_CONNECTED)
        (§ item NOT_THERE)
    )
    #_private
    (§ field LocalhostCheckState localhostCheckState = LocalhostCheckState.NOT_TRIED)

    #_private
    (§ method boolean maybeCheckForLocalhostPeer(§ args ))
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ if (§ expr localhostCheckState == LocalhostCheckState.NOT_TRIED))
        (§ block
            ;; Do a fast blocking connect to see if anything is listening.
            (§ var Socket socket = nil)
            (§ try )
            (§ block
                (§ ass socket = new Socket(§ pars ))
                (§ call socket.connect(§ pars (§ new InetSocketAddress(§ pars InetAddresses.forString(§ pars "127.0.0.1"), params.getPort(§ pars ))), vConnectTimeoutMillis))
                (§ ass localhostCheckState = LocalhostCheckState.FOUND)
                (§ return true)
            )
            (§ catch (§ args IOException e))
            (§ block
                (§ call log.info(§ pars "Localhost peer not detected."))
                (§ ass localhostCheckState = LocalhostCheckState.NOT_THERE)
            )
            (§ finally )
            (§ block
                (§ if (§ expr socket != nil))
                (§ block
                    (§ try )
                    (§ block
                        (§ call socket.close(§ pars ))
                    )
                    (§ catch (§ args IOException _))
                    (§ block
                        ;; Ignore.
                    )
                )
            )
        )
        (§ return false)
    )

    ;;;
     ; Starts the PeerGroup and begins network activity.
     ; @return A future that completes when first connection activity has been triggered (note: not first connection made).
     ;;
    #_public
    (§ method ListenableFuture startAsync(§ args ))
    (§ block
        ;; This is run in a background thread by the Service implementation.
        (§ if (§ expr chain == nil))
        (§ block
            ;; Just try to help catch what might be a programming error.
            (§ call log.warn(§ pars "Starting up with no attached block chain. Did you forget to pass one to the constructor?"))
        )
        (§ call Preconditions.checkState(§ pars !vUsedUp, "Cannot start a peer group twice"))

        (§ ass vRunning = true)
        (§ ass vUsedUp = true)
        (§ call executorStartupLatch.countDown(§ pars ))

        ;; We do blocking waits during startup, so run on the executor thread.
        (§ return executor.submit(§ pars (§ new Runnable(§ pars ))
        (§ anon
            #_override
            #_public
            (§ method void run(§ args ))
            (§ block
                (§ try )
                (§ block
                    (§ call log.info(§ pars "Starting ..."))
                    (§ call channels.startAsync(§ pars ))
                    (§ call channels.awaitRunning(§ pars ))
                    (§ call triggerConnections(§ pars ))
                    (§ call setupPinging(§ pars ))
                )
                (§ catch (§ args Throwable e))
                (§ block
                    (§ call log.error(§ pars "Exception when starting up", e)) ;; The executor swallows exceptions :( ;; )
                )
            )
        )))
    )

    ;;; Does a blocking startup. ;;
    #_public
    (§ method void start(§ args ))
    (§ block
        (§ call Futures.getUnchecked(§ pars startAsync(§ pars )))
    )

    ;;; Can just use start() for a blocking start here instead of startAsync/awaitRunning: PeerGroup is no longer a Guava service. ;;
    #_deprecated
    #_public
    (§ method void awaitRunning(§ args ))
    (§ block
        (§ call waitForJobQueue(§ pars ))
    )

    #_public
    (§ method ListenableFuture stopAsync(§ args ))
    (§ block
        (§ call Preconditions.checkState(§ pars vRunning))
        (§ ass vRunning = false)
        (§ var ListenableFuture future = executor.submit(§ pars (§ new Runnable(§ pars ))
        (§ anon
            #_override
            #_public
            (§ method void run(§ args ))
            (§ block
                (§ try )
                (§ block
                    (§ call log.info(§ pars "Stopping ..."))
                    ;; Blocking close of all sockets.
                    (§ call channels.stopAsync(§ pars ))
                    (§ call channels.awaitTerminated(§ pars ))
                    (§ for (§ var PeerDiscovery peerDiscovery) :for (§ expr peerDiscoverers))
                    (§ block
                        (§ call peerDiscovery.shutdown(§ pars ))
                    )
                    (§ ass vRunning = false)
                    (§ call log.info(§ pars "Stopped."))
                )
                (§ catch (§ args Throwable e))
                (§ block
                    (§ call log.error(§ pars "Exception when shutting down", e)) ;; The executor swallows exceptions :( ;; )
                )
            )
        )))
        (§ call executor.shutdown(§ pars ))
        (§ return future)
    )

    ;;; Does a blocking stop. ;;
    #_public
    (§ method void stop(§ args ))
    (§ block
        (§ try )
        (§ block
            (§ call stopAsync(§ pars ))
            (§ call log.info(§ pars "Awaiting PeerGroup shutdown ..."))
            (§ call executor.awaitTermination(§ pars Long.MAX_VALUE, TimeUnit.SECONDS))
        )
        (§ catch (§ args InterruptedException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )

    ;;; Can just use stop() here instead of stopAsync/awaitTerminated: PeerGroup is no longer a Guava service. ;;
    #_deprecated
    #_public
    (§ method void awaitTerminated(§ args ))
    (§ block
        (§ try )
        (§ block
            (§ call executor.awaitTermination(§ pars Long.MAX_VALUE, TimeUnit.SECONDS))
        )
        (§ catch (§ args InterruptedException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )

    ;;;
     ; <p>Link the given wallet to this PeerGroup.  This is used for three purposes:</p>
     ;
     ; <ol>
     ;   <li>So the wallet receives broadcast transactions.</li>
     ;   <li>Announcing pending transactions that didn't get into the chain yet to our peers.</li>
     ;   <li>Set the fast catchup time using {@link PeerGroup#setFastCatchupTimeSecs(long)} to optimize chain download.</li>
     ; </ol>
     ;
     ; <p>Note that this should be done before chain download commences because if you add a wallet with keys earlier
     ; than the current chain head, the relevant parts of the chain won't be redownloaded for you.</p>
     ;
     ; <p>The Wallet will have an event listener registered on it, so to avoid leaks remember to use
     ; {@link PeerGroup#removeWallet(Wallet)} on it if you wish to keep the Wallet but lose the PeerGroup.</p>
     ;;
    #_public
    (§ method void addWallet(§ args Wallet wallet))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call Preconditions.checkNotNull(§ pars wallet))
            (§ call Preconditions.checkState(§ pars !wallets.contains(§ pars wallet)))
            (§ call wallets.add(§ pars wallet))
            (§ call wallet.setTransactionBroadcaster(§ pars this))
            (§ call wallet.addCoinsReceivedEventListener(§ pars Threading.SAME_THREAD, walletCoinsReceivedEventListener))
            (§ call wallet.addKeyChainEventListener(§ pars Threading.SAME_THREAD, walletKeyEventListener))
            (§ call addPeerFilterProvider(§ pars wallet))
            (§ for (§ var Peer peer) :for (§ expr peers))
            (§ block
                (§ call peer.addWallet(§ pars wallet))
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; <p>Link the given PeerFilterProvider to this PeerGroup.
     ; DO NOT use this for Wallets, use {@link PeerGroup#addWallet(Wallet)} instead.</p>
     ;
     ; <p>Note that this should be done before chain download commences because if you add a listener with keys earlier
     ; than the current chain head, the relevant parts of the chain won't be redownloaded for you.</p>
     ;
     ; <p>This method invokes {@link PeerGroup#recalculateFastCatchupAndFilter(FilterRecalculateMode)}.
     ; The return value of this method is the <code>ListenableFuture</code> returned by that invocation.</p>
     ;
     ; @return a future that completes once each <code>Peer</code> in this group has had its <code>BloomFilter</code> (re)set.
     ;;
    #_public
    (§ method ListenableFuture<BloomFilter> addPeerFilterProvider(§ args PeerFilterProvider provider))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call Preconditions.checkNotNull(§ pars provider))
            (§ call Preconditions.checkState(§ pars !peerFilterProviders.contains(§ pars provider)))
            ;; Insert provider at the start.  This avoids various concurrency problems that could occur because we need
            ;; all providers to be in a consistent, unchanging state whilst the filter is built.  Providers can give
            ;; this guarantee by taking a lock in their begin method, but if we add to the end of the list here, it
            ;; means we establish a lock ordering a > b > c if that's the order the providers were added in.  Given that
            ;; the main wallet will usually be first, this establishes an ordering wallet > other-provider, which means
            ;; other-provider can then not call into the wallet itself.  Other providers installed by the API user should
            ;; come first so the expected ordering is preserved.  This can also manifest itself in providers that use
            ;; synchronous RPCs into an actor instead of locking, but the same issue applies.
            (§ call peerFilterProviders.add(§ pars 0, provider))

            ;; Don't bother downloading block bodies before the oldest keys in all our wallets.  Make sure we recalculate
            ;; if a key is added.  Of course, by then we may have downloaded the chain already.  Ideally adding keys would
            ;; automatically rewind the block chain and redownload the blocks to find transactions relevant to those keys,
            ;; all transparently and in the background.  But we are a long way from that yet.
            (§ var ListenableFuture<BloomFilter> future = recalculateFastCatchupAndFilter(§ pars FilterRecalculateMode.SEND_IF_CHANGED))
            (§ call updateVersionMessageRelayTxesBeforeFilter(§ pars getVersionMessage(§ pars )))
            (§ return future)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Opposite of {@link #addPeerFilterProvider(PeerFilterProvider)}.  Again, don't use this for wallets.  Does not
     ; trigger recalculation of the filter.
     ;;
    #_public
    (§ method void removePeerFilterProvider(§ args PeerFilterProvider provider))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call Preconditions.checkNotNull(§ pars provider))
            (§ call Preconditions.checkArgument(§ pars peerFilterProviders.remove(§ pars provider)))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Unlinks the given wallet so it no longer receives broadcast transactions or has its transactions announced.
     ;;
    #_public
    (§ method void removeWallet(§ args Wallet wallet))
    (§ block
        (§ call wallets.remove(§ pars Preconditions.checkNotNull(§ pars wallet)))
        (§ call peerFilterProviders.remove(§ pars wallet))
        (§ call wallet.removeCoinsReceivedEventListener(§ pars walletCoinsReceivedEventListener))
        (§ call wallet.removeKeyChainEventListener(§ pars walletKeyEventListener))
        (§ call wallet.setTransactionBroadcaster(§ pars nil))
        (§ for (§ var Peer peer) :for (§ expr peers))
        (§ block
            (§ call peer.removeWallet(§ pars wallet))
        )
    )

    #_public
    (§ enum FilterRecalculateMode
        (§ item SEND_IF_CHANGED)
        (§ item FORCE_SEND_FOR_REFRESH)
        (§ item DONT_SEND)
    )

    #_private
    #_final
    (§ field Map<FilterRecalculateMode, SettableFuture<BloomFilter>> inFlightRecalculations = Maps.newHashMap(§ pars ))

    ;;;
     ; Recalculates the bloom filter given to peers as well as the timestamp after which full blocks are downloaded
     ; (instead of only headers).  Note that calls made one after another may return the same future, if the request
     ; wasn't processed yet (i.e. calls are deduplicated).
     ;
     ; @param mode In what situations to send the filter to connected peers.
     ; @return A future that completes once the filter has been calculated (note: this does not mean acknowledged by remote peers).
     ;;
    #_public
    (§ method ListenableFuture<BloomFilter> recalculateFastCatchupAndFilter(§ args #_final FilterRecalculateMode mode))
    (§ block
        #_final
        (§ var SettableFuture<BloomFilter> future = SettableFuture.create(§ pars ))
        (§ sync inFlightRecalculations)
        (§ block
            (§ if (§ expr inFlightRecalculations.get(§ pars mode) != nil))
            (§ block
                (§ return inFlightRecalculations.get(§ pars mode))
            )

            (§ call inFlightRecalculations.put(§ pars mode, future))
        )
        (§ var Runnable command = new Runnable(§ pars )
        (§ anon
            #_override
            #_public
            (§ method void run(§ args ))
            (§ block
                (§ try )
                (§ block
                    (§ call go(§ pars ))
                )
                (§ catch (§ args Throwable e))
                (§ block
                    (§ call log.error(§ pars "Exception when trying to recalculate Bloom filter", e)) ;; The executor swallows exceptions :( ;; )
                )
            )

            #_public
            (§ method void go(§ args ))
            (§ block
                (§ call Preconditions.checkState(§ pars !lock.isHeldByCurrentThread(§ pars )))
                ;; Fully verifying mode doesn't use this optimization (it can't as it needs to see all transactions).
                (§ if (§ expr (§ expr chain != nil && chain.shouldVerifyTransactions(§ pars )) || !vBloomFilteringEnabled))
                (§ block
                    (§ return )
                )

                ;; We only ever call bloomFilterMerger.calculate on jobQueue, so we cannot be calculating two filters at once.
                (§ var FilterMerger.Result result = bloomFilterMerger.calculate(§ pars ImmutableList.copyOf(§ pars peerFilterProviders))) ;; COW
                (§ var boolean send)
                (§ switch (§ expr mode))
                (§ block
                    (§ case SEND_IF_CHANGED)
                    (§ block
                        (§ ass send = result.changed)
                        (§ break )
                    )
                    (§ case DONT_SEND)
                    (§ block
                        (§ ass send = false)
                        (§ break )
                    )
                    (§ case FORCE_SEND_FOR_REFRESH)
                    (§ block
                        (§ ass send = true)
                        (§ break )
                    )
                    (§ default )
                    (§ block
                        (§ throw (§ new UnsupportedOperationException(§ pars )))
                    )
                )
                (§ if (§ expr send))
                (§ block
                    (§ for (§ var Peer peer) :for (§ expr peers)) ;; COW
                    (§ block
                        ;; Only query the mempool if this recalculation request is not in order to lower the observed FP
                        ;; rate.  There's no point querying the mempool when doing this because the FP rate can only go
                        ;; down, and we will have seen all the relevant txns before: it's pointless to ask for them again.
                        (§ call peer.setBloomFilter(§ pars result.filter, mode != FilterRecalculateMode.FORCE_SEND_FOR_REFRESH))
                    )
                    ;; Reset the false positive estimate so that we don't send a flood of filter updates
                    ;; if the estimate temporarily overshoots our threshold.
                    (§ if (§ expr chain != nil))
                    (§ block
                        (§ call chain.resetFalsePositiveEstimate(§ pars ))
                    )
                )
                ;; Do this last so that bloomFilter is already set when it gets called.
                (§ call setFastCatchupTimeSecs(§ pars result.earliestKeyTimeSecs))
                (§ sync inFlightRecalculations)
                (§ block
                    (§ call inFlightRecalculations.put(§ pars mode, nil))
                )
                (§ call future.set(§ pars result.filter))
            )
        ))
        (§ try )
        (§ block
            (§ call executor.execute(§ pars command))
        )
        (§ catch (§ args RejectedExecutionException _))
        (§ block
            ;; Can happen during shutdown.
        )
        (§ return future)
    )

    ;;;
     ; <p>Sets the false positive rate of bloom filters given to peers.  The default is {@link #DEFAULT_BLOOM_FILTER_FP_RATE}.</p>
     ;
     ; <p>Be careful regenerating the bloom filter too often, as it decreases anonymity because remote nodes can
     ; compare transactions against both the new and old filters to significantly decrease the false positive rate.</p>
     ;
     ; <p>See the docs for {@link BloomFilter#BloomFilter(int, double, long, BloomFilter.BloomUpdate)} for a brief
     ; explanation of anonymity when using bloom filters.</p>
     ;;
    #_public
    (§ method void setBloomFilterFalsePositiveRate(§ args double bloomFilterFPRate))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call bloomFilterMerger.setBloomFilterFPRate(§ pars bloomFilterFPRate))
            (§ call recalculateFastCatchupAndFilter(§ pars FilterRecalculateMode.SEND_IF_CHANGED))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the number of currently connected peers.  To be informed when this count changes, register a
     ; {@link org.bitcoinj.core.listeners.PeerConnectedEventListener}/{@link org.bitcoinj.core.listeners.PeerDisconnectedEventListener}
     ; and use the onPeerConnected/onPeerDisconnected methods.
     ;;
    #_public
    (§ method int numConnectedPeers(§ args ))
    (§ block
        (§ return peers.size(§ pars ))
    )

    ;;;
     ; Connect to a peer by creating a channel to the destination address.  This should not be
     ; used normally - let the PeerGroup manage connections through {@link #start()}.
     ;
     ; @param address Destination IP and port.
     ; @return The newly created Peer object or null if the peer could not be connected.
     ;         Use {@link org.bitcoinj.core.Peer#getConnectionOpenFuture()} if you
     ;         want a future which completes when the connection is open.
     ;;
    #_nilable
    #_public
    (§ method Peer connectTo(§ args InetSocketAddress address))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var PeerAddress peerAddress = new PeerAddress(§ pars params, address))
            (§ call backoffMap.put(§ pars peerAddress, new ExponentialBackoff(§ pars peerBackoffParams)))
            (§ return connectTo(§ pars peerAddress, true, vConnectTimeoutMillis))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Helper for forcing a connection to localhost.  Useful when using test mode.  Returns the peer object.
     ;;
    #_nilable
    #_public
    (§ method Peer connectToLocalHost(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            #_final
            (§ var PeerAddress localhost = PeerAddress.localhost(§ pars params))
            (§ call backoffMap.put(§ pars localhost, new ExponentialBackoff(§ pars peerBackoffParams)))
            (§ return connectTo(§ pars localhost, true, vConnectTimeoutMillis))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Creates a version message to send, constructs a Peer object and attempts to connect it.
     ; Returns the peer on success or null on failure.
     ; @param address Remote network address.
     ; @param incrementMaxConnections Whether to consider this connection an attempt to fill our quota, or something explicitly requested.
     ; @return Peer or null.
     ;;
    #_nilable
    #_guarded-by(§ opt "lock")
    #_protected
    (§ method Peer connectTo(§ args PeerAddress address, boolean incrementMaxConnections, int connectTimeoutMillis))
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ var VersionMessage ver = getVersionMessage(§ pars ).duplicate(§ pars ))
        (§ ass ver.bestHeight = (§ expr chain != nil) ? chain.getBestChainHeight(§ pars ) :else 0)
        (§ ass ver.time = Utils.currentTimeSeconds(§ pars ))

        (§ var Peer peer = createPeer(§ pars address, ver))
        (§ call peer.addConnectedEventListener(§ pars Threading.SAME_THREAD, startupListener))
        (§ call peer.addDisconnectedEventListener(§ pars Threading.SAME_THREAD, startupListener))
        (§ call peer.setMinProtocolVersion(§ pars vMinRequiredProtocolVersion))
        (§ call pendingPeers.add(§ pars peer))

        (§ try )
        (§ block
            (§ call log.info(§ pars "Attempting connection to {}     ({} connected, {} pending, {} max)", address, peers.size(§ pars ), pendingPeers.size(§ pars ), maxConnections))
            (§ var ListenableFuture<SocketAddress> future = channels.openConnection(§ pars address.toSocketAddress(§ pars ), peer))
            (§ if (§ expr future.isDone(§ pars )))
            (§ block
                (§ call Uninterruptibles.getUninterruptibly(§ pars future))
            )
        )
        (§ catch (§ args ExecutionException e))
        (§ block
            (§ var Throwable cause = Throwables.getRootCause(§ pars e))
            (§ call log.warn(§ pars "Failed to connect to " + address + ": " + cause.getMessage(§ pars )))
            (§ call handlePeerDeath(§ pars peer, cause))
            (§ return nil)
        )
        (§ call peer.setSocketTimeout(§ pars connectTimeoutMillis))
        ;; When the channel has connected and version negotiated successfully, handleNewPeer will end up being called
        ;; on a worker thread.
        (§ if (§ expr incrementMaxConnections))
        (§ block
            ;; We don't use setMaxConnections here as that would trigger a recursive attempt to establish a new
            ;; outbound connection.
            (§ ass maxConnections = maxConnections + 1)
        )
        (§ return peer)
    )

    ;;; You can override this to customise the creation of {@link Peer} objects. ;;
    #_guarded-by(§ opt "lock")
    #_protected
    (§ method Peer createPeer(§ args PeerAddress address, VersionMessage ver))
    (§ block
        (§ return (§ new Peer(§ pars params, ver, address, chain, downloadTxDependencyDepth)))
    )

    ;;;
     ; Sets the timeout between when a connection attempt to a peer begins and when the version message exchange completes.
     ; This does not apply to currently pending peers.
     ;;
    #_public
    (§ method void setConnectTimeoutMillis(§ args int connectTimeoutMillis))
    (§ block
        (§ ass this.vConnectTimeoutMillis = connectTimeoutMillis)
    )

    ;;;
     ; <p>Start downloading the blockchain from the first available peer.</p>
     ;
     ; <p>If no peers are currently connected, the download will be started once a peer starts.  If the peer dies,
     ; the download will resume with another peer.</p>
     ;
     ; @param listener A listener for chain download events, may not be null.
     ;;
    #_public
    (§ method void startBlockChainDownload(§ args PeerDataEventListener listener))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr downloadPeer != nil))
            (§ block
                (§ if (§ expr this.downloadListener != nil))
                (§ block
                    (§ call removeDataEventListenerFromPeer(§ pars downloadPeer, this.downloadListener))
                )
                (§ if (§ expr listener != nil))
                (§ block
                    (§ call addDataEventListenerToPeer(§ pars Threading.USER_THREAD, downloadPeer, listener))
                )
            )
            (§ ass this.downloadListener = listener)
            ;; TODO: Be more nuanced about which peer to download from.  We can also try
            ;; downloading from multiple peers and handle the case when a new peer comes along
            ;; with a longer chain after we thought we were done.
            (§ if (§ expr !peers.isEmpty(§ pars )))
            (§ block
                (§ call startBlockChainDownloadFromPeer(§ pars peers.iterator(§ pars ).next(§ pars ))) ;; Will add the new download listener.
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Register a data event listener against a single peer (i.e. for blockchain download).
     ; Handling registration/deregistration on peer death/add is outside the scope of these methods.
     ;;
    #_private
    #_static
    (§ method void addDataEventListenerToPeer(§ args Executor executor, Peer peer, PeerDataEventListener downloadListener))
    (§ block
        (§ call peer.addBlocksDownloadedEventListener(§ pars executor, downloadListener))
        (§ call peer.addChainDownloadStartedEventListener(§ pars executor, downloadListener))
        (§ call peer.addGetDataEventListener(§ pars executor, downloadListener))
        (§ call peer.addPreMessageReceivedEventListener(§ pars executor, downloadListener))
    )

    ;;;
     ; Remove a registered data event listener against a single peer (i.e. for blockchain download).
     ; Handling registration/deregistration on peer death/add is outside the scope of these methods.
     ;;
    #_private
    #_static
    (§ method void removeDataEventListenerFromPeer(§ args Peer peer, PeerDataEventListener listener))
    (§ block
        (§ call peer.removeBlocksDownloadedEventListener(§ pars listener))
        (§ call peer.removeChainDownloadStartedEventListener(§ pars listener))
        (§ call peer.removeGetDataEventListener(§ pars listener))
        (§ call peer.removePreMessageReceivedEventListener(§ pars listener))
    )

    ;;;
     ; Download the blockchain from peers.  Convenience that uses a {@link DownloadProgressTracker} for you.
     ;
     ; This method waits until the download is complete.  "Complete" is defined as downloading
     ; from at least one peer all the blocks that are in that peer's inventory.
     ;;
    #_public
    (§ method void downloadBlockChain(§ args ))
    (§ block
        (§ var DownloadProgressTracker listener = new DownloadProgressTracker(§ pars ))
        (§ call startBlockChainDownload(§ pars listener))
        (§ try )
        (§ block
            (§ call listener.await(§ pars ))
        )
        (§ catch (§ args InterruptedException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )

    #_protected
    (§ method void handleNewPeer(§ args #_final Peer peer))
    (§ block
        (§ var int newSize = -1)
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call groupBackoff.trackSuccess(§ pars ))
            (§ call backoffMap.get(§ pars peer.getAddress(§ pars )).trackSuccess(§ pars ))

            ;; Sets up the newly connected peer so it can do everything it needs to.
            (§ call pendingPeers.remove(§ pars peer))
            (§ call peers.add(§ pars peer))
            (§ ass newSize = peers.size(§ pars ))
            (§ call log.info(§ pars "{}: New peer      ({} connected, {} pending, {} max)", peer, newSize, pendingPeers.size(§ pars ), maxConnections))
            ;; Give the peer a filter that can be used to probabilistically drop transactions that
            ;; aren't relevant to our wallet.  We may still receive some false positives, which is
            ;; OK because it helps improve wallet privacy.  Old nodes will just ignore the message.
            (§ if (§ expr bloomFilterMerger.getLastFilter(§ pars ) != nil))
            (§ block
                (§ call peer.setBloomFilter(§ pars bloomFilterMerger.getLastFilter(§ pars )))
            )
            (§ call peer.setDownloadData(§ pars false))
            ;; TODO: The peer should calculate the fast catchup time from the added wallets here.
            (§ for (§ var Wallet wallet) :for (§ expr wallets))
            (§ block
                (§ call peer.addWallet(§ pars wallet))
            )
            (§ if (§ expr downloadPeer == nil))
            (§ block
                ;; Kick off chain download if we aren't already doing it.
                (§ call setDownloadPeer(§ pars selectDownloadPeer(§ pars peers)))
                (§ var boolean shouldDownloadChain = (§ expr downloadListener != nil && chain != nil))
                (§ if (§ expr shouldDownloadChain))
                (§ block
                    (§ call startBlockChainDownloadFromPeer(§ pars downloadPeer))
                )
            )
            ;; Make sure the peer knows how to upload transactions that are requested from us.
            (§ call peer.addBlocksDownloadedEventListener(§ pars Threading.SAME_THREAD, peerListener))
            (§ call peer.addGetDataEventListener(§ pars Threading.SAME_THREAD, peerListener))

            ;; And set up event listeners for clients.  This will allow them to find out about new transactions and blocks.
            (§ for (§ var ListenerRegistration<BlocksDownloadedEventListener> registration) :for (§ expr peersBlocksDownloadedEventListeners))
            (§ block
                (§ call peer.addBlocksDownloadedEventListener(§ pars registration.executor, registration.listener))
            )
            (§ for (§ var ListenerRegistration<ChainDownloadStartedEventListener> registration) :for (§ expr peersChainDownloadStartedEventListeners))
            (§ block
                (§ call peer.addChainDownloadStartedEventListener(§ pars registration.executor, registration.listener))
            )
            (§ for (§ var ListenerRegistration<PeerConnectedEventListener> registration) :for (§ expr peerConnectedEventListeners))
            (§ block
                (§ call peer.addConnectedEventListener(§ pars registration.executor, registration.listener))
            )

            ;; We intentionally do not add disconnect listeners to peers.
            (§ for (§ var ListenerRegistration<GetDataEventListener> registration) :for (§ expr peerGetDataEventListeners))
            (§ block
                (§ call peer.addGetDataEventListener(§ pars registration.executor, registration.listener))
            )
            (§ for (§ var ListenerRegistration<OnTransactionBroadcastListener> registration) :for (§ expr peersTransactionBroadastEventListeners))
            (§ block
                (§ call peer.addOnTransactionBroadcastListener(§ pars registration.executor, registration.listener))
            )
            (§ for (§ var ListenerRegistration<PreMessageReceivedEventListener> registration) :for (§ expr peersPreMessageReceivedEventListeners))
            (§ block
                (§ call peer.addPreMessageReceivedEventListener(§ pars registration.executor, registration.listener))
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )

        #_final
        (§ var int fNewSize = newSize)
        (§ for (§ var #_final ListenerRegistration<PeerConnectedEventListener> registration) :for (§ expr peerConnectedEventListeners))
        (§ block
            (§ call registration.executor.execute(§ pars (§ new Runnable(§ pars ))
            (§ anon
                #_override
                #_public
                (§ method void run(§ args ))
                (§ block
                    (§ call registration.listener.onPeerConnected(§ pars peer, fNewSize))
                )
            )))
        )
    )

    #_nilable
    #_private
    #_volatile
    (§ field ListenableScheduledFuture<?> vPingTask)

    #_suppress(§ opt "NonAtomicOperationOnVolatileField")
    #_private
    (§ method void setupPinging(§ args ))
    (§ block
        (§ if (§ expr getPingIntervalMsec(§ pars ) <= 0))
        (§ block
            (§ return ) ;; Disabled.
        )

        (§ ass vPingTask = executor.scheduleAtFixedRate(§ pars (§ new Runnable(§ pars ))
        (§ anon
            #_override
            #_public
            (§ method void run(§ args ))
            (§ block
                (§ try )
                (§ block
                    (§ if (§ expr getPingIntervalMsec(§ pars ) <= 0))
                    (§ block
                        (§ var ListenableScheduledFuture<?> task = vPingTask)
                        (§ if (§ expr task != nil))
                        (§ block
                            (§ call task.cancel(§ pars false))
                            (§ ass vPingTask = nil)
                        )
                        (§ return ) ;; Disabled.
                    )
                    (§ for (§ var Peer peer) :for (§ expr getConnectedPeers(§ pars )))
                    (§ block
                        (§ if (§ expr peer.getPeerVersionMessage(§ pars ).clientVersion < params.getProtocolVersionNum(§ pars NetworkParameters.ProtocolVersion.PONG)))
                        (§ block
                            (§ continue )
                        )
                        (§ call peer.ping(§ pars ))
                    )
                )
                (§ catch (§ args Throwable e))
                (§ block
                    (§ call log.error(§ pars "Exception in ping loop", e)) ;; The executor swallows exceptions :( ;; )
                )
            )
        ), getPingIntervalMsec(§ pars ), getPingIntervalMsec(§ pars ), TimeUnit.MILLISECONDS))
    )

    #_private
    (§ method void setDownloadPeer(§ args #_nilable Peer peer))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr downloadPeer == peer))
            (§ block
                (§ return )
            )
            (§ if (§ expr downloadPeer != nil))
            (§ block
                (§ call log.info(§ pars "Unsetting download peer: {}", downloadPeer))
                (§ if (§ expr downloadListener != nil))
                (§ block
                    (§ call removeDataEventListenerFromPeer(§ pars downloadPeer, downloadListener))
                )
                (§ call downloadPeer.setDownloadData(§ pars false))
            )
            (§ ass downloadPeer = peer)
            (§ if (§ expr downloadPeer != nil))
            (§ block
                (§ call log.info(§ pars "Setting download peer: {}", downloadPeer))
                (§ if (§ expr downloadListener != nil))
                (§ block
                    (§ call addDataEventListenerToPeer(§ pars Threading.SAME_THREAD, peer, downloadListener))
                )
                (§ call downloadPeer.setDownloadData(§ pars true))
                (§ if (§ expr chain != nil))
                (§ block
                    (§ call downloadPeer.setDownloadParameters(§ pars fastCatchupTimeSecs, bloomFilterMerger.getLastFilter(§ pars ) != nil))
                )
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Tells the PeerGroup to download only block headers before a certain time and bodies after that.
     ; Call this before starting block chain download.
     ; Do not use a time > NOW - 1 block, as it will break some block download logic.
     ;;
    #_public
    (§ method void setFastCatchupTimeSecs(§ args long secondsSinceEpoch))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call Preconditions.checkState(§ pars chain == nil || !chain.shouldVerifyTransactions(§ pars ), "Fast catchup is incompatible with fully verifying"))

            (§ ass fastCatchupTimeSecs = secondsSinceEpoch)
            (§ if (§ expr downloadPeer != nil))
            (§ block
                (§ call downloadPeer.setDownloadParameters(§ pars secondsSinceEpoch, bloomFilterMerger.getLastFilter(§ pars ) != nil))
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the current fast catchup time.  The contents of blocks before this time won't be downloaded as they
     ; cannot contain any interesting transactions.  If you use {@link PeerGroup#addWallet(Wallet)} this just returns
     ; the min of the wallets earliest key times.
     ; @return a time in seconds since the epoch.
     ;;
    #_public
    (§ method long getFastCatchupTimeSecs(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return fastCatchupTimeSecs)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_protected
    (§ method void handlePeerDeath(§ args #_final Peer peer, #_nilable Throwable exception))
    (§ block
        ;; Peer deaths can occur during startup if a connect attempt after peer discovery aborts immediately.
        (§ if (§ expr !isRunning(§ pars )))
        (§ block
            (§ return )
        )

        (§ var int numPeers)
        (§ var int numConnectedPeers = 0)
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call pendingPeers.remove(§ pars peer))
            (§ call peers.remove(§ pars peer))

            (§ var PeerAddress address = peer.getAddress(§ pars ))

            (§ call log.info(§ pars "{}: Peer died      ({} connected, {} pending, {} max)", address, peers.size(§ pars ), pendingPeers.size(§ pars ), maxConnections))
            (§ if (§ expr peer == downloadPeer))
            (§ block
                (§ call log.info(§ pars "Download peer died. Picking a new one."))
                (§ call setDownloadPeer(§ pars nil))
                ;; Pick a new one and possibly tell it to download the chain.
                #_final
                (§ var Peer newDownloadPeer = selectDownloadPeer(§ pars peers))
                (§ if (§ expr newDownloadPeer != nil))
                (§ block
                    (§ call setDownloadPeer(§ pars newDownloadPeer))
                    (§ if (§ expr downloadListener != nil))
                    (§ block
                        (§ call startBlockChainDownloadFromPeer(§ pars newDownloadPeer))
                    )
                )
            )
            (§ ass numPeers = peers.size(§ pars ) + pendingPeers.size(§ pars ))
            (§ ass numConnectedPeers = peers.size(§ pars ))

            (§ call groupBackoff.trackFailure(§ pars ))

            (§ if (§ expr exception instanceof NoRouteToHostException))
            (§ block
                (§ if (§ expr address.getAddr(§ pars ) instanceof Inet6Address && !ipv6Unreachable))
                (§ block
                    (§ ass ipv6Unreachable = true)
                    (§ call log.warn(§ pars "IPv6 peer connect failed due to routing failure, ignoring IPv6 addresses from now on"))
                )
            )
            (§ else )
            (§ block
                (§ call backoffMap.get(§ pars address).trackFailure(§ pars ))
                ;; Put back on inactive list.
                (§ call inactives.offer(§ pars address))
            )

            (§ if (§ expr numPeers < getMaxConnections(§ pars )))
            (§ block
                (§ call triggerConnections(§ pars ))
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )

        (§ call peer.removeBlocksDownloadedEventListener(§ pars peerListener))
        (§ call peer.removeGetDataEventListener(§ pars peerListener))
        (§ for (§ var Wallet wallet) :for (§ expr wallets))
        (§ block
            (§ call peer.removeWallet(§ pars wallet))
        )

        #_final
        (§ var int fNumConnectedPeers = numConnectedPeers)

        (§ for (§ var ListenerRegistration<BlocksDownloadedEventListener> registration) :for (§ expr peersBlocksDownloadedEventListeners))
        (§ block
            (§ call peer.removeBlocksDownloadedEventListener(§ pars registration.listener))
        )
        (§ for (§ var ListenerRegistration<ChainDownloadStartedEventListener> registration) :for (§ expr peersChainDownloadStartedEventListeners))
        (§ block
            (§ call peer.removeChainDownloadStartedEventListener(§ pars registration.listener))
        )
        (§ for (§ var ListenerRegistration<GetDataEventListener> registration) :for (§ expr peerGetDataEventListeners))
        (§ block
            (§ call peer.removeGetDataEventListener(§ pars registration.listener))
        )
        (§ for (§ var ListenerRegistration<PreMessageReceivedEventListener> registration) :for (§ expr peersPreMessageReceivedEventListeners))
        (§ block
            (§ call peer.removePreMessageReceivedEventListener(§ pars registration.listener))
        )
        (§ for (§ var ListenerRegistration<OnTransactionBroadcastListener> registration) :for (§ expr peersTransactionBroadastEventListeners))
        (§ block
            (§ call peer.removeOnTransactionBroadcastListener(§ pars registration.listener))
        )

        (§ for (§ var #_final ListenerRegistration<PeerDisconnectedEventListener> registration) :for (§ expr peerDisconnectedEventListeners))
        (§ block
            (§ call registration.executor.execute(§ pars (§ new Runnable(§ pars ))
            (§ anon
                #_override
                #_public
                (§ method void run(§ args ))
                (§ block
                    (§ call registration.listener.onPeerDisconnected(§ pars peer, fNumConnectedPeers))
                )
            )))
            (§ call peer.removeDisconnectedEventListener(§ pars registration.listener))
        )
    )

    #_guarded-by(§ opt "lock")
    #_private
    (§ field int stallPeriodSeconds = 10)
    #_guarded-by(§ opt "lock")
    #_private
    (§ field int stallMinSpeedBytesSec = Block.HEADER_SIZE * 20)

    ;;;
     ; Configures the stall speed: the speed at which a peer is considered to be serving us the block chain
     ; unacceptably slowly.  Once a peer has served us data slower than the given data rate for the given
     ; number of seconds, it is considered stalled and will be disconnected, forcing the chain download to continue
     ; from a different peer.  The defaults are chosen conservatively, but if you are running on a platform that is
     ; CPU constrained or on a very slow network e.g. EDGE, the default settings may need adjustment to
     ; avoid false stalls.
     ;
     ; @param periodSecs How many seconds the download speed must be below blocksPerSec, defaults to 10.
     ; @param bytesPerSecond Download speed (only blocks/txns count) must be consistently below this for a stall, defaults to the bandwidth required for 20 block headers per second.
     ;;
    #_public
    (§ method void setStallThreshold(§ args int periodSecs, int bytesPerSecond))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass stallPeriodSeconds = periodSecs)
            (§ ass stallMinSpeedBytesSec = bytesPerSecond)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_private
    (§ class ChainDownloadSpeedCalculator implements BlocksDownloadedEventListener, Runnable
        #_private
        (§ field int blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond)
        #_private
        (§ field long bytesInLastSecond)

        ;; If we take more stalls than this, we assume we're on some kind of terminally slow network and the
        ;; stall threshold just isn't set properly.  We give up on stall disconnects after that.
        #_private
        (§ field int maxStalls = 3)

        ;; How many seconds the peer has until we start measuring its speed.
        #_private
        (§ field int warmupSeconds = -1)

        ;; Used to calculate a moving average.
        #_private
        (§ field long[] samples)
        #_private
        (§ field int cursor)

        #_private
        (§ field boolean syncDone)

        #_override
        #_public
        #_synchronized
        (§ method void onBlocksDownloaded(§ args Peer peer, Block block, #_nilable FilteredBlock filteredBlock, int blocksLeft))
        (§ block
            (§ ass blocksInLastSecond = blocksInLastSecond + 1)
            (§ ass bytesInLastSecond = bytesInLastSecond + Block.HEADER_SIZE)
            (§ var List<Transaction> blockTransactions = block.getTransactions(§ pars ))
            ;; This whole area of the type hierarchy is a mess.
            (§ var int txCount = (§ expr (§ quest (§ expr blockTransactions != nil) ? countAndMeasureSize(§ pars blockTransactions) :else 0) + (§ quest (§ expr filteredBlock != nil) ? countAndMeasureSize(§ pars filteredBlock.getAssociatedTransactions(§ pars ).values(§ pars )) :else 0)))
            (§ ass txnsInLastSecond = txnsInLastSecond + txCount)
            (§ if (§ expr filteredBlock != nil))
            (§ block
                (§ ass origTxnsInLastSecond = origTxnsInLastSecond + filteredBlock.getTransactionCount(§ pars ))
            )
        )

        #_private
        (§ method int countAndMeasureSize(§ args Collection<Transaction> transactions))
        (§ block
            (§ for (§ var Transaction transaction) :for (§ expr transactions))
            (§ block
                (§ ass bytesInLastSecond = bytesInLastSecond + transaction.getMessageSize(§ pars ))
            )
            (§ return transactions.size(§ pars ))
        )

        #_override
        #_public
        (§ method void run(§ args ))
        (§ block
            (§ try )
            (§ block
                (§ call calculate(§ pars ))
            )
            (§ catch (§ args Throwable e))
            (§ block
                (§ call log.error(§ pars "Error in speed calculator", e))
            )
        )

        #_private
        (§ method void calculate(§ args ))
        (§ block
            (§ var int minSpeedBytesPerSec)
            (§ var int period)

            (§ call lock.lock(§ pars ))
            (§ try )
            (§ block
                (§ ass minSpeedBytesPerSec = stallMinSpeedBytesSec)
                (§ ass period = stallPeriodSeconds)
            )
            (§ finally )
            (§ block
                (§ call lock.unlock(§ pars ))
            )

            (§ sync this)
            (§ block
                (§ if (§ expr samples == nil || samples.length != period))
                (§ block
                    (§ ass samples = new long[period])
                    ;; *2 because otherwise a single low sample could cause an immediate disconnect which is too harsh.
                    (§ call Arrays.fill(§ pars samples, minSpeedBytesPerSec * 2))
                    (§ ass warmupSeconds = 15)
                )

                (§ var boolean behindPeers = (§ expr chain != nil && chain.getBestChainHeight(§ pars ) < getMostCommonChainHeight(§ pars )))
                (§ if (§ expr !behindPeers))
                (§ block
                    (§ ass syncDone = true)
                )
                (§ if (§ expr !syncDone))
                (§ block
                    (§ if (§ expr warmupSeconds < 0))
                    (§ block
                        ;; Calculate the moving average.
                        (§ ass samples[cursor] = bytesInLastSecond)
                        (§ ass cursor = cursor + 1)
                        (§ if (§ expr cursor == samples.length))
                        (§ block
                            (§ ass cursor = 0)
                        )
                        (§ var long average = 0)
                        (§ for (§ var long sample) :for (§ expr samples))
                        (§ block
                            (§ ass average = average + sample)
                        )
                        (§ ass average = average / samples.length)

                        (§ call log.info(§ pars String.format(§ pars Locale.US, "%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, avg/last %.2f/%.2f kilobytes per sec (stall threshold <%.2f KB/sec for %d seconds)", blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond, average / 1024.0, bytesInLastSecond / 1024.0, minSpeedBytesPerSec / 1024.0, samples.length)))

                        (§ if (§ expr average < minSpeedBytesPerSec && 0 < maxStalls))
                        (§ block
                            (§ ass maxStalls = maxStalls - 1)
                            (§ if (§ expr maxStalls == 0))
                            (§ block
                                ;; We could consider starting to drop the Bloom filtering FP rate at this point, because
                                ;; we tried a bunch of peers and no matter what we don't seem to be able to go any faster.
                                ;; This implies we're bandwidth bottlenecked and might want to start using bandwidth
                                ;; more effectively.  Of course if there's a MITM that is deliberately throttling us,
                                ;; this is a good way to make us take away all the FPs from our Bloom filters ... but
                                ;; as they don't give us a whole lot of privacy either way that's not inherently a big
                                ;; deal.
                                (§ call log.warn(§ pars "This network seems to be slower than the requested stall threshold - won't do stall disconnects any more."))
                            )
                            (§ else )
                            (§ block
                                (§ var Peer peer = getDownloadPeer(§ pars ))
                                (§ call log.warn(§ pars String.format(§ pars Locale.US, "Chain download stalled: received %.2f KB/sec for %d seconds, require average of %.2f KB/sec, disconnecting %s", average / 1024.0, samples.length, minSpeedBytesPerSec / 1024.0, peer)))
                                (§ call peer.close(§ pars ))
                                ;; Reset the sample buffer and give the next peer time to get going.
                                (§ ass samples = nil)
                                (§ ass warmupSeconds = period)
                            )
                        )
                    )
                    (§ else )
                    (§ block
                        (§ ass warmupSeconds = warmupSeconds - 1)
                        (§ if (§ expr 0 < bytesInLastSecond))
                        (§ block
                            (§ call log.info(§ pars String.format(§ pars Locale.US, "%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, last %.2f kilobytes per sec", blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond, bytesInLastSecond / 1024.0)))
                        )
                    )
                )
                (§ ass blocksInLastSecond = 0)
                (§ ass txnsInLastSecond = 0)
                (§ ass origTxnsInLastSecond = 0)
                (§ ass bytesInLastSecond = 0)
            )
        )
    )
    #_nilable
    #_private
    (§ field ChainDownloadSpeedCalculator chainDownloadSpeedCalculator)

    #_private
    (§ method void startBlockChainDownloadFromPeer(§ args Peer peer))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call setDownloadPeer(§ pars peer))

            (§ if (§ expr chainDownloadSpeedCalculator == nil))
            (§ block
                ;; Every second, run the calculator which will log how fast we are downloading the chain.
                (§ ass chainDownloadSpeedCalculator = new ChainDownloadSpeedCalculator(§ pars ))
                (§ call executor.scheduleAtFixedRate(§ pars chainDownloadSpeedCalculator, 1, 1, TimeUnit.SECONDS))
            )
            (§ call peer.addBlocksDownloadedEventListener(§ pars Threading.SAME_THREAD, chainDownloadSpeedCalculator))

            ;; startBlockChainDownload will setDownloadData(true) on itself automatically.
            (§ call peer.startBlockChainDownload(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a future that is triggered when the number of connected peers is equal to the given number of peers.
     ; By using this with {@link org.bitcoinj.core.PeerGroup#getMaxConnections()} you can wait until the
     ; network is fully online.  To block immediately, just call get() on the result.  Just calls
     ; {@link #waitForPeersOfVersion(int, long)} with zero as the protocol version.
     ;
     ; @param numPeers How many peers to wait for.
     ; @return a future that will be triggered when the number of connected peers >= numPeers.
     ;;
    #_public
    (§ method ListenableFuture<List<Peer>> waitForPeers(§ args #_final int numPeers))
    (§ block
        (§ return waitForPeersOfVersion(§ pars numPeers, 0))
    )

    ;;;
     ; Returns a future that is triggered when there are at least the requested number of connected peers that support
     ; the given protocol version or higher.  To block immediately, just call get() on the result.
     ;
     ; @param numPeers How many peers to wait for.
     ; @param protocolVersion The protocol version the awaited peers must implement (or better).
     ; @return a future that will be triggered when the number of connected peers implementing protocolVersion or higher >= numPeers.
     ;;
    #_public
    (§ method ListenableFuture<List<Peer>> waitForPeersOfVersion(§ args #_final int numPeers, #_final long protocolVersion))
    (§ block
        (§ var List<Peer> foundPeers = findPeersOfAtLeastVersion(§ pars protocolVersion))
        (§ if (§ expr numPeers <= foundPeers.size(§ pars )))
        (§ block
            (§ return Futures.immediateFuture(§ pars foundPeers))
        )

        #_final
        (§ var SettableFuture<List<Peer>> future = SettableFuture.create(§ pars ))
        (§ call addConnectedEventListener(§ pars (§ new PeerConnectedEventListener(§ pars ))
        (§ anon
            #_override
            #_public
            (§ method void onPeerConnected(§ args Peer peer, int peerCount))
            (§ block
                #_final
                (§ var List<Peer> peers = findPeersOfAtLeastVersion(§ pars protocolVersion))
                (§ if (§ expr numPeers <= peers.size(§ pars )))
                (§ block
                    (§ call future.set(§ pars peers))
                    (§ call removeConnectedEventListener(§ pars this))
                )
            )
        )))
        (§ return future)
    )

    ;;;
     ; Returns an array list of peers that implement the given protocol version or better.
     ;;
    #_public
    (§ method List<Peer> findPeersOfAtLeastVersion(§ args long protocolVersion))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var ArrayList<Peer> results = new ArrayList<Peer>(§ pars peers.size(§ pars )))
            (§ for (§ var Peer peer) :for (§ expr peers))
            (§ block
                (§ if (§ expr peer.getPeerVersionMessage(§ pars ).clientVersion >= protocolVersion))
                (§ block
                    (§ call results.add(§ pars peer))
                )
            )
            (§ return results)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a future that is triggered when there are at least the requested number of connected peers that support
     ; the given protocol version or higher.  To block immediately, just call get() on the result.
     ;
     ; @param numPeers How many peers to wait for.
     ; @param mask An integer representing a bit mask that will be ANDed with the peers advertised service masks.
     ; @return a future that will be triggered when the number of connected peers implementing protocolVersion or higher >= numPeers.
     ;;
    #_public
    (§ method ListenableFuture<List<Peer>> waitForPeersWithServiceMask(§ args #_final int numPeers, #_final int mask))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var List<Peer> foundPeers = findPeersWithServiceMask(§ pars mask))
            (§ if (§ expr numPeers <= foundPeers.size(§ pars )))
            (§ block
                (§ return Futures.immediateFuture(§ pars foundPeers))
            )

            #_final
            (§ var SettableFuture<List<Peer>> future = SettableFuture.create(§ pars ))
            (§ call addConnectedEventListener(§ pars (§ new PeerConnectedEventListener(§ pars ))
            (§ anon
                #_override
                #_public
                (§ method void onPeerConnected(§ args Peer peer, int peerCount))
                (§ block
                    #_final
                    (§ var List<Peer> peers = findPeersWithServiceMask(§ pars mask))
                    (§ if (§ expr numPeers <= peers.size(§ pars )))
                    (§ block
                        (§ call future.set(§ pars peers))
                        (§ call removeConnectedEventListener(§ pars this))
                    )
                )
            )))
            (§ return future)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns an array list of peers that match the requested service bit mask.
     ;;
    #_public
    (§ method List<Peer> findPeersWithServiceMask(§ args int mask))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var ArrayList<Peer> results = new ArrayList<Peer>(§ pars peers.size(§ pars )))
            (§ for (§ var Peer peer) :for (§ expr peers))
            (§ block
                (§ if (§ expr (§ expr peer.getPeerVersionMessage(§ pars ).localServices & mask) == mask))
                (§ block
                    (§ call results.add(§ pars peer))
                )
            )
            (§ return results)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the number of connections that are required before transactions will be broadcast.  If there aren't
     ; enough, {@link PeerGroup#broadcastTransaction(Transaction)} will wait until the minimum number is reached so
     ; propagation across the network can be observed.  If no value has been set using
     ; {@link PeerGroup#setMinBroadcastConnections(int)} a default of 80% of whatever
     ; {@link org.bitcoinj.core.PeerGroup#getMaxConnections()} returns is used.
     ;;
    #_public
    (§ method int getMinBroadcastConnections(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr minBroadcastConnections == 0))
            (§ block
                (§ var int max = getMaxConnections(§ pars ))
                (§ if (§ expr max <= 1))
                (§ block
                    (§ return max)
                )
                (§ else )
                (§ block
                    (§ return (§ cast int)Math.round(§ pars getMaxConnections(§ pars ) * 0.8))
                )
            )
            (§ return minBroadcastConnections)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; See {@link org.bitcoinj.core.PeerGroup#getMinBroadcastConnections()}.
     ;;
    #_public
    (§ method void setMinBroadcastConnections(§ args int value))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass minBroadcastConnections = value)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Calls {@link PeerGroup#broadcastTransaction(Transaction, int)} with getMinBroadcastConnections() as the number
     ; of connections to wait for before commencing broadcast.
     ;;
    #_override
    #_public
    (§ method TransactionBroadcast broadcastTransaction(§ args #_final Transaction tx))
    (§ block
        (§ return broadcastTransaction(§ pars tx, Math.max(§ pars 1, getMinBroadcastConnections(§ pars ))))
    )

    ;;;
     ; <p>Given a transaction, sends it un-announced to one peer and then waits for it to be received back from
     ; other peers.  Once all connected peers have announced the transaction, the future available via the
     ; {@link org.bitcoinj.core.TransactionBroadcast#future()} method will be completed.  If anything goes
     ; wrong the exception will be thrown when get() is called, or you can receive it via a callback on the
     ; {@link ListenableFuture}.  This method returns immediately, so if you want it to block just call get() on the
     ; result.</p>
     ;
     ; <p>Note that if the PeerGroup is limited to only one connection (discovery is not activated) then the future
     ; will complete as soon as the transaction was successfully written to that peer.</p>
     ;
     ; <p>The transaction won't be sent until there are at least minConnections active connections available.
     ; A good choice for proportion would be between 0.5 and 0.8 but if you want faster transmission during initial
     ; bringup of the peer group you can lower it.</p>
     ;
     ; <p>The returned {@link org.bitcoinj.core.TransactionBroadcast} object can be used to get progress feedback,
     ; which is calculated by watching the transaction propagate across the network and be announced by peers.</p>
     ;;
    #_public
    (§ method TransactionBroadcast broadcastTransaction(§ args #_final Transaction tx, #_final int minConnections))
    (§ block
        ;; If we don't have a record of where this tx came from already, set it to be ourselves so Peer doesn't end up
        ;; redownloading it from the network redundantly.
        (§ if (§ expr tx.getConfidence(§ pars ).getSource(§ pars ).equals(§ pars TransactionConfidence.Source.UNKNOWN)))
        (§ block
            (§ call log.info(§ pars "Transaction source unknown, setting to SELF: {}", tx.getHashAsString(§ pars )))
            (§ call tx.getConfidence(§ pars ).setSource(§ pars TransactionConfidence.Source.SELF))
        )
        #_final
        (§ var TransactionBroadcast broadcast = new TransactionBroadcast(§ pars this, tx))
        (§ call broadcast.setMinConnections(§ pars minConnections))
        ;; Send the TX to the wallet once we have a successful broadcast.
        (§ call Futures.addCallback(§ pars broadcast.future(§ pars ), new FutureCallback<Transaction>(§ pars )
        (§ anon
            #_override
            #_public
            (§ method void onSuccess(§ args Transaction transaction))
            (§ block
                (§ call runningBroadcasts.remove(§ pars broadcast))
                ;; OK, now tell the wallet about the transaction.  If the wallet created the transaction,
                ;; then it already knows and will ignore this.  If it's a transaction we received from
                ;; somebody else via a side channel and are now broadcasting, this will put it into the
                ;; wallet now we know it's valid.
                (§ for (§ var Wallet wallet) :for (§ expr wallets))
                (§ block
                    ;; Assumption here is there are no dependencies of the created transaction.
                    ;;
                    ;; We may end up with two threads trying to do this in parallel - the wallet will
                    ;; ignore whichever one loses the race.
                    (§ try )
                    (§ block
                        (§ call wallet.receivePending(§ pars transaction, nil))
                    )
                    (§ catch (§ args VerificationException e))
                    (§ block
                        (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot fail to verify a tx we created ourselves.
                    )
                )
            )

            #_override
            #_public
            (§ method void onFailure(§ args Throwable throwable))
            (§ block
                ;; This can happen if we get a reject message from a peer.
                (§ call runningBroadcasts.remove(§ pars broadcast))
            )
        )))
        ;; Keep a reference to the TransactionBroadcast object.  This is important because otherwise, the entire tree
        ;; of objects we just created would become garbage if the user doesn't hold on to the returned future, and
        ;; eventually be collected.  This in turn could result in the transaction not being committed to the wallet
        ;; at all.
        (§ call runningBroadcasts.add(§ pars broadcast))
        (§ call broadcast.broadcast(§ pars ))
        (§ return broadcast)
    )

    ;;;
     ; Returns the period between pings for an individual peer.  Setting this lower means more accurate and timely
     ; ping times are available via {@link org.bitcoinj.core.Peer#getLastPingTime()} but it increases load on the
     ; remote node.  It defaults to {@link PeerGroup#DEFAULT_PING_INTERVAL_MSEC}.
     ;;
    #_public
    (§ method long getPingIntervalMsec(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return pingIntervalMsec)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Sets the period between pings for an individual peer.  Setting this lower means more accurate and timely
     ; ping times are available via {@link org.bitcoinj.core.Peer#getLastPingTime()} but it increases load on the
     ; remote node.  It defaults to {@link PeerGroup#DEFAULT_PING_INTERVAL_MSEC}.
     ; Setting the value to be <= 0 disables pinging entirely, although you can still request one yourself
     ; using {@link org.bitcoinj.core.Peer#ping()}.
     ;;
    #_public
    (§ method void setPingIntervalMsec(§ args long pingIntervalMsec))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass this.pingIntervalMsec = pingIntervalMsec)
            (§ var ListenableScheduledFuture<?> task = vPingTask)
            (§ if (§ expr task != nil))
            (§ block
                (§ call task.cancel(§ pars false))
            )
            (§ call setupPinging(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; If a peer is connected to that claims to speak a protocol version lower than the given version, it will
     ; be disconnected and another one will be tried instead.
     ;;
    #_public
    (§ method void setMinRequiredProtocolVersion(§ args int minRequiredProtocolVersion))
    (§ block
        (§ ass this.vMinRequiredProtocolVersion = minRequiredProtocolVersion)
    )

    ;;; The minimum protocol version required: defaults to the version required for Bloom filtering. ;;
    #_public
    (§ method int getMinRequiredProtocolVersion(§ args ))
    (§ block
        (§ return vMinRequiredProtocolVersion)
    )

    ;;;
     ; Returns our peers most commonly reported chain height.  If multiple heights are tied, the highest is returned.
     ; If no peers are connected, returns zero.
     ;;
    #_public
    (§ method int getMostCommonChainHeight(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return getMostCommonChainHeight(§ pars this.peers))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns most commonly reported chain height from the given list of {@link Peer}s.
     ; If multiple heights are tied, the highest is returned.  If no peers are connected, returns zero.
     ;;
    #_public
    #_static
    (§ method int getMostCommonChainHeight(§ args #_final List<Peer> peers))
    (§ block
        (§ if (§ expr peers.isEmpty(§ pars )))
        (§ block
            (§ return 0)
        )

        (§ var List<Integer> heights = new ArrayList<>(§ pars peers.size(§ pars )))
        (§ for (§ var Peer peer) :for (§ expr peers))
        (§ block
            (§ call heights.add(§ pars (§ cast int)peer.getBestHeight(§ pars )))
        )
        (§ return Utils.maxOfMostFreq(§ pars heights))
    )

    ;;;
     ; Given a list of Peers, return a Peer to be used as the download peer.  If you don't want PeerGroup to manage
     ; download peer statuses for you, just override this and always return null.
     ;;
    #_nilable
    #_protected
    (§ method Peer selectDownloadPeer(§ args List<Peer> peers))
    (§ block
        ;; Characteristics to select for in order of importance:
        ;;  - Chain height is reasonable (majority of nodes).
        ;;  - High enough protocol version for the features we want (but we'll settle for less).
        ;;  - Randomly, to try and spread the load.
        (§ if (§ expr peers.isEmpty(§ pars )))
        (§ block
            (§ return nil)
        )

        ;; Make sure we don't select a peer that is behind/synchronizing itself.
        (§ var int mostCommonChainHeight = getMostCommonChainHeight(§ pars peers))
        (§ var List<Peer> candidates = new ArrayList<>(§ pars ))
        (§ for (§ var Peer peer) :for (§ expr peers))
        (§ block
            (§ if (§ expr peer.getBestHeight(§ pars ) == mostCommonChainHeight))
            (§ block
                (§ call candidates.add(§ pars peer))
            )
        )

        ;; Of the candidates, find the peers that meet the minimum protocol version we want to target.  We could select
        ;; the highest version we've seen on the assumption that newer versions are always better but we don't want to
        ;; zap peers if they upgrade early.  If we can't find any peers that have our preferred protocol version or
        ;; better then we'll settle for the highest we found instead.
        (§ var int highestVersion = 0, preferredVersion = 0)

        ;; if/when PREFERRED_VERSION is not equal to vMinRequiredProtocolVersion, reenable the last test in PeerGroupTest.downloadPeerSelection
        #_final
        (§ var int PREFERRED_VERSION = params.getProtocolVersionNum(§ pars NetworkParameters.ProtocolVersion.BLOOM_FILTER))
        (§ for (§ var Peer peer) :for (§ expr candidates))
        (§ block
            (§ ass highestVersion = Math.max(§ pars peer.getPeerVersionMessage(§ pars ).clientVersion, highestVersion))
            (§ ass preferredVersion = Math.min(§ pars highestVersion, PREFERRED_VERSION))
        )
        (§ var ArrayList<Peer> candidates2 = new ArrayList<>(§ pars candidates.size(§ pars )))
        (§ for (§ var Peer peer) :for (§ expr candidates))
        (§ block
            (§ if (§ expr preferredVersion <= peer.getPeerVersionMessage(§ pars ).clientVersion))
            (§ block
                (§ call candidates2.add(§ pars peer))
            )
        )
        (§ var int index = (§ cast int)(§ expr Math.random(§ pars ) * candidates2.size(§ pars )))
        (§ return candidates2.get(§ pars index))
    )

    ;;;
     ; Returns the currently selected download peer.  Bear in mind that it may have changed as soon as this method
     ; returns.  Can return null if no peer was selected.
     ;;
    #_public
    (§ method Peer getDownloadPeer(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return downloadPeer)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the maximum number of {@link Peer}s to discover.  This maximum is checked after
     ; each {@link PeerDiscovery} so this max number can be surpassed.
     ; @return the maximum number of peers to discover.
     ;;
    #_public
    (§ method int getMaxPeersToDiscoverCount(§ args ))
    (§ block
        (§ return vMaxPeersToDiscoverCount)
    )

    ;;;
     ; Sets the maximum number of {@link Peer}s to discover.  This maximum is checked after
     ; each {@link PeerDiscovery} so this max number can be surpassed.
     ; @param maxPeersToDiscoverCount the maximum number of peers to discover.
     ;;
    #_public
    (§ method void setMaxPeersToDiscoverCount(§ args int maxPeersToDiscoverCount))
    (§ block
        (§ ass this.vMaxPeersToDiscoverCount = maxPeersToDiscoverCount)
    )

    ;;; See {@link #setUseLocalhostPeerWhenPossible(boolean)}. ;;
    #_public
    (§ method boolean getUseLocalhostPeerWhenPossible(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return useLocalhostPeerWhenPossible)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; When true (the default), PeerGroup will attempt to connect to a Bitcoin node running on localhost before
     ; attempting to use the P2P network.  If successful, only localhost will be used.  This makes for a simple
     ; and easy way for a user to upgrade a bitcoinj based app running in SPV mode to fully validating security.
     ;;
    #_public
    (§ method void setUseLocalhostPeerWhenPossible(§ args boolean useLocalhostPeerWhenPossible))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass this.useLocalhostPeerWhenPossible = useLocalhostPeerWhenPossible)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_public
    (§ method boolean isRunning(§ args ))
    (§ block
        (§ return vRunning)
    )

    ;;;
     ; Can be used to disable Bloom filtering entirely, even in SPV mode.  You are very unlikely to need this, it is
     ; an optimisation for rare cases when full validation is not required but it's still more efficient to download
     ; full blocks than filtered blocks.
     ;;
    #_public
    (§ method void setBloomFilteringEnabled(§ args boolean bloomFilteringEnabled))
    (§ block
        (§ ass this.vBloomFilteringEnabled = bloomFilteringEnabled)
    )

    ;;; Returns whether the Bloom filtering protocol optimisation is in use: defaults to true. ;;
    #_public
    (§ method boolean isBloomFilteringEnabled(§ args ))
    (§ block
        (§ return vBloomFilteringEnabled)
    )
)

#_(ns org.bitcoinj.core #_"PeerSocketHandler"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.net ConnectException InetSocketAddress]
             [java.nio BufferUnderflowException ByteBuffer]
             [java.nio.channels NotYetConnectedException]
             [java.util.concurrent.locks Lock])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.net AbstractTimeoutHandler MessageWriteTarget StreamConnection]
             [org.bitcoinj.utils Threading]))

;;;
 ; Handles high-level message (de)serialization for peers, acting as the bridge between the
 ; {@link org.bitcoinj.net} classes and {@link Peer}.
 ;;
#_public
#_abstract
(§ class PeerSocketHandler extends AbstractTimeoutHandler implements StreamConnection
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars PeerSocketHandler.class))

    #_private
    #_final
    (§ field MessageSerializer serializer)
    #_protected
    (§ field PeerAddress peerAddress)
    ;; If we close() before we know our writeTarget, set this to true to call writeTarget.closeConnection() right away.
    #_private
    (§ field boolean closePending)
    ;; writeTarget will be thread-safe, and may call into PeerGroup, which calls us, so we should call it unlocked.
    #_testing
    #_protected
    (§ field MessageWriteTarget writeTarget)

    ;; The ByteBuffers passed to us from the writeTarget are static in size, and usually smaller than some messages we
    ;; will receive.  For SPV clients, this should be rare (i.e. we're mostly dealing with small transactions), but for
    ;; messages which are larger than the read buffer, we have to keep a temporary buffer with its bytes.
    #_private
    (§ field byte[] largeReadBuffer)
    #_private
    (§ field int largeReadBufferPos)
    #_private
    (§ field BitcoinSerializer.BitcoinPacketHeader header)

    #_private
    (§ field Lock lock = Threading.lock(§ pars "PeerSocketHandler"))

    #_public
    (§ constructor PeerSocketHandler(§ args NetworkParameters params, InetSocketAddress remoteIp))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars params))
        (§ ass serializer = params.getDefaultSerializer(§ pars ))
        (§ ass this.peerAddress = new PeerAddress(§ pars params, remoteIp))
    )

    #_public
    (§ constructor PeerSocketHandler(§ args NetworkParameters params, PeerAddress peerAddress))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars params))
        (§ ass serializer = params.getDefaultSerializer(§ pars ))
        (§ ass this.peerAddress = Preconditions.checkNotNull(§ pars peerAddress))
    )

    ;;;
     ; Sends the given message to the peer.  Due to the asynchronousness of network programming, there is no guarantee
     ; the peer will have received it.  Throws NotYetConnectedException if we are not yet connected to the remote peer.
     ; TODO: Maybe use something other than the unchecked NotYetConnectedException here.
     ;;
    #_public
    (§ method void sendMessage(§ args Message message))
        (§ throws NotYetConnectedException)
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr writeTarget == nil))
            (§ block
                (§ throw (§ new NotYetConnectedException(§ pars )))
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
        ;; TODO: Some round-tripping could be avoided here.
        (§ var ByteArrayOutputStream out = new ByteArrayOutputStream(§ pars ))
        (§ try )
        (§ block
            (§ call serializer.serialize(§ pars message, out))
            (§ call writeTarget.writeBytes(§ pars out.toByteArray(§ pars )))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ call exceptionCaught(§ pars e))
        )
    )

    ;;;
     ; Closes the connection to the peer if one exists, or immediately closes the connection as soon as it opens.
     ;;
    #_public
    (§ method void close(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr writeTarget == nil))
            (§ block
                (§ ass closePending = true)
                (§ return )
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
        (§ call writeTarget.closeConnection(§ pars ))
    )

    #_override
    #_protected
    (§ method void timeoutOccurred(§ args ))
    (§ block
        (§ call log.info(§ pars "{}: Timed out", getAddress(§ pars )))
        (§ call close(§ pars ))
    )

    ;;;
     ; Called every time a message is received from the network.
     ;;
    #_protected
    #_abstract
    (§ method void processMessage(§ args Message m))
        (§ throws Exception)

    #_override
    #_public
    (§ method int receiveBytes(§ args ByteBuffer buff))
    (§ block
        (§ call Preconditions.checkArgument(§ pars buff.position(§ pars ) == 0 && BitcoinSerializer.BitcoinPacketHeader.HEADER_LENGTH + 4 <= buff.capacity(§ pars )))
        (§ try )
        (§ block
            ;; Repeatedly try to deserialize messages until we hit a BufferUnderflowException.
            (§ var boolean firstMessage = true)
            (§ while (§ expr true))
            (§ block
                ;; If we are in the middle of reading a message, try to fill that one first, before we expect another.
                (§ if (§ expr largeReadBuffer != nil))
                (§ block
                    ;; This can only happen in the first iteration.
                    (§ call Preconditions.checkState(§ pars firstMessage))
                    ;; Read new bytes into the largeReadBuffer.
                    (§ var int bytesToGet = Math.min(§ pars buff.remaining(§ pars ), largeReadBuffer.length - largeReadBufferPos))
                    (§ call buff.get(§ pars largeReadBuffer, largeReadBufferPos, bytesToGet))
                    (§ ass largeReadBufferPos = largeReadBufferPos + bytesToGet)
                    ;; Check the largeReadBuffer's status.
                    (§ if (§ expr largeReadBufferPos == largeReadBuffer.length))
                    (§ block
                        ;; ...processing a message if one is available.
                        (§ call processMessage(§ pars serializer.deserializePayload(§ pars header, ByteBuffer.wrap(§ pars largeReadBuffer))))
                        (§ ass largeReadBuffer = nil)
                        (§ ass header = nil)
                        (§ ass firstMessage = false)
                    )
                    (§ else ) ;; ...or just returning if we don't have enough bytes yet.
                    (§ block
                        (§ return buff.position(§ pars ))
                    )
                )
                ;; Now try to deserialize any messages left in buff.
                (§ var Message message)
                (§ var int preSerializePosition = buff.position(§ pars ))
                (§ try )
                (§ block
                    (§ ass message = serializer.deserialize(§ pars buff))
                )
                (§ catch (§ args BufferUnderflowException e))
                (§ block
                    ;; If we went through the whole buffer without a full message, we need to use the largeReadBuffer.
                    (§ if (§ expr firstMessage && buff.limit(§ pars ) == buff.capacity(§ pars )))
                    (§ block
                        ;; ...so reposition the buffer to 0 and read the next message header.
                        (§ call buff.position(§ pars 0))
                        (§ try )
                        (§ block
                            (§ call serializer.seekPastMagicBytes(§ pars buff))
                            (§ ass header = serializer.deserializeHeader(§ pars buff))
                            ;; Initialize the largeReadBuffer with the next message's size and fill it with any bytes left in buff.
                            (§ ass largeReadBuffer = new byte[header.size])
                            (§ ass largeReadBufferPos = buff.remaining(§ pars ))
                            (§ call buff.get(§ pars largeReadBuffer, 0, largeReadBufferPos))
                        )
                        (§ catch (§ args BufferUnderflowException e1))
                        (§ block
                            ;; If we went through a whole buffer's worth of bytes without getting a header, give up.
                            ;; In cases where the buff is just really small, we could create a second largeReadBuffer
                            ;; that we use to deserialize the magic+header, but that is rather complicated when the buff
                            ;; should probably be at least that big anyway (for efficiency).
                            (§ throw (§ new ProtocolException(§ pars "No magic bytes+header after reading " + buff.capacity(§ pars ) + " bytes")))
                        )
                    )
                    (§ else )
                    (§ block
                        ;; Reposition the buffer to its original position, which saves us from skipping messages by
                        ;; seeking past part of the magic bytes before all of them are in the buffer.
                        (§ call buff.position(§ pars preSerializePosition))
                    )
                    (§ return buff.position(§ pars ))
                )
                ;; Process our freshly deserialized message.
                (§ call processMessage(§ pars message))
                (§ ass firstMessage = false)
            )
        )
        (§ catch (§ args Exception e))
        (§ block
            (§ call exceptionCaught(§ pars e))
            ;; Returning -1 also throws an IllegalStateException upstream and kills the connection.
            (§ return -1)
        )
    )

    ;;;
     ; Sets the {@link MessageWriteTarget} used to write messages to the peer.  This should almost never be called,
     ; it is called automatically by {@link org.bitcoinj.net.NioClient} or
     ; {@link org.bitcoinj.net.NioClientManager} once the socket finishes initialization.
     ;;
    #_override
    #_public
    (§ method void setWriteTarget(§ args MessageWriteTarget writeTarget))
    (§ block
        (§ call Preconditions.checkArgument(§ pars writeTarget != nil))

        (§ call lock.lock(§ pars ))
        (§ var boolean closeNow = false)
        (§ try )
        (§ block
            (§ call Preconditions.checkArgument(§ pars this.writeTarget == nil))

            (§ ass closeNow = closePending)
            (§ ass this.writeTarget = writeTarget)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
        (§ if (§ expr closeNow))
        (§ block
            (§ call writeTarget.closeConnection(§ pars ))
        )
    )

    #_override
    #_public
    (§ method int getMaxMessageSize(§ args ))
    (§ block
        (§ return Message.MAX_SIZE)
    )

    ;;;
     ; @return the IP address and port of peer.
     ;;
    #_public
    (§ method PeerAddress getAddress(§ args ))
    (§ block
        (§ return peerAddress)
    )

    ;;; Catch any exceptions, logging them and then closing the channel. ;;
    #_private
    (§ method void exceptionCaught(§ args Exception e))
    (§ block
        (§ var PeerAddress addr = getAddress(§ pars ))
        (§ var String s = (§ quest (§ expr addr == nil) ? "?" :else addr.toString(§ pars )))
        (§ if (§ expr e instanceof ConnectException || e instanceof IOException))
        (§ block
            ;; Short message for network errors
            (§ call log.info(§ pars s + " - " + e.getMessage(§ pars )))
        )
        (§ else )
        (§ block
            (§ call log.warn(§ pars s + " - ", e))
            (§ var Thread.UncaughtExceptionHandler handler = Threading.uncaughtExceptionHandler)
            (§ if (§ expr handler != nil))
            (§ block
                (§ call handler.uncaughtException(§ pars Thread.currentThread(§ pars ), e))
            )
        )

        (§ call close(§ pars ))
    )
)

#_(ns org.bitcoinj.core #_"Ping"
    (:import [java.io IOException OutputStream]))

;;;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class Ping extends Message
    #_private
    (§ field long nonce)
    #_private
    (§ field boolean hasNonce)

    #_public
    (§ constructor Ping(§ args NetworkParameters params, byte[] payloadBytes))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payloadBytes, 0))
    )

    ;;;
     ; Create a Ping with a nonce value.
     ; Only use this if the remote node has a protocol version > 60000.
     ;;
    #_public
    (§ constructor Ping(§ args long nonce))
    (§ block
        (§ ass this.nonce = nonce)
        (§ ass this.hasNonce = true)
    )

    ;;;
     ; Create a Ping without a nonce value.
     ; Only use this if the remote node has a protocol version <= 60000.
     ;;
    #_public
    (§ constructor Ping(§ args ))
    (§ block
        (§ ass this.hasNonce = false)
    )

    #_override
    #_public
    (§ method void bitcoinSerializeToStream(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ if (§ expr hasNonce))
        (§ block
            (§ call Utils.int64ToByteStreamLE(§ pars nonce, stream))
        )
    )

    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ try )
        (§ block
            (§ ass nonce = readInt64(§ pars ))
            (§ ass hasNonce = true)
        )
        (§ catch (§ args ProtocolException e))
        (§ block
            (§ ass hasNonce = false)
        )
        (§ ass length = hasNonce ? 8 :else 0)
    )

    #_public
    (§ method boolean hasNonce(§ args ))
    (§ block
        (§ return hasNonce)
    )

    #_public
    (§ method long getNonce(§ args ))
    (§ block
        (§ return nonce)
    )
)

#_(ns org.bitcoinj.core #_"Pong"
    (:import [java.io IOException OutputStream]))

;;;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class Pong extends Message
    #_private
    (§ field long nonce)

    #_public
    (§ constructor Pong(§ args NetworkParameters params, byte[] payloadBytes))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payloadBytes, 0))
    )

    ;;;
     ; Create a Pong with a nonce value.
     ; Only use this if the remote node has a protocol version > 60000.
     ;;
    #_public
    (§ constructor Pong(§ args long nonce))
    (§ block
        (§ ass this.nonce = nonce)
    )

    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ ass nonce = readInt64(§ pars ))
        (§ ass length = 8)
    )

    #_override
    #_public
    (§ method void bitcoinSerializeToStream(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ call Utils.int64ToByteStreamLE(§ pars nonce, stream))
    )

    ;;; Returns the nonce sent by the remote peer. ;;
    #_public
    (§ method long getNonce(§ args ))
    (§ block
        (§ return nonce)
    )
)

#_(ns org.bitcoinj.core #_"ProtocolException")

#_public
(§ class ProtocolException extends VerificationException
    #_public
    (§ constructor ProtocolException(§ args String msg))
    (§ block
        (§ super (§ pars msg))
    )

    #_public
    (§ constructor ProtocolException(§ args Exception e))
    (§ block
        (§ super (§ pars e))
    )

    #_public
    (§ constructor ProtocolException(§ args String msg, Exception e))
    (§ block
        (§ super (§ pars msg, e))
    )
)

#_(ns org.bitcoinj.core #_"PrunedException")

;; TODO: Rename PrunedException to something like RequiredDataWasPrunedException.

;;;
 ; PrunedException is thrown in cases where a fully verifying node has deleted (pruned) old block data that turned
 ; out to be necessary for handling a re-org.  Normally this should never happen unless you're playing with the testnet
 ; as the pruning parameters should be set very conservatively, such that an absolutely enormous re-org would be
 ; required to trigger it.
 ;;
#_public
(§ class PrunedException extends Exception
    #_private
    (§ field Sha256Hash hash)

    #_public
    (§ constructor PrunedException(§ args Sha256Hash hash))
    (§ block
        (§ super (§ pars hash.toString(§ pars )))

        (§ ass this.hash = hash)
    )

    #_public
    (§ method Sha256Hash getHash(§ args ))
    (§ block
        (§ return hash)
    )
)

#_(ns org.bitcoinj.core #_"RejectMessage"
    (:import [java.io IOException OutputStream]
             [java.util Locale])
    (:import [com.google.common.base Objects]))

;;;
 ; <p>A message sent by nodes when a message we sent was rejected (i.e. a transaction had too little fee/was invalid/etc).</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class RejectMessage extends Message
    #_private
    (§ field String message, reason)

    #_public
    (§ enum RejectCode
        ;;; The message was not able to be parsed. ;;
        (§ item MALFORMED(§ pars (§ cast byte)0x01))
        ;;; The message described an invalid object. ;;
        (§ item INVALID(§ pars (§ cast byte)0x10))
        ;;; The message was obsolete or described an object which is obsolete (e.g. unsupported, old version, v1 block). ;;
        (§ item OBSOLETE(§ pars (§ cast byte)0x11))
        ;;;
         ; The message was relayed multiple times or described an object which is in conflict with another.
         ; This message can describe errors in protocol implementation or the presence of an attempt to DOUBLE SPEND.
         ;;
        (§ item DUPLICATE(§ pars (§ cast byte)0x12))
        ;;;
         ; The message described an object was not standard and was thus not accepted.
         ; Bitcoin Core has a concept of standard transaction forms, which describe scripts and encodings which
         ; it is willing to relay further.  Other transactions are neither relayed nor mined, though they are considered
         ; valid if they appear in a block.
         ;;
        (§ item NONSTANDARD(§ pars (§ cast byte)0x40))
        ;;;
         ; This refers to a specific form of NONSTANDARD transactions, which have an output smaller than some constant
         ; defining them as dust (this is no longer used).
         ;;
        (§ item DUST(§ pars (§ cast byte)0x41))
        ;;; The messages described an object which did not have sufficient fee to be relayed further. ;;
        (§ item INSUFFICIENTFEE(§ pars (§ cast byte)0x42))
        ;;; The message described a block which was invalid according to hard-coded checkpoint blocks. ;;
        (§ item CHECKPOINT(§ pars (§ cast byte)0x43))
        (§ item OTHER(§ pars (§ cast byte)0xff))

        (§ var byte code)

        (§ constructor RejectCode(§ args byte code))
        (§ block
            (§ ass this.code = code)
        )

        #_static
        (§ method RejectCode fromCode(§ args byte code))
        (§ block
            (§ for (§ var RejectCode rejectCode) :for (§ expr RejectCode.values(§ pars )))
            (§ block
                (§ if (§ expr rejectCode.code == code))
                (§ block
                    (§ return rejectCode)
                )
            )

            (§ return OTHER)
        )
    )

    #_private
    (§ field RejectCode code)
    #_private
    (§ field Sha256Hash messageHash)

    #_public
    (§ constructor RejectMessage(§ args NetworkParameters params, byte[] payload))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, 0))
    )

    ;;; Constructs a reject message that fingers the object with the given hash as rejected for the given reason. ;;
    #_public
    (§ constructor RejectMessage(§ args NetworkParameters params, RejectCode code, Sha256Hash hash, String message, String reason))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params))

        (§ ass this.code = code)
        (§ ass this.messageHash = hash)
        (§ ass this.message = message)
        (§ ass this.reason = reason)
    )

    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ ass message = readStr(§ pars ))
        (§ ass code = RejectCode.fromCode(§ pars readBytes(§ pars 1)[0]))
        (§ ass reason = readStr(§ pars ))
        (§ if (§ expr message.equals(§ pars "block") || message.equals(§ pars "tx")))
        (§ block
            (§ ass messageHash = readHash(§ pars ))
        )
        (§ ass length = cursor - offset)
    )

    #_override
    #_public
    (§ method void bitcoinSerializeToStream(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ var byte[] messageBytes = message.getBytes(§ pars "UTF-8"))
        (§ call stream.write(§ pars (§ new VarInt(§ pars messageBytes.length)).encode(§ pars )))
        (§ call stream.write(§ pars messageBytes))
        (§ call stream.write(§ pars code.code))
        (§ var byte[] reasonBytes = reason.getBytes(§ pars "UTF-8"))
        (§ call stream.write(§ pars (§ new VarInt(§ pars reasonBytes.length)).encode(§ pars )))
        (§ call stream.write(§ pars reasonBytes))
        (§ if (§ expr "block".equals(§ pars message) || "tx".equals(§ pars message)))
        (§ block
            (§ call stream.write(§ pars messageHash.getReversedBytes(§ pars )))
        )
    )

    ;;;
     ; Provides the type of message which was rejected by the peer.
     ; Note that this is ENTIRELY UNTRUSTED and should be sanity-checked before it is printed or processed.
     ;;
    #_public
    (§ method String getRejectedMessage(§ args ))
    (§ block
        (§ return message)
    )

    ;;;
     ; Provides the hash of the rejected object (if getRejectedMessage() is either "tx" or "block"), otherwise null.
     ;;
    #_public
    (§ method Sha256Hash getRejectedObjectHash(§ args ))
    (§ block
        (§ return messageHash)
    )

    ;;;
     ; The reason code given for why the peer rejected the message.
     ;;
    #_public
    (§ method RejectCode getReasonCode(§ args ))
    (§ block
        (§ return code)
    )

    ;;;
     ; The reason message given for rejection.
     ; Note that this is ENTIRELY UNTRUSTED and should be sanity-checked before it is printed or processed.
     ;;
    #_public
    (§ method String getReasonString(§ args ))
    (§ block
        (§ return reason)
    )

    ;;;
     ; A String representation of the relevant details of this reject message.
     ; Be aware that the value returned by this method includes the value returned by
     ; {@link #getReasonString() getReasonString}, which is taken from the reject message unchecked.
     ; Through malice or otherwise, it might contain control characters or other harmful content.
     ;;
    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ var Sha256Hash hash = getRejectedObjectHash(§ pars ))
        (§ return String.format(§ pars Locale.US, "Reject: %s %s for reason '%s' (%d)", getRejectedMessage(§ pars ), (§ expr hash != nil) ? hash) :for (§ expr "", getReasonString(§ pars ), getReasonCode(§ pars ).code))
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var RejectMessage other = (§ cast RejectMessage)o)
        (§ return (§ expr message.equals(§ pars other.message) && code.equals(§ pars other.code) && reason.equals(§ pars other.reason) && messageHash.equals(§ pars other.messageHash)))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars message, code, reason, messageHash))
    )
)

#_(ns org.bitcoinj.core #_"RejectedTransactionException")

;;;
 ; This exception is used by the TransactionBroadcast class to indicate that a broadcast
 ; Transaction has been rejected by the network, for example because it violates a
 ; protocol rule.  Note that not all invalid transactions generate a reject message, and
 ; some peers may never do so.
 ;;
#_public
(§ class RejectedTransactionException extends Exception
    #_private
    (§ field Transaction tx)
    #_private
    (§ field RejectMessage rejectMessage)

    #_public
    (§ constructor RejectedTransactionException(§ args Transaction tx, RejectMessage rejectMessage))
    (§ block
        (§ super (§ pars rejectMessage.toString(§ pars )))

        (§ ass this.tx = tx)
        (§ ass this.rejectMessage = rejectMessage)
    )

    ;;; Return the original Transaction object whose broadcast was rejected. ;;
    #_public
    (§ method Transaction getTransaction(§ args ))
    (§ block
        (§ return tx)
    )

    ;;; Return the RejectMessage object representing the broadcast rejection. ;;
    #_public
    (§ method RejectMessage getRejectMessage(§ args ))
    (§ block
        (§ return rejectMessage)
    )
)

#_(ns org.bitcoinj.core #_"ScriptException"
   (:require [org.bitcoinj.script ScriptError]))

#_public
(§ class ScriptException extends VerificationException
    #_private
    #_final
    (§ field ScriptError err)

    #_public
    (§ constructor ScriptException(§ args ScriptError err, String msg))
    (§ block
        (§ super (§ pars msg))
        (§ ass this.err = err)
    )

    #_public
    (§ constructor ScriptException(§ args ScriptError err, String msg, Exception e))
    (§ block
        (§ super (§ pars msg, e))
        (§ ass this.err = err)
    )

    #_public
    (§ method ScriptError getError(§ args ))
    (§ block
        (§ return err)
    )
)

#_(ns org.bitcoinj.core #_"Sha256Hash"
    (:import [java.io File FileInputStream IOException Serializable]
             [java.math BigInteger]
             [java.security MessageDigest NoSuchAlgorithmException]
             [java.util Arrays])
    (:import [com.google.common.base Preconditions]
             [com.google.common.io ByteStreams]
             [com.google.common.primitives *]))

;;;
 ; A Sha256Hash just wraps a byte[] so that equals and hashcode work correctly,
 ; allowing it to be used as keys in a map.
 ; It also checks that the length is correct and provides a bit more type safety.
 ;;
#_public
(§ class Sha256Hash implements Serializable, Comparable<Sha256Hash>
    #_public
    #_static
    #_final
    (§ field int LENGTH = 32) ;; bytes
    #_public
    #_static
    #_final
    (§ field Sha256Hash ZERO_HASH = wrap(§ pars new byte[LENGTH]))

    #_private
    #_final
    (§ field byte[] bytes)

    ;;;
     ; Use {@link #wrap(byte[])} instead.
     ;;
    #_protected
    (§ constructor Sha256Hash(§ args byte[] rawHashBytes))
    (§ block
        (§ call Preconditions.checkArgument(§ pars rawHashBytes.length == LENGTH))
        (§ ass this.bytes = rawHashBytes)
    )

    ;;;
     ; Creates a new instance that wraps the given hash value.
     ;
     ; @param rawHashBytes The raw hash bytes to wrap.
     ; @return a new instance.
     ; @throws IllegalArgumentException if the given array length is not exactly 32.
     ;;
    #_public
    #_static
    (§ method Sha256Hash wrap(§ args byte[] rawHashBytes))
    (§ block
        (§ return (§ new Sha256Hash(§ pars rawHashBytes)))
    )

    ;;;
     ; Creates a new instance that wraps the given hash value (represented as a hex string).
     ;
     ; @param hexString A hash value represented as a hex string.
     ; @return a new instance.
     ; @throws IllegalArgumentException if the given string is not a valid hex string, or if it does not represent exactly 32 bytes.
     ;;
    #_public
    #_static
    (§ method Sha256Hash wrap(§ args String hexString))
    (§ block
        (§ return wrap(§ pars Utils.HEX.decode(§ pars hexString)))
    )

    ;;;
     ; Creates a new instance that wraps the given hash value, but with byte order reversed.
     ;
     ; @param rawHashBytes The raw hash bytes to wrap.
     ; @return a new instance.
     ; @throws IllegalArgumentException if the given array length is not exactly 32.
     ;;
    #_public
    #_static
    (§ method Sha256Hash wrapReversed(§ args byte[] rawHashBytes))
    (§ block
        (§ return wrap(§ pars Utils.reverseBytes(§ pars rawHashBytes)))
    )

    ;;;
     ; Creates a new instance containing the calculated (one-time) hash of the given bytes.
     ;
     ; @param contents The bytes on which the hash value is calculated.
     ; @return a new instance containing the calculated (one-time) hash.
     ;;
    #_public
    #_static
    (§ method Sha256Hash of(§ args byte[] contents))
    (§ block
        (§ return wrap(§ pars hash(§ pars contents)))
    )

    ;;;
     ; Creates a new instance containing the hash of the calculated hash of the given bytes.
     ;
     ; @param contents The bytes on which the hash value is calculated.
     ; @return a new instance containing the calculated (two-time) hash.
     ;;
    #_public
    #_static
    (§ method Sha256Hash twiceOf(§ args byte[] contents))
    (§ block
        (§ return wrap(§ pars hashTwice(§ pars contents)))
    )

    ;;;
     ; Creates a new instance containing the calculated (one-time) hash of the given file's contents.
     ;
     ; The file contents are read fully into memory, so this method should only be used with small files.
     ;
     ; @param file The file on which the hash value is calculated.
     ; @return a new instance containing the calculated (one-time) hash.
     ; @throws IOException if an error occurs while reading the file.
     ;;
    #_public
    #_static
    (§ method Sha256Hash of(§ args File file))
        (§ throws IOException)
    (§ block
        (§ var FileInputStream in = new FileInputStream(§ pars file))
        (§ try )
        (§ block
            (§ return of(§ pars ByteStreams.toByteArray(§ pars in)))
        )
        (§ finally )
        (§ block
            (§ call in.close(§ pars ))
        )
    )

    ;;;
     ; Returns a new SHA-256 MessageDigest instance.
     ;
     ; This is a convenience method which wraps the checked
     ; exception that can never occur with a RuntimeException.
     ;
     ; @return a new SHA-256 MessageDigest instance.
     ;;
    #_public
    #_static
    (§ method MessageDigest newDigest(§ args ))
    (§ block
        (§ try )
        (§ block
            (§ return MessageDigest.getInstance(§ pars "SHA-256"))
        )
        (§ catch (§ args NoSuchAlgorithmException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Can't happen.
        )
    )

    ;;;
     ; Calculates the SHA-256 hash of the given bytes.
     ;
     ; @param input The bytes to hash.
     ; @return the hash (in big-endian order).
     ;;
    #_public
    #_static
    (§ method byte[] hash(§ args byte[] input))
    (§ block
        (§ return hash(§ pars input, 0, input.length))
    )

    ;;;
     ; Calculates the SHA-256 hash of the given byte range.
     ;
     ; @param input The array containing the bytes to hash.
     ; @param offset The offset within the array of the bytes to hash.
     ; @param length The number of bytes to hash.
     ; @return the hash (in big-endian order).
     ;;
    #_public
    #_static
    (§ method byte[] hash(§ args byte[] input, int offset, int length))
    (§ block
        (§ var MessageDigest digest = newDigest(§ pars ))
        (§ call digest.update(§ pars input, offset, length))
        (§ return digest.digest(§ pars ))
    )

    ;;;
     ; Calculates the SHA-256 hash of the given bytes,
     ; and then hashes the resulting hash again.
     ;
     ; @param input The bytes to hash.
     ; @return the double-hash (in big-endian order).
     ;;
    #_public
    #_static
    (§ method byte[] hashTwice(§ args byte[] input))
    (§ block
        (§ return hashTwice(§ pars input, 0, input.length))
    )

    ;;;
     ; Calculates the SHA-256 hash of the given byte range,
     ; and then hashes the resulting hash again.
     ;
     ; @param input The array containing the bytes to hash.
     ; @param offset The offset within the array of the bytes to hash.
     ; @param length The number of bytes to hash.
     ; @return the double-hash (in big-endian order).
     ;;
    #_public
    #_static
    (§ method byte[] hashTwice(§ args byte[] input, int offset, int length))
    (§ block
        (§ var MessageDigest digest = newDigest(§ pars ))
        (§ call digest.update(§ pars input, offset, length))
        (§ return digest.digest(§ pars digest.digest(§ pars )))
    )

    ;;;
     ; Calculates the hash of hash on the given byte ranges.  This is equivalent to
     ; concatenating the two ranges and then passing the result to {@link #hashTwice(byte[])}.
     ;;
    #_public
    #_static
    (§ method byte[] hashTwice(§ args byte[] input1, int offset1, int length1, byte[] input2, int offset2, int length2))
    (§ block
        (§ var MessageDigest digest = newDigest(§ pars ))
        (§ call digest.update(§ pars input1, offset1, length1))
        (§ call digest.update(§ pars input2, offset2, length2))
        (§ return digest.digest(§ pars digest.digest(§ pars )))
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return Arrays.equals(§ pars bytes, (§ expr (§ cast Sha256Hash)o).bytes))
    )

    ;;;
     ; Returns the last four bytes of the wrapped hash.  This should be unique enough to be a suitable hash code
     ; even for blocks, where the goal is to try and get the first bytes to be zeros (i.e. the value as a big integer
     ; lower than the target value).
     ;;
    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        ;; Use the last 4 bytes, not the first 4 which are often zeros in Bitcoin.
        (§ return Ints.fromBytes(§ pars bytes[LENGTH - 4], bytes[LENGTH - 3], bytes[LENGTH - 2], bytes[LENGTH - 1]))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return Utils.HEX.encode(§ pars bytes))
    )

    ;;;
     ; Returns the bytes interpreted as a positive integer.
     ;;
    #_public
    (§ method BigInteger toBigInteger(§ args ))
    (§ block
        (§ return (§ new BigInteger(§ pars 1, bytes)))
    )

    ;;;
     ; Returns the internal byte array, without defensively copying.  Therefore do NOT modify the returned array.
     ;;
    #_public
    (§ method byte[] getBytes(§ args ))
    (§ block
        (§ return bytes)
    )

    ;;;
     ; Returns a reversed copy of the internal byte array.
     ;;
    #_public
    (§ method byte[] getReversedBytes(§ args ))
    (§ block
        (§ return Utils.reverseBytes(§ pars bytes))
    )

    #_override
    #_public
    (§ method int compareTo(§ args #_final Sha256Hash other))
    (§ block
        (§ for (§ var int i = LENGTH - 1) :for (§ expr 0 <= i) :for (§ ass i = i - 1))
        (§ block
            #_final
            (§ var int thisByte = this.bytes[i] & 0xff)
            #_final
            (§ var int otherByte = other.bytes[i] & 0xff)
            (§ if (§ expr thisByte > otherByte))
            (§ block
                (§ return 1)
            )
            (§ if (§ expr thisByte < otherByte))
            (§ block
                (§ return -1)
            )
        )
        (§ return 0)
    )
)

#_(ns org.bitcoinj.core #_"StoredBlock"
    (:import [java.math BigInteger]
             [java.nio ByteBuffer]
             [java.util Locale])
    (:import [com.google.common.base Objects Preconditions])
   (:require [org.bitcoinj.store BlockStore BlockStoreException]))

;;;
 ; Wraps a {@link Block} object with extra data that can be derived from the block chain but is slow or inconvenient
 ; to calculate.  By storing it alongside the block header we reduce the amount of work required significantly.
 ; Recalculation is slow because the fields are cumulative - to find the chainWork you have to iterate over every
 ; block in the chain back to the genesis block, which involves lots of seeking/loading etc.  So we just keep a
 ; running total: it's a disk space vs cpu/io tradeoff.
 ;
 ; StoredBlocks are put inside a {@link BlockStore} which saves them to memory or disk.
 ;;
#_public
(§ class StoredBlock
    ;; A BigInteger representing the total amount of work done so far on this chain.  As of May 2011 it takes
    ;; 8 bytes to represent this field, so 12 bytes should be plenty for now.
    #_public
    #_static
    #_final
    (§ field int CHAIN_WORK_BYTES = 12)
    #_public
    #_static
    #_final
    (§ field byte[] EMPTY_BYTES = new byte[CHAIN_WORK_BYTES])
    #_public
    #_static
    #_final
    (§ field int COMPACT_SERIALIZED_SIZE = Block.HEADER_SIZE + CHAIN_WORK_BYTES + 4) ;; for height

    #_private
    (§ field Block header)
    #_private
    (§ field BigInteger chainWork)
    #_private
    (§ field int height)

    #_public
    (§ constructor StoredBlock(§ args Block header, BigInteger chainWork, int height))
    (§ block
        (§ ass this.header = header)
        (§ ass this.chainWork = chainWork)
        (§ ass this.height = height)
    )

    ;;;
     ; The block header this object wraps.  The referenced block object must not have any transactions in it.
     ;;
    #_public
    (§ method Block getHeader(§ args ))
    (§ block
        (§ return header)
    )

    ;;;
     ; The total sum of work done in this block, and all the blocks below it in the chain.  Work is a measure of
     ; how many tries are needed to solve a block.  If the target is set to cover 10% of the total hash value space,
     ; then the work represented by a block is 10.
     ;;
    #_public
    (§ method BigInteger getChainWork(§ args ))
    (§ block
        (§ return chainWork)
    )

    ;;;
     ; Position in the chain for this block.  The genesis block has a height of zero.
     ;;
    #_public
    (§ method int getHeight(§ args ))
    (§ block
        (§ return height)
    )

    ;;; Returns true if this objects chainWork is higher than the others. ;;
    #_public
    (§ method boolean moreWorkThan(§ args StoredBlock other))
    (§ block
        (§ return (§ expr 0 < chainWork.compareTo(§ pars other.chainWork)))
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var StoredBlock other = (§ cast StoredBlock)o)
        (§ return (§ expr header.equals(§ pars other.header) && chainWork.equals(§ pars other.chainWork) && height == other.height))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars header, chainWork, height))
    )

    ;;;
     ; Creates a new StoredBlock, calculating the additional fields by adding to the values in this block.
     ;;
    #_public
    (§ method StoredBlock build(§ args Block block))
        (§ throws VerificationException)
    (§ block
        ;; Stored blocks track total work done in this chain, because the canonical chain is the one that represents
        ;; the largest amount of work done not the tallest.
        (§ var BigInteger chainWork = this.chainWork.add(§ pars block.getWork(§ pars )))
        (§ var int height = this.height + 1)
        (§ return (§ new StoredBlock(§ pars block, chainWork, height)))
    )

    ;;;
     ; Given a block store, looks up the previous block in this chain.  Convenience method for doing
     ; <tt>store.get(this.getHeader().getPrevBlockHash())</tt>.
     ;
     ; @return the previous block in the chain or null if it was not found in the store.
     ;;
    #_public
    (§ method StoredBlock getPrev(§ args BlockStore store))
        (§ throws BlockStoreException)
    (§ block
        (§ return store.get(§ pars getHeader(§ pars ).getPrevBlockHash(§ pars )))
    )

    ;;; Serializes the stored block to a custom packed format.  Used by {@link CheckpointManager}. ;;
    #_public
    (§ method void serializeCompact(§ args ByteBuffer buffer))
    (§ block
        (§ var byte[] chainWorkBytes = getChainWork(§ pars ).toByteArray(§ pars ))
        (§ call Preconditions.checkState(§ pars chainWorkBytes.length <= CHAIN_WORK_BYTES, "Ran out of space to store chain work!"))
        (§ if (§ expr chainWorkBytes.length < CHAIN_WORK_BYTES))
        (§ block
            ;; Pad to the right size.
            (§ call buffer.put(§ pars EMPTY_BYTES, 0, CHAIN_WORK_BYTES - chainWorkBytes.length))
        )
        (§ call buffer.put(§ pars chainWorkBytes))
        (§ call buffer.putInt(§ pars getHeight(§ pars )))
        ;; Using unsafeBitcoinSerialize here can give us direct access to the same bytes we read off the wire,
        ;; avoiding serialization round-trips.
        (§ var byte[] bytes = getHeader(§ pars ).unsafeBitcoinSerialize(§ pars ))
        (§ call buffer.put(§ pars bytes, 0, Block.HEADER_SIZE)) ;; Trim the trailing 00 byte (zero transactions).
    )

    ;;; De-serializes the stored block from a custom packed format.  Used by {@link CheckpointManager}. ;;
    #_public
    #_static
    (§ method StoredBlock deserializeCompact(§ args NetworkParameters params, ByteBuffer buffer))
        (§ throws ProtocolException)
    (§ block
        (§ var byte[] chainWorkBytes = new byte[StoredBlock.CHAIN_WORK_BYTES])
        (§ call buffer.get(§ pars chainWorkBytes))
        (§ var BigInteger chainWork = new BigInteger(§ pars 1, chainWorkBytes))
        (§ var int height = buffer.getInt(§ pars )) ;; +4 bytes
        (§ var byte[] header = new byte[Block.HEADER_SIZE + 1]) ;; Extra byte for the 00 transactions length.
        (§ call buffer.get(§ pars header, 0, Block.HEADER_SIZE))
        (§ return (§ new StoredBlock(§ pars params.getDefaultSerializer(§ pars ).makeBlock(§ pars header), chainWork, height)))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return String.format(§ pars Locale.US, "Block %s at height %d: %s", getHeader(§ pars ).getHashAsString(§ pars ), getHeight(§ pars ), getHeader(§ pars ).toString(§ pars )))
    )
)

#_(ns org.bitcoinj.core #_"StoredUndoableBlock"
    (:import [java.util List]))

;;;
 ; Contains minimal data neccessary to disconnect/connect the transactions
 ; in the stored block at will.  Can either store the full set of
 ; transactions (if the inputs for the block have not been tested to work)
 ; or the set of transaction outputs created/destroyed when the block is
 ; connected.
 ;;
#_public
(§ class StoredUndoableBlock
    (§ field Sha256Hash blockHash)

    ;; Only one of either txOutChanges or transactions will be set.
    #_private
    (§ field TransactionOutputChanges txOutChanges)
    #_private
    (§ field List<Transaction> transactions)

    #_public
    (§ constructor StoredUndoableBlock(§ args Sha256Hash hash, TransactionOutputChanges txOutChanges))
    (§ block
        (§ ass this.blockHash = hash)
        (§ ass this.transactions = nil)
        (§ ass this.txOutChanges = txOutChanges)
    )

    #_public
    (§ constructor StoredUndoableBlock(§ args Sha256Hash hash, List<Transaction> transactions))
    (§ block
        (§ ass this.blockHash = hash)
        (§ ass this.txOutChanges = nil)
        (§ ass this.transactions = transactions)
    )

    ;;;
     ; Get the transaction output changes if they have been calculated, otherwise null.
     ; Only one of this and getTransactions() will return a non-null value.
     ;;
    #_public
    (§ method TransactionOutputChanges getTxOutChanges(§ args ))
    (§ block
        (§ return txOutChanges)
    )

    ;;;
     ; Get the full list of transactions if it is stored, otherwise null.
     ; Only one of this and getTxOutChanges() will return a non-null value.
     ;;
    #_public
    (§ method List<Transaction> getTransactions(§ args ))
    (§ block
        (§ return transactions)
    )

    ;;;
     ; Get the hash of the represented block.
     ;;
    #_public
    (§ method Sha256Hash getHash(§ args ))
    (§ block
        (§ return blockHash)
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return blockHash.hashCode(§ pars ))
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return getHash(§ pars ).equals(§ pars (§ expr (§ cast StoredUndoableBlock)o).getHash(§ pars )))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return "Undoable Block " + blockHash)
    )
)

#_(ns org.bitcoinj.core #_"Transaction"
    (:import [java.io *]
             [java.math BigInteger]
             [java.util *])
    (:import [com.google.common.base Preconditions Strings]
             [com.google.common.collect ImmutableMap]
             [com.google.common.primitives Ints Longs]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core.TransactionConfidence ConfidenceType]
             #_static [org.bitcoinj.core.Utils *]
             [org.bitcoinj.crypto TransactionSignature]
             [org.bitcoinj.script Script ScriptBuilder ScriptError ScriptOpCodes]
             [org.bitcoinj.signers TransactionSigner]
             [org.bitcoinj.utils ExchangeRate]
             [org.bitcoinj.wallet Wallet]
             [org.bitcoinj.wallet.WalletTransaction Pool]))

;;;
 ; <p>A transaction represents the movement of coins from some addresses to some other addresses.  It can also represent
 ; the minting of new coins.  A Transaction object corresponds to the equivalent in the Bitcoin C++ implementation.</p>
 ;
 ; <p>Transactions are the fundamental atoms of Bitcoin and have many powerful features.  Read
 ; <a href="https://bitcoinj.github.io/working-with-transactions">"Working with transactions"</a> in the
 ; documentation to learn more about how to use this class.</p>
 ;
 ; <p>All Bitcoin transactions are at risk of being reversed, though the risk is much less than with traditional payment
 ; systems.  Transactions have <i>confidence levels</i>, which help you decide whether to trust a transaction or not.
 ; Whether to trust a transaction is something that needs to be decided on a case by case basis - a rule that makes
 ; sense for selling MP3s might not make sense for selling cars, or accepting payments from a family member.  If you
 ; are building a wallet, how to present confidence to your users is something to consider carefully.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class Transaction extends ChildMessage
    ;;;
     ; A comparator that can be used to sort transactions by their updateTime field.
     ; The ordering goes from most recent into the past.
     ;;
    #_public
    #_static
    #_final
    (§ field Comparator<Transaction> SORT_TX_BY_UPDATE_TIME = new Comparator<Transaction>(§ pars )
        (§ anon
            #_override
            #_public
            (§ method int compare(§ args #_final Transaction tx1, #_final Transaction tx2))
            (§ block
                #_final
                (§ var long time1 = tx1.getUpdateTime(§ pars ).getTime(§ pars ))
                #_final
                (§ var long time2 = tx2.getUpdateTime(§ pars ).getTime(§ pars ))
                #_final
                (§ var int updateTimeComparison = -Longs.compare(§ pars time1, time2))
                ;; If time1 == time2, compare by tx hash to make comparator consistent with equals.
                (§ return (§ quest (§ expr updateTimeComparison != 0) ? updateTimeComparison :else tx1.getHash(§ pars ).compareTo(§ pars tx2.getHash(§ pars ))))
            )
        ))

    ;;; A comparator that can be used to sort transactions by their chain height. ;;
    #_public
    #_static
    #_final
    (§ field Comparator<Transaction> SORT_TX_BY_HEIGHT = new Comparator<Transaction>(§ pars )
        (§ anon
            #_override
            #_public
            (§ method int compare(§ args #_final Transaction tx1, #_final Transaction tx2))
            (§ block
                #_final
                (§ var TransactionConfidence confidence1 = tx1.getConfidence(§ pars ))
                #_final
                (§ var int height1 = (§ expr confidence1.getConfidenceType(§ pars ) == ConfidenceType.BUILDING) ? confidence1.getAppearedAtChainHeight(§ pars ) :else Block.BLOCK_HEIGHT_UNKNOWN)
                #_final
                (§ var TransactionConfidence confidence2 = tx2.getConfidence(§ pars ))
                #_final
                (§ var int height2 = (§ expr confidence2.getConfidenceType(§ pars ) == ConfidenceType.BUILDING) ? confidence2.getAppearedAtChainHeight(§ pars ) :else Block.BLOCK_HEIGHT_UNKNOWN)
                #_final
                (§ var int heightComparison = -Ints.compare(§ pars height1, height2))
                ;; If height1 == height2, compare by tx hash to make comparator consistent with equals.
                (§ return (§ quest (§ expr heightComparison != 0) ? heightComparison :else tx1.getHash(§ pars ).compareTo(§ pars tx2.getHash(§ pars ))))
            )
        ))

    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars Transaction.class))

    ;;; Threshold for lockTime: below this value it is interpreted as block number, otherwise as timestamp. ;;
    #_public
    #_static
    #_final
    (§ field int LOCKTIME_THRESHOLD = 500000000) ;; Tue Nov  5 00:53:20 1985 UTC
    ;;; Same, but as a BigInteger for CHECKLOCKTIMEVERIFY. ;;
    #_public
    #_static
    #_final
    (§ field BigInteger LOCKTIME_THRESHOLD_BIG = BigInteger.valueOf(§ pars LOCKTIME_THRESHOLD))

    ;;; How many bytes a transaction can be before it won't be relayed anymore.  Currently 100kb. ;;
    #_public
    #_static
    #_final
    (§ field int MAX_STANDARD_TX_SIZE = 100000)

    ;;;
     ; If feePerKb is lower than this, Bitcoin Core will treat it as if there were no fee.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin REFERENCE_DEFAULT_MIN_TX_FEE = Coin.valueOf(§ pars 5000)) ;; 0.05 mBTC

    ;;;
     ; If using this feePerKb, transactions will get confirmed within the next couple of blocks.
     ; This should be adjusted from time to time.  Last adjustment: February 2017.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin DEFAULT_TX_FEE = Coin.valueOf(§ pars 100000)) ;; 1 mBTC

    ;;;
     ; Any standard (i.e. pay-to-address) output smaller than this value (in satoshis) will most likely be rejected by the network.
     ; This is calculated by assuming a standard output will be 34 bytes, and then using the formula used in
     ; {@link TransactionOutput#getMinNonDustValue(Coin)}.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin MIN_NONDUST_OUTPUT = Coin.valueOf(§ pars 2730)) ;; satoshis

    ;; These are bitcoin serialized.
    #_private
    (§ field long version)
    #_private
    (§ field ArrayList<TransactionInput> inputs)
    #_private
    (§ field ArrayList<TransactionOutput> outputs)

    #_private
    (§ field long lockTime)

    ;; This is either the time the transaction was broadcast as measured from the local clock, or the time from the
    ;; block in which it was included.  Note that this can be changed by re-orgs so the wallet may update this field.
    ;; Old serialized transactions don't have this field, thus null is valid.  It is used for returning an ordered
    ;; list of transactions from a wallet, which is helpful for presenting to users.
    #_private
    (§ field Date updatedAt)

    ;; This is an in memory helper only.
    #_private
    (§ field Sha256Hash hash)

    ;; Data about how confirmed this tx is.  Serialized, may be null.
    #_nilable
    #_private
    (§ field TransactionConfidence confidence)

    ;; Records a map of which blocks the transaction has appeared in (keys) to an index within that block (values).
    ;; The "index" is not a real index, instead the values are only meaningful relative to each other.  For example,
    ;; consider two transactions that appear in the same block, t1 and t2, where t2 spends an output of t1.  Both
    ;; will have the same block hash as a key in their appearsInHashes, but the counter would be 1 and 2 respectively
    ;; regardless of where they actually appeared in the block.
    ;;
    ;; If this transaction is not stored in the wallet, appearsInHashes is null.
    #_private
    (§ field Map<Sha256Hash, Integer> appearsInHashes)

    ;; Transactions can be encoded in a way that will use more bytes than is optimal
    ;; (due to VarInts having multiple encodings).
    ;; MAX_BLOCK_SIZE must be compared to the optimal encoding, not the actual encoding, so when parsing, we keep track
    ;; of the size of the ideal encoding in addition to the actual message size (which Message needs) so that Blocks
    ;; can properly keep track of optimal encoded size.
    #_private
    (§ field int optimalEncodingMessageSize)

    ;;;
     ; This enum describes the underlying reason the transaction was created.  It's useful for rendering wallet GUIs
     ; more appropriately.
     ;;
    #_public
    (§ enum Purpose
        ;;; Used when the purpose of a transaction is genuinely unknown. ;;
        (§ item UNKNOWN)
        ;;; Transaction created to satisfy a user payment request. ;;
        (§ item USER_PAYMENT)
        ;;; Transaction automatically created and broadcast in order to reallocate money from old to new keys. ;;
        (§ item KEY_ROTATION)
        ;;; Transaction that uses up pledges to an assurance contract. ;;
        (§ item ASSURANCE_CONTRACT_CLAIM)
        ;;; Transaction that makes a pledge to an assurance contract. ;;
        (§ item ASSURANCE_CONTRACT_PLEDGE)
        ;;; Send-to-self transaction that exists just to create an output of the right size we can pledge. ;;
        (§ item ASSURANCE_CONTRACT_STUB)
        ;;; Raise fee, e.g. child-pays-for-parent. ;;
        (§ item RAISE_FEE)
        ;; In future: de/refragmentation, privacy boosting/mixing, etc.
        ;; When adding a value, it also needs to be added to wallet.proto, WalletProtobufSerialize.makeTxProto()
        ;; and WalletProtobufSerializer.readTransaction()!
    )

    #_private
    (§ field Purpose purpose = Purpose.UNKNOWN)

    ;;;
     ; This field can be used by applications to record the exchange rate that was valid when the transaction happened.
     ; It's optional.
     ;;
    #_nilable
    #_private
    (§ field ExchangeRate exchangeRate)

    ;;;
     ; This field can be used to record the memo of the payment request that initiated the transaction.
     ; It's optional.
     ;;
    #_nilable
    #_private
    (§ field String memo)

    ;; Below flags apply in the context of BIP 68.
     ; If this flag set, CTxIn::nSequence is NOT interpreted as a relative lock-time.
     ;;
    #_public
    #_static
    #_final
    (§ field long SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 << 31)

    ;; If CTxIn::nSequence encodes a relative lock-time and this flag
     ; is set, the relative lock-time has units of 512 seconds,
     ; otherwise it specifies blocks with a granularity of 1.
     ;;
    #_public
    #_static
    #_final
    (§ field long SEQUENCE_LOCKTIME_TYPE_FLAG = 1 << 22)

    ;; If CTxIn::nSequence encodes a relative lock-time, this mask is
     ; applied to extract that lock-time from the sequence field.
     ;;
    #_public
    #_static
    #_final
    (§ field long SEQUENCE_LOCKTIME_MASK = 0x0000ffff)

    #_public
    (§ constructor Transaction(§ args NetworkParameters params))
    (§ block
        (§ super (§ pars params))

        (§ ass version = 1)
        (§ ass inputs = new ArrayList<>(§ pars ))
        (§ ass outputs = new ArrayList<>(§ pars ))
        ;; We don't initialize appearsIn deliberately as it's only useful for transactions stored in the wallet.
        (§ ass length = 8) ;; 8 for std fields
    )

    ;;;
     ; Creates a transaction from the given serialized bytes, e.g. from a block or a tx network message.
     ;;
    #_public
    (§ constructor Transaction(§ args NetworkParameters params, byte[] payloadBytes))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payloadBytes, 0))
    )

    ;;;
     ; Creates a transaction by reading payload starting from offset bytes in.  Length of a transaction is fixed.
     ;;
    #_public
    (§ constructor Transaction(§ args NetworkParameters params, byte[] payload, int offset))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, offset))
        ;; inputs/outputs will be created in parse()
    )

    ;;;
     ; Creates a transaction by reading payload starting from offset bytes in.  Length of a transaction is fixed.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param parseRetain Whether to retain the backing byte array for quick reserialization.
     ; If true and the backing byte array is invalidated due to modification of a field, then
     ; the cached bytes may be repopulated and retained if the message is serialized again in the future.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor Transaction(§ args NetworkParameters params, byte[] payload, int offset, #_nilable Message parent, MessageSerializer setSerializer, int length))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, offset, parent, setSerializer, length))
    )

    ;;;
     ; Creates a transaction by reading payload.  Length of a transaction is fixed.
     ;;
    #_public
    (§ constructor Transaction(§ args NetworkParameters params, byte[] payload, #_nilable Message parent, MessageSerializer setSerializer, int length))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, 0, parent, setSerializer, length))
    )

    ;;;
     ; Returns the transaction hash as you see them in the block explorer.
     ;;
    #_override
    #_public
    (§ method Sha256Hash getHash(§ args ))
    (§ block
        (§ if (§ expr hash == nil))
        (§ block
            (§ ass hash = Sha256Hash.wrapReversed(§ pars Sha256Hash.hashTwice(§ pars unsafeBitcoinSerialize(§ pars ))))
        )
        (§ return hash)
    )

    ;;;
     ; Used by BitcoinSerializer.  The serializer has to calculate a hash for checksumming so to
     ; avoid wasting the considerable effort a set method is provided so the serializer can set it.
     ;
     ; No verification is performed on this hash.
     ;;
    (§ method void setHash(§ args Sha256Hash hash))
    (§ block
        (§ ass this.hash = hash)
    )

    #_public
    (§ method String getHashAsString(§ args ))
    (§ block
        (§ return getHash(§ pars ).toString(§ pars ))
    )

    ;;;
     ; Gets the sum of the inputs, regardless of who owns them.
     ;;
    #_public
    (§ method Coin getInputSum(§ args ))
    (§ block
        (§ var Coin inputTotal = Coin.ZERO)

        (§ for (§ var TransactionInput input) :for (§ expr inputs))
        (§ block
            (§ var Coin inputValue = input.getValue(§ pars ))
            (§ if (§ expr inputValue != nil))
            (§ block
                (§ ass inputTotal = inputTotal.add(§ pars inputValue))
            )
        )

        (§ return inputTotal)
    )

    ;;;
     ; Calculates the sum of the outputs that are sending coins to a key in the wallet.
     ;;
    #_public
    (§ method Coin getValueSentToMe(§ args TransactionBag transactionBag))
    (§ block
        ;; This is tested in WalletTest.
        (§ var Coin v = Coin.ZERO)
        (§ for (§ var TransactionOutput o) :for (§ expr outputs))
        (§ block
            (§ if (§ expr o.isMine(§ pars transactionBag)))
            (§ block
                (§ ass v = v.add(§ pars o.getValue(§ pars )))
            )
        )
        (§ return v)
    )

    ;;;
     ; Returns a map of block [hashes] which contain the transaction mapped to relativity counters, or null if this
     ; transaction doesn't have that data because it's not stored in the wallet or because it has never appeared in a
     ; block.
     ;;
    #_nilable
    #_public
    (§ method Map<Sha256Hash, Integer> getAppearsInHashes(§ args ))
    (§ block
        (§ return (§ expr appearsInHashes != nil) ? ImmutableMap.copyOf(§ pars appearsInHashes) :else nil)
    )

    ;;;
     ; Convenience wrapper around getConfidence().getConfidenceType().
     ; @return true if this transaction hasn't been seen in any block yet.
     ;;
    #_public
    (§ method boolean isPending(§ args ))
    (§ block
        (§ return (§ expr getConfidence(§ pars ).getConfidenceType(§ pars ) == TransactionConfidence.ConfidenceType.PENDING))
    )

    ;;;
     ; <p>Puts the given block in the internal set of blocks in which this transaction appears.  This is
     ; used by the wallet to ensure transactions that appear on side chains are recorded properly even though
     ; the block stores do not save the transaction data at all.</p>
     ;
     ; <p>If there is a re-org this will be called once for each block that was previously seen, to update which block
     ; is the best chain.  The best chain block is guaranteed to be called last. So this must be idempotent.</p>
     ;
     ; <p>Sets updatedAt to be the earliest valid block time where this tx was seen.</p>
     ;
     ; @param block     The {@link StoredBlock} in which the transaction has appeared.
     ; @param bestChain Whether to set the updatedAt timestamp from the block header (only if not already set).
     ; @param relativityOffset A number that disambiguates the order of transactions within a block.
     ;;
    #_public
    (§ method void setBlockAppearance(§ args StoredBlock block, boolean bestChain, int relativityOffset))
    (§ block
        (§ var long blockTime = block.getHeader(§ pars ).getTimeSeconds(§ pars ) * 1000)
        (§ if (§ expr bestChain && (§ expr updatedAt == nil || updatedAt.getTime(§ pars ) == 0 || blockTime < updatedAt.getTime(§ pars ))))
        (§ block
            (§ ass updatedAt = new Date(§ pars blockTime))
        )

        (§ call addBlockAppearance(§ pars block.getHeader(§ pars ).getHash(§ pars ), relativityOffset))

        (§ if (§ expr bestChain))
        (§ block
            (§ var TransactionConfidence transactionConfidence = getConfidence(§ pars ))
            ;; This sets type to BUILDING and depth to one.
            (§ call transactionConfidence.setAppearedAtChainHeight(§ pars block.getHeight(§ pars )))
        )
    )

    #_public
    (§ method void addBlockAppearance(§ args #_final Sha256Hash blockHash, int relativityOffset))
    (§ block
        ;; TODO: This could be a lot more memory efficient as we'll typically only store one element.
        (§ if (§ expr appearsInHashes == nil))
        (§ block
            (§ ass appearsInHashes = new TreeMap<>(§ pars ))
        )

        (§ call appearsInHashes.put(§ pars blockHash, relativityOffset))
    )

    ;;;
     ; Calculates the sum of the inputs that are spending coins with keys in the wallet.  This requires the
     ; transactions sending coins to those keys to be in the wallet.  This method will not attempt to download
     ; the blocks containing the input transactions if the key is in the wallet but the transactions are not.
     ;
     ; @return sum of the inputs that are spending coins with keys in the wallet.
     ;;
    #_public
    (§ method Coin getValueSentFromMe(§ args TransactionBag wallet))
        (§ throws ScriptException)
    (§ block
        ;; This is tested in WalletTest.
        (§ var Coin v = Coin.ZERO)
        (§ for (§ var TransactionInput input) :for (§ expr inputs))
        (§ block
            ;; This input is taking value from a transaction in our wallet.  To discover the value,
            ;; we must find the connected transaction.
            (§ var TransactionOutput connected = input.getConnectedOutput(§ pars wallet.getTransactionPool(§ pars Pool.UNSPENT)))
            (§ if (§ expr connected == nil))
            (§ block
                (§ ass connected = input.getConnectedOutput(§ pars wallet.getTransactionPool(§ pars Pool.SPENT)))
            )
            (§ if (§ expr connected == nil))
            (§ block
                (§ ass connected = input.getConnectedOutput(§ pars wallet.getTransactionPool(§ pars Pool.PENDING)))
            )

            ;; The connected output may be the change to the sender of a previous input sent to this wallet.
            ;; In this case we ignore it.
            (§ if (§ expr connected != nil && connected.isMine(§ pars wallet)))
            (§ block
                (§ ass v = v.add(§ pars connected.getValue(§ pars )))
            )
        )
        (§ return v)
    )

    ;;;
     ; Gets the sum of the outputs of the transaction.  If the outputs are less than the inputs, it does not count the fee.
     ; @return the sum of the outputs regardless of who owns them.
     ;;
    #_public
    (§ method Coin getOutputSum(§ args ))
    (§ block
        (§ var Coin totalOut = Coin.ZERO)

        (§ for (§ var TransactionOutput output) :for (§ expr outputs))
        (§ block
            (§ ass totalOut = totalOut.add(§ pars output.getValue(§ pars )))
        )

        (§ return totalOut)
    )

    #_nilable
    #_private
    (§ field Coin cachedValue)
    #_nilable
    #_private
    (§ field TransactionBag cachedForBag)

    ;;;
     ; Returns the difference of {@link Transaction#getValueSentToMe(TransactionBag)} and {@link Transaction#getValueSentFromMe(TransactionBag)}.
     ;;
    #_public
    (§ method Coin getValue(§ args TransactionBag wallet))
        (§ throws ScriptException)
    (§ block
        ;; FIXME: TEMP PERF HACK FOR ANDROID - this crap can go away once we have a real payments API.
        (§ var boolean isAndroid = Utils.isAndroidRuntime(§ pars ))
        (§ if (§ expr isAndroid && cachedValue != nil && cachedForBag == wallet))
        (§ block
            (§ return cachedValue)
        )

        (§ var Coin result = getValueSentToMe(§ pars wallet).subtract(§ pars getValueSentFromMe(§ pars wallet)))
        (§ if (§ expr isAndroid))
        (§ block
            (§ ass cachedValue = result)
            (§ ass cachedForBag = wallet)
        )
        (§ return result)
    )

    ;;;
     ; The transaction fee is the difference of the value of all inputs and the value of all outputs.
     ; Currently, the fee can only be determined for transactions created by us.
     ;
     ; @return fee, or null if it cannot be determined.
     ;;
    #_public
    (§ method Coin getFee(§ args ))
    (§ block
        (§ var Coin fee = Coin.ZERO)
        (§ if (§ expr inputs.isEmpty(§ pars ) || outputs.isEmpty(§ pars ))) ;; Incomplete transaction.
        (§ block
            (§ return nil)
        )

        (§ for (§ var TransactionInput input) :for (§ expr inputs))
        (§ block
            (§ if (§ expr input.getValue(§ pars ) == nil))
            (§ block
                (§ return nil)
            )
            (§ ass fee = fee.add(§ pars input.getValue(§ pars )))
        )
        (§ for (§ var TransactionOutput output) :for (§ expr outputs))
        (§ block
            (§ ass fee = fee.subtract(§ pars output.getValue(§ pars )))
        )
        (§ return fee)
    )

    ;;;
     ; Returns true if any of the outputs is marked as spent.
     ;;
    #_public
    (§ method boolean isAnyOutputSpent(§ args ))
    (§ block
        (§ for (§ var TransactionOutput output) :for (§ expr outputs))
        (§ block
            (§ if (§ expr !output.isAvailableForSpending(§ pars )))
            (§ block
                (§ return true)
            )
        )

        (§ return false)
    )

    ;;;
     ; Returns false if this transaction has at least one output that is owned by the given wallet and unspent,
     ; true otherwise.
     ;;
    #_public
    (§ method boolean isEveryOwnedOutputSpent(§ args TransactionBag transactionBag))
    (§ block
        (§ for (§ var TransactionOutput output) :for (§ expr outputs))
        (§ block
            (§ if (§ expr output.isAvailableForSpending(§ pars ) && output.isMine(§ pars transactionBag)))
            (§ block
                (§ return false)
            )
        )

        (§ return true)
    )

    ;;;
     ; Returns the earliest time at which the transaction was seen (broadcast or included into the chain),
     ; or the epoch if that information isn't available.
     ;;
    #_public
    (§ method Date getUpdateTime(§ args ))
    (§ block
        ;; Older wallets did not store this field.  Set to the epoch.
        (§ if (§ expr updatedAt == nil))
        (§ block
            (§ ass updatedAt = new Date(§ pars 0))
        )
        (§ return updatedAt)
    )

    #_public
    (§ method void setUpdateTime(§ args Date updatedAt))
    (§ block
        (§ ass this.updatedAt = updatedAt)
    )

    ;;;
     ; These constants are a part of a scriptSig signature on the inputs.  They define the details of how a
     ; transaction can be redeemed, specifically, they control how the hash of the transaction is calculated.
     ;;
    #_public
    (§ enum SigHash
        (§ item ALL(§ pars 1))
        (§ item NONE(§ pars 2))
        (§ item SINGLE(§ pars 3))
        (§ item ANYONECANPAY(§ pars 0x80)) ;; Caution: Using this type in isolation is non-standard.  Treated similar to ANYONECANPAY_ALL.
        (§ item ANYONECANPAY_ALL(§ pars 0x81))
        (§ item ANYONECANPAY_NONE(§ pars 0x82))
        (§ item ANYONECANPAY_SINGLE(§ pars 0x83))
        (§ item UNSET(§ pars 0)) ;; Caution: Using this type in isolation is non-standard.  Treated similar to ALL.

        #_public
        #_final
        (§ field int value)

        ;;;
         ; @param value
         ;;
        #_private
        (§ constructor SigHash(§ args #_final int value))
        (§ block
            (§ ass this.value = value)
        )

        ;;;
         ; @return the value as a byte.
         ;;
        #_public
        (§ method byte byteValue(§ args ))
        (§ block
            (§ return (§ cast byte)this.value)
        )
    )

    #_override
    #_protected
    (§ method void unCache(§ args ))
    (§ block
        (§ call super.unCache(§ pars ))
        (§ ass hash = nil)
    )

    #_protected
    #_static
    (§ method int calcLength(§ args byte[] buf, int offset))
    (§ block
        ;; jump past version (uint32)
        (§ var int cursor = offset + 4)

        (§ var VarInt varint = new VarInt(§ pars buf, cursor))
        (§ var long txInCount = varint.value)
        (§ ass cursor = cursor + varint.getOriginalSizeInBytes(§ pars ))

        (§ for (§ var int i = 0) :for (§ expr i < txInCount) :for (§ ass i = i + 1))
        (§ block
            ;; 36 = length of previous_outpoint
            (§ ass cursor = cursor + 36)
            (§ ass varint = new VarInt(§ pars buf, cursor))
            (§ var long scriptLen = varint.value)
            ;; 4 = length of sequence field (unint32)
            (§ ass cursor = cursor + scriptLen + 4 + varint.getOriginalSizeInBytes(§ pars ))
        )

        (§ ass varint = new VarInt(§ pars buf, cursor))
        (§ var long txOutCount = varint.value)
        (§ ass cursor = cursor + varint.getOriginalSizeInBytes(§ pars ))

        (§ for (§ var int i = 0) :for (§ expr i < txOutCount) :for (§ ass i = i + 1))
        (§ block
            ;; 8 = length of tx value field (uint64)
            (§ ass cursor = cursor + 8)
            (§ ass varint = new VarInt(§ pars buf, cursor))
            (§ var long scriptLen = varint.value)
            (§ ass cursor = cursor + scriptLen + varint.getOriginalSizeInBytes(§ pars ))
        )
        ;; 4 = length of lock_time field (uint32)
        (§ return cursor - offset + 4)
    )

    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ ass cursor = offset)

        (§ ass version = readUint32(§ pars ))
        (§ ass optimalEncodingMessageSize = 4)

        ;; First come the inputs.
        (§ var long numInputs = readVarInt(§ pars ))
        (§ ass optimalEncodingMessageSize = optimalEncodingMessageSize + VarInt.sizeOf(§ pars numInputs))
        (§ ass inputs = new ArrayList<>(§ pars (§ cast int)numInputs))
        (§ for (§ var long i = 0) :for (§ expr i < numInputs) :for (§ ass i = i + 1))
        (§ block
            (§ var TransactionInput input = new TransactionInput(§ pars params, this, payload, cursor, serializer))
            (§ call inputs.add(§ pars input))
            (§ var long scriptLen = readVarInt(§ pars TransactionOutPoint.MESSAGE_LENGTH))
            (§ ass optimalEncodingMessageSize = optimalEncodingMessageSize + TransactionOutPoint.MESSAGE_LENGTH + VarInt.sizeOf(§ pars scriptLen) + scriptLen + 4)
            (§ ass cursor = cursor + scriptLen + 4)
        )
        ;; Now the outputs.
        (§ var long numOutputs = readVarInt(§ pars ))
        (§ ass optimalEncodingMessageSize = optimalEncodingMessageSize + VarInt.sizeOf(§ pars numOutputs))
        (§ ass outputs = new ArrayList<>(§ pars (§ cast int)numOutputs))
        (§ for (§ var long i = 0) :for (§ expr i < numOutputs) :for (§ ass i = i + 1))
        (§ block
            (§ var TransactionOutput output = new TransactionOutput(§ pars params, this, payload, cursor, serializer))
            (§ call outputs.add(§ pars output))
            (§ var long scriptLen = readVarInt(§ pars 8))
            (§ ass optimalEncodingMessageSize = optimalEncodingMessageSize + 8 + VarInt.sizeOf(§ pars scriptLen) + scriptLen)
            (§ ass cursor = cursor + scriptLen)
        )
        (§ ass lockTime = readUint32(§ pars ))
        (§ ass optimalEncodingMessageSize = optimalEncodingMessageSize + 4)
        (§ ass length = cursor - offset)
    )

    #_public
    (§ method int getOptimalEncodingMessageSize(§ args ))
    (§ block
        (§ if (§ expr optimalEncodingMessageSize != 0))
        (§ block
            (§ return optimalEncodingMessageSize)
        )

        (§ ass optimalEncodingMessageSize = getMessageSize(§ pars ))
        (§ return optimalEncodingMessageSize)
    )

    ;;;
     ; The priority (coin age) calculation doesn't use the regular message size, but rather one adjusted downwards
     ; for the number of inputs.  The goal is to incentivise cleaning up the UTXO set with free transactions, if one
     ; can do so.
     ;;
    #_public
    (§ method int getMessageSizeForPriorityCalc(§ args ))
    (§ block
        (§ var int size = getMessageSize(§ pars ))
        (§ for (§ var TransactionInput input) :for (§ expr inputs))
        (§ block
            ;; 41: min size of an input
            ;; 110: enough to cover a compressed pubkey p2sh redemption (somewhat arbitrary)
            (§ var int benefit = 41 + Math.min(§ pars 110, input.getScriptSig(§ pars ).getProgram(§ pars ).length))
            (§ if (§ expr benefit < size))
            (§ block
                (§ ass size = size - benefit)
            )
        )
        (§ return size)
    )

    ;;;
     ; A coinbase transaction is one that creates a new coin.  They are the first transaction in each block and their
     ; value is determined by a formula that all implementations of Bitcoin share.  In 2011 the value of a coinbase
     ; transaction is 50 coins, but in future it will be less.  A coinbase transaction is defined not only by its
     ; position in a block but by the data in the inputs.
     ;;
    #_public
    (§ method boolean isCoinBase(§ args ))
    (§ block
        (§ return (§ expr inputs.size(§ pars ) == 1 && inputs.get(§ pars 0).isCoinBase(§ pars )))
    )

    ;;;
     ; A transaction is mature if it is either a building coinbase tx that is as deep or deeper than the required coinbase depth, or a non-coinbase tx.
     ;;
    #_public
    (§ method boolean isMature(§ args ))
    (§ block
        (§ if (§ expr !isCoinBase(§ pars )))
        (§ block
            (§ return true)
        )

        (§ if (§ expr getConfidence(§ pars ).getConfidenceType(§ pars ) != ConfidenceType.BUILDING))
        (§ block
            (§ return false)
        )

        (§ return (§ expr params.getSpendableCoinbaseDepth(§ pars ) <= getConfidence(§ pars ).getDepthInBlocks(§ pars )))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return toString(§ pars nil))
    )

    ;;;
     ; A human readable version of the transaction useful for debugging.  The format is not guaranteed to be stable.
     ; @param chain If provided, will be used to estimate lock times (if set).  Can be null.
     ;;
    #_public
    (§ method String toString(§ args #_nilable AbstractBlockChain chain))
    (§ block
        (§ var StringBuilder sb = new StringBuilder(§ pars ))
        (§ call sb.append(§ pars "  ").append(§ pars getHashAsString(§ pars )).append(§ pars "\n"))
        (§ if (§ expr updatedAt != nil))
        (§ block
            (§ call sb.append(§ pars "  updated: ").append(§ pars Utils.dateTimeFormat(§ pars updatedAt)).append(§ pars "\n"))
        )
        (§ if (§ expr version != 1))
        (§ block
            (§ call sb.append(§ pars "  version ").append(§ pars version).append(§ pars "\n"))
        )
        (§ if (§ expr isTimeLocked(§ pars )))
        (§ block
            (§ call sb.append(§ pars "  time locked until "))
            (§ if (§ expr lockTime < LOCKTIME_THRESHOLD))
            (§ block
                (§ call sb.append(§ pars "block ").append(§ pars lockTime))
                (§ if (§ expr chain != nil))
                (§ block
                    (§ call sb.append(§ pars " (estimated to be reached at ").append(§ pars Utils.dateTimeFormat(§ pars chain.estimateBlockTime(§ pars (§ cast int)lockTime))).append(§ pars ")"))
                )
            )
            (§ else )
            (§ block
                (§ call sb.append(§ pars Utils.dateTimeFormat(§ pars lockTime * 1000)))
            )
            (§ call sb.append(§ pars "\n"))
        )
        (§ if (§ expr isOptInFullRBF(§ pars )))
        (§ block
            (§ call sb.append(§ pars "  opts into full replace-by-fee\n"))
        )
        (§ if (§ expr isCoinBase(§ pars )))
        (§ block
            (§ var String script)
            (§ var String script2)
            (§ try )
            (§ block
                (§ ass script = inputs.get(§ pars 0).getScriptSig(§ pars ).toString(§ pars ))
                (§ ass script2 = outputs.get(§ pars 0).getScriptPubKey(§ pars ).toString(§ pars ))
            )
            (§ catch (§ args ScriptException _))
            (§ block
                (§ ass script = "???")
                (§ ass script2 = "???")
            )
            (§ call sb.append(§ pars "     == COINBASE TXN (scriptSig ").append(§ pars script).append(§ pars ")  (scriptPubKey ").append(§ pars script2).append(§ pars ")\n"))
            (§ return sb.toString(§ pars ))
        )

        (§ if (§ expr !inputs.isEmpty(§ pars )))
        (§ block
            (§ for (§ var TransactionInput in) :for (§ expr inputs))
            (§ block
                (§ call sb.append(§ pars "     in   "))

                (§ try )
                (§ block
                    (§ var String scriptSigStr = in.getScriptSig(§ pars ).toString(§ pars ))
                    (§ call sb.append(§ pars !Strings.isNullOrEmpty(§ pars scriptSigStr) ? scriptSigStr :else "<no scriptSig>"))
                    #_final
                    (§ var Coin value = in.getValue(§ pars ))
                    (§ if (§ expr value != nil))
                    (§ block
                        (§ call sb.append(§ pars " ").append(§ pars value.toFriendlyString(§ pars )))
                    )
                    (§ call sb.append(§ pars "\n          outpoint:"))
                    #_final
                    (§ var TransactionOutPoint outpoint = in.getOutpoint(§ pars ))
                    (§ call sb.append(§ pars outpoint.toString(§ pars )))
                    #_final
                    (§ var TransactionOutput connectedOutput = outpoint.getConnectedOutput(§ pars ))
                    (§ if (§ expr connectedOutput != nil))
                    (§ block
                        (§ var Script scriptPubKey = connectedOutput.getScriptPubKey(§ pars ))
                        (§ if (§ expr scriptPubKey.isSentToAddress(§ pars ) || scriptPubKey.isPayToScriptHash(§ pars )))
                        (§ block
                            (§ call sb.append(§ pars " hash160:").append(§ pars Utils.HEX.encode(§ pars scriptPubKey.getPubKeyHash(§ pars ))))
                        )
                    )
                    (§ if (§ expr in.hasSequence(§ pars )))
                    (§ block
                        (§ call sb.append(§ pars "\n          sequence:").append(§ pars Long.toHexString(§ pars in.getSequenceNumber(§ pars ))))
                        (§ if (§ expr in.isOptInFullRBF(§ pars )))
                        (§ block
                            (§ call sb.append(§ pars ", opts into full RBF"))
                        )
                    )
                )
                (§ catch (§ args Exception e))
                (§ block
                    (§ call sb.append(§ pars "[exception: ").append(§ pars e.getMessage(§ pars )).append(§ pars "]"))
                )
                (§ call sb.append(§ pars "\n"))
            )
        )
        (§ else )
        (§ block
            (§ call sb.append(§ pars "     INCOMPLETE: No inputs!\n"))
        )

        (§ for (§ var TransactionOutput out) :for (§ expr outputs))
        (§ block
            (§ call sb.append(§ pars "     out  "))
            (§ try )
            (§ block
                (§ var String scriptPubKeyStr = out.getScriptPubKey(§ pars ).toString(§ pars ))
                (§ call sb.append(§ pars !Strings.isNullOrEmpty(§ pars scriptPubKeyStr) ? scriptPubKeyStr :else "<no scriptPubKey>").append(§ pars " ").append(§ pars out.getValue(§ pars ).toFriendlyString(§ pars )))
                (§ if (§ expr !out.isAvailableForSpending(§ pars )))
                (§ block
                    (§ call sb.append(§ pars " Spent"))
                )
                #_final
                (§ var TransactionInput spentBy = out.getSpentBy(§ pars ))
                (§ if (§ expr spentBy != nil))
                (§ block
                    (§ call sb.append(§ pars " by ").append(§ pars spentBy.getParentTransaction(§ pars ).getHashAsString(§ pars )))
                )
            )
            (§ catch (§ args Exception e))
            (§ block
                (§ call sb.append(§ pars "[exception: ").append(§ pars e.getMessage(§ pars )).append(§ pars "]"))
            )
            (§ call sb.append(§ pars "\n"))
        )

        #_final
        (§ var Coin fee = getFee(§ pars ))
        (§ if (§ expr fee != nil))
        (§ block
            #_final
            (§ var int size = unsafeBitcoinSerialize(§ pars ).length)
            (§ call sb.append(§ pars "     fee  ").append(§ pars fee.multiply(§ pars 1000).divide(§ pars size).toFriendlyString(§ pars )).append(§ pars "/kB, ").append(§ pars fee.toFriendlyString(§ pars )).append(§ pars " for ").append(§ pars size).append(§ pars " bytes\n"))
        )
        (§ if (§ expr purpose != nil))
        (§ block
            (§ call sb.append(§ pars "     prps ").append(§ pars purpose).append(§ pars "\n"))
        )
        (§ return sb.toString(§ pars ))
    )

    ;;;
     ; Removes all the inputs from this transaction.
     ; Note that this also invalidates the length attribute.
     ;;
    #_public
    (§ method void clearInputs(§ args ))
    (§ block
        (§ call unCache(§ pars ))
        (§ for (§ var TransactionInput input) :for (§ expr inputs))
        (§ block
            (§ call input.setParent(§ pars nil))
        )
        (§ call inputs.clear(§ pars ))
        ;; You wanted to reserialize, right?
        (§ ass this.length = this.unsafeBitcoinSerialize(§ pars ).length)
    )

    ;;;
     ; Adds an input to this transaction that imports value from the given output.  Note that this input is <i>not</i>
     ; complete and after every input is added with {@link #addInput()} and every output is added with {@link #addOutput()},
     ; a {@link TransactionSigner} must be used to finalize the transaction and finish the inputs off.
     ; Otherwise it won't be accepted by the network.
     ; @return the newly created input.
     ;;
    #_public
    (§ method TransactionInput addInput(§ args TransactionOutput from))
    (§ block
        (§ return addInput(§ pars (§ new TransactionInput(§ pars params, this, from))))
    )

    ;;;
     ; Adds an input directly, with no checking that it's valid.
     ; @return the new input.
     ;;
    #_public
    (§ method TransactionInput addInput(§ args TransactionInput input))
    (§ block
        (§ call unCache(§ pars ))
        (§ call input.setParent(§ pars this))
        (§ call inputs.add(§ pars input))
        (§ call adjustLength(§ pars inputs.size(§ pars ), input.length))
        (§ return input)
    )

    ;;;
     ; Creates and adds an input to this transaction, with no checking that it's valid.
     ; @return the newly created input.
     ;;
    #_public
    (§ method TransactionInput addInput(§ args Sha256Hash spendTxHash, long outputIndex, Script script))
    (§ block
        (§ return addInput(§ pars (§ new TransactionInput(§ pars params, this, script.getProgram(§ pars ), new TransactionOutPoint(§ pars params, outputIndex, spendTxHash)))))
    )

    ;;;
     ; Adds a new and fully signed input for the given parameters.  Note that this method is <b>not</b> thread safe
     ; and requires external synchronization.  Please refer to general documentation on Bitcoin scripting and contracts
     ; to understand the values of sigHash and anyoneCanPay: otherwise you can use the other form of this method
     ; that sets them to typical defaults.
     ;
     ; @throws ScriptException if the scriptPubKey is not a pay to address or pay to pubkey script.
     ;;
    #_public
    (§ method TransactionInput addSignedInput(§ args TransactionOutPoint prevOut, Script scriptPubKey, ECKey sigKey, SigHash sigHash, boolean anyoneCanPay))
        (§ throws ScriptException)
    (§ block
        ;; Verify the API user didn't try to do operations out of order.
        (§ call Preconditions.checkState(§ pars !outputs.isEmpty(§ pars ), "Attempting to sign tx without outputs."))

        (§ var TransactionInput input = new TransactionInput(§ pars params, this, new byte[] (§ coll ), prevOut))
        (§ call addInput(§ pars input))
        (§ var Sha256Hash hash = hashForSignature(§ pars inputs.size(§ pars ) - 1, scriptPubKey, sigHash, anyoneCanPay))
        (§ var ECKey.ECDSASignature ecSig = sigKey.sign(§ pars hash))
        (§ var TransactionSignature txSig = new TransactionSignature(§ pars ecSig, sigHash, anyoneCanPay))
        (§ if (§ expr scriptPubKey.isSentToRawPubKey(§ pars )))
        (§ block
            (§ call input.setScriptSig(§ pars ScriptBuilder.createInputScript(§ pars txSig)))
        )
        (§ elseif (§ expr scriptPubKey.isSentToAddress(§ pars )))
        (§ block
            (§ call input.setScriptSig(§ pars ScriptBuilder.createInputScript(§ pars txSig, sigKey)))
        )
        (§ else )
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Don't know how to sign for this kind of scriptPubKey: " + scriptPubKey)))
        )
        (§ return input)
    )

    ;;;
     ; Same as {@link #addSignedInput(TransactionOutPoint, org.bitcoinj.script.Script, ECKey, org.bitcoinj.core.Transaction.SigHash, boolean)},
     ; but defaults to {@link SigHash#ALL} and "false" for the anyoneCanPay flag.  This is normally what you want.
     ;;
    #_public
    (§ method TransactionInput addSignedInput(§ args TransactionOutPoint prevOut, Script scriptPubKey, ECKey sigKey))
        (§ throws ScriptException)
    (§ block
        (§ return addSignedInput(§ pars prevOut, scriptPubKey, sigKey, SigHash.ALL, false))
    )

    ;;;
     ; Adds an input that points to the given output and contains a valid signature for it, calculated using the
     ; signing key.
     ;;
    #_public
    (§ method TransactionInput addSignedInput(§ args TransactionOutput output, ECKey signingKey))
    (§ block
        (§ return addSignedInput(§ pars output.getOutPointFor(§ pars ), output.getScriptPubKey(§ pars ), signingKey))
    )

    ;;;
     ; Adds an input that points to the given output and contains a valid signature for it, calculated using the
     ; signing key.
     ;;
    #_public
    (§ method TransactionInput addSignedInput(§ args TransactionOutput output, ECKey signingKey, SigHash sigHash, boolean anyoneCanPay))
    (§ block
        (§ return addSignedInput(§ pars output.getOutPointFor(§ pars ), output.getScriptPubKey(§ pars ), signingKey, sigHash, anyoneCanPay))
    )

    ;;;
     ; Removes all the outputs from this transaction.
     ; Note that this also invalidates the length attribute.
     ;;
    #_public
    (§ method void clearOutputs(§ args ))
    (§ block
        (§ call unCache(§ pars ))
        (§ for (§ var TransactionOutput output) :for (§ expr outputs))
        (§ block
            (§ call output.setParent(§ pars nil))
        )
        (§ call outputs.clear(§ pars ))
        ;; You wanted to reserialize, right?
        (§ ass this.length = this.unsafeBitcoinSerialize(§ pars ).length)
    )

    ;;;
     ; Adds the given output to this transaction.  The output must be completely initialized.  Returns the given output.
     ;;
    #_public
    (§ method TransactionOutput addOutput(§ args TransactionOutput to))
    (§ block
        (§ call unCache(§ pars ))
        (§ call to.setParent(§ pars this))
        (§ call outputs.add(§ pars to))
        (§ call adjustLength(§ pars outputs.size(§ pars ), to.length))
        (§ return to)
    )

    ;;;
     ; Creates an output based on the given address and value, adds it to this transaction, and returns the new output.
     ;;
    #_public
    (§ method TransactionOutput addOutput(§ args Coin value, Address address))
    (§ block
        (§ return addOutput(§ pars (§ new TransactionOutput(§ pars params, this, value, address))))
    )

    ;;;
     ; Creates an output that pays to the given pubkey directly (no address) with the given value, adds it to this
     ; transaction, and returns the new output.
     ;;
    #_public
    (§ method TransactionOutput addOutput(§ args Coin value, ECKey pubkey))
    (§ block
        (§ return addOutput(§ pars (§ new TransactionOutput(§ pars params, this, value, pubkey))))
    )

    ;;;
     ; Creates an output that pays to the given script.  The address and key forms are specialisations of this method,
     ; you won't normally need to use it unless you're doing unusual things.
     ;;
    #_public
    (§ method TransactionOutput addOutput(§ args Coin value, Script script))
    (§ block
        (§ return addOutput(§ pars (§ new TransactionOutput(§ pars params, this, value, script.getProgram(§ pars )))))
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.  The key
     ; must be usable for signing as-is: if the key is encrypted it must be decrypted first external to this method.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param redeemScript Byte-exact contents of the scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
    #_public
    (§ method TransactionSignature calculateSignature(§ args int inputIndex, ECKey key, byte[] redeemScript, SigHash hashType, boolean anyoneCanPay))
    (§ block
        (§ var Sha256Hash hash = hashForSignature(§ pars inputIndex, redeemScript, hashType, anyoneCanPay))
        (§ return (§ new TransactionSignature(§ pars key.sign(§ pars hash), hashType, anyoneCanPay)))
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param redeemScript The scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
    #_public
    (§ method TransactionSignature calculateSignature(§ args int inputIndex, ECKey key, Script redeemScript, SigHash hashType, boolean anyoneCanPay))
    (§ block
        (§ var Sha256Hash hash = hashForSignature(§ pars inputIndex, redeemScript.getProgram(§ pars ), hashType, anyoneCanPay))
        (§ return (§ new TransactionSignature(§ pars key.sign(§ pars hash), hashType, anyoneCanPay)))
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.  The key
     ; must be usable for signing as-is: if the key is encrypted it must be decrypted first external to this method.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param aesKey The AES key to use for decryption of the private key.  If null then no decryption is required.
     ; @param redeemScript Byte-exact contents of the scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
    #_public
    (§ method TransactionSignature calculateSignature(§ args int inputIndex, ECKey key, #_nilable KeyParameter aesKey, byte[] redeemScript, SigHash hashType, boolean anyoneCanPay))
    (§ block
        (§ var Sha256Hash hash = hashForSignature(§ pars inputIndex, redeemScript, hashType, anyoneCanPay))
        (§ return (§ new TransactionSignature(§ pars key.sign(§ pars hash, aesKey), hashType, anyoneCanPay)))
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param aesKey The AES key to use for decryption of the private key.  If null then no decryption is required.
     ; @param redeemScript The scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
    #_public
    (§ method TransactionSignature calculateSignature(§ args int inputIndex, ECKey key, #_nilable KeyParameter aesKey, Script redeemScript, SigHash hashType, boolean anyoneCanPay))
    (§ block
        (§ var Sha256Hash hash = hashForSignature(§ pars inputIndex, redeemScript.getProgram(§ pars ), hashType, anyoneCanPay))
        (§ return (§ new TransactionSignature(§ pars key.sign(§ pars hash, aesKey), hashType, anyoneCanPay)))
    )

    ;;;
     ; <p>Calculates a signature hash, that is, a hash of a simplified form of the transaction.  How exactly the transaction
     ; is simplified is specified by the type and anyoneCanPay parameters.</p>
     ;
     ; <p>This is a low level API and when using the regular {@link Wallet} class you don't have to call this yourself.
     ; When working with more complex transaction types and contracts, it can be necessary.  When signing a P2SH output
     ; the redeemScript should be the script encoded into the scriptSig field, for normal transactions, it's the
     ; scriptPubKey of the output you're signing for.</p>
     ;
     ; @param inputIndex Input the signature is being calculated for.  Tx signatures are always relative to an input.
     ; @param redeemScript The bytes that should be in the given input during signing.
     ; @param type Should be SigHash.ALL.
     ; @param anyoneCanPay Should be false.
     ;;
    #_public
    (§ method Sha256Hash hashForSignature(§ args int inputIndex, byte[] redeemScript, SigHash type, boolean anyoneCanPay))
    (§ block
        (§ var byte sigHashType = (§ cast byte)TransactionSignature.calcSigHashValue(§ pars type, anyoneCanPay))
        (§ return hashForSignature(§ pars inputIndex, redeemScript, sigHashType))
    )

    ;;;
     ; <p>Calculates a signature hash, that is, a hash of a simplified form of the transaction.  How exactly the transaction
     ; is simplified is specified by the type and anyoneCanPay parameters.</p>
     ;
     ; <p>This is a low level API and when using the regular {@link Wallet} class you don't have to call this yourself.
     ; When working with more complex transaction types and contracts, it can be necessary.  When signing a P2SH output
     ; the redeemScript should be the script encoded into the scriptSig field, for normal transactions, it's the
     ; scriptPubKey of the output you're signing for.</p>
     ;
     ; @param inputIndex Input the signature is being calculated for.  Tx signatures are always relative to an input.
     ; @param redeemScript The script that should be in the given input during signing.
     ; @param type Should be SigHash.ALL.
     ; @param anyoneCanPay Should be false.
     ;;
    #_public
    (§ method Sha256Hash hashForSignature(§ args int inputIndex, Script redeemScript, SigHash type, boolean anyoneCanPay))
    (§ block
        (§ var int sigHash = TransactionSignature.calcSigHashValue(§ pars type, anyoneCanPay))
        (§ return hashForSignature(§ pars inputIndex, redeemScript.getProgram(§ pars ), (§ cast byte)sigHash))
    )

    ;;;
     ; This is required for signatures which use a sigHashType which cannot be represented using SigHash and anyoneCanPay.
     ; See transaction c99c49da4c38af669dea436d3e73780dfdb6c1ecf9958baa52960e8baee30e73, which has sigHashType 0.
     ;;
    #_public
    (§ method Sha256Hash hashForSignature(§ args int inputIndex, byte[] connectedScript, byte sigHashType))
    (§ block
        ;; The SIGHASH flags are used in the design of contracts, please see this page for a further understanding of
        ;; the purposes of the code in this method:
        ;;
        ;;   https://en.bitcoin.it/wiki/Contracts

        (§ try )
        (§ block
            ;; Create a copy of this transaction to operate upon because we need make changes to the inputs and outputs.
            ;; It would not be thread-safe to change the attributes of the transaction object itself.
            (§ var Transaction tx = this.params.getDefaultSerializer(§ pars ).makeTransaction(§ pars this.bitcoinSerialize(§ pars )))

            ;; Clear input scripts in preparation for signing.  If we're signing a fresh transaction that step isn't very
            ;; helpful, but it doesn't add much cost relative to the actual EC math so we'll do it anyway.
            (§ for (§ var int i = 0) :for (§ expr i < tx.inputs.size(§ pars )) :for (§ ass i = i + 1))
            (§ block
                (§ call tx.inputs.get(§ pars i).clearScriptBytes(§ pars ))
            )

            ;; This step has no purpose beyond being synchronized with Bitcoin Core's bugs.  OP_CODESEPARATOR
            ;; is a legacy holdover from a previous, broken design of executing scripts that shipped in Bitcoin 0.1.
            ;; It was seriously flawed and would have let anyone take anyone elses money.  Later versions switched to
            ;; the design we use today where scripts are executed independently but share a stack.  This left the
            ;; OP_CODESEPARATOR instruction having no purpose as it was only meant to be used internally, not actually
            ;; ever put into scripts.  Deleting OP_CODESEPARATOR is a step that should never be required but if we don't
            ;; do it, we could split off the main chain.
            (§ ass connectedScript = Script.removeAllInstancesOfOp(§ pars connectedScript, ScriptOpCodes.OP_CODESEPARATOR))

            ;; Set the input to the script of its output.  Bitcoin Core does this but the step has no obvious purpose as
            ;; the signature covers the hash of the prevout transaction which obviously includes the output script
            ;; already.  Perhaps it felt safer to him in some way, or is another leftover from how the code was written.
            (§ var TransactionInput input = tx.inputs.get(§ pars inputIndex))
            (§ call input.setScriptBytes(§ pars connectedScript))

            (§ if (§ expr (§ expr sigHashType & 0x1f) == SigHash.NONE.value))
            (§ block
                ;; SIGHASH_NONE means no outputs are signed at all - the signature is effectively for a "blank cheque".
                (§ ass tx.outputs = new ArrayList<>(§ pars 0))
                ;; The signature isn't broken by new versions of the transaction issued by other parties.
                (§ for (§ var int i = 0) :for (§ expr i < tx.inputs.size(§ pars )) :for (§ ass i = i + 1))
                (§ block
                    (§ if (§ expr i != inputIndex))
                    (§ block
                        (§ call tx.inputs.get(§ pars i).setSequenceNumber(§ pars 0))
                    )
                )
            )
            (§ elseif (§ expr (§ expr sigHashType & 0x1f) == SigHash.SINGLE.value))
            (§ block
                ;; SIGHASH_SINGLE means only sign the output at the same index as the input (i.e. my output).
                (§ if (§ expr tx.outputs.size(§ pars ) <= inputIndex))
                (§ block
                    ;; The input index is beyond the number of outputs, it's a buggy signature made by a broken
                    ;; Bitcoin implementation.  Bitcoin Core also contains a bug in handling this case:
                    ;; any transaction output that is signed in this case will result in both the signed output
                    ;; and any future outputs to this public key being steal-able by anyone who has
                    ;; the resulting signature and the public key (both of which are part of the signed tx input).

                    ;; Bitcoin Core's bug is that SignatureHash was supposed to return a hash and on this codepath it
                    ;; actually returns the constant "1" to indicate an error, which is never checked for.  Oops.
                    (§ return Sha256Hash.wrap(§ pars "0100000000000000000000000000000000000000000000000000000000000000"))
                )
                ;; In SIGHASH_SINGLE the outputs after the matching input index are deleted, and the outputs before
                ;; that position are "nulled out".  Unintuitively, the value in a "null" transaction is set to -1.
                (§ ass tx.outputs = new ArrayList<>(§ pars tx.outputs.subList(§ pars 0, inputIndex + 1)))
                (§ for (§ var int i = 0) :for (§ expr i < inputIndex) :for (§ ass i = i + 1))
                (§ block
                    (§ call tx.outputs.set(§ pars i, new TransactionOutput(§ pars tx.params, tx, Coin.NEGATIVE_SATOSHI, new byte[] (§ coll ))))
                )
                ;; The signature isn't broken by new versions of the transaction issued by other parties.
                (§ for (§ var int i = 0) :for (§ expr i < tx.inputs.size(§ pars )) :for (§ ass i = i + 1))
                (§ block
                    (§ if (§ expr i != inputIndex))
                    (§ block
                        (§ call tx.inputs.get(§ pars i).setSequenceNumber(§ pars 0))
                    )
                )
            )

            (§ if (§ expr (§ expr sigHashType & SigHash.ANYONECANPAY.value) == SigHash.ANYONECANPAY.value))
            (§ block
                ;; SIGHASH_ANYONECANPAY means the signature in the input is not broken by changes/additions/removals
                ;; of other inputs.  For example, this is useful for building assurance contracts.
                (§ ass tx.inputs = new ArrayList<TransactionInput>(§ pars ))
                (§ call tx.inputs.add(§ pars input))
            )

            (§ var ByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(§ pars (§ expr tx.length == UNKNOWN_LENGTH) ? 256 :else tx.length + 4))
            (§ call tx.bitcoinSerialize(§ pars bos))
            ;; We also have to write a hash type (sigHashType is actually an unsigned char).
            (§ call uint32ToByteStreamLE(§ pars 0x000000ff & sigHashType, bos))
            ;; Note that this is NOT reversed to ensure it will be signed correctly.  If it were to be printed out
            ;; however then we would expect that it is IS reversed.
            (§ var Sha256Hash hash = Sha256Hash.twiceOf(§ pars bos.toByteArray(§ pars )))
            (§ call bos.close(§ pars ))

            (§ return hash)
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
    )

    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ call uint32ToByteStreamLE(§ pars version, stream))
        (§ call stream.write(§ pars (§ new VarInt(§ pars inputs.size(§ pars ))).encode(§ pars )))
        (§ for (§ var TransactionInput in) :for (§ expr inputs))
        (§ block
            (§ call in.bitcoinSerialize(§ pars stream))
        )
        (§ call stream.write(§ pars (§ new VarInt(§ pars outputs.size(§ pars ))).encode(§ pars )))
        (§ for (§ var TransactionOutput out) :for (§ expr outputs))
        (§ block
            (§ call out.bitcoinSerialize(§ pars stream))
        )
        (§ call uint32ToByteStreamLE(§ pars lockTime, stream))
    )

    ;;;
     ; Transactions can have an associated lock time, specified either as a block height or in seconds since the
     ; UNIX epoch.  A transaction is not allowed to be confirmed by miners until the lock time is reached, and
     ; since Bitcoin 0.8+ a transaction that did not end its lock period (non final) is considered to be non
     ; standard and won't be relayed or included in the memory pool either.
     ;;
    #_public
    (§ method long getLockTime(§ args ))
    (§ block
        (§ return lockTime)
    )

    ;;;
     ; Transactions can have an associated lock time, specified either as a block height or in seconds since the
     ; UNIX epoch.  A transaction is not allowed to be confirmed by miners until the lock time is reached, and
     ; since Bitcoin 0.8+ a transaction that did not end its lock period (non final) is considered to be non
     ; standard and won't be relayed or included in the memory pool either.
     ;;
    #_public
    (§ method void setLockTime(§ args long lockTime))
    (§ block
        (§ call unCache(§ pars ))
        (§ var boolean seqNumSet = false)
        (§ for (§ var TransactionInput input) :for (§ expr inputs))
        (§ block
            (§ if (§ expr input.getSequenceNumber(§ pars ) != TransactionInput.NO_SEQUENCE))
            (§ block
                (§ ass seqNumSet = true)
                (§ break )
            )
        )
        (§ if (§ expr lockTime != 0 && (§ expr !seqNumSet || inputs.isEmpty(§ pars ))))
        (§ block
            ;; At least one input must have a non-default sequence number for lock times to have any effect.
            ;; For instance one of them can be set to zero to make this feature work.
            (§ call log.warn(§ pars "You are setting the lock time on a transaction but none of the inputs have non-default sequence numbers. This will not do what you expect!"))
        )
        (§ ass this.lockTime = lockTime)
    )

    #_public
    (§ method long getVersion(§ args ))
    (§ block
        (§ return version)
    )

    #_public
    (§ method void setVersion(§ args int version))
    (§ block
        (§ ass this.version = version)
        (§ call unCache(§ pars ))
    )

    ;;; Returns an unmodifiable view of all inputs. ;;
    #_public
    (§ method List<TransactionInput> getInputs(§ args ))
    (§ block
        (§ return Collections.unmodifiableList(§ pars inputs))
    )

    ;;; Returns an unmodifiable view of all outputs. ;;
    #_public
    (§ method List<TransactionOutput> getOutputs(§ args ))
    (§ block
        (§ return Collections.unmodifiableList(§ pars outputs))
    )

    ;;;
     ; <p>Returns the list of transacion outputs, whether spent or unspent, that match a wallet by address or that are
     ; watched by a wallet, i.e. transaction outputs whose script's address is controlled by the wallet and transaction
     ; outputs whose script is watched by the wallet.</p>
     ;
     ; @param transactionBag The wallet that controls addresses and watches scripts.
     ; @return linked list of outputs relevant to the wallet in this transaction.
     ;;
    #_public
    (§ method List<TransactionOutput> getWalletOutputs(§ args TransactionBag transactionBag))
    (§ block
        (§ var List<TransactionOutput> walletOutputs = new LinkedList<>(§ pars ))

        (§ for (§ var TransactionOutput o) :for (§ expr outputs))
        (§ block
            (§ if (§ expr o.isMine(§ pars transactionBag)))
            (§ block
                (§ call walletOutputs.add(§ pars o))
            )
        )

        (§ return walletOutputs)
    )

    ;;; Randomly re-orders the transaction outputs: good for privacy. ;;
    #_public
    (§ method void shuffleOutputs(§ args ))
    (§ block
        (§ call Collections.shuffle(§ pars outputs))
    )

    ;;; Same as getInputs().get(index). ;;
    #_public
    (§ method TransactionInput getInput(§ args long index))
    (§ block
        (§ return inputs.get(§ pars (§ cast int)index))
    )

    ;;; Same as getOutputs().get(index). ;;
    #_public
    (§ method TransactionOutput getOutput(§ args long index))
    (§ block
        (§ return outputs.get(§ pars (§ cast int)index))
    )

    ;;;
     ; Returns the confidence object for this transaction from the {@link org.bitcoinj.core.TxConfidenceTable}
     ; referenced by the implicit {@link Context}.
     ;;
    #_public
    (§ method TransactionConfidence getConfidence(§ args ))
    (§ block
        (§ return getConfidence(§ pars Context.get(§ pars )))
    )

    ;;;
     ; Returns the confidence object for this transaction from the {@link org.bitcoinj.core.TxConfidenceTable}
     ; referenced by the given {@link Context}.
     ;;
    #_public
    (§ method TransactionConfidence getConfidence(§ args Context context))
    (§ block
        (§ return getConfidence(§ pars context.getConfidenceTable(§ pars )))
    )

    ;;;
     ; Returns the confidence object for this transaction from the {@link org.bitcoinj.core.TxConfidenceTable}.
     ;;
    #_public
    (§ method TransactionConfidence getConfidence(§ args TxConfidenceTable table))
    (§ block
        (§ if (§ expr confidence == nil))
        (§ block
            (§ ass confidence = table.getOrCreate(§ pars getHash(§ pars )))
        )
        (§ return confidence)
    )

    ;;; Check if the transaction has a known confidence. ;;
    #_public
    (§ method boolean hasConfidence(§ args ))
    (§ block
        (§ return (§ expr getConfidence(§ pars ).getConfidenceType(§ pars ) != TransactionConfidence.ConfidenceType.UNKNOWN))
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return getHash(§ pars ).equals(§ pars (§ expr (§ cast Transaction)o).getHash(§ pars )))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return getHash(§ pars ).hashCode(§ pars ))
    )

    ;;;
     ; Gets the count of regular SigOps in this transactions.
     ;;
    #_public
    (§ method int getSigOpCount(§ args ))
        (§ throws ScriptException)
    (§ block
        (§ var int sigOps = 0)
        (§ for (§ var TransactionInput input) :for (§ expr inputs))
        (§ block
            (§ ass sigOps = sigOps + Script.getSigOpCount(§ pars input.getScriptBytes(§ pars )))
        )
        (§ for (§ var TransactionOutput output) :for (§ expr outputs))
        (§ block
            (§ ass sigOps = sigOps + Script.getSigOpCount(§ pars output.getScriptBytes(§ pars )))
        )
        (§ return sigOps)
    )

    ;;;
     ; Check block height is in coinbase input script, for use after BIP 34
     ; enforcement is enabled.
     ;;
    #_public
    (§ method void checkCoinBaseHeight(§ args #_final int height))
        (§ throws VerificationException)
    (§ block
        (§ call Preconditions.checkArgument(§ pars Block.BLOCK_HEIGHT_GENESIS <= height))
        (§ call Preconditions.checkState(§ pars isCoinBase(§ pars )))

        ;; Check block height is in coinbase input script.
        #_final
        (§ var TransactionInput in = this.getInputs(§ pars ).get(§ pars 0))
        #_final
        (§ var ScriptBuilder builder = new ScriptBuilder(§ pars ))
        (§ call builder.number(§ pars height))
        #_final
        (§ var byte[] expected = builder.build(§ pars ).getProgram(§ pars ))
        #_final
        (§ var byte[] actual = in.getScriptBytes(§ pars ))
        (§ if (§ expr actual.length < expected.length))
        (§ block
            (§ throw new VerificationException.CoinbaseHeightMismatch(§ pars "Block height mismatch in coinbase."))
        )

        (§ for (§ var int scriptIdx = 0) :for (§ expr scriptIdx < expected.length) :for (§ ass scriptIdx = scriptIdx + 1))
        (§ block
            (§ if (§ expr actual[scriptIdx] != expected[scriptIdx]))
            (§ block
                (§ throw new VerificationException.CoinbaseHeightMismatch(§ pars "Block height mismatch in coinbase."))
            )
        )
    )

    ;;;
     ; <p>Checks the transaction contents for sanity, in ways that can be done in a standalone manner.
     ; Does <b>not</b> perform all checks on a transaction such as whether the inputs are already spent.
     ; Specifically this method verifies:</p>
     ;
     ; <ul>
     ;     <li>That there is at least one input and output.</li>
     ;     <li>That the serialized size is not larger than the max block size.</li>
     ;     <li>That no outputs have negative value.</li>
     ;     <li>That the outputs do not sum to larger than the max allowed quantity of coin in the system.</li>
     ;     <li>If the tx is a coinbase tx, the coinbase scriptSig size is within range.  Otherwise that
     ;     there are no coinbase inputs in the tx.</li>
     ; </ul>
     ;
     ; @throws VerificationException
     ;;
    #_public
    (§ method void verify(§ args ))
        (§ throws VerificationException)
    (§ block
        (§ if (§ expr inputs.size(§ pars ) == 0 || outputs.size(§ pars ) == 0))
        (§ block
            (§ throw new VerificationException.EmptyInputsOrOutputs(§ pars ))
        )
        (§ if (§ expr Block.MAX_BLOCK_SIZE < this.getMessageSize(§ pars )))
        (§ block
            (§ throw new VerificationException.LargerThanMaxBlockSize(§ pars ))
        )

        (§ var Coin valueOut = Coin.ZERO)
        (§ var HashSet<TransactionOutPoint> outpoints = new HashSet<>(§ pars ))
        (§ for (§ var TransactionInput input) :for (§ expr inputs))
        (§ block
            (§ if (§ expr outpoints.contains(§ pars input.getOutpoint(§ pars ))))
            (§ block
                (§ throw new VerificationException.DuplicatedOutPoint(§ pars ))
            )
            (§ call outpoints.add(§ pars input.getOutpoint(§ pars )))
        )
        (§ try )
        (§ block
            (§ for (§ var TransactionOutput output) :for (§ expr outputs))
            (§ block
                (§ if (§ expr output.getValue(§ pars ).signum(§ pars ) < 0)) ;; getValue() can throw IllegalStateException
                (§ block
                    (§ throw new VerificationException.NegativeValueOutput(§ pars ))
                )

                (§ ass valueOut = valueOut.add(§ pars output.getValue(§ pars )))
                (§ if (§ expr params.hasMaxMoney(§ pars ) && 0 < valueOut.compareTo(§ pars params.getMaxMoney(§ pars ))))
                (§ block
                    (§ throw (§ new IllegalArgumentException(§ pars )))
                )
            )
        )
        (§ catch (§ args IllegalStateException _))
        (§ block
            (§ throw new VerificationException.ExcessiveValue(§ pars ))
        )
        (§ catch (§ args IllegalArgumentException _))
        (§ block
            (§ throw new VerificationException.ExcessiveValue(§ pars ))
        )

        (§ if (§ expr isCoinBase(§ pars )))
        (§ block
            (§ var int n = inputs.get(§ pars 0).getScriptBytes(§ pars ).length)
            (§ if (§ expr n < 2 || 100 < n))
            (§ block
                (§ throw new VerificationException.CoinbaseScriptSizeOutOfRange(§ pars ))
            )
        )
        (§ else )
        (§ block
            (§ for (§ var TransactionInput input) :for (§ expr inputs))
            (§ block
                (§ if (§ expr input.isCoinBase(§ pars )))
                (§ block
                    (§ throw new VerificationException.UnexpectedCoinbaseInput(§ pars ))
                )
            )
        )
    )

    ;;;
     ; <p>A transaction is time locked if at least one of its inputs is non-final and it has a lock time.</p>
     ;
     ; <p>To check if this transaction is final at a given height and time, see {@link Transaction#isFinal(int, long)}.</p>
     ;;
    #_public
    (§ method boolean isTimeLocked(§ args ))
    (§ block
        (§ if (§ expr getLockTime(§ pars ) == 0))
        (§ block
            (§ return false)
        )
        (§ for (§ var TransactionInput input) :for (§ expr getInputs(§ pars )))
        (§ block
            (§ if (§ expr input.hasSequence(§ pars )))
            (§ block
                (§ return true)
            )
        )
        (§ return false)
    )

    ;;;
     ; Returns whether this transaction will opt into the
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki">full replace-by-fee</a> semantics.
     ;;
    #_public
    (§ method boolean isOptInFullRBF(§ args ))
    (§ block
        (§ for (§ var TransactionInput input) :for (§ expr getInputs(§ pars )))
        (§ block
            (§ if (§ expr input.isOptInFullRBF(§ pars )))
            (§ block
                (§ return true)
            )
        )
        (§ return false)
    )

    ;;;
     ; <p>Returns true if this transaction is considered finalized and can be placed in a block.  Non-finalized
     ; transactions won't be included by miners and can be replaced with newer versions using sequence numbers.
     ; This is useful in certain types of <a href="http://en.bitcoin.it/wiki/Contracts">contracts</a>, such as
     ; micropayment channels.</p>
     ;
     ; <p>Note that currently the replacement feature is disabled in Bitcoin Core and will need to be
     ; re-activated before this functionality is useful.</p>
     ;;
    #_public
    (§ method boolean isFinal(§ args int height, long blockTimeSeconds))
    (§ block
        (§ var long time = getLockTime(§ pars ))
        (§ return (§ expr time < (§ expr time < LOCKTIME_THRESHOLD ? height :else blockTimeSeconds) || !isTimeLocked(§ pars )))
    )

    ;;;
     ; Returns either the lock time as a date, if it was specified in seconds, or an estimate based on the time in
     ; the current head block if it was specified as a block time.
     ;;
    #_public
    (§ method Date estimateLockTime(§ args AbstractBlockChain chain))
    (§ block
        (§ return (§ quest (§ expr lockTime < LOCKTIME_THRESHOLD) ? chain.estimateBlockTime(§ pars (§ cast int)getLockTime(§ pars )) :else new Date(§ pars getLockTime(§ pars ) * 1000)))
    )

    ;;;
     ; Returns the purpose for which this transaction was created.  See the javadoc for {@link Purpose} for more
     ; information on the point of this field and what it can be.
     ;;
    #_public
    (§ method Purpose getPurpose(§ args ))
    (§ block
        (§ return purpose)
    )

    ;;;
     ; Marks the transaction as being created for the given purpose.  See the javadoc for {@link Purpose} for more
     ; information on the point of this field and what it can be.
     ;;
    #_public
    (§ method void setPurpose(§ args Purpose purpose))
    (§ block
        (§ ass this.purpose = purpose)
    )

    ;;;
     ; Getter for {@link #exchangeRate}.
     ;;
    #_nilable
    #_public
    (§ method ExchangeRate getExchangeRate(§ args ))
    (§ block
        (§ return exchangeRate)
    )

    ;;;
     ; Setter for {@link #exchangeRate}.
     ;;
    #_public
    (§ method void setExchangeRate(§ args ExchangeRate exchangeRate))
    (§ block
        (§ ass this.exchangeRate = exchangeRate)
    )

    ;;;
     ; Returns the transaction {@link #memo}.
     ;;
    #_public
    (§ method String getMemo(§ args ))
    (§ block
        (§ return memo)
    )

    ;;;
     ; Set the transaction {@link #memo}.  It can be used to record the memo of the payment request that initiated the
     ; transaction.
     ;;
    #_public
    (§ method void setMemo(§ args String memo))
    (§ block
        (§ ass this.memo = memo)
    )
)

#_(ns org.bitcoinj.core #_"TransactionBag"
    (:import [java.util Map])
   (:require [org.bitcoinj.script Script]
             [org.bitcoinj.wallet WalletTransaction]))

;;;
 ; This interface is used to abstract the {@link org.bitcoinj.wallet.Wallet} and the {@link org.bitcoinj.core.Transaction}.
 ;;
#_public
(§ interface TransactionBag
    ;;; Returns true if this wallet contains a public key which hashes to the given hash. ;;
    (§ method boolean isPubKeyHashMine(§ args byte[] pubkeyHash))

    ;;; Returns true if this wallet contains a keypair with the given public key. ;;
    (§ method boolean isPubKeyMine(§ args byte[] pubkey))

    ;;; Returns true if this wallet knows the script corresponding to the given hash. ;;
    (§ method boolean isPayToScriptHashMine(§ args byte[] payToScriptHash))

    ;;; Returns transactions from a specific pool. ;;
    (§ method Map<Sha256Hash, Transaction> getTransactionPool(§ args WalletTransaction.Pool pool))
)

#_(ns org.bitcoinj.core #_"TransactionBroadcast"
    (:import [java.util *]
             [java.util.concurrent *])
    (:import [com.google.common.annotations *]
             [com.google.common.base *]
             [com.google.common.util.concurrent *]
             [org.slf4j *])
   (:require [org.bitcoinj.core.listeners PreMessageReceivedEventListener]
             [org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; Represents a single transaction broadcast that we are performing.  A broadcast occurs after a new transaction is created
 ; (typically by a {@link Wallet}) and needs to be sent to the network.  A broadcast can succeed or fail.  A success is
 ; defined as seeing the transaction be announced by peers via inv messages, thus indicating their acceptance.  A failure
 ; is defined as not reaching acceptance within a timeout period, or getting an explicit reject message from a peer
 ; indicating that the transaction was not acceptable.
 ;;
#_public
(§ class TransactionBroadcast
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars TransactionBroadcast.class))

    #_private
    #_final
    (§ field SettableFuture<Transaction> future = SettableFuture.create(§ pars ))
    #_private
    #_final
    (§ field PeerGroup peerGroup)
    #_private
    #_final
    (§ field Transaction tx)
    #_private
    (§ field int minConnections)
    #_private
    (§ field int numWaitingFor)

    ;;; Used for shuffling the peers before broadcast: unit tests can replace this to make themselves deterministic. ;;
    #_testing
    #_public
    #_static
    (§ field Random random = new Random(§ pars ))

    ;; Tracks which nodes sent us a reject message about this broadcast, if any.  Useful for debugging.
    #_private
    (§ field Map<Peer, RejectMessage> rejects = Collections.synchronizedMap(§ pars new HashMap<Peer, RejectMessage>(§ pars )))

    (§ constructor TransactionBroadcast(§ args PeerGroup peerGroup, Transaction tx))
    (§ block
        (§ ass this.peerGroup = peerGroup)
        (§ ass this.tx = tx)
        (§ ass this.minConnections = Math.max(§ pars 1, peerGroup.getMinBroadcastConnections(§ pars )))
    )

    ;; Only for mock broadcasts.
    #_private
    (§ constructor TransactionBroadcast(§ args Transaction tx))
    (§ block
        (§ ass this.peerGroup = nil)
        (§ ass this.tx = tx)
    )

    #_testing
    #_public
    #_static
    (§ method TransactionBroadcast createMockBroadcast(§ args Transaction tx, #_final SettableFuture<Transaction> future))
    (§ block
        (§ return (§ new TransactionBroadcast(§ pars tx))
        (§ anon
            #_override
            #_public
            (§ method ListenableFuture<Transaction> broadcast(§ args ))
            (§ block
                (§ return future)
            )

            #_override
            #_public
            (§ method ListenableFuture<Transaction> future(§ args ))
            (§ block
                (§ return future)
            )
        ))
    )

    #_public
    (§ method ListenableFuture<Transaction> future(§ args ))
    (§ block
        (§ return future)
    )

    #_public
    (§ method void setMinConnections(§ args int minConnections))
    (§ block
        (§ ass this.minConnections = minConnections)
    )

    #_private
    (§ field PreMessageReceivedEventListener rejectionListener = new PreMessageReceivedEventListener(§ pars )
        (§ anon
            #_override
            #_public
            (§ method Message onPreMessageReceived(§ args Peer peer, Message m))
            (§ block
                (§ if (§ expr m instanceof RejectMessage))
                (§ block
                    (§ var RejectMessage rejectMessage = (§ cast RejectMessage)m)
                    (§ if (§ expr tx.getHash(§ pars ).equals(§ pars rejectMessage.getRejectedObjectHash(§ pars ))))
                    (§ block
                        (§ call rejects.put(§ pars peer, rejectMessage))
                        (§ var int size = rejects.size(§ pars ))
                        (§ var long threshold = Math.round(§ pars numWaitingFor / 2.0))
                        (§ if (§ expr threshold < size))
                        (§ block
                            (§ call log.warn(§ pars "Threshold for considering broadcast rejected has been reached ({}/{})", size, threshold))
                            (§ call future.setException(§ pars (§ new RejectedTransactionException(§ pars tx, rejectMessage))))
                            (§ call peerGroup.removePreMessageReceivedEventListener(§ pars this))
                        )
                    )
                )
                (§ return m)
            )
        ))

    #_public
    (§ method ListenableFuture<Transaction> broadcast(§ args ))
    (§ block
        (§ call peerGroup.addPreMessageReceivedEventListener(§ pars Threading.SAME_THREAD, rejectionListener))
        (§ call log.info(§ pars "Waiting for {} peers required for broadcast, we have {} ...", minConnections, peerGroup.getConnectedPeers(§ pars ).size(§ pars )))
        (§ call peerGroup.waitForPeers(§ pars minConnections).addListener(§ pars (§ new EnoughAvailablePeers(§ pars )), Threading.SAME_THREAD))
        (§ return future)
    )

    #_private
    (§ class EnoughAvailablePeers implements Runnable
        #_override
        #_public
        (§ method void run(§ args ))
        (§ block
            ;; We now have enough connected peers to send the transaction.
            ;; This can be called immediately if we already have enough.  Otherwise it'll be called from a peer thread.

            ;; We will send the tx simultaneously to half the connected peers and wait to hear back from at least half
            ;; of the other half, i.e. with 4 peers connected we will send the tx to 2 randomly chosen peers, and then
            ;; wait for it to show up on one of the other two.  This will be taken as sign of network acceptance.  As can
            ;; be seen, 4 peers is probably too little - it doesn't taken many broken peers for tx propagation to have
            ;; a big effect.
            (§ var List<Peer> peers = peerGroup.getConnectedPeers(§ pars )) ;; snapshots
            ;; Prepare to send the transaction by adding a listener that'll be called when confidence changes.
            ;; Only bother with this if we might actually hear back:
            (§ if (§ expr 1 < minConnections))
            (§ block
                (§ call tx.getConfidence(§ pars ).addEventListener(§ pars (§ new ConfidenceChange(§ pars ))))
            )
            ;; Bitcoin Core sends an inv in this case and then lets the peer request the tx data.  We just
            ;; blast out the TX here for a couple of reasons.  Firstly it's simpler: in the case where we have
            ;; just a single connection we don't have to wait for getdata to be received and handled before
            ;; completing the future in the code immediately below.  Secondly, it's faster.  The reason the
            ;; Bitcoin Core sends an inv is privacy - it means you can't tell if the peer originated the
            ;; transaction or not.  However, we are not a fully validating node and this is advertised in
            ;; our version message, as SPV nodes cannot relay it doesn't give away any additional information
            ;; to skip the inv here - we wouldn't send invs anyway.
            (§ var int numConnected = peers.size(§ pars ))
            (§ var int numToBroadcastTo = (§ cast int)Math.max(§ pars 1, Math.round(§ pars Math.ceil(§ pars peers.size(§ pars ) / 2.0))))
            (§ ass numWaitingFor = (§ cast int)Math.ceil(§ pars (§ expr peers.size(§ pars ) - numToBroadcastTo) / 2.0))
            (§ call Collections.shuffle(§ pars peers, random))
            (§ ass peers = peers.subList(§ pars 0, numToBroadcastTo))
            (§ call log.info(§ pars "broadcastTransaction: We have {} peers, adding {} to the memory pool", numConnected, tx.getHashAsString(§ pars )))
            (§ call log.info(§ pars "Sending to {} peers, will wait for {}, sending to: {}", numToBroadcastTo, numWaitingFor, Joiner.on(§ pars ",").join(§ pars peers)))
            (§ for (§ var Peer peer) :for (§ expr peers))
            (§ block
                (§ try )
                (§ block
                    (§ call peer.sendMessage(§ pars tx))
                    ;; We don't record the peer as having seen the tx in the memory pool because we want to track only
                    ;; how many peers announced to us.
                )
                (§ catch (§ args Exception e))
                (§ block
                    (§ call log.error(§ pars "Caught exception sending to {}", peer, e))
                )
            )
            ;; If we've been limited to talk to only one peer, we can't wait to hear back because the
            ;; remote peer won't tell us about transactions we just announced to it for obvious reasons.
            ;; So we just have to assume we're done, at that point.  This happens when we're not given
            ;; any peer discovery source and the user just calls connectTo() once.
            (§ if (§ expr minConnections == 1))
            (§ block
                (§ call peerGroup.removePreMessageReceivedEventListener(§ pars rejectionListener))
                (§ call future.set(§ pars tx))
            )
        )
    )

    #_private
    (§ field int numSeemPeers)
    #_private
    (§ field boolean mined)

    #_private
    (§ class ConfidenceChange implements TransactionConfidence.Listener
        #_override
        #_public
        (§ method void onConfidenceChanged(§ args TransactionConfidence conf, ChangeReason reason))
        (§ block
            ;; The number of peers that announced this tx has gone up.
            (§ var int numSeenPeers = conf.numBroadcastPeers(§ pars ) + rejects.size(§ pars ))
            (§ var boolean mined = (§ expr tx.getAppearsInHashes(§ pars ) != nil))
            (§ call log.info(§ pars "broadcastTransaction: {}:  TX {} seen by {} peers{}", reason, tx.getHashAsString(§ pars ), numSeenPeers, mined ? " and mined" :else ""))

            ;; Progress callback on the requested thread.
            (§ call invokeAndRecord(§ pars numSeenPeers, mined))

            (§ if (§ expr numWaitingFor <= numSeenPeers || mined))
            (§ block
                ;; We've seen the min required number of peers announce the transaction, or it was included
                ;; in a block.  Normally we'd expect to see it fully propagate before it gets mined, but
                ;; it can be that a block is solved very soon after broadcast, and it's also possible that
                ;; due to version skew and changes in the relay rules our transaction is not going to
                ;; fully propagate yet can get mined anyway.
                ;;
                ;; Note that we can't wait for the current number of connected peers right now because we
                ;; could have added more peers after the broadcast took place, which means they won't
                ;; have seen the transaction.  In future when peers sync up their memory pools after they
                ;; connect we could come back and change this.
                ;;
                ;; We're done!  It's important that the PeerGroup lock is not held (by this thread) at this
                ;; point to avoid triggering inversions when the Future completes.
                (§ call log.info(§ pars "broadcastTransaction: {} complete", tx.getHash(§ pars )))
                (§ call peerGroup.removePreMessageReceivedEventListener(§ pars rejectionListener))
                (§ call conf.removeEventListener(§ pars this))
                (§ call future.set(§ pars tx)) ;; RE-ENTRANCY POINT
            )
        )
    )

    #_private
    (§ method void invokeAndRecord(§ args int numSeenPeers, boolean mined))
    (§ block
        (§ sync this)
        (§ block
            (§ ass this.numSeemPeers = numSeenPeers)
            (§ ass this.mined = mined)
        )
        (§ call invokeProgressCallback(§ pars numSeenPeers, mined))
    )

    #_private
    (§ method void invokeProgressCallback(§ args int numSeenPeers, boolean mined))
    (§ block
        #_final
        (§ var ProgressCallback callback)
        (§ var Executor executor)
        (§ sync this)
        (§ block
            (§ ass callback = this.callback)
            (§ ass executor = this.progressCallbackExecutor)
        )
        (§ if (§ expr callback != nil))
        (§ block
            #_final
            (§ var double progress = Math.min(§ pars 1.0, mined ? 1.0 :else numSeenPeers / (§ cast double)numWaitingFor))
            (§ call Preconditions.checkState(§ pars 0.0 <= progress && progress <= 1.0, progress))
            (§ try )
            (§ block
                (§ if (§ expr executor == nil))
                (§ block
                    (§ call callback.onBroadcastProgress(§ pars progress))
                )
                (§ else )
                (§ block
                    (§ call executor.execute(§ pars (§ new Runnable(§ pars ))
                    (§ anon
                        #_override
                        #_public
                        (§ method void run(§ args ))
                        (§ block
                            (§ call callback.onBroadcastProgress(§ pars progress))
                        )
                    )))
                )
            )
            (§ catch (§ args Throwable e))
            (§ block
                (§ call log.error(§ pars "Exception during progress callback", e))
            )
        )
    )

    ;;; An interface for receiving progress information on the propagation of the tx, from 0.0 to 1.0 ;;
    #_public
    (§ interface ProgressCallback
        ;;;
         ; onBroadcastProgress will be invoked on the provided executor when the progress of the transaction
         ; broadcast has changed, because the transaction has been announced by another peer or because the transaction
         ; was found inside a mined block (in this case progress will go to 1.0 immediately).  Any exceptions thrown
         ; by this callback will be logged and ignored.
         ;;
        (§ method void onBroadcastProgress(§ args double progress))
    )

    #_nilable
    #_private
    (§ field ProgressCallback callback)
    #_nilable
    #_private
    (§ field Executor progressCallbackExecutor)

    ;;;
     ; Sets the given callback for receiving progress values, which will run on the user thread.
     ; See {@link org.bitcoinj.utils.Threading} for details.  If the broadcast has already started then the callback will
     ; be invoked immediately with the current progress.
     ;;
    #_public
    (§ method void setProgressCallback(§ args ProgressCallback callback))
    (§ block
        (§ call setProgressCallback(§ pars callback, Threading.USER_THREAD))
    )

    ;;;
     ; Sets the given callback for receiving progress values, which will run on the given executor.  If the executor
     ; is null, then the callback will run on a network thread and may be invoked multiple times in parallel.  You
     ; probably want to provide your UI thread or Threading.USER_THREAD for the second parameter.  If the broadcast
     ; has already started, then the callback will be invoked immediately with the current progress.
     ;;
    #_public
    (§ method void setProgressCallback(§ args ProgressCallback callback, #_nilable Executor executor))
    (§ block
        (§ var boolean shouldInvoke)
        (§ var int num)
        (§ var boolean mined)
        (§ sync this)
        (§ block
            (§ ass this.callback = callback)
            (§ ass this.progressCallbackExecutor = executor)
            (§ ass num = this.numSeemPeers)
            (§ ass mined = this.mined)
            (§ ass shouldInvoke = (§ expr 0 < numWaitingFor))
        )
        (§ if (§ expr shouldInvoke))
        (§ block
            (§ call invokeProgressCallback(§ pars num, mined))
        )
    )
)

#_(ns org.bitcoinj.core #_"TransactionBroadcaster")

;;;
 ; A general interface which declares the ability to broadcast transactions.
 ; This is implemented by {@link org.bitcoinj.core.PeerGroup}.
 ;;
#_public
(§ interface TransactionBroadcaster
    ;;; Broadcast the given transaction on the network. ;;
    (§ method TransactionBroadcast broadcastTransaction(§ args #_final Transaction tx))
)

#_(ns org.bitcoinj.core #_"TransactionConfidence"
    (:import [java.util *]
             [java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect *]
             [com.google.common.util.concurrent *])
   (:require [org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

;; TODO: Modify the getDepthInBlocks method to require the chain height to be specified, in preparation for ceasing to touch every tx on every block.

;;;
 ; <p>A TransactionConfidence object tracks data you can use to make a confidence decision about a transaction.
 ; It also contains some pre-canned rules for common scenarios: if you aren't really sure what level of confidence
 ; you need, these should prove useful.  You can get a confidence object using {@link Transaction#getConfidence()}.
 ; They cannot be constructed directly.</p>
 ;
 ; <p>Confidence in a transaction can come in multiple ways:</p>
 ;
 ; <ul>
 ; <li>Because you created it yourself and only you have the necessary keys.</li>
 ; <li>Receiving it from a fully validating peer you know is trustworthy, for instance, because it's run by yourself.</li>
 ; <li>Receiving it from a peer on the network you randomly chose.  If your network connection is not being
 ;     intercepted, you have a pretty good chance of connecting to a node that is following the rules.</li>
 ; <li>Receiving it from multiple peers on the network.  If your network connection is not being intercepted,
 ;     hearing about a transaction from multiple peers indicates the network has accepted the transaction and
 ;     thus miners likely have too (miners have the final say in whether a transaction becomes valid or not).</li>
 ; <li>Seeing the transaction appear appear in a block on the main chain.  Your confidence increases as the transaction
 ;     becomes further buried under work.  Work can be measured either in blocks (roughly, units of time), or
 ;     amount of work done.</li>
 ; </ul>
 ;
 ; <p>Alternatively, you may know that the transaction is "dead", that is, one or more of its inputs have
 ; been double spent and will never confirm unless there is another re-org.</p>
 ;
 ; <p>TransactionConfidence is updated via the {@link org.bitcoinj.core.TransactionConfidence#incrementDepthInBlocks()}
 ; method to ensure the block depth is up to date.</p>
 ; To make a copy that won't be changed, use {@link org.bitcoinj.core.TransactionConfidence#duplicate()}.
 ;;
#_public
(§ class TransactionConfidence
    ;;;
     ; The peers that have announced the transaction to us.  Network nodes don't have stable identities, so we use
     ; IP address as an approximation.  It's obviously vulnerable to being gamed if we allow arbitrary people to connect
     ; to us, so only peers we explicitly connected to should go here.
     ;;
    #_private
    (§ field CopyOnWriteArrayList<PeerAddress> broadcastBy)
    ;;; The time the transaction was last announced to us. ;;
    #_private
    (§ field Date lastBroadcastedAt)
    ;;; The Transaction that this confidence object is associated with. ;;
    #_private
    #_final
    (§ field Sha256Hash hash)
    ;; Lazily created listeners array.
    #_private
    (§ field CopyOnWriteArrayList<ListenerRegistration<Listener>> listeners)

    ;; The depth of the transaction on the best chain in blocks.  An unconfirmed block has depth 0.
    #_private
    (§ field int depth)

    ;;; Describes the state of the transaction in general terms.  Properties can be read to learn specifics. ;;
    #_public
    (§ enum ConfidenceType
        ;;; If BUILDING, then the transaction is included in the best chain and your confidence in it is increasing. ;;
        (§ item BUILDING(§ pars 1))

        ;;;
         ; If PENDING, then the transaction is unconfirmed and should be included shortly, as long as it is being
         ; announced and is considered valid by the network.  A pending transaction will be announced if the containing
         ; wallet has been attached to a live {@link PeerGroup} using {@link PeerGroup#addWallet(Wallet)}.
         ; You can estimate how likely the transaction is to be included by connecting to a bunch of nodes then measuring
         ; how many announce it, using {@link org.bitcoinj.core.TransactionConfidence#numBroadcastPeers()}.
         ; Or if you saw it from a trusted peer, you can assume it's valid and will get mined sooner or later as well.
         ;;
        (§ item PENDING(§ pars 2))

        ;;;
         ; If DEAD, then it means the transaction won't confirm unless there is another re-org,
         ; because some other transaction is spending one of its inputs.  Such transactions should be alerted to the user
         ; so they can take action, e.g. suspending shipment of goods if they are a merchant.
         ; It can also mean that a coinbase transaction has been made dead from it being moved onto a side chain.
         ;;
        (§ item DEAD(§ pars 4))

        ;;;
         ; If IN_CONFLICT, then it means there is another transaction (or several other transactions) spending one
         ; (or several) of its inputs but nor this transaction nor the other/s transaction/s are included in the best chain.
         ; The other/s transaction/s should be IN_CONFLICT too.
         ; IN_CONFLICT can be thought as an intermediary state between a. PENDING and BUILDING or b. PENDING and DEAD.
         ; Another common name for this situation is "double spend".
         ;;
        (§ item IN_CONFLICT(§ pars 5))

        ;;;
         ; If a transaction hasn't been broadcast yet, or there's no record of it, its confidence is UNKNOWN.
         ;;
        (§ item UNKNOWN(§ pars 0))

        #_private
        (§ field int value)

        (§ constructor ConfidenceType(§ args int value))
        (§ block
            (§ ass this.value = value)
        )

        #_public
        (§ method int getValue(§ args ))
        (§ block
            (§ return value)
        )
    )

    #_private
    (§ field ConfidenceType confidenceType = ConfidenceType.UNKNOWN)
    #_private
    (§ field int appearedAtChainHeight = -1)
    ;; The transaction that double spent this one, if any.
    #_private
    (§ field Transaction overridingTransaction)

    ;;;
     ; Information about where the transaction was first seen (network, sent direct from peer, created by ourselves).
     ; Useful for risk analyzing pending transactions.  Probably not that useful after a tx is included in the chain,
     ; unless re-org double spends start happening frequently.
     ;;
    #_public
    (§ enum Source
        ;;; We don't know where the transaction came from. ;;
        (§ item UNKNOWN)
        ;;; We got this transaction from a network peer. ;;
        (§ item NETWORK)
        ;;; This transaction was created by our own wallet, so we know it's not a double spend. ;;
        (§ item SELF)
    )
    #_private
    (§ field Source source = Source.UNKNOWN)

    #_public
    (§ constructor TransactionConfidence(§ args Sha256Hash hash))
    (§ block
        ;; Assume a default number of peers for our set.
        (§ ass broadcastBy = new CopyOnWriteArrayList<>(§ pars ))
        (§ ass listeners = new CopyOnWriteArrayList<>(§ pars ))
        (§ ass this.hash = hash)
    )

    ;;;
     ; <p>A confidence listener is informed when the level of {@link TransactionConfidence} is updated by something, like
     ; for example a {@link Wallet}.  You can add listeners to update your user interface or manage your order tracking
     ; system when confidence levels pass a certain threshold.  <b>Note that confidence can go down as well as up.</b>
     ; For example, this can happen if somebody is doing a double-spend attack against you.  Whilst it's unlikely, your
     ; code should be able to handle that in order to be correct.</p>
     ;
     ; <p>During listener execution, it's safe to remove the current listener but not others.</p>
     ;;
    #_public
    (§ interface Listener
        ;;; An enum that describes why a transaction confidence listener is being invoked (i.e. the class of change). ;;
        (§ enum ChangeReason
            ;;;
             ; Occurs when the type returned by {@link org.bitcoinj.core.TransactionConfidence#getConfidenceType()}
             ; has changed.  For example, if a PENDING transaction changes to BUILDING or DEAD, then this reason will
             ; be given.  It's a high level summary.
             ;;
            (§ item TYPE)

            ;;;
             ; Occurs when a transaction that is in the best known block chain gets buried by another block.  If you're
             ; waiting for a certain number of confirmations, this is the reason to watch out for.
             ;;
            (§ item DEPTH)

            ;;;
             ; Occurs when a pending transaction (not in the chain) was announced by another connected peers.  By
             ; watching the number of peers that announced a transaction go up, you can see whether it's being
             ; accepted by the network or not.  If all your peers announce, it's a pretty good bet the transaction
             ; is considered relayable and has thus reached the miners.
             ;;
            (§ item SEEN_PEERS)
        )

        (§ method void onConfidenceChanged(§ args TransactionConfidence confidence, ChangeReason reason))
    )

    ;; This is used to ensure that confidence objects which aren't referenced from anywhere but which have an event
    ;; listener set on them don't become eligible for garbage collection.  Otherwise the TxConfidenceTable, which only
    ;; has weak references to these objects, would not be enough to keep the event listeners working as transactions
    ;; propagate around the network - it cannot know directly if the API user is interested in the object, so it uses
    ;; heap reachability as a proxy for interest.
    ;;
    ;; We add ourselves to this set when a listener is added and remove ourselves when the listener list is empty.
    #_private
    #_static
    #_final
    (§ field Set<TransactionConfidence> pinnedConfidenceObjects = Collections.synchronizedSet(§ pars new HashSet<TransactionConfidence>(§ pars )))

    ;;;
     ; <p>Adds an event listener that will be run when this confidence object is updated.  The listener will be locked
     ; and is likely to be invoked on a peer thread.</p>
     ;
     ; <p>Note that this is NOT called when every block arrives.  Instead it is called when the transaction
     ; transitions between confidence states, i.e. from not being seen in the chain to being seen (not necessarily in
     ; the best chain).  If you want to know when the transaction gets buried under another block, consider using
     ; a future from {@link #getDepthFuture(int)}.</p>
     ;;
    #_public
    (§ method void addEventListener(§ args Executor executor, Listener listener))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars listener))

        (§ call listeners.addIfAbsent(§ pars new ListenerRegistration<>(§ pars listener, executor)))
        (§ call pinnedConfidenceObjects.add(§ pars this))
    )

    ;;;
     ; <p>Adds an event listener that will be run when this confidence object is updated.  The listener will be locked
     ; and is likely to be invoked on a peer thread.</p>
     ;
     ; <p>Note that this is NOT called when every block arrives.  Instead it is called when the transaction
     ; transitions between confidence states, i.e. from not being seen in the chain to being seen (not necessarily in
     ; the best chain).  If you want to know when the transaction gets buried under another block, implement a
     ; {@link BlockChainListener}, attach it to a {@link BlockChain} and then use the getters on the
     ; confidence object to determine the new depth.</p>
     ;;
    #_public
    (§ method void addEventListener(§ args Listener listener))
    (§ block
        (§ call addEventListener(§ pars Threading.USER_THREAD, listener))
    )

    #_public
    (§ method boolean removeEventListener(§ args Listener listener))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars listener))

        (§ var boolean removed = ListenerRegistration.removeFromList(§ pars listener, listeners))
        (§ if (§ expr listeners.isEmpty(§ pars )))
        (§ block
            (§ call pinnedConfidenceObjects.remove(§ pars this))
        )
        (§ return removed)
    )

    ;;;
     ; Returns the chain height at which the transaction appeared if confidence type is BUILDING.
     ; @throws IllegalStateException if the confidence type is not BUILDING.
     ;;
    #_public
    #_synchronized
    (§ method int getAppearedAtChainHeight(§ args ))
    (§ block
        (§ if (§ expr getConfidenceType(§ pars ) != ConfidenceType.BUILDING))
        (§ block
            (§ throw (§ new IllegalStateException(§ pars "Confidence type is " + getConfidenceType(§ pars ) + ", not BUILDING")))
        )
        (§ return appearedAtChainHeight)
    )

    ;;;
     ; The chain height at which the transaction appeared, if it has been seen in the best chain.
     ; Automatically sets the current type to {@link ConfidenceType#BUILDING} and depth to one.
     ;;
    #_public
    #_synchronized
    (§ method void setAppearedAtChainHeight(§ args int appearedAtChainHeight))
    (§ block
        (§ if (§ expr appearedAtChainHeight < 0))
        (§ block
            (§ throw (§ new IllegalArgumentException(§ pars "appearedAtChainHeight out of range")))
        )

        (§ ass this.appearedAtChainHeight = appearedAtChainHeight)
        (§ ass this.depth = 1)
        (§ call setConfidenceType(§ pars ConfidenceType.BUILDING))
    )

    ;;;
     ; Returns a general statement of the level of confidence you can have in this transaction.
     ;;
    #_public
    #_synchronized
    (§ method ConfidenceType getConfidenceType(§ args ))
    (§ block
        (§ return confidenceType)
    )

    ;;;
     ; Called by other objects in the system, like a {@link Wallet}, when new information about the confidence
     ; of a transaction becomes available.
     ;;
    #_public
    #_synchronized
    (§ method void setConfidenceType(§ args ConfidenceType confidenceType))
    (§ block
        (§ if (§ expr confidenceType == this.confidenceType))
        (§ block
            (§ return )
        )

        (§ ass this.confidenceType = confidenceType)
        (§ if (§ expr confidenceType != ConfidenceType.DEAD))
        (§ block
            (§ ass overridingTransaction = nil)
        )
        (§ if (§ expr confidenceType == ConfidenceType.PENDING || confidenceType == ConfidenceType.IN_CONFLICT))
        (§ block
            (§ ass depth = 0)
            (§ ass appearedAtChainHeight = -1)
        )
    )

    ;;;
     ; Called by a {@link Peer} when a transaction is pending and announced by a peer.  The more peers announce
     ; the transaction, the more peers have validated it (assuming your internet connection is not being intercepted).
     ; If confidence is currently unknown, sets it to {@link ConfidenceType#PENDING}.  Does not run listeners.
     ;
     ; @param address IP address of the peer, used as a proxy for identity.
     ; @return true if marked, false if this address was already seen.
     ;;
    #_public
    (§ method boolean markBroadcastBy(§ args PeerAddress address))
    (§ block
        (§ ass lastBroadcastedAt = Utils.now(§ pars ))
        (§ if (§ expr !broadcastBy.addIfAbsent(§ pars address)))
        (§ block
            (§ return false) ;; Duplicate.
        )

        (§ sync this)
        (§ block
            (§ if (§ expr getConfidenceType(§ pars ) == ConfidenceType.UNKNOWN))
            (§ block
                (§ ass this.confidenceType = ConfidenceType.PENDING)
            )
        )
        (§ return true)
    )

    ;;;
     ; Returns how many peers have been passed to {@link TransactionConfidence#markBroadcastBy}.
     ;;
    #_public
    (§ method int numBroadcastPeers(§ args ))
    (§ block
        (§ return broadcastBy.size(§ pars ))
    )

    ;;;
     ; Returns a snapshot of {@link PeerAddress}es that announced the transaction.
     ;;
    #_public
    (§ method Set<PeerAddress> getBroadcastBy(§ args ))
    (§ block
        (§ var ListIterator<PeerAddress> iterator = broadcastBy.listIterator(§ pars ))
        (§ return Sets.newHashSet(§ pars iterator))
    )

    ;;; Returns true if the given address has been seen via markBroadcastBy(). ;;
    #_public
    (§ method boolean wasBroadcastBy(§ args PeerAddress address))
    (§ block
        (§ return broadcastBy.contains(§ pars address))
    )

    ;;; Return the time the transaction was last announced to us. ;;
    #_public
    (§ method Date getLastBroadcastedAt(§ args ))
    (§ block
        (§ return lastBroadcastedAt)
    )

    ;;; Set the time the transaction was last announced to us. ;;
    #_public
    (§ method void setLastBroadcastedAt(§ args Date lastBroadcastedAt))
    (§ block
        (§ ass this.lastBroadcastedAt = lastBroadcastedAt)
    )

    #_override
    #_public
    #_synchronized
    (§ method String toString(§ args ))
    (§ block
        (§ var StringBuilder sb = new StringBuilder(§ pars ))
        (§ var int peers = numBroadcastPeers(§ pars ))
        (§ if (§ expr 0 < peers))
        (§ block
            (§ call sb.append(§ pars "Seen by ").append(§ pars peers).append(§ pars (§ expr 1 < peers) ? " peers" :else " peer"))
            (§ if (§ expr lastBroadcastedAt != nil))
            (§ block
                (§ call sb.append(§ pars " (most recently: ").append(§ pars Utils.dateTimeFormat(§ pars lastBroadcastedAt)).append(§ pars ")"))
            )
            (§ call sb.append(§ pars ". "))
        )
        (§ switch (§ expr getConfidenceType(§ pars )))
        (§ block
            (§ case UNKNOWN)
            (§ block
                (§ call sb.append(§ pars "Unknown confidence level."))
                (§ break )
            )
            (§ case DEAD)
            (§ block
                (§ call sb.append(§ pars "Dead: overridden by double spend and will not confirm."))
                (§ break )
            )
            (§ case PENDING)
            (§ block
                (§ call sb.append(§ pars "Pending/unconfirmed."))
                (§ break )
            )
            (§ case IN_CONFLICT)
            (§ block
                (§ call sb.append(§ pars "In conflict."))
                (§ break )
            )
            (§ case BUILDING)
            (§ block
                (§ call sb.append(§ pars String.format(§ pars Locale.US, "Appeared in best chain at height %d, depth %d.", getAppearedAtChainHeight(§ pars ), getDepthInBlocks(§ pars ))))
                (§ break )
            )
        )
        (§ if (§ expr source != Source.UNKNOWN))
        (§ block
            (§ call sb.append(§ pars " Source: ").append(§ pars source))
        )
        (§ return sb.toString(§ pars ))
    )

    ;;;
     ; Called by the wallet when the tx appears on the best chain and a new block is added to the top.
     ; Updates the internal counter that tracks how deeply buried the block is.
     ;
     ; @return the new depth
     ;;
    #_public
    #_synchronized
    (§ method int incrementDepthInBlocks(§ args ))
    (§ block
        (§ ass this.depth = this.depth + 1)
        (§ return this.depth)
    )

    ;;;
     ; <p>Depth in the chain is an approximation of how much time has elapsed since the transaction has been confirmed.
     ; On average there is supposed to be a new block every 10 minutes, but the actual rate may vary.  Bitcoin Core
     ; considers a transaction impractical to reverse after 6 blocks, but as of EOY 2011 network
     ; security is high enough that often only one block is considered enough even for high value transactions.
     ; For low value transactions like songs, or other cheap items, no blocks at all may be necessary.</p>
     ;
     ; <p>If the transaction appears in the top block, the depth is one.  If it's anything else (pending, dead, unknown)
     ; the depth is zero.</p>
     ;;
    #_public
    #_synchronized
    (§ method int getDepthInBlocks(§ args ))
    (§ block
        (§ return depth)
    )

    ;;
     ; Set the depth in blocks.  Having one block confirmation is a depth of one.
     ;;
    #_public
    #_synchronized
    (§ method void setDepthInBlocks(§ args int depth))
    (§ block
        (§ ass this.depth = depth)
    )

    ;;;
     ; Erases the set of broadcast/seen peers.  This cannot be called whilst the confidence is PENDING.  It is useful
     ; for saving memory and wallet space once a tx is buried so deep it doesn't seem likely to go pending again.
     ;;
    #_public
    (§ method void clearBroadcastBy(§ args ))
    (§ block
        (§ call Preconditions.checkState(§ pars getConfidenceType(§ pars ) != ConfidenceType.PENDING))
        (§ call broadcastBy.clear(§ pars ))
        (§ ass lastBroadcastedAt = nil)
    )

    ;;;
     ; If this transaction has been overridden by a double spend (is dead), this call returns the overriding transaction.
     ; Note that this call <b>can return null</b> if you have migrated an old wallet, as pre-Jan 2012 wallets did not
     ; store this information.
     ;
     ; @return the transaction that double spent this one.
     ; @throws IllegalStateException if confidence type is not DEAD.
     ;;
    #_public
    #_synchronized
    (§ method Transaction getOverridingTransaction(§ args ))
    (§ block
        (§ if (§ expr getConfidenceType(§ pars ) != ConfidenceType.DEAD))
        (§ block
            (§ throw (§ new IllegalStateException(§ pars "Confidence type is " + getConfidenceType(§ pars ) + ", not DEAD")))
        )
        (§ return overridingTransaction)
    )

    ;;;
     ; Called when the transaction becomes newly dead, that is, we learn that one of its inputs has already been spent
     ; in such a way that the double-spending transaction takes precedence over this one.  It will not become valid now
     ; unless there is a re-org.  Automatically sets the confidence type to DEAD.  The overriding transaction may not
     ; directly double spend this one, but could also have double spent a dependency of this tx.
     ;;
    #_public
    #_synchronized
    (§ method void setOverridingTransaction(§ args #_nilable Transaction overridingTransaction))
    (§ block
        (§ ass this.overridingTransaction = overridingTransaction)
        (§ call setConfidenceType(§ pars ConfidenceType.DEAD))
    )

    ;;; Returns a copy of this object.  Event listeners are not duplicated. ;;
    #_public
    (§ method TransactionConfidence duplicate(§ args ))
    (§ block
        (§ var TransactionConfidence c = new TransactionConfidence(§ pars hash))
        (§ call c.broadcastBy.addAll(§ pars broadcastBy))
        (§ ass c.lastBroadcastedAt = lastBroadcastedAt)
        (§ sync this)
        (§ block
            (§ ass c.confidenceType = confidenceType)
            (§ ass c.overridingTransaction = overridingTransaction)
            (§ ass c.appearedAtChainHeight = appearedAtChainHeight)
        )
        (§ return c)
    )

    ;;;
     ; Call this after adjusting the confidence, for cases where listeners should be notified.  This has to be done
     ; explicitly rather than being done automatically because sometimes complex changes to transaction states can
     ; result in a series of confidence changes that are not really useful to see separately.  By invoking listeners
     ; explicitly, more precise control is available.  Note that this will run the listeners on the user code thread.
     ;;
    #_public
    (§ method void queueListeners(§ args #_final Listener.ChangeReason reason))
    (§ block
        (§ for (§ var #_final ListenerRegistration<Listener> registration) :for (§ expr listeners))
        (§ block
            (§ call registration.executor.execute(§ pars (§ new Runnable(§ pars ))
            (§ anon
                #_override
                #_public
                (§ method void run(§ args ))
                (§ block
                    (§ call registration.listener.onConfidenceChanged(§ pars TransactionConfidence.this, reason))
                )
            )))
        )
    )

    ;;;
     ; The source of a transaction tries to identify where it came from originally.  For instance, did we download it
     ; from the peer to peer network, or make it ourselves, or receive it via Bluetooth, or import it from another app,
     ; and so on.  This information is useful for {@link org.bitcoinj.wallet.CoinSelector} implementations to risk analyze
     ; transactions and decide when to spend them.
     ;;
    #_public
    #_synchronized
    (§ method Source getSource(§ args ))
    (§ block
        (§ return source)
    )

    ;;;
     ; The source of a transaction tries to identify where it came from originally.  For instance, did we download it
     ; from the peer to peer network, or make it ourselves, or receive it via Bluetooth, or import it from another app,
     ; and so on.  This information is useful for {@link org.bitcoinj.wallet.CoinSelector} implementations to risk analyze
     ; transactions and decide when to spend them.
     ;;
    #_public
    #_synchronized
    (§ method void setSource(§ args Source source))
    (§ block
        (§ ass this.source = source)
    )

    ;;;
     ; Returns a future that completes when the transaction has been confirmed by "depth" blocks.  For instance setting
     ; depth to one will wait until it appears in a block on the best chain, and zero will wait until it has been seen
     ; on the network.
     ;;
    #_public
    #_synchronized
    (§ method ListenableFuture<TransactionConfidence> getDepthFuture(§ args #_final int depth, Executor executor))
    (§ block
        #_final
        (§ var SettableFuture<TransactionConfidence> result = SettableFuture.create(§ pars ))
        (§ if (§ expr depth <= getDepthInBlocks(§ pars )))
        (§ block
            (§ call result.set(§ pars this))
        )

        (§ call addEventListener(§ pars executor, new Listener(§ pars )
        (§ anon
            #_override
            #_public
            (§ method void onConfidenceChanged(§ args TransactionConfidence confidence, ChangeReason reason))
            (§ block
                (§ if (§ expr depth <= getDepthInBlocks(§ pars )))
                (§ block
                    (§ call removeEventListener(§ pars this))
                    (§ call result.set(§ pars confidence))
                )
            )
        )))
        (§ return result)
    )

    #_public
    #_synchronized
    (§ method ListenableFuture<TransactionConfidence> getDepthFuture(§ args #_final int depth))
    (§ block
        (§ return getDepthFuture(§ pars depth, Threading.USER_THREAD))
    )

    #_public
    (§ method Sha256Hash getTransactionHash(§ args ))
    (§ block
        (§ return hash)
    )
)

#_(ns org.bitcoinj.core #_"TransactionInput"
    (:import [java.io IOException OutputStream]
             [java.lang.ref WeakReference]
             [java.util Arrays Map])
    (:import [com.google.common.base Joiner Objects Preconditions])
   (:require [org.bitcoinj.script Script ScriptError]
             [org.bitcoinj.wallet DefaultRiskAnalysis KeyBag RedeemData]))

;;;
 ; <p>A transfer of coins from one address to another creates a transaction in which the outputs
 ; can be claimed by the recipient in the input of another transaction.  You can imagine a
 ; transaction as being a module which is wired up to others, the inputs of one have to be wired
 ; to the outputs of another.  The exceptions are coinbase transactions, which create new coins.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class TransactionInput extends ChildMessage
    ;;; Magic sequence number that indicates there is no sequence number. ;;
    #_public
    #_static
    #_final
    (§ field long NO_SEQUENCE = 0xffffffff)
    #_private
    #_static
    #_final
    (§ field byte[] EMPTY_ARRAY = new byte[0])
    ;; Magic outpoint index that indicates the input is in fact unconnected.
    #_private
    #_static
    #_final
    (§ field long UNCONNECTED = 0xffffffff)

    ;; Allows for altering transactions after they were broadcast.  Values below NO_SEQUENCE-1 mean it can be altered.
    #_private
    (§ field long sequence)
    ;; Data needed to connect to the output of the transaction we're gathering coins from.
    #_private
    (§ field TransactionOutPoint outpoint)
    ;; The "script bytes" might not actually be a script.  In coinbase transactions where new coins are minted there
    ;; is no input transaction, so instead the scriptBytes contains some extra stuff (like a rollover nonce) that we
    ;; don't care about much.  The bytes are turned into a Script object (cached below) on demand via a getter.
    #_private
    (§ field byte[] scriptBytes)
    ;; The Script object obtained from parsing scriptBytes.  Only filled in on demand and if the transaction is not
    ;; coinbase.
    #_private
    (§ field WeakReference<Script> scriptSig)
    ;;; Value of the output connected to the input, if known.  This field does not participate in equals()/hashCode(). ;;
    #_nilable
    #_private
    (§ field Coin value)

    ;;;
     ; Creates an input that connects to nothing - used only in creation of coinbase transactions.
     ;;
    #_public
    (§ constructor TransactionInput(§ args NetworkParameters params, #_nilable Transaction parentTransaction, byte[] scriptBytes))
    (§ block
        (§ this (§ pars params, parentTransaction, scriptBytes, new TransactionOutPoint(§ pars params, UNCONNECTED, (§ cast Transaction)nil)))
    )

    #_public
    (§ constructor TransactionInput(§ args NetworkParameters params, #_nilable Transaction parentTransaction, byte[] scriptBytes, TransactionOutPoint outpoint))
    (§ block
        (§ this (§ pars params, parentTransaction, scriptBytes, outpoint, nil))
    )

    #_public
    (§ constructor TransactionInput(§ args NetworkParameters params, #_nilable Transaction parentTransaction, byte[] scriptBytes, TransactionOutPoint outpoint, #_nilable Coin value))
    (§ block
        (§ super (§ pars params))

        (§ ass this.scriptBytes = scriptBytes)
        (§ ass this.outpoint = outpoint)
        (§ ass this.sequence = NO_SEQUENCE)
        (§ ass this.value = value)
        (§ call setParent(§ pars parentTransaction))
        (§ ass length = 40 + (§ expr scriptBytes != nil ? VarInt.sizeOf(§ pars scriptBytes.length) + scriptBytes.length :else 1))
    )

    ;;;
     ; Creates an UNSIGNED input that links to the given output.
     ;;
    (§ constructor TransactionInput(§ args NetworkParameters params, Transaction parentTransaction, TransactionOutput output))
    (§ block
        (§ super (§ pars params))

        (§ var long outputIndex = output.getIndex(§ pars ))
        (§ if (§ expr output.getParentTransaction(§ pars ) != nil ))
        (§ block
            (§ ass outpoint = new TransactionOutPoint(§ pars params, outputIndex, output.getParentTransaction(§ pars )))
        )
        (§ else )
        (§ block
            (§ ass outpoint = new TransactionOutPoint(§ pars params, output))
        )
        (§ ass scriptBytes = EMPTY_ARRAY)
        (§ ass sequence = NO_SEQUENCE)
        (§ call setParent(§ pars parentTransaction))
        (§ ass this.value = output.getValue(§ pars ))
        (§ ass length = 41)
    )

    ;;;
     ; Deserializes an input message.  This is usually part of a transaction message.
     ;;
    #_public
    (§ constructor TransactionInput(§ args NetworkParameters params, #_nilable Transaction parentTransaction, byte[] payload, int offset))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, offset))

        (§ call setParent(§ pars parentTransaction))
        (§ ass this.value = nil)
    )

    ;;;
     ; Deserializes an input message.  This is usually part of a transaction message.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor TransactionInput(§ args NetworkParameters params, Transaction parentTransaction, byte[] payload, int offset, MessageSerializer serializer))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, offset, parentTransaction, serializer, UNKNOWN_LENGTH))

        (§ ass this.value = nil)
    )

    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ ass outpoint = new TransactionOutPoint(§ pars params, payload, cursor, this, serializer))
        (§ ass cursor = cursor + outpoint.getMessageSize(§ pars ))
        (§ var int scriptLen = (§ cast int)readVarInt(§ pars ))
        (§ ass length = cursor - offset + scriptLen + 4)
        (§ ass scriptBytes = readBytes(§ pars scriptLen))
        (§ ass sequence = readUint32(§ pars ))
    )

    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ call outpoint.bitcoinSerialize(§ pars stream))
        (§ call stream.write(§ pars (§ new VarInt(§ pars scriptBytes.length)).encode(§ pars )))
        (§ call stream.write(§ pars scriptBytes))
        (§ call Utils.uint32ToByteStreamLE(§ pars sequence, stream))
    )

    ;;;
     ; Coinbase transactions have special inputs with hashes of zero.  If this is such an input, returns true.
     ;;
    #_public
    (§ method boolean isCoinBase(§ args ))
    (§ block
        (§ return (§ expr outpoint.getHash(§ pars ).equals(§ pars Sha256Hash.ZERO_HASH) && (§ expr outpoint.getIndex(§ pars ) & 0xffffffff) == 0xffffffff)) ;; -1 but all is serialized to the wire as unsigned int.
    )

    ;;;
     ; Returns the script that is fed to the referenced output (scriptPubKey) script in order to satisfy it: usually
     ; contains signatures and maybe keys, but can contain arbitrary data if the output script accepts it.
     ;;
    #_public
    (§ method Script getScriptSig(§ args ))
        (§ throws ScriptException)
    (§ block
        ;; Transactions that generate new coins don't actually have a script.
        ;; Instead this parameter is overloaded to be something totally different.
        (§ var Script script = (§ expr scriptSig != nil) ? scriptSig.get(§ pars ) :else nil)
        (§ if (§ expr script == nil))
        (§ block
            (§ ass script = new Script(§ pars scriptBytes))
            (§ ass scriptSig = new WeakReference<>(§ pars script))
        )
        (§ return script)
    )

    ;;; Set the given program as the scriptSig that is supposed to satisfy the connected output script. ;;
    #_public
    (§ method void setScriptSig(§ args Script scriptSig))
    (§ block
        (§ ass this.scriptSig = new WeakReference<>(§ pars Preconditions.checkNotNull(§ pars scriptSig)))
        ;; TODO: This should all be cleaned up so we have a consistent internal representation.
        (§ call setScriptBytes(§ pars scriptSig.getProgram(§ pars )))
    )

    ;;;
     ; Convenience method that returns the from address of this input by parsing the scriptSig.  The concept of
     ; a "from address" is not well defined in Bitcoin and you should not assume that senders of a transaction can
     ; actually receive coins on the same address they used to sign (e.g. this is not true for shared wallets).
     ;;
    #_deprecated
    #_public
    (§ method Address getFromAddress(§ args ))
        (§ throws ScriptException)
    (§ block
        (§ if (§ expr isCoinBase(§ pars )))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "This is a coinbase transaction which generates new coins. It does not have a from address.")))
        )

        (§ return getScriptSig(§ pars ).getFromAddress(§ pars params))
    )

    ;;;
     ; Sequence numbers allow participants in a multi-party transaction signing protocol to create new versions of the
     ; transaction independently of each other.  Newer versions of a transaction can replace an existing version that's
     ; in nodes memory pools if the existing version is time locked.  See the Contracts page on the Bitcoin wiki for
     ; examples of how you can use this feature to build contract protocols.
     ;;
    #_public
    (§ method long getSequenceNumber(§ args ))
    (§ block
        (§ return sequence)
    )

    ;;;
     ; Sequence numbers allow participants in a multi-party transaction signing protocol to create new versions of the
     ; transaction independently of each other.  Newer versions of a transaction can replace an existing version that's
     ; in nodes memory pools if the existing version is time locked.  See the Contracts page on the Bitcoin wiki for
     ; examples of how you can use this feature to build contract protocols.
     ;;
    #_public
    (§ method void setSequenceNumber(§ args long sequence))
    (§ block
        (§ call unCache(§ pars ))
        (§ ass this.sequence = sequence)
    )

    ;;;
     ; @return The previous output transaction reference, as an OutPoint structure.  This contains the
     ; data needed to connect to the output of the transaction we're gathering coins from.
     ;;
    #_public
    (§ method TransactionOutPoint getOutpoint(§ args ))
    (§ block
        (§ return outpoint)
    )

    ;;;
     ; The "script bytes" might not actually be a script.  In coinbase transactions where new coins are minted there
     ; is no input transaction, so instead the scriptBytes contains some extra stuff (like a rollover nonce) that we
     ; don't care about much.  The bytes are turned into a Script object (cached below) on demand via a getter.
     ; @return the scriptBytes
     ;;
    #_public
    (§ method byte[] getScriptBytes(§ args ))
    (§ block
        (§ return scriptBytes)
    )

    ;;; Clear input scripts, e.g. in preparation for signing. ;;
    #_public
    (§ method void clearScriptBytes(§ args ))
    (§ block
        (§ call setScriptBytes(§ pars TransactionInput.EMPTY_ARRAY))
    )

    ;;;
     ; @param scriptBytes The scriptBytes to set.
     ;;
    (§ method void setScriptBytes(§ args byte[] scriptBytes))
    (§ block
        (§ call unCache(§ pars ))
        (§ ass this.scriptSig = nil)
        (§ var int oldLength = length)
        (§ ass this.scriptBytes = scriptBytes)
        ;; 40 = previous_outpoint (36) + sequence (4)
        (§ var int newLength = 40 + (§ expr scriptBytes != nil ? VarInt.sizeOf(§ pars scriptBytes.length) + scriptBytes.length :else 1))
        (§ call adjustLength(§ pars newLength - oldLength))
    )

    ;;;
     ; @return the Transaction that owns this input.
     ;;
    #_public
    (§ method Transaction getParentTransaction(§ args ))
    (§ block
        (§ return (§ cast Transaction)parent)
    )

    ;;;
     ; @return the value of the output connected to this input.
     ;;
    #_nilable
    #_public
    (§ method Coin getValue(§ args ))
    (§ block
        (§ return value)
    )

    #_public
    (§ enum ConnectionResult
        (§ item NO_SUCH_TX)
        (§ item ALREADY_SPENT)
        (§ item SUCCESS)
    )

    ;; TODO: Clean all this up once TransactionOutPoint disappears.

    ;;;
     ; Locates the referenced output from the given pool of transactions.
     ;
     ; @return the TransactionOutput (or null) if the transaction's map doesn't contain the referenced tx.
     ;;
    #_nilable
    (§ method TransactionOutput getConnectedOutput(§ args Map<Sha256Hash, Transaction> transactions))
    (§ block
        (§ var Transaction tx = transactions.get(§ pars outpoint.getHash(§ pars )))
        (§ return (§ quest (§ expr tx != nil) ? tx.getOutputs(§ pars ).get(§ pars (§ cast int)outpoint.getIndex(§ pars )) :else nil))
    )

    ;;;
     ; Alias for getOutpoint().getConnectedRedeemData(keyBag).
     ; @see TransactionOutPoint#getConnectedRedeemData(org.bitcoinj.wallet.KeyBag)
     ;;
    #_nilable
    #_public
    (§ method RedeemData getConnectedRedeemData(§ args KeyBag keyBag))
        (§ throws ScriptException)
    (§ block
        (§ return getOutpoint(§ pars ).getConnectedRedeemData(§ pars keyBag))
    )

    #_public
    (§ enum ConnectMode
        (§ item DISCONNECT_ON_CONFLICT)
        (§ item ABORT_ON_CONFLICT)
    )

    ;;;
     ; Connects this input to the relevant output of the referenced transaction if it's in the given map.
     ; Connecting means updating the internal pointers and spent flags.  If the mode is to ABORT_ON_CONFLICT,
     ; then the spent output won't be changed, but the outpoint.fromTx pointer will still be updated.
     ;
     ; @param transactions Map of txhash->transaction.
     ; @param mode Whether to abort if there's a pre-existing connection or not.
     ; @return NO_SUCH_TX if the prevtx wasn't found, ALREADY_SPENT if there was a conflict, SUCCESS if not.
     ;;
    #_public
    (§ method ConnectionResult connect(§ args Map<Sha256Hash, Transaction> transactions, ConnectMode mode))
    (§ block
        (§ var Transaction tx = transactions.get(§ pars outpoint.getHash(§ pars )))
        (§ return (§ expr tx != nil) ? connect(§ pars tx, mode) :else TransactionInput.ConnectionResult.NO_SUCH_TX)
    )

    ;;;
     ; Connects this input to the relevant output of the referenced transaction.
     ; Connecting means updating the internal pointers and spent flags.  If the mode is to ABORT_ON_CONFLICT,
     ; then the spent output won't be changed, but the outpoint.fromTx pointer will still be updated.
     ;
     ; @param transaction The transaction to try.
     ; @param mode Whether to abort if there's a pre-existing connection or not.
     ; @return NO_SUCH_TX if transaction is not the prevtx, ALREADY_SPENT if there was a conflict, SUCCESS if not.
     ;;
    #_public
    (§ method ConnectionResult connect(§ args Transaction transaction, ConnectMode mode))
    (§ block
        (§ if (§ expr !transaction.getHash(§ pars ).equals(§ pars outpoint.getHash(§ pars ))))
        (§ block
            (§ return ConnectionResult.NO_SUCH_TX)
        )

        (§ call Preconditions.checkElementIndex(§ pars (§ cast int)outpoint.getIndex(§ pars ), transaction.getOutputs(§ pars ).size(§ pars ), "Corrupt transaction"))

        (§ var TransactionOutput out = transaction.getOutput(§ pars (§ cast int)outpoint.getIndex(§ pars )))
        (§ if (§ expr !out.isAvailableForSpending(§ pars )))
        (§ block
            (§ if (§ expr getParentTransaction(§ pars ).equals(§ pars outpoint.fromTx)))
            (§ block
                ;; Already connected.
                (§ return ConnectionResult.SUCCESS)
            )
            (§ elseif (§ expr mode == ConnectMode.DISCONNECT_ON_CONFLICT))
            (§ block
                (§ call out.markAsUnspent(§ pars ))
            )
            (§ elseif (§ expr mode == ConnectMode.ABORT_ON_CONFLICT))
            (§ block
                (§ ass outpoint.fromTx = out.getParentTransaction(§ pars ))
                (§ return TransactionInput.ConnectionResult.ALREADY_SPENT)
            )
        )
        (§ call connect(§ pars out))
        (§ return TransactionInput.ConnectionResult.SUCCESS)
    )

    ;;; Internal use only: connects this TransactionInput to the given output (updates pointers and spent flags). ;;
    #_public
    (§ method void connect(§ args TransactionOutput out))
    (§ block
        (§ ass outpoint.fromTx = out.getParentTransaction(§ pars ))
        (§ call out.markAsSpent(§ pars this))
        (§ ass value = out.getValue(§ pars ))
    )

    ;;;
     ; If this input is connected, check the output is connected back to this input and release it if so, making
     ; it spendable once again.
     ;
     ; @return true if the disconnection took place, false if it was not connected.
     ;;
    #_public
    (§ method boolean disconnect(§ args ))
    (§ block
        (§ var TransactionOutput connectedOutput)
        (§ if (§ expr outpoint.fromTx != nil))
        (§ block
            ;; The outpoint is connected using a "standard" wallet, disconnect it.
            (§ ass connectedOutput = outpoint.fromTx.getOutput(§ pars (§ cast int)outpoint.getIndex(§ pars )))
            (§ ass outpoint.fromTx = nil)
        )
        (§ elseif (§ expr outpoint.connectedOutput != nil))
        (§ block
            ;; The outpoint is connected using a UTXO based wallet, disconnect it.
            (§ ass connectedOutput = outpoint.connectedOutput)
            (§ ass outpoint.connectedOutput = nil)
        )
        (§ else )
        (§ block
            ;; The outpoint is not connected, do nothing.
            (§ return false)
        )

        (§ if (§ expr connectedOutput != nil && connectedOutput.getSpentBy(§ pars ) == this))
        (§ block
            ;; The outpoint was connected to an output, disconnect the output.
            (§ call connectedOutput.markAsUnspent(§ pars ))
            (§ return true)
        )

        (§ return false)
    )

    ;;;
     ; @return true if this transaction's sequence number is set (i.e. it may be a part of a time-locked transaction).
     ;;
    #_public
    (§ method boolean hasSequence(§ args ))
    (§ block
        (§ return (§ expr sequence != NO_SEQUENCE))
    )

    ;;;
     ; Returns whether this input will cause a transaction to opt into the
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki">full replace-by-fee</a> semantics.
     ;;
    #_public
    (§ method boolean isOptInFullRBF(§ args ))
    (§ block
        (§ return (§ expr sequence < NO_SEQUENCE - 1))
    )

    ;;;
     ; For a connected transaction, runs the script against the connected pubkey and verifies they are correct.
     ; @throws ScriptException if the script did not verify.
     ; @throws VerificationException if the outpoint doesn't match the given output.
     ;;
    #_public
    (§ method void verify(§ args ))
        (§ throws VerificationException)
    (§ block
        #_final
        (§ var Transaction fromTx = getOutpoint(§ pars ).fromTx)
        (§ var long spendingIndex = getOutpoint(§ pars ).getIndex(§ pars ))

        (§ call Preconditions.checkNotNull(§ pars fromTx, "Not connected"))

        #_final
        (§ var TransactionOutput output = fromTx.getOutput(§ pars (§ cast int)spendingIndex))
        (§ call verify(§ pars output))
    )

    ;;;
     ; Verifies that this input can spend the given output.  Note that this input must be a part of a transaction.
     ; Also note that the consistency of the outpoint will be checked, even if this input has not been connected.
     ;
     ; @param output The output that this input is supposed to spend.
     ; @throws ScriptException if the script doesn't verify.
     ; @throws VerificationException if the outpoint doesn't match the given output.
     ;;
    #_public
    (§ method void verify(§ args TransactionOutput output))
        (§ throws VerificationException)
    (§ block
        (§ if (§ expr output.parent != nil))
        (§ block
            (§ if (§ expr !getOutpoint(§ pars ).getHash(§ pars ).equals(§ pars output.getParentTransaction(§ pars ).getHash(§ pars ))))
            (§ block
                (§ throw (§ new VerificationException(§ pars "This input does not refer to the tx containing the output.")))
            )
            (§ if (§ expr getOutpoint(§ pars ).getIndex(§ pars ) != output.getIndex(§ pars )))
            (§ block
                (§ throw (§ new VerificationException(§ pars "This input refers to a different output on the given tx.")))
            )
        )
        (§ var Script pubKey = output.getScriptPubKey(§ pars ))
        (§ var int myIndex = getParentTransaction(§ pars ).getInputs(§ pars ).indexOf(§ pars this))
        (§ call getScriptSig(§ pars ).correctlySpends(§ pars getParentTransaction(§ pars ), myIndex, pubKey))
    )

    ;;;
     ; Returns the connected output, assuming the input was connected with
     ; {@link TransactionInput#connect(TransactionOutput)} or variants at some point.
     ; If it wasn't connected, then this method returns null.
     ;;
    #_nilable
    #_public
    (§ method TransactionOutput getConnectedOutput(§ args ))
    (§ block
        (§ return getOutpoint(§ pars ).getConnectedOutput(§ pars ))
    )

    ;;;
     ; Returns the connected transaction, assuming the input was connected with
     ; {@link TransactionInput#connect(TransactionOutput)} or variants at some point.
     ; If it wasn't connected, then this method returns null.
     ;;
    #_nilable
    #_public
    (§ method Transaction getConnectedTransaction(§ args ))
    (§ block
        (§ return getOutpoint(§ pars ).fromTx)
    )

    ;;; Returns a copy of the input detached from its containing transaction, if need be. ;;
    #_public
    (§ method TransactionInput duplicateDetached(§ args ))
    (§ block
        (§ return (§ new TransactionInput(§ pars params, nil, bitcoinSerialize(§ pars ), 0)))
    )

    ;;;
     ; <p>Returns either RuleViolation.NONE if the input is standard, or which rule makes it non-standard if so.
     ; The "IsStandard" rules control whether the default Bitcoin Core client blocks relay of a tx / refuses to mine it,
     ; however, non-standard transactions can still be included in blocks and will be accepted as valid if so.</p>
     ;
     ; <p>This method simply calls <tt>DefaultRiskAnalysis.isInputStandard(this)</tt>.</p>
     ;;
    #_public
    (§ method DefaultRiskAnalysis.RuleViolation isStandard(§ args ))
    (§ block
        (§ return DefaultRiskAnalysis.isInputStandard(§ pars this))
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var TransactionInput other = (§ cast TransactionInput)o)
        (§ return (§ expr sequence == other.sequence && parent == other.parent && outpoint.equals(§ pars other.outpoint) && Arrays.equals(§ pars scriptBytes, other.scriptBytes)))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars sequence, outpoint, Arrays.hashCode(§ pars scriptBytes)))
    )

    ;;;
     ; Returns a human readable debug string.
     ;;
    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ try )
        (§ block
            (§ var StringBuilder sb = new StringBuilder(§ pars "TxIn"))
            (§ if (§ expr isCoinBase(§ pars )))
            (§ block
                (§ call sb.append(§ pars ": COINBASE"))
            )
            (§ else )
            (§ block
                (§ call sb.append(§ pars " for [").append(§ pars outpoint).append(§ pars "]: ").append(§ pars getScriptSig(§ pars )))
                (§ var String flags = Joiner.on(§ pars ", ").skipNulls(§ pars ).join(§ pars hasSequence(§ pars ) ? "sequence: " + Long.toHexString(§ pars sequence) :else nil, isOptInFullRBF(§ pars ) ? "opts into full RBF" :else nil))
                (§ if (§ expr !flags.isEmpty(§ pars )))
                (§ block
                    (§ call sb.append(§ pars " (").append(§ pars flags).append(§ pars ")"))
                )
            )
            (§ return sb.toString(§ pars ))
        )
        (§ catch (§ args ScriptException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )
)

#_(ns org.bitcoinj.core #_"TransactionOutPoint"
    (:import [java.io *])
    (:import [com.google.common.base Objects Preconditions])
   (:require [org.bitcoinj.script *]
             [org.bitcoinj.wallet *]))

;;;
 ; <p>This message is a reference or pointer to an output of a different transaction.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class TransactionOutPoint extends ChildMessage
    #_static
    #_final
    (§ field int MESSAGE_LENGTH = 36)

    ;;; Hash of the transaction to which we refer. ;;
    #_private
    (§ field Sha256Hash hash)
    ;;; Which output of that transaction we are talking about. ;;
    #_private
    (§ field long index)

    ;; This is not part of bitcoin serialization.  It points to the connected transaction.
    (§ field Transaction fromTx)

    ;; The connected output.
    (§ field TransactionOutput connectedOutput)

    #_public
    (§ constructor TransactionOutPoint(§ args NetworkParameters params, long index, #_nilable Transaction fromTx))
    (§ block
        (§ super (§ pars params))

        (§ ass this.index = index)
        (§ if (§ expr fromTx != nil))
        (§ block
            (§ ass this.hash = fromTx.getHash(§ pars ))
            (§ ass this.fromTx = fromTx)
        )
        (§ else )
        (§ block
            ;; This happens when constructing the genesis block.
            (§ ass hash = Sha256Hash.ZERO_HASH)
        )
        (§ ass length = MESSAGE_LENGTH)
    )

    #_public
    (§ constructor TransactionOutPoint(§ args NetworkParameters params, long index, Sha256Hash hash))
    (§ block
        (§ super (§ pars params))

        (§ ass this.index = index)
        (§ ass this.hash = hash)
        (§ ass length = MESSAGE_LENGTH)
    )

    #_public
    (§ constructor TransactionOutPoint(§ args NetworkParameters params, TransactionOutput connectedOutput))
    (§ block
        (§ this (§ pars params, connectedOutput.getIndex(§ pars ), connectedOutput.getParentTransactionHash(§ pars )))
        (§ ass this.connectedOutput = connectedOutput)
    )

    ;;;
     ; Deserializes the message.  This is usually part of a transaction message.
     ;;
    #_public
    (§ constructor TransactionOutPoint(§ args NetworkParameters params, byte[] payload, int offset))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, offset))
    )

    ;;;
     ; Deserializes the message.  This is usually part of a transaction message.
     ; @param params NetworkParameters object.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor TransactionOutPoint(§ args NetworkParameters params, byte[] payload, int offset, Message parent, MessageSerializer serializer))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, offset, parent, serializer, MESSAGE_LENGTH))
    )

    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ ass length = MESSAGE_LENGTH)
        (§ ass hash = readHash(§ pars ))
        (§ ass index = readUint32(§ pars ))
    )

    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ call stream.write(§ pars hash.getReversedBytes(§ pars )))
        (§ call Utils.uint32ToByteStreamLE(§ pars index, stream))
    )

    ;;;
     ; An outpoint is a part of a transaction input that points to the output of another transaction.  If we have both
     ; sides in memory, and they have been linked together, this returns a pointer to the connected output, or null
     ; if there is no such connection.
     ;;
    #_nilable
    #_public
    (§ method TransactionOutput getConnectedOutput(§ args ))
    (§ block
        (§ if (§ expr fromTx != nil))
        (§ block
            (§ return fromTx.getOutputs(§ pars ).get(§ pars (§ cast int)index))
        )
        (§ if (§ expr connectedOutput != nil))
        (§ block
            (§ return connectedOutput)
        )
        (§ return nil)
    )

    ;;;
     ; Returns the pubkey script from the connected output.
     ; @throws java.lang.NullPointerException if there is no connected output.
     ;;
    #_public
    (§ method byte[] getConnectedPubKeyScript(§ args ))
    (§ block
        (§ var byte[] result = Preconditions.checkNotNull(§ pars getConnectedOutput(§ pars )).getScriptBytes(§ pars ))
        (§ call Preconditions.checkState(§ pars 0 < result.length))
        (§ return result)
    )

    ;;;
     ; Returns the ECKey identified in the connected output, for either pay-to-address scripts or pay-to-key scripts.
     ; For P2SH scripts you can use {@link #getConnectedRedeemData(org.bitcoinj.wallet.KeyBag)} and then get the
     ; key from RedeemData.
     ; If the script form cannot be understood, throws ScriptException.
     ;
     ; @return an ECKey or null if the connected key cannot be found in the wallet.
     ;;
    #_nilable
    #_public
    (§ method ECKey getConnectedKey(§ args KeyBag keyBag))
        (§ throws ScriptException)
    (§ block
        (§ var TransactionOutput connectedOutput = getConnectedOutput(§ pars ))
        (§ call Preconditions.checkNotNull(§ pars connectedOutput, "Input is not connected so cannot retrieve key"))
        (§ var Script connectedScript = connectedOutput.getScriptPubKey(§ pars ))

        (§ if (§ expr connectedScript.isSentToAddress(§ pars )))
        (§ block
            (§ var byte[] addressBytes = connectedScript.getPubKeyHash(§ pars ))
            (§ return keyBag.findKeyFromPubHash(§ pars addressBytes))
        )

        (§ if (§ expr connectedScript.isSentToRawPubKey(§ pars )))
        (§ block
            (§ var byte[] pubkeyBytes = connectedScript.getPubKey(§ pars ))
            (§ return keyBag.findKeyFromPubKey(§ pars pubkeyBytes))
        )

        (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Could not understand form of connected output script: " + connectedScript)))
    )

    ;;;
     ; Returns the RedeemData identified in the connected output, for either pay-to-address scripts, pay-to-key
     ; or P2SH scripts.
     ; If the script forms cannot be understood, throws ScriptException.
     ;
     ; @return a RedeemData or null if the connected data cannot be found in the wallet.
     ;;
    #_nilable
    #_public
    (§ method RedeemData getConnectedRedeemData(§ args KeyBag keyBag))
        (§ throws ScriptException)
    (§ block
        (§ var TransactionOutput connectedOutput = getConnectedOutput(§ pars ))
        (§ call Preconditions.checkNotNull(§ pars connectedOutput, "Input is not connected so cannot retrieve key"))
        (§ var Script connectedScript = connectedOutput.getScriptPubKey(§ pars ))

        (§ if (§ expr connectedScript.isSentToAddress(§ pars )))
        (§ block
            (§ var byte[] addressBytes = connectedScript.getPubKeyHash(§ pars ))
            (§ return RedeemData.of(§ pars keyBag.findKeyFromPubHash(§ pars addressBytes), connectedScript))
        )

        (§ if (§ expr connectedScript.isSentToRawPubKey(§ pars )))
        (§ block
            (§ var byte[] pubkeyBytes = connectedScript.getPubKey(§ pars ))
            (§ return RedeemData.of(§ pars keyBag.findKeyFromPubKey(§ pars pubkeyBytes), connectedScript))
        )

        (§ if (§ expr connectedScript.isPayToScriptHash(§ pars )))
        (§ block
            (§ var byte[] scriptHash = connectedScript.getPubKeyHash(§ pars ))
            (§ return keyBag.findRedeemDataFromScriptHash(§ pars scriptHash))
        )

        (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Could not understand form of connected output script: " + connectedScript)))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return hash + ":" + index)
    )

    ;;;
     ; Returns the hash of the transaction this outpoint references/spends/is connected to.
     ;;
    #_override
    #_public
    (§ method Sha256Hash getHash(§ args ))
    (§ block
        (§ return hash)
    )

    (§ method void setHash(§ args Sha256Hash hash))
    (§ block
        (§ ass this.hash = hash)
    )

    #_public
    (§ method long getIndex(§ args ))
    (§ block
        (§ return index)
    )

    #_public
    (§ method void setIndex(§ args long index))
    (§ block
        (§ ass this.index = index)
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var TransactionOutPoint other = (§ cast TransactionOutPoint)o)
        (§ return (§ expr getIndex(§ pars ) == other.getIndex(§ pars ) && getHash(§ pars ).equals(§ pars other.getHash(§ pars ))))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars getIndex(§ pars ), getHash(§ pars )))
    )
)

#_(ns org.bitcoinj.core #_"TransactionOutput"
    (:import [java.io *]
             [java.util *])
    (:import [com.google.common.base Objects Preconditions]
             [org.slf4j *])
   (:require [org.bitcoinj.script *]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>A TransactionOutput message contains a scriptPubKey that controls who is able to spend its value.
 ; It is a sub-part of the Transaction message.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class TransactionOutput extends ChildMessage
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars TransactionOutput.class))

    ;; The output's value is kept as a native type in order to save class instances.
    #_private
    (§ field long value)

    ;; A transaction output has a script used for authenticating that the redeemer is allowed to spend
    ;; this output.
    #_private
    (§ field byte[] scriptBytes)

    ;; The script bytes are parsed and turned into a Script on demand.
    #_private
    (§ field Script scriptPubKey)

    ;; These fields are not Bitcoin serialized.  They are used for tracking purposes in our wallet only.
    ;; If set to true, this output is counted towards our balance.  If false and spentBy is null the tx output
    ;; was owned by us and was sent to somebody else.  If false and spentBy is set it means this output was owned
    ;; by us and used in one of our own transactions (e.g. because it is a change output).
    #_private
    (§ field boolean availableForSpending)
    #_nilable
    #_private
    (§ field TransactionInput spentBy)

    #_private
    (§ field int scriptLen)

    ;;;
     ; Deserializes a transaction output message.  This is usually part of a transaction message.
     ;;
    #_public
    (§ constructor TransactionOutput(§ args NetworkParameters params, #_nilable Transaction parent, byte[] payload, int offset))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, offset))

        (§ call setParent(§ pars parent))
        (§ ass availableForSpending = true)
    )

    ;;;
     ; Deserializes a transaction output message.  This is usually part of a transaction message.
     ;
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor TransactionOutput(§ args NetworkParameters params, #_nilable Transaction parent, byte[] payload, int offset, MessageSerializer serializer))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, offset, parent, serializer, UNKNOWN_LENGTH))

        (§ ass availableForSpending = true)
    )

    ;;;
     ; Creates an output that sends 'value' to the given address (public key hash).  The amount should be
     ; created with something like {@link Coin#valueOf(int, int)}.  Typically you would use
     ; {@link Transaction#addOutput(Coin, Address)} instead of creating a TransactionOutput directly.
     ;;
    #_public
    (§ constructor TransactionOutput(§ args NetworkParameters params, #_nilable Transaction parent, Coin value, Address to))
    (§ block
        (§ this (§ pars params, parent, value, ScriptBuilder.createOutputScript(§ pars to).getProgram(§ pars )))
    )

    ;;;
     ; Creates an output that sends 'value' to the given public key using a simple CHECKSIG script (no addresses).
     ; The amount should be created with something like {@link Coin#valueOf(int, int)}.  Typically you would use
     ; {@link Transaction#addOutput(Coin, ECKey)} instead of creating an output directly.
     ;;
    #_public
    (§ constructor TransactionOutput(§ args NetworkParameters params, #_nilable Transaction parent, Coin value, ECKey to))
    (§ block
        (§ this (§ pars params, parent, value, ScriptBuilder.createOutputScript(§ pars to).getProgram(§ pars )))
    )

    #_public
    (§ constructor TransactionOutput(§ args NetworkParameters params, #_nilable Transaction parent, Coin value, byte[] scriptBytes))
    (§ block
        (§ super (§ pars params))

        ;; Negative values obviously make no sense, except for -1 which is used as a sentinel value when calculating
        ;; SIGHASH_SINGLE signatures, so unfortunately we have to allow that here.
        (§ call Preconditions.checkArgument(§ pars 0 <= value.signum(§ pars ) || value.equals(§ pars Coin.NEGATIVE_SATOSHI), "Negative values not allowed"))
        (§ call Preconditions.checkArgument(§ pars !params.hasMaxMoney(§ pars ) || value.compareTo(§ pars params.getMaxMoney(§ pars )) <= 0, "Values larger than MAX_MONEY not allowed"))

        (§ ass this.value = value.value)
        (§ ass this.scriptBytes = scriptBytes)
        (§ call setParent(§ pars parent))
        (§ ass availableForSpending = true)
        (§ ass length = 8 + VarInt.sizeOf(§ pars scriptBytes.length) + scriptBytes.length)
    )

    #_public
    (§ method Script getScriptPubKey(§ args ))
        (§ throws ScriptException)
    (§ block
        (§ if (§ expr scriptPubKey == nil))
        (§ block
            (§ ass scriptPubKey = new Script(§ pars scriptBytes))
        )
        (§ return scriptPubKey)
    )

    ;;;
     ; <p>If the output script pays to an address as in <a href="https://bitcoin.org/en/developer-guide#term-p2pkh">P2PKH</a>,
     ; return the address of the receiver, i.e. a base58 encoded hash of the public key in the script.</p>
     ;
     ; @param networkParameters Needed to specify an address.
     ; @return null, if the output script is not the form <i>OP_DUP OP_HASH160 <PubkeyHash> OP_EQUALVERIFY OP_CHECKSIG</i>,
     ; i.e. not P2PKH.
     ; @return an address made out of the public key hash.
     ;;
    #_nilable
    #_public
    (§ method Address getAddressFromP2PKHScript(§ args NetworkParameters networkParameters))
        (§ throws ScriptException)
    (§ block
        (§ return getScriptPubKey(§ pars ).isSentToAddress(§ pars ) ? getScriptPubKey(§ pars ).getToAddress(§ pars networkParameters) :else nil)
    )

    ;;;
     ; <p>If the output script pays to a redeem script, return the address of the redeem script as described by,
     ; i.e. a base58 encoding of [one-byte version][20-byte hash][4-byte checksum], where the 20-byte hash refers to
     ; the redeem script.</p>
     ;
     ; <p>P2SH is described by <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP 16</a> and
     ; <a href="https://bitcoin.org/en/developer-guide#p2sh-scripts">documented in the Bitcoin Developer Guide</a>.</p>
     ;
     ; @param networkParameters Needed to specify an address.
     ; @return null if the output script does not pay to a script hash.
     ; @return an address that belongs to the redeem script.
     ;;
    #_nilable
    #_public
    (§ method Address getAddressFromP2SH(§ args NetworkParameters networkParameters))
        (§ throws ScriptException)
    (§ block
        (§ return getScriptPubKey(§ pars ).isPayToScriptHash(§ pars ) ? getScriptPubKey(§ pars ).getToAddress(§ pars networkParameters) :else nil)
    )

    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ ass value = readInt64(§ pars ))
        (§ ass scriptLen = (§ cast int)readVarInt(§ pars ))
        (§ ass length = cursor - offset + scriptLen)
        (§ ass scriptBytes = readBytes(§ pars scriptLen))
    )

    #_override
    #_protected
    (§ method void bitcoinSerializeToStream(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars scriptBytes))

        (§ call Utils.int64ToByteStreamLE(§ pars value, stream))
        ;; TODO: Move script serialization into the Script class, where it belongs.
        (§ call stream.write(§ pars (§ new VarInt(§ pars scriptBytes.length)).encode(§ pars )))
        (§ call stream.write(§ pars scriptBytes))
    )

    ;;;
     ; Returns the value of this output.
     ; This is the amount of currency that the destination address receives.
     ;;
    #_public
    (§ method Coin getValue(§ args ))
    (§ block
        (§ try )
        (§ block
            (§ return Coin.valueOf(§ pars value))
        )
        (§ catch (§ args IllegalArgumentException e))
        (§ block
            (§ throw (§ new IllegalStateException(§ pars e.getMessage(§ pars ), e)))
        )
    )

    ;;;
     ; Sets the value of this output.
     ;;
    #_public
    (§ method void setValue(§ args Coin value))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars value))

        (§ call unCache(§ pars ))
        (§ ass this.value = value.value)
    )

    ;;;
     ; Gets the index of this output in the parent transaction, or throws if this output is free standing.
     ; Iterates over the parents list to discover this.
     ;;
    #_public
    (§ method int getIndex(§ args ))
    (§ block
        (§ var List<TransactionOutput> outputs = getParentTransaction(§ pars ).getOutputs(§ pars ))
        (§ for (§ var int i = 0) :for (§ expr i < outputs.size(§ pars )) :for (§ ass i = i + 1))
        (§ block
            (§ if (§ expr outputs.get(§ pars i) == this))
            (§ block
                (§ return i)
            )
        )

        (§ throw (§ new IllegalStateException(§ pars "Output linked to wrong parent transaction?")))
    )

    ;;;
     ; Will this transaction be relayable and mined by default miners?
     ;;
    #_public
    (§ method boolean isDust(§ args ))
    (§ block
        ;; Transactions that are OP_RETURN can't be dust regardless of their value.
        (§ return getScriptPubKey(§ pars ).isOpReturn(§ pars ) ? false :else getValue(§ pars ).isLessThan(§ pars getMinNonDustValue(§ pars )))
    )

    ;;;
     ; <p>Gets the minimum value for a txout of this size to be considered non-dust by Bitcoin Core
     ; (and thus relayed).  See CTxOut::IsDust() in Bitcoin Core.  The assumption is that any output that would
     ; consume more than a third of its value in fees is not something the Bitcoin system wants to deal with right now,
     ; so we call them "dust outputs" and they're made non standard.  The choice of one third is somewhat arbitrary and
     ; may change in future.</p>
     ;
     ; <p>You probably should use {@link org.bitcoinj.core.TransactionOutput#getMinNonDustValue()} which uses
     ; a safe fee-per-kb by default.</p>
     ;
     ; @param feePerKb The fee required per kilobyte.  Note that this is the same as Bitcoin Core's -minrelaytxfee * 3.
     ;;
    #_public
    (§ method Coin getMinNonDustValue(§ args Coin feePerKb))
    (§ block
        ;; A typical output is 33 bytes (pubkey hash + opcodes) and requires an input of 148 bytes to spend so we add
        ;; that together to find out the total amount of data used to transfer this amount of value.  Note that this
        ;; formula is wrong for anything that's not a pay-to-address output, unfortunately, we must follow Bitcoin Core's
        ;; wrongness in order to ensure we're considered standard.  A better formula would either estimate the
        ;; size of data needed to satisfy all different script types, or just hard code 33 below.
        #_final
        (§ var long size = this.unsafeBitcoinSerialize(§ pars ).length + 148)
        (§ return feePerKb.multiply(§ pars size).divide(§ pars 1000))
    )

    ;;;
     ; Returns the minimum value for this output to be considered "not dust", i.e. the transaction will be relayable
     ; and mined by default miners.  For normal pay to address outputs, this is 2730 satoshis, the same as
     ; {@link Transaction#MIN_NONDUST_OUTPUT}.
     ;;
    #_public
    (§ method Coin getMinNonDustValue(§ args ))
    (§ block
        (§ return getMinNonDustValue(§ pars Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.multiply(§ pars 3)))
    )

    ;;;
     ; Sets this objects availableForSpending flag to false and the spentBy pointer to the given input.
     ; If the input is null, it means this output was signed over to somebody else rather than one of our own keys.
     ; @throws IllegalStateException if the transaction was already marked as spent.
     ;;
    #_public
    (§ method void markAsSpent(§ args TransactionInput input))
    (§ block
        (§ call Preconditions.checkState(§ pars availableForSpending))

        (§ ass availableForSpending = false)
        (§ ass spentBy = input)

        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ if (§ expr parent != nil))
            (§ block
                (§ call log.debug(§ pars "Marked {}:{} as spent by {}", getParentTransactionHash(§ pars ), getIndex(§ pars ), input))
            )
            (§ else )
            (§ block
                (§ call log.debug(§ pars "Marked floating output as spent by {}", input))
            )
        )
    )

    ;;;
     ; Resets the spent pointer / availableForSpending flag to null.
     ;;
    #_public
    (§ method void markAsUnspent(§ args ))
    (§ block
        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ if (§ expr parent != nil))
            (§ block
                (§ call log.debug(§ pars "Un-marked {}:{} as spent by {}", getParentTransactionHash(§ pars ), getIndex(§ pars ), spentBy))
            )
            (§ else )
            (§ block
                (§ call log.debug(§ pars "Un-marked floating output as spent by {}", spentBy))
            )
        )

        (§ ass availableForSpending = true)
        (§ ass spentBy = nil)
    )

    ;;;
     ; Returns whether {@link TransactionOutput#markAsSpent(TransactionInput)} has been called on this class.
     ; A {@link Wallet} will mark a transaction output as spent once it sees a transaction input that is connected to it.
     ; Note that this flag can be false when an output has in fact been spent according to the rest of the network if
     ; the spending transaction wasn't downloaded yet, and it can be marked as spent when in reality the rest of the
     ; network believes it to be unspent if the signature or script connecting to it was not actually valid.
     ;;
    #_public
    (§ method boolean isAvailableForSpending(§ args ))
    (§ block
        (§ return availableForSpending)
    )

    ;;;
     ; The backing script bytes which can be turned into a Script object.
     ; @return the scriptBytes
    ;;
    #_public
    (§ method byte[] getScriptBytes(§ args ))
    (§ block
        (§ return scriptBytes)
    )

    ;;;
     ; Returns true if this output is to a key, or an address we have the keys for, in the wallet.
     ;;
    #_public
    (§ method boolean isMine(§ args TransactionBag transactionBag))
    (§ block
        (§ try )
        (§ block
            (§ var Script script = getScriptPubKey(§ pars ))
            (§ if (§ expr script.isSentToRawPubKey(§ pars )))
            (§ block
                (§ return transactionBag.isPubKeyMine(§ pars script.getPubKey(§ pars )))
            )
            (§ if (§ expr script.isPayToScriptHash(§ pars )))
            (§ block
                (§ return transactionBag.isPayToScriptHashMine(§ pars script.getPubKeyHash(§ pars )))
            )
            (§ return transactionBag.isPubKeyHashMine(§ pars script.getPubKeyHash(§ pars )))
        )
        (§ catch (§ args ScriptException e))
        (§ block
            ;; Just means we didn't understand the output of this transaction: ignore it.
            (§ call log.debug(§ pars "Could not parse tx {} output script: {}", (§ expr parent != nil) ? parent.getHash(§ pars ) :else "(no parent)", e.toString(§ pars )))
            (§ return false)
        )
    )

    ;;;
     ; Returns a human readable debug string.
     ;;
    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ try )
        (§ block
            (§ var Script script = getScriptPubKey(§ pars ))
            (§ var StringBuilder sb = new StringBuilder(§ pars "TxOut of "))
            (§ call sb.append(§ pars Coin.valueOf(§ pars value).toFriendlyString(§ pars )))
            (§ if (§ expr script.isSentToAddress(§ pars ) || script.isPayToScriptHash(§ pars )))
            (§ block
                (§ call sb.append(§ pars " to ").append(§ pars script.getToAddress(§ pars params)))
            )
            (§ elseif (§ expr script.isSentToRawPubKey(§ pars )))
            (§ block
                (§ call sb.append(§ pars " to pubkey ").append(§ pars Utils.HEX.encode(§ pars script.getPubKey(§ pars ))))
            )
            (§ elseif (§ expr script.isSentToMultiSig(§ pars )))
            (§ block
                (§ call sb.append(§ pars " to multisig"))
            )
            (§ else )
            (§ block
                (§ call sb.append(§ pars " (unknown type)"))
            )
            (§ call sb.append(§ pars " script:").append(§ pars script))
            (§ return sb.toString(§ pars ))
        )
        (§ catch (§ args ScriptException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )

    ;;;
     ; Returns the connected input.
     ;;
    #_nilable
    #_public
    (§ method TransactionInput getSpentBy(§ args ))
    (§ block
        (§ return spentBy)
    )

    ;;;
     ; Returns the transaction that owns this output.
     ;;
    #_nilable
    #_public
    (§ method Transaction getParentTransaction(§ args ))
    (§ block
        (§ return (§ cast Transaction)parent)
    )

    ;;;
     ; Returns the transaction hash that owns this output.
     ;;
    #_nilable
    #_public
    (§ method Sha256Hash getParentTransactionHash(§ args ))
    (§ block
        (§ return (§ expr parent != nil) ? parent.getHash(§ pars ) :else nil)
    )

    ;;;
     ; Returns the depth in blocks of the parent tx.
     ;
     ; <p>If the transaction appears in the top block, the depth is one.
     ; If it's anything else (pending, dead, unknown), then -1.</p>
     ; @return the tx depth or -1.
     ;;
    #_public
    (§ method int getParentTransactionDepthInBlocks(§ args ))
    (§ block
        (§ if (§ expr getParentTransaction(§ pars ) != nil))
        (§ block
            (§ var TransactionConfidence confidence = getParentTransaction(§ pars ).getConfidence(§ pars ))
            (§ if (§ expr confidence.getConfidenceType(§ pars ) == TransactionConfidence.ConfidenceType.BUILDING))
            (§ block
                (§ return confidence.getDepthInBlocks(§ pars ))
            )
        )
        (§ return -1)
    )

    ;;;
     ; Returns a new {@link TransactionOutPoint}, which is essentially a structure pointing to this output.
     ; Requires that this output is not detached.
     ;;
    #_public
    (§ method TransactionOutPoint getOutPointFor(§ args ))
    (§ block
        (§ return (§ new TransactionOutPoint(§ pars params, getIndex(§ pars ), getParentTransaction(§ pars ))))
    )

    ;;; Returns a copy of the output detached from its containing transaction, if need be. ;;
    #_public
    (§ method TransactionOutput duplicateDetached(§ args ))
    (§ block
        (§ return (§ new TransactionOutput(§ pars params, nil, Coin.valueOf(§ pars value), org.spongycastle.util.Arrays.clone(§ pars scriptBytes))))
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var TransactionOutput other = (§ cast TransactionOutput)o)
        (§ return (§ expr value == other.value && (§ expr parent == nil || (§ expr parent == other.parent && getIndex(§ pars ) == other.getIndex(§ pars ))) && Arrays.equals(§ pars scriptBytes, other.scriptBytes)))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars value, parent, Arrays.hashCode(§ pars scriptBytes)))
    )
)

#_(ns org.bitcoinj.core #_"TransactionOutputChanges"
    (:import [java.io IOException InputStream OutputStream]
             [java.util LinkedList List]))

;;;
 ; <p>TransactionOutputChanges represents a delta to the set of unspent outputs.  It used as a return value for
 ; {@link AbstractBlockChain#connectTransactions(int, Block)}.  It contains the full list of transaction outputs created
 ; and spent in a block.  It DOES contain outputs created that were spent later in the block, as those are needed for
 ; BIP30 (no duplicate txid creation if the previous one was not fully spent prior to this block) verification.</p>
 ;;
#_public
(§ class TransactionOutputChanges
    #_public
    #_final
    (§ field List<UTXO> txOutsCreated)
    #_public
    #_final
    (§ field List<UTXO> txOutsSpent)

    #_public
    (§ constructor TransactionOutputChanges(§ args List<UTXO> txOutsCreated, List<UTXO> txOutsSpent))
    (§ block
        (§ ass this.txOutsCreated = txOutsCreated)
        (§ ass this.txOutsSpent = txOutsSpent)
    )

    #_private
    #_static
    #_final
    (§ method int read4x8le(§ args InputStream is))
        (§ throws IOException)
    (§ block
        (§ return (§ expr (§ expr is.read(§ pars ) & 0xff) | (§ expr (§ expr is.read(§ pars ) & 0xff) << 8) | (§ expr (§ expr is.read(§ pars ) & 0xff) << 16) | (§ expr (§ expr is.read(§ pars ) & 0xff) << 24)))
    )

    #_public
    (§ constructor TransactionOutputChanges(§ args InputStream is))
        (§ throws IOException)
    (§ block
        (§ var int nCreated = read4x8le(§ pars is))
        (§ ass txOutsCreated = new LinkedList<>(§ pars ))
        (§ for (§ var int i = 0) :for (§ expr i < nCreated) :for (§ ass i = i + 1))
        (§ block
            (§ call txOutsCreated.add(§ pars (§ new UTXO(§ pars is))))
        )

        (§ var int nSpent = read4x8le(§ pars is))
        (§ ass txOutsSpent = new LinkedList<>(§ pars ))
        (§ for (§ var int i = 0) :for (§ expr i < nSpent) :for (§ ass i = i + 1))
        (§ block
            (§ call txOutsSpent.add(§ pars (§ new UTXO(§ pars is))))
        )
    )

    #_private
    #_static
    #_final
    (§ method void write4x8le(§ args OutputStream os, int n))
        (§ throws IOException)
    (§ block
        (§ call os.write(§ pars 0xff & n))
        (§ call os.write(§ pars 0xff & (§ expr n >> 8)))
        (§ call os.write(§ pars 0xff & (§ expr n >> 16)))
        (§ call os.write(§ pars 0xff & (§ expr n >> 24)))
    )

    #_public
    (§ method void serializeToStream(§ args OutputStream os))
        (§ throws IOException)
    (§ block
        (§ call write4x8le(§ pars os, txOutsCreated.size(§ pars )))
        (§ for (§ var UTXO output) :for (§ expr txOutsCreated))
        (§ block
            (§ call output.serializeToStream(§ pars os))
        )

        (§ call write4x8le(§ pars os, txOutsSpent.size(§ pars )))
        (§ for (§ var UTXO output) :for (§ expr txOutsSpent))
        (§ block
            (§ call output.serializeToStream(§ pars os))
        )
    )
)

#_(ns org.bitcoinj.core #_"TxConfidenceTable"
    (:import [java.lang.ref *]
             [java.util *]
             [java.util.concurrent.locks *])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.utils *]))

;;;
 ; <p>Tracks transactions that are being announced across the network.  Typically one is created for you by a
 ; {@link PeerGroup} and then given to each Peer to update.  The current purpose is to let Peers update the confidence
 ; (number of peers broadcasting).  It helps address an attack scenario in which a malicious remote peer (or several)
 ; feeds you invalid transactions, e.g. ones that spend coins which don't exist.  If you don't see most of the peers
 ; announce the transaction within a reasonable time, it may be that the TX is not valid.  Alternatively, an attacker
 ; may control your entire internet connection: in this scenario counting broadcasting peers does not help you.</p>
 ;
 ; <p>It is <b>not</b> at this time directly equivalent to the Bitcoin Core memory pool, which tracks
 ; all transactions not currently included in the best chain - it's simply a cache.</p>
 ;;
#_public
(§ class TxConfidenceTable
    #_protected
    (§ field ReentrantLock lock = Threading.lock(§ pars "txconfidencetable"))

    #_private
    #_static
    (§ class WeakConfidenceReference extends WeakReference<TransactionConfidence>
        #_public
        (§ field Sha256Hash hash)

        #_public
        (§ constructor WeakConfidenceReference(§ args TransactionConfidence confidence, ReferenceQueue<TransactionConfidence> queue))
        (§ block
            (§ super (§ pars confidence, queue))

            (§ ass hash = confidence.getTransactionHash(§ pars ))
        )
    )
    #_private
    (§ field LinkedHashMap<Sha256Hash, WeakConfidenceReference> table)

    ;; This ReferenceQueue gets entries added to it when they are only weakly reachable, i.e. the TxConfidenceTable is
    ;; the only thing that is tracking the confidence data anymore.  We check it from time to time and delete table entries
    ;; corresponding to expired transactions.  In this way memory usage of the system is in line with however many
    ;; transactions you actually care to track the confidence of.  We can still end up with lots of hashes being stored
    ;; if our peers flood us with invs but the MAX_SIZE param caps this.
    #_private
    (§ field ReferenceQueue<TransactionConfidence> referenceQueue)

    ;;; The max size of a table created with the no-args constructor. ;;
    #_public
    #_static
    #_final
    (§ field int MAX_SIZE = 1000)

    ;;;
     ; Creates a table that will track at most the given number of transactions (allowing you to bound memory usage).
     ; @param size Max number of transactions to track.  The table will fill up to this size then stop growing.
     ;;
    #_public
    (§ constructor TxConfidenceTable(§ args #_final int size))
    (§ block
        (§ ass table = new LinkedHashMap<Sha256Hash, WeakConfidenceReference>(§ pars )
        (§ anon
            #_override
            #_protected
            (§ method boolean removeEldestEntry(§ args Map.Entry<Sha256Hash, WeakConfidenceReference> entry))
            (§ block
                ;; An arbitrary choice to stop the memory used by tracked transactions getting too huge in the event
                ;; of some kind of DoS attack.
                (§ return (§ expr size < size(§ pars )))
            )
        ))
        (§ ass referenceQueue = new ReferenceQueue<>(§ pars ))
    )

    ;;;
     ; Creates a table that will track at most {@link TxConfidenceTable#MAX_SIZE} entries.
     ; You should normally use this constructor.
     ;;
    #_public
    (§ constructor TxConfidenceTable(§ args ))
    (§ block
        (§ this (§ pars MAX_SIZE))
    )

    ;;;
     ; If any transactions have expired due to being only weakly reachable through us, go ahead and delete their
     ; table entries - it means we downloaded the transaction and sent it to various event listeners, none of
     ; which bothered to keep a reference.  Typically, this is because the transaction does not involve any keys
     ; that are relevant to any of our wallets.
     ;;
    #_private
    (§ method void cleanTable(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var Reference<? extends TransactionConfidence> ref)
            (§ while (§ expr (§ ass ref = referenceQueue.poll(§ pars )) != nil))
            (§ block
                ;; Find which transaction got deleted by the GC.
                (§ var WeakConfidenceReference txRef = (§ cast WeakConfidenceReference)ref)
                ;; And remove the associated map entry, so the other bits of memory can also be reclaimed.
                (§ call table.remove(§ pars txRef.hash))
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the number of peers that have seen the given hash recently.
     ;;
    #_public
    (§ method int numBroadcastPeers(§ args Sha256Hash txHash))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call cleanTable(§ pars ))
            (§ var WeakConfidenceReference entry = table.get(§ pars txHash))
            (§ if (§ expr entry == nil))
            (§ block
                (§ return 0) ;; No such TX known.
            )

            (§ var TransactionConfidence confidence = entry.get(§ pars ))
            (§ if (§ expr confidence == nil))
            (§ block
                ;; Such a TX hash was seen, but nothing seemed to care, so we ended up throwing away the data.
                (§ call table.remove(§ pars txHash))
                (§ return 0)
            )

            (§ return confidence.numBroadcastPeers(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Called by peers when they see a transaction advertised in an "inv" message.  It passes the data on to the relevant
     ; {@link org.bitcoinj.core.TransactionConfidence} object, creating it if needed.
     ;
     ; @return the number of peers that have now announced this hash (including the caller).
     ;;
    #_public
    (§ method TransactionConfidence seen(§ args Sha256Hash hash, PeerAddress byPeer))
    (§ block
        (§ var TransactionConfidence confidence)
        (§ var boolean fresh = false)
        (§ call lock.lock(§ pars ))
        (§ block
            (§ call cleanTable(§ pars ))
            (§ ass confidence = getOrCreate(§ pars hash))
            (§ ass fresh = confidence.markBroadcastBy(§ pars byPeer))
        )
        (§ call lock.unlock(§ pars ))
        (§ if (§ expr fresh))
        (§ block
            (§ call confidence.queueListeners(§ pars TransactionConfidence.Listener.ChangeReason.SEEN_PEERS))
        )
        (§ return confidence)
    )

    ;;;
     ; Returns the {@link TransactionConfidence} for the given hash if we have downloaded it, or null if that tx hash
     ; is unknown to the system at this time.
     ;;
    #_public
    (§ method TransactionConfidence getOrCreate(§ args Sha256Hash hash))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars hash))

        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var WeakConfidenceReference reference = table.get(§ pars hash))
            (§ if (§ expr reference != nil))
            (§ block
                (§ var TransactionConfidence confidence = reference.get(§ pars ))
                (§ if (§ expr confidence != nil))
                (§ block
                    (§ return confidence)
                )
            )
            (§ var TransactionConfidence newConfidence = new TransactionConfidence(§ pars hash))
            (§ call table.put(§ pars hash, new WeakConfidenceReference(§ pars newConfidence, referenceQueue)))
            (§ return newConfidence)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the {@link TransactionConfidence} for the given hash if we have downloaded it, or null if that tx hash
     ; is unknown to the system at this time.
     ;;
    #_nilable
    #_public
    (§ method TransactionConfidence get(§ args Sha256Hash hash))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var WeakConfidenceReference ref = table.get(§ pars hash))
            (§ return (§ expr ref != nil) ? ref.get(§ pars ) :else nil)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )
)

#_(ns org.bitcoinj.core #_"UTXO"
    (:import [java.io *]
             [java.math *]
             [java.util Locale])
    (:import [com.google.common.base Objects])
   (:require [org.bitcoinj.script *]))

;; TODO: Fix this class: should not talk about addresses, height should be optional/support mempool height etc.

;;;
 ; A UTXO message contains the information necessary to check a spending transaction.
 ; It avoids having to store the entire parentTransaction just to get the hash and index.
 ; Useful when working with free standing outputs.
 ;;
#_public
(§ class UTXO implements Serializable
    #_private
    (§ field Coin value)
    #_private
    (§ field Script script)
    #_private
    (§ field Sha256Hash hash)
    #_private
    (§ field long index)
    #_private
    (§ field int height)
    #_private
    (§ field boolean coinbase)
    #_private
    (§ field String address)

    ;;;
     ; Creates a stored transaction output.
     ;
     ; @param hash     The hash of the containing transaction.
     ; @param index    The outpoint.
     ; @param value    The value available.
     ; @param height   The height this output was created in.
     ; @param coinbase The coinbase flag.
     ;;
    #_public
    (§ constructor UTXO(§ args Sha256Hash hash, long index, Coin value, int height, boolean coinbase, Script script))
    (§ block
        (§ ass this.hash = hash)
        (§ ass this.index = index)
        (§ ass this.value = value)
        (§ ass this.height = height)
        (§ ass this.script = script)
        (§ ass this.coinbase = coinbase)
        (§ ass this.address = "")
    )

    ;;;
     ; Creates a stored transaction output.
     ;
     ; @param hash     The hash of the containing transaction.
     ; @param index    The outpoint.
     ; @param value    The value available.
     ; @param height   The height this output was created in.
     ; @param coinbase The coinbase flag.
     ; @param address  The address.
     ;;
    #_public
    (§ constructor UTXO(§ args Sha256Hash hash, long index, Coin value, int height, boolean coinbase, Script script, String address))
    (§ block
        (§ this (§ pars hash, index, value, height, coinbase, script))
        (§ ass this.address = address)
    )

    #_public
    (§ constructor UTXO(§ args InputStream in))
        (§ throws IOException)
    (§ block
        (§ call deserializeFromStream(§ pars in))
    )

    ;;; The value which this Transaction output holds. ;;
    #_public
    (§ method Coin getValue(§ args ))
    (§ block
        (§ return value)
    )

    ;;; The Script object which you can use to get address, script bytes or script type. ;;
    #_public
    (§ method Script getScript(§ args ))
    (§ block
        (§ return script)
    )

    ;;; The hash of the transaction which holds this output. ;;
    #_public
    (§ method Sha256Hash getHash(§ args ))
    (§ block
        (§ return hash)
    )

    ;;; The index of this output in the transaction which holds it. ;;
    #_public
    (§ method long getIndex(§ args ))
    (§ block
        (§ return index)
    )

    ;;; Gets the height of the block that created this output. ;;
    #_public
    (§ method int getHeight(§ args ))
    (§ block
        (§ return height)
    )

    ;;; Gets the flag of whether this was created by a coinbase tx. ;;
    #_public
    (§ method boolean isCoinbase(§ args ))
    (§ block
        (§ return coinbase)
    )

    ;;; The address of this output, can be the empty string if none was provided at construction time or was deserialized. ;;
    #_public
    (§ method String getAddress(§ args ))
    (§ block
        (§ return address)
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return String.format(§ pars Locale.US, "Stored TxOut of %s (%s:%d)", value.toFriendlyString(§ pars ), hash, index))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars getIndex(§ pars ), getHash(§ pars )))
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var UTXO other = (§ cast UTXO)o)
        (§ return (§ expr getIndex(§ pars ) == other.getIndex(§ pars ) && getHash(§ pars ).equals(§ pars other.getHash(§ pars ))))
    )

    #_private
    #_static
    #_final
    (§ method void write4x8le(§ args OutputStream os, int n))
        (§ throws IOException)
    (§ block
        (§ call os.write(§ pars 0xff & n))
        (§ call os.write(§ pars 0xff & (§ expr n >> 8)))
        (§ call os.write(§ pars 0xff & (§ expr n >> 16)))
        (§ call os.write(§ pars 0xff & (§ expr n >> 24)))
    )

    #_public
    (§ method void serializeToStream(§ args OutputStream os))
        (§ throws IOException)
    (§ block
        (§ call Utils.uint64ToByteStreamLE(§ pars BigInteger.valueOf(§ pars value.value), os))

        (§ var byte[] scriptBytes = script.getProgram(§ pars ))
        (§ call write4x8le(§ pars os, scriptBytes.length))
        (§ call os.write(§ pars scriptBytes))

        (§ call os.write(§ pars hash.getBytes(§ pars )))
        (§ call Utils.uint32ToByteStreamLE(§ pars index, os))

        (§ call write4x8le(§ pars os, height))
        (§ call os.write(§ pars new byte[] (§ coll (§ cast byte)(§ quest coinbase ? 1 :else 0) )))
    )

    #_private
    #_static
    #_final
    (§ method int read4x8le(§ args InputStream is))
        (§ throws IOException)
    (§ block
        (§ return (§ expr (§ expr is.read(§ pars ) & 0xff) | (§ expr (§ expr is.read(§ pars ) & 0xff) << 8) | (§ expr (§ expr is.read(§ pars ) & 0xff) << 16) | (§ expr (§ expr is.read(§ pars ) & 0xff) << 24)))
    )

    #_public
    (§ method void deserializeFromStream(§ args InputStream is))
        (§ throws IOException)
    (§ block
        (§ var byte[] valueBytes = new byte[8])
        (§ if (§ expr is.read(§ pars valueBytes, 0, 8) != 8))
        (§ block
            (§ throw (§ new EOFException(§ pars )))
        )
        (§ ass value = Coin.valueOf(§ pars Utils.readInt64(§ pars valueBytes, 0)))

        (§ var int scriptBytesLength = read4x8le(§ pars is))
        (§ var byte[] scriptBytes = new byte[scriptBytesLength])
        (§ if (§ expr is.read(§ pars scriptBytes) != scriptBytesLength))
        (§ block
            (§ throw (§ new EOFException(§ pars )))
        )
        (§ ass script = new Script(§ pars scriptBytes))

        (§ var byte[] hashBytes = new byte[32])
        (§ if (§ expr is.read(§ pars hashBytes) != 32))
        (§ block
            (§ throw (§ new EOFException(§ pars )))
        )
        (§ ass hash = Sha256Hash.wrap(§ pars hashBytes))

        (§ var byte[] indexBytes = new byte[4])
        (§ if (§ expr is.read(§ pars indexBytes) != 4))
        (§ block
            (§ throw (§ new EOFException(§ pars )))
        )
        (§ ass index = Utils.readUint32(§ pars indexBytes, 0))

        (§ ass height = read4x8le(§ pars is))

        (§ var byte[] coinbaseByte = new byte[1])
        (§ call is.read(§ pars coinbaseByte))
        (§ ass coinbase = (§ expr coinbaseByte[0] == 1))
    )

    #_private
    (§ method void writeObject(§ args ObjectOutputStream o))
        (§ throws IOException)
    (§ block
        (§ call serializeToStream(§ pars o))
    )

    #_private
    (§ method void readObject(§ args ObjectInputStream o))
        (§ throws IOException, ClassNotFoundException)
    (§ block
        (§ call deserializeFromStream(§ pars o))
    )
)

#_(ns org.bitcoinj.core #_"UnknownMessage")

;;;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class UnknownMessage extends EmptyMessage
    #_private
    (§ field String name)

    #_public
    (§ constructor UnknownMessage(§ args NetworkParameters params, String name, byte[] payloadBytes))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payloadBytes, 0))

        (§ ass this.name = name)
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return "Unknown message [" + name + "]: " + (§ expr payload != nil ? Utils.HEX.encode(§ pars payload) :else ""))
    )
)

#_(ns org.bitcoinj.core #_"UnsafeByteArrayOutputStream"
    (:import [java.io ByteArrayOutputStream IOException OutputStream]))

;;;
 ; An unsynchronized implementation of ByteArrayOutputStream that will return the backing byte array
 ; if its length == size().  This avoids unneeded array copy where the BOS is simply being used to
 ; extract a byte array of known length from a 'serialized to stream' method.
 ;
 ; Unless the final length can be accurately predicted the only performance this will yield is due
 ; to unsynchronized methods.
 ;
 ; @author git
 ;;
#_public
(§ class UnsafeByteArrayOutputStream extends ByteArrayOutputStream
    #_public
    (§ constructor UnsafeByteArrayOutputStream(§ args ))
    (§ block
        (§ super (§ pars 32))
    )

    #_public
    (§ constructor UnsafeByteArrayOutputStream(§ args int size))
    (§ block
        (§ super (§ pars size))
    )

    ;;;
     ; Writes the specified byte to this byte array output stream.
     ;
     ; @param b The byte to be written.
     ;;
    #_override
    #_public
    (§ method void write(§ args int b))
    (§ block
        (§ var int n = count + 1)
        (§ if (§ expr buf.length < n))
        (§ block
            (§ ass buf = Utils.copyOf(§ pars buf, Math.max(§ pars buf.length << 1, n)))
        )
        (§ ass buf[count] = (§ cast byte)b)
        (§ ass count = n)
    )

    ;;;
     ; Writes <code>len</code> bytes from the specified byte array
     ; starting at offset <code>off</code> to this byte array output stream.
     ;
     ; @param b   The data.
     ; @param off The start offset in the data.
     ; @param len The number of bytes to write.
     ;;
    #_override
    #_public
    (§ method void write(§ args byte[] b, int off, int len))
    (§ block
        (§ if (§ expr off < 0 || b.length < off || len < 0 || b.length < off + len || off + len < 0))
        (§ block
            (§ throw (§ new IndexOutOfBoundsException(§ pars )))
        )

        (§ if (§ expr len != 0))
        (§ block
            (§ var int n = count + len)
            (§ if (§ expr buf.length < n))
            (§ block
                (§ ass buf = Utils.copyOf(§ pars buf, Math.max(§ pars buf.length << 1, n)))
            )
            (§ call System.arraycopy(§ pars b, off, buf, count, len))
            (§ ass count = n)
        )
    )

    ;;;
     ; Writes the complete contents of this byte array output stream to
     ; the specified output stream argument, as if by calling the output
     ; stream's write method using <code>out.write(buf, 0, count)</code>.
     ;
     ; @param out The output stream to which to write the data.
     ; @throws IOException if an I/O error occurs.
     ;;
    #_override
    #_public
    (§ method void writeTo(§ args OutputStream out))
        (§ throws IOException)
    (§ block
        (§ call out.write(§ pars buf, 0, count))
    )

    ;;;
     ; Resets the <code>count</code> field of this byte array output
     ; stream to zero, so that all currently accumulated output in the
     ; output stream is discarded.  The output stream can be used again,
     ; reusing the already allocated buffer space.
     ;
     ; @see java.io.ByteArrayInputStream#count
     ;;
    #_override
    #_public
    (§ method void reset(§ args ))
    (§ block
        (§ ass count = 0)
    )

    ;;;
     ; Creates a newly allocated byte array.  Its size is the current
     ; size of this output stream and the valid contents of the buffer
     ; have been copied into it.
     ;
     ; @return the current contents of this output stream, as a byte array.
     ; @see java.io.ByteArrayOutputStream#size()
     ;;
    #_override
    #_public
    (§ method byte[] toByteArray(§ args ))
    (§ block
        (§ return (§ quest (§ expr count == buf.length) ? buf :else Utils.copyOf(§ pars buf, count)))
    )

    ;;;
     ; Returns the current size of the buffer.
     ;
     ; @return the value of the <code>count</code> field, which is the number
     ;         of valid bytes in this output stream.
     ; @see java.io.ByteArrayOutputStream#count
     ;;
    #_override
    #_public
    (§ method int size(§ args ))
    (§ block
        (§ return count)
    )
)

#_(ns org.bitcoinj.core #_"Utils"
    (:import [java.io ByteArrayOutputStream IOException InputStream OutputStream UnsupportedEncodingException]
             [java.math BigInteger]
             [java.net URL]
             [java.text DateFormat SimpleDateFormat]
             [java.util *]
             [java.util.concurrent ArrayBlockingQueue BlockingQueue TimeUnit])
    (:import [com.google.common.base Charsets Joiner Preconditions]
             [com.google.common.collect Lists Ordering]
             [com.google.common.io BaseEncoding Resources]
             [com.google.common.primitives Ints UnsignedLongs]
             #_static [com.google.common.util.concurrent.Uninterruptibles sleepUninterruptibly]
             [org.spongycastle.crypto.digests RIPEMD160Digest]))

;;;
 ; A collection of various utility methods that are helpful for working with the Bitcoin protocol.
 ; To enable debug logging from the library, run with -Dbitcoinj.logging=true on your command line.
 ;;
#_public
(§ class Utils
    ;;; The string that prefixes all text messages signed using Bitcoin keys. ;;
    #_public
    #_static
    #_final
    (§ field String BITCOIN_SIGNED_MESSAGE_HEADER = "Bitcoin Signed Message:\n")
    #_public
    #_static
    #_final
    (§ field byte[] BITCOIN_SIGNED_MESSAGE_HEADER_BYTES = BITCOIN_SIGNED_MESSAGE_HEADER.getBytes(§ pars Charsets.UTF_8))

    #_public
    #_static
    #_final
    (§ field Joiner SPACE_JOINER = Joiner.on(§ pars " "))

    #_private
    #_static
    (§ field BlockingQueue<Boolean> mockSleepQueue)

    ;;;
     ; The regular {@link java.math.BigInteger#toByteArray()} includes the sign bit of the number and
     ; might result in an extra byte addition.  This method removes this extra byte.
     ;
     ; Assuming only positive numbers, it's possible to discriminate if an extra byte
     ; is added by checking if the first element of the array is 0 (0000_0000).
     ; Due to the minimal representation provided by BigInteger, it means that the bit sign
     ; is the least significant bit 0000_000<b>0</b>.  Otherwise the representation is not minimal.
     ; For example, if the sign bit is 0000_00<b>0</b>0, then the representation is not minimal due to the rightmost zero.
     ;
     ; @param b The integer to format into a byte array.
     ; @param numBytes The desired size of the resulting byte array.
     ; @return numBytes byte long array.
     ;;
    #_public
    #_static
    (§ method byte[] bigIntegerToBytes(§ args BigInteger b, int numBytes))
    (§ block
        (§ call Preconditions.checkArgument(§ pars 0 <= b.signum(§ pars ), "b must be positive or zero"))
        (§ call Preconditions.checkArgument(§ pars 0 < numBytes, "numBytes must be positive"))

        (§ var byte[] src = b.toByteArray(§ pars ))
        (§ var byte[] dest = new byte[numBytes])
        (§ var boolean isFirstByteOnlyForSign = (§ expr src[0] == 0))
        (§ var int length = isFirstByteOnlyForSign ? src.length - 1 :else src.length)

        (§ call Preconditions.checkArgument(§ pars length <= numBytes, "The given number does not fit in " + numBytes))

        (§ var int srcPos = isFirstByteOnlyForSign ? 1 :else 0)
        (§ var int destPos = numBytes - length)
        (§ call System.arraycopy(§ pars src, srcPos, dest, destPos, length))
        (§ return dest)
    )

    #_public
    #_static
    (§ method void uint32ToByteArrayBE(§ args long val, byte[] out, int offset))
    (§ block
        (§ ass out[offset] = (§ cast byte)(§ expr 0xff & (§ expr val >> 24)))
        (§ ass out[offset + 1] = (§ cast byte)(§ expr 0xff & (§ expr val >> 16)))
        (§ ass out[offset + 2] = (§ cast byte)(§ expr 0xff & (§ expr val >> 8)))
        (§ ass out[offset + 3] = (§ cast byte)(§ expr 0xff & val))
    )

    #_public
    #_static
    (§ method void uint32ToByteArrayLE(§ args long val, byte[] out, int offset))
    (§ block
        (§ ass out[offset] = (§ cast byte)(§ expr 0xff & val))
        (§ ass out[offset + 1] = (§ cast byte)(§ expr 0xff & (§ expr val >> 8)))
        (§ ass out[offset + 2] = (§ cast byte)(§ expr 0xff & (§ expr val >> 16)))
        (§ ass out[offset + 3] = (§ cast byte)(§ expr 0xff & (§ expr val >> 24)))
    )

    #_public
    #_static
    (§ method void uint64ToByteArrayLE(§ args long val, byte[] out, int offset))
    (§ block
        (§ ass out[offset] = (§ cast byte)(§ expr 0xff & val))
        (§ ass out[offset + 1] = (§ cast byte)(§ expr 0xff & (§ expr val >> 8)))
        (§ ass out[offset + 2] = (§ cast byte)(§ expr 0xff & (§ expr val >> 16)))
        (§ ass out[offset + 3] = (§ cast byte)(§ expr 0xff & (§ expr val >> 24)))
        (§ ass out[offset + 4] = (§ cast byte)(§ expr 0xff & (§ expr val >> 32)))
        (§ ass out[offset + 5] = (§ cast byte)(§ expr 0xff & (§ expr val >> 40)))
        (§ ass out[offset + 6] = (§ cast byte)(§ expr 0xff & (§ expr val >> 48)))
        (§ ass out[offset + 7] = (§ cast byte)(§ expr 0xff & (§ expr val >> 56)))
    )

    #_public
    #_static
    (§ method void uint32ToByteStreamLE(§ args long val, OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ call stream.write(§ pars (§ cast int)(§ expr 0xff & val)))
        (§ call stream.write(§ pars (§ cast int)(§ expr 0xff & (§ expr val >> 8))))
        (§ call stream.write(§ pars (§ cast int)(§ expr 0xff & (§ expr val >> 16))))
        (§ call stream.write(§ pars (§ cast int)(§ expr 0xff & (§ expr val >> 24))))
    )

    #_public
    #_static
    (§ method void int64ToByteStreamLE(§ args long val, OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ call stream.write(§ pars (§ cast int)(§ expr 0xff & val)))
        (§ call stream.write(§ pars (§ cast int)(§ expr 0xff & (§ expr val >> 8))))
        (§ call stream.write(§ pars (§ cast int)(§ expr 0xff & (§ expr val >> 16))))
        (§ call stream.write(§ pars (§ cast int)(§ expr 0xff & (§ expr val >> 24))))
        (§ call stream.write(§ pars (§ cast int)(§ expr 0xff & (§ expr val >> 32))))
        (§ call stream.write(§ pars (§ cast int)(§ expr 0xff & (§ expr val >> 40))))
        (§ call stream.write(§ pars (§ cast int)(§ expr 0xff & (§ expr val >> 48))))
        (§ call stream.write(§ pars (§ cast int)(§ expr 0xff & (§ expr val >> 56))))
    )

    #_public
    #_static
    (§ method void uint64ToByteStreamLE(§ args BigInteger val, OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ var byte[] bytes = val.toByteArray(§ pars ))
        (§ if (§ expr 8 < bytes.length))
        (§ block
            (§ throw (§ new RuntimeException(§ pars "Input too large to encode into a uint64")))
        )

        (§ ass bytes = reverseBytes(§ pars bytes))
        (§ call stream.write(§ pars bytes))
        (§ if (§ expr bytes.length < 8))
        (§ block
            (§ for (§ var int i = 0) :for (§ expr i < 8 - bytes.length) :for (§ ass i = i + 1))
            (§ block
                (§ call stream.write(§ pars 0))
            )
        )
    )

    ;;;
     ; Work around lack of unsigned types in Java.
     ;;
    #_public
    #_static
    (§ method boolean isLessThanUnsigned(§ args long n1, long n2))
    (§ block
        (§ return (§ expr UnsignedLongs.compare(§ pars n1, n2) < 0))
    )

    ;;;
     ; Work around lack of unsigned types in Java.
     ;;
    #_public
    #_static
    (§ method boolean isLessThanOrEqualToUnsigned(§ args long n1, long n2))
    (§ block
        (§ return (§ expr UnsignedLongs.compare(§ pars n1, n2) <= 0))
    )

    ;;;
     ; Hex encoding used throughout the framework.  Use with HEX.encode(byte[]) or HEX.decode(CharSequence).
     ;;
    #_public
    #_static
    #_final
    (§ field BaseEncoding HEX = BaseEncoding.base16(§ pars ).lowerCase(§ pars ))

    ;;;
     ; Returns a copy of the given byte array in reverse order.
     ;;
    #_public
    #_static
    (§ method byte[] reverseBytes(§ args byte[] bytes))
    (§ block
        ;; We could use the XOR trick here, but it's easier to understand if we don't.
        ;; If we find this is really a performance issue, the matter can be revisited.
        (§ var byte[] buf = new byte[bytes.length])
        (§ for (§ var int i = 0) :for (§ expr i < bytes.length) :for (§ ass i = i + 1))
        (§ block
            (§ ass buf[i] = bytes[bytes.length - 1 - i])
        )
        (§ return buf)
    )

    ;;;
     ; Returns a copy of the given byte array with the bytes of each double-word (4 bytes) reversed.
     ;
     ; @param bytes Length must be divisible by 4.
     ; @param trimLength Trim output to this length.  If positive, must be divisible by 4.
     ;;
    #_public
    #_static
    (§ method byte[] reverseDwordBytes(§ args byte[] bytes, int trimLength))
    (§ block
        (§ call Preconditions.checkArgument(§ pars bytes.length % 4 == 0))
        (§ call Preconditions.checkArgument(§ pars trimLength < 0 || trimLength % 4 == 0))

        (§ var byte[] rev = new byte[(§ expr 0 <= trimLength && trimLength < bytes.length) ? trimLength :else bytes.length])

        (§ for (§ var int i = 0) :for (§ expr i < rev.length) :for (§ ass i = i + 4))
        (§ block
            (§ call System.arraycopy(§ pars bytes, i, rev, i , 4))
            (§ for (§ var int j = 0) :for (§ expr j < 4) :for (§ ass j = j + 1))
            (§ block
                (§ ass rev[i + j] = bytes[i + 3 - j])
            )
        )
        (§ return rev)
    )

    ;;; Parse 4 bytes from the byte array (starting at the offset) as unsigned 32-bit integer in little endian format. ;;
    #_public
    #_static
    (§ method long readUint32(§ args byte[] bytes, int offset))
    (§ block
        (§ return (§ expr (§ expr bytes[offset] & 0xff) | (§ expr (§ expr bytes[offset + 1] & 0xff) << 8) | (§ expr (§ expr bytes[offset + 2] & 0xff) << 16) | (§ expr (§ expr bytes[offset + 3] & 0xff) << 24)))
    )

    ;;; Parse 8 bytes from the byte array (starting at the offset) as signed 64-bit integer in little endian format. ;;
    #_public
    #_static
    (§ method long readInt64(§ args byte[] bytes, int offset))
    (§ block
        (§ return (§ expr (§ expr bytes[offset] & 0xff) | (§ expr (§ expr bytes[offset + 1] & 0xff) << 8) | (§ expr (§ expr bytes[offset + 2] & 0xff) << 16) | (§ expr (§ expr bytes[offset + 3] & 0xff) << 24) | (§ expr (§ expr bytes[offset + 4] & 0xff) << 32) | (§ expr (§ expr bytes[offset + 5] & 0xff) << 40) | (§ expr (§ expr bytes[offset + 6] & 0xff) << 48) | (§ expr (§ expr bytes[offset + 7] & 0xff) << 56)))
    )

    ;;; Parse 4 bytes from the byte array (starting at the offset) as unsigned 32-bit integer in big endian format. ;;
    #_public
    #_static
    (§ method long readUint32BE(§ args byte[] bytes, int offset))
    (§ block
        (§ return (§ expr (§ expr (§ expr bytes[offset] & 0xff) << 24) |  (§ expr (§ expr bytes[offset + 1] & 0xff) << 16) |  (§ expr (§ expr bytes[offset + 2] & 0xff) << 8) |   (§ expr bytes[offset + 3] & 0xff)))
    )

    ;;; Parse 2 bytes from the byte array (starting at the offset) as unsigned 16-bit integer in big endian format. ;;
    #_public
    #_static
    (§ method int readUint16BE(§ args byte[] bytes, int offset))
    (§ block
        (§ return (§ expr (§ expr (§ expr bytes[offset] & 0xff) << 8) |   (§ expr bytes[offset + 1] & 0xff)))
    )

    ;;;
     ; Calculates RIPEMD160(SHA256(input)).  This is used in Address calculations.
     ;;
    #_public
    #_static
    (§ method byte[] sha256hash160(§ args byte[] input))
    (§ block
        (§ var byte[] sha256 = Sha256Hash.hash(§ pars input))
        (§ var RIPEMD160Digest digest = new RIPEMD160Digest(§ pars ))
        (§ call digest.update(§ pars sha256, 0, sha256.length))
        (§ var byte[] out = new byte[20])
        (§ call digest.doFinal(§ pars out, 0))
        (§ return out)
    )

    ;;;
     ; MPI encoded numbers are produced by the OpenSSL BN_bn2mpi function.  They consist of
     ; a 4 byte big endian length field, followed by the stated number of bytes representing
     ; the number in big endian format (with a sign bit).
     ; @param hasLength can be set to false if the given array is missing the 4 byte length field.
     ;;
    #_public
    #_static
    (§ method BigInteger decodeMPI(§ args byte[] mpi, boolean hasLength))
    (§ block
        (§ var byte[] buf)
        (§ if (§ expr hasLength))
        (§ block
            (§ var int length = (§ cast int)readUint32BE(§ pars mpi, 0))
            (§ ass buf = new byte[length])
            (§ call System.arraycopy(§ pars mpi, 4, buf, 0, length))
        )
        (§ else )
        (§ block
            (§ ass buf = mpi)
        )
        (§ if (§ expr buf.length == 0))
        (§ block
            (§ return BigInteger.ZERO)
        )

        (§ var boolean isNegative = (§ expr (§ expr buf[0] & 0x80) == 0x80))
        (§ if (§ expr isNegative))
        (§ block
            (§ ass buf[0] = buf[0] & 0x7f)
        )
        (§ var BigInteger result = new BigInteger(§ pars buf))
        (§ return isNegative ? result.negate(§ pars ) :else result)
    )

    ;;;
     ; MPI encoded numbers are produced by the OpenSSL BN_bn2mpi function.  They consist of
     ; a 4 byte big endian length field, followed by the stated number of bytes representing
     ; the number in big endian format (with a sign bit).
     ; @param includeLength indicates whether the 4 byte length field should be included.
     ;;
    #_public
    #_static
    (§ method byte[] encodeMPI(§ args BigInteger value, boolean includeLength))
    (§ block
        (§ if (§ expr value.equals(§ pars BigInteger.ZERO)))
        (§ block
            (§ return includeLength ? new byte[] (§ coll 0x00, 0x00, 0x00, 0x00 ) :else new byte[] (§ coll ))
        )

        (§ var boolean isNegative = (§ expr value.signum(§ pars ) < 0))
        (§ if (§ expr isNegative))
        (§ block
            (§ ass value = value.negate(§ pars ))
        )
        (§ var byte[] array = value.toByteArray(§ pars ))
        (§ var int length = array.length)
        (§ if (§ expr (§ expr array[0] & 0x80) == 0x80))
        (§ block
            (§ ass length = length + 1)
        )

        (§ if (§ expr includeLength))
        (§ block
            (§ var byte[] result = new byte[length + 4])
            (§ call System.arraycopy(§ pars array, 0, result, length - array.length + 3, array.length))
            (§ call uint32ToByteArrayBE(§ pars length, result, 0))
            (§ if (§ expr isNegative))
            (§ block
                (§ ass result[4] = result[4] | 0x80)
            )
            (§ return result)
        )
        (§ else )
        (§ block
            (§ var byte[] result)
            (§ if (§ expr length != array.length))
            (§ block
                (§ ass result = new byte[length])
                (§ call System.arraycopy(§ pars array, 0, result, 1, array.length))
            )
            (§ else )
            (§ block
                (§ ass result = array)
            )
            (§ if (§ expr isNegative))
            (§ block
                (§ ass result[0] = result[0] | 0x80)
            )
            (§ return result)
        )
    )

    ;;;
     ; <p>The "compact" format is a representation of a whole number N using an unsigned 32 bit number similar to
     ; a floating point format.  The most significant 8 bits are the unsigned exponent of base 256.  This exponent
     ; can be thought of as "number of bytes of N".  The lower 23 bits are the mantissa.  Bit number 24 (0x800000)
     ; represents the sign of N.  Therefore, N = (-1^sign) * mantissa * 256^(exponent-3).</p>
     ;
     ; <p>Satoshi's original implementation used BN_bn2mpi() and BN_mpi2bn().  MPI uses the most significant bit of
     ; the first byte as sign.  Thus 0x1234560000 is compact 0x05123456 and 0xc0de000000 is compact 0x0600c0de.
     ; Compact 0x05c0de00 would be -0x40de000000.</p>
     ;
     ; <p>Bitcoin only uses this "compact" format for encoding difficulty targets, which are unsigned 256bit quantities.
     ; Thus, all the complexities of the sign bit and using base 256 are probably an implementation accident.</p>
     ;;
    #_public
    #_static
    (§ method BigInteger decodeCompactBits(§ args long compact))
    (§ block
        (§ var int size = (§ expr (§ expr (§ cast int)(§ expr compact >> 24)) & 0xff))
        (§ var byte[] bytes = new byte[4 + size])
        (§ ass bytes[3] = (§ cast byte)size)
        (§ if (§ expr 1 <= size))
        (§ block
            (§ ass bytes[4] = (§ cast byte)(§ expr (§ expr compact >> 16) & 0xff))
        )
        (§ if (§ expr 2 <= size))
        (§ block
            (§ ass bytes[5] = (§ cast byte)(§ expr (§ expr compact >> 8) & 0xff))
        )
        (§ if (§ expr 3 <= size))
        (§ block
            (§ ass bytes[6] = (§ cast byte)(§ expr compact & 0xff))
        )
        (§ return decodeMPI(§ pars bytes, true))
    )

    ;;;
     ; @see Utils#decodeCompactBits(long)
     ;;
    #_public
    #_static
    (§ method long encodeCompactBits(§ args BigInteger value))
    (§ block
        (§ var long result)
        (§ var int size = value.toByteArray(§ pars ).length)
        (§ if (§ expr size <= 3))
        (§ block
            (§ ass result = value.longValue(§ pars ) << 8 * (§ expr 3 - size))
        )
        (§ else )
        (§ block
            (§ ass result = value.shiftRight(§ pars 8 * (§ expr size - 3)).longValue(§ pars ))
        )
        ;; The 0x00800000 bit denotes the sign.
        ;; Thus, if it is already set, divide the mantissa by 256 and increase the exponent.
        (§ if (§ expr (§ expr result & 0x00800000) != 0))
        (§ block
            (§ ass result = result >> 8)
            (§ ass size = size + 1)
        )
        (§ ass result = result | (§ expr size << 24))
        (§ ass result = result | (§ expr value.signum(§ pars ) == -1 ? 0x00800000 :else 0))
        (§ return result)
    )

    ;;;
     ; If non-null, overrides the return value of now().
     ;;
    #_public
    #_static
    #_volatile
    (§ field Date mockTime)

    ;;;
     ; Advances (or rewinds) the mock clock by the given number of seconds.
     ;;
    #_public
    #_static
    (§ method Date rollMockClock(§ args int seconds))
    (§ block
        (§ return rollMockClockMillis(§ pars seconds * 1000))
    )

    ;;;
     ; Advances (or rewinds) the mock clock by the given number of milliseconds.
     ;;
    #_public
    #_static
    (§ method Date rollMockClockMillis(§ args long millis))
    (§ block
        (§ if (§ expr mockTime == nil))
        (§ block
            (§ throw (§ new IllegalStateException(§ pars "You need to use setMockClock() first.")))
        )

        (§ ass mockTime = new Date(§ pars mockTime.getTime(§ pars ) + millis))
        (§ return mockTime)
    )

    ;;;
     ; Sets the mock clock to the current time.
     ;;
    #_public
    #_static
    (§ method void setMockClock(§ args ))
    (§ block
        (§ ass mockTime = new Date(§ pars ))
    )

    ;;;
     ; Sets the mock clock to the given time (in seconds).
     ;;
    #_public
    #_static
    (§ method void setMockClock(§ args long mockClockSeconds))
    (§ block
        (§ ass mockTime = new Date(§ pars mockClockSeconds * 1000))
    )

    ;;;
     ; Returns the current time, or a mocked out equivalent.
     ;;
    #_public
    #_static
    (§ method Date now(§ args ))
    (§ block
        (§ return (§ quest (§ expr mockTime != nil) ? mockTime :else new Date(§ pars )))
    )

    ;; TODO: Replace usages of this where the result is / 1000 with currentTimeSeconds.
    ;;; Returns the current time in milliseconds since the epoch, or a mocked out equivalent. ;;
    #_public
    #_static
    (§ method long currentTimeMillis(§ args ))
    (§ block
        (§ return (§ quest (§ expr mockTime != nil) ? mockTime.getTime(§ pars ) :else System.currentTimeMillis(§ pars )))
    )

    #_public
    #_static
    (§ method long currentTimeSeconds(§ args ))
    (§ block
        (§ return currentTimeMillis(§ pars ) / 1000)
    )

    #_private
    #_static
    #_final
    (§ field TimeZone UTC = TimeZone.getTimeZone(§ pars "UTC"))

    ;;;
     ; Formats a given date+time value to an ISO 8601 string.
     ; @param dateTime value to format, as a Date
     ;;
    #_public
    #_static
    (§ method String dateTimeFormat(§ args Date dateTime))
    (§ block
        (§ var DateFormat iso8601 = new SimpleDateFormat(§ pars "yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US))
        (§ call iso8601.setTimeZone(§ pars UTC))
        (§ return iso8601.format(§ pars dateTime))
    )

    ;;;
     ; Formats a given date+time value to an ISO 8601 string.
     ; @param dateTime value to format, unix time (ms)
     ;;
    #_public
    #_static
    (§ method String dateTimeFormat(§ args long dateTime))
    (§ block
        (§ var DateFormat iso8601 = new SimpleDateFormat(§ pars "yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.US))
        (§ call iso8601.setTimeZone(§ pars UTC))
        (§ return iso8601.format(§ pars dateTime))
    )

    #_public
    #_static
    (§ method byte[] copyOf(§ args byte[] in, int length))
    (§ block
        (§ var byte[] out = new byte[length])
        (§ call System.arraycopy(§ pars in, 0, out, 0, Math.min(§ pars length, in.length)))
        (§ return out)
    )

    ;;;
     ; Creates a copy of bytes and appends b to the end of it.
     ;;
    #_public
    #_static
    (§ method byte[] appendByte(§ args byte[] bytes, byte b))
    (§ block
        (§ var byte[] result = Arrays.copyOf(§ pars bytes, bytes.length + 1))
        (§ ass result[result.length - 1] = b)
        (§ return result)
    )

    ;;;
     ; Constructs a new String by decoding the given bytes using the specified charset.
     ;
     ; This is a convenience method which wraps the checked exception with a RuntimeException.
     ; The exception can never occur given the charsets
     ; US-ASCII, ISO-8859-1, UTF-8, UTF-16, UTF-16LE or UTF-16BE.
     ;
     ; @param bytes The bytes to be decoded into characters.
     ; @param charsetName The name of a supported {@linkplain java.nio.charset.Charset charset}.
     ; @return the decoded String.
     ;;
    #_public
    #_static
    (§ method String toString(§ args byte[] bytes, String charsetName))
    (§ block
        (§ try )
        (§ block
            (§ return (§ new String(§ pars bytes, charsetName)))
        )
        (§ catch (§ args UnsupportedEncodingException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )

    ;;;
     ; Encodes the given string into a sequence of bytes using the named charset.
     ;
     ; This is a convenience method which wraps the checked exception with a RuntimeException.
     ; The exception can never occur given the charsets
     ; US-ASCII, ISO-8859-1, UTF-8, UTF-16, UTF-16LE or UTF-16BE.
     ;
     ; @param str The string to encode into bytes.
     ; @param charsetName The name of a supported {@linkplain java.nio.charset.Charset charset}.
     ; @return the encoded bytes.
     ;;
    #_public
    #_static
    (§ method byte[] toBytes(§ args CharSequence str, String charsetName))
    (§ block
        (§ try )
        (§ block
            (§ return str.toString(§ pars ).getBytes(§ pars charsetName))
        )
        (§ catch (§ args UnsupportedEncodingException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )

    ;;;
     ; Attempts to parse the given string as arbitrary-length hex or base58 and then return the results,
     ; or null if neither parse was successful.
     ;;
    #_public
    #_static
    (§ method byte[] parseAsHexOrBase58(§ args String data))
    (§ block
        (§ try )
        (§ block
            (§ return HEX.decode(§ pars data))
        )
        (§ catch (§ args Exception _))
        (§ block
            ;; Didn't decode as hex, try base58.
            (§ try )
            (§ block
                (§ return Base58.decodeChecked(§ pars data))
            )
            (§ catch (§ args AddressFormatException __))
            (§ block
                (§ return nil)
            )
        )
    )

    #_public
    #_static
    (§ method boolean isWindows(§ args ))
    (§ block
        (§ return System.getProperty(§ pars "os.name").toLowerCase(§ pars ).contains(§ pars "win"))
    )

    ;;;
     ; <p>Given a textual message, returns a byte buffer formatted as follows:</p>
     ;
     ; <p><tt>[24] "Bitcoin Signed Message:\n" [message.length as a varint] message</tt>.</p>
     ;;
    #_public
    #_static
    (§ method byte[] formatMessageForSigning(§ args String message))
    (§ block
        (§ try )
        (§ block
            (§ var ByteArrayOutputStream bos = new ByteArrayOutputStream(§ pars ))
            (§ call bos.write(§ pars BITCOIN_SIGNED_MESSAGE_HEADER_BYTES.length))
            (§ call bos.write(§ pars BITCOIN_SIGNED_MESSAGE_HEADER_BYTES))
            (§ var byte[] messageBytes = message.getBytes(§ pars Charsets.UTF_8))
            (§ var VarInt size = new VarInt(§ pars messageBytes.length))
            (§ call bos.write(§ pars size.encode(§ pars )))
            (§ call bos.write(§ pars messageBytes))
            (§ return bos.toByteArray(§ pars ))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
    )

    ;; 00000001, 00000010, 00000100, 00001000, ...
    #_private
    #_static
    #_final
    (§ field int[] bitMask = (§ coll 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 ))

    ;;; Checks if the given bit is set in data, using little endian (not the same as Java native big endian). ;;
    #_public
    #_static
    (§ method boolean checkBitLE(§ args byte[] data, int index))
    (§ block
        (§ return (§ expr (§ expr data[index >>> 3] & bitMask[7 & index]) != 0))
    )

    ;;; Sets the given bit in data to one, using little endian (not the same as Java native big endian). ;;
    #_public
    #_static
    (§ method void setBitLE(§ args byte[] data, int index))
    (§ block
        (§ ass data[index >>> 3] = data[index >>> 3] | bitMask[7 & index])
    )

    ;;; Sleep for a span of time, or mock sleep if enabled. ;;
    #_public
    #_static
    (§ method void sleep(§ args long millis))
    (§ block
        (§ if (§ expr mockSleepQueue == nil))
        (§ block
            (§ call sleepUninterruptibly(§ pars millis, TimeUnit.MILLISECONDS))
        )
        (§ else )
        (§ block
            (§ try )
            (§ block
                (§ var boolean isMultiPass = mockSleepQueue.take(§ pars ))
                (§ call rollMockClockMillis(§ pars millis))
                (§ if (§ expr isMultiPass))
                (§ block
                    (§ call mockSleepQueue.offer(§ pars true))
                )
            )
            (§ catch (§ args InterruptedException _))
            (§ block
                ;; Ignored.
            )
        )
    )

    ;;; Enable or disable mock sleep.  If enabled, set mock time to current time. ;;
    #_public
    #_static
    (§ method void setMockSleep(§ args boolean isEnable))
    (§ block
        (§ if (§ expr isEnable))
        (§ block
            (§ ass mockSleepQueue = new ArrayBlockingQueue<>(§ pars 1))
            (§ ass mockTime = new Date(§ pars System.currentTimeMillis(§ pars )))
        )
        (§ else )
        (§ block
            (§ ass mockSleepQueue = nil)
        )
    )

    ;;; Let sleeping thread pass the synchronization point. ;;
    #_public
    #_static
    (§ method void passMockSleep(§ args ))
    (§ block
        (§ call mockSleepQueue.offer(§ pars false))
    )

    ;;; Let the sleeping thread pass the synchronization point any number of times. ;;
    #_public
    #_static
    (§ method void finishMockSleep(§ args ))
    (§ block
        (§ if (§ expr mockSleepQueue != nil))
        (§ block
            (§ call mockSleepQueue.offer(§ pars true))
        )
    )

    #_private
    #_static
    (§ field int isAndroid = -1)
    #_public
    #_static
    (§ method boolean isAndroidRuntime(§ args ))
    (§ block
        (§ if (§ expr isAndroid == -1))
        (§ block
            #_final
            (§ var String runtime = System.getProperty(§ pars "java.runtime.name"))
            (§ ass isAndroid = (§ quest (§ expr runtime != nil && runtime.equals(§ pars "Android Runtime")) ? 1 :else 0))
        )
        (§ return (§ expr isAndroid == 1))
    )

    #_private
    #_static
    (§ class Pair implements Comparable<Pair>
        (§ var int item, count)

        #_public
        (§ constructor Pair(§ args int item, int count))
        (§ block
            (§ ass this.count = count)
            (§ ass this.item = item)
        )

        ;; Note that in this implementation compareTo() is not consistent with equals().
        #_override
        #_public
        (§ method int compareTo(§ args Pair o))
        (§ block
            (§ return -Ints.compare(§ pars count, o.count))
        )
    )

    #_public
    #_static
    (§ method int maxOfMostFreq(§ args int... items))
    (§ block
        ;; Java 6 sucks.
        (§ var ArrayList<Integer> list = new ArrayList<>(§ pars items.length))
        (§ for (§ var int item) :for (§ expr items))
        (§ block
            (§ call list.add(§ pars item))
        )
        (§ return maxOfMostFreq(§ pars list))
    )

    #_public
    #_static
    (§ method int maxOfMostFreq(§ args List<Integer> items))
    (§ block
        (§ if (§ expr items.isEmpty(§ pars )))
        (§ block
            (§ return 0)
        )

        ;; This would be much easier in a functional language (or in Java 8).
        (§ ass items = Ordering.natural(§ pars ).reverse(§ pars ).sortedCopy(§ pars items))
        (§ var LinkedList<Pair> pairs = Lists.newLinkedList(§ pars ))
        (§ call pairs.add(§ pars (§ new Pair(§ pars items.get(§ pars 0), 0))))
        (§ for (§ var int item) :for (§ expr items))
        (§ block
            (§ var Pair pair = pairs.getLast(§ pars ))
            (§ if (§ expr pair.item != item))
            (§ block
                (§ ass pairs.add(§ pars (§ ass pair = new Pair(§ pars item, 0))))
            )
            (§ ass pair.count = pair.count + 1)
        )
        ;; pairs now contains a uniqified list of the sorted inputs, with counts for how often that item appeared.
        ;; Now sort by how frequently they occur, and pick the max of the most frequent.
        (§ call Collections.sort(§ pars pairs))
        (§ var int maxCount = pairs.getFirst(§ pars ).count)
        (§ var int maxItem = pairs.getFirst(§ pars ).item)
        (§ for (§ var Pair pair) :for (§ expr pairs))
        (§ block
            (§ if (§ expr pair.count != maxCount))
            (§ block
                (§ break )
            )
            (§ ass maxItem = Math.max(§ pars maxItem, pair.item))
        )
        (§ return maxItem)
    )

    ;;;
     ; Reads and joins together with LF char (\n) all the lines from given file.
     ; It's assumed that file is in UTF-8.
     ;;
    #_public
    #_static
    (§ method String getResourceAsString(§ args URL url))
        (§ throws IOException)
    (§ block
        (§ var List<String> lines = Resources.readLines(§ pars url, Charsets.UTF_8))
        (§ return Joiner.on(§ pars "\n").join(§ pars lines))
    )

    ;; Can't use Closeable here because it's Java 7 only and Android devices only got that with KitKat.
    #_public
    #_static
    (§ method InputStream closeUnchecked(§ args InputStream stream))
    (§ block
        (§ try )
        (§ block
            (§ call stream.close(§ pars ))
            (§ return stream)
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )

    #_public
    #_static
    (§ method OutputStream closeUnchecked(§ args OutputStream stream))
    (§ block
        (§ try )
        (§ block
            (§ call stream.close(§ pars ))
            (§ return stream)
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )
)

#_(ns org.bitcoinj.core #_"VarInt")

;;;
 ; A variable-length encoded unsigned integer using Satoshi's encoding (a.k.a. "CompactSize").
 ;;
#_public
(§ class VarInt
    #_public
    #_final
    (§ field long value)
    #_private
    #_final
    (§ field int originallyEncodedSize)

    ;;;
     ; Constructs a new VarInt with the given unsigned long value.
     ;
     ; @param value the unsigned long value (beware widening conversion of negatives!)
     ;;
    #_public
    (§ constructor VarInt(§ args long value))
    (§ block
        (§ ass this.value = value)
        (§ ass originallyEncodedSize = getSizeInBytes(§ pars ))
    )

    ;;;
     ; Constructs a new VarInt with the value parsed from the specified offset of the given buffer.
     ;
     ; @param buf The buffer containing the value.
     ; @param offset The offset of the value.
     ;;
    #_public
    (§ constructor VarInt(§ args byte[] buf, int offset))
    (§ block
        (§ var int first = 0xff & buf[offset])
        (§ if (§ expr first < 253))
        (§ block
            (§ ass value = first)
            (§ ass originallyEncodedSize = 1) ;; 1 data byte (8 bits)
        )
        (§ elseif (§ expr first == 253))
        (§ block
            (§ ass value = (§ expr (§ expr 0xff & buf[offset + 1]) | (§ expr (§ expr 0xff & buf[offset + 2]) << 8)))
            (§ ass originallyEncodedSize = 3) ;; 1 marker + 2 data bytes (16 bits)
        )
        (§ elseif (§ expr first == 254))
        (§ block
            (§ ass value = Utils.readUint32(§ pars buf, offset + 1))
            (§ ass originallyEncodedSize = 5) ;; 1 marker + 4 data bytes (32 bits)
        )
        (§ else )
        (§ block
            (§ ass value = Utils.readInt64(§ pars buf, offset + 1))
            (§ ass originallyEncodedSize = 9) ;; 1 marker + 8 data bytes (64 bits)
        )
    )

    ;;;
     ; Returns the original number of bytes used to encode the value if it was
     ; deserialized from a byte array, or the minimum encoded size if it was not.
     ;;
    #_public
    (§ method int getOriginalSizeInBytes(§ args ))
    (§ block
        (§ return originallyEncodedSize)
    )

    ;;;
     ; Returns the minimum encoded size of the value.
     ;;
    #_public
    #_final
    (§ method int getSizeInBytes(§ args ))
    (§ block
        (§ return sizeOf(§ pars value))
    )

    ;;;
     ; Returns the minimum encoded size of the given unsigned long value.
     ;
     ; @param value the unsigned long value (beware widening conversion of negatives!)
     ;;
    #_public
    #_static
    (§ method int sizeOf(§ args long value))
    (§ block
        ;; if negative, it's actually a very large unsigned long value
        (§ if (§ expr value < 0))
        (§ block
            (§ return 9) ;; 1 marker + 8 data bytes
        )
        (§ if (§ expr value < 253))
        (§ block
            (§ return 1) ;; 1 data byte
        )
        (§ if (§ expr value <= 0xffff))
        (§ block
            (§ return 3) ;; 1 marker + 2 data bytes
        )
        (§ if (§ expr value <= 0xffffffff))
        (§ block
            (§ return 5) ;; 1 marker + 4 data bytes
        )
        (§ return 9) ;; 1 marker + 8 data bytes
    )

    ;;;
     ; Encodes the value into its minimal representation.
     ;
     ; @return the minimal encoded bytes of the value.
     ;;
    #_public
    (§ method byte[] encode(§ args ))
    (§ block
        (§ var byte[] bytes)
        (§ switch (§ expr sizeOf(§ pars value)))
        (§ block
            (§ case 1)
            (§ block
                (§ return new byte[] (§ coll (§ cast byte)value ))
            )
            (§ case 3)
            (§ block
                (§ return new byte[] (§ coll (§ cast byte)253, (§ cast byte)value, (§ cast byte)(§ expr value >> 8) ))
            )
            (§ case 5)
            (§ block
                (§ ass bytes = new byte[5])
                (§ ass bytes[0] = (§ cast byte)254)
                (§ call Utils.uint32ToByteArrayLE(§ pars value, bytes, 1))
                (§ return bytes)
            )
            (§ default )
            (§ block
                (§ ass bytes = new byte[9])
                (§ ass bytes[0] = (§ cast byte)255)
                (§ call Utils.uint64ToByteArrayLE(§ pars value, bytes, 1))
                (§ return bytes)
            )
        )
    )
)

#_(ns org.bitcoinj.core #_"VerificationException")

#_public
(§ class VerificationException extends RuntimeException
    #_public
    (§ constructor VerificationException(§ args String msg))
    (§ block
        (§ super (§ pars msg))
    )

    #_public
    (§ constructor VerificationException(§ args Exception e))
    (§ block
        (§ super (§ pars e))
    )

    #_public
    (§ constructor VerificationException(§ args String msg, Throwable t))
    (§ block
        (§ super (§ pars msg, t))
    )

    #_public
    #_static
    (§ class EmptyInputsOrOutputs extends VerificationException
        #_public
        (§ constructor EmptyInputsOrOutputs(§ args ))
        (§ block
            (§ super (§ pars "Transaction had no inputs or no outputs."))
        )
    )

    #_public
    #_static
    (§ class LargerThanMaxBlockSize extends VerificationException
        #_public
        (§ constructor LargerThanMaxBlockSize(§ args ))
        (§ block
            (§ super (§ pars "Transaction larger than MAX_BLOCK_SIZE"))
        )
    )

    #_public
    #_static
    (§ class DuplicatedOutPoint extends VerificationException
        #_public
        (§ constructor DuplicatedOutPoint(§ args ))
        (§ block
            (§ super (§ pars "Duplicated outpoint"))
        )
    )

    #_public
    #_static
    (§ class NegativeValueOutput extends VerificationException
        #_public
        (§ constructor NegativeValueOutput(§ args ))
        (§ block
            (§ super (§ pars "Transaction output negative"))
        )
    )

    #_public
    #_static
    (§ class ExcessiveValue extends VerificationException
        #_public
        (§ constructor ExcessiveValue(§ args ))
        (§ block
            (§ super (§ pars "Total transaction output value greater than possible"))
        )
    )

    #_public
    #_static
    (§ class CoinbaseScriptSizeOutOfRange extends VerificationException
        #_public
        (§ constructor CoinbaseScriptSizeOutOfRange(§ args ))
        (§ block
            (§ super (§ pars "Coinbase script size out of range"))
        )
    )

    #_public
    #_static
    (§ class BlockVersionOutOfDate extends VerificationException
        #_public
        (§ constructor BlockVersionOutOfDate(§ args #_final long version))
        (§ block
            (§ super (§ pars "Block version #" + version + " is outdated."))
        )
    )

    #_public
    #_static
    (§ class UnexpectedCoinbaseInput extends VerificationException
        #_public
        (§ constructor UnexpectedCoinbaseInput(§ args ))
        (§ block
            (§ super (§ pars "Coinbase input as input in non-coinbase transaction"))
        )
    )

    #_public
    #_static
    (§ class CoinbaseHeightMismatch extends VerificationException
        #_public
        (§ constructor CoinbaseHeightMismatch(§ args #_final String message))
        (§ block
            (§ super (§ pars message))
        )
    )
)

#_(ns org.bitcoinj.core #_"VersionAck")

;;;
 ; <p>The verack message, sent by a client accepting the version message they
 ; received from their peer.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class VersionAck extends EmptyMessage
    #_public
    (§ constructor VersionAck(§ args ))
    (§ block
    )

    ;; this is needed by the BitcoinSerializer
    #_public
    (§ constructor VersionAck(§ args NetworkParameters params, byte[] payload))
    (§ block
    )
)

#_(ns org.bitcoinj.core #_"VersionMessage"
    (:import [java.io IOException OutputStream]
             [java.math BigInteger]
             [java.net InetAddress UnknownHostException]
             [java.util Locale])
    (:import [com.google.common.base Objects]
             [com.google.common.net InetAddresses]))

;;;
 ; <p>A VersionMessage holds information exchanged during connection setup with another peer.  Most of the fields are
 ; not particularly interesting.  The subVer field, since BIP 14, acts as a User-Agent string would.  You can and should
 ; append to or change the subVer for your own software so other implementations can identify it, and you can look at
 ; the subVer field received from other nodes to see what they are running.</p>
 ;
 ; <p>After creating yourself a VersionMessage, you can pass it to {@link PeerGroup#setVersionMessage(VersionMessage)}
 ; to ensure it will be used for each new connection.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class VersionMessage extends Message
    ;;; The version of this library release, as a string. ;;
    #_public
    #_static
    #_final
    (§ field String BITCOINJ_VERSION = "0.15-SNAPSHOT")
    ;;; The value that is prepended to the subVer field of this application. ;;
    #_public
    #_static
    #_final
    (§ field String LIBRARY_SUBVER = "/bitcoinj:" + BITCOINJ_VERSION + "/")

    ;;; A services flag that denotes whether the peer has a copy of the block chain or not. ;;
    #_public
    #_static
    #_final
    (§ field int NODE_NETWORK = 1)

    ;;;
     ; The version number of the protocol spoken.
     ;;
    #_public
    (§ field int clientVersion)
    ;;;
     ; Flags defining what optional services are supported.
     ;;
    #_public
    (§ field long localServices)
    ;;;
     ; What the other side believes the current time to be, in seconds.
     ;;
    #_public
    (§ field long time)
    ;;;
     ; What the other side believes the address of this program is.  Not used.
     ;;
    #_public
    (§ field PeerAddress myAddr)
    ;;;
     ; What the other side believes their own address is.  Not used.
     ;;
    #_public
    (§ field PeerAddress theirAddr)
    ;;;
     ; User-Agent as defined in <a href="https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki">BIP 14</a>.
     ; Bitcoin Core sets it to something like "/Satoshi:0.9.1/".
     ;;
    #_public
    (§ field String subVer)
    ;;;
     ; How many blocks are in the chain, according to the other side.
     ;;
    #_public
    (§ field long bestHeight)
    ;;;
     ; Whether or not to relay tx invs before a filter is received.
     ; See <a href="https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki#extensions-to-existing-messages">BIP 37</a>.
     ;;
    #_public
    (§ field boolean relayTxesBeforeFilter)

    #_public
    (§ constructor VersionMessage(§ args NetworkParameters params, byte[] payload))
        (§ throws ProtocolException)
    (§ block
        (§ super (§ pars params, payload, 0))
    )

    ;; It doesn't really make sense to ever lazily parse a version message or to retain the backing bytes.
    ;; If you're receiving this on the wire you need to check the protocol version and it will never need
    ;; to be sent back down the wire.

    #_public
    (§ constructor VersionMessage(§ args NetworkParameters params, int newBestHeight))
    (§ block
        (§ super (§ pars params))

        (§ ass clientVersion = params.getProtocolVersionNum(§ pars NetworkParameters.ProtocolVersion.CURRENT))
        (§ ass localServices = 0)
        (§ ass time = System.currentTimeMillis(§ pars ) / 1000)
        ;; Note that the Bitcoin Core doesn't do anything with these, and finding out your own external IP address
        ;; is kind of tricky anyway, so we just put nonsense here for now.
        (§ var InetAddress localhost = InetAddresses.forString(§ pars "127.0.0.1"))
        (§ ass myAddr = new PeerAddress(§ pars params, localhost, params.getPort(§ pars ), 0, BigInteger.ZERO))
        (§ ass theirAddr = new PeerAddress(§ pars params, localhost, params.getPort(§ pars ), 0, BigInteger.ZERO))
        (§ ass subVer = LIBRARY_SUBVER)
        (§ ass bestHeight = newBestHeight)
        (§ ass relayTxesBeforeFilter = true)

        (§ ass length = 85)
        (§ if (§ expr 31402 < protocolVersion))
        (§ block
            (§ ass length = length + 8)
        )
        (§ ass length = length + VarInt.sizeOf(§ pars subVer.length(§ pars )) + subVer.length(§ pars ))
    )

    #_override
    #_protected
    (§ method void parse(§ args ))
        (§ throws ProtocolException)
    (§ block
        (§ ass clientVersion = (§ cast int)readUint32(§ pars ))
        (§ ass localServices = readUint64(§ pars ).longValue(§ pars ))
        (§ ass time = readUint64(§ pars ).longValue(§ pars ))
        (§ ass myAddr = new PeerAddress(§ pars params, payload, cursor, 0))
        (§ ass cursor = cursor + myAddr.getMessageSize(§ pars ))
        (§ ass theirAddr = new PeerAddress(§ pars params, payload, cursor, 0))
        (§ ass cursor = cursor + theirAddr.getMessageSize(§ pars ))
        ;; uint64 localHostNonce (random data)
        ;; We don't care about the localhost nonce.  It's used to detect connecting back to yourself in cases where
        ;; there are NATs and proxies in the way.  However we don't listen for inbound connections so it's irrelevant.
        (§ call readUint64(§ pars ))
        (§ try )
        (§ block
            ;; Initialize default values for flags which may not be sent by old nodes.
            (§ ass subVer = "")
            (§ ass bestHeight = 0)
            (§ ass relayTxesBeforeFilter = true)
            (§ if (§ expr !hasMoreBytes(§ pars )))
            (§ block
                (§ return )
            )

            ;; string subVer (currently "")
            (§ ass subVer = readStr(§ pars ))
            (§ if (§ expr !hasMoreBytes(§ pars )))
            (§ block
                (§ return )
            )

            ;; int bestHeight (size of known block chain)
            (§ ass bestHeight = readUint32(§ pars ))
            (§ if (§ expr !hasMoreBytes(§ pars )))
            (§ block
                (§ return )
            )

            (§ ass relayTxesBeforeFilter = (§ expr readBytes(§ pars 1)[0] != 0))
        )
        (§ finally )
        (§ block
            (§ ass length = cursor - offset)
        )
    )

    #_override
    #_public
    (§ method void bitcoinSerializeToStream(§ args OutputStream buf))
        (§ throws IOException)
    (§ block
        (§ call Utils.uint32ToByteStreamLE(§ pars clientVersion, buf))
        (§ call Utils.uint32ToByteStreamLE(§ pars localServices, buf))
        (§ call Utils.uint32ToByteStreamLE(§ pars localServices >> 32, buf))
        (§ call Utils.uint32ToByteStreamLE(§ pars time, buf))
        (§ call Utils.uint32ToByteStreamLE(§ pars time >> 32, buf))
        (§ try )
        (§ block
            ;; My address.
            (§ call myAddr.bitcoinSerialize(§ pars buf))
            ;; Their address.
            (§ call theirAddr.bitcoinSerialize(§ pars buf))
        )
        (§ catch (§ args UnknownHostException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Can't happen.
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Can't happen.
        )
        ;; Next up is the "local host nonce", this is to detect the case of connecting back to yourself.
        ;; We don't care about this as we won't be accepting inbound connections.
        (§ call Utils.uint32ToByteStreamLE(§ pars 0, buf))
        (§ call Utils.uint32ToByteStreamLE(§ pars 0, buf))
        ;; Now comes subVer.
        (§ var byte[] subVerBytes = subVer.getBytes(§ pars "UTF-8"))
        (§ call buf.write(§ pars (§ new VarInt(§ pars subVerBytes.length)).encode(§ pars )))
        (§ call buf.write(§ pars subVerBytes))
        ;; Size of known block chain.
        (§ call Utils.uint32ToByteStreamLE(§ pars bestHeight, buf))
        (§ call buf.write(§ pars relayTxesBeforeFilter ? 1 :else 0))
    )

    ;;;
     ; Returns true if the version message indicates the sender has a full copy of the block chain,
     ; or if it's running in client mode (only has the headers).
     ;;
    #_public
    (§ method boolean hasBlockChain(§ args ))
    (§ block
        (§ return (§ expr (§ expr localServices & NODE_NETWORK) == NODE_NETWORK))
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var VersionMessage other = (§ cast VersionMessage)o)
        (§ return (§ expr other.bestHeight == bestHeight && other.clientVersion == clientVersion && other.localServices == localServices && other.time == time && other.subVer.equals(§ pars subVer) && other.myAddr.equals(§ pars myAddr) && other.theirAddr.equals(§ pars theirAddr) && other.relayTxesBeforeFilter == relayTxesBeforeFilter))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars bestHeight, clientVersion, localServices, time, subVer, myAddr, theirAddr, relayTxesBeforeFilter))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ var StringBuilder sb = new StringBuilder(§ pars ))
        (§ call sb.append(§ pars "\n"))
        (§ call sb.append(§ pars "client version: ").append(§ pars clientVersion).append(§ pars "\n"))
        (§ call sb.append(§ pars "local services: ").append(§ pars localServices).append(§ pars "\n"))
        (§ call sb.append(§ pars "time:           ").append(§ pars time).append(§ pars "\n"))
        (§ call sb.append(§ pars "my addr:        ").append(§ pars myAddr).append(§ pars "\n"))
        (§ call sb.append(§ pars "their addr:     ").append(§ pars theirAddr).append(§ pars "\n"))
        (§ call sb.append(§ pars "sub version:    ").append(§ pars subVer).append(§ pars "\n"))
        (§ call sb.append(§ pars "best height:    ").append(§ pars bestHeight).append(§ pars "\n"))
        (§ call sb.append(§ pars "delay tx relay: ").append(§ pars !relayTxesBeforeFilter).append(§ pars "\n"))
        (§ return sb.toString(§ pars ))
    )

    #_public
    (§ method VersionMessage duplicate(§ args ))
    (§ block
        (§ var VersionMessage v = new VersionMessage(§ pars params, (§ cast int)bestHeight))
        (§ ass v.clientVersion = clientVersion)
        (§ ass v.localServices = localServices)
        (§ ass v.time = time)
        (§ ass v.myAddr = myAddr)
        (§ ass v.theirAddr = theirAddr)
        (§ ass v.subVer = subVer)
        (§ ass v.relayTxesBeforeFilter = relayTxesBeforeFilter)
        (§ return v)
    )

    ;;;
     ; Appends the given user-agent information to the subVer field.  The subVer is composed of a series of
     ; name:version pairs separated by slashes in the form of a path.  For example a typical subVer field for bitcoinj
     ; users might look like "/bitcoinj:0.13/MultiBit:1.2/" where libraries come further to the left.
     ;
     ; There can be as many components as you feel a need for, and the version string can be anything, but it is
     ; recommended to use A.B.C where A = major, B = minor and C = revision for software releases, and dates for
     ; auto-generated source repository snapshots.  A valid subVer begins and ends with a slash, therefore name
     ; and version are not allowed to contain such characters.
     ;
     ; Anything put in the "comments" field will appear in brackets and may be used for platform info, or anything
     ; else.  For example, calling <tt>appendToSubVer("MultiBit", "1.0", "Windows")</tt> will result in a subVer being
     ; set of "/bitcoinj:1.0/MultiBit:1.0(Windows)/".  Therefore the / ( and ) characters are reserved in all these
     ; components.  If you don't want to add a comment (recommended), pass null.
     ;
     ; See <a href="https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki">BIP 14</a> for more information.
     ;
     ; @param comments Optional (can be null) platform or other node specific information.
     ; @throws IllegalArgumentException if name, version or comments contains invalid characters.
     ;;
    #_public
    (§ method void appendToSubVer(§ args String name, String version, #_nilable String comments))
    (§ block
        (§ call checkSubVerComponent(§ pars name))
        (§ call checkSubVerComponent(§ pars version))

        (§ if (§ expr comments != nil))
        (§ block
            (§ call checkSubVerComponent(§ pars comments))
            (§ ass subVer = subVer.concat(§ pars String.format(§ pars Locale.US, "%s:%s(%s)/", name, version, comments)))
        )
        (§ else )
        (§ block
            (§ ass subVer = subVer.concat(§ pars String.format(§ pars Locale.US, "%s:%s/", name, version)))
        )
    )

    #_private
    #_static
    (§ method void checkSubVerComponent(§ args String component))
    (§ block
        (§ if (§ expr component.contains(§ pars "/") || component.contains(§ pars "(") || component.contains(§ pars ")")))
        (§ block
            (§ throw (§ new IllegalArgumentException(§ pars "name contains invalid characters")))
        )
    )

    ;;;
     ; Returns true if the clientVersion field is >= Pong.MIN_PROTOCOL_VERSION.  If it is then ping() is usable.
     ;;
    #_public
    (§ method boolean isPingPongSupported(§ args ))
    (§ block
        (§ return (§ expr params.getProtocolVersionNum(§ pars NetworkParameters.ProtocolVersion.PONG) <= clientVersion))
    )

    ;;;
     ; Returns true if the clientVersion field is >= FilteredBlock.MIN_PROTOCOL_VERSION.  If it is then Bloom filtering
     ; is available and the memory pool of the remote peer will be queried when the downloadData property is true.
     ;;
    #_public
    (§ method boolean isBloomFilteringSupported(§ args ))
    (§ block
        (§ return (§ expr params.getProtocolVersionNum(§ pars NetworkParameters.ProtocolVersion.BLOOM_FILTER) <= clientVersion))
    )
)

#_(ns org.bitcoinj.core #_"VersionedChecksummedBytes"
    (:import [java.io Serializable]
             [java.util Arrays])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.primitives Ints UnsignedBytes]))

;;;
 ; <p>In Bitcoin the following format is often used to represent some type of key:</p>
 ;
 ; <pre>[one version byte] [data bytes] [4 checksum bytes]</pre>
 ;
 ; <p>and the result is then Base58 encoded.
 ; This format is used for addresses, and private keys exported using the dumpprivkey command.</p>
 ;;
#_public
(§ class VersionedChecksummedBytes implements Serializable, Cloneable, Comparable<VersionedChecksummedBytes>
    #_protected
    #_final
    (§ field int version)
    #_protected
    (§ field byte[] bytes)

    #_protected
    (§ constructor VersionedChecksummedBytes(§ args String encoded))
        (§ throws AddressFormatException)
    (§ block
        (§ var byte[] versionAndDataBytes = Base58.decodeChecked(§ pars encoded))
        (§ var byte versionByte = versionAndDataBytes[0])
        (§ ass version = versionByte & 0xff)
        (§ ass bytes = new byte[versionAndDataBytes.length - 1])
        (§ call System.arraycopy(§ pars versionAndDataBytes, 1, bytes, 0, versionAndDataBytes.length - 1))
    )

    #_protected
    (§ constructor VersionedChecksummedBytes(§ args int version, byte[] bytes))
    (§ block
        (§ call Preconditions.checkArgument(§ pars 0 <= version && version < 256))

        (§ ass this.version = version)
        (§ ass this.bytes = bytes)
    )

    ;;;
     ; Returns the base-58 encoded String representation of this object,
     ; including version and checksum bytes.
     ;;
    #_public
    #_final
    (§ method String toBase58(§ args ))
    (§ block
        ;; A stringified buffer is: 1 byte version + data bytes + 4 bytes check code (a truncated hash).
        (§ var byte[] addressBytes = new byte[1 + bytes.length + 4])
        (§ ass addressBytes[0] = (§ cast byte)version)
        (§ call System.arraycopy(§ pars bytes, 0, addressBytes, 1, bytes.length))
        (§ var byte[] checksum = Sha256Hash.hashTwice(§ pars addressBytes, 0, bytes.length + 1))
        (§ call System.arraycopy(§ pars checksum, 0, addressBytes, bytes.length + 1, 4))
        (§ return Base58.encode(§ pars addressBytes))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return toBase58(§ pars ))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars version, Arrays.hashCode(§ pars bytes)))
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var VersionedChecksummedBytes other = (§ cast VersionedChecksummedBytes)o)
        (§ return (§ expr this.version == other.version && Arrays.equals(§ pars this.bytes, other.bytes)))
    )

    ;;;
     ; {@inheritDoc}
     ;
     ; This implementation narrows the return type to <code>VersionedChecksummedBytes</code>
     ; and allows subclasses to throw <code>CloneNotSupportedException</code> even though it
     ; is never thrown by this implementation.
     ;;
    #_override
    #_public
    (§ method VersionedChecksummedBytes clone(§ args ))
        (§ throws CloneNotSupportedException)
    (§ block
        (§ return (§ cast VersionedChecksummedBytes)super.clone(§ pars ))
    )

    ;;;
     ; {@inheritDoc}
     ;
     ; This implementation uses an optimized Google Guava method to compare <code>bytes</code>.
     ;;
    #_override
    #_public
    (§ method int compareTo(§ args VersionedChecksummedBytes o))
    (§ block
        (§ var int result = Ints.compare(§ pars this.version, o.version))
        (§ return (§ quest (§ expr result != 0) ? result :else UnsignedBytes.lexicographicalComparator(§ pars ).compare(§ pars this.bytes, o.bytes)))
    )

    ;;;
     ; Returns the "version" or "header" byte: the first byte of the data.  This is used to disambiguate what
     ; the contents apply to, for example, which network the key or address is valid on.
     ;
     ; @return a positive number between 0 and 255.
     ;;
    #_public
    (§ method int getVersion(§ args ))
    (§ block
        (§ return version)
    )
)

#_(ns org.bitcoinj.core #_"WrongNetworkException"
    (:import [java.util Arrays]))

;;;
 ; This exception is thrown by the Address class when you try and decode an address with a version code that isn't
 ; used by that network.  You shouldn't allow the user to proceed in this case as they are trying to send money across
 ; different chains, an operation that is guaranteed to destroy the money.
 ;;
#_public
(§ class WrongNetworkException extends AddressFormatException
    ;;; The version code that was provided in the address. ;;
    #_public
    (§ field int verCode)
    ;;; The list of acceptable versions that were expected given the addresses network parameters. ;;
    #_public
    (§ field int[] acceptableVersions)

    #_public
    (§ constructor WrongNetworkException(§ args int verCode, int[] acceptableVersions))
    (§ block
        (§ super (§ pars "Version code of address did not match acceptable versions for network: " + verCode + " not in " + Arrays.toString(§ pars acceptableVersions)))

        (§ ass this.verCode = verCode)
        (§ ass this.acceptableVersions = acceptableVersions)
    )
)

#_(ns org.bitcoinj.core.listeners #_"AbstractPeerDataEventListener"
    (:import [java.util *])
   (:require [org.bitcoinj.core *]))

;;;
 ; Deprecated: implement the more specific event listener interfaces instead to fill out only what you need.
 ;;
#_deprecated
#_public
#_abstract
(§ class AbstractPeerDataEventListener implements PeerDataEventListener
    #_override
    #_public
    (§ method void onBlocksDownloaded(§ args Peer peer, Block block, #_nilable FilteredBlock filteredBlock, int blocksLeft))
    (§ block
    )

    #_override
    #_public
    (§ method void onChainDownloadStarted(§ args Peer peer, int blocksLeft))
    (§ block
    )

    #_override
    #_public
    (§ method Message onPreMessageReceived(§ args Peer peer, Message m))
    (§ block
        ;; Just pass the message right through for further processing.
        (§ return m)
    )

    #_override
    #_public
    (§ method List<Message> getData(§ args Peer peer, GetDataMessage m))
    (§ block
        (§ return nil)
    )
)

#_(ns org.bitcoinj.core.listeners #_"BlockChainListener")

;;;
 ; Old interface for backwards compatibility. Implement the more specific interfaces instead.
 ;;
#_deprecated
#_public
(§ interface BlockChainListener extends NewBestBlockListener, TransactionReceivedInBlockListener, ReorganizeListener)

#_(ns org.bitcoinj.core.listeners #_"BlocksDownloadedEventListener"
   (:require [org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(§ interface BlocksDownloadedEventListener
    ;; TODO: Fix the Block/FilteredBlock type hierarchy so we can avoid the stupid typeless API here.
    ;;;
     ; <p>Called on a Peer thread when a block is received.</p>
     ;
     ; <p>The block may be a Block object that contains transactions, a Block object that is only a header when
     ; fast catchup is being used.  If set, filteredBlock can be used to retrieve the list of associated transactions.</p>
     ;
     ; @param peer The peer receiving the block.
     ; @param block The downloaded block.
     ; @param filteredBlock If non-null, the object that wraps the block header passed as the block param.
     ; @param blocksLeft The number of blocks left to download.
     ;;
    (§ method void onBlocksDownloaded(§ args Peer peer, Block block, #_nilable FilteredBlock filteredBlock, int blocksLeft))
)

#_(ns org.bitcoinj.core.listeners #_"ChainDownloadStartedEventListener"
   (:require [org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(§ interface ChainDownloadStartedEventListener
    ;;;
     ; Called when a download is started with the initial number of blocks to be downloaded.
     ;
     ; @param peer The peer receiving the block.
     ; @param blocksLeft The number of blocks left to download.
     ;;
    (§ method void onChainDownloadStarted(§ args Peer peer, int blocksLeft))
)

#_(ns org.bitcoinj.core.listeners #_"DownloadProgressTracker"
    (:import [java.util Date Locale]
             [java.util.concurrent ExecutionException])
    (:import [com.google.common.util.concurrent ListenableFuture SettableFuture]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core Block FilteredBlock Peer Utils]))

;;;
 ; <p>An implementation of {@link AbstractPeerDataEventListener} that listens to chain download events and tracks
 ; progress as a percentage.  The default implementation prints progress to stdout, but you can subclass it and
 ; override the progress method to update a GUI instead.</p>
 ;;
#_public
(§ class DownloadProgressTracker extends AbstractPeerDataEventListener
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars DownloadProgressTracker.class))

    #_private
    (§ field int originalBlocksLeft = -1)
    #_private
    (§ field int lastPercent = 0)
    #_private
    (§ field SettableFuture<Long> future = SettableFuture.create(§ pars ))
    #_private
    (§ field boolean caughtUp = false)

    #_override
    #_public
    (§ method void onChainDownloadStarted(§ args Peer peer, int blocksLeft))
    (§ block
        (§ if (§ expr 0 < blocksLeft && originalBlocksLeft == -1))
        (§ block
            (§ call startDownload(§ pars blocksLeft))
        )
        ;; Only mark this the first time, because this method can be called more than once during a chain download
        ;; if we switch peers during it.
        (§ if (§ expr originalBlocksLeft == -1))
        (§ block
            (§ ass originalBlocksLeft = blocksLeft)
        )
        (§ else )
        (§ block
            (§ call log.info(§ pars "Chain download switched to {}", peer))
        )
        (§ if (§ expr blocksLeft == 0))
        (§ block
            (§ call doneDownload(§ pars ))
            (§ call future.set(§ pars peer.getBestHeight(§ pars )))
        )
    )

    #_override
    #_public
    (§ method void onBlocksDownloaded(§ args Peer peer, Block block, #_nilable FilteredBlock filteredBlock, int blocksLeft))
    (§ block
        (§ if (§ expr caughtUp))
        (§ block
            (§ return )
        )

        (§ if (§ expr blocksLeft == 0))
        (§ block
            (§ ass caughtUp = true)
            (§ call doneDownload(§ pars ))
            (§ call future.set(§ pars peer.getBestHeight(§ pars )))
        )

        (§ if (§ expr blocksLeft < 0 || originalBlocksLeft <= 0))
        (§ block
            (§ return )
        )

        (§ var double pct = 100.0 - (§ expr 100.0 * (§ expr blocksLeft / (§ cast double)originalBlocksLeft)))
        (§ if (§ expr (§ cast int)pct != lastPercent))
        (§ block
            (§ call progress(§ pars pct, blocksLeft, new Date(§ pars block.getTimeSeconds(§ pars ) * 1000)))
            (§ ass lastPercent = (§ cast int)pct)
        )
    )

    ;;;
     ; Called when download progress is made.
     ;
     ; @param pct The percentage of chain downloaded, estimated.
     ; @param date The date of the last block downloaded.
     ;;
    #_protected
    (§ method void progress(§ args double pct, int blocksSoFar, Date date))
    (§ block
        (§ call log.info(§ pars String.format(§ pars Locale.US, "Chain download %d%% done with %d blocks to go, block date %s", (§ cast int)pct, blocksSoFar, Utils.dateTimeFormat(§ pars date))))
    )

    ;;;
     ; Called when download is initiated.
     ;
     ; @param blocks The number of blocks to download, estimated.
     ;;
    #_protected
    (§ method void startDownload(§ args int blocks))
    (§ block
        (§ call log.info(§ pars "Downloading block chain of size " + blocks + ". " + (§ expr 1000 < blocks ? "This may take a while." :else "")))
    )

    ;;;
     ; Called when we are done downloading the block chain.
     ;;
    #_protected
    (§ method void doneDownload(§ args ))
    (§ block
    )

    ;;;
     ; Wait for the chain to be downloaded.
     ;;
    #_public
    (§ method void await(§ args ))
        (§ throws InterruptedException)
    (§ block
        (§ try )
        (§ block
            (§ call future.get(§ pars ))
        )
        (§ catch (§ args ExecutionException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )

    ;;;
     ; Returns a listenable future that completes with the height of the best chain (as reported by the peer) once chain
     ; download seems to be finished.
     ;;
    #_public
    (§ method ListenableFuture<Long> getFuture(§ args ))
    (§ block
        (§ return future)
    )
)

#_(ns org.bitcoinj.core.listeners #_"GetDataEventListener"
    (:import [java.util *])
   (:require [org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(§ interface GetDataEventListener
    ;;;
     ; <p>Called when a peer receives a getdata message, usually in response to an "inv" being broadcast.  Return as many
     ; items as possible which appear in the {@link GetDataMessage}, or null if you're not interested in responding.</p>
     ;
     ; <p>Note that this will never be called if registered with any executor other than
     ; {@link org.bitcoinj.utils.Threading#SAME_THREAD}</p>
     ;;
    #_nilable
    (§ method List<Message> getData(§ args Peer peer, GetDataMessage m))
)

#_(ns org.bitcoinj.core.listeners #_"NewBestBlockListener"
   (:require [org.bitcoinj.core StoredBlock VerificationException]))

;;;
 ; Listener interface for when a new block on the best chain is seen.
 ;;
#_public
(§ interface NewBestBlockListener
    ;;;
     ; Called when a new block on the best chain is seen, after relevant transactions are extracted and sent to us via either
     ; {@link TransactionReceivedInBlockListener#receiveFromBlock(org.bitcoinj.core.Transaction, org.bitcoinj.core.StoredBlock, org.bitcoinj.core.BlockChain.NewBlockType, int relativityOffset)}
     ; or {@link TransactionReceivedInBlockListener#notifyTransactionIsInBlock(org.bitcoinj.core.Sha256Hash, org.bitcoinj.core.StoredBlock, org.bitcoinj.core.BlockChain.NewBlockType, int)}.
     ;
     ; If this block is causing a re-organise to a new chain, this method is NOT
     ; called even though the block may be the new best block: your reorganize
     ; implementation is expected to do whatever would normally be done do for a
     ; new best block in this case.
     ;;
    (§ method void notifyNewBestBlock(§ args #_final StoredBlock block))
        (§ throws VerificationException)
)

#_(ns org.bitcoinj.core.listeners #_"OnTransactionBroadcastListener"
   (:require [org.bitcoinj.core *]))

;;;
 ; Called when a new transaction is broadcast over the network.
 ;;
#_public
(§ interface OnTransactionBroadcastListener
    ;;;
     ; Called when a new transaction is broadcast over the network.
     ;;
    (§ method void onTransaction(§ args Peer peer, Transaction t))
)

#_(ns org.bitcoinj.core.listeners #_"PeerConnectedEventListener"
   (:require [org.bitcoinj.core Peer]))

;;;
 ; <p>Implementors can listen to events indicating a new peer connecting.</p>
 ;;
#_public
(§ interface PeerConnectedEventListener
    ;;;
     ; Called when a peer is connected.  If this listener is registered to a {@link Peer} instead of a {@link PeerGroup},
     ; peerCount will always be 1.
     ;
     ; @param peer
     ; @param peerCount The total number of connected peers.
     ;;
    (§ method void onPeerConnected(§ args Peer peer, int peerCount))
)

#_(ns org.bitcoinj.core.listeners #_"PeerDataEventListener"
   (:require [org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are processed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(§ interface PeerDataEventListener extends BlocksDownloadedEventListener, ChainDownloadStartedEventListener, GetDataEventListener, PreMessageReceivedEventListener)

#_(ns org.bitcoinj.core.listeners #_"PeerDisconnectedEventListener"
   (:require [org.bitcoinj.core Peer]))

;;;
 ; <p>Implementors can listen to events indicating a peer disconnecting.</p>
 ;;
#_public
(§ interface PeerDisconnectedEventListener
    ;;;
     ; Called when a peer is disconnected.  Note that this won't be called if the listener is registered on
     ; a {@link PeerGroup} and the group is in the process of shutting down.  If this listener is registered to
     ; a {@link Peer} instead of a {@link PeerGroup}, peerCount will always be 0.  This handler can be called
     ; without a corresponding invocation of onPeerConnected if the initial connection is never successful.
     ;
     ; @param peer
     ; @param peerCount The total number of connected peers.
     ;;
    (§ method void onPeerDisconnected(§ args Peer peer, int peerCount))
)

#_(ns org.bitcoinj.core.listeners #_"PeerDiscoveredEventListener"
    (:import [java.util Set])
   (:require [org.bitcoinj.core Peer PeerAddress]))

;;;
 ; <p>Implementors can listen to events for peers being discovered.</p>
 ;;
#_public
(§ interface PeerDiscoveredEventListener
    ;;;
     ; <p>Called when peers are discovered, this happens at startup of {@link PeerGroup}
     ; or if we run out of suitable {@link Peer}s to connect to.</p>
     ;
     ; @param peerAddresses The set of discovered {@link PeerAddress}es.
     ;;
    (§ method void onPeersDiscovered(§ args Set<PeerAddress> peerAddresses))
)

#_(ns org.bitcoinj.core.listeners #_"PreMessageReceivedEventListener"
   (:require [org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(§ interface PreMessageReceivedEventListener
    ;;;
     ; <p>Called when a message is received by a peer, before the message is processed.  The returned message is
     ; processed instead.  Returning null will cause the message to be ignored by the Peer returning the same message
     ; object allows you to see the messages received but not change them.  The result from one event listeners
     ; callback is passed as "m" to the next, forming a chain.</p>
     ;
     ; <p>Note that this will never be called if registered with any executor other than
     ; {@link org.bitcoinj.utils.Threading#SAME_THREAD}.</p>
     ;;
    (§ method Message onPreMessageReceived(§ args Peer peer, Message m))
)

#_(ns org.bitcoinj.core.listeners #_"ReorganizeListener"
    (:import [java.util List])
   (:require [org.bitcoinj.core StoredBlock VerificationException]))

;;;
 ; Listener interface for when the best chain has changed.
 ;;
#_public
(§ interface ReorganizeListener
    ;;;
     ; Called by the {@link org.bitcoinj.core.BlockChain} when the best chain (representing total work done)
     ; has changed.  In this case, we need to go through our transactions and find out if any have become invalid.
     ; It's possible for our balance to go down in this case: money we thought we had can suddenly vanish
     ; if the rest of the network agrees it should be so.
     ;
     ; The oldBlocks/newBlocks lists are ordered height-wise from top first to bottom last (i.e. newest blocks first).
     ;;
    (§ method void reorganize(§ args StoredBlock splitPoint, List<StoredBlock> oldBlocks, List<StoredBlock> newBlocks))
        (§ throws VerificationException)
)

#_(ns org.bitcoinj.core.listeners #_"TransactionConfidenceEventListener"
   (:require [org.bitcoinj.core Transaction]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when confidence of a transaction changes.</p>
 ;;
#_public
(§ interface TransactionConfidenceEventListener
    ;;;
     ; <p>Called when a transaction changes its confidence level.  You can also attach event listeners to
     ; the individual transactions, if you don't care about all of them.  Usually you would save the wallet to disk
     ; after receiving this callback unless you already set up autosaving.</p>
     ;
     ; <p>You should pay attention to this callback in case a transaction becomes <i>dead</i>, that is, a transaction
     ; you believed to be active (send or receive) becomes overridden by the network.  This can happen if</p>
     ;
     ; <ol>
     ;     <li>You are sharing keys between wallets and accidentally create/broadcast a double spend.</li>
     ;     <li>Somebody is attacking the network and reversing transactions, i.e. the user is a victim of fraud.</li>
     ;     <li>A bug: for example you create a transaction, broadcast it but fail to commit it.
     ;     The {@link Wallet} will then re-use the same outputs when creating the next spend.</li>
     ; </ol>
     ;
     ; <p>To find if the transaction is dead, you can use <tt>tx.getConfidence().getConfidenceType() ==
     ; TransactionConfidence.ConfidenceType.DEAD</tt>.  If it is, you should notify the user in some way
     ; so they know the thing they bought may not arrive/the thing they sold should not be dispatched.</p>
     ;
     ; <p>Note that this callback will be invoked for every transaction in the wallet, for every new block that is
     ; received (because the depth has changed).  <b>If you want to update a UI view from the contents of the wallet
     ; it is more efficient to use onWalletChanged instead.</b></p>
     ;;
    (§ method void onTransactionConfidenceChanged(§ args Wallet wallet, Transaction tx))
)

#_(ns org.bitcoinj.core.listeners #_"TransactionReceivedInBlockListener"
   (:require [org.bitcoinj.core BlockChain Sha256Hash StoredBlock Transaction VerificationException]))

;;;
 ; Listener interface for when we receive a new block that contains a relevant transaction.
 ;;
#_public
(§ interface TransactionReceivedInBlockListener
    ;;;
     ; <p>Called by the {@link BlockChain} when we receive a new block that contains a relevant transaction.</p>
     ;
     ; <p>A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.</p>
     ;
     ; <p>The relativityOffset parameter is an arbitrary number used to establish an ordering between transactions
     ; within the same block.  In the case where full blocks are being downloaded, it is simply the index of the
     ; transaction within that block.  When Bloom filtering is in use, we don't find out the exact offset into a block
     ; that a transaction occurred at, so the relativity count is not reflective of anything in an absolute sense but
     ; rather exists only to order the transaction relative to the others.</p>
     ;;
    (§ method void receiveFromBlock(§ args Transaction tx, StoredBlock block, BlockChain.NewBlockType blockType, int relativityOffset))
        (§ throws VerificationException)

    ;;;
     ; <p>Called by the {@link BlockChain} when we receive a new {@link FilteredBlock} that contains the given
     ; transaction hash in its merkle tree.</p>
     ;
     ; <p>A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.</p>
     ;
     ; <p>The relativityOffset parameter in this case is an arbitrary (meaningless) number, that is useful only when
     ; compared to the relativity count of another transaction received inside the same block.  It is used to establish
     ; an ordering of transactions relative to one another.</p>
     ;
     ; <p>This method should return false if the given tx hash isn't known about, e.g. because the the transaction was
     ; a Bloom false positive.  If it was known about and stored, it should return true.  The caller may need to know
     ; this to calculate the effective FP rate.</p>
     ;
     ; @return whether the transaction is known about i.e. was considered relevant previously.
     ;;
    (§ method boolean notifyTransactionIsInBlock(§ args Sha256Hash txHash, StoredBlock block, BlockChain.NewBlockType blockType, int relativityOffset))
        (§ throws VerificationException)
)

#_(ns org.bitcoinj.crypto #_"ChildNumber"
    (:import [java.util Locale])
    (:import [com.google.common.primitives Ints]))

;;;
 ; <p>This is just a wrapper for the i (child number) as per BIP 32 with a boolean getter for the most significant bit
 ; and a getter for the actual 0-based child number.  A {@link java.util.List} of these forms a <i>path</i> through a
 ; {@link DeterministicHierarchy}.  This class is immutable.
 ;;
#_public
(§ class ChildNumber implements Comparable<ChildNumber>
    ;;;
     ; The bit that's set in the child number to indicate whether this key is "hardened".  Given a hardened key, it is
     ; not possible to derive a child public key if you know only the hardened public key.  With a non-hardened key this
     ; is possible, so you can derive trees of public keys given only a public parent, but the downside is that it's
     ; possible to leak private keys if you disclose a parent public key and a child private key (elliptic curve maths
     ; allows you to work upwards).
     ;;
    #_public
    #_static
    #_final
    (§ field int HARDENED_BIT = 0x80000000)

    #_public
    #_static
    #_final
    (§ field ChildNumber ZERO = new ChildNumber(§ pars 0))
    #_public
    #_static
    #_final
    (§ field ChildNumber ONE = new ChildNumber(§ pars 1))
    #_public
    #_static
    #_final
    (§ field ChildNumber ZERO_HARDENED = new ChildNumber(§ pars 0, true))

    ;;; Integer i as per BIP 32 spec, including the MSB denoting derivation type (0 = public, 1 = private). ;;
    #_private
    #_final
    (§ field int i)

    #_public
    (§ constructor ChildNumber(§ args int childNumber, boolean isHardened))
    (§ block
        (§ if (§ expr hasHardenedBit(§ pars childNumber)))
        (§ block
            (§ throw (§ new IllegalArgumentException(§ pars "Most significant bit is reserved and shouldn't be set: " + childNumber)))
        )

        (§ ass i = isHardened ? (§ expr childNumber | HARDENED_BIT) :else childNumber)
    )

    #_public
    (§ constructor ChildNumber(§ args int i))
    (§ block
        (§ ass this.i = i)
    )

    ;;; Returns the uint32 encoded form of the path element, including the most significant bit. ;;
    #_public
    (§ method int getI(§ args ))
    (§ block
        (§ return i)
    )

    ;;; Returns the uint32 encoded form of the path element, including the most significant bit. ;;
    #_public
    (§ method int i(§ args ))
    (§ block
        (§ return i)
    )

    #_public
    (§ method boolean isHardened(§ args ))
    (§ block
        (§ return hasHardenedBit(§ pars i))
    )

    #_private
    #_static
    (§ method boolean hasHardenedBit(§ args int a))
    (§ block
        (§ return (§ expr (§ expr a & HARDENED_BIT) != 0))
    )

    ;;; Returns the child number without the hardening bit set (i.e. index in that part of the tree). ;;
    #_public
    (§ method int num(§ args ))
    (§ block
        (§ return (§ expr i & ~HARDENED_BIT))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return String.format(§ pars Locale.US, "%d%s", num(§ pars ), isHardened(§ pars ) ? "H" :else ""))
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return (§ expr i == (§ expr (§ cast ChildNumber)o).i))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return i)
    )

    #_override
    #_public
    (§ method int compareTo(§ args ChildNumber other))
    (§ block
        ;; Note that in this implementation compareTo() is not consistent with equals().
        (§ return Ints.compare(§ pars this.num(§ pars ), other.num(§ pars )))
    )
)

#_(ns org.bitcoinj.crypto #_"DeterministicHierarchy"
    (:import [java.util List Locale Map])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect ImmutableList Maps]))

;; TODO: This whole API feels a bit object heavy.  Do we really need ChildNumber and so many maps, etc?
;; TODO: Should we be representing this using an actual tree arrangement in memory instead of a bunch of hashmaps?

;;;
 ; <p>A DeterministicHierarchy calculates and keeps a whole tree (hierarchy) of keys originating from a single
 ; root key.  This implements part of the BIP 32 specification.  A deterministic key tree is useful because
 ; Bitcoin's privacy system require new keys to be created for each transaction, but managing all these
 ; keys quickly becomes unwieldy.  In particular it becomes hard to back up and distribute them.  By having
 ; a way to derive random-looking but deterministic keys we can make wallet backup simpler and gain the
 ; ability to hand out {@link DeterministicKey}s to other people who can then create new addresses
 ; on the fly, without having to contact us.</p>
 ;
 ; <p>The hierarchy is started from a single root key, and a location in the tree is given by a path which
 ; is a list of {@link ChildNumber}s.</p>
 ;;
#_public
(§ class DeterministicHierarchy
    #_private
    #_final
    (§ field Map<ImmutableList<ChildNumber>, DeterministicKey> keys = Maps.newHashMap(§ pars ))
    #_private
    #_final
    (§ field ImmutableList<ChildNumber> rootPath)
    ;; Keep track of how many child keys each node has.  This is kind of weak.
    #_private
    #_final
    (§ field Map<ImmutableList<ChildNumber>, ChildNumber> lastChildNumbers = Maps.newHashMap(§ pars ))

    #_public
    #_static
    #_final
    (§ field int BIP32_STANDARDISATION_TIME_SECS = 1369267200)

    ;;;
     ; Constructs a new hierarchy rooted at the given key.  Note that this does not have to be the top of the tree.
     ; You can construct a DeterministicHierarchy for a subtree of a larger tree that you may not own.
     ;;
    #_public
    (§ constructor DeterministicHierarchy(§ args DeterministicKey rootKey))
    (§ block
        (§ call putKey(§ pars rootKey))
        (§ ass rootPath = rootKey.getPath(§ pars ))
    )

    ;;;
     ; Inserts a key into the heirarchy.  Used during deserialization: you normally don't need this.  Keys must be
     ; inserted in order.
     ;;
    #_public
    #_final
    (§ method void putKey(§ args DeterministicKey key))
    (§ block
        (§ var ImmutableList<ChildNumber> path = key.getPath(§ pars ))
        ;; Update our tracking of what the next child in each branch of the tree should be.  Just assume that keys
        ;; are inserted in order here.
        #_final
        (§ var DeterministicKey parent = key.getParent(§ pars ))
        (§ if (§ expr parent != nil))
        (§ block
            (§ call lastChildNumbers.put(§ pars parent.getPath(§ pars ), key.getChildNumber(§ pars )))
        )
        (§ call keys.put(§ pars path, key))
    )

    ;;;
     ; Returns a key for the given path, optionally creating it.
     ;
     ; @param path The path to the key.
     ; @param relativePath Whether the path is relative to the root path.
     ; @param create Whether the key corresponding to path should be created (with any necessary ancestors) if it doesn't exist already.
     ; @return next newly created key using the child derivation function.
     ; @throws IllegalArgumentException if create is false and the path was not found.
     ;;
    #_public
    (§ method DeterministicKey get(§ args List<ChildNumber> path, boolean relativePath, boolean create))
    (§ block
        (§ var ImmutableList<ChildNumber> absolutePath = relativePath ? ImmutableList.<ChildNumber>builder(§ pars ).addAll(§ pars rootPath).addAll(§ pars path).build(§ pars ) :else ImmutableList.copyOf(§ pars path))
        (§ if (§ expr !keys.containsKey(§ pars absolutePath)))
        (§ block
            (§ if (§ expr !create))
            (§ block
                (§ throw (§ new IllegalArgumentException(§ pars String.format(§ pars Locale.US, "No key found for %s path %s.", relativePath ? "relative") :for (§ expr "absolute", HDUtils.formatPath(§ pars path)))))
            )
            (§ call Preconditions.checkArgument(§ pars 0 < absolutePath.size(§ pars ), "Can't derive the master key: nothing to derive from."))
            (§ var DeterministicKey parent = get(§ pars absolutePath.subList(§ pars 0, absolutePath.size(§ pars ) - 1), false, true))
            (§ call putKey(§ pars HDKeyDerivation.deriveChildKey(§ pars parent, absolutePath.get(§ pars absolutePath.size(§ pars ) - 1))))
        )
        (§ return keys.get(§ pars absolutePath))
    )

    ;;;
     ; Extends the tree by calculating the next key that hangs off the given parent path.  For example, if you pass
     ; a path of 1/2 here and there are already keys 1/2/1 and 1/2/2 then it will derive 1/2/3.
     ;
     ; @param parentPath The path to the parent.
     ; @param relative Whether the path is relative to the root path.
     ; @param createParent Whether the parent corresponding to path should be created (with any necessary ancestors) if it doesn't exist already.
     ; @param privateDerivation Whether to use private or public derivation.
     ; @return next newly created key using the child derivation funtcion.
     ; @throws IllegalArgumentException if the parent doesn't exist and createParent is false.
     ;;
    #_public
    (§ method DeterministicKey deriveNextChild(§ args ImmutableList<ChildNumber> parentPath, boolean relative, boolean createParent, boolean privateDerivation))
    (§ block
        (§ var DeterministicKey parent = get(§ pars parentPath, relative, createParent))
        (§ for (§ var int i = 0) :for (§ expr i < HDKeyDerivation.MAX_CHILD_DERIVATION_ATTEMPTS) :for (§ ass i = i + 1))
        (§ block
            (§ try )
            (§ block
                (§ var ChildNumber createChildNumber = getNextChildNumberToDerive(§ pars parent.getPath(§ pars ), privateDerivation))
                (§ return deriveChild(§ pars parent, createChildNumber))
            )
            (§ catch (§ args HDDerivationException _))
            (§ block
            )
        )
        (§ throw (§ new HDDerivationException(§ pars "Maximum number of child derivation attempts reached, this is probably an indication of a bug.")))
    )

    #_private
    (§ method ChildNumber getNextChildNumberToDerive(§ args ImmutableList<ChildNumber> path, boolean privateDerivation))
    (§ block
        (§ var ChildNumber lastChildNumber = lastChildNumbers.get(§ pars path))
        (§ var ChildNumber nextChildNumber = new ChildNumber(§ pars lastChildNumber != nil ? lastChildNumber.num(§ pars ) + 1 :else 0, privateDerivation))
        (§ call lastChildNumbers.put(§ pars path, nextChildNumber))
        (§ return nextChildNumber)
    )

    #_public
    (§ method int getNumChildren(§ args ImmutableList<ChildNumber> path))
    (§ block
        #_final
        (§ var ChildNumber cn = lastChildNumbers.get(§ pars path))
        ;; Children start with zero based childnumbers.
        (§ return (§ quest (§ expr cn == nil) ? 0 :else 1 + cn.num(§ pars )))
    )

    ;;;
     ; Extends the tree by calculating the requested child for the given path.  For example, to get the key at position
     ; 1/2/3 you would pass 1/2 as the parent path and 3 as the child number.
     ;
     ; @param parentPath The path to the parent.
     ; @param relative Whether the path is relative to the root path.
     ; @param createParent Whether the parent corresponding to path should be created (with any necessary ancestors) if it doesn't exist already.
     ; @return the requested key.
     ; @throws IllegalArgumentException if the parent doesn't exist and createParent is false.
     ;;
    #_public
    (§ method DeterministicKey deriveChild(§ args List<ChildNumber> parentPath, boolean relative, boolean createParent, ChildNumber createChildNumber))
    (§ block
        (§ return deriveChild(§ pars get(§ pars parentPath, relative, createParent), createChildNumber))
    )

    #_private
    (§ method DeterministicKey deriveChild(§ args DeterministicKey parent, ChildNumber createChildNumber))
    (§ block
        (§ var DeterministicKey childKey = HDKeyDerivation.deriveChildKey(§ pars parent, createChildNumber))
        (§ call putKey(§ pars childKey))
        (§ return childKey)
    )

    ;;;
     ; Returns the root key that the {@link DeterministicHierarchy} was created with.
     ;;
    #_public
    (§ method DeterministicKey getRootKey(§ args ))
    (§ block
        (§ return get(§ pars rootPath, false, false))
    )
)

#_(ns org.bitcoinj.crypto #_"DeterministicKey"
    (:import [java.math BigInteger]
             [java.nio ByteBuffer]
             [java.util Arrays Comparator])
    (:import [com.google.common.base MoreObjects Objects Preconditions]
             [com.google.common.collect ImmutableList]
             [org.spongycastle.crypto.params KeyParameter]
             [org.spongycastle.math.ec ECPoint])
   (:require [org.bitcoinj.core *]
             #_static [org.bitcoinj.core.Utils HEX]))

;;;
 ; A deterministic key is a node in a {@link DeterministicHierarchy}.  As per
 ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">the BIP 32 specification</a> it is a pair
 ; (key, chaincode).  If you know its path in the tree and its chain code you can derive more keys from this.
 ; To obtain one of these, you can call {@link HDKeyDerivation#createMasterPrivateKey(byte[])}.
 ;;
#_public
(§ class DeterministicKey extends ECKey
    ;;; Sorts deterministic keys in the order of their child number.  That's <i>usually</i> the order used to derive them. ;;
    #_public
    #_static
    #_final
    (§ field Comparator<ECKey> CHILDNUM_ORDER = new Comparator<ECKey>(§ pars )
        (§ anon
            #_override
            #_public
            (§ method int compare(§ args ECKey k1, ECKey k2))
            (§ block
                (§ var ChildNumber cn1 = (§ expr (§ expr (§ cast DeterministicKey)k1).getChildNumber(§ pars )))
                (§ var ChildNumber cn2 = (§ expr (§ expr (§ cast DeterministicKey)k2).getChildNumber(§ pars )))
                (§ return cn1.compareTo(§ pars cn2))
            )
        ))

    #_private
    #_final
    (§ field DeterministicKey parent)
    #_private
    #_final
    (§ field ImmutableList<ChildNumber> childNumberPath)
    #_private
    #_final
    (§ field int depth)
    #_private
    (§ field int parentFingerprint) ;; 0 if this key is root node of key hierarchy

    ;;; 32 bytes ;;
    #_private
    #_final
    (§ field byte[] chainCode)

    ;;; Constructs a key from its components.  This is not normally something you should use. ;;
    #_public
    (§ constructor DeterministicKey(§ args ImmutableList<ChildNumber> childNumberPath, byte[] chainCode, LazyECPoint publicAsPoint, #_nilable BigInteger priv, #_nilable DeterministicKey parent))
    (§ block
        (§ super (§ pars priv, compressPoint(§ pars Preconditions.checkNotNull(§ pars publicAsPoint))))

        (§ call Preconditions.checkArgument(§ pars chainCode.length == 32))

        (§ ass this.parent = parent)
        (§ ass this.childNumberPath = Preconditions.checkNotNull(§ pars childNumberPath))
        (§ ass this.chainCode = Arrays.copyOf(§ pars chainCode, chainCode.length))
        (§ ass this.depth = (§ expr parent != nil) ? parent.depth + 1 :else 0)
        (§ ass this.parentFingerprint = (§ expr parent != nil) ? parent.getFingerprint(§ pars ) :else 0)
    )

    #_public
    (§ constructor DeterministicKey(§ args ImmutableList<ChildNumber> childNumberPath, byte[] chainCode, ECPoint publicAsPoint, #_nilable BigInteger priv, #_nilable DeterministicKey parent))
    (§ block
        (§ this (§ pars childNumberPath, chainCode, new LazyECPoint(§ pars publicAsPoint), priv, parent))
    )

    ;;; Constructs a key from its components.  This is not normally something you should use. ;;
    #_public
    (§ constructor DeterministicKey(§ args ImmutableList<ChildNumber> childNumberPath, byte[] chainCode, BigInteger priv, #_nilable DeterministicKey parent))
    (§ block
        (§ super (§ pars priv, compressPoint(§ pars ECKey.publicPointFromPrivate(§ pars priv))))

        (§ call Preconditions.checkArgument(§ pars chainCode.length == 32))

        (§ ass this.parent = parent)
        (§ ass this.childNumberPath = Preconditions.checkNotNull(§ pars childNumberPath))
        (§ ass this.chainCode = Arrays.copyOf(§ pars chainCode, chainCode.length))
        (§ ass this.depth = (§ expr parent != nil) ? parent.depth + 1 :else 0)
        (§ ass this.parentFingerprint = (§ expr parent != nil) ? parent.getFingerprint(§ pars ) :else 0)
    )

    ;;; Constructs a key from its components.  This is not normally something you should use. ;;
    #_public
    (§ constructor DeterministicKey(§ args ImmutableList<ChildNumber> childNumberPath, byte[] chainCode, KeyCrypter crypter, LazyECPoint pub, EncryptedData priv, #_nilable DeterministicKey parent))
    (§ block
        (§ this (§ pars childNumberPath, chainCode, pub, nil, parent))
        (§ ass this.encryptedPrivateKey = Preconditions.checkNotNull(§ pars priv))
        (§ ass this.keyCrypter = Preconditions.checkNotNull(§ pars crypter))
    )

    ;;;
     ; Return the fingerprint of this key's parent as an int value, or zero if this key is the
     ; root node of the key hierarchy.  Raise an exception if the arguments are inconsistent.
     ; This method exists to avoid code repetition in the constructors.
     ;;
    #_private
    (§ method int ascertainParentFingerprint(§ args DeterministicKey parentKey, int parentFingerprint))
        (§ throws IllegalArgumentException)
    (§ block
        (§ if (§ expr parentFingerprint != 0))
        (§ block
            (§ if (§ expr parent != nil))
            (§ block
                (§ call Preconditions.checkArgument(§ pars parent.getFingerprint(§ pars ) == parentFingerprint, "parent fingerprint mismatch", Integer.toHexString(§ pars parent.getFingerprint(§ pars )), Integer.toHexString(§ pars parentFingerprint)))
            )
            (§ return parentFingerprint)
        )

        (§ return 0)
    )

    ;;;
     ; Constructs a key from its components, including its public key data and possibly-redundant
     ; information about its parent key.  Invoked when deserializing, but otherwise not something
     ; that you normally should use.
     ;;
    #_public
    (§ constructor DeterministicKey(§ args ImmutableList<ChildNumber> childNumberPath, byte[] chainCode, LazyECPoint publicAsPoint, #_nilable DeterministicKey parent, int depth, int parentFingerprint))
    (§ block
        (§ super (§ pars nil, compressPoint(§ pars Preconditions.checkNotNull(§ pars publicAsPoint))))

        (§ call Preconditions.checkArgument(§ pars chainCode.length == 32))

        (§ ass this.parent = parent)
        (§ ass this.childNumberPath = Preconditions.checkNotNull(§ pars childNumberPath))
        (§ ass this.chainCode = Arrays.copyOf(§ pars chainCode, chainCode.length))
        (§ ass this.depth = depth)
        (§ ass this.parentFingerprint = ascertainParentFingerprint(§ pars parent, parentFingerprint))
    )

    ;;;
     ; Constructs a key from its components, including its private key data and possibly-redundant
     ; information about its parent key.  Invoked when deserializing, but otherwise not something that
     ; you normally should use.
     ;;
    #_public
    (§ constructor DeterministicKey(§ args ImmutableList<ChildNumber> childNumberPath, byte[] chainCode, BigInteger priv, #_nilable DeterministicKey parent, int depth, int parentFingerprint))
    (§ block
        (§ super (§ pars priv, compressPoint(§ pars ECKey.publicPointFromPrivate(§ pars priv))))

        (§ call Preconditions.checkArgument(§ pars chainCode.length == 32))

        (§ ass this.parent = parent)
        (§ ass this.childNumberPath = Preconditions.checkNotNull(§ pars childNumberPath))
        (§ ass this.chainCode = Arrays.copyOf(§ pars chainCode, chainCode.length))
        (§ ass this.depth = depth)
        (§ ass this.parentFingerprint = ascertainParentFingerprint(§ pars parent, parentFingerprint))
    )

    ;;; Clones the key. ;;
    #_public
    (§ constructor DeterministicKey(§ args DeterministicKey keyToClone, DeterministicKey newParent))
    (§ block
        (§ super (§ pars keyToClone.priv, keyToClone.pub.get(§ pars )))

        (§ ass this.parent = newParent)
        (§ ass this.childNumberPath = keyToClone.childNumberPath)
        (§ ass this.chainCode = keyToClone.chainCode)
        (§ ass this.encryptedPrivateKey = keyToClone.encryptedPrivateKey)
        (§ ass this.depth = this.childNumberPath.size(§ pars ))
        (§ ass this.parentFingerprint = this.parent.getFingerprint(§ pars ))
    )

    ;;;
     ; Returns the path through some {@link DeterministicHierarchy} which reaches this keys position in the tree.
     ; A path can be written as 1/2/1 which means the first child of the root, the second child of that node, then
     ; the first child of that node.
     ;;
    #_public
    (§ method ImmutableList<ChildNumber> getPath(§ args ))
    (§ block
        (§ return childNumberPath)
    )

    ;;;
     ; Returns the path of this key as a human readable string starting with M to indicate the master key.
     ;;
    #_public
    (§ method String getPathAsString(§ args ))
    (§ block
        (§ return HDUtils.formatPath(§ pars getPath(§ pars )))
    )

    ;;;
     ; Return this key's depth in the hierarchy, where the root node is at depth zero.
     ; This may be different than the number of segments in the path if this key was
     ; deserialized without access to its parent.
     ;;
    #_public
    (§ method int getDepth(§ args ))
    (§ block
        (§ return depth)
    )

    ;;; Returns the last element of the path returned by {@link DeterministicKey#getPath()}. ;;
    #_public
    (§ method ChildNumber getChildNumber(§ args ))
    (§ block
        (§ return (§ quest (§ expr childNumberPath.size(§ pars ) == 0) ? ChildNumber.ZERO :else childNumberPath.get(§ pars childNumberPath.size(§ pars ) - 1)))
    )

    ;;;
     ; Returns the chain code associated with this key.  See the specification to learn more about chain codes.
     ;;
    #_public
    (§ method byte[] getChainCode(§ args ))
    (§ block
        (§ return chainCode)
    )

    ;;;
     ; Returns RIPE-MD160(SHA256(pub key bytes)).
     ;;
    #_public
    (§ method byte[] getIdentifier(§ args ))
    (§ block
        (§ return Utils.sha256hash160(§ pars getPubKey(§ pars )))
    )

    ;;; Returns the first 32 bits of the result of {@link #getIdentifier()}. ;;
    #_public
    (§ method int getFingerprint(§ args ))
    (§ block
        ;; TODO: Why is this different than armory's fingerprint?  BIP 32: "The first 32 bits of the identifier are called the fingerprint."
        (§ return ByteBuffer.wrap(§ pars Arrays.copyOfRange(§ pars getIdentifier(§ pars ), 0, 4)).getInt(§ pars ))
    )

    #_nilable
    #_public
    (§ method DeterministicKey getParent(§ args ))
    (§ block
        (§ return parent)
    )

    ;;;
     ; Return the fingerprint of the key from which this key was derived, if this is
     ; a child key, or else an array of four zero-value bytes.
     ;;
    #_public
    (§ method int getParentFingerprint(§ args ))
    (§ block
        (§ return parentFingerprint)
    )

    ;;;
     ; Returns private key bytes, padded with zeros to 33 bytes.
     ; @throws java.lang.IllegalStateException if the private key bytes are missing.
     ;;
    #_public
    (§ method byte[] getPrivKeyBytes33(§ args ))
    (§ block
        (§ var byte[] bytes33 = new byte[33])
        (§ var byte[] priv = getPrivKeyBytes(§ pars ))
        (§ call System.arraycopy(§ pars priv, 0, bytes33, 33 - priv.length, priv.length))
        (§ return bytes33)
    )

    ;;;
     ; Returns the same key with the private bytes removed.  May return the same instance.  The purpose of this is to
     ; save memory: the private key can always be very efficiently rederived from a parent that a private key, so storing
     ; all the private keys in RAM is a poor tradeoff especially on constrained devices.  This means that the returned
     ; key may still be usable for signing and so on, so don't expect it to be a true pubkey-only object!  If you want
     ; that then you should follow this call with a call to {@link #dropParent()}.
     ;;
    #_public
    (§ method DeterministicKey dropPrivateBytes(§ args ))
    (§ block
        (§ return isPubKeyOnly(§ pars ) ? this :else new DeterministicKey(§ pars getPath(§ pars ), getChainCode(§ pars ), pub, nil, parent))
    )

    ;;;
     ; <p>Returns the same key with the parent pointer removed (it still knows its own path and the parent fingerprint).</p>
     ;
     ; <p>If this key doesn't have private key bytes stored/cached itself, but could rederive them from the parent, then
     ; the new key returned by this method won't be able to do that.  Thus, using dropPrivateBytes().dropParent() on a
     ; regular DeterministicKey will yield a new DeterministicKey that cannot sign or do other things involving the
     ; private key at all.</p>
     ;;
    #_public
    (§ method DeterministicKey dropParent(§ args ))
    (§ block
        (§ var DeterministicKey key = new DeterministicKey(§ pars getPath(§ pars ), getChainCode(§ pars ), pub, priv, nil))
        (§ ass key.parentFingerprint = parentFingerprint)
        (§ return key)
    )

    #_static
    (§ method byte[] addChecksum(§ args byte[] input))
    (§ block
        (§ var int inputLength = input.length)
        (§ var byte[] checksummed = new byte[inputLength + 4])
        (§ call System.arraycopy(§ pars input, 0, checksummed, 0, inputLength))
        (§ var byte[] checksum = Sha256Hash.hashTwice(§ pars input))
        (§ call System.arraycopy(§ pars checksum, 0, checksummed, inputLength, 4))
        (§ return checksummed)
    )

    #_override
    #_public
    (§ method DeterministicKey encrypt(§ args KeyCrypter keyCrypter, KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (§ block
        (§ throw (§ new UnsupportedOperationException(§ pars "Must supply a new parent for encryption")))
    )

    #_public
    (§ method DeterministicKey encrypt(§ args KeyCrypter keyCrypter, KeyParameter aesKey, #_nilable DeterministicKey newParent))
        (§ throws KeyCrypterException)
    (§ block
        ;; Same as the parent code, except we construct a DeterministicKey instead of an ECKey.
        (§ call Preconditions.checkNotNull(§ pars keyCrypter))
        (§ if (§ expr newParent != nil))
        (§ block
            (§ call Preconditions.checkArgument(§ pars newParent.isEncrypted(§ pars )))
        )

        #_final
        (§ var byte[] privKeyBytes = getPrivKeyBytes(§ pars ))
        (§ call Preconditions.checkState(§ pars privKeyBytes != nil, "Private key is not available"))

        (§ var EncryptedData encryptedPrivateKey = keyCrypter.encrypt(§ pars privKeyBytes, aesKey))
        (§ var DeterministicKey key = new DeterministicKey(§ pars childNumberPath, chainCode, keyCrypter, pub, encryptedPrivateKey, newParent))
        (§ if (§ expr newParent == nil))
        (§ block
            (§ call key.setCreationTimeSeconds(§ pars getCreationTimeSeconds(§ pars )))
        )
        (§ return key)
    )

    ;;;
     ; A deterministic key is considered to be 'public key only' if it hasn't got a private key part and it cannot be
     ; rederived.  If the hierarchy is encrypted this returns true.
     ;;
    #_override
    #_public
    (§ method boolean isPubKeyOnly(§ args ))
    (§ block
        (§ return (§ expr super.isPubKeyOnly(§ pars ) && (§ expr parent == nil || parent.isPubKeyOnly(§ pars ))))
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (§ method boolean hasPrivKey(§ args ))
    (§ block
        (§ return (§ expr findParentWithPrivKey(§ pars ) != nil))
    )

    #_nilable
    #_override
    #_public
    (§ method byte[] getSecretBytes(§ args ))
    (§ block
        (§ return (§ expr priv != nil) ? getPrivKeyBytes(§ pars ) :else nil)
    )

    ;;;
     ; A deterministic key is considered to be encrypted if it has access to encrypted private key bytes, OR if its
     ; parent does.  The reason is because the parent would be encrypted under the same key and this key knows how to
     ; rederive its own private key bytes from the parent, if needed.
     ;;
    #_override
    #_public
    (§ method boolean isEncrypted(§ args ))
    (§ block
        (§ return (§ expr priv == nil && (§ expr super.isEncrypted(§ pars ) || (§ expr parent != nil && parent.isEncrypted(§ pars )))))
    )

    ;;;
     ; Returns this keys {@link org.bitcoinj.crypto.KeyCrypter} <b>or</b> the keycrypter of its parent key.
     ;;
    #_override
    #_nilable
    #_public
    (§ method KeyCrypter getKeyCrypter(§ args ))
    (§ block
        (§ if (§ expr keyCrypter != nil))
        (§ block
            (§ return keyCrypter)
        )
        (§ if (§ expr parent != nil))
        (§ block
            (§ return parent.getKeyCrypter(§ pars ))
        )

        (§ return nil)
    )

    #_override
    #_public
    (§ method ECDSASignature sign(§ args Sha256Hash input, #_nilable KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (§ block
        (§ if (§ expr isEncrypted(§ pars )))
        (§ block
            ;; If the key is encrypted, ECKey.sign will decrypt it first before rerunning sign.  Decryption walks
            ;; the key heirarchy to find the private key (see below), so, we can just run the inherited method.
            (§ return super.sign(§ pars input, aesKey))
        )
        (§ else )
        (§ block
            ;; If it's not encrypted, derive the private via the parents.
            #_final
            (§ var BigInteger privateKey = findOrDerivePrivateKey(§ pars ))
            ;; This key is a part of a public-key only heirarchy and cannot be used for signing.
            (§ if (§ expr privateKey == nil))
            (§ block
                (§ throw (§ new MissingPrivateKeyException(§ pars )))
            )

            (§ return super.doSign(§ pars input, privateKey))
        )
    )

    #_override
    #_public
    (§ method DeterministicKey decrypt(§ args KeyCrypter keyCrypter, KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars keyCrypter))
        ;; Check that the keyCrypter matches the one used to encrypt the keys, if set.
        (§ if (§ expr this.keyCrypter != nil && !this.keyCrypter.equals(§ pars keyCrypter)))
        (§ block
            (§ throw (§ new KeyCrypterException(§ pars "The keyCrypter being used to decrypt the key is different to the one that was used to encrypt it")))
        )

        (§ var BigInteger privKey = findOrDeriveEncryptedPrivateKey(§ pars keyCrypter, aesKey))
        (§ var DeterministicKey key = new DeterministicKey(§ pars childNumberPath, chainCode, privKey, parent))
        (§ if (§ expr !Arrays.equals(§ pars key.getPubKey(§ pars ), getPubKey(§ pars ))))
        (§ block
            (§ throw (§ new KeyCrypterException(§ pars "Provided AES key is wrong")))
        )

        (§ if (§ expr parent == nil))
        (§ block
            (§ call key.setCreationTimeSeconds(§ pars getCreationTimeSeconds(§ pars )))
        )
        (§ return key)
    )

    #_override
    #_public
    (§ method DeterministicKey decrypt(§ args KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (§ block
        (§ return (§ cast DeterministicKey)super.decrypt(§ pars aesKey))
    )

    ;; For when a key is encrypted, either decrypt our encrypted private key bytes, or work up the tree asking parents
    ;; to decrypt and re-derive.
    #_private
    (§ method BigInteger findOrDeriveEncryptedPrivateKey(§ args KeyCrypter keyCrypter, KeyParameter aesKey))
    (§ block
        (§ if (§ expr encryptedPrivateKey != nil))
        (§ block
            (§ return (§ new BigInteger(§ pars 1, keyCrypter.decrypt(§ pars encryptedPrivateKey, aesKey))))
        )

        ;; Otherwise we don't have it, but maybe we can figure it out from our parents.  Walk up the tree looking for
        ;; the first key that has some encrypted private key data.
        (§ var DeterministicKey cursor = parent)
        (§ while (§ expr cursor != nil))
        (§ block
            (§ if (§ expr cursor.encryptedPrivateKey != nil))
            (§ block
                (§ break )
            )
            (§ ass cursor = cursor.parent)
        )
        (§ if (§ expr cursor == nil))
        (§ block
            (§ throw (§ new KeyCrypterException(§ pars "Neither this key nor its parents have an encrypted private key")))
        )

        (§ var byte[] parentalPrivateKeyBytes = keyCrypter.decrypt(§ pars cursor.encryptedPrivateKey, aesKey))
        (§ return derivePrivateKeyDownwards(§ pars cursor, parentalPrivateKeyBytes))
    )

    #_private
    (§ method DeterministicKey findParentWithPrivKey(§ args ))
    (§ block
        (§ var DeterministicKey cursor = this)
        (§ while (§ expr cursor != nil))
        (§ block
            (§ if (§ expr cursor.priv != nil))
            (§ block
                (§ break )
            )
            (§ ass cursor = cursor.parent)
        )
        (§ return cursor)
    )

    #_nilable
    #_private
    (§ method BigInteger findOrDerivePrivateKey(§ args ))
    (§ block
        (§ var DeterministicKey cursor = findParentWithPrivKey(§ pars ))
        (§ if (§ expr cursor == nil))
        (§ block
            (§ return nil)
        )

        (§ return derivePrivateKeyDownwards(§ pars cursor, cursor.priv.toByteArray(§ pars )))
    )

    #_private
    (§ method BigInteger derivePrivateKeyDownwards(§ args DeterministicKey cursor, byte[] parentalPrivateKeyBytes))
    (§ block
        (§ var DeterministicKey downCursor = new DeterministicKey(§ pars cursor.childNumberPath, cursor.chainCode, cursor.pub, new BigInteger(§ pars 1, parentalPrivateKeyBytes), cursor.parent))
        ;; Now we have to rederive the keys along the path back to ourselves.  That path can be found by just truncating
        ;; our path with the length of the parents path.
        (§ var ImmutableList<ChildNumber> path = childNumberPath.subList(§ pars cursor.getPath(§ pars ).size(§ pars ), childNumberPath.size(§ pars )))
        (§ for (§ var ChildNumber num) :for (§ expr path))
        (§ block
            (§ ass downCursor = HDKeyDerivation.deriveChildKey(§ pars downCursor, num))
        )
        ;; downCursor is now the same key as us, but with private key bytes.
        ;; If it's not, it means we tried decrypting with an invalid password and earlier checks e.g. for padding didn't
        ;; catch it.
        (§ if (§ expr !downCursor.pub.equals(§ pars pub)))
        (§ block
            (§ throw (§ new KeyCrypterException(§ pars "Could not decrypt bytes")))
        )

        (§ return Preconditions.checkNotNull(§ pars downCursor.priv))
    )

    ;;;
     ; Derives a child at the given index using hardened derivation.  Note: <code>index</code>
     ; is not the "i" value.  If you want the softened derivation, then use instead
     ; <code>HDKeyDerivation.deriveChildKey(this, new ChildNumber(child, false))</code>.
     ;;
    #_public
    (§ method DeterministicKey derive(§ args int child))
    (§ block
        (§ return HDKeyDerivation.deriveChildKey(§ pars this, new ChildNumber(§ pars child, true)))
    )

    ;;;
     ; Returns the private key of this deterministic key.  Even if this object isn't storing the private key,
     ; it can be re-derived by walking up to the parents if necessary and this is what will happen.
     ; @throws java.lang.IllegalStateException if the parents are encrypted or a watching chain.
     ;;
    #_override
    #_public
    (§ method BigInteger getPrivKey(§ args ))
    (§ block
        #_final
        (§ var BigInteger key = findOrDerivePrivateKey(§ pars ))
        (§ call Preconditions.checkState(§ pars key != nil, "Private key bytes not available"))
        (§ return key)
    )

    #_public
    (§ method byte[] serializePublic(§ args NetworkParameters params))
    (§ block
        (§ return serialize(§ pars params, true))
    )

    #_public
    (§ method byte[] serializePrivate(§ args NetworkParameters params))
    (§ block
        (§ return serialize(§ pars params, false))
    )

    #_private
    (§ method byte[] serialize(§ args NetworkParameters params, boolean pub))
    (§ block
        (§ var ByteBuffer ser = ByteBuffer.allocate(§ pars 78))
        (§ call ser.putInt(§ pars pub ? params.getBip32HeaderPub(§ pars ) :else params.getBip32HeaderPriv(§ pars )))
        (§ call ser.put(§ pars (§ cast byte)getDepth(§ pars )))
        (§ call ser.putInt(§ pars getParentFingerprint(§ pars )))
        (§ call ser.putInt(§ pars getChildNumber(§ pars ).i(§ pars )))
        (§ call ser.put(§ pars getChainCode(§ pars )))
        (§ call ser.put(§ pars pub ? getPubKey(§ pars ) :else getPrivKeyBytes33(§ pars )))
        (§ call Preconditions.checkState(§ pars ser.position(§ pars ) == 78))
        (§ return ser.array(§ pars ))
    )

    #_public
    (§ method String serializePubB58(§ args NetworkParameters params))
    (§ block
        (§ return toBase58(§ pars serialize(§ pars params, true)))
    )

    #_public
    (§ method String serializePrivB58(§ args NetworkParameters params))
    (§ block
        (§ return toBase58(§ pars serialize(§ pars params, false)))
    )

    #_static
    (§ method String toBase58(§ args byte[] ser))
    (§ block
        (§ return Base58.encode(§ pars addChecksum(§ pars ser)))
    )

    ;;; Deserialize a base-58-encoded HD Key with no parent. ;;
    #_public
    #_static
    (§ method DeterministicKey deserializeB58(§ args String base58, NetworkParameters params))
    (§ block
        (§ return deserializeB58(§ pars nil, base58, params))
    )

    ;;;
     ; Deserialize a base-58-encoded HD Key.
     ; @param parent The parent node in the given key's deterministic hierarchy.
     ; @throws IllegalArgumentException if the base58 encoded key could not be parsed.
     ;;
    #_public
    #_static
    (§ method DeterministicKey deserializeB58(§ args #_nilable DeterministicKey parent, String base58, NetworkParameters params))
    (§ block
        (§ return deserialize(§ pars params, Base58.decodeChecked(§ pars base58), parent))
    )

    ;;;
     ; Deserialize an HD Key with no parent.
     ;;
    #_public
    #_static
    (§ method DeterministicKey deserialize(§ args NetworkParameters params, byte[] serializedKey))
    (§ block
        (§ return deserialize(§ pars params, serializedKey, nil))
    )

    ;;;
     ; Deserialize an HD Key.
     ; @param parent The parent node in the given key's deterministic hierarchy.
     ;;
    #_public
    #_static
    (§ method DeterministicKey deserialize(§ args NetworkParameters params, byte[] serializedKey, #_nilable DeterministicKey parent))
    (§ block
        (§ var ByteBuffer buffer = ByteBuffer.wrap(§ pars serializedKey))
        (§ var int header = buffer.getInt(§ pars ))
        (§ if (§ expr header != params.getBip32HeaderPriv(§ pars ) && header != params.getBip32HeaderPub(§ pars )))
        (§ block
            (§ throw (§ new IllegalArgumentException(§ pars "Unknown header bytes: " + toBase58(§ pars serializedKey).substring(§ pars 0, 4))))
        )

        (§ var boolean pub = (§ expr header == params.getBip32HeaderPub(§ pars )))
        (§ var int depth = buffer.get(§ pars ) & 0xff) ;; convert signed byte to positive int since depth cannot be negative
        #_final
        (§ var int parentFingerprint = buffer.getInt(§ pars ))
        #_final
        (§ var int i = buffer.getInt(§ pars ))
        #_final
        (§ var ChildNumber childNumber = new ChildNumber(§ pars i))
        (§ var ImmutableList<ChildNumber> path)
        (§ if (§ expr parent != nil))
        (§ block
            (§ if (§ expr parentFingerprint == 0))
            (§ block
                (§ throw (§ new IllegalArgumentException(§ pars "Parent was provided but this key doesn't have one")))
            )
            (§ if (§ expr parent.getFingerprint(§ pars ) != parentFingerprint))
            (§ block
                (§ throw (§ new IllegalArgumentException(§ pars "Parent fingerprints don't match")))
            )
            (§ ass path = HDUtils.append(§ pars parent.getPath(§ pars ), childNumber))
            (§ if (§ expr path.size(§ pars ) != depth))
            (§ block
                (§ throw (§ new IllegalArgumentException(§ pars "Depth does not match")))
            )
        )
        (§ else )
        (§ block
            ;; We have been given a key that is not a root key, yet we lack the object representing the parent.
            ;; This can happen when deserializing an account key for a watching wallet.  In this case, we assume that
            ;; the client wants to conceal the key's position in the hierarchy.  The path is truncated at the
            ;; parent's node.
            (§ if (§ expr 1 <= depth))
            (§ block
                (§ ass path = ImmutableList.of(§ pars childNumber))
            )
            (§ else )
            (§ block
                (§ ass path = ImmutableList.of(§ pars ))
            )
        )
        (§ var byte[] chainCode = new byte[32])
        (§ call buffer.get(§ pars chainCode))
        (§ var byte[] data = new byte[33])
        (§ call buffer.get(§ pars data))
        (§ call Preconditions.checkArgument(§ pars !buffer.hasRemaining(§ pars ), "Found unexpected data in key"))
        (§ if (§ expr pub))
        (§ block
            (§ return (§ new DeterministicKey(§ pars path, chainCode, new LazyECPoint(§ pars ECKey.CURVE.getCurve(§ pars ), data), parent, depth, parentFingerprint)))
        )
        (§ else )
        (§ block
            (§ return (§ new DeterministicKey(§ pars path, chainCode, new BigInteger(§ pars 1, data), parent, depth, parentFingerprint)))
        )
    )

    ;;;
     ; The creation time of a deterministic key is equal to that of its parent, unless this key is the root of a tree
     ; in which case the time is stored alongside the key as per normal, see {@link org.bitcoinj.core.ECKey#getCreationTimeSeconds()}.
     ;;
    #_override
    #_public
    (§ method long getCreationTimeSeconds(§ args ))
    (§ block
        (§ if (§ expr parent != nil))
        (§ block
            (§ return parent.getCreationTimeSeconds(§ pars ))
        )
        (§ else )
        (§ block
            (§ return super.getCreationTimeSeconds(§ pars ))
        )
    )

    ;;;
     ; The creation time of a deterministic key is equal to that of its parent, unless this key is the root of a tree.
     ; Thus, setting the creation time on a leaf is forbidden.
     ;;
    #_override
    #_public
    (§ method void setCreationTimeSeconds(§ args long newCreationTimeSeconds))
    (§ block
        (§ if (§ expr parent != nil))
        (§ block
            (§ throw (§ new IllegalStateException(§ pars "Creation time can only be set on root keys.")))
        )
        (§ else )
        (§ block
            (§ call super.setCreationTimeSeconds(§ pars newCreationTimeSeconds))
        )
    )

    ;;;
     ; Verifies equality of all fields but NOT the parent pointer (thus the same key derived in two separate heirarchy
     ; objects will equal each other.
     ;;
    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var DeterministicKey other = (§ cast DeterministicKey)o)
        (§ return (§ expr super.equals(§ pars other) && Arrays.equals(§ pars this.chainCode, other.chainCode) && Objects.equal(§ pars this.childNumberPath, other.childNumberPath)))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars super.hashCode(§ pars ), Arrays.hashCode(§ pars chainCode), childNumberPath))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        #_final
        (§ var MoreObjects.ToStringHelper helper = MoreObjects.toStringHelper(§ pars this).omitNullValues(§ pars ))
        (§ call helper.add(§ pars "pub", Utils.HEX.encode(§ pars pub.getEncoded(§ pars ))))
        (§ call helper.add(§ pars "chainCode", HEX.encode(§ pars chainCode)))
        (§ call helper.add(§ pars "path", getPathAsString(§ pars )))
        (§ if (§ expr 0 < creationTimeSeconds))
        (§ block
            (§ call helper.add(§ pars "creationTimeSeconds", creationTimeSeconds))
        )
        (§ call helper.add(§ pars "isEncrypted", isEncrypted(§ pars )))
        (§ call helper.add(§ pars "isPubKeyOnly", isPubKeyOnly(§ pars )))
        (§ return helper.toString(§ pars ))
    )

    #_override
    #_public
    (§ method void formatKeyWithAddress(§ args boolean includePrivateKeys, StringBuilder sb, NetworkParameters params))
    (§ block
        #_final
        (§ var Address address = toAddress(§ pars params))
        (§ call sb.append(§ pars "  addr:").append(§ pars address))
        (§ call sb.append(§ pars "  hash160:").append(§ pars Utils.HEX.encode(§ pars getPubKeyHash(§ pars ))))
        (§ call sb.append(§ pars "  (").append(§ pars getPathAsString(§ pars )).append(§ pars ")\n"))
        (§ if (§ expr includePrivateKeys))
        (§ block
            (§ call sb.append(§ pars "  ").append(§ pars toStringWithPrivate(§ pars params)).append(§ pars "\n"))
        )
    )
)

#_(ns org.bitcoinj.crypto #_"EncryptableItem"
   (:require [org.bitcoinj.wallet Protos]))

;;;
 ; Provides a uniform way to access something that can be optionally encrypted with a
 ; {@link org.bitcoinj.crypto.KeyCrypter}, yielding an {@link org.bitcoinj.crypto.EncryptedData},
 ; and which can have a creation time associated with it.
 ;;
#_public
(§ interface EncryptableItem
    ;;; Returns whether the item is encrypted or not.  If it is, then {@link #getSecretBytes()} will return null. ;;
    (§ method boolean isEncrypted(§ args ))

    ;;; Returns the raw bytes of the item, if not encrypted, or null if encrypted or the secret is missing. ;;
    #_nilable
    (§ method byte[] getSecretBytes(§ args ))

    ;;; Returns the initialization vector and encrypted secret bytes, or null if not encrypted. ;;
    #_nilable
    (§ method EncryptedData getEncryptedData(§ args ))

    ;;; Returns an enum constant describing what algorithm was used to encrypt the key or UNENCRYPTED. ;;
    (§ method Protos.Wallet.EncryptionType getEncryptionType(§ args ))

    ;;; Returns the time in seconds since the UNIX epoch at which this encryptable item was first created/derived. ;;
    (§ method long getCreationTimeSeconds(§ args ))
)

#_(ns org.bitcoinj.crypto #_"EncryptedData"
    (:import [java.util Arrays])
    (:import [com.google.common.base Objects]))

;;;
 ; <p>An instance of EncryptedData is a holder for an initialization vector and encrypted bytes.
 ; It is typically used to hold encrypted private key bytes.</p>
 ;
 ; <p>The initialisation vector is random data that is used to initialise the AES block cipher when
 ; the private key bytes were encrypted.  You need these for decryption.</p>
 ;;
#_public
#_final
(§ class EncryptedData
    #_public
    #_final
    (§ field byte[] initialisationVector)
    #_public
    #_final
    (§ field byte[] encryptedBytes)

    #_public
    (§ constructor EncryptedData(§ args byte[] initialisationVector, byte[] encryptedBytes))
    (§ block
        (§ ass this.initialisationVector = Arrays.copyOf(§ pars initialisationVector, initialisationVector.length))
        (§ ass this.encryptedBytes = Arrays.copyOf(§ pars encryptedBytes, encryptedBytes.length))
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var EncryptedData other = (§ cast EncryptedData)o)
        (§ return (§ expr Arrays.equals(§ pars encryptedBytes, other.encryptedBytes) && Arrays.equals(§ pars initialisationVector, other.initialisationVector)))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars Arrays.hashCode(§ pars encryptedBytes), Arrays.hashCode(§ pars initialisationVector)))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return "EncryptedData [initialisationVector=" + Arrays.toString(§ pars initialisationVector) + ", encryptedPrivateKey=" + Arrays.toString(§ pars encryptedBytes) + "]")
    )
)

#_(ns org.bitcoinj.crypto #_"HDDerivationException")

#_public
(§ class HDDerivationException extends RuntimeException
    #_public
    (§ constructor HDDerivationException(§ args String message))
    (§ block
        (§ super (§ pars message))
    )
)

#_(ns org.bitcoinj.crypto #_"HDKeyDerivation"
    (:import [java.math *]
             [java.nio *]
             [java.security *]
             [java.util *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect *]
             [org.spongycastle.math.ec *])
   (:require [org.bitcoinj.core *]))

;;;
 ; Implementation of the <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP 32</a>
 ; deterministic wallet child key generation algorithm.
 ;;
#_public
#_final
(§ class HDKeyDerivation
    #_static
    (§ block
        ;; Init proper random number generator, as some old Android installations have bugs that make it unsecure.
        (§ if (§ expr Utils.isAndroidRuntime(§ pars )))
        (§ block
            (§ call (§ new LinuxSecureRandom(§ pars )))
        )

        (§ ass RAND_INT = new BigInteger(§ pars 256, new SecureRandom(§ pars )))
    )

    ;; Some arbitrary random number.  Doesn't matter what it is.
    #_private
    #_static
    #_final
    (§ field BigInteger RAND_INT)

    #_private
    (§ constructor HDKeyDerivation(§ args ))
    (§ block
    )

    ;;;
     ; Child derivation may fail (although with extremely low probability); in such case it is re-attempted.
     ; This is the maximum number of re-attempts (to avoid an infinite loop in case of bugs etc.)
     ;;
    #_public
    #_static
    #_final
    (§ field int MAX_CHILD_DERIVATION_ATTEMPTS = 100)

    ;;;
     ; Generates a new deterministic key from the given seed, which can be any arbitrary byte array.
     ; However resist the temptation to use a string as the seed - any key derived from a password
     ; is likely to be weak and easily broken by attackers (this is not theoretical, people have had
     ; money stolen that way).  This method checks that the given seed is at least 64 bits long.
     ;
     ; @throws HDDerivationException if generated master key is invalid (private key 0 or >= n).
     ; @throws IllegalArgumentException if the seed is less than 8 bytes and could be brute forced.
     ;;
    #_public
    #_static
    (§ method DeterministicKey createMasterPrivateKey(§ args byte[] seed))
        (§ throws HDDerivationException)
    (§ block
        (§ call Preconditions.checkArgument(§ pars 8 < seed.length, "Seed is too short and could be brute forced"))

        ;; Calculate I = HMAC-SHA512(key="Bitcoin seed", msg=S).
        (§ var byte[] i = HDUtils.hmacSha512(§ pars HDUtils.createHmacSha512Digest(§ pars "Bitcoin seed".getBytes(§ pars )), seed))
        ;; Split I into two 32-byte sequences, Il and Ir.
        ;; Use Il as master secret key, and Ir as master chain code.
        (§ call Preconditions.checkState(§ pars i.length == 64, i.length))

        (§ var byte[] il = Arrays.copyOfRange(§ pars i, 0, 32))
        (§ var byte[] ir = Arrays.copyOfRange(§ pars i, 32, 64))
        (§ call Arrays.fill(§ pars i, (§ cast byte)0))
        (§ var DeterministicKey masterPrivKey = createMasterPrivKeyFromBytes(§ pars il, ir))
        (§ call Arrays.fill(§ pars il, (§ cast byte)0))
        (§ call Arrays.fill(§ pars ir, (§ cast byte)0))

        ;; Child deterministic keys will chain up to their parents to find the keys.
        (§ call masterPrivKey.setCreationTimeSeconds(§ pars Utils.currentTimeSeconds(§ pars )))
        (§ return masterPrivKey)
    )

    ;;;
     ; @throws HDDerivationException if privKeyBytes is invalid (0 or >= n).
     ;;
    #_public
    #_static
    (§ method DeterministicKey createMasterPrivKeyFromBytes(§ args byte[] privKeyBytes, byte[] chainCode))
        (§ throws HDDerivationException)
    (§ block
        (§ var BigInteger priv = new BigInteger(§ pars 1, privKeyBytes))
        (§ call assertNonZero(§ pars priv, "Generated master key is invalid."))
        (§ call assertLessThanN(§ pars priv, "Generated master key is invalid."))
        (§ return (§ new DeterministicKey(§ pars ImmutableList.<ChildNumber>of(§ pars ), chainCode, priv, nil)))
    )

    #_public
    #_static
    (§ method DeterministicKey createMasterPubKeyFromBytes(§ args byte[] pubKeyBytes, byte[] chainCode))
    (§ block
        (§ return (§ new DeterministicKey(§ pars ImmutableList.<ChildNumber>of(§ pars ), chainCode, new LazyECPoint(§ pars ECKey.CURVE.getCurve(§ pars ), pubKeyBytes), nil, nil)))
    )

    ;;;
     ; Derives a key given the "extended" child number, i.e. the 0x80000000 bit of the value that you
     ; pass for <code>childNumber</code> will determine whether to use hardened derivation or not.
     ; Consider whether your code would benefit from the clarity of the equivalent, but explicit, form
     ; of this method that takes a <code>ChildNumber</code> rather than an <code>int</code>, for example:
     ; <code>deriveChildKey(parent, new ChildNumber(childNumber, true))</code>
     ; where the value of the hardened bit of <code>childNumber</code> is zero.
     ;;
    #_public
    #_static
    (§ method DeterministicKey deriveChildKey(§ args DeterministicKey parent, int childNumber))
    (§ block
        (§ return deriveChildKey(§ pars parent, new ChildNumber(§ pars childNumber)))
    )

    ;;;
     ; Derives a key of the "extended" child number, i.e. with the 0x80000000 bit specifying whether
     ; to use hardened derivation or not.  If derivation fails, tries a next child.
     ;;
    #_public
    #_static
    (§ method DeterministicKey deriveThisOrNextChildKey(§ args DeterministicKey parent, int childNumber))
    (§ block
        (§ var ChildNumber child = new ChildNumber(§ pars childNumber))
        (§ var boolean isHardened = child.isHardened(§ pars ))
        (§ for (§ var int i = 0) :for (§ expr i < MAX_CHILD_DERIVATION_ATTEMPTS) :for (§ ass i = i + 1))
        (§ block
            (§ try )
            (§ block
                (§ ass child = new ChildNumber(§ pars child.num(§ pars ) + i, isHardened))
                (§ return deriveChildKey(§ pars parent, child))
            )
            (§ catch (§ args HDDerivationException _))
            (§ block
            )
        )
        (§ throw (§ new HDDerivationException(§ pars "Maximum number of child derivation attempts reached, this is probably an indication of a bug.")))
    )

    ;;;
     ; @throws HDDerivationException if private derivation is attempted for a public-only parent key, or
     ; if the resulting derived key is invalid (e.g. private key == 0).
     ;;
    #_public
    #_static
    (§ method DeterministicKey deriveChildKey(§ args DeterministicKey parent, ChildNumber childNumber))
        (§ throws HDDerivationException)
    (§ block
        (§ if (§ expr !parent.hasPrivKey(§ pars )))
        (§ block
            (§ var RawKeyBytes rawKey = deriveChildKeyBytesFromPublic(§ pars parent, childNumber, PublicDeriveMode.NORMAL))
            (§ return (§ new DeterministicKey(§ pars HDUtils.append(§ pars parent.getPath(§ pars ), childNumber), rawKey.chainCode, new LazyECPoint(§ pars ECKey.CURVE.getCurve(§ pars ), rawKey.keyBytes), nil, parent)))
        )
        (§ else )
        (§ block
            (§ var RawKeyBytes rawKey = deriveChildKeyBytesFromPrivate(§ pars parent, childNumber))
            (§ return (§ new DeterministicKey(§ pars HDUtils.append(§ pars parent.getPath(§ pars ), childNumber), rawKey.chainCode, new BigInteger(§ pars 1, rawKey.keyBytes), parent)))
        )
    )

    #_public
    #_static
    (§ method RawKeyBytes deriveChildKeyBytesFromPrivate(§ args DeterministicKey parent, ChildNumber childNumber))
        (§ throws HDDerivationException)
    (§ block
        (§ call Preconditions.checkArgument(§ pars parent.hasPrivKey(§ pars ), "Parent key must have private key bytes for this method."))

        (§ var byte[] parentPublicKey = parent.getPubKeyPoint(§ pars ).getEncoded(§ pars true))
        (§ call Preconditions.checkState(§ pars parentPublicKey.length == 33, "Parent pubkey must be 33 bytes, but is " + parentPublicKey.length))

        (§ var ByteBuffer data = ByteBuffer.allocate(§ pars 37))
        (§ call data.put(§ pars childNumber.isHardened(§ pars ) ? parent.getPrivKeyBytes33(§ pars ) :else parentPublicKey))
        (§ call data.putInt(§ pars childNumber.i(§ pars )))

        (§ var byte[] i = HDUtils.hmacSha512(§ pars parent.getChainCode(§ pars ), data.array(§ pars )))
        (§ call Preconditions.checkState(§ pars i.length == 64, i.length))

        (§ var byte[] il = Arrays.copyOfRange(§ pars i, 0, 32))
        (§ var byte[] chainCode = Arrays.copyOfRange(§ pars i, 32, 64))
        (§ var BigInteger ilInt = new BigInteger(§ pars 1, il))
        (§ call assertLessThanN(§ pars ilInt, "Illegal derived key: I_L >= n"))

        #_final
        (§ var BigInteger priv = parent.getPrivKey(§ pars ))
        (§ var BigInteger ki = priv.add(§ pars ilInt).mod(§ pars ECKey.CURVE.getN(§ pars )))
        (§ call assertNonZero(§ pars ki, "Illegal derived key: derived private key equals 0."))

        (§ return (§ new RawKeyBytes(§ pars ki.toByteArray(§ pars ), chainCode)))
    )

    #_public
    (§ enum PublicDeriveMode
        (§ item NORMAL)
        (§ item WITH_INVERSION)
    )

    #_public
    #_static
    (§ method RawKeyBytes deriveChildKeyBytesFromPublic(§ args DeterministicKey parent, ChildNumber childNumber, PublicDeriveMode mode))
        (§ throws HDDerivationException)
    (§ block
        (§ call Preconditions.checkArgument(§ pars !childNumber.isHardened(§ pars ), "Can't use private derivation with public keys only."))

        (§ var byte[] parentPublicKey = parent.getPubKeyPoint(§ pars ).getEncoded(§ pars true))
        (§ call Preconditions.checkState(§ pars parentPublicKey.length == 33, "Parent pubkey must be 33 bytes, but is " + parentPublicKey.length))

        (§ var ByteBuffer data = ByteBuffer.allocate(§ pars 37))
        (§ call data.put(§ pars parentPublicKey))
        (§ call data.putInt(§ pars childNumber.i(§ pars )))

        (§ var byte[] i = HDUtils.hmacSha512(§ pars parent.getChainCode(§ pars ), data.array(§ pars )))
        (§ call Preconditions.checkState(§ pars i.length == 64, i.length))

        (§ var byte[] il = Arrays.copyOfRange(§ pars i, 0, 32))
        (§ var byte[] chainCode = Arrays.copyOfRange(§ pars i, 32, 64))
        (§ var BigInteger ilInt = new BigInteger(§ pars 1, il))
        (§ call assertLessThanN(§ pars ilInt, "Illegal derived key: I_L >= n"))

        #_final
        (§ var BigInteger N = ECKey.CURVE.getN(§ pars ))
        (§ var ECPoint Ki)
        (§ switch (§ expr mode))
        (§ block
            (§ case NORMAL)
            (§ block
                (§ ass Ki = ECKey.publicPointFromPrivate(§ pars ilInt).add(§ pars parent.getPubKeyPoint(§ pars )))
                (§ break )
            )
            (§ case WITH_INVERSION)
            (§ block
                ;; This trick comes from Gregory Maxwell.  Check the homomorphic properties of our curve hold.  The
                ;; below calculations should be redundant and give the same result as NORMAL but if the precalculated
                ;; tables have taken a bit flip will yield a different answer.  This mode is used when vending a key
                ;; to perform a last-ditch sanity check trying to catch bad RAM.
                (§ ass Ki = ECKey.publicPointFromPrivate(§ pars ilInt.add(§ pars RAND_INT).mod(§ pars N)))
                (§ var BigInteger additiveInverse = RAND_INT.negate(§ pars ).mod(§ pars N))
                (§ ass Ki = Ki.add(§ pars ECKey.publicPointFromPrivate(§ pars additiveInverse)))
                (§ ass Ki = Ki.add(§ pars parent.getPubKeyPoint(§ pars )))
                (§ break )
            )
            (§ default )
            (§ block
                (§ throw (§ new AssertionError(§ pars )))
            )
        )

        (§ call assertNonInfinity(§ pars Ki, "Illegal derived key: derived public key equals infinity."))
        (§ return (§ new RawKeyBytes(§ pars Ki.getEncoded(§ pars true), chainCode)))
    )

    #_private
    #_static
    (§ method void assertNonZero(§ args BigInteger integer, String errorMessage))
    (§ block
        (§ if (§ expr integer.equals(§ pars BigInteger.ZERO)))
        (§ block
            (§ throw (§ new HDDerivationException(§ pars errorMessage)))
        )
    )

    #_private
    #_static
    (§ method void assertNonInfinity(§ args ECPoint point, String errorMessage))
    (§ block
        (§ if (§ expr point.equals(§ pars ECKey.CURVE.getCurve(§ pars ).getInfinity(§ pars ))))
        (§ block
            (§ throw (§ new HDDerivationException(§ pars errorMessage)))
        )
    )

    #_private
    #_static
    (§ method void assertLessThanN(§ args BigInteger integer, String errorMessage))
    (§ block
        (§ if (§ expr integer.compareTo(§ pars ECKey.CURVE.getN(§ pars )) > 0))
        (§ block
            (§ throw (§ new HDDerivationException(§ pars errorMessage)))
        )
    )

    #_public
    #_static
    (§ class RawKeyBytes
        #_public
        #_final
        (§ field byte[] keyBytes, chainCode)

        #_public
        (§ constructor RawKeyBytes(§ args byte[] keyBytes, byte[] chainCode))
        (§ block
            (§ ass this.keyBytes = keyBytes)
            (§ ass this.chainCode = chainCode)
        )
    )
)

#_(ns org.bitcoinj.crypto #_"HDUtils"
    (:import [java.nio ByteBuffer]
             [java.util ArrayList Arrays Collections List])
    (:import [com.google.common.base Joiner]
             [com.google.common.collect ImmutableList Iterables]
             [org.spongycastle.crypto.digests SHA512Digest]
             [org.spongycastle.crypto.macs HMac]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core ECKey]))

;;;
 ; Static utilities used in BIP 32 Hierarchical Deterministic Wallets (HDW).
 ;;
#_public
#_final
(§ class HDUtils
    #_private
    #_static
    #_final
    (§ field Joiner PATH_JOINER = Joiner.on(§ pars "/"))

    #_static
    (§ method HMac createHmacSha512Digest(§ args byte[] key))
    (§ block
        (§ var SHA512Digest digest = new SHA512Digest(§ pars ))
        (§ var HMac hMac = new HMac(§ pars digest))
        (§ call hMac.init(§ pars (§ new KeyParameter(§ pars key))))
        (§ return hMac)
    )

    #_static
    (§ method byte[] hmacSha512(§ args HMac hmacSha512, byte[] input))
    (§ block
        (§ call hmacSha512.reset(§ pars ))
        (§ call hmacSha512.update(§ pars input, 0, input.length))
        (§ var byte[] out = new byte[64])
        (§ call hmacSha512.doFinal(§ pars out, 0))
        (§ return out)
    )

    #_public
    #_static
    (§ method byte[] hmacSha512(§ args byte[] key, byte[] data))
    (§ block
        (§ return hmacSha512(§ pars createHmacSha512Digest(§ pars key), data))
    )

    #_static
    (§ method byte[] toCompressed(§ args byte[] uncompressedPoint))
    (§ block
        (§ return ECKey.CURVE.getCurve(§ pars ).decodePoint(§ pars uncompressedPoint).getEncoded(§ pars true))
    )

    #_static
    (§ method byte[] longTo4ByteArray(§ args long n))
    (§ block
        (§ var byte[] bytes = Arrays.copyOfRange(§ pars ByteBuffer.allocate(§ pars 8).putLong(§ pars n).array(§ pars ), 4, 8))
        (§ assert (§ expr bytes.length == 4) :assert bytes.length)
        (§ return bytes)
    )

    ;;; Append a derivation level to an existing path. ;;
    #_public
    #_static
    (§ method ImmutableList<ChildNumber> append(§ args List<ChildNumber> path, ChildNumber childNumber))
    (§ block
        (§ return ImmutableList.<ChildNumber>builder(§ pars ).addAll(§ pars path).add(§ pars childNumber).build(§ pars ))
    )

    ;;; Concatenate two derivation paths. ;;
    #_public
    #_static
    (§ method ImmutableList<ChildNumber> concat(§ args List<ChildNumber> path, List<ChildNumber> path2))
    (§ block
        (§ return ImmutableList.<ChildNumber>builder(§ pars ).addAll(§ pars path).addAll(§ pars path2).build(§ pars ))
    )

    ;;; Convert to a string path, starting with "M/". ;;
    #_public
    #_static
    (§ method String formatPath(§ args List<ChildNumber> path))
    (§ block
        (§ return PATH_JOINER.join(§ pars Iterables.concat(§ pars Collections.singleton(§ pars "M"), path)))
    )

    ;;;
     ; The path is a human-friendly representation of the deterministic path.  For example:
     ;
     ; "44H / 0H / 0H / 1 / 1"
     ;
     ; Where a letter "H" means hardened key.  Spaces are ignored.
     ;;
    #_public
    #_static
    (§ method List<ChildNumber> parsePath(§ args #_non-nil String path))
    (§ block
        (§ var String[] parsedNodes = path.replace(§ pars "M", "").split(§ pars "/"))
        (§ var List<ChildNumber> nodes = new ArrayList<>(§ pars ))

        (§ for (§ var String n) :for (§ expr parsedNodes))
        (§ block
            (§ ass n = n.replaceAll(§ pars " ", ""))
            (§ if (§ expr n.length(§ pars ) != 0))
            (§ block
                (§ var boolean isHard = n.endsWith(§ pars "H"))
                (§ if (§ expr isHard))
                (§ block
                    (§ ass n = n.substring(§ pars 0, n.length(§ pars ) - 1))
                )
                (§ var int nodeNumber = Integer.parseInt(§ pars n))
                (§ call nodes.add(§ pars (§ new ChildNumber(§ pars nodeNumber, isHard))))
            )
        )

        (§ return nodes)
    )
)

#_(ns org.bitcoinj.crypto #_"KeyCrypter"
    (:import [java.io Serializable])
    (:import [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.wallet.Protos.Wallet EncryptionType]))

;;;
 ; <p>A KeyCrypter can be used to encrypt and decrypt a message.  The sequence of events to encrypt and then decrypt
 ; a message are as follows:</p>
 ;
 ; <p>(1) Ask the user for a password.  deriveKey() is then called to create an KeyParameter.  This contains the AES
 ; key that will be used for encryption.</p>
 ; <p>(2) Encrypt the message using encrypt(), providing the message bytes and the KeyParameter from (1).  This returns
 ; an EncryptedData which contains the encryptedPrivateKey bytes and an initialisation vector.</p>
 ; <p>(3) To decrypt an EncryptedData, repeat step (1) to get a KeyParameter, then call decrypt().</p>
 ;
 ; <p>There can be different algorithms used for encryption/ decryption so the getUnderstoodEncryptionType is used
 ; to determine whether any given KeyCrypter can understand the type of encrypted data you have.</p>
 ;;
#_public
(§ interface KeyCrypter extends Serializable
    ;;;
     ; Return the EncryptionType enum value which denotes the type of encryption/ decryption that this KeyCrypter
     ; can understand.
     ;;
    (§ method EncryptionType getUnderstoodEncryptionType(§ args ))

    ;;;
     ; Create a KeyParameter (which typically contains an AES key).
     ; @param password
     ; @return the KeyParameter which typically contains the AES key to use for encrypting and decrypting.
     ; @throws KeyCrypterException
     ;;
    (§ method KeyParameter deriveKey(§ args CharSequence password))
        (§ throws KeyCrypterException)

    ;;;
     ; Decrypt the provided encrypted bytes, converting them into unencrypted bytes.
     ;
     ; @throws KeyCrypterException if decryption was unsuccessful.
     ;;
    (§ method byte[] decrypt(§ args EncryptedData encryptedBytesToDecode, KeyParameter aesKey))
        (§ throws KeyCrypterException)

    ;;;
     ; Encrypt the supplied bytes, converting them into ciphertext.
     ;
     ; @return an encryptedPrivateKey containing the encrypted bytes and an initialisation vector.
     ; @throws KeyCrypterException if encryption was unsuccessful.
     ;;
    (§ method EncryptedData encrypt(§ args byte[] plainBytes, KeyParameter aesKey))
        (§ throws KeyCrypterException)
)

#_(ns org.bitcoinj.crypto #_"KeyCrypterException")

;;;
 ; <p>Exception to provide the following:</p>
 ; <ul>
 ; <li>Provision of encryption / decryption exception.</li>
 ; </ul>
 ; <p>This base exception acts as a general failure mode not attributable to a specific cause (other than
 ; that reported in the exception message).  Since this is in English, it may not be worth reporting directly
 ; to the user other than as part of a "general failure to parse" response.</p>
 ;;
#_public
(§ class KeyCrypterException extends RuntimeException
    #_public
    (§ constructor KeyCrypterException(§ args String s))
    (§ block
        (§ super (§ pars s))
    )

    #_public
    (§ constructor KeyCrypterException(§ args String s, Throwable throwable))
    (§ block
        (§ super (§ pars s, throwable))
    )
)

#_(ns org.bitcoinj.crypto #_"KeyCrypterScrypt"
    (:import [java.security SecureRandom]
             [java.util Arrays])
    (:import [com.google.common.base Objects Preconditions Stopwatch]
             [com.google.protobuf ByteString]
             [com.lambdaworks.crypto SCrypt]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto BufferedBlockCipher]
             [org.spongycastle.crypto.engines AESFastEngine]
             [org.spongycastle.crypto.modes CBCBlockCipher]
             [org.spongycastle.crypto.paddings PaddedBufferedBlockCipher]
             [org.spongycastle.crypto.params KeyParameter ParametersWithIV])
   (:require [org.bitcoinj.core Utils]
             [org.bitcoinj.wallet Protos]
             [org.bitcoinj.wallet.Protos ScryptParameters]
             [org.bitcoinj.wallet.Protos.Wallet EncryptionType]))

;;;
 ; <p>This class encrypts and decrypts byte arrays and strings using scrypt as the
 ; key derivation function and AES for the encryption.</p>
 ;
 ; <p>You can use this class to:</p>
 ;
 ; <p>1. Using a user password, create an AES key that can encrypt and decrypt your private keys.
 ; To convert the password to the AES key, scrypt is used.  This is an algorithm resistant
 ; to brute force attacks.  You can use the ScryptParameters to tune how difficult you
 ; want this to be generation to be.</p>
 ;
 ; <p>2. Using the AES Key generated above, you then can encrypt and decrypt any bytes using
 ; the AES symmetric cipher.  Eight bytes of salt is used to prevent dictionary attacks.</p>
 ;;
#_public
(§ class KeyCrypterScrypt implements KeyCrypter
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars KeyCrypterScrypt.class))

    ;;;
     ; Key length in bytes.
     ;;
    #_public
    #_static
    #_final
    (§ field int KEY_LENGTH = 32) ;; = 256 bits.

    ;;;
     ; The size of an AES block in bytes.
     ; This is also the length of the initialisation vector.
     ;;
    #_public
    #_static
    #_final
    (§ field int BLOCK_LENGTH = 16) ;; = 128 bits.

    ;;;
     ; The length of the salt used.
     ;;
    #_public
    #_static
    #_final
    (§ field int SALT_LENGTH = 8)

    #_static
    (§ block
        ;; Init proper random number generator, as some old Android installations have bugs that make it unsecure.
        (§ if (§ expr Utils.isAndroidRuntime(§ pars )))
        (§ block
            (§ call (§ new LinuxSecureRandom(§ pars )))
        )

        (§ ass secureRandom = new SecureRandom(§ pars ))
    )

    #_private
    #_static
    #_final
    (§ field SecureRandom secureRandom)

    ;;; Returns SALT_LENGTH (8) bytes of random data. ;;
    #_public
    #_static
    (§ method byte[] randomSalt(§ args ))
    (§ block
        (§ var byte[] salt = new byte[SALT_LENGTH])
        (§ call secureRandom.nextBytes(§ pars salt))
        (§ return salt)
    )

    ;; Scrypt parameters.
    #_private
    #_final
    (§ field ScryptParameters scryptParameters)

    ;;;
     ; Encryption/Decryption using default parameters and a random salt.
     ;;
    #_public
    (§ constructor KeyCrypterScrypt(§ args ))
    (§ block
        (§ var Protos.ScryptParameters.Builder builder = Protos.ScryptParameters.newBuilder(§ pars ).setSalt(§ pars ByteString.copyFrom(§ pars randomSalt(§ pars ))))
        (§ ass this.scryptParameters = builder.build(§ pars ))
    )

    ;;;
     ; Encryption/Decryption using custom number of iterations parameters and a random salt.
     ; As of August 2016, a useful value for mobile devices is 4096 (derivation takes about 1 second).
     ;
     ; @param iterations Number of scrypt iterations.
     ;;
    #_public
    (§ constructor KeyCrypterScrypt(§ args int iterations))
    (§ block
        (§ var Protos.ScryptParameters.Builder builder = Protos.ScryptParameters.newBuilder(§ pars ).setSalt(§ pars ByteString.copyFrom(§ pars randomSalt(§ pars ))).setN(§ pars iterations))
        (§ ass this.scryptParameters = builder.build(§ pars ))
    )

    ;;;
     ; Encryption/ Decryption using specified Scrypt parameters.
     ;
     ; @param scryptParameters ScryptParameters to use.
     ; @throws NullPointerException if the scryptParameters or any of its N, R or P is null.
     ;;
    #_public
    (§ constructor KeyCrypterScrypt(§ args ScryptParameters scryptParameters))
    (§ block
        (§ ass this.scryptParameters = Preconditions.checkNotNull(§ pars scryptParameters))

        ;; Check there is a non-empty salt.  Some early MultiBit wallets has a missing salt, so it is not a hard fail.
        (§ if (§ expr scryptParameters.getSalt(§ pars ) == nil || scryptParameters.getSalt(§ pars ).toByteArray(§ pars ) == nil || scryptParameters.getSalt(§ pars ).toByteArray(§ pars ).length == 0))
        (§ block
            (§ call log.warn(§ pars "You are using a ScryptParameters with no salt. Your encryption may be vulnerable to a dictionary attack."))
        )
    )

    ;;;
     ; Generate AES key.
     ;
     ; This is a very slow operation compared to encrypt/ decrypt so it is normally worth caching the result.
     ;
     ; @param password The password to use in key generation.
     ; @return the KeyParameter containing the created AES key.
     ; @throws KeyCrypterException
     ;;
    #_override
    #_public
    (§ method KeyParameter deriveKey(§ args CharSequence password))
        (§ throws KeyCrypterException)
    (§ block
        (§ var byte[] passwordBytes = nil)
        (§ try )
        (§ block
            (§ ass passwordBytes = convertToByteArray(§ pars password))
            (§ var byte[] salt = new byte[0])
            (§ if (§ expr scryptParameters.getSalt(§ pars ) != nil))
            (§ block
                (§ ass salt = scryptParameters.getSalt(§ pars ).toByteArray(§ pars ))
            )
            (§ else )
            (§ block
                ;; Warn the user that they are not using a salt.  Some early MultiBit wallets had a blank salt.
                (§ call log.warn(§ pars "You are using a ScryptParameters with no salt. Your encryption may be vulnerable to a dictionary attack."))
            )

            #_final
            (§ var Stopwatch watch = Stopwatch.createStarted(§ pars ))
            (§ var byte[] keyBytes = SCrypt.scrypt(§ pars passwordBytes, salt, (§ cast int)scryptParameters.getN(§ pars ), scryptParameters.getR(§ pars ), scryptParameters.getP(§ pars ), KEY_LENGTH))
            (§ call watch.stop(§ pars ))
            (§ call log.info(§ pars "Deriving key took {} for {} scrypt iterations.", watch, scryptParameters.getN(§ pars )))
            (§ return (§ new KeyParameter(§ pars keyBytes)))
        )
        (§ catch (§ args Exception e))
        (§ block
            (§ throw (§ new KeyCrypterException(§ pars "Could not generate key from password and salt.", e)))
        )
        (§ finally )
        (§ block
            ;; Zero the password bytes.
            (§ if (§ expr passwordBytes != nil))
            (§ block
                (§ call java.util.Arrays.fill(§ pars passwordBytes, (§ cast byte)0))
            )
        )
    )

    ;;;
     ; Password based encryption using AES - CBC 256 bits.
     ;;
    #_override
    #_public
    (§ method EncryptedData encrypt(§ args byte[] plainBytes, KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars plainBytes))
        (§ call Preconditions.checkNotNull(§ pars aesKey))

        (§ try )
        (§ block
            ;; Generate iv - each encryption call has a different iv.
            (§ var byte[] iv = new byte[BLOCK_LENGTH])
            (§ call secureRandom.nextBytes(§ pars iv))

            (§ var ParametersWithIV keyWithIv = new ParametersWithIV(§ pars aesKey, iv))

            ;; Encrypt using AES.
            (§ var BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(§ pars (§ new CBCBlockCipher(§ pars (§ new AESFastEngine(§ pars ))))))
            (§ call cipher.init(§ pars true, keyWithIv))
            (§ var byte[] encryptedBytes = new byte[cipher.getOutputSize(§ pars plainBytes.length)])
            #_final
            (§ var int length1 = cipher.processBytes(§ pars plainBytes, 0, plainBytes.length, encryptedBytes, 0))
            #_final
            (§ var int length2 = cipher.doFinal(§ pars encryptedBytes, length1))

            (§ return (§ new EncryptedData(§ pars iv, Arrays.copyOf(§ pars encryptedBytes, length1 + length2))))
        )
        (§ catch (§ args Exception e))
        (§ block
            (§ throw (§ new KeyCrypterException(§ pars "Could not encrypt bytes.", e)))
        )
    )

    ;;;
     ; Decrypt bytes previously encrypted with this class.
     ;
     ; @param dataToDecrypt The data to decrypt.
     ; @param aesKey The AES key to use for decryption.
     ; @return the decrypted bytes.
     ; @throws KeyCrypterException if bytes could not be decrypted.
     ;;
    #_override
    #_public
    (§ method byte[] decrypt(§ args EncryptedData dataToDecrypt, KeyParameter aesKey))
        (§ throws KeyCrypterException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars dataToDecrypt))
        (§ call Preconditions.checkNotNull(§ pars aesKey))

        (§ try )
        (§ block
            (§ var ParametersWithIV keyWithIv = new ParametersWithIV(§ pars (§ new KeyParameter(§ pars aesKey.getKey(§ pars ))), dataToDecrypt.initialisationVector))

            ;; Decrypt the message.
            (§ var BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(§ pars (§ new CBCBlockCipher(§ pars (§ new AESFastEngine(§ pars ))))))
            (§ call cipher.init(§ pars false, keyWithIv))

            (§ var byte[] cipherBytes = dataToDecrypt.encryptedBytes)
            (§ var byte[] decryptedBytes = new byte[cipher.getOutputSize(§ pars cipherBytes.length)])
            #_final
            (§ var int length1 = cipher.processBytes(§ pars cipherBytes, 0, cipherBytes.length, decryptedBytes, 0))
            #_final
            (§ var int length2 = cipher.doFinal(§ pars decryptedBytes, length1))

            (§ return Arrays.copyOf(§ pars decryptedBytes, length1 + length2))
        )
        (§ catch (§ args Exception e))
        (§ block
            (§ throw (§ new KeyCrypterException(§ pars "Could not decrypt bytes", e)))
        )
    )

    ;;;
     ; Convert a CharSequence (which are UTF16) into a byte array.
     ;
     ; Note: a String.getBytes() is not used to avoid creating a String of the password in the JVM.
     ;;
    #_private
    #_static
    (§ method byte[] convertToByteArray(§ args CharSequence charSequence))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars charSequence))

        (§ var byte[] byteArray = new byte[charSequence.length(§ pars ) << 1])
        (§ for (§ var int i = 0) :for (§ expr i < charSequence.length(§ pars )) :for (§ ass i = i + 1))
        (§ block
            (§ var int bytePosition = i << 1)
            (§ ass byteArray[bytePosition] = (§ cast byte)(§ expr (§ expr charSequence.charAt(§ pars i) & 0xff00) >> 8))
            (§ ass byteArray[bytePosition + 1] = (§ cast byte)(§ expr charSequence.charAt(§ pars i) & 0x00ff))
        )
        (§ return byteArray)
    )

    #_public
    (§ method ScryptParameters getScryptParameters(§ args ))
    (§ block
        (§ return scryptParameters)
    )

    ;;;
     ; Return the EncryptionType enum value which denotes the type of encryption/ decryption that this KeyCrypter
     ; can understand.
     ;;
    #_override
    #_public
    (§ method EncryptionType getUnderstoodEncryptionType(§ args ))
    (§ block
        (§ return EncryptionType.ENCRYPTED_SCRYPT_AES)
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return "AES-" + KEY_LENGTH * 8 + "-CBC, Scrypt (N: " + scryptParameters.getN(§ pars ) + ")")
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars scryptParameters))
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return Objects.equal(§ pars scryptParameters, (§ expr (§ cast KeyCrypterScrypt)o).scryptParameters))
    )
)

#_(ns org.bitcoinj.crypto #_"LazyECPoint"
    (:import [java.math BigInteger]
             [java.util Arrays])
    (:import [com.google.common.base Preconditions]
             [org.spongycastle.math.ec ECCurve ECFieldElement ECPoint]))

;;;
 ; A wrapper around ECPoint that delays decoding of the point for as long as possible.  This is useful because point
 ; encode/decode in Bouncy Castle is quite slow especially on Dalvik, as it often involves decompression/recompression.
 ;;
#_public
(§ class LazyECPoint
    ;; If curve is set, bits is also set.  If curve is unset, point is set and bits is unset.  Point can be set along
    ;; with curve and bits when the cached form has been accessed and thus must have been converted.
    #_private
    #_final
    (§ field ECCurve curve)
    #_private
    #_final
    (§ field byte[] bits)

    ;; This field is effectively final - once set it won't change again.  However it can be set after construction.
    #_nilable
    #_private
    (§ field ECPoint point)

    #_public
    (§ constructor LazyECPoint(§ args ECCurve curve, byte[] bits))
    (§ block
        (§ ass this.curve = curve)
        (§ ass this.bits = bits)
    )

    #_public
    (§ constructor LazyECPoint(§ args ECPoint point))
    (§ block
        (§ ass this.point = Preconditions.checkNotNull(§ pars point))
        (§ ass this.curve = nil)
        (§ ass this.bits = nil)
    )

    #_public
    (§ method ECPoint get(§ args ))
    (§ block
        (§ if (§ expr point == nil))
        (§ block
            (§ ass point = curve.decodePoint(§ pars bits))
        )
        (§ return point)
    )

    ;; Delegated methods.

    #_public
    (§ method ECPoint getDetachedPoint(§ args ))
    (§ block
        (§ return get(§ pars ).getDetachedPoint(§ pars ))
    )

    #_public
    (§ method byte[] getEncoded(§ args ))
    (§ block
        (§ if (§ expr bits != nil))
        (§ block
            (§ return Arrays.copyOf(§ pars bits, bits.length))
        )
        (§ else )
        (§ block
            (§ return get(§ pars ).getEncoded(§ pars ))
        )
    )

    #_public
    (§ method boolean isInfinity(§ args ))
    (§ block
        (§ return get(§ pars ).isInfinity(§ pars ))
    )

    #_public
    (§ method ECPoint timesPow2(§ args int e))
    (§ block
        (§ return get(§ pars ).timesPow2(§ pars e))
    )

    #_public
    (§ method ECFieldElement getYCoord(§ args ))
    (§ block
        (§ return get(§ pars ).getYCoord(§ pars ))
    )

    #_public
    (§ method ECFieldElement[] getZCoords(§ args ))
    (§ block
        (§ return get(§ pars ).getZCoords(§ pars ))
    )

    #_public
    (§ method boolean isNormalized(§ args ))
    (§ block
        (§ return get(§ pars ).isNormalized(§ pars ))
    )

    #_public
    (§ method boolean isCompressed(§ args ))
    (§ block
        (§ if (§ expr bits != nil))
        (§ block
            (§ return (§ expr bits[0] == 2 || bits[0] == 3))
        )
        (§ else )
        (§ block
            (§ return get(§ pars ).isCompressed(§ pars ))
        )
    )

    #_public
    (§ method ECPoint multiply(§ args BigInteger k))
    (§ block
        (§ return get(§ pars ).multiply(§ pars k))
    )

    #_public
    (§ method ECPoint subtract(§ args ECPoint b))
    (§ block
        (§ return get(§ pars ).subtract(§ pars b))
    )

    #_public
    (§ method boolean isValid(§ args ))
    (§ block
        (§ return get(§ pars ).isValid(§ pars ))
    )

    #_public
    (§ method ECPoint scaleY(§ args ECFieldElement scale))
    (§ block
        (§ return get(§ pars ).scaleY(§ pars scale))
    )

    #_public
    (§ method ECFieldElement getXCoord(§ args ))
    (§ block
        (§ return get(§ pars ).getXCoord(§ pars ))
    )

    #_public
    (§ method ECPoint scaleX(§ args ECFieldElement scale))
    (§ block
        (§ return get(§ pars ).scaleX(§ pars scale))
    )

    #_public
    (§ method boolean equals(§ args ECPoint other))
    (§ block
        (§ return get(§ pars ).equals(§ pars other))
    )

    #_public
    (§ method ECPoint negate(§ args ))
    (§ block
        (§ return get(§ pars ).negate(§ pars ))
    )

    #_public
    (§ method ECPoint threeTimes(§ args ))
    (§ block
        (§ return get(§ pars ).threeTimes(§ pars ))
    )

    #_public
    (§ method ECFieldElement getZCoord(§ args int index))
    (§ block
        (§ return get(§ pars ).getZCoord(§ pars index))
    )

    #_public
    (§ method byte[] getEncoded(§ args boolean compressed))
    (§ block
        (§ if (§ expr compressed == isCompressed(§ pars ) && bits != nil))
        (§ block
            (§ return Arrays.copyOf(§ pars bits, bits.length))
        )
        (§ else )
        (§ block
            (§ return get(§ pars ).getEncoded(§ pars compressed))
        )
    )

    #_public
    (§ method ECPoint add(§ args ECPoint b))
    (§ block
        (§ return get(§ pars ).add(§ pars b))
    )

    #_public
    (§ method ECPoint twicePlus(§ args ECPoint b))
    (§ block
        (§ return get(§ pars ).twicePlus(§ pars b))
    )

    #_public
    (§ method ECCurve getCurve(§ args ))
    (§ block
        (§ return get(§ pars ).getCurve(§ pars ))
    )

    #_public
    (§ method ECPoint normalize(§ args ))
    (§ block
        (§ return get(§ pars ).normalize(§ pars ))
    )

    #_public
    (§ method ECFieldElement getY(§ args ))
    (§ block
        (§ return this.normalize(§ pars ).getYCoord(§ pars ))
    )

    #_public
    (§ method ECPoint twice(§ args ))
    (§ block
        (§ return get(§ pars ).twice(§ pars ))
    )

    #_public
    (§ method ECFieldElement getAffineYCoord(§ args ))
    (§ block
        (§ return get(§ pars ).getAffineYCoord(§ pars ))
    )

    #_public
    (§ method ECFieldElement getAffineXCoord(§ args ))
    (§ block
        (§ return get(§ pars ).getAffineXCoord(§ pars ))
    )

    #_public
    (§ method ECFieldElement getX(§ args ))
    (§ block
        (§ return this.normalize(§ pars ).getXCoord(§ pars ))
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return Arrays.equals(§ pars getCanonicalEncoding(§ pars ), (§ expr (§ cast LazyECPoint)o).getCanonicalEncoding(§ pars )))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Arrays.hashCode(§ pars getCanonicalEncoding(§ pars )))
    )

    #_private
    (§ method byte[] getCanonicalEncoding(§ args ))
    (§ block
        (§ return getEncoded(§ pars true))
    )
)

#_(ns org.bitcoinj.crypto #_"LinuxSecureRandom"
    (:import [java.io *]
             [java.security *])
    (:import [org.slf4j *]))

;;;
 ; A SecureRandom implementation that is able to override the standard JVM provided implementation, and which simply
 ; serves random numbers by reading /dev/urandom.  That is, it delegates to the kernel on UNIX systems and is unusable
 ; on other platforms.  Attempts to manually set the seed are ignored.  There is no difference between seed bytes and
 ; non-seed bytes, they are all from the same source.
 ;;
#_public
(§ class LinuxSecureRandom extends SecureRandomSpi
    #_private
    #_static
    #_final
    (§ field FileInputStream urandom)

    #_private
    #_static
    (§ class LinuxSecureRandomProvider extends Provider
        #_public
        (§ constructor LinuxSecureRandomProvider(§ args ))
        (§ block
            (§ super (§ pars "LinuxSecureRandom", 1.0, "A Linux specific random number provider that uses /dev/urandom"))

            (§ call put(§ pars "SecureRandom.LinuxSecureRandom", LinuxSecureRandom.class.getName(§ pars )))
        )
    )

    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars LinuxSecureRandom.class))

    #_static
    (§ block
        (§ try )
        (§ block
            (§ var File file = new File(§ pars "/dev/urandom"))
            ;; This stream is deliberately leaked.
            (§ ass urandom = new FileInputStream(§ pars file))
            (§ if (§ expr urandom.read(§ pars ) == -1))
            (§ block
                (§ throw (§ new RuntimeException(§ pars "/dev/urandom not readable?")))
            )

            ;; Now override the default SecureRandom implementation with this one.
            (§ var int position = Security.insertProviderAt(§ pars (§ new LinuxSecureRandomProvider(§ pars )), 1))

            (§ if (§ expr position != -1))
            (§ block
                (§ call log.info(§ pars "Secure randomness will be read from {} only.", file))
            )
            (§ else )
            (§ block
                (§ call log.info(§ pars "Randomness is already secure."))
            )
        )
        (§ catch (§ args FileNotFoundException e))
        (§ block
            ;; Should never happen.
            (§ call log.error(§ pars "/dev/urandom does not appear to exist or is not openable"))
            (§ throw (§ new RuntimeException(§ pars e)))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ call log.error(§ pars "/dev/urandom does not appear to be readable"))
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )

    #_private
    #_final
    (§ field DataInputStream dis)

    #_public
    (§ constructor LinuxSecureRandom(§ args ))
    (§ block
        ;; DataInputStream is not thread safe, so each random object has its own.
        (§ ass dis = new DataInputStream(§ pars urandom))
    )

    #_override
    #_protected
    (§ method void engineSetSeed(§ args byte[] bytes))
    (§ block
        ;; Ignore.
    )

    #_override
    #_protected
    (§ method void engineNextBytes(§ args byte[] bytes))
    (§ block
        (§ try )
        (§ block
            (§ call dis.readFully(§ pars bytes)) ;; This will block until all the bytes can be read.
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Fatal error.  Do not attempt to recover from this.
        )
    )

    #_override
    #_protected
    (§ method byte[] engineGenerateSeed(§ args int i))
    (§ block
        (§ var byte[] bits = new byte[i])
        (§ call engineNextBytes(§ pars bits))
        (§ return bits)
    )
)

#_(ns org.bitcoinj.crypto #_"MnemonicCode"
    (:import [java.io BufferedReader FileNotFoundException IOException InputStream InputStreamReader]
             [java.security MessageDigest]
             [java.util ArrayList Collections List])
    (:import [com.google.common.base Stopwatch]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core Sha256Hash Utils]
             #_static [org.bitcoinj.core.Utils HEX]))

;;;
 ; A MnemonicCode object may be used to convert between binary seed values and lists of words per
 ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">the BIP 39 specification</a>.
 ;;

#_public
(§ class MnemonicCode
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars MnemonicCode.class))

    #_private
    (§ field ArrayList<String> wordList)

    #_private
    #_static
    #_final
    (§ field String BIP39_ENGLISH_RESOURCE_NAME = "mnemonic/wordlist/english.txt")
    #_private
    #_static
    #_final
    (§ field String BIP39_ENGLISH_SHA256 = "ad90bf3beb7b0eb7e5acd74727dc0da96e0a280a258354e7293fb7e211ac03db")

    ;;; UNIX time for when the BIP39 standard was finalised.  This can be used as a default seed birthday. ;;
    #_public
    #_static
    (§ field long BIP39_STANDARDISATION_TIME_SECS = 1381276800)

    #_private
    #_static
    #_final
    (§ field int PBKDF2_ROUNDS = 2048)

    #_public
    #_static
    (§ field MnemonicCode INSTANCE)

    #_static
    (§ block
        (§ try )
        (§ block
            (§ ass INSTANCE = new MnemonicCode(§ pars ))
        )
        (§ catch (§ args FileNotFoundException e))
        (§ block
            ;; We expect failure on Android.  The developer has to set INSTANCE themselves.
            (§ if (§ expr !Utils.isAndroidRuntime(§ pars )))
            (§ block
                (§ call log.error(§ pars "Could not find word list", e))
            )
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ call log.error(§ pars "Failed to load word list", e))
        )
    )

    ;;; Initialise from the included word list.  Won't work on Android. ;;
    #_public
    (§ constructor MnemonicCode(§ args ))
        (§ throws IOException)
    (§ block
        (§ this (§ pars openDefaultWords(§ pars ), BIP39_ENGLISH_SHA256))
    )

    #_private
    #_static
    (§ method InputStream openDefaultWords(§ args ))
        (§ throws IOException)
    (§ block
        (§ var InputStream stream = MnemonicCode.class.getResourceAsStream(§ pars BIP39_ENGLISH_RESOURCE_NAME))
        (§ if (§ expr stream == nil))
        (§ block
            (§ throw (§ new FileNotFoundException(§ pars BIP39_ENGLISH_RESOURCE_NAME)))
        )
        (§ return stream)
    )

    ;;;
     ; Creates an MnemonicCode object, initializing with words read from the supplied input stream.
     ; If a wordListDigest is supplied, the digest of the words will be checked.
     ;;
    #_public
    (§ constructor MnemonicCode(§ args InputStream wordstream, String wordListDigest))
        (§ throws IOException, IllegalArgumentException)
    (§ block
        (§ var BufferedReader br = new BufferedReader(§ pars (§ new InputStreamReader(§ pars wordstream, "UTF-8"))))
        (§ ass this.wordList = new ArrayList<>(§ pars 2048))
        (§ var MessageDigest md = Sha256Hash.newDigest(§ pars ))
        (§ var String word)
        (§ while (§ expr (§ ass word = br.readLine(§ pars )) != nil))
        (§ block
            (§ call md.update(§ pars word.getBytes(§ pars )))
            (§ call this.wordList.add(§ pars word))
        )
        (§ call br.close(§ pars ))

        (§ if (§ expr this.wordList.size(§ pars ) != 2048))
        (§ block
            (§ throw (§ new IllegalArgumentException(§ pars "input stream did not contain 2048 words")))
        )

        ;; If a wordListDigest is supplied, check to make sure it matches.
        (§ if (§ expr wordListDigest != nil))
        (§ block
            (§ var byte[] digest = md.digest(§ pars ))
            (§ var String hexdigest = HEX.encode(§ pars digest))
            (§ if (§ expr !hexdigest.equals(§ pars wordListDigest)))
            (§ block
                (§ throw (§ new IllegalArgumentException(§ pars "wordlist digest mismatch")))
            )
        )
    )

    ;;;
     ; Gets the word list this code uses.
     ;;
    #_public
    (§ method List<String> getWordList(§ args ))
    (§ block
        (§ return wordList)
    )

    ;;;
     ; Convert mnemonic word list to seed.
     ;;
    #_public
    #_static
    (§ method byte[] toSeed(§ args List<String> words, String passphrase))
    (§ block
        ;; To create binary seed from mnemonic, we use PBKDF2 function with mnemonic sentence (in UTF-8) used as a password
        ;; and string "mnemonic" + passphrase (again in UTF-8) used as a salt.  Iteration count is set to 4096 and HMAC-SHA512
        ;; is used as a pseudo-random function.  Desired length of the derived key is 512 bits (= 64 bytes).

        (§ var String pass = Utils.SPACE_JOINER.join(§ pars words))
        (§ var String salt = "mnemonic" + passphrase)

        #_final
        (§ var Stopwatch watch = Stopwatch.createStarted(§ pars ))
        (§ var byte[] seed = PBKDF2SHA512.derive(§ pars pass, salt, PBKDF2_ROUNDS, 64))
        (§ call watch.stop(§ pars ))
        (§ call log.info(§ pars "PBKDF2 took {}", watch))
        (§ return seed)
    )

    ;;;
     ; Convert mnemonic word list to original entropy value.
     ;;
    #_public
    (§ method byte[] toEntropy(§ args List<String> words))
        (§ throws MnemonicException.MnemonicLengthException, MnemonicException.MnemonicWordException, MnemonicException.MnemonicChecksumException)
    (§ block
        (§ if (§ expr 0 < words.size(§ pars ) % 3))
        (§ block
            (§ throw new MnemonicException.MnemonicLengthException(§ pars "Word list size must be multiple of three words."))
        )

        (§ if (§ expr words.size(§ pars ) == 0))
        (§ block
            (§ throw new MnemonicException.MnemonicLengthException(§ pars "Word list is empty."))
        )

        ;; Look up all the words in the list and construct the concatenation of the original entropy and the checksum.

        (§ var int concatLenBits = words.size(§ pars ) * 11)
        (§ var boolean[] concatBits = new boolean[concatLenBits])
        (§ var int wordindex = 0)
        (§ for (§ var String word) :for (§ expr words))
        (§ block
            ;; Find the words index in the wordlist.
            (§ var int ndx = Collections.binarySearch(§ pars this.wordList, word))
            (§ if (§ expr ndx < 0))
            (§ block
                (§ throw new MnemonicException.MnemonicWordException(§ pars word))
            )

            ;; Set the next 11 bits to the value of the index.
            (§ for (§ var int i = 0) :for (§ expr i < 11) :for (§ ass i = i + 1))
            (§ block
                (§ ass concatBits[(§ expr wordindex * 11) + i] = (§ expr (§ expr ndx & (§ expr 1 << (§ expr 10 - i))) != 0))
            )
            (§ ass wordindex = wordindex + 1)
        )

        (§ var int checksumLengthBits = concatLenBits / 33)
        (§ var int entropyLengthBits = concatLenBits - checksumLengthBits)

        ;; Extract original entropy as bytes.
        (§ var byte[] entropy = new byte[entropyLengthBits / 8])
        (§ for (§ var int i = 0) :for (§ expr i < entropy.length) :for (§ ass i = i + 1))
        (§ block
            (§ for (§ var int j = 0) :for (§ expr j < 8) :for (§ ass j = j + 1))
            (§ block
                (§ if (§ expr concatBits[(§ expr i * 8) + j]))
                (§ block
                    (§ ass entropy[i] = entropy[i] | (§ expr 1 << (§ expr 7 - j)))
                )
            )
        )

        ;; Take the digest of the entropy.
        (§ var byte[] hash = Sha256Hash.hash(§ pars entropy))
        (§ var boolean[] hashBits = bytesToBits(§ pars hash))

        ;; Check all the checksum bits.
        (§ for (§ var int i = 0) :for (§ expr i < checksumLengthBits) :for (§ ass i = i + 1))
        (§ block
            (§ if (§ expr concatBits[entropyLengthBits + i] != hashBits[i]))
            (§ block
                (§ throw new MnemonicException.MnemonicChecksumException(§ pars ))
            )
        )

        (§ return entropy)
    )

    ;;;
     ; Convert entropy data to mnemonic word list.
     ;;
    #_public
    (§ method List<String> toMnemonic(§ args byte[] entropy))
        (§ throws MnemonicException.MnemonicLengthException)
    (§ block
        (§ if (§ expr 0 < entropy.length % 4))
        (§ block
            (§ throw new MnemonicException.MnemonicLengthException(§ pars "Entropy length not multiple of 32 bits."))
        )

        (§ if (§ expr entropy.length == 0))
        (§ block
            (§ throw new MnemonicException.MnemonicLengthException(§ pars "Entropy is empty."))
        )

        ;; We take initial entropy of ENT bits and compute its checksum by taking first ENT / 32 bits of its SHA256 hash.

        (§ var byte[] hash = Sha256Hash.hash(§ pars entropy))
        (§ var boolean[] hashBits = bytesToBits(§ pars hash))

        (§ var boolean[] entropyBits = bytesToBits(§ pars entropy))
        (§ var int checksumLengthBits = entropyBits.length / 32)

        ;; We append these bits to the end of the initial entropy.
        (§ var boolean[] concatBits = new boolean[entropyBits.length + checksumLengthBits])
        (§ call System.arraycopy(§ pars entropyBits, 0, concatBits, 0, entropyBits.length))
        (§ call System.arraycopy(§ pars hashBits, 0, concatBits, entropyBits.length, checksumLengthBits))

        ;; Next we take these concatenated bits and split them into groups of 11 bits.  Each group encodes number from 0-2047
        ;; which is a position in a wordlist.  We convert numbers into words and use joined words as mnemonic sentence.

        (§ var ArrayList<String> words = new ArrayList<>(§ pars ))
        (§ var int nwords = concatBits.length / 11)
        (§ for (§ var int i = 0) :for (§ expr i < nwords) :for (§ ass i = i + 1))
        (§ block
            (§ var int index = 0)
            (§ for (§ var int j = 0) :for (§ expr j < 11) :for (§ ass j = j + 1))
            (§ block
                (§ ass index = index << 1)
                (§ if (§ expr concatBits[(§ expr i * 11) + j]))
                (§ block
                    (§ ass index = index | 0x1)
                )
            )
            (§ call words.add(§ pars this.wordList.get(§ pars index)))
        )

        (§ return words)
    )

    ;;;
     ; Check to see if a mnemonic word list is valid.
     ;;
    #_public
    (§ method void check(§ args List<String> words))
        (§ throws MnemonicException)
    (§ block
        (§ call toEntropy(§ pars words))
    )

    #_private
    #_static
    (§ method boolean[] bytesToBits(§ args byte[] data))
    (§ block
        (§ var boolean[] bits = new boolean[data.length * 8])
        (§ for (§ var int i = 0) :for (§ expr i < data.length) :for (§ ass i = i + 1))
        (§ block
            (§ for (§ var int j = 0) :for (§ expr j < 8) :for (§ ass j = j + 1))
            (§ block
                (§ ass bits[(§ expr i * 8) + j] = (§ expr (§ expr data[i] & (§ expr 1 << (§ expr 7 - j))) != 0))
            )
        )
        (§ return bits)
    )
)

#_(ns org.bitcoinj.crypto #_"MnemonicException")

;;;
 ; Exceptions thrown by the MnemonicCode module.
 ;;
#_public
(§ class MnemonicException extends Exception
    #_public
    (§ constructor MnemonicException(§ args ))
    (§ block
        (§ super (§ pars ))
    )

    #_public
    (§ constructor MnemonicException(§ args String msg))
    (§ block
        (§ super (§ pars msg))
    )

    ;;;
     ; Thrown when an argument to MnemonicCode is the wrong length.
     ;;
    #_public
    #_static
    (§ class MnemonicLengthException extends MnemonicException
        #_public
        (§ constructor MnemonicLengthException(§ args String msg))
        (§ block
            (§ super (§ pars msg))
        )
    )

    ;;;
     ; Thrown when a list of MnemonicCode words fails the checksum check.
     ;;
    #_public
    #_static
    (§ class MnemonicChecksumException extends MnemonicException
        #_public
        (§ constructor MnemonicChecksumException(§ args ))
        (§ block
            (§ super (§ pars ))
        )
    )

    ;;;
     ; Thrown when a word is encountered which is not in the MnemonicCode's word list.
     ;;
    #_public
    #_static
    (§ class MnemonicWordException extends MnemonicException
        ;;; Contains the word that was not found in the word list. ;;
        #_public
        #_final
        (§ field String badWord)

        #_public
        (§ constructor MnemonicWordException(§ args String badWord))
        (§ block
            (§ super (§ pars ))
            (§ ass this.badWord = badWord)
        )
    )
)

#_(ns org.bitcoinj.crypto #_"PBKDF2SHA512"
    (:import [java.io ByteArrayOutputStream]
             [java.nio ByteBuffer ByteOrder]
             [javax.crypto Mac]
             [javax.crypto.spec SecretKeySpec]))

;;;
 ; <p>This is a clean-room implementation of PBKDF2 using RFC 2898 as a reference.</p>
 ;
 ; <p>RFC 2898: http://tools.ietf.org/html/rfc2898#section-5.2</p>
 ;
 ; <p>This code passes all RFC 6070 test vectors: http://tools.ietf.org/html/rfc6070</p>
 ;
 ; <p>http://cryptofreek.org/2012/11/29/pbkdf2-pure-java-implementation/<br>
 ; Modified to use SHA-512 - Ken Sedgwick ken@bonsai.com</p>
 ;;
#_public
(§ class PBKDF2SHA512
    #_public
    #_static
    (§ method byte[] derive(§ args String P, String S, int c, int dkLen))
    (§ block
        (§ var ByteArrayOutputStream baos = new ByteArrayOutputStream(§ pars ))

        (§ try )
        (§ block
            (§ var int hLen = 20)

            (§ if (§ expr (§ expr (§ expr Math.pow(§ pars 2, 32)) - 1) * hLen < dkLen))
            (§ block
                (§ throw (§ new IllegalArgumentException(§ pars "derived key too long")))
            )

            (§ var int l = (§ cast int)Math.ceil(§ pars (§ cast double)dkLen / (§ cast double)hLen))
         ;; int r = dkLen - (l - 1) * hLen;

            (§ for (§ var int i = 1) :for (§ expr i <= l) :for (§ ass i = i + 1))
            (§ block
                (§ var byte[] T = F(§ pars P, S, c, i))
                (§ call baos.write(§ pars T))
            )
        )
        (§ catch (§ args Exception e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e)))
        )

        (§ var byte[] baDerived = new byte[dkLen])
        (§ call System.arraycopy(§ pars baos.toByteArray(§ pars ), 0, baDerived, 0, baDerived.length))

        (§ return baDerived)
    )

    #_private
    #_static
    (§ method byte[] F(§ args String P, String S, int c, int i))
        (§ throws Exception)
    (§ block
        (§ var byte[] U_LAST = nil)
        (§ var byte[] U_XOR = nil)

        (§ var SecretKeySpec key = new SecretKeySpec(§ pars P.getBytes(§ pars "UTF-8"), "HmacSHA512"))
        (§ var Mac mac = Mac.getInstance(§ pars key.getAlgorithm(§ pars )))
        (§ call mac.init(§ pars key))

        (§ for (§ var int j = 0) :for (§ expr j < c) :for (§ ass j = j + 1))
        (§ block
            (§ if (§ expr j == 0))
            (§ block
                (§ var byte[] baS = S.getBytes(§ pars "UTF-8"))
                (§ var byte[] baI = INT(§ pars i))
                (§ var byte[] baU = new byte[baS.length + baI.length])

                (§ call System.arraycopy(§ pars baS, 0, baU, 0, baS.length))
                (§ call System.arraycopy(§ pars baI, 0, baU, baS.length, baI.length))

                (§ ass U_XOR = mac.doFinal(§ pars baU))
                (§ ass U_LAST = U_XOR)
                (§ call mac.reset(§ pars ))
            )
            (§ else )
            (§ block
                (§ var byte[] baU = mac.doFinal(§ pars U_LAST))
                (§ call mac.reset(§ pars ))

                (§ for (§ var int k = 0) :for (§ expr k < U_XOR.length) :for (§ ass k = k + 1))
                (§ block
                    (§ ass U_XOR[k] = (§ cast byte)(§ expr U_XOR[k] :xor baU[k]))
                )

                (§ ass U_LAST = baU)
            )
        )

        (§ return U_XOR)
    )

    #_private
    #_static
    (§ method byte[] INT(§ args int i))
    (§ block
        (§ var ByteBuffer bb = ByteBuffer.allocate(§ pars 4))
        (§ call bb.order(§ pars ByteOrder.BIG_ENDIAN))
        (§ call bb.putInt(§ pars i))

        (§ return bb.array(§ pars ))
    )
)

#_(ns org.bitcoinj.crypto #_"TransactionSignature"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.math BigInteger])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.core ECKey Transaction VerificationException]
             [org.bitcoinj.core.Transaction SigHash]))

;;;
 ; A TransactionSignature wraps an {@link org.bitcoinj.core.ECKey.ECDSASignature} and adds methods for handling
 ; the additional SIGHASH mode byte that is used.
 ;;
#_public
(§ class TransactionSignature extends ECKey.ECDSASignature
    ;;;
     ; A byte that controls which parts of a transaction are signed.  This is exposed because signatures
     ; parsed off the wire may have sighash flags that aren't "normal" serializations of the enum values.
     ; Because Bitcoin Core works via bit testing, we must not lose the exact value when round-tripping
     ; otherwise we'll fail to verify signature hashes.
     ;;
    #_public
    #_final
    (§ field int sighashFlags)

    ;;; Constructs a signature with the given components and SIGHASH_ALL. ;;
    #_public
    (§ constructor TransactionSignature(§ args BigInteger r, BigInteger s))
    (§ block
        (§ this (§ pars r, s, Transaction.SigHash.ALL.value))
    )

    ;;; Constructs a signature with the given components and raw sighash flag bytes (needed for rule compatibility). ;;
    #_public
    (§ constructor TransactionSignature(§ args BigInteger r, BigInteger s, int sighashFlags))
    (§ block
        (§ super (§ pars r, s))
        (§ ass this.sighashFlags = sighashFlags)
    )

    ;;; Constructs a transaction signature based on the ECDSA signature. ;;
    #_public
    (§ constructor TransactionSignature(§ args ECKey.ECDSASignature signature, Transaction.SigHash mode, boolean anyoneCanPay))
    (§ block
        (§ super (§ pars signature.r, signature.s))
        (§ ass sighashFlags = calcSigHashValue(§ pars mode, anyoneCanPay))
    )

    ;;;
     ; Returns a dummy invalid signature whose R/S values are set such that they will take up the same number of
     ; encoded bytes as a real signature.  This can be useful when you want to fill out a transaction to be of
     ; the right size (e.g. for fee calculations) but don't have the requisite signing key yet and will fill out
     ; the real signature later.
     ;;
    #_public
    #_static
    (§ method TransactionSignature dummy(§ args ))
    (§ block
        (§ var BigInteger val = ECKey.HALF_CURVE_ORDER)
        (§ return (§ new TransactionSignature(§ pars val, val)))
    )

    ;;; Calculates the byte used in the protocol to represent the combination of mode and anyoneCanPay. ;;
    #_public
    #_static
    (§ method int calcSigHashValue(§ args Transaction.SigHash mode, boolean anyoneCanPay))
    (§ block
        ;; Enforce compatibility since this code was made before the SigHash enum was updated.
        (§ call Preconditions.checkArgument(§ pars SigHash.ALL == mode || SigHash.NONE == mode || SigHash.SINGLE == mode))

        (§ var int sighashFlags = mode.value)
        (§ if (§ expr anyoneCanPay))
        (§ block
            (§ ass sighashFlags = sighashFlags | Transaction.SigHash.ANYONECANPAY.value)
        )
        (§ return sighashFlags)
    )

    ;;;
     ; Returns true if the given signature is has canonical encoding, and will thus be accepted as standard by
     ; Bitcoin Core.  DER and the SIGHASH encoding allow for quite some flexibility in how the same structures
     ; are encoded, and this can open up novel attacks in which a man in the middle takes a transaction and then
     ; changes its signature such that the transaction hash is different but it's still valid.  This can confuse
     ; wallets and generally violates people's mental model of how Bitcoin should work, thus non-canonical
     ; signatures are now not relayed by default.
     ;;
    #_public
    #_static
    (§ method boolean isEncodingCanonical(§ args byte[] signature))
    (§ block
        ;; See Bitcoin Core's IsCanonicalSignature, https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623
        ;; A canonical signature exists of: <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>
        ;; Where R and S are not negative (their first byte has its highest bit not set), and not
        ;; excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,
        ;; in which case a single 0 byte is necessary and even required).
        (§ if (§ expr signature.length < 9 || 73 < signature.length))
        (§ block
            (§ return false)
        )

        (§ var int hashType = (§ expr signature[signature.length-1] & 0xff) & ~Transaction.SigHash.ANYONECANPAY.value) ;; mask the byte to prevent sign-extension hurting us
        (§ if (§ expr hashType < Transaction.SigHash.ALL.value || Transaction.SigHash.SINGLE.value < hashType))
        (§ block
            (§ return false)
        )

        ;;                   "wrong type"                  "wrong length marker"
        (§ if (§ expr (§ expr signature[0] & 0xff) != 0x30 || (§ expr signature[1] & 0xff) != signature.length - 3))
        (§ block
            (§ return false)
        )

        (§ var int lenR = signature[3] & 0xff)
        (§ if (§ expr signature.length <= 5 + lenR || lenR == 0))
        (§ block
            (§ return false)
        )
        (§ var int lenS = signature[5 + lenR] & 0xff)
        (§ if (§ expr lenR + lenS + 7 != signature.length || lenS == 0))
        (§ block
            (§ return false)
        )

        ;;    R value type mismatch          R value negative
        (§ if (§ expr signature[4 - 2] != 0x02 || (§ expr signature[4] & 0x80) == 0x80))
        (§ block
            (§ return false)
        )
        (§ if (§ expr 1 < lenR && signature[4] == 0x00 && (§ expr signature[4 + 1] & 0x80) != 0x80))
        (§ block
            (§ return false) ;; R value excessively padded
        )

        ;;       S value type mismatch                    S value negative
        (§ if (§ expr signature[6 + lenR - 2] != 0x02 || (§ expr signature[6 + lenR] & 0x80) == 0x80))
        (§ block
            (§ return false)
        )
        (§ if (§ expr 1 < lenS && signature[6 + lenR] == 0x00 && (§ expr signature[6 + lenR + 1] & 0x80) != 0x80))
        (§ block
            (§ return false) ;; S value excessively padded
        )

        (§ return true)
    )

    #_public
    (§ method boolean anyoneCanPay(§ args ))
    (§ block
        (§ return (§ expr (§ expr sighashFlags & Transaction.SigHash.ANYONECANPAY.value) != 0))
    )

    #_public
    (§ method Transaction.SigHash sigHashMode(§ args ))
    (§ block
        #_final
        (§ var int mode = sighashFlags & 0x1f)

        (§ if (§ expr mode == Transaction.SigHash.NONE.value))
        (§ block
            (§ return Transaction.SigHash.NONE)
        )
        (§ if (§ expr mode == Transaction.SigHash.SINGLE.value))
        (§ block
            (§ return Transaction.SigHash.SINGLE)
        )

        (§ return Transaction.SigHash.ALL)
    )

    ;;;
     ; What we get back from the signer are the two components of a signature, r and s.  To get a flat byte stream
     ; of the type used by Bitcoin we have to encode them using DER encoding, which is just a way to pack the two
     ; components into a structure, and then we append a byte to the end for the sighash flags.
     ;;
    #_public
    (§ method byte[] encodeToBitcoin(§ args ))
    (§ block
        (§ try )
        (§ block
            (§ var ByteArrayOutputStream bos = derByteStream(§ pars ))
            (§ call bos.write(§ pars sighashFlags))
            (§ return bos.toByteArray(§ pars ))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
    )

    #_override
    #_public
    (§ method ECKey.ECDSASignature toCanonicalised(§ args ))
    (§ block
        (§ return (§ new TransactionSignature(§ pars super.toCanonicalised(§ pars ), sigHashMode(§ pars ), anyoneCanPay(§ pars ))))
    )

    ;;;
     ; Returns a decoded signature.
     ;
     ; @param requireCanonicalEncoding if the encoding of the signature must be canonical.
     ; @throws RuntimeException if the signature is invalid or unparseable in some way.
     ; @deprecated use {@link #decodeFromBitcoin(byte[], boolean, boolean)} instead.
     ;;
    #_deprecated
    #_public
    #_static
    (§ method TransactionSignature decodeFromBitcoin(§ args byte[] bytes, boolean requireCanonicalEncoding))
        (§ throws VerificationException)
    (§ block
        (§ return decodeFromBitcoin(§ pars bytes, requireCanonicalEncoding, false))
    )

    ;;;
     ; Returns a decoded signature.
     ;
     ; @param requireCanonicalEncoding if the encoding of the signature must be canonical.
     ; @param requireCanonicalSValue if the S-value must be canonical (below half the order of the curve).
     ; @throws RuntimeException if the signature is invalid or unparseable in some way.
     ;;
    #_public
    #_static
    (§ method TransactionSignature decodeFromBitcoin(§ args byte[] bytes, boolean requireCanonicalEncoding, boolean requireCanonicalSValue))
        (§ throws VerificationException)
    (§ block
        ;; Bitcoin encoding is DER signature + sighash byte.
        (§ if (§ expr requireCanonicalEncoding && !isEncodingCanonical(§ pars bytes)))
        (§ block
            (§ throw (§ new VerificationException(§ pars "Signature encoding is not canonical.")))
        )

        (§ var ECKey.ECDSASignature sig)
        (§ try )
        (§ block
            (§ ass sig = ECKey.ECDSASignature.decodeFromDER(§ pars bytes))
        )
        (§ catch (§ args IllegalArgumentException e))
        (§ block
            (§ throw (§ new VerificationException(§ pars "Could not decode DER", e)))
        )
        (§ if (§ expr requireCanonicalSValue && !sig.isCanonical(§ pars )))
        (§ block
            (§ throw (§ new VerificationException(§ pars "S-value is not canonical.")))
        )

        ;; In Bitcoin, any value of the final byte is valid, but not necessarily canonical.  See javadocs
        ;; for isEncodingCanonical to learn more about this.  So we must store the exact byte found.
        (§ return (§ new TransactionSignature(§ pars sig.r, sig.s, bytes[bytes.length - 1])))
    )
)

#_(ns org.bitcoinj.kits #_"WalletAppKit"
    (:import [java.io *]
             [java.net *]
             [java.nio.channels *]
             [java.util *]
             [java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect *]
             [com.google.common.util.concurrent *]
             [org.slf4j *])
   (:require [org.bitcoinj.core.listeners *]
             [org.bitcoinj.core *]
             [org.bitcoinj.net.discovery *]
             [org.bitcoinj.store *]
             [org.bitcoinj.wallet *]))

;;;
 ; <p>Utility class that wraps the boilerplate needed to set up a new SPV bitcoinj app.  Instantiate it with a directory
 ; and file prefix, optionally configure a few things, then use startAsync and optionally awaitRunning.  The object will
 ; construct and configure a {@link BlockChain}, {@link SPVBlockStore}, {@link Wallet} and {@link PeerGroup}.  Depending
 ; on the value of the blockingStartup property, startup will be considered complete once the block chain has fully
 ; synchronized, so it can take a while.</p>
 ;
 ; <p>To add listeners and modify the objects that are constructed, you can either do that by overriding the
 ; {@link #onSetupCompleted()} method (which will run on a background thread) and make your changes there,
 ; or by waiting for the service to start and then accessing the objects from wherever you want.  However, you cannot
 ; access the objects this class creates until startup is complete.</p>
 ;
 ; <p>The asynchronous design of this class may seem puzzling (just use {@link #awaitRunning()} if you don't want that).
 ; It is to make it easier to fit bitcoinj into GUI apps, which require a high degree of responsiveness on their main
 ; thread which handles all the animation and user interaction.  Even when blockingStart is false, initializing bitcoinj
 ; means doing potentially blocking file IO, generating keys and other potentially intensive operations.  By running it
 ; on a background thread, there's no risk of accidentally causing UI lag.</p>
 ;
 ; <p>Note that {@link #awaitRunning()} can throw an unchecked {@link java.lang.IllegalStateException}
 ; if anything goes wrong during startup - you should probably handle it and use {@link Exception#getCause()} to figure
 ; out what went wrong more precisely.  Same thing if you just use the {@link #startAsync()} method.</p>
 ;;
#_public
(§ class WalletAppKit extends AbstractIdleService
    #_protected
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars WalletAppKit.class))

    #_protected
    #_final
    (§ field String filePrefix)
    #_protected
    #_final
    (§ field NetworkParameters params)
    #_protected
    #_volatile
    (§ field BlockChain vChain)
    #_protected
    #_volatile
    (§ field BlockStore vStore)
    #_protected
    #_volatile
    (§ field Wallet vWallet)
    #_protected
    #_volatile
    (§ field PeerGroup vPeerGroup)

    #_protected
    #_final
    (§ field File directory)
    #_protected
    #_volatile
    (§ field File vWalletFile)

    #_protected
    (§ field boolean useAutoSave = true)
    #_protected
    (§ field PeerAddress[] peerAddresses)
    #_protected
    (§ field DownloadProgressTracker downloadListener)
    #_protected
    (§ field boolean autoStop = true)
    #_protected
    (§ field InputStream checkpoints)
    #_protected
    (§ field boolean blockingStartup = true)
    #_protected
    (§ field String userAgent, version)
    #_protected
    (§ field WalletProtobufSerializer.WalletFactory walletFactory)
    #_nilable
    #_protected
    (§ field DeterministicSeed restoreFromSeed)
    #_nilable
    #_protected
    (§ field PeerDiscovery discovery)

    #_protected
    #_volatile
    (§ field Context context)

    ;;;
     ; Creates a new WalletAppKit, with a newly created {@link Context}.  Files will be stored in the given directory.
     ;;
    #_public
    (§ constructor WalletAppKit(§ args NetworkParameters params, File directory, String filePrefix))
    (§ block
        (§ this (§ pars new Context(§ pars params), directory, filePrefix))
    )

    ;;;
     ; Creates a new WalletAppKit, with the given {@link Context}.  Files will be stored in the given directory.
     ;;
    #_public
    (§ constructor WalletAppKit(§ args Context context, File directory, String filePrefix))
    (§ block
        (§ ass this.context = context)
        (§ ass this.params = Preconditions.checkNotNull(§ pars context.getParams(§ pars )))
        (§ ass this.directory = Preconditions.checkNotNull(§ pars directory))
        (§ ass this.filePrefix = Preconditions.checkNotNull(§ pars filePrefix))
    )

    ;;; Will only connect to the given addresses.  Cannot be called after startup. ;;
    #_public
    (§ method WalletAppKit setPeerNodes(§ args PeerAddress... addresses))
    (§ block
        (§ call Preconditions.checkState(§ pars state(§ pars ) == State.NEW, "Cannot call after startup"))
        (§ ass this.peerAddresses = addresses)
        (§ return this)
    )

    ;;; Will only connect to localhost.  Cannot be called after startup. ;;
    #_public
    (§ method WalletAppKit connectToLocalHost(§ args ))
    (§ block
        (§ try )
        (§ block
            #_final
            (§ var InetAddress localHost = InetAddress.getLocalHost(§ pars ))
            (§ return setPeerNodes(§ pars (§ new PeerAddress(§ pars params, localHost, params.getPort(§ pars )))))
        )
        (§ catch (§ args UnknownHostException e))
        (§ block
            ;; Borked machine with no loopback adapter configured properly.
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )

    ;;; If true, the wallet will save itself to disk automatically whenever it changes. ;;
    #_public
    (§ method WalletAppKit setAutoSave(§ args boolean value))
    (§ block
        (§ call Preconditions.checkState(§ pars state(§ pars ) == State.NEW, "Cannot call after startup"))
        (§ ass useAutoSave = value)
        (§ return this)
    )

    ;;;
     ; If you want to learn about the sync process, you can provide a listener here.  For instance,
     ; a {@link org.bitcoinj.core.DownloadProgressTracker} is a good choice.  This has no effect unless
     ; setBlockingStartup(false) has been called too, due to some missing implementation code.
     ;;
    #_public
    (§ method WalletAppKit setDownloadListener(§ args DownloadProgressTracker listener))
    (§ block
        (§ ass this.downloadListener = listener)
        (§ return this)
    )

    ;;; If true, will register a shutdown hook to stop the library.  Defaults to true. ;;
    #_public
    (§ method WalletAppKit setAutoStop(§ args boolean autoStop))
    (§ block
        (§ ass this.autoStop = autoStop)
        (§ return this)
    )

    ;;;
     ; If set, the file is expected to contain a checkpoints file calculated with BuildCheckpoints.
     ; It makes initial block sync faster for new users - please refer to the documentation on the
     ; bitcoinj website (https://bitcoinj.github.io/speeding-up-chain-sync) for further details.
     ;;
    #_public
    (§ method WalletAppKit setCheckpoints(§ args InputStream checkpoints))
    (§ block
        (§ if (§ expr this.checkpoints != nil))
        (§ block
            (§ call Utils.closeUnchecked(§ pars this.checkpoints))
        )
        (§ ass this.checkpoints = Preconditions.checkNotNull(§ pars checkpoints))
        (§ return this)
    )

    ;;;
     ; If true (the default) then the startup of this service won't be considered complete until the network has been
     ; brought up, peer connections established and the block chain synchronised.  Therefore {@link #awaitRunning()} can
     ; potentially take a very long time.  If false, then startup is considered complete once the network activity
     ; begins and peer connections/block chain sync will continue in the background.
     ;;
    #_public
    (§ method WalletAppKit setBlockingStartup(§ args boolean blockingStartup))
    (§ block
        (§ ass this.blockingStartup = blockingStartup)
        (§ return this)
    )

    ;;;
     ; Sets the string that will appear in the subver field of the version message.
     ; @param userAgent A short string that should be the name of your app, e.g. "My Wallet".
     ; @param version A short string that contains the version number, e.g. "1.0-BETA".
     ;;
    #_public
    (§ method WalletAppKit setUserAgent(§ args String userAgent, String version))
    (§ block
        (§ ass this.userAgent = Preconditions.checkNotNull(§ pars userAgent))
        (§ ass this.version = Preconditions.checkNotNull(§ pars version))
        (§ return this)
    )

    ;;;
     ; Sets a wallet factory which will be used when the kit creates a new wallet.
     ;;
    #_public
    (§ method WalletAppKit setWalletFactory(§ args WalletProtobufSerializer.WalletFactory walletFactory))
    (§ block
        (§ ass this.walletFactory = walletFactory)
        (§ return this)
    )

    ;;;
     ; If a seed is set here then any existing wallet that matches the file name will be renamed to a backup name,
     ; the chain file will be deleted, and the wallet object will be instantiated with the given seed instead of
     ; a fresh one being created.  This is intended for restoring a wallet from the original seed.  To implement
     ; restore, you would shut down the existing appkit, if any, then recreate it with the seed given by the user,
     ; then start up the new kit.  The next time your app starts it should work as normal (that is, don't keep
     ; calling this each time).
     ;;
    #_public
    (§ method WalletAppKit restoreWalletFromSeed(§ args DeterministicSeed seed))
    (§ block
        (§ ass this.restoreFromSeed = seed)
        (§ return this)
    )

    ;;;
     ; Sets the peer discovery class to use.  If none is provided then DNS is used, which is a reasonable default.
     ;;
    #_public
    (§ method WalletAppKit setDiscovery(§ args #_nilable PeerDiscovery discovery))
    (§ block
        (§ ass this.discovery = discovery)
        (§ return this)
    )

    ;;;
     ; Override this to use a {@link BlockStore} that isn't the default of {@link SPVBlockStore}.
     ;;
    #_protected
    (§ method BlockStore provideBlockStore(§ args File file))
        (§ throws BlockStoreException)
    (§ block
        (§ return (§ new SPVBlockStore(§ pars params, file)))
    )

    ;;;
     ; This method is invoked on a background thread after all objects are initialised, but before the peer group
     ; or block chain download is started.  You can tweak the objects configuration here.
     ;;
    #_protected
    (§ method void onSetupCompleted(§ args ))
    (§ block
    )

    ;;;
     ; Tests to see if the spvchain file has an operating system file lock on it.  Useful for checking if your app
     ; is already running.  If another copy of your app is running and you start the appkit anyway, an exception will
     ; be thrown during the startup process.  Returns false if the chain file does not exist or is a directory.
     ;;
    #_public
    (§ method boolean isChainFileLocked(§ args ))
        (§ throws IOException)
    (§ block
        (§ var RandomAccessFile file2 = nil)
        (§ try )
        (§ block
            (§ var File file = new File(§ pars directory, filePrefix + ".spvchain"))
            (§ if (§ expr !file.exists(§ pars )))
            (§ block
                (§ return false)
            )
            (§ if (§ expr file.isDirectory(§ pars )))
            (§ block
                (§ return false)
            )
            (§ ass file2 = new RandomAccessFile(§ pars file, "rw"))
            (§ var FileLock lock = file2.getChannel(§ pars ).tryLock(§ pars ))
            (§ if (§ expr lock == nil))
            (§ block
                (§ return true)
            )
            (§ call lock.release(§ pars ))
            (§ return false)
        )
        (§ finally )
        (§ block
            (§ if (§ expr file2 != nil))
            (§ block
                (§ call file2.close(§ pars ))
            )
        )
    )

    #_override
    #_protected
    (§ method void startUp(§ args ))
        (§ throws Exception)
    (§ block
        ;; Runs in a separate thread.
        (§ call Context.propagate(§ pars context))
        (§ if (§ expr !directory.exists(§ pars ) && !directory.mkdirs(§ pars )))
        (§ block
            (§ throw (§ new IOException(§ pars "Could not create directory " + directory.getAbsolutePath(§ pars ))))
        )

        (§ ass log.info(§ pars "Starting up with directory = {}", directory))
        (§ try )
        (§ block
            (§ var File chainFile = new File(§ pars directory, filePrefix + ".spvchain"))
            (§ var boolean chainFileExists = chainFile.exists(§ pars ))
            (§ ass vWalletFile = new File(§ pars directory, filePrefix + ".wallet"))
            (§ var boolean shouldReplayWallet = (§ expr (§ expr vWalletFile.exists(§ pars ) && !chainFileExists) || restoreFromSeed != nil))
            (§ ass vWallet = createOrLoadWallet(§ pars shouldReplayWallet))

            ;; Initiate Bitcoin network objects (block store, blockchain and peer group).
            (§ ass vStore = provideBlockStore(§ pars chainFile))
            (§ if (§ expr !chainFileExists || restoreFromSeed != nil))
            (§ block
                (§ if (§ expr checkpoints == nil && !Utils.isAndroidRuntime(§ pars )))
                (§ block
                    (§ ass checkpoints = CheckpointManager.openStream(§ pars params))
                )

                (§ if (§ expr checkpoints != nil))
                (§ block
                    ;; Initialize the chain file with a checkpoint to speed up first-run sync.
                    (§ var long time)
                    (§ if (§ expr restoreFromSeed != nil))
                    (§ block
                        (§ ass time = restoreFromSeed.getCreationTimeSeconds(§ pars ))
                        (§ if (§ expr chainFileExists))
                        (§ block
                            (§ call log.info(§ pars "Deleting the chain file in preparation from restore."))
                            (§ call vStore.close(§ pars ))
                            (§ if (§ expr !chainFile.delete(§ pars )))
                            (§ block
                                (§ throw (§ new IOException(§ pars "Failed to delete chain file in preparation for restore.")))
                            )

                            (§ ass vStore = new SPVBlockStore(§ pars params, chainFile))
                        )
                    )
                    (§ else )
                    (§ block
                        (§ ass time = vWallet.getEarliestKeyCreationTime(§ pars ))
                    )
                    (§ if (§ expr 0 < time))
                    (§ block
                        (§ call CheckpointManager.checkpoint(§ pars params, checkpoints, vStore, time))
                    )
                    (§ else )
                    (§ block
                        (§ call log.warn(§ pars "Creating a new uncheckpointed block store due to a wallet with a creation time of zero: this will result in a very slow chain sync"))
                    )
                )
                (§ elseif (§ expr chainFileExists))
                (§ block
                    (§ call log.info(§ pars "Deleting the chain file in preparation from restore."))
                    (§ call vStore.close(§ pars ))
                    (§ if (§ expr !chainFile.delete(§ pars )))
                    (§ block
                        (§ throw (§ new IOException(§ pars "Failed to delete chain file in preparation for restore.")))
                    )

                    (§ ass vStore = new SPVBlockStore(§ pars params, chainFile))
                )
            )
            (§ ass vChain = new BlockChain(§ pars params, vStore))
            (§ ass vPeerGroup = createPeerGroup(§ pars ))
            (§ if (§ expr this.userAgent != nil))
            (§ block
                (§ call vPeerGroup.setUserAgent(§ pars userAgent, version))
            )

            ;; Set up peer addresses or discovery first, so if wallet extensions try to broadcast a transaction
            ;; before we're actually connected the broadcast waits for an appropriate number of connections.
            (§ if (§ expr peerAddresses != nil))
            (§ block
                (§ for (§ var PeerAddress addr) :for (§ expr peerAddresses))
                (§ block
                    (§ call vPeerGroup.addAddress(§ pars addr))
                )
                (§ call vPeerGroup.setMaxConnections(§ pars peerAddresses.length))
                (§ ass peerAddresses = nil)
            )
            (§ else )
            (§ block
                (§ call vPeerGroup.addPeerDiscovery(§ pars (§ expr discovery != nil) ? discovery :else new DnsDiscovery(§ pars params)))
            )
            (§ call vChain.addWallet(§ pars vWallet))
            (§ call vPeerGroup.addWallet(§ pars vWallet))
            (§ call onSetupCompleted(§ pars ))

            (§ if (§ expr blockingStartup))
            (§ block
                (§ call vPeerGroup.start(§ pars ))
                ;; Make sure we shut down cleanly.
                (§ call installShutdownHook(§ pars ))

                ;; TODO: Be able to use the provided download listener when doing a blocking startup.
                #_final
                (§ var DownloadProgressTracker listener = new DownloadProgressTracker(§ pars ))
                (§ call vPeerGroup.startBlockChainDownload(§ pars listener))
                (§ call listener.await(§ pars ))
            )
            (§ else )
            (§ block
                (§ call Futures.addCallback(§ pars vPeerGroup.startAsync(§ pars ), new FutureCallback(§ pars )
                (§ anon
                    #_override
                    #_public
                    (§ method void onSuccess(§ args #_nilable Object result))
                    (§ block
                        #_final
                        (§ var DownloadProgressTracker l = (§ quest (§ expr downloadListener != nil) ? downloadListener :else new DownloadProgressTracker(§ pars )))
                        (§ call vPeerGroup.startBlockChainDownload(§ pars l))
                    )

                    #_override
                    #_public
                    (§ method void onFailure(§ args Throwable t))
                    (§ block
                        (§ throw (§ new RuntimeException(§ pars t)))
                    )
                )))
            )
        )
        (§ catch (§ args BlockStoreException e))
        (§ block
            (§ throw (§ new IOException(§ pars e)))
        )
    )

    #_private
    (§ method Wallet createOrLoadWallet(§ args boolean shouldReplayWallet))
        (§ throws Exception)
    (§ block
        (§ var Wallet wallet)

        (§ call maybeMoveOldWalletOutOfTheWay(§ pars ))

        (§ if (§ expr vWalletFile.exists(§ pars )))
        (§ block
            (§ ass wallet = loadWallet(§ pars shouldReplayWallet))
        )
        (§ else )
        (§ block
            (§ ass wallet = createWallet(§ pars ))
            (§ call wallet.freshReceiveKey(§ pars ))

            ;; Currently the only way we can be sure that an extension is aware of its containing wallet is
            ;; by deserializing the extension.
            ;; Hence, we first save and then load wallet to ensure any extensions are correctly initialized.
            (§ call wallet.saveToFile(§ pars vWalletFile))
            (§ ass wallet = loadWallet(§ pars false))
        )

        (§ if (§ expr useAutoSave))
        (§ block
            (§ call this.setupAutoSave(§ pars wallet))
        )

        (§ return wallet)
    )

    #_protected
    (§ method void setupAutoSave(§ args Wallet wallet))
    (§ block
        (§ call wallet.autosaveToFile(§ pars vWalletFile, 5, TimeUnit.SECONDS, nil))
    )

    #_private
    (§ method Wallet loadWallet(§ args boolean shouldReplayWallet))
        (§ throws Exception)
    (§ block
        (§ var Wallet wallet)
        (§ var FileInputStream walletStream = new FileInputStream(§ pars vWalletFile))
        (§ try )
        (§ block
            (§ var Protos.Wallet proto = WalletProtobufSerializer.parseToProto(§ pars walletStream))
            #_final
            (§ var WalletProtobufSerializer serializer)
            (§ if (§ expr walletFactory != nil))
            (§ block
                (§ ass serializer = new WalletProtobufSerializer(§ pars walletFactory))
            )
            (§ else )
            (§ block
                (§ ass serializer = new WalletProtobufSerializer(§ pars ))
            )
            (§ ass wallet = serializer.readWallet(§ pars params, proto))
            (§ if (§ expr shouldReplayWallet))
            (§ block
                (§ call wallet.reset(§ pars ))
            )
        )
        (§ finally )
        (§ block
            (§ call walletStream.close(§ pars ))
        )
        (§ return wallet)
    )

    #_protected
    (§ method Wallet createWallet(§ args ))
    (§ block
        (§ var KeyChainGroup kcg)
        (§ if (§ expr restoreFromSeed != nil))
        (§ block
            (§ ass kcg = new KeyChainGroup(§ pars params, restoreFromSeed))
        )
        (§ else )
        (§ block
            (§ ass kcg = new KeyChainGroup(§ pars params))
        )
        (§ return (§ quest (§ expr walletFactory != nil) ? walletFactory.create(§ pars params, kcg) :else new Wallet(§ pars params, kcg))) ;; default
    )

    #_private
    (§ method void maybeMoveOldWalletOutOfTheWay(§ args ))
    (§ block
        (§ if (§ expr restoreFromSeed == nil))
        (§ block
            (§ return )
        )
        (§ if (§ expr !vWalletFile.exists(§ pars )))
        (§ block
            (§ return )
        )

        (§ var int counter = 1)
        (§ var File newName)
        (§ do )
        (§ block
            (§ ass newName = new File(§ pars vWalletFile.getParent(§ pars ), "Backup " + counter + " for " + vWalletFile.getName(§ pars )))
            (§ ass counter = counter + 1)
        )
        (§ again (§ expr newName.exists(§ pars )))

        (§ call log.info(§ pars "Renaming old wallet file {} to {}", vWalletFile, newName))

        ;; This should not happen unless something is really messed up.
        (§ if (§ expr !vWalletFile.renameTo(§ pars newName)))
        (§ block
            (§ throw (§ new RuntimeException(§ pars "Failed to rename wallet for restore")))
        )
    )

    #_protected
    (§ method PeerGroup createPeerGroup(§ args ))
        (§ throws TimeoutException)
    (§ block
        (§ return (§ new PeerGroup(§ pars params, vChain)))
    )

    #_private
    (§ method void installShutdownHook(§ args ))
    (§ block
        (§ if (§ expr autoStop))
        (§ block
            (§ call Runtime.getRuntime(§ pars ).addShutdownHook(§ pars (§ new Thread(§ pars ))
            (§ anon
                #_override
                #_public
                (§ method void run(§ args ))
                (§ block
                    (§ try )
                    (§ block
                        (§ call WalletAppKit.this.stopAsync(§ pars ))
                        (§ call WalletAppKit.this.awaitTerminated(§ pars ))
                    )
                    (§ catch (§ args Exception e))
                    (§ block
                        (§ throw (§ new RuntimeException(§ pars e)))
                    )
                )
            )))
        )
    )

    #_override
    #_protected
    (§ method void shutDown(§ args ))
        (§ throws Exception)
    (§ block
        ;; Runs in a separate thread.
        (§ try )
        (§ block
            (§ call Context.propagate(§ pars context))
            (§ call vPeerGroup.stop(§ pars ))
            (§ call vWallet.saveToFile(§ pars vWalletFile))
            (§ call vStore.close(§ pars ))

            (§ ass vPeerGroup = nil)
            (§ ass vWallet = nil)
            (§ ass vStore = nil)
            (§ ass vChain = nil)
        )
        (§ catch (§ args BlockStoreException e))
        (§ block
            (§ throw (§ new IOException(§ pars e)))
        )
    )

    #_public
    (§ method NetworkParameters params(§ args ))
    (§ block
        (§ return params)
    )

    #_public
    (§ method BlockChain chain(§ args ))
    (§ block
        (§ call Preconditions.checkState(§ pars state(§ pars ) == State.STARTING || state(§ pars ) == State.RUNNING, "Cannot call until startup is complete"))
        (§ return vChain)
    )

    #_public
    (§ method BlockStore store(§ args ))
    (§ block
        (§ call Preconditions.checkState(§ pars state(§ pars ) == State.STARTING || state(§ pars ) == State.RUNNING, "Cannot call until startup is complete"))
        (§ return vStore)
    )

    #_public
    (§ method Wallet wallet(§ args ))
    (§ block
        (§ call Preconditions.checkState(§ pars state(§ pars ) == State.STARTING || state(§ pars ) == State.RUNNING, "Cannot call until startup is complete"))
        (§ return vWallet)
    )

    #_public
    (§ method PeerGroup peerGroup(§ args ))
    (§ block
        (§ call Preconditions.checkState(§ pars state(§ pars ) == State.STARTING || state(§ pars ) == State.RUNNING, "Cannot call until startup is complete"))
        (§ return vPeerGroup)
    )

    #_public
    (§ method File directory(§ args ))
    (§ block
        (§ return directory)
    )
)

#_(ns org.bitcoinj.net #_"AbstractTimeoutHandler"
    (:import [java.util Timer TimerTask]))

;;;
 ; <p>A base class which provides basic support for socket timeouts.  It is used instead of integrating timeouts into the
 ; NIO select thread both for simplicity and to keep code shared between NIO and blocking sockets as much as possible.
 ; </p>
 ;;
#_public
#_abstract
(§ class AbstractTimeoutHandler
    ;; TimerTask and timeout value which are added to a timer to kill the connection on timeout.
    #_private
    (§ field TimerTask timeoutTask)
    #_private
    (§ field long timeoutMillis = 0)
    #_private
    (§ field boolean timeoutEnabled = true)

    ;; A timer which manages expiring channels as their timeouts occur (if configured).
    #_private
    #_static
    #_final
    (§ field Timer timeoutTimer = new Timer(§ pars "AbstractTimeoutHandler timeouts", true))

    ;;;
     ; <p>Enables or disables the timeout entirely.  This may be useful if you want to store the timeout value
     ; but wish to temporarily disable/enable timeouts.</p>
     ;
     ; <p>The default is for timeoutEnabled to be true but timeoutMillis to be set to 0 (i.e. disabled).</p>
     ;
     ; <p>This call will reset the current progress towards the timeout.</p>
     ;;
    #_public
    #_synchronized
    #_final
    (§ method void setTimeoutEnabled(§ args boolean timeoutEnabled))
    (§ block
        (§ ass this.timeoutEnabled = timeoutEnabled)
        (§ call resetTimeout(§ pars ))
    )

    ;;;
     ; <p>Sets the receive timeout to the given number of milliseconds, automatically killing the connection
     ; if no messages are received for this long.</p>
     ;
     ; <p>A timeout of 0 is interpreted as no timeout.</p>
     ;
     ; <p>The default is for timeoutEnabled to be true but timeoutMillis to be set to 0 (i.e. disabled).</p>
     ;
     ; <p>This call will reset the current progress towards the timeout.</p>
     ;;
    #_public
    #_synchronized
    #_final
    (§ method void setSocketTimeout(§ args int timeoutMillis))
    (§ block
        (§ ass this.timeoutMillis = timeoutMillis)
        (§ call resetTimeout(§ pars ))
    )

    ;;;
     ; Resets the current progress towards timeout to 0.
     ;;
    #_protected
    #_synchronized
    (§ method void resetTimeout(§ args ))
    (§ block
        (§ if (§ expr timeoutTask != nil))
        (§ block
            (§ call timeoutTask.cancel(§ pars ))
        )
        (§ if (§ expr timeoutMillis == 0 || !timeoutEnabled))
        (§ block
            (§ return )
        )

        (§ ass timeoutTask = new TimerTask(§ pars )
        (§ anon
            #_override
            #_public
            (§ method void run(§ args ))
            (§ block
                (§ call timeoutOccurred(§ pars ))
            )
        ))
        (§ call timeoutTimer.schedule(§ pars timeoutTask, timeoutMillis))
    )

    #_protected
    #_abstract
    (§ method void timeoutOccurred(§ args ))
)

#_(ns org.bitcoinj.net #_"BlockingClient"
    (:import [java.io *]
             [java.net *]
             [java.nio *]
             [java.util *]
             [javax.net *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.util.concurrent *]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]))

;;;
 ; <p>Creates a simple connection to a server using a {@link StreamConnection} to process data.</p>
 ;
 ; <p>Generally, using {@link NioClient} and {@link NioClientManager} should be preferred over {@link BlockingClient}
 ; and {@link BlockingClientManager}, unless you wish to connect over a proxy or use some other network settings that
 ; cannot be set using NIO.</p>
 ;;
#_public
(§ class BlockingClient implements MessageWriteTarget
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars BlockingClient.class))

    #_private
    #_static
    #_final
    (§ field int BUFFER_SIZE_LOWER_BOUND = 4096)
    #_private
    #_static
    #_final
    (§ field int BUFFER_SIZE_UPPER_BOUND = 65536)

    #_private
    (§ field Socket socket)
    #_private
    #_volatile
    (§ field boolean vCloseRequested = false)
    #_private
    (§ field SettableFuture<SocketAddress> connectFuture)

    ;;;
     ; <p>Creates a new client to the given server address using the given {@link StreamConnection} to decode the data.
     ; The given connection <b>MUST</b> be unique to this object.  This does not block while waiting for the connection
     ; to open, but will call either the {@link StreamConnection#connectionOpened()} or
     ; {@link StreamConnection#connectionClosed()} callback on the created network event processing thread.</p>
     ;
     ; @param connectTimeoutMillis The connect timeout set on the connection (in milliseconds).
     ;                             0 is interpreted as no timeout.
     ; @param socketFactory An object that creates {@link Socket} objects on demand, which may be customised to control
     ;                      how this client connects to the internet.  If not sure, use SocketFactory.getDefault().
     ; @param clientSet A set which this object will add itself to after initialization, and then remove itself from.
     ;;
    #_public
    (§ constructor BlockingClient(§ args #_final SocketAddress serverAddress, #_final StreamConnection connection, #_final int connectTimeoutMillis, #_final SocketFactory socketFactory, #_nilable #_final Set<BlockingClient> clientSet))
        (§ throws IOException)
    (§ block
        (§ ass connectFuture = SettableFuture.create(§ pars ))
        ;; Try to fit at least one message in the network buffer, but place an upper and lower limit on its size to make
        ;; sure it doesnt get too large or have to call read too often.
        (§ call connection.setWriteTarget(§ pars this))
        (§ ass socket = socketFactory.createSocket(§ pars ))
        #_final
        (§ var Context context = Context.get(§ pars ))
        (§ var Thread t = new Thread(§ pars )
        (§ anon
            #_override
            #_public
            (§ method void run(§ args ))
            (§ block
                (§ call Context.propagate(§ pars context))
                (§ if (§ expr clientSet != nil))
                (§ block
                    (§ call clientSet.add(§ pars BlockingClient.this))
                )
                (§ try )
                (§ block
                    (§ call socket.connect(§ pars serverAddress, connectTimeoutMillis))
                    (§ call connection.connectionOpened(§ pars ))
                    (§ call connectFuture.set(§ pars serverAddress))
                    (§ var InputStream stream = socket.getInputStream(§ pars ))
                    (§ call runReadLoop(§ pars stream, connection))
                )
                (§ catch (§ args Exception e))
                (§ block
                    (§ if (§ expr !vCloseRequested))
                    (§ block
                        (§ call log.error(§ pars "Error trying to open/read from connection: {}: {}", serverAddress, e.getMessage(§ pars )))
                        (§ call connectFuture.setException(§ pars e))
                    )
                )
                (§ finally )
                (§ block
                    (§ try )
                    (§ block
                        (§ call socket.close(§ pars ))
                    )
                    (§ catch (§ args IOException e1))
                    (§ block
                        ;; At this point there isn't much we can do, and we can probably assume the channel is closed.
                    )
                    (§ if (§ expr clientSet != nil))
                    (§ block
                        (§ call clientSet.remove(§ pars BlockingClient.this))
                    )
                    (§ call connection.connectionClosed(§ pars ))
                )
            )
        ))
        (§ call t.setName(§ pars "BlockingClient network thread for " + serverAddress))
        (§ call t.setDaemon(§ pars true))
        (§ call t.start(§ pars ))
    )

    ;;;
     ; A blocking call that never returns, except by throwing an exception.  It reads bytes from the input stream
     ; and feeds them to the provided {@link StreamConnection}, for example, a {@link Peer}.
     ;;
    #_public
    #_static
    (§ method void runReadLoop(§ args InputStream stream, StreamConnection connection))
        (§ throws Exception)
    (§ block
        (§ var ByteBuffer dbuf = ByteBuffer.allocateDirect(§ pars Math.min(§ pars Math.max(§ pars connection.getMaxMessageSize(§ pars ), BUFFER_SIZE_LOWER_BOUND), BUFFER_SIZE_UPPER_BOUND)))
        (§ var byte[] readBuff = new byte[dbuf.capacity(§ pars )])
        (§ while (§ expr true))
        (§ block
            ;; TODO: Kill the message duplication here.
            (§ call Preconditions.checkState(§ pars 0 < dbuf.remaining(§ pars ) && dbuf.remaining(§ pars ) <= readBuff.length))
            (§ var int read = stream.read(§ pars readBuff, 0, Math.max(§ pars 1, Math.min(§ pars dbuf.remaining(§ pars ), stream.available(§ pars )))))
            (§ if (§ expr read == -1))
            (§ block
                (§ return )
            )

            (§ call dbuf.put(§ pars readBuff, 0, read))
            ;; "flip" the buffer - setting the limit to the current position and setting position to 0
            (§ call dbuf.flip(§ pars ))
            ;; Use connection.receiveBytes's return value as a double-check that it stopped reading at the right location.
            (§ var int bytesConsumed = connection.receiveBytes(§ pars dbuf))
            (§ call Preconditions.checkState(§ pars dbuf.position(§ pars ) == bytesConsumed))
            ;; Now drop the bytes which were read by compacting dbuf (resetting limit and keeping relative position).
            (§ call dbuf.compact(§ pars ))
        )
    )

    ;;;
     ; Closes the connection to the server, triggering the {@link StreamConnection#connectionClosed()}
     ; event on the network-handling thread where all callbacks occur.
     ;;
    #_override
    #_public
    (§ method void closeConnection(§ args ))
    (§ block
        ;; Closes the channel, triggering an exception in the network-handling thread triggering connectionClosed().
        (§ try )
        (§ block
            (§ ass vCloseRequested = true)
            (§ call socket.close(§ pars ))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )

    #_override
    #_public
    #_synchronized
    (§ method void writeBytes(§ args byte[] message))
        (§ throws IOException)
    (§ block
        (§ try )
        (§ block
            (§ var OutputStream stream = socket.getOutputStream(§ pars ))
            (§ call stream.write(§ pars message))
            (§ call stream.flush(§ pars ))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ call log.error(§ pars "Error writing message to connection, closing connection", e))
            (§ call closeConnection(§ pars ))
            (§ throw e)
        )
    )

    ;;; Returns a future that completes once connection has occurred at the socket level or with an exception if failed to connect. ;;
    #_public
    (§ method ListenableFuture<SocketAddress> getConnectFuture(§ args ))
    (§ block
        (§ return connectFuture)
    )
)

#_(ns org.bitcoinj.net #_"BlockingClientManager"
    (:import [java.io IOException]
             [java.net SocketAddress]
             [java.util Collections HashSet Iterator Set]
             [javax.net SocketFactory])
    (:import [com.google.common.base Preconditions]
             [com.google.common.util.concurrent AbstractIdleService ListenableFuture]))

;;;
 ; <p>A thin wrapper around a set of {@link BlockingClient}s.</p>
 ;
 ; <p>Generally, using {@link NioClient} and {@link NioClientManager} should be preferred over {@link BlockingClient}
 ; and {@link BlockingClientManager} as they scale significantly better, unless you wish to connect over a proxy or use
 ; some other network settings that cannot be set using NIO.</p>
 ;;
#_public
(§ class BlockingClientManager extends AbstractIdleService implements ClientConnectionManager
    #_private
    #_final
    (§ field SocketFactory socketFactory)
    #_private
    #_final
    (§ field Set<BlockingClient> clients = Collections.synchronizedSet(§ pars new HashSet<BlockingClient>(§ pars )))

    #_private
    (§ field int connectTimeoutMillis = 1000)

    #_public
    (§ constructor BlockingClientManager(§ args ))
    (§ block
        (§ ass socketFactory = SocketFactory.getDefault(§ pars ))
    )

    ;;;
     ; Creates a blocking client manager that will obtain sockets from the given factory.
     ; Useful for customising how bitcoinj connects to the P2P network.
     ;;
    #_public
    (§ constructor BlockingClientManager(§ args SocketFactory socketFactory))
    (§ block
        (§ ass this.socketFactory = Preconditions.checkNotNull(§ pars socketFactory))
    )

    #_override
    #_public
    (§ method ListenableFuture<SocketAddress> openConnection(§ args SocketAddress serverAddress, StreamConnection connection))
    (§ block
        (§ try )
        (§ block
            (§ if (§ expr !isRunning(§ pars )))
            (§ block
                (§ throw (§ new IllegalStateException(§ pars )))
            )

            (§ return (§ new BlockingClient(§ pars serverAddress, connection, connectTimeoutMillis, socketFactory, clients)).getConnectFuture(§ pars ))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; This should only happen if we are, e.g. out of system resources.
        )
    )

    ;;; Sets the number of milliseconds to wait before giving up on a connect attempt. ;;
    #_public
    (§ method void setConnectTimeoutMillis(§ args int connectTimeoutMillis))
    (§ block
        (§ ass this.connectTimeoutMillis = connectTimeoutMillis)
    )

    #_override
    #_protected
    (§ method void startUp(§ args ))
        (§ throws Exception)
    (§ block
    )

    #_override
    #_protected
    (§ method void shutDown(§ args ))
        (§ throws Exception)
    (§ block
        (§ sync clients)
        (§ block
            (§ for (§ var BlockingClient client) :for (§ expr clients))
            (§ block
                (§ call client.closeConnection(§ pars ))
            )
        )
    )

    #_override
    #_public
    (§ method int getConnectedClientCount(§ args ))
    (§ block
        (§ return clients.size(§ pars ))
    )

    #_override
    #_public
    (§ method void closeConnections(§ args int n))
    (§ block
        (§ if (§ expr !isRunning(§ pars )))
        (§ block
            (§ throw (§ new IllegalStateException(§ pars )))
        )

        (§ sync clients)
        (§ block
            (§ for (§ var Iterator<BlockingClient> it = clients.iterator(§ pars )) :for (§ expr 0 < n && it.hasNext(§ pars )) :for (§ ass n = n - 1))
            (§ block
                (§ call it.next(§ pars ).closeConnection(§ pars ))
            )
        )
    )
)

#_(ns org.bitcoinj.net #_"ClientConnectionManager"
    (:import [java.net SocketAddress])
    (:import [com.google.common.util.concurrent ListenableFuture Service]))

;;;
 ; <p>A generic interface for an object which keeps track of a set of open client connections, creates new ones and
 ; ensures they are serviced properly.</p>
 ;
 ; <p>When the service is {@link com.google.common.util.concurrent.Service#stop()}ed, all connections will be closed
 ; and the appropriate connectionClosed() calls must be made.</p>
 ;;
#_public
(§ interface ClientConnectionManager extends Service
    ;;;
     ; Creates a new connection to the given address, with the given connection used to handle incoming data.  Any errors
     ; that occur during connection will be returned in the given future, including errors that can occur immediately.
     ;;
    (§ method ListenableFuture<SocketAddress> openConnection(§ args SocketAddress serverAddress, StreamConnection connection))

    ;;; Gets the number of connected peers. ;;
    (§ method int getConnectedClientCount(§ args ))

    ;;; Closes n peer connections. ;;
    (§ method void closeConnections(§ args int n))
)

#_(ns org.bitcoinj.net #_"ConnectionHandler"
    (:import [java.io IOException]
             [java.nio ByteBuffer]
             [java.nio.channels CancelledKeyException SelectionKey SocketChannel]
             [java.util Arrays Iterator LinkedList Set]
             [java.util.concurrent.locks ReentrantLock]
             [javax.annotation.concurrent GuardedBy])
    (:import [com.google.common.base Preconditions Throwables]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core Message]
             [org.bitcoinj.utils Threading]))

;; TODO: The locking in all this class is horrible and not really necessary.  We should just run all network stuff on one thread.

;;;
 ; A simple NIO MessageWriteTarget which handles all the business logic of a connection (reading+writing bytes).
 ; Used only by the NioClient and NioServer classes.
 ;;
(§ class ConnectionHandler implements MessageWriteTarget
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars ConnectionHandler.class))

    #_private
    #_static
    #_final
    (§ field int BUFFER_SIZE_LOWER_BOUND = 4096)
    #_private
    #_static
    #_final
    (§ field int BUFFER_SIZE_UPPER_BOUND = 65536)

    #_private
    #_static
    #_final
    (§ field int OUTBOUND_BUFFER_BYTE_COUNT = Message.MAX_SIZE + 24) ;; 24 byte message header

    ;; We lock when touching local flags and when writing data, but NEVER when calling any methods which leave
    ;; this class into non-Java classes.
    #_private
    #_final
    (§ field ReentrantLock lock = Threading.lock(§ pars "nioConnectionHandler"))
    #_guarded-by(§ opt "lock")
    #_private
    #_final
    (§ field ByteBuffer readBuff)
    #_guarded-by(§ opt "lock")
    #_private
    #_final
    (§ field SocketChannel channel)
    #_guarded-by(§ opt "lock")
    #_private
    #_final
    (§ field SelectionKey key)
    #_guarded-by(§ opt "lock")
    (§ field StreamConnection connection)
    #_guarded-by(§ opt "lock")
    #_private
    (§ field boolean closeCalled = false)

    #_guarded-by(§ opt "lock")
    #_private
    (§ field long bytesToWriteRemaining = 0)
    #_guarded-by(§ opt "lock")
    #_private
    #_final
    (§ field LinkedList<ByteBuffer> bytesToWrite = new LinkedList<>(§ pars ))

    #_private
    (§ field Set<ConnectionHandler> connectedHandlers)

    #_public
    (§ constructor ConnectionHandler(§ args StreamConnectionFactory connectionFactory, SelectionKey key))
        (§ throws IOException)
    (§ block
        (§ this (§ pars connectionFactory.getNewConnection(§ pars (§ expr (§ cast SocketChannel)key.channel(§ pars )).socket(§ pars ).getInetAddress(§ pars ), (§ expr (§ cast SocketChannel)key.channel(§ pars )).socket(§ pars ).getPort(§ pars )), key))
        (§ if (§ expr connection == nil))
        (§ block
            (§ throw (§ new IOException(§ pars "Parser factory.getNewConnection returned nil")))
        )
    )

    #_private
    (§ constructor ConnectionHandler(§ args #_nilable StreamConnection connection, SelectionKey key))
    (§ block
        (§ ass this.key = key)
        (§ ass this.channel = Preconditions.checkNotNull(§ pars (§ expr (§ cast SocketChannel)key.channel(§ pars ))))
        (§ if (§ expr connection == nil))
        (§ block
            (§ ass readBuff = nil)
            (§ return )
        )

        (§ ass this.connection = connection)
        (§ ass readBuff = ByteBuffer.allocateDirect(§ pars Math.min(§ pars Math.max(§ pars connection.getMaxMessageSize(§ pars ), BUFFER_SIZE_LOWER_BOUND), BUFFER_SIZE_UPPER_BOUND)))
        (§ call connection.setWriteTarget(§ pars this)) ;; May callback into us (e.g. closeConnection() now).
        (§ ass connectedHandlers = nil)
    )

    #_public
    (§ constructor ConnectionHandler(§ args StreamConnection connection, SelectionKey key, Set<ConnectionHandler> connectedHandlers))
    (§ block
        (§ this (§ pars Preconditions.checkNotNull(§ pars connection), key))

        ;; closeConnection() may have already happened because we invoked the other c'tor above, which called
        ;; connection.setWriteTarget which might have re-entered already.  In this case we shouldn't add ourselves
        ;; to the connectedHandlers set.
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass this.connectedHandlers = connectedHandlers)
            (§ if (§ expr !closeCalled))
            (§ block
                (§ call Preconditions.checkState(§ pars this.connectedHandlers.add(§ pars this)))
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_guarded-by(§ opt "lock")
    #_private
    (§ method void setWriteOps(§ args ))
    (§ block
        ;; Make sure we are registered to get updated when writing is available again.
        (§ call key.interestOps(§ pars key.interestOps(§ pars ) | SelectionKey.OP_WRITE))
        ;; Refresh the selector to make sure it gets the new interestOps.
        (§ call key.selector(§ pars ).wakeup(§ pars ))
    )

    ;; Tries to write any outstanding write bytes, runs in any thread (possibly unlocked).
    #_private
    (§ method void tryWriteBytes(§ args ))
        (§ throws IOException)
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; Iterate through the outbound ByteBuff queue, pushing as much as possible into the OS' network buffer.
            (§ var Iterator<ByteBuffer> bytesIterator = bytesToWrite.iterator(§ pars ))
            (§ while (§ expr bytesIterator.hasNext(§ pars )))
            (§ block
                (§ var ByteBuffer buff = bytesIterator.next(§ pars ))
                (§ ass bytesToWriteRemaining = bytesToWriteRemaining - channel.write(§ pars buff))
                (§ if (§ expr !buff.hasRemaining(§ pars )))
                (§ block
                    (§ call bytesIterator.remove(§ pars ))
                )
                (§ else )
                (§ block
                    (§ call setWriteOps(§ pars ))
                    (§ break )
                )
            )
            ;; If we are done writing, clear the OP_WRITE interestOps.
            (§ if (§ expr bytesToWrite.isEmpty(§ pars )))
            (§ block
                (§ call key.interestOps(§ pars key.interestOps(§ pars ) & ~SelectionKey.OP_WRITE))
            )
            ;; Don't bother waking up the selector here, since we're just removing an op, not adding.
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method void writeBytes(§ args byte[] message))
        (§ throws IOException)
    (§ block
        (§ var boolean andUnlock = true)
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; Network buffers are not unlimited (and are often smaller than some messages we may wish to send), and
            ;; thus we have to buffer outbound messages sometimes.  To do this, we use a queue of ByteBuffers and just
            ;; append to it when we want to send a message.  We then let tryWriteBytes() either send the message or
            ;; register our SelectionKey to wakeup when we have free outbound buffer space available.
            (§ if (§ expr OUTBOUND_BUFFER_BYTE_COUNT < bytesToWriteRemaining + message.length))
            (§ block
                (§ throw (§ new IOException(§ pars "Outbound buffer overflowed")))
            )

            ;; Just dump the message onto the write buffer and call tryWriteBytes.
            ;; TODO: Kill the needless message duplication when the write completes right away.
            (§ call bytesToWrite.offer(§ pars ByteBuffer.wrap(§ pars Arrays.copyOf(§ pars message, message.length))))
            (§ ass bytesToWriteRemaining = bytesToWriteRemaining + message.length)
            (§ call setWriteOps(§ pars ))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ call lock.unlock(§ pars ))
            (§ ass andUnlock = false)
            (§ call log.warn(§ pars "Error writing message to connection, closing connection", e))
            (§ call closeConnection(§ pars ))
            (§ throw e)
        )
        (§ catch (§ args CancelledKeyException e))
        (§ block
            (§ call lock.unlock(§ pars ))
            (§ ass andUnlock = false)
            (§ call log.warn(§ pars "Error writing message to connection, closing connection", e))
            (§ call closeConnection(§ pars ))
            (§ throw (§ new IOException(§ pars e)))
        )
        (§ finally )
        (§ block
            (§ if (§ expr andUnlock))
            (§ block
                (§ call lock.unlock(§ pars ))
            )
        )
    )

    ;; May NOT be called with lock held.
    #_override
    #_public
    (§ method void closeConnection(§ args ))
    (§ block
        (§ call Preconditions.checkState(§ pars !lock.isHeldByCurrentThread(§ pars )))
        (§ try )
        (§ block
            (§ call channel.close(§ pars ))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e)))
        )
        (§ call connectionClosed(§ pars ))
    )

    #_private
    (§ method void connectionClosed(§ args ))
    (§ block
        (§ var boolean callClosed = false)
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass callClosed = !closeCalled)
            (§ ass closeCalled = true)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
        (§ if (§ expr callClosed))
        (§ block
            (§ call Preconditions.checkState(§ pars connectedHandlers == nil || connectedHandlers.remove(§ pars this)))
            (§ call connection.connectionClosed(§ pars ))
        )
    )

    ;; Handle a SelectionKey which was selected.
    ;; Runs unlocked as the caller is single-threaded (or if not, should enforce that handleKey is only called
    ;; atomically for a given ConnectionHandler).
    #_public
    #_static
    (§ method void handleKey(§ args SelectionKey key))
    (§ block
        (§ var ConnectionHandler handler = (§ cast ConnectionHandler)key.attachment(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr handler == nil))
            (§ block
                (§ return )
            )
            (§ if (§ expr !key.isValid(§ pars )))
            (§ block
                (§ call handler.closeConnection(§ pars )) ;; Key has been cancelled, make sure the socket gets closed.
                (§ return )
            )
            (§ if (§ expr key.isReadable(§ pars )))
            (§ block
                ;; Do a socket read and invoke the connection's receiveBytes message.
                (§ var int read = handler.channel.read(§ pars handler.readBuff))
                (§ if (§ expr read == 0))
                (§ block
                    (§ return ) ;; Was probably waiting on a write.
                )
                (§ elseif (§ expr read == -1)) ;; Socket was closed.
                (§ block
                    (§ call key.cancel(§ pars ))
                    (§ call handler.closeConnection(§ pars ))
                    (§ return )
                )
                ;; "flip" the buffer - setting the limit to the current position and setting position to 0
                (§ call handler.readBuff.flip(§ pars ))
                ;; Use connection.receiveBytes's return value as a check that it stopped reading at the right location.
                (§ var int bytesConsumed = Preconditions.checkNotNull(§ pars handler.connection).receiveBytes(§ pars handler.readBuff))
                (§ call Preconditions.checkState(§ pars handler.readBuff.position(§ pars ) == bytesConsumed))
                ;; Now drop the bytes which were read by compacting readBuff (resetting limit and keeping relative position).
                (§ call handler.readBuff.compact(§ pars ))
            )
            (§ if (§ expr key.isWritable(§ pars )))
            (§ block
                (§ call handler.tryWriteBytes(§ pars ))
            )
        )
        (§ catch (§ args Exception e))
        (§ block
            ;; This can happen e.g. if the channel closes while the thread is about to get killed
            ;; (ClosedByInterruptException), or if handler.connection.receiveBytes throws something.
            (§ var Throwable t = Throwables.getRootCause(§ pars e))
            (§ call log.warn(§ pars "Error handling SelectionKey: {} {}", t.getClass(§ pars ).getName(§ pars ), (§ expr t.getMessage(§ pars ) != nil) ? t.getMessage(§ pars ) :else "", e))
            (§ call handler.closeConnection(§ pars ))
        )
    )
)

#_(ns org.bitcoinj.net #_"FilterMerger"
    (:import [java.util LinkedList])
    (:import [com.google.common.collect ImmutableList Lists])
   (:require [org.bitcoinj.core BloomFilter PeerFilterProvider]))

;;;
 ; <p>A reusable object that will calculate, given a list of {@link org.bitcoinj.core.PeerFilterProvider}s, a merged
 ; {@link org.bitcoinj.core.BloomFilter} and earliest key time for all of them.
 ; Used by the {@link org.bitcoinj.core.PeerGroup} class internally.</p>
 ;
 ; <p>Thread safety: threading here can be complicated.  Each filter provider is given a begin event, which may acquire
 ; a lock (and is guaranteed to receive an end event).  This class is mostly thread unsafe and is meant to be used from
 ; a single thread only, PeerGroup ensures this by only accessing it from the dedicated PeerGroup thread.  PeerGroup
 ; does not hold any locks whilst this object is used, relying on the single thread to prevent multiple filters being
 ; calculated in parallel, thus a filter provider can do things like make blocking calls into PeerGroup from a separate
 ; thread.  However the bloomFilterFPRate property IS thread safe, for convenience.</p>
 ;;
#_public
(§ class FilterMerger
    ;; We use a constant tweak to avoid giving up privacy when we regenerate our filter with new keys.
    #_private
    #_final
    (§ field long bloomFilterTweak = (§ cast long)(§ expr Math.random(§ pars ) * Long.MAX_VALUE))

    #_private
    #_volatile
    (§ field double vBloomFilterFPRate)
    #_private
    (§ field int lastBloomFilterElementCount)
    #_private
    (§ field BloomFilter lastFilter)

    #_public
    (§ constructor FilterMerger(§ args double bloomFilterFPRate))
    (§ block
        (§ ass this.vBloomFilterFPRate = bloomFilterFPRate)
    )

    #_public
    #_static
    (§ class Result
        #_public
        (§ field BloomFilter filter)
        #_public
        (§ field long earliestKeyTimeSecs)
        #_public
        (§ field boolean changed)
    )

    #_public
    (§ method Result calculate(§ args ImmutableList<PeerFilterProvider> providers))
    (§ block
        (§ var LinkedList<PeerFilterProvider> begunProviders = Lists.newLinkedList(§ pars ))
        (§ try )
        (§ block
            ;; All providers must be in a consistent, unchanging state because the filter is a merged one that's
            ;; large enough for all providers elements: if a provider were to get more elements in the middle of the
            ;; calculation, we might assert or calculate the filter wrongly.  Most providers use a lock here but
            ;; snapshotting required state is also a legitimate strategy.
            (§ for (§ var PeerFilterProvider provider) :for (§ expr providers))
            (§ block
                (§ call provider.beginBloomFilterCalculation(§ pars ))
                (§ call begunProviders.add(§ pars provider))
            )
            (§ var Result result = new Result(§ pars ))
            (§ ass result.earliestKeyTimeSecs = Long.MAX_VALUE)
            (§ var int elements = 0)
            (§ var boolean requiresUpdateAll = false)
            (§ for (§ var PeerFilterProvider p) :for (§ expr providers))
            (§ block
                (§ ass result.earliestKeyTimeSecs = Math.min(§ pars result.earliestKeyTimeSecs, p.getEarliestKeyCreationTime(§ pars )))
                (§ ass elements = elements + p.getBloomFilterElementCount(§ pars ))
            )

            (§ if (§ expr 0 < elements))
            (§ block
                ;; We stair-step our element count so that we avoid creating a filter with different parameters
                ;; as much as possible as that results in a loss of privacy.
                ;; The constant 100 here is somewhat arbitrary, but makes sense for small to medium wallets -
                ;; it will likely mean we never need to create a filter with different parameters.
                (§ ass lastBloomFilterElementCount = (§ expr lastBloomFilterElementCount < elements) ? elements + 100 :else lastBloomFilterElementCount)
                (§ var BloomFilter.BloomUpdate bloomFlags = requiresUpdateAll ? BloomFilter.BloomUpdate.UPDATE_ALL :else BloomFilter.BloomUpdate.UPDATE_P2PUBKEY_ONLY)
                (§ var double fpRate = vBloomFilterFPRate)
                (§ var BloomFilter filter = new BloomFilter(§ pars lastBloomFilterElementCount, fpRate, bloomFilterTweak, bloomFlags))
                (§ for (§ var PeerFilterProvider p) :for (§ expr providers))
                (§ block
                    (§ call filter.merge(§ pars p.getBloomFilter(§ pars lastBloomFilterElementCount, fpRate, bloomFilterTweak)))
                )

                (§ ass result.changed = !filter.equals(§ pars lastFilter))
                (§ ass result.filter = lastFilter = filter)
            )
            ;; Now adjust the earliest key time backwards by a week to handle the case of clock drift.  This can occur
            ;; both in block header timestamps and if the users clock was out of sync when the key was first created
            ;; (to within a small amount of tolerance).
            (§ ass result.earliestKeyTimeSecs = earliestKeyTimeSecs - (§ expr 86400 * 7))
            (§ return result)
        )
        (§ finally )
        (§ block
            (§ for (§ var PeerFilterProvider provider) :for (§ expr begunProviders))
            (§ block
                (§ call provider.endBloomFilterCalculation(§ pars ))
            )
        )
    )

    #_public
    (§ method void setBloomFilterFPRate(§ args double bloomFilterFPRate))
    (§ block
        (§ ass this.vBloomFilterFPRate = bloomFilterFPRate)
    )

    #_public
    (§ method double getBloomFilterFPRate(§ args ))
    (§ block
        (§ return vBloomFilterFPRate)
    )

    #_public
    (§ method BloomFilter getLastFilter(§ args ))
    (§ block
        (§ return lastFilter)
    )
)

#_(ns org.bitcoinj.net #_"MessageWriteTarget"
    (:import [java.io IOException]))

;;;
 ; A target to which messages can be written/connection can be closed.
 ;;
#_public
(§ interface MessageWriteTarget
    ;;;
     ; Writes the given bytes to the remote server.
     ;;
    (§ method void writeBytes(§ args byte[] message))
        (§ throws IOException)
    ;;;
     ; Closes the connection to the server, triggering the {@link StreamConnection#connectionClosed()}
     ; event on the network-handling thread where all callbacks occur.
     ;;
    (§ method void closeConnection(§ args ))
)

#_(ns org.bitcoinj.net #_"NioClient"
    (:import [java.io *]
             [java.net *]
             [java.nio *])
    (:import [com.google.common.base *]
             [com.google.common.util.concurrent *]
             [org.slf4j *]))

;;;
 ; Creates a simple connection to a server using a {@link StreamConnection} to process data.
 ;;
#_public
(§ class NioClient implements MessageWriteTarget
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars NioClient.class))

    #_private
    #_final
    (§ field Handler handler)
    #_private
    #_final
    (§ field NioClientManager manager = new NioClientManager(§ pars ))

    (§ class Handler extends AbstractTimeoutHandler implements StreamConnection
        #_private
        #_final
        (§ field StreamConnection upstreamConnection)
        #_private
        (§ field MessageWriteTarget writeTarget)
        #_private
        (§ field boolean closeOnOpen)
        #_private
        (§ field boolean closeCalled)

        (§ constructor Handler(§ args StreamConnection upstreamConnection, int connectTimeoutMillis))
        (§ block
            (§ ass this.upstreamConnection = upstreamConnection)
            (§ call setSocketTimeout(§ pars connectTimeoutMillis))
            (§ call setTimeoutEnabled(§ pars true))
        )

        #_override
        #_protected
        #_synchronized
        (§ method void timeoutOccurred(§ args ))
        (§ block
            (§ ass closeOnOpen = true)
            (§ call connectionClosed(§ pars ))
        )

        #_override
        #_public
        #_synchronized
        (§ method void connectionClosed(§ args ))
        (§ block
            (§ call manager.stopAsync(§ pars ))
            (§ if (§ expr !closeCalled))
            (§ block
                (§ ass closeCalled = true)
                (§ call upstreamConnection.connectionClosed(§ pars ))
            )
        )

        #_override
        #_public
        #_synchronized
        (§ method void connectionOpened(§ args ))
        (§ block
            (§ if (§ expr !closeOnOpen))
            (§ block
                (§ call upstreamConnection.connectionOpened(§ pars ))
            )
        )

        #_override
        #_public
        (§ method int receiveBytes(§ args ByteBuffer buff))
            (§ throws Exception)
        (§ block
            (§ return upstreamConnection.receiveBytes(§ pars buff))
        )

        #_override
        #_public
        #_synchronized
        (§ method void setWriteTarget(§ args MessageWriteTarget writeTarget))
        (§ block
            (§ if (§ expr closeOnOpen))
            (§ block
                (§ call writeTarget.closeConnection(§ pars ))
            )
            (§ else )
            (§ block
                (§ call setTimeoutEnabled(§ pars false))
                (§ ass this.writeTarget = writeTarget)
                (§ call upstreamConnection.setWriteTarget(§ pars writeTarget))
            )
        )

        #_override
        #_public
        (§ method int getMaxMessageSize(§ args ))
        (§ block
            (§ return upstreamConnection.getMaxMessageSize(§ pars ))
        )
    )

    ;;;
     ; <p>Creates a new client to the given server address using the given {@link StreamConnection} to decode the data.
     ; The given connection <b>MUST</b> be unique to this object.  This does not block while waiting for the connection
     ; to open, but will call either the {@link StreamConnection#connectionOpened()} or
     ; {@link StreamConnection#connectionClosed()} callback on the created network event processing thread.</p>
     ;
     ; @param connectTimeoutMillis The connect timeout set on the connection (in milliseconds).
     ;                             0 is interpreted as no timeout.
     ;;
    #_public
    (§ constructor NioClient(§ args #_final SocketAddress serverAddress, #_final StreamConnection parser, #_final int connectTimeoutMillis))
        (§ throws IOException)
    (§ block
        (§ call manager.startAsync(§ pars ))
        (§ call manager.awaitRunning(§ pars ))
        (§ ass handler = new Handler(§ pars parser, connectTimeoutMillis))
        (§ call Futures.addCallback(§ pars manager.openConnection(§ pars serverAddress, handler), new FutureCallback<SocketAddress>(§ pars )
        (§ anon
            #_override
            #_public
            (§ method void onSuccess(§ args SocketAddress result))
            (§ block
            )

            #_override
            #_public
            (§ method void onFailure(§ args Throwable t))
            (§ block
                (§ call log.error(§ pars "Connect to {} failed: {}", serverAddress, Throwables.getRootCause(§ pars t)))
            )
        )))
    )

    #_override
    #_public
    (§ method void closeConnection(§ args ))
    (§ block
        (§ call handler.writeTarget.closeConnection(§ pars ))
    )

    #_override
    #_public
    #_synchronized
    (§ method void writeBytes(§ args byte[] message))
        (§ throws IOException)
    (§ block
        (§ call handler.writeTarget.writeBytes(§ pars message))
    )
)

#_(ns org.bitcoinj.net #_"NioClientManager"
    (:import [java.io IOException]
             [java.net ConnectException SocketAddress]
             [java.nio.channels *]
             [java.nio.channels.spi SelectorProvider]
             [java.util *]
             [java.util.concurrent *])
    (:import [com.google.common.base Throwables]
             [com.google.common.util.concurrent *]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.utils *]))

;;;
 ; A class which manages a set of client connections.  Uses Java NIO to select network events and processes them
 ; in a single network processing thread.
 ;;
#_public
(§ class NioClientManager extends AbstractExecutionThreadService implements ClientConnectionManager
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars NioClientManager.class))

    #_private
    #_final
    (§ field Selector selector)

    (§ class PendingConnect
        (§ var SocketChannel sc)
        (§ var StreamConnection connection)
        (§ var SocketAddress address)
        (§ var SettableFuture<SocketAddress> future = SettableFuture.create(§ pars ))

        (§ constructor PendingConnect(§ args SocketChannel sc, StreamConnection connection, SocketAddress address))
        (§ block
            (§ ass this.sc = sc)
            (§ ass this.connection = connection)
            (§ ass this.address = address)
        )
    )
    #_final
    (§ field Queue<PendingConnect> newConnectionChannels = new LinkedBlockingQueue<>(§ pars ))

    ;; Added to/removed from by the individual ConnectionHandler's, thus must by synchronized on its own.
    #_private
    #_final
    (§ field Set<ConnectionHandler> connectedHandlers = Collections.synchronizedSet(§ pars new HashSet<ConnectionHandler>(§ pars )))

    ;; Handle a SelectionKey which was selected.
    #_private
    (§ method void handleKey(§ args SelectionKey key))
        (§ throws IOException)
    (§ block
        ;; We could have a !isValid() key here if the connection is already closed at this point,
        ;; i.e. a client connection which has finished the initial connect process.
        (§ if (§ expr key.isValid(§ pars ) && key.isConnectable(§ pars )))
        (§ block
            ;; Create a ConnectionHandler and hook everything together.
            (§ var PendingConnect data = (§ cast PendingConnect)key.attachment(§ pars ))
            (§ var StreamConnection connection = data.connection)
            (§ var SocketChannel sc = (§ cast SocketChannel)key.channel(§ pars ))
            (§ var ConnectionHandler handler = new ConnectionHandler(§ pars connection, key, connectedHandlers))
            (§ try )
            (§ block
                (§ if (§ expr sc.finishConnect(§ pars )))
                (§ block
                    (§ call log.info(§ pars "Connected to {}", sc.socket(§ pars ).getRemoteSocketAddress(§ pars )))
                    (§ call key.interestOps(§ pars (§ expr key.interestOps(§ pars ) | SelectionKey.OP_READ) & ~SelectionKey.OP_CONNECT).attach(§ pars handler))
                    (§ call connection.connectionOpened(§ pars ))
                    (§ call data.future.set(§ pars data.address))
                )
                (§ else )
                (§ block
                    (§ call log.warn(§ pars "Failed to connect to {}", sc.socket(§ pars ).getRemoteSocketAddress(§ pars )))
                    (§ call handler.closeConnection(§ pars )) ;; Failed to connect for some reason.
                    (§ call data.future.setException(§ pars (§ new ConnectException(§ pars "Unknown reason"))))
                    (§ ass data.future = nil)
                )
            )
            (§ catch (§ args Exception e))
            (§ block
                ;; If e is a CancelledKeyException, there is a race to get to interestOps after finishConnect() which
                ;; may cause this.  Otherwise it may be any arbitrary kind of connection failure.
                ;; Calling sc.socket().getRemoteSocketAddress() here throws an exception, so we can only log the error itself.
                (§ var Throwable cause = Throwables.getRootCause(§ pars e))
                (§ call log.warn(§ pars "Failed to connect with exception: {}: {}", cause.getClass(§ pars ).getName(§ pars ), cause.getMessage(§ pars ), e))
                (§ call handler.closeConnection(§ pars ))
                (§ call data.future.setException(§ pars cause))
                (§ ass data.future = nil)
            )
        )
        (§ else ) ;; Process bytes read.
        (§ block
            (§ call ConnectionHandler.handleKey(§ pars key))
        )
    )

    ;;;
     ; Creates a new client manager which uses Java NIO for socket management.
     ; Uses a single thread to handle all select calls.
     ;;
    #_public
    (§ constructor NioClientManager(§ args ))
    (§ block
        (§ try )
        (§ block
            (§ ass selector = SelectorProvider.provider(§ pars ).openSelector(§ pars ))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Shouldn't ever happen.
        )
    )

    #_override
    #_public
    (§ method void run(§ args ))
    (§ block
        (§ try )
        (§ block
            (§ call Thread.currentThread(§ pars ).setPriority(§ pars Thread.MIN_PRIORITY))
            (§ while (§ expr isRunning(§ pars )))
            (§ block
                (§ var PendingConnect conn)
                (§ while (§ expr (§ ass conn = newConnectionChannels.poll(§ pars )) != nil))
                (§ block
                    (§ try )
                    (§ block
                        (§ var SelectionKey key = conn.sc.register(§ pars selector, SelectionKey.OP_CONNECT))
                        (§ call key.attach(§ pars conn))
                    )
                    (§ catch (§ args ClosedChannelException _))
                    (§ block
                        (§ call log.warn(§ pars "SocketChannel was closed before it could be registered"))
                    )
                )

                (§ call selector.select(§ pars ))

                (§ var Iterator<SelectionKey> keyIterator = selector.selectedKeys(§ pars ).iterator(§ pars ))
                (§ while (§ expr keyIterator.hasNext(§ pars )))
                (§ block
                    (§ var SelectionKey key = keyIterator.next(§ pars ))
                    (§ call keyIterator.remove(§ pars ))
                    (§ call handleKey(§ pars key))
                )
            )
        )
        (§ catch (§ args Exception e))
        (§ block
            (§ call log.warn(§ pars "Error trying to open/read from connection: ", e))
        )
        (§ finally )
        (§ block
            ;; Go through and close everything, without letting IOExceptions get in our way.
            (§ for (§ var SelectionKey key) :for (§ expr selector.keys(§ pars )))
            (§ block
                (§ try )
                (§ block
                    (§ call key.channel(§ pars ).close(§ pars ))
                )
                (§ catch (§ args IOException e))
                (§ block
                    (§ call log.warn(§ pars "Error closing channel", e))
                )
                (§ call key.cancel(§ pars ))
                (§ if (§ expr key.attachment(§ pars ) instanceof ConnectionHandler))
                (§ block
                    (§ call ConnectionHandler.handleKey(§ pars key)) ;; Close connection if relevant.
                )
            )
            (§ try )
            (§ block
                (§ call selector.close(§ pars ))
            )
            (§ catch (§ args IOException e))
            (§ block
                (§ call log.warn(§ pars "Error closing client manager selector", e))
            )
        )
    )

    #_override
    #_public
    (§ method ListenableFuture<SocketAddress> openConnection(§ args SocketAddress serverAddress, StreamConnection connection))
    (§ block
        (§ if (§ expr !isRunning(§ pars )))
        (§ block
            (§ throw (§ new IllegalStateException(§ pars )))
        )

        ;; Create a new connection, give it a connection as an attachment.
        (§ try )
        (§ block
            (§ var SocketChannel sc = SocketChannel.open(§ pars ))
            (§ call sc.configureBlocking(§ pars false))
            (§ call sc.connect(§ pars serverAddress))
            (§ var PendingConnect data = new PendingConnect(§ pars sc, connection, serverAddress))
            (§ call newConnectionChannels.offer(§ pars data))
            (§ call selector.wakeup(§ pars ))
            (§ return data.future)
        )
        (§ catch (§ args Throwable e))
        (§ block
            (§ return Futures.immediateFailedFuture(§ pars e))
        )
    )

    #_override
    #_public
    (§ method void triggerShutdown(§ args ))
    (§ block
        (§ call selector.wakeup(§ pars ))
    )

    #_override
    #_public
    (§ method int getConnectedClientCount(§ args ))
    (§ block
        (§ return connectedHandlers.size(§ pars ))
    )

    #_override
    #_public
    (§ method void closeConnections(§ args int n))
    (§ block
        (§ for (§ var ) :for (§ expr 0 < n) :for (§ ass n = n - 1))
        (§ block
            (§ var ConnectionHandler handler)
            (§ sync connectedHandlers)
            (§ block
                (§ ass handler = connectedHandlers.iterator(§ pars ).next(§ pars ))
            )
            (§ if (§ expr handler != nil))
            (§ block
                (§ call handler.closeConnection(§ pars )) ;; Removes handler from connectedHandlers before returning.
            )
        )
    )

    #_override
    #_protected
    (§ method Executor executor(§ args ))
    (§ block
        (§ return (§ new Executor(§ pars ))
        (§ anon
            #_override
            #_public
            (§ method void execute(§ args Runnable command))
            (§ block
                (§ call (§ new ContextPropagatingThreadFactory(§ pars "NioClientManager")).newThread(§ pars command).start(§ pars ))
            )
        ))
    )
)

#_(ns org.bitcoinj.net #_"NioServer"
    (:import [java.io IOException]
             [java.net InetSocketAddress]
             [java.nio.channels *]
             [java.nio.channels.spi SelectorProvider]
             [java.util Iterator])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base Throwables]
             [com.google.common.util.concurrent AbstractExecutionThreadService]
             [org.slf4j Logger LoggerFactory]))

;;;
 ; Creates a simple server listener which listens for incoming client connections and uses a {@link StreamConnection}
 ; to process data.
 ;;
#_public
(§ class NioServer extends AbstractExecutionThreadService
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars NioServer.class))

    #_private
    #_final
    (§ field StreamConnectionFactory connectionFactory)

    #_private
    #_final
    (§ field ServerSocketChannel sc)
    #_testing
    #_final
    (§ field Selector selector)

    ;; Handle a SelectionKey which was selected.
    #_private
    (§ method void handleKey(§ args Selector selector, SelectionKey key))
        (§ throws IOException)
    (§ block
        (§ if (§ expr key.isValid(§ pars ) && key.isAcceptable(§ pars )))
        (§ block
            ;; Accept a new connection, give it a stream connection as an attachment.
            (§ var SocketChannel newChannel = sc.accept(§ pars ))
            (§ call newChannel.configureBlocking(§ pars false))
            (§ var SelectionKey newKey = newChannel.register(§ pars selector, SelectionKey.OP_READ))
            (§ try )
            (§ block
                (§ var ConnectionHandler handler = new ConnectionHandler(§ pars connectionFactory, newKey))
                (§ call newKey.attach(§ pars handler))
                (§ call handler.connection.connectionOpened(§ pars ))
            )
            (§ catch (§ args IOException e))
            (§ block
                ;; This can happen if ConnectionHandler's call to get a new handler returned null.
                (§ call log.error(§ pars "Error handling new connection", Throwables.getRootCause(§ pars e).getMessage(§ pars )))
                (§ call newKey.channel(§ pars ).close(§ pars ))
            )
        )
        (§ else ) ;; Got a closing channel or a channel to a client connection.
        (§ block
            (§ call ConnectionHandler.handleKey(§ pars key))
        )
    )

    ;;;
     ; Creates a new server which is capable of listening for incoming connections and processing client provided data
     ; using {@link StreamConnection}s created by the given {@link StreamConnectionFactory}.
     ;
     ; @throws IOException if there is an issue opening the server socket or binding fails for some reason.
     ;;
    #_public
    (§ constructor NioServer(§ args #_final StreamConnectionFactory connectionFactory, InetSocketAddress bindAddress))
        (§ throws IOException)
    (§ block
        (§ ass this.connectionFactory = connectionFactory)

        (§ ass sc = ServerSocketChannel.open(§ pars ))
        (§ call sc.configureBlocking(§ pars false))
        (§ call sc.socket(§ pars ).bind(§ pars bindAddress))
        (§ ass selector = SelectorProvider.provider(§ pars ).openSelector(§ pars ))
        (§ call sc.register(§ pars selector, SelectionKey.OP_ACCEPT))
    )

    #_override
    #_protected
    (§ method void run(§ args ))
        (§ throws Exception)
    (§ block
        (§ try )
        (§ block
            (§ while (§ expr isRunning(§ pars )))
            (§ block
                (§ call selector.select(§ pars ))

                (§ var Iterator<SelectionKey> keyIterator = selector.selectedKeys(§ pars ).iterator(§ pars ))
                (§ while (§ expr keyIterator.hasNext(§ pars )))
                (§ block
                    (§ var SelectionKey key = keyIterator.next(§ pars ))
                    (§ call keyIterator.remove(§ pars ))

                    (§ call handleKey(§ pars selector, key))
                )
            )
        )
        (§ catch (§ args Exception e))
        (§ block
            (§ call log.error(§ pars "Error trying to open/read from connection: {}", e))
        )
        (§ finally )
        (§ block
            ;; Go through and close everything, without letting IOExceptions get in our way.
            (§ for (§ var SelectionKey key) :for (§ expr selector.keys(§ pars )))
            (§ block
                (§ try )
                (§ block
                    (§ call key.channel(§ pars ).close(§ pars ))
                )
                (§ catch (§ args IOException e))
                (§ block
                    (§ call log.error(§ pars "Error closing channel", e))
                )
                (§ try )
                (§ block
                    (§ call key.cancel(§ pars ))
                    (§ call handleKey(§ pars selector, key))
                )
                (§ catch (§ args IOException e))
                (§ block
                    (§ call log.error(§ pars "Error closing selection key", e))
                )
            )
            (§ try )
            (§ block
                (§ call selector.close(§ pars ))
            )
            (§ catch (§ args IOException e))
            (§ block
                (§ call log.error(§ pars "Error closing server selector", e))
            )
            (§ try )
            (§ block
                (§ call sc.close(§ pars ))
            )
            (§ catch (§ args IOException e))
            (§ block
                (§ call log.error(§ pars "Error closing server channel", e))
            )
        )
    )

    ;;;
     ; Invoked by the Execution service when it's time to stop.
     ; Calling this method directly will NOT stop the service, call
     ; {@link com.google.common.util.concurrent.AbstractExecutionThreadService#stop()} instead.
     ;;
    #_override
    #_public
    (§ method void triggerShutdown(§ args ))
    (§ block
        ;; Wake up the selector and let the selection thread break its loop as the ExecutionService !isRunning().
        (§ call selector.wakeup(§ pars ))
    )
)

#_(ns org.bitcoinj.net #_"ProtobufConnection"
    (:import [java.io IOException]
             [java.nio ByteBuffer ByteOrder]
             [java.util.concurrent.atomic AtomicReference]
             [java.util.concurrent.locks ReentrantLock]
             [javax.annotation.concurrent GuardedBy])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base Preconditions]
             [com.google.protobuf ByteString MessageLite]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core Utils]
             [org.bitcoinj.utils Threading]))

;;;
 ; <p>A handler which is used in {@link NioServer} and {@link NioClient} to split up incoming data streams
 ; into protobufs and provide an interface for writing protobufs to the connections.</p>
 ;
 ; <p>Messages are encoded with a 4-byte signed integer (big endian) prefix to indicate their length followed
 ; by the serialized protobuf.</p>
 ;;
#_public
(§ class ProtobufConnection<MessageType extends MessageLite> extends AbstractTimeoutHandler implements StreamConnection
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars ProtobufConnection.class))

    ;;;
     ; An interface which can be implemented to handle callbacks as new messages are generated and socket events occur.
     ; @param <MessageType> The protobuf type which is used on this socket.
     ;                      This <b>MUST</b> match the MessageType used in the parent {@link ProtobufConnection}.
     ;;
    #_public
    (§ interface Listener<MessageType extends MessageLite>
        ;;; Called when a new protobuf is received from the remote side. ;;
        (§ method void messageReceived(§ args ProtobufConnection<MessageType> handler, MessageType msg))
        ;;; Called when the connection is opened and available for writing data to. ;;
        (§ method void connectionOpen(§ args ProtobufConnection<MessageType> handler))
        ;;; Called when the connection is closed and no more data should be provided. ;;
        (§ method void connectionClosed(§ args ProtobufConnection<MessageType> handler))
    )

    ;; The callback listener.
    #_private
    #_final
    (§ field Listener<MessageType> handler)
    ;; The prototype which is used to deserialize messages.
    #_private
    #_final
    (§ field MessageLite prototype)

    ;; The maximum message size (NOT INCLUDING LENGTH PREFIX).
    #_final
    (§ field int maxMessageSize)

    ;; A temporary buffer used when the message size is larger than the buffer being used by the network code.
    ;; Because the networking code uses a constant size buffer and we want to allow for very large message sizes, we use
    ;; a smaller network buffer per client and only allocate more memory when we need it to deserialize large messages.
    ;; Though this is not in of itself a DoS protection, it allows for handling more legitimate clients per server and
    ;; attacking clients can be made to timeout/get blocked if they are sending crap to fill buffers.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field int messageBytesOffset = 0)
    #_guarded-by(§ opt "lock")
    #_private
    (§ field byte[] messageBytes)
    #_private
    #_final
    (§ field ReentrantLock lock = Threading.lock(§ pars "ProtobufConnection"))

    #_testing
    #_final
    (§ field AtomicReference<MessageWriteTarget> writeTarget = new AtomicReference<>(§ pars ))

    ;;;
     ; Creates a new protobuf handler.
     ;
     ; @param handler The callback listener.
     ; @param prototype The default instance of the message type used in both directions of this channel.
     ;                  This should be the return value from {@link MessageType#getDefaultInstanceForType()}.
     ; @param maxMessageSize The maximum message size (not including the 4-byte length prefix).
     ;                       Note that this has an upper bound of {@link Integer#MAX_VALUE} - 4.
     ; @param timeoutMillis The timeout between messages before the connection is automatically closed.
     ;                      Only enabled after the connection is established.
     ;;
    #_public
    (§ constructor ProtobufConnection(§ args Listener<MessageType> handler, MessageType prototype, int maxMessageSize, int timeoutMillis))
    (§ block
        (§ ass this.handler = handler)
        (§ ass this.prototype = prototype)
        (§ ass this.maxMessageSize = Math.min(§ pars maxMessageSize, Integer.MAX_VALUE - 4))
        (§ call setTimeoutEnabled(§ pars false))
        (§ call setSocketTimeout(§ pars timeoutMillis))
    )

    #_override
    #_public
    (§ method void setWriteTarget(§ args MessageWriteTarget writeTarget))
    (§ block
        ;; Only allow it to be set once.
        (§ call Preconditions.checkState(§ pars this.writeTarget.getAndSet(§ pars Preconditions.checkNotNull(§ pars writeTarget)) == nil))
    )

    #_override
    #_public
    (§ method int getMaxMessageSize(§ args ))
    (§ block
        (§ return maxMessageSize)
    )

    ;;;
     ; Closes this connection, eventually triggering a {@link ProtobufConnection.Listener#connectionClosed()} event.
     ;;
    #_public
    (§ method void closeConnection(§ args ))
    (§ block
        (§ call this.writeTarget.get(§ pars ).closeConnection(§ pars ))
    )

    #_override
    #_protected
    (§ method void timeoutOccurred(§ args ))
    (§ block
        (§ call log.warn(§ pars "Timeout occurred for " + handler))
        (§ call closeConnection(§ pars ))
    )

    ;; Deserializes and provides a listener event (buff must not have the length prefix in it).
    ;; Does set the buffers's position to its limit.
    #_suppress(§ opt "unchecked")
    ;; The warning 'unchecked cast' being suppressed here comes from the build() formally returning
    ;; a MessageLite-derived class that cannot be statically guaranteed to be the MessageType.
    #_private
    (§ method void deserializeMessage(§ args ByteBuffer buff))
        (§ throws Exception)
    (§ block
        (§ var MessageType msg = (§ cast MessageType)prototype.newBuilderForType(§ pars ).mergeFrom(§ pars ByteString.copyFrom(§ pars buff)).build(§ pars ))
        (§ call resetTimeout(§ pars ))
        (§ call handler.messageReceived(§ pars this, msg))
    )

    #_override
    #_public
    (§ method int receiveBytes(§ args ByteBuffer buff))
        (§ throws Exception)
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr messageBytes != nil))
            (§ block
                ;; Just keep filling up the currently being worked on message.
                (§ var int bytesToGet = Math.min(§ pars messageBytes.length - messageBytesOffset, buff.remaining(§ pars )))
                (§ call buff.get(§ pars messageBytes, messageBytesOffset, bytesToGet))
                (§ ass messageBytesOffset = messageBytesOffset + bytesToGet)
                (§ if (§ expr messageBytesOffset == messageBytes.length))
                (§ block
                    ;; Filled up our buffer, decode the message.
                    (§ call deserializeMessage(§ pars ByteBuffer.wrap(§ pars messageBytes)))
                    (§ ass messageBytes = nil)
                    (§ if (§ expr buff.hasRemaining(§ pars )))
                    (§ block
                        (§ return bytesToGet + receiveBytes(§ pars buff))
                    )
                )
                (§ return bytesToGet)
            )

            ;; If we cant read the length prefix yet, give up.
            (§ if (§ expr buff.remaining(§ pars ) < 4))
            (§ block
                (§ return 0)
            )

            ;; Read one integer in big endian.
            (§ call buff.order(§ pars ByteOrder.BIG_ENDIAN))
            #_final
            (§ var int len = buff.getInt(§ pars ))

            ;; If length is larger than the maximum message size (or is negative/overflows) throw an exception and close
            ;; the connection.
            (§ if (§ expr maxMessageSize < len || len + 4 < 4))
            (§ block
                (§ throw (§ new IllegalStateException(§ pars "Message too large or length underflowed")))
            )

            ;; If the buffer's capacity is less than the next messages length + 4 (length prefix), we must use messageBytes
            ;; as a temporary buffer to store the message.
            (§ if (§ expr buff.capacity(§ pars ) < len + 4))
            (§ block
                (§ ass messageBytes = new byte[len])
                ;; Now copy all remaining bytes into the new buffer, set messageBytesOffset and tell the caller how many
                ;; bytes we consumed.
                (§ var int bytesToRead = buff.remaining(§ pars ))
                (§ call buff.get(§ pars messageBytes, 0, bytesToRead))
                (§ ass messageBytesOffset = bytesToRead)
                (§ return bytesToRead + 4)
            )

            ;; Wait until the whole message is available in the buffer.
            (§ if (§ expr buff.remaining(§ pars ) < len))
            (§ block
                ;; Make sure the buffer's position is right at the end.
                (§ call buff.position(§ pars buff.position(§ pars ) - 4))
                (§ return 0)
            )

            ;; Temporarily limit the buffer to the size of the message, so that the protobuf decode doesn't get messed up.
            (§ var int limit = buff.limit(§ pars ))
            (§ call buff.limit(§ pars buff.position(§ pars ) + len))
            (§ call deserializeMessage(§ pars buff))
            (§ call Preconditions.checkState(§ pars buff.remaining(§ pars ) == 0))
            ;; Reset the limit in case we have to recurse.
            (§ call buff.limit(§ pars limit))

            ;; If there are still bytes remaining, see if we can pull out another message since we won't get called again.
            (§ if (§ expr buff.hasRemaining(§ pars )))
            (§ block
                (§ return len + 4 + receiveBytes(§ pars buff))
            )
            (§ else )
            (§ block
                (§ return len + 4)
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method void connectionClosed(§ args ))
    (§ block
        (§ call handler.connectionClosed(§ pars this))
    )

    #_override
    #_public
    (§ method void connectionOpened(§ args ))
    (§ block
        (§ call setTimeoutEnabled(§ pars true))
        (§ call handler.connectionOpen(§ pars this))
    )

    ;;;
     ; <p>Writes the given message to the other side of the connection, prefixing it with the proper 4-byte prefix.</p>
     ;
     ; <p>Provides a write-order guarantee.</p>
     ;
     ; @throws IllegalStateException if the encoded message is larger than the maximum message size.
     ;;
    #_public
    (§ method void write(§ args MessageType msg))
        (§ throws IllegalStateException)
    (§ block
        (§ var byte[] messageBytes = msg.toByteArray(§ pars ))
        (§ call Preconditions.checkState(§ pars messageBytes.length <= maxMessageSize))

        (§ var byte[] messageLength = new byte[4])
        (§ call Utils.uint32ToByteArrayBE(§ pars messageBytes.length, messageLength, 0))
        (§ try )
        (§ block
            (§ var MessageWriteTarget target = writeTarget.get(§ pars ))
            (§ call target.writeBytes(§ pars messageLength))
            (§ call target.writeBytes(§ pars messageBytes))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ call closeConnection(§ pars ))
        )
    )
)

#_(ns org.bitcoinj.net #_"StreamConnection"
    (:import [java.nio ByteBuffer]))

;;;
 ; A generic handler which is used in {@link NioServer}, {@link NioClient} and {@link BlockingClient} to handle incoming
 ; data streams.
 ;;
#_public
(§ interface StreamConnection
    ;;; Called when the connection socket is closed. ;;
    (§ method void connectionClosed(§ args ))

    ;;; Called when the connection socket is first opened. ;;
    (§ method void connectionOpened(§ args ))

    ;;;
     ; <p>Called when new bytes are available from the remote end.  This should only ever be called by the single
     ; writeTarget associated with any given StreamConnection, multiple callers will likely confuse implementations.</p>
     ;
     ; Implementers/callers must follow the following conventions exactly:
     ; <ul>
     ; <li>buff will start with its limit set to the position we can read to and its position set to the location we
     ;     will start reading at (always 0).</li>
     ; <li>May read more than one message (recursively) if there are enough bytes available.</li>
     ; <li>Uses some internal buffering to store message which are larger (incl. their length prefix) than buff's
     ;     capacity(), i.e. it is up to this method to ensure we dont run out of buffer space to decode the next message.</li>
     ; <li>buff will end with its limit the same as it was previously, and its position set to the position up to which
     ;     bytes have been read (the same as its return value).</li>
     ; <li>buff must be at least the size of a Bitcoin header (incl. magic bytes).</li>
     ; </ul>
     ;
     ; @return the amount of bytes consumed which should not be provided again.
     ;;
    (§ method int receiveBytes(§ args ByteBuffer buff))
        (§ throws Exception)

    ;;;
     ; Called when this connection is attached to an upstream write target (i.e. a low-level connection handler).
     ; This writeTarget should be stored and used to close the connection or write data to the socket.
     ;;
    (§ method void setWriteTarget(§ args MessageWriteTarget writeTarget))

    ;;;
     ; Returns the maximum message size of a message on the socket. This is used in calculating size of buffers
     ; to allocate.
     ;;
    (§ method int getMaxMessageSize(§ args ))
)

#_(ns org.bitcoinj.net #_"StreamConnectionFactory"
    (:import [java.net InetAddress]))

;;;
 ; A factory which generates new {@link StreamConnection}s when a new connection is opened.
 ;;
#_public
(§ interface StreamConnectionFactory
    ;;;
     ; Returns a new handler or null to have the connection close.
     ; @param inetAddress The client's (IP) address.
     ; @param port The remote port on the client side.
     ;;
    #_nilable
    (§ method StreamConnection getNewConnection(§ args InetAddress inetAddress, int port))
)

#_(ns org.bitcoinj.net.discovery #_"DnsDiscovery"
    (:import [java.net *]
             [java.util *]
             [java.util.concurrent *])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.utils *]))

;;;
 ; <p>Supports peer discovery through DNS.</p>
 ;
 ; <p>Failure to resolve individual host names will not cause an Exception to be thrown.
 ; However, if all hosts passed fail to resolve a PeerDiscoveryException will be thrown during getPeers().</p>
 ;
 ; <p>DNS seeds do not attempt to enumerate every peer on the network.
 ; {@link DnsDiscovery#getPeers(long, java.util.concurrent.TimeUnit)} will return up to 30 random peers
 ; from the set of those returned within the timeout period.  If you want more peers to connect to,
 ; you need to discover them via other means (like addr broadcasts).</p>
 ;;
#_public
(§ class DnsDiscovery extends MultiplexingDiscovery
    ;;;
     ; Supports finding peers through DNS A records.  Community run DNS entry points will be used.
     ;
     ; @param netParams Network parameters to be used for port information.
     ;;
    #_public
    (§ constructor DnsDiscovery(§ args NetworkParameters netParams))
    (§ block
        (§ this (§ pars netParams.getDnsSeeds(§ pars ), netParams))
    )

    ;;;
     ; Supports finding peers through DNS A records.
     ;
     ; @param dnsSeeds Host names to be examined for seed addresses.
     ; @param params Network parameters to be used for port information.
     ;;
    #_public
    (§ constructor DnsDiscovery(§ args String[] dnsSeeds, NetworkParameters params))
    (§ block
        (§ super (§ pars params, buildDiscoveries(§ pars params, dnsSeeds)))
    )

    #_private
    #_static
    (§ method List<PeerDiscovery> buildDiscoveries(§ args NetworkParameters params, String[] seeds))
    (§ block
        (§ var List<PeerDiscovery> discoveries = new ArrayList<>(§ pars ))
        (§ if (§ expr seeds != nil))
        (§ block
            (§ for (§ var String seed) :for (§ expr seeds))
            (§ block
                (§ call discoveries.add(§ pars (§ new DnsSeedDiscovery(§ pars params, seed))))
            )
        )
        (§ return discoveries)
    )

    #_override
    #_protected
    (§ method ExecutorService createExecutor(§ args ))
    (§ block
        ;; Attempted workaround for reported bugs on Linux in which gethostbyname does not appear to be properly
        ;; thread safe and can cause segfaults on some libc versions.
        (§ if (§ expr System.getProperty(§ pars "os.name").toLowerCase(§ pars ).contains(§ pars "linux")))
        (§ block
            (§ return Executors.newSingleThreadExecutor(§ pars (§ new ContextPropagatingThreadFactory(§ pars "DNS seed lookups"))))
        )
        (§ else )
        (§ block
            (§ return Executors.newFixedThreadPool(§ pars seeds.size(§ pars ), new DaemonThreadFactory(§ pars "DNS seed lookups")))
        )
    )

    ;;; Implements discovery from a single DNS host. ;;
    #_public
    #_static
    (§ class DnsSeedDiscovery implements PeerDiscovery
        #_private
        #_final
        (§ field String hostname)
        #_private
        #_final
        (§ field NetworkParameters params)

        #_public
        (§ constructor DnsSeedDiscovery(§ args NetworkParameters params, String hostname))
        (§ block
            (§ ass this.hostname = hostname)
            (§ ass this.params = params)
        )

        #_override
        #_public
        (§ method InetSocketAddress[] getPeers(§ args long services, long timeoutValue, TimeUnit timeoutUnit))
            (§ throws PeerDiscoveryException)
        (§ block
            (§ if (§ expr services != 0))
            (§ block
                (§ throw (§ new PeerDiscoveryException(§ pars "DNS seeds cannot filter by services: " + services)))
            )

            (§ try )
            (§ block
                (§ var InetAddress[] response = InetAddress.getAllByName(§ pars hostname))
                (§ var InetSocketAddress[] result = new InetSocketAddress[response.length])
                (§ for (§ var int i = 0) :for (§ expr i < response.length) :for (§ ass i = i + 1))
                (§ block
                    (§ ass result[i] = new InetSocketAddress(§ pars response[i], params.getPort(§ pars )))
                )
                (§ return result)
            )
            (§ catch (§ args UnknownHostException e))
            (§ block
                (§ throw (§ new PeerDiscoveryException(§ pars e)))
            )
        )

        #_override
        #_public
        (§ method void shutdown(§ args ))
        (§ block
        )

        #_override
        #_public
        (§ method String toString(§ args ))
        (§ block
            (§ return hostname)
        )
    )
)

#_(ns org.bitcoinj.net.discovery #_"MultiplexingDiscovery"
    (:import [java.net InetSocketAddress]
             [java.util ArrayList Collections List]
             [java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core NetworkParameters VersionMessage]
             [org.bitcoinj.net.discovery.DnsDiscovery DnsSeedDiscovery]
             [org.bitcoinj.utils *]))

;;;
 ; MultiplexingDiscovery queries multiple PeerDiscovery objects, shuffles their responses and then returns the results,
 ; thus selecting randomly between them and reducing the influence of any particular seed.  Any that don't respond
 ; within the timeout are ignored.  Backends are queried in parallel.  Backends may block.
 ;;
#_public
(§ class MultiplexingDiscovery implements PeerDiscovery
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars MultiplexingDiscovery.class))

    #_protected
    #_final
    (§ field List<PeerDiscovery> seeds)
    #_protected
    #_final
    (§ field NetworkParameters netParams)
    #_private
    #_volatile
    (§ field ExecutorService vThreadPool)

    ;;;
     ; Builds a suitable set of peer discoveries.  Will query them in parallel before producing a merged response.
     ; If specific services are required, DNS is not used as the protocol can't handle it.
     ; @param params Network to use.
     ; @param services Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     ;;
    #_public
    #_static
    (§ method MultiplexingDiscovery forServices(§ args NetworkParameters params, long services))
    (§ block
        (§ var List<PeerDiscovery> discoveries = Lists.newArrayList(§ pars ))
        ;; Also use DNS seeds if there is no specific service requirement.
        (§ if (§ expr services == 0))
        (§ block
            (§ var String[] dnsSeeds = params.getDnsSeeds(§ pars ))
            (§ if (§ expr dnsSeeds != nil))
            (§ block
                (§ for (§ var String dnsSeed) :for (§ expr dnsSeeds))
                (§ block
                    (§ call discoveries.add(§ pars (§ new DnsSeedDiscovery(§ pars params, dnsSeed))))
                )
            )
        )
        (§ return (§ new MultiplexingDiscovery(§ pars params, discoveries)))
    )

    ;;;
     ; Will query the given seeds in parallel before producing a merged response.
     ;;
    #_public
    (§ constructor MultiplexingDiscovery(§ args NetworkParameters params, List<PeerDiscovery> seeds))
    (§ block
        (§ call Preconditions.checkArgument(§ pars !seeds.isEmpty(§ pars )))

        (§ ass this.netParams = params)
        (§ ass this.seeds = seeds)
    )

    #_override
    #_public
    (§ method InetSocketAddress[] getPeers(§ args #_final long services, #_final long timeoutValue, #_final TimeUnit timeoutUnit))
        (§ throws PeerDiscoveryException)
    (§ block
        (§ ass vThreadPool = createExecutor(§ pars ))
        (§ try )
        (§ block
            (§ var List<Callable<InetSocketAddress[]>> tasks = Lists.newArrayList(§ pars ))
            (§ for (§ var #_final PeerDiscovery seed) :for (§ expr seeds))
            (§ block
                (§ call tasks.add(§ pars new Callable<InetSocketAddress[]>(§ pars )
                (§ anon
                    #_override
                    #_public
                    (§ method InetSocketAddress[] call(§ args ))
                        (§ throws Exception)
                    (§ block
                        (§ return seed.getPeers(§ pars services, timeoutValue,  timeoutUnit))
                    )
                )))
            )
            #_final
            (§ var List<Future<InetSocketAddress[]>> futures = vThreadPool.invokeAll(§ pars tasks, timeoutValue, timeoutUnit))
            (§ var ArrayList<InetSocketAddress> addrs = Lists.newArrayList(§ pars ))
            (§ for (§ var int i = 0) :for (§ expr i < futures.size(§ pars )) :for (§ ass i = i + 1))
            (§ block
                (§ var Future<InetSocketAddress[]> future = futures.get(§ pars i))
                (§ if (§ expr future.isCancelled(§ pars )))
                (§ block
                    (§ call log.warn(§ pars "Seed {}: timed out", seeds.get(§ pars i)))
                    (§ continue ) ;; Timed out.
                )
                #_final
                (§ var InetSocketAddress[] inetAddresses)
                (§ try )
                (§ block
                    (§ ass inetAddresses = future.get(§ pars ))
                )
                (§ catch (§ args ExecutionException e))
                (§ block
                    (§ call log.warn(§ pars "Seed {}: failed to look up: {}", seeds.get(§ pars i), e.getMessage(§ pars )))
                    (§ continue )
                )
                (§ call Collections.addAll(§ pars addrs, inetAddresses))
            )
            (§ if (§ expr addrs.size(§ pars ) == 0))
            (§ block
                (§ throw (§ new PeerDiscoveryException(§ pars "No peer discovery returned any results in " + timeoutUnit.toMillis(§ pars timeoutValue) + "ms. Check internet connection?")))
            )

            (§ call Collections.shuffle(§ pars addrs))
            (§ call vThreadPool.shutdownNow(§ pars ))
            (§ return addrs.toArray(§ pars new InetSocketAddress[addrs.size(§ pars )]))
        )
        (§ catch (§ args InterruptedException e))
        (§ block
            (§ throw (§ new PeerDiscoveryException(§ pars e)))
        )
        (§ finally )
        (§ block
            (§ call vThreadPool.shutdown(§ pars ))
        )
    )

    #_protected
    (§ method ExecutorService createExecutor(§ args ))
    (§ block
        (§ return Executors.newFixedThreadPool(§ pars seeds.size(§ pars ), new ContextPropagatingThreadFactory(§ pars "Multiplexing discovery")))
    )

    #_override
    #_public
    (§ method void shutdown(§ args ))
    (§ block
        (§ var ExecutorService tp = vThreadPool)
        (§ if (§ expr tp != nil))
        (§ block
            (§ call tp.shutdown(§ pars ))
        )
    )
)

#_(ns org.bitcoinj.net.discovery #_"PeerDiscovery"
    (:import [java.net InetSocketAddress]
             [java.util.concurrent TimeUnit]))

;;;
 ; A PeerDiscovery object is responsible for finding addresses of other nodes in the Bitcoin P2P network.
 ; Note that the addresses returned may or may not be accepting connections.
 ;;
#_public
(§ interface PeerDiscovery
    ;; TODO: Flesh out this interface a lot more.

    ;;;
     ; Returns an array of addresses.  This method may block.
     ; @param services Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     ;;
    (§ method InetSocketAddress[] getPeers(§ args long services, long timeoutValue, TimeUnit timeoutUnit))
        (§ throws PeerDiscoveryException)

    ;;; Stops any discovery in progress when we want to shut down quickly. ;;
    (§ method void shutdown(§ args ))
)

#_(ns org.bitcoinj.net.discovery #_"PeerDiscoveryException")

#_public
(§ class PeerDiscoveryException extends Exception
    #_public
    (§ constructor PeerDiscoveryException(§ args ))
    (§ block
        (§ super (§ pars ))
    )

    #_public
    (§ constructor PeerDiscoveryException(§ args String message))
    (§ block
        (§ super (§ pars message))
    )

    #_public
    (§ constructor PeerDiscoveryException(§ args Throwable arg0))
    (§ block
        (§ super (§ pars arg0))
    )

    #_public
    (§ constructor PeerDiscoveryException(§ args String message, Throwable arg0))
    (§ block
        (§ super (§ pars message, arg0))
    )
)

#_(ns org.bitcoinj.net.discovery #_"SeedPeers"
    (:import [java.net InetAddress InetSocketAddress UnknownHostException]
             [java.util.concurrent TimeUnit])
   (:require [org.bitcoinj.core NetworkParameters]))

;;;
 ; SeedPeers stores a pre-determined list of Bitcoin node addresses.  These nodes are selected based on
 ; being active on the network for a long period of time.  The intention is to be a last resort way of finding
 ; a connection to the network, in case IRC and DNS fail.  The list comes from the Bitcoin C++ source code.
 ;;
#_public
(§ class SeedPeers implements PeerDiscovery
    #_private
    (§ field NetworkParameters params)
    #_private
    (§ field int[] seedAddrs)
    #_private
    (§ field int pnseedIndex)

    ;;;
     ; Supports finding peers by IP addresses.
     ;
     ; @param params Network parameters to be used for port information.
     ;;
    #_public
    (§ constructor SeedPeers(§ args NetworkParameters params))
    (§ block
        (§ this (§ pars params.getAddrSeeds(§ pars ), params))
    )

    ;;;
     ; Supports finding peers by IP addresses.
     ;
     ; @param seedAddrs IP addresses for seed addresses.
     ; @param params Network parameters to be used for port information.
     ;;
    #_public
    (§ constructor SeedPeers(§ args int[] seedAddrs, NetworkParameters params))
    (§ block
        (§ ass this.seedAddrs = seedAddrs)
        (§ ass this.params = params)
    )

    ;;;
     ; Acts as an iterator, returning the address of each node in the list sequentially.
     ; Once all the list has been iterated, null will be returned for each subsequent query.
     ;
     ; @return InetSocketAddress - the address/port of the next node.
     ; @throws PeerDiscoveryException
     ;;
    #_nilable
    #_public
    (§ method InetSocketAddress getPeer(§ args ))
        (§ throws PeerDiscoveryException)
    (§ block
        (§ try )
        (§ block
            (§ return nextPeer(§ pars ))
        )
        (§ catch (§ args UnknownHostException e))
        (§ block
            (§ throw (§ new PeerDiscoveryException(§ pars e)))
        )
    )

    #_nilable
    #_private
    (§ method InetSocketAddress nextPeer(§ args ))
        (§ throws UnknownHostException, PeerDiscoveryException)
    (§ block
        (§ if (§ expr seedAddrs == nil || seedAddrs.length == 0))
        (§ block
            (§ throw (§ new PeerDiscoveryException(§ pars "No IP address seeds configured; unable to find any peers")))
        )

        (§ if (§ expr seedAddrs.length <= pnseedIndex))
        (§ block
            (§ return nil)
        )

        (§ var int i = pnseedIndex)
        (§ ass pnseedIndex = pnseedIndex + 1)
        (§ return (§ new InetSocketAddress(§ pars convertAddress(§ pars seedAddrs[i]), params.getPort(§ pars ))))
    )

    ;;;
     ; Returns an array containing all the Bitcoin nodes within the list.
     ;;
    #_override
    #_public
    (§ method InetSocketAddress[] getPeers(§ args long services, long timeoutValue, TimeUnit timeoutUnit))
        (§ throws PeerDiscoveryException)
    (§ block
        (§ if (§ expr services != 0))
        (§ block
            (§ throw (§ new PeerDiscoveryException(§ pars "Pre-determined peers cannot be filtered by services: " + services)))
        )

        (§ try )
        (§ block
            (§ return allPeers(§ pars ))
        )
        (§ catch (§ args UnknownHostException e))
        (§ block
            (§ throw (§ new PeerDiscoveryException(§ pars e)))
        )
    )

    #_private
    (§ method InetSocketAddress[] allPeers(§ args ))
        (§ throws UnknownHostException)
    (§ block
        (§ var InetSocketAddress[] addresses = new InetSocketAddress[seedAddrs.length])
        (§ for (§ var int i = 0) :for (§ expr i < seedAddrs.length) :for (§ ass i = i + 1))
        (§ block
            (§ ass addresses[i] = new InetSocketAddress(§ pars convertAddress(§ pars seedAddrs[i]), params.getPort(§ pars )))
        )
        (§ return addresses)
    )

    #_private
    (§ method InetAddress convertAddress(§ args int seed))
        (§ throws UnknownHostException)
    (§ block
        (§ var byte[] v4addr = new byte[4])
        (§ ass v4addr[0] = (§ cast byte)(§ expr 0xff & seed))
        (§ ass v4addr[1] = (§ cast byte)(§ expr 0xff & (§ expr seed >> 8)))
        (§ ass v4addr[2] = (§ cast byte)(§ expr 0xff & (§ expr seed >> 16)))
        (§ ass v4addr[3] = (§ cast byte)(§ expr 0xff & (§ expr seed >> 24)))
        (§ return InetAddress.getByAddress(§ pars v4addr))
    )

    #_override
    #_public
    (§ method void shutdown(§ args ))
    (§ block
    )
)

#_(ns org.bitcoinj.params #_"AbstractBitcoinNetParams"
    (:import [java.math BigInteger]
             [java.util.concurrent TimeUnit])
    (:import [com.google.common.base Preconditions Stopwatch]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core BitcoinSerializer Block Coin NetworkParameters Sha256Hash StoredBlock Transaction Utils VerificationException]
             [org.bitcoinj.utils MonetaryFormat]
             [org.bitcoinj.store BlockStore BlockStoreException]))

;;;
 ; Parameters for Bitcoin-like networks.
 ;;
#_public
#_abstract
(§ class AbstractBitcoinNetParams extends NetworkParameters
    ;;;
     ; Scheme part for Bitcoin URIs.
     ;;
    #_public
    #_static
    #_final
    (§ field String BITCOIN_SCHEME = "bitcoin")
    #_public
    #_static
    #_final
    (§ field int REWARD_HALVING_INTERVAL = 210000)

    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars AbstractBitcoinNetParams.class))

    #_public
    (§ constructor AbstractBitcoinNetParams(§ args ))
    (§ block
        (§ super (§ pars ))
    )

    ;;;
     ; Checks if we are at a reward halving point.
     ; @param height The height of the previous stored block.
     ; @return if this is a reward halving point.
     ;;
    #_public
    #_final
    (§ method boolean isRewardHalvingPoint(§ args #_final int height))
    (§ block
        (§ return (§ expr (§ expr (§ expr height + 1) % REWARD_HALVING_INTERVAL) == 0))
    )

    ;;;
     ; Checks if we are at a difficulty transition point.
     ; @param height The height of the previous stored block.
     ; @return if this is a difficulty transition point.
     ;;
    #_public
    #_final
    (§ method boolean isDifficultyTransitionPoint(§ args #_final int height))
    (§ block
        (§ return (§ expr (§ expr (§ expr height + 1) % this.getInterval(§ pars )) == 0))
    )

    #_override
    #_public
    (§ method void checkDifficultyTransitions(§ args #_final StoredBlock storedPrev, #_final Block nextBlock, #_final BlockStore blockStore))
        (§ throws VerificationException, BlockStoreException)
    (§ block
        #_final
        (§ var Block prev = storedPrev.getHeader(§ pars ))

        ;; Is this supposed to be a difficulty transition point?
        (§ if (§ expr !isDifficultyTransitionPoint(§ pars storedPrev.getHeight(§ pars ))))
        (§ block
            ;; No ... so check the difficulty didn't actually change.
            (§ if (§ expr nextBlock.getDifficultyTarget(§ pars ) != prev.getDifficultyTarget(§ pars )))
            (§ block
                (§ throw (§ new VerificationException(§ pars "Unexpected change in difficulty at height " + storedPrev.getHeight(§ pars ) + ": " + Long.toHexString(§ pars nextBlock.getDifficultyTarget(§ pars )) + " vs " + Long.toHexString(§ pars prev.getDifficultyTarget(§ pars )))))
            )
            (§ return )
        )

        ;; We need to find a block far back in the chain.  It's OK that this is expensive because it only occurs every
        ;; two weeks after the initial block chain download.
        #_final
        (§ var Stopwatch watch = Stopwatch.createStarted(§ pars ))

        (§ var Sha256Hash hash = prev.getHash(§ pars ))
        (§ var StoredBlock cursor = nil)
        #_final
        (§ var int interval = this.getInterval(§ pars ))
        (§ for (§ var int i = 0) :for (§ expr i < interval) :for (§ ass i = i + 1))
        (§ block
            (§ ass cursor = blockStore.get(§ pars hash))
            (§ if (§ expr cursor == nil))
            (§ block
                ;; This should never happen.  If it does, it means we are following an incorrect or busted chain.
                (§ throw (§ new VerificationException(§ pars "Difficulty transition point but we did not find a way back to the last transition point. Not found: " + hash)))
            )
            (§ ass hash = cursor.getHeader(§ pars ).getPrevBlockHash(§ pars ))
        )
        (§ call Preconditions.checkState(§ pars cursor != nil && isDifficultyTransitionPoint(§ pars cursor.getHeight(§ pars ) - 1), "Didn't arrive at a transition point."))

        (§ call watch.stop(§ pars ))
        (§ if (§ expr 50 < watch.elapsed(§ pars TimeUnit.MILLISECONDS)))
        (§ block
            (§ call log.info(§ pars "Difficulty transition traversal took {}", watch))
        )

        (§ var Block blockIntervalAgo = cursor.getHeader(§ pars ))
        (§ var int timespan = (§ cast int)(§ expr prev.getTimeSeconds(§ pars ) - blockIntervalAgo.getTimeSeconds(§ pars )))
        ;; Limit the adjustment step.
        #_final
        (§ var int targetTimespan = this.getTargetTimespan(§ pars ))
        (§ if (§ expr timespan < targetTimespan / 4))
        (§ block
            (§ ass timespan = targetTimespan / 4)
        )
        (§ if (§ expr timespan > targetTimespan * 4))
        (§ block
            (§ ass timespan = targetTimespan * 4)
        )

        (§ var BigInteger newTarget = Utils.decodeCompactBits(§ pars prev.getDifficultyTarget(§ pars )))
        (§ ass newTarget = newTarget.multiply(§ pars BigInteger.valueOf(§ pars timespan)))
        (§ ass newTarget = newTarget.divide(§ pars BigInteger.valueOf(§ pars targetTimespan)))

        (§ if (§ expr 0 < newTarget.compareTo(§ pars this.getMaxTarget(§ pars ))))
        (§ block
            (§ call log.info(§ pars "Difficulty hit proof of work limit: {}", newTarget.toString(§ pars 16)))
            (§ ass newTarget = this.getMaxTarget(§ pars ))
        )

        (§ var int accuracyBytes = (§ cast int)(§ expr nextBlock.getDifficultyTarget(§ pars ) >>> 24) - 3)
        (§ var long receivedTargetCompact = nextBlock.getDifficultyTarget(§ pars ))

        ;; The calculated difficulty is to a higher precision than received, so reduce here.
        (§ var BigInteger mask = BigInteger.valueOf(§ pars 0xffffff).shiftLeft(§ pars accuracyBytes * 8))
        (§ ass newTarget = newTarget.and(§ pars mask))
        (§ var long newTargetCompact = Utils.encodeCompactBits(§ pars newTarget))

        (§ if (§ expr newTargetCompact != receivedTargetCompact))
        (§ block
            (§ throw (§ new VerificationException(§ pars "Network provided difficulty bits do not match what was calculated: " + Long.toHexString(§ pars newTargetCompact) + " vs " + Long.toHexString(§ pars receivedTargetCompact))))
        )
    )

    #_override
    #_public
    (§ method Coin getMaxMoney(§ args ))
    (§ block
        (§ return MAX_MONEY)
    )

    #_override
    #_public
    (§ method Coin getMinNonDustOutput(§ args ))
    (§ block
        (§ return Transaction.MIN_NONDUST_OUTPUT)
    )

    #_override
    #_public
    (§ method MonetaryFormat getMonetaryFormat(§ args ))
    (§ block
        (§ return (§ new MonetaryFormat(§ pars )))
    )

    #_override
    #_public
    (§ method int getProtocolVersionNum(§ args #_final ProtocolVersion version))
    (§ block
        (§ return version.getBitcoinProtocolVersion(§ pars ))
    )

    #_override
    #_public
    (§ method BitcoinSerializer getSerializer(§ args boolean parseRetain))
    (§ block
        (§ return (§ new BitcoinSerializer(§ pars this, parseRetain)))
    )

    #_override
    #_public
    (§ method String getUriScheme(§ args ))
    (§ block
        (§ return BITCOIN_SCHEME)
    )

    #_override
    #_public
    (§ method boolean hasMaxMoney(§ args ))
    (§ block
        (§ return true)
    )
)

#_(ns org.bitcoinj.params #_"MainNetParams"
    (:import [java.net *])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.net.discovery *]))

;;;
 ; Parameters for the main production network on which people trade goods and services.
 ;;
#_public
(§ class MainNetParams extends AbstractBitcoinNetParams
    #_public
    #_static
    #_final
    (§ field int MAINNET_MAJORITY_WINDOW = 1000)
    #_public
    #_static
    #_final
    (§ field int MAINNET_MAJORITY_REJECT_BLOCK_OUTDATED = 950)
    #_public
    #_static
    #_final
    (§ field int MAINNET_MAJORITY_ENFORCE_BLOCK_UPGRADE = 750)

    #_public
    (§ constructor MainNetParams(§ args ))
    (§ block
        (§ super (§ pars ))

        (§ ass interval = INTERVAL)
        (§ ass targetTimespan = TARGET_TIMESPAN)
        (§ ass maxTarget = Utils.decodeCompactBits(§ pars 0x1d00ffff))
        (§ ass addressHeader = 0)
        (§ ass p2shHeader = 5)
        (§ ass acceptableAddressCodes = new int[] (§ coll addressHeader, p2shHeader ))
        (§ ass port = 8333)
        (§ ass packetMagic = 0xf9beb4d9)
        (§ ass bip32HeaderPub = 0x0488b21e) ;; 4 byte header that serializes in base58 to "xpub"
        (§ ass bip32HeaderPriv = 0x0488ade4) ;; 4 byte header that serializes in base58 to "xprv"

        (§ ass majorityEnforceBlockUpgrade = MAINNET_MAJORITY_ENFORCE_BLOCK_UPGRADE)
        (§ ass majorityRejectBlockOutdated = MAINNET_MAJORITY_REJECT_BLOCK_OUTDATED)
        (§ ass majorityWindow = MAINNET_MAJORITY_WINDOW)

        (§ call genesisBlock.setDifficultyTarget(§ pars 0x1d00ffff))
        (§ call genesisBlock.setTime(§ pars 1231006505))
        (§ call genesisBlock.setNonce(§ pars 2083236893))
        (§ ass id = ID_MAINNET)
        (§ ass subsidyDecreaseBlockCount = 210000)
        (§ ass spendableCoinbaseDepth = 100)
        (§ var String genesisHash = genesisBlock.getHashAsString(§ pars ))
        (§ call Preconditions.checkState(§ pars genesisHash.equals(§ pars "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f"), genesisHash))

        ;; This contains (at a minimum) the blocks which are not BIP30 compliant.  BIP30 changed how duplicate
        ;; transactions are handled.  Duplicated transactions could occur in the case where a coinbase had the same
        ;; extraNonce and the same outputs but appeared at different heights, and greatly complicated re-org handling.
        ;; Having these here simplifies block connection logic considerably.
        (§ call checkpoints.put(§ pars 91722, Sha256Hash.wrap(§ pars "00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e")))
        (§ call checkpoints.put(§ pars 91812, Sha256Hash.wrap(§ pars "00000000000af0aed4792b1acee3d966af36cf5def14935db8de83d6f9306f2f")))
        (§ call checkpoints.put(§ pars 91842, Sha256Hash.wrap(§ pars "00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec")))
        (§ call checkpoints.put(§ pars 91880, Sha256Hash.wrap(§ pars "00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721")))
        (§ call checkpoints.put(§ pars 200000, Sha256Hash.wrap(§ pars "000000000000034a7dedef4a161fa058a2d67a173a90155f3a2fe6fc132e0ebf")))

        (§ ass dnsSeeds = new String[]
        (§ coll
            "seed.bitcoin.sipa.be",          ;; Pieter Wuille
            "dnsseed.bluematt.me",           ;; Matt Corallo
            "dnsseed.bitcoin.dashjr.org",    ;; Luke Dashjr
            "seed.bitcoinstats.com",         ;; Chris Decker
            "seed.bitnodes.io",              ;; Addy Yeow
            "bitseed.xf2.org",               ;; Jeff Garzik
            "seed.bitcoin.jonasschnelli.ch", ;; Jonas Schnelli
        ))

        (§ ass addrSeeds = new int[]
        (§ coll
                0x1ddb1032, 0x6242ce40, 0x52d6a445, 0x2dd7a445, 0x8a53cd47, 0x73263750, 0xda23c257, 0xecd4ed57,
                0x0a40ec59, 0x75dce160, 0x7df76791, 0x89370bad, 0xa4f214ad, 0x767700ae, 0x638b0418, 0x868a1018,
                0xcd9f332e, 0x0129653e, 0xcc92dc3e, 0x96671640, 0x56487e40, 0x5b66f440, 0xb1d01f41, 0xf1dc6041,
                0xc1d12b42, 0x86ba1243, 0x6be4df43, 0x6d4cef43, 0xd18e0644, 0x1ab0b344, 0x6584a345, 0xe7c1a445,
                0x58cea445, 0xc5daa445, 0x21dda445, 0x3d3b5346, 0x13e55347, 0x1080d24a, 0x8e611e4b, 0x81518e4b,
                0x6c839e4b, 0xe2ad0a4c, 0xfbbc0a4c, 0x7f5b6e4c, 0x7244224e, 0x1300554e, 0x20690652, 0x5a48b652,
                0x75c5c752, 0x4335cc54, 0x340fd154, 0x87c07455, 0x087b2b56, 0x8a133a57, 0xac23c257, 0x70374959,
                0xfb63d45b, 0xb9a1685c, 0x180d765c, 0x674f645d, 0x04d3495e, 0x1de44b5e, 0x4ee8a362, 0x0ded1b63,
                0xc1b04b6d, 0x8d921581, 0x97b7ea82, 0x1cf83a8e, 0x91490bad, 0x09dc75ae, 0x9a6d79ae, 0xa26d79ae,
                0x0fd08fae, 0x0f3e3fb2, 0x4f944fb2, 0xcca448b8, 0x3ecd6ab8, 0xa9d5a5bc, 0x8d0119c1, 0x045997d5,
                0xca019dd9, 0x0d526c4d, 0xabf1ba44, 0x66b1ab55, 0x1165f462, 0x3ed7cbad, 0xa38fae6e, 0x3bd2cbad,
                0xd36f0547, 0x20df7840, 0x7a337742, 0x549f8e4b, 0x9062365c, 0xd399f562, 0x2b5274a1, 0x8edfa153,
                0x3bffb347, 0x7074bf58, 0xb74fcbad, 0x5b5a795b, 0x02fa29ce, 0x5a6738d4, 0xe8a1d23e, 0xef98c445,
                0x4b0f494c, 0xa2bc1e56, 0x7694ad63, 0xa4a800c3, 0x05fda6cd, 0x9f22175e, 0x364a795b, 0x536285d5,
                0xac44c9d4, 0x0b06254d, 0x150c2fd4, 0x32a50dcc, 0xfd79ce48, 0xf15cfa53, 0x66c01e60, 0x6bc26661,
                0xc03b47ae, 0x4dda1b81, 0x3285a4c1, 0x883ca96d, 0x35d60a4c, 0xdae09744, 0x2e314d61, 0x84e247cf,
                0x6c814552, 0x3a1cc658, 0x98d8f382, 0xe584cb5b, 0x15e86057, 0x7b01504e, 0xd852dd48, 0x56382f56,
                0x0a5df454, 0xa0d18d18, 0x2e89b148, 0xa79c114c, 0xcbdcd054, 0x5523bc43, 0xa9832640, 0x8a066144,
                0x3894c3bc, 0xab76bf58, 0x6a018ac1, 0xfebf4f43, 0x2f26c658, 0x31102f4e, 0x85e929d5, 0x2a1c175e,
                0xfc6c2cd1, 0x27b04b6d, 0xdf024650, 0x161748b8, 0x28be6580, 0x57be6580, 0x1cee677a, 0xaa6bb742,
                0x9a53964b, 0x0a5a2d4d, 0x2434c658, 0x9a494f57, 0x1ebb0e48, 0xf610b85d, 0x077ecf44, 0x085128bc,
                0x5ba17a18, 0x27ca1b42, 0xf8a00b56, 0xfcd4c257, 0xcf2fc15e, 0xd897e052, 0x4cada04f, 0x2f35f6d5,
                0x382ce8c9, 0xe523984b, 0x3f946846, 0x60c8be43, 0x41da6257, 0xde0be142, 0xae8a544b, 0xeff0c254,
                0x1e0f795b, 0xaeb28890, 0xca16acd9, 0x1e47ddd8, 0x8c8c4829, 0xd27dc747, 0xd53b1663, 0x4096b163,
                0x9c8dd958, 0xcb12f860, 0x9e79305c, 0x40c1a445, 0x4a90c2bc, 0x2c3a464d, 0x2727f23c, 0x30b04b6d,
                0x59024cb8, 0xa091e6ad, 0x31b04b6d, 0xc29d46a6, 0x63934fb2, 0xd9224dbe, 0x9f5910d8, 0x7f530a6b,
                0x752e9c95, 0x65453548, 0xa484be46, 0xce5a1b59, 0x710e0718, 0x46a13d18, 0xdaaf5318, 0xc4a8ff53,
                0x87abaa52, 0xb764cf51, 0xb2025d4a, 0x6d351e41, 0xc035c33e, 0xa432c162, 0x61ef34ae, 0xd16fddbc,
                0x0870e8c1, 0x3070e8c1, 0x9c71e8c1, 0xa4992363, 0x85a1f663, 0x4184e559, 0x18d96ed8, 0x17b8dbd5,
                0x60e7cd18, 0xe5ee104c, 0xab17ac62, 0x1e786e1b, 0x5d23b762, 0xf2388fae, 0x88270360, 0x9e5b3d80,
                0x7da518b2, 0xb5613b45, 0x1ad41f3e, 0xd550854a, 0x8617e9a9, 0x925b229c, 0xf2e92542, 0x47af0544,
                0x73b5a843, 0xb9b7a0ad, 0x03a748d0, 0x0a6ff862, 0x6694df62, 0x3bfac948, 0x8e098f4f, 0x746916c3,
                0x02f38e4f, 0x40bb1243, 0x6a54d162, 0x6008414b, 0xa513794c, 0x514aa343, 0x63781747, 0xdbb6795b,
                0xed065058, 0x42d24b46, 0x1518794c, 0x9b271681, 0x73e4ffad, 0x0654784f, 0x438dc945, 0x641846a6,
                0x2d1b0944, 0x94b59148, 0x8d369558, 0xa5a97662, 0x8b705b42, 0xce9204ae, 0x8d584450, 0x2df61555,
                0xeebff943, 0x2e75fb4d, 0x3ef8fc57, 0x9921135e, 0x8e31042e, 0xb5afad43, 0x89ecedd1, 0x9cfcc047,
                0x8fcd0f4c, 0xbe49f5ad, 0x146a8d45, 0x98669ab8, 0x98d9175e, 0xd1a8e46d, 0x839a3ab8, 0x40a0016c,
                0x6d27c257, 0x977fffad, 0x7baa5d5d, 0x1213be43, 0xb167e5a9, 0x640fe8ca, 0xbc9ea655, 0x0f820a4c,
                0x0f097059, 0x69ac957c, 0x366d8453, 0xb1ba2844, 0x8857f081, 0x70b5be63, 0xc545454b, 0xaf36ded1,
                0xb5a4b052, 0x21f062d1, 0x72ab89b2, 0x74a45318, 0x8312e6bc, 0xb916965f, 0x8aa7c858, 0xfe7effad,
        ))
    )

    #_private
    #_static
    (§ field MainNetParams instance)

    #_public
    #_static
    #_synchronized
    (§ method MainNetParams get(§ args ))
    (§ block
        (§ if (§ expr instance == nil))
        (§ block
            (§ ass instance = new MainNetParams(§ pars ))
        )
        (§ return instance)
    )

    #_override
    #_public
    (§ method String getPaymentProtocolId(§ args ))
    (§ block
        (§ return PAYMENT_PROTOCOL_ID_MAINNET)
    )
)

#_(ns org.bitcoinj.params #_"Networks"
    (:import [java.util Collection Set])
    (:import [com.google.common.collect ImmutableSet Lists])
   (:require [org.bitcoinj.core NetworkParameters]))

;;;
 ; Utility class that holds all the registered NetworkParameters types used for Address auto discovery.
 ; By default only MainNetParams and TestNet3Params are used.  If you want to use UnitTestParams, use
 ; the register and unregister the TestNet3Params as they don't have their own address version/type code.
 ;;
#_public
(§ class Networks
    ;;; Registered networks. ;;
    #_private
    #_static
    (§ field Set<? extends NetworkParameters> networks = ImmutableSet.of(§ pars TestNet3Params.get(§ pars ), MainNetParams.get(§ pars )))

    #_public
    #_static
    (§ method Set<? extends NetworkParameters> get(§ args ))
    (§ block
        (§ return networks)
    )

    #_public
    #_static
    (§ method void register(§ args NetworkParameters network))
    (§ block
        (§ call register(§ pars Lists.newArrayList(§ pars network)))
    )

    #_public
    #_static
    (§ method void register(§ args Collection<? extends NetworkParameters> networks))
    (§ block
        (§ var ImmutableSet.Builder<NetworkParameters> builder = ImmutableSet.builder(§ pars ))
        (§ call builder.addAll(§ pars Networks.networks))
        (§ call builder.addAll(§ pars networks))
        (§ ass Networks.networks = builder.build(§ pars ))
    )

    #_public
    #_static
    (§ method void unregister(§ args NetworkParameters network))
    (§ block
        (§ if (§ expr networks.contains(§ pars network)))
        (§ block
            (§ var ImmutableSet.Builder<NetworkParameters> builder = ImmutableSet.builder(§ pars ))

            (§ for (§ var NetworkParameters parameters) :for (§ expr networks))
            (§ block
                (§ if (§ expr !parameters.equals(§ pars network)))
                (§ block
                    (§ call builder.add(§ pars parameters))
                )
            )

            (§ ass networks = builder.build(§ pars ))
        )
    )
)

#_(ns org.bitcoinj.params #_"TestNet3Params"
    (:import [java.math BigInteger]
             [java.util Date])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.core Block NetworkParameters StoredBlock Utils VerificationException]
             [org.bitcoinj.store BlockStore BlockStoreException]))

;;;
 ; Parameters for the testnet, a separate public instance of Bitcoin that has relaxed rules suitable for development
 ; and testing of applications and new Bitcoin versions.
 ;;
#_public
(§ class TestNet3Params extends AbstractBitcoinNetParams
    #_public
    #_static
    #_final
    (§ field int TESTNET_MAJORITY_WINDOW = 100)
    #_public
    #_static
    #_final
    (§ field int TESTNET_MAJORITY_REJECT_BLOCK_OUTDATED = 75)
    #_public
    #_static
    #_final
    (§ field int TESTNET_MAJORITY_ENFORCE_BLOCK_UPGRADE = 51)

    #_public
    (§ constructor TestNet3Params(§ args ))
    (§ block
        (§ super (§ pars ))

        (§ ass id = ID_TESTNET)
        (§ ass packetMagic = 0x0b110907)
        (§ ass interval = INTERVAL)
        (§ ass targetTimespan = TARGET_TIMESPAN)
        (§ ass maxTarget = Utils.decodeCompactBits(§ pars 0x1d00ffff))
        (§ ass port = 18333)
        (§ ass addressHeader = 111)
        (§ ass p2shHeader = 196)
        (§ ass acceptableAddressCodes = new int[] (§ coll addressHeader, p2shHeader ))
        (§ call genesisBlock.setTime(§ pars 1296688602))
        (§ call genesisBlock.setDifficultyTarget(§ pars 0x1d00ffff))
        (§ call genesisBlock.setNonce(§ pars 414098458))
        (§ ass spendableCoinbaseDepth = 100)
        (§ ass subsidyDecreaseBlockCount = 210000)
        (§ var String genesisHash = genesisBlock.getHashAsString(§ pars ))
        (§ call Preconditions.checkState(§ pars genesisHash.equals(§ pars "000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943")))
        (§ ass alertSigningKey = Utils.HEX.decode(§ pars "04302390343f91cc401d56d68b123028bf52e5fca1939df127f63c6467cdf9c8e2c14b61104cf817d0b780da337893ecc4aaff1309e536162dabbdb45200ca2b0a"))

        (§ ass dnsSeeds = new String[]
        (§ coll
            "testnet-seed.bitcoin.jonasschnelli.ch", ;; Jonas Schnelli
            "testnet-seed.bluematt.me",              ;; Matt Corallo
            "testnet-seed.bitcoin.petertodd.org",    ;; Peter Todd
            "testnet-seed.bitcoin.schildbach.de",    ;; Andreas Schildbach
        ))
        (§ ass addrSeeds = nil)
        (§ ass bip32HeaderPub = 0x043587cf)
        (§ ass bip32HeaderPriv = 0x04358394)

        (§ ass majorityEnforceBlockUpgrade = TESTNET_MAJORITY_ENFORCE_BLOCK_UPGRADE)
        (§ ass majorityRejectBlockOutdated = TESTNET_MAJORITY_REJECT_BLOCK_OUTDATED)
        (§ ass majorityWindow = TESTNET_MAJORITY_WINDOW)
    )

    #_private
    #_static
    (§ field TestNet3Params instance)

    #_public
    #_static
    #_synchronized
    (§ method TestNet3Params get(§ args ))
    (§ block
        (§ if (§ expr instance == nil))
        (§ block
            (§ ass instance = new TestNet3Params(§ pars ))
        )
        (§ return instance)
    )

    #_override
    #_public
    (§ method String getPaymentProtocolId(§ args ))
    (§ block
        (§ return PAYMENT_PROTOCOL_ID_TESTNET)
    )

    ;; February 16th 2012
    #_private
    #_static
    #_final
    (§ field Date testnetDiffDate = new Date(§ pars 1329264000000))

    #_override
    #_public
    (§ method void checkDifficultyTransitions(§ args #_final StoredBlock storedPrev, #_final Block nextBlock, #_final BlockStore blockStore))
        (§ throws VerificationException, BlockStoreException)
    (§ block
        (§ if (§ expr !isDifficultyTransitionPoint(§ pars storedPrev.getHeight(§ pars )) && nextBlock.getTime(§ pars ).after(§ pars testnetDiffDate)))
        (§ block
            (§ var Block prev = storedPrev.getHeader(§ pars ))

            ;; After 15th February 2012 the rules on the testnet change to avoid people running up the difficulty
            ;; and then leaving, making it too hard to mine a block.  On non-difficulty transition points, easy
            ;; blocks are allowed if there has been a span of 20 minutes without one.
            #_final
            (§ var long timeDelta = nextBlock.getTimeSeconds(§ pars ) - prev.getTimeSeconds(§ pars ))
            ;; There is an integer underflow bug in bitcoin-qt that means mindiff blocks are accepted when time
            ;; goes backwards.
            (§ if (§ expr 0 <= timeDelta && timeDelta <= NetworkParameters.TARGET_SPACING * 2))
            (§ block
                ;; Walk backwards until we find a block that doesn't have the easiest proof of work, then check
                ;; that difficulty is equal to that one.
                (§ var StoredBlock cursor = storedPrev)
                (§ while (§ expr !cursor.getHeader(§ pars ).equals(§ pars getGenesisBlock(§ pars )) && cursor.getHeight(§ pars ) % getInterval(§ pars ) != 0 && cursor.getHeader(§ pars ).getDifficultyTargetAsInteger(§ pars ).equals(§ pars getMaxTarget(§ pars ))))
                (§ block
                    (§ ass cursor = cursor.getPrev(§ pars blockStore))
                )
                (§ var BigInteger cursorTarget = cursor.getHeader(§ pars ).getDifficultyTargetAsInteger(§ pars ))
                (§ var BigInteger newTarget = nextBlock.getDifficultyTargetAsInteger(§ pars ))
                (§ if (§ expr !cursorTarget.equals(§ pars newTarget)))
                (§ block
                    (§ throw (§ new VerificationException(§ pars "Testnet block transition that is not allowed: " + Long.toHexString(§ pars cursor.getHeader(§ pars ).getDifficultyTarget(§ pars )) + " vs " + Long.toHexString(§ pars nextBlock.getDifficultyTarget(§ pars )))))
                )
            )
        )
        (§ else )
        (§ block
            (§ call super.checkDifficultyTransitions(§ pars storedPrev, nextBlock, blockStore))
        )
    )
)

#_(ns org.bitcoinj.params #_"UnitTestParams"
    (:import [java.math BigInteger])
   (:require [org.bitcoinj.core *]))

;;;
 ; Network parameters used by the bitcoinj unit tests (and potentially your own).  This lets you solve a block using
 ; {@link org.bitcoinj.core.Block#solve()} by setting difficulty to the easiest possible.
 ;;
#_public
(§ class UnitTestParams extends AbstractBitcoinNetParams
    #_public
    #_static
    #_final
    (§ field int UNITNET_MAJORITY_WINDOW = 8)
    #_public
    #_static
    #_final
    (§ field int TESTNET_MAJORITY_REJECT_BLOCK_OUTDATED = 6)
    #_public
    #_static
    #_final
    (§ field int TESTNET_MAJORITY_ENFORCE_BLOCK_UPGRADE = 4)

    #_public
    (§ constructor UnitTestParams(§ args ))
    (§ block
        (§ super (§ pars ))

        (§ ass id = ID_UNITTESTNET)
        (§ ass packetMagic = 0x0b110907)
        (§ ass addressHeader = 111)
        (§ ass p2shHeader = 196)
        (§ ass acceptableAddressCodes = new int[] (§ coll addressHeader, p2shHeader ))
        (§ ass maxTarget = new BigInteger(§ pars "00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16))
        (§ call genesisBlock.setTime(§ pars System.currentTimeMillis(§ pars ) / 1000))
        (§ call genesisBlock.setDifficultyTarget(§ pars Block.EASIEST_DIFFICULTY_TARGET))
        (§ call genesisBlock.solve(§ pars ))
        (§ ass port = 18333)
        (§ ass interval = 10)
        (§ ass targetTimespan = 200000000) ;; 6 years.  Just a very big number.
        (§ ass spendableCoinbaseDepth = 5)
        (§ ass subsidyDecreaseBlockCount = 100)
        (§ ass dnsSeeds = nil)
        (§ ass addrSeeds = nil)
        (§ ass bip32HeaderPub = 0x043587cf)
        (§ ass bip32HeaderPriv = 0x04358394)

        (§ ass majorityEnforceBlockUpgrade = 3)
        (§ ass majorityRejectBlockOutdated = 4)
        (§ ass majorityWindow = 7)
    )

    #_private
    #_static
    (§ field UnitTestParams instance)

    #_public
    #_static
    #_synchronized
    (§ method UnitTestParams get(§ args ))
    (§ block
        (§ if (§ expr instance == nil))
        (§ block
            (§ ass instance = new UnitTestParams(§ pars ))
        )
        (§ return instance)
    )

    #_override
    #_public
    (§ method String getPaymentProtocolId(§ args ))
    (§ block
        (§ return "unittest")
    )
)

#_(ns org.bitcoinj.script #_"Script"
    (:import [java.io ByteArrayInputStream ByteArrayOutputStream IOException OutputStream]
             [java.math BigInteger]
             [java.security MessageDigest NoSuchAlgorithmException]
             [java.util *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto.digests RIPEMD160Digest])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.crypto TransactionSignature]
             #_static [org.bitcoinj.script.ScriptOpCodes *]))

;; TODO: Redesign this entire API to be more type safe and organised.

;;;
 ; <p>Programs embedded inside transactions that control redemption of payments.</p>
 ;
 ; <p>Bitcoin transactions don't specify what they do directly.  Instead
 ; <a href="https://en.bitcoin.it/wiki/Script">a small binary stack language</a> is used to define programs that
 ; when evaluated, return whether the transaction "accepts" or rejects the other transactions connected to it.</p>
 ;
 ; <p>In SPV mode, scripts are not run, because that would require all transactions to be available and lightweight
 ; clients don't have that data.  In full mode, this class is used to run the interpreted language.  It also has
 ; static methods for building scripts.</p>
 ;;
#_public
(§ class Script
    ;;; Enumeration to encapsulate the type of this script. ;;
    #_public
    (§ enum ScriptType
        ;; Do NOT change the ordering of the following definitions because their ordinals are stored in databases.
        (§ item NO_TYPE)
        (§ item P2PKH)
        (§ item PUB_KEY)
        (§ item P2SH)
    )

    ;;; Flags to pass to {@link Script#correctlySpends(Transaction, long, Script, Set)}.
     ; Note currently only P2SH, DERSIG and NULLDUMMY are actually supported.
     ;;
    #_public
    (§ enum VerifyFlag
        (§ item P2SH) ;; Enable BIP16-style subscript evaluation.
        (§ item STRICTENC) ;; Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.
        (§ item DERSIG) ;; Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP66 rule 1).
        (§ item LOW_S) ;; Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure.
        (§ item NULLDUMMY) ;; Verify dummy stack item consumed by CHECKMULTISIG is of zero-length.
        (§ item SIGPUSHONLY) ;; Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).
        (§ item MINIMALDATA) ;; Require minimal encodings for all push operations.
        (§ item DISCOURAGE_UPGRADABLE_NOPS) ;; Discourage use of NOPs reserved for upgrades (NOP1-10).
        (§ item CLEANSTACK) ;; Require that only a single stack element remains after evaluation.
        (§ item CHECKLOCKTIMEVERIFY) ;; Enable CHECKLOCKTIMEVERIFY operation.
        (§ item CHECKSEQUENCEVERIFY) ;; Enable CHECKSEQUENCEVERIFY operation.
    )
    #_public
    #_static
    #_final
    (§ field EnumSet<VerifyFlag> ALL_VERIFY_FLAGS = EnumSet.allOf(§ pars VerifyFlag.class))

    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars Script.class))

    #_public
    #_static
    #_final
    (§ field long MAX_SCRIPT_ELEMENT_SIZE = 520) ;; bytes
    #_private
    #_static
    #_final
    (§ field int MAX_OPS_PER_SCRIPT = 201)
    #_private
    #_static
    #_final
    (§ field int MAX_STACK_SIZE = 1000)
    #_private
    #_static
    #_final
    (§ field int MAX_PUBKEYS_PER_MULTISIG = 20)
    #_private
    #_static
    #_final
    (§ field int MAX_SCRIPT_SIZE = 10000)
    #_public
    #_static
    #_final
    (§ field int SIG_SIZE = 75)
    ;;; Max number of sigops allowed in a standard p2sh redeem script. ;;
    #_public
    #_static
    #_final
    (§ field int MAX_P2SH_SIGOPS = 15)

    ;; The program is a set of chunks where each element is either [opcode] or [data, data, data ...].
    #_protected
    (§ field List<ScriptChunk> chunks)
    ;; Unfortunately, scripts are not ever re-serialized or canonicalized when used in signature hashing.
    ;; Thus we must preserve the exact bytes that we read off the wire, along with the parsed form.
    #_protected
    (§ field byte[] program)

    ;; Creation time of the associated keys in seconds since the epoch.
    #_private
    (§ field long creationTimeSeconds)

    ;;; Creates an empty script that serializes to nothing. ;;
    #_private
    (§ constructor Script(§ args ))
    (§ block
        (§ ass chunks = Lists.newArrayList(§ pars ))
    )

    ;; Used from ScriptBuilder.
    (§ constructor Script(§ args List<ScriptChunk> chunks))
    (§ block
        (§ ass this.chunks = Collections.unmodifiableList(§ pars new ArrayList<>(§ pars chunks)))
        (§ ass creationTimeSeconds = Utils.currentTimeSeconds(§ pars ))
    )

    ;;;
     ; Construct a Script that copies and wraps the programBytes array.
     ; The array is parsed and checked for syntactic validity.
     ; @param programBytes Array of program bytes from a transaction.
     ;;
    #_public
    (§ constructor Script(§ args byte[] programBytes))
        (§ throws ScriptException)
    (§ block
        (§ ass program = programBytes)
        (§ call parse(§ pars programBytes))
        (§ ass creationTimeSeconds = 0)
    )

    #_public
    (§ constructor Script(§ args byte[] programBytes, long creationTimeSeconds))
        (§ throws ScriptException)
    (§ block
        (§ ass program = programBytes)
        (§ call parse(§ pars programBytes))
        (§ ass this.creationTimeSeconds = creationTimeSeconds)
    )

    #_public
    (§ method long getCreationTimeSeconds(§ args ))
    (§ block
        (§ return creationTimeSeconds)
    )

    #_public
    (§ method void setCreationTimeSeconds(§ args long creationTimeSeconds))
    (§ block
        (§ ass this.creationTimeSeconds = creationTimeSeconds)
    )

    ;;;
     ; Returns the program opcodes as a string, for example "[1234] DUP HASH160".
     ;;
    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return Utils.SPACE_JOINER.join(§ pars chunks))
    )

    ;;; Returns the serialized program as a newly created byte array. ;;
    #_public
    (§ method byte[] getProgram(§ args ))
    (§ block
        (§ try )
        (§ block
            ;; Don't round-trip as Bitcoin Core doesn't and it would introduce a mismatch.
            (§ if (§ expr program != nil))
            (§ block
                (§ return Arrays.copyOf(§ pars program, program.length))
            )

            (§ var ByteArrayOutputStream bos = new ByteArrayOutputStream(§ pars ))
            (§ for (§ var ScriptChunk chunk) :for (§ expr chunks))
            (§ block
                (§ call chunk.write(§ pars bos))
            )
            (§ ass program = bos.toByteArray(§ pars ))
            (§ return program)
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
    )

    ;;; Returns an immutable list of the scripts parsed form.  Each chunk is either an opcode or data element. ;;
    #_public
    (§ method List<ScriptChunk> getChunks(§ args ))
    (§ block
        (§ return Collections.unmodifiableList(§ pars chunks))
    )

    #_private
    #_static
    #_final
    (§ var ScriptChunk[] STANDARD_TRANSACTION_SCRIPT_CHUNKS =
    (§ coll
        (§ new ScriptChunk(§ pars ScriptOpCodes.OP_DUP, nil, 0))
        (§ new ScriptChunk(§ pars ScriptOpCodes.OP_HASH160, nil, 1))
        (§ new ScriptChunk(§ pars ScriptOpCodes.OP_EQUALVERIFY, nil, 23))
        (§ new ScriptChunk(§ pars ScriptOpCodes.OP_CHECKSIG, nil, 24))
    ))

    ;;;
     ; <p>To run a script, first we parse it which breaks it up into chunks representing pushes of data
     ; or logical opcodes.  Then we can run the parsed chunks.</p>
     ;
     ; <p>The reason for this split, instead of just interpreting directly, is to make it easier
     ; to reach into a programs structure and pull out bits of data without having to run it.
     ; This is necessary to render the to/from addresses of transactions in a user interface.
     ; Bitcoin Core does something similar.</p>
     ;;
    #_private
    (§ method void parse(§ args byte[] program))
        (§ throws ScriptException)
    (§ block
        (§ ass chunks = new ArrayList<>(§ pars 5)) ;; Common size.
        (§ var ByteArrayInputStream bis = new ByteArrayInputStream(§ pars program))
        (§ var int initialSize = bis.available(§ pars ))
        (§ while (§ expr 0 < bis.available(§ pars )))
        (§ block
            (§ var int startLocationInProgram = initialSize - bis.available(§ pars ))
            (§ var int opcode = bis.read(§ pars ))

            (§ var long dataToRead = -1)
            (§ if (§ expr 0 <= opcode && opcode < OP_PUSHDATA1))
            (§ block
                ;; Read some bytes of data, where how many is the opcode value itself.
                (§ ass dataToRead = opcode)
            )
            (§ elseif (§ expr opcode == OP_PUSHDATA1))
            (§ block
                (§ if (§ expr bis.available(§ pars ) < 1))
                (§ block
                    (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Unexpected end of script")))
                )
                (§ ass dataToRead = bis.read(§ pars ))
            )
            (§ elseif (§ expr opcode == OP_PUSHDATA2))
            (§ block
                ;; Read a short, then read that many bytes of data.
                (§ if (§ expr bis.available(§ pars ) < 2))
                (§ block
                    (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Unexpected end of script")))
                )
                (§ ass dataToRead = bis.read(§ pars ) | (§ expr bis.read(§ pars ) << 8))
            )
            (§ elseif (§ expr opcode == OP_PUSHDATA4))
            (§ block
                ;; Read a uint32, then read that many bytes of data.
                ;; Though this is allowed, because its value cannot be > 520, it should never actually be used.
                (§ if (§ expr bis.available(§ pars ) < 4))
                (§ block
                    (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Unexpected end of script")))
                )
                (§ ass dataToRead = (§ expr (§ expr (§ cast long)bis.read(§ pars )) | (§ expr (§ expr (§ cast long)bis.read(§ pars )) << 8) | (§ expr (§ expr (§ cast long)bis.read(§ pars )) << 16) | (§ expr (§ expr (§ cast long)bis.read(§ pars )) << 24)))
            )

            (§ var ScriptChunk chunk)
            (§ if (§ expr dataToRead == -1))
            (§ block
                (§ ass chunk = new ScriptChunk(§ pars opcode, nil, startLocationInProgram))
            )
            (§ else )
            (§ block
                (§ if (§ expr bis.available(§ pars ) < dataToRead))
                (§ block
                    (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_BAD_OPCODE, "Push of data element that is larger than remaining data")))
                )

                (§ var byte[] data = new byte[(§ cast int)dataToRead])
                (§ call Preconditions.checkState(§ pars dataToRead == 0 || bis.read(§ pars data, 0, (§ cast int)dataToRead) == dataToRead))
                (§ ass chunk = new ScriptChunk(§ pars opcode, data, startLocationInProgram))
            )
            ;; Save some memory by eliminating redundant copies of the same chunk objects.
            (§ for (§ var ScriptChunk c) :for (§ expr STANDARD_TRANSACTION_SCRIPT_CHUNKS))
            (§ block
                (§ if (§ expr c.equals(§ pars chunk)))
                (§ block
                    (§ ass chunk = c)
                )
            )
            (§ call chunks.add(§ pars chunk))
        )
    )

    ;;;
     ; Returns true if this script is of the form <pubkey> OP_CHECKSIG.  This form was originally intended for
     ; transactions where the peers talked to each other directly via TCP/IP, but has fallen out of favor with time
     ; due to that mode of operation being susceptible to man-in-the-middle attacks.  It is still used in coinbase
     ; outputs and can be useful more exotic types of transaction, but today most payments are to addresses.
     ;;
    #_public
    (§ method boolean isSentToRawPubKey(§ args ))
    (§ block
        (§ return (§ expr chunks.size(§ pars ) == 2 && chunks.get(§ pars 1).equalsOpCode(§ pars OP_CHECKSIG) && !chunks.get(§ pars 0).isOpCode(§ pars ) && 1 < chunks.get(§ pars 0).data.length))
    )

    ;;;
     ; Returns true if this script is of the form DUP HASH160 <pubkey hash> EQUALVERIFY CHECKSIG, i.e. payment to an
     ; address like 1VayNert3x1KzbpzMGt2qdqrAThiRovi8.  This form was originally intended for the case where you wish
     ; to send somebody money with a written code because their node is offline, but over time has become the standard
     ; way to make payments due to the short and recognizable base58 form addresses come in.
     ;;
    #_public
    (§ method boolean isSentToAddress(§ args ))
    (§ block
        (§ return (§ expr chunks.size(§ pars ) == 5 && chunks.get(§ pars 0).equalsOpCode(§ pars OP_DUP) && chunks.get(§ pars 1).equalsOpCode(§ pars OP_HASH160) && chunks.get(§ pars 2).data.length == Address.LENGTH && chunks.get(§ pars 3).equalsOpCode(§ pars OP_EQUALVERIFY) && chunks.get(§ pars 4).equalsOpCode(§ pars OP_CHECKSIG)))
    )

    ;;;
     ; <p>If a program matches the standard template DUP HASH160 &lt;pubkey hash&gt; EQUALVERIFY CHECKSIG,
     ; then this function retrieves the third element.
     ; In this case, this is useful for fetching the destination address of a transaction.</p>
     ;
     ; <p>If a program matches the standard template HASH160 &lt;script hash&gt; EQUAL,
     ; then this function retrieves the second element.
     ; In this case, this is useful for fetching the hash of the redeem script of a transaction.</p>
     ;
     ; <p>Otherwise it throws a ScriptException.</p>
     ;
     ;;
    #_public
    (§ method byte[] getPubKeyHash(§ args ))
        (§ throws ScriptException)
    (§ block
        (§ if (§ expr isSentToAddress(§ pars )))
        (§ block
            (§ return chunks.get(§ pars 2).data)
        )
        (§ if (§ expr isPayToScriptHash(§ pars )))
        (§ block
            (§ return chunks.get(§ pars 1).data)
        )

        (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script not in the standard scriptPubKey form")))
    )

    ;;;
     ; Returns the public key in this script.  If a script contains two constants and nothing else, it is assumed
     ; to be a scriptSig (input) for a pay-to-address output and the second constant is returned (the first is the
     ; signature).  If a script contains a constant and an OP_CHECKSIG opcode, the constant is returned as it is
     ; assumed to be a direct pay-to-key scriptPubKey (output) and the first constant is the public key.
     ;
     ; @throws ScriptException if the script is none of the named forms.
     ;;
    #_public
    (§ method byte[] getPubKey(§ args ))
        (§ throws ScriptException)
    (§ block
        (§ if (§ expr chunks.size(§ pars ) != 2))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script not of right size, expecting 2 but got " + chunks.size(§ pars ))))
        )

        #_final
        (§ var ScriptChunk chunk0 = chunks.get(§ pars 0))
        #_final
        (§ var byte[] chunk0data = chunk0.data)
        #_final
        (§ var ScriptChunk chunk1 = chunks.get(§ pars 1))
        #_final
        (§ var byte[] chunk1data = chunk1.data)

        ;; If we have two large constants assume the input to a pay-to-address output.
        (§ if (§ expr chunk0data != nil && 2 < chunk0data.length && chunk1data != nil && 2 < chunk1data.length))
        (§ block
            (§ return chunk1data)
        )

        ;; A large constant followed by an OP_CHECKSIG is the key.
        (§ if (§ expr chunk1.equalsOpCode(§ pars OP_CHECKSIG) && chunk0data != nil && 2 < chunk0data.length))
        (§ block
            (§ return chunk0data)
        )

        (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script did not match expected form: " + this)))
    )

    ;;;
     ; Retrieves the sender public key from a LOCKTIMEVERIFY transaction.
     ;
     ; @throws ScriptException
     ;;
    #_public
    (§ method byte[] getCLTVPaymentChannelSenderPubKey(§ args ))
        (§ throws ScriptException)
    (§ block
        (§ if (§ expr isSentToCLTVPaymentChannel(§ pars )))
        (§ block
            (§ return chunks.get(§ pars 8).data)
        )

        (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script not a standard CHECKLOCKTIMVERIFY transaction: " + this)))
    )

    ;;;
     ; Retrieves the recipient public key from a LOCKTIMEVERIFY transaction.
     ;
     ; @throws ScriptException
     ;;
    #_public
    (§ method byte[] getCLTVPaymentChannelRecipientPubKey(§ args ))
        (§ throws ScriptException)
    (§ block
        (§ if (§ expr isSentToCLTVPaymentChannel(§ pars )))
        (§ block
            (§ return chunks.get(§ pars 1).data)
        )

        (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script not a standard CHECKLOCKTIMVERIFY transaction: " + this)))
    )

    #_public
    (§ method BigInteger getCLTVPaymentChannelExpiry(§ args ))
    (§ block
        (§ if (§ expr isSentToCLTVPaymentChannel(§ pars )))
        (§ block
            (§ return castToBigInteger(§ pars chunks.get(§ pars 4).data, 5, false))
        )

        (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script not a standard CHECKLOCKTIMEVERIFY transaction: " + this)))
    )

    ;;;
     ; For 2-element [input] scripts assumes that the paid-to-address can be derived from the public key.
     ; The concept of a "from address" isn't well defined in Bitcoin and you should not assume the sender
     ; of a transaction can actually receive coins on it. This method may be removed in future.
     ;;
    #_deprecated
    #_public
    (§ method Address getFromAddress(§ args NetworkParameters params))
        (§ throws ScriptException)
    (§ block
        (§ return (§ new Address(§ pars params, Utils.sha256hash160(§ pars getPubKey(§ pars )))))
    )

    ;;;
     ; Gets the destination address from this script, if it's in the required form (see getPubKey).
     ;;
    #_public
    (§ method Address getToAddress(§ args NetworkParameters params))
        (§ throws ScriptException)
    (§ block
        (§ return getToAddress(§ pars params, false))
    )

    ;;;
     ; Gets the destination address from this script, if it's in the required form (see getPubKey).
     ;
     ; @param forcePayToPubKey If true, allow payToPubKey to be casted to the corresponding address.
     ;                         This is useful if you prefer showing addresses rather than pubkeys.
     ;;
    #_public
    (§ method Address getToAddress(§ args NetworkParameters params, boolean forcePayToPubKey))
        (§ throws ScriptException)
    (§ block
        (§ if (§ expr isSentToAddress(§ pars )))
        (§ block
            (§ return (§ new Address(§ pars params, getPubKeyHash(§ pars ))))
        )
        (§ if (§ expr isPayToScriptHash(§ pars )))
        (§ block
            (§ return Address.fromP2SHScript(§ pars params, this))
        )
        (§ if (§ expr forcePayToPubKey && isSentToRawPubKey(§ pars )))
        (§ block
            (§ return ECKey.fromPublicOnly(§ pars getPubKey(§ pars )).toAddress(§ pars params))
        )

        (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Cannot cast this script to a pay-to-address type")))
    )

    ;;;
     ; Writes out the given byte buffer to the output stream with the correct opcode prefix.
     ; To write an integer call writeBytes(out, Utils.reverseBytes(Utils.encodeMPI(val, false))).
     ;;
    #_public
    #_static
    (§ method void writeBytes(§ args OutputStream os, byte[] buf))
        (§ throws IOException)
    (§ block
        (§ if (§ expr buf.length < OP_PUSHDATA1))
        (§ block
            (§ call os.write(§ pars buf.length))
            (§ call os.write(§ pars buf))
        )
        (§ elseif (§ expr buf.length < 256))
        (§ block
            (§ call os.write(§ pars OP_PUSHDATA1))
            (§ call os.write(§ pars buf.length))
            (§ call os.write(§ pars buf))
        )
        (§ elseif (§ expr buf.length < 65536))
        (§ block
            (§ call os.write(§ pars OP_PUSHDATA2))
            (§ call os.write(§ pars 0xff & buf.length))
            (§ call os.write(§ pars 0xff & (§ expr buf.length >> 8)))
            (§ call os.write(§ pars buf))
        )
        (§ else )
        (§ block
            (§ throw (§ new RuntimeException(§ pars "Unimplemented")))
        )
    )

    ;;; Creates a program that requires at least N of the given keys to sign, using OP_CHECKMULTISIG. ;;
    #_public
    #_static
    (§ method byte[] createMultiSigOutputScript(§ args int threshold, List<ECKey> pubkeys))
    (§ block
        (§ call Preconditions.checkArgument(§ pars 0 < threshold))
        (§ call Preconditions.checkArgument(§ pars threshold <= pubkeys.size(§ pars )))
        (§ call Preconditions.checkArgument(§ pars pubkeys.size(§ pars ) <= 16)) ;; That's the max we can represent with a single opcode.

        (§ if (§ expr 3 < pubkeys.size(§ pars )))
        (§ block
            (§ call log.warn(§ pars "Creating a multi-signature output that is non-standard: {} pubkeys, should be <= 3", pubkeys.size(§ pars )))
        )

        (§ try )
        (§ block
            (§ var ByteArrayOutputStream bits = new ByteArrayOutputStream(§ pars ))
            (§ call bits.write(§ pars encodeToOpN(§ pars threshold)))
            (§ for (§ var ECKey key) :for (§ expr pubkeys))
            (§ block
                (§ call writeBytes(§ pars bits, key.getPubKey(§ pars )))
            )
            (§ call bits.write(§ pars encodeToOpN(§ pars pubkeys.size(§ pars ))))
            (§ call bits.write(§ pars OP_CHECKMULTISIG))
            (§ return bits.toByteArray(§ pars ))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
    )

    #_public
    #_static
    (§ method byte[] createInputScript(§ args byte[] signature, byte[] pubkey))
    (§ block
        (§ try )
        (§ block
            ;; TODO: Do this by creating a Script *first* then having the script reassemble itself into bytes.
            (§ var ByteArrayOutputStream bits = new UnsafeByteArrayOutputStream(§ pars signature.length + pubkey.length + 2))
            (§ call writeBytes(§ pars bits, signature))
            (§ call writeBytes(§ pars bits, pubkey))
            (§ return bits.toByteArray(§ pars ))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )

    #_public
    #_static
    (§ method byte[] createInputScript(§ args byte[] signature))
    (§ block
        (§ try )
        (§ block
            ;; TODO: Do this by creating a Script *first* then having the script reassemble itself into bytes.
            (§ var ByteArrayOutputStream bits = new UnsafeByteArrayOutputStream(§ pars signature.length + 2))
            (§ call writeBytes(§ pars bits, signature))
            (§ return bits.toByteArray(§ pars ))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )

    ;;;
     ; Creates an incomplete scriptSig that, once filled with signatures, can redeem output containing this scriptPubKey.
     ; Instead of the signatures resulting script has OP_0.
     ; Having incomplete input script allows to pass around partially signed tx.
     ; It is expected that this program later on will be updated with proper signatures.
     ;;
    #_public
    (§ method Script createEmptyInputScript(§ args #_nilable ECKey key, #_nilable Script redeemScript))
    (§ block
        (§ if (§ expr isSentToAddress(§ pars )))
        (§ block
            (§ call Preconditions.checkArgument(§ pars key != nil, "Key required to create pay-to-address input script"))
            (§ return ScriptBuilder.createInputScript(§ pars nil, key))
        )

        (§ if (§ expr isSentToRawPubKey(§ pars )))
        (§ block
            (§ return ScriptBuilder.createInputScript(§ pars nil))
        )

        (§ if (§ expr isPayToScriptHash(§ pars )))
        (§ block
            (§ call Preconditions.checkArgument(§ pars redeemScript != nil, "Redeem script required to create P2SH input script"))
            (§ return ScriptBuilder.createP2SHMultiSigInputScript(§ pars nil, redeemScript))
        )

        (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Do not understand script type: " + this)))
    )

    ;;;
     ; Returns a copy of the given scriptSig with the signature inserted in the given position.
     ;;
    #_public
    (§ method Script getScriptSigWithSignature(§ args Script scriptSig, byte[] sigBytes, int index))
    (§ block
        (§ var int sigsPrefixCount = 0)
        (§ var int sigsSuffixCount = 0)
        (§ if (§ expr isPayToScriptHash(§ pars )))
        (§ block
            (§ ass sigsPrefixCount = 1) ;; OP_0 <sig>* <redeemScript>
            (§ ass sigsSuffixCount = 1)
        )
        (§ elseif (§ expr isSentToMultiSig(§ pars )))
        (§ block
            (§ ass sigsPrefixCount = 1) ;; OP_0 <sig>*
        )
        (§ elseif (§ expr isSentToAddress(§ pars )))
        (§ block
            (§ ass sigsSuffixCount = 1) ;; <sig> <pubkey>
        )
        (§ return ScriptBuilder.updateScriptWithSignature(§ pars scriptSig, sigBytes, index, sigsPrefixCount, sigsSuffixCount))
    )

    ;;;
     ; Returns the index where a signature by the key should be inserted.
     ; Only applicable to a P2SH scriptSig.
     ;;
    #_public
    (§ method int getSigInsertionIndex(§ args Sha256Hash hash, ECKey signingKey))
    (§ block
        ;; Iterate over existing signatures, skipping the initial OP_0, the final redeem script
        ;; and any placeholder OP_0 sigs.
        (§ var List<ScriptChunk> existingChunks = chunks.subList(§ pars 1, chunks.size(§ pars ) - 1))
        (§ var ScriptChunk redeemScriptChunk = chunks.get(§ pars chunks.size(§ pars ) - 1))
        (§ call Preconditions.checkNotNull(§ pars redeemScriptChunk.data))
        (§ var Script redeemScript = new Script(§ pars redeemScriptChunk.data))

        (§ var int sigCount = 0)
        (§ var int myIndex = redeemScript.findKeyInRedeem(§ pars signingKey))
        (§ for (§ var ScriptChunk chunk) :for (§ expr existingChunks))
        (§ block
            (§ if (§ expr chunk.opcode == OP_0))
            (§ block
                ;; OP_0, skip
            )
            (§ else )
            (§ block
                (§ call Preconditions.checkNotNull(§ pars chunk.data))
                (§ if (§ expr myIndex < redeemScript.findSigInRedeem(§ pars chunk.data, hash)))
                (§ block
                    (§ return sigCount)
                )
                (§ ass sigCount = sigCount + 1)
            )
        )
        (§ return sigCount)
    )

    #_private
    (§ method int findKeyInRedeem(§ args ECKey key))
    (§ block
        (§ call Preconditions.checkArgument(§ pars chunks.get(§ pars 0).isOpCode(§ pars ))) ;; P2SH scriptSig

        (§ var int numKeys = Script.decodeFromOpN(§ pars chunks.get(§ pars chunks.size(§ pars ) - 2).opcode))
        (§ for (§ var int i = 0) :for (§ expr i < numKeys) :for (§ ass i = i + 1))
        (§ block
            (§ if (§ expr Arrays.equals(§ pars chunks.get(§ pars 1 + i).data, key.getPubKey(§ pars ))))
            (§ block
                (§ return i)
            )
        )

        (§ throw (§ new IllegalStateException(§ pars "Could not find matching key " + key + " in script " + this)))
    )

    ;;;
     ; Returns a list of the keys required by this script, assuming a multi-sig script.
     ;
     ; @throws ScriptException if the script type is not understood or is pay to address or is P2SH (run this method on the "Redeem script" instead).
     ;;
    #_public
    (§ method List<ECKey> getPubKeys(§ args ))
    (§ block
        (§ if (§ expr !isSentToMultiSig(§ pars )))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Only usable for multisig scripts.")))
        )

        (§ var ArrayList<ECKey> result = Lists.newArrayList(§ pars ))
        (§ var int numKeys = Script.decodeFromOpN(§ pars chunks.get(§ pars chunks.size(§ pars ) - 2).opcode))
        (§ for (§ var int i = 0) :for (§ expr i < numKeys) :for (§ ass i = i + 1))
        (§ block
            (§ call result.add(§ pars ECKey.fromPublicOnly(§ pars chunks.get(§ pars 1 + i).data)))
        )
        (§ return result)
    )

    #_private
    (§ method int findSigInRedeem(§ args byte[] signatureBytes, Sha256Hash hash))
    (§ block
        (§ call Preconditions.checkArgument(§ pars chunks.get(§ pars 0).isOpCode(§ pars ))) ;; P2SH scriptSig

        (§ var int numKeys = Script.decodeFromOpN(§ pars chunks.get(§ pars chunks.size(§ pars ) - 2).opcode))
        (§ var TransactionSignature signature = TransactionSignature.decodeFromBitcoin(§ pars signatureBytes, true))
        (§ for (§ var int i = 0) :for (§ expr i < numKeys) :for (§ ass i = i + 1))
        (§ block
            (§ if (§ expr ECKey.fromPublicOnly(§ pars chunks.get(§ pars i + 1).data).verify(§ pars hash, signature)))
            (§ block
                (§ return i)
            )
        )

        (§ throw (§ new IllegalStateException(§ pars "Could not find matching key for signature on " + hash + " sig " + Utils.HEX.encode(§ pars signatureBytes))))
    )

    #_private
    #_static
    (§ method int getSigOpCount(§ args List<ScriptChunk> chunks, boolean accurate))
        (§ throws ScriptException)
    (§ block
        (§ var int sigOps = 0)
        (§ var int lastOpCode = OP_INVALIDOPCODE)
        (§ for (§ var ScriptChunk chunk) :for (§ expr chunks))
        (§ block
            (§ if (§ expr chunk.isOpCode(§ pars )))
            (§ block
                (§ switch (§ expr chunk.opcode))
                (§ block
                    (§ case OP_CHECKSIG)
                    (§ case OP_CHECKSIGVERIFY)
                    (§ block
                        (§ ass sigOps = sigOps + 1)
                        (§ break )
                    )
                    (§ case OP_CHECKMULTISIG)
                    (§ case OP_CHECKMULTISIGVERIFY)
                    (§ block
                        (§ if (§ expr accurate && OP_1 <= lastOpCode && lastOpCode <= OP_16))
                        (§ block
                            (§ ass sigOps = sigOps + decodeFromOpN(§ pars lastOpCode))
                        )
                        (§ else )
                        (§ block
                            (§ ass sigOps = sigOps + 20)
                        )
                        (§ break )
                    )
                    (§ default )
                    (§ block
                        (§ break )
                    )
                )
                (§ ass lastOpCode = chunk.opcode)
            )
        )
        (§ return sigOps)
    )

    #_static
    (§ method int decodeFromOpN(§ args int opcode))
    (§ block
        (§ call Preconditions.checkArgument(§ pars (§ expr opcode == OP_0 || opcode == OP_1NEGATE) || (§ expr OP_1 <= opcode && opcode <= OP_16), "decodeFromOpN called on non OP_N opcode"))

        (§ if (§ expr opcode == OP_0))
        (§ block
            (§ return 0)
        )
        (§ if (§ expr opcode == OP_1NEGATE))
        (§ block
            (§ return -1)
        )

        (§ return opcode + 1 - OP_1)
    )

    #_static
    (§ method int encodeToOpN(§ args int value))
    (§ block
        (§ call Preconditions.checkArgument(§ pars -1 <= value && value <= 16, "encodeToOpN called for " + value + " which we cannot encode in an opcode."))

        (§ if (§ expr value == 0))
        (§ block
            (§ return OP_0)
        )
        (§ if (§ expr value == -1))
        (§ block
            (§ return OP_1NEGATE)
        )

        (§ return value - 1 + OP_1)
    )

    ;;;
     ; Gets the count of regular SigOps in the script program (counting multisig ops as 20).
     ;;
    #_public
    #_static
    (§ method int getSigOpCount(§ args byte[] program))
        (§ throws ScriptException)
    (§ block
        (§ var Script script = new Script(§ pars ))
        (§ try )
        (§ block
            (§ call script.parse(§ pars program))
        )
        (§ catch (§ args ScriptException _))
        (§ block
            ;; Ignore errors and count up to the parse-able length.
        )
        (§ return getSigOpCount(§ pars script.chunks, false))
    )

    ;;;
     ; Gets the count of P2SH Sig Ops in the Script scriptSig.
     ;;
    #_public
    #_static
    (§ method long getP2SHSigOpCount(§ args byte[] scriptSig))
        (§ throws ScriptException)
    (§ block
        (§ var Script script = new Script(§ pars ))
        (§ try )
        (§ block
            (§ call script.parse(§ pars scriptSig))
        )
        (§ catch (§ args ScriptException _))
        (§ block
            ;; Ignore errors and count up to the parse-able length.
        )
        (§ for (§ var int i = script.chunks.size(§ pars ) - 1) :for (§ expr 0 <= i) :for (§ ass i = i - 1))
        (§ block
            (§ if (§ expr !script.chunks.get(§ pars i).isOpCode(§ pars )))
            (§ block
                (§ var Script subScript = new Script(§ pars ))
                (§ call subScript.parse(§ pars script.chunks.get(§ pars i).data))
                (§ return getSigOpCount(§ pars subScript.chunks, true))
            )
        )
        (§ return 0)
    )

    ;;;
     ; Returns number of signatures required to satisfy this script.
     ;;
    #_public
    (§ method int getNumberOfSignaturesRequiredToSpend(§ args ))
    (§ block
        ;; For N of M CHECKMULTISIG script we will need N signatures to spend.
        (§ if (§ expr isSentToMultiSig(§ pars )))
        (§ block
            (§ return Script.decodeFromOpN(§ pars chunks.get(§ pars 0).opcode))
        )

        ;; pay-to-address and pay-to-pubkey require single sig
        (§ if (§ expr isSentToAddress(§ pars ) || isSentToRawPubKey(§ pars )))
        (§ block
            (§ return 1)
        )

        (§ if (§ expr isPayToScriptHash(§ pars )))
        (§ block
            (§ throw (§ new IllegalStateException(§ pars "For P2SH number of signatures depends on redeem script")))
        )

        (§ throw (§ new IllegalStateException(§ pars "Unsupported script type")))
    )

    ;;;
     ; Returns number of bytes required to spend this script.  It accepts optional ECKey and redeemScript
     ; that may be required for certain types of script to estimate target size.
     ;;
    #_public
    (§ method int getNumberOfBytesRequiredToSpend(§ args #_nilable ECKey pubKey, #_nilable Script redeemScript))
    (§ block
        (§ if (§ expr isPayToScriptHash(§ pars )))
        (§ block
            ;; scriptSig: <sig> [sig] [sig...] <redeemscript>
            (§ call Preconditions.checkArgument(§ pars redeemScript != nil, "P2SH script requires redeemScript to be spent"))
            (§ return redeemScript.getNumberOfSignaturesRequiredToSpend(§ pars ) * SIG_SIZE + redeemScript.getProgram(§ pars ).length)
        )
        (§ elseif (§ expr isSentToMultiSig(§ pars )))
        (§ block
            ;; scriptSig: OP_0 <sig> [sig] [sig...]
            (§ return getNumberOfSignaturesRequiredToSpend(§ pars ) * SIG_SIZE + 1)
        )
        (§ elseif (§ expr isSentToRawPubKey(§ pars )))
        (§ block
            ;; scriptSig: <sig>
            (§ return SIG_SIZE)
        )
        (§ elseif (§ expr isSentToAddress(§ pars )))
        (§ block
            ;; scriptSig: <sig> <pubkey>
            (§ var int uncompressedPubKeySize = 65)
            (§ return SIG_SIZE + (§ expr pubKey != nil ? pubKey.getPubKey(§ pars ).length :else uncompressedPubKeySize))
        )
        (§ else )
        (§ block
            (§ throw (§ new IllegalStateException(§ pars "Unsupported script type")))
        )
    )

    ;;;
     ; <p>Whether or not this is a scriptPubKey representing a pay-to-script-hash output.  In such outputs, the logic
     ; that controls reclamation is not actually in the output at all.  Instead there's just a hash, and it's up to the
     ; spending input to provide a program matching that hash.  This rule is "soft enforced" by the network as it does
     ; not exist in Bitcoin Core.  It means blocks containing P2SH transactions that don't match
     ; correctly are considered valid, but won't be mined upon, so they'll be rapidly re-orgd out of the chain.  This
     ; logic is defined by <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP 16</a>.</p>
     ;
     ; <p>bitcoinj does not support creation of P2SH transactions today.  The goal of P2SH is to allow short addresses
     ; even for complex scripts (e.g. multi-sig outputs) so they are convenient to work with in things like QRcodes or
     ; with copy/paste, and also to minimize the size of the unspent output set (which improves performance of the
     ; Bitcoin system).</p>
     ;;
    #_public
    (§ method boolean isPayToScriptHash(§ args ))
    (§ block
        ;; We have to check against the serialized form because BIP16 defines a P2SH output using an exact byte
        ;; template, not the logical program structure.  Thus you can have two programs that look identical when
        ;; printed out but one is a P2SH script and the other isn't! :( ;; )
        (§ var byte[] program = getProgram(§ pars ))
        (§ return program.length == 23 && (§ expr program[0] & 0xff) == OP_HASH160 && (§ expr program[1] & 0xff) == 0x14 && (§ expr program[22] & 0xff) == OP_EQUAL)
    )

    ;;;
     ; Returns whether this script matches the format used for multisig outputs: [n] [keys...] [m] CHECKMULTISIG.
     ;;
    #_public
    (§ method boolean isSentToMultiSig(§ args ))
    (§ block
        (§ if (§ expr chunks.size(§ pars ) < 4))
        (§ block
            (§ return false)
        )

        (§ var ScriptChunk chunk = chunks.get(§ pars chunks.size(§ pars ) - 1))
        ;; Must end in OP_CHECKMULTISIG[VERIFY].
        (§ if (§ expr !chunk.isOpCode(§ pars )))
        (§ block
            (§ return false)
        )
        (§ if (§ expr !(§ expr chunk.equalsOpCode(§ pars OP_CHECKMULTISIG) || chunk.equalsOpCode(§ pars OP_CHECKMULTISIGVERIFY))))
        (§ block
            (§ return false)
        )

        (§ try )
        (§ block
            ;; Second to last chunk must be an OP_N opcode and there should be that many data chunks (keys).
            (§ var ScriptChunk m = chunks.get(§ pars chunks.size(§ pars ) - 2))
            (§ if (§ expr !m.isOpCode(§ pars )))
            (§ block
                (§ return false)
            )

            (§ var int numKeys = decodeFromOpN(§ pars m.opcode))
            (§ if (§ expr numKeys < 1 || chunks.size(§ pars ) != 3 + numKeys))
            (§ block
                (§ return false)
            )

            (§ for (§ var int i = 1) :for (§ expr i < chunks.size(§ pars ) - 2) :for (§ ass i = i + 1))
            (§ block
                (§ if (§ expr chunks.get(§ pars i).isOpCode(§ pars )))
                (§ block
                    (§ return false)
                )
            )

            ;; First chunk must be an OP_N opcode too.
            (§ if (§ expr decodeFromOpN(§ pars chunks.get(§ pars 0).opcode) < 1))
            (§ block
                (§ return false)
            )
        )
        (§ catch (§ args IllegalStateException e))
        (§ block
            (§ return false) ;; Not an OP_N opcode.
        )
        (§ return true)
    )

    #_public
    (§ method boolean isSentToCLTVPaymentChannel(§ args ))
    (§ block
        ;; Check that opcodes match the pre-determined format.
        ;; chunk[1] = recipient pubkey
        ;; chunk[4] = locktime
        ;; chunk[8] = sender pubkey
        (§ return (§ expr (§ expr chunks.size(§ pars ) == 10) && chunks.get(§ pars 0).equalsOpCode(§ pars OP_IF) && chunks.get(§ pars 2).equalsOpCode(§ pars OP_CHECKSIGVERIFY) && chunks.get(§ pars 3).equalsOpCode(§ pars OP_ELSE) && chunks.get(§ pars 5).equalsOpCode(§ pars OP_CHECKLOCKTIMEVERIFY) && chunks.get(§ pars 6).equalsOpCode(§ pars OP_DROP) && chunks.get(§ pars 7).equalsOpCode(§ pars OP_ENDIF) && chunks.get(§ pars 9).equalsOpCode(§ pars OP_CHECKSIG)))
    )

    #_private
    #_static
    (§ method boolean equalsRange(§ args byte[] a, int start, byte[] b))
    (§ block
        (§ if (§ expr a.length < start + b.length))
        (§ block
            (§ return false)
        )

        (§ for (§ var int i = 0) :for (§ expr i < b.length) :for (§ ass i = i + 1))
        (§ block
            (§ if (§ expr a[i + start] != b[i]))
            (§ block
                (§ return false)
            )
        )

        (§ return true)
    )

    ;;;
     ; Returns the script bytes of inputScript with all instances of the specified script object removed.
     ;;
    #_public
    #_static
    (§ method byte[] removeAllInstancesOf(§ args byte[] inputScript, byte[] chunkToRemove))
    (§ block
        ;; We usually don't end up removing anything.
        (§ var UnsafeByteArrayOutputStream bos = new UnsafeByteArrayOutputStream(§ pars inputScript.length))

        (§ var int cursor = 0)
        (§ while (§ expr cursor < inputScript.length))
        (§ block
            (§ var boolean skip = equalsRange(§ pars inputScript, cursor, chunkToRemove))

            (§ var int opcode = inputScript[cursor] & 0xff)
            (§ ass cursor = cursor + 1)
            (§ var int additionalBytes = 0)
            (§ if (§ expr 0 <= opcode && opcode < OP_PUSHDATA1))
            (§ block
                (§ ass additionalBytes = opcode)
            )
            (§ elseif (§ expr opcode == OP_PUSHDATA1))
            (§ block
                (§ ass additionalBytes = (§ expr 0xff & inputScript[cursor]) + 1)
            )
            (§ elseif (§ expr opcode == OP_PUSHDATA2))
            (§ block
                (§ ass additionalBytes = (§ expr (§ expr (§ expr 0xff & inputScript[cursor]) | (§ expr (§ expr 0xff & inputScript[cursor + 1]) << 8)) + 2))
            )
            (§ elseif (§ expr opcode == OP_PUSHDATA4))
            (§ block
                (§ ass additionalBytes = (§ expr (§ expr (§ expr 0xff & inputScript[cursor]) | (§ expr (§ expr 0xff & inputScript[cursor + 1]) << 8) | (§ expr (§ expr 0xff & inputScript[cursor + 1]) << 16) | (§ expr (§ expr 0xff & inputScript[cursor + 1]) << 24)) + 4))
            )
            (§ if (§ expr !skip))
            (§ block
                (§ try )
                (§ block
                    (§ call bos.write(§ pars opcode))
                    (§ call bos.write(§ pars Arrays.copyOfRange(§ pars inputScript, cursor, cursor + additionalBytes)))
                )
                (§ catch (§ args IOException e))
                (§ block
                    (§ throw (§ new RuntimeException(§ pars e)))
                )
            )
            (§ ass cursor = cursor + additionalBytes)
        )
        (§ return bos.toByteArray(§ pars ))
    )

    ;;;
     ; Returns the script bytes of inputScript with all instances of the given op code removed.
     ;;
    #_public
    #_static
    (§ method byte[] removeAllInstancesOfOp(§ args byte[] inputScript, int opCode))
    (§ block
        (§ return removeAllInstancesOf(§ pars inputScript, new byte[] {(§ cast byte)opCode}))
    )

    #_private
    #_static
    (§ method boolean castToBool(§ args byte[] data))
    (§ block
        (§ for (§ var int i = 0) :for (§ expr i < data.length) :for (§ ass i = i + 1))
        (§ block
            ;; "Can be negative zero" - Bitcoin Core (see OpenSSL's BN_bn2mpi)
            (§ if (§ expr data[i] != 0))
            (§ block
                (§ return (§ expr i != data.length - 1 || (§ expr data[i] & 0xff) != 0x80))
            )
        )
        (§ return false)
    )

    ;;;
     ; Cast a script chunk to a BigInteger.
     ;
     ; @see #castToBigInteger(byte[], int) for values with different maximum sizes.
     ; @throws ScriptException if the chunk is longer than 4 bytes.
     ;;
    #_private
    #_static
    (§ method BigInteger castToBigInteger(§ args byte[] chunk, #_final boolean requireMinimal))
        (§ throws ScriptException)
    (§ block
        (§ return castToBigInteger(§ pars chunk, 4, requireMinimal))
    )

    ;;;
     ; Cast a script chunk to a BigInteger.  Normally you would want {@link #castToBigInteger(byte[])} instead, this
     ; is only for cases where the normal maximum length does not apply (i.e. CHECKLOCKTIMEVERIFY, CHECKSEQUENCEVERIFY).
     ;
     ; @param maxLength The maximum length in bytes.
     ; @param requireMinimal Check if the number is encoded with the minimum possible number of bytes.
     ; @throws ScriptException if the chunk is longer than the specified maximum.
     ;;
    #_private
    #_static
    (§ method BigInteger castToBigInteger(§ args #_final byte[] chunk, #_final int maxLength, #_final boolean requireMinimal))
        (§ throws ScriptException)
    (§ block
        (§ if (§ expr maxLength < chunk.length))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "Script attempted to use an integer larger than " + maxLength + " bytes")))
        )

        (§ if (§ expr requireMinimal && 0 < chunk.length))
        (§ block
            ;; Check that the number is encoded with the minimum possible number of bytes.
            ;;
            ;; If the most-significant-byte - excluding the sign bit - is zero, then we're not minimal.
            ;; Note how this test also rejects the negative-zero encoding, 0x80.
            (§ if (§ expr (§ expr chunk[chunk.length - 1] & 0x7f) == 0))
            (§ block
                ;; One exception: if there's more than one byte and the most significant bit
                ;; of the second-most-significant-byte is set, it would conflict with the sign bit.
                ;; An example of this case is +-255, which encode to 0xff00 and 0xff80 respectively.
                ;; (big-endian)
                (§ if (§ expr chunk.length <= 1 || (§ expr chunk[chunk.length - 2] & 0x80) == 0))
                (§ block
                    (§ throw  new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNKNOWN_ERROR, "non-minimally encoded script number"))
                )
            )
        )

        (§ return Utils.decodeMPI(§ pars Utils.reverseBytes(§ pars chunk), false))
    )

    #_public
    (§ method boolean isOpReturn(§ args ))
    (§ block
        (§ return (§ expr 0 < chunks.size(§ pars ) && chunks.get(§ pars 0).equalsOpCode(§ pars OP_RETURN)))
    )

    ;;;
     ; Exposes the script interpreter.  Normally you should not use this directly, instead use
     ; {@link org.bitcoinj.core.TransactionInput#verify(org.bitcoinj.core.TransactionOutput)} or
     ; {@link org.bitcoinj.script.Script#correctlySpends(org.bitcoinj.core.Transaction, long, Script)}.
     ; This method is useful if you need more precise control or access to the final state of the stack.
     ; This interface is very likely to change in future.
     ;
     ; @deprecated Use {@link #executeScript(org.bitcoinj.core.Transaction, long, org.bitcoinj.script.Script, java.util.LinkedList, java.util.Set)}
     ; instead.
     ;;
    #_deprecated
    #_public
    #_static
    (§ method void executeScript(§ args #_nilable Transaction txContainingThis, long index, Script script, LinkedList<byte[]> stack, boolean enforceNullDummy))
        (§ throws ScriptException)
    (§ block
        #_final
        (§ var EnumSet<VerifyFlag> flags = enforceNullDummy ? EnumSet.of(§ pars VerifyFlag.NULLDUMMY) :else EnumSet.noneOf(§ pars VerifyFlag.class))

        (§ call executeScript(§ pars txContainingThis, index, script, stack, flags))
    )

    ;;;
     ; Exposes the script interpreter.  Normally you should not use this directly, instead use
     ; {@link org.bitcoinj.core.TransactionInput#verify(org.bitcoinj.core.TransactionOutput)} or
     ; {@link org.bitcoinj.script.Script#correctlySpends(org.bitcoinj.core.Transaction, long, Script)}.
     ; This method is useful if you need more precise control or access to the final state of the stack.
     ; This interface is very likely to change in future.
     ;;
    #_public
    #_static
    (§ method void executeScript(§ args #_nilable Transaction txContainingThis, long index, Script script, LinkedList<byte[]> stack, Set<VerifyFlag> verifyFlags))
        (§ throws ScriptException)
    (§ block
        (§ var int opCount = 0)
        (§ var int lastCodeSepLocation = 0)

        (§ var LinkedList<byte[]> altstack = new LinkedList<>(§ pars ))
        (§ var LinkedList<Boolean> ifStack = new LinkedList<>(§ pars ))

        (§ for (§ var ScriptChunk chunk) :for (§ expr script.chunks))
        (§ block
            (§ var boolean shouldExecute = !ifStack.contains(§ pars false))
            (§ var int opcode = chunk.opcode)

            ;; Check stack element size.
            (§ if (§ expr chunk.data != nil && MAX_SCRIPT_ELEMENT_SIZE < chunk.data.length))
            (§ block
                (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_PUSH_SIZE, "Attempted to push a data string larger than 520 bytes")))
            )

            ;; Note how OP_RESERVED does not count towards the opcode limit.
            (§ if (§ expr OP_16 < opcode))
            (§ block
                (§ ass opCount = opCount + 1)
                (§ if (§ expr MAX_OPS_PER_SCRIPT < opCount))
                (§ block
                    (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_OP_COUNT, "More script operations than is allowed")))
                )
            )

            ;; Disabled opcodes.
            (§ if (§ expr opcode == OP_CAT || opcode == OP_SUBSTR || opcode == OP_LEFT || opcode == OP_RIGHT || opcode == OP_INVERT || opcode == OP_AND || opcode == OP_OR || opcode == OP_XOR || opcode == OP_2MUL || opcode == OP_2DIV || opcode == OP_MUL || opcode == OP_DIV || opcode == OP_MOD || opcode == OP_LSHIFT || opcode == OP_RSHIFT))
            (§ block
                (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_DISABLED_OPCODE, "Script included a disabled Script Op.")))
            )

            (§ if (§ expr shouldExecute && OP_0 <= opcode && opcode <= OP_PUSHDATA4))
            (§ block
                ;; Check minimal push.
                (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag.MINIMALDATA) && !chunk.isShortestPossiblePushData(§ pars )))
                (§ block
                    (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_MINIMALDATA, "Script included a not minimal push operation.")))
                )

                (§ if (§ expr opcode == OP_0))
                (§ block
                    (§ call stack.add(§ pars new byte[] (§ coll )))
                )
                (§ else )
                (§ block
                    (§ call stack.add(§ pars chunk.data))
                )
            )
            (§ elseif (§ expr shouldExecute || (§ expr OP_IF <= opcode && opcode <= OP_ENDIF)))
            (§ block
                (§ switch (§ expr opcode))
                (§ block
                    (§ case OP_IF)
                    (§ block
                        (§ if (§ expr !shouldExecute))
                        (§ block
                            (§ call ifStack.add(§ pars false))
                            (§ continue )
                        )
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_IF on an empty stack")))
                        )
                        (§ call ifStack.add(§ pars castToBool(§ pars stack.pollLast(§ pars ))))
                        (§ continue )
                    )
                    (§ case OP_NOTIF)
                    (§ block
                        (§ if (§ expr !shouldExecute))
                        (§ block
                            (§ call ifStack.add(§ pars false))
                            (§ continue )
                        )
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_NOTIF on an empty stack")))
                        )
                        (§ call ifStack.add(§ pars !castToBool(§ pars stack.pollLast(§ pars ))))
                        (§ continue )
                    )
                    (§ case OP_ELSE)
                    (§ block
                        (§ if (§ expr ifStack.isEmpty(§ pars )))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_ELSE without OP_IF/NOTIF")))
                        )
                        (§ call ifStack.add(§ pars !ifStack.pollLast(§ pars )))
                        (§ continue )
                    )
                    (§ case OP_ENDIF)
                    (§ block
                        (§ if (§ expr ifStack.isEmpty(§ pars )))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_ENDIF without OP_IF/NOTIF")))
                        )
                        (§ call ifStack.pollLast(§ pars ))
                        (§ continue )
                    )

                    ;; OP_0 is no opcode
                    (§ case OP_1NEGATE)
                    (§ block
                        (§ call stack.add(§ pars Utils.reverseBytes(§ pars Utils.encodeMPI(§ pars BigInteger.ONE.negate(§ pars ), false))))
                        (§ break )
                    )
                    (§ case OP_1)
                    (§ case OP_2)
                    (§ case OP_3)
                    (§ case OP_4)
                    (§ case OP_5)
                    (§ case OP_6)
                    (§ case OP_7)
                    (§ case OP_8)
                    (§ case OP_9)
                    (§ case OP_10)
                    (§ case OP_11)
                    (§ case OP_12)
                    (§ case OP_13)
                    (§ case OP_14)
                    (§ case OP_15)
                    (§ case OP_16)
                    (§ block
                        (§ call stack.add(§ pars Utils.reverseBytes(§ pars Utils.encodeMPI(§ pars BigInteger.valueOf(§ pars decodeFromOpN(§ pars opcode)), false))))
                        (§ break )
                    )
                    (§ case OP_NOP)
                    (§ block
                        (§ break )
                    )
                    (§ case OP_VERIFY)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_VERIFY on an empty stack")))
                        )
                        (§ if (§ expr !castToBool(§ pars stack.pollLast(§ pars ))))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_VERIFY, "OP_VERIFY failed")))
                        )
                        (§ break )
                    )
                    (§ case OP_RETURN)
                    (§ block
                        (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_OP_RETURN, "Script called OP_RETURN")))
                    )
                    (§ case OP_TOALTSTACK)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_TOALTSTACK on an empty stack")))
                        )
                        (§ call altstack.add(§ pars stack.pollLast(§ pars )))
                        (§ break )
                    )
                    (§ case OP_FROMALTSTACK)
                    (§ block
                        (§ if (§ expr altstack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_ALTSTACK_OPERATION, "Attempted OP_FROMALTSTACK on an empty altstack")))
                        )
                        (§ call stack.add(§ pars altstack.pollLast(§ pars )))
                        (§ break )
                    )
                    (§ case OP_2DROP)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 2))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2DROP on a stack with size < 2")))
                        )
                        (§ call stack.pollLast(§ pars ))
                        (§ call stack.pollLast(§ pars ))
                        (§ break )
                    )
                    (§ case OP_2DUP)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 2))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2DUP on a stack with size < 2")))
                        )
                        (§ var Iterator<byte[]> it2DUP = stack.descendingIterator(§ pars ))
                        (§ var byte[] OP2DUPtmpChunk2 = it2DUP.next(§ pars ))
                        (§ call stack.add(§ pars it2DUP.next(§ pars )))
                        (§ call stack.add(§ pars OP2DUPtmpChunk2))
                        (§ break )
                    )
                    (§ case OP_3DUP)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 3))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_3DUP on a stack with size < 3")))
                        )
                        (§ var Iterator<byte[]> it3DUP = stack.descendingIterator(§ pars ))
                        (§ var byte[] OP3DUPtmpChunk3 = it3DUP.next(§ pars ))
                        (§ var byte[] OP3DUPtmpChunk2 = it3DUP.next(§ pars ))
                        (§ call stack.add(§ pars it3DUP.next(§ pars )))
                        (§ call stack.add(§ pars OP3DUPtmpChunk2))
                        (§ call stack.add(§ pars OP3DUPtmpChunk3))
                        (§ break )
                    )
                    (§ case OP_2OVER)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 4))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2OVER on a stack with size < 4")))
                        )
                        (§ var Iterator<byte[]> it2OVER = stack.descendingIterator(§ pars ))
                        (§ call it2OVER.next(§ pars ))
                        (§ call it2OVER.next(§ pars ))
                        (§ var byte[] OP2OVERtmpChunk2 = it2OVER.next(§ pars ))
                        (§ call stack.add(§ pars it2OVER.next(§ pars )))
                        (§ call stack.add(§ pars OP2OVERtmpChunk2))
                        (§ break )
                    )
                    (§ case OP_2ROT)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 6))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2ROT on a stack with size < 6")))
                        )
                        (§ var byte[] OP2ROTtmpChunk6 = stack.pollLast(§ pars ))
                        (§ var byte[] OP2ROTtmpChunk5 = stack.pollLast(§ pars ))
                        (§ var byte[] OP2ROTtmpChunk4 = stack.pollLast(§ pars ))
                        (§ var byte[] OP2ROTtmpChunk3 = stack.pollLast(§ pars ))
                        (§ var byte[] OP2ROTtmpChunk2 = stack.pollLast(§ pars ))
                        (§ var byte[] OP2ROTtmpChunk1 = stack.pollLast(§ pars ))
                        (§ call stack.add(§ pars OP2ROTtmpChunk3))
                        (§ call stack.add(§ pars OP2ROTtmpChunk4))
                        (§ call stack.add(§ pars OP2ROTtmpChunk5))
                        (§ call stack.add(§ pars OP2ROTtmpChunk6))
                        (§ call stack.add(§ pars OP2ROTtmpChunk1))
                        (§ call stack.add(§ pars OP2ROTtmpChunk2))
                        (§ break )
                    )
                    (§ case OP_2SWAP)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 4))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2SWAP on a stack with size < 4")))
                        )
                        (§ var byte[] OP2SWAPtmpChunk4 = stack.pollLast(§ pars ))
                        (§ var byte[] OP2SWAPtmpChunk3 = stack.pollLast(§ pars ))
                        (§ var byte[] OP2SWAPtmpChunk2 = stack.pollLast(§ pars ))
                        (§ var byte[] OP2SWAPtmpChunk1 = stack.pollLast(§ pars ))
                        (§ call stack.add(§ pars OP2SWAPtmpChunk3))
                        (§ call stack.add(§ pars OP2SWAPtmpChunk4))
                        (§ call stack.add(§ pars OP2SWAPtmpChunk1))
                        (§ call stack.add(§ pars OP2SWAPtmpChunk2))
                        (§ break )
                    )
                    (§ case OP_IFDUP)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_IFDUP on an empty stack")))
                        )
                        (§ if (§ expr castToBool(§ pars stack.getLast(§ pars ))))
                        (§ block
                            (§ call stack.add(§ pars stack.getLast(§ pars )))
                        )
                        (§ break )
                    )
                    (§ case OP_DEPTH)
                    (§ block
                        (§ call stack.add(§ pars Utils.reverseBytes(§ pars Utils.encodeMPI(§ pars BigInteger.valueOf(§ pars stack.size(§ pars )), false))))
                        (§ break )
                    )
                    (§ case OP_DROP)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_DROP on an empty stack")))
                        )
                        (§ call stack.pollLast(§ pars ))
                        (§ break )
                    )
                    (§ case OP_DUP)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_DUP on an empty stack")))
                        )
                        (§ call stack.add(§ pars stack.getLast(§ pars )))
                        (§ break )
                    )
                    (§ case OP_NIP)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 2))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_NIP on a stack with size < 2")))
                        )
                        (§ var byte[] OPNIPtmpChunk = stack.pollLast(§ pars ))
                        (§ call stack.pollLast(§ pars ))
                        (§ call stack.add(§ pars OPNIPtmpChunk))
                        (§ break )
                    )
                    (§ case OP_OVER)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 2))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_OVER on a stack with size < 2")))
                        )
                        (§ var Iterator<byte[]> itOVER = stack.descendingIterator(§ pars ))
                        (§ call itOVER.next(§ pars ))
                        (§ call stack.add(§ pars itOVER.next(§ pars )))
                        (§ break )
                    )
                    (§ case OP_PICK)
                    (§ case OP_ROLL)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_PICK/OP_ROLL on an empty stack")))
                        )
                        (§ var long val = castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag.MINIMALDATA)).longValue(§ pars ))
                        (§ if (§ expr val < 0 || stack.size(§ pars ) <= val))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "OP_PICK/OP_ROLL attempted to get data deeper than stack size")))
                        )
                        (§ var Iterator<byte[]> itPICK = stack.descendingIterator(§ pars ))
                        (§ for (§ var long i = 0) :for (§ expr i < val) :for (§ ass i = i + 1))
                        (§ block
                            (§ call itPICK.next(§ pars ))
                        )
                        (§ var byte[] OPROLLtmpChunk = itPICK.next(§ pars ))
                        (§ if (§ expr opcode == OP_ROLL))
                        (§ block
                            (§ call itPICK.remove(§ pars ))
                        )
                        (§ call stack.add(§ pars OPROLLtmpChunk))
                        (§ break )
                    )
                    (§ case OP_ROT)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 3))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_ROT on a stack with size < 3")))
                        )
                        (§ var byte[] OPROTtmpChunk3 = stack.pollLast(§ pars ))
                        (§ var byte[] OPROTtmpChunk2 = stack.pollLast(§ pars ))
                        (§ var byte[] OPROTtmpChunk1 = stack.pollLast(§ pars ))
                        (§ call stack.add(§ pars OPROTtmpChunk2))
                        (§ call stack.add(§ pars OPROTtmpChunk3))
                        (§ call stack.add(§ pars OPROTtmpChunk1))
                        (§ break )
                    )
                    (§ case OP_SWAP)
                    (§ case OP_TUCK)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 2))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SWAP on a stack with size < 2")))
                        )
                        (§ var byte[] OPSWAPtmpChunk2 = stack.pollLast(§ pars ))
                        (§ var byte[] OPSWAPtmpChunk1 = stack.pollLast(§ pars ))
                        (§ call stack.add(§ pars OPSWAPtmpChunk2))
                        (§ call stack.add(§ pars OPSWAPtmpChunk1))
                        (§ if (§ expr opcode == OP_TUCK))
                        (§ block
                            (§ call stack.add(§ pars OPSWAPtmpChunk2))
                        )
                        (§ break )
                    )
                    (§ case OP_SIZE)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SIZE on an empty stack")))
                        )
                        (§ call stack.add(§ pars Utils.reverseBytes(§ pars Utils.encodeMPI(§ pars BigInteger.valueOf(§ pars stack.getLast(§ pars ).length), false))))
                        (§ break )
                    )
                    (§ case OP_EQUAL)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 2))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_EQUAL on a stack with size < 2")))
                        )
                        (§ call stack.add(§ pars Arrays.equals(§ pars stack.pollLast(§ pars ), stack.pollLast(§ pars )) ? new byte[] (§ coll 1 ) :else new byte[] (§ coll )))
                        (§ break )
                    )
                    (§ case OP_EQUALVERIFY)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 2))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_EQUALVERIFY on a stack with size < 2")))
                        )
                        (§ if (§ expr !Arrays.equals(§ pars stack.pollLast(§ pars ), stack.pollLast(§ pars ))))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_EQUALVERIFY, "OP_EQUALVERIFY: non-equal data")))
                        )
                        (§ break )
                    )
                    (§ case OP_1ADD)
                    (§ case OP_1SUB)
                    (§ case OP_NEGATE)
                    (§ case OP_ABS)
                    (§ case OP_NOT)
                    (§ case OP_0NOTEQUAL)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted a numeric op on an empty stack")))
                        )
                        (§ var BigInteger numericOPnum = castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag.MINIMALDATA)))

                        (§ switch (§ expr opcode))
                        (§ block
                            (§ case OP_1ADD)
                            (§ block
                                (§ ass numericOPnum = numericOPnum.add(§ pars BigInteger.ONE))
                                (§ break )
                            )
                            (§ case OP_1SUB)
                            (§ block
                                (§ ass numericOPnum = numericOPnum.subtract(§ pars BigInteger.ONE))
                                (§ break )
                            )
                            (§ case OP_NEGATE)
                            (§ block
                                (§ ass numericOPnum = numericOPnum.negate(§ pars ))
                                (§ break )
                            )
                            (§ case OP_ABS)
                            (§ block
                                (§ if (§ expr numericOPnum.signum(§ pars ) < 0))
                                (§ block
                                    (§ ass numericOPnum = numericOPnum.negate(§ pars ))
                                )
                                (§ break )
                            )
                            (§ case OP_NOT)
                            (§ block
                                (§ if (§ expr numericOPnum.equals(§ pars BigInteger.ZERO)))
                                (§ block
                                    (§ ass numericOPnum = BigInteger.ONE)
                                )
                                (§ else )
                                (§ block
                                    (§ ass numericOPnum = BigInteger.ZERO)
                                )
                                (§ break )
                            )
                            (§ case OP_0NOTEQUAL)
                            (§ block
                                (§ if (§ expr numericOPnum.equals(§ pars BigInteger.ZERO)))
                                (§ block
                                    (§ ass numericOPnum = BigInteger.ZERO)
                                )
                                (§ else )
                                (§ block
                                    (§ ass numericOPnum = BigInteger.ONE)
                                )
                                (§ break )
                            )
                            (§ default )
                            (§ block
                                (§ throw (§ new AssertionError(§ pars "Unreachable")))
                            )
                        )

                        (§ call stack.add(§ pars Utils.reverseBytes(§ pars Utils.encodeMPI(§ pars numericOPnum, false))))
                        (§ break )
                    )
                    (§ case OP_ADD)
                    (§ case OP_SUB)
                    (§ case OP_BOOLAND)
                    (§ case OP_BOOLOR)
                    (§ case OP_NUMEQUAL)
                    (§ case OP_NUMNOTEQUAL)
                    (§ case OP_LESSTHAN)
                    (§ case OP_GREATERTHAN)
                    (§ case OP_LESSTHANOREQUAL)
                    (§ case OP_GREATERTHANOREQUAL)
                    (§ case OP_MIN)
                    (§ case OP_MAX)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 2))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted a numeric op on a stack with size < 2")))
                        )
                        (§ var BigInteger numericOPnum2 = castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag.MINIMALDATA)))
                        (§ var BigInteger numericOPnum1 = castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag.MINIMALDATA)))

                        (§ var BigInteger numericOPresult)
                        (§ switch (§ expr opcode))
                        (§ block
                            (§ case OP_ADD)
                            (§ block
                                (§ ass numericOPresult = numericOPnum1.add(§ pars numericOPnum2))
                                (§ break )
                            )
                            (§ case OP_SUB)
                            (§ block
                                (§ ass numericOPresult = numericOPnum1.subtract(§ pars numericOPnum2))
                                (§ break )
                            )
                            (§ case OP_BOOLAND)
                            (§ block
                                (§ if (§ expr !numericOPnum1.equals(§ pars BigInteger.ZERO) && !numericOPnum2.equals(§ pars BigInteger.ZERO)))
                                (§ block
                                    (§ ass numericOPresult = BigInteger.ONE)
                                )
                                (§ else )
                                (§ block
                                    (§ ass numericOPresult = BigInteger.ZERO)
                                )
                                (§ break )
                            )
                            (§ case OP_BOOLOR)
                            (§ block
                                (§ if (§ expr !numericOPnum1.equals(§ pars BigInteger.ZERO) || !numericOPnum2.equals(§ pars BigInteger.ZERO)))
                                (§ block
                                    (§ ass numericOPresult = BigInteger.ONE)
                                )
                                (§ else )
                                (§ block
                                    (§ ass numericOPresult = BigInteger.ZERO)
                                )
                                (§ break )
                            )
                            (§ case OP_NUMEQUAL)
                            (§ block
                                (§ if (§ expr numericOPnum1.equals(§ pars numericOPnum2)))
                                (§ block
                                    (§ ass numericOPresult = BigInteger.ONE)
                                )
                                (§ else )
                                (§ block
                                    (§ ass numericOPresult = BigInteger.ZERO)
                                )
                                (§ break )
                            )
                            (§ case OP_NUMNOTEQUAL)
                            (§ block
                                (§ if (§ expr !numericOPnum1.equals(§ pars numericOPnum2)))
                                (§ block
                                    (§ ass numericOPresult = BigInteger.ONE)
                                )
                                (§ else )
                                (§ block
                                    (§ ass numericOPresult = BigInteger.ZERO)
                                )
                                (§ break )
                            )
                            (§ case OP_LESSTHAN)
                            (§ block
                                (§ if (§ expr numericOPnum1.compareTo(§ pars numericOPnum2) < 0))
                                (§ block
                                    (§ ass numericOPresult = BigInteger.ONE)
                                )
                                (§ else )
                                (§ block
                                    (§ ass numericOPresult = BigInteger.ZERO)
                                )
                                (§ break )
                            )
                            (§ case OP_GREATERTHAN)
                            (§ block
                                (§ if (§ expr numericOPnum1.compareTo(§ pars numericOPnum2) > 0))
                                (§ block
                                    (§ ass numericOPresult = BigInteger.ONE)
                                )
                                (§ else )
                                (§ block
                                    (§ ass numericOPresult = BigInteger.ZERO)
                                )
                                (§ break )
                            )
                            (§ case OP_LESSTHANOREQUAL)
                            (§ block
                                (§ if (§ expr numericOPnum1.compareTo(§ pars numericOPnum2) <= 0))
                                (§ block
                                    (§ ass numericOPresult = BigInteger.ONE)
                                )
                                (§ else )
                                (§ block
                                    (§ ass numericOPresult = BigInteger.ZERO)
                                )
                                (§ break )
                            )
                            (§ case OP_GREATERTHANOREQUAL)
                            (§ block
                                (§ if (§ expr numericOPnum1.compareTo(§ pars numericOPnum2) >= 0))
                                (§ block
                                    (§ ass numericOPresult = BigInteger.ONE)
                                )
                                (§ else )
                                (§ block
                                    (§ ass numericOPresult = BigInteger.ZERO)
                                )
                                (§ break )
                            )
                            (§ case OP_MIN)
                            (§ block
                                (§ if (§ expr numericOPnum1.compareTo(§ pars numericOPnum2) < 0))
                                (§ block
                                    (§ ass numericOPresult = numericOPnum1)
                                )
                                (§ else )
                                (§ block
                                    (§ ass numericOPresult = numericOPnum2)
                                )
                                (§ break )
                            )
                            (§ case OP_MAX)
                            (§ block
                                (§ if (§ expr numericOPnum1.compareTo(§ pars numericOPnum2) > 0))
                                (§ block
                                    (§ ass numericOPresult = numericOPnum1)
                                )
                                (§ else )
                                (§ block
                                    (§ ass numericOPresult = numericOPnum2)
                                )
                                (§ break )
                            )
                            (§ default )
                            (§ block
                                (§ throw (§ new RuntimeException(§ pars "Opcode switched at runtime?")))
                            )
                        )

                        (§ call stack.add(§ pars Utils.reverseBytes(§ pars Utils.encodeMPI(§ pars numericOPresult, false))))
                        (§ break )
                    )
                    (§ case OP_NUMEQUALVERIFY)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 2))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_NUMEQUALVERIFY on a stack with size < 2")))
                        )
                        (§ var BigInteger OPNUMEQUALVERIFYnum2 = castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag.MINIMALDATA)))
                        (§ var BigInteger OPNUMEQUALVERIFYnum1 = castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag.MINIMALDATA)))

                        (§ if (§ expr !OPNUMEQUALVERIFYnum1.equals(§ pars OPNUMEQUALVERIFYnum2)))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_NUMEQUALVERIFY, "OP_NUMEQUALVERIFY failed")))
                        )
                        (§ break )
                    )
                    (§ case OP_WITHIN)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 3))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_WITHIN on a stack with size < 3")))
                        )
                        (§ var BigInteger OPWITHINnum3 = castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag.MINIMALDATA)))
                        (§ var BigInteger OPWITHINnum2 = castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag.MINIMALDATA)))
                        (§ var BigInteger OPWITHINnum1 = castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag.MINIMALDATA)))
                        (§ if (§ expr OPWITHINnum2.compareTo(§ pars OPWITHINnum1) <= 0 && OPWITHINnum1.compareTo(§ pars OPWITHINnum3) < 0))
                        (§ block
                            (§ call stack.add(§ pars Utils.reverseBytes(§ pars Utils.encodeMPI(§ pars BigInteger.ONE, false))))
                        )
                        (§ else )
                        (§ block
                            (§ call stack.add(§ pars Utils.reverseBytes(§ pars Utils.encodeMPI(§ pars BigInteger.ZERO, false))))
                        )
                        (§ break )
                    )
                    (§ case OP_RIPEMD160)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_RIPEMD160 on an empty stack")))
                        )
                        (§ var RIPEMD160Digest digest = new RIPEMD160Digest(§ pars ))
                        (§ var byte[] dataToHash = stack.pollLast(§ pars ))
                        (§ call digest.update(§ pars dataToHash, 0, dataToHash.length))
                        (§ var byte[] ripmemdHash = new byte[20])
                        (§ call digest.doFinal(§ pars ripmemdHash, 0))
                        (§ call stack.add(§ pars ripmemdHash))
                        (§ break )
                    )
                    (§ case OP_SHA1)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SHA1 on an empty stack")))
                        )
                        (§ try )
                        (§ block
                            (§ call stack.add(§ pars MessageDigest.getInstance(§ pars "SHA-1").digest(§ pars stack.pollLast(§ pars ))))
                        )
                        (§ catch (§ args NoSuchAlgorithmException e))
                        (§ block
                            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
                        )
                        (§ break )
                    )
                    (§ case OP_SHA256)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SHA256 on an empty stack")))
                        )
                        (§ call stack.add(§ pars Sha256Hash.hash(§ pars stack.pollLast(§ pars ))))
                        (§ break )
                    )
                    (§ case OP_HASH160)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_HASH160 on an empty stack")))
                        )
                        (§ call stack.add(§ pars Utils.sha256hash160(§ pars stack.pollLast(§ pars ))))
                        (§ break )
                    )
                    (§ case OP_HASH256)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SHA256 on an empty stack")))
                        )
                        (§ call stack.add(§ pars Sha256Hash.hashTwice(§ pars stack.pollLast(§ pars ))))
                        (§ break )
                    )
                    (§ case OP_CODESEPARATOR)
                    (§ block
                        (§ ass lastCodeSepLocation = chunk.getStartLocationInProgram(§ pars ) + 1)
                        (§ break )
                    )
                    (§ case OP_CHECKSIG)
                    (§ case OP_CHECKSIGVERIFY)
                    (§ block
                        (§ if (§ expr txContainingThis == nil))
                        (§ block
                            (§ throw (§ new IllegalStateException(§ pars "Script attempted signature check but no tx was provided")))
                        )
                        (§ call executeCheckSig(§ pars txContainingThis, (§ cast int)index, script, stack, lastCodeSepLocation, opcode, verifyFlags))
                        (§ break )
                    )
                    (§ case OP_CHECKMULTISIG)
                    (§ case OP_CHECKMULTISIGVERIFY)
                    (§ block
                        (§ if (§ expr txContainingThis == nil))
                        (§ block
                            (§ throw (§ new IllegalStateException(§ pars "Script attempted signature check but no tx was provided")))
                        )
                        (§ ass opCount = executeMultiSig(§ pars txContainingThis, (§ cast int)index, script, stack, opCount, lastCodeSepLocation, opcode, verifyFlags))
                        (§ break )
                    )
                    (§ case OP_CHECKLOCKTIMEVERIFY)
                    (§ block
                        (§ if (§ expr !verifyFlags.contains(§ pars VerifyFlag.CHECKLOCKTIMEVERIFY)))
                        (§ block
                            ;; not enabled; treat as a NOP2
                            (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag.DISCOURAGE_UPGRADABLE_NOPS)))
                            (§ block
                                (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, "Script used a reserved opcode " + opcode)))
                            )
                            (§ break )
                        )
                        (§ call executeCheckLockTimeVerify(§ pars txContainingThis, (§ cast int)index, stack, verifyFlags))
                        (§ break )
                    )
                    (§ case OP_CHECKSEQUENCEVERIFY)
                    (§ block
                        (§ if (§ expr !verifyFlags.contains(§ pars VerifyFlag.CHECKSEQUENCEVERIFY)))
                        (§ block
                            ;; not enabled; treat as a NOP3
                            (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag.DISCOURAGE_UPGRADABLE_NOPS)))
                            (§ block
                                (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, "Script used a reserved opcode " + opcode)))
                            )
                            (§ break )
                        )
                        (§ call executeCheckSequenceVerify(§ pars txContainingThis, (§ cast int)index, stack, verifyFlags))
                        (§ break )
                    )
                    (§ case OP_NOP1)
                    (§ case OP_NOP4)
                    (§ case OP_NOP5)
                    (§ case OP_NOP6)
                    (§ case OP_NOP7)
                    (§ case OP_NOP8)
                    (§ case OP_NOP9)
                    (§ case OP_NOP10)
                    (§ block
                        (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag.DISCOURAGE_UPGRADABLE_NOPS)))
                        (§ block
                            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, "Script used a reserved opcode " + opcode)))
                        )
                        (§ break )
                    )

                    (§ default )
                    (§ block
                        (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_BAD_OPCODE, "Script used a reserved or disabled opcode: " + opcode)))
                    )
                )
            )

            (§ if (§ expr MAX_STACK_SIZE < stack.size(§ pars ) + altstack.size(§ pars ) || stack.size(§ pars ) + altstack.size(§ pars ) < 0))
            (§ block
                (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_STACK_SIZE, "Stack size exceeded range")))
            )
        )

        (§ if (§ expr !ifStack.isEmpty(§ pars )))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNBALANCED_CONDITIONAL, "OP_IF/OP_NOTIF without OP_ENDIF")))
        )
    )

    ;; This is more or less a direct translation of the code in Bitcoin Core.
    #_private
    #_static
    (§ method void executeCheckLockTimeVerify(§ args Transaction txContainingThis, int index, LinkedList<byte[]> stack, Set<VerifyFlag> verifyFlags))
        (§ throws ScriptException)
    (§ block
        (§ if (§ expr stack.size(§ pars ) < 1))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKLOCKTIMEVERIFY on a stack with size < 1")))
        )

        ;; Thus as a special case we tell CScriptNum to accept up to 5-byte bignums to avoid year 2038 issue.
        #_final
        (§ var BigInteger nLockTime = castToBigInteger(§ pars stack.getLast(§ pars ), 5, verifyFlags.contains(§ pars VerifyFlag.MINIMALDATA)))

        (§ if (§ expr nLockTime.compareTo(§ pars BigInteger.ZERO) < 0))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_NEGATIVE_LOCKTIME, "Negative locktime")))
        )

        ;; There are two kinds of nLockTime, need to ensure we're comparing apples-to-apples.
        (§ if (§ expr !(§ expr (§ expr (§ expr txContainingThis.getLockTime(§ pars ) <  Transaction.LOCKTIME_THRESHOLD) && (§ expr nLockTime.compareTo(§ pars Transaction.LOCKTIME_THRESHOLD_BIG)) <  0) || (§ expr (§ expr txContainingThis.getLockTime(§ pars ) >= Transaction.LOCKTIME_THRESHOLD) && (§ expr nLockTime.compareTo(§ pars Transaction.LOCKTIME_THRESHOLD_BIG)) >= 0))))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Locktime requirement type mismatch")))
        )

        ;; Now that we know we're comparing apples-to-apples, the comparison is a simple numeric one.
        (§ if (§ expr 0 < nLockTime.compareTo(§ pars BigInteger.valueOf(§ pars txContainingThis.getLockTime(§ pars )))))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Locktime requirement not satisfied")))
        )

        ;; Finally the nLockTime feature can be disabled and thus CHECKLOCKTIMEVERIFY bypassed if every txin has been
        ;; finalized by setting nSequence to maxint.  The transaction would be allowed into the blockchain, making
        ;; the opcode ineffective.
        ;;
        ;; Testing if this vin is not final is sufficient to prevent this condition.  Alternatively we could test all
        ;; inputs, but testing just this input minimizes the data required to prove correct CHECKLOCKTIMEVERIFY execution.
        (§ if (§ expr !txContainingThis.getInput(§ pars index).hasSequence(§ pars )))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Transaction contains a final transaction input for a CHECKLOCKTIMEVERIFY script.")))
        )
    )

    #_private
    #_static
    (§ method void executeCheckSequenceVerify(§ args Transaction txContainingThis, int index, LinkedList<byte[]> stack, Set<VerifyFlag> verifyFlags))
        (§ throws ScriptException)
    (§ block
        (§ if (§ expr stack.size(§ pars ) < 1))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKSEQUENCEVERIFY on a stack with size < 1")))
        )

        ;; Note that elsewhere numeric opcodes are limited to operands in the range -2**31+1 to 2**31-1, however
        ;; it is legal for opcodes to produce results exceeding that range.  This limitation is implemented by
        ;; CScriptNum's default 4-byte limit.
        ;;
        ;; Thus as a special case we tell CScriptNum to accept up to 5-byte bignums, which are good until 2**39-1,
        ;; well beyond the 2**32-1 limit of the nSequence field itself.
        #_final
        (§ var long nSequence = castToBigInteger(§ pars stack.getLast(§ pars ), 5, verifyFlags.contains(§ pars VerifyFlag.MINIMALDATA)).longValue(§ pars ))

        ;; In the rare event that the argument may be < 0 due to some arithmetic being done first, you can always
        ;; use 0 MAX CHECKSEQUENCEVERIFY.
        (§ if (§ expr nSequence < 0))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_NEGATIVE_LOCKTIME, "Negative sequence")))
        )

        ;; To provide for future soft-fork extensibility, if the operand has the disabled lock-time flag set,
        ;; CHECKSEQUENCEVERIFY behaves as a NOP.
        (§ if (§ expr (§ expr nSequence & Transaction.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0))
        (§ block
            (§ return )
        )

        ;; Compare the specified sequence number with the input.
        (§ if (§ expr !checkSequence(§ pars nSequence, txContainingThis, index)))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Unsatisfied CHECKLOCKTIMEVERIFY lock time")))
        )
    )

    #_private
    #_static
    (§ method boolean checkSequence(§ args long nSequence, Transaction txContainingThis, int index))
    (§ block
        ;; Relative lock times are supported by comparing the passed in operand to the sequence number
        ;; of the input.
        (§ var long txToSequence = txContainingThis.getInput(§ pars index).getSequenceNumber(§ pars ))

        ;; Fail if the transaction's version number is not set high enough to trigger BIP 68 rules.
        (§ if (§ expr txContainingThis.getVersion(§ pars ) < 2))
        (§ block
            (§ return false)
        )

        ;; Sequence numbers with their most significant bit set are not consensus constrained.  Testing
        ;; that the transaction's sequence number do not have this bit set prevents using this property
        ;; to get around a CHECKSEQUENCEVERIFY check.
        (§ if (§ expr (§ expr txToSequence & Transaction.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0))
        (§ block
            (§ return false)
        )

        ;; Mask off any bits that do not have consensus-enforced meaning before doing the integer comparisons.
        (§ var long nLockTimeMask =  Transaction.SEQUENCE_LOCKTIME_TYPE_FLAG | Transaction.SEQUENCE_LOCKTIME_MASK)
        (§ var long txToSequenceMasked = txToSequence & nLockTimeMask)
        (§ var long nSequenceMasked = nSequence & nLockTimeMask)

        ;; There are two kinds of nSequence: lock-by-blockheight and lock-by-blocktime, distinguished by
        ;; whether nSequenceMasked < CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.
        ;;
        ;; We want to compare apples to apples, so fail the script unless the type of nSequenceMasked
        ;; being tested is the same as the nSequenceMasked in the transaction.
        (§ if (§ expr !(§ expr (§ expr txToSequenceMasked <  Transaction.SEQUENCE_LOCKTIME_TYPE_FLAG && nSequenceMasked <  Transaction.SEQUENCE_LOCKTIME_TYPE_FLAG) || (§ expr txToSequenceMasked >= Transaction.SEQUENCE_LOCKTIME_TYPE_FLAG && nSequenceMasked >= Transaction.SEQUENCE_LOCKTIME_TYPE_FLAG))))
        (§ block
            (§ return false)
        )

        ;; Now that we know we're comparing apples-to-apples, the comparison is a simple numeric one.
        (§ if (§ expr txToSequenceMasked < nSequenceMasked))
        (§ block
            (§ return false)
        )

        (§ return true)
    )

    #_private
    #_static
    (§ method void executeCheckSig(§ args Transaction txContainingThis, int index, Script script, LinkedList<byte[]> stack, int lastCodeSepLocation, int opcode, Set<VerifyFlag> verifyFlags))
        (§ throws ScriptException)
    (§ block
        #_final
        (§ var boolean requireCanonical = verifyFlags.contains(§ pars VerifyFlag.STRICTENC) || verifyFlags.contains(§ pars VerifyFlag.DERSIG) || verifyFlags.contains(§ pars VerifyFlag.LOW_S))
        (§ if (§ expr stack.size(§ pars ) < 2))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKSIG(VERIFY) on a stack with size < 2")))
        )

        (§ var byte[] pubKey = stack.pollLast(§ pars ))
        (§ var byte[] sigBytes = stack.pollLast(§ pars ))

        (§ var byte[] prog = script.getProgram(§ pars ))
        (§ var byte[] connectedScript = Arrays.copyOfRange(§ pars prog, lastCodeSepLocation, prog.length))

        (§ var UnsafeByteArrayOutputStream outStream = new UnsafeByteArrayOutputStream(§ pars sigBytes.length + 1))
        (§ try )
        (§ block
            (§ call writeBytes(§ pars outStream, sigBytes))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
        (§ ass connectedScript = removeAllInstancesOf(§ pars connectedScript, outStream.toByteArray(§ pars )))

        ;; TODO: Use int for indexes everywhere, we can't have that many inputs/outputs.
        (§ var boolean sigValid = false)
        (§ try )
        (§ block
            (§ var TransactionSignature sig = TransactionSignature.decodeFromBitcoin(§ pars sigBytes, requireCanonical, verifyFlags.contains(§ pars VerifyFlag.LOW_S)))

            ;; TODO: Should check hash type is known.
            (§ var Sha256Hash hash = txContainingThis.hashForSignature(§ pars index, connectedScript, (§ cast byte)sig.sighashFlags))
            (§ ass sigValid = ECKey.verify(§ pars hash.getBytes(§ pars ), sig, pubKey))
        )
        (§ catch (§ args Exception e))
        (§ block
            ;; There is (at least) one exception that could be hit here (EOFException, if the sig is too short).
            ;; Because I can't verify there aren't more, we use a very generic Exception catch.

            ;; This RuntimeException occurs when signing as we run partial/invalid scripts to see if they need more
            ;; signing work to be done inside LocalTransactionSigner.signInputs.
            (§ if (§ expr !e.getMessage(§ pars ).contains(§ pars "Reached past end of ASN.1 stream")))
            (§ block
                (§ call log.warn(§ pars "Signature checking failed!", e))
            )
        )

        (§ if (§ expr opcode == OP_CHECKSIG))
        (§ block
            (§ call stack.add(§ pars sigValid ? new byte[] (§ coll 1 ) :else new byte[] (§ coll )))
        )
        (§ elseif (§ expr opcode == OP_CHECKSIGVERIFY && !sigValid))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_CHECKSIGVERIFY, "Script failed OP_CHECKSIGVERIFY")))
        )
    )

    #_private
    #_static
    (§ method int executeMultiSig(§ args Transaction txContainingThis, int index, Script script, LinkedList<byte[]> stack, int opCount, int lastCodeSepLocation, int opcode, Set<VerifyFlag> verifyFlags))
        (§ throws ScriptException)
    (§ block
        #_final
        (§ var boolean requireCanonical = verifyFlags.contains(§ pars VerifyFlag.STRICTENC) || verifyFlags.contains(§ pars VerifyFlag.DERSIG) || verifyFlags.contains(§ pars VerifyFlag.LOW_S))
        (§ if (§ expr stack.size(§ pars ) < 1))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size < 2")))
        )

        (§ var int pubKeyCount = castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag.MINIMALDATA)).intValue(§ pars ))
        (§ if (§ expr pubKeyCount < 0 || MAX_PUBKEYS_PER_MULTISIG < pubKeyCount))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_PUBKEY_COUNT, "OP_CHECKMULTISIG(VERIFY) with pubkey count out of range")))
        )

        (§ ass opCount = opCount + pubKeyCount)
        (§ if (§ expr MAX_OPS_PER_SCRIPT < opCount))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_OP_COUNT, "Total op count > 201 during OP_CHECKMULTISIG(VERIFY)")))
        )
        (§ if (§ expr stack.size(§ pars ) < pubKeyCount + 1))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size < num_of_pubkeys + 2")))
        )

        (§ var LinkedList<byte[]> pubkeys = new LinkedList<>(§ pars ))
        (§ for (§ var int i = 0) :for (§ expr i < pubKeyCount) :for (§ ass i = i + 1))
        (§ block
            (§ call pubkeys.add(§ pars stack.pollLast(§ pars )))
        )

        (§ var int sigCount = castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag.MINIMALDATA)).intValue(§ pars ))
        (§ if (§ expr sigCount < 0 || pubKeyCount < sigCount))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_SIG_COUNT, "OP_CHECKMULTISIG(VERIFY) with sig count out of range")))
        )
        (§ if (§ expr stack.size(§ pars ) < sigCount + 1))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size < num_of_pubkeys + num_of_signatures + 3")))
        )

        (§ var LinkedList<byte[]> sigs = new LinkedList<>(§ pars ))
        (§ for (§ var int i = 0) :for (§ expr i < sigCount) :for (§ ass i = i + 1))
        (§ block
            (§ call sigs.add(§ pars stack.pollLast(§ pars )))
        )

        (§ var byte[] prog = script.getProgram(§ pars ))
        (§ var byte[] connectedScript = Arrays.copyOfRange(§ pars prog, lastCodeSepLocation, prog.length))

        (§ for (§ var byte[] sig) :for (§ expr sigs))
        (§ block
            (§ var UnsafeByteArrayOutputStream outStream = new UnsafeByteArrayOutputStream(§ pars sig.length + 1))
            (§ try )
            (§ block
                (§ call writeBytes(§ pars outStream, sig))
            )
            (§ catch (§ args IOException e))
            (§ block
                (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
            )
            (§ ass connectedScript = removeAllInstancesOf(§ pars connectedScript, outStream.toByteArray(§ pars )))
        )

        (§ var boolean valid = true)
        (§ while (§ expr 0 < sigs.size(§ pars )))
        (§ block
            (§ var byte[] pubKey = pubkeys.pollFirst(§ pars ))
            ;; We could reasonably move this out of the loop, but because signature verification is significantly
            ;; more expensive than hashing, its not a big deal.
            (§ try )
            (§ block
                (§ var TransactionSignature sig = TransactionSignature.decodeFromBitcoin(§ pars sigs.getFirst(§ pars ), requireCanonical))
                (§ var Sha256Hash hash = txContainingThis.hashForSignature(§ pars index, connectedScript, (§ cast byte)sig.sighashFlags))
                (§ if (§ expr ECKey.verify(§ pars hash.getBytes(§ pars ), sig, pubKey)))
                (§ block
                    (§ call sigs.pollFirst(§ pars ))
                )
            )
            (§ catch (§ args Exception _))
            (§ block
                ;; There is (at least) one exception that could be hit here (EOFException, if the sig is too short).
                ;; Because I can't verify there aren't more, we use a very generic Exception catch.
            )

            (§ if (§ expr pubkeys.size(§ pars ) < sigs.size(§ pars )))
            (§ block
                (§ ass valid = false)
                (§ break )
            )
        )

        ;; We uselessly remove a stack object to emulate a Bitcoin Core bug.
        (§ var byte[] nullDummy = stack.pollLast(§ pars ))
        (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag.NULLDUMMY) && 0 < nullDummy.length))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_SIG_NULLFAIL, "OP_CHECKMULTISIG(VERIFY) with non-null nulldummy: " + Arrays.toString(§ pars nullDummy))))
        )

        (§ if (§ expr opcode == OP_CHECKMULTISIG))
        (§ block
            (§ call stack.add(§ pars valid ? new byte[] (§ coll 1 ) :else new byte[] (§ coll )))
        )
        (§ elseif (§ expr opcode == OP_CHECKMULTISIGVERIFY && !valid))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_SIG_NULLFAIL, "Script failed OP_CHECKMULTISIGVERIFY")))
        )

        (§ return opCount)
    )

    ;;;
     ; Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey, enabling all validation rules.
     ; @param txContainingThis The transaction in which this input scriptSig resides.
     ;                         Accessing txContainingThis from another thread while this method runs results in undefined behavior.
     ; @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
     ; @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
     ; @deprecated Use {@link #correctlySpends(org.bitcoinj.core.Transaction, long, org.bitcoinj.script.Script, java.util.Set)}
     ; instead so that verification flags do not change as new verification options are added.
     ;;
    #_deprecated
    #_public
    (§ method void correctlySpends(§ args Transaction txContainingThis, long scriptSigIndex, Script scriptPubKey))
        (§ throws ScriptException)
    (§ block
        (§ call correctlySpends(§ pars txContainingThis, scriptSigIndex, scriptPubKey, ALL_VERIFY_FLAGS))
    )

    ;;;
     ; Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey.
     ; @param txContainingThis The transaction in which this input scriptSig resides.
     ;                         Accessing txContainingThis from another thread while this method runs results in undefined behavior.
     ; @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
     ; @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
     ; @param verifyFlags Each flag enables one validation rule.  If in doubt, use {@link #correctlySpends(Transaction, long, Script)}
     ;                    which sets all flags.
     ;;
    #_public
    (§ method void correctlySpends(§ args Transaction txContainingThis, long scriptSigIndex, Script scriptPubKey, Set<VerifyFlag> verifyFlags))
        (§ throws ScriptException)
    (§ block
        ;; Clone the transaction because executing the script involves editing it, and if we die, we'll leave
        ;; the tx half broken (also it's not so thread safe to work on it directly).
        (§ try )
        (§ block
            (§ ass txContainingThis = txContainingThis.getParams(§ pars ).getDefaultSerializer(§ pars ).makeTransaction(§ pars txContainingThis.bitcoinSerialize(§ pars )))
        )
        (§ catch (§ args ProtocolException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Should not happen unless we were given a totally broken transaction.
        )

        (§ if (§ expr MAX_SCRIPT_SIZE < getProgram(§ pars ).length || MAX_SCRIPT_SIZE < scriptPubKey.getProgram(§ pars ).length))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_SCRIPT_SIZE, "Script larger than 10,000 bytes")))
        )

        (§ var LinkedList<byte[]> stack = new LinkedList<>(§ pars ))
        (§ var LinkedList<byte[]> p2shStack = nil)

        (§ call executeScript(§ pars txContainingThis, scriptSigIndex, this, stack, verifyFlags))
        (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag.P2SH)))
        (§ block
            (§ ass p2shStack = new LinkedList<>(§ pars stack))
        )
        (§ call executeScript(§ pars txContainingThis, scriptSigIndex, scriptPubKey, stack, verifyFlags))

        (§ if (§ expr stack.size(§ pars ) == 0))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_EVAL_FALSE, "Stack empty at end of script execution.")))
        )

        (§ if (§ expr !castToBool(§ pars stack.pollLast(§ pars ))))
        (§ block
            (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_EVAL_FALSE, "Script resulted in a non-true stack: " + stack)))
        )

        ;; P2SH is pay to script hash.  It means that the scriptPubKey has a special form which is a valid
        ;; program but it has "useless" form that if evaluated as a normal program always returns true.
        ;; Instead, miners recognize it as special based on its template - it provides a hash of the real scriptPubKey
        ;; and that must be provided by the input.  The goal of this bizarre arrangement is twofold:
        ;;
        ;; (1) You can sum up a large, complex script (like a CHECKMULTISIG script) with an address that's the same
        ;;     size as a regular address.  This means it doesn't overload scannable QR codes/NFC tags or become
        ;;     un-wieldy to copy/paste.
        ;; (2) It allows the working set to be smaller: nodes perform best when they can store as many unspent outputs
        ;;     in RAM as possible, so if the outputs are made smaller and the inputs get bigger, then it's better for
        ;;     overall scalability and performance.

        ;; TODO: Check if we can take out enforceP2SH if there's a checkpoint at the enforcement block.
        (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag.P2SH) && scriptPubKey.isPayToScriptHash(§ pars )))
        (§ block
            (§ for (§ var ScriptChunk chunk) :for (§ expr chunks))
            (§ block
                (§ if (§ expr chunk.isOpCode(§ pars ) && OP_16 < chunk.opcode))
                (§ block
                    (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_SIG_PUSHONLY, "Attempted to spend a P2SH scriptPubKey with a script that contained script ops")))
                )
            )

            (§ var byte[] scriptPubKeyBytes = p2shStack.pollLast(§ pars ))
            (§ var Script scriptPubKeyP2SH = new Script(§ pars scriptPubKeyBytes))

            (§ call executeScript(§ pars txContainingThis, scriptSigIndex, scriptPubKeyP2SH, p2shStack, verifyFlags))

            (§ if (§ expr p2shStack.size(§ pars ) == 0))
            (§ block
                (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_EVAL_FALSE, "P2SH stack empty at end of script execution.")))
            )

            (§ if (§ expr !castToBool(§ pars p2shStack.pollLast(§ pars ))))
            (§ block
                (§ throw (§ new ScriptException(§ pars ScriptError.SCRIPT_ERR_EVAL_FALSE, "P2SH script execution resulted in a non-true stack")))
            )
        )
    )

    ;; Utility that doesn't copy for internal use.
    #_private
    (§ method byte[] getQuickProgram(§ args ))
    (§ block
        (§ return (§ quest (§ expr program != nil) ? program :else getProgram(§ pars )))
    )

    ;;;
     ; Get the {@link org.bitcoinj.script.Script.ScriptType}.
     ; @return The script type.
     ;;
    #_public
    (§ method ScriptType getScriptType(§ args ))
    (§ block
        (§ if (§ expr isSentToAddress(§ pars )))
        (§ block
            (§ return ScriptType.P2PKH)
        )
        (§ if (§ expr isSentToRawPubKey(§ pars )))
        (§ block
            (§ return ScriptType.PUB_KEY)
        )
        (§ if (§ expr isPayToScriptHash(§ pars )))
        (§ block
            (§ return ScriptType.P2SH)
        )

        (§ return ScriptType.NO_TYPE)
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return Arrays.equals(§ pars getQuickProgram(§ pars ), (§ expr (§ cast Script)o).getQuickProgram(§ pars )))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Arrays.hashCode(§ pars getQuickProgram(§ pars )))
    )
)

#_(ns org.bitcoinj.script #_"ScriptBuilder"
    (:import [java.math BigInteger]
             [java.util ArrayList Arrays Collections List Stack])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists])
   (:require [org.bitcoinj.core Address ECKey Utils]
             [org.bitcoinj.crypto TransactionSignature]
             #_static [org.bitcoinj.script.ScriptOpCodes *]))

;;;
 ; <p>Tools for the construction of commonly used script types.  You don't normally need this as it's hidden
 ; behind convenience methods on {@link org.bitcoinj.core.Transaction}, but they are useful when working with
 ; the protocol at a lower level.</p>
 ;;
#_public
(§ class ScriptBuilder
    #_private
    (§ field List<ScriptChunk> chunks)

    ;;; Creates a fresh ScriptBuilder with an empty program. ;;
    #_public
    (§ constructor ScriptBuilder(§ args ))
    (§ block
        (§ ass chunks = Lists.newLinkedList(§ pars ))
    )

    ;;; Creates a fresh ScriptBuilder with the given program as the starting point. ;;
    #_public
    (§ constructor ScriptBuilder(§ args Script template))
    (§ block
        (§ ass chunks = new ArrayList<>(§ pars template.getChunks(§ pars )))
    )

    ;;; Adds the given chunk to the end of the program. ;;
    #_public
    (§ method ScriptBuilder addChunk(§ args ScriptChunk chunk))
    (§ block
        (§ return addChunk(§ pars chunks.size(§ pars ), chunk))
    )

    ;;; Adds the given chunk at the given index in the program. ;;
    #_public
    (§ method ScriptBuilder addChunk(§ args int index, ScriptChunk chunk))
    (§ block
        (§ call chunks.add(§ pars index, chunk))
        (§ return this)
    )

    ;;; Adds the given opcode to the end of the program. ;;
    #_public
    (§ method ScriptBuilder op(§ args int opcode))
    (§ block
        (§ return op(§ pars chunks.size(§ pars ), opcode))
    )

    ;;; Adds the given opcode to the given index in the program. ;;
    #_public
    (§ method ScriptBuilder op(§ args int index, int opcode))
    (§ block
        (§ call Preconditions.checkArgument(§ pars OP_PUSHDATA4 < opcode))
        (§ return addChunk(§ pars index, new ScriptChunk(§ pars opcode, nil)))
    )

    ;;; Adds a copy of the given byte array as a data element (i.e. PUSHDATA) at the end of the program. ;;
    #_public
    (§ method ScriptBuilder data(§ args byte[] data))
    (§ block
        (§ return (§ quest (§ expr data.length == 0) ? smallNum(§ pars 0) :else data(§ pars chunks.size(§ pars ), data)))
    )

    ;;; Adds a copy of the given byte array as a data element (i.e. PUSHDATA) at the given index in the program. ;;
    #_public
    (§ method ScriptBuilder data(§ args int index, byte[] data))
    (§ block
        ;; implements BIP62
        (§ var byte[] copy = Arrays.copyOf(§ pars data, data.length))
        (§ var int opcode)
        (§ if (§ expr data.length == 0))
        (§ block
            (§ ass opcode = OP_0)
        )
        (§ elseif (§ expr data.length == 1))
        (§ block
            (§ var byte b = data[0])
            (§ if (§ expr 1 <= b && b <= 16))
            (§ block
                (§ ass opcode = Script.encodeToOpN(§ pars b))
            )
            (§ else )
            (§ block
                (§ ass opcode = 1)
            )
        )
        (§ elseif (§ expr data.length < OP_PUSHDATA1))
        (§ block
            (§ ass opcode = data.length)
        )
        (§ elseif (§ expr data.length < 256))
        (§ block
            (§ ass opcode = OP_PUSHDATA1)
        )
        (§ elseif (§ expr data.length < 65536))
        (§ block
            (§ ass opcode = OP_PUSHDATA2)
        )
        (§ else )
        (§ block
            (§ throw (§ new RuntimeException(§ pars "Unimplemented")))
        )
        (§ return addChunk(§ pars index, new ScriptChunk(§ pars opcode, copy)))
    )

    ;;;
     ; Adds the given number to the end of the program.
     ; Automatically uses shortest encoding possible.
     ;;
    #_public
    (§ method ScriptBuilder number(§ args long num))
    (§ block
        (§ return (§ quest (§ expr 0 <= num && num <= 16) ? smallNum(§ pars (§ cast int)num) :else bigNum(§ pars num)))
    )

    ;;;
     ; Adds the given number to the given index in the program.
     ; Automatically uses shortest encoding possible.
     ;;
    #_public
    (§ method ScriptBuilder number(§ args int index, long num))
    (§ block
        (§ return (§ quest (§ expr 0 <= num && num <= 16) ? smallNum(§ pars index, (§ cast int)num) :else bigNum(§ pars index, num)))
    )

    ;;;
     ; Adds the given number as a OP_N opcode to the end of the program.
     ; Only handles values 0-16 inclusive.
     ;
     ; @see #number(int)
     ;;
    #_public
    (§ method ScriptBuilder smallNum(§ args int num))
    (§ block
        (§ return smallNum(§ pars chunks.size(§ pars ), num))
    )

    ;;; Adds the given number as a push data chunk.
     ; This is intended to use for negative numbers or values > 16, and although
     ; it will accept numbers in the range 0-16 inclusive, the encoding would be
     ; considered non-standard.
     ;
     ; @see #number(int)
     ;;
    #_protected
    (§ method ScriptBuilder bigNum(§ args long num))
    (§ block
        (§ return bigNum(§ pars chunks.size(§ pars ), num))
    )

    ;;;
     ; Adds the given number as a OP_N opcode to the given index in the program.
     ; Only handles values 0-16 inclusive.
     ;
     ; @see #number(int)
     ;;
    #_public
    (§ method ScriptBuilder smallNum(§ args int index, int num))
    (§ block
        (§ call Preconditions.checkArgument(§ pars 0 <= num, "Cannot encode negative numbers with smallNum"))
        (§ call Preconditions.checkArgument(§ pars num <= 16, "Cannot encode numbers larger than 16 with smallNum"))

        (§ return addChunk(§ pars index, new ScriptChunk(§ pars Script.encodeToOpN(§ pars num), nil)))
    )

    ;;;
     ; Adds the given number as a push data chunk to the given index in the program.
     ; This is intended to use for negative numbers or values > 16, and although
     ; it will accept numbers in the range 0-16 inclusive, the encoding would be
     ; considered non-standard.
     ;
     ; @see #number(int)
     ;;
    #_protected
    (§ method ScriptBuilder bigNum(§ args int index, long num))
    (§ block
        #_final
        (§ var byte[] data)

        (§ if (§ expr num == 0))
        (§ block
            (§ ass data = new byte[0])
        )
        (§ else )
        (§ block
            (§ var Stack<Byte> result = new Stack<>(§ pars ))
            #_final
            (§ var boolean neg = num < 0)
            (§ var long absvalue = Math.abs(§ pars num))

            (§ while (§ expr absvalue != 0))
            (§ block
                (§ call result.push(§ pars (§ cast byte)(§ expr absvalue & 0xff)))
                (§ ass absvalue = absvalue >> 8)
            )

            (§ if (§ expr (§ expr result.peek(§ pars ) & 0x80) != 0))
            (§ block
                ;; The most significant byte is >= 0x80, so push an extra byte that
                ;; contains just the sign of the value.
                (§ call result.push(§ pars (§ cast byte)(§ quest neg ? 0x80 :else 0)))
            )
            (§ elseif (§ expr neg))
            (§ block
                ;; The most significant byte is < 0x80 and the value is negative,
                ;; set the sign bit so it is subtracted and interpreted as a
                ;; negative when converting back to an integral.
                (§ call result.push(§ pars (§ cast byte)(§ expr result.pop(§ pars ) | 0x80)))
            )

            (§ ass data = new byte[result.size(§ pars )])
            (§ for (§ var int byteIdx = 0) :for (§ expr byteIdx < data.length) :for (§ ass byteIdx = byteIdx + 1))
            (§ block
                (§ ass data[byteIdx] = result.get(§ pars byteIdx))
            )
        )

        ;; At most the encoded value could take up to 8 bytes, so we don't need
        ;; to use OP_PUSHDATA opcodes.
        (§ return addChunk(§ pars index, new ScriptChunk(§ pars data.length, data)))
    )

    ;;; Creates a new immutable Script based on the state of the builder. ;;
    #_public
    (§ method Script build(§ args ))
    (§ block
        (§ return (§ new Script(§ pars chunks)))
    )

    ;;; Creates a scriptPubKey that encodes payment to the given address. ;;
    #_public
    #_static
    (§ method Script createOutputScript(§ args Address to))
    (§ block
        (§ if (§ expr to.isP2SHAddress(§ pars )))
        (§ block
            ;; OP_HASH160 <scriptHash> OP_EQUAL
            (§ return (§ new ScriptBuilder(§ pars )).op(§ pars OP_HASH160).data(§ pars to.getHash160(§ pars )).op(§ pars OP_EQUAL).build(§ pars ))
        )
        (§ else )
        (§ block
            ;; OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
            (§ return (§ new ScriptBuilder(§ pars )).op(§ pars OP_DUP).op(§ pars OP_HASH160).data(§ pars to.getHash160(§ pars )).op(§ pars OP_EQUALVERIFY).op(§ pars OP_CHECKSIG).build(§ pars ))
        )
    )

    ;;; Creates a scriptPubKey that encodes payment to the given raw public key. ;;
    #_public
    #_static
    (§ method Script createOutputScript(§ args ECKey key))
    (§ block
        (§ return (§ new ScriptBuilder(§ pars )).data(§ pars key.getPubKey(§ pars )).op(§ pars OP_CHECKSIG).build(§ pars ))
    )

    ;;;
     ; Creates a scriptSig that can redeem a pay-to-address output.
     ; If given signature is null, incomplete scriptSig will be created with OP_0 instead of signature.
     ;;
    #_public
    #_static
    (§ method Script createInputScript(§ args #_nilable TransactionSignature signature, ECKey pubKey))
    (§ block
        (§ var byte[] pubkeyBytes = pubKey.getPubKey(§ pars ))
        (§ var byte[] sigBytes = (§ quest (§ expr signature != nil) ? signature.encodeToBitcoin(§ pars ) :else new byte[] (§ coll )))
        (§ return (§ new ScriptBuilder(§ pars )).data(§ pars sigBytes).data(§ pars pubkeyBytes).build(§ pars ))
    )

    ;;;
     ; Creates a scriptSig that can redeem a pay-to-pubkey output.
     ; If given signature is null, incomplete scriptSig will be created with OP_0 instead of signature.
     ;;
    #_public
    #_static
    (§ method Script createInputScript(§ args #_nilable TransactionSignature signature))
    (§ block
        (§ var byte[] sigBytes = (§ quest (§ expr signature != nil) ? signature.encodeToBitcoin(§ pars ) :else new byte[] (§ coll )))
        (§ return (§ new ScriptBuilder(§ pars )).data(§ pars sigBytes).build(§ pars ))
    )

    ;;; Creates a program that requires at least N of the given keys to sign, using OP_CHECKMULTISIG. ;;
    #_public
    #_static
    (§ method Script createMultiSigOutputScript(§ args int threshold, List<ECKey> pubkeys))
    (§ block
        (§ call Preconditions.checkArgument(§ pars 0 < threshold))
        (§ call Preconditions.checkArgument(§ pars threshold <= pubkeys.size(§ pars )))
        (§ call Preconditions.checkArgument(§ pars pubkeys.size(§ pars ) <= 16)) ;; That's the max we can represent with a single opcode.

        (§ var ScriptBuilder builder = new ScriptBuilder(§ pars ))
        (§ call builder.smallNum(§ pars threshold))
        (§ for (§ var ECKey key) :for (§ expr pubkeys))
        (§ block
            (§ call builder.data(§ pars key.getPubKey(§ pars )))
        )
        (§ call builder.smallNum(§ pars pubkeys.size(§ pars )))
        (§ call builder.op(§ pars OP_CHECKMULTISIG))
        (§ return builder.build(§ pars ))
    )

    ;;; Create a program that satisfies an OP_CHECKMULTISIG program. ;;
    #_public
    #_static
    (§ method Script createMultiSigInputScript(§ args List<TransactionSignature> signatures))
    (§ block
        (§ var List<byte[]> sigs = new ArrayList<>(§ pars signatures.size(§ pars )))
        (§ for (§ var TransactionSignature signature) :for (§ expr signatures))
        (§ block
            (§ call sigs.add(§ pars signature.encodeToBitcoin(§ pars )))
        )

        (§ return createMultiSigInputScriptBytes(§ pars sigs, nil))
    )

    ;;; Create a program that satisfies an OP_CHECKMULTISIG program. ;;
    #_public
    #_static
    (§ method Script createMultiSigInputScript(§ args TransactionSignature... signatures))
    (§ block
        (§ return createMultiSigInputScript(§ pars Arrays.asList(§ pars signatures)))
    )

    ;;; Create a program that satisfies an OP_CHECKMULTISIG program, using pre-encoded signatures. ;;
    #_public
    #_static
    (§ method Script createMultiSigInputScriptBytes(§ args List<byte[]> signatures))
    (§ block
        (§ return createMultiSigInputScriptBytes(§ pars signatures, nil))
    )

    ;;;
     ; Create a program that satisfies a pay-to-script hashed OP_CHECKMULTISIG program.
     ; If given signature list is null, incomplete scriptSig will be created with OP_0 instead of signatures.
     ;;
    #_public
    #_static
    (§ method Script createP2SHMultiSigInputScript(§ args #_nilable List<TransactionSignature> signatures, Script multisigProgram))
    (§ block
        (§ var List<byte[]> sigs = new ArrayList<>(§ pars ))
        (§ if (§ expr signatures == nil))
        (§ block
            ;; Create correct number of empty signatures.
            (§ var int numSigs = multisigProgram.getNumberOfSignaturesRequiredToSpend(§ pars ))
            (§ for (§ var int i = 0) :for (§ expr i < numSigs) :for (§ ass i = i + 1))
            (§ block
                (§ call sigs.add(§ pars new byte[] (§ coll )))
            )
        )
        (§ else )
        (§ block
            (§ for (§ var TransactionSignature signature) :for (§ expr signatures))
            (§ block
                (§ call sigs.add(§ pars signature.encodeToBitcoin(§ pars )))
            )
        )
        (§ return createMultiSigInputScriptBytes(§ pars sigs, multisigProgram.getProgram(§ pars )))
    )

    ;;;
     ; Create a program that satisfies an OP_CHECKMULTISIG program, using pre-encoded signatures.
     ; Optionally, appends the script program bytes if spending a P2SH output.
     ;;
    #_public
    #_static
    (§ method Script createMultiSigInputScriptBytes(§ args List<byte[]> signatures, #_nilable byte[] multisigProgramBytes))
    (§ block
        (§ call Preconditions.checkArgument(§ pars signatures.size(§ pars ) <= 16))

        (§ var ScriptBuilder builder = new ScriptBuilder(§ pars ))
        (§ call builder.smallNum(§ pars 0)) ;; Work around a bug in CHECKMULTISIG that is now a required part of the protocol.
        (§ for (§ var byte[] signature) :for (§ expr signatures))
        (§ block
            (§ call builder.data(§ pars signature))
        )
        (§ if (§ expr multisigProgramBytes!= nil))
        (§ block
            (§ call builder.data(§ pars multisigProgramBytes))
        )
        (§ return builder.build(§ pars ))
    )

    ;;;
     ; Returns a copy of the given scriptSig with the signature inserted in the given position.
     ;
     ; This function assumes that any missing sigs have OP_0 placeholders.  If given scriptSig
     ; already has all the signatures in place, IllegalArgumentException will be thrown.
     ;
     ; @param targetIndex Where to insert the signature.
     ; @param sigsPrefixCount How many items to copy verbatim (e.g. initial OP_0 for multisig).
     ; @param sigsSuffixCount How many items to copy verbatim at end (e.g. redeemScript for P2SH).
     ;;
    #_public
    #_static
    (§ method Script updateScriptWithSignature(§ args Script scriptSig, byte[] signature, int targetIndex, int sigsPrefixCount, int sigsSuffixCount))
    (§ block
        (§ var List<ScriptChunk> inputChunks = scriptSig.getChunks(§ pars ))
        (§ var int totalChunks = inputChunks.size(§ pars ))

        ;; Check if we have a place to insert, otherwise just return given scriptSig unchanged.
        ;; We assume here that OP_0 placeholders always go after the sigs, so
        ;; to find if we have sigs missing, we can just check the chunk in latest sig position.
        (§ var boolean hasMissingSigs = inputChunks.get(§ pars totalChunks - sigsSuffixCount - 1).equalsOpCode(§ pars OP_0))
        (§ call Preconditions.checkArgument(§ pars hasMissingSigs, "ScriptSig is already filled with signatures"))

        ;; copy the prefix
        (§ var ScriptBuilder builder = new ScriptBuilder(§ pars ))
        (§ for (§ var ScriptChunk chunk) :for (§ expr inputChunks.subList(§ pars 0, sigsPrefixCount)))
        (§ block
            (§ call builder.addChunk(§ pars chunk))
        )

        ;; Copy the sigs.
        (§ var int pos = 0)
        (§ var boolean inserted = false)
        (§ for (§ var ScriptChunk chunk) :for (§ expr inputChunks.subList(§ pars sigsPrefixCount, totalChunks - sigsSuffixCount)))
        (§ block
            (§ if (§ expr pos == targetIndex))
            (§ block
                (§ ass inserted = true)
                (§ call builder.data(§ pars signature))
                (§ ass pos = pos + 1)
            )
            (§ if (§ expr !chunk.equalsOpCode(§ pars OP_0)))
            (§ block
                (§ call builder.addChunk(§ pars chunk))
                (§ ass pos = pos + 1)
            )
        )

        ;; Add OP_0's if needed, since we skipped them in the previous loop.
        (§ while (§ expr pos < totalChunks - sigsPrefixCount - sigsSuffixCount))
        (§ block
            (§ if (§ expr pos == targetIndex))
            (§ block
                (§ ass inserted = true)
                (§ call builder.data(§ pars signature))
            )
            (§ else )
            (§ block
                (§ call builder.addChunk(§ pars (§ new ScriptChunk(§ pars OP_0, nil))))
            )
            (§ ass pos = pos + 1)
        )

        ;; Copy the suffix.
        (§ for (§ var ScriptChunk chunk) :for (§ expr inputChunks.subList(§ pars totalChunks - sigsSuffixCount, totalChunks)))
        (§ block
            (§ call builder.addChunk(§ pars chunk))
        )

        (§ call Preconditions.checkState(§ pars inserted))
        (§ return builder.build(§ pars ))
    )

    ;;;
     ; Creates a scriptPubKey that sends to the given script hash.  Read
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP 16</a>
     ; to learn more about this kind of script.
     ;;
    #_public
    #_static
    (§ method Script createP2SHOutputScript(§ args byte[] hash))
    (§ block
        (§ call Preconditions.checkArgument(§ pars hash.length == 20))

        (§ return (§ new ScriptBuilder(§ pars )).op(§ pars OP_HASH160).data(§ pars hash).op(§ pars OP_EQUAL).build(§ pars ))
    )

    ;;;
     ; Creates a scriptPubKey for the given redeem script.
     ;;
    #_public
    #_static
    (§ method Script createP2SHOutputScript(§ args Script redeemScript))
    (§ block
        (§ var byte[] hash = Utils.sha256hash160(§ pars redeemScript.getProgram(§ pars )))
        (§ return ScriptBuilder.createP2SHOutputScript(§ pars hash))
    )

    ;;;
     ; Creates a P2SH output script with given public keys and threshold.
     ; Given public keys will be placed in redeem script in the lexicographical sorting order.
     ;;
    #_public
    #_static
    (§ method Script createP2SHOutputScript(§ args int threshold, List<ECKey> pubkeys))
    (§ block
        (§ var Script redeemScript = createRedeemScript(§ pars threshold, pubkeys))
        (§ return createP2SHOutputScript(§ pars redeemScript))
    )

    ;;;
     ; Creates redeem script with given public keys and threshold.
     ; Given public keys will be placed in redeem script in the lexicographical sorting order.
     ;;
    #_public
    #_static
    (§ method Script createRedeemScript(§ args int threshold, List<ECKey> pubkeys))
    (§ block
        (§ ass pubkeys = new ArrayList<>(§ pars pubkeys))
        (§ call Collections.sort(§ pars pubkeys, ECKey.PUBKEY_COMPARATOR))
        (§ return ScriptBuilder.createMultiSigOutputScript(§ pars threshold, pubkeys))
    )

    ;;;
     ; Creates a script of the form OP_RETURN [data].  This feature allows you to attach
     ; a small piece of data (like a hash of something stored elsewhere) to a zero valued
     ; output which can never be spent and thus does not pollute the ledger.
     ;;
    #_public
    #_static
    (§ method Script createOpReturnScript(§ args byte[] data))
    (§ block
        (§ call Preconditions.checkArgument(§ pars data.length <= 80))

        (§ return (§ new ScriptBuilder(§ pars )).op(§ pars OP_RETURN).data(§ pars data).build(§ pars ))
    )

    #_public
    #_static
    (§ method Script createCLTVPaymentChannelOutput(§ args BigInteger time, ECKey from, ECKey to))
    (§ block
        (§ var byte[] timeBytes = Utils.reverseBytes(§ pars Utils.encodeMPI(§ pars time, false)))
        (§ if (§ expr 5 < timeBytes.length))
        (§ block
            (§ throw (§ new RuntimeException(§ pars "Time too large to encode as 5-byte int")))
        )

        (§ return (§ new ScriptBuilder(§ pars )).op(§ pars OP_IF).data(§ pars to.getPubKey(§ pars )).op(§ pars OP_CHECKSIGVERIFY).op(§ pars OP_ELSE).data(§ pars timeBytes).op(§ pars OP_CHECKLOCKTIMEVERIFY).op(§ pars OP_DROP).op(§ pars OP_ENDIF).data(§ pars from.getPubKey(§ pars )).op(§ pars OP_CHECKSIG).build(§ pars ))
    )

    #_public
    #_static
    (§ method Script createCLTVPaymentChannelRefund(§ args TransactionSignature signature))
    (§ block
        (§ var ScriptBuilder builder = new ScriptBuilder(§ pars ))
        (§ call builder.data(§ pars signature.encodeToBitcoin(§ pars )))
        (§ call builder.data(§ pars new byte[] (§ coll 0 ))) ;; Use the CHECKLOCKTIMEVERIFY if branch.
        (§ return builder.build(§ pars ))
    )

    #_public
    #_static
    (§ method Script createCLTVPaymentChannelP2SHRefund(§ args TransactionSignature signature, Script redeemScript))
    (§ block
        (§ var ScriptBuilder builder = new ScriptBuilder(§ pars ))
        (§ call builder.data(§ pars signature.encodeToBitcoin(§ pars )))
        (§ call builder.data(§ pars new byte[] (§ coll 0 ))) ;; Use the CHECKLOCKTIMEVERIFY if branch.
        (§ call builder.data(§ pars redeemScript.getProgram(§ pars )))
        (§ return builder.build(§ pars ))
    )

    #_public
    #_static
    (§ method Script createCLTVPaymentChannelP2SHInput(§ args byte[] from, byte[] to, Script redeemScript))
    (§ block
        (§ var ScriptBuilder builder = new ScriptBuilder(§ pars ))
        (§ call builder.data(§ pars from))
        (§ call builder.data(§ pars to))
        (§ call builder.smallNum(§ pars 1)) ;; Use the CHECKLOCKTIMEVERIFY if branch.
        (§ call builder.data(§ pars redeemScript.getProgram(§ pars )))
        (§ return builder.build(§ pars ))
    )

    #_public
    #_static
    (§ method Script createCLTVPaymentChannelInput(§ args TransactionSignature from, TransactionSignature to))
    (§ block
        (§ return createCLTVPaymentChannelInput(§ pars from.encodeToBitcoin(§ pars ), to.encodeToBitcoin(§ pars )))
    )

    #_public
    #_static
    (§ method Script createCLTVPaymentChannelInput(§ args byte[] from, byte[] to))
    (§ block
        (§ var ScriptBuilder builder = new ScriptBuilder(§ pars ))
        (§ call builder.data(§ pars from))
        (§ call builder.data(§ pars to))
        (§ call builder.smallNum(§ pars 1)) ;; Use the CHECKLOCKTIMEVERIFY if branch.
        (§ return builder.build(§ pars ))
    )
)

#_(ns org.bitcoinj.script #_"ScriptChunk"
    (:import [java.io IOException OutputStream]
             [java.util Arrays])
    (:import [com.google.common.base Objects Preconditions])
   (:require [org.bitcoinj.core Utils]
             #_static [org.bitcoinj.script.ScriptOpCodes *]))

;;;
 ; A script element that is either a data push (signature, pubkey, etc.) or a non-push (logic, numeric, etc.) operation.
 ;;
#_public
(§ class ScriptChunk
    ;;; Operation to be executed.  Opcodes are defined in {@link ScriptOpCodes}. ;;
    #_public
    #_final
    (§ field int opcode)
    ;;;
     ; For push operations, this is the vector to be pushed on the stack.
     ; For {@link ScriptOpCodes#OP_0}, the vector is empty.
     ; Null for non-push operations.
     ;;
    #_nilable
    #_public
    #_final
    (§ field byte[] data)
    #_private
    (§ field int startLocationInProgram)

    #_public
    (§ constructor ScriptChunk(§ args int opcode, byte[] data))
    (§ block
        (§ this (§ pars opcode, data, -1))
    )

    #_public
    (§ constructor ScriptChunk(§ args int opcode, byte[] data, int startLocationInProgram))
    (§ block
        (§ ass this.opcode = opcode)
        (§ ass this.data = data)
        (§ ass this.startLocationInProgram = startLocationInProgram)
    )

    #_public
    (§ method boolean equalsOpCode(§ args int opcode))
    (§ block
        (§ return (§ expr opcode == this.opcode))
    )

    ;;;
     ; If this chunk is a single byte of non-pushdata content (could be OP_RESERVED or some invalid Opcode).
     ;;
    #_public
    (§ method boolean isOpCode(§ args ))
    (§ block
        (§ return (§ expr OP_PUSHDATA4 < opcode))
    )

    ;;;
     ; Returns true if this chunk is pushdata content, including the single-byte pushdatas.
     ;;
    #_public
    (§ method boolean isPushData(§ args ))
    (§ block
        (§ return (§ expr opcode <= OP_16))
    )

    #_public
    (§ method int getStartLocationInProgram(§ args ))
    (§ block
        (§ call Preconditions.checkState(§ pars 0 <= startLocationInProgram))

        (§ return startLocationInProgram)
    )

    ;;; If this chunk is an OP_N opcode returns the equivalent integer value. ;;
    #_public
    (§ method int decodeOpN(§ args ))
    (§ block
        (§ call Preconditions.checkState(§ pars isOpCode(§ pars )))

        (§ return Script.decodeFromOpN(§ pars opcode))
    )

    ;;;
     ; Called on a pushdata chunk, returns true if it uses the smallest possible way (according to BIP62) to push the data.
     ;;
    #_public
    (§ method boolean isShortestPossiblePushData(§ args ))
    (§ block
        (§ call Preconditions.checkState(§ pars isPushData(§ pars )))

        (§ if (§ expr data == nil))
        (§ block
            (§ return true) ;; OP_N
        )
        (§ if (§ expr data.length == 0))
        (§ block
            (§ return opcode == OP_0)
        )
        (§ if (§ expr data.length == 1))
        (§ block
            (§ var byte b = data[0])
            (§ if (§ expr 0x01 <= b && b <= 0x10))
            (§ block
                (§ return (§ expr opcode == OP_1 + b - 1))
            )
            (§ if (§ expr (§ expr b & 0xff) == 0x81))
            (§ block
                (§ return (§ expr opcode == OP_1NEGATE))
            )
        )
        (§ if (§ expr data.length < OP_PUSHDATA1))
        (§ block
            (§ return opcode == data.length)
        )
        (§ if (§ expr data.length < 256))
        (§ block
            (§ return opcode == OP_PUSHDATA1)
        )
        (§ if (§ expr data.length < 65536))
        (§ block
            (§ return opcode == OP_PUSHDATA2)
        )

        ;; Can never be used, but implemented for completeness.
        (§ return (§ expr opcode == OP_PUSHDATA4))
    )

    #_public
    (§ method void write(§ args OutputStream stream))
        (§ throws IOException)
    (§ block
        (§ if (§ expr isOpCode(§ pars )))
        (§ block
            (§ call Preconditions.checkState(§ pars data == nil))
            (§ call stream.write(§ pars opcode))
        )
        (§ elseif (§ expr data != nil))
        (§ block
            (§ if (§ expr opcode < OP_PUSHDATA1))
            (§ block
                (§ call Preconditions.checkState(§ pars data.length == opcode))
                (§ call stream.write(§ pars opcode))
            )
            (§ elseif (§ expr opcode == OP_PUSHDATA1))
            (§ block
                (§ call Preconditions.checkState(§ pars data.length <= 0xff))
                (§ call stream.write(§ pars OP_PUSHDATA1))
                (§ call stream.write(§ pars data.length))
            )
            (§ elseif (§ expr opcode == OP_PUSHDATA2))
            (§ block
                (§ call Preconditions.checkState(§ pars data.length <= 0xffff))
                (§ call stream.write(§ pars OP_PUSHDATA2))
                (§ call stream.write(§ pars 0xff & data.length))
                (§ call stream.write(§ pars 0xff & (§ expr data.length >> 8)))
            )
            (§ elseif (§ expr opcode == OP_PUSHDATA4))
            (§ block
                (§ call Preconditions.checkState(§ pars data.length <= Script.MAX_SCRIPT_ELEMENT_SIZE))
                (§ call stream.write(§ pars OP_PUSHDATA4))
                (§ call Utils.uint32ToByteStreamLE(§ pars data.length, stream))
            )
            (§ else )
            (§ block
                (§ throw (§ new RuntimeException(§ pars "Unimplemented")))
            )
            (§ call stream.write(§ pars data))
        )
        (§ else )
        (§ block
            (§ call stream.write(§ pars opcode)) ;; smallNum
        )
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ var StringBuilder sb = new StringBuilder(§ pars ))
        (§ if (§ expr isOpCode(§ pars )))
        (§ block
            (§ call sb.append(§ pars getOpCodeName(§ pars opcode)))
        )
        (§ elseif (§ expr data != nil)) ;; Data chunk.
        (§ block
            (§ call sb.append(§ pars getPushDataName(§ pars opcode)).append(§ pars "[").append(§ pars Utils.HEX.encode(§ pars data)).append(§ pars "]"))
        )
        (§ else ) ;; Small num.
        (§ block
            (§ call sb.append(§ pars Script.decodeFromOpN(§ pars opcode)))
        )
        (§ return sb.toString(§ pars ))
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var ScriptChunk other = (§ cast ScriptChunk)o)
        (§ return (§ expr opcode == other.opcode && startLocationInProgram == other.startLocationInProgram && Arrays.equals(§ pars data, other.data)))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars opcode, startLocationInProgram, Arrays.hashCode(§ pars data)))
    )
)

#_(ns org.bitcoinj.script #_"ScriptError"
    (:import [java.util HashMap Map]))

#_public
(§ enum ScriptError
    (§ item SCRIPT_ERR_OK(§ pars "OK"))
    (§ item SCRIPT_ERR_UNKNOWN_ERROR(§ pars "UNKNOWN_ERROR"))
    (§ item SCRIPT_ERR_EVAL_FALSE(§ pars "EVAL_FALSE"))
    (§ item SCRIPT_ERR_OP_RETURN(§ pars "OP_RETURN"))

    ;;;max sizes ;;
    (§ item SCRIPT_ERR_SCRIPT_SIZE(§ pars "SCRIPT_SIZE"))
    (§ item SCRIPT_ERR_PUSH_SIZE(§ pars "PUSH_SIZE"))
    (§ item SCRIPT_ERR_OP_COUNT(§ pars "OP_COUNT"))
    (§ item SCRIPT_ERR_STACK_SIZE(§ pars "STACK_SIZE"))
    (§ item SCRIPT_ERR_SIG_COUNT(§ pars "SIG_COUNT"))
    (§ item SCRIPT_ERR_PUBKEY_COUNT(§ pars "PUBKEY_COUNT"))

    ;;;failed verify operations ;;
    (§ item SCRIPT_ERR_VERIFY(§ pars "VERIFY"))
    (§ item SCRIPT_ERR_EQUALVERIFY(§ pars "EQUALVERIFY"))
    (§ item SCRIPT_ERR_CHECKMULTISIGVERIFY(§ pars "CHECKMULTISIGVERIFY"))
    (§ item SCRIPT_ERR_CHECKSIGVERIFY(§ pars "CHECKSIGVERIFY"))
    (§ item SCRIPT_ERR_NUMEQUALVERIFY(§ pars "NUMEQUALVERIFY"))

    ;;;logical/format/canonical errors ;;
    (§ item SCRIPT_ERR_BAD_OPCODE(§ pars "BAD_OPCODE"))
    (§ item SCRIPT_ERR_DISABLED_OPCODE(§ pars "DISABLED_OPCODE"))
    (§ item SCRIPT_ERR_INVALID_STACK_OPERATION(§ pars "INVALID_STACK_OPERATION"))
    (§ item SCRIPT_ERR_INVALID_ALTSTACK_OPERATION(§ pars "INVALID_ALTSTACK_OPERATION"))
    (§ item SCRIPT_ERR_UNBALANCED_CONDITIONAL(§ pars "UNBALANCED_CONDITIONAL"))

    ;;;CHECKLOCKTIMEVERIFY and CHECKSEQUENCEVERIFY ;;
    (§ item SCRIPT_ERR_NEGATIVE_LOCKTIME(§ pars "NEGATIVE_LOCKTIME"))
    (§ item SCRIPT_ERR_UNSATISFIED_LOCKTIME(§ pars "UNSATISFIED_LOCKTIME"))

    ;;;malleability ;;
    (§ item SCRIPT_ERR_SIG_HASHTYPE(§ pars "SIG_HASHTYPE"))
    (§ item SCRIPT_ERR_SIG_DER(§ pars "SIG_DER"))
    (§ item SCRIPT_ERR_MINIMALDATA(§ pars "MINIMALDATA"))
    (§ item SCRIPT_ERR_SIG_PUSHONLY(§ pars "SIG_PUSHONLY"))
    (§ item SCRIPT_ERR_SIG_HIGH_S(§ pars "SIG_HIGH_S"))
    (§ item SCRIPT_ERR_SIG_NULLDUMMY(§ pars "SIG_NULLDUMMY"))
    (§ item SCRIPT_ERR_PUBKEYTYPE(§ pars "PUBKEYTYPE"))
    (§ item SCRIPT_ERR_CLEANSTACK(§ pars "CLEANSTACK"))
    (§ item SCRIPT_ERR_MINIMALIF(§ pars "MINIMALIF"))
    (§ item SCRIPT_ERR_SIG_NULLFAIL(§ pars "NULLFAIL"))

    ;;;softfork safeness ;;
    (§ item SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS(§ pars "DISCOURAGE_UPGRADABLE_NOPS"))
    (§ item SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM(§ pars "DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM"))

    ;;;segregated witness ;;
    (§ item SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH(§ pars "WITNESS_PROGRAM_WRONG_LENGTH"))
    (§ item SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY(§ pars "WITNESS_PROGRAM_WITNESS_EMPTY"))
    (§ item SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH(§ pars "WITNESS_PROGRAM_MISMATCH"))
    (§ item SCRIPT_ERR_WITNESS_MALLEATED(§ pars "WITNESS_MALLEATED"))
    (§ item SCRIPT_ERR_WITNESS_MALLEATED_P2SH(§ pars "WITNESS_MALLEATED_P2SH"))
    (§ item SCRIPT_ERR_WITNESS_UNEXPECTED(§ pars "WITNESS_UNEXPECTED"))
    (§ item SCRIPT_ERR_WITNESS_PUBKEYTYPE(§ pars "WITNESS_PUBKEYTYPE"))

    (§ item SCRIPT_ERR_ERROR_COUNT(§ pars "ERROR_COUNT"))

    #_private
    #_final
    (§ field String mnemonic)
    #_private
    #_static
    #_final
    (§ field Map<String, ScriptError> mnemonicToScriptErrorMap)

    #_private
    (§ constructor ScriptError(§ args String name))
    (§ block
        (§ ass this.mnemonic = name)
    )

    #_static
    (§ block
        (§ ass mnemonicToScriptErrorMap = new HashMap<>(§ pars ))
        (§ for (§ var ScriptError err) :for (§ expr ScriptError.values(§ pars )))
        (§ block
            (§ call mnemonicToScriptErrorMap.put(§ pars err.getMnemonic(§ pars ), err))
        )
    )

    #_public
    (§ method String getMnemonic(§ args ))
    (§ block
        (§ return mnemonic)
    )

    #_public
    #_static
    (§ method ScriptError fromMnemonic(§ args String name))
    (§ block
        (§ var ScriptError err = mnemonicToScriptErrorMap.get(§ pars name))
        (§ if (§ expr err == nil))
        (§ block
            (§ throw (§ new IllegalArgumentException(§ pars name + " is not a valid name")))
        )
        (§ return err)
    )
)

#_(ns org.bitcoinj.script #_"ScriptOpCodes"
    (:import [java.util Map])
    (:import [com.google.common.collect ImmutableMap]))

;;;
 ; Various constants that define the assembly-like scripting language that forms part of the Bitcoin protocol.
 ; See {@link org.bitcoinj.script.Script} for details.  Also provides a method to convert them to a string.
 ;;
#_public
(§ class ScriptOpCodes
    ;; push value
    #_public
    #_static
    #_final
    (§ field int OP_0 = 0x00) ;; push empty vector
    #_public
    #_static
    #_final
    (§ field int OP_FALSE = OP_0)
    #_public
    #_static
    #_final
    (§ field int OP_PUSHDATA1 = 0x4c)
    #_public
    #_static
    #_final
    (§ field int OP_PUSHDATA2 = 0x4d)
    #_public
    #_static
    #_final
    (§ field int OP_PUSHDATA4 = 0x4e)
    #_public
    #_static
    #_final
    (§ field int OP_1NEGATE = 0x4f)
    #_public
    #_static
    #_final
    (§ field int OP_RESERVED = 0x50)
    #_public
    #_static
    #_final
    (§ field int OP_1 = 0x51)
    #_public
    #_static
    #_final
    (§ field int OP_TRUE = OP_1)
    #_public
    #_static
    #_final
    (§ field int OP_2 = 0x52)
    #_public
    #_static
    #_final
    (§ field int OP_3 = 0x53)
    #_public
    #_static
    #_final
    (§ field int OP_4 = 0x54)
    #_public
    #_static
    #_final
    (§ field int OP_5 = 0x55)
    #_public
    #_static
    #_final
    (§ field int OP_6 = 0x56)
    #_public
    #_static
    #_final
    (§ field int OP_7 = 0x57)
    #_public
    #_static
    #_final
    (§ field int OP_8 = 0x58)
    #_public
    #_static
    #_final
    (§ field int OP_9 = 0x59)
    #_public
    #_static
    #_final
    (§ field int OP_10 = 0x5a)
    #_public
    #_static
    #_final
    (§ field int OP_11 = 0x5b)
    #_public
    #_static
    #_final
    (§ field int OP_12 = 0x5c)
    #_public
    #_static
    #_final
    (§ field int OP_13 = 0x5d)
    #_public
    #_static
    #_final
    (§ field int OP_14 = 0x5e)
    #_public
    #_static
    #_final
    (§ field int OP_15 = 0x5f)
    #_public
    #_static
    #_final
    (§ field int OP_16 = 0x60)

    ;; control
    #_public
    #_static
    #_final
    (§ field int OP_NOP = 0x61)
    #_public
    #_static
    #_final
    (§ field int OP_VER = 0x62)
    #_public
    #_static
    #_final
    (§ field int OP_IF = 0x63)
    #_public
    #_static
    #_final
    (§ field int OP_NOTIF = 0x64)
    #_public
    #_static
    #_final
    (§ field int OP_VERIF = 0x65)
    #_public
    #_static
    #_final
    (§ field int OP_VERNOTIF = 0x66)
    #_public
    #_static
    #_final
    (§ field int OP_ELSE = 0x67)
    #_public
    #_static
    #_final
    (§ field int OP_ENDIF = 0x68)
    #_public
    #_static
    #_final
    (§ field int OP_VERIFY = 0x69)
    #_public
    #_static
    #_final
    (§ field int OP_RETURN = 0x6a)

    ;; stack ops
    #_public
    #_static
    #_final
    (§ field int OP_TOALTSTACK = 0x6b)
    #_public
    #_static
    #_final
    (§ field int OP_FROMALTSTACK = 0x6c)
    #_public
    #_static
    #_final
    (§ field int OP_2DROP = 0x6d)
    #_public
    #_static
    #_final
    (§ field int OP_2DUP = 0x6e)
    #_public
    #_static
    #_final
    (§ field int OP_3DUP = 0x6f)
    #_public
    #_static
    #_final
    (§ field int OP_2OVER = 0x70)
    #_public
    #_static
    #_final
    (§ field int OP_2ROT = 0x71)
    #_public
    #_static
    #_final
    (§ field int OP_2SWAP = 0x72)
    #_public
    #_static
    #_final
    (§ field int OP_IFDUP = 0x73)
    #_public
    #_static
    #_final
    (§ field int OP_DEPTH = 0x74)
    #_public
    #_static
    #_final
    (§ field int OP_DROP = 0x75)
    #_public
    #_static
    #_final
    (§ field int OP_DUP = 0x76)
    #_public
    #_static
    #_final
    (§ field int OP_NIP = 0x77)
    #_public
    #_static
    #_final
    (§ field int OP_OVER = 0x78)
    #_public
    #_static
    #_final
    (§ field int OP_PICK = 0x79)
    #_public
    #_static
    #_final
    (§ field int OP_ROLL = 0x7a)
    #_public
    #_static
    #_final
    (§ field int OP_ROT = 0x7b)
    #_public
    #_static
    #_final
    (§ field int OP_SWAP = 0x7c)
    #_public
    #_static
    #_final
    (§ field int OP_TUCK = 0x7d)

    ;; splice ops
    #_public
    #_static
    #_final
    (§ field int OP_CAT = 0x7e)
    #_public
    #_static
    #_final
    (§ field int OP_SUBSTR = 0x7f)
    #_public
    #_static
    #_final
    (§ field int OP_LEFT = 0x80)
    #_public
    #_static
    #_final
    (§ field int OP_RIGHT = 0x81)
    #_public
    #_static
    #_final
    (§ field int OP_SIZE = 0x82)

    ;; bit logic
    #_public
    #_static
    #_final
    (§ field int OP_INVERT = 0x83)
    #_public
    #_static
    #_final
    (§ field int OP_AND = 0x84)
    #_public
    #_static
    #_final
    (§ field int OP_OR = 0x85)
    #_public
    #_static
    #_final
    (§ field int OP_XOR = 0x86)
    #_public
    #_static
    #_final
    (§ field int OP_EQUAL = 0x87)
    #_public
    #_static
    #_final
    (§ field int OP_EQUALVERIFY = 0x88)
    #_public
    #_static
    #_final
    (§ field int OP_RESERVED1 = 0x89)
    #_public
    #_static
    #_final
    (§ field int OP_RESERVED2 = 0x8a)

    ;; numeric
    #_public
    #_static
    #_final
    (§ field int OP_1ADD = 0x8b)
    #_public
    #_static
    #_final
    (§ field int OP_1SUB = 0x8c)
    #_public
    #_static
    #_final
    (§ field int OP_2MUL = 0x8d)
    #_public
    #_static
    #_final
    (§ field int OP_2DIV = 0x8e)
    #_public
    #_static
    #_final
    (§ field int OP_NEGATE = 0x8f)
    #_public
    #_static
    #_final
    (§ field int OP_ABS = 0x90)
    #_public
    #_static
    #_final
    (§ field int OP_NOT = 0x91)
    #_public
    #_static
    #_final
    (§ field int OP_0NOTEQUAL = 0x92)
    #_public
    #_static
    #_final
    (§ field int OP_ADD = 0x93)
    #_public
    #_static
    #_final
    (§ field int OP_SUB = 0x94)
    #_public
    #_static
    #_final
    (§ field int OP_MUL = 0x95)
    #_public
    #_static
    #_final
    (§ field int OP_DIV = 0x96)
    #_public
    #_static
    #_final
    (§ field int OP_MOD = 0x97)
    #_public
    #_static
    #_final
    (§ field int OP_LSHIFT = 0x98)
    #_public
    #_static
    #_final
    (§ field int OP_RSHIFT = 0x99)
    #_public
    #_static
    #_final
    (§ field int OP_BOOLAND = 0x9a)
    #_public
    #_static
    #_final
    (§ field int OP_BOOLOR = 0x9b)
    #_public
    #_static
    #_final
    (§ field int OP_NUMEQUAL = 0x9c)
    #_public
    #_static
    #_final
    (§ field int OP_NUMEQUALVERIFY = 0x9d)
    #_public
    #_static
    #_final
    (§ field int OP_NUMNOTEQUAL = 0x9e)
    #_public
    #_static
    #_final
    (§ field int OP_LESSTHAN = 0x9f)
    #_public
    #_static
    #_final
    (§ field int OP_GREATERTHAN = 0xa0)
    #_public
    #_static
    #_final
    (§ field int OP_LESSTHANOREQUAL = 0xa1)
    #_public
    #_static
    #_final
    (§ field int OP_GREATERTHANOREQUAL = 0xa2)
    #_public
    #_static
    #_final
    (§ field int OP_MIN = 0xa3)
    #_public
    #_static
    #_final
    (§ field int OP_MAX = 0xa4)
    #_public
    #_static
    #_final
    (§ field int OP_WITHIN = 0xa5)

    ;; crypto
    #_public
    #_static
    #_final
    (§ field int OP_RIPEMD160 = 0xa6)
    #_public
    #_static
    #_final
    (§ field int OP_SHA1 = 0xa7)
    #_public
    #_static
    #_final
    (§ field int OP_SHA256 = 0xa8)
    #_public
    #_static
    #_final
    (§ field int OP_HASH160 = 0xa9)
    #_public
    #_static
    #_final
    (§ field int OP_HASH256 = 0xaa)
    #_public
    #_static
    #_final
    (§ field int OP_CODESEPARATOR = 0xab)
    #_public
    #_static
    #_final
    (§ field int OP_CHECKSIG = 0xac)
    #_public
    #_static
    #_final
    (§ field int OP_CHECKSIGVERIFY = 0xad)
    #_public
    #_static
    #_final
    (§ field int OP_CHECKMULTISIG = 0xae)
    #_public
    #_static
    #_final
    (§ field int OP_CHECKMULTISIGVERIFY = 0xaf)

    ;; block state
    ;;; Check lock time of the block.  Introduced in BIP 65, replacing OP_NOP2 ;;
    #_public
    #_static
    #_final
    (§ field int OP_CHECKLOCKTIMEVERIFY = 0xb1)
    #_public
    #_static
    #_final
    (§ field int OP_CHECKSEQUENCEVERIFY = 0xb2)

    ;; expansion
    #_public
    #_static
    #_final
    (§ field int OP_NOP1 = 0xb0)
    ;;; Deprecated by BIP 65 ;;
    #_deprecated
    #_public
    #_static
    #_final
    (§ field int OP_NOP2 = OP_CHECKLOCKTIMEVERIFY)
    ;;; Deprecated by BIP 112 ;;
    #_deprecated
    #_public
    #_static
    #_final
    (§ field int OP_NOP3 = OP_CHECKSEQUENCEVERIFY)
    #_public
    #_static
    #_final
    (§ field int OP_NOP4 = 0xb3)
    #_public
    #_static
    #_final
    (§ field int OP_NOP5 = 0xb4)
    #_public
    #_static
    #_final
    (§ field int OP_NOP6 = 0xb5)
    #_public
    #_static
    #_final
    (§ field int OP_NOP7 = 0xb6)
    #_public
    #_static
    #_final
    (§ field int OP_NOP8 = 0xb7)
    #_public
    #_static
    #_final
    (§ field int OP_NOP9 = 0xb8)
    #_public
    #_static
    #_final
    (§ field int OP_NOP10 = 0xb9)
    #_public
    #_static
    #_final
    (§ field int OP_INVALIDOPCODE = 0xff)

    #_private
    #_static
    #_final
    (§ var Map<Integer, String> opCodeMap = ImmutableMap.<Integer, String>builder(§ pars ).put(§ pars OP_0, "0").put(§ pars OP_PUSHDATA1, "PUSHDATA1").put(§ pars OP_PUSHDATA2, "PUSHDATA2").put(§ pars OP_PUSHDATA4, "PUSHDATA4").put(§ pars OP_1NEGATE, "1NEGATE").put(§ pars OP_RESERVED, "RESERVED").put(§ pars OP_1, "1").put(§ pars OP_2, "2").put(§ pars OP_3, "3").put(§ pars OP_4, "4").put(§ pars OP_5, "5").put(§ pars OP_6, "6").put(§ pars OP_7, "7").put(§ pars OP_8, "8").put(§ pars OP_9, "9").put(§ pars OP_10, "10").put(§ pars OP_11, "11").put(§ pars OP_12, "12").put(§ pars OP_13, "13").put(§ pars OP_14, "14").put(§ pars OP_15, "15").put(§ pars OP_16, "16").put(§ pars OP_NOP, "NOP").put(§ pars OP_VER, "VER").put(§ pars OP_IF, "IF").put(§ pars OP_NOTIF, "NOTIF").put(§ pars OP_VERIF, "VERIF").put(§ pars OP_VERNOTIF, "VERNOTIF").put(§ pars OP_ELSE, "ELSE").put(§ pars OP_ENDIF, "ENDIF").put(§ pars OP_VERIFY, "VERIFY").put(§ pars OP_RETURN, "RETURN").put(§ pars OP_TOALTSTACK, "TOALTSTACK").put(§ pars OP_FROMALTSTACK, "FROMALTSTACK").put(§ pars OP_2DROP, "2DROP").put(§ pars OP_2DUP, "2DUP").put(§ pars OP_3DUP, "3DUP").put(§ pars OP_2OVER, "2OVER").put(§ pars OP_2ROT, "2ROT").put(§ pars OP_2SWAP, "2SWAP").put(§ pars OP_IFDUP, "IFDUP").put(§ pars OP_DEPTH, "DEPTH").put(§ pars OP_DROP, "DROP").put(§ pars OP_DUP, "DUP").put(§ pars OP_NIP, "NIP").put(§ pars OP_OVER, "OVER").put(§ pars OP_PICK, "PICK").put(§ pars OP_ROLL, "ROLL").put(§ pars OP_ROT, "ROT").put(§ pars OP_SWAP, "SWAP").put(§ pars OP_TUCK, "TUCK").put(§ pars OP_CAT, "CAT").put(§ pars OP_SUBSTR, "SUBSTR").put(§ pars OP_LEFT, "LEFT").put(§ pars OP_RIGHT, "RIGHT").put(§ pars OP_SIZE, "SIZE").put(§ pars OP_INVERT, "INVERT").put(§ pars OP_AND, "AND").put(§ pars OP_OR, "OR").put(§ pars OP_XOR, "XOR").put(§ pars OP_EQUAL, "EQUAL").put(§ pars OP_EQUALVERIFY, "EQUALVERIFY").put(§ pars OP_RESERVED1, "RESERVED1").put(§ pars OP_RESERVED2, "RESERVED2").put(§ pars OP_1ADD, "1ADD").put(§ pars OP_1SUB, "1SUB").put(§ pars OP_2MUL, "2MUL").put(§ pars OP_2DIV, "2DIV").put(§ pars OP_NEGATE, "NEGATE").put(§ pars OP_ABS, "ABS").put(§ pars OP_NOT, "NOT").put(§ pars OP_0NOTEQUAL, "0NOTEQUAL").put(§ pars OP_ADD, "ADD").put(§ pars OP_SUB, "SUB").put(§ pars OP_MUL, "MUL").put(§ pars OP_DIV, "DIV").put(§ pars OP_MOD, "MOD").put(§ pars OP_LSHIFT, "LSHIFT").put(§ pars OP_RSHIFT, "RSHIFT").put(§ pars OP_BOOLAND, "BOOLAND").put(§ pars OP_BOOLOR, "BOOLOR").put(§ pars OP_NUMEQUAL, "NUMEQUAL").put(§ pars OP_NUMEQUALVERIFY, "NUMEQUALVERIFY").put(§ pars OP_NUMNOTEQUAL, "NUMNOTEQUAL").put(§ pars OP_LESSTHAN, "LESSTHAN").put(§ pars OP_GREATERTHAN, "GREATERTHAN").put(§ pars OP_LESSTHANOREQUAL, "LESSTHANOREQUAL").put(§ pars OP_GREATERTHANOREQUAL, "GREATERTHANOREQUAL").put(§ pars OP_MIN, "MIN").put(§ pars OP_MAX, "MAX").put(§ pars OP_WITHIN, "WITHIN").put(§ pars OP_RIPEMD160, "RIPEMD160").put(§ pars OP_SHA1, "SHA1").put(§ pars OP_SHA256, "SHA256").put(§ pars OP_HASH160, "HASH160").put(§ pars OP_HASH256, "HASH256").put(§ pars OP_CODESEPARATOR, "CODESEPARATOR").put(§ pars OP_CHECKSIG, "CHECKSIG").put(§ pars OP_CHECKSIGVERIFY, "CHECKSIGVERIFY").put(§ pars OP_CHECKMULTISIG, "CHECKMULTISIG").put(§ pars OP_CHECKMULTISIGVERIFY, "CHECKMULTISIGVERIFY").put(§ pars OP_NOP1, "NOP1").put(§ pars OP_CHECKLOCKTIMEVERIFY, "CHECKLOCKTIMEVERIFY").put(§ pars OP_CHECKSEQUENCEVERIFY, "CHECKSEQUENCEVERIFY").put(§ pars OP_NOP4, "NOP4").put(§ pars OP_NOP5, "NOP5").put(§ pars OP_NOP6, "NOP6").put(§ pars OP_NOP7, "NOP7").put(§ pars OP_NOP8, "NOP8").put(§ pars OP_NOP9, "NOP9").put(§ pars OP_NOP10, "NOP10").build(§ pars ))

    #_private
    #_static
    #_final
    (§ var Map<String, Integer> opCodeNameMap = ImmutableMap.<String, Integer>builder(§ pars ).put(§ pars "0", OP_0).put(§ pars "PUSHDATA1", OP_PUSHDATA1).put(§ pars "PUSHDATA2", OP_PUSHDATA2).put(§ pars "PUSHDATA4", OP_PUSHDATA4).put(§ pars "1NEGATE", OP_1NEGATE).put(§ pars "RESERVED", OP_RESERVED).put(§ pars "1", OP_1).put(§ pars "2", OP_2).put(§ pars "3", OP_3).put(§ pars "4", OP_4).put(§ pars "5", OP_5).put(§ pars "6", OP_6).put(§ pars "7", OP_7).put(§ pars "8", OP_8).put(§ pars "9", OP_9).put(§ pars "10", OP_10).put(§ pars "11", OP_11).put(§ pars "12", OP_12).put(§ pars "13", OP_13).put(§ pars "14", OP_14).put(§ pars "15", OP_15).put(§ pars "16", OP_16).put(§ pars "NOP", OP_NOP).put(§ pars "VER", OP_VER).put(§ pars "IF", OP_IF).put(§ pars "NOTIF", OP_NOTIF).put(§ pars "VERIF", OP_VERIF).put(§ pars "VERNOTIF", OP_VERNOTIF).put(§ pars "ELSE", OP_ELSE).put(§ pars "ENDIF", OP_ENDIF).put(§ pars "VERIFY", OP_VERIFY).put(§ pars "RETURN", OP_RETURN).put(§ pars "TOALTSTACK", OP_TOALTSTACK).put(§ pars "FROMALTSTACK", OP_FROMALTSTACK).put(§ pars "2DROP", OP_2DROP).put(§ pars "2DUP", OP_2DUP).put(§ pars "3DUP", OP_3DUP).put(§ pars "2OVER", OP_2OVER).put(§ pars "2ROT", OP_2ROT).put(§ pars "2SWAP", OP_2SWAP).put(§ pars "IFDUP", OP_IFDUP).put(§ pars "DEPTH", OP_DEPTH).put(§ pars "DROP", OP_DROP).put(§ pars "DUP", OP_DUP).put(§ pars "NIP", OP_NIP).put(§ pars "OVER", OP_OVER).put(§ pars "PICK", OP_PICK).put(§ pars "ROLL", OP_ROLL).put(§ pars "ROT", OP_ROT).put(§ pars "SWAP", OP_SWAP).put(§ pars "TUCK", OP_TUCK).put(§ pars "CAT", OP_CAT).put(§ pars "SUBSTR", OP_SUBSTR).put(§ pars "LEFT", OP_LEFT).put(§ pars "RIGHT", OP_RIGHT).put(§ pars "SIZE", OP_SIZE).put(§ pars "INVERT", OP_INVERT).put(§ pars "AND", OP_AND).put(§ pars "OR", OP_OR).put(§ pars "XOR", OP_XOR).put(§ pars "EQUAL", OP_EQUAL).put(§ pars "EQUALVERIFY", OP_EQUALVERIFY).put(§ pars "RESERVED1", OP_RESERVED1).put(§ pars "RESERVED2", OP_RESERVED2).put(§ pars "1ADD", OP_1ADD).put(§ pars "1SUB", OP_1SUB).put(§ pars "2MUL", OP_2MUL).put(§ pars "2DIV", OP_2DIV).put(§ pars "NEGATE", OP_NEGATE).put(§ pars "ABS", OP_ABS).put(§ pars "NOT", OP_NOT).put(§ pars "0NOTEQUAL", OP_0NOTEQUAL).put(§ pars "ADD", OP_ADD).put(§ pars "SUB", OP_SUB).put(§ pars "MUL", OP_MUL).put(§ pars "DIV", OP_DIV).put(§ pars "MOD", OP_MOD).put(§ pars "LSHIFT", OP_LSHIFT).put(§ pars "RSHIFT", OP_RSHIFT).put(§ pars "BOOLAND", OP_BOOLAND).put(§ pars "BOOLOR", OP_BOOLOR).put(§ pars "NUMEQUAL", OP_NUMEQUAL).put(§ pars "NUMEQUALVERIFY", OP_NUMEQUALVERIFY).put(§ pars "NUMNOTEQUAL", OP_NUMNOTEQUAL).put(§ pars "LESSTHAN", OP_LESSTHAN).put(§ pars "GREATERTHAN", OP_GREATERTHAN).put(§ pars "LESSTHANOREQUAL", OP_LESSTHANOREQUAL).put(§ pars "GREATERTHANOREQUAL", OP_GREATERTHANOREQUAL).put(§ pars "MIN", OP_MIN).put(§ pars "MAX", OP_MAX).put(§ pars "WITHIN", OP_WITHIN).put(§ pars "RIPEMD160", OP_RIPEMD160).put(§ pars "SHA1", OP_SHA1).put(§ pars "SHA256", OP_SHA256).put(§ pars "HASH160", OP_HASH160).put(§ pars "HASH256", OP_HASH256).put(§ pars "CODESEPARATOR", OP_CODESEPARATOR).put(§ pars "CHECKSIG", OP_CHECKSIG).put(§ pars "CHECKSIGVERIFY", OP_CHECKSIGVERIFY).put(§ pars "CHECKMULTISIG", OP_CHECKMULTISIG).put(§ pars "CHECKMULTISIGVERIFY", OP_CHECKMULTISIGVERIFY).put(§ pars "NOP1", OP_NOP1).put(§ pars "CHECKLOCKTIMEVERIFY", OP_CHECKLOCKTIMEVERIFY).put(§ pars "CHECKSEQUENCEVERIFY", OP_CHECKSEQUENCEVERIFY).put(§ pars "NOP2", OP_NOP2).put(§ pars "NOP3", OP_NOP3).put(§ pars "NOP4", OP_NOP4).put(§ pars "NOP5", OP_NOP5).put(§ pars "NOP6", OP_NOP6).put(§ pars "NOP7", OP_NOP7).put(§ pars "NOP8", OP_NOP8).put(§ pars "NOP9", OP_NOP9).put(§ pars "NOP10", OP_NOP10).build(§ pars ))

    ;;;
     ; Converts the given OpCode into a string (e.g. "0", "PUSHDATA", or "NON_OP(10)")
     ;;
    #_public
    #_static
    (§ method String getOpCodeName(§ args int opcode))
    (§ block
        (§ if (§ expr opCodeMap.containsKey(§ pars opcode)))
        (§ block
            (§ return opCodeMap.get(§ pars opcode))
        )

        (§ return "NON_OP(" + opcode + ")")
    )

    ;;;
     ; Converts the given pushdata OpCode into a string (e.g. "PUSHDATA2", or "PUSHDATA(23)")
     ;;
    #_public
    #_static
    (§ method String getPushDataName(§ args int opcode))
    (§ block
        (§ if (§ expr opCodeMap.containsKey(§ pars opcode)))
        (§ block
            (§ return opCodeMap.get(§ pars opcode))
        )

        (§ return "PUSHDATA(" + opcode + ")")
    )

    ;;;
     ; Converts the given OpCodeName into an int.
     ;;
    #_public
    #_static
    (§ method int getOpCode(§ args String opCodeName))
    (§ block
        (§ return (§ quest (§ expr opCodeNameMap.containsKey(§ pars opCodeName)) ? opCodeNameMap.get(§ pars opCodeName) :else OP_INVALIDOPCODE))
    )
)

#_(ns org.bitcoinj.signers #_"CustomTransactionSigner"
    (:import [java.util List])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.crypto ChildNumber TransactionSignature]
             [org.bitcoinj.script Script]
             [org.bitcoinj.wallet KeyBag RedeemData]))

;;;
 ; <p>This signer may be used as a template for creating custom multisig transaction signers.</p>
 ;
 ; Concrete implementations have to implement {@link #getSignature(org.bitcoinj.core.Sha256Hash, java.util.List)}
 ; method returning a signature and a public key of the keypair used to created that signature.
 ; It's up to custom implementation where to locate signatures: it may be a network connection,
 ; some local API or something else.
 ; </p>
 ;;
#_public
#_abstract
(§ class CustomTransactionSigner extends StatelessTransactionSigner
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars CustomTransactionSigner.class))

    #_override
    #_public
    (§ method boolean isReady(§ args ))
    (§ block
        (§ return true)
    )

    #_override
    #_public
    (§ method boolean signInputs(§ args ProposedTransaction propTx, KeyBag keyBag))
    (§ block
        (§ var Transaction tx = propTx.partialTx)
        (§ var int numInputs = tx.getInputs(§ pars ).size(§ pars ))
        (§ for (§ var int i = 0) :for (§ expr i < numInputs) :for (§ ass i = i + 1))
        (§ block
            (§ var TransactionInput txIn = tx.getInput(§ pars i))
            (§ var TransactionOutput txOut = txIn.getConnectedOutput(§ pars ))
            (§ if (§ expr txOut == nil))
            (§ block
                (§ continue )
            )

            (§ var Script scriptPubKey = txOut.getScriptPubKey(§ pars ))
            (§ if (§ expr !scriptPubKey.isPayToScriptHash(§ pars )))
            (§ block
                (§ call log.warn(§ pars "CustomTransactionSigner works only with P2SH transactions"))
                (§ return false)
            )

            (§ var Script inputScript = Preconditions.checkNotNull(§ pars txIn.getScriptSig(§ pars )))

            (§ try )
            (§ block
                ;; We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                ;; we sign missing pieces (to check this would require either assuming any signatures are signing
                ;; standard output types or a way to get processed signatures out of script execution).
                (§ call txIn.getScriptSig(§ pars ).correctlySpends(§ pars tx, i, txIn.getConnectedOutput(§ pars ).getScriptPubKey(§ pars )))
                (§ call log.warn(§ pars "Input {} already correctly spends output, assuming SIGHASH type used will be safe and skipping signing.", i))
                (§ continue )
            )
            (§ catch (§ args ScriptException _))
            (§ block
                ;; Expected.
            )

            (§ var RedeemData redeemData = txIn.getConnectedRedeemData(§ pars keyBag))
            (§ if (§ expr redeemData == nil))
            (§ block
                (§ call log.warn(§ pars "No redeem data found for input {}", i))
                (§ continue )
            )

            (§ var Sha256Hash sighash = tx.hashForSignature(§ pars i, redeemData.redeemScript, Transaction.SigHash.ALL, false))
            (§ var SignatureAndKey sigKey = getSignature(§ pars sighash, propTx.keyPaths.get(§ pars scriptPubKey)))
            (§ var TransactionSignature txSig = new TransactionSignature(§ pars sigKey.sig, Transaction.SigHash.ALL, false))
            (§ var int sigIndex = inputScript.getSigInsertionIndex(§ pars sighash, sigKey.pubKey))
            (§ ass inputScript = scriptPubKey.getScriptSigWithSignature(§ pars inputScript, txSig.encodeToBitcoin(§ pars ), sigIndex))
            (§ call txIn.setScriptSig(§ pars inputScript))
        )
        (§ return true)
    )

    #_protected
    #_abstract
    (§ method SignatureAndKey getSignature(§ args Sha256Hash sighash, List<ChildNumber> derivationPath))

    #_public
    (§ class SignatureAndKey
        #_public
        #_final
        (§ field ECKey.ECDSASignature sig)
        #_public
        #_final
        (§ field ECKey pubKey)

        #_public
        (§ constructor SignatureAndKey(§ args ECKey.ECDSASignature sig, ECKey pubKey))
        (§ block
            (§ ass this.sig = sig)
            (§ ass this.pubKey = pubKey)
        )
    )
)

#_(ns org.bitcoinj.signers #_"LocalTransactionSigner"
    (:import [java.util EnumSet])
    (:import [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core ECKey ScriptException Transaction TransactionInput]
             [org.bitcoinj.crypto DeterministicKey TransactionSignature]
             [org.bitcoinj.script Script]
             [org.bitcoinj.script.Script VerifyFlag]
             [org.bitcoinj.wallet KeyBag RedeemData]))

;;;
 ; <p>{@link TransactionSigner} implementation for signing inputs using keys from provided {@link org.bitcoinj.wallet.KeyBag}.</p>
 ; <p>This signer doesn't create input scripts for tx inputs.  Instead it expects inputs to contain scripts with
 ; empty sigs and replaces one of the empty sigs with calculated signature.
 ; </p>
 ; <p>This signer is always implicitly added into every wallet and it is the first signer to be executed during tx
 ; completion.  As the first signer to create a signature, it stores derivation path of the signing key in a given
 ; {@link ProposedTransaction} object that will be also passed then to the next signer in chain.  This allows other
 ; signers to use correct signing key for P2SH inputs, because all the keys involved in a single P2SH address have
 ; the same derivation path.</p>
 ; <p>This signer always uses {@link org.bitcoinj.core.Transaction.SigHash#ALL} signing mode.</p>
 ;;
#_public
(§ class LocalTransactionSigner extends StatelessTransactionSigner
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars LocalTransactionSigner.class))

    ;;;
     ; Verify flags that are safe to use when testing if an input is already signed.
     ;;
    #_private
    #_static
    #_final
    (§ field EnumSet<VerifyFlag> MINIMUM_VERIFY_FLAGS = EnumSet.of(§ pars VerifyFlag.P2SH, VerifyFlag.NULLDUMMY))

    #_override
    #_public
    (§ method boolean isReady(§ args ))
    (§ block
        (§ return true)
    )

    #_override
    #_public
    (§ method boolean signInputs(§ args ProposedTransaction propTx, KeyBag keyBag))
    (§ block
        (§ var Transaction tx = propTx.partialTx)
        (§ var int numInputs = tx.getInputs(§ pars ).size(§ pars ))
        (§ for (§ var int i = 0) :for (§ expr i < numInputs) :for (§ ass i = i + 1))
        (§ block
            (§ var TransactionInput txIn = tx.getInput(§ pars i))
            (§ if (§ expr txIn.getConnectedOutput(§ pars ) == nil))
            (§ block
                (§ call log.warn(§ pars "Missing connected output, assuming input {} is already signed.", i))
                (§ continue )
            )

            (§ try )
            (§ block
                ;; We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                ;; we sign missing pieces (to check this would require either assuming any signatures are signing
                ;; standard output types or a way to get processed signatures out of script execution).
                (§ call txIn.getScriptSig(§ pars ).correctlySpends(§ pars tx, i, txIn.getConnectedOutput(§ pars ).getScriptPubKey(§ pars ), MINIMUM_VERIFY_FLAGS))
                (§ call log.warn(§ pars "Input {} already correctly spends output, assuming SIGHASH type used will be safe and skipping signing.", i))
                (§ continue )
            )
            (§ catch (§ args ScriptException _))
            (§ block
                ;; Expected.
            )

            (§ var RedeemData redeemData = txIn.getConnectedRedeemData(§ pars keyBag))

            (§ var Script scriptPubKey = txIn.getConnectedOutput(§ pars ).getScriptPubKey(§ pars ))

            ;; For P2SH inputs we need to share derivation path of the signing key with other signers, so that they
            ;; use correct key to calculate their signatures.
            ;; Married keys all have the same derivation path, so we can safely just take first one here.
            (§ var ECKey pubKey = redeemData.keys.get(§ pars 0))
            (§ if (§ expr pubKey instanceof DeterministicKey))
            (§ block
                (§ call propTx.keyPaths.put(§ pars scriptPubKey, (§ expr (§ expr (§ cast DeterministicKey)pubKey).getPath(§ pars ))))
            )

            (§ var ECKey key)
            ;; Locate private key in redeem data.  For pay-to-address and pay-to-key inputs RedeemData will always contain
            ;; only one key (with private bytes).  For P2SH inputs RedeemData will contain multiple keys, one of which MAY
            ;; have private bytes.
            (§ if (§ expr (§ ass key = redeemData.getFullKey(§ pars )) == nil))
            (§ block
                (§ call log.warn(§ pars "No local key found for input {}", i))
                (§ continue )
            )

            (§ var Script inputScript = txIn.getScriptSig(§ pars ))
            ;; script here would be either a standard CHECKSIG program for pay-to-address or pay-to-pubkey inputs or
            ;; a CHECKMULTISIG program for P2SH inputs.
            (§ var byte[] script = redeemData.redeemScript.getProgram(§ pars ))
            (§ try )
            (§ block
                (§ var TransactionSignature signature = tx.calculateSignature(§ pars i, key, script, Transaction.SigHash.ALL, false))

                ;; At this point we have incomplete inputScript with OP_0 in place of one or more signatures.  We already
                ;; have calculated the signature using the local key and now need to insert it in the correct place
                ;; within inputScript.  For pay-to-address and pay-to-key script there is only one signature and it always
                ;; goes first in an inputScript (sigIndex = 0).  In P2SH input scripts we need to figure out our relative
                ;; position relative to other signers.  Since we don't have that information at this point, and since
                ;; we always run first, we have to depend on the other signers rearranging the signatures as needed.
                ;; Therefore, always place as first signature.
                (§ var int sigIndex = 0)
                (§ ass inputScript = scriptPubKey.getScriptSigWithSignature(§ pars inputScript, signature.encodeToBitcoin(§ pars ), sigIndex))
                (§ call txIn.setScriptSig(§ pars inputScript))
            )
            (§ catch (§ args ECKey.KeyIsEncryptedException e))
            (§ block
                (§ throw e)
            )
            (§ catch (§ args ECKey.MissingPrivateKeyException _))
            (§ block
                (§ call log.warn(§ pars "No private key in keypair for input {}", i))
            )
        )
        (§ return true)
    )
)

#_(ns org.bitcoinj.signers #_"MissingSigResolutionSigner"
    (:import [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core ECKey TransactionInput]
             [org.bitcoinj.crypto TransactionSignature]
             [org.bitcoinj.script Script ScriptChunk]
             [org.bitcoinj.wallet KeyBag Wallet]))

;;;
 ; This transaction signer resolves missing signatures in accordance with the given {@link org.bitcoinj.wallet.Wallet.MissingSigsMode}.
 ; If missingSigsMode is USE_OP_ZERO this signer does nothing assuming missing signatures are already presented in scriptSigs as OP_0.
 ; In MissingSigsMode.THROW mode this signer will throw an exception.  It would be MissingSignatureException
 ; for P2SH or MissingPrivateKeyException for other transaction types.
 ;;
#_public
(§ class MissingSigResolutionSigner extends StatelessTransactionSigner
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars MissingSigResolutionSigner.class))

    #_public
    (§ field Wallet.MissingSigsMode missingSigsMode = Wallet.MissingSigsMode.USE_DUMMY_SIG)

    #_public
    (§ constructor MissingSigResolutionSigner(§ args ))
    (§ block
    )

    #_public
    (§ constructor MissingSigResolutionSigner(§ args Wallet.MissingSigsMode missingSigsMode))
    (§ block
        (§ ass this.missingSigsMode = missingSigsMode)
    )

    #_override
    #_public
    (§ method boolean isReady(§ args ))
    (§ block
        (§ return true)
    )

    #_override
    #_public
    (§ method boolean signInputs(§ args ProposedTransaction propTx, KeyBag keyBag))
    (§ block
        (§ if (§ expr missingSigsMode == Wallet.MissingSigsMode.USE_OP_ZERO))
        (§ block
            (§ return true)
        )

        (§ var int numInputs = propTx.partialTx.getInputs(§ pars ).size(§ pars ))
        (§ var byte[] dummySig = TransactionSignature.dummy(§ pars ).encodeToBitcoin(§ pars ))
        (§ for (§ var int i = 0) :for (§ expr i < numInputs) :for (§ ass i = i + 1))
        (§ block
            (§ var TransactionInput txIn = propTx.partialTx.getInput(§ pars i))
            (§ if (§ expr txIn.getConnectedOutput(§ pars ) == nil))
            (§ block
                (§ call log.warn(§ pars "Missing connected output, assuming input {} is already signed.", i))
                (§ continue )
            )

            (§ var Script scriptPubKey = txIn.getConnectedOutput(§ pars ).getScriptPubKey(§ pars ))
            (§ var Script inputScript = txIn.getScriptSig(§ pars ))
            (§ if (§ expr scriptPubKey.isPayToScriptHash(§ pars ) || scriptPubKey.isSentToMultiSig(§ pars )))
            (§ block
                (§ var int sigSuffixCount = scriptPubKey.isPayToScriptHash(§ pars ) ? 1 :else 0)
                ;; All chunks except the first one (OP_0) and the last (redeem script) are signatures.
                (§ for (§ var int j = 1) :for (§ expr j < inputScript.getChunks(§ pars ).size(§ pars ) - sigSuffixCount) :for (§ ass j = j + 1))
                (§ block
                    (§ var ScriptChunk scriptChunk = inputScript.getChunks(§ pars ).get(§ pars j))
                    (§ if (§ expr scriptChunk.equalsOpCode(§ pars 0)))
                    (§ block
                        (§ if (§ expr missingSigsMode == Wallet.MissingSigsMode.THROW))
                        (§ block
                            (§ throw (§ new MissingSignatureException(§ pars )))
                        )

                        (§ if (§ expr missingSigsMode == Wallet.MissingSigsMode.USE_DUMMY_SIG))
                        (§ block
                            (§ call txIn.setScriptSig(§ pars scriptPubKey.getScriptSigWithSignature(§ pars inputScript, dummySig, j - 1)))
                        )
                    )
                )
            )
            (§ else )
            (§ block
                (§ if (§ expr inputScript.getChunks(§ pars ).get(§ pars 0).equalsOpCode(§ pars 0)))
                (§ block
                    (§ if (§ expr missingSigsMode == Wallet.MissingSigsMode.THROW))
                    (§ block
                        (§ throw new ECKey.MissingPrivateKeyException(§ pars ))
                    )

                    (§ if (§ expr missingSigsMode == Wallet.MissingSigsMode.USE_DUMMY_SIG))
                    (§ block
                        (§ call txIn.setScriptSig(§ pars scriptPubKey.getScriptSigWithSignature(§ pars inputScript, dummySig, 0)))
                    )
                )
            )
            ;; TODO: Handle non-P2SH multisig.
        )
        (§ return true)
    )
)

#_(ns org.bitcoinj.signers #_"StatelessTransactionSigner")

;;;
 ; A signer that doesn't have any state to be serialized.
 ;;
#_public
#_abstract
(§ class StatelessTransactionSigner implements TransactionSigner
    #_override
    #_public
    (§ method void deserialize(§ args byte[] data))
    (§ block
    )

    #_override
    #_public
    (§ method byte[] serialize(§ args ))
    (§ block
        (§ return new byte[0])
    )
)

#_(ns org.bitcoinj.signers #_"TransactionSigner"
    (:import [java.util HashMap List Map])
   (:require [org.bitcoinj.core Transaction]
             [org.bitcoinj.crypto ChildNumber]
             [org.bitcoinj.script Script]
             [org.bitcoinj.wallet KeyBag]))

;;;
 ; <p>Implementations of this interface are intended to sign inputs of the given transaction.
 ; Given transaction may already be partially signed or somehow altered by other signers.</p>
 ; <p>To make use of the signer, you need to add it into the wallet by calling
 ; {@link org.bitcoinj.wallet.Wallet#addTransactionSigner(TransactionSigner)}.
 ; Signer will be serialized along with the wallet data.  In order for a wallet to recreate
 ; signer after deserialization, each signer should have no-args constructor.</p>
 ;;
#_public
(§ interface TransactionSigner
    ;;;
     ; This class wraps transaction proposed to complete keeping a metadata that may be updated, used and effectively
     ; shared by transaction signers.
     ;;
    (§ class ProposedTransaction
        #_public
        #_final
        (§ field Transaction partialTx)

        ;;;
         ; HD key paths used for each input to derive a signing key.  It's useful for multisig inputs only.
         ; The keys used to create a single P2SH address have the same derivation path, so to use a correct key each signer
         ; has to know a derivation path of signing keys used by previous signers.  For each input signers will use the
         ; same derivation path and we need to store only one key path per input.  As TransactionInput is mutable, inputs
         ; are identified by their scriptPubKeys (keys in this map).
         ;;
        #_public
        #_final
        (§ field Map<Script, List<ChildNumber>> keyPaths)

        #_public
        (§ constructor ProposedTransaction(§ args Transaction partialTx))
        (§ block
            (§ ass this.partialTx = partialTx)
            (§ ass this.keyPaths = new HashMap<>(§ pars ))
        )
    )

    (§ class MissingSignatureException extends RuntimeException
    )

    ;;;
     ; Returns true if this signer is ready to be used.
     ;;
    (§ method boolean isReady(§ args ))

    ;;;
     ; Returns byte array of data representing state of this signer.
     ; It's used to serialize/deserialize this signer.
     ;;
    (§ method byte[] serialize(§ args ))

    ;;;
     ; Uses given byte array of data to reconstruct internal state of this signer.
     ;;
    (§ method void deserialize(§ args byte[] data))

    ;;;
     ; Signs given transaction's inputs.
     ; Returns true if signer is compatible with given transaction (can do something meaningful with it).
     ; Otherwise this method returns false.
     ;;
    (§ method boolean signInputs(§ args ProposedTransaction propTx, KeyBag keyBag))
)

#_(ns org.bitcoinj.store #_"BlockStore"
   (:require [org.bitcoinj.core NetworkParameters Sha256Hash StoredBlock]))

;;;
 ; An implementor of BlockStore saves StoredBlock objects to disk.  Different implementations store them in
 ; different ways.  An in-memory implementation (MemoryBlockStore) exists for unit testing but real apps will
 ; want to use implementations that save to disk.
 ;
 ; A BlockStore is a map of hashes to StoredBlock.  The hash is the double digest of the Bitcoin serialization
 ; of the block header, <b>not</b> the header with the extra data as well.
 ;
 ; BlockStores are thread safe.
 ;;
#_public
(§ interface BlockStore
    ;;;
     ; Saves the given block header+extra data.  The key isn't specified explicitly as it can be calculated
     ; from the StoredBlock directly.  Can throw if there is a problem with the underlying storage layer such
     ; as running out of disk space.
     ;;
    (§ method void put(§ args StoredBlock block))
        (§ throws BlockStoreException)

    ;;;
     ; Returns the StoredBlock given a hash.  The returned values block.getHash() method will be equal to the
     ; parameter. If no such block is found, returns null.
     ;;
    (§ method StoredBlock get(§ args Sha256Hash hash))
        (§ throws BlockStoreException)

    ;;;
     ; Returns the {@link StoredBlock} that represents the top of the chain of greatest total work.  Note that
     ; this can be arbitrarily expensive, you probably should use {@link org.bitcoinj.core.BlockChain#getChainHead()}
     ; or perhaps {@link org.bitcoinj.core.BlockChain#getBestChainHeight()} which will run in constant time and
     ; not take any heavyweight locks.
     ;;
    (§ method StoredBlock getChainHead(§ args ))
        (§ throws BlockStoreException)

    ;;;
     ; Sets the {@link StoredBlock} that represents the top of the chain of greatest total work.
     ;;
    (§ method void setChainHead(§ args StoredBlock chainHead))
        (§ throws BlockStoreException)

    ;;; Closes the store. ;;
    (§ method void close(§ args ))
        (§ throws BlockStoreException)

    ;;;
     ; Get the {@link org.bitcoinj.core.NetworkParameters} of this store.
     ; @return the network params.
     ;;
    (§ method NetworkParameters getParams(§ args ))
)

#_(ns org.bitcoinj.store #_"BlockStoreException")

;;;
 ; Thrown when something goes wrong with storing a block.  Examples: out of disk space.
 ;;
#_public
(§ class BlockStoreException extends Exception
    #_public
    (§ constructor BlockStoreException(§ args String message))
    (§ block
        (§ super (§ pars message))
    )

    #_public
    (§ constructor BlockStoreException(§ args Throwable t))
    (§ block
        (§ super (§ pars t))
    )

    #_public
    (§ constructor BlockStoreException(§ args String message, Throwable t))
    (§ block
        (§ super (§ pars message, t))
    )
)

#_(ns org.bitcoinj.store #_"ChainFileLockedException")

;;;
 ; Thrown by {@link SPVBlockStore} when the process cannot gain exclusive access to the chain file.
 ;;
#_public
(§ class ChainFileLockedException extends BlockStoreException
    #_public
    (§ constructor ChainFileLockedException(§ args String message))
    (§ block
        (§ super (§ pars message))
    )

    #_public
    (§ constructor ChainFileLockedException(§ args Throwable t))
    (§ block
        (§ super (§ pars t))
    )
)

#_(ns org.bitcoinj.store #_"DatabaseFullPrunedBlockStore"
    (:import [java.io ByteArrayInputStream ByteArrayOutputStream IOException]
             [java.math BigInteger]
             [java.sql *]
             [java.util *])
    (:import [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.script Script]))

;;;
 ; <p>A generic full pruned block store for a relational database.  This generic class
 ; requires certain table structures for the block store.</p>
 ;
 ; <p>The following are the tables and field names/types that are assumed:</p>
 ;
 ; <p><br/>
 ; <b>setting</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>name</td><td>string</td></tr>
 ;     <tr><td>value</td><td>binary</td></tr>
 ; </table>
 ; </p>
 ;
 ; <p><br/>
 ; <b>headers</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>hash</td><td>binary</td></tr>
 ;     <tr><td>chainwork</td><td>binary</td></tr>
 ;     <tr><td>height</td><td>integer</td></tr>
 ;     <tr><td>header</td><td>binary</td></tr>
 ;     <tr><td>wasundoable</td><td>boolean</td></tr>
 ; </table>
 ; </p>
 ;
 ; <p><br/>
 ; <b>undoableblocks</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>hash</td><td>binary</td></tr>
 ;     <tr><td>height</td><td>integer</td></tr>
 ;     <tr><td>txoutchanges</td><td>binary</td></tr>
 ;     <tr><td>transactions</td><td>binary</td></tr>
 ; </table>
 ; </p>
 ;
 ; <p><br/>
 ; <b>openoutputs</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>hash</td><td>binary</td></tr>
 ;     <tr><td>index</td><td>integer</td></tr>
 ;     <tr><td>height</td><td>integer</td></tr>
 ;     <tr><td>value</td><td>integer</td></tr>
 ;     <tr><td>scriptbytes</td><td>binary</td></tr>
 ;     <tr><td>toaddress</td><td>string</td></tr>
 ;     <tr><td>addresstargetable</td><td>integer</td></tr>
 ;     <tr><td>coinbase</td><td>boolean</td></tr>
 ; </table>
 ; </p>
 ;
 ;;
#_public
#_abstract
(§ class DatabaseFullPrunedBlockStore implements FullPrunedBlockStore
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars DatabaseFullPrunedBlockStore.class))

    #_private
    #_static
    #_final
    (§ field String CHAIN_HEAD_SETTING                = "chainhead")
    #_private
    #_static
    #_final
    (§ field String VERIFIED_CHAIN_HEAD_SETTING       = "verifiedchainhead")
    #_private
    #_static
    #_final
    (§ field String VERSION_SETTING                   = "version")

    ;; Drop table SQL.
    #_private
    #_static
    #_final
    (§ field String DROP_SETTINGS_TABLE               = "DROP TABLE settings")
    #_private
    #_static
    #_final
    (§ field String DROP_HEADERS_TABLE                = "DROP TABLE headers")
    #_private
    #_static
    #_final
    (§ field String DROP_UNDOABLE_TABLE               = "DROP TABLE undoableblocks")
    #_private
    #_static
    #_final
    (§ field String DROP_OPEN_OUTPUT_TABLE            = "DROP TABLE openoutputs")

    ;; Queries SQL.
    #_private
    #_static
    #_final
    (§ field String SELECT_SETTINGS_SQL               = "SELECT value FROM settings WHERE name = ?")
    #_private
    #_static
    #_final
    (§ field String INSERT_SETTINGS_SQL               = "INSERT INTO settings(name, value) VALUES(?, ?)")
    #_private
    #_static
    #_final
    (§ field String UPDATE_SETTINGS_SQL               = "UPDATE settings SET value = ? WHERE name = ?")

    #_private
    #_static
    #_final
    (§ field String SELECT_HEADERS_SQL                = "SELECT chainwork, height, header, wasundoable FROM headers WHERE hash = ?")
    #_private
    #_static
    #_final
    (§ field String INSERT_HEADERS_SQL                = "INSERT INTO headers(hash, chainwork, height, header, wasundoable) VALUES(?, ?, ?, ?, ?)")
    #_private
    #_static
    #_final
    (§ field String UPDATE_HEADERS_SQL                = "UPDATE headers SET wasundoable=? WHERE hash=?")

    #_private
    #_static
    #_final
    (§ field String SELECT_UNDOABLEBLOCKS_SQL         = "SELECT txoutchanges, transactions FROM undoableblocks WHERE hash = ?")
    #_private
    #_static
    #_final
    (§ field String INSERT_UNDOABLEBLOCKS_SQL         = "INSERT INTO undoableblocks(hash, height, txoutchanges, transactions) VALUES(?, ?, ?, ?)")
    #_private
    #_static
    #_final
    (§ field String UPDATE_UNDOABLEBLOCKS_SQL         = "UPDATE undoableblocks SET txoutchanges=?, transactions=? WHERE hash = ?")
    #_private
    #_static
    #_final
    (§ field String DELETE_UNDOABLEBLOCKS_SQL         = "DELETE FROM undoableblocks WHERE height <= ?")

    #_private
    #_static
    #_final
    (§ field String SELECT_OPENOUTPUTS_SQL            = "SELECT height, value, scriptbytes, coinbase, toaddress, addresstargetable FROM openoutputs WHERE hash = ? AND index = ?")
    #_private
    #_static
    #_final
    (§ field String SELECT_OPENOUTPUTS_COUNT_SQL      = "SELECT COUNT(*) FROM openoutputs WHERE hash = ?")
    #_private
    #_static
    #_final
    (§ field String INSERT_OPENOUTPUTS_SQL            = "INSERT INTO openoutputs (hash, index, height, value, scriptbytes, toaddress, addresstargetable, coinbase) VALUES (?, ?, ?, ?, ?, ?, ?, ?)")
    #_private
    #_static
    #_final
    (§ field String DELETE_OPENOUTPUTS_SQL            = "DELETE FROM openoutputs WHERE hash = ? AND index = ?")

    ;; Dump table SQL (this is just for data sizing statistics).
    #_private
    #_static
    #_final
    (§ field String SELECT_DUMP_SETTINGS_SQL          = "SELECT name, value FROM settings")
    #_private
    #_static
    #_final
    (§ field String SELECT_DUMP_HEADERS_SQL           = "SELECT chainwork, header FROM headers")
    #_private
    #_static
    #_final
    (§ field String SELECT_DUMP_UNDOABLEBLOCKS_SQL    = "SELECT txoutchanges, transactions FROM undoableblocks")
    #_private
    #_static
    #_final
    (§ field String SELECT_DUMP_OPENOUTPUTS_SQL       = "SELECT value, scriptbytes FROM openoutputs")

    #_private
    #_static
    #_final
    (§ field String SELECT_TRANSACTION_OUTPUTS_SQL    = "SELECT hash, value, scriptbytes, height, index, coinbase, toaddress, addresstargetable FROM openoutputs where toaddress = ?")

    ;; Select the balance of an address SQL.
    #_private
    #_static
    #_final
    (§ field String SELECT_BALANCE_SQL                = "select sum(value) from openoutputs where toaddress = ?")

    ;; Tables exist SQL.
    #_private
    #_static
    #_final
    (§ field String SELECT_CHECK_TABLES_EXIST_SQL     = "SELECT * FROM settings WHERE 1 = 2")

    ;; Compatibility SQL.
    #_private
    #_static
    #_final
    (§ field String SELECT_COMPATIBILITY_COINBASE_SQL = "SELECT coinbase FROM openoutputs WHERE 1 = 2")

    #_protected
    (§ field Sha256Hash chainHeadHash)
    #_protected
    (§ field StoredBlock chainHeadBlock)
    #_protected
    (§ field Sha256Hash verifiedChainHeadHash)
    #_protected
    (§ field StoredBlock verifiedChainHeadBlock)
    #_protected
    (§ field NetworkParameters params)
    #_protected
    (§ field ThreadLocal<Connection> conn)
    #_protected
    (§ field List<Connection> allConnections)
    #_protected
    (§ field String connectionURL)
    #_protected
    (§ field int fullStoreDepth)
    #_protected
    (§ field String username)
    #_protected
    (§ field String password)
    #_protected
    (§ field String schemaName)

    ;;;
     ; <p>Create a new DatabaseFullPrunedBlockStore, using the full connection URL instead of a hostname and password,
     ; and optionally allowing a schema to be specified.</p>
     ;
     ; @param params A copy of the NetworkParameters used.
     ; @param connectionURL The jdbc url to connect to the database.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param username The database username.
     ; @param password The password to the database.
     ; @param schemaName The name of the schema to put the tables in.  May be null if no schema is being used.
     ; @throws BlockStoreException if there is a failure to connect and/or initialise the database.
     ;;
    #_public
    (§ constructor DatabaseFullPrunedBlockStore(§ args NetworkParameters params, String connectionURL, int fullStoreDepth, #_nilable String username, #_nilable String password, #_nilable String schemaName))
        (§ throws BlockStoreException)
    (§ block
        (§ ass this.params = params)
        (§ ass this.fullStoreDepth = fullStoreDepth)
        (§ ass this.connectionURL = connectionURL)
        (§ ass this.schemaName = schemaName)
        (§ ass this.username = username)
        (§ ass this.password = password)
        (§ ass this.conn = new ThreadLocal<>(§ pars ))
        (§ ass this.allConnections = new LinkedList<>(§ pars ))

        (§ try )
        (§ block
            (§ call Class.forName(§ pars getDatabaseDriverClass(§ pars )))
            (§ call log.info(§ pars getDatabaseDriverClass(§ pars ) + " loaded. "))
        )
        (§ catch (§ args ClassNotFoundException e))
        (§ block
            (§ call log.error(§ pars "check CLASSPATH for database driver jar ", e))
        )

        (§ call maybeConnect(§ pars ))

        (§ try )
        (§ block
            ;; Create tables if needed.
            (§ if (§ expr !tablesExist(§ pars )))
            (§ block
                (§ call createTables(§ pars ))
            )
            (§ else )
            (§ block
                (§ call checkCompatibility(§ pars ))
            )
            (§ call initFromDatabase(§ pars ))
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
    )

    ;;;
     ; Get the database driver class, i.e <i>org.postgresql.Driver</i>.
     ; @return the fully qualified database driver class.
     ;;
    #_protected
    #_abstract
    (§ method String getDatabaseDriverClass(§ args ))

    ;;;
     ; Get the SQL statements that create the schema (DDL).
     ; @return the list of SQL statements.
     ;;
    #_protected
    #_abstract
    (§ method List<String> getCreateSchemeSQL(§ args ))

    ;;;
     ; Get the SQL statements that create the tables (DDL).
     ; @return the list of SQL statements.
     ;;
    #_protected
    #_abstract
    (§ method List<String> getCreateTablesSQL(§ args ))

    ;;;
     ; Get the SQL statements that create the indexes (DDL).
     ; @return the list of SQL statements.
     ;;
    #_protected
    #_abstract
    (§ method List<String> getCreateIndexesSQL(§ args ))

    ;;;
     ; Get the database specific error code that indicated a duplicate key error when inserting a record.
     ; <p>This is the code returned by {@link java.sql.SQLException#getSQLState()}.</p>
     ; @return the database duplicate error code.
     ;;
    #_protected
    #_abstract
    (§ method String getDuplicateKeyErrorCode(§ args ))

    ;;;
     ; Get the SQL to select the total balance for a given address.
     ; @return the SQL prepared statement.
     ;;
    #_protected
    (§ method String getBalanceSelectSQL(§ args ))
    (§ block
        (§ return SELECT_BALANCE_SQL)
    )

    ;;;
     ; Get the SQL statement that checks if tables exist.
     ; @return the SQL prepared statement.
     ;;
    #_protected
    (§ method String getTablesExistSQL(§ args ))
    (§ block
        (§ return SELECT_CHECK_TABLES_EXIST_SQL)
    )

    ;;;
     ; Get the SQL statements to check if the database is compatible.
     ; @return the SQL prepared statements.
     ;;
    #_protected
    (§ method List<String> getCompatibilitySQL(§ args ))
    (§ block
        (§ var List<String> sql = new ArrayList<>(§ pars ))
        (§ call sql.add(§ pars SELECT_COMPATIBILITY_COINBASE_SQL))
        (§ return sql)
    )

    ;;;
     ; Get the SQL to select the transaction outputs for a given address.
     ; @return the SQL prepared statement.
     ;;
    #_protected
    (§ method String getTransactionOutputSelectSQL(§ args ))
    (§ block
        (§ return SELECT_TRANSACTION_OUTPUTS_SQL)
    )

    ;;;
     ; Get the SQL to drop all the tables (DDL).
     ; @return the SQL drop statements.
     ;;
    #_protected
    (§ method List<String> getDropTablesSQL(§ args ))
    (§ block
        (§ var List<String> sql = new ArrayList<>(§ pars ))
        (§ call sql.add(§ pars DROP_SETTINGS_TABLE))
        (§ call sql.add(§ pars DROP_HEADERS_TABLE))
        (§ call sql.add(§ pars DROP_UNDOABLE_TABLE))
        (§ call sql.add(§ pars DROP_OPEN_OUTPUT_TABLE))
        (§ return sql)
    )

    ;;;
     ; Get the SQL to select a setting value.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method String getSelectSettingsSQL(§ args ))
    (§ block
        (§ return SELECT_SETTINGS_SQL)
    )

    ;;;
     ; Get the SQL to insert a settings record.
     ; @return the SQL insert statement.
     ;;
    #_protected
    (§ method String getInsertSettingsSQL(§ args ))
    (§ block
        (§ return INSERT_SETTINGS_SQL)
    )

    ;;;
     ; Get the SQL to update a setting value.
     ; @return the SQL update statement.
     ;;
    #_protected
    (§ method String getUpdateSettingsSLQ(§ args ))
    (§ block
        (§ return UPDATE_SETTINGS_SQL)
    )

    ;;;
     ; Get the SQL to select a headers record.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method String getSelectHeadersSQL(§ args ))
    (§ block
        (§ return SELECT_HEADERS_SQL)
    )

    ;;;
     ; Get the SQL to insert a headers record.
     ; @return the SQL insert statement.
     ;;
    #_protected
    (§ method String getInsertHeadersSQL(§ args ))
    (§ block
        (§ return INSERT_HEADERS_SQL)
    )

    ;;;
     ; Get the SQL to update a headers record.
     ; @return the SQL update statement.
     ;;
    #_protected
    (§ method String getUpdateHeadersSQL(§ args ))
    (§ block
        (§ return UPDATE_HEADERS_SQL)
    )

    ;;;
     ; Get the SQL to select an undoableblocks record.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method String getSelectUndoableBlocksSQL(§ args ))
    (§ block
        (§ return SELECT_UNDOABLEBLOCKS_SQL)
    )

    ;;;
     ; Get the SQL to insert a undoableblocks record.
     ; @return the SQL insert statement.
     ;;
    #_protected
    (§ method String getInsertUndoableBlocksSQL(§ args ))
    (§ block
        (§ return INSERT_UNDOABLEBLOCKS_SQL)
    )

    ;;;
     ; Get the SQL to update a undoableblocks record.
     ; @return the SQL update statement.
     ;;
    #_protected
    (§ method String getUpdateUndoableBlocksSQL(§ args ))
    (§ block
        (§ return UPDATE_UNDOABLEBLOCKS_SQL)
    )

    ;;;
     ; Get the SQL to delete a undoableblocks record.
     ; @return the SQL delete statement.
     ;;
    #_protected
    (§ method String getDeleteUndoableBlocksSQL(§ args ))
    (§ block
        (§ return DELETE_UNDOABLEBLOCKS_SQL)
    )

    ;;;
     ; Get the SQL to select a openoutputs record.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method String getSelectOpenoutputsSQL(§ args ))
    (§ block
        (§ return SELECT_OPENOUTPUTS_SQL)
    )

    ;;;
     ; Get the SQL to select count of openoutputs.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method String getSelectOpenoutputsCountSQL(§ args ))
    (§ block
        (§ return SELECT_OPENOUTPUTS_COUNT_SQL)
    )

    ;;;
     ; Get the SQL to insert a openoutputs record.
     ; @return the SQL insert statement.
     ;;
    #_protected
    (§ method String getInsertOpenoutputsSQL(§ args ))
    (§ block
        (§ return INSERT_OPENOUTPUTS_SQL)
    )

    ;;;
     ; Get the SQL to delete a openoutputs record.
     ; @return the SQL delete statement.
     ;;
    #_protected
    (§ method String getDeleteOpenoutputsSQL(§ args ))
    (§ block
        (§ return DELETE_OPENOUTPUTS_SQL)
    )

    ;;;
     ; Get the SQL to select the setting dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method String getSelectSettingsDumpSQL(§ args ))
    (§ block
        (§ return SELECT_DUMP_SETTINGS_SQL)
    )

    ;;;
     ; Get the SQL to select the headers dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method String getSelectHeadersDumpSQL(§ args ))
    (§ block
        (§ return SELECT_DUMP_HEADERS_SQL)
    )

    ;;;
     ; Get the SQL to select the undoableblocks dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method String getSelectUndoableblocksDumpSQL(§ args ))
    (§ block
        (§ return SELECT_DUMP_UNDOABLEBLOCKS_SQL)
    )

    ;;;
     ; Get the SQL to select the openoutouts dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method String getSelectopenoutputsDumpSQL(§ args ))
    (§ block
        (§ return SELECT_DUMP_OPENOUTPUTS_SQL)
    )

    ;;;
     ; <p>If there isn't a connection on the {@link ThreadLocal} then create and store it.</p>
     ; <p>This will also automatically set up the schema if it does not exist within the DB.</p>
     ; @throws BlockStoreException if successful connection to the DB couldn't be made.
     ;;
    #_protected
    #_synchronized
    #_final
    (§ method void maybeConnect(§ args ))
        (§ throws BlockStoreException)
    (§ block
        (§ try )
        (§ block
            (§ if (§ expr conn.get(§ pars ) != nil && !conn.get(§ pars ).isClosed(§ pars )))
            (§ block
                (§ return )
            )

            (§ if (§ expr username == nil || password == nil))
            (§ block
                (§ call conn.set(§ pars DriverManager.getConnection(§ pars connectionURL)))
            )
            (§ else )
            (§ block
                (§ var Properties props = new Properties(§ pars ))
                (§ call props.setProperty(§ pars "user", this.username))
                (§ call props.setProperty(§ pars "password", this.password))
                (§ call conn.set(§ pars DriverManager.getConnection(§ pars connectionURL, props)))
            )
            (§ call allConnections.add(§ pars conn.get(§ pars )))
            (§ var Connection connection = conn.get(§ pars ))
            ;; Set the schema if one is needed.
            (§ if (§ expr schemaName != nil))
            (§ block
                (§ var Statement s = connection.createStatement(§ pars ))
                (§ for (§ var String sql) :for (§ expr getCreateSchemeSQL(§ pars )))
                (§ block
                    (§ call s.execute(§ pars sql))
                )
            )
            (§ call log.info(§ pars "Made a new connection to database " + connectionURL))
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
    )

    #_override
    #_public
    #_synchronized
    (§ method void close(§ args ))
    (§ block
        (§ for (§ var Connection conn) :for (§ expr allConnections))
        (§ block
            (§ try )
            (§ block
                (§ if (§ expr !conn.getAutoCommit(§ pars )))
                (§ block
                    (§ call conn.rollback(§ pars ))
                )
                (§ call conn.close(§ pars ))
                (§ if (§ expr conn == this.conn.get(§ pars )))
                (§ block
                    (§ call this.conn.set(§ pars nil))
                )
            )
            (§ catch (§ args SQLException e))
            (§ block
                (§ throw (§ new RuntimeException(§ pars e)))
            )
        )
        (§ call allConnections.clear(§ pars ))
    )

    ;;;
     ; <p>Check if a tables exists within the database.</p>
     ;
     ; <p>This specifically checks for the 'settings' table and
     ; if it exists makes an assumption that the rest of the data
     ; structures are present.</p>
     ;
     ; @return if the tables exist.
     ; @throws java.sql.SQLException
     ;;
    #_private
    (§ method boolean tablesExist(§ args ))
        (§ throws SQLException)
    (§ block
        (§ var PreparedStatement ps = nil)
        (§ try )
        (§ block
            (§ ass ps = conn.get(§ pars ).prepareStatement(§ pars getTablesExistSQL(§ pars )))
            (§ var ResultSet results = ps.executeQuery(§ pars ))
            (§ call results.close(§ pars ))
            (§ return true)
        )
        (§ catch (§ args SQLException _))
        (§ block
            (§ return false)
        )
        (§ finally )
        (§ block
            (§ if (§ expr ps != nil && !ps.isClosed(§ pars )))
            (§ block
                (§ call ps.close(§ pars ))
            )
        )
    )

    ;;;
     ; Check that the database is compatible with this version of the {@link DatabaseFullPrunedBlockStore}.
     ; @throws BlockStoreException if the database is not compatible.
     ;;
    #_private
    (§ method void checkCompatibility(§ args ))
        (§ throws SQLException, BlockStoreException)
    (§ block
        (§ for (§ var String sql) :for (§ expr getCompatibilitySQL(§ pars )))
        (§ block
            (§ var PreparedStatement ps = nil)
            (§ try )
            (§ block
                (§ ass ps = conn.get(§ pars ).prepareStatement(§ pars sql))
                (§ var ResultSet results = ps.executeQuery(§ pars ))
                (§ call results.close(§ pars ))
            )
            (§ catch (§ args SQLException e))
            (§ block
                (§ throw (§ new BlockStoreException(§ pars "Database block store is not compatible with the current release.  See bitcoinj release notes for further information: " + e.getMessage(§ pars ))))
            )
            (§ finally )
            (§ block
                (§ if (§ expr ps != nil && !ps.isClosed(§ pars )))
                (§ block
                    (§ call ps.close(§ pars ))
                )
            )
        )
    )

    ;;;
     ; Create the tables in the database.
     ; @throws java.sql.SQLException if there is a database error.
     ; @throws BlockStoreException if the block store could not be created.
     ;;
    #_private
    (§ method void createTables(§ args ))
        (§ throws SQLException, BlockStoreException)
    (§ block
        (§ var Statement s = conn.get(§ pars ).createStatement(§ pars ))
        ;; Create all the database tables.
        (§ for (§ var String sql) :for (§ expr getCreateTablesSQL(§ pars )))
        (§ block
            (§ if (§ expr log.isDebugEnabled(§ pars )))
            (§ block
                (§ call log.debug(§ pars "DatabaseFullPrunedBlockStore : CREATE table [SQL= {0}]", sql))
            )
            (§ call s.executeUpdate(§ pars sql))
        )
        ;; Create all the database indexes.
        (§ for (§ var String sql) :for (§ expr getCreateIndexesSQL(§ pars )))
        (§ block
            (§ if (§ expr log.isDebugEnabled(§ pars )))
            (§ block
                (§ call log.debug(§ pars "DatabaseFullPrunedBlockStore : CREATE index [SQL= {0}]", sql))
            )
            (§ call s.executeUpdate(§ pars sql))
        )
        (§ call s.close(§ pars ))

        ;; Insert the initial settings for this store.
        (§ var PreparedStatement ps = conn.get(§ pars ).prepareStatement(§ pars getInsertSettingsSQL(§ pars )))
        (§ call ps.setString(§ pars 1, CHAIN_HEAD_SETTING))
        (§ call ps.setNull(§ pars 2, Types.BINARY))
        (§ call ps.execute(§ pars ))
        (§ call ps.setString(§ pars 1, VERIFIED_CHAIN_HEAD_SETTING))
        (§ call ps.setNull(§ pars 2, Types.BINARY))
        (§ call ps.execute(§ pars ))
        (§ call ps.setString(§ pars 1, VERSION_SETTING))
        (§ call ps.setBytes(§ pars 2, "03".getBytes(§ pars )))
        (§ call ps.execute(§ pars ))
        (§ call ps.close(§ pars ))

        (§ call createNewStore(§ pars params))
    )

    ;;;
     ; Create a new store for the given {@link org.bitcoinj.core.NetworkParameters}.
     ; @param params The network.
     ; @throws BlockStoreException if the store couldn't be created.
     ;;
    #_private
    (§ method void createNewStore(§ args NetworkParameters params))
        (§ throws BlockStoreException)
    (§ block
        (§ try )
        (§ block
            ;; Set up the genesis block.  When we start out fresh, it is by definition the top of the chain.
            (§ var StoredBlock storedGenesisHeader = new StoredBlock(§ pars params.getGenesisBlock(§ pars ).cloneAsHeader(§ pars ), params.getGenesisBlock(§ pars ).getWork(§ pars ), 0))
            ;; The coinbase in the genesis block is not spendable.  This is because of how Bitcoin Core inits
            ;; its database - the genesis transaction isn't actually in the db so its spent flags can never be updated.
            (§ var List<Transaction> genesisTransactions = Lists.newLinkedList(§ pars ))
            (§ var StoredUndoableBlock storedGenesis = new StoredUndoableBlock(§ pars params.getGenesisBlock(§ pars ).getHash(§ pars ), genesisTransactions))
            (§ call put(§ pars storedGenesisHeader, storedGenesis))
            (§ call setChainHead(§ pars storedGenesisHeader))
            (§ call setVerifiedChainHead(§ pars storedGenesisHeader))
        )
        (§ catch (§ args VerificationException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
    )

    ;;;
     ; Initialise the store state from the database.
     ; @throws java.sql.SQLException if there is a database error.
     ; @throws BlockStoreException if there is a block store error.
     ;;
    #_private
    (§ method void initFromDatabase(§ args ))
        (§ throws SQLException, BlockStoreException)
    (§ block
        (§ var PreparedStatement ps = conn.get(§ pars ).prepareStatement(§ pars getSelectSettingsSQL(§ pars )))
        (§ var ResultSet rs)
        (§ call ps.setString(§ pars 1, CHAIN_HEAD_SETTING))
        (§ ass rs = ps.executeQuery(§ pars ))
        (§ if (§ expr !rs.next(§ pars )))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars "corrupt database block store - no chain head pointer")))
        )

        (§ var Sha256Hash hash = Sha256Hash.wrap(§ pars rs.getBytes(§ pars 1)))
        (§ call rs.close(§ pars ))
        (§ ass this.chainHeadBlock = get(§ pars hash))
        (§ ass this.chainHeadHash = hash)
        (§ if (§ expr this.chainHeadBlock == nil))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars "corrupt database block store - head block not found")))
        )

        (§ call ps.setString(§ pars 1, VERIFIED_CHAIN_HEAD_SETTING))
        (§ ass rs = ps.executeQuery(§ pars ))
        (§ if (§ expr !rs.next(§ pars )))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars "corrupt database block store - no verified chain head pointer")))
        )

        (§ ass hash = Sha256Hash.wrap(§ pars rs.getBytes(§ pars 1)))
        (§ call rs.close(§ pars ))
        (§ call ps.close(§ pars ))
        (§ ass this.verifiedChainHeadBlock = get(§ pars hash))
        (§ ass this.verifiedChainHeadHash = hash)
        (§ if (§ expr this.verifiedChainHeadBlock == nil))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars "corrupt database block store - verified head block not found")))
        )
    )

    #_protected
    (§ method void putUpdateStoredBlock(§ args StoredBlock storedBlock, boolean wasUndoable))
        (§ throws SQLException)
    (§ block
        (§ try )
        (§ block
            (§ var PreparedStatement ps = conn.get(§ pars ).prepareStatement(§ pars getInsertHeadersSQL(§ pars )))
            ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
            (§ var byte[] hashBytes = new byte[28])
            (§ call System.arraycopy(§ pars storedBlock.getHeader(§ pars ).getHash(§ pars ).getBytes(§ pars ), 4, hashBytes, 0, 28))
            (§ call ps.setBytes(§ pars 1, hashBytes))
            (§ call ps.setBytes(§ pars 2, storedBlock.getChainWork(§ pars ).toByteArray(§ pars )))
            (§ call ps.setInt(§ pars 3, storedBlock.getHeight(§ pars )))
            (§ call ps.setBytes(§ pars 4, storedBlock.getHeader(§ pars ).cloneAsHeader(§ pars ).unsafeBitcoinSerialize(§ pars )))
            (§ call ps.setBoolean(§ pars 5, wasUndoable))
            (§ call ps.executeUpdate(§ pars ))
            (§ call ps.close(§ pars ))
        )
        (§ catch (§ args SQLException e))
        (§ block
            ;; It is possible we try to add a duplicate StoredBlock if we upgraded.
            ;; In that case, we just update the entry to mark it wasUndoable.
            (§ if (§ expr !(§ expr e.getSQLState(§ pars ).equals(§ pars getDuplicateKeyErrorCode(§ pars ))) || !wasUndoable))
            (§ block
                (§ throw e)
            )

            (§ var PreparedStatement ps = conn.get(§ pars ).prepareStatement(§ pars getUpdateHeadersSQL(§ pars )))
            (§ call ps.setBoolean(§ pars 1, true))
            ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
            (§ var byte[] hashBytes = new byte[28])
            (§ call System.arraycopy(§ pars storedBlock.getHeader(§ pars ).getHash(§ pars ).getBytes(§ pars ), 4, hashBytes, 0, 28))
            (§ call ps.setBytes(§ pars 2, hashBytes))
            (§ call ps.executeUpdate(§ pars ))
            (§ call ps.close(§ pars ))
        )
    )

    #_override
    #_public
    (§ method void put(§ args StoredBlock storedBlock))
        (§ throws BlockStoreException)
    (§ block
        (§ call maybeConnect(§ pars ))
        (§ try )
        (§ block
            (§ call putUpdateStoredBlock(§ pars storedBlock, false))
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
    )

    #_override
    #_public
    (§ method void put(§ args StoredBlock storedBlock, StoredUndoableBlock undoableBlock))
        (§ throws BlockStoreException)
    (§ block
        (§ call maybeConnect(§ pars ))
        ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
        (§ var byte[] hashBytes = new byte[28])
        (§ call System.arraycopy(§ pars storedBlock.getHeader(§ pars ).getHash(§ pars ).getBytes(§ pars ), 4, hashBytes, 0, 28))
        (§ var int height = storedBlock.getHeight(§ pars ))
        (§ var byte[] transactions = nil)
        (§ var byte[] txOutChanges = nil)
        (§ try )
        (§ block
            (§ var ByteArrayOutputStream bos = new ByteArrayOutputStream(§ pars ))
            (§ if (§ expr undoableBlock.getTxOutChanges(§ pars ) != nil))
            (§ block
                (§ call undoableBlock.getTxOutChanges(§ pars ).serializeToStream(§ pars bos))
                (§ ass txOutChanges = bos.toByteArray(§ pars ))
            )
            (§ else )
            (§ block
                (§ var int numTxn = undoableBlock.getTransactions(§ pars ).size(§ pars ))
                (§ call bos.write(§ pars 0xff & numTxn))
                (§ call bos.write(§ pars 0xff & (§ expr numTxn >> 8)))
                (§ call bos.write(§ pars 0xff & (§ expr numTxn >> 16)))
                (§ call bos.write(§ pars 0xff & (§ expr numTxn >> 24)))
                (§ for (§ var Transaction tx) :for (§ expr undoableBlock.getTransactions(§ pars )))
                (§ block
                    (§ call tx.bitcoinSerialize(§ pars bos))
                )
                (§ ass transactions = bos.toByteArray(§ pars ))
            )
            (§ call bos.close(§ pars ))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )

        (§ try )
        (§ block
            (§ try )
            (§ block
                (§ var PreparedStatement ps = conn.get(§ pars ).prepareStatement(§ pars getInsertUndoableBlocksSQL(§ pars )))
                (§ call ps.setBytes(§ pars 1, hashBytes))
                (§ call ps.setInt(§ pars 2, height))
                (§ if (§ expr transactions == nil))
                (§ block
                    (§ call ps.setBytes(§ pars 3, txOutChanges))
                    (§ call ps.setNull(§ pars 4, Types.BINARY))
                )
                (§ else )
                (§ block
                    (§ call ps.setNull(§ pars 3, Types.BINARY))
                    (§ call ps.setBytes(§ pars 4, transactions))
                )
                (§ call ps.executeUpdate(§ pars ))
                (§ call ps.close(§ pars ))
                (§ try )
                (§ block
                    (§ call putUpdateStoredBlock(§ pars storedBlock, true))
                )
                (§ catch (§ args SQLException e))
                (§ block
                    (§ throw (§ new BlockStoreException(§ pars e)))
                )
            )
            (§ catch (§ args SQLException e))
            (§ block
                (§ if (§ expr !e.getSQLState(§ pars ).equals(§ pars getDuplicateKeyErrorCode(§ pars ))))
                (§ block
                    (§ throw (§ new BlockStoreException(§ pars e)))
                )

                ;; There is probably an update-or-insert statement, but it wasn't obvious from the docs.
                (§ var PreparedStatement ps = conn.get(§ pars ).prepareStatement(§ pars getUpdateUndoableBlocksSQL(§ pars )))
                (§ call ps.setBytes(§ pars 3, hashBytes))
                (§ if (§ expr transactions == nil))
                (§ block
                    (§ call ps.setBytes(§ pars 1, txOutChanges))
                    (§ call ps.setNull(§ pars 2, Types.BINARY))
                )
                (§ else )
                (§ block
                    (§ call ps.setNull(§ pars 1, Types.BINARY))
                    (§ call ps.setBytes(§ pars 2, transactions))
                )
                (§ call ps.executeUpdate(§ pars ))
                (§ call ps.close(§ pars ))
            )
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
    )

    #_public
    (§ method StoredBlock get(§ args Sha256Hash hash, boolean wasUndoableOnly))
        (§ throws BlockStoreException)
    (§ block
        ;; Optimize for chain head.
        (§ if (§ expr chainHeadHash != nil && chainHeadHash.equals(§ pars hash)))
        (§ block
            (§ return chainHeadBlock)
        )

        (§ if (§ expr verifiedChainHeadHash != nil && verifiedChainHeadHash.equals(§ pars hash)))
        (§ block
            (§ return verifiedChainHeadBlock)
        )

        (§ call maybeConnect(§ pars ))
        (§ var PreparedStatement ps = nil)
        (§ try )
        (§ block
            (§ ass ps = conn.get(§ pars ).prepareStatement(§ pars getSelectHeadersSQL(§ pars )))
            ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
            (§ var byte[] hashBytes = new byte[28])
            (§ call System.arraycopy(§ pars hash.getBytes(§ pars ), 4, hashBytes, 0, 28))
            (§ call ps.setBytes(§ pars 1, hashBytes))
            (§ var ResultSet results = ps.executeQuery(§ pars ))
            (§ if (§ expr !results.next(§ pars )))
            (§ block
                (§ return nil)
            )

            ;; Parse it.
            (§ if (§ expr wasUndoableOnly && !results.getBoolean(§ pars 4)))
            (§ block
                (§ return nil)
            )

            (§ var BigInteger chainWork = new BigInteger(§ pars results.getBytes(§ pars 1)))
            (§ var int height = results.getInt(§ pars 2))
            (§ var Block b = params.getDefaultSerializer(§ pars ).makeBlock(§ pars results.getBytes(§ pars 3)))
            (§ call b.verifyHeader(§ pars ))
            (§ var StoredBlock stored = new StoredBlock(§ pars b, chainWork, height))
            (§ return stored)
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
        (§ catch (§ args ProtocolException e))
        (§ block
            ;; Corrupted database.
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
        (§ catch (§ args VerificationException e))
        (§ block
            ;; Should not be able to happen unless the database contains bad blocks.
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
        (§ finally )
        (§ block
            (§ if (§ expr ps != nil))
            (§ block
                (§ try )
                (§ block
                    (§ call ps.close(§ pars ))
                )
                (§ catch (§ args SQLException _))
                (§ block
                    (§ throw (§ new BlockStoreException(§ pars "Failed to close PreparedStatement")))
                )
            )
        )
    )

    #_override
    #_public
    (§ method StoredBlock get(§ args Sha256Hash hash))
        (§ throws BlockStoreException)
    (§ block
        (§ return get(§ pars hash, false))
    )

    #_override
    #_public
    (§ method StoredBlock getOnceUndoableStoredBlock(§ args Sha256Hash hash))
        (§ throws BlockStoreException)
    (§ block
        (§ return get(§ pars hash, true))
    )

    #_override
    #_public
    (§ method StoredUndoableBlock getUndoBlock(§ args Sha256Hash hash))
        (§ throws BlockStoreException)
    (§ block
        (§ call maybeConnect(§ pars ))
        (§ var PreparedStatement ps = nil)
        (§ try )
        (§ block
            (§ ass ps = conn.get(§ pars ).prepareStatement(§ pars getSelectUndoableBlocksSQL(§ pars )))
            ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.

            (§ var byte[] hashBytes = new byte[28])
            (§ call System.arraycopy(§ pars hash.getBytes(§ pars ), 4, hashBytes, 0, 28))
            (§ call ps.setBytes(§ pars 1, hashBytes))
            (§ var ResultSet results = ps.executeQuery(§ pars ))
            (§ if (§ expr !results.next(§ pars )))
            (§ block
                (§ return nil)
            )

            ;; Parse it.
            (§ var byte[] txOutChanges = results.getBytes(§ pars 1))
            (§ var byte[] transactions = results.getBytes(§ pars 2))
            (§ var StoredUndoableBlock block)
            (§ if (§ expr txOutChanges == nil))
            (§ block
                (§ var int numTxn = (§ expr (§ expr transactions[0] & 0xff) | (§ expr (§ expr transactions[1] & 0xff) << 8) | (§ expr (§ expr transactions[2] & 0xff) << 16) | (§ expr (§ expr transactions[3] & 0xff) << 24)))
                (§ var int offset = 4)
                (§ var List<Transaction> transactionList = new LinkedList<>(§ pars ))
                (§ for (§ var int i = 0) :for (§ expr i < numTxn) :for (§ ass i = i + 1))
                (§ block
                    (§ var Transaction tx = params.getDefaultSerializer(§ pars ).makeTransaction(§ pars transactions, offset))
                    (§ call transactionList.add(§ pars tx))
                    (§ ass offset = offset + tx.getMessageSize(§ pars ))
                )
                (§ ass block = new StoredUndoableBlock(§ pars hash, transactionList))
            )
            (§ else )
            (§ block
                (§ var TransactionOutputChanges outChangesObject = new TransactionOutputChanges(§ pars (§ new ByteArrayInputStream(§ pars txOutChanges))))
                (§ ass block = new StoredUndoableBlock(§ pars hash, outChangesObject))
            )
            (§ return block)
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
        (§ catch (§ args NullPointerException e))
        (§ block
            ;; Corrupted database.
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
        (§ catch (§ args ClassCastException e))
        (§ block
            ;; Corrupted database.
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
        (§ catch (§ args ProtocolException e))
        (§ block
            ;; Corrupted database.
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
        (§ catch (§ args IOException e))
        (§ block
            ;; Corrupted database.
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
        (§ finally )
        (§ block
            (§ if (§ expr ps != nil))
            (§ block
                (§ try )
                (§ block
                    (§ call ps.close(§ pars ))
                )
                (§ catch (§ args SQLException _))
                (§ block
                    (§ throw (§ new BlockStoreException(§ pars "Failed to close PreparedStatement")))
                )
            )
        )
    )

    #_override
    #_public
    (§ method StoredBlock getChainHead(§ args ))
        (§ throws BlockStoreException)
    (§ block
        (§ return chainHeadBlock)
    )

    #_override
    #_public
    (§ method void setChainHead(§ args StoredBlock chainHead))
        (§ throws BlockStoreException)
    (§ block
        (§ var Sha256Hash hash = chainHead.getHeader(§ pars ).getHash(§ pars ))
        (§ ass this.chainHeadHash = hash)
        (§ ass this.chainHeadBlock = chainHead)
        (§ call maybeConnect(§ pars ))
        (§ try )
        (§ block
            (§ var PreparedStatement ps = conn.get(§ pars ).prepareStatement(§ pars getUpdateSettingsSLQ(§ pars )))
            (§ call ps.setString(§ pars 2, CHAIN_HEAD_SETTING))
            (§ call ps.setBytes(§ pars 1, hash.getBytes(§ pars )))
            (§ call ps.executeUpdate(§ pars ))
            (§ call ps.close(§ pars ))
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
    )

    #_override
    #_public
    (§ method StoredBlock getVerifiedChainHead(§ args ))
        (§ throws BlockStoreException)
    (§ block
        (§ return verifiedChainHeadBlock)
    )

    #_override
    #_public
    (§ method void setVerifiedChainHead(§ args StoredBlock chainHead))
        (§ throws BlockStoreException)
    (§ block
        (§ var Sha256Hash hash = chainHead.getHeader(§ pars ).getHash(§ pars ))
        (§ ass this.verifiedChainHeadHash = hash)
        (§ ass this.verifiedChainHeadBlock = chainHead)
        (§ call maybeConnect(§ pars ))
        (§ try )
        (§ block
            (§ var PreparedStatement ps = conn.get(§ pars ).prepareStatement(§ pars getUpdateSettingsSLQ(§ pars )))
            (§ call ps.setString(§ pars 2, VERIFIED_CHAIN_HEAD_SETTING))
            (§ call ps.setBytes(§ pars 1, hash.getBytes(§ pars )))
            (§ call ps.executeUpdate(§ pars ))
            (§ call ps.close(§ pars ))
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
        (§ if (§ expr this.chainHeadBlock.getHeight(§ pars ) < chainHead.getHeight(§ pars )))
        (§ block
            (§ call setChainHead(§ pars chainHead))
        )
        (§ call removeUndoableBlocksWhereHeightIsLessThan(§ pars chainHead.getHeight(§ pars ) - fullStoreDepth))
    )

    #_private
    (§ method void removeUndoableBlocksWhereHeightIsLessThan(§ args int height))
        (§ throws BlockStoreException)
    (§ block
        (§ try )
        (§ block
            (§ var PreparedStatement ps = conn.get(§ pars ).prepareStatement(§ pars getDeleteUndoableBlocksSQL(§ pars )))
            (§ call ps.setInt(§ pars 1, height))
            (§ if (§ expr log.isDebugEnabled(§ pars )))
            (§ block
                (§ call log.debug(§ pars "Deleting undoable undoable block with height <= " + height))
            )
            (§ call ps.executeUpdate(§ pars ))
            (§ call ps.close(§ pars ))
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
    )

    #_override
    #_public
    (§ method UTXO getTransactionOutput(§ args Sha256Hash hash, long index))
        (§ throws BlockStoreException)
    (§ block
        (§ call maybeConnect(§ pars ))
        (§ var PreparedStatement ps = nil)
        (§ try )
        (§ block
            (§ ass ps = conn.get(§ pars ).prepareStatement(§ pars getSelectOpenoutputsSQL(§ pars )))
            (§ call ps.setBytes(§ pars 1, hash.getBytes(§ pars )))
            ;; index is actually an unsigned int
            (§ call ps.setInt(§ pars 2, (§ cast int)index))
            (§ var ResultSet results = ps.executeQuery(§ pars ))
            (§ if (§ expr !results.next(§ pars )))
            (§ block
                (§ return nil)
            )

            ;; Parse it.
            (§ var int height = results.getInt(§ pars 1))
            (§ var Coin value = Coin.valueOf(§ pars results.getLong(§ pars 2)))
            (§ var byte[] scriptBytes = results.getBytes(§ pars 3))
            (§ var boolean coinbase = results.getBoolean(§ pars 4))
            (§ var String address = results.getString(§ pars 5))
            (§ return (§ new UTXO(§ pars hash, index, value, height, coinbase, new Script(§ pars scriptBytes), address)))
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
        (§ finally )
        (§ block
            (§ if (§ expr ps != nil))
            (§ block
                (§ try )
                (§ block
                    (§ call ps.close(§ pars ))
                )
                (§ catch (§ args SQLException _))
                (§ block
                    (§ throw (§ new BlockStoreException(§ pars "Failed to close PreparedStatement")))
                )
            )
        )
    )

    #_override
    #_public
    (§ method void addUnspentTransactionOutput(§ args UTXO out))
        (§ throws BlockStoreException)
    (§ block
        (§ call maybeConnect(§ pars ))
        (§ var PreparedStatement ps = nil)
        (§ try )
        (§ block
            (§ ass ps = conn.get(§ pars ).prepareStatement(§ pars getInsertOpenoutputsSQL(§ pars )))
            (§ call ps.setBytes(§ pars 1, out.getHash(§ pars ).getBytes(§ pars )))
            ;; index is actually an unsigned int
            (§ call ps.setInt(§ pars 2, (§ cast int)out.getIndex(§ pars )))
            (§ call ps.setInt(§ pars 3, out.getHeight(§ pars )))
            (§ call ps.setLong(§ pars 4, out.getValue(§ pars ).value))
            (§ call ps.setBytes(§ pars 5, out.getScript(§ pars ).getProgram(§ pars )))
            (§ call ps.setString(§ pars 6, out.getAddress(§ pars )))
            (§ call ps.setInt(§ pars 7, out.getScript(§ pars ).getScriptType(§ pars ).ordinal(§ pars )))
            (§ call ps.setBoolean(§ pars 8, out.isCoinbase(§ pars )))
            (§ call ps.executeUpdate(§ pars ))
            (§ call ps.close(§ pars ))
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ if (§ expr !(§ expr e.getSQLState(§ pars ).equals(§ pars getDuplicateKeyErrorCode(§ pars )))))
            (§ block
                (§ throw (§ new BlockStoreException(§ pars e)))
            )
        )
        (§ finally )
        (§ block
            (§ if (§ expr ps != nil))
            (§ block
                (§ try )
                (§ block
                    (§ call ps.close(§ pars ))
                )
                (§ catch (§ args SQLException e))
                (§ block
                    (§ throw (§ new BlockStoreException(§ pars e)))
                )
            )
        )
    )

    #_override
    #_public
    (§ method void removeUnspentTransactionOutput(§ args UTXO out))
        (§ throws BlockStoreException)
    (§ block
        (§ call maybeConnect(§ pars ))
        ;; TODO: This should only need one query (maybe a stored procedure).
        (§ if (§ expr getTransactionOutput(§ pars out.getHash(§ pars ), out.getIndex(§ pars )) == nil))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars "Tried to remove a UTXO from DatabaseFullPrunedBlockStore that it didn't have!")))
        )

        (§ try )
        (§ block
            (§ var PreparedStatement ps = conn.get(§ pars ).prepareStatement(§ pars getDeleteOpenoutputsSQL(§ pars )))
            (§ call ps.setBytes(§ pars 1, out.getHash(§ pars ).getBytes(§ pars )))
            ;; index is actually an unsigned int
            (§ call ps.setInt(§ pars 2, (§ cast int)out.getIndex(§ pars )))
            (§ call ps.executeUpdate(§ pars ))
            (§ call ps.close(§ pars ))
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
    )

    #_override
    #_public
    (§ method void beginDatabaseBatchWrite(§ args ))
        (§ throws BlockStoreException)
    (§ block
        (§ call maybeConnect(§ pars ))
        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ call log.debug(§ pars "Starting database batch write with connection: " + conn.get(§ pars )))
        )

        (§ try )
        (§ block
            (§ call conn.get(§ pars ).setAutoCommit(§ pars false))
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
    )

    #_override
    #_public
    (§ method void commitDatabaseBatchWrite(§ args ))
        (§ throws BlockStoreException)
    (§ block
        (§ call maybeConnect(§ pars ))
        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ call log.debug(§ pars "Committing database batch write with connection: " + conn.get(§ pars )))
        )

        (§ try )
        (§ block
            (§ call conn.get(§ pars ).commit(§ pars ))
            (§ call conn.get(§ pars ).setAutoCommit(§ pars true))
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
    )

    #_override
    #_public
    (§ method void abortDatabaseBatchWrite(§ args ))
        (§ throws BlockStoreException)
    (§ block
        (§ call maybeConnect(§ pars ))
        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ call log.debug(§ pars "Rollback database batch write with connection: " + conn.get(§ pars )))
        )

        (§ try )
        (§ block
            (§ if (§ expr !conn.get(§ pars ).getAutoCommit(§ pars )))
            (§ block
                (§ call conn.get(§ pars ).rollback(§ pars ))
                (§ call conn.get(§ pars ).setAutoCommit(§ pars true))
            )
            (§ else )
            (§ block
                (§ call log.warn(§ pars "Warning: Rollback attempt without transaction"))
            )
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
    )

    #_override
    #_public
    (§ method boolean hasUnspentOutputs(§ args Sha256Hash hash, int numOutputs))
        (§ throws BlockStoreException)
    (§ block
        (§ call maybeConnect(§ pars ))
        (§ var PreparedStatement ps = nil)
        (§ try )
        (§ block
            (§ ass ps = conn.get(§ pars ).prepareStatement(§ pars getSelectOpenoutputsCountSQL(§ pars )))
            (§ call ps.setBytes(§ pars 1, hash.getBytes(§ pars )))
            (§ var ResultSet results = ps.executeQuery(§ pars ))
            (§ if (§ expr !results.next(§ pars )))
            (§ block
                (§ throw (§ new BlockStoreException(§ pars "Got no results from a COUNT(*) query")))
            )

            (§ var int count = results.getInt(§ pars 1))
            (§ return (§ expr count != 0))
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
        (§ finally )
        (§ block
            (§ if (§ expr ps != nil))
            (§ block
                (§ try )
                (§ block
                    (§ call ps.close(§ pars ))
                )
                (§ catch (§ args SQLException _))
                (§ block
                    (§ throw (§ new BlockStoreException(§ pars "Failed to close PreparedStatement")))
                )
            )
        )
    )

    #_override
    #_public
    (§ method NetworkParameters getParams(§ args ))
    (§ block
        (§ return params)
    )

    ;;;
     ; Resets the store by deleting the contents of the tables and reinitialising them.
     ; @throws BlockStoreException if the tables couldn't be cleared and initialised.
     ;;
    #_public
    (§ method void resetStore(§ args ))
        (§ throws BlockStoreException)
    (§ block
        (§ call maybeConnect(§ pars ))
        (§ try )
        (§ block
            (§ call deleteStore(§ pars ))
            (§ call createTables(§ pars ))
            (§ call initFromDatabase(§ pars ))
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )

    ;;;
     ; Deletes the store by deleting the tables within the database.
     ; @throws BlockStoreException if tables couldn't be deleted.
     ;;
    #_public
    (§ method void deleteStore(§ args ))
        (§ throws BlockStoreException)
    (§ block
        (§ call maybeConnect(§ pars ))
        (§ try )
        (§ block
            (§ var Statement s = conn.get(§ pars ).createStatement(§ pars ))
            (§ for (§ var String sql) :for (§ expr getDropTablesSQL(§ pars )))
            (§ block
                (§ call s.execute(§ pars sql))
            )
            (§ call s.close(§ pars ))
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )

    ;;;
     ; Calculate the balance for a coinbase, to-address, or p2sh address.
     ;
     ; <p>The balance {@link org.bitcoinj.store.DatabaseFullPrunedBlockStore#getBalanceSelectSQL()} returns
     ; the balance (summed) as a number, then use calculateClientSide=false.</p>
     ;
     ; <p>The balance {@link org.bitcoinj.store.DatabaseFullPrunedBlockStore#getBalanceSelectSQL()} returns
     ; all the open outputs as stored in the DB (binary), then use calculateClientSide=true.</p>
     ;
     ; @param address The address to calculate the balance of.
     ; @return The balance of the address supplied.  If the address has not been seen,
     ;         or there are no outputs open for this address, the return value is 0.
     ; @throws BlockStoreException if there is an error getting the balance.
     ;;
    #_public
    (§ method BigInteger calculateBalanceForAddress(§ args Address address))
        (§ throws BlockStoreException)
    (§ block
        (§ call maybeConnect(§ pars ))
        (§ var PreparedStatement ps = nil)
        (§ try )
        (§ block
            (§ ass ps = conn.get(§ pars ).prepareStatement(§ pars getBalanceSelectSQL(§ pars )))
            (§ call ps.setString(§ pars 1, address.toString(§ pars )))
            (§ var ResultSet rs = ps.executeQuery(§ pars ))
            (§ var BigInteger balance = BigInteger.ZERO)
            (§ return rs.next(§ pars ) ? BigInteger.valueOf(§ pars rs.getLong(§ pars 1)) :else balance)
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
        (§ finally )
        (§ block
            (§ if (§ expr ps != nil))
            (§ block
                (§ try )
                (§ block
                    (§ call ps.close(§ pars ))
                )
                (§ catch (§ args SQLException _))
                (§ block
                    (§ throw (§ new BlockStoreException(§ pars "Could not close statement")))
                )
            )
        )
    )
)

#_(ns org.bitcoinj.store #_"FullPrunedBlockStore"
   (:require [org.bitcoinj.core *]))

;;;
 ; <p>An implementor of FullPrunedBlockStore saves StoredBlock objects to some storage mechanism.</p>
 ;
 ; <p>In addition to keeping track of a chain using {@link StoredBlock}s, it should also keep track of
 ; a second copy of the chain which holds {@link StoredUndoableBlock}s.  In this way, an application can
 ; perform a headers-only initial sync and then use that information to more efficiently download a locally
 ; verified full copy of the block chain.</p>
 ;
 ; <p>A FullPrunedBlockStore should function well as a standard {@link BlockStore} and then be able to
 ; trivially switch to being used as a FullPrunedBlockStore.</p>
 ;
 ; <p>It should store the {@link StoredUndoableBlock}s of a number of recent blocks before verifiedHead.height
 ; and all those after verifiedHead.height.
 ; It is advisable to store any {@link StoredUndoableBlock} which has a height > verifiedHead.height - N.
 ; Because N determines the memory usage, it is recommended that N be customizable.  N should be chosen such
 ; that re-orgs beyond that point are vanishingly unlikely, e.g. a few thousand blocks is a reasonable choice.</p>
 ;
 ; <p>It must store the {@link StoredBlock} of all blocks.</p>
 ;
 ; <p>A FullPrunedBlockStore contains a map of hashes to [Full]StoredBlock.  The hash is the double digest of
 ; the Bitcoin serialization of the block header, <b>not</b> the header with the extra data as well.</p>
 ;
 ; <p>A FullPrunedBlockStore also contains a map of hash+index to UTXO.  Again, the hash is
 ; a standard Bitcoin double-SHA256 hash of the transaction.</p>
 ;
 ; <p>FullPrunedBlockStores are thread safe.</p>
 ;;
#_public
(§ interface FullPrunedBlockStore extends BlockStore
    ;;;
     ; <p>Saves the given {@link StoredUndoableBlock} and {@link StoredBlock}.  Calculates keys from the {@link StoredBlock}.</p>
     ;
     ; <p>Though not required for proper function of a FullPrunedBlockStore, any user of a FullPrunedBlockStore should ensure
     ; that a StoredUndoableBlock for each block up to the fully verified chain head has been added to this block store using
     ; this function (not put(StoredBlock)), so that the ability to perform reorgs is maintained.</p>
     ;
     ; @throws BlockStoreException if there is a problem with the underlying storage layer, such as running out of disk space.
     ;;
    (§ method void put(§ args StoredBlock storedBlock, StoredUndoableBlock undoableBlock))
        (§ throws BlockStoreException)

    ;;;
     ; Returns the StoredBlock that was added as a StoredUndoableBlock given a hash.  The returned values block.getHash()
     ; method will be equal to the parameter.  If no such block is found, returns null.
     ;;
    (§ method StoredBlock getOnceUndoableStoredBlock(§ args Sha256Hash hash))
        (§ throws BlockStoreException)

    ;;;
     ; Returns a {@link StoredUndoableBlock} whose block.getHash() method will be equal to the parameter.  If no such
     ; block is found, returns null.  Note that this may return null more often than get(Sha256Hash hash) as not all
     ; {@link StoredBlock}s have a {@link StoredUndoableBlock} copy stored as well.
     ;;
    (§ method StoredUndoableBlock getUndoBlock(§ args Sha256Hash hash))
        (§ throws BlockStoreException)

    ;;;
     ; Gets a {@link org.bitcoinj.core.UTXO} with the given hash and index, or null if none is found.
     ;;
    (§ method UTXO getTransactionOutput(§ args Sha256Hash hash, long index))
        (§ throws BlockStoreException)

    ;;;
     ; Adds a {@link org.bitcoinj.core.UTXO} to the list of unspent TransactionOutputs.
     ;;
    (§ method void addUnspentTransactionOutput(§ args UTXO out))
        (§ throws BlockStoreException)

    ;;;
     ; Removes a {@link org.bitcoinj.core.UTXO} from the list of unspent TransactionOutputs.
     ; Note that the coinbase of the genesis block should NEVER be spendable and thus never in the list.
     ; @throws BlockStoreException if there is an underlying storage issue, or out was not in the list.
     ;;
    (§ method void removeUnspentTransactionOutput(§ args UTXO out))
        (§ throws BlockStoreException)

    ;;;
     ; True if this store has any unspent outputs from a transaction with a hash equal to the first parameter.
     ; @param numOutputs The number of outputs the given transaction has.
     ;;
    (§ method boolean hasUnspentOutputs(§ args Sha256Hash hash, int numOutputs))
        (§ throws BlockStoreException)

    ;;;
     ; Returns the {@link StoredBlock} that represents the top of the chain of greatest total work that has
     ; been fully verified and the point in the chain at which the unspent transaction output set in this
     ; store represents.
     ;;
    (§ method StoredBlock getVerifiedChainHead(§ args ))
        (§ throws BlockStoreException)

    ;;;
     ; Sets the {@link StoredBlock} that represents the top of the chain of greatest total work that has been
     ; fully verified.  It should generally be set after a batch of updates to the transaction unspent output set,
     ; before a call to commitDatabaseBatchWrite.
     ;
     ; If chainHead has a greater height than the non-verified chain head (i.e. that set with
     ; {@link BlockStore#setChainHead}) the non-verified chain head should be set to the one set here.
     ; In this way a class using a FullPrunedBlockStore only in full-verification mode can ignore the regular
     ; {@link BlockStore} functions implemented as a part of a FullPrunedBlockStore.
     ;;
    (§ method void setVerifiedChainHead(§ args StoredBlock chainHead))
        (§ throws BlockStoreException)

    ;;;
     ; <p>Begins/Commits/Aborts a database transaction.</p>
     ;
     ; <p>If abortDatabaseBatchWrite() is called by the same thread that called beginDatabaseBatchWrite(),
     ; any data writes between this call and abortDatabaseBatchWrite() made by the same thread
     ; should be discarded.</p>
     ;
     ; <p>Furthermore, any data written after a call to beginDatabaseBatchWrite() should not be readable
     ; by any other threads until commitDatabaseBatchWrite() has been called by this thread.
     ; Multiple calls to beginDatabaseBatchWrite() in any given thread should be ignored and treated as one call.</p>
     ;;
    (§ method void beginDatabaseBatchWrite(§ args ))
        (§ throws BlockStoreException)

    (§ method void commitDatabaseBatchWrite(§ args ))
        (§ throws BlockStoreException)

    (§ method void abortDatabaseBatchWrite(§ args ))
        (§ throws BlockStoreException)
)

#_(ns org.bitcoinj.store #_"H2FullPrunedBlockStore"
    (:import [java.sql *]
             [java.util ArrayList Collections List])
   (:require [org.bitcoinj.core *]))

;;;
 ; A full pruned block store using the H2 pure-java embedded database.
 ;
 ; Note that because of the heavy delete load on the database, during IBD,
 ; you may see the database files grow quite large (around 1.5G).
 ; H2 automatically frees some space at shutdown, so close()ing the database
 ; decreases the space usage somewhat (to only around 1.3G).
 ;;
#_public
(§ class H2FullPrunedBlockStore extends DatabaseFullPrunedBlockStore
    #_private
    #_static
    #_final
    (§ field String H2_DUPLICATE_KEY_ERROR_CODE = "23505")
    #_private
    #_static
    #_final
    (§ field String DATABASE_DRIVER_CLASS = "org.h2.Driver")
    #_private
    #_static
    #_final
    (§ field String DATABASE_CONNECTION_URL_PREFIX = "jdbc:h2:")

    ;; create table SQL
    #_private
    #_static
    #_final
    (§ field String CREATE_SETTINGS_TABLE = "CREATE TABLE settings ( "
            + "name VARCHAR(32) NOT NULL CONSTRAINT settings_pk PRIMARY KEY,"
            + "value BLOB"
            + ")")

    #_private
    #_static
    #_final
    (§ field String CREATE_HEADERS_TABLE = "CREATE TABLE headers ( "
            + "hash BINARY(28) NOT NULL CONSTRAINT headers_pk PRIMARY KEY,"
            + "chainwork BLOB NOT NULL,"
            + "height INT NOT NULL,"
            + "header BLOB NOT NULL,"
            + "wasundoable BOOL NOT NULL"
            + ")")

    #_private
    #_static
    #_final
    (§ field String CREATE_UNDOABLE_TABLE = "CREATE TABLE undoableblocks ( "
            + "hash BINARY(28) NOT NULL CONSTRAINT undoableblocks_pk PRIMARY KEY,"
            + "height INT NOT NULL,"
            + "txoutchanges BLOB,"
            + "transactions BLOB"
            + ")")

    #_private
    #_static
    #_final
    (§ field String CREATE_OPEN_OUTPUT_TABLE = "CREATE TABLE openoutputs ("
            + "hash BINARY(32) NOT NULL,"
            + "index INT NOT NULL,"
            + "height INT NOT NULL,"
            + "value BIGINT NOT NULL,"
            + "scriptbytes BLOB NOT NULL,"
            + "toaddress VARCHAR(35),"
            + "addresstargetable TINYINT,"
            + "coinbase BOOLEAN,"
            + "PRIMARY KEY (hash, index),"
            + ")")

    ;; Some indexes to speed up inserts.
    #_private
    #_static
    #_final
    (§ field String CREATE_OUTPUTS_ADDRESS_MULTI_INDEX     = "CREATE INDEX openoutputs_hash_index_height_toaddress_idx ON openoutputs (hash, index, height, toaddress)")
    #_private
    #_static
    #_final
    (§ field String CREATE_OUTPUTS_TOADDRESS_INDEX         = "CREATE INDEX openoutputs_toaddress_idx ON openoutputs (toaddress)")
    #_private
    #_static
    #_final
    (§ field String CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX = "CREATE INDEX openoutputs_addresstargetable_idx ON openoutputs (addresstargetable)")
    #_private
    #_static
    #_final
    (§ field String CREATE_OUTPUTS_HASH_INDEX              = "CREATE INDEX openoutputs_hash_idx ON openoutputs (hash)")
    #_private
    #_static
    #_final
    (§ field String CREATE_UNDOABLE_TABLE_INDEX            = "CREATE INDEX undoableblocks_height_idx ON undoableblocks (height)")

    ;;;
     ; Creates a new H2FullPrunedBlockStore, with given credentials for H2 database.
     ; @param params A copy of the NetworkParameters used.
     ; @param dbName The path to the database on disk.
     ; @param username The username to use in the database.
     ; @param password The username's password to use in the database.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    (§ constructor H2FullPrunedBlockStore(§ args NetworkParameters params, String dbName, String username, String password, int fullStoreDepth))
        (§ throws BlockStoreException)
    (§ block
        (§ super (§ pars params, DATABASE_CONNECTION_URL_PREFIX + dbName + ";create=true;LOCK_TIMEOUT=60000;DB_CLOSE_ON_EXIT=FALSE", fullStoreDepth, username, password, nil))
    )

    ;;;
     ; Creates a new H2FullPrunedBlockStore.
     ; @param params A copy of the NetworkParameters used.
     ; @param dbName The path to the database on disk.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    (§ constructor H2FullPrunedBlockStore(§ args NetworkParameters params, String dbName, int fullStoreDepth))
        (§ throws BlockStoreException)
    (§ block
        (§ this (§ pars params, dbName, nil, nil, fullStoreDepth))
    )

    ;;;
     ; Creates a new H2FullPrunedBlockStore with the given cache size.
     ; @param params A copy of the NetworkParameters used.
     ; @param dbName The path to the database on disk.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param cacheSize The number of kilobytes to dedicate to H2 Cache.  The default value of 16MB (16384) is a safe bet
     ;                  to achieve good performance/cost when importing blocks from disk, past 32MB makes little sense,
     ;                  and below 4MB sees a sharp drop in performance.
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    (§ constructor H2FullPrunedBlockStore(§ args NetworkParameters params, String dbName, int fullStoreDepth, int cacheSize))
        (§ throws BlockStoreException)
    (§ block
        (§ this (§ pars params, dbName, fullStoreDepth))

        (§ try )
        (§ block
            (§ var Statement s = conn.get(§ pars ).createStatement(§ pars ))
            (§ call s.executeUpdate(§ pars "SET CACHE_SIZE " + cacheSize))
            (§ call s.close(§ pars ))
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
    )

    #_override
    #_protected
    (§ method String getDuplicateKeyErrorCode(§ args ))
    (§ block
        (§ return H2_DUPLICATE_KEY_ERROR_CODE)
    )

    #_override
    #_protected
    (§ method List<String> getCreateTablesSQL(§ args ))
    (§ block
        (§ var List<String> sql = new ArrayList<>(§ pars ))
        (§ call sql.add(§ pars CREATE_SETTINGS_TABLE))
        (§ call sql.add(§ pars CREATE_HEADERS_TABLE))
        (§ call sql.add(§ pars CREATE_UNDOABLE_TABLE))
        (§ call sql.add(§ pars CREATE_OPEN_OUTPUT_TABLE))
        (§ return sql)
    )

    #_override
    #_protected
    (§ method List<String> getCreateIndexesSQL(§ args ))
    (§ block
        (§ var List<String> sql = new ArrayList<>(§ pars ))
        (§ call sql.add(§ pars CREATE_UNDOABLE_TABLE_INDEX))
        (§ call sql.add(§ pars CREATE_OUTPUTS_ADDRESS_MULTI_INDEX))
        (§ call sql.add(§ pars CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX))
        (§ call sql.add(§ pars CREATE_OUTPUTS_HASH_INDEX))
        (§ call sql.add(§ pars CREATE_OUTPUTS_TOADDRESS_INDEX))
        (§ return sql)
    )

    #_override
    #_protected
    (§ method List<String> getCreateSchemeSQL(§ args ))
    (§ block
        ;; do nothing
        (§ return Collections.emptyList(§ pars ))
    )

    #_override
    #_protected
    (§ method String getDatabaseDriverClass(§ args ))
    (§ block
        (§ return DATABASE_DRIVER_CLASS)
    )
)

#_(ns org.bitcoinj.store #_"MemoryBlockStore"
    (:import [java.util LinkedHashMap Map])
   (:require [org.bitcoinj.core *]))

;;;
 ; Keeps {@link org.bitcoinj.core.StoredBlock}s in memory.  Used primarily for unit testing.
 ;;
#_public
(§ class MemoryBlockStore implements BlockStore
    #_private
    (§ field LinkedHashMap<Sha256Hash, StoredBlock> blockMap = new LinkedHashMap<Sha256Hash, StoredBlock>(§ pars )
        (§ anon
            #_override
            #_protected
            (§ method boolean removeEldestEntry(§ args Map.Entry<Sha256Hash, StoredBlock> eldest))
            (§ block
                (§ return (§ expr 5000 < blockMap.size(§ pars )))
            )
        ))
    #_private
    (§ field StoredBlock chainHead)
    #_private
    (§ field NetworkParameters params)

    #_public
    (§ constructor MemoryBlockStore(§ args NetworkParameters params))
    (§ block
        ;; Insert the genesis block.
        (§ try )
        (§ block
            (§ var Block genesisHeader = params.getGenesisBlock(§ pars ).cloneAsHeader(§ pars ))
            (§ var StoredBlock storedGenesis = new StoredBlock(§ pars genesisHeader, genesisHeader.getWork(§ pars ), 0))
            (§ call put(§ pars storedGenesis))
            (§ call setChainHead(§ pars storedGenesis))
            (§ ass this.params = params)
        )
        (§ catch (§ args BlockStoreException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
        (§ catch (§ args VerificationException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
    )

    #_override
    #_public
    #_synchronized
    #_final
    (§ method void put(§ args StoredBlock block))
        (§ throws BlockStoreException)
    (§ block
        (§ if (§ expr blockMap == nil))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars "MemoryBlockStore is closed")))
        )

        (§ var Sha256Hash hash = block.getHeader(§ pars ).getHash(§ pars ))
        (§ call blockMap.put(§ pars hash, block))
    )

    #_override
    #_public
    #_synchronized
    (§ method StoredBlock get(§ args Sha256Hash hash))
        (§ throws BlockStoreException)
    (§ block
        (§ if (§ expr blockMap == nil))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars "MemoryBlockStore is closed")))
        )

        (§ return blockMap.get(§ pars hash))
    )

    #_override
    #_public
    (§ method StoredBlock getChainHead(§ args ))
        (§ throws BlockStoreException)
    (§ block
        (§ if (§ expr blockMap == nil))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars "MemoryBlockStore is closed")))
        )

        (§ return chainHead)
    )

    #_override
    #_public
    #_final
    (§ method void setChainHead(§ args StoredBlock chainHead))
        (§ throws BlockStoreException)
    (§ block
        (§ if (§ expr blockMap == nil))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars "MemoryBlockStore is closed")))
        )

        (§ ass this.chainHead = chainHead)
    )

    #_override
    #_public
    (§ method void close(§ args ))
    (§ block
        (§ ass blockMap = nil)
    )

    #_override
    #_public
    (§ method NetworkParameters getParams(§ args ))
    (§ block
        (§ return params)
    )
)

#_(ns org.bitcoinj.store #_"MemoryFullPrunedBlockStore"
    (:import [java.util *])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.collect Lists])
   (:require [org.bitcoinj.core *]))

;;;
 ; Used as a key for memory map (to avoid having to think about NetworkParameters,
 ; which is required for {@link TransactionOutPoint}.
 ;;
(§ class StoredTransactionOutPoint
    ;;; Hash of the transaction to which we refer. ;;
    (§ field Sha256Hash hash)
    ;;; Which output of that transaction we are talking about. ;;
    (§ field long index)

    (§ constructor StoredTransactionOutPoint(§ args Sha256Hash hash, long index))
    (§ block
        (§ ass this.hash = hash)
        (§ ass this.index = index)
    )

    (§ constructor StoredTransactionOutPoint(§ args UTXO out))
    (§ block
        (§ ass this.hash = out.getHash(§ pars ))
        (§ ass this.index = out.getIndex(§ pars ))
    )

    ;;;
     ; The hash of the transaction to which we refer.
     ;;
    (§ method Sha256Hash getHash(§ args ))
    (§ block
        (§ return hash)
    )

    ;;;
     ; The index of the output in transaction to which we refer.
     ;;
    (§ method long getIndex(§ args ))
    (§ block
        (§ return index)
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars getIndex(§ pars ), getHash(§ pars )))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return "Stored transaction out point: " + hash + ":" + index)
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var StoredTransactionOutPoint other = (§ cast StoredTransactionOutPoint)o)
        (§ return (§ expr getIndex(§ pars ) == other.getIndex(§ pars ) && Objects.equal(§ pars getHash(§ pars ), other.getHash(§ pars ))))
    )
)

;;;
 ; A HashMap<KeyType, ValueType> that is DB transaction-aware.
 ; This class is not thread-safe.
 ;;
(§ class TransactionalHashMap<KeyType, ValueType>
    (§ field ThreadLocal<HashMap<KeyType, ValueType>> tempMap)
    (§ field ThreadLocal<HashSet<KeyType>> tempSetRemoved)
    #_private
    (§ field ThreadLocal<Boolean> inTransaction)

    (§ field HashMap<KeyType, ValueType> map)

    #_public
    (§ constructor TransactionalHashMap(§ args ))
    (§ block
        (§ ass tempMap = new ThreadLocal<>(§ pars ))
        (§ ass tempSetRemoved = new ThreadLocal<>(§ pars ))
        (§ ass inTransaction = new ThreadLocal<>(§ pars ))
        (§ ass map = new HashMap<>(§ pars ))
    )

    #_public
    (§ method void beginDatabaseBatchWrite(§ args ))
    (§ block
        (§ call inTransaction.set(§ pars true))
    )

    #_public
    (§ method void commitDatabaseBatchWrite(§ args ))
    (§ block
        (§ if (§ expr tempSetRemoved.get(§ pars ) != nil))
        (§ block
            (§ for (§ var KeyType key) :for (§ expr tempSetRemoved.get(§ pars )))
            (§ block
                (§ call map.remove(§ pars key))
            )
        )
        (§ if (§ expr tempMap.get(§ pars ) != nil))
        (§ block
            (§ for (§ var Map.Entry<KeyType, ValueType> entry) :for (§ expr tempMap.get(§ pars ).entrySet(§ pars )))
            (§ block
                (§ call map.put(§ pars entry.getKey(§ pars ), entry.getValue(§ pars )))
            )
        )
        (§ call abortDatabaseBatchWrite(§ pars ))
    )

    #_public
    (§ method void abortDatabaseBatchWrite(§ args ))
    (§ block
        (§ call inTransaction.set(§ pars false))
        (§ call tempSetRemoved.remove(§ pars ))
        (§ call tempMap.remove(§ pars ))
    )

    #_nilable
    #_public
    (§ method ValueType get(§ args KeyType key))
    (§ block
        (§ if (§ expr Boolean.TRUE.equals(§ pars inTransaction.get(§ pars ))))
        (§ block
            (§ if (§ expr tempMap.get(§ pars ) != nil))
            (§ block
                (§ var ValueType value = tempMap.get(§ pars ).get(§ pars key))
                (§ if (§ expr value != nil))
                (§ block
                    (§ return value)
                )
            )
            (§ if (§ expr tempSetRemoved.get(§ pars ) != nil && tempSetRemoved.get(§ pars ).contains(§ pars key)))
            (§ block
                (§ return nil)
            )
        )
        (§ return map.get(§ pars key))
    )

    #_public
    (§ method List<ValueType> values(§ args ))
    (§ block
        (§ var List<ValueType> valueTypes = new ArrayList<>(§ pars ))
        (§ for (§ var KeyType keyType) :for (§ expr map.keySet(§ pars )))
        (§ block
            (§ call valueTypes.add(§ pars get(§ pars keyType)))
        )
        (§ return valueTypes)
    )

    #_public
    (§ method void put(§ args KeyType key, ValueType value))
    (§ block
        (§ if (§ expr Boolean.TRUE.equals(§ pars inTransaction.get(§ pars ))))
        (§ block
            (§ if (§ expr tempSetRemoved.get(§ pars ) != nil))
            (§ block
                (§ call tempSetRemoved.get(§ pars ).remove(§ pars key))
            )
            (§ if (§ expr tempMap.get(§ pars ) == nil))
            (§ block
                (§ call tempMap.set(§ pars new HashMap<KeyType, ValueType>(§ pars )))
            )
            (§ call tempMap.get(§ pars ).put(§ pars key, value))
        )
        (§ else )
        (§ block
            (§ call map.put(§ pars key, value))
        )
    )

    #_nilable
    #_public
    (§ method ValueType remove(§ args KeyType key))
    (§ block
        (§ if (§ expr Boolean.TRUE.equals(§ pars inTransaction.get(§ pars ))))
        (§ block
            (§ var ValueType retVal = map.get(§ pars key))
            (§ if (§ expr retVal != nil))
            (§ block
                (§ if (§ expr tempSetRemoved.get(§ pars ) == nil))
                (§ block
                    (§ call tempSetRemoved.set(§ pars new HashSet<KeyType>(§ pars )))
                )
                (§ call tempSetRemoved.get(§ pars ).add(§ pars key))
            )
            (§ if (§ expr tempMap.get(§ pars ) != nil))
            (§ block
                (§ var ValueType tempVal = tempMap.get(§ pars ).remove(§ pars key))
                (§ if (§ expr tempVal != nil))
                (§ block
                    (§ return tempVal)
                )
            )
            (§ return retVal)
        )
        (§ else )
        (§ block
            (§ return map.remove(§ pars key))
        )
    )
)

;;;
 ; A Map with multiple key types that is DB per-thread-transaction-aware.
 ; However, this class is not thread-safe.
 ; @param <UniqueKeyType> Is a key that must be unique per object.
 ; @param <MultiKeyType> Is a key that can have multiple values.
 ;;
(§ class TransactionalMultiKeyHashMap<UniqueKeyType, MultiKeyType, ValueType>
    (§ field TransactionalHashMap<UniqueKeyType, ValueType> mapValues)
    (§ field HashMap<MultiKeyType, Set<UniqueKeyType>> mapKeys)

    #_public
    (§ constructor TransactionalMultiKeyHashMap(§ args ))
    (§ block
        (§ ass mapValues = new TransactionalHashMap<>(§ pars ))
        (§ ass mapKeys = new HashMap<>(§ pars ))
    )

    #_public
    (§ method void beginTransaction(§ args ))
    (§ block
        (§ call mapValues.beginDatabaseBatchWrite(§ pars ))
    )

    #_public
    (§ method void commitTransaction(§ args ))
    (§ block
        (§ call mapValues.commitDatabaseBatchWrite(§ pars ))
    )

    #_public
    (§ method void abortTransaction(§ args ))
    (§ block
        (§ call mapValues.abortDatabaseBatchWrite(§ pars ))
    )

    #_nilable
    #_public
    (§ method ValueType get(§ args UniqueKeyType key))
    (§ block
        (§ return mapValues.get(§ pars key))
    )

    #_public
    (§ method void put(§ args UniqueKeyType uniqueKey, MultiKeyType multiKey, ValueType value))
    (§ block
        (§ call mapValues.put(§ pars uniqueKey, value))
        (§ var Set<UniqueKeyType> set = mapKeys.get(§ pars multiKey))
        (§ if (§ expr set == nil))
        (§ block
            (§ ass set = new HashSet<>(§ pars ))
            (§ call set.add(§ pars uniqueKey))
            (§ call mapKeys.put(§ pars multiKey, set))
        )
        (§ else )
        (§ block
            (§ call set.add(§ pars uniqueKey))
        )
    )

    #_nilable
    #_public
    (§ method ValueType removeByUniqueKey(§ args UniqueKeyType key))
    (§ block
        (§ return mapValues.remove(§ pars key))
    )

    #_public
    (§ method void removeByMultiKey(§ args MultiKeyType key))
    (§ block
        (§ var Set<UniqueKeyType> set = mapKeys.remove(§ pars key))
        (§ if (§ expr set != nil))
        (§ block
            (§ for (§ var UniqueKeyType uniqueKey) :for (§ expr set))
            (§ block
                (§ call removeByUniqueKey(§ pars uniqueKey))
            )
        )
    )
)

;;;
 ; Keeps {@link StoredBlock}s, {@link StoredUndoableBlock}s and {@link org.bitcoinj.core.UTXO}s in memory.
 ; Used primarily for unit testing.
 ;;
#_public
(§ class MemoryFullPrunedBlockStore implements FullPrunedBlockStore
    #_protected
    #_static
    (§ class StoredBlockAndWasUndoableFlag
        #_public
        (§ field StoredBlock block)
        #_public
        (§ field boolean wasUndoable)
        #_public
        (§ constructor StoredBlockAndWasUndoableFlag(§ args StoredBlock block, boolean wasUndoable))
        (§ block
            (§ ass this.block = block)
            (§ ass this.wasUndoable = wasUndoable)
        )
    )
    #_private
    (§ field TransactionalHashMap<Sha256Hash, StoredBlockAndWasUndoableFlag> blockMap)
    #_private
    (§ field TransactionalMultiKeyHashMap<Sha256Hash, Integer, StoredUndoableBlock> fullBlockMap)
    ;; TODO: Use something more suited to remove-heavy use?
    #_private
    (§ field TransactionalHashMap<StoredTransactionOutPoint, UTXO> transactionOutputMap)
    #_private
    (§ field StoredBlock chainHead)
    #_private
    (§ field StoredBlock verifiedChainHead)
    #_private
    (§ field int fullStoreDepth)
    #_private
    (§ field NetworkParameters params)

    ;;;
     ; Set up the MemoryFullPrunedBlockStore.
     ; @param params The network parameters of this block store - used to get genesis block.
     ; @param fullStoreDepth The depth of blocks to keep FullStoredBlocks instead of StoredBlocks.
     ;;
    #_public
    (§ constructor MemoryFullPrunedBlockStore(§ args NetworkParameters params, int fullStoreDepth))
    (§ block
        (§ ass blockMap = new TransactionalHashMap<>(§ pars ))
        (§ ass fullBlockMap = new TransactionalMultiKeyHashMap<>(§ pars ))
        (§ ass transactionOutputMap = new TransactionalHashMap<>(§ pars ))
        (§ ass this.fullStoreDepth = (§ expr 0 < fullStoreDepth) ? fullStoreDepth :else 1)
        ;; Insert the genesis block.
        (§ try )
        (§ block
            (§ var StoredBlock storedGenesisHeader = new StoredBlock(§ pars params.getGenesisBlock(§ pars ).cloneAsHeader(§ pars ), params.getGenesisBlock(§ pars ).getWork(§ pars ), 0))
            ;; The coinbase in the genesis block is not spendable.
            (§ var List<Transaction> genesisTransactions = Lists.newLinkedList(§ pars ))
            (§ var StoredUndoableBlock storedGenesis = new StoredUndoableBlock(§ pars params.getGenesisBlock(§ pars ).getHash(§ pars ), genesisTransactions))
            (§ call put(§ pars storedGenesisHeader, storedGenesis))
            (§ call setChainHead(§ pars storedGenesisHeader))
            (§ call setVerifiedChainHead(§ pars storedGenesisHeader))
            (§ ass this.params = params)
        )
        (§ catch (§ args BlockStoreException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
        (§ catch (§ args VerificationException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
    )

    #_override
    #_public
    #_synchronized
    (§ method void put(§ args StoredBlock block))
        (§ throws BlockStoreException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ var Sha256Hash hash = block.getHeader(§ pars ).getHash(§ pars ))
        (§ call blockMap.put(§ pars hash, new StoredBlockAndWasUndoableFlag(§ pars block, false)))
    )

    #_override
    #_public
    #_synchronized
    #_final
    (§ method void put(§ args StoredBlock storedBlock, StoredUndoableBlock undoableBlock))
        (§ throws BlockStoreException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ var Sha256Hash hash = storedBlock.getHeader(§ pars ).getHash(§ pars ))
        (§ call fullBlockMap.put(§ pars hash, storedBlock.getHeight(§ pars ), undoableBlock))
        (§ call blockMap.put(§ pars hash, new StoredBlockAndWasUndoableFlag(§ pars storedBlock, true)))
    )

    #_override
    #_nilable
    #_public
    #_synchronized
    (§ method StoredBlock get(§ args Sha256Hash hash))
        (§ throws BlockStoreException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ var StoredBlockAndWasUndoableFlag storedBlock = blockMap.get(§ pars hash))
        (§ return (§ expr storedBlock != nil) ? storedBlock.block :else nil)
    )

    #_override
    #_nilable
    #_public
    #_synchronized
    (§ method StoredBlock getOnceUndoableStoredBlock(§ args Sha256Hash hash))
        (§ throws BlockStoreException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ var StoredBlockAndWasUndoableFlag storedBlock = blockMap.get(§ pars hash))
        (§ return (§ expr storedBlock != nil && storedBlock.wasUndoable) ? storedBlock.block :else nil)
    )

    #_override
    #_nilable
    #_public
    #_synchronized
    (§ method StoredUndoableBlock getUndoBlock(§ args Sha256Hash hash))
        (§ throws BlockStoreException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars fullBlockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ return fullBlockMap.get(§ pars hash))
    )

    #_override
    #_public
    #_synchronized
    (§ method StoredBlock getChainHead(§ args ))
        (§ throws BlockStoreException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ return chainHead)
    )

    #_override
    #_public
    #_synchronized
    #_final
    (§ method void setChainHead(§ args StoredBlock chainHead))
        (§ throws BlockStoreException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ ass this.chainHead = chainHead)
    )

    #_override
    #_public
    #_synchronized
    (§ method StoredBlock getVerifiedChainHead(§ args ))
        (§ throws BlockStoreException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ return verifiedChainHead)
    )

    #_override
    #_public
    #_synchronized
    #_final
    (§ method void setVerifiedChainHead(§ args StoredBlock chainHead))
        (§ throws BlockStoreException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ ass this.verifiedChainHead = chainHead)
        (§ if (§ expr this.chainHead.getHeight(§ pars ) < chainHead.getHeight(§ pars )))
        (§ block
            (§ call setChainHead(§ pars chainHead))
        )
        ;; Potential leak here if not all blocks get setChainHead'd.
        ;; Though the FullPrunedBlockStore allows for this, the current AbstractBlockChain will not do it.
        (§ call fullBlockMap.removeByMultiKey(§ pars chainHead.getHeight(§ pars ) - fullStoreDepth))
    )

    #_override
    #_public
    (§ method void close(§ args ))
    (§ block
        (§ ass blockMap = nil)
        (§ ass fullBlockMap = nil)
        (§ ass transactionOutputMap = nil)
    )

    #_override
    #_nilable
    #_public
    #_synchronized
    (§ method UTXO getTransactionOutput(§ args Sha256Hash hash, long index))
        (§ throws BlockStoreException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars transactionOutputMap, "MemoryFullPrunedBlockStore is closed"))
        (§ return transactionOutputMap.get(§ pars (§ new StoredTransactionOutPoint(§ pars hash, index))))
    )

    #_override
    #_public
    #_synchronized
    (§ method void addUnspentTransactionOutput(§ args UTXO out))
        (§ throws BlockStoreException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars transactionOutputMap, "MemoryFullPrunedBlockStore is closed"))
        (§ call transactionOutputMap.put(§ pars (§ new StoredTransactionOutPoint(§ pars out)), out))
    )

    #_override
    #_public
    #_synchronized
    (§ method void removeUnspentTransactionOutput(§ args UTXO out))
        (§ throws BlockStoreException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars transactionOutputMap, "MemoryFullPrunedBlockStore is closed"))
        (§ if (§ expr transactionOutputMap.remove(§ pars (§ new StoredTransactionOutPoint(§ pars out))) == nil))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars "Tried to remove a UTXO from MemoryFullPrunedBlockStore that it didn't have!")))
        )
    )

    #_override
    #_public
    #_synchronized
    (§ method void beginDatabaseBatchWrite(§ args ))
        (§ throws BlockStoreException)
    (§ block
        (§ call blockMap.beginDatabaseBatchWrite(§ pars ))
        (§ call fullBlockMap.beginTransaction(§ pars ))
        (§ call transactionOutputMap.beginDatabaseBatchWrite(§ pars ))
    )

    #_override
    #_public
    #_synchronized
    (§ method void commitDatabaseBatchWrite(§ args ))
        (§ throws BlockStoreException)
    (§ block
        (§ call blockMap.commitDatabaseBatchWrite(§ pars ))
        (§ call fullBlockMap.commitTransaction(§ pars ))
        (§ call transactionOutputMap.commitDatabaseBatchWrite(§ pars ))
    )

    #_override
    #_public
    #_synchronized
    (§ method void abortDatabaseBatchWrite(§ args ))
        (§ throws BlockStoreException)
    (§ block
        (§ call blockMap.abortDatabaseBatchWrite(§ pars ))
        (§ call fullBlockMap.abortTransaction(§ pars ))
        (§ call transactionOutputMap.abortDatabaseBatchWrite(§ pars ))
    )

    #_override
    #_public
    #_synchronized
    (§ method boolean hasUnspentOutputs(§ args Sha256Hash hash, int numOutputs))
        (§ throws BlockStoreException)
    (§ block
        (§ for (§ var int i = 0) :for (§ expr i < numOutputs) :for (§ ass i = i + 1))
        (§ block
            (§ if (§ expr getTransactionOutput(§ pars hash, i) != nil))
            (§ block
                (§ return true)
            )
        )
        (§ return false)
    )

    #_override
    #_public
    (§ method NetworkParameters getParams(§ args ))
    (§ block
        (§ return params)
    )
)

#_(ns org.bitcoinj.store #_"PostgresFullPrunedBlockStore"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.sql PreparedStatement ResultSet SQLException Types]
             [java.util ArrayList List])
    (:import [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]))

;;;
 ; <p>A full pruned block store using the Postgres database engine.  As an added bonus an address index is calculated,
 ; so you can use {@link #calculateBalanceForAddress(org.bitcoinj.core.Address)} to quickly look up
 ; the quantity of bitcoins controlled by that address.</p>
 ;;
#_public
(§ class PostgresFullPrunedBlockStore extends DatabaseFullPrunedBlockStore
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars PostgresFullPrunedBlockStore.class))

    #_private
    #_static
    #_final
    (§ field String POSTGRES_DUPLICATE_KEY_ERROR_CODE = "23505")
    #_private
    #_static
    #_final
    (§ field String DATABASE_DRIVER_CLASS = "org.postgresql.Driver")
    #_private
    #_static
    #_final
    (§ field String DATABASE_CONNECTION_URL_PREFIX = "jdbc:postgresql://")

    ;; create table SQL
    #_private
    #_static
    #_final
    (§ field String CREATE_SETTINGS_TABLE = "CREATE TABLE settings ("
          + "name character varying(32) NOT NULL, "
          + "value bytea, "
          + "CONSTRAINT setting_pk PRIMARY KEY (name)"
          + ")")

    #_private
    #_static
    #_final
    (§ field String CREATE_HEADERS_TABLE = "CREATE TABLE headers ("
          + "hash bytea NOT NULL, "
          + "chainwork bytea NOT NULL, "
          + "height integer NOT NULL, "
          + "header bytea NOT NULL, "
          + "wasundoable boolean NOT NULL, "
          + "CONSTRAINT headers_pk PRIMARY KEY (hash)"
          + ")")

    #_private
    #_static
    #_final
    (§ field String CREATE_UNDOABLE_TABLE = "CREATE TABLE undoableblocks ("
          + "hash bytea NOT NULL, "
          + "height integer NOT NULL, "
          + "txoutchanges bytea, "
          + "transactions bytea, "
          + "CONSTRAINT undoableblocks_pk PRIMARY KEY (hash)"
          + ")")

    #_private
    #_static
    #_final
    (§ field String CREATE_OPEN_OUTPUT_TABLE = "CREATE TABLE openoutputs ("
          + "hash bytea NOT NULL, "
          + "index integer NOT NULL, "
          + "height integer NOT NULL, "
          + "value bigint NOT NULL, "
          + "scriptbytes bytea NOT NULL, "
          + "toaddress character varying(35), "
          + "addresstargetable smallint, "
          + "coinbase boolean, "
          + "CONSTRAINT openoutputs_pk PRIMARY KEY (hash,index)"
          + ")")

    ;; Some indexes to speed up inserts.
    #_private
    #_static
    #_final
    (§ field String CREATE_OUTPUTS_ADDRESS_MULTI_INDEX     = "CREATE INDEX openoutputs_hash_index_num_height_toaddress_idx ON openoutputs USING btree (hash, index, height, toaddress)")
    #_private
    #_static
    #_final
    (§ field String CREATE_OUTPUTS_TOADDRESS_INDEX         = "CREATE INDEX openoutputs_toaddress_idx ON openoutputs USING btree (toaddress)")
    #_private
    #_static
    #_final
    (§ field String CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX = "CREATE INDEX openoutputs_addresstargetable_idx ON openoutputs USING btree (addresstargetable)")
    #_private
    #_static
    #_final
    (§ field String CREATE_OUTPUTS_HASH_INDEX              = "CREATE INDEX openoutputs_hash_idx ON openoutputs USING btree (hash)")
    #_private
    #_static
    #_final
    (§ field String CREATE_UNDOABLE_TABLE_INDEX            = "CREATE INDEX undoableblocks_height_idx ON undoableBlocks USING btree (height)")

    #_private
    #_static
    #_final
    (§ field String SELECT_UNDOABLEBLOCKS_EXISTS_SQL       = "select 1 from undoableblocks where hash = ?")

    ;;;
     ; Creates a new PostgresFullPrunedBlockStore.
     ;
     ; @param params A copy of the NetworkParameters used.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param hostname The hostname of the database to connect to.
     ; @param dbName The database to connect to.
     ; @param username The database username.
     ; @param password The password to the database.
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    (§ constructor PostgresFullPrunedBlockStore(§ args NetworkParameters params, int fullStoreDepth, String hostname, String dbName, String username, String password))
        (§ throws BlockStoreException)
    (§ block
        (§ super (§ pars params, DATABASE_CONNECTION_URL_PREFIX + hostname + "/" + dbName, fullStoreDepth, username, password, nil))
    )

    ;;;
     ; <p>Create a new PostgresFullPrunedBlockStore, storing the tables in the schema specified.  You may want to
     ; specify a schema to avoid name collisions, or just to keep the database better organized.  The schema is not
     ; required, and if one is not provided than the default schema for the username will be used.  See
     ; <a href="http://www.postgres.org/docs/9.3/static/ddl-schemas.html">the postgres schema docs</a>
     ; for more on schemas.</p>
     ;
     ; @param params A copy of the NetworkParameters used.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param hostname The hostname of the database to connect to.
     ; @param dbName The database to connect to.
     ; @param username The database username.
     ; @param password The password to the database.
     ; @param schemaName The name of the schema to put the tables in.  May be null if no schema is being used.
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    (§ constructor PostgresFullPrunedBlockStore(§ args NetworkParameters params, int fullStoreDepth, String hostname, String dbName, String username, String password, #_nilable String schemaName))
        (§ throws BlockStoreException)
    (§ block
        (§ super (§ pars params, DATABASE_CONNECTION_URL_PREFIX + hostname + "/" + dbName, fullStoreDepth, username, password, schemaName))
    )

    #_override
    #_protected
    (§ method String getDuplicateKeyErrorCode(§ args ))
    (§ block
        (§ return POSTGRES_DUPLICATE_KEY_ERROR_CODE)
    )

    #_override
    #_protected
    (§ method List<String> getCreateTablesSQL(§ args ))
    (§ block
        (§ var List<String> sql = new ArrayList<>(§ pars ))
        (§ call sql.add(§ pars CREATE_SETTINGS_TABLE))
        (§ call sql.add(§ pars CREATE_HEADERS_TABLE))
        (§ call sql.add(§ pars CREATE_UNDOABLE_TABLE))
        (§ call sql.add(§ pars CREATE_OPEN_OUTPUT_TABLE))
        (§ return sql)
    )

    #_override
    #_protected
    (§ method List<String> getCreateIndexesSQL(§ args ))
    (§ block
        (§ var List<String> sql = new ArrayList<>(§ pars ))
        (§ call sql.add(§ pars CREATE_UNDOABLE_TABLE_INDEX))
        (§ call sql.add(§ pars CREATE_OUTPUTS_ADDRESS_MULTI_INDEX))
        (§ call sql.add(§ pars CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX))
        (§ call sql.add(§ pars CREATE_OUTPUTS_HASH_INDEX))
        (§ call sql.add(§ pars CREATE_OUTPUTS_TOADDRESS_INDEX))
        (§ return sql)
    )

    #_override
    #_protected
    (§ method List<String> getCreateSchemeSQL(§ args ))
    (§ block
        (§ var List<String> sql = new ArrayList<>(§ pars ))
        (§ call sql.add(§ pars "CREATE SCHEMA IF NOT EXISTS " + schemaName))
        (§ call sql.add(§ pars "set search_path to '" + schemaName +"'"))
        (§ return sql)
    )

    #_override
    #_protected
    (§ method String getDatabaseDriverClass(§ args ))
    (§ block
        (§ return DATABASE_DRIVER_CLASS)
    )

    #_override
    #_public
    (§ method void put(§ args StoredBlock storedBlock, StoredUndoableBlock undoableBlock))
        (§ throws BlockStoreException)
    (§ block
        (§ call maybeConnect(§ pars ))
        ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
        (§ var byte[] hashBytes = new byte[28])
        (§ call System.arraycopy(§ pars storedBlock.getHeader(§ pars ).getHash(§ pars ).getBytes(§ pars ), 4, hashBytes, 0, 28))
        (§ var int height = storedBlock.getHeight(§ pars ))
        (§ var byte[] transactions = nil)
        (§ var byte[] txOutChanges = nil)
        (§ try )
        (§ block
            (§ var ByteArrayOutputStream bos = new ByteArrayOutputStream(§ pars ))
            (§ if (§ expr undoableBlock.getTxOutChanges(§ pars ) != nil))
            (§ block
                (§ call undoableBlock.getTxOutChanges(§ pars ).serializeToStream(§ pars bos))
                (§ ass txOutChanges = bos.toByteArray(§ pars ))
            )
            (§ else )
            (§ block
                (§ var int numTxn = undoableBlock.getTransactions(§ pars ).size(§ pars ))
                (§ call bos.write(§ pars 0xff & numTxn))
                (§ call bos.write(§ pars 0xff & (§ expr numTxn >> 8)))
                (§ call bos.write(§ pars 0xff & (§ expr numTxn >> 16)))
                (§ call bos.write(§ pars 0xff & (§ expr numTxn >> 24)))
                (§ for (§ var Transaction tx) :for (§ expr undoableBlock.getTransactions(§ pars )))
                (§ block
                    (§ call tx.bitcoinSerialize(§ pars bos))
                )
                (§ ass transactions = bos.toByteArray(§ pars ))
            )
            (§ call bos.close(§ pars ))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )

        (§ try )
        (§ block
            (§ if (§ expr log.isDebugEnabled(§ pars )))
            (§ block
                (§ call log.debug(§ pars "Looking for undoable block with hash: " + Utils.HEX.encode(§ pars hashBytes)))
            )

            (§ var PreparedStatement findS = conn.get(§ pars ).prepareStatement(§ pars SELECT_UNDOABLEBLOCKS_EXISTS_SQL))
            (§ call findS.setBytes(§ pars 1, hashBytes))

            (§ var ResultSet rs = findS.executeQuery(§ pars ))
            (§ if (§ expr rs.next(§ pars )))
            (§ block
                ;; We already have this output, update it.
                (§ call findS.close(§ pars ))

                ;; Postgres insert-or-updates are very complex (and finnicky).
                ;; This level of transaction isolation seems to work for bitcoinj.
                (§ var PreparedStatement ps = conn.get(§ pars ).prepareStatement(§ pars getUpdateUndoableBlocksSQL(§ pars )))
                (§ call ps.setBytes(§ pars 3, hashBytes))

                (§ if (§ expr log.isDebugEnabled(§ pars )))
                (§ block
                    (§ call log.debug(§ pars "Updating undoable block with hash: " + Utils.HEX.encode(§ pars hashBytes)))
                )

                (§ if (§ expr transactions == nil))
                (§ block
                    (§ call ps.setBytes(§ pars 1, txOutChanges))
                    (§ call ps.setNull(§ pars 2, Types.BINARY))
                )
                (§ else )
                (§ block
                    (§ call ps.setNull(§ pars 1, Types.BINARY))
                    (§ call ps.setBytes(§ pars 2, transactions))
                )
                (§ call ps.executeUpdate(§ pars ))
                (§ call ps.close(§ pars ))

                (§ return )
            )

            (§ var PreparedStatement ps = conn.get(§ pars ).prepareStatement(§ pars getInsertUndoableBlocksSQL(§ pars )))
            (§ call ps.setBytes(§ pars 1, hashBytes))
            (§ call ps.setInt(§ pars 2, height))

            (§ if (§ expr log.isDebugEnabled(§ pars )))
            (§ block
                (§ call log.debug(§ pars "Inserting undoable block with hash: " + Utils.HEX.encode(§ pars hashBytes)  + " at height " + height))
            )

            (§ if (§ expr transactions == nil))
            (§ block
                (§ call ps.setBytes(§ pars 3, txOutChanges))
                (§ call ps.setNull(§ pars 4, Types.BINARY))
            )
            (§ else )
            (§ block
                (§ call ps.setNull(§ pars 3, Types.BINARY))
                (§ call ps.setBytes(§ pars 4, transactions))
            )
            (§ call ps.executeUpdate(§ pars ))
            (§ call ps.close(§ pars ))
            (§ try )
            (§ block
                (§ call putUpdateStoredBlock(§ pars storedBlock, true))
            )
            (§ catch (§ args SQLException e))
            (§ block
                (§ throw (§ new BlockStoreException(§ pars e)))
            )
        )
        (§ catch (§ args SQLException e))
        (§ block
            (§ if (§ expr !e.getSQLState(§ pars ).equals(§ pars POSTGRES_DUPLICATE_KEY_ERROR_CODE)))
            (§ block
                (§ throw (§ new BlockStoreException(§ pars e)))
            )
        )
    )
)

#_(ns org.bitcoinj.store #_"SPVBlockStore"
    (:import [java.io *]
             [java.nio *]
             [java.nio.channels *]
             [java.util *]
             [java.util.concurrent.locks *])
    (:import [com.google.common.base Charsets Preconditions]
             [org.slf4j *])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.utils *]))

;; TODO: Lose the mmap in this class.  There are too many platform bugs that require odd workarounds.

;;;
 ; An SPVBlockStore holds a limited number of block headers in a memory mapped ring buffer.  With such a store,
 ; you may not be able to process very deep re-orgs and could be disconnected from the chain (requiring a replay),
 ; but as they are virtually unheard of this is not a significant risk.
 ;;
#_public
(§ class SPVBlockStore implements BlockStore
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars SPVBlockStore.class))

    ;;; The default number of headers that will be stored in the ring buffer. ;;
    #_public
    #_static
    #_final
    (§ field int DEFAULT_CAPACITY = 5000)
    #_public
    #_static
    #_final
    (§ field String HEADER_MAGIC = "SPVB")

    #_protected
    #_volatile
    (§ field MappedByteBuffer buffer)
    #_protected
    #_final
    (§ field int capacity)
    #_protected
    #_final
    (§ field NetworkParameters params)

    #_protected
    (§ field ReentrantLock lock = Threading.lock(§ pars "SPVBlockStore"))

    ;; The entire ring-buffer is mmapped and accessing it should be as fast as accessing regular memory once it's
    ;; faulted in.  Unfortunately, in theory practice and theory are the same.  In practice they aren't.
    ;;
    ;; MMapping a file in Java does not give us a byte[] as you may expect but rather a ByteBuffer, and whilst on
    ;; the OpenJDK/Oracle JVM calls into the get() methods are compiled down to inlined native code on Android each
    ;; get() call is actually a full-blown JNI method under the hood, meaning it's unbelievably slow.  The caches
    ;; below let us stay in the JIT-compiled Java world without expensive JNI transitions and make a 10x difference!
    #_protected
    (§ field LinkedHashMap<Sha256Hash, StoredBlock> blockCache = new LinkedHashMap<Sha256Hash, StoredBlock>(§ pars )
        (§ anon
            #_override
            #_protected
            (§ method boolean removeEldestEntry(§ args Map.Entry<Sha256Hash, StoredBlock> entry))
            (§ block
                (§ return (§ expr 2050 < size(§ pars ))) ;; Slightly more than the difficulty transition period.
            )
        ))

    ;; Use a separate cache to track get() misses.  This is to efficiently handle the case of an unconnected block
    ;; during chain download.  Each new block will do a get() on the unconnected block so if we haven't seen it yet
    ;; we must efficiently respond.
    ;;
    ;; We don't care about the value in this cache.  It is always notFoundMarker.  Unfortunately LinkedHashSet does
    ;; not provide the removeEldestEntry control.
    #_private
    #_static
    #_final
    (§ field Object NOT_FOUND_MARKER = new Object(§ pars ))
    #_protected
    (§ field LinkedHashMap<Sha256Hash, Object> notFoundCache = new LinkedHashMap<Sha256Hash, Object>(§ pars )
        (§ anon
            #_override
            #_protected
            (§ method boolean removeEldestEntry(§ args Map.Entry<Sha256Hash, Object> entry))
            (§ block
                (§ return (§ expr 100 < size(§ pars ))) ;; This was chosen arbitrarily.
            )
        ))

    ;; Used to stop other applications/processes from opening the store.
    #_protected
    (§ field FileLock fileLock)
    #_protected
    (§ field RandomAccessFile randomAccessFile)

    ;;;
     ; Creates and initializes an SPV block store that can hold {@link #DEFAULT_CAPACITY} blocks.
     ; Will create the given file if it's missing.  This operation will block on disk.
     ; @param file File to use for the block store.
     ; @throws BlockStoreException if something goes wrong.
     ;;
    #_public
    (§ constructor SPVBlockStore(§ args NetworkParameters params, File file))
        (§ throws BlockStoreException)
    (§ block
        (§ this (§ pars params, file, DEFAULT_CAPACITY))
    )

    ;;;
     ; Creates and initializes an SPV block store that can hold a given amount of blocks.
     ; Will create the given file if it's missing.  This operation will block on disk.
     ; @param file File to use for the block store.
     ; @param capacity Custom capacity.
     ; @throws BlockStoreException if something goes wrong.
     ;;
    #_public
    (§ constructor SPVBlockStore(§ args NetworkParameters params, File file, int capacity))
        (§ throws BlockStoreException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars file))
        (§ ass this.params = Preconditions.checkNotNull(§ pars params))
        (§ call Preconditions.checkArgument(§ pars capacity > 0))

        (§ ass this.capacity = capacity)
        (§ try )
        (§ block
            (§ var boolean exists = file.exists(§ pars ))
            ;; Set up the backing file.
            (§ ass randomAccessFile = new RandomAccessFile(§ pars file, "rw"))
            (§ var long fileSize = getFileSize(§ pars capacity))
            (§ if (§ expr !exists))
            (§ block
                (§ call log.info(§ pars "Creating new SPV block chain file " + file))
                (§ call randomAccessFile.setLength(§ pars fileSize))
            )
            (§ elseif (§ expr randomAccessFile.length(§ pars ) != fileSize))
            (§ block
                (§ throw (§ new BlockStoreException(§ pars "File size on disk does not match expected size: " + randomAccessFile.length(§ pars ) + " vs " + fileSize)))
            )

            (§ var FileChannel channel = randomAccessFile.getChannel(§ pars ))
            (§ ass fileLock = channel.tryLock(§ pars ))
            (§ if (§ expr fileLock == nil))
            (§ block
                (§ throw (§ new ChainFileLockedException(§ pars "Store file is already locked by another process")))
            )

            ;; Map it into memory read/write.  The kernel will take care of flushing writes to disk at the most
            ;; efficient times, which may mean that until the map is deallocated the data on disk is randomly
            ;; inconsistent.  However the only process accessing it is us, via this mapping, so our own view will
            ;; always be correct.  Once we establish the mmap the underlying file and channel can go away.  Note
            ;; that the details of mmapping vary between platforms.
            (§ ass buffer = channel.map(§ pars FileChannel.MapMode.READ_WRITE, 0, fileSize))

            ;; Check or initialize the header bytes to ensure we don't try to open some random file.
            (§ var byte[] header)
            (§ if (§ expr exists))
            (§ block
                (§ ass header = new byte[4])
                (§ call buffer.get(§ pars header))
                (§ if (§ expr !(§ new String(§ pars header, Charsets.US_ASCII)).equals(§ pars HEADER_MAGIC)))
                (§ block
                    (§ throw (§ new BlockStoreException(§ pars "Header bytes do not equal " + HEADER_MAGIC)))
                )
            )
            (§ else )
            (§ block
                (§ call initNewStore(§ pars params))
            )
        )
        (§ catch (§ args Exception e1))
        (§ block
            (§ try )
            (§ block
                (§ if (§ expr randomAccessFile != nil))
                (§ block
                    (§ call randomAccessFile.close(§ pars ))
                )
            )
            (§ catch (§ args IOException e2))
            (§ block
                (§ throw (§ new BlockStoreException(§ pars e2)))
            )
            (§ throw (§ new BlockStoreException(§ pars e1)))
        )
    )

    #_private
    (§ method void initNewStore(§ args NetworkParameters params))
        (§ throws Exception)
    (§ block
        (§ var byte[] header = HEADER_MAGIC.getBytes(§ pars "US-ASCII"))
        (§ call buffer.put(§ pars header))
        ;; Insert the genesis block.
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call setRingCursor(§ pars buffer, FILE_PROLOGUE_BYTES))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
        (§ var Block genesis = params.getGenesisBlock(§ pars ).cloneAsHeader(§ pars ))
        (§ var StoredBlock storedGenesis = new StoredBlock(§ pars genesis, genesis.getWork(§ pars ), 0))
        (§ call put(§ pars storedGenesis))
        (§ call setChainHead(§ pars storedGenesis))
    )

    ;;; Returns the size in bytes of the file that is used to store the chain with the current parameters. ;;
    #_public
    #_static
    #_final
    (§ method int getFileSize(§ args int capacity))
    (§ block
        (§ return RECORD_SIZE * capacity + FILE_PROLOGUE_BYTES) ;; extra kilobyte for stuff
    )

    #_override
    #_public
    (§ method void put(§ args StoredBlock block))
        (§ throws BlockStoreException)
    (§ block
        #_final
        (§ var MappedByteBuffer buffer = this.buffer)
        (§ if (§ expr buffer == nil))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars "Store closed")))
        )

        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var int cursor = getRingCursor(§ pars buffer))
            ;; Wrapped around.
            (§ if (§ expr cursor == getFileSize(§ pars capacity)))
            (§ block
                (§ ass cursor = FILE_PROLOGUE_BYTES)
            )
            (§ call buffer.position(§ pars cursor))
            (§ var Sha256Hash hash = block.getHeader(§ pars ).getHash(§ pars ))
            (§ call notFoundCache.remove(§ pars hash))
            (§ call buffer.put(§ pars hash.getBytes(§ pars )))
            (§ call block.serializeCompact(§ pars buffer))
            (§ call setRingCursor(§ pars buffer, buffer.position(§ pars )))
            (§ call blockCache.put(§ pars hash, block))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_override
    #_nilable
    #_public
    (§ method StoredBlock get(§ args Sha256Hash hash))
        (§ throws BlockStoreException)
    (§ block
        #_final
        (§ var MappedByteBuffer buffer = this.buffer)
        (§ if (§ expr buffer == nil))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars "Store closed")))
        )

        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var StoredBlock cacheHit = blockCache.get(§ pars hash))
            (§ if (§ expr cacheHit != nil))
            (§ block
                (§ return cacheHit)
            )
            (§ if (§ expr notFoundCache.get(§ pars hash) != nil))
            (§ block
                (§ return nil)
            )

            ;; Starting from the current tip of the ring work backwards until we have either
            ;; found the block or wrapped around.
            (§ var int cursor = getRingCursor(§ pars buffer))
            #_final
            (§ var int startingPoint = cursor)
            #_final
            (§ var int fileSize = getFileSize(§ pars capacity))
            #_final
            (§ var byte[] targetHashBytes = hash.getBytes(§ pars ))
            (§ var byte[] scratch = new byte[32])
            (§ do )
            (§ block
                (§ ass cursor = cursor - RECORD_SIZE)
                ;; We hit the start, so wrap around.
                (§ if (§ expr cursor < FILE_PROLOGUE_BYTES))
                (§ block
                    (§ ass cursor = fileSize - RECORD_SIZE)
                )
                ;; Cursor is now at the start of the next record to check, so read the hash and compare it.
                (§ call buffer.position(§ pars cursor))
                (§ call buffer.get(§ pars scratch))
                (§ if (§ expr Arrays.equals(§ pars scratch, targetHashBytes)))
                (§ block
                    ;; Found the target.
                    (§ var StoredBlock storedBlock = StoredBlock.deserializeCompact(§ pars params, buffer))
                    (§ call blockCache.put(§ pars hash, storedBlock))
                    (§ return storedBlock)
                )
            )
            (§ again (§ expr cursor != startingPoint))

            ;; Not found.
            (§ call notFoundCache.put(§ pars hash, NOT_FOUND_MARKER))
            (§ return nil)
        )
        (§ catch (§ args ProtocolException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_protected
    (§ field StoredBlock lastChainHead)

    #_override
    #_public
    (§ method StoredBlock getChainHead(§ args ))
        (§ throws BlockStoreException)
    (§ block
        #_final
        (§ var MappedByteBuffer buffer = this.buffer)
        (§ if (§ expr buffer == nil))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars "Store closed")))
        )

        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr lastChainHead == nil))
            (§ block
                (§ var byte[] headHash = new byte[32])
                (§ call buffer.position(§ pars 8))
                (§ call buffer.get(§ pars headHash))
                (§ var Sha256Hash hash = Sha256Hash.wrap(§ pars headHash))
                (§ var StoredBlock block = get(§ pars hash))
                (§ if (§ expr block == nil))
                (§ block
                    (§ throw (§ new BlockStoreException(§ pars "Corrupted block store: could not find chain head: " + hash)))
                )

                (§ ass lastChainHead = block)
            )
            (§ return lastChainHead)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method void setChainHead(§ args StoredBlock chainHead))
        (§ throws BlockStoreException)
    (§ block
        #_final
        (§ var MappedByteBuffer buffer = this.buffer)
        (§ if (§ expr buffer == nil))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars "Store closed")))
        )

        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass lastChainHead = chainHead)
            (§ var byte[] headHash = chainHead.getHeader(§ pars ).getHash(§ pars ).getBytes(§ pars ))
            (§ call buffer.position(§ pars 8))
            (§ call buffer.put(§ pars headHash))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method void close(§ args ))
        (§ throws BlockStoreException)
    (§ block
        (§ try )
        (§ block
            (§ call buffer.force(§ pars ))
            (§ ass buffer = nil) ;; Allow it to be GCd and the underlying file mapping to go away.
            (§ call randomAccessFile.close(§ pars ))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new BlockStoreException(§ pars e)))
        )
    )

    #_override
    #_public
    (§ method NetworkParameters getParams(§ args ))
    (§ block
        (§ return params)
    )

    #_protected
    #_static
    #_final
    (§ field int RECORD_SIZE = 32 + StoredBlock.COMPACT_SERIALIZED_SIZE) ;; hash

    ;; File format:
    ;;   4 header bytes = "SPVB"
    ;;   4 cursor bytes, which indicate the offset from the first kb where the next block header should be written
    ;;   32 bytes for the hash of the chain head
    ;;
    ;; For each header (128 bytes)
    ;;   32 bytes hash of the header
    ;;   12 bytes of chain work
    ;;    4 bytes of height
    ;;   80 bytes of block header data
    #_protected
    #_static
    #_final
    (§ field int FILE_PROLOGUE_BYTES = 1024)

    ;;; Returns the offset from the file start where the latest block should be written (end of prev block). ;;
    #_private
    (§ method int getRingCursor(§ args ByteBuffer buffer))
    (§ block
        (§ var int c = buffer.getInt(§ pars 4))
        (§ call Preconditions.checkState(§ pars FILE_PROLOGUE_BYTES <= c, "Integer overflow"))
        (§ return c)
    )

    #_private
    (§ method void setRingCursor(§ args ByteBuffer buffer, int newCursor))
    (§ block
        (§ call Preconditions.checkArgument(§ pars 0 <= newCursor))
        (§ call buffer.putInt(§ pars 4, newCursor))
    )
)

#_(ns org.bitcoinj.uri #_"BitcoinURI"
    (:import [java.io UnsupportedEncodingException]
             [java.net URI URISyntaxException URLDecoder]
             [java.util ArrayList Collections LinkedHashMap List Locale Map])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.core Address AddressFormatException Coin NetworkParameters]
             [org.bitcoinj.params AbstractBitcoinNetParams]))

;;;
 ; <p>Provides a standard implementation of a Bitcoin URI with support for the following:</p>
 ;
 ; <ul>
 ; <li>URLEncoded URIs (as passed in by IE on the command line)</li>
 ; <li>BIP21 names (including the "req-" prefix handling requirements)</li>
 ; </ul>
 ;
 ; <h2>Accepted formats</h2>
 ;
 ; <p>The following input forms are accepted:</p>
 ;
 ; <ul>
 ; <li>{@code bitcoin:<address>}</li>
 ; <li>{@code bitcoin:<address>?<name1>=<value1>&<name2>=<value2>} with multiple additional name/value pairs</li>
 ; </ul>
 ;
 ; <p>The name/value pairs are processed as follows.</p>
 ; <ol>
 ; <li>URL encoding is stripped and treated as UTF-8</li>
 ; <li>names prefixed with {@code req-} are treated as required and if unknown or conflicting cause a parse exception</li>
 ; <li>Unknown names not prefixed with {@code req-} are added to a Map, accessible by parameter name</li>
 ; <li>Known names not prefixed with {@code req-} are processed unless they are malformed</li>
 ; </ol>
 ;
 ; <p>The following names are known and have the following formats:</p>
 ; <ul>
 ; <li>{@code amount} decimal value to 8 dp (e.g. 0.12345678) <b>Note that the exponent notation is not supported any more.</b></li>
 ; <li>{@code label} any URL encoded alphanumeric</li>
 ; <li>{@code message} any URL encoded alphanumeric</li>
 ; </ul>
 ;
 ; @author Andreas Schildbach (initial code)
 ; @author Jim Burton (enhancements for MultiBit)
 ; @author Gary Rowe (BIP21 support)
 ; @see <a href="https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki">BIP 0021</a>
 ;;
#_public
(§ class BitcoinURI
    ;; Not worth turning into an enum.
    #_public
    #_static
    #_final
    (§ field String FIELD_MESSAGE = "message")
    #_public
    #_static
    #_final
    (§ field String FIELD_LABEL = "label")
    #_public
    #_static
    #_final
    (§ field String FIELD_AMOUNT = "amount")
    #_public
    #_static
    #_final
    (§ field String FIELD_ADDRESS = "address")
    #_public
    #_static
    #_final
    (§ field String FIELD_PAYMENT_REQUEST_URL = "r")

    ;;;
     ; URI for Bitcoin network.  Use {@link org.bitcoinj.params.AbstractBitcoinNetParams#BITCOIN_SCHEME}
     ; if you specifically need Bitcoin, or use {@link org.bitcoinj.core.NetworkParameters#getUriScheme}
     ; to get the scheme from network parameters.
     ;;
    #_deprecated
    #_public
    #_static
    #_final
    (§ field String BITCOIN_SCHEME = "bitcoin")
    #_private
    #_static
    #_final
    (§ field String ENCODED_SPACE_CHARACTER = "%20")
    #_private
    #_static
    #_final
    (§ field String AMPERSAND_SEPARATOR = "&")
    #_private
    #_static
    #_final
    (§ field String QUESTION_MARK_SEPARATOR = "?")

    ;;;
     ; Contains all the parameters in the order in which they were processed.
     ;;
    #_private
    #_final
    (§ field Map<String, Object> parameterMap = new LinkedHashMap<>(§ pars ))

    ;;;
     ; Constructs a new BitcoinURI from the given string.  Can be for any network.
     ;
     ; @param uri The raw URI data to be parsed (see class comments for accepted formats).
     ; @throws BitcoinURIParseException if the URI is not syntactically or semantically valid.
     ;;
    #_public
    (§ constructor BitcoinURI(§ args String uri))
        (§ throws BitcoinURIParseException)
    (§ block
        (§ this (§ pars nil, uri))
    )

    ;;;
     ; Constructs a new object by trying to parse the input as a valid Bitcoin URI.
     ;
     ; @param params The network parameters that determine which network the URI is from, or null if you
     ;               don't have any expectation about what network the URI is for and wish to check yourself.
     ; @param input The raw URI data to be parsed (see class comments for accepted formats).
     ;
     ; @throws BitcoinURIParseException if the input fails Bitcoin URI syntax and semantic checks.
     ;;
    #_public
    (§ constructor BitcoinURI(§ args #_nilable NetworkParameters params, String input))
        (§ throws BitcoinURIParseException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars input))

        (§ var String scheme = (§ expr params != nil) ? params.getUriScheme(§ pars ) :else AbstractBitcoinNetParams.BITCOIN_SCHEME)

        ;; Attempt to form the URI (fail fast syntax checking to official standards).
        (§ var URI uri)
        (§ try )
        (§ block
            (§ ass uri = new URI(§ pars input))
        )
        (§ catch (§ args URISyntaxException e))
        (§ block
            (§ throw (§ new BitcoinURIParseException(§ pars "Bad URI syntax", e)))
        )

        ;; URI is formed as  bitcoin:<address>?<query parameters>
        ;; blockchain.info generates URIs of non-BIP compliant form bitcoin://address?....
        ;; We support both until Ben fixes his code.

        ;; Remove the bitcoin scheme.
        ;; (Note: getSchemeSpecificPart() is not used as it unescapes the label and parse then fails.
        ;; For instance with  bitcoin:129mVqKUmJ9uwPxKJBnNdABbuaaNfho4Ha?amount=0.06&label=Tom%20%26%20Jerry
        ;; the & (%26) in Tom and Jerry gets interpreted as a separator and the label then gets parsed
        ;; as 'Tom ' instead of 'Tom & Jerry'.)
        (§ var String blockchainInfoScheme = scheme + "://")
        (§ var String correctScheme = scheme + ":")
        (§ var String schemeSpecificPart)
        (§ if (§ expr input.startsWith(§ pars blockchainInfoScheme)))
        (§ block
            (§ ass schemeSpecificPart = input.substring(§ pars blockchainInfoScheme.length(§ pars )))
        )
        (§ elseif (§ expr input.startsWith(§ pars correctScheme)))
        (§ block
            (§ ass schemeSpecificPart = input.substring(§ pars correctScheme.length(§ pars )))
        )
        (§ else )
        (§ block
            (§ throw (§ new BitcoinURIParseException(§ pars "Unsupported URI scheme: " + uri.getScheme(§ pars ))))
        )

        ;; Split off the address from the rest of the query parameters.
        (§ var String[] addressSplitTokens = schemeSpecificPart.split(§ pars "\\?", 2))
        (§ if (§ expr addressSplitTokens.length == 0))
        (§ block
            (§ throw (§ new BitcoinURIParseException(§ pars "No data found after the bitcoin: prefix")))
        )

        (§ var String addressToken = addressSplitTokens[0]) ;; may be empty!

        (§ var String[] nameValuePairTokens)
        (§ if (§ expr addressSplitTokens.length == 1))
        (§ block
            ;; Only an address is specified - use an empty '<name>=<value>' token array.
            (§ ass nameValuePairTokens = new String[] (§ coll ))
        )
        (§ else )
        (§ block
            ;; Split into '<name>=<value>' tokens.
            (§ ass nameValuePairTokens = addressSplitTokens[1].split(§ pars "&"))
        )

        ;; Attempt to parse the rest of the URI parameters.
        (§ call parseParameters(§ pars params, addressToken, nameValuePairTokens))

        (§ if (§ expr !addressToken.isEmpty(§ pars )))
        (§ block
            ;; Attempt to parse the addressToken as a Bitcoin address for this network.
            (§ try )
            (§ block
                (§ var Address address = Address.fromBase58(§ pars params, addressToken))
                (§ call putWithValidation(§ pars FIELD_ADDRESS, address))
            )
            (§ catch (§ args #_final AddressFormatException e))
            (§ block
                (§ throw (§ new BitcoinURIParseException(§ pars "Bad address", e)))
            )
        )

        (§ if (§ expr addressToken.isEmpty(§ pars ) && getPaymentRequestUrl(§ pars ) == nil))
        (§ block
            (§ throw (§ new BitcoinURIParseException(§ pars "No address and no r= parameter found")))
        )
    )

    ;;;
     ; @param params The network parameters or null.
     ; @param nameValuePairTokens The tokens representing the name value pairs (assumed to be separated by '=' e.g. 'amount=0.2').
     ;;
    #_private
    (§ method void parseParameters(§ args #_nilable NetworkParameters params, String addressToken, String[] nameValuePairTokens))
        (§ throws BitcoinURIParseException)
    (§ block
        ;; Attempt to decode the rest of the tokens into a parameter map.
        (§ for (§ var String nameValuePairToken) :for (§ expr nameValuePairTokens))
        (§ block
            #_final
            (§ var int sepIndex = nameValuePairToken.indexOf(§ pars "="))
            (§ if (§ expr sepIndex == -1))
            (§ block
                (§ throw (§ new BitcoinURIParseException(§ pars "Malformed Bitcoin URI - no separator in '" + nameValuePairToken + "'")))
            )
            (§ if (§ expr sepIndex == 0))
            (§ block
                (§ throw (§ new BitcoinURIParseException(§ pars "Malformed Bitcoin URI - empty name '" + nameValuePairToken + "'")))
            )

            #_final
            (§ var String nameToken = nameValuePairToken.substring(§ pars 0, sepIndex).toLowerCase(§ pars Locale.ENGLISH))
            #_final
            (§ var String valueToken = nameValuePairToken.substring(§ pars sepIndex + 1))

            ;; Parse the amount.
            (§ if (§ expr FIELD_AMOUNT.equals(§ pars nameToken)))
            (§ block
                ;; Decode the amount (contains an optional decimal component to 8dp).
                (§ try )
                (§ block
                    (§ var Coin amount = Coin.parseCoin(§ pars valueToken))
                    (§ if (§ expr params != nil && amount.isGreaterThan(§ pars params.getMaxMoney(§ pars ))))
                    (§ block
                        (§ throw (§ new BitcoinURIParseException(§ pars "Max number of coins exceeded")))
                    )
                    (§ if (§ expr amount.signum(§ pars ) < 0))
                    (§ block
                        (§ throw (§ new ArithmeticException(§ pars "Negative coins specified")))
                    )

                    (§ call putWithValidation(§ pars FIELD_AMOUNT, amount))
                )
                (§ catch (§ args IllegalArgumentException e))
                (§ block
                    (§ throw (§ new OptionalFieldValidationException(§ pars String.format(§ pars Locale.US, "'%s' is not a valid amount", valueToken), e)))
                )
                (§ catch (§ args ArithmeticException e))
                (§ block
                    (§ throw (§ new OptionalFieldValidationException(§ pars String.format(§ pars Locale.US, "'%s' has too many decimal places", valueToken), e)))
                )
            )
            (§ else )
            (§ block
                (§ if (§ expr nameToken.startsWith(§ pars "req-")))
                (§ block
                    ;; A required parameter that we do not know about.
                    (§ throw (§ new RequiredFieldValidationException(§ pars "'" + nameToken + "' is required but not known, this URI is not valid")))
                )

                ;; Known fields and unknown parameters that are optional.
                (§ try )
                (§ block
                    (§ if (§ expr 0 < valueToken.length(§ pars )))
                    (§ block
                        (§ call putWithValidation(§ pars nameToken, URLDecoder.decode(§ pars valueToken, "UTF-8")))
                    )
                )
                (§ catch (§ args UnsupportedEncodingException e))
                (§ block
                    (§ throw (§ new RuntimeException(§ pars e))) ;; Can't happen.
                )
            )
        )

        ;; Note to the future:
        ;; when you want to implement 'req-expires', have a look at commit 410a53791841 which had it in.
    )

    ;;;
     ; Put the value against the key in the map checking for duplication.  This avoids address field overwrite etc.
     ;
     ; @param key The key for the map.
     ; @param value The value to store.
     ;;
    #_private
    (§ method void putWithValidation(§ args String key, Object value))
        (§ throws BitcoinURIParseException)
    (§ block
        (§ if (§ expr parameterMap.containsKey(§ pars key)))
        (§ block
            (§ throw (§ new BitcoinURIParseException(§ pars String.format(§ pars Locale.US, "'%s' is duplicated, URI is invalid", key))))
        )

        (§ call parameterMap.put(§ pars key, value))
    )

    ;;;
     ; The Bitcoin Address from the URI, if one was present.  It's possible to have Bitcoin URI's with no address
     ; if a r= payment protocol parameter is specified, though this form is not recommended as older wallets
     ; can't understand it.
     ;;
    #_nilable
    #_public
    (§ method Address getAddress(§ args ))
    (§ block
        (§ return (§ cast Address)parameterMap.get(§ pars FIELD_ADDRESS))
    )

    ;;;
     ; @return The amount name encoded using a pure integer value based at 10,000,000 units is 1 BTC.
     ;         May be null if no amount is specified.
     ;;
    #_public
    (§ method Coin getAmount(§ args ))
    (§ block
        (§ return (§ cast Coin)parameterMap.get(§ pars FIELD_AMOUNT))
    )

    ;;;
     ; @return the label from the URI.
     ;;
    #_public
    (§ method String getLabel(§ args ))
    (§ block
        (§ return (§ cast String)parameterMap.get(§ pars FIELD_LABEL))
    )

    ;;;
     ; @return the message from the URI.
     ;;
    #_public
    (§ method String getMessage(§ args ))
    (§ block
        (§ return (§ cast String)parameterMap.get(§ pars FIELD_MESSAGE))
    )

    ;;;
     ; @return the URL where a payment request (as specified in BIP 70) may be fetched.
     ;;
    #_public
    #_final
    (§ method String getPaymentRequestUrl(§ args ))
    (§ block
        (§ return (§ cast String)parameterMap.get(§ pars FIELD_PAYMENT_REQUEST_URL))
    )

    ;;;
     ; Returns the URLs where a payment request (as specified in BIP 70) may be fetched.
     ; The first URL is the main URL, all subsequent URLs are fallbacks.
     ;;
    #_public
    (§ method List<String> getPaymentRequestUrls(§ args ))
    (§ block
        (§ var ArrayList<String> urls = new ArrayList<>(§ pars ))
        (§ while (§ expr true))
        (§ block
            (§ var int i = urls.size(§ pars ))
            (§ var String paramName = FIELD_PAYMENT_REQUEST_URL + (§ expr 0 < i ? Integer.toString(§ pars i) :else ""))
            (§ var String url = (§ cast String)parameterMap.get(§ pars paramName))
            (§ if (§ expr url == nil))
            (§ block
                (§ break )
            )
            (§ call urls.add(§ pars url))
        )
        (§ call Collections.reverse(§ pars urls))
        (§ return urls)
    )

    ;;;
     ; @param name The name of the parameter.
     ; @return the parameter value, or null if not present.
     ;;
    #_public
    (§ method Object getParameterByName(§ args String name))
    (§ block
        (§ return parameterMap.get(§ pars name))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ var StringBuilder sb = new StringBuilder(§ pars "BitcoinURI["))
        (§ var boolean first = true)
        (§ for (§ var Map.Entry<String, Object> entry) :for (§ expr parameterMap.entrySet(§ pars )))
        (§ block
            (§ if (§ expr first))
            (§ block
                (§ ass first = false)
            )
            (§ else )
            (§ block
                (§ call sb.append(§ pars ","))
            )
            (§ call sb.append(§ pars "'").append(§ pars entry.getKey(§ pars )).append(§ pars "'='").append(§ pars entry.getValue(§ pars )).append(§ pars "'"))
        )
        (§ call sb.append(§ pars "]"))
        (§ return sb.toString(§ pars ))
    )

    ;;;
     ; Simple Bitcoin URI builder using known good fields.
     ;
     ; @param address The Bitcoin address.
     ; @param amount The amount.
     ; @param label A label.
     ; @param message A message.
     ; @return a String containing the Bitcoin URI.
     ;;
    #_public
    #_static
    (§ method String convertToBitcoinURI(§ args Address address, Coin amount, String label, String message))
    (§ block
        (§ return convertToBitcoinURI(§ pars address.getParameters(§ pars ), address.toString(§ pars ), amount, label, message))
    )

    ;;;
     ; Simple Bitcoin URI builder using known good fields.
     ;
     ; @param params The network parameters that determine which network the URI is for.
     ; @param address The Bitcoin address.
     ; @param amount The amount.
     ; @param label A label.
     ; @param message A message.
     ; @return a String containing the Bitcoin URI.
     ;;
    #_public
    #_static
    (§ method String convertToBitcoinURI(§ args NetworkParameters params, String address, #_nilable Coin amount, #_nilable String label, #_nilable String message))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars params))
        (§ call Preconditions.checkNotNull(§ pars address))

        (§ if (§ expr amount != nil && amount.signum(§ pars ) < 0))
        (§ block
            (§ throw (§ new IllegalArgumentException(§ pars "Coin must be positive")))
        )

        (§ var StringBuilder sb = new StringBuilder(§ pars ))
        (§ var String scheme = params.getUriScheme(§ pars ))
        (§ call sb.append(§ pars scheme).append(§ pars ":").append(§ pars address))

        (§ var boolean questionMarkHasBeenOutput = false)

        (§ if (§ expr amount != nil))
        (§ block
            (§ call sb.append(§ pars QUESTION_MARK_SEPARATOR).append(§ pars FIELD_AMOUNT).append(§ pars "="))
            (§ call sb.append(§ pars amount.toPlainString(§ pars )))
            (§ ass questionMarkHasBeenOutput = true)
        )

        (§ if (§ expr label != nil && !"".equals(§ pars label)))
        (§ block
            (§ if (§ expr questionMarkHasBeenOutput))
            (§ block
                (§ call sb.append(§ pars AMPERSAND_SEPARATOR))
            )
            (§ else )
            (§ block
                (§ call sb.append(§ pars QUESTION_MARK_SEPARATOR))
                (§ ass questionMarkHasBeenOutput = true)
            )
            (§ call sb.append(§ pars FIELD_LABEL).append(§ pars "=").append(§ pars encodeURLString(§ pars label)))
        )

        (§ if (§ expr message != nil && !"".equals(§ pars message)))
        (§ block
            (§ if (§ expr questionMarkHasBeenOutput))
            (§ block
                (§ call sb.append(§ pars AMPERSAND_SEPARATOR))
            )
            (§ else )
            (§ block
                (§ call sb.append(§ pars QUESTION_MARK_SEPARATOR))
            )
            (§ call sb.append(§ pars FIELD_MESSAGE).append(§ pars "=").append(§ pars encodeURLString(§ pars message)))
        )

        (§ return sb.toString(§ pars ))
    )

    ;;;
     ; Encode a string using URL encoding.
     ;
     ; @param stringToEncode The string to URL encode.
     ;;
    #_static
    (§ method String encodeURLString(§ args String stringToEncode))
    (§ block
        (§ try )
        (§ block
            (§ return java.net.URLEncoder.encode(§ pars stringToEncode, "UTF-8").replace(§ pars "+", ENCODED_SPACE_CHARACTER))
        )
        (§ catch (§ args UnsupportedEncodingException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Can't happen.
        )
    )
)

#_(ns org.bitcoinj.uri #_"BitcoinURIParseException")

;;;
 ; <p>Exception to provide the following to {@link BitcoinURI}:</p>
 ; <ul>
 ; <li>Provision of parsing error messages.</li>
 ; </ul>
 ; <p>This base exception acts as a general failure mode not attributable to a specific cause (other than
 ; that reported in the exception message).  Since this is in English, it may not be worth reporting directly
 ; to the user other than as part of a "general failure to parse" response.</p>
 ;;
#_public
(§ class BitcoinURIParseException extends Exception
    #_public
    (§ constructor BitcoinURIParseException(§ args String s))
    (§ block
        (§ super (§ pars s))
    )

    #_public
    (§ constructor BitcoinURIParseException(§ args String s, Throwable throwable))
    (§ block
        (§ super (§ pars s, throwable))
    )
)

#_(ns org.bitcoinj.uri #_"OptionalFieldValidationException")

;;;
 ; <p>Exception to provide the following to {@link org.bitcoinj.uri.BitcoinURI}:</p>
 ; <ul>
 ; <li>Provision of parsing error messages.</li>
 ; </ul>
 ; <p>This exception occurs when an optional field is detected (under the Bitcoin URI scheme) and fails
 ; to pass the associated test (such as {@code amount} not being a valid number).</p>
 ;
 ; @since 0.3.0
 ;
 ;;
#_public
(§ class OptionalFieldValidationException extends BitcoinURIParseException
    #_public
    (§ constructor OptionalFieldValidationException(§ args String s))
    (§ block
        (§ super (§ pars s))
    )

    #_public
    (§ constructor OptionalFieldValidationException(§ args String s, Throwable throwable))
    (§ block
        (§ super (§ pars s, throwable))
    )
)

#_(ns org.bitcoinj.uri #_"RequiredFieldValidationException")

;;;
 ; <p>Exception to provide the following to {@link BitcoinURI}:</p>
 ; <ul>
 ; <li>Provision of parsing error messages.</li>
 ; </ul>
 ; <p>This exception occurs when a required field is detected (under the BIP21 rules) and fails
 ; to pass the associated test (such as {@code req-expires} being out of date), or the required field is unknown
 ; to this version of the client in which case it should fail for security reasons.</p>
 ;
 ; @since 0.3.0
 ;
 ;;
#_public
(§ class RequiredFieldValidationException extends BitcoinURIParseException
    #_public
    (§ constructor RequiredFieldValidationException(§ args String s))
    (§ block
        (§ super (§ pars s))
    )

    #_public
    (§ constructor RequiredFieldValidationException(§ args String s, Throwable throwable))
    (§ block
        (§ super (§ pars s, throwable))
    )
)

#_(ns org.bitcoinj.utils #_"BtcAutoFormat"
    (:import [java.math BigDecimal]
             #_static [java.math.BigDecimal ONE]
             #_static [java.math.BigDecimal ZERO]
             [java.math BigInteger]
             #_static [java.math.RoundingMode HALF_UP]
             [java.text DecimalFormat DecimalFormatSymbols NumberFormat]
             [java.util Locale])
    (:import [com.google.common.collect ImmutableList])
    (:import #_static [org.bitcoinj.core.Coin SMALLEST_UNIT_EXPONENT]))

;;;
 ; <p>This class, a concrete extension of {@link BtcFormat}, is distinguished by its
 ; accommodation of multiple denominational units as follows:
 ;
 ; <p>When formatting Bitcoin monetary values, an instance of this class automatically adjusts
 ; the denominational units in which it represents a given value so as to minimize the number
 ; of consecutive zeros in the number that is displayed, and includes either a currency code or
 ; symbol in the formatted value to indicate which denomination was chosen.
 ;
 ; <p>When parsing <code>String</code> representations of Bitcoin monetary values, instances of
 ; this class automatically recognize units indicators consisting of currency codes and
 ; symbols, including including those containing currency or metric prefixes such as
 ; <code>"¢"</code> or <code>"c"</code> to indicate hundredths, and interpret each number being
 ; parsed in accordance with the recognized denominational units.
 ;
 ; <p>A more detailed explanation, including examples, is in the documentation for the {@link
 ; BtcFormat} class, and further information beyond that is in the documentation for the {@link
 ; java.text.Format} class, from which this class descends.
 ;
 ; @see java.text.Format
 ; @see java.text.NumberFormat
 ; @see java.text.DecimalFormat
 ; @see DecimalFormatSymbols
 ; @see org.bitcoinj.core.Coin
 ;;

#_public
#_final
(§ class BtcAutoFormat extends BtcFormat
    ;;;
     ; Enum for specifying the style of currency indicators thas are used
     ; when formatting, ether codes or symbols.
     ;;
    #_public
    (§ enum Style
        ;; Notes:
         ; 1) The odd-looking character in the replacements below, named "currency sign," is used
         ;    in the patterns recognized by Java's number formatter.  A single occurrence of this
         ;    character specifies a currency symbol, while two adjacent occurrences indicate an
         ;    international currency code.
         ; 2) The positive and negative patterns each have three parts: prefix, number, suffix.
         ;    The number characters are limited to digits, zero, decimal-separator, group-separator,
         ;    and scientific-notation specifier: [#0.,E]
         ;    All number characters besides 'E' must be single-quoted in order to appear as
         ;    literals in either the prefix or suffix.
         ; These patterns are explained in the documentation for java.text.DecimalFormat.
         ;;

        ;;; Constant for the formatting style that uses a currency code, e.g. "BTC". ;;
        (§ item CODE
        (§ anon
            #_override
            (§ method void apply(§ args DecimalFormat decimalFormat))
            (§ block
                ;; To switch to using codes from symbols, we replace each single occurrence of the
                 ; currency-sign character with two such characters in a row.
                 ; We also insert a space character between every occurence of this character and an
                 ; adjacent numerical digit or negative sign (that is, between the currency-sign and
                 ; the signed-number).
                 ;;
                (§ call decimalFormat.applyPattern(§ pars negify(§ pars decimalFormat.toPattern(§ pars )).replaceAll(§ pars "¤", "¤¤").replaceAll(§ pars "([#0.,E-])¤¤", "$1 ¤¤").replaceAll(§ pars "¤¤([0#.,E-])", "¤¤ $1")))
            )
        ))

        ;;; Constant for the formatting style that uses a currency symbol, e.g. "฿". ;;
        (§ item SYMBOL
        (§ anon
            #_override
            (§ method void apply(§ args DecimalFormat decimalFormat))
            (§ block
                ;; To make certain we are using symbols rather than codes, we replace
                 ; each double occurrence of the currency sign character with a single.
                 ;;
                (§ call decimalFormat.applyPattern(§ pars negify(§ pars decimalFormat.toPattern(§ pars )).replaceAll(§ pars "¤¤", "¤")))
            )
        ))

        ;;; Effect a style corresponding to an enum value on the given number formatter object. ;;
        #_abstract
        (§ method void apply(§ args DecimalFormat decimalFormat))
    )

    ;;; Constructor. ;;
    #_protected
    (§ constructor BtcAutoFormat(§ args Locale locale, Style style, int fractionPlaces))
    (§ block
        (§ super (§ pars (§ cast DecimalFormat)NumberFormat.getCurrencyInstance(§ pars locale), fractionPlaces, ImmutableList.<Integer>of(§ pars )))

        (§ call style.apply(§ pars this.numberFormat))
    )

    ;;;
     ; Calculate the appropriate denomination for the given Bitcoin monetary value.
     ; This method takes a BigInteger representing a quantity of satoshis, and returns the
     ; number of places that value's decimal point is to be moved when formatting said value
     ; in order that the resulting number represents the correct quantity of denominational
     ; units.
     ;
     ; <p>As a side-effect, this sets the units indicators of the underlying NumberFormat object.
     ; Only invoke this from a synchronized method, and be sure to put the DecimalFormatSymbols
     ; back to its proper state, otherwise immutability, equals() and hashCode() fail.
     ;;
    #_override
    #_protected
    (§ method int scale(§ args BigInteger satoshis, int fractionPlaces))
    (§ block
        ;; The algorithm is as follows.  TODO: is there a way to optimize step 4?
         ; 1. Can we use coin denomination w/ no rounding?  If yes, do it.
         ; 2. Else, can we use millicoin denomination w/ no rounding?  If yes, do it.
         ; 3. Else, can we use micro denomination w/ no rounding?  If yes, do it.
         ; 4. Otherwise we must round:
         ;   (a) round to nearest coin + decimals
         ;   (b) round to nearest millicoin + decimals
         ;   (c) round to nearest microcoin + decimals
         ;   Subtract each of (a), (b) and (c) from the true value, and choose the
         ;   denomination that gives smallest absolute difference.  It case of tie,
         ;   use the smaller denomination.
         ;;
        (§ var int places)
        (§ var int coinOffset = Math.max(§ pars SMALLEST_UNIT_EXPONENT - fractionPlaces, 0))
        (§ var BigDecimal inCoins = new BigDecimal(§ pars satoshis).movePointLeft(§ pars coinOffset))
        (§ if (§ expr inCoins.remainder(§ pars ONE).compareTo(§ pars ZERO) == 0))
        (§ block
            (§ ass places = COIN_SCALE)
        )
        (§ else )
        (§ block
            (§ var BigDecimal inMillis = inCoins.movePointRight(§ pars MILLICOIN_SCALE))
            (§ if (§ expr inMillis.remainder(§ pars ONE).compareTo(§ pars ZERO) == 0))
            (§ block
                (§ ass places = MILLICOIN_SCALE)
            )
            (§ else )
            (§ block
                (§ var BigDecimal inMicros = inCoins.movePointRight(§ pars MICROCOIN_SCALE))
                (§ if (§ expr inMicros.remainder(§ pars ONE).compareTo(§ pars ZERO) == 0))
                (§ block
                    (§ ass places = MICROCOIN_SCALE)
                )
                (§ else )
                (§ block
                    ;; No way to avoid rounding: so what denomination gives smallest error?
                    (§ var BigDecimal a = inCoins.subtract(§ pars inCoins.setScale(§ pars 0, HALF_UP)).movePointRight(§ pars coinOffset).abs(§ pars ))
                    (§ var BigDecimal b = inMillis.subtract(§ pars inMillis.setScale(§ pars 0, HALF_UP)).movePointRight(§ pars coinOffset - MILLICOIN_SCALE).abs(§ pars ))
                    (§ var BigDecimal c = inMicros.subtract(§ pars inMicros.setScale(§ pars 0, HALF_UP)).movePointRight(§ pars coinOffset - MICROCOIN_SCALE).abs(§ pars ))
                    (§ if (§ expr a.compareTo(§ pars b) < 0))
                    (§ block
                        (§ ass places = (§ expr a.compareTo(§ pars c) < 0) ? COIN_SCALE :else MICROCOIN_SCALE)
                    )
                    (§ elseif (§ expr b.compareTo(§ pars c) < 0))
                    (§ block
                        (§ ass places = MILLICOIN_SCALE)
                    )
                    (§ else )
                    (§ block
                        (§ ass places = MICROCOIN_SCALE)
                    )
                )
            )
        )
        (§ call prefixUnitsIndicator(§ pars numberFormat, places))
        (§ return places)
    )

    ;;;
     ; Returns the <code>int</code> value indicating coin denomination.  This is what causes
     ; the number in a parsed value that lacks a units indicator to be interpreted as a quantity
     ; of bitcoins.
     ;;
    #_override
    #_protected
    (§ method int scale(§ args ))
    (§ block
        (§ return COIN_SCALE)
    )

    ;;;
     ; Return the number of decimal places in the fraction part of numbers formatted by this
     ; instance.  This is the maximum number of fraction places that will be displayed;
     ; the actual number used is limited to a precision of satoshis.
     ;;
    #_public
    (§ method int fractionPlaces(§ args ))
    (§ block
        (§ return minimumFractionDigits)
    )

    ;;;
     ; Return true if the other instance is equivalent to this one.
     ; Formatters for different locales will never be equal, even if they behave identically.
     ;;
    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr !(§ expr o instanceof BtcAutoFormat)))
        (§ block
            (§ return false)
        )
        (§ return super.equals(§ pars o))
    )

    ;;;
     ; Return a brief description of this formatter.  The exact details of the representation
     ; are unspecified and subject to change, but will include some representation of the
     ; pattern and the number of fractional decimal places.
     ;;
    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return "Auto-format " + pattern(§ pars ))
    )
)

#_(ns org.bitcoinj.utils #_"BtcFixedFormat"
    (:import [java.math BigInteger]
             [java.text DecimalFormat NumberFormat]
             [java.util Locale List])
    (:import [com.google.common.base Objects Preconditions])
    (:import #_static [org.bitcoinj.core.Coin SMALLEST_UNIT_EXPONENT]))

;;;
 ; This class, a concrete extension of {@link BtcFormat}, is distinguished in that each
 ; instance formats and by-default parses all Bitcoin monetary values in units of a single
 ; denomination that is specified at the time that instance is constructed.
 ;
 ; By default, neither currency codes nor symbols are included in formatted values as
 ; output, nor recognized in parsed values as input.  The can be overridden by applying a
 ; custom pattern using either the {@link BtcFormat.Builder#localizedPattern}
 ; or {@link BtcFormat.Builder#localizedPattern} methods, as described in the documentation
 ; for the {@link BtcFormat.Builder} class.
 ;
 ; A more detailed explanation, including examples, is in the documentation for the
 ; {@link BtcFormat} class, and further information beyond that is in the documentation
 ; for the {@link java.text.Format} class, from which this class descends.
 ;
 ; @see java.text.Format
 ; @see java.text.NumberFormat
 ; @see java.text.DecimalFormat
 ; @see org.bitcoinj.core.Coin
 ;;

#_public
#_final
(§ class BtcFixedFormat extends BtcFormat
    ;;;
     ; A constant specifying the use of as many optional decimal places in the fraction part
     ; of a formatted number as are useful for expressing precision.  This value can be passed
     ; as the final argument to a factory method or {@link #format(Object, int, int...)}.
     ;;
    #_public
    #_static
    #_final
    (§ field int[] REPEATING_PLACES = (§ coll 1,1,1,1,1,1,1,1,1,1,1,1,1,1 ))

    ;;;
     ; A constant specifying the use of as many optional groups of <strong>two</strong>
     ; decimal places in the fraction part of a formatted number as are useful for expressing
     ; precision.  This value can be passed as the final argument to a factory method or
     ; {@link #format(Object, int, int...)}.
     ;;
    #_public
    #_static
    #_final
    (§ field int[] REPEATING_DOUBLETS = (§ coll 2,2,2,2,2,2,2 ))

    ;;;
     ; A constant specifying the use of as many optional groups of <strong>three</strong>
     ; decimal places in the fraction part of a formatted number as are useful for expressing
     ; precision.  This value can be passed as the final argument to a factory method or
     ; {@link #format(Object, int, int...)}.
     ;;
    #_public
    #_static
    #_final
    (§ field int[] REPEATING_TRIPLETS = (§ coll 3,3,3,3,3 ))

    ;;;
     ; The number of places the decimal point of formatted values is shifted rightward from
     ; thet same value expressed in bitcoins.
     ;;
    #_private
    #_final
    (§ field int scale)

    ;;; Constructor. ;;
    #_protected
    (§ constructor BtcFixedFormat(§ args Locale locale, int scale, int minDecimals, List<Integer> groups))
    (§ block
        (§ super (§ pars (§ cast DecimalFormat)NumberFormat.getInstance(§ pars locale), minDecimals, groups))

        (§ call Preconditions.checkArgument(§ pars scale <= SMALLEST_UNIT_EXPONENT, "decimal cannot be shifted " + String.valueOf(§ pars scale) + " places"))

        (§ ass this.scale = scale)
    )

    ;;;
     ; Return the decimal-place shift for this object's unit-denomination.  For example, if
     ; the denomination is millibitcoins, this method will return the value <code>3</code>.
     ; As a side-effect, prefixes the currency signs of the underlying NumberFormat object.
     ; This method is invoked by the superclass when formatting.  The arguments are ignored
     ; because the denomination is fixed regardless of the value being formatted.
     ;;
    #_override
    #_protected
    (§ method int scale(§ args BigInteger satoshis, int fractionPlaces))
    (§ block
        (§ call prefixUnitsIndicator(§ pars numberFormat, scale))
        (§ return scale)
    )

    ;;;
     ; Return the decimal-place shift for this object's fixed unit-denomination.  For example,
     ; if the denomination is millibitcoins, this method will return the value <code>3</code>.
     ;;
    #_override
    #_public
    (§ method int scale(§ args ))
    (§ block
        (§ return scale)
    )

    ;;;
     ; Return the currency code that identifies the units in which values formatted and
     ; (by-default) parsed by this instance are denominated.  For example, if the formatter's
     ; denomination is millibitcoins, then this method will return <code>"mBTC"</code>,
     ; assuming the default base currency-code is not overridden using a {@link BtcFormat.Builder}.
     ;;
    #_public
    (§ method String code(§ args ))
    (§ block
        (§ return prefixCode(§ pars coinCode(§ pars ), scale))
    )

    ;;;
     ; Return the currency symbol that identifies the units in which values formatted by this
     ; instance are denominated.  For example, when invoked on an instance denominated in
     ; millibitcoins, this method by default returns <code>"₥฿"</code>, depending on the
     ; locale.
     ;;
    #_public
    (§ method String symbol(§ args ))
    (§ block
        (§ return prefixSymbol(§ pars coinSymbol(§ pars ), scale))
    )

    ;;;
     ; Return the fractional decimal-placing used when formatting.  This method returns an
     ; <code>int</code> array.  The value of the first element is the minimum number of
     ; decimal places to be used in all cases, limited to a precision of satoshis.  The value
     ; of each successive element is the size of an optional place-group that will be applied,
     ; possibly partially, if useful for expressing precision.  The actual size of each group
     ; is limited to, and may be reduced to the limit of, a precision of no smaller than
     ; satoshis.
     ;;
    #_public
    (§ method int[] fractionPlaceGroups(§ args ))
    (§ block
        (§ var Object[] boxedArray = decimalGroups.toArray(§ pars ))
        (§ var int len = boxedArray.length + 1)
        (§ var int[] array = new int[len])
        (§ ass array[0] = minimumFractionDigits)
        (§ for (§ var int i = 1) :for (§ expr i < len) :for (§ ass i = i + 1))
        (§ block
            (§ ass array[i] = (§ cast Integer)boxedArray[i-1])
        )
        (§ return array)
    )

    ;;;
     ; Return true if the given object is equivalent to this one.  Formatters for different
     ; locales will never be equal, even if they behave identically.
     ;;
    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr o == this))
        (§ block
            (§ return true)
        )
        (§ if (§ expr !(§ expr o instanceof BtcFixedFormat)))
        (§ block
            (§ return false)
        )
        (§ var BtcFixedFormat other = (§ cast BtcFixedFormat)o)
        (§ return (§ expr super.equals(§ pars other) && other.scale(§ pars ) == scale(§ pars ) && other.decimalGroups.equals(§ pars decimalGroups)))
    )

    ;;; Return a hash code value for this instance.
     ;  @see java.lang.Object#hashCode
     ;;
    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars super.hashCode(§ pars ), scale))
    )

    #_private
    #_static
    (§ method String prefixLabel(§ args int scale))
    (§ block
        (§ switch (§ expr scale))
        (§ block
            (§ case COIN_SCALE)
            (§ block
                (§ return "Coin-")
            )
            (§ case 1)
            (§ block
                (§ return "Decicoin-")
            )
            (§ case 2)
            (§ block
                (§ return "Centicoin-")
            )
            (§ case MILLICOIN_SCALE)
            (§ block
                (§ return "Millicoin-")
            )
            (§ case MICROCOIN_SCALE)
            (§ block
                (§ return "Microcoin-")
            )
            (§ case -1)
            (§ block
                (§ return "Dekacoin-")
            )
            (§ case -2)
            (§ block
                (§ return "Hectocoin-")
            )
            (§ case -3)
            (§ block
                (§ return "Kilocoin-")
            )
            (§ case -6)
            (§ block
                (§ return "Megacoin-")
            )
            (§ default )
            (§ block
                (§ return "Fixed (" + scale + ") ")
            )
        )
    )

    ;;;
     ; Returns a brief description of this formatter.  The exact details of the representation
     ; are unspecified and subject to change, but will include some representation of the
     ; formatting/parsing pattern and the fractional decimal place grouping.
     ;;
    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return prefixLabel(§ pars scale) + "format " + pattern(§ pars ))
    )
)

#_(ns org.bitcoinj.utils #_"BtcFormat"
    (:import [java.math BigDecimal BigInteger]
             #_static [java.math.RoundingMode HALF_UP]
             [java.text AttributedCharacterIterator DecimalFormat DecimalFormatSymbols FieldPosition Format NumberFormat ParseException ParsePosition]
             [java.util Locale List ArrayList]
             [java.util.regex Matcher Pattern])
    (:import [com.google.common.base Objects Preconditions Strings]
             [com.google.common.collect ImmutableList])
   (:require [org.bitcoinj.core Coin]
             [org.bitcoinj.utils.BtcAutoFormat Style]
             #_static [org.bitcoinj.utils.BtcAutoFormat.Style *]))

;;;
 ; <p>Instances of this class format and parse locale-specific numerical representations of Bitcoin monetary values.
 ;
 ; <p>A primary goal of this class is to minimize the danger of human-misreading of monetary values due to mis-counting
 ; the number of zeros (or, more generally, of decimal places) in the number that represents a Bitcoin monetary value.
 ; Some of the features offered for doing this are:
 ; <ol>
 ;   <li>automatic adjustment of denominational units in which a value is represented so as to lessen the number of adjacent zeros,
 ;   <li>use of locale-specific decimal-separators to group digits in the integer portion of formatted numbers,
 ;   <li>fine control over the number and  grouping of fractional decimal places, and
 ;   <li>access to character information that allows for vertical alignment of tabular columns of formatted values.
 ; </ol>
 ;
 ; <h3>Basic Usage</h3>
 ;
 ; Basic usage is very simple:
 ; <ol>
 ;   <li>Construct a new formatter object using one of the factory methods.
 ;   <li>Format a value by passing it as an argument to the {@link BtcFormat#format(Object)} method.
 ;   <li>Parse a value by passing a <code>String</code>-type representation of it to the {@link BtcFormat#parse(String)} method.
 ; </ol>
 ;
 ; <p>For example, depending on your locale, values might be formatted and parsed as follows:
 ;
 ; <blockquote><pre>
 ; BtcFormat f = BtcFormat.getInstance();
 ; String c = f.format(Coin.COIN);                <strong>// "BTC 1.00"</strong>
 ; String k = f.format(Coin.COIN.multiply(1000)); <strong>// "BTC 1,000.00"</strong>
 ; String m = f.format(Coin.COIN.divide(1000));   <strong>// "mBTC 1.00"</strong>
 ; Coin all = f.parseObject("M฿ 21");             <strong>// All the money in the world</strong>
 ; </pre></blockquote>
 ;
 ; <h3>Auto-Denomination versus Fixed-Denomination</h3>
 ;
 ; There are two provided concrete classes, one that automatically denominates values to be formatted, {@link BtcAutoFormat},
 ; and another that formats any value in units of a fixed, specified denomination, {@link BtcFixedFormat}.
 ;
 ; <h5>Automatic Denomination</h5>
 ;
 ; Automatic denomination means that the formatter adjusts the denominational units in which a formatted number is
 ; expressed based on the monetary value that number represents.  An auto-denominating formatter is defined by its
 ; style, specified by one of the enumerated values of {@link BtcAutoFormat.Style}.  There are two styles constants:
 ; {@link BtcAutoFormat.Style#CODE} (the default), and {@link BtcAutoFormat.Style#SYMBOL}.  The difference is that
 ; the <code>CODE</code> style uses an internationally-distinct currency code, such as <code>"BTC"</code>, to indicate
 ; the units of denomination, while the <code>SYMBOL</code> style uses a possibly-ambiguous currency symbol such as
 ; <code>"฿"</code>.
 ;
 ; <p>The denomination used when formatting will be either bitcoin, millicoin or microcoin, depending on the value
 ; being represented, chosen so as to minimize the number of consecutive zeros displayed without losing precision.
 ; For example, depending on the locale, a value of one bitcoin might be formatted as <pre>฿1.00</pre> where a value
 ; exceeding that by one satoshi would be <pre>µ฿1,000,000.01</pre>.
 ;
 ; <h5>Fixed Denomination</h5>
 ;
 ; Fixed denomination means that the same denomination of units is used for every value that is formatted or parsed
 ; by a given formatter instance.  A fixed-denomination formatter is defined by its scale, which is the number of
 ; places one must shift the decimal point in increasing precision to convert the representation of a given quantity
 ; of bitcoins into a representation of the same value denominated in the formatter's units.  For example, a scale
 ; value of <code>3</code> specifies a denomination of millibitcoins, because to represent <code>1.0000 BTC</code>,
 ; or one bitcoin, in millibitcoins, one shifts the decimal point three places, that is, to <code>1000.0 mBTC</code>.
 ;
 ; <h3>Construction</h3>
 ;
 ; There are two ways to obtain an instance of this class:
 ; <ol>
 ;   <li>Use one of the factory methods; or
 ;   <li>Use a {@link BtcFormat.Builder} object.
 ; </ol>
 ;
 ; <p>The factory methods are appropriate for basic use where the default configuration is either used or modified.
 ; The <code>Builder</code> class provides more control over the configuration, and gives access to some features
 ; not available through the factory methods, such as using custom formatting patterns and currency symbols.
 ;
 ; <h5>Factory Methods</h5>
 ;
 ; Although formatting and parsing is performed by one of the concrete subclasses, you can obtain formatters using
 ; the various static factory methods of this abstract base class <code>BtcFormat</code>.  There are a variety of
 ; overloaded methods that allow you to obtain a formatter that behaves according to your needs.
 ;
 ; <p>The primary distinction is between automatic- and fixed-denomination formatters.  By default, the
 ; <code>getInstance()</code> method with no arguments returns a new, automatic-denominating <code>BtcAutoFormat</code>
 ; instance for your default locale that will display exactly two fractional decimal places and a currency code.
 ; For example, if you happen to be in the USA:
 ;
 ; <blockquote><pre>
 ; BtcFormat f = BtcFormat.getInstance();
 ; String s = f.format(Coin.COIN); <strong>// "BTC 1.00"</strong>
 ; </pre></blockquote>
 ;
 ; <p>The first argument to <code>getInstance()</code> can determine whether you get an auto- or fixed-denominating
 ; formatter.  If the type of the first argument is an <code>int</code>, then the value of that <code>int</code>
 ; will be interpreted as the decimal-place scale of the {@link BtcFixedFormat} instance that is returned, and thus
 ; will determine its denomination.  For example, if you want to format values in units of microbitcoins:
 ;
 ; <blockquote><pre>
 ; BtcFormat m = BtcFormat.getInstance(6);
 ; String s = m.format(Coin.COIN); <strong>// "1,000,000.00"</strong>
 ; </pre></blockquote>
 ;
 ; <p>This class provides several constants bound to common scale values:
 ;
 ; <blockquote><pre>
 ; BtcFormat milliFormat = BtcFormat.getInstance(MILLICOIN_SCALE);
 ; </pre></blockquote>
 ;
 ; <p>Alternatively, if the type of the first argument to <code>getInstance()</code> is one of the enumerated values
 ; of the {@link BtcAutoFormat.Style} type, either <code>CODE</code> or <code>SYMBOL</code>, then you will get a
 ; {@link BtcAutoFormat} instance that uses either a currency code or symbol, respectively, to indicate the results
 ; of its auto-denomination.
 ;
 ; <blockquote><pre>
 ; BtcFormat s = BtcFormat.getInstance(SYMBOL);
 ; Coin value = Coin.parseCoin("0.1234");
 ; String mil = s.format(value);              <strong>// "₥฿123.40"</strong>
 ; String mic = s.format(value.divide(1000)); <strong>// "µ฿123.40"</strong>
 ; </pre></blockquote>
 ;
 ; <p>An alternative way to specify whether you want an auto- or fixed-denomination formatter is to use one
 ; of the factory methods that is named to indicate that characteristics of the new instance returned.  For
 ; fixed-denomination formatters, these methods are {@link #getCoinInstance()}, {@link #getMilliInstance()},
 ; and {@link #getMicroInstance()}.  These three methods are equivalent to invoking <code>getInstance()</code>
 ; with a first argument of <code>0</code>, <code>3</code> and <code>6</code>, respectively.  For auto-denominating
 ; formatters the relevant factory methods are {@link #getCodeInstance()} and {@link #getSymbolInstance()},
 ; which are equivalent to <code>getInstance(Style.CODE)</code>, and <code>getInstance(Style.SYMBOL)</code>.
 ;
 ; <p>Regardless of how you specify whether your new formatter is to be of automatic- or fixed-denomination, the
 ; next (and possibly first) parameter to each of the factory methods is an optional <code>Locale</code> value.
 ;
 ; For example, here we construct four instances for the same locale that each format
 ; differently the same one-bitcoin value:
 ;
 ; <blockquote><pre>
 ; <strong>// Next line returns "1,00 BTC"</strong>
 ; BtcFormat.getInstance(Locale.GERMANY).format(Coin.COIN);
 ; <strong>// Next line returns "1,00 ฿"</strong>
 ; BtcFormat.getInstance(SYMBOL, Locale.GERMANY).format(Coin.COIN);
 ; <strong>// Next line returns "1.000,00"</strong>
 ; BtcFormat.getMilliInstance(Locale.GERMANY).format(Coin.COIN);
 ; <strong>// Next line returns "10.000,00"</strong>
 ; BtcFormat.getInstance(4, Locale.GERMANY).format(Coin.COIN);
 ; </pre></blockquote>
 ;
 ; Omitting such a <code>Locale</code> parameter will give you a formatter for your default locale.
 ;
 ; <p>The final (and possibly only) arguments to the factory methods serve to set the default number of
 ; fractional decimal places that will be displayed when formatting monetary values.  In the case of an
 ; auto-denominating formatter, this can be a single <code>int</code> value, which will determine the number
 ; of fractional decimal places to be used in all cases, except where either (1) doing so would provide
 ; a place for fractional satoshis, or (2) that default value is overridden when invoking
 ; the <code>format()</code> method as described below.
 ;
 ; <p>In the case of a fixed-denomination formatter, you can pass any number of <code>int</code> values.
 ; The first will determine the minimum number of fractional decimal places, and each following <code>int</code>
 ; value specifies the size of an optional group of decimal-places to be displayed only if useful for expressing
 ; precision.  As with auto-denominating formatters, numbers will never be formatted with a decimal place that
 ; represents a fractional quantity of satoshis, and these defaults can be overridden by arguments to the
 ; <code>format()</code> method.  See below for examples.
 ;
 ; <h5>The <code>Builder</code> Class</h5>
 ;
 ; A new {@link BtcFormat.Builder} instance is returned by the {@link #builder()} method.  Such an object has
 ; methods that set the configuration parameters of a <code>BtcFormat</code> object.  Its {@link Builder#build()}
 ; method constructs and returns a <code>BtcFormat</code> instance configured according to those settings.
 ;
 ; <p>In addition to setter-methods that correspond to the factory-method parameters explained above,
 ; a <code>Builder</code> also allows you to specify custom formatting and parsing patterns and currency symbols
 ; and codes.  For example, rather than using the default currency symbol, which has the same unicode character
 ; point as the national currency symbol of Thailand, some people prefer to use a capital letter "B" with
 ; a vertical overstrike.
 ;
 ; <blockquote><pre>
 ; BtcFormat.Builder builder = BtcFormat.builder();
 ; builder.style(SYMBOL);
 ; builder.symbol("B&#x5c;u20e6"); <strong>// unicode char "double vertical stroke overlay"</strong>
 ; BtcFormat f = builder.build();
 ; String out = f.format(COIN); <strong>// "B⃦1.00" depending on locale</strong>
 ; </pre></blockquote>
 ;
 ; The <code>Builder</code> methods are chainable.  So, for example, if you are
 ; deferential to ISO 4217, you might construct a formatter in a single line this way:
 ;
 ; <blockquote><pre>
 ; BtcFormat f = BtcFormat.builder().style(CODE).code("XBT").build();
 ; String out = f.format(COIN); <strong>// "XBT 1.00"</strong>
 ; </pre></blockquote>
 ;
 ; <p>See the documentation of the {@link BtcFormat.Builder} class for details.
 ;
 ; <h3>Formatting</h3>
 ;
 ; <p>You format a Bitcoin monetary value by passing it to the {@link BtcFormat#format(Object)} method.  This argument
 ; can be either a {@link org.bitcoinj.core.Coin}-type object or a numerical object such as {@link java.lang.Long} or
 ; {@link java.math.BigDecimal}.  Integer-based types such as {@link java.math.BigInteger} are interpreted as representing
 ; a number of satoshis, while a {@link java.math.BigDecimal} is interpreted as representing a number of bitcoins.
 ; A value having a fractional amount of satoshis is rounded to the nearest whole satoshi at least, and possibly to
 ; a greater unit depending on the number of fractional decimal-places displayed.  The <code>format()</code> method will
 ; not accept an argument whose type is <code>String</code>, <code>Float</code> nor <code>Double</code>.
 ;
 ; <p>Subsequent to the monetary value to be formatted, the {@link #format(Object)} method also accepts as arguments
 ; optional <code>int</code> values that specify the number of decimal places to use to represent the fractional portion
 ; of the number.  This overrides the default, and enables a single formatter instance to be reused, formatting different
 ; values that require different numbers of fractional decimal places.  These parameters have the same meaning as those
 ; that set the default values in the factory methods as described above.  Namely, a single <code>int</code> value determines
 ; the minimum number of fractional decimal places that will be used in all cases, to a precision limit of satoshis.
 ; Instances of {@link BtcFixedFormat} also accept a variable-length sequence of additional <code>int</code> values, each
 ; of which specifies the size of a group of fractional decimal-places to be used in addition to all preceding places, only
 ; if useful to express precision, and only to a maximum precision of satoshis.  For example:
 ;
 ; <blockquote><pre>
 ; BtcFormat f = BtcFormat.getCoinInstance();
 ; Coin value = COIN.add(Coin.valueOf(5)); <strong>// 100000005 satoshis</strong>
 ; f.format(value, 2);       <strong>// "1.00"</strong>
 ; f.format(value, 3);       <strong>// "1.000"</strong>
 ; f.format(value, 2, 3);    <strong>// "1.00" three more zeros doesn't help</strong>
 ; f.format(value, 2, 3, 3); <strong>// "1.00000005" </strong>
 ; f.format(value, 2, 3, 4); <strong>// "1.00000005" fractions of satoshis have no place</strong>
 ; f.format(value, 2, 3, 2); <strong>// "1.0000001" rounds to nearest usable place</strong>
 ; </pre></blockquote>
 ;
 ; <p>Note that if using all the fractional decimal places in a specified group would give a place to fractions of satoshis,
 ; then the size of that group will be reduced to a maximum precision of satoshis.  Either all or none of the allowed decimal
 ; places of that group will still be applied as doing so is useful for expressing the precision of the value being formatted.
 ;
 ; <p>Several convenient constants of repeating group-size sequences are provided: {@link BtcFixedFormat#REPEATING_PLACES},
 ; {@link BtcFixedFormat#REPEATING_DOUBLETS} and {@link BtcFixedFormat#REPEATING_TRIPLETS}.  These signify repeating groups
 ; of one, two and three decimals places, respectively.  For example, to display only as many fractional places as useful
 ; in order to prevent hanging zeros on the least-significant end of formatted numbers:
 ;
 ; <blockquote><pre>
 ; format(value, 0, REPEATING_PLACES);
 ; </pre></blockquote>
 ;
 ; <p>When using an automatically-denominating formatter, you might want to know what denomination was chosen.  You can get
 ; the currency-units indicator, as well as any other field in the formatted output, by using a {@link java.text.FieldPosition}
 ; instance constructed using an appropriate constant from the {@link java.text.NumberFormat.Field} class:
 ;
 ; <blockquote><pre>
 ; BtcFormat de = BtcFormat.getInstance(Locale.GERMANY);
 ; FieldPosition currField = new FieldPosition(NumberFormat.Field.CURRENCY);
 ; <strong>// next line formats the value as "987.654.321,23 µBTC"</strong>
 ; String output = de.format(valueOf(98765432123L), new StringBuffer(), currField);
 ; <strong>// next line sets variable currencyCode to "µBTC"</strong>
 ; String currencyCode = output.substring(currField.getBeginIndex(), currField.getEndIndex()));
 ; </pre></blockquote>
 ;
 ; <p>When using a fixed-denomination formatter whose scale can be expressed as a standard "metric" prefix,
 ; you can invoke the <code>code()</code> and <code>symbol()</code> methods to obtain a <code>String</code>
 ; whose value is the appropriate currency code or symbol, respectively, for that formatter.
 ;
 ; <blockquote><pre>
 ; BtcFixedFormat kilo = (BtcFixedFormat)BtcFormat(-3); <strong>// scale -3 for kilocoins</strong>
 ; Coin value = Coin.parseCoin("1230");
 ; <strong>// variable coded will be set to "kBTC 1.23"</strong>
 ; String coded = kilo.code() + " " + kilo.format(value);
 ; <strong>// variable symbolic will be set to "k฿1.23"</strong>
 ; String symbolic = kilo.symbol() + kilo.format(value);
 ; BtcFormat(4).code(); <strong>// unnamed denomination has no code; raises exception</strong>
 ; </pre></blockquote>
 ;
 ; <h5>Formatting for Tabular Columns</h5>
 ;
 ; When displaying tables of monetary values, you can lessen the risk of human misreading-error by vertically
 ; aligning the decimal separator of those values.  This example demonstrates one way to do that:
 ;
 ; <blockquote><pre>
 ; <strong>// The elements of this array are the values we will format:</strong>
 ; Coin[] rows = { MAX_MONEY, MAX_MONEY.subtract(SATOSHI), Coin.parseCoin("1234"), COIN,
 ;                 COIN.divide(1000), valueOf(10000), valueOf(1000), valueOf(100), SATOSHI };
 ; BtcFormat f = BtcFormat.getCoinInstance(2, REPEATING_PLACES);
 ; FieldPosition fp = new FieldPosition(DECIMAL_SEPARATOR); <strong>// see java.text.NumberFormat.Field</strong>
 ; String[] output = new String[rows.length];
 ; int[] indexes = new int[rows.length];
 ; int maxIndex = 0;
 ; for (int i = 0; i < rows.length; i++)
 ; {
 ;     output[i] = f.format(rows[i], new StringBuffer(), fp).toString();
 ;     indexes[i] = fp.getBeginIndex();
 ;     if (maxIndex < indexes[i])
 ;         maxIndex = indexes[i];
 ; }
 ; for (int i = 0; i < output.length; i++)
 ; {
 ;     System.out.println(repeat(" ", maxIndex - indexes[i]) + output[i]);
 ; }
 ; </pre></blockquote>
 ;
 ; Assuming you are using a monospaced font, and depending on your locale, the foregoing will print the following:
 ;
 ; <blockquote><pre>
 ; 21,000,000.00
 ; 20,999,999.99999999
 ;      1,234.00
 ;          1.00
 ;          0.001
 ;          0.0001
 ;          0.00001
 ;          0.000001
 ;          0.00000001
 ; </pre></blockquote>
 ;
 ; If you need to vertically-align columns printed in a proportional font, then see the documentation
 ; for the {@link java.text.NumberFormat} class for an explanation of how to do that.
 ;
 ; <h3>Parsing</h3>
 ;
 ; <p>The {@link #parse(String)} method accepts a <code>String</code> argument, and returns a {@link Coin}-type value.
 ; The difference in parsing behavior between instances of {@link BtcFixedFormat} and {@link BtcAutoFormat} is analogous
 ; to the difference in formatting behavior between instances of those classes.  Instances of {@link BtcAutoFormat} recognize
 ; currency codes and symbols in the <code>String</code> being parsed, and interpret them as indicators of the units in which
 ; the number being parsed is denominated.  On the other hand, instances of {@link BtcFixedFormat} by default recognize no
 ; codes nor symbols, but rather interpret every number as being denominated in the units that were specified when constructing
 ; the instance doing the parsing.  This default behavior of {@link BtcFixedFormat} can be overridden by setting a parsing
 ; pattern that includes a currency sign using the {@link BtcFormat.Builder#pattern()} method.
 ;
 ; <p>The {@link BtcAutoFormat#parse(String)}</code> method of {@link BtcAutoFormat} (and of {@link BtcAutoFormat} configured
 ; with applicable non-default pattern) will recognize a variety of currency symbols and codes, including all standard
 ; international (metric) prefixes from micro to mega.  For example, denominational units of microcoins may be specified
 ; by <code>µ฿</code>, <code>u฿</code>, <code>µB⃦</code>, <code>µɃ</code>, <code>µBTC</code> or other appropriate permutations
 ; of those characters.  Additionally, if either or both of a custom currency code or symbol is configured using
 ; {@link BtcFormat.Builder#code} or {@link BtcFormat.Builder#code}, then such code or symbol will be recognized in addition
 ; to those recognized by default.
 ;
 ; <p>Instances of this class that recognize currency signs will recognize both currency symbols and codes, regardless of which
 ; that instance uses for formatting.  However, if the style is <code>CODE</code> (and unless overridden by a custom pattern)
 ; then a space character must separate the units indicator from the number.  When parsing with a <code>SYMBOL</code>-style
 ; <code>BtcFormat</code> instance, on the other hand, whether or not the units indicator must be separated by a space from
 ; the number is determined by the locale.  The {@link BtcFormat#pattern()} method returns a representation of the pattern
 ; that can be examined to determine whether a space must separate currency signs from numbers in parsed <code>String</code>s.
 ;
 ; <p>When parsing, if the currency-units indicator is absent, then a {@link BtcAutoFormat} instance will infer a denomination
 ; of bitcoins while a {@link BtcFixedFormat} will infer the denomination in which it expresses formatted values.  Note: by
 ; default (unless overridden by a custom pattern), if the locale or style requires a space to separate the number from the
 ; units indicator, that space must be present in the String to be parsed, even if the units indicator is absent.
 ;
 ; <p>The <code>parse()</code> method returns an instance of the {@link Coin} class.  Therefore, attempting to parse a value
 ; greater than the maximum that a <code>Coin</code> object can represent will raise a <code>ParseException</code>, as will
 ; any other detected parsing error.
 ;
 ; <h3>Limitations</h3>
 ;
 ; <h5>Parsing</h5>
 ;
 ; Parsing is performed by an underlying {@link java.text.NumberFormat} object.  While this delivers the benefit
 ; of recognizing locale-specific patterns, some have criticized other aspects of its behavior.  For example, see
 ; <a href="http://www.ibm.com/developerworks/library/j-numberformat/">this article by Joe Sam Shirah</a>.  In particular,
 ; explicit positive-signs are not recognized.  If you are parsing input from end-users, then you should consider whether
 ; you would benefit from any of the work-arounds mentioned in that article.
 ;
 ; <h5>Exotic Locales</h5>
 ;
 ; This class is not well-tested in locales that use non-ascii character sets, especially those where writing proceeds
 ; from right-to-left.  Helpful feedback in that regard is appreciated.
 ;
 ; <h3>Thread-Safety</h3>
 ;
 ; <p>Instances of this class are immutable.
 ;
 ; @see java.text.Format
 ; @see java.text.NumberFormat
 ; @see java.text.DecimalFormat
 ; @see java.text.DecimalFormatSymbols
 ; @see java.text.FieldPosition
 ; @see org.bitcoinj.core.Coin
 ;;

#_public
#_abstract
(§ class BtcFormat extends Format
    ;; CONCURRENCY NOTES
     ;
     ; There is one mutable member of this class, the `DecimalFormat` object bound to variable `numberFormat`.
     ; The relevant methods invoked on it are: setMinimumFractionDigits(), setMaximumFractionDigits(), and
     ; setDecimalFormatSymbols(), along with the respective getter methods corresponding to each.  The first
     ; two methods are used to set the number of fractional decimal places displayed when formatting, which is
     ; reflected in the patterns returned by the public pattern() and localizedPattern() methods.  The last
     ; method sets the value of that object's member `DecimalFormatSymbols` object for formatting and parsing,
     ; which is also reflected in the aforementioned patterns.  The patterns, which are the passed-through
     ; return values of the DecimalFormat object's toPattern() and toLocalizedPattern() methods, and the value
     ; of the DecimalFormat object's DecimalFormatSymbols member are among the values compared between instances
     ; of this class in determining the return values of the `equals()` and `hashCode()` methods.
     ;
     ; From the foregoing, you can understand that immutability is achieved as follows: access to the variable
     ; `numberFormat` referent's fraction-digits and format-symbols fields are synchronized on that DecimalFormat
     ; object.  The state of those fraction-digits limits and decimal-format symbols must be returned to a static
     ; state after being changed for formatting or parsing since the user can see them reflected in the return
     ; values of above-mentioned methods and because `equals()` and `hashCode()` use them for comparisons.
     ;;

    ;;; The conventional international currency code for bitcoins: "BTC" ;;
    #_private
    #_static
    #_final
    (§ field String COIN_CODE = "BTC")
    ;;; The default currency symbols for bitcoins. ;;
    #_private
    #_static
    #_final
    (§ field String COIN_SYMBOL = "฿")
    ;;; An alternative currency symbol to use in locales where the default symbol is used for the national currency. ;;
    #_protected
    #_static
    #_final
    (§ field String COIN_SYMBOL_ALT = "Ƀ")

    #_protected
    #_final
    (§ field DecimalFormat numberFormat) ;; warning: mutable
    #_protected
    #_final
    (§ field int minimumFractionDigits)
    #_protected
    #_final
    (§ field List<Integer> decimalGroups)

    ;; Scale is the number of decimal-places difference from same value in bitcoins.

    ;;;
     ; A constant useful for specifying a denomination of bitcoins, the <code>int</code> value <code>0</code>.
     ;;
    #_public
    #_static
    #_final
    (§ field int COIN_SCALE = 0)

    ;;;
     ; A constant useful for specifying a denomination of millibitcoins, the <code>int</code> value <code>3</code>.
     ;;
    #_public
    #_static
    #_final
    (§ field int MILLICOIN_SCALE = 3)

    ;;;
     ; A constant useful for specifying a denomination of microbitcoins, the <code>int</code> value <code>6</code>.
     ;;
    #_public
    #_static
    #_final
    (§ field int MICROCOIN_SCALE = 6)

    ;;;
     ; Return the number of decimal places by which any value denominated in the units indicated
     ; by the given scale differs from that same value denominated in satoshis.
     ;;
    #_private
    #_static
    (§ method int offSatoshis(§ args int scale))
    (§ block
        (§ return Coin.SMALLEST_UNIT_EXPONENT - scale)
    )

    #_private
    #_static
    (§ method Locale defaultLocale(§ args ))
    (§ block
        (§ return Locale.getDefault(§ pars ))
    )

    ;;;
     ; <p>This class constructs new instances of {@link BtcFormat}, allowing for the configuration of those instances
     ; before they are constructed.  After obtaining a <code>Builder</code> object from the {@link BtcFormat#builder()}
     ; method, invoke the necessary setter methods to obtain your desired configuration.  Finaly, the {@link #build()}
     ; method returns a new <code>BtcFormat</code> object that has the specified configuration.
     ;
     ; <p>All the setter methods override defaults.  Invoking <code>build()</code> without invoking any of the setting
     ; methods is equivalent to invoking {@link BtcFormat#getInstance()} with no arguments.
     ;
     ; <p>Each setter methods returns the same instance on which it is invoked, thus these methods can be chained.
     ;
     ; <p>Instances of this class are <strong>not</strong> thread-safe.
     ;;
    #_public
    #_static
    (§ class Builder
        #_private
        (§ enum Variant
            (§ item AUTO
            (§ anon
                #_override
                (§ method BtcFormat newInstance(§ args Builder b))
                (§ block
                    (§ return getInstance(§ pars b.style, b.locale, b.minimumFractionDigits))
                )
            ))
            (§ item FIXED)
            (§ item UNSET)

            (§ method BtcFormat newInstance(§ args Builder b))
            (§ block
                (§ return getInstance(§ pars b.scale, b.locale, b.minimumFractionDigits, b.fractionGroups))
            )
        )
        ;; Parameters are initialized to default or unset values.
        #_private
        (§ field Variant variant = Variant.UNSET)
        #_private
        (§ field Locale locale = defaultLocale(§ pars ))
        #_private
        (§ field int minimumFractionDigits = 2)
        #_private
        (§ field int[] fractionGroups = (§ coll ))
        #_private
        (§ field Style style = BtcAutoFormat.Style.CODE)
        #_private
        (§ field int scale = 0)
        #_private
        (§ field String symbol = "", code = "", pattern = "", localizedPattern = "")

        #_private
        (§ constructor Builder(§ args ))
        (§ block
        )

        ;;;
         ; Specify the new <code>BtcFormat</code> is to be automatically-denominating.
         ; The argument determines which of either codes or symbols the new <code>BtcFormat</code>
         ; will use by default to indicate the denominations it chooses when formatting values.
         ;
         ; <p>Note that the <code>Style</code> argument specifies the <em>default</em> style, which is
         ; overridden by invoking either {@link #pattern(String)} or {@link #localizedPattern(String)}.
         ;
         ; @throws IllegalArgumentException if {@link #scale(int)} has previously been invoked on this instance.
         ;;
        #_public
        (§ method Builder style(§ args BtcAutoFormat.Style val))
        (§ block
            (§ if (§ expr variant == Variant.FIXED))
            (§ block
                (§ throw (§ new IllegalStateException(§ pars "You cannot invoke both style() and scale()")))
            )

            (§ ass variant = Variant.AUTO)
            (§ ass style = val)
            (§ return this)
        )

        ;;;
         ; Specify the number of decimal places in the fraction part of formatted numbers.
         ; This is equivalent to the {@link #minimumFractionDigits(int)} method, but named
         ; appropriately for the context of generating {@link BtcAutoFormat} instances.
         ;
         ; <p>If neither this method nor <code>minimumFactionDigits()</code> is invoked,
         ; the default value will be <code>2</code>.
         ;;
        #_public
        (§ method Builder fractionDigits(§ args int val))
        (§ block
            (§ return minimumFractionDigits(§ pars val))
        )

        ;;;
         ; Specify a fixed-denomination of units to use when formatting and parsing values.
         ; The argument specifies the number of decimal places, in increasing precision, by which
         ; each formatted value will differ from that same value denominated in bitcoins.  For example,
         ; a denomination of millibitcoins is specified with a value of <code>3</code>.
         ;
         ; <p>The <code>BtcFormat</code> class provides appropriately named <code>int</code>-type constants
         ; for the three common values, {@link BtcFormat#COIN_SCALE}, {@link BtcFormat#MILLICOIN_SCALE}
         ; and {@link BtcFormat#MICROCOIN_SCALE}.
         ;
         ; <p>If neither this method nor {@link #style(BtcAutoFormat.Style)} is invoked on a <code>Builder</code>,
         ; then the <code>BtcFormat</code> will default to a fixed-denomination of bitcoins, equivalent
         ; to invoking this method with an argument of <code>0</code>.
         ;;
        #_public
        (§ method Builder scale(§ args int val))
        (§ block
            (§ if (§ expr variant == Variant.AUTO))
            (§ block
                (§ throw (§ new IllegalStateException(§ pars "You cannot invoke both scale() and style()")))
            )

            (§ ass variant = Variant.FIXED)
            (§ ass scale = val)
            (§ return this)
        )

        ;;;
         ; Specify the minimum number of decimal places in the fraction part of formatted values.
         ; This method is equivalent to {@link #fractionDigits(int)}, but named appropriately for
         ; the context of generating a fixed-denomination formatter.
         ;
         ; <p>If neither this method nor <code>fractionDigits()</code> is invoked, the default value
         ; will be <code>2</code>.
         ;;
        #_public
        (§ method Builder minimumFractionDigits(§ args int val))
        (§ block
            (§ ass minimumFractionDigits = val)
            (§ return this)
        )

        ;;;
         ; Specify the sizes of a variable number of optional decimal-place groups in the fraction
         ; part of formatted values.  A group of each specified size will be used in addition to
         ; all previously applied decimal places only if doing so is useful for expressing precision.
         ; The size of each group is limited to a maximum precision of satoshis.
         ;
         ; <p>If this method is not invoked, then the number of fractional decimal places will be limited to
         ; the value passed to {@link #minimumFractionDigits}, or <code>2</code> if that method is not invoked.
         ;;
        #_public
        (§ method Builder fractionGroups(§ args int... val))
        (§ block
            (§ ass fractionGroups = val)
            (§ return this)
        )

        ;;;
         ; Specify the {@link java.util.Locale} for formatting and parsing.
         ; If this method is not invoked, then the runtime default locale will be used.
         ;;
        #_public
        (§ method Builder locale(§ args Locale val))
        (§ block
            (§ ass locale = val)
            (§ return this)
        )

        ;;;
         ; Specify a currency symbol to be used in the denomination-unit indicators of formatted values.
         ; This method only sets the symbol, but does not cause it to be used.  You must also invoke either
         ; <code>style(SYMBOL)</code>, or else apply a custom pattern that includes a single currency-sign
         ; character by invoking either {@link #pattern(String)} or {@link #localizedPattern(String)}.
         ;
         ; <p>Specify only the base symbol.  The appropriate prefix will be applied according to
         ; the denomination of formatted and parsed values.
         ;;
        #_public
        (§ method Builder symbol(§ args String val))
        (§ block
            (§ ass symbol = val)
            (§ return this)
        )

        ;;;
         ; Specify a custom currency code to be used in the denomination-unit indicators of formatted values.
         ; This method only sets the code, but does not cause it to be used.  You must also invoke either
         ; <code>style(CODE)</code>, or else apply a custom pattern that includes a double currency-sign
         ; character by invoking either {@link #pattern(String)} or {@link #localizedPattern(String)}.
         ;
         ; <p>Specify only the base code.  The appropriate prefix will be applied according to
         ; the denomination of formatted and parsed values.
         ;;
        #_public
        (§ method Builder code(§ args String val))
        (§ block
            (§ ass code = val)
            (§ return this)
        )

        ;;;
         ; Use the given pattern when formatting and parsing.  The format of this pattern is identical to
         ; that used by the {@link java.text.DecimalFormat} class.
         ;
         ; <p>If the pattern lacks a negative subpattern, then the formatter will indicate negative values
         ; by placing a minus sign immediately preceding the number part of formatted values.
         ;
         ; <p>Note that while the pattern format specified by the {@link java.text.DecimalFormat} class
         ; includes a mechanism for setting the number of fractional decimal places, that part of the pattern
         ; is ignored.  Instead, use the {@link #fractionDigits(int)}, {@link #minimumFractionDigits(int)}
         ; and {@link #fractionGroups(int...)} methods.
         ;
         ; <p>Warning: if you set a pattern that includes a currency-sign for a fixed-denomination formatter
         ; that uses a non-standard scale, then an exception will be raised when you try to format a value.
         ; The standard scales include all for which a metric prefix exists from micro to mega.
         ;
         ; <p>Note that by applying a pattern you override the configured formatting style of
         ; {@link BtcAutoFormat} instances.
         ;;
        #_public
        (§ method Builder pattern(§ args String val))
        (§ block
            (§ if (§ expr localizedPattern != ""))
            (§ block
                (§ throw (§ new IllegalStateException(§ pars "You cannot invoke both pattern() and localizedPattern()")))
            )

            (§ ass pattern = val)
            (§ return this)
        )

        ;;;
         ; Use the given localized-pattern for formatting and parsing.  The format of this pattern is identical
         ; to the patterns used by the {@link java.text.DecimalFormat} class.
         ;
         ; <p>The pattern is localized according to the locale of the <code>BtcFormat</code> instance, the symbols
         ; for which can be examined by inspecting the {@link java.text.DecimalFormatSymbols} object returned by
         ; {@link BtcFormat#symbols()}.  So, for example, if you are in Germany, then the non-localized pattern of
         ; <pre>"#,##0.###"</pre> would be localized as <pre>"#.##0,###"</pre>.
         ;
         ; <p>If the pattern lacks a negative subpattern, then the formatter will indicate negative values by
         ; placing a minus sign immediately preceding the number part of formatted values.
         ;
         ; <p>Note that while the pattern format specified by the {@link java.text.DecimalFormat} class includes
         ; a mechanism for setting the number of fractional decimal places, that part of the pattern is ignored.
         ; Instead, use the {@link #fractionDigits(int)}, {@link #minimumFractionDigits(int)} and
         ; {@link #fractionGroups(int...)} methods.
         ;
         ; <p>Warning: if you set a pattern that includes a currency-sign for a fixed-denomination formatter
         ; that uses a non-standard scale, then an exception will be raised when you try to format a value.
         ; The standard scales include all for which a metric prefix exists from micro to mega.
         ;
         ; <p>Note that by applying a pattern you override the configured formatting style of
         ; {@link BtcAutoFormat} instances.
         ;;
        #_public
        (§ method Builder localizedPattern(§ args String val))
        (§ block
            (§ if (§ expr pattern != ""))
            (§ block
                (§ throw (§ new IllegalStateException(§ pars "You cannot invoke both pattern() and localizedPattern().")))
            )

            (§ ass localizedPattern = val)
            (§ return this)
        )

        ;;;
         ; Return a new {@link BtcFormat} instance.  The object returned will be configured according
         ; to the state of this <code>Builder</code> instance at the time this method is invoked.
         ;;
        #_public
        (§ method BtcFormat build(§ args ))
        (§ block
            (§ var BtcFormat f = variant.newInstance(§ pars this))
            (§ if (§ expr symbol != "" || code != ""))
            (§ block
                (§ sync f.numberFormat)
                (§ block
                    (§ var DecimalFormatSymbols defaultSigns = f.numberFormat.getDecimalFormatSymbols(§ pars ))
                    (§ call setSymbolAndCode(§ pars f.numberFormat, (§ expr symbol != "") ? symbol :else defaultSigns.getCurrencySymbol(§ pars ), (§ expr code != "") ? code :else defaultSigns.getInternationalCurrencySymbol(§ pars )))
                )
            )
            (§ if (§ expr localizedPattern != "" || pattern != ""))
            (§ block
                (§ var int places = f.numberFormat.getMinimumFractionDigits(§ pars ))
                (§ if (§ expr localizedPattern != ""))
                (§ block
                    (§ call f.numberFormat.applyLocalizedPattern(§ pars negify(§ pars localizedPattern)))
                )
                (§ else )
                (§ block
                    (§ call f.numberFormat.applyPattern(§ pars negify(§ pars pattern)))
                )
                (§ call f.numberFormat.setMinimumFractionDigits(§ pars places))
                (§ call f.numberFormat.setMaximumFractionDigits(§ pars places))
            )
            (§ return f)
        )
    )

    ;;; Return a new {@link Builder} object.  See the documentation of that class for usage details. ;;
    #_public
    #_static
    (§ method Builder builder(§ args ))
    (§ block
        (§ return (§ new Builder(§ pars )))
    )

    ;;; This single constructor is invoked by the overriding subclass constructors. ;;
    #_protected
    (§ constructor BtcFormat(§ args DecimalFormat numberFormat, int minDecimals, List<Integer> groups))
    (§ block
        (§ call Preconditions.checkArgument(§ pars 0 <= minDecimals, "There can be no fewer than zero fractional decimal places"))

        (§ ass this.numberFormat = numberFormat)
        (§ call this.numberFormat.setParseBigDecimal(§ pars true))
        (§ call this.numberFormat.setRoundingMode(§ pars HALF_UP))
        (§ ass this.minimumFractionDigits = minDecimals)
        (§ call this.numberFormat.setMinimumFractionDigits(§ pars this.minimumFractionDigits))
        (§ call this.numberFormat.setMaximumFractionDigits(§ pars this.minimumFractionDigits))
        (§ ass this.decimalGroups = groups)
        (§ sync this.numberFormat)
        (§ block
            (§ call setSymbolAndCode(§ pars this.numberFormat, (§ expr this.numberFormat.getDecimalFormatSymbols(§ pars ).getCurrencySymbol(§ pars ).contains(§ pars COIN_SYMBOL)) ? COIN_SYMBOL_ALT :else COIN_SYMBOL, COIN_CODE))
        )
    )

    ;;;
     ; Return a new instance of this class using all defaults.  The returned formatter will auto-denominate
     ; values so as to minimize zeros without loss of precision and display a currency code, for example
     ; "<code>BTC</code>", to indicate that denomination.  The returned object will uses the default locale
     ; for formatting the number and placement of the currency-code.  Two fractional decimal places will
     ; be displayed in all formatted numbers.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(§ args ))
    (§ block
        (§ return getInstance(§ pars defaultLocale(§ pars )))
    )

    ;;;
     ; Return a new auto-denominating instance that will indicate units using a currency symbol, for example,
     ; <code>"฿"</code>.  Formatting and parsing will be done according to the default locale.
     ;;
    #_public
    #_static
    (§ method BtcFormat getSymbolInstance(§ args ))
    (§ block
        (§ return getSymbolInstance(§ pars defaultLocale(§ pars )))
    )

    ;;;
     ; Return a new auto-denominating instance that will indicate units using a currency code, for example,
     ; <code>"BTC"</code>.  Formatting and parsing will be done according to the default locale.
     ;;
    #_public
    #_static
    (§ method BtcFormat getCodeInstance(§ args ))
    (§ block
        (§ return getCodeInstance(§ pars defaultLocale(§ pars )))
    )

    ;;;
     ; Return a new symbol-style auto-formatter with the given number of fractional decimal places.
     ; Denominational units will be indicated using a currency symbol, for example, <code>"฿"</code>.
     ; The returned object will format the fraction-part of numbers using the given number of decimal
     ; places, or fewer as necessary to avoid giving a place to fractional satoshis.  Formatting and
     ; parsing will be done according to the default locale.
     ;;
    #_public
    #_static
    (§ method BtcFormat getSymbolInstance(§ args int fractionPlaces))
    (§ block
        (§ return getSymbolInstance(§ pars defaultLocale(§ pars ), fractionPlaces))
    )

    ;;;
     ; Return a new code-style auto-formatter with the given number of fractional decimal places.
     ; Denominational units will be indicated using a currency code, for example, <code>"BTC"</code>.
     ; The returned object will format the fraction-part of numbers using the given number of decimal
     ; places, or fewer as necessary to avoid giving a place to fractional satoshis.  Formatting and
     ; parsing will be done according to the default locale.
     ;;
    #_public
    #_static
    (§ method BtcFormat getCodeInstance(§ args int minDecimals))
    (§ block
        (§ return getCodeInstance(§ pars defaultLocale(§ pars ), minDecimals))
    )

    ;;;
     ; Return a new code-style auto-formatter for the given locale.  The returned object will
     ; select denominational units based on each value being formatted, and will indicate those
     ; units using a currency code, for example, <code>"mBTC"</code>.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(§ args Locale locale))
    (§ block
        (§ return getCodeInstance(§ pars locale))
    )

    ;;;
     ; Return a new code-style auto-formatter for the given locale.  The returned object will
     ; select denominational units based on each value being formatted, and will indicate those
     ; units using a currency code, for example, <code>"mBTC"</code>.
     ;;
    #_public
    #_static
    (§ method BtcFormat getCodeInstance(§ args Locale locale))
    (§ block
        (§ return getInstance(§ pars CODE, locale))
    )

    ;;;
     ; Return a new code-style auto-formatter for the given locale with the given number of
     ; fraction places.  The returned object will select denominational units based on each
     ; value being formatted, and will indicate those units using a currency code, for example,
     ; <code>"mBTC"</code>.  The returned object will format the fraction-part of numbers using
     ; the given number of decimal places, or fewer as necessary to avoid giving a place to
     ; fractional satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(§ args Locale locale, int minDecimals))
    (§ block
        (§ return getCodeInstance(§ pars locale, minDecimals))
    )

    ;;;
     ; Return a new code-style auto-formatter for the given locale with the given number of
     ; fraction places.  The returned object will select denominational units based on each
     ; value being formatted, and will indicate those units using a currency code, for example,
     ; <code>"mBTC"</code>.  The returned object will format the fraction-part of numbers using
     ; the given number of decimal places, or fewer as necessary to avoid giving a place to
     ; fractional satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getCodeInstance(§ args Locale locale, int minDecimals))
    (§ block
        (§ return getInstance(§ pars CODE, locale, minDecimals))
    )

    ;;;
     ; Return a new symbol-style auto-formatter for the given locale.  The returned object will
     ; select denominational units based on each value being formatted, and will indicate those
     ; units using a currency symbol, for example, <code>"µ฿"</code>.
     ;;
    #_public
    #_static
    (§ method BtcFormat getSymbolInstance(§ args Locale locale))
    (§ block
        (§ return getInstance(§ pars SYMBOL, locale))
    )

    ;;;
     ; Return a new symbol-style auto-formatter for the given locale with the given number of
     ; fraction places.  The returned object will select denominational units based on each
     ; value being formatted, and will indicate those units using a currency symbol, for example,
     ; <code>"µ฿"</code>.  The returned object will format the fraction-part of numbers using
     ; the given number of decimal places, or fewer as necessary to avoid giving a place to
     ; fractional satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getSymbolInstance(§ args Locale locale, int fractionPlaces))
    (§ block
        (§ return getInstance(§ pars SYMBOL, locale, fractionPlaces))
    )

    ;;;
     ; Return a new auto-denominating formatter.  The returned object will indicate the
     ; denominational units of formatted values using either a currency symbol, such as,
     ; <code>"฿"</code>, or code, such as <code>"mBTC"</code>, depending on the value of
     ; the argument.  Formatting and parsing will be done according to the default locale.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(§ args Style style))
    (§ block
        (§ return getInstance(§ pars style, defaultLocale(§ pars )))
    )

    ;;;
     ; Return a new auto-denominating formatter with the given number of fractional decimal
     ; places.  The returned object will indicate the denominational units of formatted values
     ; using either a currency symbol, such as, <code>"฿"</code>, or code, such as
     ; <code>"mBTC"</code>, depending on the value of the first argument.  The returned object
     ; will format the fraction-part of numbers using the given number of decimal places, or
     ; fewer as necessary to avoid giving a place to fractional satoshis.  Formatting and
     ; parsing will be done according to the default locale.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(§ args Style style, int fractionPlaces))
    (§ block
        (§ return getInstance(§ pars style, defaultLocale(§ pars ), fractionPlaces))
    )

    ;;;
     ; Return a new auto-formatter with the given style for the given locale.
     ; The returned object that will auto-denominate each formatted value, and will indicate
     ; that denomination using either a currency code, such as "<code>BTC</code>", or symbol,
     ; such as "<code>฿</code>", depending on the value of the first argument.
     ; <p>The number of fractional decimal places in formatted number will be two, or fewer
     ; as necessary to avoid giving a place to fractional satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(§ args Style style, Locale locale))
    (§ block
        (§ return getInstance(§ pars style, locale, 2))
    )

    ;;;
     ; Return a new auto-formatter for the given locale with the given number of fraction places.
     ; The returned object will automatically-denominate each formatted value, and will indicate
     ; that denomination using either a currency code, such as <code>"mBTC"</code>, or symbol,
     ; such as "<code>฿</code>", according to the given style argument.  It will format each
     ; number according to the given locale.
     ;
     ; <p>The third parameter is the number of fractional decimal places to use for each formatted
     ; number, reduced as neccesary when formatting to avoid giving a place to fractional satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(§ args Style style, Locale locale, int fractionPlaces))
    (§ block
        (§ return (§ new BtcAutoFormat(§ pars locale, style, fractionPlaces)))
    )

    ;;;
     ; Return a new coin-denominated formatter.  The returned object will format and parse values
     ; according to the default locale, and will format numbers with two fractional decimal places,
     ; rounding values as necessary.
     ;;
    #_public
    #_static
    (§ method BtcFormat getCoinInstance(§ args ))
    (§ block
        (§ return getCoinInstance(§ pars defaultLocale(§ pars )))
    )

    #_private
    #_static
    (§ method List<Integer> boxAsList(§ args int[] elements))
        (§ throws IllegalArgumentException)
    (§ block
        (§ var List<Integer> list = new ArrayList<>(§ pars elements.length))
        (§ for (§ var int e) :for (§ expr elements))
        (§ block
            (§ call Preconditions.checkArgument(§ pars 0 < e, "Size of decimal group must be at least one."))
            (§ call list.add(§ pars e))
        )
        (§ return list)
    )

    ;;;
     ; Return a new coin-denominated formatter with the specified fraction-places.  The returned
     ; object will format and parse values according to the default locale, and will format the
     ; fraction part of numbers with at least two decimal places.  The sizes of additional groups
     ; of decimal places can be specified by a variable number of <code>int</code> arguments.
     ; Each optional decimal-place group will be applied only if useful for expressing precision,
     ; and will be only partially applied if necessary to avoid giving a place to fractional satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getCoinInstance(§ args int minFractionPlaces, int... groups))
    (§ block
        (§ return getInstance(§ pars COIN_SCALE, defaultLocale(§ pars ), minFractionPlaces, boxAsList(§ pars groups)))
    )

    ;;;
     ; Return a new coin-denominated formatter for the given locale.  The returned object will
     ; format the fractional part of numbers with two decimal places, rounding as necessary.
     ;;
    #_public
    #_static
    (§ method BtcFormat getCoinInstance(§ args Locale locale))
    (§ block
        (§ return getInstance(§ pars COIN_SCALE, locale, 2))
    )

    ;;;
     ; Return a newly-constructed instance for the given locale that will format values in terms of bitcoins,
     ; with the given minimum number of fractional decimal places.  Optionally, repeating integer arguments
     ; can be passed, each indicating the size of an additional group of fractional decimal places to be used
     ; as necessary to avoid rounding, to a limiting precision of satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getCoinInstance(§ args Locale locale, int scale, int... groups))
    (§ block
        (§ return getInstance(§ pars COIN_SCALE, locale, scale, boxAsList(§ pars groups)))
    )

    ;;;
     ; Return a new millicoin-denominated formatter.  The returned object will format and parse values for
     ; the default locale, and will format the fractional part of numbers with two decimal places, rounding
     ; as necessary.
     ;;
    #_public
    #_static
    (§ method BtcFormat getMilliInstance(§ args ))
    (§ block
        (§ return getMilliInstance(§ pars defaultLocale(§ pars )))
    )

    ;;;
     ; Return a new millicoin-denominated formatter for the given locale.  The returned object will
     ; format the fractional part of numbers with two decimal places, rounding as necessary.
     ;;
    #_public
    #_static
    (§ method BtcFormat getMilliInstance(§ args Locale locale))
    (§ block
        (§ return getInstance(§ pars MILLICOIN_SCALE, locale, 2))
    )

    ;;;
     ; Return a new millicoin-denominated formatter with the specified fractional decimal placing.
     ; The returned object will format and parse values according to the default locale, and will format the
     ; fractional part of numbers with the given minimum number of fractional decimal places.  Optionally,
     ; repeating integer arguments can be passed, each indicating the size of an additional group of fractional
     ; decimal places to be used as necessary to avoid rounding, to a limiting precision of satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getMilliInstance(§ args int scale, int... groups))
    (§ block
        (§ return getInstance(§ pars MILLICOIN_SCALE, defaultLocale(§ pars ), scale, boxAsList(§ pars groups)))
    )

    ;;;
     ; Return a new millicoin-denominated formatter for the given locale with the specified fractional
     ; decimal placing.  The returned object will format the fractional part of numbers with the given
     ; minimum number of fractional decimal places.  Optionally, repeating integer arguments can be passed,
     ; each indicating the size of an additional group of fractional decimal places to be used as necessary
     ; to avoid rounding, to a limiting precision of satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getMilliInstance(§ args Locale locale, int scale, int... groups))
    (§ block
        (§ return getInstance(§ pars MILLICOIN_SCALE, locale, scale, boxAsList(§ pars groups)))
    )

    ;;;
     ; Return a new microcoin-denominated formatter for the default locale.  The returned object will
     ; format the fractional part of numbers with two decimal places, rounding as necessary.
     ;;
    #_public
    #_static
    (§ method BtcFormat getMicroInstance(§ args ))
    (§ block
        (§ return getMicroInstance(§ pars defaultLocale(§ pars )))
    )

    ;;;
     ; Return a new microcoin-denominated formatter for the given locale.  The returned object will
     ; format the fractional part of numbers with two decimal places, rounding as necessary.
     ;;
    #_public
    #_static
    (§ method BtcFormat getMicroInstance(§ args Locale locale))
    (§ block
        (§ return getInstance(§ pars MICROCOIN_SCALE, locale))
    )

    ;;;
     ; Return a new microcoin-denominated formatter with the specified fractional decimal placing.
     ; The returned object will format and parse values according to the default locale, and will format the
     ; fractional part of numbers with the given minimum number of fractional decimal places.  Optionally,
     ; repeating integer arguments can be passed, each indicating the size of an additional group of fractional
     ; decimal places to be used as necessary to avoid rounding, to a limiting precision of satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getMicroInstance(§ args int scale, int... groups))
    (§ block
        (§ return getInstance(§ pars MICROCOIN_SCALE, defaultLocale(§ pars ), scale, boxAsList(§ pars groups)))
    )

    ;;;
     ; Return a new microcoin-denominated formatter for the given locale with the specified fractional
     ; decimal placing.  The returned object will format the fractional part of numbers with the given
     ; minimum number of fractional decimal places.  Optionally, repeating integer arguments can be passed,
     ; each indicating the size of an additional group of fractional decimal places to be used as necessary
     ; to avoid rounding, to a limiting precision of satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getMicroInstance(§ args Locale locale, int scale, int... groups))
    (§ block
        (§ return getInstance(§ pars MICROCOIN_SCALE, locale, scale, boxAsList(§ pars groups)))
    )

    ;;;
     ; Return a new fixeed-denomination formatter with the specified fractional decimal placing.
     ; The first argument specifies the denomination as the size of the shift from coin-denomination
     ; in increasingly-precise decimal places.  The returned object will format and parse values according
     ; to the default locale, and will format the fractional part of numbers with the given minimum number
     ; of fractional decimal places.  Optionally, repeating integer arguments can be passed, each indicating
     ; the size of an additional group of fractional decimal places to be used as necessary to avoid rounding,
     ; to a limiting precision of satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(§ args int scale, int minDecimals, int... groups))
    (§ block
        (§ return getInstance(§ pars scale, defaultLocale(§ pars ), minDecimals, boxAsList(§ pars groups)))
    )

    ;;;
     ; Return a new fixeed-denomination formatter.  The argument specifies the denomination as the size of
     ; the shift from coin-denomination in increasingly-precise decimal places.  The returned object will
     ; format and parse values according to the default locale, and will format the fractional part of
     ; numbers with two decimal places, or fewer as necessary to avoid giving a place to fractional satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(§ args int scale))
    (§ block
        (§ return getInstance(§ pars scale, defaultLocale(§ pars )))
    )

    ;;;
     ; Return a new fixeed-denomination formatter for the given locale.  The first argument specifies the
     ; denomination as the size of the shift from coin-denomination in increasingly-precise decimal places.
     ; The returned object will format and parse values according to the locale specified by the second
     ; argument, and will format the fractional part of numbers with two decimal places, or fewer as
     ; necessary to avoid giving a place to fractional satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(§ args int scale, Locale locale))
    (§ block
        (§ return getInstance(§ pars scale, locale, 2))
    )

    ;;;
     ; Return a new fixed-denomination formatter for the given locale, with the specified fractional
     ; decimal placing.  The first argument specifies the denomination as the size of the shift from
     ; coin-denomination in increasingly-precise decimal places.  The third parameter is the minimum
     ; number of fractional decimal places to use, followed by optional repeating integer parameters
     ; each specifying the size of an additional group of fractional decimal places to use as
     ; necessary to avoid rounding, down to a maximum precision of satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(§ args int scale, Locale locale, int minDecimals, int... groups))
    (§ block
        (§ return getInstance(§ pars scale, locale, minDecimals, boxAsList(§ pars groups)))
    )

    ;;;
     ; Return a new fixed-denomination formatter for the given locale, with the specified fractional
     ; decimal placing.  The first argument specifies the denomination as the size of the shift from
     ; coin-denomination in increasingly-precise decimal places.  The third parameter is the minimum
     ; number of fractional decimal places to use.  The third argument specifies the minimum number of
     ; fractional decimal places in formatted numbers.  The last argument is a <code>List</code> of
     ; <code>Integer</code> values, each of which specifies the size of an additional group of fractional
     ; decimal places to use as necessary to avoid rounding, down to a maximum precision of satoshis.
     ;;
    #_public
    #_static
    (§ method BtcFormat getInstance(§ args int scale, Locale locale, int minDecimals, List<Integer> groups))
    (§ block
        (§ return (§ new BtcFixedFormat(§ pars locale, scale, minDecimals, groups)))
    )

    ;;;
     ; Formats a bitcoin monetary value and returns an {@link java.text.AttributedCharacterIterator}.
     ; By iterating, you can examine what fields apply to each character.  This can be useful since a character
     ; may be part of more than one field, for example a grouping separator that is also part of the integer field.
     ;
     ; @see java.text.AttributedCharacterIterator
     ;;
    #_override
    #_public
    (§ method AttributedCharacterIterator formatToCharacterIterator(§ args Object obj))
    (§ block
        (§ sync numberFormat)
        (§ block
            (§ var DecimalFormatSymbols anteSigns = numberFormat.getDecimalFormatSymbols(§ pars ))
            (§ var BigDecimal units = denominateAndRound(§ pars inSatoshis(§ pars obj), minimumFractionDigits, decimalGroups))
            (§ var List<Integer> anteDigits = setFormatterDigits(§ pars numberFormat, units.scale(§ pars ), units.scale(§ pars )))
            (§ var AttributedCharacterIterator i = numberFormat.formatToCharacterIterator(§ pars units))
            (§ call numberFormat.setDecimalFormatSymbols(§ pars anteSigns))
            (§ call setFormatterDigits(§ pars numberFormat, anteDigits.get(§ pars 0), anteDigits.get(§ pars 1)))
            (§ return i)
        )
    )

    ;;;
     ; Formats a bitcoin value as a number and possibly a units indicator and appends the resulting text
     ; to the given string buffer.  The type of monetary value argument can be any one of any of the following
     ; classes: <code>{@link Coin}</code>, <code>Integer</code>, <code>Long</code>, <code>BigInteger</code>,
     ; <code>BigDecimal</code>.  Numeric types that can represent only an integer are interpreted as that
     ; number of satoshis.  The value of a <code>BigDecimal</code> is interpreted as that number of bitcoins,
     ; rounded to the nearest satoshi as necessary.
     ;
     ; @return the <code>StringBuffer</code> passed in as <code>toAppendTo</code>.
     ;;
    #_override
    #_public
    (§ method StringBuffer format(§ args Object qty, StringBuffer toAppendTo, FieldPosition pos))
    (§ block
        (§ return format(§ pars qty, toAppendTo, pos, minimumFractionDigits, decimalGroups))
    )

    ;;;
     ; Formats a bitcoin value as a number and possibly a units indicator to a <code>String</code>.
     ; The type of monetary value argument can be any one of any of the following classes:
     ; <code>{@link Coin}</code>, <code>Integer</code>, <code>Long</code>, <code>BigInteger</code>,
     ; <code>BigDecimal</code>.  Numeric types that can represent only an integer are interpreted
     ; as that number of satoshis.  The value of a <code>BigDecimal</code> is interpreted as that
     ; number of bitcoins, rounded to the nearest satoshi as necessary.
     ;
     ; @param minDecimals The minimum number of decimal places in the fractional part of the formatted number.
     ; @param fractionGroups The sizes of optional additional fractional decimal-place groups.
     ; @throws IllegalArgumentException if the number of fraction places is negative.
     ;;
    #_public
    (§ method String format(§ args Object qty, int minDecimals, int... fractionGroups))
    (§ block
        (§ return format(§ pars qty, new StringBuffer(§ pars ), new FieldPosition(§ pars 0), minDecimals, boxAsList(§ pars fractionGroups)).toString(§ pars ))
    )

    ;;;
     ; Formats a bitcoin value as a number and possibly a units indicator and appends the resulting
     ; text to the given string buffer.  The type of monetary value argument can be any one of any of
     ; the following classes: <code>{@link Coin}</code>, <code>Integer</code>, <code>Long</code>,
     ; <code>BigInteger</code>, <code>BigDecimal</code>.  Numeric types that can represent only an
     ; integer are interpreted as that number of satoshis.  The value of a <code>BigDecimal</code> is
     ; interpreted as that number of bitcoins, rounded to the nearest satoshi as necessary.
     ;
     ; @param minDecimals The minimum number of decimal places in the fractional part of the formatted number.
     ; @param fractionGroups The sizes of optional additional fractional decimal-place groups.
     ; @throws IllegalArgumentException if the number of fraction places is negative.
     ;;
    #_public
    (§ method StringBuffer format(§ args Object qty, StringBuffer toAppendTo, FieldPosition pos, int minDecimals, int... fractionGroups))
    (§ block
        (§ return format(§ pars qty, toAppendTo, pos, minDecimals, boxAsList(§ pars fractionGroups)))
    )

    #_private
    (§ method StringBuffer format(§ args Object qty, StringBuffer toAppendTo, FieldPosition pos, int minDecimals, List<Integer> fractionGroups))
    (§ block
        (§ call Preconditions.checkArgument(§ pars 0 <= minDecimals, "There can be no fewer than zero fractional decimal places"))

        (§ sync numberFormat)
        (§ block
            (§ var DecimalFormatSymbols anteSigns = numberFormat.getDecimalFormatSymbols(§ pars ))
            (§ var BigDecimal denominatedUnitCount = denominateAndRound(§ pars inSatoshis(§ pars qty), minDecimals, fractionGroups))
            (§ var List<Integer> antePlaces = setFormatterDigits(§ pars numberFormat, denominatedUnitCount.scale(§ pars ), denominatedUnitCount.scale(§ pars )))
            (§ var StringBuffer s = numberFormat.format(§ pars denominatedUnitCount, toAppendTo, pos))
            (§ call numberFormat.setDecimalFormatSymbols(§ pars anteSigns))
            (§ call setFormatterDigits(§ pars numberFormat, antePlaces.get(§ pars 0), antePlaces.get(§ pars 1)))
            (§ return s)
        )
    )

    ;;;
     ; Return the denomination for formatting the given value.  The returned <code>int</code> is the size
     ; of the decimal-place shift between the given Bitcoin-value denominated in bitcoins and that same value
     ; as formatted.  A fixed-denomination formatter will ignore the arguments.
     ;
     ; @param satoshis The number of satoshis having the value for which the shift is calculated.
     ; @param fractionPlaces The number of decimal places available for displaying the fractional part of the denominated value.
     ; @return the size of the shift in increasingly-precise decimal places.
     ;;
    #_protected
    #_abstract
    (§ method int scale(§ args BigInteger satoshis, int fractionPlaces))

    ;;;
     ; Return the denomination of this object.  Fixed-denomination formatters will override with their configured
     ; denomination, auto-formatters with coin denomination.  This determines the interpretation of parsed numbers
     ; lacking a units-indicator.
     ;;
    #_protected
    #_abstract
    (§ method int scale(§ args ))

    ;;;
     ; Takes a bitcoin monetary value that the client wants to format and returns the number of denominational units
     ; having the equal value, rounded to the appropriate number of decimal places.  Calls the scale() method of the
     ; subclass, which may have the side-effect of changing the currency symbol and code of the underlying `NumberFormat`
     ; object, therefore only invoke this from a synchronized method that resets the NumberFormat.
     ;;
    #_private
    (§ method BigDecimal denominateAndRound(§ args BigInteger satoshis, int minDecimals, List<Integer> fractionGroups))
    (§ block
        (§ var int scale = scale(§ pars satoshis, minDecimals))
        (§ var BigDecimal denominatedUnitCount = new BigDecimal(§ pars satoshis).movePointLeft(§ pars offSatoshis(§ pars scale)))
        (§ var int places = calculateFractionPlaces(§ pars denominatedUnitCount, scale, minDecimals, fractionGroups))
        (§ return denominatedUnitCount.setScale(§ pars places, HALF_UP))
    )

    ;;;
     ; Sets the number of fractional decimal places to be displayed on the given NumberFormat object to the value
     ; of the given integer.
     ; @return the minimum and maximum fractional places settings that the formatter had before this change,
     ; as an ImmutableList.
     ;;
    #_private
    #_static
    (§ method ImmutableList<Integer> setFormatterDigits(§ args DecimalFormat formatter, int min, int max))
    (§ block
        (§ var ImmutableList<Integer> ante = ImmutableList.of(§ pars formatter.getMinimumFractionDigits(§ pars ), formatter.getMaximumFractionDigits(§ pars )))
        (§ call formatter.setMinimumFractionDigits(§ pars min))
        (§ call formatter.setMaximumFractionDigits(§ pars max))
        (§ return ante)
    )

    ;;;
     ; Return the number of fractional decimal places to be displayed when formatting the given number of monetory
     ; units of the denomination indicated by the given decimal scale value, where 0 = coin, 3 = millicoin, and so on.
     ;
     ; @param unitCount      The number of monetary units to be formatted.
     ; @param scale          The denomination of those units as the decimal-place shift from coins.
     ; @param minDecimals    The minimum number of fractional decimal places.
     ; @param fractionGroups The sizes of option fractional decimal-place groups.
     ;;
    #_private
    #_static
    (§ method int calculateFractionPlaces(§ args BigDecimal unitCount, int scale, int minDecimals, List<Integer> fractionGroups))
    (§ block
        ;; Taking into account BOTH the user's preference for decimal-place groups, AND the prohibition against displaying
         ; a fractional number of satoshis, determine the maximum possible number of fractional decimal places.
         ;;
        (§ var int places = minDecimals)
        (§ for (§ var int group) :for (§ expr fractionGroups))
        (§ block
            (§ ass places = places + group)
        )
        (§ var int max = Math.min(§ pars places, offSatoshis(§ pars scale)))

        (§ ass places = Math.min(§ pars minDecimals, max))
        (§ for (§ var int group) :for (§ expr fractionGroups))
        (§ block
            ;; Compare the value formatted using only this many decimal places to the same value using as many places
             ; as possible.  If there's no difference, then there's no reason to continue adding more places.
             ;;
            (§ if (§ expr unitCount.setScale(§ pars places, HALF_UP).compareTo(§ pars unitCount.setScale(§ pars max, HALF_UP)) == 0))
            (§ block
                (§ break )
            )
            (§ ass places = places + group)
            (§ if (§ expr max < places))
            (§ block
                (§ ass places = max)
            )
        )
        (§ return places)
    )

    ;;;
     ; Takes an object representing a bitcoin quantity of any type the client is permitted to pass us, and return
     ; a BigInteger representing the number of satoshis having the equivalent value.
     ;;
    #_private
    #_static
    (§ method BigInteger inSatoshis(§ args Object qty))
    (§ block
        ;; The value might be bitcoins or satoshis.
        (§ if (§ expr qty instanceof Long || qty instanceof Integer))
        (§ block
            (§ return BigInteger.valueOf(§ pars (§ expr (§ cast Number)qty).longValue(§ pars )))
        )
        (§ if (§ expr qty instanceof BigInteger))
        (§ block
            (§ return (§ cast BigInteger)qty)
        )
        (§ if (§ expr qty instanceof BigDecimal))
        (§ block
            (§ return (§ expr (§ expr (§ cast BigDecimal)qty).movePointRight(§ pars Coin.SMALLEST_UNIT_EXPONENT).setScale(§ pars 0, BigDecimal.ROUND_HALF_UP).unscaledValue(§ pars )))
        )
        (§ if (§ expr qty instanceof Coin))
        (§ block
            (§ return BigInteger.valueOf(§ pars (§ expr (§ cast Coin)qty).value))
        )

        (§ throw (§ new IllegalArgumentException(§ pars "Cannot format a " + qty.getClass(§ pars ).getSimpleName(§ pars ) + " as a Bicoin value")))
    )

    ;;;
     ; Parse a <code>String</code> representation of a Bitcoin monetary value.
     ; Returns a {@link org.bitcoinj.core.Coin} object that represents the parsed value.
     ; @see java.text.NumberFormat
     ;;
    #_override
    #_public
    #_final
    (§ method Object parseObject(§ args String source, ParsePosition pos))
    (§ block
        (§ return parse(§ pars source, pos))
    )

    #_private
    (§ class ScaleMatcher
        #_public
        (§ field Pattern pattern)
        #_public
        (§ field int scale)

        (§ constructor ScaleMatcher(§ args Pattern p, int s))
        (§ block
            (§ ass pattern = p)
            (§ ass scale = s)
        )
    )

    ;; Lazy initialization.  No reason to create all these objects unless needed for parsing.
    ;; Coin indicator regex String.  TODO: does this need to be volatile?
    #_private
    #_volatile
    (§ field String ci = "(" + COIN_SYMBOL + "|" + COIN_SYMBOL_ALT + "|B⃦|" + COIN_CODE + "|XBT)")
    #_private
    (§ field Pattern coinPattern)
    #_private
    #_volatile
    (§ field ScaleMatcher[] denoms)
    (§ method ScaleMatcher[] denomMatchers(§ args ))
    (§ block
        (§ var ScaleMatcher[] result = denoms)
        (§ if (§ expr result == nil))
        (§ block
            (§ sync this)
            (§ block
                (§ ass result = denoms)
                (§ if (§ expr result == nil))
                (§ block
                    (§ if (§ expr !coinSymbol(§ pars ).matches(§ pars ci)))
                    (§ block
                        (§ ass ci = ci.replaceFirst(§ pars "\\(", "(" + coinSymbol(§ pars ) + "|"))
                    )
                    (§ if (§ expr !coinCode(§ pars ).matches(§ pars ci)))
                    (§ block
                        (§ ass ci = ci.replaceFirst(§ pars "\\)", "|" + coinCode(§ pars ) + ")"))
                    )
                    (§ ass coinPattern = Pattern.compile(§ pars ci + "?"))
                    (§ ass result = denoms = new ScaleMatcher[]
                    (§ coll
                        (§ new ScaleMatcher(§ pars Pattern.compile(§ pars "¢" + ci + "?|c" + ci), 2)) ;; centi
                        (§ new ScaleMatcher(§ pars Pattern.compile(§ pars "₥" + ci + "?|m" + ci), MILLICOIN_SCALE))
                        (§ new ScaleMatcher(§ pars Pattern.compile(§ pars "([µu]" + ci + ")"),    MICROCOIN_SCALE))
                        (§ new ScaleMatcher(§ pars Pattern.compile(§ pars "(da" + ci + ")"),     -1)) ;; deka
                        (§ new ScaleMatcher(§ pars Pattern.compile(§ pars "(h" + ci + ")"),      -2)) ;; hekto
                        (§ new ScaleMatcher(§ pars Pattern.compile(§ pars "(k" + ci + ")"),      -3)) ;; kilo
                        (§ new ScaleMatcher(§ pars Pattern.compile(§ pars "(M" + ci + ")"),      -6)) ;; mega
                    ))
                )
            )
        )
        (§ return result)
    )

    ;;;
     ; Set both the currency symbol and international code of the underlying {@link java.text.NumberFormat} object
     ; to the value of the given <code>String</code>.
     ; This method is invoked in the process of parsing, not formatting.
     ;
     ; Only invoke this from code synchronized on the value of the first argument, and don't forget
     ; to put the symbols back otherwise equals(), hashCode() and immutability will break.
     ;;
    #_private
    #_static
    (§ method DecimalFormatSymbols setSymbolAndCode(§ args DecimalFormat numberFormat, String sign))
    (§ block
        (§ return setSymbolAndCode(§ pars numberFormat, sign, sign))
    )

    ;;;
     ; Set the currency symbol and international code of the underlying {@link java.text.NumberFormat} object
     ; to the values of the last two arguments, respectively.
     ; This method is invoked in the process of parsing, not formatting.
     ;
     ; Only invoke this from code synchronized on value of the first argument, and don't forget
     ; to put the symbols back otherwise equals(), hashCode() and immutability will break.
     ;;
    #_private
    #_static
    (§ method DecimalFormatSymbols setSymbolAndCode(§ args DecimalFormat numberFormat, String symbol, String code))
    (§ block
        (§ call Preconditions.checkState(§ pars Thread.holdsLock(§ pars numberFormat)))

        (§ var DecimalFormatSymbols fs = numberFormat.getDecimalFormatSymbols(§ pars ))
        (§ var DecimalFormatSymbols ante = (§ cast DecimalFormatSymbols)fs.clone(§ pars ))
        (§ call fs.setInternationalCurrencySymbol(§ pars code))
        (§ call fs.setCurrencySymbol(§ pars symbol))
        (§ call numberFormat.setDecimalFormatSymbols(§ pars fs))
        (§ return ante)
    )

    ;;;
     ; Set both the currency symbol and code of the underlying, mutable NumberFormat object according to
     ; the given denominational units scale factor.  This is for formatting, not parsing.
     ;
     ; Set back to zero when you're done formatting otherwise immutability, equals() and hashCode() will break!
     ;
     ; @param scale Number of places the decimal point will be shifted when formatting a quantity of satoshis.
     ; @return the DecimalFormatSymbols before changing.
     ;;
    #_protected
    #_static
    (§ method void prefixUnitsIndicator(§ args DecimalFormat numberFormat, int scale))
    (§ block
        ;; Make sure caller intends to reset before changing.
        (§ call Preconditions.checkState(§ pars Thread.holdsLock(§ pars numberFormat)))

        (§ var DecimalFormatSymbols fs = numberFormat.getDecimalFormatSymbols(§ pars ))
        (§ call setSymbolAndCode(§ pars numberFormat, prefixSymbol(§ pars fs.getCurrencySymbol(§ pars ), scale), prefixCode(§ pars fs.getInternationalCurrencySymbol(§ pars ), scale)))
    )

    ;;;
     ; Parse a <code>String</code> representation of a Bitcoin monetary value.  If this object's pattern includes
     ; a currency sign, either symbol or code, as by default is true for instances of {@link BtcAutoFormat} and
     ; false for instances of {@link BtcFixedFormat}, then denominated (i.e. prefixed) currency signs in the parsed
     ; String will be recognized, and the parsed number will be interpreted as a quantity of units having that
     ; recognized denomination.
     ;
     ; If the pattern includes a currency sign but no currency sign is detected in the parsed String,
     ; then the number is interpreted as a quatity of bitcoins.
     ;
     ; If the pattern contains neither a currency symbol nor sign, then instances of {@link BtcAutoFormat} will
     ; interpret the parsed number as a quantity of bitcoins, and instances of {@link BtcAutoFormat} will interpret
     ; the number as a quantity of that instance's configured denomination, which can be ascertained by invoking
     ; the {@link BtcFixedFormat#symbol()} or {@link BtcFixedFormat#code()} method.
     ;
     ; Consider using the single-argument version of this overloaded method unless you need to keep track
     ; of the current parse position.
     ;
     ; @return a Coin object representing the parsed value.
     ; @see java.text.ParsePosition
     ;;
    #_public
    (§ method Coin parse(§ args String source, ParsePosition pos))
    (§ block
        (§ var DecimalFormatSymbols anteSigns = nil)
        (§ var int parseScale = COIN_SCALE) ;; default
        (§ var Coin coin = nil)
        (§ sync numberFormat)
        (§ block
            (§ if (§ expr numberFormat.toPattern(§ pars ).contains(§ pars "¤")))
            (§ block
                (§ for (§ var ScaleMatcher d) :for (§ expr denomMatchers(§ pars )))
                (§ block
                    (§ var Matcher matcher = d.pattern.matcher(§ pars source))
                    (§ if (§ expr matcher.find(§ pars )))
                    (§ block
                        (§ ass anteSigns = setSymbolAndCode(§ pars numberFormat, matcher.group(§ pars )))
                        (§ ass parseScale = d.scale)
                        (§ break )
                    )
                )
                (§ if (§ expr parseScale == COIN_SCALE))
                (§ block
                    (§ var Matcher matcher = coinPattern.matcher(§ pars source))
                    (§ call matcher.find(§ pars ))
                    (§ ass anteSigns = setSymbolAndCode(§ pars numberFormat, matcher.group(§ pars )))
                )
            )
            (§ else )
            (§ block
                (§ ass parseScale = scale(§ pars ))
            )

            (§ var Number number = numberFormat.parse(§ pars source, pos))
            (§ if (§ expr number != nil))
            (§ block
                (§ try )
                (§ block
                    (§ ass coin = Coin.valueOf(§ pars (§ expr (§ cast BigDecimal)number).movePointRight(§ pars offSatoshis(§ pars parseScale)).setScale(§ pars 0, HALF_UP).longValue(§ pars )))
                )
                (§ catch (§ args IllegalArgumentException _))
                (§ block
                    (§ call pos.setIndex(§ pars 0))
                )
            )
            (§ if (§ expr anteSigns != nil))
            (§ block
                (§ call numberFormat.setDecimalFormatSymbols(§ pars anteSigns))
            )
        )
        (§ return coin)
    )

    ;;; Parse a <code>String</code> representation of a Bitcoin monetary value.  If this object's pattern includes
     ; a currency sign, either symbol or code, as by default is true for instances of {@link BtcAutoFormat} and
     ; false for instances of {@link BtcFixedFormat}, then denominated (i.e. prefixed) currency signs in the parsed
     ; String will be recognized, and the parsed number will be interpreted as a quantity of units having that
     ; recognized denomination.
     ;
     ; If the pattern includes a currency sign but no currency sign is detected in the parsed String,
     ; then the number is interpreted as a quatity of bitcoins.
     ;
     ; If the pattern contains neither a currency symbol nor sign, then instances of {@link BtcAutoFormat} will
     ; interpret the parsed number as a quantity of bitcoins, and instances of {@link BtcAutoFormat} will interpret
     ; the number as a quantity of that instance's configured denomination, which can be ascertained by invoking
     ; the {@link BtcFixedFormat#symbol()} or {@link BtcFixedFormat#code()} method.
     ;
     ; @return a Coin object representing the parsed value.
     ;;
    #_public
    (§ method Coin parse(§ args String source))
        (§ throws ParseException)
    (§ block
        (§ return (§ cast Coin)parseObject(§ pars source))
    )

    #_protected
    #_static
    (§ method String prefixCode(§ args String code, int scale))
    (§ block
        (§ switch (§ expr scale))
        (§ block
            (§ case COIN_SCALE)
            (§ block
                (§ return code)
            )
            (§ case 1)
            (§ block
                (§ return "d" + code)
            )
            (§ case 2)
            (§ block
                (§ return "c" + code)
            )
            (§ case MILLICOIN_SCALE)
            (§ block
                (§ return "m" + code)
            )
            (§ case MICROCOIN_SCALE)
            (§ block
                (§ return "µ" + code)
            )
            (§ case -1)
            (§ block
                (§ return "da" + code)
            )
            (§ case -2)
            (§ block
                (§ return "h" + code)
            )
            (§ case -3)
            (§ block
                (§ return "k" + code)
            )
            (§ case -6)
            (§ block
                (§ return "M" + code)
            )
            (§ default )
            (§ block
                (§ throw (§ new IllegalStateException(§ pars "No known prefix for scale " + String.valueOf(§ pars scale))))
            )
        )
    )

    #_protected
    #_static
    (§ method String prefixSymbol(§ args String symbol, int scale))
    (§ block
        (§ switch (§ expr scale))
        (§ block
            (§ case COIN_SCALE)
            (§ block
                (§ return symbol)
            )
            (§ case 1)
            (§ block
                (§ return "d" + symbol)
            )
            (§ case 2)
            (§ block
                (§ return "¢" + symbol)
            )
            (§ case MILLICOIN_SCALE)
            (§ block
                (§ return "₥" + symbol)
            )
            (§ case MICROCOIN_SCALE)
            (§ block
                (§ return "µ" + symbol)
            )
            (§ case -1)
            (§ block
                (§ return "da" + symbol)
            )
            (§ case -2)
            (§ block
                (§ return "h" + symbol)
            )
            (§ case -3)
            (§ block
                (§ return "k" + symbol)
            )
            (§ case -6)
            (§ block
                (§ return "M" + symbol)
            )
            (§ default )
            (§ block
                (§ throw (§ new IllegalStateException(§ pars "No known prefix for scale " + String.valueOf(§ pars scale))))
            )
        )
    )

    ;;;
     ; Guarantee a formatting pattern has a subpattern for negative values.  This method takes
     ; a pattern that may be missing a negative subpattern, and returns the same pattern with
     ; a negative subpattern appended as needed.
     ;
     ; This method accommodates an imperfection in the Java formatting code and distributed
     ; locale data.  To wit: the subpattern for negative numbers is optional and not all
     ; locales have one.  In those cases, {@link java.text.DecimalFormat} will indicate numbers
     ; less than zero by adding a negative sign as the first character of the prefix of the
     ; positive subpattern.
     ;
     ; We don't like this, since we claim the negative sign applies to the number not the
     ; units, and therefore it ought to be adjacent to the number, displacing the
     ; currency-units indicator if necessary.
     ;;
    #_protected
    #_static
    (§ method String negify(§ args String pattern))
    (§ block
        (§ if (§ expr pattern.contains(§ pars ";")))
        (§ block
            (§ return pattern)
        )

        (§ if (§ expr pattern.contains(§ pars "-")))
        (§ block
            (§ throw (§ new IllegalStateException(§ pars "Positive pattern contains negative sign")))
        )

        ;; The regex matches everything until the first non-quoted number character.
        (§ return pattern + ";" + pattern.replaceFirst(§ pars "^([^#0,.']*('[^']*')?)*", "$0-"))
    )

    ;;;
     ; Return an array of all locales for which the getInstance() method of this class can
     ; return localized instances.  See {@link java.text.NumberFormat#getAvailableLocales()}.
     ;;
    #_public
    #_static
    (§ method Locale[] getAvailableLocales(§ args ))
    (§ block
        (§ return NumberFormat.getAvailableLocales(§ pars ))
    )

    ;;;
     ; Return the unprefixed currency symbol for bitcoins configured for this object.
     ; The return value of this method is constant throughough the life of an instance.
     ;;
    #_public
    (§ method String coinSymbol(§ args ))
    (§ block
        (§ sync numberFormat)
        (§ block
            (§ return numberFormat.getDecimalFormatSymbols(§ pars ).getCurrencySymbol(§ pars ))
        )
    )

    ;;;
     ; Return the unprefixed international currency code for bitcoins configured for this object.
     ; The return value of this method is constant throughough the life of an instance.
     ;;
    #_public
    (§ method String coinCode(§ args ))
    (§ block
        (§ sync numberFormat)
        (§ block
            (§ return numberFormat.getDecimalFormatSymbols(§ pars ).getInternationalCurrencySymbol(§ pars ))
        )
    )

    ;;;
     ; Return a representation of the pattern used by this instance for formatting and parsing.
     ; The format is similar to, but not the same as the format recognized by the {@link Builder#pattern}
     ; and {@link Builder#localizedPattern} methods.  The pattern returned by this method is localized,
     ; any currency signs expressed are literally, and optional fractional decimal places are shown
     ; grouped in parentheses.
     ;;
    #_public
    (§ method String pattern(§ args ))
    (§ block
        (§ sync numberFormat)
        (§ block
            (§ var StringBuilder groups = new StringBuilder(§ pars ))
            (§ for (§ var int group) :for (§ expr decimalGroups))
            (§ block
                (§ call groups.append(§ pars "(").append(§ pars Strings.repeat(§ pars "#", group)).append(§ pars ")"))
            )

            (§ var DecimalFormatSymbols s = numberFormat.getDecimalFormatSymbols(§ pars ))
            (§ var String digit = String.valueOf(§ pars s.getDigit(§ pars )))
            (§ var String exp = s.getExponentSeparator(§ pars ))
            (§ var String groupSep = String.valueOf(§ pars s.getGroupingSeparator(§ pars )))
            (§ var String moneySep = String.valueOf(§ pars s.getMonetaryDecimalSeparator(§ pars )))
            (§ var String zero = String.valueOf(§ pars s.getZeroDigit(§ pars )))
            (§ var String boundary = String.valueOf(§ pars s.getPatternSeparator(§ pars )))
            (§ var String minus = String.valueOf(§ pars s.getMinusSign(§ pars )))
            (§ var String decSep = String.valueOf(§ pars s.getDecimalSeparator(§ pars )))

            (§ var String prefixAndNumber = "(^|" + boundary + ")" + "([^" + Matcher.quoteReplacement(§ pars digit + zero + groupSep + decSep + moneySep) + "']*('[^']*')?)*" + "[" + Matcher.quoteReplacement(§ pars digit + zero + groupSep + decSep + moneySep + exp) + "]+")

            (§ return numberFormat.toLocalizedPattern(§ pars ).replaceAll(§ pars prefixAndNumber, "$0" + groups).replaceAll(§ pars "¤¤", Matcher.quoteReplacement(§ pars coinCode(§ pars ))).replaceAll(§ pars "¤", Matcher.quoteReplacement(§ pars coinSymbol(§ pars ))))
        )
    )

    ;;; Return a copy of the localized symbols used by this instance for formatting and parsing. ;;
    #_public
    (§ method DecimalFormatSymbols symbols(§ args ))
    (§ block
        (§ sync numberFormat)
        (§ block
            (§ return numberFormat.getDecimalFormatSymbols(§ pars ))
        )
    )

    ;;;
     ; Return true if the given object is equivalent to this one.
     ; Formatters for different locales will never be equal, even if they behave identically.
     ;;
    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr o == this))
        (§ block
            (§ return true)
        )
        (§ if (§ expr !(§ expr o instanceof BtcFormat)))
        (§ block
            (§ return false)
        )
        (§ var BtcFormat other = (§ cast BtcFormat)o)
        (§ return (§ expr other.pattern(§ pars ).equals(§ pars pattern(§ pars )) && other.symbols(§ pars ).equals(§ pars symbols(§ pars )) && other.minimumFractionDigits == minimumFractionDigits))
    )

    ;;;
     ; Return a hash code value for this instance.
     ; @see java.lang.Object#hashCode
     ;;
    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars pattern(§ pars ), symbols(§ pars ), minimumFractionDigits, decimalGroups))
    )
)

#_(ns org.bitcoinj.utils #_"ContextPropagatingThreadFactory"
    (:import [java.util.concurrent *])
    (:import [com.google.common.base *]
             [org.slf4j *])
   (:require [org.bitcoinj.core *]))

;;;
 ; A {@link java.util.concurrent.ThreadFactory} that propagates a {@link org.bitcoinj.core.Context}
 ; from the creating thread into the new thread.  This factory creates daemon threads.
 ;;
#_public
(§ class ContextPropagatingThreadFactory implements ThreadFactory
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars ContextPropagatingThreadFactory.class))

    #_private
    #_final
    (§ field String name)
    #_private
    #_final
    (§ field int priority)

    #_public
    (§ constructor ContextPropagatingThreadFactory(§ args String name, int priority))
    (§ block
        (§ ass this.name = name)
        (§ ass this.priority = priority)
    )

    #_public
    (§ constructor ContextPropagatingThreadFactory(§ args String name))
    (§ block
        (§ this (§ pars name, Thread.NORM_PRIORITY))
    )

    #_override
    #_public
    (§ method Thread newThread(§ args #_final Runnable r))
    (§ block
        #_final
        (§ var Context context = Context.get(§ pars ))
        (§ var Thread thread = new Thread(§ pars (§ new Runnable(§ pars ))
        (§ anon
            #_override
            #_public
            (§ method void run(§ args ))
            (§ block
                (§ try )
                (§ block
                    (§ call Context.propagate(§ pars context))
                    (§ call r.run(§ pars ))
                )
                (§ catch (§ args Exception e))
                (§ block
                    (§ call log.error(§ pars "Exception in thread", e))
                    (§ call Throwables.propagate(§ pars e))
                )
            )
        ), name))
        (§ call thread.setPriority(§ pars priority))
        (§ call thread.setDaemon(§ pars true))
        (§ var Thread.UncaughtExceptionHandler handler = Threading.uncaughtExceptionHandler)
        (§ if (§ expr handler != nil))
        (§ block
            (§ call thread.setUncaughtExceptionHandler(§ pars handler))
        )
        (§ return thread)
    )
)

#_(ns org.bitcoinj.utils #_"DaemonThreadFactory"
    (:import [java.util.concurrent Executors ThreadFactory]))

;;; Thread factory whose threads are marked as daemon and won't prevent process exit. ;;
#_public
(§ class DaemonThreadFactory implements ThreadFactory
    #_nilable
    #_private
    #_final
    (§ field String name)

    #_public
    (§ constructor DaemonThreadFactory(§ args #_nilable String name))
    (§ block
        (§ ass this.name = name)
    )

    #_public
    (§ constructor DaemonThreadFactory(§ args ))
    (§ block
        (§ this (§ pars nil))
    )

    #_override
    #_public
    (§ method Thread newThread(§ args #_non-nil Runnable runnable))
    (§ block
        (§ var Thread thread = Executors.defaultThreadFactory(§ pars ).newThread(§ pars runnable))
        (§ call thread.setDaemon(§ pars true))
        (§ if (§ expr name != nil))
        (§ block
            (§ call thread.setName(§ pars name))
        )
        (§ return thread)
    )
)

#_(ns org.bitcoinj.utils #_"ExchangeRate"
    (:import [java.io Serializable]
             [java.math BigInteger])
    (:import [com.google.common.base Objects Preconditions])
   (:require [org.bitcoinj.core Coin]))

;;;
 ; An exchange rate is expressed as a ratio of a {@link Coin} and a {@link Fiat} amount.
 ;;
#_public
(§ class ExchangeRate implements Serializable
    #_public
    #_final
    (§ field Coin coin)
    #_public
    #_final
    (§ field Fiat fiat)

    ;;; Construct exchange rate.  This amount of coin is worth that amount of fiat. ;;
    #_public
    (§ constructor ExchangeRate(§ args Coin coin, Fiat fiat))
    (§ block
        (§ call Preconditions.checkArgument(§ pars coin.isPositive(§ pars )))
        (§ call Preconditions.checkArgument(§ pars fiat.isPositive(§ pars )))
        (§ call Preconditions.checkArgument(§ pars fiat.currencyCode != nil, "currency code required"))

        (§ ass this.coin = coin)
        (§ ass this.fiat = fiat)
    )

    ;;; Construct exchange rate.  One coin is worth this amount of fiat. ;;
    #_public
    (§ constructor ExchangeRate(§ args Fiat fiat))
    (§ block
        (§ this (§ pars Coin.COIN, fiat))
    )

    ;;;
     ; Convert a coin amount to a fiat amount using this exchange rate.
     ; @throws ArithmeticException if the converted fiat amount is too high or too low.
     ;;
    #_public
    (§ method Fiat coinToFiat(§ args Coin convertCoin))
    (§ block
        ;; Use BigInteger because it's much easier to maintain full precision without overflowing.
        #_final
        (§ var BigInteger converted = BigInteger.valueOf(§ pars convertCoin.value).multiply(§ pars BigInteger.valueOf(§ pars fiat.value)).divide(§ pars BigInteger.valueOf(§ pars coin.value)))

        (§ if (§ expr 0 < converted.compareTo(§ pars BigInteger.valueOf(§ pars Long.MAX_VALUE)) || converted.compareTo(§ pars BigInteger.valueOf(§ pars Long.MIN_VALUE)) < 0))
        (§ block
            (§ throw (§ new ArithmeticException(§ pars "Overflow")))
        )

        (§ return Fiat.valueOf(§ pars fiat.currencyCode, converted.longValue(§ pars )))
    )

    ;;;
     ; Convert a fiat amount to a coin amount using this exchange rate.
     ; @throws ArithmeticException if the converted coin amount is too high or too low.
     ;;
    #_public
    (§ method Coin fiatToCoin(§ args Fiat convertFiat))
    (§ block
        (§ call Preconditions.checkArgument(§ pars convertFiat.currencyCode.equals(§ pars fiat.currencyCode), "Currency mismatch: %s vs %s", convertFiat.currencyCode, fiat.currencyCode))

        ;; Use BigInteger because it's much easier to maintain full precision without overflowing.
        #_final
        (§ var BigInteger converted = BigInteger.valueOf(§ pars convertFiat.value).multiply(§ pars BigInteger.valueOf(§ pars coin.value)).divide(§ pars BigInteger.valueOf(§ pars fiat.value)))

        (§ if (§ expr 0 < converted.compareTo(§ pars BigInteger.valueOf(§ pars Long.MAX_VALUE)) || converted.compareTo(§ pars BigInteger.valueOf(§ pars Long.MIN_VALUE)) < 0))
        (§ block
            (§ throw (§ new ArithmeticException(§ pars "Overflow")))
        )

        (§ try )
        (§ block
            (§ return Coin.valueOf(§ pars converted.longValue(§ pars )))
        )
        (§ catch (§ args IllegalArgumentException e))
        (§ block
            (§ throw (§ new ArithmeticException(§ pars "Overflow: " + e.getMessage(§ pars ))))
        )
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var ExchangeRate other = (§ cast ExchangeRate)o)
        (§ return (§ expr Objects.equal(§ pars this.coin, other.coin) && Objects.equal(§ pars this.fiat, other.fiat)))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars coin, fiat))
    )
)

#_(ns org.bitcoinj.utils #_"ExponentialBackoff"
    (:import [com.google.common.base Preconditions]
             [com.google.common.primitives Longs])
   (:require [org.bitcoinj.core Utils]))

;;;
 ; <p>Tracks successes and failures and calculates a time to retry the operation.</p>
 ;
 ; <p>The retries are exponentially backed off, up to a maximum interval.  On success the back off interval is reset.</p>
 ;;
#_public
(§ class ExponentialBackoff implements Comparable<ExponentialBackoff>
    #_public
    #_static
    #_final
    (§ field int DEFAULT_INITIAL_MILLIS = 100)
    #_public
    #_static
    #_final
    (§ field float DEFAULT_MULTIPLIER = 1.1)
    #_public
    #_static
    #_final
    (§ field int DEFAULT_MAXIMUM_MILLIS = 30 * 1000)

    #_private
    (§ field float backoff)
    #_private
    (§ field long retryTime)
    #_private
    #_final
    (§ field Params params)

    ;;;
     ; Parameters to configure a particular kind of exponential backoff.
     ;;
    #_public
    #_static
    (§ class Params
        #_private
        #_final
        (§ field float initial)
        #_private
        #_final
        (§ field float multiplier)
        #_private
        #_final
        (§ field float maximum)

        ;;;
         ; @param initialMillis The initial interval to wait, in milliseconds.
         ; @param multiplier The multiplier to apply on each failure.
         ; @param maximumMillis The maximum interval to wait, in milliseconds.
         ;;
        #_public
        (§ constructor Params(§ args long initialMillis, float multiplier, long maximumMillis))
        (§ block
            (§ call Preconditions.checkArgument(§ pars 1.0 < multiplier, "multiplier must be greater than 1.0"))
            (§ call Preconditions.checkArgument(§ pars initialMillis <= maximumMillis, "maximum must not be less than initial"))

            (§ ass this.initial = initialMillis)
            (§ ass this.multiplier = multiplier)
            (§ ass this.maximum = maximumMillis)
        )

        ;;;
         ; Construct params with default values.
         ;;
        #_public
        (§ constructor Params(§ args ))
        (§ block
            (§ ass initial = DEFAULT_INITIAL_MILLIS)
            (§ ass multiplier = DEFAULT_MULTIPLIER)
            (§ ass maximum = DEFAULT_MAXIMUM_MILLIS)
        )
    )

    #_public
    (§ constructor ExponentialBackoff(§ args Params params))
    (§ block
        (§ ass this.params = params)
        (§ call trackSuccess(§ pars ))
    )

    ;;; Track a success - reset back off interval to the initial value. ;;
    #_public
    #_final
    (§ method void trackSuccess(§ args ))
    (§ block
        (§ ass backoff = params.initial)
        (§ ass retryTime = Utils.currentTimeMillis(§ pars ))
    )

    ;;; Track a failure - multiply the back off interval by the multiplier. ;;
    #_public
    (§ method void trackFailure(§ args ))
    (§ block
        (§ ass retryTime = Utils.currentTimeMillis(§ pars ) + (§ cast long)backoff)
        (§ ass backoff = Math.min(§ pars backoff * params.multiplier, params.maximum))
    )

    ;;; Get the next time to retry, in milliseconds since the epoch. ;;
    #_public
    (§ method long getRetryTime(§ args ))
    (§ block
        (§ return retryTime)
    )

    #_override
    #_public
    (§ method int compareTo(§ args ExponentialBackoff other))
    (§ block
        ;; Note that in this implementation compareTo() is not consistent with equals().
        (§ return Longs.compare(§ pars retryTime, other.retryTime))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return "ExponentialBackoff retry=" + retryTime + " backoff=" + backoff)
    )
)

#_(ns org.bitcoinj.utils #_"Fiat"
    (:import [java.io Serializable]
             [java.math BigDecimal])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.math LongMath]
             [com.google.common.primitives Longs])
   (:require [org.bitcoinj.core Monetary]))

;;;
 ; Represents a monetary fiat value.  It was decided to not fold this into {@link org.bitcoinj.core.Coin}
 ; because of type safety.  Fiat values always come with an attached currency code.
 ;
 ; This class is immutable.
 ;;
#_public
#_final
(§ class Fiat implements Monetary, Comparable<Fiat>, Serializable
    ;;;
     ; The absolute value of exponent of the value of a "smallest unit" in scientific notation.
     ; We picked 4 rather than 2, because in financial applications it's common to use sub-cent precision.
     ;;
    #_public
    #_static
    #_final
    (§ field int SMALLEST_UNIT_EXPONENT = 4)

    ;;;
     ; The number of smallest units of this monetary value.
     ;;
    #_public
    #_final
    (§ field long value)
    #_public
    #_final
    (§ field String currencyCode)

    #_private
    (§ constructor Fiat(§ args #_final String currencyCode, #_final long value))
    (§ block
        (§ ass this.value = value)
        (§ ass this.currencyCode = currencyCode)
    )

    #_public
    #_static
    (§ method Fiat valueOf(§ args #_final String currencyCode, #_final long value))
    (§ block
        (§ return (§ new Fiat(§ pars currencyCode, value)))
    )

    #_override
    #_public
    (§ method int smallestUnitExponent(§ args ))
    (§ block
        (§ return SMALLEST_UNIT_EXPONENT)
    )

    ;;;
     ; Returns the number of "smallest units" of this monetary value.
     ;;
    #_override
    #_public
    (§ method long getValue(§ args ))
    (§ block
        (§ return value)
    )

    #_public
    (§ method String getCurrencyCode(§ args ))
    (§ block
        (§ return currencyCode)
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify more than 4 digits after the comma, or a value out of range.
     ;;
    #_public
    #_static
    (§ method Fiat parseFiat(§ args #_final String currencyCode, #_final String str))
    (§ block
        (§ try )
        (§ block
            (§ var long val = new BigDecimal(§ pars str).movePointRight(§ pars SMALLEST_UNIT_EXPONENT).longValueExact(§ pars ))
            (§ return Fiat.valueOf(§ pars currencyCode, val))
        )
        (§ catch (§ args ArithmeticException e))
        (§ block
            (§ throw (§ new IllegalArgumentException(§ pars e)))
        )
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.  The amount is cut to 4 digits after the comma.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify a value out of range.
     ;;
    #_public
    #_static
    (§ method Fiat parseFiatInexact(§ args #_final String currencyCode, #_final String str))
    (§ block
        (§ try )
        (§ block
            (§ var long val = new BigDecimal(§ pars str).movePointRight(§ pars SMALLEST_UNIT_EXPONENT).longValue(§ pars ))
            (§ return Fiat.valueOf(§ pars currencyCode, val))
        )
        (§ catch (§ args ArithmeticException e))
        (§ block
            (§ throw (§ new IllegalArgumentException(§ pars e)))
        )
    )

    #_public
    (§ method Fiat add(§ args #_final Fiat value))
    (§ block
        (§ call Preconditions.checkArgument(§ pars value.currencyCode.equals(§ pars currencyCode)))

        (§ return (§ new Fiat(§ pars currencyCode, LongMath.checkedAdd(§ pars this.value, value.value))))
    )

    #_public
    (§ method Fiat subtract(§ args #_final Fiat value))
    (§ block
        (§ call Preconditions.checkArgument(§ pars value.currencyCode.equals(§ pars currencyCode)))

        (§ return (§ new Fiat(§ pars currencyCode, LongMath.checkedSubtract(§ pars this.value, value.value))))
    )

    #_public
    (§ method Fiat multiply(§ args #_final long factor))
    (§ block
        (§ return (§ new Fiat(§ pars currencyCode, LongMath.checkedMultiply(§ pars this.value, factor))))
    )

    #_public
    (§ method Fiat divide(§ args #_final long divisor))
    (§ block
        (§ return (§ new Fiat(§ pars currencyCode, this.value / divisor)))
    )

    #_public
    (§ method Fiat[] divideAndRemainder(§ args #_final long divisor))
    (§ block
        (§ return new Fiat[] (§ coll new Fiat(§ pars currencyCode, this.value / divisor), new Fiat(§ pars currencyCode, this.value % divisor) ))
    )

    #_public
    (§ method long divide(§ args #_final Fiat divisor))
    (§ block
        (§ call Preconditions.checkArgument(§ pars divisor.currencyCode.equals(§ pars currencyCode)))

        (§ return this.value / divisor.value)
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value greater than zero, otherwise false.
     ;;
    #_public
    (§ method boolean isPositive(§ args ))
    (§ block
        (§ return (§ expr signum(§ pars ) == 1))
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value less than zero, otherwise false.
     ;;
    #_public
    (§ method boolean isNegative(§ args ))
    (§ block
        (§ return (§ expr signum(§ pars ) == -1))
    )

    ;;;
     ; Returns true if and only if this instance represents zero monetary value, otherwise false.
     ;;
    #_public
    (§ method boolean isZero(§ args ))
    (§ block
        (§ return (§ expr signum(§ pars ) == 0))
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is greater than that of the given other Fiat,
     ; otherwise false.
     ;;
    #_public
    (§ method boolean isGreaterThan(§ args Fiat other))
    (§ block
        (§ return (§ expr compareTo(§ pars other) > 0))
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is less than that of the given other Fiat,
     ; otherwise false.
     ;;
    #_public
    (§ method boolean isLessThan(§ args Fiat other))
    (§ block
        (§ return (§ expr compareTo(§ pars other) < 0))
    )

    #_override
    #_public
    (§ method int signum(§ args ))
    (§ block
        (§ return (§ expr this.value == 0) ? 0 :else (§ expr this.value < 0) ? -1 :else 1)
    )

    #_public
    (§ method Fiat negate(§ args ))
    (§ block
        (§ return (§ new Fiat(§ pars currencyCode, -this.value)))
    )

    ;;;
     ; Returns the number of "smallest units" of this monetary value.
     ; It's deprecated in favour of accessing {@link #value} directly.
     ;;
    #_public
    (§ method long longValue(§ args ))
    (§ block
        (§ return this.value)
    )

    #_private
    #_static
    #_final
    (§ field MonetaryFormat FRIENDLY_FORMAT = MonetaryFormat.FIAT.postfixCode(§ pars ))

    ;;;
     ; Returns the value as a 0.12 type string.
     ; More digits after the decimal place will be used if necessary, but two will always be present.
     ;;
    #_public
    (§ method String toFriendlyString(§ args ))
    (§ block
        (§ return FRIENDLY_FORMAT.code(§ pars 0, currencyCode).format(§ pars this).toString(§ pars ))
    )

    #_private
    #_static
    #_final
    (§ field MonetaryFormat PLAIN_FORMAT = MonetaryFormat.FIAT.minDecimals(§ pars 0).repeatOptionalDecimals(§ pars 1, 4).noCode(§ pars ))

    ;;;
     ; Returns the value as a plain string.  The result is unformatted with no trailing zeroes.
     ; For instance, a value of 150000 "smallest units" gives an output string of "0.0015".
     ;;
    #_public
    (§ method String toPlainString(§ args ))
    (§ block
        (§ return PLAIN_FORMAT.format(§ pars this).toString(§ pars ))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return Long.toString(§ pars value))
    )

    #_override
    #_public
    (§ method boolean equals(§ args #_final Object o))
    (§ block
        (§ if (§ expr o == this))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || o.getClass(§ pars ) != getClass(§ pars )))
        (§ block
            (§ return false)
        )
        #_final
        (§ var Fiat other = (§ cast Fiat)o)
        (§ return (§ expr this.value == other.value && this.currencyCode.equals(§ pars other.currencyCode)))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars value, currencyCode))
    )

    #_override
    #_public
    (§ method int compareTo(§ args #_final Fiat other))
    (§ block
        (§ return this.currencyCode.equals(§ pars other.currencyCode) ? Longs.compare(§ pars this.value, other.value) :else this.currencyCode.compareTo(§ pars other.currencyCode))
    )
)

#_(ns org.bitcoinj.utils #_"ListenerRegistration"
    (:import [java.util List]
             [java.util.concurrent Executor])
    (:import [com.google.common.base Preconditions]))

;;;
 ; A simple wrapper around a listener and an executor, with some utility methods.
 ;;
#_public
(§ class ListenerRegistration<T>
    #_public
    #_final
    (§ field T listener)
    #_public
    #_final
    (§ field Executor executor)

    #_public
    (§ constructor ListenerRegistration(§ args T listener, Executor executor))
    (§ block
        (§ ass this.listener = Preconditions.checkNotNull(§ pars listener))
        (§ ass this.executor = Preconditions.checkNotNull(§ pars executor))
    )

    ;;; Returns true if the listener was removed, else false. ;;
    #_public
    #_static
    (§ method <T> boolean removeFromList(§ args T listener, List<? extends ListenerRegistration<T>> list))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars listener))

        (§ var ListenerRegistration<T> item = nil)
        (§ for (§ var ListenerRegistration<T> registration) :for (§ expr list))
        (§ block
            (§ if (§ expr registration.listener == listener))
            (§ block
                (§ ass item = registration)
                (§ break )
            )
        )
        (§ return (§ expr item != nil && list.remove(§ pars item)))
    )
)

#_(ns org.bitcoinj.utils #_"MonetaryFormat"
    (:import [java.math RoundingMode]
             [java.text DecimalFormatSymbols]
             [java.util ArrayList Arrays List Locale])
    (:import [com.google.common.base Preconditions]
             #_static [com.google.common.math.LongMath checkedMultiply]
             #_static [com.google.common.math.LongMath checkedPow]
             #_static [com.google.common.math.LongMath divide])
   (:require [org.bitcoinj.core Coin Monetary]))

;;;
 ; Utility for formatting and parsing coin values to and from human readable form.
 ;
 ; MonetaryFormat instances are immutable.  Invoking a configuration method has no effect on the receiving instance;
 ; you must store and use the new instance it returns, instead.  Instances are thread safe, so they may be stored safely
 ; as static constants.
 ;;
#_public
#_final
(§ class MonetaryFormat
    ;;; Standard format for the BTC denomination. ;;
    #_public
    #_static
    #_final
    (§ field MonetaryFormat BTC = new MonetaryFormat(§ pars ).shift(§ pars 0).minDecimals(§ pars 2).repeatOptionalDecimals(§ pars 2, 3))
    ;;; Standard format for the mBTC denomination. ;;
    #_public
    #_static
    #_final
    (§ field MonetaryFormat MBTC = new MonetaryFormat(§ pars ).shift(§ pars 3).minDecimals(§ pars 2).optionalDecimals(§ pars 2))
    ;;; Standard format for the µBTC denomination. ;;
    #_public
    #_static
    #_final
    (§ field MonetaryFormat UBTC = new MonetaryFormat(§ pars ).shift(§ pars 6).minDecimals(§ pars 0).optionalDecimals(§ pars 2))
    ;;; Standard format for fiat amounts. ;;
    #_public
    #_static
    #_final
    (§ field MonetaryFormat FIAT = new MonetaryFormat(§ pars ).shift(§ pars 0).minDecimals(§ pars 2).repeatOptionalDecimals(§ pars 2, 1))
    ;;; Currency code for base 1 Bitcoin. ;;
    #_public
    #_static
    #_final
    (§ field String CODE_BTC = "BTC")
    ;;; Currency code for base 1/1000 Bitcoin. ;;
    #_public
    #_static
    #_final
    (§ field String CODE_MBTC = "mBTC")
    ;;; Currency code for base 1/1000000 Bitcoin. ;;
    #_public
    #_static
    #_final
    (§ field String CODE_UBTC = "µBTC")

    #_public
    #_static
    #_final
    (§ field int MAX_DECIMALS = 8)

    #_private
    #_final
    (§ field char negativeSign)
    #_private
    #_final
    (§ field char positiveSign)
    #_private
    #_final
    (§ field char zeroDigit)
    #_private
    #_final
    (§ field char decimalMark)
    #_private
    #_final
    (§ field int minDecimals)
    #_private
    #_final
    (§ field List<Integer> decimalGroups)
    #_private
    #_final
    (§ field int shift)
    #_private
    #_final
    (§ field RoundingMode roundingMode)
    #_private
    #_final
    (§ field String[] codes)
    #_private
    #_final
    (§ field char codeSeparator)
    #_private
    #_final
    (§ field boolean codePrefixed)

    #_private
    #_static
    #_final
    (§ field String DECIMALS_PADDING = "0000000000000000") ;; a few more than necessary for Bitcoin

    ;;;
     ; Set character to prefix negative values.
     ;;
    #_public
    (§ method MonetaryFormat negativeSign(§ args char negativeSign))
    (§ block
        (§ call Preconditions.checkArgument(§ pars !Character.isDigit(§ pars negativeSign)))
        (§ call Preconditions.checkArgument(§ pars 0 < negativeSign))

        (§ return (§ quest (§ expr negativeSign == this.negativeSign) ? this :else new MonetaryFormat(§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed)))
    )

    ;;;
     ; Set character to prefix positive values.  A zero value means no sign is used in this case.
     ; For parsing, a missing sign will always be interpreted as if the positive sign was used.
     ;;
    #_public
    (§ method MonetaryFormat positiveSign(§ args char positiveSign))
    (§ block
        (§ call Preconditions.checkArgument(§ pars !Character.isDigit(§ pars positiveSign)))

        (§ return (§ quest (§ expr positiveSign == this.positiveSign) ? this :else new MonetaryFormat(§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed)))
    )

    ;;;
     ; Set character range to use for representing digits.  It starts with the specified character representing zero.
     ;;
    #_public
    (§ method MonetaryFormat digits(§ args char zeroDigit))
    (§ block
        (§ return (§ quest (§ expr zeroDigit == this.zeroDigit) ? this :else new MonetaryFormat(§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed)))
    )

    ;;;
     ; Set character to use as the decimal mark.  If the formatted value does not have any decimals,
     ; no decimal mark is used either.
     ;;
    #_public
    (§ method MonetaryFormat decimalMark(§ args char decimalMark))
    (§ block
        (§ call Preconditions.checkArgument(§ pars !Character.isDigit(§ pars decimalMark)))
        (§ call Preconditions.checkArgument(§ pars 0 < decimalMark))

        (§ return (§ quest (§ expr decimalMark == this.decimalMark) ? this :else new MonetaryFormat(§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed)))
    )

    ;;;
     ; Set minimum number of decimals to use for formatting.  If the value precision exceeds all decimals specified
     ; (including additional decimals specified by {@link #optionalDecimals(int...)} or {@link #repeatOptionalDecimals(int, int)}),
     ; the value will be rounded.  This configuration is not relevant for parsing.
     ;;
    #_public
    (§ method MonetaryFormat minDecimals(§ args int minDecimals))
    (§ block
        (§ return (§ quest (§ expr minDecimals == this.minDecimals) ? this :else new MonetaryFormat(§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed)))
    )

    ;;;
     ; Set additional groups of decimals to use after the minimum decimals, if they are useful for expressing precision.
     ; Each value is a number of decimals in that group.  If the value precision exceeds all decimals specified
     ; (including minimum decimals), the value will be rounded.  This configuration is not relevant for parsing.
     ;
     ; For example, if you pass <tt>4,2</tt> it will add four decimals to your formatted string if needed, and then add
     ; another two decimals if needed.  At this point, rather than adding further decimals the value will be rounded.
     ;
     ; @param groups Any number numbers of decimals, one for each group.
     ;;
    #_public
    (§ method MonetaryFormat optionalDecimals(§ args int... groups))
    (§ block
        (§ var List<Integer> decimalGroups = new ArrayList<>(§ pars groups.length))
        (§ for (§ var int group) :for (§ expr groups))
        (§ block
            (§ call decimalGroups.add(§ pars group))
        )
        (§ return (§ new MonetaryFormat(§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed)))
    )

    ;;;
     ; Set repeated additional groups of decimals to use after the minimum decimals, if they are useful for expressing
     ; precision.  If the value precision exceeds all decimals specified (including minimum decimals), the value will be
     ; rounded.  This configuration is not relevant for parsing.
     ;
     ; For example, if you pass <tt>1,8</tt> it will up to eight decimals to your formatted string if needed.
     ; After these have been used up, rather than adding further decimals the value will be rounded.
     ;
     ; @param decimals Value of the group to be repeated.
     ; @param repetitions Number of repetitions.
     ;;
    #_public
    (§ method MonetaryFormat repeatOptionalDecimals(§ args int decimals, int repetitions))
    (§ block
        (§ call Preconditions.checkArgument(§ pars 0 <= repetitions))

        (§ var List<Integer> decimalGroups = new ArrayList<>(§ pars repetitions))
        (§ for (§ var int i = 0) :for (§ expr i < repetitions) :for (§ ass i = i + 1))
        (§ block
            (§ call decimalGroups.add(§ pars decimals))
        )
        (§ return (§ new MonetaryFormat(§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed)))
    )

    ;;;
     ; Set number of digits to shift the decimal separator to the right, coming from the standard BTC notation that was
     ; common pre-2014.  Note this will change the currency code if enabled.
     ;;
    #_public
    (§ method MonetaryFormat shift(§ args int shift))
    (§ block
        (§ return (§ quest (§ expr shift == this.shift) ? this :else new MonetaryFormat(§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed)))
    )

    ;;;
     ; Set rounding mode to use when it becomes necessary.
     ;;
    #_public
    (§ method MonetaryFormat roundingMode(§ args RoundingMode roundingMode))
    (§ block
        (§ return (§ quest (§ expr roundingMode == this.roundingMode) ? this :else new MonetaryFormat(§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed)))
    )

    ;;;
     ; Don't display currency code when formatting.  This configuration is not relevant for parsing.
     ;;
    #_public
    (§ method MonetaryFormat noCode(§ args ))
    (§ block
        (§ return (§ quest (§ expr codes == nil) ? this :else new MonetaryFormat(§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, nil, codeSeparator, codePrefixed)))
    )

    ;;;
     ; Configure currency code for given decimal separator shift.  This configuration is not relevant for parsing.
     ;
     ; @param codeShift Decimal separator shift, see {@link #shift}.
     ; @param code Currency code.
     ;;
    #_public
    (§ method MonetaryFormat code(§ args int codeShift, String code))
    (§ block
        (§ call Preconditions.checkArgument(§ pars 0 <= codeShift))

        #_final
        (§ var String[] codes = (§ expr this.codes != nil) ? Arrays.copyOf(§ pars this.codes, this.codes.length) :else new String[MAX_DECIMALS])

        (§ ass codes[codeShift] = code)
        (§ return (§ new MonetaryFormat(§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed)))
    )

    ;;;
     ; Separator between currency code and formatted value.  This configuration is not relevant for parsing.
     ;;
    #_public
    (§ method MonetaryFormat codeSeparator(§ args char codeSeparator))
    (§ block
        (§ call Preconditions.checkArgument(§ pars !Character.isDigit(§ pars codeSeparator)))
        (§ call Preconditions.checkArgument(§ pars 0 < codeSeparator))

        (§ return (§ quest (§ expr codeSeparator == this.codeSeparator) ? this :else new MonetaryFormat(§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed)))
    )

    ;;;
     ; Prefix formatted output by currency code.  This configuration is not relevant for parsing.
     ;;
    #_public
    (§ method MonetaryFormat prefixCode(§ args ))
    (§ block
        (§ return codePrefixed ? this :else new MonetaryFormat(§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, true))
    )

    ;;;
     ; Postfix formatted output with currency code.  This configuration is not relevant for parsing.
     ;;
    #_public
    (§ method MonetaryFormat postfixCode(§ args ))
    (§ block
        (§ return !codePrefixed ? this :else new MonetaryFormat(§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, false))
    )

    ;;;
     ; Configure this instance with values from a {@link Locale}.
     ;;
    #_public
    (§ method MonetaryFormat withLocale(§ args Locale locale))
    (§ block
        (§ var DecimalFormatSymbols dfs = new DecimalFormatSymbols(§ pars locale))
        (§ var char negativeSign = dfs.getMinusSign(§ pars ))
        (§ var char zeroDigit = dfs.getZeroDigit(§ pars ))
        (§ var char decimalMark = dfs.getMonetaryDecimalSeparator(§ pars ))
        (§ return (§ new MonetaryFormat(§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed)))
    )

    #_public
    (§ constructor MonetaryFormat(§ args ))
    (§ block
        ;; defaults
        (§ ass this.negativeSign = \-)
        (§ ass this.positiveSign = 0) ;; none
        (§ ass this.zeroDigit = \0)
        (§ ass this.decimalMark = \.)
        (§ ass this.minDecimals = 2)
        (§ ass this.decimalGroups = nil)
        (§ ass this.shift = 0)
        (§ ass this.roundingMode = RoundingMode.HALF_UP)
        (§ ass this.codes = new String[MAX_DECIMALS])
        (§ ass this.codes[0] = CODE_BTC)
        (§ ass this.codes[3] = CODE_MBTC)
        (§ ass this.codes[6] = CODE_UBTC)
        (§ ass this.codeSeparator = \space)
        (§ ass this.codePrefixed = true)
    )

    #_private
    (§ constructor MonetaryFormat(§ args char negativeSign, char positiveSign, char zeroDigit, char decimalMark, int minDecimals, List<Integer> decimalGroups, int shift, RoundingMode roundingMode, String[] codes, char codeSeparator, boolean codePrefixed))
    (§ block
        (§ ass this.negativeSign = negativeSign)
        (§ ass this.positiveSign = positiveSign)
        (§ ass this.zeroDigit = zeroDigit)
        (§ ass this.decimalMark = decimalMark)
        (§ ass this.minDecimals = minDecimals)
        (§ ass this.decimalGroups = decimalGroups)
        (§ ass this.shift = shift)
        (§ ass this.roundingMode = roundingMode)
        (§ ass this.codes = codes)
        (§ ass this.codeSeparator = codeSeparator)
        (§ ass this.codePrefixed = codePrefixed)
    )

    ;;;
     ; Format the given monetary value to a human readable form.
     ;;
    #_public
    (§ method CharSequence format(§ args Monetary monetary))
    (§ block
        ;; preparation
        (§ var int maxDecimals = minDecimals)
        (§ if (§ expr decimalGroups != nil))
        (§ block
            (§ for (§ var int group) :for (§ expr decimalGroups))
            (§ block
                (§ ass maxDecimals = maxDecimals + group)
            )
        )
        (§ var int smallestUnitExponent = monetary.smallestUnitExponent(§ pars ))
        (§ call Preconditions.checkState(§ pars maxDecimals <= smallestUnitExponent, "The maximum possible number of decimals (%s) cannot exceed %s.", maxDecimals, smallestUnitExponent))

        ;; rounding
        (§ var long satoshis = Math.abs(§ pars monetary.getValue(§ pars )))
        (§ var long precisionDivisor = checkedPow(§ pars 10, smallestUnitExponent - shift - maxDecimals))
        (§ ass satoshis = checkedMultiply(§ pars divide(§ pars satoshis, precisionDivisor, roundingMode), precisionDivisor))

        ;; shifting
        (§ var long shiftDivisor = checkedPow(§ pars 10, smallestUnitExponent - shift))
        (§ var long numbers = satoshis / shiftDivisor)
        (§ var long decimals = satoshis % shiftDivisor)

        ;; formatting
        (§ var String decimalsStr = String.format(§ pars Locale.US, "%0" + (§ expr smallestUnitExponent - shift) + "d", decimals))
        (§ var StringBuilder sb = new StringBuilder(§ pars decimalsStr))
        (§ while (§ expr minDecimals < sb.length(§ pars ) && sb.charAt(§ pars sb.length(§ pars ) - 1) == \0))
        (§ block
            (§ call sb.setLength(§ pars sb.length(§ pars ) - 1)) ;; trim trailing zero
        )
        (§ var int i = minDecimals)
        (§ if (§ expr decimalGroups != nil))
        (§ block
            (§ for (§ var int group) :for (§ expr decimalGroups))
            (§ block
                (§ if (§ expr i < sb.length(§ pars ) && sb.length(§ pars ) < i + group))
                (§ block
                    (§ while (§ expr sb.length(§ pars ) < i + group))
                    (§ block
                        (§ call sb.append(§ pars "0"))
                    )
                    (§ break )
                )
                (§ ass i = i + group)
            )
        )
        (§ if (§ expr 0 < sb.length(§ pars )))
        (§ block
            (§ call sb.insert(§ pars 0, decimalMark))
        )
        (§ call sb.insert(§ pars 0, numbers))
        (§ if (§ expr monetary.getValue(§ pars ) < 0))
        (§ block
            (§ call sb.insert(§ pars 0, negativeSign))
        )
        (§ elseif (§ expr positiveSign != 0))
        (§ block
            (§ call sb.insert(§ pars 0, positiveSign))
        )
        (§ if (§ expr codes != nil))
        (§ block
            (§ if (§ expr codePrefixed))
            (§ block
                (§ call sb.insert(§ pars 0, codeSeparator))
                (§ call sb.insert(§ pars 0, code(§ pars )))
            )
            (§ else )
            (§ block
                (§ call sb.append(§ pars codeSeparator))
                (§ call sb.append(§ pars code(§ pars )))
            )
        )

        ;; Convert to non-arabic digits.
        (§ if (§ expr zeroDigit != \0))
        (§ block
            (§ var int offset = zeroDigit - \0)
            (§ for (§ var int d = 0) :for (§ expr d < sb.length(§ pars )) :for (§ ass d = d + 1))
            (§ block
                (§ var char c = sb.charAt(§ pars d))
                (§ if (§ expr Character.isDigit(§ pars c)))
                (§ block
                    (§ call sb.setCharAt(§ pars d, (§ cast char)(§ expr c + offset)))
                )
            )
        )
        (§ return sb)
    )

    ;;;
     ; Parse a human readable coin value to a {@link org.bitcoinj.core.Coin} instance.
     ;
     ; @throws NumberFormatException if the string cannot be parsed for some reason.
     ;;
    #_public
    (§ method Coin parse(§ args String str))
        (§ throws NumberFormatException)
    (§ block
        (§ return Coin.valueOf(§ pars parseValue(§ pars str, Coin.SMALLEST_UNIT_EXPONENT)))
    )

    ;;;
     ; Parse a human readable fiat value to a {@link org.bitcoinj.utils.Fiat} instance.
     ;
     ; @throws NumberFormatException if the string cannot be parsed for some reason.
     ;;
    #_public
    (§ method Fiat parseFiat(§ args String currencyCode, String str))
        (§ throws NumberFormatException)
    (§ block
        (§ return Fiat.valueOf(§ pars currencyCode, parseValue(§ pars str, Fiat.SMALLEST_UNIT_EXPONENT)))
    )

    #_private
    (§ method long parseValue(§ args String str, int smallestUnitExponent))
    (§ block
        (§ call Preconditions.checkState(§ pars smallestUnitExponent <= DECIMALS_PADDING.length(§ pars )))

        (§ if (§ expr str.isEmpty(§ pars )))
        (§ block
            (§ throw (§ new NumberFormatException(§ pars "empty string")))
        )

        (§ var char first = str.charAt(§ pars 0))
        (§ if (§ expr first == negativeSign || first == positiveSign))
        (§ block
            (§ ass str = str.substring(§ pars 1))
        )
        (§ var String numbers)
        (§ var String decimals)
        (§ var int decimalMarkIndex = str.indexOf(§ pars decimalMark))
        (§ if (§ expr decimalMarkIndex != -1))
        (§ block
            (§ ass numbers = str.substring(§ pars 0, decimalMarkIndex))
            (§ ass decimals = (§ expr str + DECIMALS_PADDING).substring(§ pars decimalMarkIndex + 1))
            (§ if (§ expr decimals.indexOf(§ pars decimalMark) != -1))
            (§ block
                (§ throw (§ new NumberFormatException(§ pars "more than one decimal mark")))
            )
        )
        (§ else )
        (§ block
            (§ ass numbers = str)
            (§ ass decimals = DECIMALS_PADDING)
        )

        (§ var String satoshis = numbers + decimals.substring(§ pars 0, smallestUnitExponent - shift))
        (§ for (§ var char c) :for (§ expr satoshis.toCharArray(§ pars )))
        (§ block
            (§ if (§ expr !Character.isDigit(§ pars c)))
            (§ block
                (§ throw (§ new NumberFormatException(§ pars "illegal character: " + c)))
            )
        )

        ;; Non-arabic digits allowed here.
        (§ var long value = Long.parseLong(§ pars satoshis))
        (§ if (§ expr first == negativeSign))
        (§ block
            (§ ass value = -value)
        )
        (§ return value)
    )

    ;;;
     ; Get currency code that will be used for current shift.
     ;;
    #_public
    (§ method String code(§ args ))
    (§ block
        (§ if (§ expr codes == nil))
        (§ block
            (§ return nil)
        )
        (§ if (§ expr codes[shift] == nil))
        (§ block
            (§ throw (§ new NumberFormatException(§ pars "missing code for shift: " + shift)))
        )
        (§ return codes[shift])
    )
)

#_(ns org.bitcoinj.utils #_"Threading"
    (:import [java.util.concurrent *]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.util.concurrent CycleDetectingLockFactory ListeningExecutorService MoreExecutors Uninterruptibles]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]))

;;;
 ; Various threading related utilities.  Provides a wrapper around explicit lock creation that lets you control whether
 ; bitcoinj performs cycle detection or not.  Cycle detection is useful to detect bugs but comes with a small cost.
 ; Also provides a worker thread that is designed for event listeners to be dispatched on.
 ;;
#_public
(§ class Threading
    ;;;
     ; An executor with one thread that is intended for running event listeners on.  This ensures all event listener
     ; code runs without any locks being held.  It's intended for the API user to run things on.  Callbacks registered
     ; by bitcoinj internally shouldn't normally run here, although currently there are a few exceptions.
     ;;
    #_public
    #_static
    (§ field Executor USER_THREAD)

    ;;;
     ; A dummy executor that just invokes the runnable immediately.  Use this over
     ; {@link com.google.common.util.concurrent.MoreExecutors#sameThreadExecutor()} because the latter creates
     ; a new object each time in order to implement the more complex {@link ExecutorService} interface, which is
     ; overkill for our needs.
     ;;
    #_public
    #_static
    #_final
    (§ field Executor SAME_THREAD)

    ;;;
     ; Put a dummy task into the queue and wait for it to be run.  Because it's single threaded, this means all
     ; tasks submitted before this point are now completed.  Usually you won't want to use this method - it's a
     ; convenience primarily used in unit testing.  If you want to wait for an event to be called the right thing
     ; to do is usually to create a {@link com.google.common.util.concurrent.SettableFuture} and then call set
     ; on it.  You can then either block on that future, compose it, add listeners to it and so on.
     ;;
    #_public
    #_static
    (§ method void waitForUserCode(§ args ))
    (§ block
        #_final
        (§ var CountDownLatch latch = new CountDownLatch(§ pars 1))
        (§ call USER_THREAD.execute(§ pars (§ new Runnable(§ pars ))
        (§ anon
            #_override
            #_public
            (§ method void run(§ args ))
            (§ block
                (§ call latch.countDown(§ pars ))
            )
        )))
        (§ call Uninterruptibles.awaitUninterruptibly(§ pars latch))
    )

    ;;;
     ; An exception handler that will be invoked for any exceptions that occur in the user thread, and any unhandled
     ; exceptions that are caught whilst the framework is processing network traffic or doing other background tasks.
     ; The purpose of this is to allow you to report back unanticipated crashes from your users to a central collection
     ; center for analysis and debugging.  You should configure this <b>before</b> any bitcoinj library code is run,
     ; setting it after you started network traffic and other forms of processing may result in the change not taking effect.
     ;;
    #_nilable
    #_public
    #_static
    #_volatile
    (§ field Thread.UncaughtExceptionHandler uncaughtExceptionHandler)

    #_public
    #_static
    (§ class UserThread extends Thread implements Executor
        #_private
        #_static
        #_final
        (§ field Logger log = LoggerFactory.getLogger(§ pars UserThread.class))

        ;; 10,000 pending tasks is entirely arbitrary and may or may not be appropriate for the device we're running on.
        #_public
        #_static
        (§ field int WARNING_THRESHOLD = 10000)

        #_private
        (§ field LinkedBlockingQueue<Runnable> tasks)

        #_public
        (§ constructor UserThread(§ args ))
        (§ block
            (§ super (§ pars "bitcoinj user thread"))

            (§ call setDaemon(§ pars true))
            (§ ass tasks = new LinkedBlockingQueue<>(§ pars ))
            (§ call start(§ pars ))
        )

        #_suppress(§ opt "InfiniteLoopStatement")
        #_override
        #_public
        (§ method void run(§ args ))
        (§ block
            (§ while (§ expr true))
            (§ block
                (§ var Runnable task = Uninterruptibles.takeUninterruptibly(§ pars tasks))
                (§ try )
                (§ block
                    (§ call task.run(§ pars ))
                )
                (§ catch (§ args Throwable t))
                (§ block
                    (§ call log.warn(§ pars "Exception in user thread", t))
                    (§ var Thread.UncaughtExceptionHandler handler = uncaughtExceptionHandler)
                    (§ if (§ expr handler != nil))
                    (§ block
                        (§ call handler.uncaughtException(§ pars this, t))
                    )
                )
            )
        )

        #_override
        #_public
        (§ method void execute(§ args Runnable command))
        (§ block
            #_final
            (§ var int size = tasks.size(§ pars ))
            (§ if (§ expr size == WARNING_THRESHOLD))
            (§ block
                (§ call log.warn(§ pars "User thread has {} pending tasks, memory exhaustion may occur.\n" + "If you see this message, check your memory consumption and see if it's problematic or excessively spikey.\n" + "If it is, check for deadlocked or slow event handlers. If it isn't, try adjusting the constant \n" + "Threading.UserThread.WARNING_THRESHOLD upwards until it's a suitable level for your app, or Integer.MAX_VALUE to disable." , size))
            )
            (§ call Uninterruptibles.putUninterruptibly(§ pars tasks, command))
        )
    )

    #_static
    (§ block
        ;; Default policy goes here.  If you want to change this, use one of the static methods before instantiating
        ;; any bitcoinj objects.  The policy change will take effect only on new objects from that point onwards.
        (§ call throwOnLockCycles(§ pars ))

        (§ ass USER_THREAD = new UserThread(§ pars ))
        (§ ass SAME_THREAD = new Executor(§ pars )
        (§ anon
            #_override
            #_public
            (§ method void execute(§ args #_non-nil Runnable runnable))
            (§ block
                (§ call runnable.run(§ pars ))
            )
        ))
    )

    #_private
    #_static
    (§ field CycleDetectingLockFactory.Policy policy)
    #_public
    #_static
    (§ field CycleDetectingLockFactory factory)

    #_public
    #_static
    (§ method ReentrantLock lock(§ args String name))
    (§ block
        (§ return Utils.isAndroidRuntime(§ pars ) ? new ReentrantLock(§ pars true) :else factory.newReentrantLock(§ pars name))
    )

    #_public
    #_static
    (§ method void warnOnLockCycles(§ args ))
    (§ block
        (§ call setPolicy(§ pars CycleDetectingLockFactory.Policies.WARN))
    )

    #_public
    #_static
    (§ method void throwOnLockCycles(§ args ))
    (§ block
        (§ call setPolicy(§ pars CycleDetectingLockFactory.Policies.THROW))
    )

    #_public
    #_static
    (§ method void ignoreLockCycles(§ args ))
    (§ block
        (§ call setPolicy(§ pars CycleDetectingLockFactory.Policies.DISABLED))
    )

    #_public
    #_static
    (§ method void setPolicy(§ args CycleDetectingLockFactory.Policy policy))
    (§ block
        (§ ass Threading.policy = policy)
        (§ ass factory = CycleDetectingLockFactory.newInstance(§ pars policy))
    )

    #_public
    #_static
    (§ method CycleDetectingLockFactory.Policy getPolicy(§ args ))
    (§ block
        (§ return policy)
    )

    ;;; A caching thread pool that creates daemon threads, which won't keep the JVM alive waiting for more work. ;;
    #_public
    #_static
    (§ field ListeningExecutorService THREAD_POOL = MoreExecutors.listeningDecorator(§ pars Executors.newCachedThreadPool(§ pars (§ new ThreadFactory(§ pars ))
        (§ anon
            #_override
            #_public
            (§ method Thread newThread(§ args Runnable r))
            (§ block
                (§ var Thread t = new Thread(§ pars r))
                (§ call t.setName(§ pars "Threading.THREAD_POOL worker"))
                (§ call t.setDaemon(§ pars true))
                (§ return t)
            )
        ))))
)

#_(ns org.bitcoinj.utils #_"VersionTally"
    (:import [java.util Stack])
   (:require [org.bitcoinj.core NetworkParameters StoredBlock]
             [org.bitcoinj.store BlockStore BlockStoreException]))

;;;
 ; Caching counter for the block versions within a moving window.  This class is NOT thread safe
 ; (as if two threads are trying to use it concurrently, there's risk of getting versions out of sequence).
 ;
 ; @see org.bitcoinj.core.NetworkParameters#getMajorityWindow()
 ; @see org.bitcoinj.core.NetworkParameters#getMajorityEnforceBlockUpgrade()
 ; @see org.bitcoinj.core.NetworkParameters#getMajorityRejectBlockOutdated()
 ;;
#_public
(§ class VersionTally
    ;;;
     ; Cache of version numbers.
     ;;
    #_private
    #_final
    (§ field long[] versionWindow)

    ;;;
     ; Offset within the version window at which the next version will be written.
     ;;
    #_private
    (§ field int versionWriteHead = 0)

    ;;;
     ; Number of versions written into the tally.  Until this matches the length
     ; of the version window, we do not have sufficient data to return values.
     ;;
    #_private
    (§ field int versionsStored = 0)

    #_public
    (§ constructor VersionTally(§ args #_final NetworkParameters params))
    (§ block
        (§ ass versionWindow = new long[params.getMajorityWindow(§ pars )])
    )

    ;;;
     ; Add a new block version to the tally, and return the count for that version within the window.
     ;
     ; @param version The block version to add.
     ;;
    #_public
    (§ method void add(§ args #_final long version))
    (§ block
        (§ ass versionWindow[versionWriteHead] = version)
        (§ ass versionWriteHead = versionWriteHead + 1)
        (§ if (§ expr versionWriteHead == versionWindow.length))
        (§ block
            (§ ass versionWriteHead = 0)
        )
        (§ ass versionsStored = versionsStored + 1)
    )

    ;;;
     ; Get the count of blocks at or above the given version, within the window.
     ;
     ; @param version The block version to query.
     ; @return the count for the block version, or null if the window is not yet full.
     ;;
    #_public
    (§ method Integer getCountAtOrAbove(§ args #_final long version))
    (§ block
        (§ if (§ expr versionsStored < versionWindow.length))
        (§ block
            (§ return nil)
        )

        (§ var int count = 0)
        (§ for (§ var int versionIdx = 0) :for (§ expr versionIdx < versionWindow.length) :for (§ ass versionIdx = versionIdx + 1))
        (§ block
            (§ if (§ expr version <= versionWindow[versionIdx]))
            (§ block
                (§ ass count = count + 1)
            )
        )

        (§ return count)
    )

    ;;;
     ; Initialize the version tally from the block store.  Note this does not search backwards past
     ; the start of the block store, so if starting from a checkpoint this may not fill the window.
     ;
     ; @param blockStore Block store to load blocks from.
     ; @param chainHead Current chain tip.
     ;;
    #_public
    (§ method void initialize(§ args #_final BlockStore blockStore, #_final StoredBlock chainHead))
        (§ throws BlockStoreException)
    (§ block
        (§ var StoredBlock versionBlock = chainHead)
        #_final
        (§ var Stack<Long> versions = new Stack<>(§ pars ))

        ;; We don't know how many blocks back we can go, so load what we can first.
        (§ call versions.push(§ pars versionBlock.getHeader(§ pars ).getVersion(§ pars )))
        (§ for (§ var int headOffset = 0) :for (§ expr headOffset < versionWindow.length) :for (§ ass headOffset = headOffset + 1))
        (§ block
            (§ ass versionBlock = versionBlock.getPrev(§ pars blockStore))
            (§ if (§ expr versionBlock == nil))
            (§ block
                (§ break )
            )
            (§ call versions.push(§ pars versionBlock.getHeader(§ pars ).getVersion(§ pars )))
        )

        ;; Replay the versions into the tally.
        (§ while (§ expr !versions.isEmpty(§ pars )))
        (§ block
            (§ call add(§ pars versions.pop(§ pars )))
        )
    )

    ;;;
     ; Get the size of the version window.
     ;;
    #_public
    (§ method int size(§ args ))
    (§ block
        (§ return versionWindow.length)
    )
)

#_(ns org.bitcoinj.wallet #_"AllRandomKeysRotating")

;;;
 ; Indicates that an attempt was made to upgrade a random wallet to deterministic, but there were no non-rotating
 ; random keys to use as source material for the seed.  Add a non-compromised key first!
 ;;
#_public
(§ class AllRandomKeysRotating extends RuntimeException)

#_(ns org.bitcoinj.wallet #_"AllowUnconfirmedCoinSelector"
   (:require [org.bitcoinj.core Transaction]))

;;;
 ; This coin selector will select any transaction at all, regardless of where it came from or whether it was
 ; confirmed yet.  However immature coinbases will not be included (would be a protocol violation).
 ;;
#_public
(§ class AllowUnconfirmedCoinSelector extends DefaultCoinSelector
    #_override
    #_protected
    (§ method boolean shouldSelect(§ args Transaction tx))
    (§ block
        (§ return true)
    )

    #_private
    #_static
    (§ field AllowUnconfirmedCoinSelector instance)

    ;;; Returns a global static instance of the selector. ;;
    #_public
    #_static
    (§ method AllowUnconfirmedCoinSelector get(§ args ))
    (§ block
        ;; This doesn't have to be thread safe as the object has no state, so discarded duplicates are harmless.
        (§ if (§ expr instance == nil))
        (§ block
            (§ ass instance = new AllowUnconfirmedCoinSelector(§ pars ))
        )
        (§ return instance)
    )
)

#_(ns org.bitcoinj.wallet #_"BasicKeyChain"
    (:import [java.util *]
             [java.util.concurrent CopyOnWriteArrayList Executor]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect ImmutableList Lists]
             [com.google.protobuf ByteString]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core BloomFilter ECKey]
             [org.bitcoinj.crypto *]
             [org.bitcoinj.utils ListenerRegistration Threading]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

;;;
 ; A {@link KeyChain} that implements the simplest model possible: it can have keys imported into it, and just
 ; acts as a dumb bag of keys.  It will, left to its own devices, always return the same key for usage by the wallet,
 ; although it will automatically add one to itself if it's empty or if encryption is requested.
 ;;
#_public
(§ class BasicKeyChain implements EncryptableKeyChain
    #_private
    #_final
    (§ field ReentrantLock lock = Threading.lock(§ pars "BasicKeyChain"))

    ;; Maps used to let us quickly look up a key given data we find in transcations or the block chain.
    #_private
    #_final
    (§ field LinkedHashMap<ByteString, ECKey> hashToKeys)
    #_private
    #_final
    (§ field LinkedHashMap<ByteString, ECKey> pubkeyToKeys)
    #_nilable
    #_private
    #_final
    (§ field KeyCrypter keyCrypter)
    #_private
    (§ field boolean isWatching)

    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<KeyChainEventListener>> listeners)

    #_public
    (§ constructor BasicKeyChain(§ args ))
    (§ block
        (§ this (§ pars nil))
    )

    #_public
    (§ constructor BasicKeyChain(§ args #_nilable KeyCrypter crypter))
    (§ block
        (§ ass this.keyCrypter = crypter)
        (§ ass hashToKeys = new LinkedHashMap<>(§ pars ))
        (§ ass pubkeyToKeys = new LinkedHashMap<>(§ pars ))
        (§ ass listeners = new CopyOnWriteArrayList<>(§ pars ))
    )

    ;;; Returns the {@link KeyCrypter} in use or null if the key chain is not encrypted. ;;
    #_override
    #_nilable
    #_public
    (§ method KeyCrypter getKeyCrypter(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return keyCrypter)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method ECKey getKey(§ args #_nilable KeyPurpose ignored))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr hashToKeys.isEmpty(§ pars )))
            (§ block
                ;; We will refuse to encrypt an empty key chain.
                (§ call Preconditions.checkState(§ pars keyCrypter == nil))

                #_final
                (§ var ECKey key = new ECKey(§ pars ))
                (§ call importKeyLocked(§ pars key))
                (§ call queueOnKeysAdded(§ pars ImmutableList.of(§ pars key)))
            )
            (§ return hashToKeys.values(§ pars ).iterator(§ pars ).next(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method List<ECKey> getKeys(§ args #_nilable KeyPurpose purpose, int numberOfKeys))
    (§ block
        (§ call Preconditions.checkArgument(§ pars 0 < numberOfKeys))

        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr hashToKeys.size(§ pars ) < numberOfKeys))
            (§ block
                (§ call Preconditions.checkState(§ pars keyCrypter == nil))

                (§ var List<ECKey> keys = new ArrayList<>(§ pars ))
                (§ for (§ var int i = 0) :for (§ expr i < numberOfKeys - hashToKeys.size(§ pars )) :for (§ ass i = i + 1))
                (§ block
                    (§ call keys.add(§ pars (§ new ECKey(§ pars ))))
                )

                (§ var ImmutableList<ECKey> immutableKeys = ImmutableList.copyOf(§ pars keys))
                (§ call importKeysLocked(§ pars immutableKeys))
                (§ call queueOnKeysAdded(§ pars immutableKeys))
            )

            (§ var List<ECKey> keysToReturn = new ArrayList<>(§ pars ))
            (§ var int count = 0)
            (§ while (§ expr hashToKeys.values(§ pars ).iterator(§ pars ).hasNext(§ pars ) && numberOfKeys != count))
            (§ block
                (§ call keysToReturn.add(§ pars hashToKeys.values(§ pars ).iterator(§ pars ).next(§ pars )))
                (§ ass count = count + 1)
            )
            (§ return keysToReturn)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;; Returns a copy of the list of keys that this chain is managing. ;;
    #_public
    (§ method List<ECKey> getKeys(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return new ArrayList<>(§ pars hashToKeys.values(§ pars )))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_public
    (§ method int importKeys(§ args ECKey... keys))
    (§ block
        (§ return importKeys(§ pars ImmutableList.copyOf(§ pars keys)))
    )

    #_public
    (§ method int importKeys(§ args List<? extends ECKey> keys))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; Check that if we're encrypted, the keys are all encrypted, and if we're not, that none are.
            ;; We are NOT checking that the actual password matches here because we don't have access to the
            ;; password at this point: if you screw up and import keys with mismatched passwords, you lose!
            ;; So make sure the password is checked first.
            (§ for (§ var ECKey key) :for (§ expr keys))
            (§ block
                (§ call checkKeyEncryptionStateMatches(§ pars key))
            )

            (§ var List<ECKey> actuallyAdded = new ArrayList<>(§ pars keys.size(§ pars )))
            (§ for (§ var #_final ECKey key) :for (§ expr keys))
            (§ block
                (§ if (§ expr !hasKey(§ pars key)))
                (§ block
                    (§ call actuallyAdded.add(§ pars key))
                    (§ call importKeyLocked(§ pars key))
                )
            )
            (§ if (§ expr 0 < actuallyAdded.size(§ pars )))
            (§ block
                (§ call queueOnKeysAdded(§ pars actuallyAdded))
            )
            (§ return actuallyAdded.size(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_private
    (§ method void checkKeyEncryptionStateMatches(§ args ECKey key))
    (§ block
        (§ if (§ expr keyCrypter == nil && key.isEncrypted(§ pars )))
        (§ block
            (§ throw (§ new KeyCrypterException(§ pars "Key is encrypted but chain is not")))
        )
        (§ if (§ expr keyCrypter != nil && !key.isEncrypted(§ pars )))
        (§ block
            (§ throw (§ new KeyCrypterException(§ pars "Key is not encrypted but chain is")))
        )
        (§ if (§ expr keyCrypter != nil && key.getKeyCrypter(§ pars ) != nil && !key.getKeyCrypter(§ pars ).equals(§ pars keyCrypter)))
        (§ block
            (§ throw (§ new KeyCrypterException(§ pars "Key encrypted under different parameters to chain")))
        )
    )

    #_private
    (§ method void importKeyLocked(§ args ECKey key))
    (§ block
        (§ if (§ expr hashToKeys.isEmpty(§ pars )))
        (§ block
            (§ ass isWatching = key.isWatching(§ pars ))
        )
        (§ else )
        (§ block
            (§ if (§ expr key.isWatching(§ pars ) && !isWatching))
            (§ block
                (§ throw (§ new IllegalArgumentException(§ pars "Key is watching but chain is not")))
            )
            (§ if (§ expr !key.isWatching(§ pars ) && isWatching))
            (§ block
                (§ throw (§ new IllegalArgumentException(§ pars "Key is not watching but chain is")))
            )
        )
        (§ var ECKey previousKey = pubkeyToKeys.put(§ pars ByteString.copyFrom(§ pars key.getPubKey(§ pars )), key))
        (§ call hashToKeys.put(§ pars ByteString.copyFrom(§ pars key.getPubKeyHash(§ pars )), key))
        (§ call Preconditions.checkState(§ pars previousKey == nil))
    )

    #_private
    (§ method void importKeysLocked(§ args List<ECKey> keys))
    (§ block
        (§ for (§ var ECKey key) :for (§ expr keys))
        (§ block
            (§ call importKeyLocked(§ pars key))
        )
    )

    ;;;
     ; Imports a key to the key chain.  If key is present in the key chain, ignore it.
     ;;
    #_public
    (§ method void importKey(§ args ECKey key))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call checkKeyEncryptionStateMatches(§ pars key))
            (§ if (§ expr hasKey(§ pars key)))
            (§ block
                (§ return )
            )

            (§ call importKeyLocked(§ pars key))
            (§ call queueOnKeysAdded(§ pars ImmutableList.of(§ pars key)))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_public
    (§ method ECKey findKeyFromPubHash(§ args byte[] pubkeyHash))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return hashToKeys.get(§ pars ByteString.copyFrom(§ pars pubkeyHash)))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_public
    (§ method ECKey findKeyFromPubKey(§ args byte[] pubkey))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return pubkeyToKeys.get(§ pars ByteString.copyFrom(§ pars pubkey)))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method boolean hasKey(§ args ECKey key))
    (§ block
        (§ return (§ expr findKeyFromPubKey(§ pars key.getPubKey(§ pars )) != nil))
    )

    #_override
    #_public
    (§ method int numKeys(§ args ))
    (§ block
        (§ return pubkeyToKeys.size(§ pars ))
    )

    ;;; Whether this basic key chain is empty, full of regular (usable for signing) keys, or full of watching keys. ;;
    #_public
    (§ enum State
        (§ item EMPTY)
        (§ item WATCHING)
        (§ item REGULAR)
    )

    ;;;
     ; Returns whether this chain consists of pubkey only (watching) keys, regular keys (usable for signing),
     ; or has no keys in it yet at all (thus we cannot tell).
     ;;
    #_public
    (§ method State isWatching(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return hashToKeys.isEmpty(§ pars ) ? State.EMPTY :else isWatching ? State.WATCHING :else State.REGULAR)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Removes the given key from the keychain.  Be very careful with this - losing a private key
     ; <b>destroys the money associated with it</b>.
     ; @return whether the key was removed or not.
     ;;
    #_public
    (§ method boolean removeKey(§ args ECKey key))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var boolean a = (§ expr hashToKeys.remove(§ pars ByteString.copyFrom(§ pars key.getPubKeyHash(§ pars ))) != nil))
            (§ var boolean b = (§ expr pubkeyToKeys.remove(§ pars ByteString.copyFrom(§ pars key.getPubKey(§ pars ))) != nil))
            (§ call Preconditions.checkState(§ pars a == b)) ;; Should be in both maps or neither.
            (§ return a)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method long getEarliestKeyCreationTime(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var long time = Long.MAX_VALUE)
            (§ for (§ var ECKey key) :for (§ expr hashToKeys.values(§ pars )))
            (§ block
                (§ ass time = Math.min(§ pars key.getCreationTimeSeconds(§ pars ), time))
            )
            (§ return time)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_public
    (§ method List<ListenerRegistration<KeyChainEventListener>> getListeners(§ args ))
    (§ block
        (§ return new ArrayList<>(§ pars listeners))
    )

    (§ method Map<ECKey, Protos.Key.Builder> serializeToEditableProtobufs(§ args ))
    (§ block
        (§ var Map<ECKey, Protos.Key.Builder> result = new LinkedHashMap<>(§ pars ))
        (§ for (§ var ECKey ecKey) :for (§ expr hashToKeys.values(§ pars )))
        (§ block
            (§ var Protos.Key.Builder protoKey = serializeEncryptableItem(§ pars ecKey))
            (§ call protoKey.setPublicKey(§ pars ByteString.copyFrom(§ pars ecKey.getPubKey(§ pars ))))
            (§ call result.put(§ pars ecKey, protoKey))
        )
        (§ return result)
    )

    #_override
    #_public
    (§ method List<Protos.Key> serializeToProtobuf(§ args ))
    (§ block
        (§ var Collection<Protos.Key.Builder> builders = serializeToEditableProtobufs(§ pars ).values(§ pars ))
        (§ var List<Protos.Key> result = new ArrayList<>(§ pars builders.size(§ pars )))
        (§ for (§ var Protos.Key.Builder builder) :for (§ expr builders))
        (§ block
            (§ call result.add(§ pars builder.build(§ pars )))
        )
        (§ return result)
    )

    #_static
    (§ method Protos.Key.Builder serializeEncryptableItem(§ args EncryptableItem item))
    (§ block
        (§ var Protos.Key.Builder proto = Protos.Key.newBuilder(§ pars ))
        (§ call proto.setCreationTimestamp(§ pars item.getCreationTimeSeconds(§ pars ) * 1000))
        (§ if (§ expr item.isEncrypted(§ pars ) && item.getEncryptedData(§ pars ) != nil))
        (§ block
            ;; The encrypted data can be missing for an "encrypted" key in the case of a deterministic wallet
            ;; for which the leaf keys chain to an encrypted parent and rederive their private keys on the fly.
            ;; In that case the caller in DeterministicKeyChain will take care of setting the type.
            (§ var EncryptedData data = item.getEncryptedData(§ pars ))
            (§ call proto.getEncryptedDataBuilder(§ pars ).setEncryptedPrivateKey(§ pars ByteString.copyFrom(§ pars data.encryptedBytes)).setInitialisationVector(§ pars ByteString.copyFrom(§ pars data.initialisationVector)))
            ;; We don't allow mixing of encryption types at the moment.
            (§ call Preconditions.checkState(§ pars item.getEncryptionType(§ pars ) == Protos.Wallet.EncryptionType.ENCRYPTED_SCRYPT_AES))
            (§ call proto.setType(§ pars Protos.Key.Type.ENCRYPTED_SCRYPT_AES))
        )
        (§ else )
        (§ block
            #_final
            (§ var byte[] secret = item.getSecretBytes(§ pars ))
            ;; The secret might be missing in the case of a watching wallet, or a key for which the private key
            ;; is expected to be rederived on the fly from its parent.
            (§ if (§ expr secret != nil))
            (§ block
                (§ call proto.setSecretBytes(§ pars ByteString.copyFrom(§ pars secret)))
            )
            (§ call proto.setType(§ pars Protos.Key.Type.ORIGINAL))
        )
        (§ return proto)
    )

    ;;;
     ; Returns a new BasicKeyChain that contains all basic, ORIGINAL type keys extracted from the list.
     ; Unrecognised key types are ignored.
     ;;
    #_public
    #_static
    (§ method BasicKeyChain fromProtobufUnencrypted(§ args List<Protos.Key> keys))
        (§ throws UnreadableWalletException)
    (§ block
        (§ var BasicKeyChain chain = new BasicKeyChain(§ pars ))
        (§ call chain.deserializeFromProtobuf(§ pars keys))
        (§ return chain)
    )

    ;;;
     ; Returns a new BasicKeyChain that contains all basic, ORIGINAL type keys and also any encrypted keys
     ; extracted from the list.  Unrecognised key types are ignored.
     ; @throws org.bitcoinj.wallet.UnreadableWalletException.BadPassword if the password doesn't seem to match.
     ; @throws org.bitcoinj.wallet.UnreadableWalletException if the data structures are corrupted/inconsistent.
     ;;
    #_public
    #_static
    (§ method BasicKeyChain fromProtobufEncrypted(§ args List<Protos.Key> keys, KeyCrypter crypter))
        (§ throws UnreadableWalletException)
    (§ block
        (§ var BasicKeyChain chain = new BasicKeyChain(§ pars Preconditions.checkNotNull(§ pars crypter)))
        (§ call chain.deserializeFromProtobuf(§ pars keys))
        (§ return chain)
    )

    #_private
    (§ method void deserializeFromProtobuf(§ args List<Protos.Key> keys))
        (§ throws UnreadableWalletException)
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call Preconditions.checkState(§ pars hashToKeys.isEmpty(§ pars ), "Tried to deserialize into a non-empty chain"))
            (§ for (§ var Protos.Key key) :for (§ expr keys))
            (§ block
                (§ if (§ expr key.getType(§ pars ) != Protos.Key.Type.ORIGINAL && key.getType(§ pars ) != Protos.Key.Type.ENCRYPTED_SCRYPT_AES))
                (§ block
                    (§ continue )
                )

                (§ var boolean encrypted = (§ expr key.getType(§ pars ) == Protos.Key.Type.ENCRYPTED_SCRYPT_AES))
                (§ var byte[] priv = key.hasSecretBytes(§ pars ) ? key.getSecretBytes(§ pars ).toByteArray(§ pars ) :else nil)
                (§ if (§ expr !key.hasPublicKey(§ pars )))
                (§ block
                    (§ throw (§ new UnreadableWalletException(§ pars "Public key missing")))
                )

                (§ var byte[] pub = key.getPublicKey(§ pars ).toByteArray(§ pars ))
                (§ var ECKey ecKey)
                (§ if (§ expr encrypted))
                (§ block
                    (§ call Preconditions.checkState(§ pars keyCrypter != nil, "This wallet is encrypted but encrypt() was not called prior to deserialization"))
                    (§ if (§ expr !key.hasEncryptedData(§ pars )))
                    (§ block
                        (§ throw (§ new UnreadableWalletException(§ pars "Encrypted private key data missing")))
                    )

                    (§ var Protos.EncryptedData proto = key.getEncryptedData(§ pars ))
                    (§ var EncryptedData e = new EncryptedData(§ pars proto.getInitialisationVector(§ pars ).toByteArray(§ pars ), proto.getEncryptedPrivateKey(§ pars ).toByteArray(§ pars )))
                    (§ ass ecKey = ECKey.fromEncrypted(§ pars e, keyCrypter, pub))
                )
                (§ else )
                (§ block
                    (§ ass ecKey = (§ quest (§ expr priv != nil) ? ECKey.fromPrivateAndPrecalculatedPublic(§ pars priv, pub) :else ECKey.fromPublicOnly(§ pars pub)))
                )
                (§ call ecKey.setCreationTimeSeconds(§ pars key.getCreationTimestamp(§ pars ) / 1000))
                (§ call importKeyLocked(§ pars ecKey))
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method void addEventListener(§ args KeyChainEventListener listener))
    (§ block
        (§ call addEventListener(§ pars listener, Threading.USER_THREAD))
    )

    #_override
    #_public
    (§ method void addEventListener(§ args KeyChainEventListener listener, Executor executor))
    (§ block
        (§ call listeners.add(§ pars new ListenerRegistration<>(§ pars listener, executor)))
    )

    #_override
    #_public
    (§ method boolean removeEventListener(§ args KeyChainEventListener listener))
    (§ block
        (§ return ListenerRegistration.removeFromList(§ pars listener, listeners))
    )

    #_private
    (§ method void queueOnKeysAdded(§ args #_final List<ECKey> keys))
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ for (§ var #_final ListenerRegistration<KeyChainEventListener> registration) :for (§ expr listeners))
        (§ block
            (§ call registration.executor.execute(§ pars (§ new Runnable(§ pars ))
            (§ anon
                #_override
                #_public
                (§ method void run(§ args ))
                (§ block
                    (§ call registration.listener.onKeysAdded(§ pars keys))
                )
            )))
        )
    )

    ;;;
     ; Convenience wrapper around {@link #toEncrypted(org.bitcoinj.crypto.KeyCrypter, org.spongycastle.crypto.params.KeyParameter)}
     ; which uses the default Scrypt key derivation algorithm and parameters, derives a key from the given password and returns
     ; the created key.
     ;;
    #_override
    #_public
    (§ method BasicKeyChain toEncrypted(§ args CharSequence password))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars password))
        (§ call Preconditions.checkArgument(§ pars 0 < password.length(§ pars )))

        (§ var KeyCrypter scrypt = new KeyCrypterScrypt(§ pars ))
        (§ var KeyParameter derivedKey = scrypt.deriveKey(§ pars password))
        (§ return toEncrypted(§ pars scrypt, derivedKey))
    )

    ;;;
     ; Encrypt the wallet using the KeyCrypter and the AES key.  A good default KeyCrypter to use is
     ; {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @param keyCrypter The KeyCrypter that specifies how to encrypt/ decrypt a key.
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming
     ;               to create from a password).
     ; @throws KeyCrypterException if the wallet encryption fails.  If so, the wallet state is unchanged.
     ;;
    #_override
    #_public
    (§ method BasicKeyChain toEncrypted(§ args KeyCrypter keyCrypter, KeyParameter aesKey))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call Preconditions.checkNotNull(§ pars keyCrypter))
            (§ call Preconditions.checkState(§ pars this.keyCrypter == nil, "Key chain is already encrypted"))

            (§ var BasicKeyChain encrypted = new BasicKeyChain(§ pars keyCrypter))
            (§ for (§ var ECKey key) :for (§ expr hashToKeys.values(§ pars )))
            (§ block
                (§ var ECKey encryptedKey = key.encrypt(§ pars keyCrypter, aesKey))
                ;; Check that the encrypted key can be successfully decrypted.
                ;; This is done as it is a critical failure if the private key cannot be decrypted successfully
                ;; (all bitcoin controlled by that private key is lost forever).
                ;; For a correctly constructed keyCrypter the encryption should always be reversible so it is just
                ;; being as cautious as possible.
                (§ if (§ expr !ECKey.encryptionIsReversible(§ pars key, encryptedKey, keyCrypter, aesKey)))
                (§ block
                    (§ throw (§ new KeyCrypterException(§ pars "The key " + key + " cannot be successfully decrypted after encryption so aborting wallet encryption.")))
                )
                (§ call encrypted.importKeyLocked(§ pars encryptedKey))
            )
            (§ return encrypted)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method BasicKeyChain toDecrypted(§ args CharSequence password))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars keyCrypter, "Wallet is already decrypted"))

        (§ return toDecrypted(§ pars keyCrypter.deriveKey(§ pars password)))
    )

    #_override
    #_public
    (§ method BasicKeyChain toDecrypted(§ args KeyParameter aesKey))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call Preconditions.checkState(§ pars keyCrypter != nil, "Wallet is already decrypted"))

            ;; Do an up-front check.
            (§ if (§ expr 0 < numKeys(§ pars ) && !checkAESKey(§ pars aesKey)))
            (§ block
                (§ throw (§ new KeyCrypterException(§ pars "Password/key was incorrect.")))
            )

            (§ var BasicKeyChain decrypted = new BasicKeyChain(§ pars ))
            (§ for (§ var ECKey key) :for (§ expr hashToKeys.values(§ pars )))
            (§ block
                (§ call decrypted.importKeyLocked(§ pars key.decrypt(§ pars aesKey)))
            )
            (§ return decrypted)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns whether the given password is correct for this key chain.
     ; @throws IllegalStateException if the chain is not encrypted at all.
     ;;
    #_override
    #_public
    (§ method boolean checkPassword(§ args CharSequence password))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars password))
        (§ call Preconditions.checkState(§ pars keyCrypter != nil, "Key chain not encrypted"))

        (§ return checkAESKey(§ pars keyCrypter.deriveKey(§ pars password)))
    )

    ;;;
     ; Check whether the AES key can decrypt the first encrypted key in the wallet.
     ;
     ; @return true if AES key supplied can decrypt the first encrypted private key in the wallet, false otherwise.
     ;;
    #_override
    #_public
    (§ method boolean checkAESKey(§ args KeyParameter aesKey))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; If no keys then cannot decrypt.
            (§ if (§ expr hashToKeys.isEmpty(§ pars )))
            (§ block
                (§ return false)
            )

            (§ call Preconditions.checkState(§ pars keyCrypter != nil, "Key chain is not encrypted"))

            ;; Find the first encrypted key in the wallet.
            (§ var ECKey first = nil)
            (§ for (§ var ECKey key) :for (§ expr hashToKeys.values(§ pars )))
            (§ block
                (§ if (§ expr key.isEncrypted(§ pars )))
                (§ block
                    (§ ass first = key)
                    (§ break )
                )
            )
            (§ call Preconditions.checkState(§ pars first != nil, "No encrypted keys in the wallet"))

            (§ try )
            (§ block
                (§ var ECKey rebornKey = first.decrypt(§ pars aesKey))
                (§ return Arrays.equals(§ pars first.getPubKey(§ pars ), rebornKey.getPubKey(§ pars )))
            )
            (§ catch (§ args KeyCrypterException _))
            (§ block
                ;; The AES key supplied is incorrect.
                (§ return false)
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method BloomFilter getFilter(§ args int size, double falsePositiveRate, long tweak))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var BloomFilter filter = new BloomFilter(§ pars size, falsePositiveRate, tweak))
            (§ for (§ var ECKey key) :for (§ expr hashToKeys.values(§ pars )))
            (§ block
                (§ call filter.insert(§ pars key))
            )
            (§ return filter)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method int numBloomFilterEntries(§ args ))
    (§ block
        (§ return numKeys(§ pars ) * 2)
    )

    ;;; Returns the first ECKey created after the given UNIX time, or null if there is none. ;;
    #_nilable
    #_public
    (§ method ECKey findOldestKeyAfter(§ args long timeSecs))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var ECKey oldest = nil)
            (§ for (§ var ECKey key) :for (§ expr hashToKeys.values(§ pars )))
            (§ block
                #_final
                (§ var long keyTime = key.getCreationTimeSeconds(§ pars ))
                (§ if (§ expr timeSecs < keyTime && (§ expr oldest == nil || keyTime < oldest.getCreationTimeSeconds(§ pars ))))
                (§ block
                    (§ ass oldest = key)
                )
            )
            (§ return oldest)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;; Returns a list of all ECKeys created after the given UNIX time. ;;
    #_public
    (§ method List<ECKey> findKeysBefore(§ args long timeSecs))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var List<ECKey> results = Lists.newLinkedList(§ pars ))
            (§ for (§ var ECKey key) :for (§ expr hashToKeys.values(§ pars )))
            (§ block
                #_final
                (§ var long keyTime = key.getCreationTimeSeconds(§ pars ))
                (§ if (§ expr keyTime < timeSecs))
                (§ block
                    (§ call results.add(§ pars key))
                )
            )
            (§ return results)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )
)

#_(ns org.bitcoinj.wallet #_"CoinSelection"
    (:import [java.util Collection])
   (:require [org.bitcoinj.core Coin TransactionOutput]))

;;;
 ; Represents the results of a {@link CoinSelector#select(Coin, java.util.List)} operation.
 ; A coin selection represents a list of spendable transaction outputs that sum together to give valueGathered.
 ; Different coin selections could be produced by different coin selectors from the same input set, according
 ; to their varying policies.
 ;;
#_public
(§ class CoinSelection
    #_public
    (§ field Coin valueGathered)
    #_public
    (§ field Collection<TransactionOutput> gathered)

    #_public
    (§ constructor CoinSelection(§ args Coin valueGathered, Collection<TransactionOutput> gathered))
    (§ block
        (§ ass this.valueGathered = valueGathered)
        (§ ass this.gathered = gathered)
    )
)

#_(ns org.bitcoinj.wallet #_"CoinSelector"
    (:import [java.util List])
   (:require [org.bitcoinj.core Coin TransactionOutput]))

;;;
 ; A CoinSelector is responsible for picking some outputs to spend, from the list of all possible outputs.
 ; It allows you to customize the policies for creation of transactions to suit your needs.  The select operation
 ; may return a {@link CoinSelection} that has a valueGathered lower than the requested target, if there's not
 ; enough money in the wallet.
 ;;
#_public
(§ interface CoinSelector
    ;;;
     ; Creates a CoinSelection that tries to meet the target amount of value.  The candidates list is given to
     ; this call and can be edited freely.  See the docs for CoinSelection to learn more, or look a the implementation
     ; of {@link DefaultCoinSelector}.
     ;;
    (§ method CoinSelection select(§ args Coin target, List<TransactionOutput> candidates))
)

#_(ns org.bitcoinj.wallet #_"DecryptingKeyBag"
    (:import [java.util ArrayList List])
    (:import [com.google.common.base Preconditions]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core ECKey]))

;;;
 ; A DecryptingKeyBag filters a pre-existing key bag, decrypting keys as they are requested using the provided AES key.
 ; If the keys are encrypted and no AES key provided, {@link org.bitcoinj.core.ECKey.KeyIsEncryptedException} will be thrown.
 ;;
#_public
(§ class DecryptingKeyBag implements KeyBag
    #_protected
    #_final
    (§ field KeyBag target)
    #_protected
    #_final
    (§ field KeyParameter aesKey)

    #_public
    (§ constructor DecryptingKeyBag(§ args KeyBag target, #_nilable KeyParameter aesKey))
    (§ block
        (§ ass this.target = Preconditions.checkNotNull(§ pars target))
        (§ ass this.aesKey = aesKey)
    )

    #_nilable
    #_private
    (§ method ECKey maybeDecrypt(§ args ECKey key))
    (§ block
        (§ if (§ expr key == nil))
        (§ block
            (§ return nil)
        )

        (§ if (§ expr key.isEncrypted(§ pars )))
        (§ block
            (§ if (§ expr aesKey == nil))
            (§ block
                (§ throw new ECKey.KeyIsEncryptedException(§ pars ))
            )
            (§ return key.decrypt(§ pars aesKey))
        )

        (§ return key)
    )

    #_private
    (§ method RedeemData maybeDecrypt(§ args RedeemData redeemData))
    (§ block
        (§ var List<ECKey> decryptedKeys = new ArrayList<>(§ pars ))
        (§ for (§ var ECKey key) :for (§ expr redeemData.keys))
        (§ block
            (§ call decryptedKeys.add(§ pars maybeDecrypt(§ pars key)))
        )
        (§ return RedeemData.of(§ pars decryptedKeys, redeemData.redeemScript))
    )

    #_nilable
    #_override
    #_public
    (§ method ECKey findKeyFromPubHash(§ args byte[] pubkeyHash))
    (§ block
        (§ return maybeDecrypt(§ pars target.findKeyFromPubHash(§ pars pubkeyHash)))
    )

    #_nilable
    #_override
    #_public
    (§ method ECKey findKeyFromPubKey(§ args byte[] pubkey))
    (§ block
        (§ return maybeDecrypt(§ pars target.findKeyFromPubKey(§ pars pubkey)))
    )

    #_nilable
    #_override
    #_public
    (§ method RedeemData findRedeemDataFromScriptHash(§ args byte[] scriptHash))
    (§ block
        (§ return maybeDecrypt(§ pars target.findRedeemDataFromScriptHash(§ pars scriptHash)))
    )
)

#_(ns org.bitcoinj.wallet #_"DefaultCoinSelector"
    (:import [java.math BigInteger]
             [java.util *])
    (:import [com.google.common.annotations VisibleForTesting])
   (:require [org.bitcoinj.core Coin NetworkParameters Transaction TransactionConfidence TransactionOutput]))

;;;
 ; This class implements a {@link CoinSelector} which attempts to get the highest priority possible.
 ; This means that the transaction is the most likely to get confirmed.  Note that this means we may end up
 ; "spending" more priority than would be required to get the transaction we are creating confirmed.
 ;;
#_public
(§ class DefaultCoinSelector implements CoinSelector
    #_override
    #_public
    (§ method CoinSelection select(§ args Coin target, List<TransactionOutput> candidates))
    (§ block
        (§ var ArrayList<TransactionOutput> selected = new ArrayList<>(§ pars ))
        ;; Sort the inputs by age * value, so we get the highest "coindays" spent.
        ;; TODO: Consider changing the wallets internal format to track just outputs and keep them ordered.
        (§ var ArrayList<TransactionOutput> sortedOutputs = new ArrayList<>(§ pars candidates))
        ;; When calculating the wallet balance, we may be asked to select all possible coins, if so, avoid
        ;; sorting them in order to improve performance.
        ;; TODO: Take in network parameters when instanatiated, and then test against the current network.
        ;; Or just have a boolean parameter for "give me everything".
        (§ if (§ expr !target.equals(§ pars NetworkParameters.MAX_MONEY)))
        (§ block
            (§ call sortOutputs(§ pars sortedOutputs))
        )
        ;; Now iterate over the sorted outputs until we have got as close to the target as possible or
        ;; a little bit over (excessive value will be change).
        (§ var long total = 0)
        (§ for (§ var TransactionOutput output) :for (§ expr sortedOutputs))
        (§ block
            (§ if (§ expr target.value <= total))
            (§ block
                (§ break )
            )
            ;; Only pick chain-included transactions, or transactions that are ours and pending.
            (§ if (§ expr shouldSelect(§ pars output.getParentTransaction(§ pars ))))
            (§ block
                (§ call selected.add(§ pars output))
                (§ ass total = total + output.getValue(§ pars ).value)
            )
        )
        ;; Total may be lower than the target here if the given candidates were insufficient to create
        ;; the requested transaction.
        (§ return (§ new CoinSelection(§ pars Coin.valueOf(§ pars total), selected)))
    )

    #_testing
    #_static
    (§ method void sortOutputs(§ args ArrayList<TransactionOutput> outputs))
    (§ block
        (§ call Collections.sort(§ pars outputs, new Comparator<TransactionOutput>(§ pars )
        (§ anon
            #_override
            #_public
            (§ method int compare(§ args TransactionOutput a, TransactionOutput b))
            (§ block
                (§ var int depth1 = a.getParentTransactionDepthInBlocks(§ pars ))
                (§ var int depth2 = b.getParentTransactionDepthInBlocks(§ pars ))
                (§ var Coin aValue = a.getValue(§ pars ))
                (§ var Coin bValue = b.getValue(§ pars ))
                (§ var BigInteger aCoinDepth = BigInteger.valueOf(§ pars aValue.value).multiply(§ pars BigInteger.valueOf(§ pars depth1)))
                (§ var BigInteger bCoinDepth = BigInteger.valueOf(§ pars bValue.value).multiply(§ pars BigInteger.valueOf(§ pars depth2)))
                (§ var int c1 = bCoinDepth.compareTo(§ pars aCoinDepth))
                (§ if (§ expr c1 != 0))
                (§ block
                    (§ return c1)
                )

                ;; The "coin * days" destroyed are equal, sort by value alone to get the lowest transaction size.
                (§ var int c2 = bValue.compareTo(§ pars aValue))
                (§ if (§ expr c2 != 0))
                (§ block
                    (§ return c2)
                )

                ;; They are entirely equivalent (possibly pending) so sort by hash to ensure a total ordering.
                (§ var BigInteger aHash = a.getParentTransactionHash(§ pars ).toBigInteger(§ pars ))
                (§ var BigInteger bHash = b.getParentTransactionHash(§ pars ).toBigInteger(§ pars ))
                (§ return aHash.compareTo(§ pars bHash))
            )
        )))
    )

    ;;; Sub-classes can override this to just customize whether transactions are usable, but keep age sorting. ;;
    #_protected
    (§ method boolean shouldSelect(§ args Transaction tx))
    (§ block
        (§ return (§ expr tx != nil) ? isSelectable(§ pars tx) :else true)
    )

    #_public
    #_static
    (§ method boolean isSelectable(§ args Transaction tx))
    (§ block
        ;; Only pick chain-included transactions, or transactions that are ours and pending.
        (§ var TransactionConfidence confidence = tx.getConfidence(§ pars ))
        (§ var TransactionConfidence.ConfidenceType type = confidence.getConfidenceType(§ pars ))
        ;; TODO: The value 1 below dates from a time when transactions we broadcast *to* were counted, set to 0.
        (§ return type.equals(§ pars TransactionConfidence.ConfidenceType.BUILDING) || (§ expr type.equals(§ pars TransactionConfidence.ConfidenceType.PENDING) && confidence.getSource(§ pars ).equals(§ pars TransactionConfidence.Source.SELF) && 1 < confidence.numBroadcastPeers(§ pars )))
    )
)

#_(ns org.bitcoinj.wallet #_"DefaultKeyChainFactory"
   (:require [org.bitcoinj.crypto *]))

;;;
 ; Default factory for creating keychains while de-serializing.
 ;;
#_public
(§ class DefaultKeyChainFactory implements KeyChainFactory
    #_override
    #_public
    (§ method DeterministicKeyChain makeKeyChain(§ args Protos.Key key, Protos.Key firstSubKey, DeterministicSeed seed, KeyCrypter crypter, boolean isMarried))
    (§ block
        (§ return isMarried ? new MarriedKeyChain(§ pars seed, crypter) :else new DeterministicKeyChain(§ pars seed, crypter))
    )

    #_override
    #_public
    (§ method DeterministicKeyChain makeWatchingKeyChain(§ args Protos.Key key, Protos.Key firstSubKey, DeterministicKey accountKey, boolean isFollowingKey, boolean isMarried))
        (§ throws UnreadableWalletException)
    (§ block
        (§ if (§ expr !accountKey.getPath(§ pars ).equals(§ pars DeterministicKeyChain.ACCOUNT_ZERO_PATH)))
        (§ block
            (§ throw (§ new UnreadableWalletException(§ pars "Expecting account key but found key with path: " + HDUtils.formatPath(§ pars accountKey.getPath(§ pars )))))
        )

        (§ return isMarried ? new MarriedKeyChain(§ pars accountKey) :else new DeterministicKeyChain(§ pars accountKey, isFollowingKey))
    )
)

#_(ns org.bitcoinj.wallet #_"DefaultRiskAnalysis"
    (:import [java.util List])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core Coin ECKey]
             [org.bitcoinj.core.ECKey ECDSASignature]
             [org.bitcoinj.core NetworkParameters Transaction TransactionConfidence TransactionInput TransactionOutput]
             [org.bitcoinj.crypto TransactionSignature]
             [org.bitcoinj.script ScriptChunk]))

;;;
 ; <p>The default risk analysis.  Currently, it only is concerned with whether a tx/dependency is non-final or not,
 ; and whether a tx/dependency violates the dust rules.  Outside of specialised protocols you should not encounter
 ; non-final transactions.</p>
 ;;
#_public
(§ class DefaultRiskAnalysis implements RiskAnalysis
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars DefaultRiskAnalysis.class))

    ;;;
     ; Any standard output smaller than this value (in satoshis) will be considered risky, as it's most likely
     ; be rejected by the network.  This is usually the same as {@link Transaction#MIN_NONDUST_OUTPUT} but can
     ; be different when the fee is about to change in Bitcoin Core.
     ;;
    #_public
    #_static
    #_final
    (§ field Coin MIN_ANALYSIS_NONDUST_OUTPUT = Transaction.MIN_NONDUST_OUTPUT)

    #_protected
    #_final
    (§ field Transaction tx)
    #_protected
    #_final
    (§ field List<Transaction> dependencies)
    #_nilable
    #_protected
    #_final
    (§ field Wallet wallet)

    #_private
    (§ field Transaction nonStandard)
    #_protected
    (§ field Transaction nonFinal)
    #_protected
    (§ field boolean analyzed)

    #_private
    (§ constructor DefaultRiskAnalysis(§ args Wallet wallet, Transaction tx, List<Transaction> dependencies))
    (§ block
        (§ ass this.tx = tx)
        (§ ass this.dependencies = dependencies)
        (§ ass this.wallet = wallet)
    )

    #_override
    #_public
    (§ method Result analyze(§ args ))
    (§ block
        (§ call Preconditions.checkState(§ pars !analyzed))
        (§ ass analyzed = true)

        (§ var Result result = analyzeIsFinal(§ pars ))
        (§ if (§ expr result != nil && result != Result.OK))
        (§ block
            (§ return result)
        )

        (§ return analyzeIsStandard(§ pars ))
    )

    #_nilable
    #_private
    (§ method Result analyzeIsFinal(§ args ))
    (§ block
        ;; Transactions we create ourselves are, by definition, not at risk of double spending against us.
        (§ if (§ expr tx.getConfidence(§ pars ).getSource(§ pars ) == TransactionConfidence.Source.SELF))
        (§ block
            (§ return Result.OK)
        )

        ;; We consider transactions that opt into replace-by-fee at risk of double spending.
        (§ if (§ expr tx.isOptInFullRBF(§ pars )))
        (§ block
            (§ ass nonFinal = tx)
            (§ return Result.NON_FINAL)
        )

        (§ if (§ expr wallet == nil))
        (§ block
            (§ return nil)
        )

        #_final
        (§ var int height = wallet.getLastBlockSeenHeight(§ pars ))
        #_final
        (§ var long time = wallet.getLastBlockSeenTimeSecs(§ pars ))
        ;; If the transaction has a lock time specified in blocks, we consider that if the tx would become final
        ;; in the next block, it is not risky (as it would confirm normally).
        #_final
        (§ var int adjustedHeight = height + 1)

        (§ if (§ expr !tx.isFinal(§ pars adjustedHeight, time)))
        (§ block
            (§ ass nonFinal = tx)
            (§ return Result.NON_FINAL)
        )

        (§ for (§ var Transaction dep) :for (§ expr dependencies))
        (§ block
            (§ if (§ expr !dep.isFinal(§ pars adjustedHeight, time)))
            (§ block
                (§ ass nonFinal = dep)
                (§ return Result.NON_FINAL)
            )
        )

        (§ return Result.OK)
    )

    ;;;
     ; The reason a transaction is considered non-standard, returned by {@link #isStandard(org.bitcoinj.core.Transaction)}.
     ;;
    #_public
    (§ enum RuleViolation
        (§ item NONE)
        (§ item VERSION)
        (§ item DUST)
        (§ item SHORTEST_POSSIBLE_PUSHDATA)
        (§ item NONEMPTY_STACK) ;; Not yet implemented (for post 0.12)
        (§ item SIGNATURE_CANONICAL_ENCODING)
    )

    ;;;
     ; <p>Checks if a transaction is considered "standard" by Bitcoin Core's IsStandardTx and AreInputsStandard functions.</p>
     ;
     ; <p>Note that this method currently only implements a minimum of checks.  More to be added later.</p>
     ;;
    #_public
    #_static
    (§ method RuleViolation isStandard(§ args Transaction tx))
    (§ block
        ;; TODO: Finish this function off.
        (§ if (§ expr 1 < tx.getVersion(§ pars ) || tx.getVersion(§ pars ) < 1))
        (§ block
            (§ call log.warn(§ pars "TX considered non-standard due to unknown version number {}", tx.getVersion(§ pars )))
            (§ return RuleViolation.VERSION)
        )

        #_final
        (§ var List<TransactionOutput> outputs = tx.getOutputs(§ pars ))
        (§ for (§ var int i = 0) :for (§ expr i < outputs.size(§ pars )) :for (§ ass i = i + 1))
        (§ block
            (§ var TransactionOutput output = outputs.get(§ pars i))
            (§ var RuleViolation violation = isOutputStandard(§ pars output))
            (§ if (§ expr violation != RuleViolation.NONE))
            (§ block
                (§ call log.warn(§ pars "TX considered non-standard due to output {} violating rule {}", i, violation))
                (§ return violation)
            )
        )

        #_final
        (§ var List<TransactionInput> inputs = tx.getInputs(§ pars ))
        (§ for (§ var int i = 0) :for (§ expr i < inputs.size(§ pars )) :for (§ ass i = i + 1))
        (§ block
            (§ var TransactionInput input = inputs.get(§ pars i))
            (§ var RuleViolation violation = isInputStandard(§ pars input))
            (§ if (§ expr violation != RuleViolation.NONE))
            (§ block
                (§ call log.warn(§ pars "TX considered non-standard due to input {} violating rule {}", i, violation))
                (§ return violation)
            )
        )

        (§ return RuleViolation.NONE)
    )

    ;;;
     ; Checks the output to see if the script violates a standardness rule.  Not complete.
     ;;
    #_public
    #_static
    (§ method RuleViolation isOutputStandard(§ args TransactionOutput output))
    (§ block
        (§ if (§ expr output.getValue(§ pars ).compareTo(§ pars MIN_ANALYSIS_NONDUST_OUTPUT) < 0))
        (§ block
            (§ return RuleViolation.DUST)
        )

        (§ for (§ var ScriptChunk chunk) :for (§ expr output.getScriptPubKey(§ pars ).getChunks(§ pars )))
        (§ block
            (§ if (§ expr chunk.isPushData(§ pars ) && !chunk.isShortestPossiblePushData(§ pars )))
            (§ block
                (§ return RuleViolation.SHORTEST_POSSIBLE_PUSHDATA)
            )
        )

        (§ return RuleViolation.NONE)
    )

    ;;; Checks if the given input passes some of the AreInputsStandard checks.  Not complete. ;;
    #_public
    #_static
    (§ method RuleViolation isInputStandard(§ args TransactionInput input))
    (§ block
        (§ for (§ var ScriptChunk chunk) :for (§ expr input.getScriptSig(§ pars ).getChunks(§ pars )))
        (§ block
            (§ if (§ expr chunk.data != nil && !chunk.isShortestPossiblePushData(§ pars )))
            (§ block
                (§ return RuleViolation.SHORTEST_POSSIBLE_PUSHDATA)
            )

            (§ if (§ expr chunk.isPushData(§ pars )))
            (§ block
                (§ var ECDSASignature signature)
                (§ try )
                (§ block
                    (§ ass signature = ECKey.ECDSASignature.decodeFromDER(§ pars chunk.data))
                )
                (§ catch (§ args IllegalArgumentException _))
                (§ block
                    ;; Doesn't look like a signature.
                    (§ ass signature = nil)
                )
                (§ if (§ expr signature != nil))
                (§ block
                    (§ if (§ expr !TransactionSignature.isEncodingCanonical(§ pars chunk.data)))
                    (§ block
                        (§ return RuleViolation.SIGNATURE_CANONICAL_ENCODING)
                    )
                    (§ if (§ expr !signature.isCanonical(§ pars )))
                    (§ block
                        (§ return RuleViolation.SIGNATURE_CANONICAL_ENCODING)
                    )
                )
            )
        )
        (§ return RuleViolation.NONE)
    )

    #_private
    (§ method Result analyzeIsStandard(§ args ))
    (§ block
        ;; The IsStandard rules don't apply on testnet, because they're just a safety mechanism and we don't
        ;; want to crush innovation with valueless test coins.
        (§ if (§ expr wallet != nil && !wallet.getNetworkParameters(§ pars ).getId(§ pars ).equals(§ pars NetworkParameters.ID_MAINNET)))
        (§ block
            (§ return Result.OK)
        )

        (§ var RuleViolation ruleViolation = isStandard(§ pars tx))
        (§ if (§ expr ruleViolation != RuleViolation.NONE))
        (§ block
            (§ ass nonStandard = tx)
            (§ return Result.NON_STANDARD)
        )

        (§ for (§ var Transaction dep) :for (§ expr dependencies))
        (§ block
            (§ ass ruleViolation = isStandard(§ pars dep))
            (§ if (§ expr ruleViolation != RuleViolation.NONE))
            (§ block
                (§ ass nonStandard = dep)
                (§ return Result.NON_STANDARD)
            )
        )

        (§ return Result.OK)
    )

    ;;; Returns the transaction that was found to be non-standard, or null. ;;
    #_nilable
    #_public
    (§ method Transaction getNonStandard(§ args ))
    (§ block
        (§ return nonStandard)
    )

    ;;; Returns the transaction that was found to be non-final, or null. ;;
    #_nilable
    #_public
    (§ method Transaction getNonFinal(§ args ))
    (§ block
        (§ return nonFinal)
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ if (§ expr !analyzed))
        (§ block
            (§ return "Pending risk analysis for " + tx.getHashAsString(§ pars ))
        )
        (§ if (§ expr nonFinal != nil))
        (§ block
            (§ return "Risky due to non-finality of " + nonFinal.getHashAsString(§ pars ))
        )
        (§ if (§ expr nonStandard != nil))
        (§ block
            (§ return "Risky due to non-standard tx " + nonStandard.getHashAsString(§ pars ))
        )

        (§ return "Non-risky")
    )

    #_public
    #_static
    (§ class Analyzer implements RiskAnalysis.Analyzer
        #_override
        #_public
        (§ method DefaultRiskAnalysis create(§ args Wallet wallet, Transaction tx, List<Transaction> dependencies))
        (§ block
            (§ return (§ new DefaultRiskAnalysis(§ pars wallet, tx, dependencies)))
        )
    )

    #_public
    #_static
    (§ field Analyzer FACTORY = new Analyzer(§ pars ))
)

#_(ns org.bitcoinj.wallet #_"DeterministicKeyChain"
    (:import [java.math BigInteger]
             [java.security SecureRandom]
             [java.util *]
             [java.util.concurrent Executor]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.base Preconditions Stopwatch]
             [com.google.common.collect ImmutableList Iterators]
             #_static [com.google.common.collect.Lists newArrayList]
             #_static [com.google.common.collect.Lists newLinkedList]
             [com.google.common.collect PeekingIterator]
             [com.google.protobuf ByteString]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core BloomFilter ECKey NetworkParameters Utils]
             [org.bitcoinj.crypto *]
             [org.bitcoinj.script Script]
             [org.bitcoinj.utils Threading]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

;;;
 ; <p>A deterministic key chain is a {@link KeyChain} that uses the
 ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP 32 standard</a>, as implemented by
 ; {@link org.bitcoinj.crypto.DeterministicHierarchy}, to derive all the keys in the keychain from a master seed.
 ; This type of wallet is extremely convenient and flexible.  Although backing up full wallet files is always a good
 ; idea, to recover money only the root seed needs to be preserved and that is a number small enough that it can be
 ; written down on paper or, when represented using a BIP 39 {@link org.bitcoinj.crypto.MnemonicCode},
 ; dictated over the phone (possibly even memorized).</p>
 ;
 ; <p>Deterministic key chains have other advantages: parts of the key tree can be selectively revealed to allow
 ; for auditing, and new public keys can be generated without access to the private keys, yielding a highly secure
 ; configuration for web servers which can accept payments into a wallet but not spend from them.  This does not work
 ; quite how you would expect due to a quirk of elliptic curve mathematics and the techniques used to deal with it.
 ; A watching wallet is not instantiated using the public part of the master key as you may imagine.  Instead, you
 ; need to take the account key (first child of the master key) and provide the public part of that to the watching
 ; wallet instead.  You can do this by calling {@link #getWatchingKey()} and then serializing it with
 ; {@link org.bitcoinj.crypto.DeterministicKey#serializePubB58(org.bitcoinj.core.NetworkParameters)}.  The resulting
 ; "xpub..." string encodes sufficient information about the account key to create a watching chain via
 ; {@link org.bitcoinj.crypto.DeterministicKey#deserializeB58(org.bitcoinj.crypto.DeterministicKey, String, org.bitcoinj.core.NetworkParameters)}
 ; (with null as the first parameter) and then
 ; {@link DeterministicKeyChain#DeterministicKeyChain(org.bitcoinj.crypto.DeterministicKey)}.</p>
 ;
 ; <p>This class builds on {@link org.bitcoinj.crypto.DeterministicHierarchy} and {@link org.bitcoinj.crypto.DeterministicKey}
 ; by adding support for serialization to and from protobufs, and encryption of parts of the key tree.  Internally it
 ; arranges itself as per the BIP 32 spec, with the seed being used to derive a master key, which is then used to derive
 ; an account key, the account key is used to derive two child keys called the <i>internal</i> and <i>external</i> parent
 ; keys (for change and handing out addresses respectively) and finally the actual leaf keys that users use hanging off
 ; the end.  The leaf keys are special in that they don't internally store the private part at all, instead choosing to
 ; rederive the private key from the parent when needed for signing.  This simplifies the design for encrypted key chains.</p>
 ;
 ; <p>The key chain manages a <i>lookahead zone</i>.  This zone is required because when scanning the chain, you don't
 ; know exactly which keys might receive payments.  The user may have handed out several addresses and received payments
 ; on them, but for latency reasons the block chain is requested from remote peers in bulk, meaning you must
 ; "look ahead" when calculating keys to put in the Bloom filter.  The default lookahead zone is 100 keys, meaning
 ; if the user hands out more than 100 addresses and receives payment on them before the chain is next scanned, some
 ; transactions might be missed.  100 is a reasonable choice for consumer wallets running on CPU constrained devices.
 ; For industrial wallets that are receiving keys all the time, a higher value is more appropriate.  Ideally DKC and
 ; the wallet would know how to adjust this value automatically, but that's not implemented at the moment.</p>
 ;
 ; <p>In fact the real size of the lookahead zone is larger than requested, by default, it's one third larger.  This
 ; is because the act of deriving new keys means recalculating the Bloom filters and this is an expensive operation.
 ; Thus, to ensure we don't have to recalculate on every single new key/address requested or seen we add more buffer
 ; space and only extend the lookahead zone when that buffer is exhausted.  For example with a lookahead zone of 100
 ; keys, you can request 33 keys before more keys will be calculated and the Bloom filter rebuilt and rebroadcast.
 ; But even when you are requesting the 33rd key, you will still be looking 100 keys ahead.</p>
 ;
 ; @author Andreas Schildbach
 ;;
#_suppress(§ opt "PublicStaticCollectionField")
#_public
(§ class DeterministicKeyChain implements EncryptableKeyChain
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars DeterministicKeyChain.class))
    #_public
    #_static
    #_final
    (§ field String DEFAULT_PASSPHRASE_FOR_MNEMONIC = "")

    #_protected
    #_final
    (§ field ReentrantLock lock = Threading.lock(§ pars "DeterministicKeyChain"))

    #_private
    (§ field DeterministicHierarchy hierarchy)
    #_nilable
    #_private
    (§ field DeterministicKey rootKey)
    #_nilable
    #_private
    (§ field DeterministicSeed seed)

    ;; Paths through the key tree.  External keys are ones that are communicated to other parties.  Internal keys are
    ;; keys created for change addresses, coinbases, mixing, etc - anything that isn't communicated.  The distinction
    ;; is somewhat arbitrary but can be useful for audits.  The first number is the "account number" but we don't use
    ;; that feature yet.  In future we might hand out different accounts for cases where we wish to hand payers
    ;; a payment request that can generate lots of addresses independently.
    ;; The account path may be overridden by subclasses.
    #_public
    #_static
    #_final
    (§ field ImmutableList<ChildNumber> ACCOUNT_ZERO_PATH = ImmutableList.of(§ pars ChildNumber.ZERO_HARDENED))
    #_public
    #_static
    #_final
    (§ field ImmutableList<ChildNumber> EXTERNAL_SUBPATH = ImmutableList.of(§ pars ChildNumber.ZERO))
    #_public
    #_static
    #_final
    (§ field ImmutableList<ChildNumber> INTERNAL_SUBPATH = ImmutableList.of(§ pars ChildNumber.ONE))
    #_public
    #_static
    #_final
    (§ field ImmutableList<ChildNumber> EXTERNAL_PATH = HDUtils.concat(§ pars ACCOUNT_ZERO_PATH, EXTERNAL_SUBPATH))
    #_public
    #_static
    #_final
    (§ field ImmutableList<ChildNumber> INTERNAL_PATH = HDUtils.concat(§ pars ACCOUNT_ZERO_PATH, INTERNAL_SUBPATH))
    ;; m / 44' / 0' / 0'
    #_public
    #_static
    #_final
    (§ field ImmutableList<ChildNumber> BIP44_ACCOUNT_ZERO_PATH = ImmutableList.of(§ pars (§ new ChildNumber(§ pars 44, true)), ChildNumber.ZERO_HARDENED, ChildNumber.ZERO_HARDENED))

    ;; We try to ensure we have at least this many keys ready and waiting to be handed out via getKey().  See docs
    ;; for getLookaheadSize() for more info on what this is for.  The -1 value means it hasn't been calculated yet.
    ;; For new chains it's set to whatever the default is, unless overridden by setLookaheadSize.  For deserialized
    ;; chains, it will be calculated on demand from the number of loaded keys.
    #_private
    #_static
    #_final
    (§ field int LAZY_CALCULATE_LOOKAHEAD = -1)
    #_protected
    (§ field int lookaheadSize = 100)
    ;; The lookahead threshold causes us to batch up creation of new keys to minimize the frequency of Bloom filter
    ;; regenerations, which are expensive and will (in future) trigger chain download stalls/retries.  One third is
    ;; an efficiency tradeoff.
    #_protected
    (§ field int lookaheadThreshold = calcDefaultLookaheadThreshold(§ pars ))

    #_private
    (§ method int calcDefaultLookaheadThreshold(§ args ))
    (§ block
        (§ return lookaheadSize / 3)
    )

    ;; The parent keys for external keys (handed out to other people) and internal keys (used for change addresses).
    #_private
    (§ field DeterministicKey externalParentKey, internalParentKey)
    ;; How many keys on each path have actually been used.  This may be fewer than the number that have been
    ;; deserialized or held in memory, because of the lookahead zone.
    #_private
    (§ field int issuedExternalKeys, issuedInternalKeys)
    ;; A counter that is incremented each time a key in the lookahead threshold zone is marked as used and lookahead
    ;; is triggered.  The Wallet/KCG reads these counters and combines them so it can tell the Peer whether to throw
    ;; away the current block (and any future blocks in the same download batch) and restart chain sync once a new filter
    ;; has been calculated.  This field isn't persisted to the wallet as it's only relevant within a network session.
    #_private
    (§ field int keyLookaheadEpoch)

    ;; We simplify by wrapping a basic key chain and that way we get some functionality like key lookup and event
    ;; listeners "for free".  All keys in the key tree appear here, even if they aren't meant to be used for
    ;; receiving money.
    #_private
    #_final
    (§ field BasicKeyChain basicKeyChain)

    ;; If set this chain is following another chain in a married KeyChainGroup.
    #_private
    (§ field boolean isFollowing)

    ;; Holds a number of signatures required to spend.  It's the N from N-of-M CHECKMULTISIG script for P2SH transactions
    ;; and always 1 for other transaction types.
    #_protected
    (§ field int sigsRequiredToSpend = 1)

    #_public
    #_static
    (§ class Builder<T extends Builder<T>>
        #_protected
        (§ field SecureRandom random)
        #_protected
        (§ field int bits = 128)
        #_protected
        (§ field String passphrase)
        #_protected
        (§ field long seedCreationTimeSecs)
        #_protected
        (§ field byte[] entropy)
        #_protected
        (§ field DeterministicSeed seed)
        #_protected
        (§ field DeterministicKey watchingKey)

        #_protected
        (§ constructor Builder(§ args ))
        (§ block
        )

        #_suppress(§ opt "unchecked")
        #_protected
        (§ method T self(§ args ))
        (§ block
            (§ return (§ cast T)this)
        )

        ;;;
         ; Creates a deterministic key chain starting from the given entropy.  All keys yielded by this chain will be the
         ; same if the starting entropy is the same.  You should provide the creation time in seconds since the UNIX epoch
         ; for the seed: this lets us know from what part of the chain we can expect to see derived keys appear.
         ;;
        #_public
        (§ method T entropy(§ args byte[] entropy))
        (§ block
            (§ ass this.entropy = entropy)
            (§ return self(§ pars ))
        )

        ;;;
         ; Creates a deterministic key chain starting from the given seed.  All keys yielded by this chain will be the same
         ; if the starting seed is the same.
         ;;
        #_public
        (§ method T seed(§ args DeterministicSeed seed))
        (§ block
            (§ ass this.seed = seed)
            (§ return self(§ pars ))
        )

        ;;;
         ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom} object
         ; and of the requested size in bits.  The derived seed is further protected with a user selected passphrase (see BIP 39).
         ; @param random The random number generator - use new SecureRandom().
         ; @param bits The number of bits of entropy to use when generating entropy.  Either 128 (default), 192 or 256.
         ;;
        #_public
        (§ method T random(§ args SecureRandom random, int bits))
        (§ block
            (§ ass this.random = random)
            (§ ass this.bits = bits)
            (§ return self(§ pars ))
        )

        ;;;
         ; Generates a new key chain with 128 bits of entropy selected randomly from the given {@link java.security.SecureRandom}
         ; object.  The derived seed is further protected with a user selected passphrase (see BIP 39).
         ; @param random The random number generator - use new SecureRandom().
         ;;
        #_public
        (§ method T random(§ args SecureRandom random))
        (§ block
            (§ ass this.random = random)
            (§ return self(§ pars ))
        )

        #_public
        (§ method T watchingKey(§ args DeterministicKey watchingKey))
        (§ block
            (§ ass this.watchingKey = watchingKey)
            (§ return self(§ pars ))
        )

        #_public
        (§ method T seedCreationTimeSecs(§ args long seedCreationTimeSecs))
        (§ block
            (§ ass this.seedCreationTimeSecs = seedCreationTimeSecs)
            (§ return self(§ pars ))
        )

        ;;;
         ; The passphrase to use with the generated mnemonic, or null if you would like to use the default empty string.
         ; Currently must be the empty string.
         ;;
        #_public
        (§ method T passphrase(§ args String passphrase))
        (§ block
            ;; FIXME support non-empty passphrase
            (§ ass this.passphrase = passphrase)
            (§ return self(§ pars ))
        )

        #_public
        (§ method DeterministicKeyChain build(§ args ))
        (§ block
            (§ call Preconditions.checkState(§ pars random != nil || entropy != nil || seed != nil || watchingKey!= nil, "Must provide either entropy or random or seed or watchingKey"))
            (§ call Preconditions.checkState(§ pars passphrase == nil || seed == nil, "Passphrase must not be specified with seed"))

            ;; Default passphrase to "" if not specified.
            (§ if (§ expr random != nil))
            (§ block
                (§ return (§ new DeterministicKeyChain(§ pars random, bits, getPassphrase(§ pars ), seedCreationTimeSecs)))
            )

            (§ if (§ expr entropy != nil))
            (§ block
                (§ return (§ new DeterministicKeyChain(§ pars entropy, getPassphrase(§ pars ), seedCreationTimeSecs)))
            )

            (§ if (§ expr seed != nil))
            (§ block
                (§ call seed.setCreationTimeSeconds(§ pars seedCreationTimeSecs))
                (§ return (§ new DeterministicKeyChain(§ pars seed)))
            )

            (§ call watchingKey.setCreationTimeSeconds(§ pars seedCreationTimeSecs))
            (§ return (§ new DeterministicKeyChain(§ pars watchingKey)))
        )

        #_protected
        (§ method String getPassphrase(§ args ))
        (§ block
            (§ return (§ expr passphrase != nil) ? passphrase :else DEFAULT_PASSPHRASE_FOR_MNEMONIC)
        )
    )

    #_public
    #_static
    (§ method Builder<?> builder(§ args ))
    (§ block
        (§ return (§ new Builder(§ pars )))
    )

    ;;;
     ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
     ; object and the default entropy size.
     ;;
    #_public
    (§ constructor DeterministicKeyChain(§ args SecureRandom random))
    (§ block
        (§ this (§ pars random, DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS, DEFAULT_PASSPHRASE_FOR_MNEMONIC, Utils.currentTimeSeconds(§ pars )))
    )

    ;;;
     ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
     ; object and of the requested size in bits.
     ;;
    #_public
    (§ constructor DeterministicKeyChain(§ args SecureRandom random, int bits))
    (§ block
        (§ this (§ pars random, bits, DEFAULT_PASSPHRASE_FOR_MNEMONIC, Utils.currentTimeSeconds(§ pars )))
    )

    ;;;
     ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
     ; object and of the requested size in bits.  The derived seed is further protected with a user selected passphrase
     ; (see BIP 39).
     ;;
    #_public
    (§ constructor DeterministicKeyChain(§ args SecureRandom random, int bits, String passphrase, long seedCreationTimeSecs))
    (§ block
        (§ this (§ pars new DeterministicSeed(§ pars random, bits, passphrase, seedCreationTimeSecs)))
    )

    ;;;
     ; Creates a deterministic key chain starting from the given entropy.  All keys yielded by this chain will be the
     ; same if the starting seed is the same.  You should provide the creation time in seconds since the UNIX epoch
     ; for the seed: this lets us know from what part of the chain we can expect to see derived keys appear.
     ;;
    #_public
    (§ constructor DeterministicKeyChain(§ args byte[] entropy, String passphrase, long seedCreationTimeSecs))
    (§ block
        (§ this (§ pars new DeterministicSeed(§ pars entropy, passphrase, seedCreationTimeSecs)))
    )

    ;;;
     ; Creates a deterministic key chain starting from the given seed.  All keys yielded by this chain will be the
     ; same if the starting seed is the same.
     ;;
    #_protected
    (§ constructor DeterministicKeyChain(§ args DeterministicSeed seed))
    (§ block
        (§ this (§ pars seed, nil))
    )

    ;;;
     ; Creates a deterministic key chain that watches the given (public only) root key.  You can use this to calculate
     ; balances and generally follow along, but spending is not possible with such a chain.  Currently you can't use
     ; this method to watch an arbitrary fragment of some other tree, this limitation may be removed in future.
     ;;
    #_public
    (§ constructor DeterministicKeyChain(§ args DeterministicKey watchingKey))
    (§ block
        (§ call Preconditions.checkArgument(§ pars watchingKey.isPubKeyOnly(§ pars ), "Private subtrees not currently supported: if you got this key from DKC.getWatchingKey() then use .dropPrivate().dropParent() on it first."))
        (§ call Preconditions.checkArgument(§ pars watchingKey.getPath(§ pars ).size(§ pars ) == getAccountPath(§ pars ).size(§ pars ), "You can only watch an account key currently"))

        (§ ass basicKeyChain = new BasicKeyChain(§ pars ))
        (§ ass this.seed = nil)
        (§ ass this.rootKey = nil)
        (§ call basicKeyChain.importKey(§ pars watchingKey))
        (§ ass hierarchy = new DeterministicHierarchy(§ pars watchingKey))
        (§ call initializeHierarchyUnencrypted(§ pars watchingKey))
    )

    ;;;
     ; <p>Creates a deterministic key chain with the given watch key.  If <code>isFollowing</code> flag is set then this
     ; keychain follows some other keychain.  In a married wallet following keychain represents "spouse's" keychain.</p>
     ; <p>Watch key has to be an account key.</p>
     ;;
    #_protected
    (§ constructor DeterministicKeyChain(§ args DeterministicKey watchKey, boolean isFollowing))
    (§ block
        (§ this (§ pars watchKey))
        (§ ass this.isFollowing = isFollowing)
    )

    ;;;
     ; Creates a deterministic key chain with the given watch key and that follows some other keychain.
     ; In a married wallet following keychain represents "spouse".
     ; Watch key has to be an account key.
     ;;
    #_public
    #_static
    (§ method DeterministicKeyChain watchAndFollow(§ args DeterministicKey watchKey))
    (§ block
        (§ return (§ new DeterministicKeyChain(§ pars watchKey, true)))
    )

    ;;;
     ; Creates a key chain that watches the given account key.
     ;;
    #_public
    #_static
    (§ method DeterministicKeyChain watch(§ args DeterministicKey accountKey))
    (§ block
        (§ return (§ new DeterministicKeyChain(§ pars accountKey)))
    )

    ;;;
     ; For use in {@link KeyChainFactory} during deserialization.
     ;;
    #_protected
    (§ constructor DeterministicKeyChain(§ args DeterministicSeed seed, #_nilable KeyCrypter crypter))
    (§ block
        (§ ass this.seed = seed)
        (§ ass basicKeyChain = new BasicKeyChain(§ pars crypter))
        (§ if (§ expr !seed.isEncrypted(§ pars )))
        (§ block
            (§ ass rootKey = HDKeyDerivation.createMasterPrivateKey(§ pars Preconditions.checkNotNull(§ pars seed.getSeedBytes(§ pars ))))
            (§ call rootKey.setCreationTimeSeconds(§ pars seed.getCreationTimeSeconds(§ pars )))
            (§ call basicKeyChain.importKey(§ pars rootKey))
            (§ ass hierarchy = new DeterministicHierarchy(§ pars rootKey))
            (§ for (§ var int i = 1) :for (§ expr i <= getAccountPath(§ pars ).size(§ pars )) :for (§ ass i = i + 1))
            (§ block
                (§ call basicKeyChain.importKey(§ pars hierarchy.get(§ pars getAccountPath(§ pars ).subList(§ pars 0, i), false, true)))
            )
            (§ call initializeHierarchyUnencrypted(§ pars rootKey))
        )
        ;; Else...
        ;; We can't initialize ourselves with just an encrypted seed, so we expected deserialization code
        ;; to do the rest of the setup (loading the root key).
    )

    ;;;
     ; For use in encryption when {@link #toEncrypted(KeyCrypter, KeyParameter)} is called,
     ; so that subclasses can override that method and create an instance of the right class.
     ;
     ; See also {@link #makeKeyChainFromSeed(DeterministicSeed)}.
     ;;
    #_protected
    (§ constructor DeterministicKeyChain(§ args KeyCrypter crypter, KeyParameter aesKey, DeterministicKeyChain chain))
    (§ block
        ;; Can't encrypt a watching chain.
        (§ call Preconditions.checkNotNull(§ pars chain.rootKey))
        (§ call Preconditions.checkNotNull(§ pars chain.seed))

        (§ call Preconditions.checkArgument(§ pars !chain.rootKey.isEncrypted(§ pars ), "Chain already encrypted"))

        (§ ass this.issuedExternalKeys = chain.issuedExternalKeys)
        (§ ass this.issuedInternalKeys = chain.issuedInternalKeys)

        (§ ass this.lookaheadSize = chain.lookaheadSize)
        (§ ass this.lookaheadThreshold = chain.lookaheadThreshold)

        (§ ass this.seed = chain.seed.encrypt(§ pars crypter, aesKey))
        (§ ass basicKeyChain = new BasicKeyChain(§ pars crypter))
        ;; The first number is the "account number" but we don't use that feature.
        (§ ass rootKey = chain.rootKey.encrypt(§ pars crypter, aesKey, nil))
        (§ ass hierarchy = new DeterministicHierarchy(§ pars rootKey))
        (§ call basicKeyChain.importKey(§ pars rootKey))

        (§ for (§ var int i = 1) :for (§ expr i < getAccountPath(§ pars ).size(§ pars )) :for (§ ass i = i + 1))
        (§ block
            (§ call encryptNonLeaf(§ pars aesKey, chain, rootKey, getAccountPath(§ pars ).subList(§ pars 0, i)))
        )

        (§ var DeterministicKey account = encryptNonLeaf(§ pars aesKey, chain, rootKey, getAccountPath(§ pars )))
        (§ ass externalParentKey = encryptNonLeaf(§ pars aesKey, chain, account, HDUtils.concat(§ pars getAccountPath(§ pars ), EXTERNAL_SUBPATH)))
        (§ ass internalParentKey = encryptNonLeaf(§ pars aesKey, chain, account, HDUtils.concat(§ pars getAccountPath(§ pars ), INTERNAL_SUBPATH)))

        ;; Now copy the (pubkey only) leaf keys across to avoid rederiving them.  The private key bytes are missing
        ;; anyway so there's nothing to encrypt.
        (§ for (§ var ECKey eckey) :for (§ expr chain.basicKeyChain.getKeys(§ pars )))
        (§ block
            (§ var DeterministicKey key = (§ cast DeterministicKey)eckey)
            (§ if (§ expr key.getPath(§ pars ).size(§ pars ) != getAccountPath(§ pars ).size(§ pars ) + 2))
            (§ block
                (§ continue ) ;; Not a leaf key.
            )

            (§ var DeterministicKey parent = hierarchy.get(§ pars Preconditions.checkNotNull(§ pars key.getParent(§ pars )).getPath(§ pars ), false, false))
            ;; Clone the key to the new encrypted hierarchy.
            (§ ass key = new DeterministicKey(§ pars key.dropPrivateBytes(§ pars ), parent))
            (§ call hierarchy.putKey(§ pars key))
            (§ call basicKeyChain.importKey(§ pars key))
        )
    )

    ;;; Override in subclasses to use a different account derivation path. ;;
    #_protected
    (§ method ImmutableList<ChildNumber> getAccountPath(§ args ))
    (§ block
        (§ return ACCOUNT_ZERO_PATH)
    )

    #_private
    (§ method DeterministicKey encryptNonLeaf(§ args KeyParameter aesKey, DeterministicKeyChain chain, DeterministicKey parent, ImmutableList<ChildNumber> path))
    (§ block
        (§ var DeterministicKey key = chain.hierarchy.get(§ pars path, false, false))
        (§ ass key = key.encrypt(§ pars Preconditions.checkNotNull(§ pars basicKeyChain.getKeyCrypter(§ pars )), aesKey, parent))
        (§ call hierarchy.putKey(§ pars key))
        (§ call basicKeyChain.importKey(§ pars key))
        (§ return key)
    )

    ;; Derives the account path keys and inserts them into the basic key chain.
    ;; This is important to preserve their order for serialization, amongst other things.
    #_private
    (§ method void initializeHierarchyUnencrypted(§ args DeterministicKey baseKey))
    (§ block
        (§ ass externalParentKey = hierarchy.deriveChild(§ pars getAccountPath(§ pars ), false, false, ChildNumber.ZERO))
        (§ ass internalParentKey = hierarchy.deriveChild(§ pars getAccountPath(§ pars ), false, false, ChildNumber.ONE))
        (§ call basicKeyChain.importKey(§ pars externalParentKey))
        (§ call basicKeyChain.importKey(§ pars internalParentKey))
    )

    ;;; Returns a freshly derived key that has not been returned by this method before. ;;
    #_override
    #_public
    (§ method DeterministicKey getKey(§ args KeyPurpose purpose))
    (§ block
        (§ return getKeys(§ pars purpose, 1).get(§ pars 0))
    )

    ;;; Returns freshly derived key/s that have not been returned by this method before. ;;
    #_override
    #_public
    (§ method List<DeterministicKey> getKeys(§ args KeyPurpose purpose, int numberOfKeys))
    (§ block
        (§ call Preconditions.checkArgument(§ pars 0 < numberOfKeys))
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var DeterministicKey parentKey)
            (§ var int index)
            (§ switch (§ expr purpose))
            (§ block
                ;; Map both REFUND and RECEIVE_KEYS to the same branch for now.  Refunds are a feature of the BIP 70
                ;; payment protocol.  Later we may wish to map it to a different branch (in a new wallet version?).
                ;; This would allow a watching wallet to only be able to see inbound payments, but not change
                ;; (i.e. spends) or refunds.  Might be useful for auditing ...
                (§ case RECEIVE_FUNDS)
                (§ case REFUND)
                (§ block
                    (§ ass issuedExternalKeys = issuedExternalKeys + numberOfKeys)
                    (§ ass index = issuedExternalKeys)
                    (§ ass parentKey = externalParentKey)
                    (§ break )
                )
                (§ case AUTHENTICATION)
                (§ case CHANGE)
                (§ block
                    (§ ass issuedInternalKeys = issuedInternalKeys + numberOfKeys)
                    (§ ass index = issuedInternalKeys)
                    (§ ass parentKey = internalParentKey)
                    (§ break )
                )
                (§ default )
                (§ block
                    (§ throw (§ new UnsupportedOperationException(§ pars )))
                )
            )
            ;; Optimization: potentially do a very quick key generation for just the number of keys we need if we
            ;; didn't already create them, ignoring the configured lookahead size.  This ensures we'll be able to
            ;; retrieve the keys in the following loop, but if we're totally fresh and didn't get a chance to
            ;; calculate the lookahead keys yet, this will not block waiting to calculate 100+ EC point multiplies.
            ;; On slow/crappy Android phones looking ahead 100 keys can take ~5 seconds but the OS will kill us
            ;; if we block for just one second on the UI thread.  Because UI threads may need an address in order
            ;; to render the screen, we need getKeys to be fast even if the wallet is totally brand new and lookahead
            ;; didn't happen yet.
            ;;
            ;; It's safe to do this because when a network thread tries to calculate a Bloom filter, we'll go ahead
            ;; and calculate the full lookahead zone there, so network requests will always use the right amount.
            (§ var List<DeterministicKey> lookahead = maybeLookAhead(§ pars parentKey, index, 0, 0))
            (§ call basicKeyChain.importKeys(§ pars lookahead))
            (§ var List<DeterministicKey> keys = new ArrayList<>(§ pars numberOfKeys))
            (§ for (§ var int i = 0) :for (§ expr i < numberOfKeys) :for (§ ass i = i + 1))
            (§ block
                (§ var ImmutableList<ChildNumber> path = HDUtils.append(§ pars parentKey.getPath(§ pars ), new ChildNumber(§ pars index - numberOfKeys + i, false)))
                (§ var DeterministicKey k = hierarchy.get(§ pars path, false, false))
                ;; Just a last minute sanity check before we hand the key out to the app for usage.  This isn't
                ;; inspired by any real problem reports from bitcoinj users, but I've heard of cases via the grapevine
                ;; of places that lost money due to bitflips causing addresses to not match keys.  Of course in an
                ;; environment with flaky RAM there's no real way to always win: bitflips could be introduced at any
                ;; other layer.  But as we're potentially retrieving from long term storage here, check anyway.
                (§ call checkForBitFlip(§ pars k))
                (§ call keys.add(§ pars k))
            )
            (§ return keys)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_private
    (§ method void checkForBitFlip(§ args DeterministicKey k))
    (§ block
        (§ var DeterministicKey parent = Preconditions.checkNotNull(§ pars k.getParent(§ pars )))
        (§ var byte[] rederived = HDKeyDerivation.deriveChildKeyBytesFromPublic(§ pars parent, k.getChildNumber(§ pars ), HDKeyDerivation.PublicDeriveMode.WITH_INVERSION).keyBytes)
        (§ var byte[] actual = k.getPubKey(§ pars ))
        (§ if (§ expr !Arrays.equals(§ pars rederived, actual)))
        (§ block
            (§ throw (§ new IllegalStateException(§ pars String.format(§ pars Locale.US, "Bit-flip check failed: %s vs %s", Arrays.toString(§ pars rederived), Arrays.toString(§ pars actual)))))
        )
    )

    ;;;
     ; Mark the DeterministicKey as used.
     ; Also correct the issued{Internal|External}Keys counter, because all lower children seem to be requested already.
     ; If the counter was updated, we also might trigger lookahead.
     ;;
    #_public
    (§ method DeterministicKey markKeyAsUsed(§ args DeterministicKey k))
    (§ block
        (§ var int numChildren = k.getChildNumber(§ pars ).i(§ pars ) + 1)

        (§ if (§ expr k.getParent(§ pars ) == internalParentKey))
        (§ block
            (§ if (§ expr issuedInternalKeys < numChildren))
            (§ block
                (§ ass issuedInternalKeys = numChildren)
                (§ call maybeLookAhead(§ pars ))
            )
        )
        (§ elseif (§ expr k.getParent(§ pars ) == externalParentKey))
        (§ block
            (§ if (§ expr issuedExternalKeys < numChildren))
            (§ block
                (§ ass issuedExternalKeys = numChildren)
                (§ call maybeLookAhead(§ pars ))
            )
        )
        (§ return k)
    )

    #_public
    (§ method DeterministicKey findKeyFromPubHash(§ args byte[] pubkeyHash))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ cast DeterministicKey)basicKeyChain.findKeyFromPubHash(§ pars pubkeyHash))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_public
    (§ method DeterministicKey findKeyFromPubKey(§ args byte[] pubkey))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ cast DeterministicKey)basicKeyChain.findKeyFromPubKey(§ pars pubkey))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkeyHash.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_nilable
    #_public
    (§ method DeterministicKey markPubHashAsUsed(§ args byte[] pubkeyHash))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var DeterministicKey k = (§ cast DeterministicKey)basicKeyChain.findKeyFromPubHash(§ pars pubkeyHash))
            (§ if (§ expr k != nil))
            (§ block
                (§ call markKeyAsUsed(§ pars k))
            )
            (§ return k)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkey.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_nilable
    #_public
    (§ method DeterministicKey markPubKeyAsUsed(§ args byte[] pubkey))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var DeterministicKey k = (§ cast DeterministicKey)basicKeyChain.findKeyFromPubKey(§ pars pubkey))
            (§ if (§ expr k != nil))
            (§ block
                (§ call markKeyAsUsed(§ pars k))
            )
            (§ return k)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method boolean hasKey(§ args ECKey key))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return basicKeyChain.hasKey(§ pars key))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;; Returns the deterministic key for the given absolute path in the hierarchy. ;;
    #_protected
    (§ method DeterministicKey getKeyByPath(§ args ChildNumber... path))
    (§ block
        (§ return getKeyByPath(§ pars ImmutableList.copyOf(§ pars path)))
    )

    ;;; Returns the deterministic key for the given absolute path in the hierarchy. ;;
    #_protected
    (§ method DeterministicKey getKeyByPath(§ args List<ChildNumber> path))
    (§ block
        (§ return getKeyByPath(§ pars path, false))
    )

    ;;; Returns the deterministic key for the given absolute path in the hierarchy, optionally creating it. ;;
    #_public
    (§ method DeterministicKey getKeyByPath(§ args List<ChildNumber> path, boolean create))
    (§ block
        (§ return hierarchy.get(§ pars path, false, create))
    )

    ;;;
     ; <p>An alias for <code>getKeyByPath(getAccountPath())</code>.</p>
     ;
     ; <p>Use this when you would like to create a watching key chain that follows this one, but can't spend money from it.
     ; The returned key can be serialized and then passed into {@link #watch(org.bitcoinj.crypto.DeterministicKey)}
     ; on another system to watch the hierarchy.</p>
     ;
     ; <p>Note that the returned key is not pubkey only unless this key chain already is: the returned key can still
     ; be used for signing etc if the private key bytes are available.</p>
     ;;
    #_public
    (§ method DeterministicKey getWatchingKey(§ args ))
    (§ block
        (§ return getKeyByPath(§ pars getAccountPath(§ pars )))
    )

    ;;; Returns true if this chain is watch only, meaning it has public keys but no private key. ;;
    #_public
    (§ method boolean isWatching(§ args ))
    (§ block
        (§ return getWatchingKey(§ pars ).isWatching(§ pars ))
    )

    #_override
    #_public
    (§ method int numKeys(§ args ))
    (§ block
        ;; We need to return here the total number of keys including the lookahead zone, not the number
        ;; of keys we have issued via getKey/freshReceiveKey.
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call maybeLookAhead(§ pars ))
            (§ return basicKeyChain.numKeys(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns number of leaf keys used including both internal and external paths.  This may be fewer
     ; than the number that have been deserialized or held in memory, because of the lookahead zone.
     ;;
    #_public
    (§ method int numLeafKeysIssued(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return issuedExternalKeys + issuedInternalKeys)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method long getEarliestKeyCreationTime(§ args ))
    (§ block
        (§ return (§ quest (§ expr seed != nil) ? seed.getCreationTimeSeconds(§ pars ) :else getWatchingKey(§ pars ).getCreationTimeSeconds(§ pars )))
    )

    #_override
    #_public
    (§ method void addEventListener(§ args KeyChainEventListener listener))
    (§ block
        (§ call basicKeyChain.addEventListener(§ pars listener))
    )

    #_override
    #_public
    (§ method void addEventListener(§ args KeyChainEventListener listener, Executor executor))
    (§ block
        (§ call basicKeyChain.addEventListener(§ pars listener, executor))
    )

    #_override
    #_public
    (§ method boolean removeEventListener(§ args KeyChainEventListener listener))
    (§ block
        (§ return basicKeyChain.removeEventListener(§ pars listener))
    )

    ;;; Returns a list of words that represent the seed or null if this chain is a watching chain. ;;
    #_nilable
    #_public
    (§ method List<String> getMnemonicCode(§ args ))
    (§ block
        (§ if (§ expr seed == nil))
        (§ block
            (§ return nil)
        )

        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return seed.getMnemonicCode(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Return true if this keychain is following another keychain.
     ;;
    #_public
    (§ method boolean isFollowing(§ args ))
    (§ block
        (§ return isFollowing)
    )

    #_override
    #_public
    (§ method List<Protos.Key> serializeToProtobuf(§ args ))
    (§ block
        (§ var List<Protos.Key> result = newArrayList(§ pars ))
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call result.addAll(§ pars serializeMyselfToProtobuf(§ pars )))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
        (§ return result)
    )

    #_protected
    (§ method List<Protos.Key> serializeMyselfToProtobuf(§ args ))
    (§ block
        ;; Most of the serialization work is delegated to the basic key chain, which will serialize the bulk of the
        ;; data (handling encryption along the way), and letting us patch it up with the extra data we care about.
        (§ var LinkedList<Protos.Key> entries = newLinkedList(§ pars ))
        (§ if (§ expr seed != nil))
        (§ block
            (§ var Protos.Key.Builder mnemonicEntry = BasicKeyChain.serializeEncryptableItem(§ pars seed))
            (§ call mnemonicEntry.setType(§ pars Protos.Key.Type.DETERMINISTIC_MNEMONIC))
            (§ call serializeSeedEncryptableItem(§ pars seed, mnemonicEntry))
            (§ call entries.add(§ pars mnemonicEntry.build(§ pars )))
        )
        (§ var Map<ECKey, Protos.Key.Builder> keys = basicKeyChain.serializeToEditableProtobufs(§ pars ))
        (§ for (§ var Map.Entry<ECKey, Protos.Key.Builder> entry) :for (§ expr keys.entrySet(§ pars )))
        (§ block
            (§ var DeterministicKey key = (§ cast DeterministicKey)entry.getKey(§ pars ))
            (§ var Protos.Key.Builder proto = entry.getValue(§ pars ))
            (§ call proto.setType(§ pars Protos.Key.Type.DETERMINISTIC_KEY))
            #_final
            (§ var Protos.DeterministicKey.Builder detKey = proto.getDeterministicKeyBuilder(§ pars ))
            (§ call detKey.setChainCode(§ pars ByteString.copyFrom(§ pars key.getChainCode(§ pars ))))
            (§ for (§ var ChildNumber num) :for (§ expr key.getPath(§ pars )))
            (§ block
                (§ call detKey.addPath(§ pars num.i(§ pars )))
            )
            (§ if (§ expr key.equals(§ pars externalParentKey)))
            (§ block
                (§ call detKey.setIssuedSubkeys(§ pars issuedExternalKeys))
                (§ call detKey.setLookaheadSize(§ pars lookaheadSize))
                (§ call detKey.setSigsRequiredToSpend(§ pars getSigsRequiredToSpend(§ pars )))
            )
            (§ elseif (§ expr key.equals(§ pars internalParentKey)))
            (§ block
                (§ call detKey.setIssuedSubkeys(§ pars issuedInternalKeys))
                (§ call detKey.setLookaheadSize(§ pars lookaheadSize))
                (§ call detKey.setSigsRequiredToSpend(§ pars getSigsRequiredToSpend(§ pars )))
            )
            ;; Flag the very first key of following keychain.
            (§ if (§ expr entries.isEmpty(§ pars ) && isFollowing(§ pars )))
            (§ block
                (§ call detKey.setIsFollowing(§ pars true))
            )
            ;; HD keys inherit the timestamp of their parent if they have one, so no need to serialize it.
            (§ if (§ expr key.getParent(§ pars ) != nil))
            (§ block
                (§ call proto.clearCreationTimestamp(§ pars ))
            )
            (§ call entries.add(§ pars proto.build(§ pars )))
        )
        (§ return entries)
    )

    #_static
    (§ method List<DeterministicKeyChain> fromProtobuf(§ args List<Protos.Key> keys, #_nilable KeyCrypter crypter))
        (§ throws UnreadableWalletException)
    (§ block
        (§ return fromProtobuf(§ pars keys, crypter, new DefaultKeyChainFactory(§ pars )))
    )

    ;;;
     ; Returns all the key chains found in the given list of keys.  Typically there will only be one,
     ; but in the case of key rotation it can happen that there are multiple chains found.
     ;;
    #_public
    #_static
    (§ method List<DeterministicKeyChain> fromProtobuf(§ args List<Protos.Key> keys, #_nilable KeyCrypter crypter, KeyChainFactory factory))
        (§ throws UnreadableWalletException)
    (§ block
        (§ var List<DeterministicKeyChain> chains = newLinkedList(§ pars ))
        (§ var DeterministicSeed seed = nil)
        (§ var DeterministicKeyChain chain = nil)

        (§ var int lookaheadSize = -1)
        (§ var int sigsRequiredToSpend = 1)

        (§ var PeekingIterator<Protos.Key> iter = Iterators.peekingIterator(§ pars keys.iterator(§ pars )))
        (§ while (§ expr iter.hasNext(§ pars )))
        (§ block
            (§ var Protos.Key key = iter.next(§ pars ))
            #_final
            (§ var Protos.Key.Type t = key.getType(§ pars ))
            (§ if (§ expr t == Protos.Key.Type.DETERMINISTIC_MNEMONIC))
            (§ block
                (§ if (§ expr chain != nil))
                (§ block
                    (§ call Preconditions.checkState(§ pars 0 <= lookaheadSize))

                    (§ call chain.setLookaheadSize(§ pars lookaheadSize))
                    (§ call chain.setSigsRequiredToSpend(§ pars sigsRequiredToSpend))
                    (§ call chain.maybeLookAhead(§ pars ))
                    (§ call chains.add(§ pars chain))
                    (§ ass chain = nil)
                )
                (§ var long timestamp = key.getCreationTimestamp(§ pars ) / 1000)
                (§ var String passphrase = DEFAULT_PASSPHRASE_FOR_MNEMONIC) ;; FIXME allow non-empty passphrase
                (§ if (§ expr key.hasSecretBytes(§ pars )))
                (§ block
                    (§ if (§ expr key.hasEncryptedDeterministicSeed(§ pars )))
                    (§ block
                        (§ throw (§ new UnreadableWalletException(§ pars "Malformed key proto: " + key)))
                    )

                    (§ var byte[] seedBytes = nil)
                    (§ if (§ expr key.hasDeterministicSeed(§ pars )))
                    (§ block
                        (§ ass seedBytes = key.getDeterministicSeed(§ pars ).toByteArray(§ pars ))
                    )
                    (§ ass seed = new DeterministicSeed(§ pars key.getSecretBytes(§ pars ).toStringUtf8(§ pars ), seedBytes, passphrase, timestamp))
                )
                (§ elseif (§ expr key.hasEncryptedData(§ pars )))
                (§ block
                    (§ if (§ expr key.hasDeterministicSeed(§ pars )))
                    (§ block
                        (§ throw (§ new UnreadableWalletException(§ pars "Malformed key proto: " + key)))
                    )

                    (§ var EncryptedData data = new EncryptedData(§ pars key.getEncryptedData(§ pars ).getInitialisationVector(§ pars ).toByteArray(§ pars ), key.getEncryptedData(§ pars ).getEncryptedPrivateKey(§ pars ).toByteArray(§ pars )))
                    (§ var EncryptedData encryptedSeedBytes = nil)
                    (§ if (§ expr key.hasEncryptedDeterministicSeed(§ pars )))
                    (§ block
                        (§ var Protos.EncryptedData encryptedSeed = key.getEncryptedDeterministicSeed(§ pars ))
                        (§ ass encryptedSeedBytes = new EncryptedData(§ pars encryptedSeed.getInitialisationVector(§ pars ).toByteArray(§ pars ), encryptedSeed.getEncryptedPrivateKey(§ pars ).toByteArray(§ pars )))
                    )
                    (§ ass seed = new DeterministicSeed(§ pars data, encryptedSeedBytes, timestamp))
                )
                (§ else )
                (§ block
                    (§ throw (§ new UnreadableWalletException(§ pars "Malformed key proto: " + key)))
                )

                (§ if (§ expr log.isDebugEnabled(§ pars )))
                (§ block
                    (§ call log.debug(§ pars "Deserializing: DETERMINISTIC_MNEMONIC: {}", seed))
                )
            )
            (§ elseif (§ expr t == Protos.Key.Type.DETERMINISTIC_KEY))
            (§ block
                (§ if (§ expr !key.hasDeterministicKey(§ pars )))
                (§ block
                    (§ throw (§ new UnreadableWalletException(§ pars "Deterministic key missing extra data: " + key)))
                )

                (§ var byte[] chainCode = key.getDeterministicKey(§ pars ).getChainCode(§ pars ).toByteArray(§ pars ))
                ;; Deserialize the path through the tree.
                (§ var LinkedList<ChildNumber> path = newLinkedList(§ pars ))
                (§ for (§ var int i) :for (§ expr key.getDeterministicKey(§ pars ).getPathList(§ pars )))
                (§ block
                    (§ call path.add(§ pars (§ new ChildNumber(§ pars i))))
                )

                ;; Deserialize the public key and path.
                (§ var LazyECPoint pubkey = new LazyECPoint(§ pars ECKey.CURVE.getCurve(§ pars ), key.getPublicKey(§ pars ).toByteArray(§ pars )))
                #_final
                (§ var ImmutableList<ChildNumber> immutablePath = ImmutableList.copyOf(§ pars path))
                ;; Possibly create the chain, if we didn't already do so yet.
                (§ var boolean isWatchingAccountKey = false)
                (§ var boolean isFollowingKey = false)
                ;; Save previous chain if any if the key is marked as following.  Current key and the next ones
                ;; are to be placed in new following key chain.
                (§ if (§ expr key.getDeterministicKey(§ pars ).getIsFollowing(§ pars )))
                (§ block
                    (§ if (§ expr chain != nil))
                    (§ block
                        (§ call Preconditions.checkState(§ pars 0 <= lookaheadSize))

                        (§ call chain.setLookaheadSize(§ pars lookaheadSize))
                        (§ call chain.setSigsRequiredToSpend(§ pars sigsRequiredToSpend))
                        (§ call chain.maybeLookAhead(§ pars ))
                        (§ call chains.add(§ pars chain))
                        (§ ass chain = nil)
                        (§ ass seed = nil)
                    )
                    (§ ass isFollowingKey = true)
                )

                (§ if (§ expr chain == nil))
                (§ block
                    ;; If this is not a following chain and previous was, this must be married.
                    (§ var boolean isMarried = (§ expr !isFollowingKey && !chains.isEmpty(§ pars ) && chains.get(§ pars chains.size(§ pars ) - 1).isFollowing(§ pars )))
                    (§ if (§ expr seed == nil))
                    (§ block
                        (§ var DeterministicKey accountKey = new DeterministicKey(§ pars immutablePath, chainCode, pubkey, nil, nil))
                        (§ call accountKey.setCreationTimeSeconds(§ pars key.getCreationTimestamp(§ pars ) / 1000))
                        (§ ass chain = factory.makeWatchingKeyChain(§ pars key, iter.peek(§ pars ), accountKey, isFollowingKey, isMarried))
                        (§ ass isWatchingAccountKey = true)
                    )
                    (§ else )
                    (§ block
                        (§ ass chain = factory.makeKeyChain(§ pars key, iter.peek(§ pars ), seed, crypter, isMarried))
                        (§ ass chain.lookaheadSize = LAZY_CALCULATE_LOOKAHEAD)
                        ;; If the seed is encrypted, then the chain is incomplete at this point.  However, we will load
                        ;; it up below as we parse in the keys.  We just need to check at the end that we've loaded
                        ;; everything afterwards.
                    )
                )
                ;; Find the parent key assuming this is not the root key, and not an account key for a watching chain.
                (§ var DeterministicKey parent = nil)
                (§ if (§ expr !path.isEmpty(§ pars ) && !isWatchingAccountKey))
                (§ block
                    (§ var ChildNumber index = path.removeLast(§ pars ))
                    (§ ass parent = chain.hierarchy.get(§ pars path, false, false))
                    (§ call path.add(§ pars index))
                )
                (§ var DeterministicKey detkey)
                (§ if (§ expr key.hasSecretBytes(§ pars )))
                (§ block
                    ;; Not encrypted: private key is available.
                    #_final
                    (§ var BigInteger priv = new BigInteger(§ pars 1, key.getSecretBytes(§ pars ).toByteArray(§ pars )))
                    (§ ass detkey = new DeterministicKey(§ pars immutablePath, chainCode, pubkey, priv, parent))
                )
                (§ else )
                (§ block
                    (§ if (§ expr key.hasEncryptedData(§ pars )))
                    (§ block
                        (§ var Protos.EncryptedData proto = key.getEncryptedData(§ pars ))
                        (§ var EncryptedData data = new EncryptedData(§ pars proto.getInitialisationVector(§ pars ).toByteArray(§ pars ), proto.getEncryptedPrivateKey(§ pars ).toByteArray(§ pars )))
                        (§ call Preconditions.checkNotNull(§ pars crypter, "Encountered an encrypted key but no key crypter provided"))
                        (§ ass detkey = new DeterministicKey(§ pars immutablePath, chainCode, crypter, pubkey, data, parent))
                    )
                    (§ else )
                    (§ block
                        ;; No secret key bytes and key is not encrypted: either a watching key or private key bytes
                        ;; will be rederived on the fly from the parent.
                        (§ ass detkey = new DeterministicKey(§ pars immutablePath, chainCode, pubkey, nil, parent))
                    )
                )
                (§ if (§ expr key.hasCreationTimestamp(§ pars )))
                (§ block
                    (§ call detkey.setCreationTimeSeconds(§ pars key.getCreationTimestamp(§ pars ) / 1000))
                )
                (§ if (§ expr log.isDebugEnabled(§ pars )))
                (§ block
                    (§ call log.debug(§ pars "Deserializing: DETERMINISTIC_KEY: {}", detkey))
                )
                (§ if (§ expr !isWatchingAccountKey))
                (§ block
                    ;; If the non-encrypted case, the non-leaf keys (account, internal, external) have already
                    ;; been rederived and inserted at this point.  In the encrypted case though, we can't
                    ;; rederive and we must reinsert, potentially building the heirarchy object if need be.
                    (§ if (§ expr path.size(§ pars ) == 0))
                    (§ block
                        ;; Master key.
                        (§ if (§ expr chain.rootKey == nil))
                        (§ block
                            (§ ass chain.rootKey = detkey)
                            (§ ass chain.hierarchy = new DeterministicHierarchy(§ pars detkey))
                        )
                    )
                    (§ elseif (§ expr path.size(§ pars ) == chain.getAccountPath(§ pars ).size(§ pars ) + 1))
                    (§ block
                        (§ if (§ expr detkey.getChildNumber(§ pars ).num(§ pars ) == 0))
                        (§ block
                            (§ ass chain.externalParentKey = detkey)
                            (§ ass chain.issuedExternalKeys = key.getDeterministicKey(§ pars ).getIssuedSubkeys(§ pars ))
                            (§ ass lookaheadSize = Math.max(§ pars lookaheadSize, key.getDeterministicKey(§ pars ).getLookaheadSize(§ pars )))
                            (§ ass sigsRequiredToSpend = key.getDeterministicKey(§ pars ).getSigsRequiredToSpend(§ pars ))
                        )
                        (§ elseif (§ expr detkey.getChildNumber(§ pars ).num(§ pars ) == 1))
                        (§ block
                            (§ ass chain.internalParentKey = detkey)
                            (§ ass chain.issuedInternalKeys = key.getDeterministicKey(§ pars ).getIssuedSubkeys(§ pars ))
                        )
                    )
                )
                (§ call chain.hierarchy.putKey(§ pars detkey))
                (§ call chain.basicKeyChain.importKey(§ pars detkey))
            )
        )
        (§ if (§ expr chain != nil))
        (§ block
            (§ call Preconditions.checkState(§ pars lookaheadSize >= 0))
            (§ call chain.setLookaheadSize(§ pars lookaheadSize))
            (§ call chain.setSigsRequiredToSpend(§ pars sigsRequiredToSpend))
            (§ call chain.maybeLookAhead(§ pars ))
            (§ call chains.add(§ pars chain))
        )
        (§ return chains)
    )

    #_override
    #_public
    (§ method DeterministicKeyChain toEncrypted(§ args CharSequence password))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars password))
        (§ call Preconditions.checkArgument(§ pars 0 < password.length(§ pars )))
        (§ call Preconditions.checkState(§ pars seed != nil, "Attempt to encrypt a watching chain."))
        (§ call Preconditions.checkState(§ pars !seed.isEncrypted(§ pars )))

        (§ var KeyCrypter scrypt = new KeyCrypterScrypt(§ pars ))
        (§ var KeyParameter derivedKey = scrypt.deriveKey(§ pars password))
        (§ return toEncrypted(§ pars scrypt, derivedKey))
    )

    #_override
    #_public
    (§ method DeterministicKeyChain toEncrypted(§ args KeyCrypter keyCrypter, KeyParameter aesKey))
    (§ block
        (§ return (§ new DeterministicKeyChain(§ pars keyCrypter, aesKey, this)))
    )

    #_override
    #_public
    (§ method DeterministicKeyChain toDecrypted(§ args CharSequence password))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars password))
        (§ call Preconditions.checkArgument(§ pars 0 < password.length(§ pars )))

        (§ var KeyCrypter crypter = getKeyCrypter(§ pars ))
        (§ call Preconditions.checkState(§ pars crypter != nil, "Chain not encrypted"))
        (§ var KeyParameter derivedKey = crypter.deriveKey(§ pars password))
        (§ return toDecrypted(§ pars derivedKey))
    )

    #_override
    #_public
    (§ method DeterministicKeyChain toDecrypted(§ args KeyParameter aesKey))
    (§ block
        (§ call Preconditions.checkState(§ pars getKeyCrypter(§ pars ) != nil, "Key chain not encrypted"))
        (§ call Preconditions.checkState(§ pars seed != nil, "Can't decrypt a watching chain"))
        (§ call Preconditions.checkState(§ pars seed.isEncrypted(§ pars )))

        (§ var String passphrase = DEFAULT_PASSPHRASE_FOR_MNEMONIC) ;; FIXME allow non-empty passphrase
        (§ var DeterministicSeed decSeed = seed.decrypt(§ pars getKeyCrypter(§ pars ), passphrase, aesKey))
        (§ var DeterministicKeyChain chain = makeKeyChainFromSeed(§ pars decSeed))
        ;; Now double check that the keys match to catch the case where the key is wrong but padding didn't catch it.
        (§ if (§ expr !chain.getWatchingKey(§ pars ).getPubKeyPoint(§ pars ).equals(§ pars getWatchingKey(§ pars ).getPubKeyPoint(§ pars ))))
        (§ block
            (§ throw (§ new KeyCrypterException(§ pars "Provided AES key is wrong")))
        )

        (§ ass chain.lookaheadSize = lookaheadSize)
        ;; Now copy the (pubkey only) leaf keys across to avoid rederiving them.  The private key bytes are missing
        ;; anyway so there's nothing to decrypt.
        (§ for (§ var ECKey eckey) :for (§ expr basicKeyChain.getKeys(§ pars )))
        (§ block
            (§ var DeterministicKey key = (§ cast DeterministicKey)eckey)
            (§ if (§ expr key.getPath(§ pars ).size(§ pars ) != getAccountPath(§ pars ).size(§ pars ) + 2))
            (§ block
                (§ continue ) ;; Not a leaf key.
            )

            (§ call Preconditions.checkState(§ pars key.isEncrypted(§ pars )))
            (§ var DeterministicKey parent = chain.hierarchy.get(§ pars Preconditions.checkNotNull(§ pars key.getParent(§ pars )).getPath(§ pars ), false, false))
            ;; Clone the key to the new decrypted hierarchy.
            (§ ass key = new DeterministicKey(§ pars key.dropPrivateBytes(§ pars ), parent))
            (§ call chain.hierarchy.putKey(§ pars key))
            (§ call chain.basicKeyChain.importKey(§ pars key))
        )
        (§ ass chain.issuedExternalKeys = issuedExternalKeys)
        (§ ass chain.issuedInternalKeys = issuedInternalKeys)
        (§ return chain)
    )

    ;;;
     ; Factory method to create a key chain from a seed.
     ; Subclasses should override this to create an instance of the subclass instead of a plain DKC.
     ; This is used in encryption/decryption.
     ;;
    #_protected
    (§ method DeterministicKeyChain makeKeyChainFromSeed(§ args DeterministicSeed seed))
    (§ block
        (§ return (§ new DeterministicKeyChain(§ pars seed)))
    )

    #_override
    #_public
    (§ method boolean checkPassword(§ args CharSequence password))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars password))
        (§ call Preconditions.checkState(§ pars getKeyCrypter(§ pars ) != nil, "Key chain not encrypted"))

        (§ return checkAESKey(§ pars getKeyCrypter(§ pars ).deriveKey(§ pars password)))
    )

    #_override
    #_public
    (§ method boolean checkAESKey(§ args KeyParameter aesKey))
    (§ block
        (§ call Preconditions.checkState(§ pars rootKey != nil, "Can't check password for a watching chain"))
        (§ call Preconditions.checkNotNull(§ pars aesKey))
        (§ call Preconditions.checkState(§ pars getKeyCrypter(§ pars ) != nil, "Key chain not encrypted"))

        (§ try )
        (§ block
            (§ return rootKey.decrypt(§ pars aesKey).getPubKeyPoint(§ pars ).equals(§ pars rootKey.getPubKeyPoint(§ pars )))
        )
        (§ catch (§ args KeyCrypterException _))
        (§ block
            (§ return false)
        )
    )

    #_nilable
    #_override
    #_public
    (§ method KeyCrypter getKeyCrypter(§ args ))
    (§ block
        (§ return basicKeyChain.getKeyCrypter(§ pars ))
    )

    #_override
    #_public
    (§ method int numBloomFilterEntries(§ args ))
    (§ block
        (§ return numKeys(§ pars ) * 2)
    )

    #_override
    #_public
    (§ method BloomFilter getFilter(§ args int size, double falsePositiveRate, long tweak))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call Preconditions.checkArgument(§ pars numBloomFilterEntries(§ pars ) <= size))
            (§ call maybeLookAhead(§ pars ))
            (§ return basicKeyChain.getFilter(§ pars size, falsePositiveRate, tweak))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; <p>The number of public keys we should pre-generate on each path before they are requested by the app.  This is
     ; required so that when scanning through the chain given only a seed, we can give enough keys to the remote node
     ; via the Bloom filter such that we see transactions that are "from the future", for example transactions created
     ; by a different app that's sharing the same seed, or transactions we made before but we're replaying the chain
     ; given just the seed. The default is 100.</p>
     ;;
    #_public
    (§ method int getLookaheadSize(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return lookaheadSize)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Sets a new lookahead size.  See {@link #getLookaheadSize()} for details on what this is.  Setting a new size
     ; that's larger than the current size will return immediately and the new size will only take effect next time
     ; a fresh filter is requested (e.g. due to a new peer being connected).  So you should set this before starting
     ; to sync the chain, if you want to modify it.  If you haven't modified the lookahead threshold manually then
     ; it will be automatically set to be a third of the new size.
     ;;
    #_public
    (§ method void setLookaheadSize(§ args int lookaheadSize))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var boolean readjustThreshold = (§ expr this.lookaheadThreshold == calcDefaultLookaheadThreshold(§ pars )))
            (§ ass this.lookaheadSize = lookaheadSize)
            (§ if (§ expr readjustThreshold))
            (§ block
                (§ ass this.lookaheadThreshold = calcDefaultLookaheadThreshold(§ pars ))
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Sets the threshold for the key pre-generation.  This is used to avoid adding new keys and thus re-calculating
     ; Bloom filters every time a new key is calculated.  Without a lookahead threshold, every time we received
     ; a relevant transaction, we'd extend the lookahead zone and generate a new filter, which is inefficient.
     ;;
    #_public
    (§ method void setLookaheadThreshold(§ args int num))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr lookaheadSize <= num))
            (§ block
                (§ throw (§ new IllegalArgumentException(§ pars "Threshold larger or equal to the lookaheadSize")))
            )

            (§ ass this.lookaheadThreshold = num)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Gets the threshold for the key pre-generation.  See {@link #setLookaheadThreshold(int)} for details on what
     ; this is.  The default is a third of the lookahead size (100 / 3 == 33).  If you don't modify it explicitly,
     ; then this value will always be one third of the lookahead size.
     ;;
    #_public
    (§ method int getLookaheadThreshold(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr lookaheadThreshold < lookaheadSize) ? lookaheadThreshold :else 0)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Pre-generate enough keys to reach the lookahead size.  You can call this if you need to explicitly invoke
     ; the lookahead procedure, but it's normally unnecessary as it will be done automatically when needed.
     ;;
    #_public
    (§ method void maybeLookAhead(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var List<DeterministicKey> keys = maybeLookAhead(§ pars externalParentKey, issuedExternalKeys))
            (§ call keys.addAll(§ pars maybeLookAhead(§ pars internalParentKey, issuedInternalKeys)))
            (§ if (§ expr keys.isEmpty(§ pars )))
            (§ block
                (§ return )
            )

            (§ ass keyLookaheadEpoch = keyLookaheadEpoch + 1)
            ;; Batch add all keys at once so there's only one event listener invocation, as this will be listened to
            ;; by the wallet and used to rebuild/broadcast the Bloom filter.  That's expensive so we don't want to do
            ;; it more often than necessary.
            (§ call basicKeyChain.importKeys(§ pars keys))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_private
    (§ method List<DeterministicKey> maybeLookAhead(§ args DeterministicKey parent, int issued))
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ return maybeLookAhead(§ pars parent, issued, getLookaheadSize(§ pars ), getLookaheadThreshold(§ pars )))
    )

    ;;;
     ; Pre-generate enough keys to reach the lookahead size, but only if there are more than the lookaheadThreshold
     ; to be generated, so that the Bloom filter does not have to be regenerated that often.
     ;
     ; The returned mutable list of keys must be inserted into the basic key chain.
     ;;
    #_private
    (§ method List<DeterministicKey> maybeLookAhead(§ args DeterministicKey parent, int issued, int lookaheadSize, int lookaheadThreshold))
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        #_final
        (§ var int numChildren = hierarchy.getNumChildren(§ pars parent.getPath(§ pars )))
        #_final
        (§ var int needed = issued + lookaheadSize + lookaheadThreshold - numChildren)

        (§ if (§ expr needed <= lookaheadThreshold))
        (§ block
            (§ return new ArrayList<>(§ pars ))
        )

        (§ call log.info(§ pars "{} keys needed for {} = {} issued + {} lookahead size + {} lookahead threshold - {} num children", needed, parent.getPathAsString(§ pars ), issued, lookaheadSize, lookaheadThreshold, numChildren))

        (§ var List<DeterministicKey> result  = new ArrayList<>(§ pars needed))
        #_final
        (§ var Stopwatch watch = Stopwatch.createStarted(§ pars ))
        (§ var int nextChild = numChildren)
        (§ for (§ var int i = 0) :for (§ expr i < needed) :for (§ ass i = i + 1))
        (§ block
            (§ var DeterministicKey key = HDKeyDerivation.deriveThisOrNextChildKey(§ pars parent, nextChild))
            (§ ass key = key.dropPrivateBytes(§ pars ))
            (§ call hierarchy.putKey(§ pars key))
            (§ call result.add(§ pars key))
            (§ ass nextChild = key.getChildNumber(§ pars ).num(§ pars ) + 1)
        )
        (§ call watch.stop(§ pars ))
        (§ call log.info(§ pars "Took {}", watch))
        (§ return result)
    )

    ;;; Housekeeping call to call when lookahead might be needed.  Normally called automatically by KeychainGroup. ;;
    #_public
    (§ method void maybeLookAheadScripts(§ args ))
    (§ block
    )

    ;;;
     ; Returns number of keys used on external path.  This may be fewer than the number that have been deserialized
     ; or held in memory, because of the lookahead zone.
     ;;
    #_public
    (§ method int getIssuedExternalKeys(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return issuedExternalKeys)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns number of keys used on internal path.  This may be fewer than the number that have been deserialized
     ; or held in memory, because of the lookahead zone.
     ;;
    #_public
    (§ method int getIssuedInternalKeys(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return issuedInternalKeys)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;; Returns the seed or null if this chain is a watching chain. ;;
    #_nilable
    #_public
    (§ method DeterministicSeed getSeed(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return seed)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;; For internal usage only.
    (§ method List<ECKey> getKeys(§ args boolean includeLookahead, boolean includeParents))
    (§ block
        (§ var List<ECKey> keys = basicKeyChain.getKeys(§ pars ))
        (§ if (§ expr !includeLookahead))
        (§ block
            (§ var int treeSize = internalParentKey.getPath(§ pars ).size(§ pars ))
            (§ var List<ECKey> issuedKeys = new LinkedList<>(§ pars ))
            (§ for (§ var ECKey key) :for (§ expr keys))
            (§ block
                (§ var DeterministicKey detkey = (§ cast DeterministicKey)key)
                (§ var DeterministicKey parent = detkey.getParent(§ pars ))
                (§ if (§ expr !includeParents && parent == nil))
                (§ block
                    (§ continue )
                )
                (§ if (§ expr !includeParents && detkey.getPath(§ pars ).size(§ pars ) <= treeSize))
                (§ block
                    (§ continue )
                )
                (§ if (§ expr internalParentKey.equals(§ pars parent) && issuedInternalKeys <= detkey.getChildNumber(§ pars ).i(§ pars )))
                (§ block
                    (§ continue )
                )
                (§ if (§ expr externalParentKey.equals(§ pars parent) && issuedExternalKeys <= detkey.getChildNumber(§ pars ).i(§ pars )))
                (§ block
                    (§ continue )
                )
                (§ call issuedKeys.add(§ pars detkey))
            )
            (§ return issuedKeys)
        )
        (§ return keys)
    )

    ;;;
     ; Returns only the external keys that have been issued by this chain, lookahead not included.
     ;;
    #_public
    (§ method List<ECKey> getIssuedReceiveKeys(§ args ))
    (§ block
        #_final
        (§ var List<ECKey> keys = new ArrayList<>(§ pars getKeys(§ pars false, false)))
        (§ for (§ var Iterator<ECKey> i = keys.iterator(§ pars )) :for (§ expr i.hasNext(§ pars )) :for (§ expr ))
        (§ block
            (§ var DeterministicKey parent = (§ expr (§ expr (§ cast DeterministicKey)i.next(§ pars )).getParent(§ pars )))
            (§ if (§ expr parent == nil || !externalParentKey.equals(§ pars parent)))
            (§ block
                (§ call i.remove(§ pars ))
            )
        )
        (§ return keys)
    )

    ;;;
     ; Returns leaf keys issued by this chain (including lookahead zone).
     ;;
    #_public
    (§ method List<DeterministicKey> getLeafKeys(§ args ))
    (§ block
        (§ var ImmutableList.Builder<DeterministicKey> keys = ImmutableList.builder(§ pars ))
        (§ for (§ var ECKey key) :for (§ expr getKeys(§ pars true, false)))
        (§ block
            (§ var DeterministicKey dKey = (§ cast DeterministicKey)key)
            (§ if (§ expr dKey.getPath(§ pars ).size(§ pars ) == getAccountPath(§ pars ).size(§ pars ) + 2))
            (§ block
                (§ call keys.add(§ pars dKey))
            )
        )
        (§ return keys.build(§ pars ))
    )

    #_static
    (§ method void serializeSeedEncryptableItem(§ args DeterministicSeed seed, Protos.Key.Builder proto))
    (§ block
        ;; The seed can be missing if we have not derived it yet from the mnemonic.
        ;; This will not normally happen once all the wallets are on the latest code that caches the seed.
        (§ if (§ expr seed.isEncrypted(§ pars ) && seed.getEncryptedSeedData(§ pars ) != nil))
        (§ block
            (§ var EncryptedData data = seed.getEncryptedSeedData(§ pars ))
            (§ call proto.getEncryptedDeterministicSeedBuilder(§ pars ).setEncryptedPrivateKey(§ pars ByteString.copyFrom(§ pars data.encryptedBytes)).setInitialisationVector(§ pars ByteString.copyFrom(§ pars data.initialisationVector)))
            ;; We don't allow mixing of encryption types at the moment.
            (§ call Preconditions.checkState(§ pars seed.getEncryptionType(§ pars ) == Protos.Wallet.EncryptionType.ENCRYPTED_SCRYPT_AES))
        )
        (§ else )
        (§ block
            #_final
            (§ var byte[] secret = seed.getSeedBytes(§ pars ))
            (§ if (§ expr secret != nil))
            (§ block
                (§ call proto.setDeterministicSeed(§ pars ByteString.copyFrom(§ pars secret)))
            )
        )
    )

    ;;;
     ; Returns a counter that is incremented each time new keys are generated due to lookahead.
     ; Used by the network code to learn whether to discard the current block and await calculation
     ; of a new filter.
     ;;
    #_public
    (§ method int getKeyLookaheadEpoch(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return keyLookaheadEpoch)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Whether the keychain is married.  A keychain is married when it vends P2SH addresses from
     ; multiple keychains in a multisig relationship.
     ; @see org.bitcoinj.wallet.MarriedKeyChain
     ;;
    #_public
    (§ method boolean isMarried(§ args ))
    (§ block
        (§ return false)
    )

    ;;; Get redeem data for a key.  Only applicable to married keychains. ;;
    #_public
    (§ method RedeemData getRedeemData(§ args DeterministicKey followedKey))
    (§ block
        (§ throw (§ new UnsupportedOperationException(§ pars )))
    )

    ;;; Create a new key and return the matching output script.  Only applicable to married keychains. ;;
    #_public
    (§ method Script freshOutputScript(§ args KeyPurpose purpose))
    (§ block
        (§ throw (§ new UnsupportedOperationException(§ pars )))
    )

    #_public
    (§ method String toString(§ args boolean includePrivateKeys, NetworkParameters params))
    (§ block
        #_final
        (§ var DeterministicKey watchingKey = getWatchingKey(§ pars ))
        #_final
        (§ var StringBuilder sb = new StringBuilder(§ pars ))
        (§ if (§ expr seed != nil))
        (§ block
            (§ if (§ expr seed.isEncrypted(§ pars )))
            (§ block
                (§ call sb.append(§ pars "Seed is encrypted\n"))
            )
            (§ elseif (§ expr includePrivateKeys))
            (§ block
                #_final
                (§ var List<String> words = seed.getMnemonicCode(§ pars ))
                (§ call sb.append(§ pars "Seed as words: ").append(§ pars Utils.SPACE_JOINER.join(§ pars words)).append(§ pars "\n"))
                (§ call sb.append(§ pars "Seed as hex:   ").append(§ pars seed.toHexString(§ pars )).append(§ pars "\n"))
            )
            (§ call sb.append(§ pars "Seed birthday: ").append(§ pars seed.getCreationTimeSeconds(§ pars )).append(§ pars "  [").append(§ pars Utils.dateTimeFormat(§ pars seed.getCreationTimeSeconds(§ pars ) * 1000)).append(§ pars "]\n"))
        )
        (§ else )
        (§ block
            (§ call sb.append(§ pars "Key birthday:  ").append(§ pars watchingKey.getCreationTimeSeconds(§ pars )).append(§ pars "  [").append(§ pars Utils.dateTimeFormat(§ pars watchingKey.getCreationTimeSeconds(§ pars ) * 1000)).append(§ pars "]\n"))
        )
        (§ call sb.append(§ pars "Key to watch:  ").append(§ pars watchingKey.serializePubB58(§ pars params)).append(§ pars "\n"))
        (§ call formatAddresses(§ pars includePrivateKeys, params, sb))
        (§ return sb.toString(§ pars ))
    )

    #_protected
    (§ method void formatAddresses(§ args boolean includePrivateKeys, NetworkParameters params, StringBuilder builder))
    (§ block
        (§ for (§ var ECKey key) :for (§ expr getKeys(§ pars false, true)))
        (§ block
            (§ call key.formatKeyWithAddress(§ pars includePrivateKeys, builder, params))
        )
    )

    ;;; The number of signatures required to spend coins received by this keychain. ;;
    #_public
    (§ method void setSigsRequiredToSpend(§ args int sigsRequiredToSpend))
    (§ block
        (§ ass this.sigsRequiredToSpend = sigsRequiredToSpend)
    )

    ;;;
     ; Returns the number of signatures required to spend transactions for this KeyChain.
     ; It's the N from N-of-M CHECKMULTISIG script for P2SH transactions and always 1 for other transaction types.
     ;;
    #_public
    (§ method int getSigsRequiredToSpend(§ args ))
    (§ block
        (§ return sigsRequiredToSpend)
    )

    ;;; Returns the redeem script by its hash or null if this keychain did not generate the script. ;;
    #_nilable
    #_public
    (§ method RedeemData findRedeemDataByScriptHash(§ args ByteString bytes))
    (§ block
        (§ return nil)
    )
)

#_(ns org.bitcoinj.wallet #_"DeterministicSeed"
    (:import [java.security SecureRandom]
             [java.util List])
    (:import [com.google.common.base Charsets Objects Preconditions Splitter]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core Utils]
             #_static [org.bitcoinj.core.Utils HEX]
             [org.bitcoinj.crypto *]))

;;;
 ; Holds the seed bytes for the BIP32 deterministic wallet algorithm, inside a {@link DeterministicKeyChain}.
 ; The purpose of this wrapper is to simplify the encryption code.
 ;;
#_public
(§ class DeterministicSeed implements EncryptableItem
    ;; It would take more than 10^12 years to brute-force a 128 bit seed using $1B worth of computing equipment.
    #_public
    #_static
    #_final
    (§ field int DEFAULT_SEED_ENTROPY_BITS = 128)
    #_public
    #_static
    #_final
    (§ field int MAX_SEED_ENTROPY_BITS = 512)

    #_nilable
    #_private
    #_final
    (§ field byte[] seed)
    #_nilable
    #_private
    #_final
    (§ field List<String> mnemonicCode) ;; only one of mnemonicCode/encryptedMnemonicCode will be set
    #_nilable
    #_private
    #_final
    (§ field EncryptedData encryptedMnemonicCode)
    #_nilable
    #_private
    (§ field EncryptedData encryptedSeed)
    #_private
    (§ field long creationTimeSeconds)

    #_public
    (§ constructor DeterministicSeed(§ args String mnemonicCode, byte[] seed, String passphrase, long creationTimeSeconds))
        (§ throws UnreadableWalletException)
    (§ block
        (§ this (§ pars decodeMnemonicCode(§ pars mnemonicCode), seed, passphrase, creationTimeSeconds))
    )

    #_public
    (§ constructor DeterministicSeed(§ args byte[] seed, List<String> mnemonic, long creationTimeSeconds))
    (§ block
        (§ ass this.seed = Preconditions.checkNotNull(§ pars seed))
        (§ ass this.mnemonicCode = Preconditions.checkNotNull(§ pars mnemonic))
        (§ ass this.encryptedMnemonicCode = nil)
        (§ ass this.creationTimeSeconds = creationTimeSeconds)
    )

    #_public
    (§ constructor DeterministicSeed(§ args EncryptedData encryptedMnemonic, #_nilable EncryptedData encryptedSeed, long creationTimeSeconds))
    (§ block
        (§ ass this.seed = nil)
        (§ ass this.mnemonicCode = nil)
        (§ ass this.encryptedMnemonicCode = Preconditions.checkNotNull(§ pars encryptedMnemonic))
        (§ ass this.encryptedSeed = encryptedSeed)
        (§ ass this.creationTimeSeconds = creationTimeSeconds)
    )

    ;;;
     ; Constructs a seed from a BIP 39 mnemonic code.
     ; See {@link org.bitcoinj.crypto.MnemonicCode} for more details on this scheme.
     ; @param mnemonicCode A list of words.
     ; @param seed The derived seed, or pass null to derive it from mnemonicCode (slow).
     ; @param passphrase A user supplied passphrase, or an empty string if there is no passphrase.
     ; @param creationTimeSeconds When the seed was originally created, UNIX time.
     ;;
    #_public
    (§ constructor DeterministicSeed(§ args List<String> mnemonicCode, #_nilable byte[] seed, String passphrase, long creationTimeSeconds))
    (§ block
        (§ this (§ pars (§ expr seed != nil) ? seed :else MnemonicCode.toSeed(§ pars mnemonicCode, Preconditions.checkNotNull(§ pars passphrase)), mnemonicCode, creationTimeSeconds))
    )

    ;;;
     ; Constructs a seed from a BIP 39 mnemonic code.
     ; See {@link org.bitcoinj.crypto.MnemonicCode} for more details on this scheme.
     ; @param random Entropy source.
     ; @param bits Number of bits, must be divisible by 32.
     ; @param passphrase A user supplied passphrase, or an empty string if there is no passphrase.
     ; @param creationTimeSeconds When the seed was originally created, UNIX time.
     ;;
    #_public
    (§ constructor DeterministicSeed(§ args SecureRandom random, int bits, String passphrase, long creationTimeSeconds))
    (§ block
        (§ this (§ pars getEntropy(§ pars random, bits), Preconditions.checkNotNull(§ pars passphrase), creationTimeSeconds))
    )

    ;;;
     ; Constructs a seed from a BIP 39 mnemonic code.
     ; See {@link org.bitcoinj.crypto.MnemonicCode} for more details on this scheme.
     ; @param entropy Entropy bits, length must be divisible by 32.
     ; @param passphrase A user supplied passphrase, or an empty string if there is no passphrase.
     ; @param creationTimeSeconds When the seed was originally created, UNIX time.
     ;;
    #_public
    (§ constructor DeterministicSeed(§ args byte[] entropy, String passphrase, long creationTimeSeconds))
    (§ block
        (§ call Preconditions.checkArgument(§ pars entropy.length % 4 == 0, "entropy size in bits not divisible by 32"))
        (§ call Preconditions.checkArgument(§ pars DEFAULT_SEED_ENTROPY_BITS <= entropy.length * 8, "entropy size too small"))
        (§ call Preconditions.checkNotNull(§ pars passphrase))

        (§ try )
        (§ block
            (§ ass this.mnemonicCode = MnemonicCode.INSTANCE.toMnemonic(§ pars entropy))
        )
        (§ catch (§ args MnemonicException.MnemonicLengthException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
        (§ ass this.seed = MnemonicCode.toSeed(§ pars mnemonicCode, passphrase))
        (§ ass this.encryptedMnemonicCode = nil)
        (§ ass this.creationTimeSeconds = creationTimeSeconds)
    )

    #_private
    #_static
    (§ method byte[] getEntropy(§ args SecureRandom random, int bits))
    (§ block
        (§ call Preconditions.checkArgument(§ pars bits <= MAX_SEED_ENTROPY_BITS, "requested entropy size too large"))

        (§ var byte[] seed = new byte[bits / 8])
        (§ call random.nextBytes(§ pars seed))
        (§ return seed)
    )

    #_override
    #_public
    (§ method boolean isEncrypted(§ args ))
    (§ block
        (§ call Preconditions.checkState(§ pars mnemonicCode != nil || encryptedMnemonicCode != nil))
        (§ return (§ expr encryptedMnemonicCode != nil))
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return isEncrypted(§ pars ) ? "DeterministicSeed [encrypted]" :else "DeterministicSeed " + toHexString(§ pars ) + " " + Utils.SPACE_JOINER.join(§ pars mnemonicCode))
    )

    ;;; Returns the seed as hex or null if encrypted. ;;
    #_nilable
    #_public
    (§ method String toHexString(§ args ))
    (§ block
        (§ return (§ expr seed != nil) ? HEX.encode(§ pars seed) :else nil)
    )

    #_nilable
    #_override
    #_public
    (§ method byte[] getSecretBytes(§ args ))
    (§ block
        (§ return getMnemonicAsBytes(§ pars ))
    )

    #_nilable
    #_public
    (§ method byte[] getSeedBytes(§ args ))
    (§ block
        (§ return seed)
    )

    #_nilable
    #_override
    #_public
    (§ method EncryptedData getEncryptedData(§ args ))
    (§ block
        (§ return encryptedMnemonicCode)
    )

    #_override
    #_public
    (§ method Protos.Wallet.EncryptionType getEncryptionType(§ args ))
    (§ block
        (§ return Protos.Wallet.EncryptionType.ENCRYPTED_SCRYPT_AES)
    )

    #_nilable
    #_public
    (§ method EncryptedData getEncryptedSeedData(§ args ))
    (§ block
        (§ return encryptedSeed)
    )

    #_override
    #_public
    (§ method long getCreationTimeSeconds(§ args ))
    (§ block
        (§ return creationTimeSeconds)
    )

    #_public
    (§ method void setCreationTimeSeconds(§ args long creationTimeSeconds))
    (§ block
        (§ ass this.creationTimeSeconds = creationTimeSeconds)
    )

    #_public
    (§ method DeterministicSeed encrypt(§ args KeyCrypter keyCrypter, KeyParameter aesKey))
    (§ block
        (§ call Preconditions.checkState(§ pars encryptedMnemonicCode == nil, "Trying to encrypt seed twice"))
        (§ call Preconditions.checkState(§ pars mnemonicCode != nil, "Mnemonic missing so cannot encrypt"))

        (§ var EncryptedData encryptedMnemonic = keyCrypter.encrypt(§ pars getMnemonicAsBytes(§ pars ), aesKey))
        (§ var EncryptedData encryptedSeed = keyCrypter.encrypt(§ pars seed, aesKey))
        (§ return (§ new DeterministicSeed(§ pars encryptedMnemonic, encryptedSeed, creationTimeSeconds)))
    )

    #_private
    (§ method byte[] getMnemonicAsBytes(§ args ))
    (§ block
        (§ return Utils.SPACE_JOINER.join(§ pars mnemonicCode).getBytes(§ pars Charsets.UTF_8))
    )

    #_public
    (§ method DeterministicSeed decrypt(§ args KeyCrypter crypter, String passphrase, KeyParameter aesKey))
    (§ block
        (§ call Preconditions.checkState(§ pars isEncrypted(§ pars )))
        (§ call Preconditions.checkNotNull(§ pars encryptedMnemonicCode))

        (§ var List<String> mnemonic = decodeMnemonicCode(§ pars crypter.decrypt(§ pars encryptedMnemonicCode, aesKey)))
        (§ var byte[] seed = (§ expr encryptedSeed != nil) ? crypter.decrypt(§ pars encryptedSeed, aesKey) :else nil)
        (§ return (§ new DeterministicSeed(§ pars mnemonic, seed, passphrase, creationTimeSeconds)))
    )

    #_override
    #_public
    (§ method boolean equals(§ args Object o))
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var DeterministicSeed other = (§ cast DeterministicSeed)o)
        (§ return (§ expr creationTimeSeconds == other.creationTimeSeconds && Objects.equal(§ pars encryptedMnemonicCode, other.encryptedMnemonicCode) && Objects.equal(§ pars mnemonicCode, other.mnemonicCode)))
    )

    #_override
    #_public
    (§ method int hashCode(§ args ))
    (§ block
        (§ return Objects.hashCode(§ pars creationTimeSeconds, encryptedMnemonicCode, mnemonicCode))
    )

    ;;;
     ; Check if our mnemonic is a valid mnemonic phrase for our word list.
     ; Does nothing if we are encrypted.
     ;
     ; @throws org.bitcoinj.crypto.MnemonicException if check fails.
     ;;
    #_public
    (§ method void check(§ args ))
        (§ throws MnemonicException)
    (§ block
        (§ if (§ expr mnemonicCode != nil))
        (§ block
            (§ call MnemonicCode.INSTANCE.check(§ pars mnemonicCode))
        )
    )

    (§ method byte[] getEntropyBytes(§ args ))
        (§ throws MnemonicException)
    (§ block
        (§ return MnemonicCode.INSTANCE.toEntropy(§ pars mnemonicCode))
    )

    ;;; Get the mnemonic code, or null if unknown. ;;
    #_nilable
    #_public
    (§ method List<String> getMnemonicCode(§ args ))
    (§ block
        (§ return mnemonicCode)
    )

    #_private
    #_static
    (§ method List<String> decodeMnemonicCode(§ args byte[] mnemonicCode))
    (§ block
        (§ return decodeMnemonicCode(§ pars Utils.toString(§ pars mnemonicCode, "UTF-8")))
    )

    #_private
    #_static
    (§ method List<String> decodeMnemonicCode(§ args String mnemonicCode))
    (§ block
        (§ return Splitter.on(§ pars " ").splitToList(§ pars mnemonicCode))
    )
)

#_(ns org.bitcoinj.wallet #_"DeterministicUpgradeRequiredException")

;;;
 ; Indicates that an attempt was made to use HD wallet features on a wallet that was deserialized from an old,
 ; pre-HD random wallet without calling upgradeToDeterministic() beforehand.
 ;;
#_public
(§ class DeterministicUpgradeRequiredException extends RuntimeException)

#_(ns org.bitcoinj.wallet #_"DeterministicUpgradeRequiresPassword")

;;;
 ; Indicates that the pre-HD random wallet is encrypted, so you should try the upgrade again after getting the
 ; users password.  This is required because HD wallets are upgraded from random using the private key bytes of
 ; the oldest non-rotating key, in order to make the upgrade process itself deterministic.
 ;;
#_public
(§ class DeterministicUpgradeRequiresPassword extends RuntimeException)

#_(ns org.bitcoinj.wallet #_"EncryptableKeyChain"
    (:import [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.crypto KeyCrypter KeyCrypterException]))

;;;
 ; An encryptable key chain is a key-chain that can be encrypted with a user-provided password or AES key.
 ;;
#_public
(§ interface EncryptableKeyChain extends KeyChain
    ;;;
     ; Takes the given password, which should be strong, derives a key from it and then invokes
     ; {@link #toEncrypted(org.bitcoinj.crypto.KeyCrypter, org.spongycastle.crypto.params.KeyParameter)}
     ; with {@link org.bitcoinj.crypto.KeyCrypterScrypt} as the crypter.
     ;
     ; @return the derived key, in case you wish to cache it for future use.
     ;;
    (§ method EncryptableKeyChain toEncrypted(§ args CharSequence password))

    ;;;
     ; Returns a new keychain holding identical/cloned keys to this chain, but encrypted under the given key.
     ; Old keys and keychains remain valid and so you should ensure you don't accidentally hold references to them.
     ;;
    (§ method EncryptableKeyChain toEncrypted(§ args KeyCrypter keyCrypter, KeyParameter aesKey))

    ;;;
     ; Decrypts the key chain with the given password.
     ; See {@link #toDecrypted(org.spongycastle.crypto.params.KeyParameter)} for details.
     ;;
    (§ method EncryptableKeyChain toDecrypted(§ args CharSequence password))

    ;;;
     ; Decrypt the key chain with the given AES key and whatever {@link KeyCrypter} is already set.  Note that
     ; if you just want to spend money from an encrypted wallet, don't decrypt the whole thing first.  Instead,
     ; set the {@link org.bitcoinj.wallet.SendRequest#aesKey} field before asking the wallet to build the send.
     ;
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time
     ;               consuming to create from a password).
     ; @throws KeyCrypterException if the wallet decryption fails.  If so, the wallet state is unchanged.
     ;;
    (§ method EncryptableKeyChain toDecrypted(§ args KeyParameter aesKey))

    (§ method boolean checkPassword(§ args CharSequence password))
    (§ method boolean checkAESKey(§ args KeyParameter aesKey))

    ;;; Returns the key crypter used by this key chain, or null if it's not encrypted. ;;
    #_nilable
    (§ method KeyCrypter getKeyCrypter(§ args ))
)

#_(ns org.bitcoinj.wallet #_"FilteringCoinSelector"
    (:import [java.util HashSet Iterator List])
   (:require [org.bitcoinj.core *]))

;;;
 ; A filtering coin selector delegates to another coin selector, but won't select outputs spent by the given transactions.
 ;;
#_public
(§ class FilteringCoinSelector implements CoinSelector
    #_protected
    (§ field CoinSelector delegate)
    #_protected
    (§ field HashSet<TransactionOutPoint> spent = new HashSet<>(§ pars ))

    #_public
    (§ constructor FilteringCoinSelector(§ args CoinSelector delegate))
    (§ block
        (§ ass this.delegate = delegate)
    )

    #_public
    (§ method void excludeOutputsSpentBy(§ args Transaction tx))
    (§ block
        (§ for (§ var TransactionInput input) :for (§ expr tx.getInputs(§ pars )))
        (§ block
            (§ call spent.add(§ pars input.getOutpoint(§ pars )))
        )
    )

    #_override
    #_public
    (§ method CoinSelection select(§ args Coin target, List<TransactionOutput> candidates))
    (§ block
        (§ var Iterator<TransactionOutput> iter = candidates.iterator(§ pars ))
        (§ while (§ expr iter.hasNext(§ pars )))
        (§ block
            (§ var TransactionOutput output = iter.next(§ pars ))
            (§ if (§ expr spent.contains(§ pars output.getOutPointFor(§ pars ))))
            (§ block
                (§ call iter.remove(§ pars ))
            )
        )
        (§ return delegate.select(§ pars target, candidates))
    )
)

#_(ns org.bitcoinj.wallet #_"KeyBag"
   (:require [org.bitcoinj.core ECKey]))

;;;
 ; A KeyBag is simply an object that can map public keys, their 160-bit hashes and script hashes to ECKey
 ; and {@link RedeemData} objects.
 ;;
#_public
(§ interface KeyBag
    ;;;
     ; Locates a keypair from the keychain given the hash of the public key.  This is needed when finding out
     ; which key we need to use to redeem a transaction output.
     ;
     ; @return ECKey object or null if no such key was found.
     ;;
    #_nilable
    (§ method ECKey findKeyFromPubHash(§ args byte[] pubkeyHash))

    ;;;
     ; Locates a keypair from the keychain given the raw public key bytes.
     ;
     ; @return ECKey or null if no such key was found.
     ;;
    #_nilable
    (§ method ECKey findKeyFromPubKey(§ args byte[] pubkey))

    ;;;
     ; Locates a redeem data (redeem script and keys) from the keychain given the hash of the script.
     ; This is needed when finding out which key and script we need to use to locally sign a P2SH transaction input.
     ; It is assumed that wallet should not have more than one private key for a single P2SH tx for security reasons.
     ;
     ; @return RedeemData object or null if no such data was found.
     ;;
    #_nilable
    (§ method RedeemData findRedeemDataFromScriptHash(§ args byte[] scriptHash))
)

#_(ns org.bitcoinj.wallet #_"KeyChain"
    (:import [java.util List]
             [java.util.concurrent Executor])
   (:require [org.bitcoinj.core BloomFilter ECKey]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

;;;
 ; <p>A KeyChain is a class that stores a collection of keys for a {@link org.bitcoinj.wallet.Wallet}.  Key chains
 ; are expected to be able to look up keys given a hash (i.e. address) or pubkey bytes, and provide keys on request
 ; for a given purpose.  They can inform event listeners about new keys being added.</p>
 ;
 ; <p>However it is important to understand what this interface does <i>not</i> provide.  It cannot encrypt or decrypt
 ; keys, for instance you need an implementor of {@link EncryptableKeyChain}.  It cannot have keys imported into it,
 ; that you to use a method of a specific key chain instance, such as {@link BasicKeyChain}.  The reason for these
 ; restrictions is to support key chains that may be handled by external hardware or software, or which are derived
 ; deterministically from a seed (and thus the notion of importing a key is meaningless).</p>
 ;;
#_public
(§ interface KeyChain
    ;;; Returns true if the given key is in the chain. ;;
    (§ method boolean hasKey(§ args ECKey key))

    (§ enum KeyPurpose
        (§ item RECEIVE_FUNDS)
        (§ item CHANGE)
        (§ item REFUND)
        (§ item AUTHENTICATION)
    )

    ;;;
     ; Obtains a number of key/s intended for the given purpose.
     ; The chain may create new key/s, derive, or re-use an old one.
     ;;
    (§ method List<? extends ECKey> getKeys(§ args KeyPurpose purpose, int numberOfKeys))

    ;;;
     ; Obtains a key intended for the given purpose.
     ; The chain may create a new key, derive one, or re-use an old one.
     ;;
    (§ method ECKey getKey(§ args KeyPurpose purpose))

    ;;; Returns a list of keys serialized to the bitcoinj protobuf format. ;;
    (§ method List<Protos.Key> serializeToProtobuf(§ args ))

    ;;; Adds a listener for events that are run when keys are added, on the user thread. ;;
    (§ method void addEventListener(§ args KeyChainEventListener listener))

    ;;; Adds a listener for events that are run when keys are added, on the given executor. ;;
    (§ method void addEventListener(§ args KeyChainEventListener listener, Executor executor))

    ;;; Removes a listener for events that are run when keys are added. ;;
    (§ method boolean removeEventListener(§ args KeyChainEventListener listener))

    ;;; Returns the number of keys this key chain manages. ;;
    (§ method int numKeys(§ args ))

    ;;;
     ; Returns the number of elements this chain wishes to insert into the Bloom filter.
     ; The size passed to {@link #getFilter(int, double, long)} should be at least this large.
     ;;
    (§ method int numBloomFilterEntries(§ args ))

    ;;;
     ; Returns the earliest creation time of keys in this chain, in seconds since the epoch.  This can return
     ; zero if at least one key does not have that data (was created before key timestamping was implemented).
     ; If there are no keys in the wallet, {@link Long#MAX_VALUE} is returned.
     ;;
    (§ method long getEarliestKeyCreationTime(§ args ))

    ;;;
     ; <p>Gets a bloom filter that contains all of the public keys from this chain, and which will provide the given
     ; false-positive rate if it has size elements.  Keep in mind that you will get 2 elements in the bloom filter for
     ; each key in the key chain, for the public key and the hash of the public key (address form).  For this reason
     ; size should be <i>at least</i> 2x the result of {@link #numKeys()}.</p>
     ;
     ; <p>This is used to generate a {@link BloomFilter} which can be {@link BloomFilter#merge(BloomFilter)}d with
     ; another.  It could also be used if you have a specific target for the filter's size.</p>
     ;
     ; <p>See the docs for {@link org.bitcoinj.core.BloomFilter#BloomFilter(int, double, long)} for a brief
     ; explanation of anonymity when using bloom filters, and for the meaning of these parameters.</p>
     ;;
    (§ method BloomFilter getFilter(§ args int size, double falsePositiveRate, long tweak))
)

#_(ns org.bitcoinj.wallet #_"KeyChainFactory"
   (:require [org.bitcoinj.crypto DeterministicKey KeyCrypter]))

;;;
 ; Factory interface for creation keychains while de-serializing a wallet.
 ;;
#_public
(§ interface KeyChainFactory
    ;;;
     ; Make a keychain (but not a watching one).
     ;
     ; @param key The protobuf for the root key.
     ; @param firstSubKey The protobuf for the first child key (normally the parent of the external subchain).
     ; @param seed The seed.
     ; @param crypter The encrypted/decrypter.
     ; @param isMarried Whether the keychain is leading in a marriage.
     ;;
    (§ method DeterministicKeyChain makeKeyChain(§ args Protos.Key key, Protos.Key firstSubKey, DeterministicSeed seed, KeyCrypter crypter, boolean isMarried))

    ;;;
     ; Make a watching keychain.
     ;
     ; isMarried and isFollowingKey must not be true at the same time.
     ;
     ; @param key The protobuf for the account key.
     ; @param firstSubKey The protobuf for the first child key (normally the parent of the external subchain).
     ; @param accountKey The account extended public key.
     ; @param isFollowingKey Whether the keychain is following in a marriage.
     ; @param isMarried Whether the keychain is leading in a marriage.
     ;;
    (§ method DeterministicKeyChain makeWatchingKeyChain(§ args Protos.Key key, Protos.Key firstSubKey, DeterministicKey accountKey, boolean isFollowingKey, boolean isMarried))
        (§ throws UnreadableWalletException)
)

#_(ns org.bitcoinj.wallet #_"KeyChainGroup"
    (:import [java.security *]
             [java.util *]
             [java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect *]
             [com.google.protobuf *]
             [org.slf4j *]
             [org.spongycastle.crypto.params *])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.crypto *]
             [org.bitcoinj.script *]
             [org.bitcoinj.utils *]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

;;;
 ; <p>A KeyChainGroup is used by the {@link org.bitcoinj.wallet.Wallet} and manages: a {@link BasicKeyChain} object
 ; (which will normally be empty), and zero or more {@link DeterministicKeyChain}s.  A deterministic key chain will be
 ; created lazily/on demand when a fresh or current key is requested, possibly being initialized from the private key
 ; bytes of the earliest non rotating key in the basic key chain if one is available, or from a fresh random seed if not.</p>
 ;
 ; <p>If a key rotation time is set, it may be necessary to add a new DeterministicKeyChain with a fresh seed and
 ; also preserve the old one, so funds can be swept from the rotating keys.  In this case, there may be more than
 ; one deterministic chain.  The latest chain is called the active chain and is where new keys are served from.</p>
 ;
 ; <p>The wallet delegates most key management tasks to this class.  It is <b>not</b> thread safe and requires external
 ; locking, i.e. by the wallet lock.  The group then in turn delegates most operations to the key chain objects,
 ; combining their responses together when necessary.</p>
 ;
 ; <p>Deterministic key chains have a concept of a lookahead size and threshold.  Please see the discussion in the
 ; class docs for {@link DeterministicKeyChain} for more information on this topic.</p>
 ;;
#_public
(§ class KeyChainGroup implements KeyBag
    #_static
    (§ block
        ;; Init proper random number generator, as some old Android installations have bugs that make it unsecure.
        (§ if (§ expr Utils.isAndroidRuntime(§ pars )))
        (§ block
            (§ call (§ new LinuxSecureRandom(§ pars )))
        )
    )

    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars KeyChainGroup.class))

    #_private
    (§ field BasicKeyChain basic)
    #_private
    (§ field NetworkParameters params)
    #_protected
    #_final
    (§ field LinkedList<DeterministicKeyChain> chains)
    ;; currentKeys is used for normal, non-multisig/married wallets.
    ;; currentAddresses is used when we're handing out P2SH addresses.
    ;; They're mutually exclusive.
    #_private
    #_final
    (§ field EnumMap<KeyChain.KeyPurpose, DeterministicKey> currentKeys)
    #_private
    #_final
    (§ field EnumMap<KeyChain.KeyPurpose, Address> currentAddresses)

    #_nilable
    #_private
    (§ field KeyCrypter keyCrypter)
    #_private
    (§ field int lookaheadSize = -1)
    #_private
    (§ field int lookaheadThreshold = -1)

    ;;; Creates a keychain group with no basic chain, and a single, lazily created HD chain. ;;
    #_public
    (§ constructor KeyChainGroup(§ args NetworkParameters params))
    (§ block
        (§ this (§ pars params, nil, new ArrayList<DeterministicKeyChain>(§ pars 1), nil, nil))
    )

    ;;; Creates a keychain group with no basic chain, and an HD chain initialized from the given seed. ;;
    #_public
    (§ constructor KeyChainGroup(§ args NetworkParameters params, DeterministicSeed seed))
    (§ block
        (§ this (§ pars params, nil, ImmutableList.of(§ pars (§ new DeterministicKeyChain(§ pars seed))), nil, nil))
    )

    ;;;
     ; Creates a keychain group with no basic chain, and an HD chain that is watching the given watching key.
     ; This HAS to be an account key as returned by {@link DeterministicKeyChain#getWatchingKey()}.
     ;;
    #_public
    (§ constructor KeyChainGroup(§ args NetworkParameters params, DeterministicKey watchKey))
    (§ block
        (§ this (§ pars params, nil, ImmutableList.of(§ pars DeterministicKeyChain.watch(§ pars watchKey)), nil, nil))
    )

    ;; Used for deserialization.
    #_private
    (§ constructor KeyChainGroup(§ args NetworkParameters params, #_nilable BasicKeyChain basicKeyChain, List<DeterministicKeyChain> chains, #_nilable EnumMap<KeyChain.KeyPurpose, DeterministicKey> currentKeys, #_nilable KeyCrypter crypter))
    (§ block
        (§ ass this.params = params)
        (§ ass this.basic = (§ expr basicKeyChain == nil) ? new BasicKeyChain(§ pars ) :else basicKeyChain)
        (§ ass this.chains = new LinkedList<>(§ pars Preconditions.checkNotNull(§ pars chains)))
        (§ ass this.keyCrypter = crypter)
        (§ ass this.currentKeys = (§ expr currentKeys == nil) ? new EnumMap<KeyChain.KeyPurpose, DeterministicKey>(§ pars KeyChain.KeyPurpose.class) :else currentKeys)
        (§ ass this.currentAddresses = new EnumMap<>(§ pars KeyChain.KeyPurpose.class))
        (§ call maybeLookaheadScripts(§ pars ))

        (§ if (§ expr isMarried(§ pars )))
        (§ block
            (§ for (§ var Map.Entry<KeyChain.KeyPurpose, DeterministicKey> entry) :for (§ expr this.currentKeys.entrySet(§ pars )))
            (§ block
                (§ var Address address = makeP2SHOutputScript(§ pars entry.getValue(§ pars ), getActiveKeyChain(§ pars )).getToAddress(§ pars params))
                (§ call currentAddresses.put(§ pars entry.getKey(§ pars ), address))
            )
        )
    )

    ;; This keeps married redeem data in sync with the number of keys issued.
    #_private
    (§ method void maybeLookaheadScripts(§ args ))
    (§ block
        (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
        (§ block
            (§ call chain.maybeLookAheadScripts(§ pars ))
        )
    )

    ;;; Adds a new HD chain to the chains list, and make it the default chain (from which keys are issued). ;;
    #_public
    (§ method void createAndActivateNewHDChain(§ args ))
    (§ block
        ;; We can't do auto upgrade here because we don't know the rotation time, if any.
        #_final
        (§ var DeterministicKeyChain chain = new DeterministicKeyChain(§ pars (§ new SecureRandom(§ pars ))))
        (§ call addAndActivateHDChain(§ pars chain))
    )

    ;;;
     ; Adds an HD chain to the chains list, and make it the default chain (from which keys are issued).
     ; Useful for adding a complex pre-configured keychain, such as a married wallet.
     ;;
    #_public
    (§ method void addAndActivateHDChain(§ args DeterministicKeyChain chain))
    (§ block
        (§ call log.info(§ pars "Creating and activating a new HD chain: {}", chain))
        (§ for (§ var ListenerRegistration<KeyChainEventListener> registration) :for (§ expr basic.getListeners(§ pars )))
        (§ block
            (§ call chain.addEventListener(§ pars registration.listener, registration.executor))
        )
        (§ if (§ expr 0 <= lookaheadSize))
        (§ block
            (§ call chain.setLookaheadSize(§ pars lookaheadSize))
        )
        (§ if (§ expr 0 <= lookaheadThreshold))
        (§ block
            (§ call chain.setLookaheadThreshold(§ pars lookaheadThreshold))
        )
        (§ call chains.add(§ pars chain))
    )

    ;;;
     ; Returns a key that hasn't been seen in a transaction yet, and which is suitable for displaying in a wallet
     ; user interface as "a convenient key to receive funds on" when the purpose parameter is
     ; {@link KeyChain.KeyPurpose#RECEIVE_FUNDS}.  The returned key is stable until it's actually seen in a pending
     ; or confirmed transaction, at which point this method will start returning a different key (for each purpose
     ; independently).
     ;
     ; <p>This method is not supposed to be used for married keychains and will throw UnsupportedOperationException
     ; if the active chain is married.
     ; For married keychains use {@link #currentAddress(KeyChain.KeyPurpose)} to get a proper P2SH address.</p>
     ;;
    #_public
    (§ method DeterministicKey currentKey(§ args KeyChain.KeyPurpose purpose))
    (§ block
        (§ var DeterministicKeyChain chain = getActiveKeyChain(§ pars ))
        (§ if (§ expr chain.isMarried(§ pars )))
        (§ block
            (§ throw (§ new UnsupportedOperationException(§ pars "Key is not suitable to receive coins for married keychains. Use freshAddress to get P2SH address instead.")))
        )

        (§ var DeterministicKey current = currentKeys.get(§ pars purpose))
        (§ if (§ expr current == nil))
        (§ block
            (§ ass current = freshKey(§ pars purpose))
            (§ call currentKeys.put(§ pars purpose, current))
        )
        (§ return current)
    )

    ;;;
     ; Returns address for a {@link #currentKey(KeyChain.KeyPurpose)}.
     ;;
    #_public
    (§ method Address currentAddress(§ args KeyChain.KeyPurpose purpose))
    (§ block
        (§ var DeterministicKeyChain chain = getActiveKeyChain(§ pars ))
        (§ if (§ expr chain.isMarried(§ pars )))
        (§ block
            (§ var Address current = currentAddresses.get(§ pars purpose))
            (§ if (§ expr current == nil))
            (§ block
                (§ ass current = freshAddress(§ pars purpose))
                (§ call currentAddresses.put(§ pars purpose, current))
            )
            (§ return current)
        )

        (§ return currentKey(§ pars purpose).toAddress(§ pars params))
    )

    ;;;
     ; Returns a key that has not been returned by this method before (fresh).  You can think of this as being a newly
     ; created key, although the notion of "create" is not really valid for a {@link DeterministicKeyChain}.  When the
     ; parameter is {@link KeyChain.KeyPurpose#RECEIVE_FUNDS}, the returned key is suitable for being put into a receive
     ; coins wizard type UI.  You should use this when the user is definitely going to hand this key out to someone who
     ; wishes to send money.
     ; <p>This method is not supposed to be used for married keychains and will throw UnsupportedOperationException if
     ; the active chain is married.
     ; For married keychains use {@link #freshAddress(KeyChain.KeyPurpose)} to get a proper P2SH address.</p>
     ;;
    #_public
    (§ method DeterministicKey freshKey(§ args KeyChain.KeyPurpose purpose))
    (§ block
        (§ return freshKeys(§ pars purpose, 1).get(§ pars 0))
    )

    ;;;
     ; Returns a key/s that have not been returned by this method before (fresh).  You can think of this as being newly
     ; created key/s, although the notion of "create" is not really valid for a {@link DeterministicKeyChain}.  When the
     ; parameter is {@link KeyChain.KeyPurpose#RECEIVE_FUNDS}, the returned key is suitable for being put into a receive
     ; coins wizard type UI.  You should use this when the user is definitely going to hand this key out to someone who
     ; wishes to send money.
     ; <p>This method is not supposed to be used for married keychains and will throw UnsupportedOperationException if
     ; the active chain is married.
     ; For married keychains use {@link #freshAddress(KeyChain.KeyPurpose)} to get a proper P2SH address.</p>
     ;;
    #_public
    (§ method List<DeterministicKey> freshKeys(§ args KeyChain.KeyPurpose purpose, int numberOfKeys))
    (§ block
        (§ var DeterministicKeyChain chain = getActiveKeyChain(§ pars ))
        (§ if (§ expr chain.isMarried(§ pars )))
        (§ block
            (§ throw (§ new UnsupportedOperationException(§ pars "Key is not suitable to receive coins for married keychains. Use freshAddress to get P2SH address instead.")))
        )

        (§ return chain.getKeys(§ pars purpose, numberOfKeys)) ;; Always returns the next key along the key chain.
    )

    ;;;
     ; Returns address for a {@link #freshKey(KeyChain.KeyPurpose)}.
     ;;
    #_public
    (§ method Address freshAddress(§ args KeyChain.KeyPurpose purpose))
    (§ block
        (§ var DeterministicKeyChain chain = getActiveKeyChain(§ pars ))
        (§ if (§ expr chain.isMarried(§ pars )))
        (§ block
            (§ var Script outputScript = chain.freshOutputScript(§ pars purpose))
            (§ call Preconditions.checkState(§ pars outputScript.isPayToScriptHash(§ pars ))) ;; Only handle P2SH for now.
            (§ var Address freshAddress = Address.fromP2SHScript(§ pars params, outputScript))
            (§ call maybeLookaheadScripts(§ pars ))
            (§ call currentAddresses.put(§ pars purpose, freshAddress))
            (§ return freshAddress)
        )

        (§ return freshKey(§ pars purpose).toAddress(§ pars params))
    )

    ;;; Returns the key chain that's used for generation of fresh/current keys.  This is always the newest HD chain. ;;
    #_public
    #_final
    (§ method DeterministicKeyChain getActiveKeyChain(§ args ))
    (§ block
        (§ if (§ expr chains.isEmpty(§ pars )))
        (§ block
            (§ if (§ expr 0 < basic.numKeys(§ pars )))
            (§ block
                (§ call log.warn(§ pars "No HD chain present but random keys are: you probably deserialized an old wallet."))
                ;; If called from the wallet (most likely) it'll try to upgrade us, as it knows the rotation time but not the password.
                (§ throw (§ new DeterministicUpgradeRequiredException(§ pars )))
            )
            ;; Otherwise we have no HD chains and no random keys: we are a new born!  So a random seed is fine.
            (§ call createAndActivateNewHDChain(§ pars ))
        )
        (§ return chains.get(§ pars chains.size(§ pars ) - 1))
    )

    ;;;
     ; Sets the lookahead buffer size for ALL deterministic key chains as well as for following key chains if any exist.
     ; See {@link DeterministicKeyChain#setLookaheadSize(int)} for more information.
     ;;
    #_public
    (§ method void setLookaheadSize(§ args int lookaheadSize))
    (§ block
        (§ ass this.lookaheadSize = lookaheadSize)
        (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
        (§ block
            (§ call chain.setLookaheadSize(§ pars lookaheadSize))
        )
    )

    ;;;
     ; Gets the current lookahead size being used for ALL deterministic key chains.
     ; See {@link DeterministicKeyChain#setLookaheadSize(int)} for more information.
     ;;
    #_public
    (§ method int getLookaheadSize(§ args ))
    (§ block
        (§ return (§ expr lookaheadSize == -1) ? getActiveKeyChain(§ pars ).getLookaheadSize(§ pars ) :else lookaheadSize)
    )

    ;;;
     ; Sets the lookahead buffer threshold for ALL deterministic key chains.
     ; See {@link DeterministicKeyChain#setLookaheadThreshold(int)} for more information.
     ;;
    #_public
    (§ method void setLookaheadThreshold(§ args int num))
    (§ block
        (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
        (§ block
            (§ call chain.setLookaheadThreshold(§ pars num))
        )
    )

    ;;;
     ; Gets the current lookahead threshold being used for ALL deterministic key chains.
     ; See {@link DeterministicKeyChain#setLookaheadThreshold(int)} for more information.
     ;;
    #_public
    (§ method int getLookaheadThreshold(§ args ))
    (§ block
        (§ return (§ expr lookaheadThreshold == -1) ? getActiveKeyChain(§ pars ).getLookaheadThreshold(§ pars ) :else lookaheadThreshold)
    )

    ;;; Imports the given keys into the basic chain, creating it if necessary. ;;
    #_public
    (§ method int importKeys(§ args List<ECKey> keys))
    (§ block
        (§ return basic.importKeys(§ pars keys))
    )

    ;;; Imports the given keys into the basic chain, creating it if necessary. ;;
    #_public
    (§ method int importKeys(§ args ECKey... keys))
    (§ block
        (§ return importKeys(§ pars ImmutableList.copyOf(§ pars keys)))
    )

    #_public
    (§ method boolean checkPassword(§ args CharSequence password))
    (§ block
        (§ call Preconditions.checkState(§ pars keyCrypter != nil, "Not encrypted"))

        (§ return checkAESKey(§ pars keyCrypter.deriveKey(§ pars password)))
    )

    #_public
    (§ method boolean checkAESKey(§ args KeyParameter aesKey))
    (§ block
        (§ call Preconditions.checkState(§ pars keyCrypter != nil, "Not encrypted"))

        (§ return (§ quest (§ expr 0 < basic.numKeys(§ pars )) ? basic.checkAESKey(§ pars aesKey) :else getActiveKeyChain(§ pars ).checkAESKey(§ pars aesKey)))
    )

    ;;; Imports the given unencrypted keys into the basic chain, encrypting them along the way with the given key. ;;
    #_public
    (§ method int importKeysAndEncrypt(§ args #_final List<ECKey> keys, KeyParameter aesKey))
    (§ block
        ;; TODO: Firstly check if the aes key can decrypt any of the existing keys successfully.
        (§ call Preconditions.checkState(§ pars keyCrypter != nil, "Not encrypted"))

        (§ var LinkedList<ECKey> encryptedKeys = Lists.newLinkedList(§ pars ))
        (§ for (§ var ECKey key) :for (§ expr keys))
        (§ block
            (§ if (§ expr key.isEncrypted(§ pars )))
            (§ block
                (§ throw (§ new IllegalArgumentException(§ pars "Cannot provide already encrypted keys")))
            )

            (§ call encryptedKeys.add(§ pars key.encrypt(§ pars keyCrypter, aesKey)))
        )
        (§ return importKeys(§ pars encryptedKeys))
    )

    #_override
    #_nilable
    #_public
    (§ method RedeemData findRedeemDataFromScriptHash(§ args byte[] scriptHash))
    (§ block
        ;; Iterate in reverse order, since the active keychain is the one most likely to have the hit.
        (§ for (§ var Iterator<DeterministicKeyChain> iter = chains.descendingIterator(§ pars )) :for (§ expr iter.hasNext(§ pars )) :for (§ expr ))
        (§ block
            (§ var DeterministicKeyChain chain = iter.next(§ pars ))
            (§ var RedeemData redeemData = chain.findRedeemDataByScriptHash(§ pars ByteString.copyFrom(§ pars scriptHash)))
            (§ if (§ expr redeemData != nil))
            (§ block
                (§ return redeemData)
            )
        )
        (§ return nil)
    )

    #_public
    (§ method void markP2SHAddressAsUsed(§ args Address address))
    (§ block
        (§ call Preconditions.checkArgument(§ pars address.isP2SHAddress(§ pars )))

        (§ var RedeemData data = findRedeemDataFromScriptHash(§ pars address.getHash160(§ pars )))
        (§ if (§ expr data == nil))
        (§ block
            (§ return ) ;; Not our P2SH address.
        )

        (§ for (§ var ECKey key) :for (§ expr data.keys))
        (§ block
            (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
            (§ block
                (§ var DeterministicKey k = chain.findKeyFromPubKey(§ pars key.getPubKey(§ pars )))
                (§ if (§ expr k != nil))
                (§ block
                    (§ call chain.markKeyAsUsed(§ pars k))
                    (§ call maybeMarkCurrentAddressAsUsed(§ pars address))
                )
            )
        )
    )

    #_nilable
    #_override
    #_public
    (§ method ECKey findKeyFromPubHash(§ args byte[] pubkeyHash))
    (§ block
        (§ var ECKey result = basic.findKeyFromPubHash(§ pars pubkeyHash))
        (§ if (§ expr result != nil))
        (§ block
            (§ return result)
        )

        (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
        (§ block
            (§ ass result = chain.findKeyFromPubHash(§ pars pubkeyHash))
            (§ if (§ expr result != nil))
            (§ block
                (§ return result)
            )
        )

        (§ return nil)
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkeyHash.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_public
    (§ method void markPubKeyHashAsUsed(§ args byte[] pubkeyHash))
    (§ block
        (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
        (§ block
            (§ var DeterministicKey key = chain.markPubHashAsUsed(§ pars pubkeyHash))
            (§ if (§ expr key != nil))
            (§ block
                (§ call maybeMarkCurrentKeyAsUsed(§ pars key))
                (§ return )
            )
        )
    )

    ;;; If the given P2SH address is "current", advance it to a new one. ;;
    #_private
    (§ method void maybeMarkCurrentAddressAsUsed(§ args Address address))
    (§ block
        (§ call Preconditions.checkArgument(§ pars address.isP2SHAddress(§ pars )))

        (§ for (§ var Map.Entry<KeyChain.KeyPurpose, Address> entry) :for (§ expr currentAddresses.entrySet(§ pars )))
        (§ block
            (§ if (§ expr entry.getValue(§ pars ) != nil && entry.getValue(§ pars ).equals(§ pars address)))
            (§ block
                (§ call log.info(§ pars "Marking P2SH address as used: {}", address))
                (§ call currentAddresses.put(§ pars entry.getKey(§ pars ), freshAddress(§ pars entry.getKey(§ pars ))))
                (§ return )
            )
        )
    )

    ;;; If the given key is "current", advance the current key to a new one. ;;
    #_private
    (§ method void maybeMarkCurrentKeyAsUsed(§ args DeterministicKey key))
    (§ block
        ;; It's OK for currentKeys to be empty here: it means we're a married wallet and the key may be a part of a rotating chain.
        (§ for (§ var Map.Entry<KeyChain.KeyPurpose, DeterministicKey> entry) :for (§ expr currentKeys.entrySet(§ pars )))
        (§ block
            (§ if (§ expr entry.getValue(§ pars ) != nil && entry.getValue(§ pars ).equals(§ pars key)))
            (§ block
                (§ call log.info(§ pars "Marking key as used: {}", key))
                (§ call currentKeys.put(§ pars entry.getKey(§ pars ), freshKey(§ pars entry.getKey(§ pars ))))
                (§ return )
            )
        )
    )

    #_public
    (§ method boolean hasKey(§ args ECKey key))
    (§ block
        (§ if (§ expr basic.hasKey(§ pars key)))
        (§ block
            (§ return true)
        )
        (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
        (§ block
            (§ if (§ expr chain.hasKey(§ pars key)))
            (§ block
                (§ return true)
            )
        )
        (§ return false)
    )

    #_nilable
    #_override
    #_public
    (§ method ECKey findKeyFromPubKey(§ args byte[] pubkey))
    (§ block
        (§ var ECKey result = basic.findKeyFromPubKey(§ pars pubkey))
        (§ if (§ expr result != nil))
        (§ block
            (§ return result)
        )

        (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
        (§ block
            (§ ass result = chain.findKeyFromPubKey(§ pars pubkey))
            (§ if (§ expr result != nil))
            (§ block
                (§ return result)
            )
        )

        (§ return nil)
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkey.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_public
    (§ method void markPubKeyAsUsed(§ args byte[] pubkey))
    (§ block
        (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
        (§ block
            (§ var DeterministicKey key = chain.markPubKeyAsUsed(§ pars pubkey))
            (§ if (§ expr key != nil))
            (§ block
                (§ call maybeMarkCurrentKeyAsUsed(§ pars key))
                (§ return )
            )
        )
    )

    ;;; Returns the number of keys managed by this group, including the lookahead buffers. ;;
    #_public
    (§ method int numKeys(§ args ))
    (§ block
        (§ var int result = basic.numKeys(§ pars ))
        (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
        (§ block
            (§ ass result = result + chain.numKeys(§ pars ))
        )
        (§ return result)
    )

    ;;;
     ; Removes a key that was imported into the basic key chain.  You cannot remove deterministic keys.
     ; @throws java.lang.IllegalArgumentException if the key is deterministic.
     ;;
    #_public
    (§ method boolean removeImportedKey(§ args ECKey key))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars key))
        (§ call Preconditions.checkArgument(§ pars !(§ expr key instanceof DeterministicKey)))

        (§ return basic.removeKey(§ pars key))
    )

    ;;;
     ; Whether the active keychain is married.  A keychain is married when it vends P2SH addresses
     ; from multiple keychains in a multisig relationship.
     ; @see org.bitcoinj.wallet.MarriedKeyChain
     ;;
    #_public
    #_final
    (§ method boolean isMarried(§ args ))
    (§ block
        (§ return !chains.isEmpty(§ pars ) && getActiveKeyChain(§ pars ).isMarried(§ pars ))
    )

    ;;;
     ; Encrypt the keys in the group using the KeyCrypter and the AES key.
     ; A good default KeyCrypter to use is {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @throws org.bitcoinj.crypto.KeyCrypterException if the wallet encryption fails for some reason,
     ;         leaving the group unchanged.
     ; @throws DeterministicUpgradeRequiredException if there are random keys but no HD chain.
     ;;
    #_public
    (§ method void encrypt(§ args KeyCrypter keyCrypter, KeyParameter aesKey))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars keyCrypter))
        (§ call Preconditions.checkNotNull(§ pars aesKey))

        ;; This code must be exception safe.
        (§ var BasicKeyChain newBasic = basic.toEncrypted(§ pars keyCrypter, aesKey))
        (§ var List<DeterministicKeyChain> newChains = new ArrayList<>(§ pars chains.size(§ pars )))
        (§ if (§ expr chains.isEmpty(§ pars ) && basic.numKeys(§ pars ) == 0))
        (§ block
            ;; No HD chains and no random keys: encrypting an entirely empty keychain group.
            ;; But we can't do that, we must have something to encrypt: so instantiate a new HD chain here.
            (§ call createAndActivateNewHDChain(§ pars ))
        )
        (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
        (§ block
            (§ call newChains.add(§ pars chain.toEncrypted(§ pars keyCrypter, aesKey)))
        )
        (§ ass this.keyCrypter = keyCrypter)
        (§ ass basic = newBasic)
        (§ call chains.clear(§ pars ))
        (§ call chains.addAll(§ pars newChains))
    )

    ;;;
     ; Decrypt the keys in the group using the previously given key crypter and the AES key.
     ; A good default KeyCrypter to use is {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @throws org.bitcoinj.crypto.KeyCrypterException if the wallet decryption fails for some reason, leaving the group unchanged.
     ;;
    #_public
    (§ method void decrypt(§ args KeyParameter aesKey))
    (§ block
        ;; This code must be exception safe.
        (§ call Preconditions.checkNotNull(§ pars aesKey))

        (§ var BasicKeyChain newBasic = basic.toDecrypted(§ pars aesKey))
        (§ var List<DeterministicKeyChain> newChains = new ArrayList<>(§ pars chains.size(§ pars )))
        (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
        (§ block
            (§ call newChains.add(§ pars chain.toDecrypted(§ pars aesKey)))
        )

        (§ ass this.keyCrypter = nil)
        (§ ass basic = newBasic)
        (§ call chains.clear(§ pars ))
        (§ call chains.addAll(§ pars newChains))
    )

    ;;; Returns true if the group is encrypted. ;;
    #_public
    (§ method boolean isEncrypted(§ args ))
    (§ block
        (§ return (§ expr keyCrypter != nil))
    )

    ;;;
     ; Returns whether this chain has only watching keys (unencrypted keys with no private part).
     ; Mixed chains are forbidden.
     ;
     ; @throws IllegalStateException if there are no keys, or if there is a mix between watching and non-watching keys.
     ;;
    #_public
    (§ method boolean isWatching(§ args ))
    (§ block
        (§ var BasicKeyChain.State activeState = BasicKeyChain.State.EMPTY)
        (§ if (§ expr !chains.isEmpty(§ pars )))
        (§ block
            (§ ass activeState = getActiveKeyChain(§ pars ).isWatching(§ pars ) ? BasicKeyChain.State.WATCHING :else BasicKeyChain.State.REGULAR)
        )

        (§ var BasicKeyChain.State basicState = basic.isWatching(§ pars ))
        (§ if (§ expr basicState == BasicKeyChain.State.EMPTY))
        (§ block
            (§ if (§ expr activeState == BasicKeyChain.State.EMPTY))
            (§ block
                (§ throw (§ new IllegalStateException(§ pars "Empty key chain group: cannot answer isWatching() query")))
            )

            (§ return (§ expr activeState == BasicKeyChain.State.WATCHING))
        )

        (§ if (§ expr activeState == BasicKeyChain.State.EMPTY))
        (§ block
            (§ return (§ expr basicState == BasicKeyChain.State.WATCHING))
        )

        (§ if (§ expr activeState != basicState))
        (§ block
            (§ throw (§ new IllegalStateException(§ pars "Mix of watching and non-watching keys in wallet")))
        )

        (§ return (§ expr activeState == BasicKeyChain.State.WATCHING))
    )

    ;;; Returns the key crypter or null if the group is not encrypted. ;;
    #_nilable
    #_public
    (§ method KeyCrypter getKeyCrypter(§ args ))
    (§ block
        (§ return keyCrypter)
    )

    ;;;
     ; Returns a list of the non-deterministic keys that have been imported into the wallet, or the empty list if none.
     ;;
    #_public
    (§ method List<ECKey> getImportedKeys(§ args ))
    (§ block
        (§ return basic.getKeys(§ pars ))
    )

    #_public
    (§ method long getEarliestKeyCreationTime(§ args ))
    (§ block
        (§ var long time = basic.getEarliestKeyCreationTime(§ pars )) ;; Long.MAX_VALUE if empty.
        (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
        (§ block
            (§ ass time = Math.min(§ pars time, chain.getEarliestKeyCreationTime(§ pars )))
        )
        (§ return time)
    )

    #_public
    (§ method int getBloomFilterElementCount(§ args ))
    (§ block
        (§ var int result = basic.numBloomFilterEntries(§ pars ))
        (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
        (§ block
            (§ ass result = result + chain.numBloomFilterEntries(§ pars ))
        )
        (§ return result)
    )

    #_public
    (§ method BloomFilter getBloomFilter(§ args int size, double falsePositiveRate, long nTweak))
    (§ block
        (§ var BloomFilter filter = new BloomFilter(§ pars size, falsePositiveRate, nTweak))
        (§ if (§ expr 0 < basic.numKeys(§ pars )))
        (§ block
            (§ call filter.merge(§ pars basic.getFilter(§ pars size, falsePositiveRate, nTweak)))
        )

        (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
        (§ block
            (§ call filter.merge(§ pars chain.getFilter(§ pars size, falsePositiveRate, nTweak)))
        )
        (§ return filter)
    )

    #_private
    (§ method Script makeP2SHOutputScript(§ args DeterministicKey followedKey, DeterministicKeyChain chain))
    (§ block
        (§ return ScriptBuilder.createP2SHOutputScript(§ pars chain.getRedeemData(§ pars followedKey).redeemScript))
    )

    ;;; Adds a listener for events that are run when keys are added, on the user thread. ;;
    #_public
    (§ method void addEventListener(§ args KeyChainEventListener listener))
    (§ block
        (§ call addEventListener(§ pars listener, Threading.USER_THREAD))
    )

    ;;; Adds a listener for events that are run when keys are added, on the given executor. ;;
    #_public
    (§ method void addEventListener(§ args KeyChainEventListener listener, Executor executor))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars listener))
        (§ call Preconditions.checkNotNull(§ pars executor))

        (§ call basic.addEventListener(§ pars listener, executor))
        (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
        (§ block
            (§ call chain.addEventListener(§ pars listener, executor))
        )
    )

    ;;; Removes a listener for events that are run when keys are added. ;;
    #_public
    (§ method boolean removeEventListener(§ args KeyChainEventListener listener))
    (§ block
        (§ call Preconditions.checkNotNull(§ pars listener))

        (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
        (§ block
            (§ call chain.removeEventListener(§ pars listener))
        )
        (§ return basic.removeEventListener(§ pars listener))
    )

    ;;; Returns a list of key protobufs obtained by merging the chains. ;;
    #_public
    (§ method List<Protos.Key> serializeToProtobuf(§ args ))
    (§ block
        (§ var List<Protos.Key> result = (§ quest (§ expr basic != nil) ? basic.serializeToProtobuf(§ pars ) :else Lists.newArrayList(§ pars )))

        (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
        (§ block
            (§ var List<Protos.Key> protos = chain.serializeToProtobuf(§ pars ))
            (§ call result.addAll(§ pars protos))
        )
        (§ return result)
    )

    #_static
    (§ method KeyChainGroup fromProtobufUnencrypted(§ args NetworkParameters params, List<Protos.Key> keys))
        (§ throws UnreadableWalletException)
    (§ block
        (§ return fromProtobufUnencrypted(§ pars params, keys, new DefaultKeyChainFactory(§ pars )))
    )

    #_public
    #_static
    (§ method KeyChainGroup fromProtobufUnencrypted(§ args NetworkParameters params, List<Protos.Key> keys, KeyChainFactory factory))
        (§ throws UnreadableWalletException)
    (§ block
        (§ var BasicKeyChain basicKeyChain = BasicKeyChain.fromProtobufUnencrypted(§ pars keys))
        (§ var List<DeterministicKeyChain> chains = DeterministicKeyChain.fromProtobuf(§ pars keys, nil, factory))
        (§ var EnumMap<KeyChain.KeyPurpose, DeterministicKey> currentKeys = nil)
        (§ if (§ expr !chains.isEmpty(§ pars )))
        (§ block
            (§ ass currentKeys = createCurrentKeysMap(§ pars chains))
        )
        (§ call extractFollowingKeychains(§ pars chains))
        (§ return (§ new KeyChainGroup(§ pars params, basicKeyChain, chains, currentKeys, nil)))
    )

    #_static
    (§ method KeyChainGroup fromProtobufEncrypted(§ args NetworkParameters params, List<Protos.Key> keys, KeyCrypter crypter))
        (§ throws UnreadableWalletException)
    (§ block
        (§ return fromProtobufEncrypted(§ pars params, keys, crypter, new DefaultKeyChainFactory(§ pars )))
    )

    #_public
    #_static
    (§ method KeyChainGroup fromProtobufEncrypted(§ args NetworkParameters params, List<Protos.Key> keys, KeyCrypter crypter, KeyChainFactory factory))
        (§ throws UnreadableWalletException)
    (§ block
        (§ call Preconditions.checkNotNull(§ pars crypter))

        (§ var BasicKeyChain basicKeyChain = BasicKeyChain.fromProtobufEncrypted(§ pars keys, crypter))
        (§ var List<DeterministicKeyChain> chains = DeterministicKeyChain.fromProtobuf(§ pars keys, crypter, factory))
        (§ var EnumMap<KeyChain.KeyPurpose, DeterministicKey> currentKeys = nil)
        (§ if (§ expr !chains.isEmpty(§ pars )))
        (§ block
            (§ ass currentKeys = createCurrentKeysMap(§ pars chains))
        )
        (§ call extractFollowingKeychains(§ pars chains))
        (§ return (§ new KeyChainGroup(§ pars params, basicKeyChain, chains, currentKeys, crypter)))
    )

    ;;;
     ; If the key chain contains only random keys and no deterministic key chains, this method will create a chain
     ; based on the oldest non-rotating private key (i.e. the seed is derived from the old wallet).
     ;
     ; @param keyRotationTimeSecs If non-zero, UNIX time for which keys created before this are assumed to be
     ;                            compromised or weak, those keys will not be used for deterministic upgrade.
     ; @param aesKey If non-null, the encryption key the keychain is encrypted under.  If the keychain is encrypted
     ;               and this is not supplied, an exception is thrown letting you know you should ask the user for
     ;               their password, turn it into a key, and then try again.
     ; @throws java.lang.IllegalStateException if there is already a deterministic key chain present or if there are
     ;                                         no random keys (i.e. this is not an upgrade scenario), or if aesKey is
     ;                                         provided but the wallet is not encrypted.
     ; @throws java.lang.IllegalArgumentException if the rotation time specified excludes all keys.
     ; @throws DeterministicUpgradeRequiresPassword if the key chain group is encrypted
     ;         and you should provide the users encryption key.
     ; @return the DeterministicKeyChain that was created by the upgrade.
     ;;
    #_public
    (§ method DeterministicKeyChain upgradeToDeterministic(§ args long keyRotationTimeSecs, #_nilable KeyParameter aesKey))
        (§ throws DeterministicUpgradeRequiresPassword, AllRandomKeysRotating)
    (§ block
        (§ call Preconditions.checkState(§ pars 0 < basic.numKeys(§ pars )))
        (§ call Preconditions.checkArgument(§ pars 0 <= keyRotationTimeSecs))

        ;; Subtract one because the key rotation time might have been set to the creation time of the first known
        ;; good key, in which case, that's the one we want to find.
        (§ var ECKey keyToUse = basic.findOldestKeyAfter(§ pars keyRotationTimeSecs - 1))
        (§ if (§ expr keyToUse == nil))
        (§ block
            (§ throw (§ new AllRandomKeysRotating(§ pars )))
        )

        (§ if (§ expr keyToUse.isEncrypted(§ pars )))
        (§ block
            (§ if (§ expr aesKey == nil))
            (§ block
                ;; We can't auto upgrade because we don't know the users password at this point.  We throw an exception
                ;; so the calling code knows to abort the load and ask the user for their password, they can then try
                ;; loading the wallet again passing in the AES key.
                ;;
                ;; There are a few different approaches we could have used here, but they all suck.  The most obvious
                ;; is to try and be as lazy as possible, running in the old random-wallet mode until the user enters
                ;; their password for some other reason and doing the upgrade then.  But this could result in strange
                ;; and unexpected UI flows for the user, as well as complicating the job of wallet developers who then
                ;; have to support both "old" and "new" UI modes simultaneously, switching them on the fly.  Given that
                ;; this is a one-off transition, it seems more reasonable to just ask the user for their password
                ;; on startup, and then the wallet app can have all the widgets for accessing seed words etc active
                ;; all the time.
                (§ throw (§ new DeterministicUpgradeRequiresPassword(§ pars )))
            )
            (§ ass keyToUse = keyToUse.decrypt(§ pars aesKey))
        )
        (§ elseif (§ expr aesKey != nil))
        (§ block
            (§ throw (§ new IllegalStateException(§ pars "AES Key was provided but wallet is not encrypted.")))
        )

        (§ if (§ expr chains.isEmpty(§ pars )))
        (§ block
            (§ call log.info(§ pars "Auto-upgrading pre-HD wallet to HD!"))
        )
        (§ else )
        (§ block
            (§ call log.info(§ pars "Wallet with existing HD chain is being re-upgraded due to change in key rotation time."))
        )

        (§ call log.info(§ pars "Instantiating new HD chain using oldest non-rotating private key (address: {})", keyToUse.toAddress(§ pars params)))
        (§ var byte[] entropy = Preconditions.checkNotNull(§ pars keyToUse.getSecretBytes(§ pars )))
        ;; Private keys should be at least 128 bits long.
        (§ call Preconditions.checkState(§ pars DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS / 8 <= entropy.length))
        ;; We reduce the entropy here to 128 bits because people like to write their seeds down on paper,
        ;; and 128 bits should be sufficient forever unless the laws of the universe change or ECC is broken;
        ;; in either case we all have bigger problems.
        (§ ass entropy = Arrays.copyOfRange(§ pars entropy, 0, DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS / 8)) ;; Final argument is exclusive range.
        (§ call Preconditions.checkState(§ pars entropy.length == DeterministicSeed.DEFAULT_SEED_ENTROPY_BITS / 8))
        (§ var String passphrase = "") ;; FIXME allow non-empty passphrase
        (§ var DeterministicKeyChain chain = new DeterministicKeyChain(§ pars entropy, passphrase, keyToUse.getCreationTimeSeconds(§ pars )))
        (§ if (§ expr aesKey != nil))
        (§ block
            (§ ass chain = chain.toEncrypted(§ pars Preconditions.checkNotNull(§ pars basic.getKeyCrypter(§ pars )), aesKey))
        )
        (§ call chains.add(§ pars chain))
        (§ return chain)
    )

    ;;; Returns true if the group contains random keys but no HD chains. ;;
    #_public
    (§ method boolean isDeterministicUpgradeRequired(§ args ))
    (§ block
        (§ return (§ expr 0 < basic.numKeys(§ pars ) && chains.isEmpty(§ pars )))
    )

    #_private
    #_static
    (§ method EnumMap<KeyChain.KeyPurpose, DeterministicKey> createCurrentKeysMap(§ args List<DeterministicKeyChain> chains))
    (§ block
        (§ var DeterministicKeyChain activeChain = chains.get(§ pars chains.size(§ pars ) - 1))

        (§ var EnumMap<KeyChain.KeyPurpose, DeterministicKey> currentKeys = new EnumMap<>(§ pars KeyChain.KeyPurpose.class))

        ;; Assuming that only RECEIVE and CHANGE keys are being used at the moment, we will treat the latest issued
        ;; external key as current RECEIVE key and latest issued internal key as CHANGE key.  This should be changed
        ;; as soon as other kinds of KeyPurpose are introduced.
        (§ if (§ expr 0 < activeChain.getIssuedExternalKeys(§ pars )))
        (§ block
            (§ var DeterministicKey currentExternalKey = activeChain.getKeyByPath(§ pars HDUtils.append(§ pars HDUtils.concat(§ pars activeChain.getAccountPath(§ pars ), DeterministicKeyChain.EXTERNAL_SUBPATH), new ChildNumber(§ pars activeChain.getIssuedExternalKeys(§ pars ) - 1))))
            (§ call currentKeys.put(§ pars KeyChain.KeyPurpose.RECEIVE_FUNDS, currentExternalKey))
        )

        (§ if (§ expr 0 < activeChain.getIssuedInternalKeys(§ pars )))
        (§ block
            (§ var DeterministicKey currentInternalKey = activeChain.getKeyByPath(§ pars HDUtils.append(§ pars HDUtils.concat(§ pars activeChain.getAccountPath(§ pars ), DeterministicKeyChain.INTERNAL_SUBPATH), new ChildNumber(§ pars activeChain.getIssuedInternalKeys(§ pars ) - 1))))
            (§ call currentKeys.put(§ pars KeyChain.KeyPurpose.CHANGE, currentInternalKey))
        )

        (§ return currentKeys)
    )

    #_private
    #_static
    (§ method void extractFollowingKeychains(§ args List<DeterministicKeyChain> chains))
    (§ block
        ;; Look for following key chains and map them to the watch keys of followed keychains.
        (§ var List<DeterministicKeyChain> followingChains = Lists.newArrayList(§ pars ))
        (§ for (§ var Iterator<DeterministicKeyChain> it = chains.iterator(§ pars )) :for (§ expr it.hasNext(§ pars )) :for (§ expr ))
        (§ block
            (§ var DeterministicKeyChain chain = it.next(§ pars ))
            (§ if (§ expr chain.isFollowing(§ pars )))
            (§ block
                (§ call followingChains.add(§ pars chain))
                (§ call it.remove(§ pars ))
            )
            (§ elseif (§ expr !followingChains.isEmpty(§ pars )))
            (§ block
                (§ if (§ expr !(§ expr chain instanceof MarriedKeyChain)))
                (§ block
                    (§ throw (§ new IllegalStateException(§ pars )))
                )

                (§ call (§ expr (§ cast MarriedKeyChain)chain).setFollowingKeyChains(§ pars followingChains))
                (§ ass followingChains = Lists.newArrayList(§ pars ))
            )
        )
    )

    #_public
    (§ method String toString(§ args boolean includePrivateKeys))
    (§ block
        #_final
        (§ var StringBuilder sb = new StringBuilder(§ pars ))
        (§ if (§ expr basic != nil))
        (§ block
            (§ var List<ECKey> keys = basic.getKeys(§ pars ))
            (§ call Collections.sort(§ pars keys, ECKey.AGE_COMPARATOR))
            (§ for (§ var ECKey key) :for (§ expr keys))
            (§ block
                (§ call key.formatKeyWithAddress(§ pars includePrivateKeys, sb, params))
            )
        )
        (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
        (§ block
            (§ call sb.append(§ pars chain.toString(§ pars includePrivateKeys, params)).append(§ pars "\n"))
        )
        (§ return sb.toString(§ pars ))
    )

    ;;; Returns a copy of the current list of chains. ;;
    #_public
    (§ method List<DeterministicKeyChain> getDeterministicKeyChains(§ args ))
    (§ block
        (§ return new ArrayList<>(§ pars chains))
    )

    ;;;
     ; Returns a counter that increases (by an arbitrary amount) each time new keys have been calculated
     ; due to lookahead and thus the Bloom filter that was previously calculated has become stale.
     ;;
    #_public
    (§ method int getCombinedKeyLookaheadEpochs(§ args ))
    (§ block
        (§ var int epoch = 0)
        (§ for (§ var DeterministicKeyChain chain) :for (§ expr chains))
        (§ block
            (§ ass epoch = epoch + chain.getKeyLookaheadEpoch(§ pars ))
        )
        (§ return epoch)
    )
)

#_(ns org.bitcoinj.wallet #_"KeyTimeCoinSelector"
    (:import [java.util LinkedList List])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.script Script]))

;;;
 ; A coin selector that takes all coins assigned to keys created before the given timestamp.
 ; Used as part of the implementation of {@link Wallet#setKeyRotationTime(java.util.Date)}.
 ;;
#_public
(§ class KeyTimeCoinSelector implements CoinSelector
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars KeyTimeCoinSelector.class))

    ;;; A number of inputs chosen to avoid hitting {@link org.bitcoinj.core.Transaction#MAX_STANDARD_TX_SIZE}. ;;
    #_public
    #_static
    #_final
    (§ field int MAX_SIMULTANEOUS_INPUTS = 600)

    #_private
    #_final
    (§ field long unixTimeSeconds)
    #_private
    #_final
    (§ field Wallet wallet)
    #_private
    #_final
    (§ field boolean ignorePending)

    #_public
    (§ constructor KeyTimeCoinSelector(§ args Wallet wallet, long unixTimeSeconds, boolean ignorePending))
    (§ block
        (§ ass this.unixTimeSeconds = unixTimeSeconds)
        (§ ass this.wallet = wallet)
        (§ ass this.ignorePending = ignorePending)
    )

    #_override
    #_public
    (§ method CoinSelection select(§ args Coin target, List<TransactionOutput> candidates))
    (§ block
        (§ try )
        (§ block
            (§ var LinkedList<TransactionOutput> gathered = Lists.newLinkedList(§ pars ))
            (§ var Coin valueGathered = Coin.ZERO)
            (§ for (§ var TransactionOutput output) :for (§ expr candidates))
            (§ block
                (§ if (§ expr ignorePending && !isConfirmed(§ pars output)))
                (§ block
                    (§ continue )
                )

                ;; Find the key that controls output, assuming it's a regular pay-to-pubkey or pay-to-address output.
                ;; We ignore any other kind of exotic output on the assumption we can't spend it ourselves.
                #_final
                (§ var Script scriptPubKey = output.getScriptPubKey(§ pars ))
                (§ var ECKey controllingKey)
                (§ if (§ expr scriptPubKey.isSentToRawPubKey(§ pars )))
                (§ block
                    (§ ass controllingKey = wallet.findKeyFromPubKey(§ pars scriptPubKey.getPubKey(§ pars )))
                )
                (§ elseif (§ expr scriptPubKey.isSentToAddress(§ pars )))
                (§ block
                    (§ ass controllingKey = wallet.findKeyFromPubHash(§ pars scriptPubKey.getPubKeyHash(§ pars )))
                )
                (§ else )
                (§ block
                    (§ call log.info(§ pars "Skipping tx output {} because it's not of simple form.", output))
                    (§ continue )
                )

                (§ call Preconditions.checkNotNull(§ pars controllingKey, "Coin selector given output as candidate for which we lack the key"))
                (§ if (§ expr unixTimeSeconds <= controllingKey.getCreationTimeSeconds(§ pars )))
                (§ block
                    (§ continue )
                )

                ;; It's older than the cutoff time so select.
                (§ ass valueGathered = valueGathered.add(§ pars output.getValue(§ pars )))
                (§ call gathered.push(§ pars output))
                (§ if (§ expr MAX_SIMULTANEOUS_INPUTS <= gathered.size(§ pars )))
                (§ block
                    (§ call log.warn(§ pars "Reached {} inputs, going further would yield a tx that is too large, stopping here.", gathered.size(§ pars )))
                    (§ break )
                )
            )
            (§ return (§ new CoinSelection(§ pars valueGathered, gathered)))
        )
        (§ catch (§ args ScriptException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; We should never have problems understanding scripts in our wallet.
        )
    )

    #_private
    (§ method boolean isConfirmed(§ args TransactionOutput output))
    (§ block
        (§ return output.getParentTransaction(§ pars ).getConfidence(§ pars ).getConfidenceType(§ pars ).equals(§ pars TransactionConfidence.ConfidenceType.BUILDING))
    )
)

#_(ns org.bitcoinj.wallet #_"MarriedKeyChain"
    (:import [java.security SecureRandom]
             [java.util LinkedHashMap List Map])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect ImmutableList Lists]
             #_static [com.google.common.collect.Lists newArrayList]
             [com.google.protobuf ByteString])
   (:require [org.bitcoinj.core BloomFilter ECKey NetworkParameters Utils]
             [org.bitcoinj.crypto DeterministicKey KeyCrypter]
             [org.bitcoinj.script Script ScriptBuilder]))

;;;
 ; <p>A multi-signature keychain using synchronized HD keys (a.k.a HDM).</p>
 ;
 ; <p>This keychain keeps track of following keychains that follow the account key of this keychain.  You can get P2SH
 ; addresses to receive coins to from this chain.  The threshold - sigsRequiredToSpend specifies how many signatures
 ; required to spend transactions for this married keychain.  This value should not exceed the total number of keys
 ; involved (one followed key plus number of following keys), otherwise IllegalArgumentException will be thrown.</p>
 ;
 ; <p>IMPORTANT: As of Bitcoin Core 0.9 all multisig transactions which require more than 3 public keys are non-standard and
 ; such spends won't be processed by peers with default settings, essentially making such transactions almost nonspendable.</p>
 ;
 ; <p>This method will throw an IllegalStateException, if the keychain is already married or already has leaf keys issued.</p>
 ;;
#_public
(§ class MarriedKeyChain extends DeterministicKeyChain
    ;; The map holds P2SH redeem script and corresponding ECKeys issued by this KeyChainGroup (including lookahead)
    ;; mapped to redeem script hashes.
    #_private
    (§ field LinkedHashMap<ByteString, RedeemData> marriedKeysRedeemData = new LinkedHashMap<>(§ pars ))

    #_private
    (§ field List<DeterministicKeyChain> followingKeyChains)

    ;;; Builds a {@link MarriedKeyChain}. ;;
    #_public
    #_static
    (§ class Builder<T extends Builder<T>> extends DeterministicKeyChain.Builder<T>
        #_private
        (§ field List<DeterministicKey> followingKeys)
        #_private
        (§ field int threshold)

        #_protected
        (§ constructor Builder(§ args ))
        (§ block
        )

        #_public
        (§ method T followingKeys(§ args List<DeterministicKey> followingKeys))
        (§ block
            (§ ass this.followingKeys = followingKeys)
            (§ return self(§ pars ))
        )

        #_public
        (§ method T followingKeys(§ args DeterministicKey followingKey, DeterministicKey ...followingKeys))
        (§ block
            (§ ass this.followingKeys = Lists.asList(§ pars followingKey, followingKeys))
            (§ return self(§ pars ))
        )

        ;;;
         ; Threshold, or <code>(followingKeys.size() + 1) / 2 + 1)</code> (majority) if unspecified.
         ;
         ; IMPORTANT: As of Bitcoin Core 0.9 all multisig transactions which require more than 3 public keys are non-standard and
         ; such spends won't be processed by peers with default settings, essentially making such transactions almost nonspendable.
         ;;
        #_public
        (§ method T threshold(§ args int threshold))
        (§ block
            (§ ass this.threshold = threshold)
            (§ return self(§ pars ))
        )

        #_override
        #_public
        (§ method MarriedKeyChain build(§ args ))
        (§ block
            (§ call Preconditions.checkState(§ pars random != nil || entropy != nil || seed != nil || watchingKey!= nil, "Must provide either entropy or random or seed or watchingKey"))
            (§ call Preconditions.checkNotNull(§ pars followingKeys, "followingKeys must be provided"))

            (§ var MarriedKeyChain chain)
            (§ if (§ expr threshold == 0))
            (§ block
                (§ ass threshold = (§ expr followingKeys.size(§ pars ) + 1) / 2 + 1)
            )

            (§ if (§ expr random != nil))
            (§ block
                (§ ass chain = new MarriedKeyChain(§ pars random, bits, getPassphrase(§ pars ), seedCreationTimeSecs))
            )
            (§ elseif (§ expr entropy != nil))
            (§ block
                (§ ass chain = new MarriedKeyChain(§ pars entropy, getPassphrase(§ pars ), seedCreationTimeSecs))
            )
            (§ elseif (§ expr seed != nil))
            (§ block
                (§ call seed.setCreationTimeSeconds(§ pars seedCreationTimeSecs))
                (§ ass chain = new MarriedKeyChain(§ pars seed))
            )
            (§ else )
            (§ block
                (§ call watchingKey.setCreationTimeSeconds(§ pars seedCreationTimeSecs))
                (§ ass chain = new MarriedKeyChain(§ pars watchingKey))
            )

            (§ call chain.addFollowingAccountKeys(§ pars followingKeys, threshold))
            (§ return chain)
        )
    )

    #_public
    #_static
    (§ method Builder<?> builder(§ args ))
    (§ block
        (§ return (§ new Builder(§ pars )))
    )

    ;; Protobuf deserialization constructors.
    (§ constructor MarriedKeyChain(§ args DeterministicKey accountKey))
    (§ block
        (§ super (§ pars accountKey, false))
    )

    (§ constructor MarriedKeyChain(§ args DeterministicSeed seed, KeyCrypter crypter))
    (§ block
        (§ super (§ pars seed, crypter))
    )

    ;; Builder constructors.
    #_private
    (§ constructor MarriedKeyChain(§ args SecureRandom random, int bits, String passphrase, long seedCreationTimeSecs))
    (§ block
        (§ super (§ pars random, bits, passphrase, seedCreationTimeSecs))
    )

    #_private
    (§ constructor MarriedKeyChain(§ args byte[] entropy, String passphrase, long seedCreationTimeSecs))
    (§ block
        (§ super (§ pars entropy, passphrase, seedCreationTimeSecs))
    )

    #_private
    (§ constructor MarriedKeyChain(§ args DeterministicSeed seed))
    (§ block
        (§ super (§ pars seed))
    )

    (§ method void setFollowingKeyChains(§ args List<DeterministicKeyChain> followingKeyChains))
    (§ block
        (§ call Preconditions.checkArgument(§ pars !followingKeyChains.isEmpty(§ pars )))
        (§ ass this.followingKeyChains = followingKeyChains)
    )

    #_override
    #_public
    (§ method boolean isMarried(§ args ))
    (§ block
        (§ return true)
    )

    ;;; Create a new married key and return the matching output script. ;;
    #_override
    #_public
    (§ method Script freshOutputScript(§ args KeyPurpose purpose))
    (§ block
        (§ var DeterministicKey followedKey = getKey(§ pars purpose))
        (§ var ImmutableList.Builder<ECKey> keys = ImmutableList.<ECKey>builder(§ pars ).add(§ pars followedKey))
        (§ for (§ var DeterministicKeyChain keyChain) :for (§ expr followingKeyChains))
        (§ block
            (§ var DeterministicKey followingKey = keyChain.getKey(§ pars purpose))
            (§ call Preconditions.checkState(§ pars followedKey.getChildNumber(§ pars ).equals(§ pars followingKey.getChildNumber(§ pars )), "Following keychains should be in sync"))
            (§ call keys.add(§ pars followingKey))
        )
        (§ var List<ECKey> marriedKeys = keys.build(§ pars ))
        (§ var Script redeemScript = ScriptBuilder.createRedeemScript(§ pars sigsRequiredToSpend, marriedKeys))
        (§ return ScriptBuilder.createP2SHOutputScript(§ pars redeemScript))
    )

    #_private
    (§ method List<ECKey> getMarriedKeysWithFollowed(§ args DeterministicKey followedKey))
    (§ block
        (§ var ImmutableList.Builder<ECKey> keys = ImmutableList.builder(§ pars ))
        (§ for (§ var DeterministicKeyChain keyChain) :for (§ expr followingKeyChains))
        (§ block
            (§ call keyChain.maybeLookAhead(§ pars ))
            (§ call keys.add(§ pars keyChain.getKeyByPath(§ pars followedKey.getPath(§ pars ))))
        )
        (§ call keys.add(§ pars followedKey))
        (§ return keys.build(§ pars ))
    )

    ;;; Get the redeem data for a key in this married chain. ;;
    #_override
    #_public
    (§ method RedeemData getRedeemData(§ args DeterministicKey followedKey))
    (§ block
        (§ var List<ECKey> marriedKeys = getMarriedKeysWithFollowed(§ pars followedKey))
        (§ var Script redeemScript = ScriptBuilder.createRedeemScript(§ pars sigsRequiredToSpend, marriedKeys))
        (§ return RedeemData.of(§ pars marriedKeys, redeemScript))
    )

    #_private
    (§ method void addFollowingAccountKeys(§ args List<DeterministicKey> followingAccountKeys, int sigsRequiredToSpend))
    (§ block
        (§ call Preconditions.checkArgument(§ pars sigsRequiredToSpend <= followingAccountKeys.size(§ pars ) + 1, "Multisig threshold can't exceed total number of keys"))
        (§ call Preconditions.checkState(§ pars numLeafKeysIssued(§ pars ) == 0, "Active keychain already has keys in use"))
        (§ call Preconditions.checkState(§ pars followingKeyChains == nil))

        (§ var List<DeterministicKeyChain> followingKeyChains = Lists.newArrayList(§ pars ))

        (§ for (§ var DeterministicKey key) :for (§ expr followingAccountKeys))
        (§ block
            (§ call Preconditions.checkArgument(§ pars key.getPath(§ pars ).size(§ pars ) == getAccountPath(§ pars ).size(§ pars ), "Following keys have to be account keys"))

            (§ var DeterministicKeyChain chain = DeterministicKeyChain.watchAndFollow(§ pars key))
            (§ if (§ expr 0 <= lookaheadSize))
            (§ block
                (§ call chain.setLookaheadSize(§ pars lookaheadSize))
            )
            (§ if (§ expr 0 <= lookaheadThreshold))
            (§ block
                (§ call chain.setLookaheadThreshold(§ pars lookaheadThreshold))
            )
            (§ call followingKeyChains.add(§ pars chain))
        )

        (§ ass this.sigsRequiredToSpend = sigsRequiredToSpend)
        (§ ass this.followingKeyChains = followingKeyChains)
    )

    #_override
    #_public
    (§ method void setLookaheadSize(§ args int lookaheadSize))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call super.setLookaheadSize(§ pars lookaheadSize))

            (§ if (§ expr followingKeyChains != nil))
            (§ block
                (§ for (§ var DeterministicKeyChain followingChain) :for (§ expr followingKeyChains))
                (§ block
                    (§ call followingChain.setLookaheadSize(§ pars lookaheadSize))
                )
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method List<Protos.Key> serializeToProtobuf(§ args ))
    (§ block
        (§ var List<Protos.Key> result = newArrayList(§ pars ))
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ for (§ var DeterministicKeyChain chain) :for (§ expr followingKeyChains))
            (§ block
                (§ call result.addAll(§ pars chain.serializeMyselfToProtobuf(§ pars )))
            )
            (§ call result.addAll(§ pars serializeMyselfToProtobuf(§ pars )))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
        (§ return result)
    )

    #_override
    #_protected
    (§ method void formatAddresses(§ args boolean includePrivateKeys, NetworkParameters params, StringBuilder sb))
    (§ block
        (§ for (§ var DeterministicKeyChain followingChain) :for (§ expr followingKeyChains))
        (§ block
            (§ call sb.append(§ pars "Following chain:  ").append(§ pars followingChain.getWatchingKey(§ pars ).serializePubB58(§ pars params)).append(§ pars "\n"))
        )
        (§ call sb.append(§ pars "\n"))
        (§ for (§ var RedeemData redeemData) :for (§ expr marriedKeysRedeemData.values(§ pars )))
        (§ block
            (§ call formatScript(§ pars ScriptBuilder.createP2SHOutputScript(§ pars redeemData.redeemScript), sb, params))
        )
    )

    #_private
    (§ method void formatScript(§ args Script script, StringBuilder sb, NetworkParameters params))
    (§ block
        (§ call sb.append(§ pars "  addr:").append(§ pars script.getToAddress(§ pars params)))
        (§ call sb.append(§ pars "  hash160:").append(§ pars Utils.HEX.encode(§ pars script.getPubKeyHash(§ pars ))))
        (§ if (§ expr 0 < script.getCreationTimeSeconds(§ pars )))
        (§ block
            (§ call sb.append(§ pars "  creationTimeSeconds:").append(§ pars script.getCreationTimeSeconds(§ pars )))
        )
        (§ call sb.append(§ pars "\n"))
    )

    #_override
    #_public
    (§ method void maybeLookAheadScripts(§ args ))
    (§ block
        (§ call super.maybeLookAheadScripts(§ pars ))

        (§ var int numLeafKeys = getLeafKeys(§ pars ).size(§ pars ))
        (§ call Preconditions.checkState(§ pars marriedKeysRedeemData.size(§ pars ) <= numLeafKeys, "Number of scripts is greater than number of leaf keys"))

        (§ if (§ expr marriedKeysRedeemData.size(§ pars ) != numLeafKeys))
        (§ block
            (§ call maybeLookAhead(§ pars ))
            (§ for (§ var DeterministicKey followedKey) :for (§ expr getLeafKeys(§ pars )))
            (§ block
                (§ var RedeemData redeemData = getRedeemData(§ pars followedKey))
                (§ var Script scriptPubKey = ScriptBuilder.createP2SHOutputScript(§ pars redeemData.redeemScript))
                (§ call marriedKeysRedeemData.put(§ pars ByteString.copyFrom(§ pars scriptPubKey.getPubKeyHash(§ pars )), redeemData))
            )
        )
    )

    #_nilable
    #_override
    #_public
    (§ method RedeemData findRedeemDataByScriptHash(§ args ByteString bytes))
    (§ block
        (§ return marriedKeysRedeemData.get(§ pars bytes))
    )

    #_override
    #_public
    (§ method BloomFilter getFilter(§ args int size, double falsePositiveRate, long tweak))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ var BloomFilter filter)
        (§ try )
        (§ block
            (§ ass filter = new BloomFilter(§ pars size, falsePositiveRate, tweak))
            (§ for (§ var Map.Entry<ByteString, RedeemData> entry) :for (§ expr marriedKeysRedeemData.entrySet(§ pars )))
            (§ block
                (§ call filter.insert(§ pars entry.getKey(§ pars ).toByteArray(§ pars )))
                (§ call filter.insert(§ pars entry.getValue(§ pars ).redeemScript.getProgram(§ pars )))
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
        (§ return filter)
    )

    #_override
    #_public
    (§ method int numBloomFilterEntries(§ args ))
    (§ block
        (§ call maybeLookAhead(§ pars ))
        (§ return getLeafKeys(§ pars ).size(§ pars ) * 2)
    )
)

#_(ns org.bitcoinj.wallet #_"RedeemData"
    (:import [java.util ArrayList Collections List])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.core ECKey]
             [org.bitcoinj.script Script]))

;;;
 ; This class aggregates data required to spend transaction output.
 ;
 ; For pay-to-address and pay-to-pubkey transactions it will have only a single key and CHECKSIG program as redeemScript.
 ; For multisignature transactions there will be multiple keys one of which will be a full key and the rest are watch only,
 ; redeem script will be a CHECKMULTISIG program.  Keys will be sorted in the same order they appear in
 ; a program (lexicographical order).
 ;;
#_public
(§ class RedeemData
    #_public
    #_final
    (§ field Script redeemScript)
    #_public
    #_final
    (§ field List<ECKey> keys)

    #_private
    (§ constructor RedeemData(§ args List<ECKey> keys, Script redeemScript))
    (§ block
        (§ ass this.redeemScript = redeemScript)
        (§ var List<ECKey> sortedKeys = new ArrayList<>(§ pars keys))
        (§ call Collections.sort(§ pars sortedKeys, ECKey.PUBKEY_COMPARATOR))
        (§ ass this.keys = sortedKeys)
    )

    #_public
    #_static
    (§ method RedeemData of(§ args List<ECKey> keys, Script redeemScript))
    (§ block
        (§ return (§ new RedeemData(§ pars keys, redeemScript)))
    )

    ;;;
     ; Creates RedeemData for pay-to-address or pay-to-pubkey input.  Provided key is a single private key
     ; needed to spend such inputs and provided program should be a proper CHECKSIG program.
     ;;
    #_public
    #_static
    (§ method RedeemData of(§ args ECKey key, Script program))
    (§ block
        (§ call Preconditions.checkArgument(§ pars program.isSentToAddress(§ pars ) || program.isSentToRawPubKey(§ pars )))

        (§ return (§ expr key != nil) ? new RedeemData(§ pars Collections.singletonList(§ pars key), program) :else nil)
    )

    ;;;
     ; Returns the first key that has private bytes.
     ;;
    #_public
    (§ method ECKey getFullKey(§ args ))
    (§ block
        (§ for (§ var ECKey key) :for (§ expr keys))
        (§ block
            (§ if (§ expr key.hasPrivKey(§ pars )))
            (§ block
                (§ return key)
            )
        )
        (§ return nil)
    )
)

#_(ns org.bitcoinj.wallet #_"RiskAnalysis"
    (:import [java.util List])
   (:require [org.bitcoinj.core Transaction]))

;;;
 ; <p>A RiskAnalysis represents an analysis of how likely it is that a transaction (and its dependencies)
 ; represents a possible double spending attack.  The wallet will create these to decide whether or not to accept
 ; a pending transaction.  Look at {@link DefaultRiskAnalysis} to see what is currently considered risky.</p>
 ;
 ; <p>The intention here is that implementing classes can expose more information and detail about the result,
 ; for app developers.  The core code needs only to know whether it's OK or not.</p>
 ;
 ; <p>A factory interface is provided.  The wallet will use this to analyze new pending transactions.</p>
 ;;
#_public
(§ interface RiskAnalysis
    (§ enum Result
        (§ item OK)
        (§ item NON_FINAL)
        (§ item NON_STANDARD)
    )

    (§ method Result analyze(§ args ))

    (§ interface Analyzer
        (§ method RiskAnalysis create(§ args Wallet wallet, Transaction tx, List<Transaction> dependencies))
    )
)

#_(ns org.bitcoinj.wallet #_"SendRequest"
    (:import [java.math BigInteger]
             [java.util Date])
    (:import [com.google.common.base MoreObjects Preconditions]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core Address Coin Context ECKey NetworkParameters Transaction TransactionOutput]
             [org.bitcoinj.script Script ScriptBuilder]
             [org.bitcoinj.utils ExchangeRate]
             [org.bitcoinj.wallet.KeyChain KeyPurpose]
             [org.bitcoinj.wallet.Wallet MissingSigsMode]))

;;;
 ; A SendRequest gives the wallet information about precisely how to send money to a recipient or set of recipients.
 ; Static methods are provided to help you create SendRequests and there are a few helper methods on the wallet that
 ; just simplify the most common use cases.  You may wish to customize a SendRequest if you want to attach a fee or
 ; modify the change address.
 ;;
#_public
(§ class SendRequest
    ;;;
     ; <p>A transaction, probably incomplete, that describes the outline of what you want to do.  This typically
     ; will mean it has some outputs to the intended destinations, but no inputs or change address (and therefore
     ; no fees) - the wallet will calculate all that for you and update tx later.</p>
     ;
     ; <p>Be careful when adding outputs that you check the min output value
     ; ({@link TransactionOutput#getMinNonDustValue(Coin)}) to avoid the whole transaction being rejected
     ; because one output is dust.</p>
     ;
     ; <p>If there are already inputs to the transaction, make sure their out point has a connected output,
     ; otherwise their value will be added to fee.  Also ensure they are either signed or are spendable by
     ; a wallet key, otherwise the behavior of {@link Wallet#completeTx(Wallet.SendRequest)} is undefined
     ; (likely RuntimeException).</p>
     ;;
    #_public
    (§ field Transaction tx)

    ;;;
     ; When emptyWallet is set, all coins selected by the coin selector are sent to the first output in tx
     ; (its value is ignored and set to {@link org.bitcoinj.wallet.Wallet#getBalance()} - the fees required
     ; for the transaction).  Any additional outputs are removed.
     ;;
    #_public
    (§ field boolean emptyWallet = false)

    ;;;
     ; "Change" means the difference between the value gathered by a transactions inputs (the size of which you
     ; don't really control as it depends on who sent you money), and the value being sent somewhere else.  The
     ; change address should be selected from this wallet, normally.  <b>If null this will be chosen for you.</b>
     ;;
    #_public
    (§ field Address changeAddress = nil)

    ;;;
     ; <p>A transaction can have a fee attached, which is defined as the difference between the input values
     ; and output values.  Any value taken in that is not provided to an output can be claimed by a miner.  This
     ; is how mining is incentivized in later years of the Bitcoin system when inflation drops.  It also provides
     ; a way for people to prioritize their transactions over others and is used as a way to make denial of service
     ; attacks expensive.</p>
     ;
     ; <p>This is a dynamic fee (in satoshis) which will be added to the transaction for each kilobyte in size
     ; including the first.  This is useful as as miners usually sort pending transactions by their fee per unit size
     ; when choosing which transactions to add to a block.  Note that, to keep this equivalent to Bitcoin Core
     ; definition, a kilobyte is defined as 1000 bytes, not 1024.</p>
     ;;
    #_public
    (§ field Coin feePerKb = Context.get(§ pars ).getFeePerKb(§ pars ))

    ;;;
     ; <p>Requires that there be enough fee for a default Bitcoin Core to at least relay the transaction.
     ; (i.e. ensure the transaction will not be outright rejected by the network).  Defaults to true,
     ; you should only set this to false if you know what you're doing.</p>
     ;
     ; <p>Note that this does not enforce certain fee rules that only apply to transactions which are larger
     ; than 26,000 bytes.  If you get a transaction which is that large, you should set a feePerKb of at least
     ; {@link Transaction#REFERENCE_DEFAULT_MIN_TX_FEE}.</p>
     ;;
    #_public
    (§ field boolean ensureMinRequiredFee = Context.get(§ pars ).isEnsureMinRequiredFee(§ pars ))

    ;;;
     ; If true (the default), the inputs will be signed.
     ;;
    #_public
    (§ field boolean signInputs = true)

    ;;;
     ; The AES key to use to decrypt the private keys before signing.
     ; If null then no decryption will be performed and if decryption is required an exception will be thrown.
     ; You can get this from a password by doing wallet.getKeyCrypter().deriveKey(password).
     ;;
    #_public
    (§ field KeyParameter aesKey = nil)

    ;;;
     ; If not null, the {@link org.bitcoinj.wallet.CoinSelector} to use instead of the wallets default.
     ; Coin selectors are responsible for choosing which transaction outputs (coins) in a wallet to use given
     ; the desired send value amount.
     ;;
    #_public
    (§ field CoinSelector coinSelector = nil)

    ;;;
     ; If true (the default), the outputs will be shuffled during completion to randomize the location
     ; of the change output, if any.  This is normally what you want for privacy reasons but in unit tests
     ; it can be annoying, so it can be disabled here.
     ;;
    #_public
    (§ field boolean shuffleOutputs = true)

    ;;;
     ; Specifies what to do with missing signatures left after completing this request.  Default strategy is
     ; to throw an exception on missing signature ({@link MissingSigsMode#THROW}).
     ; @see MissingSigsMode
     ;;
    #_public
    (§ field MissingSigsMode missingSigsMode = MissingSigsMode.THROW)

    ;;;
     ; If not null, this exchange rate is recorded with the transaction during completion.
     ;;
    #_public
    (§ field ExchangeRate exchangeRate = nil)

    ;;;
     ; If not null, this memo is recorded with the transaction during completion.  It can be used to record
     ; the memo of the payment request that initiated the transaction.
     ;;
    #_public
    (§ field String memo = nil)

    ;;;
     ; If false (default value), tx fee is paid by the sender.  If true, tx fee is paid by the recipient/s.
     ; If there is more than one recipient, the tx fee is split equally between them regardless of output
     ; value and size.
     ;;
    #_public
    (§ field boolean recipientsPayFees = false)

    ;; Tracks if this has been passed to wallet.completeTx already: just a safety check.
    (§ field boolean completed)

    #_private
    (§ constructor SendRequest(§ args ))
    (§ block
    )

    ;;;
     ; <p>Creates a new SendRequest to the given address for the given value.</p>
     ;
     ; <p>Be very careful when value is smaller than {@link Transaction#MIN_NONDUST_OUTPUT} as the transaction
     ; will likely be rejected by the network in this case.</p>
     ;;
    #_public
    #_static
    (§ method SendRequest to(§ args Address destination, Coin value))
    (§ block
        (§ var SendRequest req = new SendRequest(§ pars ))
        #_final
        (§ var NetworkParameters parameters = destination.getParameters(§ pars ))

        (§ call Preconditions.checkNotNull(§ pars parameters, "Address is for an unknown network"))

        (§ ass req.tx = new Transaction(§ pars parameters))
        (§ call req.tx.addOutput(§ pars value, destination))
        (§ return req)
    )

    ;;;
     ; <p>Creates a new SendRequest to the given pubkey for the given value.</p>
     ;
     ; <p>Be careful to check the output's value is reasonable using
     ; {@link TransactionOutput#getMinNonDustValue(Coin)} afterwards or you risk having the transaction
     ; rejected by the network.  Note that using {@link SendRequest#to(Address, Coin)} will result
     ; in a smaller output, and thus the ability to use a smaller output value without rejection.</p>
     ;;
    #_public
    #_static
    (§ method SendRequest to(§ args NetworkParameters params, ECKey destination, Coin value))
    (§ block
        (§ var SendRequest req = new SendRequest(§ pars ))
        (§ ass req.tx = new Transaction(§ pars params))
        (§ call req.tx.addOutput(§ pars value, destination))
        (§ return req)
    )

    ;;; Simply wraps a pre-built incomplete transaction provided by you. ;;
    #_public
    #_static
    (§ method SendRequest forTx(§ args Transaction tx))
    (§ block
        (§ var SendRequest req = new SendRequest(§ pars ))
        (§ ass req.tx = tx)
        (§ return req)
    )

    #_public
    #_static
    (§ method SendRequest emptyWallet(§ args Address destination))
    (§ block
        (§ var SendRequest req = new SendRequest(§ pars ))
        #_final
        (§ var NetworkParameters parameters = destination.getParameters(§ pars ))

        (§ call Preconditions.checkNotNull(§ pars parameters, "Address is for an unknown network"))

        (§ ass req.tx = new Transaction(§ pars parameters))
        (§ call req.tx.addOutput(§ pars Coin.ZERO, destination))
        (§ ass req.emptyWallet = true)
        (§ return req)
    )

    ;;;
     ; Construct a SendRequest for a CPFP (child-pays-for-parent) transaction.  The resulting transaction is
     ; already completed, so you should directly proceed to signing and broadcasting/committing the transaction.
     ; CPFP is currently only supported by a few miners, so use with care.
     ;;
    #_public
    #_static
    (§ method SendRequest childPaysForParent(§ args Wallet wallet, Transaction parentTransaction, Coin feeRaise))
    (§ block
        (§ var TransactionOutput outputToSpend = nil)
        (§ for (§ var #_final TransactionOutput output) :for (§ expr parentTransaction.getOutputs(§ pars )))
        (§ block
            (§ if (§ expr output.isMine(§ pars wallet) && output.isAvailableForSpending(§ pars ) && output.getValue(§ pars ).isGreaterThan(§ pars feeRaise)))
            (§ block
                (§ ass outputToSpend = output)
                (§ break )
            )
        )
        ;; TODO: Spend another confirmed output of own wallet if needed.
        (§ call Preconditions.checkNotNull(§ pars outputToSpend, "Can't find adequately sized output that spends to us"))

        #_final
        (§ var Transaction tx = new Transaction(§ pars parentTransaction.getParams(§ pars )))
        (§ call tx.addInput(§ pars outputToSpend))
        (§ call tx.addOutput(§ pars outputToSpend.getValue(§ pars ).subtract(§ pars feeRaise), wallet.freshAddress(§ pars KeyPurpose.CHANGE)))
        (§ call tx.setPurpose(§ pars Transaction.Purpose.RAISE_FEE))
        #_final
        (§ var SendRequest req = forTx(§ pars tx))
        (§ ass req.completed = true)
        (§ return req)
    )

    #_public
    #_static
    (§ method SendRequest toCLTVPaymentChannel(§ args NetworkParameters params, Date releaseTime, ECKey from, ECKey to, Coin value))
    (§ block
        (§ var long time = releaseTime.getTime(§ pars ) / 1000)

        (§ call Preconditions.checkArgument(§ pars Transaction.LOCKTIME_THRESHOLD <= time, "Release time was too small"))

        (§ return toCLTVPaymentChannel(§ pars params, BigInteger.valueOf(§ pars time), from, to, value))
    )

    #_public
    #_static
    (§ method SendRequest toCLTVPaymentChannel(§ args NetworkParameters params, int releaseBlock, ECKey from, ECKey to, Coin value))
    (§ block
        (§ call Preconditions.checkArgument(§ pars 0 <= releaseBlock && releaseBlock < Transaction.LOCKTIME_THRESHOLD, "Block number was too large"))

        (§ return toCLTVPaymentChannel(§ pars params, BigInteger.valueOf(§ pars releaseBlock), from, to, value))
    )

    #_public
    #_static
    (§ method SendRequest toCLTVPaymentChannel(§ args NetworkParameters params, BigInteger time, ECKey from, ECKey to, Coin value))
    (§ block
        (§ var SendRequest req = new SendRequest(§ pars ))
        (§ var Script output = ScriptBuilder.createCLTVPaymentChannelOutput(§ pars time, from, to))
        (§ ass req.tx = new Transaction(§ pars params))
        (§ call req.tx.addOutput(§ pars value, output))
        (§ return req)
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        ;; Print only the user-settable fields.
        (§ var MoreObjects.ToStringHelper helper = MoreObjects.toStringHelper(§ pars this).omitNullValues(§ pars ))
        (§ call helper.add(§ pars "emptyWallet", emptyWallet))
        (§ call helper.add(§ pars "changeAddress", changeAddress))
        (§ call helper.add(§ pars "feePerKb", feePerKb))
        (§ call helper.add(§ pars "ensureMinRequiredFee", ensureMinRequiredFee))
        (§ call helper.add(§ pars "signInputs", signInputs))
        (§ call helper.add(§ pars "aesKey", (§ expr aesKey != nil) ? "set" :else nil)) ;; Careful to not leak the key.
        (§ call helper.add(§ pars "coinSelector", coinSelector))
        (§ call helper.add(§ pars "shuffleOutputs", shuffleOutputs))
        (§ call helper.add(§ pars "recipientsPayFees", recipientsPayFees))
        (§ return helper.toString(§ pars ))
    )
)

#_(ns org.bitcoinj.wallet #_"UnreadableWalletException")

;;;
 ; Thrown by the {@link WalletProtobufSerializer} when the serialized protocol buffer is either corrupted,
 ; internally inconsistent or appears to be from the future.
 ;;
#_public
(§ class UnreadableWalletException extends Exception
    #_public
    (§ constructor UnreadableWalletException(§ args String s))
    (§ block
        (§ super (§ pars s))
    )

    #_public
    (§ constructor UnreadableWalletException(§ args String s, Throwable t))
    (§ block
        (§ super (§ pars s, t))
    )

    #_public
    #_static
    (§ class BadPassword extends UnreadableWalletException
        #_public
        (§ constructor BadPassword(§ args ))
        (§ block
            (§ super (§ pars "Password incorrect"))
        )
    )

    #_public
    #_static
    (§ class FutureVersion extends UnreadableWalletException
        #_public
        (§ constructor FutureVersion(§ args ))
        (§ block
            (§ super (§ pars "Unknown wallet version from the future."))
        )
    )

    #_public
    #_static
    (§ class WrongNetwork extends UnreadableWalletException
        #_public
        (§ constructor WrongNetwork(§ args ))
        (§ block
            (§ super (§ pars "Mismatched network ID"))
        )
    )
)

#_(ns org.bitcoinj.wallet #_"Wallet"
    (:import [java.io *]
             [java.math BigInteger]
             [java.util *]
             [java.util.concurrent *]
             [java.util.concurrent.atomic *]
             [java.util.concurrent.locks *])
    (:import [com.google.common.annotations *]
             [com.google.common.base *]
             [com.google.common.collect *]
             [com.google.common.primitives *]
             [com.google.common.util.concurrent *]
             [com.google.protobuf *]
             [net.jcip.annotations *]
             [org.slf4j *]
             [org.spongycastle.crypto.params *])
   (:require [org.bitcoinj.core AbstractBlockChain Address BlockChain BloomFilter Coin Context ECKey FilteredBlock InsufficientMoneyException Message NetworkParameters Peer PeerFilterProvider PeerGroup ScriptException Sha256Hash StoredBlock Transaction TransactionBag TransactionBroadcast TransactionBroadcaster TransactionConfidence TransactionInput TransactionOutPoint TransactionOutput UTXO Utils VarInt VerificationException]
             [org.bitcoinj.core.TransactionConfidence *]
             [org.bitcoinj.core.listeners *]
             [org.bitcoinj.crypto *]
             [org.bitcoinj.script *]
             [org.bitcoinj.signers *]
             [org.bitcoinj.utils *]
             [org.bitcoinj.wallet.Protos.Wallet *]
             [org.bitcoinj.wallet.WalletTransaction *]
             [org.bitcoinj.wallet.listeners KeyChainEventListener WalletChangeEventListener WalletCoinsReceivedEventListener WalletCoinsSentEventListener WalletReorganizeEventListener]))

;; To do list:
;;
;; - Take all wallet-relevant data out of Transaction and put it into WalletTransaction.  Make Transaction immutable.
;; - Only store relevant transaction outputs, don't bother storing the rest of the data.  Big RAM saving.
;; - Split block chain and tx output tracking into a superclass that doesn't have any key or spending related code.
;; - Simplify how transactions are tracked and stored: in particular, have the wallet maintain positioning information
;;   for transactions independent of the transactions themselves, so the timeline can be walked without having to
;;   process and sort every single transaction.
;; - Split data persistence out into a backend class and make the wallet transactional, so we can store a wallet
;;   in a database not just in RAM.
;; - Make clearing of transactions able to only rewind the wallet a certain distance instead of all blocks.
;; - Make it scale:
;;     - eliminate all the algorithms with quadratic complexity (or worse).
;;     - don't require everything to be held in RAM at once.
;;     - consider allowing eviction of no longer re-orgable transactions or keys that were used up.
;;
;; Finally, find more ways to break the class up and decompose it.  Currently every time we move code out, other code
;; fills up the lines saved!

;;;
 ; <p>A Wallet stores keys and a record of transactions that send and receive value from those keys.  Using these,
 ; it is able to create new transactions that spend the recorded transactions, and this is the fundamental operation
 ; of the Bitcoin protocol.</p>
 ;
 ; <p>To learn more about this class, read <b><a href="https://bitcoinj.github.io/working-with-the-wallet">working with the wallet.</a></b></p>
 ;
 ; <p>To fill up a Wallet with transactions, you need to use it in combination with a {@link BlockChain} and various
 ; other objects, see the <a href="https://bitcoinj.github.io/getting-started">Getting started</a> tutorial
 ; on the website to learn more about how to set everything up.</p>
 ;
 ; <p>Wallets can be serialized using protocol buffers.  You need to save the wallet whenever it changes, there is an
 ; auto-save feature that simplifies this for you although you're still responsible for manually triggering a save when
 ; your app is about to quit because the auto-save feature waits a moment before actually committing to disk to avoid IO
 ; thrashing when the wallet is changing very fast (e.g. due to a block chain sync).  See
 ; {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, org.bitcoinj.wallet.WalletFiles.Listener)}
 ; for more information about this.</p>
 ;;
#_public
(§ class Wallet implements NewBestBlockListener, TransactionReceivedInBlockListener, PeerFilterProvider, KeyBag, TransactionBag, ReorganizeListener
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars Wallet.class))
    #_private
    #_static
    #_final
    (§ field int MINIMUM_BLOOM_DATA_LENGTH = 8)

    ;; Ordering: lock > keyChainGroupLock.  KeyChainGroup is protected separately to allow fast querying of current receive
    ;; address even if the wallet itself is busy e.g. saving or processing a big reorg.  Useful for reducing UI latency.
    #_protected
    #_final
    (§ field ReentrantLock lock = Threading.lock(§ pars "wallet"))
    #_protected
    #_final
    (§ field ReentrantLock keyChainGroupLock = Threading.lock(§ pars "wallet-keychaingroup"))

    ;; The various pools below give quick access to wallet-relevant transactions by the state they're in:
    ;;
    ;; Pending:  Transactions that didn't make it into the best chain yet.  Pending transactions can be killed if a
    ;;           double spend against them appears in the best chain, in which case they move to the dead pool.
    ;;           If a double spend appears in the pending state as well, we update the confidence type
    ;;           of all txns in conflict to IN_CONFLICT and wait for the miners to resolve the race.
    ;; Unspent:  Transactions that appeared in the best chain and have outputs we can spend.  Note that we store the
    ;;           entire transaction in memory even though for spending purposes we only really need the outputs, the
    ;;           reason being that this simplifies handling of re-orgs.  It would be worth fixing this in future.
    ;; Spent:    Transactions that appeared in the best chain but don't have any spendable outputs.  They're stored
    ;;           here for history browsing/auditing reasons only and in future will probably be flushed out to some
    ;;           other kind of cold storage or just removed.
    ;; Dead:     Transactions that we believe will never confirm get moved here, out of pending.  Note that Bitcoin
    ;;           Core has no notion of dead-ness: the assumption is that double spends won't happen so there's no
    ;;           need to notify the user about them.  We take a more pessimistic approach and try to track the fact
    ;;           that transactions have been double spent so applications can do something intelligent (cancel orders,
    ;;           show to the user in the UI, etc).  A transaction can leave dead and move into spent/unspent if there
    ;;           is a re-org to a chain that doesn't include the double spend.

    #_private
    #_final
    (§ field Map<Sha256Hash, Transaction> pending)
    #_private
    #_final
    (§ field Map<Sha256Hash, Transaction> unspent)
    #_private
    #_final
    (§ field Map<Sha256Hash, Transaction> spent)
    #_private
    #_final
    (§ field Map<Sha256Hash, Transaction> dead)

    ;; All transactions together.
    #_protected
    #_final
    (§ field Map<Sha256Hash, Transaction> transactions)

    ;; All the TransactionOutput objects that we could spend (ignoring whether we have the private key or not).
    ;; Used to speed up various calculations.
    #_protected
    #_final
    (§ field HashSet<TransactionOutput> myUnspents = Sets.newHashSet(§ pars ))

    ;; Transactions that were dropped by the risk analysis system.  These are not in any pools and not serialized
    ;; to disk.  We have to keep them around because if we ignore a tx because we think it will never confirm, but
    ;; then it actually does confirm and does so within the same network session, remote peers will not resend us
    ;; the tx data along with the Bloom filtered block, as they know we already received it once before
    ;; (so it would be wasteful to repeat).  Thus we keep them around here for a while.  If we drop our network
    ;; connections then the remote peers will forget that we were sent the tx data previously and send it again
    ;; when relaying a filtered merkleblock.
    #_private
    #_final
    (§ field LinkedHashMap<Sha256Hash, Transaction> riskDropped = new LinkedHashMap<Sha256Hash, Transaction>(§ pars )
        (§ anon
            #_override
            #_protected
            (§ method boolean removeEldestEntry(§ args Map.Entry<Sha256Hash, Transaction> eldest))
            (§ block
                (§ return (§ expr 1000 < size(§ pars )))
            )
        ))

    ;; The key chain group is not thread safe, and generally the whole hierarchy of objects should not be mutated
    ;; outside the wallet lock.  So don't expose this object directly via any accessors!
    #_guarded-by(§ opt "keyChainGroupLock")
    #_private
    (§ field KeyChainGroup keyChainGroup)

    #_protected
    #_final
    (§ field Context context)
    #_protected
    #_final
    (§ field NetworkParameters params)

    #_nilable
    #_private
    (§ field Sha256Hash lastBlockSeenHash)
    #_private
    (§ field int lastBlockSeenHeight)
    #_private
    (§ field long lastBlockSeenTimeSecs)

    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<WalletChangeEventListener>> changeListeners = new CopyOnWriteArrayList<>(§ pars ))
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<WalletCoinsReceivedEventListener>> coinsReceivedListeners = new CopyOnWriteArrayList<>(§ pars ))
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<WalletCoinsSentEventListener>> coinsSentListeners = new CopyOnWriteArrayList<>(§ pars ))
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<WalletReorganizeEventListener>> reorganizeListeners = new CopyOnWriteArrayList<>(§ pars ))
    #_private
    #_final
    (§ field CopyOnWriteArrayList<ListenerRegistration<TransactionConfidenceEventListener>> transactionConfidenceListeners = new CopyOnWriteArrayList<>(§ pars ))

    ;; A listener that relays confidence changes from the transaction confidence object to the wallet event listener,
    ;; as a convenience to API users so they don't have to register on every transaction themselves.
    #_private
    (§ field TransactionConfidence.Listener txConfidenceListener)

    ;; If a TX hash appears in this set then notifyNewBestBlock will ignore it, as its confidence was already set up
    ;; in receive() via Transaction.setBlockAppearance().  As the BlockChain always calls notifyNewBestBlock even if
    ;; it sent transactions to the wallet, without this we'd double count.
    #_private
    (§ field HashSet<Sha256Hash> ignoreNextNewBlock)
    ;; Whether or not to ignore pending transactions that are considered risky by the configured risk analyzer.
    #_private
    (§ field boolean acceptRiskyTransactions)
    ;; Object that performs risk analysis of pending transactions.  We might reject transactions that seem like
    ;; a high risk of being a double spending attack.
    #_private
    (§ field RiskAnalysis.Analyzer riskAnalyzer = DefaultRiskAnalysis.FACTORY)

    ;; Stuff for notifying transaction objects that we changed their confidences.  The purpose of this is to avoid
    ;; spuriously sending lots of repeated notifications to listeners that API users aren't really interested in as
    ;; a side effect of how the code is written (e.g. during re-orgs confidence data gets adjusted multiple times).
    #_private
    (§ field int onWalletChangedSuppressions)
    #_private
    (§ field boolean insideReorg)
    #_private
    (§ field Map<Transaction, TransactionConfidence.Listener.ChangeReason> confidenceChanged)
    #_protected
    #_volatile
    (§ field WalletFiles vFileManager)
    ;; Object that is used to send transactions asynchronously when the wallet requires it.
    #_protected
    #_volatile
    (§ field TransactionBroadcaster vTransactionBroadcaster)
    ;; UNIX time in seconds.  Money controlled by keys created before this time will be automatically respent to
    ;; a key that was created after it.  Useful when you believe some keys have been compromised.
    #_private
    #_volatile
    (§ field long vKeyRotationTimestamp)

    #_protected
    (§ field CoinSelector coinSelector = new DefaultCoinSelector(§ pars ))

    ;; The wallet version.  This is an int that can be used to track breaking changes in the wallet format.
    ;; You can also use it to detect wallets that come from the future (i.e. they contain features you
    ;; do not know how to deal with).
    #_private
    (§ field int version)
    ;; User-provided description that may help people keep track of what a wallet is for.
    #_private
    (§ field String description)

    ;; Objects that perform transaction signing.  Applied subsequently one after another.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field List<TransactionSigner> signers)

    ;;;
     ; Creates a new, empty wallet with a randomly chosen seed and no transactions.  Make sure to provide for
     ; sufficient backup!  Any keys will be derived from the seed.  If you want to restore a wallet from disk
     ; instead, see {@link #loadFromFile}.
     ;;
    #_public
    (§ constructor Wallet(§ args NetworkParameters params))
    (§ block
        (§ this (§ pars Context.getOrCreate(§ pars params)))
    )

    ;;;
     ; Creates a new, empty wallet with a randomly chosen seed and no transactions.  Make sure to provide for
     ; sufficient backup!  Any keys will be derived from the seed.  If you want to restore a wallet from disk
     ; instead, see {@link #loadFromFile}.
     ;;
    #_public
    (§ constructor Wallet(§ args Context context))
    (§ block
        (§ this (§ pars context, new KeyChainGroup(§ pars context.getParams(§ pars ))))
    )

    #_public
    #_static
    (§ method Wallet fromSeed(§ args NetworkParameters params, DeterministicSeed seed))
    (§ block
        (§ return (§ new Wallet(§ pars params, new KeyChainGroup(§ pars params, seed))))
    )

    ;;;
     ; Creates a wallet that tracks payments to and from the HD key hierarchy rooted by the given watching key.
     ; A watching key corresponds to account zero in the recommended BIP32 key hierarchy.
     ;;
    #_public
    #_static
    (§ method Wallet fromWatchingKey(§ args NetworkParameters params, DeterministicKey watchKey))
    (§ block
        (§ return (§ new Wallet(§ pars params, new KeyChainGroup(§ pars params, watchKey))))
    )

    ;;;
     ; Creates a wallet that tracks payments to and from the HD key hierarchy rooted by the given watching key.
     ; A watching key corresponds to account zero in the recommended BIP32 key hierarchy.  The key is specified
     ; in base58 notation and the creation time of the key.  If you don't know the creation time, you can pass
     ; {@link DeterministicHierarchy#BIP32_STANDARDISATION_TIME_SECS}.
     ;;
    #_public
    #_static
    (§ method Wallet fromWatchingKeyB58(§ args NetworkParameters params, String watchKeyB58, long creationTimeSeconds))
    (§ block
        #_final
        (§ var DeterministicKey watchKey = DeterministicKey.deserializeB58(§ pars nil, watchKeyB58, params))
        (§ call watchKey.setCreationTimeSeconds(§ pars creationTimeSeconds))
        (§ return fromWatchingKey(§ pars params, watchKey))
    )

    ;;;
     ; Creates a wallet containing a given set of keys.  All further keys will be derived from the oldest key.
     ;;
    #_public
    #_static
    (§ method Wallet fromKeys(§ args NetworkParameters params, List<ECKey> keys))
    (§ block
        (§ for (§ var ECKey key) :for (§ expr keys))
        (§ block
            (§ call Preconditions.checkArgument(§ pars !(§ expr key instanceof DeterministicKey)))
        )

        (§ var KeyChainGroup group = new KeyChainGroup(§ pars params))
        (§ call group.importKeys(§ pars keys))
        (§ return (§ new Wallet(§ pars params, group)))
    )

    #_public
    (§ constructor Wallet(§ args NetworkParameters params, KeyChainGroup keyChainGroup))
    (§ block
        (§ this (§ pars Context.getOrCreate(§ pars params), keyChainGroup))
    )

    #_private
    (§ constructor Wallet(§ args Context context, KeyChainGroup keyChainGroup))
    (§ block
        (§ ass this.context = context)
        (§ ass this.params = context.getParams(§ pars ))
        (§ ass this.keyChainGroup = Preconditions.checkNotNull(§ pars keyChainGroup))
        (§ if (§ expr params.getId(§ pars ).equals(§ pars NetworkParameters.ID_UNITTESTNET)))
        (§ block
            (§ call this.keyChainGroup.setLookaheadSize(§ pars 5)) ;; Cut down excess computation for unit tests.
        )
        ;; If this keyChainGroup was created fresh just now (new wallet), make HD so a backup can be made immediately
        ;; without having to call current/freshReceiveKey.  If there are already keys in the chain of any kind then
        ;; we're probably being deserialized so leave things alone: the API user can upgrade later.
        (§ if (§ expr this.keyChainGroup.numKeys(§ pars ) == 0))
        (§ block
            (§ call this.keyChainGroup.createAndActivateNewHDChain(§ pars ))
        )
        (§ ass unspent = new HashMap<>(§ pars ))
        (§ ass spent = new HashMap<>(§ pars ))
        (§ ass pending = new HashMap<>(§ pars ))
        (§ ass dead = new HashMap<>(§ pars ))
        (§ ass transactions = new HashMap<>(§ pars ))
        ;; Use a linked hash map to ensure ordering of event listeners is correct.
        (§ ass confidenceChanged = new LinkedHashMap<>(§ pars ))
        (§ ass signers = new ArrayList<>(§ pars ))
        (§ call addTransactionSigner(§ pars (§ new LocalTransactionSigner(§ pars ))))
        (§ call createTransientState(§ pars ))
    )

    #_private
    (§ method void createTransientState(§ args ))
    (§ block
        (§ ass ignoreNextNewBlock = new HashSet<>(§ pars ))
        (§ ass txConfidenceListener = new TransactionConfidence.Listener(§ pars )
        (§ anon
            #_override
            #_public
            (§ method void onConfidenceChanged(§ args TransactionConfidence confidence, TransactionConfidence.Listener.ChangeReason reason))
            (§ block
                ;; This will run on the user code thread so we shouldn't do anything too complicated here.
                ;; We only want to queue a wallet changed event and auto-save if the number of peers announcing
                ;; the transaction has changed, as that confidence change is made by the networking code which
                ;; doesn't necessarily know at that point which wallets contain which transactions, so it's up
                ;; to us to listen for that.  Other types of confidence changes (type, etc.) are triggered by us,
                ;; so we'll queue up a wallet change event in other parts of the code.
                (§ if (§ expr reason == ChangeReason.SEEN_PEERS))
                (§ block
                    (§ call lock.lock(§ pars ))
                    (§ try )
                    (§ block
                        (§ call checkBalanceFuturesLocked(§ pars nil))
                        (§ var Transaction tx = getTransaction(§ pars confidence.getTransactionHash(§ pars )))
                        (§ call queueOnTransactionConfidenceChanged(§ pars tx))
                        (§ call maybeQueueOnWalletChanged(§ pars ))
                    )
                    (§ finally )
                    (§ block
                        (§ call lock.unlock(§ pars ))
                    )
                )
            )
        ))
        (§ ass acceptRiskyTransactions = false)
    )

    #_public
    (§ method NetworkParameters getNetworkParameters(§ args ))
    (§ block
        (§ return params)
    )

    ;;;
     ; Gets the active keychain via {@link KeyChainGroup#getActiveKeyChain()}.
     ;;
    #_public
    (§ method DeterministicKeyChain getActiveKeyChain(§ args ))
    (§ block
        (§ return keyChainGroup.getActiveKeyChain(§ pars ))
    )

    ;;;
     ; <p>Adds given transaction signer to the list of signers.  It will be added to the end of the signers list,
     ; so if this wallet already has some signers added, given signer will be executed after all of them.</p>
     ; <p>Transaction signer should be fully initialized before adding to the wallet, otherwise
     ; {@link IllegalStateException} will be thrown</p>
     ;;
    #_public
    #_final
    (§ method void addTransactionSigner(§ args TransactionSigner signer))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr signer.isReady(§ pars )))
            (§ block
                (§ call signers.add(§ pars signer))
            )
            (§ else )
            (§ block
                (§ throw (§ new IllegalStateException(§ pars "Signer instance is not ready to be added into Wallet: " + signer.getClass(§ pars ))))
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_public
    (§ method List<TransactionSigner> getTransactionSigners(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return ImmutableList.copyOf(§ pars signers))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a key that hasn't been seen in a transaction yet, and which is suitable for displaying
     ; in a wallet user interface as "a convenient key to receive funds on" when the purpose parameter
     ; is {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS}.  The returned key is stable
     ; until it's actually seen in a pending or confirmed transaction, at which point this method will
     ; start returning a different key (for each purpose independently).
     ;;
    #_public
    (§ method DeterministicKey currentKey(§ args KeyChain.KeyPurpose purpose))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call maybeUpgradeToHD(§ pars ))
            (§ return keyChainGroup.currentKey(§ pars purpose))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; An alias for calling {@link #currentKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
    #_public
    (§ method DeterministicKey currentReceiveKey(§ args ))
    (§ block
        (§ return currentKey(§ pars KeyChain.KeyPurpose.RECEIVE_FUNDS))
    )

    ;;;
     ; Returns address for a {@link #currentKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)}.
     ;;
    #_public
    (§ method Address currentAddress(§ args KeyChain.KeyPurpose purpose))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call maybeUpgradeToHD(§ pars ))
            (§ return keyChainGroup.currentAddress(§ pars purpose))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; An alias for calling {@link #currentAddress(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
    #_public
    (§ method Address currentReceiveAddress(§ args ))
    (§ block
        (§ return currentAddress(§ pars KeyChain.KeyPurpose.RECEIVE_FUNDS))
    )

    ;;;
     ; Returns a key that has not been returned by this method before (fresh).  You can think of this
     ; as being a newly created key, although the notion of "create" is not really valid for a
     ; {@link org.bitcoinj.wallet.DeterministicKeyChain}.  When the parameter is
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} the returned key is suitable for
     ; being put into a receive coins wizard type UI.  You should use this when the user is definitely
     ; going to hand this key out to someone who wishes to send money.
     ;;
    #_public
    (§ method DeterministicKey freshKey(§ args KeyChain.KeyPurpose purpose))
    (§ block
        (§ return freshKeys(§ pars purpose, 1).get(§ pars 0))
    )

    ;;;
     ; Returns a key/s that has not been returned by this method before (fresh).  You can think of this
     ; as being a newly created key/s, although the notion of "create" is not really valid for a
     ; {@link org.bitcoinj.wallet.DeterministicKeyChain}.  When the parameter is
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} the returned key is suitable for
     ; being put into a receive coins wizard type UI. You should use this when the user is definitely
     ; going to hand this key/s out to someone who wishes to send money.
     ;;
    #_public
    (§ method List<DeterministicKey> freshKeys(§ args KeyChain.KeyPurpose purpose, int numberOfKeys))
    (§ block
        (§ var List<DeterministicKey> keys)
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call maybeUpgradeToHD(§ pars ))
            (§ ass keys = keyChainGroup.freshKeys(§ pars purpose, numberOfKeys))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
        ;; Do we really need an immediate hard save?  Arguably all this is doing is saving the 'current' key
        ;; and that's not quite so important, so we could coalesce for more performance.
        (§ call saveNow(§ pars ))
        (§ return keys)
    )

    ;;;
     ; An alias for calling {@link #freshKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
    #_public
    (§ method DeterministicKey freshReceiveKey(§ args ))
    (§ block
        (§ return freshKey(§ pars KeyChain.KeyPurpose.RECEIVE_FUNDS))
    )

    ;;;
     ; Returns address for a {@link #freshKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)}.
     ;;
    #_public
    (§ method Address freshAddress(§ args KeyChain.KeyPurpose purpose))
    (§ block
        (§ var Address key)
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass key = keyChainGroup.freshAddress(§ pars purpose))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
        (§ call saveNow(§ pars ))
        (§ return key)
    )

    ;;;
     ; An alias for calling {@link #freshAddress(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
    #_public
    (§ method Address freshReceiveAddress(§ args ))
    (§ block
        (§ return freshAddress(§ pars KeyChain.KeyPurpose.RECEIVE_FUNDS))
    )

    ;;;
     ; Returns only the keys that have been issued by {@link #freshReceiveKey()}, {@link #freshReceiveAddress()},
     ; {@link #currentReceiveKey()} or {@link #currentReceiveAddress()}.
     ;;
    #_public
    (§ method List<ECKey> getIssuedReceiveKeys(§ args ))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return keyChainGroup.getActiveKeyChain(§ pars ).getIssuedReceiveKeys(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns only the addresses that have been issued by {@link #freshReceiveKey()}, {@link #freshReceiveAddress()},
     ; {@link #currentReceiveKey()} or {@link #currentReceiveAddress()}.
     ;;
    #_public
    (§ method List<Address> getIssuedReceiveAddresses(§ args ))
    (§ block
        #_final
        (§ var List<ECKey> keys = getIssuedReceiveKeys(§ pars ))
        (§ var List<Address> addresses = new ArrayList<>(§ pars keys.size(§ pars )))
        (§ for (§ var ECKey key) :for (§ expr keys))
        (§ block
            (§ call addresses.add(§ pars key.toAddress(§ pars getParams(§ pars ))))
        )
        (§ return addresses)
    )

    ;;;
     ; Upgrades the wallet to be deterministic (BIP32).  You should call this, possibly providing the users encryption
     ; key, after loading a wallet produced by previous versions of bitcoinj.  If the wallet is encrypted the key
     ; <b>must</b> be provided, due to the way the seed is derived deterministically from private key bytes: failing
     ; to do this will result in an exception being thrown.  For non-encrypted wallets, the upgrade will be done for
     ; you automatically the first time a new key is requested (this happens when spending due to the change address).
     ;;
    #_public
    (§ method void upgradeToDeterministic(§ args #_nilable KeyParameter aesKey))
        (§ throws DeterministicUpgradeRequiresPassword)
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call keyChainGroup.upgradeToDeterministic(§ pars vKeyRotationTimestamp, aesKey))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns true if the wallet contains random keys and no HD chains, in which case you should call
     ; {@link #upgradeToDeterministic(org.spongycastle.crypto.params.KeyParameter)} before attempting
     ; to do anything that would require a new address or key.
     ;;
    #_public
    (§ method boolean isDeterministicUpgradeRequired(§ args ))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return keyChainGroup.isDeterministicUpgradeRequired(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    #_private
    (§ method void maybeUpgradeToHD(§ args ))
        (§ throws DeterministicUpgradeRequiresPassword)
    (§ block
        (§ call maybeUpgradeToHD(§ pars nil))
    )

    #_guarded-by(§ opt "keyChainGroupLock")
    #_private
    (§ method void maybeUpgradeToHD(§ args #_nilable KeyParameter aesKey))
        (§ throws DeterministicUpgradeRequiresPassword)
    (§ block
        (§ call Preconditions.checkState(§ pars keyChainGroupLock.isHeldByCurrentThread(§ pars )))
        (§ if (§ expr keyChainGroup.isDeterministicUpgradeRequired(§ pars )))
        (§ block
            (§ call log.info(§ pars "Upgrade to HD wallets is required, attempting to do so."))
            (§ try )
            (§ block
                (§ call upgradeToDeterministic(§ pars aesKey))
            )
            (§ catch (§ args DeterministicUpgradeRequiresPassword e))
            (§ block
                (§ call log.error(§ pars "Failed to auto upgrade due to encryption. You should call wallet.upgradeToDeterministic with the users AES key to avoid this error."))
                (§ throw e)
            )
        )
    )

    ;;;
     ; Removes the given key from the basicKeyChain.  Be very careful with this - losing a private key
     ; <b>destroys the money associated with it</b>.
     ; @return whether the key was removed or not.
     ;;
    #_public
    (§ method boolean removeKey(§ args ECKey key))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return keyChainGroup.removeImportedKey(§ pars key))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the number of keys in the key chain group, including lookahead keys.
     ;;
    #_public
    (§ method int getKeyChainGroupSize(§ args ))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return keyChainGroup.numKeys(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    #_testing
    #_public
    (§ method int getKeyChainGroupCombinedKeyLookaheadEpochs(§ args ))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return keyChainGroup.getCombinedKeyLookaheadEpochs(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a list of the non-deterministic keys that have been imported into the wallet, or the empty list if none.
     ;;
    #_public
    (§ method List<ECKey> getImportedKeys(§ args ))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return keyChainGroup.getImportedKeys(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; Returns the address used for change outputs.  Note: this will probably go away in future. ;;
    #_public
    (§ method Address currentChangeAddress(§ args ))
    (§ block
        (§ return currentAddress(§ pars KeyChain.KeyPurpose.CHANGE))
    )

    ;;;
     ; <p>Imports the given ECKey to the wallet.</p>
     ;
     ; <p>If the wallet is configured to auto save to a file, triggers a save immediately.  Runs the onKeysAdded event
     ; handler.  If the key already exists in the wallet, does nothing and returns false.</p>
     ;;
    #_public
    (§ method boolean importKey(§ args ECKey key))
    (§ block
        (§ return (§ expr importKeys(§ pars Lists.newArrayList(§ pars key)) == 1))
    )

    ;;;
     ; Imports the given keys to the wallet.
     ; If {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, org.bitcoinj.wallet.WalletFiles.Listener)}
     ; has been called, triggers an auto save bypassing the normal coalescing delay and event handlers.
     ; Returns the number of keys added, after duplicates are ignored.  The onKeyAdded event will be called
     ; for each key in the list that was not already present.
     ;;
    #_public
    (§ method int importKeys(§ args #_final List<ECKey> keys))
    (§ block
        ;; API usage check.
        (§ call checkNoDeterministicKeys(§ pars keys))
        (§ var int result)
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass result = keyChainGroup.importKeys(§ pars keys))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
        (§ call saveNow(§ pars ))
        (§ return result)
    )

    #_private
    (§ method void checkNoDeterministicKeys(§ args List<ECKey> keys))
    (§ block
        ;; Watch out for someone doing wallet.importKey(wallet.freshReceiveKey()); or equivalent: we never tested this.
        (§ for (§ var ECKey key) :for (§ expr keys))
        (§ block
            (§ if (§ expr key instanceof DeterministicKey))
            (§ block
                (§ throw (§ new IllegalArgumentException(§ pars "Cannot import HD keys back into the wallet")))
            )
        )
    )

    ;;; Takes a list of keys and a password, then encrypts and imports them in one step using the current keycrypter. ;;
    #_public
    (§ method int importKeysAndEncrypt(§ args #_final List<ECKey> keys, CharSequence password))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call Preconditions.checkNotNull(§ pars getKeyCrypter(§ pars ), "Wallet is not encrypted"))
            (§ return importKeysAndEncrypt(§ pars keys, getKeyCrypter(§ pars ).deriveKey(§ pars password)))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; Takes a list of keys and an AES key, then encrypts and imports them in one step using the current keycrypter. ;;
    #_public
    (§ method int importKeysAndEncrypt(§ args #_final List<ECKey> keys, KeyParameter aesKey))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call checkNoDeterministicKeys(§ pars keys))
            (§ return keyChainGroup.importKeysAndEncrypt(§ pars keys, aesKey))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Add a pre-configured keychain to the wallet.  Useful for setting up a complex keychain,
     ; such as for a married wallet.  For example:
     ; <pre>
     ; MarriedKeyChain chain = MarriedKeyChain.builder()
     ;     .random(new SecureRandom())
     ;     .followingKeys(followingKeys)
     ;     .threshold(2).build();
     ; wallet.addAndActivateHDChain(chain);
     ; </p>
     ;;
    #_public
    (§ method void addAndActivateHDChain(§ args DeterministicKeyChain chain))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call keyChainGroup.addAndActivateHDChain(§ pars chain))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadSize(int)} for more info on this. ;;
    #_public
    (§ method void setKeyChainGroupLookaheadSize(§ args int lookaheadSize))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call keyChainGroup.setLookaheadSize(§ pars lookaheadSize))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadSize(int)} for more info on this. ;;
    #_public
    (§ method int getKeyChainGroupLookaheadSize(§ args ))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return keyChainGroup.getLookaheadSize(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadThreshold(int)} for more info on this. ;;
    #_public
    (§ method void setKeyChainGroupLookaheadThreshold(§ args int num))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call maybeUpgradeToHD(§ pars ))
            (§ call keyChainGroup.setLookaheadThreshold(§ pars num))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadThreshold(int)} for more info on this. ;;
    #_public
    (§ method int getKeyChainGroupLookaheadThreshold(§ args ))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call maybeUpgradeToHD(§ pars ))
            (§ return keyChainGroup.getLookaheadThreshold(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a public-only DeterministicKey that can be used to set up a watching wallet: that is, a wallet that
     ; can import transactions from the block chain just as the normal wallet can, but which cannot spend.  Watching
     ; wallets are very useful for things like web servers that accept payments.  This key corresponds to the account
     ; zero key in the recommended BIP32 hierarchy.
     ;;
    #_public
    (§ method DeterministicKey getWatchingKey(§ args ))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call maybeUpgradeToHD(§ pars ))
            (§ return keyChainGroup.getActiveKeyChain(§ pars ).getWatchingKey(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns whether this wallet consists entirely of watching keys (unencrypted keys with no private part).
     ; Mixed wallets are forbidden.
     ;
     ; @throws IllegalStateException if there are no keys, or if there is a mix between watching and non-watching keys.
     ;;
    #_public
    (§ method boolean isWatching(§ args ))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call maybeUpgradeToHD(§ pars ))
            (§ return keyChainGroup.isWatching(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Locates a keypair from the basicKeyChain given the hash of the public key.  This is needed when finding out
     ; which key we need to use to redeem a transaction output.
     ;
     ; @return ECKey object or null if no such key was found.
     ;;
    #_override
    #_nilable
    #_public
    (§ method ECKey findKeyFromPubHash(§ args byte[] pubkeyHash))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return keyChainGroup.findKeyFromPubHash(§ pars pubkeyHash))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; Returns true if the given key is in the wallet, false otherwise.  Currently an O(N) operation. ;;
    #_public
    (§ method boolean hasKey(§ args ECKey key))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return keyChainGroup.hasKey(§ pars key))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (§ method boolean isPubKeyHashMine(§ args byte[] pubkeyHash))
    (§ block
        (§ return (§ expr findKeyFromPubHash(§ pars pubkeyHash) != nil))
    )

    ;;;
     ; Locates a keypair from the basicKeyChain given the raw public key bytes.
     ; @return ECKey or null if no such key was found.
     ;;
    #_override
    #_nilable
    #_public
    (§ method ECKey findKeyFromPubKey(§ args byte[] pubkey))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return keyChainGroup.findKeyFromPubKey(§ pars pubkey))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (§ method boolean isPubKeyMine(§ args byte[] pubkey))
    (§ block
        (§ return (§ expr findKeyFromPubKey(§ pars pubkey) != nil))
    )

    ;;;
     ; Locates a redeem data (redeem script and keys) from the keyChainGroup given the hash of the script.
     ; @return RedeemData object or null if no such data was found.
     ;;
    #_nilable
    #_override
    #_public
    (§ method RedeemData findRedeemDataFromScriptHash(§ args byte[] payToScriptHash))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return keyChainGroup.findRedeemDataFromScriptHash(§ pars payToScriptHash))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (§ method boolean isPayToScriptHashMine(§ args byte[] payToScriptHash))
    (§ block
        (§ return (§ expr findRedeemDataFromScriptHash(§ pars payToScriptHash) != nil))
    )

    ;;;
     ; Marks all keys used in the transaction output as used in the wallet.
     ; See {@link org.bitcoinj.wallet.DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_private
    (§ method void markKeysAsUsed(§ args Transaction tx))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ for (§ var TransactionOutput o) :for (§ expr tx.getOutputs(§ pars )))
            (§ block
                (§ try )
                (§ block
                    (§ var Script script = o.getScriptPubKey(§ pars ))
                    (§ if (§ expr script.isSentToRawPubKey(§ pars )))
                    (§ block
                        (§ var byte[] pubkey = script.getPubKey(§ pars ))
                        (§ call keyChainGroup.markPubKeyAsUsed(§ pars pubkey))
                    )
                    (§ elseif (§ expr script.isSentToAddress(§ pars )))
                    (§ block
                        (§ var byte[] pubkeyHash = script.getPubKeyHash(§ pars ))
                        (§ call keyChainGroup.markPubKeyHashAsUsed(§ pars pubkeyHash))
                    )
                    (§ elseif (§ expr script.isPayToScriptHash(§ pars )))
                    (§ block
                        (§ var Address a = Address.fromP2SHScript(§ pars tx.getParams(§ pars ), script))
                        (§ call keyChainGroup.markP2SHAddressAsUsed(§ pars a))
                    )
                )
                (§ catch (§ args ScriptException e))
                (§ block
                    ;; Just means we didn't understand the output of this transaction: ignore it.
                    (§ call log.warn(§ pars "Could not parse tx output script: {}", e.toString(§ pars )))
                )
            )
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the immutable seed for the current active HD chain.
     ; @throws org.bitcoinj.core.ECKey.MissingPrivateKeyException if the seed is unavailable (watching wallet).
     ;;
    #_public
    (§ method DeterministicSeed getKeyChainSeed(§ args ))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var DeterministicSeed seed = keyChainGroup.getActiveKeyChain(§ pars ).getSeed(§ pars ))
            (§ if (§ expr seed == nil))
            (§ block
                (§ throw new ECKey.MissingPrivateKeyException(§ pars ))
            )
            (§ return seed)
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a key for the given HD path, assuming it's already been derived.  You normally shouldn't use this:
     ; use currentReceiveKey/freshReceiveKey instead.
     ;;
    #_public
    (§ method DeterministicKey getKeyByPath(§ args List<ChildNumber> path))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call maybeUpgradeToHD(§ pars ))
            (§ return keyChainGroup.getActiveKeyChain(§ pars ).getKeyByPath(§ pars path, false))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Convenience wrapper around
     ; {@link Wallet#encrypt(org.bitcoinj.crypto.KeyCrypter, org.spongycastle.crypto.params.KeyParameter)}
     ; which uses the default Scrypt key derivation algorithm and parameters to derive a key from the given password.
     ;;
    #_public
    (§ method void encrypt(§ args CharSequence password))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            #_final
            (§ var KeyCrypterScrypt scrypt = new KeyCrypterScrypt(§ pars ))
            (§ call keyChainGroup.encrypt(§ pars scrypt, scrypt.deriveKey(§ pars password)))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
        (§ call saveNow(§ pars ))
    )

    ;;;
     ; Encrypt the wallet using the KeyCrypter and the AES key.
     ; A good default KeyCrypter to use is {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @param keyCrypter The KeyCrypter that specifies how to encrypt/ decrypt a key.
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming to create from a password).
     ; @throws KeyCrypterException if the wallet encryption fails.  If so, the wallet state is unchanged.
     ;;
    #_public
    (§ method void encrypt(§ args KeyCrypter keyCrypter, KeyParameter aesKey))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call keyChainGroup.encrypt(§ pars keyCrypter, aesKey))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
        (§ call saveNow(§ pars ))
    )

    ;;;
     ; Decrypt the wallet with the wallets keyCrypter and password.
     ; @throws KeyCrypterException if the wallet decryption fails.  If so, the wallet state is unchanged.
     ;;
    #_public
    (§ method void decrypt(§ args CharSequence password))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            #_final
            (§ var KeyCrypter crypter = keyChainGroup.getKeyCrypter(§ pars ))
            (§ call Preconditions.checkState(§ pars crypter != nil, "Not encrypted"))
            (§ call keyChainGroup.decrypt(§ pars crypter.deriveKey(§ pars password)))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
        (§ call saveNow(§ pars ))
    )

    ;;;
     ; Decrypt the wallet with the wallets keyCrypter and AES key.
     ;
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming to create from a password).
     ; @throws KeyCrypterException if the wallet decryption fails. If so, the wallet state is unchanged.
     ;;
    #_public
    (§ method void decrypt(§ args KeyParameter aesKey))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call keyChainGroup.decrypt(§ pars aesKey))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
        (§ call saveNow(§ pars ))
    )

    ;;;
     ;  Check whether the password can decrypt the first key in the wallet.
     ;  This can be used to check the validity of an entered password.
     ;
     ;  @return true if the password supplied can decrypt the first private key in the wallet, false otherwise.
     ;  @throws IllegalStateException if the wallet is not encrypted.
     ;;
    #_public
    (§ method boolean checkPassword(§ args CharSequence password))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return keyChainGroup.checkPassword(§ pars password))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ;  Check whether the AES key can decrypt the first encrypted key in the wallet.
     ;
     ;  @return true if AES key supplied can decrypt the first encrypted private key in the wallet, false otherwise.
     ;;
    #_public
    (§ method boolean checkAESKey(§ args KeyParameter aesKey))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return keyChainGroup.checkAESKey(§ pars aesKey))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Get the wallet's KeyCrypter, or null if the wallet is not encrypted.
     ; (Used in encrypting/decrypting an ECKey).
     ;;
    #_nilable
    #_public
    (§ method KeyCrypter getKeyCrypter(§ args ))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return keyChainGroup.getKeyCrypter(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Get the type of encryption used for this wallet.
     ;
     ; (This is a convenience method - the encryption type is actually stored in the keyCrypter).
     ;;
    #_public
    (§ method EncryptionType getEncryptionType(§ args ))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var KeyCrypter crypter = keyChainGroup.getKeyCrypter(§ pars ))
            (§ return (§ expr crypter != nil) ? crypter.getUnderstoodEncryptionType(§ pars ) :else EncryptionType.UNENCRYPTED)
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; Returns true if the wallet is encrypted using any scheme, false if not. ;;
    #_public
    (§ method boolean isEncrypted(§ args ))
    (§ block
        (§ return (§ expr getEncryptionType(§ pars ) != EncryptionType.UNENCRYPTED))
    )

    ;;; Changes wallet encryption password, this is atomic operation. ;;
    #_public
    (§ method void changeEncryptionPassword(§ args CharSequence currentPassword, CharSequence newPassword))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call decrypt(§ pars currentPassword))
            (§ call encrypt(§ pars newPassword))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; Changes wallet AES encryption key, this is atomic operation. ;;
    #_public
    (§ method void changeEncryptionKey(§ args KeyCrypter keyCrypter, KeyParameter currentAesKey, KeyParameter newAesKey))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call decrypt(§ pars currentAesKey))
            (§ call encrypt(§ pars keyCrypter, newAesKey))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;; TODO: Make this package private once the classes finish moving around.
    ;;; Internal use only. ;;
    #_public
    (§ method List<Protos.Key> serializeKeyChainGroupToProtobuf(§ args ))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return keyChainGroup.serializeToProtobuf(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; Saves the wallet first to the given temp file, then renames to the dest file. ;;
    #_public
    (§ method void saveToFile(§ args File temp, File destFile))
        (§ throws IOException)
    (§ block
        (§ var FileOutputStream stream = nil)
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass stream = new FileOutputStream(§ pars temp))
            (§ call saveToFileStream(§ pars stream))
            ;; Attempt to force the bits to hit the disk.  In reality the OS or hard disk itself may still decide
            ;; to not write through to physical media for at least a few seconds, but this is the best we can do.
            (§ call stream.flush(§ pars ))
            (§ call stream.getFD(§ pars ).sync(§ pars ))
            (§ call stream.close(§ pars ))
            (§ ass stream = nil)
            (§ if (§ expr Utils.isWindows(§ pars )))
            (§ block
                ;; Work around an issue on Windows whereby you can't rename over existing files.
                (§ var File canonical = destFile.getCanonicalFile(§ pars ))
                (§ if (§ expr canonical.exists(§ pars ) && !canonical.delete(§ pars )))
                (§ block
                    (§ throw (§ new IOException(§ pars "Failed to delete canonical wallet file for replacement with autosave")))
                )
                (§ if (§ expr temp.renameTo(§ pars canonical)))
                (§ block
                    (§ return ) ;; else fall through
                )
                (§ throw (§ new IOException(§ pars "Failed to rename " + temp + " to " + canonical)))
            )
            (§ elseif (§ expr !temp.renameTo(§ pars destFile)))
            (§ block
                (§ throw (§ new IOException(§ pars "Failed to rename " + temp + " to " + destFile)))
            )
        )
        (§ catch (§ args RuntimeException e))
        (§ block
            (§ call log.error(§ pars "Failed whilst saving wallet", e))
            (§ throw e)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
            (§ if (§ expr stream != nil))
            (§ block
                (§ call stream.close(§ pars ))
            )
            (§ if (§ expr temp.exists(§ pars )))
            (§ block
                (§ call log.warn(§ pars "Temp file still exists after failed save."))
            )
        )
    )

    ;;;
     ; Uses protobuf serialization to save the wallet to the given file.  To learn more about this file format, see
     ; {@link WalletProtobufSerializer}.  Writes out first to a temporary file in the same directory and then renames
     ; once written.
     ;;
    #_public
    (§ method void saveToFile(§ args File f))
        (§ throws IOException)
    (§ block
        (§ var File directory = f.getAbsoluteFile(§ pars ).getParentFile(§ pars ))
        (§ var File temp = File.createTempFile(§ pars "wallet", nil, directory))
        (§ call saveToFile(§ pars temp, f))
    )

    ;;;
     ; <p>Whether or not the wallet will ignore pending transactions that fail the selected {@link RiskAnalysis}.
     ; By default, if a transaction is considered risky then it won't enter the wallet and won't trigger any event
     ; listeners.  If you set this property to true, then all transactions will be allowed in regardless of risk.
     ; For example, the {@link DefaultRiskAnalysis} checks for non-finality of transactions.</p>
     ;
     ; <p>Note that this property is not serialized.  You have to set it each time a Wallet object is constructed,
     ; even if it's loaded from a protocol buffer.</p>
     ;;
    #_public
    (§ method void setAcceptRiskyTransactions(§ args boolean acceptRiskyTransactions))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass this.acceptRiskyTransactions = acceptRiskyTransactions)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; See {@link Wallet#setAcceptRiskyTransactions(boolean)} for an explanation of this property.
     ;;
    #_public
    (§ method boolean isAcceptRiskyTransactions(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return acceptRiskyTransactions)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Sets the {@link RiskAnalysis} implementation to use for deciding whether received pending transactions are
     ; risky or not.  If the analyzer says a transaction is risky, by default it will be dropped. You can customize
     ; this behaviour with {@link #setAcceptRiskyTransactions(boolean)}.
     ;;
    #_public
    (§ method void setRiskAnalyzer(§ args RiskAnalysis.Analyzer analyzer))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass this.riskAnalyzer = Preconditions.checkNotNull(§ pars analyzer))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Gets the current {@link RiskAnalysis} implementation.  The default is {@link DefaultRiskAnalysis}.
     ;;
    #_public
    (§ method RiskAnalysis.Analyzer getRiskAnalyzer(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return riskAnalyzer)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; <p>Sets up the wallet to auto-save itself to the given file, using temp files with atomic renames to ensure
     ; consistency.  After connecting to a file, you no longer need to save the wallet manually, it will do it
     ; whenever necessary.  Protocol buffer serialization will be used.</p>
     ;
     ; <p>If delayTime is set, a background thread will be created and the wallet will only be saved to disk
     ; every so many time units.  If no changes have occurred for the given time period, nothing will be written.
     ; In this way disk IO can be rate limited.  It's a good idea to set this as otherwise the wallet can change very
     ; frequently, e.g. if there are a lot of transactions in it or during block sync, and there will be a lot of redundant
     ; writes.  Note that when a new key is added, that always results in an immediate save regardless of delayTime.
     ; <b>You should still save the wallet manually when your program is about to shut down as the JVM will not
     ; wait for the background thread.</b></p>
     ;
     ; <p>An event listener can be provided.  If a delay >0 was specified, it will be called on a background thread
     ; with the wallet locked when an auto-save occurs.  If delay is zero or you do something that always triggers
     ; an immediate save, like adding a key, the event listener will be invoked on the calling threads.</p>
     ;
     ; @param f The destination file to save to.
     ; @param delayTime How many time units to wait until saving the wallet on a background thread.
     ; @param timeUnit The unit of measurement for delayTime.
     ; @param eventListener Callback to be informed when the auto-save thread does things, or null.
     ;;
    #_public
    (§ method WalletFiles autosaveToFile(§ args File f, long delayTime, TimeUnit timeUnit, #_nilable WalletFiles.Listener eventListener))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call Preconditions.checkState(§ pars vFileManager == nil, "Already auto saving this wallet."))
            (§ var WalletFiles manager = new WalletFiles(§ pars this, f, delayTime, timeUnit))
            (§ if (§ expr eventListener != nil))
            (§ block
                (§ call manager.setListener(§ pars eventListener))
            )
            (§ ass vFileManager = manager)
            (§ return manager)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Disables auto-saving, after it had been enabled with
     ; {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, org.bitcoinj.wallet.WalletFiles.Listener)}
     ; before.  This method blocks until finished.
     ;;
    #_public
    (§ method void shutdownAutosaveAndWait(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var WalletFiles files = vFileManager)
            (§ ass vFileManager = nil)
            (§ call Preconditions.checkState(§ pars files != nil, "Auto saving not enabled."))
            (§ call files.shutdownAndWait(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;; Requests an asynchronous save on a background thread. ;;
    #_protected
    (§ method void saveLater(§ args ))
    (§ block
        (§ var WalletFiles files = vFileManager)
        (§ if (§ expr files != nil))
        (§ block
            (§ call files.saveLater(§ pars ))
        )
    )

    ;;; If auto saving is enabled, do an immediate sync write to disk ignoring any delays. ;;
    #_protected
    (§ method void saveNow(§ args ))
    (§ block
        (§ var WalletFiles files = vFileManager)
        (§ if (§ expr files != nil))
        (§ block
            (§ try )
            (§ block
                (§ call files.saveNow(§ pars )) ;; This calls back into saveToFile().
            )
            (§ catch (§ args IOException e))
            (§ block
                ;; Can't really do much at this point, just let the API user know.
                (§ call log.error(§ pars "Failed to save wallet to disk!", e))
                (§ var Thread.UncaughtExceptionHandler handler = Threading.uncaughtExceptionHandler)
                (§ if (§ expr handler != nil))
                (§ block
                    (§ call handler.uncaughtException(§ pars Thread.currentThread(§ pars ), e))
                )
            )
        )
    )

    ;;;
     ; Uses protobuf serialization to save the wallet to the given file stream.
     ; To learn more about this file format, see {@link WalletProtobufSerializer}.
     ;;
    #_public
    (§ method void saveToFileStream(§ args OutputStream f))
        (§ throws IOException)
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call (§ new WalletProtobufSerializer(§ pars )).writeWallet(§ pars this, f))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;; Returns the parameters this wallet was created with. ;;
    #_public
    (§ method NetworkParameters getParams(§ args ))
    (§ block
        (§ return params)
    )

    ;;; Returns the API context that this wallet was created with. ;;
    #_public
    (§ method Context getContext(§ args ))
    (§ block
        (§ return context)
    )

    ;;;
     ; Returns a wallet deserialized from the given file.
     ;
     ; @param file The wallet file to be read.
     ;;
    #_public
    #_static
    (§ method Wallet loadFromFile(§ args File file))
        (§ throws UnreadableWalletException)
    (§ block
        (§ try )
        (§ block
            (§ var FileInputStream stream = nil)
            (§ try )
            (§ block
                (§ ass stream = new FileInputStream(§ pars file))
                (§ return loadFromFileStream(§ pars stream))
            )
            (§ finally )
            (§ block
                (§ if (§ expr stream != nil))
                (§ block
                    (§ call stream.close(§ pars ))
                )
            )
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new UnreadableWalletException(§ pars "Could not open file", e)))
        )
    )

    ;;;
     ; Returns if this wallet is structurally consistent, so e.g. no duplicate transactions.
     ; First inconsistency and a dump of the wallet will be logged.
     ;;
    #_public
    (§ method boolean isConsistent(§ args ))
    (§ block
        (§ try )
        (§ block
            (§ call isConsistentOrThrow(§ pars ))
            (§ return true)
        )
        (§ catch (§ args IllegalStateException e1))
        (§ block
            (§ call log.error(§ pars e1.getMessage(§ pars )))
            (§ try )
            (§ block
                (§ call log.error(§ pars toString(§ pars )))
            )
            (§ catch (§ args RuntimeException e2))
            (§ block
                (§ call log.error(§ pars "Printing inconsistent wallet failed", e2))
            )
            (§ return false)
        )
    )

    ;;;
     ; Variant of {@link Wallet#isConsistent()} that throws an {@link IllegalStateException} describing
     ; the first inconsistency.
     ;;
    #_public
    (§ method void isConsistentOrThrow(§ args ))
        (§ throws IllegalStateException)
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var Set<Transaction> transactions = getTransactions(§ pars true))

            (§ var Set<Sha256Hash> hashes = new HashSet<>(§ pars ))
            (§ for (§ var Transaction tx) :for (§ expr transactions))
            (§ block
                (§ call hashes.add(§ pars tx.getHash(§ pars )))
            )

            (§ var int size1 = transactions.size(§ pars ))
            (§ if (§ expr size1 != hashes.size(§ pars )))
            (§ block
                (§ throw (§ new IllegalStateException(§ pars "Two transactions with same hash")))
            )

            (§ var int size2 = unspent.size(§ pars ) + spent.size(§ pars ) + pending.size(§ pars ) + dead.size(§ pars ))
            (§ if (§ expr size1 != size2))
            (§ block
                (§ throw (§ new IllegalStateException(§ pars "Inconsistent wallet sizes: " + size1 + ", " + size2)))
            )

            (§ for (§ var Transaction tx) :for (§ expr unspent.values(§ pars )))
            (§ block
                (§ if (§ expr !isTxConsistent(§ pars tx, false)))
                (§ block
                    (§ throw (§ new IllegalStateException(§ pars "Inconsistent unspent tx: " + tx.getHashAsString(§ pars ))))
                )
            )

            (§ for (§ var Transaction tx) :for (§ expr spent.values(§ pars )))
            (§ block
                (§ if (§ expr !isTxConsistent(§ pars tx, true)))
                (§ block
                    (§ throw (§ new IllegalStateException(§ pars "Inconsistent spent tx: " + tx.getHashAsString(§ pars ))))
                )
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;; If isSpent, check that all my outputs spent, otherwise check that there at least one unspent.
    #_testing
    (§ method boolean isTxConsistent(§ args #_final Transaction tx, #_final boolean isSpent))
    (§ block
        (§ var boolean isActuallySpent = true)
        (§ for (§ var TransactionOutput o) :for (§ expr tx.getOutputs(§ pars )))
        (§ block
            (§ if (§ expr o.isAvailableForSpending(§ pars )))
            (§ block
                (§ if (§ expr o.isMine(§ pars this)))
                (§ block
                    (§ ass isActuallySpent = false)
                )
                (§ if (§ expr o.getSpentBy(§ pars ) != nil))
                (§ block
                    (§ call log.error(§ pars "isAvailableForSpending != spentBy"))
                    (§ return false)
                )
            )
            (§ else )
            (§ block
                (§ if (§ expr o.getSpentBy(§ pars ) == nil))
                (§ block
                    (§ call log.error(§ pars "isAvailableForSpending != spentBy"))
                    (§ return false)
                )
            )
        )
        (§ return (§ expr isActuallySpent == isSpent))
    )

    ;;; Returns a wallet deserialized from the given input stream. ;;
    #_public
    #_static
    (§ method Wallet loadFromFileStream(§ args InputStream stream))
        (§ throws UnreadableWalletException)
    (§ block
        (§ var Wallet wallet = new WalletProtobufSerializer(§ pars ).readWallet(§ pars stream))
        (§ if (§ expr !wallet.isConsistent(§ pars )))
        (§ block
            (§ call log.error(§ pars "Loaded an inconsistent wallet"))
        )
        (§ return wallet)
    )

    ;;;
     ; Called by the {@link BlockChain} when we receive a new filtered block that contains a transactions previously
     ; received by a call to {@link #receivePending}.
     ;
     ; This is necessary for the internal book-keeping Wallet does.  When a transaction is received that sends us
     ; coins it is added to a pool so we can use it later to create spends.  When a transaction is received that
     ; consumes outputs they are marked as spent so they won't be used in future.
     ;
     ; A transaction that spends our own coins can be received either because a spend we created was accepted by
     ; the network and thus made it into a block, or because our keys are being shared between multiple instances
     ; and some other node spent the coins instead.  We still have to know about that to avoid accidentally trying
     ; to double spend.
     ;
     ; A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.  We must still record these transactions and the blocks they appear in because a future
     ; block might change which chain is best causing a reorganize.  A re-org can totally change our balance!
     ;;
    #_override
    #_public
    (§ method boolean notifyTransactionIsInBlock(§ args Sha256Hash txHash, StoredBlock block, BlockChain.NewBlockType blockType, int relativityOffset))
        (§ throws VerificationException)
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var Transaction tx = transactions.get(§ pars txHash))
            (§ if (§ expr tx == nil))
            (§ block
                (§ ass tx = riskDropped.get(§ pars txHash))
                (§ if (§ expr tx != nil))
                (§ block
                    ;; If this happens our risk analysis is probably wrong and should be improved.
                    (§ call log.info(§ pars "Risk analysis dropped tx {} but was included in block anyway", tx.getHash(§ pars )))
                )
                (§ else )
                (§ block
                    ;; False positive that was broadcast to us and ignored by us because it was irrelevant to our keys.
                    (§ return false)
                )
            )
            (§ call receive(§ pars tx, block, blockType, relativityOffset))
            (§ return true)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; <p>Called when we have found a transaction (via network broadcast or otherwise) that is relevant to this wallet
     ; and want to record it.  Note that we <b>cannot verify these transactions at all</b>, they may spend fictional
     ; coins or be otherwise invalid.  They are useful to inform the user about coins they can expect to receive soon,
     ; and if you trust the sender of the transaction you can choose to assume they are in fact valid and will not
     ; be double spent as an optimization.</p>
     ;
     ; <p>This is the same as {@link Wallet#receivePending(Transaction, java.util.List)} but allows you to override the
     ; {@link Wallet#isPendingTransactionRelevant(Transaction)} sanity-check to keep track of transactions that are not
     ; spendable or spend our coins.  This can be useful when you want to keep track of transaction confidence on
     ; arbitrary transactions.  Note that transactions added in this way will still be relayed to peers and appear in
     ; transaction lists like any other pending transaction (even when not relevant).</p>
     ;;
    #_public
    (§ method void receivePending(§ args Transaction tx, #_nilable List<Transaction> dependencies, boolean overrideIsRelevant))
        (§ throws VerificationException)
    (§ block
        ;; Can run in a peer thread.  This method will only be called if a prior call to isPendingTransactionRelevant
        ;; returned true, so we already know by this point that it sends coins to or from our wallet, or is a double
        ;; spend against one of our other pending transactions.
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call tx.verify(§ pars ))
            ;; Ignore it if we already know about this transaction.  Receiving a pending transaction never moves it
            ;; between pools.
            (§ var EnumSet<Pool> containingPools = getContainingPools(§ pars tx))
            (§ if (§ expr !containingPools.equals(§ pars EnumSet.noneOf(§ pars Pool.class))))
            (§ block
                (§ call log.debug(§ pars "Received tx we already saw in a block or created ourselves: " + tx.getHashAsString(§ pars )))
                (§ return )
            )
            ;; Repeat the check of relevancy here, even though the caller may have already done so - this is to avoid
            ;; race conditions where receivePending may be being called in parallel.
            (§ if (§ expr !overrideIsRelevant && !isPendingTransactionRelevant(§ pars tx)))
            (§ block
                (§ return )
            )

            (§ if (§ expr isTransactionRisky(§ pars tx, dependencies) && !acceptRiskyTransactions))
            (§ block
                ;; isTransactionRisky already logged the reason.
                (§ call riskDropped.put(§ pars tx.getHash(§ pars ), tx))
                (§ call log.warn(§ pars "There are now {} risk dropped transactions being kept in memory", riskDropped.size(§ pars )))
                (§ return )
            )

            (§ var Coin valueSentToMe = tx.getValueSentToMe(§ pars this))
            (§ var Coin valueSentFromMe = tx.getValueSentFromMe(§ pars this))
            (§ if (§ expr log.isInfoEnabled(§ pars )))
            (§ block
                (§ call log.info(§ pars String.format(§ pars Locale.US, "Received a pending transaction %s that spends %s from our own wallet, and sends us %s", tx.getHashAsString(§ pars ), valueSentFromMe.toFriendlyString(§ pars ), valueSentToMe.toFriendlyString(§ pars ))))
            )
            (§ if (§ expr tx.getConfidence(§ pars ).getSource(§ pars ).equals(§ pars TransactionConfidence.Source.UNKNOWN)))
            (§ block
                (§ call log.warn(§ pars "Wallet received transaction with an unknown source. Consider tagging it!"))
            )
            ;; If this tx spends any of our unspent outputs, mark them as spent now, then add to the pending pool.  This
            ;; ensures that if some other client that has our keys broadcasts a spend we stay in sync.  Also updates the
            ;; timestamp on the transaction and registers/runs event listeners.
            (§ call commitTx(§ pars tx))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
        ;; maybeRotateKeys() will ignore pending transactions, so we don't bother calling it here (see the comments
        ;; in that function for an explanation of why).
    )

    ;;;
     ; Given a transaction and an optional list of dependencies (recursive/flattened), returns true if the given
     ; transaction would be rejected by the analyzer, or false otherwise.  The result of this call is independent
     ; of the value of {@link #isAcceptRiskyTransactions()}.  Risky transactions yield a logged warning.  If you
     ; want to know the reason why a transaction is risky, create an instance of the {@link RiskAnalysis} yourself
     ; using the factory returned by {@link #getRiskAnalyzer()} and use it directly.
     ;;
    #_public
    (§ method boolean isTransactionRisky(§ args Transaction tx, #_nilable List<Transaction> dependencies))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr dependencies == nil))
            (§ block
                (§ ass dependencies = ImmutableList.of(§ pars ))
            )
            (§ var RiskAnalysis analysis = riskAnalyzer.create(§ pars this, tx, dependencies))
            (§ var RiskAnalysis.Result result = analysis.analyze(§ pars ))
            (§ if (§ expr result != RiskAnalysis.Result.OK))
            (§ block
                (§ call log.warn(§ pars "Pending transaction was considered risky: {}\n{}", analysis, tx))
                (§ return true)
            )
            (§ return false)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; <p>Called when we have found a transaction (via network broadcast or otherwise) that is relevant to this wallet
     ; and want to record it.  Note that we <b>cannot verify these transactions at all</b>, they may spend fictional
     ; coins or be otherwise invalid.  They are useful to inform the user about coins they can expect to receive soon,
     ; and if you trust the sender of the transaction you can choose to assume they are in fact valid and will not
     ; be double spent as an optimization.</p>
     ;
     ; <p>Before this method is called, {@link Wallet#isPendingTransactionRelevant(Transaction)} should have been
     ; called to decide whether the wallet cares about the transaction - if it does, then this method expects the
     ; transaction and any dependencies it has which are still in the memory pool.</p>
     ;;
    #_public
    (§ method void receivePending(§ args Transaction tx, #_nilable List<Transaction> dependencies))
        (§ throws VerificationException)
    (§ block
        (§ call receivePending(§ pars tx, dependencies, false))
    )

    ;;;
     ; This method is used by a {@link Peer} to find out if a transaction that has been announced is interesting,
     ; that is, whether we should bother downloading its dependencies and exploring the transaction to decide how
     ; risky it is.  If this method returns true then {@link Wallet#receivePending(Transaction, java.util.List)}
     ; will soon be called with the transactions dependencies as well.
     ;;
    #_public
    (§ method boolean isPendingTransactionRelevant(§ args Transaction tx))
        (§ throws ScriptException)
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; Ignore it if we already know about this transaction.  Receiving a pending transaction never moves it
            ;; between pools.
            (§ var EnumSet<Pool> containingPools = getContainingPools(§ pars tx))
            (§ if (§ expr !containingPools.equals(§ pars EnumSet.noneOf(§ pars Pool.class))))
            (§ block
                (§ call log.debug(§ pars "Received tx we already saw in a block or created ourselves: " + tx.getHashAsString(§ pars )))
                (§ return false)
            )

            ;; We only care about transactions that:
            ;;   - Send us coins.
            ;;   - Spend our coins.
            ;;   - Double spend a tx in our wallet.
            (§ if (§ expr !isTransactionRelevant(§ pars tx)))
            (§ block
                (§ call log.debug(§ pars "Received tx that isn't relevant to this wallet, discarding."))
                (§ return false)
            )
            (§ return true)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; <p>Returns true if the given transaction sends coins to any of our keys, or has inputs spending any of our outputs,
     ; and also returns true if tx has inputs that are spending outputs which are
     ; not ours but which are spent by pending transactions.</p>
     ;
     ; <p>Note that if the tx has inputs containing one of our keys, but the connected transaction is not in the wallet,
     ; it will not be considered relevant.</p>
     ;;
    #_public
    (§ method boolean isTransactionRelevant(§ args Transaction tx))
        (§ throws ScriptException)
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr 0 < tx.getValueSentFromMe(§ pars this).signum(§ pars ) || 0 < tx.getValueSentToMe(§ pars this).signum(§ pars ) || !findDoubleSpendsAgainst(§ pars tx, transactions).isEmpty(§ pars )))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Finds transactions in the specified candidates that double spend "tx".  Not a general check, but it can work even
     ; if the double spent inputs are not ours.
     ; @return the set of transactions that double spend "tx".
     ;;
    #_private
    (§ method Set<Transaction> findDoubleSpendsAgainst(§ args Transaction tx, Map<Sha256Hash, Transaction> candidates))
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ if (§ expr tx.isCoinBase(§ pars )))
        (§ block
            (§ return Sets.newHashSet(§ pars ))
        )

        ;; Compile a set of outpoints that are spent by tx.
        (§ var HashSet<TransactionOutPoint> outpoints = new HashSet<>(§ pars ))
        (§ for (§ var TransactionInput input) :for (§ expr tx.getInputs(§ pars )))
        (§ block
            (§ call outpoints.add(§ pars input.getOutpoint(§ pars )))
        )

        ;; Now for each pending transaction, see if it shares any outpoints with this tx.
        (§ var Set<Transaction> doubleSpendTxns = Sets.newHashSet(§ pars ))
        (§ for (§ var Transaction p) :for (§ expr candidates.values(§ pars )))
        (§ block
            (§ if (§ expr p.equals(§ pars tx)))
            (§ block
                (§ continue )
            )

            (§ for (§ var TransactionInput input) :for (§ expr p.getInputs(§ pars )))
            (§ block
                ;; This relies on the fact that TransactionOutPoint equality is defined at the protocol not object
                ;; level - outpoints from two different inputs that point to the same output compare the same.
                (§ var TransactionOutPoint outpoint = input.getOutpoint(§ pars ))
                ;; If does, it's a double spend against the candidates, which makes it relevant.
                (§ if (§ expr outpoints.contains(§ pars outpoint)))
                (§ block
                    (§ call doubleSpendTxns.add(§ pars p))
                )
            )
        )
        (§ return doubleSpendTxns)
    )

    ;;;
     ; Adds to txSet all the txns in txPool spending outputs of txns in txSet,
     ; and all txns spending the outputs of those txns, recursively.
     ;;
    (§ method void addTransactionsDependingOn(§ args Set<Transaction> txSet, Set<Transaction> txPool))
    (§ block
        (§ var Map<Sha256Hash, Transaction> txQueue = new LinkedHashMap<>(§ pars ))
        (§ for (§ var Transaction tx) :for (§ expr txSet))
        (§ block
            (§ call txQueue.put(§ pars tx.getHash(§ pars ), tx))
        )

        (§ while (§ expr !txQueue.isEmpty(§ pars )))
        (§ block
            (§ var Transaction tx = txQueue.remove(§ pars txQueue.keySet(§ pars ).iterator(§ pars ).next(§ pars )))
            (§ for (§ var Transaction anotherTx) :for (§ expr txPool))
            (§ block
                (§ if (§ expr anotherTx.equals(§ pars tx)))
                (§ block
                    (§ continue )
                )

                (§ for (§ var TransactionInput input) :for (§ expr anotherTx.getInputs(§ pars )))
                (§ block
                    (§ if (§ expr input.getOutpoint(§ pars ).getHash(§ pars ).equals(§ pars tx.getHash(§ pars ))))
                    (§ block
                        (§ if (§ expr txQueue.get(§ pars anotherTx.getHash(§ pars )) == nil))
                        (§ block
                            (§ call txQueue.put(§ pars anotherTx.getHash(§ pars ), anotherTx))
                            (§ call txSet.add(§ pars anotherTx))
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Called by the {@link BlockChain} when we receive a new block that sends coins to one of our addresses or
     ; spends coins from one of our addresses (note that a single transaction can do both).
     ;
     ; This is necessary for the internal book-keeping Wallet does.  When a transaction is received that sends us
     ; coins it is added to a pool so we can use it later to create spends.  When a transaction is received that
     ; consumes outputs they are marked as spent so they won't be used in future.
     ;
     ; A transaction that spends our own coins can be received either because a spend we created was accepted by
     ; the network and thus made it into a block, or because our keys are being shared between multiple instances
     ; and some other node spent the coins instead.  We still have to know about that to avoid accidentally trying
     ; to double spend.
     ;
     ; A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.  We must still record these transactions and the blocks they appear in because a future
     ; block might change which chain is best causing a reorganize.  A re-org can totally change our balance!
     ;;
    #_override
    #_public
    (§ method void receiveFromBlock(§ args Transaction tx, StoredBlock block, BlockChain.NewBlockType blockType, int relativityOffset))
        (§ throws VerificationException)
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr isTransactionRelevant(§ pars tx)))
            (§ block
                (§ call receive(§ pars tx, block, blockType, relativityOffset))
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;; Whether to do a saveNow or saveLater when we are notified of the next best block.
    #_private
    (§ field boolean hardSaveOnNextBlock = false)

    #_private
    (§ method void receive(§ args Transaction tx, StoredBlock block, BlockChain.NewBlockType blockType, int relativityOffset))
        (§ throws VerificationException)
    (§ block
        ;; Runs in a peer thread.
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ var Coin prevBalance = getBalance(§ pars ))
        (§ var Sha256Hash txHash = tx.getHash(§ pars ))
        (§ var boolean bestChain = (§ expr blockType == BlockChain.NewBlockType.BEST_CHAIN))
        (§ var boolean sideChain = (§ expr blockType == BlockChain.NewBlockType.SIDE_CHAIN))

        (§ var Coin valueSentFromMe = tx.getValueSentFromMe(§ pars this))
        (§ var Coin valueSentToMe = tx.getValueSentToMe(§ pars this))
        (§ var Coin valueDifference = valueSentToMe.subtract(§ pars valueSentFromMe))

        (§ call log.info(§ pars "Received tx{} for {}: {} [{}] in block {}", sideChain ? " on a side chain") :for (§ expr "", valueDifference.toFriendlyString(§ pars ), tx.getHashAsString(§ pars ), relativityOffset, (§ expr block != nil) ? block.getHeader(§ pars ).getHash(§ pars ) :else "(unit test)"))

        ;; Inform the key chains that the issued keys were observed in a transaction, so they know to
        ;; calculate more keys for the next Bloom filters.
        (§ call markKeysAsUsed(§ pars tx))

        (§ ass onWalletChangedSuppressions = onWalletChangedSuppressions + 1)

        ;; If this transaction is already in the wallet, we may need to move it into a different pool.
        ;; At the very least we need to ensure we're manipulating the canonical object rather than a duplicate.
        (§ block
            (§ var Transaction tmp = transactions.get(§ pars tx.getHash(§ pars )))
            (§ if (§ expr tmp != nil))
            (§ block
                (§ ass tx = tmp)
            )
        )

        (§ var boolean wasPending = (§ expr pending.remove(§ pars txHash) != nil))
        (§ if (§ expr wasPending))
        (§ block
            (§ call log.info(§ pars "  <-pending"))
        )

        (§ if (§ expr bestChain))
        (§ block
            (§ var boolean wasDead = (§ expr dead.remove(§ pars txHash) != nil))
            (§ if (§ expr wasDead))
            (§ block
                (§ call log.info(§ pars "  <-dead"))
            )
            (§ if (§ expr wasPending))
            (§ block
                ;; Was pending and is now confirmed.  Disconnect the outputs in case we spent any already:
                ;; they will be re-connected by processTxFromBestChain below.
                (§ for (§ var TransactionOutput output) :for (§ expr tx.getOutputs(§ pars )))
                (§ block
                    #_final
                    (§ var TransactionInput spentBy = output.getSpentBy(§ pars ))
                    (§ if (§ expr spentBy != nil))
                    (§ block
                        (§ call Preconditions.checkState(§ pars myUnspents.add(§ pars output)))
                        (§ call spentBy.disconnect(§ pars ))
                    )
                )
            )
            (§ call processTxFromBestChain(§ pars tx, wasPending || wasDead))
        )
        (§ else )
        (§ block
            (§ call Preconditions.checkState(§ pars sideChain))
            ;; Transactions that appear in a side chain will have that appearance recorded below - we assume
            ;; that some miners are also trying to include the transaction into the current best chain too,
            ;; so let's treat it as pending, except we don't need to do any risk analysis on it.
            (§ if (§ expr wasPending))
            (§ block
                ;; Just put it back in without touching the connections or confidence.
                (§ call addWalletTransaction(§ pars Pool.PENDING, tx))
                (§ call log.info(§ pars "  ->pending"))
            )
            (§ else )
            (§ block
                ;; Ignore the case where a tx appears on a side chain at the same time as the best chain
                ;; (this is quite normal and expected).
                (§ var Sha256Hash hash = tx.getHash(§ pars ))
                (§ if (§ expr !unspent.containsKey(§ pars hash) && !spent.containsKey(§ pars hash) && !dead.containsKey(§ pars hash)))
                (§ block
                    ;; Otherwise put it (possibly back) into pending.
                    ;; Committing it updates the spent flags and inserts into the pool as well.
                    (§ call commitTx(§ pars tx))
                )
            )
        )

        (§ if (§ expr block != nil))
        (§ block
            ;; Mark the tx as appearing in this block so we can find it later after a re-org.  This also tells
            ;; the tx confidence object about the block and sets its depth appropriately.
            (§ call tx.setBlockAppearance(§ pars block, bestChain, relativityOffset))
            (§ if (§ expr bestChain))
            (§ block
                ;; Don't notify this tx of work done in notifyNewBestBlock which will be called immediately
                ;; after this method has been called by BlockChain for all relevant transactions.  Otherwise
                ;; we'd double count.
                (§ call ignoreNextNewBlock.add(§ pars txHash))

                ;; When a tx is received from the best chain, if other txns that spend this tx are IN_CONFLICT,
                ;; change its confidence to PENDING (Unless they are also spending other txns IN_CONFLICT).
                ;; Consider dependency chains.
                (§ var Set<Transaction> currentTxDependencies = Sets.newHashSet(§ pars tx))
                (§ call addTransactionsDependingOn(§ pars currentTxDependencies, getTransactions(§ pars true)))
                (§ call currentTxDependencies.remove(§ pars tx))
                (§ var List<Transaction> currentTxDependenciesSorted = sortTxnsByDependency(§ pars currentTxDependencies))
                (§ for (§ var Transaction txDependency) :for (§ expr currentTxDependenciesSorted))
                (§ block
                    (§ if (§ expr txDependency.getConfidence(§ pars ).getConfidenceType(§ pars ).equals(§ pars ConfidenceType.IN_CONFLICT)))
                    (§ block
                        (§ if (§ expr isNotSpendingTxnsInConfidenceType(§ pars txDependency, ConfidenceType.IN_CONFLICT)))
                        (§ block
                            (§ call txDependency.getConfidence(§ pars ).setConfidenceType(§ pars ConfidenceType.PENDING))
                            (§ call confidenceChanged.put(§ pars txDependency, TransactionConfidence.Listener.ChangeReason.TYPE))
                        )
                    )
                )
            )
        )

        (§ ass onWalletChangedSuppressions = onWalletChangedSuppressions - 1)

        ;; Side chains don't affect confidence.
        (§ if (§ expr bestChain))
        (§ block
            ;; notifyNewBestBlock will be invoked next and will then call maybeQueueOnWalletChanged for us.
            (§ call confidenceChanged.put(§ pars tx, TransactionConfidence.Listener.ChangeReason.TYPE))
        )
        (§ else )
        (§ block
            (§ call maybeQueueOnWalletChanged(§ pars ))
        )

        ;; Inform anyone interested that we have received or sent coins but only if:
        ;;  - This is not due to a re-org.
        ;;  - The coins appeared on the best chain.
        ;;  - We did in fact receive some new money.
        ;;  - We have not already informed the user about the coins when we received the tx broadcast,
        ;;    or for our own spends.  If users want to know when a broadcast tx becomes confirmed,
        ;;    they need to use tx confidence listeners.
        (§ if (§ expr !insideReorg && bestChain))
        (§ block
            (§ var Coin newBalance = getBalance(§ pars )) ;; This is slow.
            (§ call log.info(§ pars "Balance is now: " + newBalance.toFriendlyString(§ pars )))
            (§ if (§ expr !wasPending))
            (§ block
                (§ var int diff = valueDifference.signum(§ pars ))
                ;; We pick one callback based on the value difference, though a tx can of course both
                ;; send and receive coins from the wallet.
                (§ if (§ expr 0 < diff))
                (§ block
                    (§ call queueOnCoinsReceived(§ pars tx, prevBalance, newBalance))
                )
                (§ elseif (§ expr diff < 0))
                (§ block
                    (§ call queueOnCoinsSent(§ pars tx, prevBalance, newBalance))
                )
            )
            (§ call checkBalanceFuturesLocked(§ pars newBalance))
        )

        (§ call informConfidenceListenersIfNotReorganizing(§ pars ))
        (§ call isConsistentOrThrow(§ pars ))
        ;; Optimization for the case where a block has tons of relevant transactions.
        (§ call saveLater(§ pars ))
        (§ ass hardSaveOnNextBlock = true)
    )

    ;;; Finds if tx is NOT spending other txns which are in the specified confidence type. ;;
    #_private
    (§ method boolean isNotSpendingTxnsInConfidenceType(§ args Transaction tx, ConfidenceType confidenceType))
    (§ block
        (§ for (§ var TransactionInput txInput) :for (§ expr tx.getInputs(§ pars )))
        (§ block
            (§ var Transaction connectedTx = this.getTransaction(§ pars txInput.getOutpoint(§ pars ).getHash(§ pars )))
            (§ if (§ expr connectedTx != nil && connectedTx.getConfidence(§ pars ).getConfidenceType(§ pars ).equals(§ pars confidenceType)))
            (§ block
                (§ return false)
            )
        )
        (§ return true)
    )

    ;;;
     ; Creates and returns a new List with the same txns as inputSet, but txns are sorted by depencency
     ; (a topological sort).  If tx B spends tx A, then tx A should be before tx B on the returned List.
     ; Several invocations to this method with the same inputSet could result in lists with txns in different
     ; order, as there is no guarantee on the order of the returned txns besides what was already stated.
     ;;
    (§ method List<Transaction> sortTxnsByDependency(§ args Set<Transaction> inputSet))
    (§ block
        (§ var ArrayList<Transaction> result = new ArrayList<>(§ pars inputSet))
        (§ for (§ var int i = 0) :for (§ expr i < result.size(§ pars ) - 1) :for (§ ass i = i + 1))
        (§ block
            (§ var boolean txAtISpendsOtherTxInTheList)
            (§ do )
            (§ block
                (§ ass txAtISpendsOtherTxInTheList = false)
                (§ for (§ var int j = i + 1) :for (§ expr j < result.size(§ pars )) :for (§ ass j = j + 1))
                (§ block
                    (§ if (§ expr spends(§ pars result.get(§ pars i), result.get(§ pars j))))
                    (§ block
                        (§ var Transaction transactionAtI = result.remove(§ pars i))
                        (§ call result.add(§ pars j, transactionAtI))
                        (§ ass txAtISpendsOtherTxInTheList = true)
                        (§ break )
                    )
                )
            )
            (§ again (§ expr txAtISpendsOtherTxInTheList))
        )
        (§ return result)
    )

    ;;; Finds whether txA spends txB. ;;
    (§ method boolean spends(§ args Transaction txA, Transaction txB))
    (§ block
        (§ for (§ var TransactionInput txInput) :for (§ expr txA.getInputs(§ pars )))
        (§ block
            (§ if (§ expr txInput.getOutpoint(§ pars ).getHash(§ pars ).equals(§ pars txB.getHash(§ pars ))))
            (§ block
                (§ return true)
            )
        )

        (§ return false)
    )

    #_private
    (§ method void informConfidenceListenersIfNotReorganizing(§ args ))
    (§ block
        (§ if (§ expr insideReorg))
        (§ block
            (§ return )
        )

        (§ for (§ var Map.Entry<Transaction, TransactionConfidence.Listener.ChangeReason> entry) :for (§ expr confidenceChanged.entrySet(§ pars )))
        (§ block
            #_final
            (§ var Transaction tx = entry.getKey(§ pars ))
            (§ call tx.getConfidence(§ pars ).queueListeners(§ pars entry.getValue(§ pars )))
            (§ call queueOnTransactionConfidenceChanged(§ pars tx))
        )
        (§ call confidenceChanged.clear(§ pars ))
    )

    ;;;
     ; Called by the {@link BlockChain} when a new block on the best chain is seen, AFTER relevant wallet
     ; transactions are extracted and sent to us UNLESS the new block caused a re-org, in which case this will
     ; not be called (the {@link Wallet#reorganize(StoredBlock, java.util.List, java.util.List)} method will
     ; call this one in that case).
     ;
     ; Used to update confidence data in each transaction and last seen block hash.  Triggers auto saving.
     ; Invokes the onWalletChanged event listener if there were any affected transactions.
     ;;
    #_override
    #_public
    (§ method void notifyNewBestBlock(§ args StoredBlock block))
        (§ throws VerificationException)
    (§ block
        ;; Check to see if this block has been seen before.
        (§ var Sha256Hash newBlockHash = block.getHeader(§ pars ).getHash(§ pars ))
        (§ if (§ expr newBlockHash.equals(§ pars getLastBlockSeenHash(§ pars ))))
        (§ block
            (§ return )
        )

        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; Store the new block hash.
            (§ call setLastBlockSeenHash(§ pars newBlockHash))
            (§ call setLastBlockSeenHeight(§ pars block.getHeight(§ pars )))
            (§ call setLastBlockSeenTimeSecs(§ pars block.getHeader(§ pars ).getTimeSeconds(§ pars )))
            ;; Notify all the BUILDING transactions of the new block.
            ;; This is so that they can update their depth.
            (§ var Set<Transaction> transactions = getTransactions(§ pars true))
            (§ for (§ var Transaction tx) :for (§ expr transactions))
            (§ block
                (§ if (§ expr ignoreNextNewBlock.contains(§ pars tx.getHash(§ pars ))))
                (§ block
                    ;; tx was already processed in receive() due to it appearing in this block, so we don't want
                    ;; to increment the tx confidence depth twice, it'd result in miscounting.
                    (§ call ignoreNextNewBlock.remove(§ pars tx.getHash(§ pars )))
                )
                (§ else )
                (§ block
                    (§ var TransactionConfidence confidence = tx.getConfidence(§ pars ))
                    (§ if (§ expr confidence.getConfidenceType(§ pars ) == ConfidenceType.BUILDING))
                    (§ block
                        ;; Erase the set of seen peers once the tx is so deep that it seems unlikely to ever go
                        ;; pending again.  We could clear this data the moment a tx is seen in the block chain,
                        ;; but in cases where the chain re-orgs, this would mean that wallets would perceive a
                        ;; newly pending tx has zero confidence at all, which would not be right: we expect it to
                        ;; be included once again.  We could have a separate was-in-chain-and-now-isn't confidence
                        ;; type, but this way is backwards compatible with existing software, and the new state
                        ;; probably wouldn't mean anything different to just remembering peers anyway.
                        (§ if (§ expr context.getEventHorizon(§ pars ) < confidence.incrementDepthInBlocks(§ pars )))
                        (§ block
                            (§ call confidence.clearBroadcastBy(§ pars ))
                        )
                        (§ call confidenceChanged.put(§ pars tx, TransactionConfidence.Listener.ChangeReason.DEPTH))
                    )
                )
            )

            (§ call informConfidenceListenersIfNotReorganizing(§ pars ))
            (§ call maybeQueueOnWalletChanged(§ pars ))

            (§ if (§ expr hardSaveOnNextBlock))
            (§ block
                (§ call saveNow(§ pars ))
                (§ ass hardSaveOnNextBlock = false)
            )
            (§ else )
            (§ block
                ;; Coalesce writes to avoid throttling on disk access when catching up with the chain.
                (§ call saveLater(§ pars ))
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Handle when a transaction becomes newly active on the best chain, either due to receiving a new block or a
     ; re-org.  Places the tx into the right pool, handles coinbase transactions, handles double-spends and so on.
     ;;
    #_private
    (§ method void processTxFromBestChain(§ args Transaction tx, boolean forceAddToPool))
        (§ throws VerificationException)
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ call Preconditions.checkState(§ pars !pending.containsKey(§ pars tx.getHash(§ pars ))))

        ;; This TX may spend our existing outputs even though it was not pending.  This can happen in unit tests,
        ;; if keys are moved between wallets, if we're catching up to the chain given only a set of keys,
        ;; or if a dead coinbase transaction has moved back onto the main chain.
        (§ var boolean isDeadCoinbase = (§ expr tx.isCoinBase(§ pars ) && dead.containsKey(§ pars tx.getHash(§ pars ))))
        (§ if (§ expr isDeadCoinbase))
        (§ block
            ;; There is a dead coinbase tx being received on the best chain.  A coinbase tx is made dead when it moves
            ;; to a side chain but it can be switched back on a reorg and resurrected back to spent or unspent.
            ;; So take it out of the dead pool.  Note that we don't resurrect dependent transactions here, even though
            ;; we could.  Bitcoin Core nodes on the network have deleted the dependent transactions from their mempools
            ;; entirely by this point.  We could and maybe should rebroadcast them so the network remembers and tries
            ;; to confirm them again.  But this is a deeply unusual edge case that due to the maturity rule should never
            ;; happen in practice, thus for simplicities sake we ignore it here.
            (§ call log.info(§ pars "  coinbase tx <-dead: confidence {}", tx.getHashAsString(§ pars ), tx.getConfidence(§ pars ).getConfidenceType(§ pars ).name(§ pars )))
            (§ call dead.remove(§ pars tx.getHash(§ pars )))
        )

        ;; Update tx and other unspent/pending transactions by connecting inputs/outputs.
        (§ call updateForSpends(§ pars tx, true))

        ;; Now make sure it ends up in the right pool.  Also, handle the case where this TX is double-spending
        ;; against our pending transactions.  Note that a tx may double spend our pending transactions and also
        ;; send us money/spend our money.
        (§ var boolean hasOutputsToMe = (§ expr 0 < tx.getValueSentToMe(§ pars this).signum(§ pars )))
        (§ var boolean hasOutputsFromMe = false)
        (§ if (§ expr hasOutputsToMe))
        (§ block
            ;; Needs to go into either unspent or spent (if the outputs were already spent by a pending tx).
            (§ if (§ expr tx.isEveryOwnedOutputSpent(§ pars this)))
            (§ block
                (§ call log.info(§ pars "  tx {} ->spent (by pending)", tx.getHashAsString(§ pars )))
                (§ call addWalletTransaction(§ pars Pool.SPENT, tx))
            )
            (§ else )
            (§ block
                (§ call log.info(§ pars "  tx {} ->unspent", tx.getHashAsString(§ pars )))
                (§ call addWalletTransaction(§ pars Pool.UNSPENT, tx))
            )
        )
        (§ elseif (§ expr 0 < tx.getValueSentFromMe(§ pars this).signum(§ pars )))
        (§ block
            (§ ass hasOutputsFromMe = true)
            ;; Didn't send us any money, but did spend some.  Keep it around for record keeping purposes.
            (§ call log.info(§ pars "  tx {} ->spent", tx.getHashAsString(§ pars )))
            (§ call addWalletTransaction(§ pars Pool.SPENT, tx))
        )
        (§ elseif (§ expr forceAddToPool))
        (§ block
            ;; Was manually added to pending, so we should keep it to notify the user of confidence information.
            (§ call log.info(§ pars "  tx {} ->spent (manually added)", tx.getHashAsString(§ pars )))
            (§ call addWalletTransaction(§ pars Pool.SPENT, tx))
        )

        ;; Kill txns in conflict with this tx.
        (§ var Set<Transaction> doubleSpendTxns = findDoubleSpendsAgainst(§ pars tx, pending))
        (§ if (§ expr !doubleSpendTxns.isEmpty(§ pars )))
        (§ block
            ;; No need to addTransactionsDependingOn(doubleSpendTxns), because killTxns() already kills dependencies.
            (§ call killTxns(§ pars doubleSpendTxns, tx))
        )
        (§ if (§ expr !hasOutputsToMe && !hasOutputsFromMe && !forceAddToPool && !findDoubleSpendsAgainst(§ pars tx, transactions).isEmpty(§ pars )))
        (§ block
            ;; Disconnect irrelevant inputs (otherwise might cause protobuf serialization issue).
            (§ for (§ var TransactionInput input) :for (§ expr tx.getInputs(§ pars )))
            (§ block
                (§ var TransactionOutput output = input.getConnectedOutput(§ pars ))
                (§ if (§ expr output != nil && !output.isMine(§ pars this)))
                (§ block
                    (§ call input.disconnect(§ pars ))
                )
            )
        )
    )

    ;;;
     ; <p>Updates the wallet by checking if this TX spends any of our outputs, and marking them as spent if so.
     ; If fromChain is true, also checks to see if any pending transaction spends outputs of this transaction and marks
     ; the spent flags appropriately.</p>
     ;
     ; <p>It can be called in two contexts.  One is when we receive a transaction on the best chain but it wasn't pending,
     ; this most commonly happens when we have a set of keys but the wallet transactions were wiped and we are catching
     ; up with the block chain.  It can also happen if a block includes a transaction we never saw at broadcast time.
     ; If this tx double spends, it takes precedence over our pending transactions and the pending tx goes dead.</p>
     ;
     ; <p>The other context it can be called is from {@link Wallet#receivePending(Transaction, java.util.List)},
     ; i.e. we saw a tx be broadcast or one was submitted directly that spends our own coins.  If this tx double spends,
     ; it does NOT take precedence because the winner will be resolved by the miners - we assume that our version will
     ; win, if we are wrong then when a block appears the tx will go dead.</p>
     ;
     ; @param tx The transaction which is being updated.
     ; @param fromChain If true, the tx appeared on the current best chain, if false it was pending.
     ;;
    #_private
    (§ method void updateForSpends(§ args Transaction tx, boolean fromChain))
        (§ throws VerificationException)
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ if (§ expr fromChain))
        (§ block
            (§ call Preconditions.checkState(§ pars !pending.containsKey(§ pars tx.getHash(§ pars ))))
        )

        (§ for (§ var TransactionInput input) :for (§ expr tx.getInputs(§ pars )))
        (§ block
            (§ var TransactionInput.ConnectionResult result = input.connect(§ pars unspent, TransactionInput.ConnectMode.ABORT_ON_CONFLICT))
            (§ if (§ expr result == TransactionInput.ConnectionResult.NO_SUCH_TX))
            (§ block
                ;; Not found in the unspent map.  Try again with the spent map.
                (§ ass result = input.connect(§ pars spent, TransactionInput.ConnectMode.ABORT_ON_CONFLICT))
                (§ if (§ expr result == TransactionInput.ConnectionResult.NO_SUCH_TX))
                (§ block
                    ;; Not found in the unspent and spent maps.  Try again with the pending map.
                    (§ ass result = input.connect(§ pars pending, TransactionInput.ConnectMode.ABORT_ON_CONFLICT))
                    (§ if (§ expr result == TransactionInput.ConnectionResult.NO_SUCH_TX))
                    (§ block
                        ;; Doesn't spend any of our outputs or is coinbase.
                        (§ continue )
                    )
                )
            )

            (§ var TransactionOutput output = Preconditions.checkNotNull(§ pars input.getConnectedOutput(§ pars )))
            (§ if (§ expr result == TransactionInput.ConnectionResult.ALREADY_SPENT))
            (§ block
                (§ if (§ expr fromChain))
                (§ block
                    ;; Can be:
                    ;; (1) We already marked this output as spent when we saw the pending transaction (most likely).
                    ;;     Now it's being confirmed of course, we cannot mark it as spent again.
                    ;; (2) A double spend from chain: this will be handled later by findDoubleSpendsAgainst()/killTxns().
                    ;;
                    ;; In any case, nothing to do here.
                )
                (§ else )
                (§ block
                    ;; We saw two pending transactions that double spend each other.  We don't know which will win.
                    ;; This can happen in the case of bad network nodes that mutate transactions.  Do a hex dump
                    ;; so the exact nature of the mutation can be examined.
                    (§ call log.warn(§ pars "Saw two pending transactions double spend each other"))
                    (§ call log.warn(§ pars "  offending input is input {}", tx.getInputs(§ pars ).indexOf(§ pars input)))
                    (§ call log.warn(§ pars "{}: {}", tx.getHash(§ pars ), Utils.HEX.encode(§ pars tx.unsafeBitcoinSerialize(§ pars ))))
                    (§ var Transaction other = output.getSpentBy(§ pars ).getParentTransaction(§ pars ))
                    (§ call log.warn(§ pars "{}: {}", other.getHash(§ pars ), Utils.HEX.encode(§ pars other.unsafeBitcoinSerialize(§ pars ))))
                )
            )
            (§ elseif (§ expr result == TransactionInput.ConnectionResult.SUCCESS))
            (§ block
                ;; Otherwise we saw a transaction spend our coins, but we didn't try and spend them ourselves yet.
                ;; The outputs are already marked as spent by the connect call above, so check if there are any more for
                ;; us to use.  Move if not.
                (§ var Transaction connected = Preconditions.checkNotNull(§ pars input.getConnectedTransaction(§ pars )))
                (§ call log.info(§ pars "  marked {} as spent by {}", input.getOutpoint(§ pars ), tx.getHashAsString(§ pars )))
                (§ call maybeMovePool(§ pars connected, "prevtx"))
                ;; Just because it's connected, doesn't mean it's actually ours: sometimes we have total visibility.
                (§ if (§ expr output.isMine(§ pars this)))
                (§ block
                    (§ call Preconditions.checkState(§ pars myUnspents.remove(§ pars output)))
                )
            )
        )

        ;; Now check each output and see if there is a pending transaction which spends it.  This shouldn't normally
        ;; ever occur because we expect transactions to arrive in temporal order, but this assumption can be violated
        ;; when we receive a pending transaction from the mempool that is relevant to us, which spends coins that we
        ;; didn't see arrive on the best chain yet.  For instance, because of a chain replay or because of our keys were
        ;; used by another wallet somewhere else.  Also, unconfirmed transactions can arrive from the mempool in more
        ;; or less random order.
        (§ for (§ var Transaction pendingTx) :for (§ expr pending.values(§ pars )))
        (§ block
            (§ for (§ var TransactionInput input) :for (§ expr pendingTx.getInputs(§ pars )))
            (§ block
                (§ var TransactionInput.ConnectionResult result = input.connect(§ pars tx, TransactionInput.ConnectMode.ABORT_ON_CONFLICT))
                (§ if (§ expr fromChain))
                (§ block
                    ;; This TX is supposed to have just appeared on the best chain, so its outputs should not be marked
                    ;; as spent yet.  If they are, it means something is happening out of order.
                    (§ call Preconditions.checkState(§ pars result != TransactionInput.ConnectionResult.ALREADY_SPENT))
                )
                (§ if (§ expr result == TransactionInput.ConnectionResult.SUCCESS))
                (§ block
                    (§ call log.info(§ pars "Connected pending tx input {}:{}", pendingTx.getHashAsString(§ pars ), pendingTx.getInputs(§ pars ).indexOf(§ pars input)))
                    ;; The unspents map might not have it if we never saw this tx until it was included in the chain
                    ;; and thus becomes spent the moment we become aware of it.
                    (§ if (§ expr myUnspents.remove(§ pars input.getConnectedOutput(§ pars ))))
                    (§ block
                        (§ call log.info(§ pars "Removed from UNSPENTS: {}", input.getConnectedOutput(§ pars )))
                    )
                )
            )
        )
        (§ if (§ expr !fromChain))
        (§ block
            (§ call maybeMovePool(§ pars tx, "pendingtx"))
        )
        (§ else )
        (§ block
            ;; If the transactions outputs are now all spent, it will be moved into the spent pool by the
            ;; processTxFromBestChain method.
        )
    )

    ;; Updates the wallet when a double spend occurs.  overridingTx can be null for the case of coinbases.
    #_private
    (§ method void killTxns(§ args Set<Transaction> txnsToKill, #_nilable Transaction overridingTx))
    (§ block
        (§ var LinkedList<Transaction> work = new LinkedList<>(§ pars txnsToKill))
        (§ while (§ expr !work.isEmpty(§ pars )))
        (§ block
            #_final
            (§ var Transaction tx = work.poll(§ pars ))
            (§ call log.warn(§ pars "TX {} killed{}", tx.getHashAsString(§ pars ), (§ expr overridingTx != nil) ? " by " + overridingTx.getHashAsString(§ pars ) :else ""))
            (§ call log.warn(§ pars "Disconnecting each input and moving connected transactions."))
            ;; TX could be pending (finney attack), or in unspent/spent (coinbase killed by reorg).
            (§ call pending.remove(§ pars tx.getHash(§ pars )))
            (§ call unspent.remove(§ pars tx.getHash(§ pars )))
            (§ call spent.remove(§ pars tx.getHash(§ pars )))
            (§ call addWalletTransaction(§ pars Pool.DEAD, tx))
            (§ for (§ var TransactionInput deadInput) :for (§ expr tx.getInputs(§ pars )))
            (§ block
                (§ var Transaction connected = deadInput.getConnectedTransaction(§ pars ))
                (§ if (§ expr connected == nil))
                (§ block
                    (§ continue )
                )
                (§ if (§ expr connected.getConfidence(§ pars ).getConfidenceType(§ pars ) != ConfidenceType.DEAD && deadInput.getConnectedOutput(§ pars ).getSpentBy(§ pars ) != nil && deadInput.getConnectedOutput(§ pars ).getSpentBy(§ pars ).equals(§ pars deadInput)))
                (§ block
                    (§ call Preconditions.checkState(§ pars myUnspents.add(§ pars deadInput.getConnectedOutput(§ pars ))))
                    (§ call log.info(§ pars "Added to UNSPENTS: {} in {}", deadInput.getConnectedOutput(§ pars ), deadInput.getConnectedOutput(§ pars ).getParentTransaction(§ pars ).getHash(§ pars )))
                )
                (§ call deadInput.disconnect(§ pars ))
                (§ call maybeMovePool(§ pars connected, "kill"))
            )
            (§ call tx.getConfidence(§ pars ).setOverridingTransaction(§ pars overridingTx))
            (§ call confidenceChanged.put(§ pars tx, TransactionConfidence.Listener.ChangeReason.TYPE))
            ;; Now kill any transactions we have that depended on this one.
            (§ for (§ var TransactionOutput deadOutput) :for (§ expr tx.getOutputs(§ pars )))
            (§ block
                (§ if (§ expr myUnspents.remove(§ pars deadOutput)))
                (§ block
                    (§ call log.info(§ pars "XX Removed from UNSPENTS: {}", deadOutput))
                )
                (§ var TransactionInput connected = deadOutput.getSpentBy(§ pars ))
                (§ if (§ expr connected == nil))
                (§ block
                    (§ continue )
                )
                #_final
                (§ var Transaction parentTransaction = connected.getParentTransaction(§ pars ))
                (§ call log.info(§ pars "This death invalidated dependent tx {}", parentTransaction.getHash(§ pars )))
                (§ call work.push(§ pars parentTransaction))
            )
        )
        (§ if (§ expr overridingTx == nil))
        (§ block
            (§ return )
        )

        (§ call log.warn(§ pars "Now attempting to connect the inputs of the overriding transaction."))
        (§ for (§ var TransactionInput input) :for (§ expr overridingTx.getInputs(§ pars )))
        (§ block
            (§ var TransactionInput.ConnectionResult result = input.connect(§ pars unspent, TransactionInput.ConnectMode.DISCONNECT_ON_CONFLICT))
            (§ if (§ expr result == TransactionInput.ConnectionResult.SUCCESS))
            (§ block
                (§ call maybeMovePool(§ pars input.getConnectedTransaction(§ pars ), "kill"))
                (§ call myUnspents.remove(§ pars input.getConnectedOutput(§ pars )))
                (§ call log.info(§ pars "Removing from UNSPENTS: {}", input.getConnectedOutput(§ pars )))
            )
            (§ else )
            (§ block
                (§ ass result = input.connect(§ pars spent, TransactionInput.ConnectMode.DISCONNECT_ON_CONFLICT))
                (§ if (§ expr result == TransactionInput.ConnectionResult.SUCCESS))
                (§ block
                    (§ call maybeMovePool(§ pars input.getConnectedTransaction(§ pars ), "kill"))
                    (§ call myUnspents.remove(§ pars input.getConnectedOutput(§ pars )))
                    (§ call log.info(§ pars "Removing from UNSPENTS: {}", input.getConnectedOutput(§ pars )))
                )
            )
        )
    )

    ;;;
     ; If the transactions outputs are all marked as spent, and it's in the unspent map, move it.
     ; If the owned transactions outputs are not all marked as spent, and it's in the spent map, move it.
     ;;
    #_private
    (§ method void maybeMovePool(§ args Transaction tx, String context))
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ if (§ expr tx.isEveryOwnedOutputSpent(§ pars this)))
        (§ block
            ;; There's nothing left I can spend in this transaction.
            (§ if (§ expr unspent.remove(§ pars tx.getHash(§ pars )) != nil))
            (§ block
                (§ if (§ expr log.isInfoEnabled(§ pars )))
                (§ block
                    (§ call log.info(§ pars "  {} {} <-unspent ->spent", tx.getHashAsString(§ pars ), context))
                )
                (§ call spent.put(§ pars tx.getHash(§ pars ), tx))
            )
        )
        (§ else )
        (§ block
            (§ if (§ expr spent.remove(§ pars tx.getHash(§ pars )) != nil))
            (§ block
                (§ if (§ expr log.isInfoEnabled(§ pars )))
                (§ block
                    (§ call log.info(§ pars "  {} {} <-spent ->unspent", tx.getHashAsString(§ pars ), context))
                )
                (§ call unspent.put(§ pars tx.getHash(§ pars ), tx))
            )
        )
    )

    ;;;
     ; Calls {@link Wallet#commitTx} if tx is not already in the pending pool.
     ;
     ; @return true if the tx was added to the wallet, or false if it was already in the pending pool.
     ;;
    #_public
    (§ method boolean maybeCommitTx(§ args Transaction tx))
        (§ throws VerificationException)
    (§ block
        (§ call tx.verify(§ pars ))
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr pending.containsKey(§ pars tx.getHash(§ pars ))))
            (§ block
                (§ return false)
            )

            (§ call log.info(§ pars "commitTx of {}", tx.getHashAsString(§ pars )))
            (§ var Coin balance = getBalance(§ pars ))
            (§ call tx.setUpdateTime(§ pars Utils.now(§ pars )))
            ;; Put any outputs that are sending money back to us into the unspents map, and calculate their total value.
            (§ var Coin valueSentToMe = Coin.ZERO)
            (§ for (§ var TransactionOutput o) :for (§ expr tx.getOutputs(§ pars )))
            (§ block
                (§ if (§ expr o.isMine(§ pars this)))
                (§ block
                    (§ ass valueSentToMe = valueSentToMe.add(§ pars o.getValue(§ pars )))
                )
            )
            ;; Mark the outputs we're spending as spent so we won't try and use them in future creations.  This will also
            ;; move any transactions that are now fully spent to the spent map so we can skip them when creating future
            ;; spends.
            (§ call updateForSpends(§ pars tx, false))

            (§ var Set<Transaction> doubleSpendPendingTxns = findDoubleSpendsAgainst(§ pars tx, pending))
            (§ var Set<Transaction> doubleSpendUnspentTxns = findDoubleSpendsAgainst(§ pars tx, unspent))
            (§ var Set<Transaction> doubleSpendSpentTxns = findDoubleSpendsAgainst(§ pars tx, spent))

            (§ if (§ expr !doubleSpendUnspentTxns.isEmpty(§ pars ) || !doubleSpendSpentTxns.isEmpty(§ pars ) || !isNotSpendingTxnsInConfidenceType(§ pars tx, ConfidenceType.DEAD)))
            (§ block
                ;; tx is a double spend against a tx already in the best chain or spends outputs of a DEAD tx.
                ;; Add tx to the dead pool and schedule confidence listener notifications.
                (§ call log.info(§ pars "->dead: {}", tx.getHashAsString(§ pars )))
                (§ call tx.getConfidence(§ pars ).setConfidenceType(§ pars ConfidenceType.DEAD))
                (§ call confidenceChanged.put(§ pars tx, TransactionConfidence.Listener.ChangeReason.TYPE))
                (§ call addWalletTransaction(§ pars Pool.DEAD, tx))
            )
            (§ elseif (§ expr !doubleSpendPendingTxns.isEmpty(§ pars ) || !isNotSpendingTxnsInConfidenceType(§ pars tx, ConfidenceType.IN_CONFLICT)))
            (§ block
                ;; tx is a double spend against a pending tx or spends outputs of a tx already IN_CONFLICT.
                ;; Add tx to the pending pool.  Update the confidence type of tx, the txns in conflict with tx
                ;; and all their dependencies to IN_CONFLICT and schedule confidence listener notifications.
                (§ call log.info(§ pars "->pending (IN_CONFLICT): {}", tx.getHashAsString(§ pars )))
                (§ call addWalletTransaction(§ pars Pool.PENDING, tx))
                (§ call doubleSpendPendingTxns.add(§ pars tx))
                (§ call addTransactionsDependingOn(§ pars doubleSpendPendingTxns, getTransactions(§ pars true)))
                (§ for (§ var Transaction doubleSpendTx) :for (§ expr doubleSpendPendingTxns))
                (§ block
                    (§ call doubleSpendTx.getConfidence(§ pars ).setConfidenceType(§ pars ConfidenceType.IN_CONFLICT))
                    (§ call confidenceChanged.put(§ pars doubleSpendTx, TransactionConfidence.Listener.ChangeReason.TYPE))
                )
            )
            (§ else )
            (§ block
                ;; No conflict detected.
                ;; Add to the pending pool and schedule confidence listener notifications.
                (§ call log.info(§ pars "->pending: {}", tx.getHashAsString(§ pars )))
                (§ call tx.getConfidence(§ pars ).setConfidenceType(§ pars ConfidenceType.PENDING))
                (§ call confidenceChanged.put(§ pars tx, TransactionConfidence.Listener.ChangeReason.TYPE))
                (§ call addWalletTransaction(§ pars Pool.PENDING, tx))
            )
            (§ if (§ expr log.isInfoEnabled(§ pars )))
            (§ block
                (§ call log.info(§ pars "Estimated balance is now: {}", getBalance(§ pars BalanceType.ESTIMATED).toFriendlyString(§ pars )))
            )

            ;; Mark any keys used in the outputs as "used", this allows wallet UI's to auto-advance the current key
            ;; they are showing to the user in qr codes etc.
            (§ call markKeysAsUsed(§ pars tx))
            (§ try )
            (§ block
                (§ var Coin valueSentFromMe = tx.getValueSentFromMe(§ pars this))
                (§ var Coin newBalance = balance.add(§ pars valueSentToMe).subtract(§ pars valueSentFromMe))
                (§ if (§ expr 0 < valueSentToMe.signum(§ pars )))
                (§ block
                    (§ call checkBalanceFuturesLocked(§ pars nil))
                    (§ call queueOnCoinsReceived(§ pars tx, balance, newBalance))
                )
                (§ if (§ expr 0 < valueSentFromMe.signum(§ pars )))
                (§ block
                    (§ call queueOnCoinsSent(§ pars tx, balance, newBalance))
                )

                (§ call maybeQueueOnWalletChanged(§ pars ))
            )
            (§ catch (§ args ScriptException e))
            (§ block
                ;; Cannot happen as we just created this transaction ourselves.
                (§ throw (§ new RuntimeException(§ pars e)))
            )

            (§ call isConsistentOrThrow(§ pars ))
            (§ call informConfidenceListenersIfNotReorganizing(§ pars ))
            (§ call saveNow(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
        (§ return true)
    )

    ;;;
     ; <p>Updates the wallet with the given transaction: puts it into the pending pool, sets the spent flags
     ; and runs the onCoinsSent/onCoinsReceived event listener.  Used in two situations:</p>
     ;
     ; <ol>
     ;     <li>When we have just successfully transmitted the tx we created to the network.</li>
     ;     <li>When we receive a pending transaction that didn't appear in the chain yet, and we did not create it.</li>
     ; </ol>
     ;
     ; <p>Triggers an auto save.</p>
     ;;
    #_public
    (§ method void commitTx(§ args Transaction tx))
        (§ throws VerificationException)
    (§ block
        (§ call Preconditions.checkArgument(§ pars maybeCommitTx(§ pars tx), "commitTx called on the same transaction twice"))
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  Runs the listener methods in the user thread.
     ;;
    #_public
    (§ method void addChangeEventListener(§ args WalletChangeEventListener listener))
    (§ block
        (§ call addChangeEventListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  The listener is executed by the given executor.
     ;;
    #_public
    (§ method void addChangeEventListener(§ args Executor executor, WalletChangeEventListener listener))
    (§ block
        ;; This is thread safe, so we don't need to take the lock.
        (§ call changeListeners.add(§ pars new ListenerRegistration<>(§ pars listener, executor)))
    )

    ;;;
     ; Adds an event listener object called when coins are received.
     ; Runs the listener methods in the user thread.
     ;;
    #_public
    (§ method void addCoinsReceivedEventListener(§ args WalletCoinsReceivedEventListener listener))
    (§ block
        (§ call addCoinsReceivedEventListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;;
     ; Adds an event listener object called when coins are received.
     ; The listener is executed by the given executor.
     ;;
    #_public
    (§ method void addCoinsReceivedEventListener(§ args Executor executor, WalletCoinsReceivedEventListener listener))
    (§ block
        ;; This is thread safe, so we don't need to take the lock.
        (§ call coinsReceivedListeners.add(§ pars new ListenerRegistration<>(§ pars listener, executor)))
    )

    ;;;
     ; Adds an event listener object called when coins are sent.
     ; Runs the listener methods in the user thread.
     ;;
    #_public
    (§ method void addCoinsSentEventListener(§ args WalletCoinsSentEventListener listener))
    (§ block
        (§ call addCoinsSentEventListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;;
     ; Adds an event listener object called when coins are sent.
     ; The listener is executed by the given executor.
     ;;
    #_public
    (§ method void addCoinsSentEventListener(§ args Executor executor, WalletCoinsSentEventListener listener))
    (§ block
        ;; This is thread safe, so we don't need to take the lock.
        (§ call coinsSentListeners.add(§ pars new ListenerRegistration<>(§ pars listener, executor)))
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when keys are
     ; added.  The listener is executed in the user thread.
     ;;
    #_public
    (§ method void addKeyChainEventListener(§ args KeyChainEventListener listener))
    (§ block
        (§ call keyChainGroup.addEventListener(§ pars listener, Threading.USER_THREAD))
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when keys are
     ; added.  The listener is executed by the given executor.
     ;;
    #_public
    (§ method void addKeyChainEventListener(§ args Executor executor, KeyChainEventListener listener))
    (§ block
        (§ call keyChainGroup.addEventListener(§ pars listener, executor))
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  Runs the listener methods in the user thread.
     ;;
    #_public
    (§ method void addReorganizeEventListener(§ args WalletReorganizeEventListener listener))
    (§ block
        (§ call addReorganizeEventListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  The listener is executed by the given executor.
     ;;
    #_public
    (§ method void addReorganizeEventListener(§ args Executor executor, WalletReorganizeEventListener listener))
    (§ block
        ;; This is thread safe, so we don't need to take the lock.
        (§ call reorganizeListeners.add(§ pars new ListenerRegistration<>(§ pars listener, executor)))
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when confidence
     ; of a transaction changes.  Runs the listener methods in the user thread.
     ;;
    #_public
    (§ method void addTransactionConfidenceEventListener(§ args TransactionConfidenceEventListener listener))
    (§ block
        (§ call addTransactionConfidenceEventListener(§ pars Threading.USER_THREAD, listener))
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when confidence
     ; of a transaction changes.  The listener is executed by the given executor.
     ;;
    #_public
    (§ method void addTransactionConfidenceEventListener(§ args Executor executor, TransactionConfidenceEventListener listener))
    (§ block
        ;; This is thread safe, so we don't need to take the lock.
        (§ call transactionConfidenceListeners.add(§ pars new ListenerRegistration<>(§ pars listener, executor)))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (§ method boolean removeChangeEventListener(§ args WalletChangeEventListener listener))
    (§ block
        (§ return ListenerRegistration.removeFromList(§ pars listener, changeListeners))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (§ method boolean removeCoinsReceivedEventListener(§ args WalletCoinsReceivedEventListener listener))
    (§ block
        (§ return ListenerRegistration.removeFromList(§ pars listener, coinsReceivedListeners))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (§ method boolean removeCoinsSentEventListener(§ args WalletCoinsSentEventListener listener))
    (§ block
        (§ return ListenerRegistration.removeFromList(§ pars listener, coinsSentListeners))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (§ method boolean removeKeyChainEventListener(§ args KeyChainEventListener listener))
    (§ block
        (§ return keyChainGroup.removeEventListener(§ pars listener))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (§ method boolean removeReorganizeEventListener(§ args WalletReorganizeEventListener listener))
    (§ block
        (§ return ListenerRegistration.removeFromList(§ pars listener, reorganizeListeners))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (§ method boolean removeTransactionConfidenceEventListener(§ args TransactionConfidenceEventListener listener))
    (§ block
        (§ return ListenerRegistration.removeFromList(§ pars listener, transactionConfidenceListeners))
    )

    #_private
    (§ method void queueOnTransactionConfidenceChanged(§ args #_final Transaction tx))
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ for (§ var #_final ListenerRegistration<TransactionConfidenceEventListener> registration) :for (§ expr transactionConfidenceListeners))
        (§ block
            (§ if (§ expr registration.executor == Threading.SAME_THREAD))
            (§ block
                (§ call registration.listener.onTransactionConfidenceChanged(§ pars this, tx))
            )
            (§ else )
            (§ block
                (§ call registration.executor.execute(§ pars (§ new Runnable(§ pars ))
                (§ anon
                    #_override
                    #_public
                    (§ method void run(§ args ))
                    (§ block
                        (§ call registration.listener.onTransactionConfidenceChanged(§ pars Wallet.this, tx))
                    )
                )))
            )
        )
    )

    #_protected
    (§ method void maybeQueueOnWalletChanged(§ args ))
    (§ block
        ;; Don't invoke the callback in some circumstances, e.g. whilst we are re-organizing or fiddling
        ;; with transactions due to a new block arriving.  It will be called later instead.
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ call Preconditions.checkState(§ pars 0 <= onWalletChangedSuppressions))

        (§ if (§ expr 0 < onWalletChangedSuppressions))
        (§ block
            (§ return )
        )

        (§ for (§ var #_final ListenerRegistration<WalletChangeEventListener> registration) :for (§ expr changeListeners))
        (§ block
            (§ call registration.executor.execute(§ pars (§ new Runnable(§ pars ))
            (§ anon
                #_override
                #_public
                (§ method void run(§ args ))
                (§ block
                    (§ call registration.listener.onWalletChanged(§ pars Wallet.this))
                )
            )))
        )
    )

    #_protected
    (§ method void queueOnCoinsReceived(§ args #_final Transaction tx, #_final Coin balance, #_final Coin newBalance))
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ for (§ var #_final ListenerRegistration<WalletCoinsReceivedEventListener> registration) :for (§ expr coinsReceivedListeners))
        (§ block
            (§ call registration.executor.execute(§ pars (§ new Runnable(§ pars ))
            (§ anon
                #_override
                #_public
                (§ method void run(§ args ))
                (§ block
                    (§ call registration.listener.onCoinsReceived(§ pars Wallet.this, tx, balance, newBalance))
                )
            )))
        )
    )

    #_protected
    (§ method void queueOnCoinsSent(§ args #_final Transaction tx, #_final Coin prevBalance, #_final Coin newBalance))
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ for (§ var #_final ListenerRegistration<WalletCoinsSentEventListener> registration) :for (§ expr coinsSentListeners))
        (§ block
            (§ call registration.executor.execute(§ pars (§ new Runnable(§ pars ))
            (§ anon
                #_override
                #_public
                (§ method void run(§ args ))
                (§ block
                    (§ call registration.listener.onCoinsSent(§ pars Wallet.this, tx, prevBalance, newBalance))
                )
            )))
        )
    )

    #_protected
    (§ method void queueOnReorganize(§ args ))
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ call Preconditions.checkState(§ pars insideReorg))

        (§ for (§ var #_final ListenerRegistration<WalletReorganizeEventListener> registration) :for (§ expr reorganizeListeners))
        (§ block
            (§ call registration.executor.execute(§ pars (§ new Runnable(§ pars ))
            (§ anon
                #_override
                #_public
                (§ method void run(§ args ))
                (§ block
                    (§ call registration.listener.onReorganize(§ pars Wallet.this))
                )
            )))
        )
    )

    ;;;
     ; Returns a set of all transactions in the wallet.
     ; @param includeDead If true, transactions that were overridden by a double spend are included.
     ;;
    #_public
    (§ method Set<Transaction> getTransactions(§ args boolean includeDead))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var Set<Transaction> all = new HashSet<>(§ pars ))
            (§ call all.addAll(§ pars unspent.values(§ pars )))
            (§ call all.addAll(§ pars spent.values(§ pars )))
            (§ call all.addAll(§ pars pending.values(§ pars )))
            (§ if (§ expr includeDead))
            (§ block
                (§ call all.addAll(§ pars dead.values(§ pars )))
            )
            (§ return all)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a set of all WalletTransactions in the wallet.
     ;;
    #_public
    (§ method Iterable<WalletTransaction> getWalletTransactions(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var Set<WalletTransaction> all = new HashSet<>(§ pars ))
            (§ call addWalletTransactionsToSet(§ pars all, Pool.UNSPENT, unspent.values(§ pars )))
            (§ call addWalletTransactionsToSet(§ pars all, Pool.SPENT, spent.values(§ pars )))
            (§ call addWalletTransactionsToSet(§ pars all, Pool.DEAD, dead.values(§ pars )))
            (§ call addWalletTransactionsToSet(§ pars all, Pool.PENDING, pending.values(§ pars )))
            (§ return all)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_private
    #_static
    (§ method void addWalletTransactionsToSet(§ args Set<WalletTransaction> txns, Pool poolType, Collection<Transaction> pool))
    (§ block
        (§ for (§ var Transaction tx) :for (§ expr pool))
        (§ block
            (§ call txns.add(§ pars (§ new WalletTransaction(§ pars poolType, tx))))
        )
    )

    ;;;
     ; Adds a transaction that has been associated with a particular wallet pool.  This is intended for usage by
     ; deserialization code, such as the {@link WalletProtobufSerializer} class.  It isn't normally useful for
     ; applications.  It does not trigger auto saving.
     ;;
    #_public
    (§ method void addWalletTransaction(§ args WalletTransaction wtx))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call addWalletTransaction(§ pars wtx.getPool(§ pars ), wtx.getTransaction(§ pars )))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Adds the given transaction to the given pools and registers a confidence change listener on it.
     ;;
    #_private
    (§ method void addWalletTransaction(§ args Pool pool, Transaction tx))
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ call transactions.put(§ pars tx.getHash(§ pars ), tx))
        (§ switch (§ expr pool))
        (§ block
            (§ case UNSPENT)
            (§ block
                (§ call Preconditions.checkState(§ pars unspent.put(§ pars tx.getHash(§ pars ), tx) == nil))
                (§ break )
            )
            (§ case SPENT)
            (§ block
                (§ call Preconditions.checkState(§ pars spent.put(§ pars tx.getHash(§ pars ), tx) == nil))
                (§ break )
            )
            (§ case PENDING)
            (§ block
                (§ call Preconditions.checkState(§ pars pending.put(§ pars tx.getHash(§ pars ), tx) == nil))
                (§ break )
            )
            (§ case DEAD)
            (§ block
                (§ call Preconditions.checkState(§ pars dead.put(§ pars tx.getHash(§ pars ), tx) == nil))
                (§ break )
            )
            (§ default )
            (§ block
                (§ throw (§ new RuntimeException(§ pars "Unknown wallet transaction type " + pool)))
            )
        )

        (§ if (§ expr pool == Pool.UNSPENT || pool == Pool.PENDING))
        (§ block
            (§ for (§ var TransactionOutput output) :for (§ expr tx.getOutputs(§ pars )))
            (§ block
                (§ if (§ expr output.isAvailableForSpending(§ pars ) && output.isMine(§ pars this)))
                (§ block
                    (§ call myUnspents.add(§ pars output))
                )
            )
        )
        ;; This is safe even if the listener has been added before, as TransactionConfidence ignores duplicate
        ;; registration requests.  That makes the code in the wallet simpler.
        (§ call tx.getConfidence(§ pars ).addEventListener(§ pars Threading.SAME_THREAD, txConfidenceListener))
    )

    ;;;
     ; Returns all non-dead, active transactions ordered by recency.
     ;;
    #_public
    (§ method List<Transaction> getTransactionsByTime(§ args ))
    (§ block
        (§ return getRecentTransactions(§ pars 0, false))
    )

    ;;;
     ; Returns an list of N transactions, ordered by increasing age.  Transactions on side chains are not included.
     ; Dead transactions (overridden by double spends) are optionally included.
     ;
     ; Note: the current implementation is O(num transactions in wallet).  Regardless of how many transactions are
     ; requested, the cost is always the same.  In future, requesting smaller numbers of transactions may be faster
     ; depending on how the wallet is implemented (e.g. if backed by a database).
     ;;
    #_public
    (§ method List<Transaction> getRecentTransactions(§ args int numTransactions, boolean includeDead))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call Preconditions.checkArgument(§ pars 0 <= numTransactions))

            ;; Firstly, put all transactions into an array.
            (§ var int size = unspent.size(§ pars ) + spent.size(§ pars ) + pending.size(§ pars ))
            (§ if (§ expr size < numTransactions || numTransactions == 0))
            (§ block
                (§ ass numTransactions = size)
            )

            (§ var ArrayList<Transaction> all = new ArrayList<>(§ pars getTransactions(§ pars includeDead)))
            ;; Order by update time.
            (§ call Collections.sort(§ pars all, Transaction.SORT_TX_BY_UPDATE_TIME))
            (§ if (§ expr numTransactions == all.size(§ pars )))
            (§ block
                (§ return all)
            )

            (§ call all.subList(§ pars numTransactions, all.size(§ pars )).clear(§ pars ))
            (§ return all)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a transaction object given its hash, if it exists in this wallet, or null otherwise.
     ;;
    #_nilable
    #_public
    (§ method Transaction getTransaction(§ args Sha256Hash hash))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return transactions.get(§ pars hash))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (§ method Map<Sha256Hash, Transaction> getTransactionPool(§ args Pool pool))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ switch (§ expr pool))
            (§ block
                (§ case UNSPENT)
                (§ block
                    (§ return unspent)
                )
                (§ case SPENT)
                (§ block
                    (§ return spent)
                )
                (§ case PENDING)
                (§ block
                    (§ return pending)
                )
                (§ case DEAD)
                (§ block
                    (§ return dead)
                )
                (§ default )
                (§ block
                    (§ throw (§ new RuntimeException(§ pars "Unknown wallet transaction type " + pool)))
                )
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Prepares the wallet for a blockchain replay.  Removes all transactions (as they would
     ; get in the way of the replay) and makes the wallet think it has never seen a block.
     ;;
    #_public
    (§ method void reset(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call clearTransactions(§ pars ))
            (§ ass lastBlockSeenHash = nil)
            (§ ass lastBlockSeenHeight = -1) ;; Magic value for 'never'.
            (§ ass lastBlockSeenTimeSecs = 0)
            (§ call saveLater(§ pars ))
            (§ call maybeQueueOnWalletChanged(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Deletes transactions which appeared above the given block height from the wallet, but does not touch the keys.
     ; This is useful if you have some keys and wish to replay the block chain into the wallet in order to pick them up.
     ; Triggers auto saving.
     ;;
    #_public
    (§ method void clearTransactions(§ args int fromHeight))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr fromHeight == 0))
            (§ block
                (§ call clearTransactions(§ pars ))
                (§ call saveLater(§ pars ))
            )
            (§ else )
            (§ block
                (§ throw (§ new UnsupportedOperationException(§ pars )))
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_private
    (§ method void clearTransactions(§ args ))
    (§ block
        (§ call unspent.clear(§ pars ))
        (§ call spent.clear(§ pars ))
        (§ call pending.clear(§ pars ))
        (§ call dead.clear(§ pars ))
        (§ call transactions.clear(§ pars ))
        (§ call myUnspents.clear(§ pars ))
    )

    ;;;
     ; Clean up the wallet.  Currently, it only removes risky pending transaction from the wallet and only
     ; if their outputs have not been spent.
     ;;
    #_public
    (§ method void cleanup(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var boolean dirty = false)
            (§ for (§ var Iterator<Transaction> i = pending.values(§ pars ).iterator(§ pars )) :for (§ expr i.hasNext(§ pars )) :for (§ expr ))
            (§ block
                (§ var Transaction tx = i.next(§ pars ))
                (§ if (§ expr isTransactionRisky(§ pars tx, nil) && !acceptRiskyTransactions))
                (§ block
                    (§ call log.debug(§ pars "Found risky transaction {} in wallet during cleanup.", tx.getHashAsString(§ pars )))
                    (§ if (§ expr !tx.isAnyOutputSpent(§ pars )))
                    (§ block
                        ;; Sync myUnspents with the change.
                        (§ for (§ var TransactionInput input) :for (§ expr tx.getInputs(§ pars )))
                        (§ block
                            (§ var TransactionOutput output = input.getConnectedOutput(§ pars ))
                            (§ if (§ expr output == nil))
                            (§ block
                                (§ continue )
                            )
                            (§ if (§ expr output.isMine(§ pars this)))
                            (§ block
                                (§ call Preconditions.checkState(§ pars myUnspents.add(§ pars output)))
                            )
                            (§ call input.disconnect(§ pars ))
                        )
                        (§ for (§ var TransactionOutput output) :for (§ expr tx.getOutputs(§ pars )))
                        (§ block
                            (§ call myUnspents.remove(§ pars output))
                        )

                        (§ call i.remove(§ pars ))
                        (§ call transactions.remove(§ pars tx.getHash(§ pars )))
                        (§ ass dirty = true)
                        (§ call log.info(§ pars "Removed transaction {} from pending pool during cleanup.", tx.getHashAsString(§ pars )))
                    )
                    (§ else )
                    (§ block
                        (§ call log.info(§ pars "Cannot remove transaction {} from pending pool during cleanup, as it's already spent partially.", tx.getHashAsString(§ pars )))
                    )
                )
            )
            (§ if (§ expr dirty))
            (§ block
                (§ call isConsistentOrThrow(§ pars ))
                (§ call saveLater(§ pars ))
                (§ if (§ expr log.isInfoEnabled(§ pars )))
                (§ block
                    (§ call log.info(§ pars "Estimated balance is now: {}", getBalance(§ pars BalanceType.ESTIMATED).toFriendlyString(§ pars )))
                )
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    (§ method EnumSet<Pool> getContainingPools(§ args Transaction tx))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var EnumSet<Pool> result = EnumSet.noneOf(§ pars Pool.class))
            (§ var Sha256Hash txHash = tx.getHash(§ pars ))
            (§ if (§ expr unspent.containsKey(§ pars txHash)))
            (§ block
                (§ call result.add(§ pars Pool.UNSPENT))
            )
            (§ if (§ expr spent.containsKey(§ pars txHash)))
            (§ block
                (§ call result.add(§ pars Pool.SPENT))
            )
            (§ if (§ expr pending.containsKey(§ pars txHash)))
            (§ block
                (§ call result.add(§ pars Pool.PENDING))
            )
            (§ if (§ expr dead.containsKey(§ pars txHash)))
            (§ block
                (§ call result.add(§ pars Pool.DEAD))
            )
            (§ return result)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_testing
    #_public
    (§ method int getPoolSize(§ args WalletTransaction.Pool pool))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ switch (§ expr pool))
            (§ block
                (§ case UNSPENT)
                (§ block
                    (§ return unspent.size(§ pars ))
                )
                (§ case SPENT)
                (§ block
                    (§ return spent.size(§ pars ))
                )
                (§ case PENDING)
                (§ block
                    (§ return pending.size(§ pars ))
                )
                (§ case DEAD)
                (§ block
                    (§ return dead.size(§ pars ))
                )
            )
            (§ throw (§ new RuntimeException(§ pars "Unreachable")))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_testing
    #_public
    (§ method boolean poolContainsTxHash(§ args #_final WalletTransaction.Pool pool, #_final Sha256Hash txHash))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ switch (§ expr pool))
            (§ block
                (§ case UNSPENT)
                (§ block
                    (§ return unspent.containsKey(§ pars txHash))
                )
                (§ case SPENT)
                (§ block
                    (§ return spent.containsKey(§ pars txHash))
                )
                (§ case PENDING)
                (§ block
                    (§ return pending.containsKey(§ pars txHash))
                )
                (§ case DEAD)
                (§ block
                    (§ return dead.containsKey(§ pars txHash))
                )
            )
            (§ throw (§ new RuntimeException(§ pars "Unreachable")))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;; Returns a copy of the internal unspent outputs list. ;;
    #_public
    (§ method List<TransactionOutput> getUnspents(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return new ArrayList<>(§ pars myUnspents))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method String toString(§ args ))
    (§ block
        (§ return toString(§ pars false, true, nil))
    )

    ;;;
     ; Formats the wallet as a human readable piece of text.  Intended for debugging, the format is
     ; not meant to be stable or human readable.
     ; @param includePrivateKeys Whether raw private key data should be included.
     ; @param includeTransactions Whether to print transaction data.
     ; @param chain If set, will be used to estimate lock times for block timelocked transactions.
     ;;
    #_public
    (§ method String toString(§ args boolean includePrivateKeys, boolean includeTransactions, #_nilable AbstractBlockChain chain))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var StringBuilder sb = new StringBuilder(§ pars ))
            (§ var Coin estimatedBalance = getBalance(§ pars BalanceType.ESTIMATED))
            (§ var Coin availableBalance = getBalance(§ pars BalanceType.AVAILABLE_SPENDABLE))
            (§ call sb.append(§ pars "Wallet containing ").append(§ pars estimatedBalance.toFriendlyString(§ pars )).append(§ pars " (spendable: ").append(§ pars availableBalance.toFriendlyString(§ pars )).append(§ pars ") in:\n"))
            (§ call sb.append(§ pars "  ").append(§ pars pending.size(§ pars )).append(§ pars " pending transactions\n"))
            (§ call sb.append(§ pars "  ").append(§ pars unspent.size(§ pars )).append(§ pars " unspent transactions\n"))
            (§ call sb.append(§ pars "  ").append(§ pars spent.size(§ pars )).append(§ pars " spent transactions\n"))
            (§ call sb.append(§ pars "  ").append(§ pars dead.size(§ pars )).append(§ pars " dead transactions\n"))
            #_final
            (§ var Date lastBlockSeenTime = getLastBlockSeenTime(§ pars ))
            (§ call sb.append(§ pars "Last seen best block: ").append(§ pars getLastBlockSeenHeight(§ pars )).append(§ pars " (").append(§ pars (§ expr lastBlockSeenTime == nil) ? "time unknown" :else Utils.dateTimeFormat(§ pars lastBlockSeenTime)).append(§ pars "): ").append(§ pars getLastBlockSeenHash(§ pars )).append(§ pars "\n"))
            #_final
            (§ var KeyCrypter crypter = keyChainGroup.getKeyCrypter(§ pars ))
            (§ if (§ expr crypter != nil))
            (§ block
                (§ call sb.append(§ pars "Encryption: ").append(§ pars crypter).append(§ pars "\n"))
            )
            (§ if (§ expr isWatching(§ pars )))
            (§ block
                (§ call sb.append(§ pars "Wallet is watching.\n"))
            )

            ;; Do the keys.
            (§ call sb.append(§ pars "\nKeys:\n"))
            (§ call sb.append(§ pars "Earliest creation time: ").append(§ pars Utils.dateTimeFormat(§ pars getEarliestKeyCreationTime(§ pars ) * 1000)).append(§ pars "\n"))
            #_final
            (§ var Date keyRotationTime = getKeyRotationTime(§ pars ))
            (§ if (§ expr keyRotationTime != nil))
            (§ block
                (§ call sb.append(§ pars "Key rotation time:      ").append(§ pars Utils.dateTimeFormat(§ pars keyRotationTime)).append(§ pars "\n"))
            )
            (§ call sb.append(§ pars keyChainGroup.toString(§ pars includePrivateKeys)))

            (§ if (§ expr includeTransactions))
            (§ block
                ;; Print the transactions themselves.
                (§ if (§ expr 0 < pending.size(§ pars )))
                (§ block
                    (§ call sb.append(§ pars "\n>>> PENDING:\n"))
                    (§ call toStringHelper(§ pars sb, pending, chain, Transaction.SORT_TX_BY_UPDATE_TIME))
                )
                (§ if (§ expr 0 < unspent.size(§ pars )))
                (§ block
                    (§ call sb.append(§ pars "\n>>> UNSPENT:\n"))
                    (§ call toStringHelper(§ pars sb, unspent, chain, Transaction.SORT_TX_BY_HEIGHT))
                )
                (§ if (§ expr 0 < spent.size(§ pars )))
                (§ block
                    (§ call sb.append(§ pars "\n>>> SPENT:\n"))
                    (§ call toStringHelper(§ pars sb, spent, chain, Transaction.SORT_TX_BY_HEIGHT))
                )
                (§ if (§ expr 0 < dead.size(§ pars )))
                (§ block
                    (§ call sb.append(§ pars "\n>>> DEAD:\n"))
                    (§ call toStringHelper(§ pars sb, dead, chain, Transaction.SORT_TX_BY_UPDATE_TIME))
                )
            )
            (§ return sb.toString(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
            (§ call lock.unlock(§ pars ))
        )
    )

    #_private
    (§ method void toStringHelper(§ args StringBuilder sb, Map<Sha256Hash, Transaction> transactionMap, #_nilable AbstractBlockChain chain, #_nilable Comparator<Transaction> sortOrder))
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        #_final
        (§ var Collection<Transaction> txns)
        (§ if (§ expr sortOrder != nil))
        (§ block
            (§ ass txns = new TreeSet<>(§ pars sortOrder))
            (§ call txns.addAll(§ pars transactionMap.values(§ pars )))
        )
        (§ else )
        (§ block
            (§ ass txns = transactionMap.values(§ pars ))
        )

        (§ for (§ var Transaction tx) :for (§ expr txns))
        (§ block
            (§ try )
            (§ block
                (§ call sb.append(§ pars tx.getValue(§ pars this).toFriendlyString(§ pars )))
                (§ call sb.append(§ pars " total value (sends "))
                (§ call sb.append(§ pars tx.getValueSentFromMe(§ pars this).toFriendlyString(§ pars )))
                (§ call sb.append(§ pars " and receives "))
                (§ call sb.append(§ pars tx.getValueSentToMe(§ pars this).toFriendlyString(§ pars )))
                (§ call sb.append(§ pars ")\n"))
            )
            (§ catch (§ args ScriptException _))
            (§ block
                ;; Ignore and don't print this line.
            )
            (§ if (§ expr tx.hasConfidence(§ pars )))
            (§ block
                (§ call sb.append(§ pars "  confidence: ").append(§ pars tx.getConfidence(§ pars )).append(§ pars "\n"))
            )
            (§ call sb.append(§ pars tx.toString(§ pars chain)))
        )
    )

    ;;;
     ; Returns an immutable view of the transactions currently waiting for network confirmations.
     ;;
    #_public
    (§ method Collection<Transaction> getPendingTransactions(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return Collections.unmodifiableCollection(§ pars pending.values(§ pars )))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the earliest creation time of keys or watched scripts in this wallet, in seconds since the epoch,
     ; i.e. the min of {@link org.bitcoinj.core.ECKey#getCreationTimeSeconds()}.  This can return zero if at least
     ; one key does not have that data (was created before key timestamping was implemented).
     ;
     ; This method is most often used in conjunction with {@link PeerGroup#setFastCatchupTimeSecs(long)} in order to
     ; optimize chain download for new users of wallet apps.  Backwards compatibility notice: if you get zero from this
     ; method, you can instead use the time of the first release of your software, as it's guaranteed no users will
     ; have wallets pre-dating this time.
     ;
     ; If there are no keys in the wallet, the current time is returned.
     ;;
    #_override
    #_public
    (§ method long getEarliestKeyCreationTime(§ args ))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var long earliestTime = keyChainGroup.getEarliestKeyCreationTime(§ pars ))
            (§ return (§ expr earliestTime == Long.MAX_VALUE) ? Utils.currentTimeSeconds(§ pars ) :else earliestTime)
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; Returns the hash of the last seen best-chain block, or null if the wallet is too old to store this data. ;;
    #_nilable
    #_public
    (§ method Sha256Hash getLastBlockSeenHash(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return lastBlockSeenHash)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_public
    (§ method void setLastBlockSeenHash(§ args #_nilable Sha256Hash lastBlockSeenHash))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass this.lastBlockSeenHash = lastBlockSeenHash)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_public
    (§ method void setLastBlockSeenHeight(§ args int lastBlockSeenHeight))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass this.lastBlockSeenHeight = lastBlockSeenHeight)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_public
    (§ method void setLastBlockSeenTimeSecs(§ args long timeSecs))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass lastBlockSeenTimeSecs = timeSecs)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the UNIX time in seconds since the epoch extracted from the last best seen block header.  This timestamp
     ; is <b>not</b> the local time at which the block was first observed by this application but rather what the block
     ; (i.e. miner) self declares.  It is allowed to have some significant drift from the real time at which the block
     ; was found, although most miners do use accurate times.  If this wallet is old and does not have a recorded
     ; time then this method returns zero.
     ;;
    #_public
    (§ method long getLastBlockSeenTimeSecs(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return lastBlockSeenTimeSecs)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a {@link Date} representing the time extracted from the last best seen block header.  This timestamp
     ; is <b>not</b> the local time at which the block was first observed by this application but rather what the block
     ; (i.e. miner) self declares.  It is allowed to have some significant drift from the real time at which the block
     ; was found, although most miners do use accurate times.  If this wallet is old and does not have a recorded
     ; time then this method returns null.
     ;;
    #_nilable
    #_public
    (§ method Date getLastBlockSeenTime(§ args ))
    (§ block
        #_final
        (§ var long secs = getLastBlockSeenTimeSecs(§ pars ))
        (§ return (§ quest (§ expr secs == 0) ? nil :else new Date(§ pars secs * 1000)))
    )

    ;;;
     ; Returns the height of the last seen best-chain block.  Can be 0 if a wallet is brand new or -1 if the wallet
     ; is old and doesn't have that data.
     ;;
    #_public
    (§ method int getLastBlockSeenHeight(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return lastBlockSeenHeight)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Get the version of the Wallet.
     ; This is an int you can use to indicate which versions of wallets your code understands,
     ; and which come from the future (and hence cannot be safely loaded).
     ;;
    #_public
    (§ method int getVersion(§ args ))
    (§ block
        (§ return version)
    )

    ;;;
     ; Set the version number of the wallet.  See {@link Wallet#getVersion()}.
     ;;
    #_public
    (§ method void setVersion(§ args int version))
    (§ block
        (§ ass this.version = version)
    )

    ;;;
     ; Set the description of the wallet.
     ; This is a Unicode encoding string typically entered by the user as descriptive text for the wallet.
     ;;
    #_public
    (§ method void setDescription(§ args String description))
    (§ block
        (§ ass this.description = description)
    )

    ;;;
     ; Get the description of the wallet.  See {@link Wallet#setDescription(String)}.
     ;;
    #_public
    (§ method String getDescription(§ args ))
    (§ block
        (§ return description)
    )

    ;;;
     ; <p>It's possible to calculate a wallets balance from multiple points of view.  This enum selects which
     ; {@link #getBalance(BalanceType)} should use.</p>
     ;
     ; <p>Consider a real-world example: you buy a snack costing $5 but you only have a $10 bill.  At the start
     ; you have $10 viewed from every possible angle.  After you order the snack you hand over your $10 bill.
     ; From the perspective of your wallet you have zero dollars (AVAILABLE).  But you know in a few seconds the
     ; shopkeeper will give you back $5 change so most people in practice would say they have $5 (ESTIMATED).</p>
     ;
     ; <p>The fact that the wallet can track transactions which are not spendable by itself ("watching wallets")
     ; adds another type of balance to the mix.  Although the wallet won't do this by default, advanced use cases
     ; that override the relevancy checks can end up with a mix of spendable and unspendable transactions.</p>
     ;;
    #_public
    (§ enum BalanceType
        ;;;
         ; Balance calculated assuming all pending transactions are in fact included into the best chain by miners.
         ; This includes the value of immature coinbase transactions.
         ;;
        (§ item ESTIMATED)

        ;;;
         ; Balance that could be safely used to create new spends, if we had all the needed private keys.  This is
         ; whatever the default coin selector would make available, which by default means transaction outputs with at
         ; least 1 confirmation and pending transactions created by our own wallet which have been propagated across
         ; the network.  Whether we <i>actually</i> have the private keys or not is irrelevant for this balance type.
         ;;
        (§ item AVAILABLE)

        ;;; Same as ESTIMATED but only for outputs we have the private keys for and can sign ourselves. ;;
        (§ item ESTIMATED_SPENDABLE)
        ;;; Same as AVAILABLE but only for outputs we have the private keys for and can sign ourselves. ;;
        (§ item AVAILABLE_SPENDABLE)
    )

    ;;;
     ; Returns the AVAILABLE balance of this wallet.
     ; See {@link BalanceType#AVAILABLE} for details on what this means.
     ;;
    #_public
    (§ method Coin getBalance(§ args ))
    (§ block
        (§ return getBalance(§ pars BalanceType.AVAILABLE))
    )

    ;;;
     ; Returns the balance of this wallet as calculated by the provided balanceType.
     ;;
    #_public
    (§ method Coin getBalance(§ args BalanceType balanceType))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr balanceType == BalanceType.AVAILABLE || balanceType == BalanceType.AVAILABLE_SPENDABLE))
            (§ block
                (§ var List<TransactionOutput> candidates = calculateAllSpendCandidates(§ pars true, balanceType == BalanceType.AVAILABLE_SPENDABLE))
                (§ var CoinSelection selection = coinSelector.select(§ pars NetworkParameters.MAX_MONEY, candidates))
                (§ return selection.valueGathered)
            )
            (§ elseif (§ expr balanceType == BalanceType.ESTIMATED || balanceType == BalanceType.ESTIMATED_SPENDABLE))
            (§ block
                (§ var List<TransactionOutput> all = calculateAllSpendCandidates(§ pars false, balanceType == BalanceType.ESTIMATED_SPENDABLE))
                (§ var Coin value = Coin.ZERO)
                (§ for (§ var TransactionOutput out) :for (§ expr all))
                (§ block
                    (§ ass value = value.add(§ pars out.getValue(§ pars )))
                )
                (§ return value)
            )
            (§ else )
            (§ block
                (§ throw (§ new AssertionError(§ pars "Unknown balance type"))) ;; Unreachable.
            )
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the balance that would be considered spendable by the given coin selector, including watched outputs
     ; (i.e. balance includes outputs we don't have the private keys for).  Just asks it to select as many coins as
     ; possible and returns the total.
     ;;
    #_public
    (§ method Coin getBalance(§ args CoinSelector selector))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call Preconditions.checkNotNull(§ pars selector))

            (§ var List<TransactionOutput> candidates = calculateAllSpendCandidates(§ pars true, false))
            (§ var CoinSelection selection = selector.select(§ pars params.getMaxMoney(§ pars ), candidates))
            (§ return selection.valueGathered)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    #_private
    #_static
    (§ class BalanceFutureRequest
        #_public
        (§ field SettableFuture<Coin> future)
        #_public
        (§ field Coin value)
        #_public
        (§ field BalanceType type)
    )
    #_guarded-by(§ opt "lock")
    #_private
    (§ field List<BalanceFutureRequest> balanceFutureRequests = Lists.newLinkedList(§ pars ))

    ;;;
     ; <p>Returns a future that will complete when the balance of the given type has become equal or larger to the
     ; given value.  If the wallet already has a large enough balance the future is returned in a pre-completed state.
     ; Note that this method is not blocking, if you want to actually wait immediately, you have to call .get() on
     ; the result.</p>
     ;
     ; <p>Also note that by the time the future completes, the wallet may have changed yet again if something else
     ; is going on in parallel, so you should treat the returned balance as advisory and be prepared for sending
     ; money to fail!  Finally please be aware that any listeners on the future will run either on the calling thread
     ; if it completes immediately, or eventually on a background thread if the balance is not yet at the right
     ; level.  If you do something that means you know the balance should be sufficient to trigger the future,
     ; you can use {@link org.bitcoinj.utils.Threading#waitForUserCode()} to block until the future had a
     ; chance to be updated.</p>
     ;;
    #_public
    (§ method ListenableFuture<Coin> getBalanceFuture(§ args #_final Coin value, #_final BalanceType type))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            #_final
            (§ var SettableFuture<Coin> future = SettableFuture.create(§ pars ))
            #_final
            (§ var Coin current = getBalance(§ pars type))
            (§ if (§ expr 0 <= current.compareTo(§ pars value)))
            (§ block
                ;; Already have enough.
                (§ call future.set(§ pars current))
            )
            (§ else )
            (§ block
                ;; Will be checked later in checkBalanceFutures.  We don't just add an event listener for ourselves
                ;; here so that running getBalanceFuture().get() in the user code thread works - generally we must
                ;; avoid giving the user back futures that require the user code thread to be free.
                (§ var BalanceFutureRequest req = new BalanceFutureRequest(§ pars ))
                (§ ass req.future = future)
                (§ ass req.value = value)
                (§ ass req.type = type)
                (§ call balanceFutureRequests.add(§ pars req))
            )
            (§ return future)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;; Runs any balance futures in the user code thread.
    #_suppress(§ opt "FieldAccessNotGuarded")
    #_private
    (§ method void checkBalanceFuturesLocked(§ args #_nilable Coin avail))
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        #_final
        (§ var ListIterator<BalanceFutureRequest> it = balanceFutureRequests.listIterator(§ pars ))
        (§ while (§ expr it.hasNext(§ pars )))
        (§ block
            #_final
            (§ var BalanceFutureRequest req = it.next(§ pars ))
            (§ var Coin val = getBalance(§ pars req.type)) ;; This could be slow for lots of futures.
            (§ if (§ expr val.compareTo(§ pars req.value) < 0))
            (§ block
                (§ continue )
            )
            ;; Found one that's finished.
            (§ call it.remove(§ pars ))
            #_final
            (§ var Coin v = val)
            ;; Don't run any user-provided future listeners with our lock held.
            (§ call Threading.USER_THREAD.execute(§ pars (§ new Runnable(§ pars ))
            (§ anon
                #_override
                #_public
                (§ method void run(§ args ))
                (§ block
                    (§ call req.future.set(§ pars v))
                )
            )))
        )
    )

    ;;;
     ; Returns the amount of bitcoin ever received via output.  <b>This is not the balance!</b>  If an output
     ; spends from a transaction whose inputs are also to our wallet, the input amounts are deducted from the
     ; outputs contribution, with a minimum of zero contribution.  The idea behind this is we avoid double
     ; counting money sent to us.
     ; @return the total amount of satoshis received, regardless of whether it was spent or not.
     ;;
    #_public
    (§ method Coin getTotalReceived(§ args ))
    (§ block
        (§ var Coin total = Coin.ZERO)

        ;; Include outputs to us if they were not just change outputs, i.e. the inputs to us summed to less
        ;; than the outputs to us.
        (§ for (§ var Transaction tx) :for (§ expr transactions.values(§ pars )))
        (§ block
            (§ var Coin txTotal = Coin.ZERO)
            (§ for (§ var TransactionOutput output) :for (§ expr tx.getOutputs(§ pars )))
            (§ block
                (§ if (§ expr output.isMine(§ pars this)))
                (§ block
                    (§ ass txTotal = txTotal.add(§ pars output.getValue(§ pars )))
                )
            )
            (§ for (§ var TransactionInput in) :for (§ expr tx.getInputs(§ pars )))
            (§ block
                (§ var TransactionOutput prevOut = in.getConnectedOutput(§ pars ))
                (§ if (§ expr prevOut != nil && prevOut.isMine(§ pars this)))
                (§ block
                    (§ ass txTotal = txTotal.subtract(§ pars prevOut.getValue(§ pars )))
                )
            )
            (§ if (§ expr txTotal.isPositive(§ pars )))
            (§ block
                (§ ass total = total.add(§ pars txTotal))
            )
        )
        (§ return total)
    )

    ;;;
     ; Returns the amount of bitcoin ever sent via output.  If an output is sent to our own wallet, because of
     ; change or rotating keys or whatever, we do not count it.  If the wallet was involved in a shared transaction,
     ; i.e. there is some input to the transaction that we don't have the key for, then we multiply the sum of
     ; the output values by the proportion of satoshi coming in to our inputs.  Essentially we treat inputs as
     ; pooling into the transaction, becoming fungible and being equally distributed to all outputs.
     ; @return the total amount of satoshis sent by us.
     ;;
    #_public
    (§ method Coin getTotalSent(§ args ))
    (§ block
        (§ var Coin total = Coin.ZERO)

        (§ for (§ var Transaction tx) :for (§ expr transactions.values(§ pars )))
        (§ block
            ;; Count spent outputs to only if they were not to us.  This means we don't count change outputs.
            (§ var Coin txOutputTotal = Coin.ZERO)
            (§ for (§ var TransactionOutput out) :for (§ expr tx.getOutputs(§ pars )))
            (§ block
                (§ if (§ expr !out.isMine(§ pars this)))
                (§ block
                    (§ ass txOutputTotal = txOutputTotal.add(§ pars out.getValue(§ pars )))
                )
            )

            ;; Count the input values to us
            (§ var Coin txOwnedInputsTotal = Coin.ZERO)
            (§ for (§ var TransactionInput in) :for (§ expr tx.getInputs(§ pars )))
            (§ block
                (§ var TransactionOutput prevOut = in.getConnectedOutput(§ pars ))
                (§ if (§ expr prevOut != nil && prevOut.isMine(§ pars this)))
                (§ block
                    (§ ass txOwnedInputsTotal = txOwnedInputsTotal.add(§ pars prevOut.getValue(§ pars )))
                )
            )

            ;; If there is an input that isn't from us, i.e. this is a shared transaction.
            (§ var Coin txInputsTotal = tx.getInputSum(§ pars ))
            (§ if (§ expr txOwnedInputsTotal != txInputsTotal))
            (§ block
                ;; Multiply our output total by the appropriate proportion to account for the inputs that we don't own.
                (§ var BigInteger txOutputTotalNum = new BigInteger(§ pars txOutputTotal.toString(§ pars )))
                (§ ass txOutputTotalNum = txOutputTotalNum.multiply(§ pars (§ new BigInteger(§ pars txOwnedInputsTotal.toString(§ pars )))))
                (§ ass txOutputTotalNum = txOutputTotalNum.divide(§ pars (§ new BigInteger(§ pars txInputsTotal.toString(§ pars )))))
                (§ ass txOutputTotal = Coin.valueOf(§ pars txOutputTotalNum.longValue(§ pars )))
            )
            (§ ass total = total.add(§ pars txOutputTotal))
        )
        (§ return total)
    )

    ;;; A SendResult is returned to you as part of sending coins to a recipient. ;;
    #_public
    #_static
    (§ class SendResult
        ;;; The Bitcoin transaction message that moves the money. ;;
        #_public
        (§ field Transaction tx)
        ;;;
         ; A future that will complete once the tx message has been successfully broadcast to the network.
         ; This is just the result of calling broadcast.future().
         ;;
        #_public
        (§ field ListenableFuture<Transaction> broadcastComplete)
        ;;; The broadcast object returned by the linked TransactionBroadcaster. ;;
        #_public
        (§ field TransactionBroadcast broadcast)
    )

    ;;;
     ; Enumerates possible resolutions for missing signatures.
     ;;
    #_public
    (§ enum MissingSigsMode
        ;;; Input script will have OP_0 instead of missing signatures. ;;
        (§ item USE_OP_ZERO)
        ;;;
         ; Missing signatures will be replaced by dummy sigs.  This is useful when you'd like to know the
         ; fee for a transaction without knowing the user's password, as fee depends on size.
         ;;
        (§ item USE_DUMMY_SIG)
        ;;;
         ; If signature is missing, {@link org.bitcoinj.signers.TransactionSigner.MissingSignatureException}
         ; will be thrown for P2SH and {@link ECKey.MissingPrivateKeyException} for other tx types.
         ;;
        (§ item THROW)
    )

    ;;;
     ; <p>Statelessly creates a transaction that sends the given value to address.  The change is sent to
     ; {@link Wallet#currentChangeAddress()}, so you must have added at least one key.</p>
     ;
     ; <p>If you just want to send money quickly, you probably want
     ; {@link Wallet#sendCoins(TransactionBroadcaster, Address, Coin)} instead.  That will create the sending
     ; transaction, commit to the wallet and broadcast it to the network all in one go.  This method is lower
     ; level and lets you see the proposed transaction before anything is done with it.</p>
     ;
     ; <p>This is a helper method that is equivalent to using {@link SendRequest#to(Address, Coin)}
     ; followed by {@link Wallet#completeTx(Wallet.SendRequest)} and returning the requests transaction object.
     ; Note that this means a fee may be automatically added if required, if you want more control over the process,
     ; just do those two steps yourself.</p>
     ;
     ; <p>IMPORTANT: This method does NOT update the wallet.  If you call createSend again you may get two transactions
     ; that spend the same coins.  You have to call {@link Wallet#commitTx(Transaction)} on the created transaction to
     ; prevent this, but that should only occur once the transaction has been accepted by the network.  This implies
     ; you cannot have more than one outstanding sending tx at once.</p>
     ;
     ; <p>You MUST ensure that the value is not smaller than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction
     ; will almost certainly be rejected by the network as dust.</p>
     ;
     ; @param address The Bitcoin address to send the money to.
     ; @param value How much currency to send.
     ; @return either the created Transaction or null if there are insufficient coins.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method Transaction createSend(§ args Address address, Coin value))
        (§ throws InsufficientMoneyException)
    (§ block
        (§ var SendRequest req = SendRequest.to(§ pars address, value))
        (§ if (§ expr params.getId(§ pars ).equals(§ pars NetworkParameters.ID_UNITTESTNET)))
        (§ block
            (§ ass req.shuffleOutputs = false)
        )
        (§ call completeTx(§ pars req))
        (§ return req.tx)
    )

    ;;;
     ; Sends coins to the given address but does not broadcast the resulting pending transaction.  It is still
     ; stored in the wallet, so when the wallet is added to a {@link PeerGroup} or {@link Peer} the transaction
     ; will be announced to the network.  The given {@link SendRequest} is completed first using
     ; {@link Wallet#completeTx(Wallet.SendRequest)} to make it valid.
     ;
     ; @return the Transaction that was created.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method Transaction sendCoinsOffline(§ args SendRequest request))
        (§ throws InsufficientMoneyException)
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call completeTx(§ pars request))
            (§ call commitTx(§ pars request.tx))
            (§ return request.tx)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; <p>Sends coins to the given address, via the given {@link PeerGroup}.  Change is returned to
     ; {@link Wallet#currentChangeAddress()}.  Note that a fee may be automatically added if one may be required
     ; for the transaction to be confirmed.</p>
     ;
     ; <p>The returned object provides both the transaction, and a future that can be used to learn when the broadcast
     ; is complete.  Complete means, if the PeerGroup is limited to only one connection, when it was written out to
     ; the socket.  Otherwise when the transaction is written out and we heard it back from a different peer.</p>
     ;
     ; <p>Note that the sending transaction is committed to the wallet immediately, not when the transaction is
     ; successfully broadcast.  This means that even if the network hasn't heard about your transaction you won't be
     ; able to spend those same coins again.</p>
     ;
     ; <p>You MUST ensure that value is not smaller than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction will
     ; almost certainly be rejected by the network as dust.</p>
     ;
     ; @param broadcaster A {@link TransactionBroadcaster} to use to send the transactions out.
     ; @param to Which address to send coins to.
     ; @param value How much value to send.
     ; @return an object containing the transaction that was created, and a future for the broadcast of it.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method SendResult sendCoins(§ args TransactionBroadcaster broadcaster, Address to, Coin value))
        (§ throws InsufficientMoneyException)
    (§ block
        (§ var SendRequest request = SendRequest.to(§ pars to, value))
        (§ return sendCoins(§ pars broadcaster, request))
    )

    ;;;
     ; <p>Sends coins according to the given request, via the given {@link TransactionBroadcaster}.</p>
     ;
     ; <p>The returned object provides both the transaction, and a future that can be used to learn when the broadcast
     ; is complete.  Complete means, if the PeerGroup is limited to only one connection, when it was written out to
     ; the socket.  Otherwise when the transaction is written out and we heard it back from a different peer.</p>
     ;
     ; <p>Note that the sending transaction is committed to the wallet immediately, not when the transaction is
     ; successfully broadcast.  This means that even if the network hasn't heard about your transaction you won't be
     ; able to spend those same coins again.</p>
     ;
     ; @param broadcaster The target to use for broadcast.
     ; @param request The SendRequest that describes what to do, get one using static methods on SendRequest itself.
     ; @return an object containing the transaction that was created, and a future for the broadcast of it.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method SendResult sendCoins(§ args TransactionBroadcaster broadcaster, SendRequest request))
        (§ throws InsufficientMoneyException)
    (§ block
        ;; Should not be locked here, as we're going to call into the broadcaster and that might want to hold its
        ;; own lock.  sendCoinsOffline handles everything that needs to be locked.
        (§ call Preconditions.checkState(§ pars !lock.isHeldByCurrentThread(§ pars )))

        ;; Commit the TX to the wallet immediately so the spent coins won't be reused.
        ;; TODO: We should probably allow the request to specify tx commit only after the network has accepted it.
        (§ var Transaction tx = sendCoinsOffline(§ pars request))
        (§ var SendResult result = new SendResult(§ pars ))
        (§ ass result.tx = tx)
        ;; The tx has been committed to the pending pool by this point (via sendCoinsOffline -> commitTx), so it has
        ;; a txConfidenceListener registered.  Once the tx is broadcast the peers will update the memory pool with the
        ;; count of seen peers, the memory pool will update the transaction confidence object, that will invoke the
        ;; txConfidenceListener which will in turn invoke the wallets event listener onTransactionConfidenceChanged
        ;; method.
        (§ ass result.broadcast = broadcaster.broadcastTransaction(§ pars tx))
        (§ ass result.broadcastComplete = result.broadcast.future(§ pars ))
        (§ return result)
    )

    ;;;
     ; Satisfies the given {@link SendRequest} using the default transaction broadcaster configured either via
     ; {@link PeerGroup#addWallet(Wallet)} or directly with {@link #setTransactionBroadcaster(TransactionBroadcaster)}.
     ;
     ; @param request The SendRequest that describes what to do, get one using static methods on SendRequest itself.
     ; @return an object containing the transaction that was created, and a future for the broadcast of it.
     ; @throws IllegalStateException if no transaction broadcaster has been configured.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method SendResult sendCoins(§ args SendRequest request))
        (§ throws InsufficientMoneyException)
    (§ block
        (§ var TransactionBroadcaster broadcaster = vTransactionBroadcaster)
        (§ call Preconditions.checkState(§ pars broadcaster != nil, "No transaction broadcaster is configured"))
        (§ return sendCoins(§ pars broadcaster, request))
    )

    ;;;
     ; Sends coins to the given address, via the given {@link Peer}.  Change is returned to {@link Wallet#currentChangeAddress()}.
     ; If an exception is thrown by {@link Peer#sendMessage(Message)} the transaction is still committed, so the pending
     ; transaction must be broadcast <b>by you</b> at some other time.  Note that a fee may be automatically added
     ; if one may be required for the transaction to be confirmed.
     ;
     ; @return the {@link Transaction} that was created or null if there was insufficient balance to send the coins.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method Transaction sendCoins(§ args Peer peer, SendRequest request))
        (§ throws InsufficientMoneyException)
    (§ block
        (§ var Transaction tx = sendCoinsOffline(§ pars request))
        (§ call peer.sendMessage(§ pars tx))
        (§ return tx)
    )

    ;;;
     ; Class of exceptions thrown in {@link Wallet#completeTx(SendRequest)}.
     ;;
    #_public
    #_static
    (§ class CompletionException extends RuntimeException)

    ;;;
     ; Thrown if the resultant transaction would violate the dust rules (an output that's too small to be worthwhile).
     ;;
    #_public
    #_static
    (§ class DustySendRequested extends CompletionException)

    ;;;
     ; Thrown if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    #_static
    (§ class MultipleOpReturnRequested extends CompletionException)

    ;;;
     ; Thrown when we were trying to empty the wallet, and the total amount of money we were trying to empty after
     ; being reduced for the fee was smaller than the min payment.
     ; Note that the missing field will be null in this case.
     ;;
    #_public
    #_static
    (§ class CouldNotAdjustDownwards extends CompletionException)

    ;;;
     ; Thrown if the resultant transaction is too big for Bitcoin to process.  Try breaking up the amounts of value.
     ;;
    #_public
    #_static
    (§ class ExceededMaxTransactionSize extends CompletionException)

    ;;;
     ; Given a spend request containing an incomplete transaction, makes it valid by adding outputs and signed inputs
     ; according to the instructions in the request.  The transaction in the request is modified by this method.
     ;
     ; @param req A SendRequest that contains the incomplete transaction and details for how to make it valid.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method void completeTx(§ args SendRequest req))
        (§ throws InsufficientMoneyException)
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ call Preconditions.checkArgument(§ pars !req.completed, "Given SendRequest has already been completed."))

            ;; Calculate the amount of value we need to import.
            (§ var Coin value = Coin.ZERO)
            (§ for (§ var TransactionOutput output) :for (§ expr req.tx.getOutputs(§ pars )))
            (§ block
                (§ ass value = value.add(§ pars output.getValue(§ pars )))
            )

            (§ call log.info(§ pars "Completing send tx with {} outputs totalling {} and a fee of {}/kB", req.tx.getOutputs(§ pars ).size(§ pars ), value.toFriendlyString(§ pars ), req.feePerKb.toFriendlyString(§ pars )))

            ;; If any inputs have already been added, we don't need to get their value from wallet.
            (§ var Coin totalInput = Coin.ZERO)
            (§ for (§ var TransactionInput input) :for (§ expr req.tx.getInputs(§ pars )))
            (§ block
                (§ if (§ expr input.getConnectedOutput(§ pars ) != nil))
                (§ block
                    (§ ass totalInput = totalInput.add(§ pars input.getConnectedOutput(§ pars ).getValue(§ pars )))
                )
                (§ else )
                (§ block
                    (§ call log.warn(§ pars "SendRequest transaction already has inputs but we don't know how much they are worth - they will be added to fee."))
                )
            )
            (§ ass value = value.subtract(§ pars totalInput))

            (§ var List<TransactionInput> originalInputs = new ArrayList<>(§ pars req.tx.getInputs(§ pars )))

            ;; Check for dusty sends and the OP_RETURN limit.
            (§ if (§ expr req.ensureMinRequiredFee && !req.emptyWallet)) ;; Min fee checking is handled later for emptyWallet.
            (§ block
                (§ var int opReturnCount = 0)
                (§ for (§ var TransactionOutput output) :for (§ expr req.tx.getOutputs(§ pars )))
                (§ block
                    (§ if (§ expr output.isDust(§ pars )))
                    (§ block
                        (§ throw (§ new DustySendRequested(§ pars )))
                    )
                    (§ if (§ expr output.getScriptPubKey(§ pars ).isOpReturn(§ pars )))
                    (§ block
                        (§ ass opReturnCount = opReturnCount + 1)
                    )
                )
                (§ if (§ expr 1 < opReturnCount)) ;; Only 1 OP_RETURN per transaction allowed.
                (§ block
                    (§ throw (§ new MultipleOpReturnRequested(§ pars )))
                )
            )

            ;; Calculate a list of ALL potential candidates for spending and then ask a coin selector to provide us
            ;; with the actual outputs that'll be used to gather the required amount of value.  In this way, users
            ;; can customize coin selection policies.  The call below will ignore immature coinbases and outputs
            ;; we don't have the keys for.
            (§ var List<TransactionOutput> candidates = calculateAllSpendCandidates(§ pars true, req.missingSigsMode == MissingSigsMode.THROW))

            (§ var CoinSelection bestCoinSelection)
            (§ var TransactionOutput bestChangeOutput = nil)
            (§ var List<Coin> updatedOutputValues = nil)
            (§ if (§ expr !req.emptyWallet))
            (§ block
                ;; This can throw InsufficientMoneyException.
                (§ var FeeCalculation feeCalculation = calculateFee(§ pars req, value, originalInputs, req.ensureMinRequiredFee, candidates))
                (§ ass bestCoinSelection = feeCalculation.bestCoinSelection)
                (§ ass bestChangeOutput = feeCalculation.bestChangeOutput)
                (§ ass updatedOutputValues = feeCalculation.updatedOutputValues)
            )
            (§ else )
            (§ block
                ;; We're being asked to empty the wallet.  What this means is ensuring "tx" has only a single output
                ;; of the total value we can currently spend as determined by the selector, and then subtracting the fee.
                (§ call Preconditions.checkState(§ pars req.tx.getOutputs(§ pars ).size(§ pars ) == 1, "Empty wallet TX must have a single output only."))

                (§ var CoinSelector selector = (§ expr req.coinSelector == nil) ? coinSelector :else req.coinSelector)
                (§ ass bestCoinSelection = selector.select(§ pars params.getMaxMoney(§ pars ), candidates))
                (§ ass candidates = nil) ;; Selector took ownership and might have changed candidates.  Don't access again.
                (§ call req.tx.getOutput(§ pars 0).setValue(§ pars bestCoinSelection.valueGathered))
                (§ call log.info(§ pars "  emptying {}", bestCoinSelection.valueGathered.toFriendlyString(§ pars )))
            )

            (§ for (§ var TransactionOutput output) :for (§ expr bestCoinSelection.gathered))
            (§ block
                (§ call req.tx.addInput(§ pars output))
            )

            (§ if (§ expr req.emptyWallet))
            (§ block
                #_final
                (§ var Coin feePerKb = (§ expr req.feePerKb == nil) ? Coin.ZERO :else req.feePerKb)
                (§ if (§ expr !adjustOutputDownwardsForFee(§ pars req.tx, bestCoinSelection, feePerKb, req.ensureMinRequiredFee)))
                (§ block
                    (§ throw (§ new CouldNotAdjustDownwards(§ pars )))
                )
            )

            (§ if (§ expr updatedOutputValues != nil))
            (§ block
                (§ for (§ var int i = 0) :for (§ expr i < updatedOutputValues.size(§ pars )) :for (§ ass i = i + 1))
                (§ block
                    (§ call req.tx.getOutput(§ pars i).setValue(§ pars updatedOutputValues.get(§ pars i)))
                )
            )

            (§ if (§ expr bestChangeOutput != nil))
            (§ block
                (§ call req.tx.addOutput(§ pars bestChangeOutput))
                (§ call log.info(§ pars "  with {} change", bestChangeOutput.getValue(§ pars ).toFriendlyString(§ pars )))
            )

            ;; Now shuffle the outputs to obfuscate which is the change.
            (§ if (§ expr req.shuffleOutputs))
            (§ block
                (§ call req.tx.shuffleOutputs(§ pars ))
            )

            ;; Now sign the inputs, thus proving that we are entitled to redeem the connected outputs.
            (§ if (§ expr req.signInputs))
            (§ block
                (§ call signTransaction(§ pars req))
            )

            ;; Check size.
            #_final
            (§ var int size = req.tx.unsafeBitcoinSerialize(§ pars ).length)
            (§ if (§ expr Transaction.MAX_STANDARD_TX_SIZE < size))
            (§ block
                (§ throw (§ new ExceededMaxTransactionSize(§ pars )))
            )

            ;; Label the transaction as being self created.  We can use this later to spend its change output even before
            ;; the transaction is confirmed.  We deliberately won't bother notifying listeners here as there's not much
            ;; point - the user isn't interested in a confidence transition they made themselves.
            (§ call req.tx.getConfidence(§ pars ).setSource(§ pars TransactionConfidence.Source.SELF))
            ;; Label the transaction as being a user requested payment.  This can be used to render GUI wallet
            ;; transaction lists more appropriately, especially when the wallet starts to generate transactions itself
            ;; for internal purposes.
            (§ call req.tx.setPurpose(§ pars Transaction.Purpose.USER_PAYMENT))
            ;; Record the exchange rate that was valid when the transaction was completed.
            (§ call req.tx.setExchangeRate(§ pars req.exchangeRate))
            (§ call req.tx.setMemo(§ pars req.memo))
            (§ ass req.completed = true)
            (§ call log.info(§ pars "  completed: {}", req.tx))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; <p>Given a send request containing transaction, attempts to sign it's inputs.  This method expects
     ; the transaction to have all necessary inputs connected or they will be ignored.</p>
     ; <p>Actual signing is done by pluggable {@link #signers} and it's not guaranteed that
     ; the transaction will be complete in the end.</p>
     ;;
    #_public
    (§ method void signTransaction(§ args SendRequest req))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var Transaction tx = req.tx)
            (§ var List<TransactionInput> inputs = tx.getInputs(§ pars ))
            (§ var List<TransactionOutput> outputs = tx.getOutputs(§ pars ))
            (§ call Preconditions.checkState(§ pars 0 < inputs.size(§ pars )))
            (§ call Preconditions.checkState(§ pars 0 < outputs.size(§ pars )))

            (§ var KeyBag maybeDecryptingKeyBag = new DecryptingKeyBag(§ pars this, req.aesKey))

            (§ var int numInputs = tx.getInputs(§ pars ).size(§ pars ))
            (§ for (§ var int i = 0) :for (§ expr i < numInputs) :for (§ ass i = i + 1))
            (§ block
                (§ var TransactionInput txIn = tx.getInput(§ pars i))
                ;; Missing connected output, assuming already signed.
                (§ if (§ expr txIn.getConnectedOutput(§ pars ) == nil))
                (§ block
                    (§ continue )
                )

                (§ try )
                (§ block
                    ;; We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                    ;; we sign missing pieces (to check this would require either assuming any signatures are signing
                    ;; standard output types or a way to get processed signatures out of script execution).
                    (§ call txIn.getScriptSig(§ pars ).correctlySpends(§ pars tx, i, txIn.getConnectedOutput(§ pars ).getScriptPubKey(§ pars )))
                    (§ call log.warn(§ pars "Input {} already correctly spends output, assuming SIGHASH type used will be safe and skipping signing.", i))
                    (§ continue )
                )
                (§ catch (§ args ScriptException e))
                (§ block
                    (§ call log.debug(§ pars "Input contained an incorrect signature", e))
                    ;; Expected.
                )

                (§ var Script scriptPubKey = txIn.getConnectedOutput(§ pars ).getScriptPubKey(§ pars ))
                (§ var RedeemData redeemData = txIn.getConnectedRedeemData(§ pars maybeDecryptingKeyBag))
                (§ call Preconditions.checkNotNull(§ pars redeemData, "Transaction exists in wallet that we cannot redeem: %s", txIn.getOutpoint(§ pars ).getHash(§ pars )))
                (§ call txIn.setScriptSig(§ pars scriptPubKey.createEmptyInputScript(§ pars redeemData.keys.get(§ pars 0), redeemData.redeemScript)))
            )

            (§ var TransactionSigner.ProposedTransaction proposal = new TransactionSigner.ProposedTransaction(§ pars tx))
            (§ for (§ var TransactionSigner signer) :for (§ expr signers))
            (§ block
                (§ if (§ expr !signer.signInputs(§ pars proposal, maybeDecryptingKeyBag)))
                (§ block
                    (§ call log.info(§ pars "{} returned false for the tx", signer.getClass(§ pars ).getName(§ pars )))
                )
            )

            ;; Resolve missing sigs if any.
            (§ call (§ new MissingSigResolutionSigner(§ pars req.missingSigsMode)).signInputs(§ pars proposal, maybeDecryptingKeyBag))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;; Reduce the value of the first output of a transaction to pay the given feePerKb as appropriate for its size. ;;
    #_private
    (§ method boolean adjustOutputDownwardsForFee(§ args Transaction tx, CoinSelection coinSelection, Coin feePerKb, boolean ensureMinRequiredFee))
    (§ block
        #_final
        (§ var int size = tx.unsafeBitcoinSerialize(§ pars ).length + estimateBytesForSigning(§ pars coinSelection))
        (§ var Coin fee = feePerKb.multiply(§ pars size).divide(§ pars 1000))
        (§ if (§ expr ensureMinRequiredFee && fee.compareTo(§ pars Transaction.REFERENCE_DEFAULT_MIN_TX_FEE) < 0))
        (§ block
            (§ ass fee = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE)
        )
        (§ var TransactionOutput output = tx.getOutput(§ pars 0))
        (§ call output.setValue(§ pars output.getValue(§ pars ).subtract(§ pars fee)))
        (§ return !output.isDust(§ pars ))
    )

    ;;;
     ; Returns a list of the outputs that can potentially be spent, i.e. that we have the keys for and are unspent
     ; according to our knowledge of the block chain.
     ;;
    #_public
    (§ method List<TransactionOutput> calculateAllSpendCandidates(§ args ))
    (§ block
        (§ return calculateAllSpendCandidates(§ pars true, true))
    )

    ;;;
     ; Returns a list of all outputs that are being tracked by this wallet taking into account the flags.
     ;
     ; @param excludeImmatureCoinbases Whether to ignore coinbase outputs that we will be able to spend in future once they mature.
     ; @param excludeUnsignable Whether to ignore outputs that we are tracking but don't have the keys to sign for.
     ;;
    #_public
    (§ method List<TransactionOutput> calculateAllSpendCandidates(§ args boolean excludeImmatureCoinbases, boolean excludeUnsignable))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var List<TransactionOutput> candidates = new ArrayList<>(§ pars myUnspents.size(§ pars )))
            (§ for (§ var TransactionOutput output) :for (§ expr myUnspents))
            (§ block
                (§ if (§ expr excludeUnsignable && !canSignFor(§ pars output.getScriptPubKey(§ pars ))))
                (§ block
                    (§ continue )
                )
                (§ var Transaction transaction = Preconditions.checkNotNull(§ pars output.getParentTransaction(§ pars )))
                (§ if (§ expr excludeImmatureCoinbases && !transaction.isMature(§ pars )))
                (§ block
                    (§ continue )
                )
                (§ call candidates.add(§ pars output))
            )
            (§ return candidates)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns true if this wallet has at least one of the private keys needed to sign for this scriptPubKey.
     ; Returns false if the form of the script is not known or if the script is OP_RETURN.
     ;;
    #_public
    (§ method boolean canSignFor(§ args Script script))
    (§ block
        (§ if (§ expr script.isSentToRawPubKey(§ pars )))
        (§ block
            (§ var byte[] pubkey = script.getPubKey(§ pars ))
            (§ var ECKey key = findKeyFromPubKey(§ pars pubkey))
            (§ return (§ expr key != nil && (§ expr key.isEncrypted(§ pars ) || key.hasPrivKey(§ pars ))))
        )

        (§ if (§ expr script.isPayToScriptHash(§ pars )))
        (§ block
            (§ var RedeemData data = findRedeemDataFromScriptHash(§ pars script.getPubKeyHash(§ pars )))
            (§ return (§ expr data != nil && canSignFor(§ pars data.redeemScript)))
        )

        (§ if (§ expr script.isSentToAddress(§ pars )))
        (§ block
            (§ var ECKey key = findKeyFromPubHash(§ pars script.getPubKeyHash(§ pars )))
            (§ return (§ expr key != nil && (§ expr key.isEncrypted(§ pars ) || key.hasPrivKey(§ pars ))))
        )

        (§ if (§ expr script.isSentToMultiSig(§ pars )))
        (§ block
            (§ for (§ var ECKey pubkey) :for (§ expr script.getPubKeys(§ pars )))
            (§ block
                (§ var ECKey key = findKeyFromPubKey(§ pars pubkey.getPubKey(§ pars )))
                (§ if (§ expr key != nil && (§ expr key.isEncrypted(§ pars ) || key.hasPrivKey(§ pars ))))
                (§ block
                    (§ return true)
                )
            )
        )
        (§ elseif (§ expr script.isSentToCLTVPaymentChannel(§ pars )))
        (§ block
            ;; Any script for which we are the recipient or sender counts.
            (§ var byte[] sender = script.getCLTVPaymentChannelSenderPubKey(§ pars ))
            (§ var ECKey senderKey = findKeyFromPubKey(§ pars sender))
            (§ if (§ expr senderKey != nil && (§ expr senderKey.isEncrypted(§ pars ) || senderKey.hasPrivKey(§ pars ))))
            (§ block
                (§ return true)
            )

            (§ var byte[] recipient = script.getCLTVPaymentChannelRecipientPubKey(§ pars ))
            (§ var ECKey recipientKey = findKeyFromPubKey(§ pars sender))
            (§ if (§ expr recipientKey != nil && (§ expr recipientKey.isEncrypted(§ pars ) || recipientKey.hasPrivKey(§ pars ))))
            (§ block
                (§ return true)
            )
        )
        (§ return false)
    )

    ;;; Returns the {@link CoinSelector} object which controls which outputs can be spent by this wallet. ;;
    #_public
    (§ method CoinSelector getCoinSelector(§ args ))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return coinSelector)
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; A coin selector is responsible for choosing which outputs to spend when creating transactions.  The default
     ; selector implements a policy of spending transactions that appeared in the best chain and pending transactions
     ; that were created by this wallet, but not others.  You can override the coin selector for any given send
     ; operation by changing {@link SendRequest#coinSelector}.
     ;;
    #_public
    (§ method void setCoinSelector(§ args CoinSelector coinSelector))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass this.coinSelector = Preconditions.checkNotNull(§ pars coinSelector))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Convenience wrapper for <tt>setCoinSelector(Wallet.AllowUnconfirmedCoinSelector.get())</tt>.  If this method
     ; is called on the wallet then transactions will be used for spending regardless of their confidence.  This can
     ; be dangerous - only use this if you absolutely know what you're doing!
     ;;
    #_public
    (§ method void allowSpendingUnconfirmedTransactions(§ args ))
    (§ block
        (§ call setCoinSelector(§ pars AllowUnconfirmedCoinSelector.get(§ pars )))
    )

    ;;;
     ; A custom {@link TransactionOutput} that is free standing.  This contains all the information
     ; required for spending without actually having all the linked data (i.e parent tx).
     ;
     ;;
    #_private
    (§ class FreeStandingTransactionOutput extends TransactionOutput
        #_private
        (§ field UTXO output)
        #_private
        (§ field int chainHeight)

        ;;;
         ; Construct a free standing Transaction Output.
         ; @param params The network parameters.
         ; @param output The stored output (free standing).
         ;;
        #_public
        (§ constructor FreeStandingTransactionOutput(§ args NetworkParameters params, UTXO output, int chainHeight))
        (§ block
            (§ super (§ pars params, nil, output.getValue(§ pars ), output.getScript(§ pars ).getProgram(§ pars )))

            (§ ass this.output = output)
            (§ ass this.chainHeight = chainHeight)
        )

        ;;;
         ; Get the {@link UTXO}.
         ; @return the stored output.
         ;;
        #_public
        (§ method UTXO getUTXO(§ args ))
        (§ block
            (§ return output)
        )

        ;;;
         ; Get the depth within the chain of the parent tx, depth is 1 if the output height is the height
         ; of the latest block.
         ; @return the depth.
         ;;
        #_override
        #_public
        (§ method int getParentTransactionDepthInBlocks(§ args ))
        (§ block
            (§ return chainHeight - output.getHeight(§ pars ) + 1)
        )

        #_override
        #_public
        (§ method int getIndex(§ args ))
        (§ block
            (§ return (§ expr (§ cast int)output.getIndex(§ pars )))
        )

        #_override
        #_public
        (§ method Sha256Hash getParentTransactionHash(§ args ))
        (§ block
            (§ return output.getHash(§ pars ))
        )
    )

    #_private
    #_static
    (§ class TxOffsetPair implements Comparable<TxOffsetPair>
        #_public
        #_final
        (§ field Transaction tx)
        #_public
        #_final
        (§ field int offset)

        #_public
        (§ constructor TxOffsetPair(§ args Transaction tx, int offset))
        (§ block
            (§ ass this.tx = tx)
            (§ ass this.offset = offset)
        )

        #_override
        #_public
        (§ method int compareTo(§ args TxOffsetPair o))
        (§ block
            ;; Note that in this implementation compareTo() is not consistent with equals().
            (§ return Ints.compare(§ pars offset, o.offset))
        )
    )

    ;;;
     ; <p>Don't call this directly.  It's not intended for API users.</p>
     ;
     ; <p>Called by the {@link BlockChain} when the best chain (representing total work done) has changed.
     ; This can cause the number of confirmations of a transaction to go higher, lower, drop to zero and
     ; can even result in a transaction going dead (will never confirm) due to a double spend.</p>
     ;
     ; <p>The oldBlocks/newBlocks lists are ordered height-wise from top first to bottom last.</p>
     ;;
    #_override
    #_public
    (§ method void reorganize(§ args StoredBlock splitPoint, List<StoredBlock> oldBlocks, List<StoredBlock> newBlocks))
        (§ throws VerificationException)
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; This runs on any peer thread with the block chain locked.
            ;;
            ;; The reorganize functionality of the wallet is tested in ChainSplitTest.java
            ;;
            ;; receive() has been called on the block that is triggering the re-org before this is called,
            ;; with type of SIDE_CHAIN.
            ;;
            ;; Note that this code assumes blocks are not invalid - if blocks contain duplicated transactions,
            ;; transactions that double spend etc then we can calculate the incorrect result.  This could open up
            ;; obscure DoS attacks if someone successfully mines a throwaway invalid block and feeds it to us, just
            ;; to try and corrupt the internal data structures.  We should try harder to avoid this but it's tricky
            ;; because there are so many ways the block can be invalid.

            ;; Avoid spuriously informing the user of wallet/tx confidence changes whilst we're re-organizing.
            (§ call Preconditions.checkState(§ pars confidenceChanged.size(§ pars ) == 0))
            (§ call Preconditions.checkState(§ pars !insideReorg))
            (§ ass insideReorg = true)
            (§ call Preconditions.checkState(§ pars onWalletChangedSuppressions == 0))
            (§ ass onWalletChangedSuppressions = onWalletChangedSuppressions + 1)

            ;; Map block hash to transactions that appear in it.  We ensure that the map values are sorted according
            ;; to their relative position within those blocks.
            (§ var ArrayListMultimap<Sha256Hash, TxOffsetPair> mapBlockTx = ArrayListMultimap.create(§ pars ))
            (§ for (§ var Transaction tx) :for (§ expr getTransactions(§ pars true)))
            (§ block
                (§ var Map<Sha256Hash, Integer> appearsIn = tx.getAppearsInHashes(§ pars ))
                (§ if (§ expr appearsIn == nil))
                (§ block
                    (§ continue ) ;; Pending.
                )
                (§ for (§ var Map.Entry<Sha256Hash, Integer> block) :for (§ expr appearsIn.entrySet(§ pars )))
                (§ block
                    (§ call mapBlockTx.put(§ pars block.getKey(§ pars ), new TxOffsetPair(§ pars tx, block.getValue(§ pars ))))
                )
            )
            (§ for (§ var Sha256Hash blockHash) :for (§ expr mapBlockTx.keySet(§ pars )))
            (§ block
                (§ call Collections.sort(§ pars mapBlockTx.get(§ pars blockHash)))
            )

            (§ var List<Sha256Hash> oldBlockHashes = new ArrayList<>(§ pars oldBlocks.size(§ pars )))
            (§ call log.info(§ pars "Old part of chain (top to bottom):"))
            (§ for (§ var StoredBlock b) :for (§ expr oldBlocks))
            (§ block
                (§ call log.info(§ pars "  {}", b.getHeader(§ pars ).getHashAsString(§ pars )))
                (§ call oldBlockHashes.add(§ pars b.getHeader(§ pars ).getHash(§ pars )))
            )
            (§ call log.info(§ pars "New part of chain (top to bottom):"))
            (§ for (§ var StoredBlock b) :for (§ expr newBlocks))
            (§ block
                (§ call log.info(§ pars "  {}", b.getHeader(§ pars ).getHashAsString(§ pars )))
            )

            (§ call Collections.reverse(§ pars newBlocks)) ;; Need bottom-to-top but we get top-to-bottom.

            ;; For each block in the old chain, disconnect the transactions in reverse order.
            (§ var LinkedList<Transaction> oldChainTxns = Lists.newLinkedList(§ pars ))
            (§ for (§ var Sha256Hash blockHash) :for (§ expr oldBlockHashes))
            (§ block
                (§ for (§ var TxOffsetPair pair) :for (§ expr mapBlockTx.get(§ pars blockHash)))
                (§ block
                    (§ var Transaction tx = pair.tx)
                    #_final
                    (§ var Sha256Hash txHash = tx.getHash(§ pars ))
                    (§ if (§ expr tx.isCoinBase(§ pars )))
                    (§ block
                        ;; All the transactions that we have in our wallet which spent this coinbase are now invalid
                        ;; and will never confirm.  Hopefully this should never happen - that's the point of the maturity
                        ;; rule that forbids spending of coinbase transactions for 100 blocks.
                        ;;
                        ;; This could be recursive, although of course because we don't have the full transaction
                        ;; graph we can never reliably kill all transactions we might have that were rooted in
                        ;; this coinbase tx.  Some can just go pending forever, like the Bitcoin Core.  However we
                        ;; can do our best.
                        (§ call log.warn(§ pars "Coinbase killed by re-org: {}", tx.getHashAsString(§ pars )))
                        (§ call killTxns(§ pars ImmutableSet.of(§ pars tx), nil))
                    )
                    (§ else )
                    (§ block
                        (§ for (§ var TransactionOutput output) :for (§ expr tx.getOutputs(§ pars )))
                        (§ block
                            (§ var TransactionInput input = output.getSpentBy(§ pars ))
                            (§ if (§ expr input != nil))
                            (§ block
                                (§ if (§ expr output.isMine(§ pars this)))
                                (§ block
                                    (§ call Preconditions.checkState(§ pars myUnspents.add(§ pars output)))
                                )
                                (§ call input.disconnect(§ pars ))
                            )
                        )
                        (§ call oldChainTxns.add(§ pars tx))
                        (§ call unspent.remove(§ pars txHash))
                        (§ call spent.remove(§ pars txHash))
                        (§ call Preconditions.checkState(§ pars !pending.containsKey(§ pars txHash)))
                        (§ call Preconditions.checkState(§ pars !dead.containsKey(§ pars txHash)))
                    )
                )
            )

            ;; Put all the disconnected transactions back into the pending pool and re-connect them.
            (§ for (§ var Transaction tx) :for (§ expr oldChainTxns))
            (§ block
                ;; Coinbase transactions on the old part of the chain are dead for good and won't come back unless
                ;; there's another re-org.
                (§ if (§ expr tx.isCoinBase(§ pars )))
                (§ block
                    (§ continue )
                )
                (§ call log.info(§ pars "  ->pending {}", tx.getHash(§ pars )))

                (§ call tx.getConfidence(§ pars ).setConfidenceType(§ pars ConfidenceType.PENDING)) ;; Wipe height/depth/work data.
                (§ call confidenceChanged.put(§ pars tx, TransactionConfidence.Listener.ChangeReason.TYPE))
                (§ call addWalletTransaction(§ pars Pool.PENDING, tx))
                (§ call updateForSpends(§ pars tx, false))
            )

            ;; Note that dead transactions stay dead.  Consider a chain that Finney attacks T1 and replaces it with
            ;; T2, so we move T1 into the dead pool.  If there's now a re-org to a chain that doesn't include T2, it
            ;; doesn't matter - the miners deleted T1 from their mempool, will resurrect T2 and put that into the
            ;; mempool and so T1 is still seen as a losing double spend.

            ;; The old blocks have contributed to the depth for all the transactions in the
            ;; wallet that are in blocks up to and including the chain split block.
            ;; The total depth is calculated here and then subtracted from the appropriate transactions.
            (§ var int depthToSubtract = oldBlocks.size(§ pars ))
            (§ ass log.info(§ pars "depthToSubtract = " + depthToSubtract))
            ;; Remove depthToSubtract from all transactions in the wallet except for pending.
            (§ call subtractDepth(§ pars depthToSubtract, spent.values(§ pars )))
            (§ call subtractDepth(§ pars depthToSubtract, unspent.values(§ pars )))
            (§ call subtractDepth(§ pars depthToSubtract, dead.values(§ pars )))

            ;; The effective last seen block is now the split point so set the lastSeenBlockHash.
            (§ call setLastBlockSeenHash(§ pars splitPoint.getHeader(§ pars ).getHash(§ pars )))

            ;; For each block in the new chain, work forwards calling receive() and notifyNewBestBlock().
            ;; This will pull them back out of the pending pool, or if the tx didn't appear in the old chain
            ;; and does appear in the new chain, will treat it as such and possibly kill pending transactions
            ;; that conflict.
            (§ for (§ var StoredBlock block) :for (§ expr newBlocks))
            (§ block
                (§ call log.info(§ pars "Replaying block {}", block.getHeader(§ pars ).getHashAsString(§ pars )))
                (§ for (§ var TxOffsetPair pair) :for (§ expr mapBlockTx.get(§ pars block.getHeader(§ pars ).getHash(§ pars ))))
                (§ block
                    (§ call log.info(§ pars "  tx {}", pair.tx.getHash(§ pars )))
                    (§ try )
                    (§ block
                        (§ call receive(§ pars pair.tx, block, BlockChain.NewBlockType.BEST_CHAIN, pair.offset))
                    )
                    (§ catch (§ args ScriptException e))
                    (§ block
                        (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen as these blocks were already verified.
                    )
                )
                (§ call notifyNewBestBlock(§ pars block))
            )
            (§ call isConsistentOrThrow(§ pars ))
            #_final
            (§ var Coin balance = getBalance(§ pars ))
            (§ call log.info(§ pars "post-reorg balance is {}", balance.toFriendlyString(§ pars )))
            ;; Inform event listeners that a re-org took place.
            (§ call queueOnReorganize(§ pars ))
            (§ ass insideReorg = false)
            (§ ass onWalletChangedSuppressions = onWalletChangedSuppressions - 1)
            (§ call maybeQueueOnWalletChanged(§ pars ))
            (§ call checkBalanceFuturesLocked(§ pars balance))
            (§ call informConfidenceListenersIfNotReorganizing(§ pars ))
            (§ call saveLater(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Subtract the supplied depth from the given transactions.
     ;;
    #_private
    (§ method void subtractDepth(§ args int depthToSubtract, Collection<Transaction> transactions))
    (§ block
        (§ for (§ var Transaction tx) :for (§ expr transactions))
        (§ block
            (§ if (§ expr tx.getConfidence(§ pars ).getConfidenceType(§ pars ) == ConfidenceType.BUILDING))
            (§ block
                (§ call tx.getConfidence(§ pars ).setDepthInBlocks(§ pars tx.getConfidence(§ pars ).getDepthInBlocks(§ pars ) - depthToSubtract))
                (§ call confidenceChanged.put(§ pars tx, TransactionConfidence.Listener.ChangeReason.DEPTH))
            )
        )
    )

    #_private
    #_final
    (§ field ArrayList<TransactionOutPoint> bloomOutPoints = Lists.newArrayList(§ pars ))
    ;; Used to track whether we must automatically begin/end a filter calculation and calc outpoints/take the locks.
    #_private
    #_final
    (§ field AtomicInteger bloomFilterGuard = new AtomicInteger(§ pars 0))

    #_override
    #_public
    (§ method void beginBloomFilterCalculation(§ args ))
    (§ block
        (§ if (§ expr 1 < bloomFilterGuard.incrementAndGet(§ pars )))
        (§ block
            (§ return )
        )

        (§ call lock.lock(§ pars ))
        (§ call keyChainGroupLock.lock(§ pars ))
        ;; noinspection FieldAccessNotGuarded
        (§ call calcBloomOutPointsLocked(§ pars ))
    )

    #_private
    (§ method void calcBloomOutPointsLocked(§ args ))
    (§ block
        ;; TODO: This could be done once and then kept up to date.
        (§ call bloomOutPoints.clear(§ pars ))
        (§ var Set<Transaction> all = new HashSet<>(§ pars ))
        (§ call all.addAll(§ pars unspent.values(§ pars )))
        (§ call all.addAll(§ pars spent.values(§ pars )))
        (§ call all.addAll(§ pars pending.values(§ pars )))

        (§ for (§ var Transaction tx) :for (§ expr all))
        (§ block
            (§ for (§ var TransactionOutput out) :for (§ expr tx.getOutputs(§ pars )))
            (§ block
                (§ try )
                (§ block
                    (§ if (§ expr isTxOutputBloomFilterable(§ pars out)))
                    (§ block
                        (§ call bloomOutPoints.add(§ pars out.getOutPointFor(§ pars )))
                    )
                )
                (§ catch (§ args ScriptException e))
                (§ block
                    ;; If it is ours, we parsed the script correctly, so this shouldn't happen.
                    (§ throw (§ new RuntimeException(§ pars e)))
                )
            )
        )
    )

    #_override
    #_guarded-by(§ opt "keyChainGroupLock")
    #_public
    (§ method void endBloomFilterCalculation(§ args ))
    (§ block
        (§ if (§ expr 0 < bloomFilterGuard.decrementAndGet(§ pars )))
        (§ block
            (§ return )
        )

        (§ call bloomOutPoints.clear(§ pars ))
        (§ call keyChainGroupLock.unlock(§ pars ))
        (§ call lock.unlock(§ pars ))
    )

    ;;;
     ; Returns the number of distinct data items (note: NOT keys) that will be inserted into a bloom filter,
     ; when it is constructed.
     ;;
    #_override
    #_public
    (§ method int getBloomFilterElementCount(§ args ))
    (§ block
        (§ call beginBloomFilterCalculation(§ pars ))
        (§ try )
        (§ block
            (§ return bloomOutPoints.size(§ pars ) + keyChainGroup.getBloomFilterElementCount(§ pars ))
        )
        (§ finally )
        (§ block
            (§ call endBloomFilterCalculation(§ pars ))
        )
    )

    ;;;
     ; Gets a bloom filter that contains all of the public keys from this wallet, and which will provide the given
     ; false-positive rate.  See the docs for {@link BloomFilter} for a brief explanation of anonymity when using filters.
     ;;
    #_public
    (§ method BloomFilter getBloomFilter(§ args double falsePositiveRate))
    (§ block
        (§ call beginBloomFilterCalculation(§ pars ))
        (§ try )
        (§ block
            (§ return getBloomFilter(§ pars getBloomFilterElementCount(§ pars ), falsePositiveRate, (§ cast long)(§ expr Math.random(§ pars ) * Long.MAX_VALUE)))
        )
        (§ finally )
        (§ block
            (§ call endBloomFilterCalculation(§ pars ))
        )
    )

    ;;;
     ; <p>Gets a bloom filter that contains all of the public keys from this wallet, and which will provide the given
     ; false-positive rate if it has size elements.  Keep in mind that you will get 2 elements in the bloom filter for
     ; each key in the wallet, for the public key and the hash of the public key (address form).</p>
     ;
     ; <p>This is used to generate a BloomFilter which can be {@link BloomFilter#merge(BloomFilter)}d with another.
     ; It could also be used if you have a specific target for the filter's size.</p>
     ;
     ; <p>See the docs for {@link BloomFilter(int, double)} for a brief explanation of anonymity when using bloom
     ; filters.</p>
     ;;
    #_override
    #_guarded-by(§ opt "keyChainGroupLock")
    #_public
    (§ method BloomFilter getBloomFilter(§ args int size, double falsePositiveRate, long nTweak))
    (§ block
        (§ call beginBloomFilterCalculation(§ pars ))
        (§ try )
        (§ block
            (§ var BloomFilter filter = keyChainGroup.getBloomFilter(§ pars size, falsePositiveRate, nTweak))
            (§ for (§ var TransactionOutPoint point) :for (§ expr bloomOutPoints))
            (§ block
                (§ call filter.insert(§ pars point.unsafeBitcoinSerialize(§ pars )))
            )
            (§ return filter)
        )
        (§ finally )
        (§ block
            (§ call endBloomFilterCalculation(§ pars ))
        )
    )

    ;; Returns true if the output is one that won't be selected by a data element matching in the scriptSig.
    #_private
    (§ method boolean isTxOutputBloomFilterable(§ args TransactionOutput out))
    (§ block
        (§ var Script script = out.getScriptPubKey(§ pars ))
        (§ var boolean isScriptTypeSupported = (§ expr script.isSentToRawPubKey(§ pars ) || script.isPayToScriptHash(§ pars )))
        (§ return (§ expr isScriptTypeSupported && myUnspents.contains(§ pars out)))
    )

    ;;;
     ; Used by {@link Peer} to decide whether or not to discard this block and any blocks building upon it, in case
     ; the Bloom filter used to request them may be exhausted, that is, not have sufficient keys in the deterministic
     ; sequence within it to reliably find relevant transactions.
     ;;
    #_public
    (§ method boolean checkForFilterExhaustion(§ args FilteredBlock block))
    (§ block
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var int epoch = keyChainGroup.getCombinedKeyLookaheadEpochs(§ pars ))
            (§ for (§ var Transaction tx) :for (§ expr block.getAssociatedTransactions(§ pars ).values(§ pars )))
            (§ block
                (§ call markKeysAsUsed(§ pars tx))
            )
            (§ var int newEpoch = keyChainGroup.getCombinedKeyLookaheadEpochs(§ pars ))
            (§ call Preconditions.checkState(§ pars epoch <= newEpoch))
            ;; If the key lookahead epoch has advanced, there was a call to importKeys and the PeerGroup already has a
            ;; pending request to recalculate the filter queued up on another thread.  The calling Peer should abandon
            ;; block at this point and await a new filter before restarting the download.
            (§ return (§ expr epoch < newEpoch))
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
        )
    )

    #_private
    #_static
    (§ class FeeCalculation
        ;; Selected UTXOs to spend.
        #_public
        (§ field CoinSelection bestCoinSelection)
        ;; Change output (may be null if no change).
        #_public
        (§ field TransactionOutput bestChangeOutput)
        ;; List of output values adjusted downwards when recipients pay fees (may be null if no adjustment needed).
        #_public
        (§ field List<Coin> updatedOutputValues)
    )

    #_private
    (§ method FeeCalculation calculateFee(§ args SendRequest req, Coin value, List<TransactionInput> originalInputs, boolean needAtLeastReferenceFee, List<TransactionOutput> candidates))
        (§ throws InsufficientMoneyException)
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ var FeeCalculation result)
        (§ var Coin fee = Coin.ZERO)
        (§ while (§ expr true))
        (§ block
            (§ ass result = new FeeCalculation(§ pars ))
            (§ var Transaction tx = new Transaction(§ pars params))
            (§ call addSuppliedInputs(§ pars tx, req.tx.getInputs(§ pars )))

            (§ var Coin valueNeeded = value)
            (§ if (§ expr !req.recipientsPayFees))
            (§ block
                (§ ass valueNeeded = valueNeeded.add(§ pars fee))
            )
            (§ if (§ expr req.recipientsPayFees))
            (§ block
                (§ ass result.updatedOutputValues = new ArrayList<Coin>(§ pars ))
            )

            (§ for (§ var int i = 0) :for (§ expr i < req.tx.getOutputs(§ pars ).size(§ pars )) :for (§ ass i = i + 1))
            (§ block
                (§ var TransactionOutput output = new TransactionOutput(§ pars params, tx, req.tx.getOutputs(§ pars ).get(§ pars i).bitcoinSerialize(§ pars ), 0))
                (§ if (§ expr req.recipientsPayFees))
                (§ block
                    ;; Subtract fee equally from each selected recipient.
                    (§ call output.setValue(§ pars output.getValue(§ pars ).subtract(§ pars fee.divide(§ pars req.tx.getOutputs(§ pars ).size(§ pars )))))
                    ;; First receiver pays the remainder not divisible by output count.
                    (§ if (§ expr i == 0))
                    (§ block
                        ;; Subtract fee equally from each selected recipient.
                        (§ call output.setValue(§ pars output.getValue(§ pars ).subtract(§ pars fee.divideAndRemainder(§ pars req.tx.getOutputs(§ pars ).size(§ pars ))[1])))
                    )
                    (§ call result.updatedOutputValues.add(§ pars output.getValue(§ pars )))
                    (§ if (§ expr output.getMinNonDustValue(§ pars ).isGreaterThan(§ pars output.getValue(§ pars ))))
                    (§ block
                        (§ throw (§ new CouldNotAdjustDownwards(§ pars )))
                    )
                )
                (§ call tx.addOutput(§ pars output))
            )

            (§ var CoinSelector selector = (§ expr req.coinSelector == nil) ? coinSelector :else req.coinSelector)
            ;; selector is allowed to modify candidates list.
            (§ var CoinSelection selection = selector.select(§ pars valueNeeded, new LinkedList<>(§ pars candidates)))
            (§ ass result.bestCoinSelection = selection)
            ;; Can we afford this?
            (§ if (§ expr selection.valueGathered.compareTo(§ pars valueNeeded) < 0))
            (§ block
                (§ var Coin valueMissing = valueNeeded.subtract(§ pars selection.valueGathered))
                (§ throw (§ new InsufficientMoneyException(§ pars valueMissing)))
            )

            (§ var Coin change = selection.valueGathered.subtract(§ pars valueNeeded))
            (§ if (§ expr change.isGreaterThan(§ pars Coin.ZERO)))
            (§ block
                ;; The value of the inputs is greater than what we want to send.  Just like in real life then,
                ;; we need to take back some coins ... this is called "change".  Add another output that sends the change
                ;; back to us.  The address comes either from the request or currentChangeAddress() as a default.
                (§ var Address changeAddress = req.changeAddress)
                (§ if (§ expr changeAddress == nil))
                (§ block
                    (§ ass changeAddress = currentChangeAddress(§ pars ))
                )

                (§ var TransactionOutput changeOutput = new TransactionOutput(§ pars params, tx, change, changeAddress))
                (§ if (§ expr req.recipientsPayFees && changeOutput.isDust(§ pars )))
                (§ block
                    ;; We do not move dust-change to fees, because the sender would end up paying more than requested.
                    ;; This would be against the purpose of the all-inclusive feature.
                    ;; So instead we raise the change and deduct from the first recipient.
                    (§ var Coin missingToNotBeDust = changeOutput.getMinNonDustValue(§ pars ).subtract(§ pars changeOutput.getValue(§ pars )))
                    (§ call changeOutput.setValue(§ pars changeOutput.getValue(§ pars ).add(§ pars missingToNotBeDust)))
                    (§ var TransactionOutput firstOutput = tx.getOutputs(§ pars ).get(§ pars 0))
                    (§ call firstOutput.setValue(§ pars firstOutput.getValue(§ pars ).subtract(§ pars missingToNotBeDust)))
                    (§ call result.updatedOutputValues.set(§ pars 0, firstOutput.getValue(§ pars )))
                    (§ if (§ expr firstOutput.isDust(§ pars )))
                    (§ block
                        (§ throw (§ new CouldNotAdjustDownwards(§ pars )))
                    )
                )

                (§ if (§ expr changeOutput.isDust(§ pars )))
                (§ block
                    ;; Never create dust outputs; if we would, just add the dust to the fee.
                    ;; Oscar comment: This seems like a way to make the condition below "if (!fee.isLessThan(feeNeeded))" to become true.
                    ;; This is a non-easy to understand way to do that.
                    ;; Maybe there are other effects I am missing.
                    (§ ass fee = fee.add(§ pars changeOutput.getValue(§ pars )))
                )
                (§ else )
                (§ block
                    (§ call tx.addOutput(§ pars changeOutput))
                    (§ ass result.bestChangeOutput = changeOutput)
                )
            )

            (§ for (§ var TransactionOutput selectedOutput) :for (§ expr selection.gathered))
            (§ block
                (§ var TransactionInput input = tx.addInput(§ pars selectedOutput))
                ;; If the scriptBytes don't default to none, our size calculations will be thrown off.
                (§ call Preconditions.checkState(§ pars input.getScriptBytes(§ pars ).length == 0))
            )

            (§ var int size = tx.unsafeBitcoinSerialize(§ pars ).length)
            (§ ass size = size + estimateBytesForSigning(§ pars selection))

            (§ var Coin feePerKb = req.feePerKb)
            (§ if (§ expr needAtLeastReferenceFee && feePerKb.compareTo(§ pars Transaction.REFERENCE_DEFAULT_MIN_TX_FEE) < 0))
            (§ block
                (§ ass feePerKb = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE)
            )

            (§ var Coin feeNeeded = feePerKb.multiply(§ pars size).divide(§ pars 1000))

            (§ if (§ expr !fee.isLessThan(§ pars feeNeeded)))
            (§ block
                ;; Done, enough fee included.
                (§ break )
            )

            ;; Include more fee and try again.
            (§ ass fee = feeNeeded)
        )
        (§ return result)
    )

    #_private
    (§ method void addSuppliedInputs(§ args Transaction tx, List<TransactionInput> originalInputs))
    (§ block
        (§ for (§ var TransactionInput input) :for (§ expr originalInputs))
        (§ block
            (§ call tx.addInput(§ pars (§ new TransactionInput(§ pars params, tx, input.bitcoinSerialize(§ pars )))))
        )
    )

    #_private
    (§ method int estimateBytesForSigning(§ args CoinSelection selection))
    (§ block
        (§ var int size = 0)
        (§ for (§ var TransactionOutput output) :for (§ expr selection.gathered))
        (§ block
            (§ try )
            (§ block
                (§ var Script script = output.getScriptPubKey(§ pars ))
                (§ var ECKey key = nil)
                (§ var Script redeemScript = nil)
                (§ if (§ expr script.isSentToAddress(§ pars )))
                (§ block
                    (§ ass key = findKeyFromPubHash(§ pars script.getPubKeyHash(§ pars )))
                    (§ call Preconditions.checkNotNull(§ pars key, "Coin selection includes unspendable outputs"))
                )
                (§ elseif (§ expr script.isPayToScriptHash(§ pars )))
                (§ block
                    (§ ass redeemScript = findRedeemDataFromScriptHash(§ pars script.getPubKeyHash(§ pars )).redeemScript)
                    (§ call Preconditions.checkNotNull(§ pars redeemScript, "Coin selection includes unspendable outputs"))
                )
                (§ ass size = size + script.getNumberOfBytesRequiredToSpend(§ pars key, redeemScript))
            )
            (§ catch (§ args ScriptException e))
            (§ block
                ;; If this happens it means an output script in a wallet tx could not be understood.  That
                ;; should never happen, if it does it means the wallet has got into an inconsistent state.
                (§ throw (§ new IllegalStateException(§ pars e)))
            )
        )
        (§ return size)
    )

    ;; Wallet maintenance transactions.  These transactions may not be directly connected to a payment the user is
    ;; making.  They may be instead key rotation transactions for when old keys are suspected to be compromised,
    ;; de/re-fragmentation transactions for when our output sizes are inappropriate or suboptimal, privacy transactions
    ;; and so on.  Because these transactions may require user intervention in some way (e.g. entering their password)
    ;; the wallet application is expected to poll the Wallet class to get SendRequests.  Ideally security systems like
    ;; hardware wallets or risk analysis providers are programmed to auto-approve transactions that send from our own
    ;; keys back to our own keys.

    ;;;
     ; <p>Specifies that the given {@link TransactionBroadcaster}, typically a {@link PeerGroup}, should be used for
     ; sending transactions to the Bitcoin network by default.  Some sendCoins methods let you specify a broadcaster
     ; explicitly, in that case, they don't use this broadcaster.  If null is specified then the wallet won't attempt
     ; to broadcast transactions itself.</p>
     ;
     ; <p>You don't normally need to call this.  A {@link PeerGroup} will automatically set itself as the wallets
     ; broadcaster when you use {@link PeerGroup#addWallet(Wallet)}.  A wallet can use the broadcaster when you ask
     ; it to send money, but in future also at other times to implement various features that may require asynchronous
     ; re-organisation of the wallet contents on the block chain.  For instance, in future the wallet may choose to
     ; optimise itself to reduce fees or improve privacy.</p>
     ;;
    #_public
    (§ method void setTransactionBroadcaster(§ args #_nilable org.bitcoinj.core.TransactionBroadcaster broadcaster))
    (§ block
        (§ var Transaction[] toBroadcast = (§ coll ))
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr vTransactionBroadcaster == broadcaster))
            (§ block
                (§ return )
            )
            (§ ass vTransactionBroadcaster = broadcaster)
            (§ if (§ expr broadcaster == nil))
            (§ block
                (§ return )
            )
            (§ ass toBroadcast = pending.values(§ pars ).toArray(§ pars toBroadcast))
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
        ;; Now use it to upload any pending transactions we have that are marked as not being seen by any peers yet.
        ;; Don't hold the wallet lock whilst doing this, so if the broadcaster accesses the wallet at some point there
        ;; is no inversion.
        (§ for (§ var Transaction tx) :for (§ expr toBroadcast))
        (§ block
            (§ var ConfidenceType confidenceType = tx.getConfidence(§ pars ).getConfidenceType(§ pars ))
            (§ call Preconditions.checkState(§ pars confidenceType == ConfidenceType.PENDING || confidenceType == ConfidenceType.IN_CONFLICT, "Expected PENDING or IN_CONFLICT, was %s.", confidenceType))
            ;; Re-broadcast even if it's marked as already seen for two reasons:
            ;; 1. Old wallets may have transactions marked as broadcast by 1 peer when
            ;;    in reality the network never saw it, due to bugs.
            ;; 2. It can't really hurt.
            (§ call log.info(§ pars "New broadcaster so uploading waiting tx {}", tx.getHash(§ pars )))
            (§ call broadcaster.broadcastTransaction(§ pars tx))
        )
    )

    ;;;
     ; When a key rotation time is set, and money controlled by keys created before the given timestamp T will be
     ; automatically respent to any key that was created after T.  This can be used to recover from a situation where
     ; a set of keys is believed to be compromised.  Once the time is set transactions will be created and broadcast
     ; immediately.  New coins that come in after calling this method will be automatically respent immediately.
     ; The rotation time is persisted to the wallet. You can stop key rotation by calling this method again with zero
     ; as the argument.
     ;;
    #_public
    (§ method void setKeyRotationTime(§ args Date time))
    (§ block
        (§ call setKeyRotationTime(§ pars time.getTime(§ pars ) / 1000))
    )

    ;;;
     ; Returns the key rotation time, or null if unconfigured.
     ; See {@link #setKeyRotationTime(Date)} for a description of the field.
     ;;
    #_public
    #_nilable
    (§ method Date getKeyRotationTime(§ args ))
    (§ block
        #_final
        (§ var long keyRotationTimestamp = vKeyRotationTimestamp)
        (§ return (§ expr keyRotationTimestamp != 0) ? new Date(§ pars keyRotationTimestamp * 1000) :else nil)
    )

    ;;;
     ; <p>When a key rotation time is set, any money controlled by keys created before the given timestamp T will be
     ; automatically respent to any key that was created after T.  This can be used to recover from a situation where
     ; a set of keys is believed to be compromised.  You can stop key rotation by calling this method again with zero
     ; as the argument.  Once set up, calling {@link #doMaintenance(org.spongycastle.crypto.params.KeyParameter, boolean)}
     ; will create and possibly send rotation transactions: but it won't be done automatically (because you might have
     ; to ask for the users password).</p>
     ;
     ; <p>The given time cannot be in the future.</p>
     ;;
    #_public
    (§ method void setKeyRotationTime(§ args long unixTimeSeconds))
    (§ block
        (§ call Preconditions.checkArgument(§ pars unixTimeSeconds <= Utils.currentTimeSeconds(§ pars ), "Given time (%s) cannot be in the future.", Utils.dateTimeFormat(§ pars unixTimeSeconds * 1000)))
        (§ ass vKeyRotationTimestamp = unixTimeSeconds)
        (§ call saveNow(§ pars ))
    )

    ;;; Returns whether the keys creation time is before the key rotation time, if one was set. ;;
    #_public
    (§ method boolean isKeyRotating(§ args ECKey key))
    (§ block
        (§ var long time = vKeyRotationTimestamp)
        (§ return (§ expr time != 0 && key.getCreationTimeSeconds(§ pars ) < time))
    )

    ;;;
     ; A wallet app should call this from time to time in order to let the wallet craft and send transactions needed
     ; to re-organise coins internally.  A good time to call this would be after receiving coins for an unencrypted
     ; wallet, or after sending money for an encrypted wallet.  If you have an encrypted wallet and just want to know
     ; if some maintenance needs doing, call this method with andSend set to false and look at the returned list of
     ; transactions.  Maintenance might also include internal changes that involve some processing or work but
     ; which don't require making transactions - these will happen automatically unless the password is required
     ; in which case an exception will be thrown.
     ;
     ; @param aesKey The users password, if any.
     ; @param signAndSend If true, send the transactions via the tx broadcaster and return them, if false just return them.
     ; @return a list of transactions that the wallet just made/will make for internal maintenance.  Might be empty.
     ; @throws org.bitcoinj.wallet.DeterministicUpgradeRequiresPassword if key rotation requires the users password.
     ;;
    #_public
    (§ method ListenableFuture<List<Transaction>> doMaintenance(§ args #_nilable KeyParameter aesKey, boolean signAndSend))
        (§ throws DeterministicUpgradeRequiresPassword)
    (§ block
        (§ var List<Transaction> txns)
        (§ call lock.lock(§ pars ))
        (§ call keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass txns = maybeRotateKeys(§ pars aesKey, signAndSend))
            (§ if (§ expr !signAndSend))
            (§ block
                (§ return Futures.immediateFuture(§ pars txns))
            )
        )
        (§ finally )
        (§ block
            (§ call keyChainGroupLock.unlock(§ pars ))
            (§ call lock.unlock(§ pars ))
        )
        (§ call Preconditions.checkState(§ pars !lock.isHeldByCurrentThread(§ pars )))
        (§ var ArrayList<ListenableFuture<Transaction>> futures = new ArrayList<>(§ pars txns.size(§ pars )))
        (§ var TransactionBroadcaster broadcaster = vTransactionBroadcaster)
        (§ for (§ var Transaction tx) :for (§ expr txns))
        (§ block
            (§ try )
            (§ block
                #_final
                (§ var ListenableFuture<Transaction> future = broadcaster.broadcastTransaction(§ pars tx).future(§ pars ))
                (§ call futures.add(§ pars future))
                (§ call Futures.addCallback(§ pars future, new FutureCallback<Transaction>(§ pars )
                (§ anon
                    #_override
                    #_public
                    (§ method void onSuccess(§ args Transaction transaction))
                    (§ block
                        (§ call log.info(§ pars "Successfully broadcast key rotation tx: {}", transaction))
                    )

                    #_override
                    #_public
                    (§ method void onFailure(§ args Throwable throwable))
                    (§ block
                        (§ call log.error(§ pars "Failed to broadcast key rotation tx", throwable))
                    )
                )))
            )
            (§ catch (§ args Exception e))
            (§ block
                (§ call log.error(§ pars "Failed to broadcast rekey tx", e))
            )
        )
        (§ return Futures.allAsList(§ pars futures))
    )

    ;; Checks to see if any coins are controlled by rotating keys and if so, spends them.
    #_guarded-by(§ opt "keyChainGroupLock")
    #_private
    (§ method List<Transaction> maybeRotateKeys(§ args #_nilable KeyParameter aesKey, boolean sign))
        (§ throws DeterministicUpgradeRequiresPassword)
    (§ block
        (§ call Preconditions.checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ call Preconditions.checkState(§ pars keyChainGroupLock.isHeldByCurrentThread(§ pars )))

        (§ var List<Transaction> results = Lists.newLinkedList(§ pars ))
        ;; TODO: Handle chain replays here.
        #_final
        (§ var long keyRotationTimestamp = vKeyRotationTimestamp)
        (§ if (§ expr keyRotationTimestamp == 0))
        (§ block
            (§ return results) ;; Nothing to do.
        )

        ;; We might have to create a new HD hierarchy if the previous ones are now rotating.
        (§ var boolean allChainsRotating = true)
        (§ for (§ var DeterministicKeyChain chain) :for (§ expr keyChainGroup.getDeterministicKeyChains(§ pars )))
        (§ block
            (§ if (§ expr keyRotationTimestamp <= chain.getEarliestKeyCreationTime(§ pars )))
            (§ block
                (§ ass allChainsRotating = false)
                (§ break )
            )
        )
        (§ if (§ expr allChainsRotating))
        (§ block
            (§ try )
            (§ block
                (§ if (§ expr keyChainGroup.getImportedKeys(§ pars ).isEmpty(§ pars )))
                (§ block
                    (§ call log.info(§ pars "All HD chains are currently rotating and we have no random keys, creating fresh HD chain ..."))
                    (§ call keyChainGroup.createAndActivateNewHDChain(§ pars ))
                )
                (§ else )
                (§ block
                    (§ call log.info(§ pars "All HD chains are currently rotating, attempting to create a new one from the next oldest non-rotating key material ..."))
                    (§ call keyChainGroup.upgradeToDeterministic(§ pars keyRotationTimestamp, aesKey))
                    (§ call log.info(§ pars " ... upgraded to HD again, based on next best oldest key."))
                )
            )
            (§ catch (§ args AllRandomKeysRotating _))
            (§ block
                (§ call log.info(§ pars " ... no non-rotating random keys available, generating entirely new HD tree: backup required after this."))
                (§ call keyChainGroup.createAndActivateNewHDChain(§ pars ))
            )
            (§ call saveNow(§ pars ))
        )

        ;; Because transactions are size limited, we might not be able to re-key the entire wallet in one go.  So loop
        ;; around here until we no longer produce transactions with the max number of inputs.  That means we're fully
        ;; done, at least for now (we may still get more transactions later and this method will be reinvoked).
        (§ var Transaction tx)
        (§ do )
        (§ block
            (§ ass tx = rekeyOneBatch(§ pars keyRotationTimestamp, aesKey, results, sign))
            (§ if (§ expr tx != nil))
            (§ block
                (§ call results.add(§ pars tx))
            )
        )
        (§ again (§ expr tx != nil && tx.getInputs(§ pars ).size(§ pars ) == KeyTimeCoinSelector.MAX_SIMULTANEOUS_INPUTS))

        (§ return results)
    )

    #_nilable
    #_private
    (§ method Transaction rekeyOneBatch(§ args long timeSecs, #_nilable KeyParameter aesKey, List<Transaction> others, boolean sign))
    (§ block
        (§ call lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; Build the transaction using some custom logic for our special needs.  Last parameter to
            ;; KeyTimeCoinSelector is whether to ignore pending transactions or not.
            ;;
            ;; We ignore pending outputs because trying to rotate these is basically racing an attacker, and
            ;; we're quite likely to lose and create stuck double spends.  Also, some users who have 0.9 wallets
            ;; have already got stuck double spends in their wallet due to the Bloom-filtering block reordering
            ;; bug that was fixed in 0.10, thus, making a re-key transaction depend on those would cause it to
            ;; never confirm at all.
            (§ var CoinSelector keyTimeSelector = new KeyTimeCoinSelector(§ pars this, timeSecs, true))
            (§ var FilteringCoinSelector selector = new FilteringCoinSelector(§ pars keyTimeSelector))
            (§ for (§ var Transaction other) :for (§ expr others))
            (§ block
                (§ call selector.excludeOutputsSpentBy(§ pars other))
            )
            ;; TODO: Make this use the standard SendRequest.
            (§ var CoinSelection toMove = selector.select(§ pars Coin.ZERO, calculateAllSpendCandidates(§ pars )))
            (§ if (§ expr toMove.valueGathered.equals(§ pars Coin.ZERO)))
            (§ block
                (§ return nil) ;; Nothing to do.
            )

            (§ call maybeUpgradeToHD(§ pars aesKey))
            (§ var Transaction rekeyTx = new Transaction(§ pars params))
            (§ for (§ var TransactionOutput output) :for (§ expr toMove.gathered))
            (§ block
                (§ call rekeyTx.addInput(§ pars output))
            )
            ;; When not signing, don't waste addresses.
            (§ call rekeyTx.addOutput(§ pars toMove.valueGathered, sign ? freshReceiveAddress(§ pars ) :else currentReceiveAddress(§ pars )))
            (§ if (§ expr !adjustOutputDownwardsForFee(§ pars rekeyTx, toMove, Transaction.DEFAULT_TX_FEE, true)))
            (§ block
                (§ call log.error(§ pars "Failed to adjust rekey tx for fees."))
                (§ return nil)
            )

            (§ call rekeyTx.getConfidence(§ pars ).setSource(§ pars TransactionConfidence.Source.SELF))
            (§ call rekeyTx.setPurpose(§ pars Transaction.Purpose.KEY_ROTATION))
            (§ var SendRequest req = SendRequest.forTx(§ pars rekeyTx))
            (§ ass req.aesKey = aesKey)
            (§ if (§ expr sign))
            (§ block
                (§ call signTransaction(§ pars req))
            )
            ;; KeyTimeCoinSelector should never select enough inputs to push us oversize.
            (§ call Preconditions.checkState(§ pars rekeyTx.unsafeBitcoinSerialize(§ pars ).length < Transaction.MAX_STANDARD_TX_SIZE))
            (§ return rekeyTx)
        )
        (§ catch (§ args VerificationException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e))) ;; Cannot happen.
        )
        (§ finally )
        (§ block
            (§ call lock.unlock(§ pars ))
        )
    )
)

#_(ns org.bitcoinj.wallet #_"WalletFiles"
    (:import [java.io *]
             [java.util Date]
             [java.util.concurrent *]
             [java.util.concurrent.atomic *])
    (:import [com.google.common.base Preconditions Stopwatch]
             [org.slf4j *])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.utils *]))

;;;
 ; A class that handles atomic and optionally delayed writing of the wallet file to disk.  In future: backups too.
 ; It can be useful to delay writing of a wallet file to disk on slow devices where disk and serialization overhead
 ; can come to dominate the chain processing speed, i.e. on Android phones.  By coalescing writes and doing
 ; serialization and disk IO on a background thread performance can be improved.
 ;;
#_public
(§ class WalletFiles
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars WalletFiles.class))

    #_private
    #_final
    (§ field Wallet wallet)
    #_private
    #_final
    (§ field ScheduledThreadPoolExecutor executor)
    #_private
    #_final
    (§ field File file)
    #_private
    #_final
    (§ field AtomicBoolean savePending)
    #_private
    #_final
    (§ field long delay)
    #_private
    #_final
    (§ field TimeUnit delayTimeUnit)
    #_private
    #_final
    (§ field Callable<Void> saver)

    #_private
    #_volatile
    (§ field Listener vListener)

    ;;;
     ; Implementors can do pre/post treatment of the wallet file.  Useful for adjusting permissions and other things.
     ;;
    #_public
    (§ interface Listener
        ;;;
         ; Called on the auto-save thread when a new temporary file is created but before the wallet data is saved
         ; to it.  If you want to do something here like adjust permissions, go ahead and do so.
         ;;
        (§ method void onBeforeAutoSave(§ args File tempFile))

        ;;;
         ; Called on the auto-save thread after the newly created temporary file has been filled with data and renamed.
         ;;
        (§ method void onAfterAutoSave(§ args File newlySavedFile))
    )

    ;;;
     ; Initialize atomic and optionally delayed writing of the wallet file to disk.  Note the initial wallet state isn't
     ; saved automatically.  The {@link Wallet} calls {@link #saveNow()} or {@link #saveLater()} as wallet state changes,
     ; depending on the urgency of the changes.
     ;;
    #_public
    (§ constructor WalletFiles(§ args #_final Wallet wallet, File file, long delay, TimeUnit delayTimeUnit))
    (§ block
        ;; An executor that starts up threads when needed and shuts them down later.
        (§ ass this.executor = new ScheduledThreadPoolExecutor(§ pars 1, new ContextPropagatingThreadFactory(§ pars "Wallet autosave thread", Thread.MIN_PRIORITY)))
        (§ call this.executor.setKeepAliveTime(§ pars 5, TimeUnit.SECONDS))
        (§ call this.executor.allowCoreThreadTimeOut(§ pars true))
        (§ call this.executor.setExecuteExistingDelayedTasksAfterShutdownPolicy(§ pars false))
        (§ ass this.wallet = Preconditions.checkNotNull(§ pars wallet))
        ;; File must only be accessed from the auto-save executor from now on, to avoid simultaneous access.
        (§ ass this.file = Preconditions.checkNotNull(§ pars file))
        (§ ass this.savePending = new AtomicBoolean(§ pars ))
        (§ ass this.delay = delay)
        (§ ass this.delayTimeUnit = Preconditions.checkNotNull(§ pars delayTimeUnit))

        (§ ass this.saver = new Callable<Void>(§ pars )
        (§ anon
            #_override
            #_public
            (§ method Void call(§ args ))
                (§ throws Exception)
            (§ block
                ;; Runs in an auto save thread.
                (§ if (§ expr !savePending.getAndSet(§ pars false)))
                (§ block
                    ;; Some other scheduled request already beat us to it.
                    (§ return nil)
                )
                (§ var Date lastBlockSeenTime = wallet.getLastBlockSeenTime(§ pars ))
                (§ call log.info(§ pars "Background saving wallet; last seen block is height {}, date {}, hash {}", wallet.getLastBlockSeenHeight(§ pars ), (§ expr lastBlockSeenTime != nil) ? Utils.dateTimeFormat(§ pars lastBlockSeenTime) :else "unknown", wallet.getLastBlockSeenHash(§ pars )))
                (§ call saveNowInternal(§ pars ))
                (§ return nil)
            )
        ))
    )

    ;;;
     ; The given listener will be called on the autosave thread before and after the wallet is saved to disk.
     ;;
    #_public
    (§ method void setListener(§ args #_non-nil Listener listener))
    (§ block
        (§ ass this.vListener = Preconditions.checkNotNull(§ pars listener))
    )

    ;;; Actually write the wallet file to disk, using an atomic rename when possible.  Runs on the current thread. ;;
    #_public
    (§ method void saveNow(§ args ))
        (§ throws IOException)
    (§ block
        ;; Can be called by any thread. However the wallet is locked whilst saving, so we can have two saves
        ;; in flight, but they will serialize (using different temp files).
        (§ var Date lastBlockSeenTime = wallet.getLastBlockSeenTime(§ pars ))
        (§ call log.info(§ pars "Saving wallet; last seen block is height {}, date {}, hash {}", wallet.getLastBlockSeenHeight(§ pars ), (§ expr lastBlockSeenTime != nil) ? Utils.dateTimeFormat(§ pars lastBlockSeenTime) :else "unknown", wallet.getLastBlockSeenHash(§ pars )))
        (§ call saveNowInternal(§ pars ))
    )

    #_private
    (§ method void saveNowInternal(§ args ))
        (§ throws IOException)
    (§ block
        #_final
        (§ var Stopwatch watch = Stopwatch.createStarted(§ pars ))
        (§ var File directory = file.getAbsoluteFile(§ pars ).getParentFile(§ pars ))
        (§ var File temp = File.createTempFile(§ pars "wallet", nil, directory))
        #_final
        (§ var Listener listener = vListener)
        (§ if (§ expr listener != nil))
        (§ block
            (§ call listener.onBeforeAutoSave(§ pars temp))
        )
        (§ call wallet.saveToFile(§ pars temp, file))
        (§ if (§ expr listener != nil))
        (§ block
            (§ call listener.onAfterAutoSave(§ pars file))
        )
        (§ call watch.stop(§ pars ))
        (§ call log.info(§ pars "Save completed in {}", watch))
    )

    ;;; Queues up a save in the background.  Useful for not very important wallet changes. ;;
    #_public
    (§ method void saveLater(§ args ))
    (§ block
        (§ if (§ expr savePending.getAndSet(§ pars true)))
        (§ block
            (§ return ) ;; Already pending.
        )

        (§ call executor.schedule(§ pars saver, delay, delayTimeUnit))
    )

    ;;; Shut down auto-saving. ;;
    #_public
    (§ method void shutdownAndWait(§ args ))
    (§ block
        (§ call executor.shutdown(§ pars ))
        (§ try )
        (§ block
            (§ call executor.awaitTermination(§ pars Long.MAX_VALUE, TimeUnit.DAYS)) ;; forever
        )
        (§ catch (§ args InterruptedException e))
        (§ block
            (§ throw (§ new RuntimeException(§ pars e)))
        )
    )
)

#_(ns org.bitcoinj.wallet #_"WalletProtobufSerializer"
    (:import [java.io IOException InputStream OutputStream]
             [java.math BigInteger]
             [java.net InetAddress UnknownHostException]
             [java.util *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [com.google.protobuf ByteString CodedInputStream CodedOutputStream TextFormat WireFormat]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.core.TransactionConfidence ConfidenceType]
             [org.bitcoinj.crypto KeyCrypter KeyCrypterScrypt]
             [org.bitcoinj.script Script]
             [org.bitcoinj.signers LocalTransactionSigner TransactionSigner]
             [org.bitcoinj.utils ExchangeRate Fiat]
             [org.bitcoinj.wallet.Protos.Wallet EncryptionType]))

;;;
 ; Serialize and de-serialize a wallet to a byte stream containing a
 ; <a href="https://developers.google.com/protocol-buffers/docs/overview">protocol buffer</a>.  Protocol buffers are
 ; a data interchange format developed by Google with an efficient binary representation, a type safe specification
 ; language and compilers that generate code to work with those data structures for many languages.  Protocol buffers
 ; can have their format evolved over time: conceptually they represent data using (tag, length, value) tuples.  The
 ; format is defined by the <tt>wallet.proto</tt> file in the bitcoinj source distribution.
 ;
 ; This class is used through its static methods.  The most common operations are writeWallet and readWallet, which do
 ; the obvious operations on Output/InputStreams.  You can use a {@link java.io.ByteArrayInputStream} and equivalent
 ; {@link java.io.ByteArrayOutputStream} if you'd like byte arrays instead.  The protocol buffer can also be manipulated
 ; in its object form if you'd like to modify the flattened data structure before serialization to binary.
 ;
 ; You can extend the wallet format with additional fields specific to your application if you want, but make sure
 ; to either put the extra data in the provided extension areas, or select tag numbers that are unlikely to be used
 ; by anyone else.
 ;
 ; @author Miron Cuperman
 ; @author Andreas Schildbach
 ;;
#_public
(§ class WalletProtobufSerializer
    #_private
    #_static
    #_final
    (§ field Logger log = LoggerFactory.getLogger(§ pars WalletProtobufSerializer.class))

    ;;; Current version used for serializing wallets.  A version higher than this is considered from the future. ;;
    #_public
    #_static
    #_final
    (§ field int CURRENT_WALLET_VERSION = Protos.Wallet.getDefaultInstance(§ pars ).getVersion(§ pars ))
    ;; 512 MB
    #_private
    #_static
    #_final
    (§ field int WALLET_SIZE_LIMIT = 512 * 1024 * 1024)
    ;; Used for de-serialization.
    #_protected
    (§ field Map<ByteString, Transaction> txMap)

    #_private
    (§ field int walletWriteBufferSize = CodedOutputStream.DEFAULT_BUFFER_SIZE)

    #_public
    (§ interface WalletFactory
        (§ method Wallet create(§ args NetworkParameters params, KeyChainGroup keyChainGroup))
    )

    #_private
    #_final
    (§ field WalletFactory factory)
    #_private
    (§ field KeyChainFactory keyChainFactory)

    #_public
    (§ constructor WalletProtobufSerializer(§ args ))
    (§ block
        (§ this (§ pars new WalletFactory(§ pars )
        (§ anon
            #_override
            #_public
            (§ method Wallet create(§ args NetworkParameters params, KeyChainGroup keyChainGroup))
            (§ block
                (§ return (§ new Wallet(§ pars params, keyChainGroup)))
            )
        )))
    )

    #_public
    (§ constructor WalletProtobufSerializer(§ args WalletFactory factory))
    (§ block
        (§ ass txMap = new HashMap<>(§ pars ))
        (§ ass this.factory = factory)
        (§ ass this.keyChainFactory = new DefaultKeyChainFactory(§ pars ))
    )

    #_public
    (§ method void setKeyChainFactory(§ args KeyChainFactory keyChainFactory))
    (§ block
        (§ ass this.keyChainFactory = keyChainFactory)
    )

    ;;;
     ; Change buffer size for writing wallet to output stream.
     ; Default is {@link com.google.protobuf.CodedOutputStream.DEFAULT_BUFFER_SIZE}.
     ; @param walletWriteBufferSize Buffer size in bytes.
     ;;
    #_public
    (§ method void setWalletWriteBufferSize(§ args int walletWriteBufferSize))
    (§ block
        (§ ass this.walletWriteBufferSize = walletWriteBufferSize)
    )

    ;;;
     ; Formats the given wallet (transactions and keys) to the given output stream in protocol buffer format.
     ;
     ; Equivalent to <tt>walletToProto(wallet).writeTo(output)</tt>.
     ;;
    #_public
    (§ method void writeWallet(§ args Wallet wallet, OutputStream output))
        (§ throws IOException)
    (§ block
        (§ var Protos.Wallet walletProto = walletToProto(§ pars wallet))
        #_final
        (§ var CodedOutputStream codedOutput = CodedOutputStream.newInstance(§ pars output, this.walletWriteBufferSize))
        (§ call walletProto.writeTo(§ pars codedOutput))
        (§ call codedOutput.flush(§ pars ))
    )

    ;;;
     ; Returns the given wallet formatted as text.  The text format is that used by protocol buffers and although
     ; it can also be parsed using {@link TextFormat#merge(CharSequence, com.google.protobuf.Message.Builder)},
     ; it is designed more for debugging than storage.  It is not well specified and wallets are largely binary data
     ; structures anyway, consisting as they do of keys (large random numbers) and {@link Transaction}s which also
     ; mostly contain keys and hashes.
     ;;
    #_public
    (§ method String walletToText(§ args Wallet wallet))
    (§ block
        (§ var Protos.Wallet walletProto = walletToProto(§ pars wallet))
        (§ return TextFormat.printToString(§ pars walletProto))
    )

    ;;;
     ; Converts the given wallet to the object representation of the protocol buffers.  This can be modified, or
     ; additional data fields set, before serialization takes place.
     ;;
    #_public
    (§ method Protos.Wallet walletToProto(§ args Wallet wallet))
    (§ block
        (§ var Protos.Wallet.Builder walletBuilder = Protos.Wallet.newBuilder(§ pars ))
        (§ call walletBuilder.setNetworkIdentifier(§ pars wallet.getNetworkParameters(§ pars ).getId(§ pars )))
        (§ if (§ expr wallet.getDescription(§ pars ) != nil))
        (§ block
            (§ call walletBuilder.setDescription(§ pars wallet.getDescription(§ pars )))
        )

        (§ for (§ var WalletTransaction wtx) :for (§ expr wallet.getWalletTransactions(§ pars )))
        (§ block
            (§ var Protos.Transaction txProto = makeTxProto(§ pars wtx))
            (§ call walletBuilder.addTransaction(§ pars txProto))
        )

        (§ call walletBuilder.addAllKey(§ pars wallet.serializeKeyChainGroupToProtobuf(§ pars )))

        ;; Populate the lastSeenBlockHash field.
        (§ var Sha256Hash lastSeenBlockHash = wallet.getLastBlockSeenHash(§ pars ))
        (§ if (§ expr lastSeenBlockHash != nil))
        (§ block
            (§ call walletBuilder.setLastSeenBlockHash(§ pars hashToByteString(§ pars lastSeenBlockHash)))
            (§ call walletBuilder.setLastSeenBlockHeight(§ pars wallet.getLastBlockSeenHeight(§ pars )))
        )
        (§ if (§ expr 0 < wallet.getLastBlockSeenTimeSecs(§ pars )))
        (§ block
            (§ call walletBuilder.setLastSeenBlockTimeSecs(§ pars wallet.getLastBlockSeenTimeSecs(§ pars )))
        )

        ;; Populate the scrypt parameters.
        (§ var KeyCrypter keyCrypter = wallet.getKeyCrypter(§ pars ))
        (§ if (§ expr keyCrypter == nil))
        (§ block
            ;; The wallet is unencrypted.
            (§ call walletBuilder.setEncryptionType(§ pars EncryptionType.UNENCRYPTED))
        )
        (§ else )
        (§ block
            ;; The wallet is encrypted.
            (§ call walletBuilder.setEncryptionType(§ pars keyCrypter.getUnderstoodEncryptionType(§ pars )))
            (§ if (§ expr keyCrypter instanceof KeyCrypterScrypt))
            (§ block
                (§ var KeyCrypterScrypt keyCrypterScrypt = (§ cast KeyCrypterScrypt)keyCrypter)
                (§ call walletBuilder.setEncryptionParameters(§ pars keyCrypterScrypt.getScryptParameters(§ pars )))
            )
            (§ else )
            (§ block
                ;; Some other form of encryption has been specified that we do not know how to persist.
                (§ throw (§ new RuntimeException(§ pars "The wallet has encryption of type '" + keyCrypter.getUnderstoodEncryptionType(§ pars ) + "' but this WalletProtobufSerializer does not know how to persist this.")))
            )
        )

        (§ if (§ expr wallet.getKeyRotationTime(§ pars ) != nil))
        (§ block
            (§ var long timeSecs = wallet.getKeyRotationTime(§ pars ).getTime(§ pars ) / 1000)
            (§ call walletBuilder.setKeyRotationTime(§ pars timeSecs))
        )

        (§ for (§ var TransactionSigner signer) :for (§ expr wallet.getTransactionSigners(§ pars )))
        (§ block
            ;; Do not serialize LocalTransactionSigner as it's being added implicitly.
            (§ if (§ expr signer instanceof LocalTransactionSigner))
            (§ block
                (§ continue )
            )

            (§ var Protos.TransactionSigner.Builder protoSigner = Protos.TransactionSigner.newBuilder(§ pars ))
            (§ call protoSigner.setClassName(§ pars signer.getClass(§ pars ).getName(§ pars )))
            (§ call protoSigner.setData(§ pars ByteString.copyFrom(§ pars signer.serialize(§ pars ))))
            (§ call walletBuilder.addTransactionSigners(§ pars protoSigner))
        )

        ;; Populate the wallet version.
        (§ call walletBuilder.setVersion(§ pars wallet.getVersion(§ pars )))

        (§ return walletBuilder.build(§ pars ))
    )

    #_private
    #_static
    (§ method Protos.Transaction makeTxProto(§ args WalletTransaction wtx))
    (§ block
        (§ var Transaction tx = wtx.getTransaction(§ pars ))
        (§ var Protos.Transaction.Builder txBuilder = Protos.Transaction.newBuilder(§ pars ))

        (§ call txBuilder.setPool(§ pars getProtoPool(§ pars wtx)).setHash(§ pars hashToByteString(§ pars tx.getHash(§ pars ))).setVersion(§ pars (§ cast int)tx.getVersion(§ pars )))

        (§ if (§ expr tx.getUpdateTime(§ pars ) != nil))
        (§ block
            (§ call txBuilder.setUpdatedAt(§ pars tx.getUpdateTime(§ pars ).getTime(§ pars )))
        )

        (§ if (§ expr 0 < tx.getLockTime(§ pars )))
        (§ block
            (§ call txBuilder.setLockTime(§ pars (§ cast int)tx.getLockTime(§ pars )))
        )

        ;; Handle inputs.
        (§ for (§ var TransactionInput input) :for (§ expr tx.getInputs(§ pars )))
        (§ block
            (§ var Protos.TransactionInput.Builder inputBuilder = Protos.TransactionInput.newBuilder(§ pars ).setScriptBytes(§ pars ByteString.copyFrom(§ pars input.getScriptBytes(§ pars ))).setTransactionOutPointHash(§ pars hashToByteString(§ pars input.getOutpoint(§ pars ).getHash(§ pars ))).setTransactionOutPointIndex(§ pars (§ cast int)input.getOutpoint(§ pars ).getIndex(§ pars )))
            (§ if (§ expr input.hasSequence(§ pars )))
            (§ block
                (§ call inputBuilder.setSequence(§ pars (§ cast int)input.getSequenceNumber(§ pars )))
            )
            (§ if (§ expr input.getValue(§ pars ) != nil))
            (§ block
                (§ call inputBuilder.setValue(§ pars input.getValue(§ pars ).value))
            )
            (§ call txBuilder.addTransactionInput(§ pars inputBuilder))
        )

        ;; Handle outputs.
        (§ for (§ var TransactionOutput output) :for (§ expr tx.getOutputs(§ pars )))
        (§ block
            (§ var Protos.TransactionOutput.Builder outputBuilder = Protos.TransactionOutput.newBuilder(§ pars ).setScriptBytes(§ pars ByteString.copyFrom(§ pars output.getScriptBytes(§ pars ))).setValue(§ pars output.getValue(§ pars ).value))
            #_final
            (§ var TransactionInput spentBy = output.getSpentBy(§ pars ))
            (§ if (§ expr spentBy != nil))
            (§ block
                (§ var Sha256Hash spendingHash = spentBy.getParentTransaction(§ pars ).getHash(§ pars ))
                (§ var int spentByTransactionIndex = spentBy.getParentTransaction(§ pars ).getInputs(§ pars ).indexOf(§ pars spentBy))
                (§ call outputBuilder.setSpentByTransactionHash(§ pars hashToByteString(§ pars spendingHash)).setSpentByTransactionIndex(§ pars spentByTransactionIndex))
            )
            (§ call txBuilder.addTransactionOutput(§ pars outputBuilder))
        )

        ;; Handle which blocks tx was seen in.
        #_final
        (§ var Map<Sha256Hash, Integer> appearsInHashes = tx.getAppearsInHashes(§ pars ))
        (§ if (§ expr appearsInHashes != nil))
        (§ block
            (§ for (§ var Map.Entry<Sha256Hash, Integer> entry) :for (§ expr appearsInHashes.entrySet(§ pars )))
            (§ block
                (§ call txBuilder.addBlockHash(§ pars hashToByteString(§ pars entry.getKey(§ pars ))))
                (§ call txBuilder.addBlockRelativityOffsets(§ pars entry.getValue(§ pars )))
            )
        )

        (§ if (§ expr tx.hasConfidence(§ pars )))
        (§ block
            (§ var TransactionConfidence confidence = tx.getConfidence(§ pars ))
            (§ var Protos.TransactionConfidence.Builder confidenceBuilder = Protos.TransactionConfidence.newBuilder(§ pars ))
            (§ call writeConfidence(§ pars txBuilder, confidence, confidenceBuilder))
        )

        (§ var Protos.Transaction.Purpose purpose)
        (§ switch (§ expr tx.getPurpose(§ pars )))
        (§ block
            (§ case UNKNOWN)
            (§ block
                (§ ass purpose = Protos.Transaction.Purpose.UNKNOWN)
                (§ break )
            )
            (§ case USER_PAYMENT)
            (§ block
                (§ ass purpose = Protos.Transaction.Purpose.USER_PAYMENT)
                (§ break )
            )
            (§ case KEY_ROTATION)
            (§ block
                (§ ass purpose = Protos.Transaction.Purpose.KEY_ROTATION)
                (§ break )
            )
            (§ case ASSURANCE_CONTRACT_CLAIM)
            (§ block
                (§ ass purpose = Protos.Transaction.Purpose.ASSURANCE_CONTRACT_CLAIM)
                (§ break )
            )
            (§ case ASSURANCE_CONTRACT_PLEDGE)
            (§ block
                (§ ass purpose = Protos.Transaction.Purpose.ASSURANCE_CONTRACT_PLEDGE)
                (§ break )
            )
            (§ case ASSURANCE_CONTRACT_STUB)
            (§ block
                (§ ass purpose = Protos.Transaction.Purpose.ASSURANCE_CONTRACT_STUB)
                (§ break )
            )
            (§ case RAISE_FEE)
            (§ block
                (§ ass purpose = Protos.Transaction.Purpose.RAISE_FEE)
                (§ break )
            )
            (§ default )
            (§ block
                (§ throw (§ new RuntimeException(§ pars "New tx purpose serialization not implemented.")))
            )
        )
        (§ call txBuilder.setPurpose(§ pars purpose))

        (§ var ExchangeRate exchangeRate = tx.getExchangeRate(§ pars ))
        (§ if (§ expr exchangeRate != nil))
        (§ block
            (§ var Protos.ExchangeRate.Builder exchangeRateBuilder = Protos.ExchangeRate.newBuilder(§ pars ).setCoinValue(§ pars exchangeRate.coin.value).setFiatValue(§ pars exchangeRate.fiat.value).setFiatCurrencyCode(§ pars exchangeRate.fiat.currencyCode))
            (§ call txBuilder.setExchangeRate(§ pars exchangeRateBuilder))
        )

        (§ if (§ expr tx.getMemo(§ pars ) != nil))
        (§ block
            (§ call txBuilder.setMemo(§ pars tx.getMemo(§ pars )))
        )

        (§ return txBuilder.build(§ pars ))
    )

    #_private
    #_static
    (§ method Protos.Transaction.Pool getProtoPool(§ args WalletTransaction wtx))
    (§ block
        (§ switch (§ expr wtx.getPool(§ pars )))
        (§ block
            (§ case UNSPENT)
            (§ block
                (§ return Protos.Transaction.Pool.UNSPENT)
            )
            (§ case SPENT)
            (§ block
                (§ return Protos.Transaction.Pool.SPENT)
            )
            (§ case DEAD)
            (§ block
                (§ return Protos.Transaction.Pool.DEAD)
            )
            (§ case PENDING)
            (§ block
                (§ return Protos.Transaction.Pool.PENDING)
            )
            (§ default )
            (§ block
                (§ throw (§ new RuntimeException(§ pars "Unreachable")))
            )
        )
    )

    #_private
    #_static
    (§ method void writeConfidence(§ args Protos.Transaction.Builder txBuilder, TransactionConfidence confidence, Protos.TransactionConfidence.Builder confidenceBuilder))
    (§ block
        (§ sync confidence)
        (§ block
            (§ call confidenceBuilder.setType(§ pars Protos.TransactionConfidence.Type.valueOf(§ pars confidence.getConfidenceType(§ pars ).getValue(§ pars ))))
            (§ if (§ expr confidence.getConfidenceType(§ pars ) == ConfidenceType.BUILDING))
            (§ block
                (§ call confidenceBuilder.setAppearedAtHeight(§ pars confidence.getAppearedAtChainHeight(§ pars )))
                (§ call confidenceBuilder.setDepth(§ pars confidence.getDepthInBlocks(§ pars )))
            )
            (§ if (§ expr confidence.getConfidenceType(§ pars ) == ConfidenceType.DEAD))
            (§ block
                ;; Copy in the overriding transaction, if available.
                ;; (A dead coinbase transaction has no overriding transaction).
                (§ if (§ expr confidence.getOverridingTransaction(§ pars ) != nil))
                (§ block
                    (§ var Sha256Hash overridingHash = confidence.getOverridingTransaction(§ pars ).getHash(§ pars ))
                    (§ call confidenceBuilder.setOverridingTransaction(§ pars hashToByteString(§ pars overridingHash)))
                )
            )
            (§ var TransactionConfidence.Source source = confidence.getSource(§ pars ))
            (§ switch (§ expr source))
            (§ block
                (§ case SELF)
                (§ block
                    (§ call confidenceBuilder.setSource(§ pars Protos.TransactionConfidence.Source.SOURCE_SELF))
                    (§ break )
                )
                (§ case NETWORK)
                (§ block
                    (§ call confidenceBuilder.setSource(§ pars Protos.TransactionConfidence.Source.SOURCE_NETWORK))
                    (§ break )
                )
                (§ case UNKNOWN)
                (§ block
                    ;; Fall through.
                )
                (§ default )
                (§ block
                    (§ call confidenceBuilder.setSource(§ pars Protos.TransactionConfidence.Source.SOURCE_UNKNOWN))
                    (§ break )
                )
            )
        )

        (§ for (§ var PeerAddress address) :for (§ expr confidence.getBroadcastBy(§ pars )))
        (§ block
            (§ var Protos.PeerAddress proto = Protos.PeerAddress.newBuilder(§ pars ).setIpAddress(§ pars ByteString.copyFrom(§ pars address.getAddr(§ pars ).getAddress(§ pars ))).setPort(§ pars address.getPort(§ pars )).setServices(§ pars address.getServices(§ pars ).longValue(§ pars )).build(§ pars ))
            (§ call confidenceBuilder.addBroadcastBy(§ pars proto))
        )
        (§ var Date lastBroadcastedAt = confidence.getLastBroadcastedAt(§ pars ))
        (§ if (§ expr lastBroadcastedAt != nil))
        (§ block
            (§ call confidenceBuilder.setLastBroadcastedAt(§ pars lastBroadcastedAt.getTime(§ pars )))
        )
        (§ call txBuilder.setConfidence(§ pars confidenceBuilder))
    )

    #_public
    #_static
    (§ method ByteString hashToByteString(§ args Sha256Hash hash))
    (§ block
        (§ return ByteString.copyFrom(§ pars hash.getBytes(§ pars )))
    )

    #_public
    #_static
    (§ method Sha256Hash byteStringToHash(§ args ByteString bs))
    (§ block
        (§ return Sha256Hash.wrap(§ pars bs.toByteArray(§ pars )))
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails the provided Wallet object may be in an indeterminate state and should be thrown away.</p>
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt data,
     ; internally inconsistent data and so on.  You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
    #_public
    (§ method Wallet readWallet(§ args InputStream input))
        (§ throws UnreadableWalletException)
    (§ block
        (§ return readWallet(§ pars input, false))
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails the provided Wallet object may be in an indeterminate state and should be thrown away.  Do not
     ; simply call this method again on the same Wallet object with {@code forceReset} set {@code true}.
     ; It won't work.</p>
     ;
     ; <p>If {@code forceReset} is {@code true}, then no transactions are loaded from the wallet, and
     ; it is configured to replay transactions from the blockchain (as if the wallet had been loaded and
     ; {@link Wallet.reset} had been called immediately thereafter).
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt data,
     ; internally inconsistent data and so on. You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
    #_public
    (§ method Wallet readWallet(§ args InputStream input, boolean forceReset))
        (§ throws UnreadableWalletException)
    (§ block
        (§ try )
        (§ block
            (§ var Protos.Wallet walletProto = parseToProto(§ pars input))
            #_final
            (§ var String paramsID = walletProto.getNetworkIdentifier(§ pars ))
            (§ var NetworkParameters params = NetworkParameters.fromID(§ pars paramsID))
            (§ if (§ expr params == nil))
            (§ block
                (§ throw (§ new UnreadableWalletException(§ pars "Unknown network parameters ID " + paramsID)))
            )

            (§ return readWallet(§ pars params, walletProto, forceReset))
        )
        (§ catch (§ args IOException e))
        (§ block
            (§ throw (§ new UnreadableWalletException(§ pars "Could not parse input stream to protobuf", e)))
        )
        (§ catch (§ args IllegalStateException e))
        (§ block
            (§ throw (§ new UnreadableWalletException(§ pars "Could not parse input stream to protobuf", e)))
        )
        (§ catch (§ args IllegalArgumentException e))
        (§ block
            (§ throw (§ new UnreadableWalletException(§ pars "Could not parse input stream to protobuf", e)))
        )
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails, the provided Wallet object may be in an indeterminate state and should be thrown away.</p>
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt
     ; data, internally inconsistent data and so on.  You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
    #_public
    (§ method Wallet readWallet(§ args NetworkParameters params, Protos.Wallet walletProto))
        (§ throws UnreadableWalletException)
    (§ block
        (§ return readWallet(§ pars params, walletProto, false))
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails, the provided Wallet object may be in an indeterminate state and should be thrown away.  Do not
     ; simply call this method again on the same Wallet object with {@code forceReset} set {@code true}.
     ; It won't work.</p>
     ;
     ; <p>If {@code forceReset} is {@code true}, then no transactions are loaded from the wallet, and it is
     ; configured to replay transactions from the blockchain (as if the wallet had been loaded and
     ; {@link Wallet.reset} had been called immediately thereafter).
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt data,
     ; internally inconsistent data and so on.  You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
    #_public
    (§ method Wallet readWallet(§ args NetworkParameters params, Protos.Wallet walletProto, boolean forceReset))
        (§ throws UnreadableWalletException)
    (§ block
        (§ if (§ expr CURRENT_WALLET_VERSION < walletProto.getVersion(§ pars )))
        (§ block
            (§ throw new UnreadableWalletException.FutureVersion(§ pars ))
        )
        (§ if (§ expr !walletProto.getNetworkIdentifier(§ pars ).equals(§ pars params.getId(§ pars ))))
        (§ block
            (§ throw new UnreadableWalletException.WrongNetwork(§ pars ))
        )

        ;; Read the scrypt parameters that specify how encryption and decryption is performed.
        (§ var KeyChainGroup keyChainGroup)
        (§ if (§ expr walletProto.hasEncryptionParameters(§ pars )))
        (§ block
            (§ var Protos.ScryptParameters encryptionParameters = walletProto.getEncryptionParameters(§ pars ))
            #_final
            (§ var KeyCrypterScrypt keyCrypter = new KeyCrypterScrypt(§ pars encryptionParameters))
            (§ ass keyChainGroup = KeyChainGroup.fromProtobufEncrypted(§ pars params, walletProto.getKeyList(§ pars ), keyCrypter, keyChainFactory))
        )
        (§ else )
        (§ block
            (§ ass keyChainGroup = KeyChainGroup.fromProtobufUnencrypted(§ pars params, walletProto.getKeyList(§ pars ), keyChainFactory))
        )

        (§ var Wallet wallet = factory.create(§ pars params, keyChainGroup))
        (§ if (§ expr walletProto.hasDescription(§ pars )))
        (§ block
            (§ call wallet.setDescription(§ pars walletProto.getDescription(§ pars )))
        )

        (§ if (§ expr forceReset))
        (§ block
            ;; Should mirror Wallet.reset().
            (§ call wallet.setLastBlockSeenHash(§ pars nil))
            (§ call wallet.setLastBlockSeenHeight(§ pars -1))
            (§ call wallet.setLastBlockSeenTimeSecs(§ pars 0))
        )
        (§ else )
        (§ block
            ;; Read all transactions and insert into the txMap.
            (§ for (§ var Protos.Transaction txProto) :for (§ expr walletProto.getTransactionList(§ pars )))
            (§ block
                (§ call readTransaction(§ pars txProto, wallet.getParams(§ pars )))
            )

            ;; Update transaction outputs to point to inputs that spend them.
            (§ for (§ var Protos.Transaction txProto) :for (§ expr walletProto.getTransactionList(§ pars )))
            (§ block
                (§ var WalletTransaction wtx = connectTransactionOutputs(§ pars params, txProto))
                (§ call wallet.addWalletTransaction(§ pars wtx))
            )

            ;; Update the lastBlockSeenHash.
            (§ if (§ expr !walletProto.hasLastSeenBlockHash(§ pars )))
            (§ block
                (§ call wallet.setLastBlockSeenHash(§ pars nil))
            )
            (§ else )
            (§ block
                (§ call wallet.setLastBlockSeenHash(§ pars byteStringToHash(§ pars walletProto.getLastSeenBlockHash(§ pars ))))
            )

            (§ if (§ expr !walletProto.hasLastSeenBlockHeight(§ pars )))
            (§ block
                (§ call wallet.setLastBlockSeenHeight(§ pars -1))
            )
            (§ else )
            (§ block
                (§ call wallet.setLastBlockSeenHeight(§ pars walletProto.getLastSeenBlockHeight(§ pars )))
            )

            ;; Will default to zero if not present.
            (§ call wallet.setLastBlockSeenTimeSecs(§ pars walletProto.getLastSeenBlockTimeSecs(§ pars )))

            (§ if (§ expr walletProto.hasKeyRotationTime(§ pars )))
            (§ block
                (§ call wallet.setKeyRotationTime(§ pars (§ new Date(§ pars walletProto.getKeyRotationTime(§ pars ) * 1000))))
            )
        )

        (§ for (§ var Protos.TransactionSigner signerProto) :for (§ expr walletProto.getTransactionSignersList(§ pars )))
        (§ block
            (§ try )
            (§ block
                (§ var Class signerClass = Class.forName(§ pars signerProto.getClassName(§ pars )))
                (§ var TransactionSigner signer = (§ cast TransactionSigner)signerClass.newInstance(§ pars ))
                (§ call signer.deserialize(§ pars signerProto.getData(§ pars ).toByteArray(§ pars )))
                (§ call wallet.addTransactionSigner(§ pars signer))
            )
            (§ catch (§ args Exception e))
            (§ block
                (§ throw (§ new UnreadableWalletException(§ pars "Unable to deserialize TransactionSigner instance: " + signerProto.getClassName(§ pars ), e)))
            )
        )

        (§ if (§ expr walletProto.hasVersion(§ pars )))
        (§ block
            (§ call wallet.setVersion(§ pars walletProto.getVersion(§ pars )))
        )

        ;; Make sure the object can be re-used to read another wallet without corruption.
        (§ call txMap.clear(§ pars ))

        (§ return wallet)
    )

    ;;;
     ; Returns the loaded protocol buffer from the given byte stream.  You normally want
     ; {@link Wallet#loadFromFile(java.io.File)} instead - this method is designed for
     ; low level work involving the wallet file format itself.
     ;;
    #_public
    #_static
    (§ method Protos.Wallet parseToProto(§ args InputStream input))
        (§ throws IOException)
    (§ block
        (§ var CodedInputStream codedInput = CodedInputStream.newInstance(§ pars input))
        (§ call codedInput.setSizeLimit(§ pars WALLET_SIZE_LIMIT))
        (§ return Protos.Wallet.parseFrom(§ pars codedInput))
    )

    #_private
    (§ method void readTransaction(§ args Protos.Transaction txProto, NetworkParameters params))
        (§ throws UnreadableWalletException)
    (§ block
        (§ var Transaction tx = new Transaction(§ pars params))

        (§ call tx.setVersion(§ pars txProto.getVersion(§ pars )))

        (§ if (§ expr txProto.hasUpdatedAt(§ pars )))
        (§ block
            (§ call tx.setUpdateTime(§ pars (§ new Date(§ pars txProto.getUpdatedAt(§ pars )))))
        )

        (§ for (§ var Protos.TransactionOutput outputProto) :for (§ expr txProto.getTransactionOutputList(§ pars )))
        (§ block
            (§ var Coin value = Coin.valueOf(§ pars outputProto.getValue(§ pars )))
            (§ var byte[] scriptBytes = outputProto.getScriptBytes(§ pars ).toByteArray(§ pars ))
            (§ var TransactionOutput output = new TransactionOutput(§ pars params, tx, value, scriptBytes))
            (§ call tx.addOutput(§ pars output))
        )

        (§ for (§ var Protos.TransactionInput inputProto) :for (§ expr txProto.getTransactionInputList(§ pars )))
        (§ block
            (§ var byte[] scriptBytes = inputProto.getScriptBytes(§ pars ).toByteArray(§ pars ))
            (§ var TransactionOutPoint outpoint = new TransactionOutPoint(§ pars params, inputProto.getTransactionOutPointIndex(§ pars ) & 0xffffffff, byteStringToHash(§ pars inputProto.getTransactionOutPointHash(§ pars ))))
            (§ var Coin value = inputProto.hasValue(§ pars ) ? Coin.valueOf(§ pars inputProto.getValue(§ pars )) :else nil)
            (§ var TransactionInput input = new TransactionInput(§ pars params, tx, scriptBytes, outpoint, value))
            (§ if (§ expr inputProto.hasSequence(§ pars )))
            (§ block
                (§ call input.setSequenceNumber(§ pars 0xffffffff & inputProto.getSequence(§ pars )))
            )
            (§ call tx.addInput(§ pars input))
        )

        (§ for (§ var int i = 0) :for (§ expr i < txProto.getBlockHashCount(§ pars )) :for (§ ass i = i + 1))
        (§ block
            (§ var ByteString blockHash = txProto.getBlockHash(§ pars i))
            (§ var int relativityOffset = 0)
            (§ if (§ expr 0 < txProto.getBlockRelativityOffsetsCount(§ pars )))
            (§ block
                (§ ass relativityOffset = txProto.getBlockRelativityOffsets(§ pars i))
            )
            (§ call tx.addBlockAppearance(§ pars byteStringToHash(§ pars blockHash), relativityOffset))
        )

        (§ if (§ expr txProto.hasLockTime(§ pars )))
        (§ block
            (§ call tx.setLockTime(§ pars 0xffffffff & txProto.getLockTime(§ pars )))
        )

        (§ if (§ expr txProto.hasPurpose(§ pars )))
        (§ block
            (§ switch (§ expr txProto.getPurpose(§ pars )))
            (§ block
                (§ case UNKNOWN)
                (§ block
                    (§ call tx.setPurpose(§ pars Transaction.Purpose.UNKNOWN))
                    (§ break )
                )
                (§ case USER_PAYMENT)
                (§ block
                    (§ call tx.setPurpose(§ pars Transaction.Purpose.USER_PAYMENT))
                    (§ break )
                )
                (§ case KEY_ROTATION)
                (§ block
                    (§ call tx.setPurpose(§ pars Transaction.Purpose.KEY_ROTATION))
                    (§ break )
                )
                (§ case ASSURANCE_CONTRACT_CLAIM)
                (§ block
                    (§ call tx.setPurpose(§ pars Transaction.Purpose.ASSURANCE_CONTRACT_CLAIM))
                    (§ break )
                )
                (§ case ASSURANCE_CONTRACT_PLEDGE)
                (§ block
                    (§ call tx.setPurpose(§ pars Transaction.Purpose.ASSURANCE_CONTRACT_PLEDGE))
                    (§ break )
                )
                (§ case ASSURANCE_CONTRACT_STUB)
                (§ block
                    (§ call tx.setPurpose(§ pars Transaction.Purpose.ASSURANCE_CONTRACT_STUB))
                    (§ break )
                )
                (§ case RAISE_FEE)
                (§ block
                    (§ call tx.setPurpose(§ pars Transaction.Purpose.RAISE_FEE))
                    (§ break )
                )
                (§ default )
                (§ block
                    (§ throw (§ new RuntimeException(§ pars "New purpose serialization not implemented")))
                )
            )
        )
        (§ else )
        (§ block
            ;; Old wallet: assume a user payment as that's the only reason a new tx would have been created back then.
            (§ call tx.setPurpose(§ pars Transaction.Purpose.USER_PAYMENT))
        )

        (§ if (§ expr txProto.hasExchangeRate(§ pars )))
        (§ block
            (§ var Protos.ExchangeRate exchangeRateProto = txProto.getExchangeRate(§ pars ))
            (§ call tx.setExchangeRate(§ pars (§ new ExchangeRate(§ pars Coin.valueOf(§ pars exchangeRateProto.getCoinValue(§ pars )), Fiat.valueOf(§ pars exchangeRateProto.getFiatCurrencyCode(§ pars ), exchangeRateProto.getFiatValue(§ pars ))))))
        )

        (§ if (§ expr txProto.hasMemo(§ pars )))
        (§ block
            (§ call tx.setMemo(§ pars txProto.getMemo(§ pars )))
        )

        ;; Transaction should now be complete.
        (§ var Sha256Hash protoHash = byteStringToHash(§ pars txProto.getHash(§ pars )))
        (§ if (§ expr !tx.getHash(§ pars ).equals(§ pars protoHash)))
        (§ block
            (§ throw (§ new UnreadableWalletException(§ pars String.format(§ pars Locale.US, "Transaction did not deserialize completely: %s vs %s", tx.getHash(§ pars ), protoHash))))
        )
        (§ if (§ expr txMap.containsKey(§ pars txProto.getHash(§ pars ))))
        (§ block
            (§ throw (§ new UnreadableWalletException(§ pars "Wallet contained duplicate transaction " + byteStringToHash(§ pars txProto.getHash(§ pars )))))
        )
        (§ call txMap.put(§ pars txProto.getHash(§ pars ), tx))
    )

    #_private
    (§ method WalletTransaction connectTransactionOutputs(§ args #_final NetworkParameters params, #_final org.bitcoinj.wallet.Protos.Transaction txProto))
        (§ throws UnreadableWalletException)
    (§ block
        (§ var Transaction tx = txMap.get(§ pars txProto.getHash(§ pars )))
        #_final
        (§ var WalletTransaction.Pool pool)
        (§ switch (§ expr txProto.getPool(§ pars )))
        (§ block
            (§ case DEAD)
            (§ block
                (§ ass pool = WalletTransaction.Pool.DEAD)
                (§ break )
            )
            (§ case PENDING)
            (§ block
                (§ ass pool = WalletTransaction.Pool.PENDING)
                (§ break )
            )
            (§ case SPENT)
            (§ block
                (§ ass pool = WalletTransaction.Pool.SPENT)
                (§ break )
            )
            (§ case UNSPENT)
            (§ block
                (§ ass pool = WalletTransaction.Pool.UNSPENT)
                (§ break )
            )
            ;; Upgrade old wallets: inactive pool has been merged with the pending pool.
            ;; Remove this some time after 0.9 is old and everyone has upgraded.
            ;; There should not be any spent outputs in this tx as old wallets would not allow them to be spent in this state.
            (§ case INACTIVE)
            (§ case PENDING_INACTIVE)
            (§ block
                (§ ass pool = WalletTransaction.Pool.PENDING)
                (§ break )
            )
            (§ default )
            (§ block
                (§ throw (§ new UnreadableWalletException(§ pars "Unknown transaction pool: " + txProto.getPool(§ pars ))))
            )
        )

        (§ for (§ var int i = 0) :for (§ expr i < tx.getOutputs(§ pars ).size(§ pars )) :for (§ ass i = i + 1))
        (§ block
            (§ var TransactionOutput output = tx.getOutputs(§ pars ).get(§ pars i))
            #_final
            (§ var Protos.TransactionOutput transactionOutput = txProto.getTransactionOutput(§ pars i))
            (§ if (§ expr transactionOutput.hasSpentByTransactionHash(§ pars )))
            (§ block
                #_final
                (§ var ByteString spentByTransactionHash = transactionOutput.getSpentByTransactionHash(§ pars ))
                (§ var Transaction spendingTx = txMap.get(§ pars spentByTransactionHash))
                (§ if (§ expr spendingTx == nil))
                (§ block
                    (§ throw (§ new UnreadableWalletException(§ pars String.format(§ pars Locale.US, "Could not connect %s to %s", tx.getHashAsString(§ pars ), byteStringToHash(§ pars spentByTransactionHash)))))
                )

                #_final
                (§ var int spendingIndex = transactionOutput.getSpentByTransactionIndex(§ pars ))
                (§ var TransactionInput input = Preconditions.checkNotNull(§ pars spendingTx.getInput(§ pars spendingIndex)))
                (§ call input.connect(§ pars output))
            )
        )

        (§ if (§ expr txProto.hasConfidence(§ pars )))
        (§ block
            (§ var Protos.TransactionConfidence confidenceProto = txProto.getConfidence(§ pars ))
            (§ var TransactionConfidence confidence = tx.getConfidence(§ pars ))
            (§ call readConfidence(§ pars params, tx, confidenceProto, confidence))
        )

        (§ return (§ new WalletTransaction(§ pars pool, tx)))
    )

    #_private
    (§ method void readConfidence(§ args #_final NetworkParameters params, #_final Transaction tx, #_final Protos.TransactionConfidence confidenceProto, #_final TransactionConfidence confidence))
        (§ throws UnreadableWalletException)
    (§ block
        ;; We are lenient here because tx confidence is not an essential part of the wallet.
        ;; If the tx has an unknown type of confidence, ignore.
        (§ if (§ expr !confidenceProto.hasType(§ pars )))
        (§ block
            (§ call log.warn(§ pars "Unknown confidence type for tx {}", tx.getHashAsString(§ pars )))
            (§ return )
        )

        (§ var ConfidenceType confidenceType)
        (§ switch (§ expr confidenceProto.getType(§ pars )))
        (§ block
            (§ case BUILDING)
            (§ block
                (§ ass confidenceType = ConfidenceType.BUILDING)
                (§ break )
            )
            (§ case DEAD)
            (§ block
                (§ ass confidenceType = ConfidenceType.DEAD)
                (§ break )
            )
            ;; These two are equivalent (must be able to read old wallets).
            (§ case NOT_IN_BEST_CHAIN)
            (§ block
                (§ ass confidenceType = ConfidenceType.PENDING)
                (§ break )
            )
            (§ case PENDING)
            (§ block
                (§ ass confidenceType = ConfidenceType.PENDING)
                (§ break )
            )
            (§ case IN_CONFLICT)
            (§ block
                (§ ass confidenceType = ConfidenceType.IN_CONFLICT)
                (§ break )
            )
            (§ case UNKNOWN)
            (§ block
                ;; Fall through.
            )
            (§ default )
            (§ block
                (§ ass confidenceType = ConfidenceType.UNKNOWN)
                (§ break )
            )
        )
        (§ call confidence.setConfidenceType(§ pars confidenceType))
        (§ if (§ expr confidenceProto.hasAppearedAtHeight(§ pars )))
        (§ block
            (§ if (§ expr confidence.getConfidenceType(§ pars ) != ConfidenceType.BUILDING))
            (§ block
                (§ call log.warn(§ pars "Have appearedAtHeight but not BUILDING for tx {}", tx.getHashAsString(§ pars )))
                (§ return )
            )
            (§ call confidence.setAppearedAtChainHeight(§ pars confidenceProto.getAppearedAtHeight(§ pars )))
        )

        (§ if (§ expr confidenceProto.hasDepth(§ pars )))
        (§ block
            (§ if (§ expr confidence.getConfidenceType(§ pars ) != ConfidenceType.BUILDING))
            (§ block
                (§ call log.warn(§ pars "Have depth but not BUILDING for tx {}", tx.getHashAsString(§ pars )))
                (§ return )
            )
            (§ call confidence.setDepthInBlocks(§ pars confidenceProto.getDepth(§ pars )))
        )

        (§ if (§ expr confidenceProto.hasOverridingTransaction(§ pars )))
        (§ block
            (§ if (§ expr confidence.getConfidenceType(§ pars ) != ConfidenceType.DEAD))
            (§ block
                (§ call log.warn(§ pars "Have overridingTransaction but not OVERRIDDEN for tx {}", tx.getHashAsString(§ pars )))
                (§ return )
            )
            (§ var Transaction overridingTransaction = txMap.get(§ pars confidenceProto.getOverridingTransaction(§ pars )))
            (§ if (§ expr overridingTransaction == nil))
            (§ block
                (§ call log.warn(§ pars "Have overridingTransaction that is not in wallet for tx {}", tx.getHashAsString(§ pars )))
                (§ return )
            )
            (§ call confidence.setOverridingTransaction(§ pars overridingTransaction))
        )

        (§ for (§ var Protos.PeerAddress proto) :for (§ expr confidenceProto.getBroadcastByList(§ pars )))
        (§ block
            (§ var InetAddress ip)
            (§ try )
            (§ block
                (§ ass ip = InetAddress.getByAddress(§ pars proto.getIpAddress(§ pars ).toByteArray(§ pars )))
            )
            (§ catch (§ args UnknownHostException e))
            (§ block
                (§ throw (§ new UnreadableWalletException(§ pars "Peer IP address does not have the right length", e)))
            )

            (§ var int port = proto.getPort(§ pars ))
            (§ var int protocolVersion = params.getProtocolVersionNum(§ pars NetworkParameters.ProtocolVersion.CURRENT))
            (§ var BigInteger services = BigInteger.valueOf(§ pars proto.getServices(§ pars )))
            (§ var PeerAddress address = new PeerAddress(§ pars params, ip, port, protocolVersion, services))
            (§ call confidence.markBroadcastBy(§ pars address))
        )

        (§ if (§ expr confidenceProto.hasLastBroadcastedAt(§ pars )))
        (§ block
            (§ call confidence.setLastBroadcastedAt(§ pars (§ new Date(§ pars confidenceProto.getLastBroadcastedAt(§ pars )))))
        )

        (§ switch (§ expr confidenceProto.getSource(§ pars )))
        (§ block
            (§ case SOURCE_SELF)
            (§ block
                (§ call confidence.setSource(§ pars TransactionConfidence.Source.SELF))
                (§ break )
            )
            (§ case SOURCE_NETWORK)
            (§ block
                (§ call confidence.setSource(§ pars TransactionConfidence.Source.NETWORK))
                (§ break )
            )
            (§ case SOURCE_UNKNOWN)
            (§ block
                ;; Fall through.
            )
            (§ default )
            (§ block
                (§ call confidence.setSource(§ pars TransactionConfidence.Source.UNKNOWN))
                (§ break )
            )
        )
    )

    ;;;
     ; Cheap test to see if input stream is a wallet.  This checks for a magic value at the beginning of the stream.
     ;
     ; @param is Input stream to test.
     ; @return true if input stream is a wallet.
     ;;
    #_public
    #_static
    (§ method boolean isWallet(§ args InputStream is))
    (§ block
        (§ try )
        (§ block
            #_final
            (§ var CodedInputStream cis = CodedInputStream.newInstance(§ pars is))
            #_final
            (§ var int tag = cis.readTag(§ pars ))
            #_final
            (§ var int field = WireFormat.getTagFieldNumber(§ pars tag))
            (§ if (§ expr field != 1)) ;; network_identifier
            (§ block
                (§ return false)
            )

            #_final
            (§ var String network = cis.readString(§ pars ))
            (§ return (§ expr NetworkParameters.fromID(§ pars network) != nil))
        )
        (§ catch (§ args IOException _))
        (§ block
            (§ return false)
        )
    )
)

#_(ns org.bitcoinj.wallet #_"WalletTransaction"
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.core Transaction]))

;;;
 ; Stores data about a transaction that is only relevant to the {@link org.bitcoinj.wallet.Wallet} class.
 ;;
#_public
(§ class WalletTransaction
    #_public
    (§ enum Pool
        (§ item UNSPENT) ;; unspent in best chain
        (§ item SPENT) ;; spent in best chain
        (§ item DEAD) ;; double-spend in alt chain
        (§ item PENDING) ;; a pending tx we would like to go into the best chain
    )
    #_private
    #_final
    (§ field Transaction transaction)
    #_private
    #_final
    (§ field Pool pool)

    #_public
    (§ constructor WalletTransaction(§ args Pool pool, Transaction transaction))
    (§ block
        (§ ass this.pool = Preconditions.checkNotNull(§ pars pool))
        (§ ass this.transaction = transaction)
    )

    #_public
    (§ method Transaction getTransaction(§ args ))
    (§ block
        (§ return transaction)
    )

    #_public
    (§ method Pool getPool(§ args ))
    (§ block
        (§ return pool)
    )
)

#_(ns org.bitcoinj.wallet.listeners #_"KeyChainEventListener"
    (:import [java.util List])
   (:require [org.bitcoinj.core ECKey]
             [org.bitcoinj.wallet KeyChain]))

#_public
(§ interface KeyChainEventListener
    ;;;
     ; Called whenever a new key is added to the key chain, whether that be via an explicit addition or due to some
     ; other automatic derivation.  See the documentation for your {@link KeyChain} implementation for details on
     ; what can trigger this event.
     ;;
    (§ method void onKeysAdded(§ args List<ECKey> keys))
)

#_(ns org.bitcoinj.wallet.listeners #_"WalletChangeEventListener"
   (:require [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when the contents of the wallet changes, for instance due to receiving/sending money
 ; or a block chain re-organize.</p>
 ;;
#_public
(§ interface WalletChangeEventListener
    ;;;
     ; <p>Designed for GUI applications to refresh their transaction lists.  This callback is invoked in the following
     ; situations:</p>
     ;
     ; <ol>
     ;     <li>A new block is received (and thus building transactions got more confidence).</li>
     ;     <li>A pending transaction is received.</li>
     ;     <li>A pending transaction changes confidence due to some non-new-block related event,
     ;     such as being announced by more peers or by  a double-spend conflict being observed.</li>
     ;     <li>A re-organize occurs. Call occurs only if the re-org modified any of our transactions.</li>
     ;     <li>A new spend is committed to the wallet.</li>
     ;     <li>The wallet is reset and all transactions removed.<li>
     ; </ol>
     ;
     ; <p>When this is called you can refresh the UI contents from the wallet contents.  It's more efficient to use
     ; this rather than onTransactionConfidenceChanged() + onReorganize() because you only get one callback per block
     ; rather than one per transaction per block.  Note that this is <b>not</b> called when a key is added.</p>
     ;;
    (§ method void onWalletChanged(§ args Wallet wallet))
)

#_(ns org.bitcoinj.wallet.listeners #_"WalletCoinsReceivedEventListener"
   (:require [org.bitcoinj.core Coin Transaction]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when the contents of the wallet changes, for instance due to receiving/sending money
 ; or a block chain re-organize.</p>
 ;;
#_public
(§ interface WalletCoinsReceivedEventListener
    ;;;
     ; This is called when a transaction is seen that sends coins <b>to</b> this wallet, either because it was
     ; broadcast across the network or because a block was received.  If a transaction is seen when it was broadcast,
     ; onCoinsReceived won't be called again when a block containing it is received.  If you want to know when such
     ; a transaction receives its first confirmation, register a {@link TransactionConfidence} event listener using
     ; the object retrieved via {@link org.bitcoinj.core.Transaction#getConfidence()}.  It's safe to modify the
     ; wallet in this callback, for example, by spending the transaction just received.
     ;
     ; @param wallet The wallet object that received the coins.
     ; @param tx The transaction which sent us the coins.
     ; @param prevBalance Balance before the coins were received.
     ; @param newBalance This is the 'estimated' balance.
     ;;
    (§ method void onCoinsReceived(§ args Wallet wallet, Transaction tx, Coin prevBalance, Coin newBalance))
)

#_(ns org.bitcoinj.wallet.listeners #_"WalletCoinsSentEventListener"
   (:require [org.bitcoinj.core Coin Transaction]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when the contents of the wallet changes, for instance due to receiving/sending money
 ; or a block chain re-organize.</p>
 ;;
#_public
(§ interface WalletCoinsSentEventListener
    ;;;
     ; This is called when a transaction is seen that sends coins <b>from</b> this wallet, either because it
     ; was broadcast across the network or because a block was received.  This may at first glance seem useless,
     ; because in the common case you already know about such transactions because you created them with the
     ; Wallets createSend/sendCoins methods.  However when you have a wallet containing only keys, and you wish
     ; to replay the block chain to fill it with transactions, it's useful to find out when a transaction is
     ; discovered that sends coins from the wallet.
     ;
     ; It's safe to modify the wallet from inside this callback, but if you're replaying the block chain you should
     ; be careful to avoid such modifications.  Otherwise your changes may be overridden by new data from the chain.
     ;
     ; @param wallet The wallet object that this callback relates to (that sent the coins).
     ; @param tx The transaction that sent the coins to someone else.
     ; @param prevBalance The wallets balance before this transaction was seen.
     ; @param newBalance The wallets balance after this transaction was seen.  This is the 'estimated' balance.
     ;;
    (§ method void onCoinsSent(§ args Wallet wallet, Transaction tx, Coin prevBalance, Coin newBalance))
)

#_(ns org.bitcoinj.wallet.listeners #_"WalletReorganizeEventListener"
   (:require [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when the wallet is reorganized.</p>
 ;;
#_public
(§ interface WalletReorganizeEventListener
    ;; TODO: Finish onReorganize to be more useful.
    ;;;
     ; <p>This is called when a block is received that triggers a block chain re-organization.</p>
     ;
     ; <p>A re-organize means that the consensus (chain) of the network has diverged and now changed from
     ; what we believed it was previously.  Usually this won't matter because the new consensus will include
     ; all our old transactions assuming we are playing by the rules.  However it's theoretically possible
     ; for our balance to change in arbitrary ways, most likely, we could lose some money we thought we had.</p>
     ;
     ; <p>It is safe to use methods of wallet whilst inside this callback.</p>
     ;;
    (§ method void onReorganize(§ args Wallet wallet))
)
