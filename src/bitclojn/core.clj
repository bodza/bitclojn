(ns bitclojn.core)

(defmacro ยง [& _])
(defmacro ร [& _])

(defmacro def- [s i] `(def ~(vary-meta s assoc :private true) ~i))

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & z] `(let [f# ~f x# ~x _# (any f# x# ~y)] (if _# _# (any f# x# ~@z)))))

(defn- ==?
    ([x y] (if (sequential? x) (if (seq x) (or (==? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (== x y))))
    ([x y & z] (==? x (cons y z))))

(defmacro when' [y & w]
    (let [[_ & w] (if (= '=> (first w)) (rest w) (cons nil w))]
        `(if ~y (do ~@w) ~_)))
(defmacro let-when [x y & w]
    (let [[_ & w] (if (= '=> (first w)) (rest w) (cons nil w))]
        `(let [~@x] (if ~y (do ~@w) ~_))))

(def- / quot)
(def- % rem)

(def- & bit-and)
(def- | bit-or)
(def- << bit-shift-left)
(def- >> bit-shift-right)
(def- >>> unsigned-bit-shift-right)

(defmacro != [x y] `(not (== ~x ~y)))

(defn -main [& args]
    )

#_(ns org.bitcoinj.core #_"AbstractBlockChain"
    (:import [java.util *]
             [java.util.concurrent *]
             [java.util.concurrent.locks *])
    (:import [com.google.common.base *]
             [com.google.common.collect *]
             [com.google.common.util.concurrent *]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core.listeners *]
             [org.bitcoinj.store *]
             [org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

#_(ns org.bitcoinj.core #_"Address"
    (:import [java.io IOException ObjectInputStream ObjectOutputStream])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.params Networks]
             [org.bitcoinj.script Script]))

#_(ns org.bitcoinj.core #_"AddressFormatException")

#_(ns org.bitcoinj.core #_"AddressMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Collections List]))

#_(ns org.bitcoinj.core #_"AlertMessage"
    (:import [java.util Date HashSet Set]))

#_(ns org.bitcoinj.core #_"Base58"
    (:import [java.math BigInteger]
             [java.util Arrays]))

#_(ns org.bitcoinj.core #_"BitcoinSerializer"
    (:import [java.io IOException OutputStream]
             [java.nio BufferUnderflowException ByteBuffer]
             [java.util HashMap Map])
    (:import [org.slf4j Logger LoggerFactory])
    (:import [org.bitcoinj.core Utils]))

#_(ns org.bitcoinj.core #_"Block"
    (:import [java.io *]
             [java.math *]
             [java.util *])
    (:import [com.google.common.annotations *]
             [com.google.common.base *]
             [com.google.common.collect *]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core Coin Sha256Hash]
             [org.bitcoinj.script *]))

#_(ns org.bitcoinj.core #_"BlockChain"
    (:import [java.util ArrayList List])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.store BlockStore BlockStoreException]
             [org.bitcoinj.wallet Wallet]))

#_(ns org.bitcoinj.core #_"BloomFilter"
    (:import [java.io IOException OutputStream]
             #_static [java.lang.Math *]
             [java.util ArrayList Arrays List])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.collect Lists])
   (:require [org.bitcoinj.script Script ScriptChunk]))

#_(ns org.bitcoinj.core #_"CheckpointManager"
    (:import [java.io BufferedInputStream BufferedReader DataInputStream IOException InputStream InputStreamReader]
             [java.nio ByteBuffer ByteOrder]
             [java.security DigestInputStream MessageDigest]
             [java.util Arrays Map TreeMap])
    (:import [com.google.common.base Charsets Preconditions]
             [com.google.common.hash HashCode Hasher Hashing]
             [com.google.common.io BaseEncoding]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.store BlockStore BlockStoreException FullPrunedBlockStore]))

#_(ns org.bitcoinj.core #_"ChildMessage")

#_(ns org.bitcoinj.core #_"Coin"
    (:import [java.io Serializable]
             [java.math BigDecimal])
    (:import [com.google.common.base Preconditions]
             [com.google.common.math LongMath]
             [com.google.common.primitives Longs])
   (:require [org.bitcoinj.utils MonetaryFormat]))

#_(ns org.bitcoinj.core #_"Context"
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory]))

#_(ns org.bitcoinj.core #_"ECKey"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.math BigInteger]
             [java.nio.charset Charset]
             [java.security SecureRandom SignatureException]
             [java.util Arrays Comparator])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base MoreObjects Objects Preconditions]
             [com.google.common.primitives Ints UnsignedBytes]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.asn1 *]
             [org.spongycastle.asn1.x9 X9ECParameters X9IntegerConverter]
             [org.spongycastle.crypto AsymmetricCipherKeyPair]
             [org.spongycastle.crypto.digests SHA256Digest]
             [org.spongycastle.crypto.ec CustomNamedCurves]
             [org.spongycastle.crypto.generators ECKeyPairGenerator]
             [org.spongycastle.crypto.params *]
             [org.spongycastle.crypto.signers ECDSASigner HMacDSAKCalculator]
             [org.spongycastle.math.ec ECAlgorithms ECPoint FixedPointCombMultiplier FixedPointUtil]
             [org.spongycastle.math.ec.custom.sec SecP256K1Curve]
             [org.spongycastle.util.encoders Base64])
   (:require [org.bitcoinj.crypto *]
             [org.bitcoinj.wallet Protos Wallet]))

#_(ns org.bitcoinj.core #_"EmptyMessage"
    (:import [java.io IOException OutputStream]))

#_(ns org.bitcoinj.core #_"FilteredBlock"
    (:import [java.io IOException OutputStream]
             [java.util *])
    (:import [com.google.common.base Objects]))

#_(ns org.bitcoinj.core #_"FullPrunedBlockChain"
    (:import [java.util ArrayList LinkedList List ListIterator Set]
             [java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.script Script]
             [org.bitcoinj.store BlockStoreException FullPrunedBlockStore]
             [org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

#_(ns org.bitcoinj.core #_"GetAddrMessage")

#_(ns org.bitcoinj.core #_"GetBlocksMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList List]))

#_(ns org.bitcoinj.core #_"GetDataMessage")

#_(ns org.bitcoinj.core #_"GetHeadersMessage"
    (:import [java.util List]))

#_(ns org.bitcoinj.core #_"HeadersMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Arrays List])
    (:import [org.slf4j Logger LoggerFactory]))

#_(ns org.bitcoinj.core #_"InsufficientMoneyException"
    (:import [com.google.common.base Preconditions]))

#_(ns org.bitcoinj.core #_"InventoryItem"
    (:import [com.google.common.base Objects]))

#_(ns org.bitcoinj.core #_"InventoryMessage"
    (:import [com.google.common.base Preconditions]))

#_(ns org.bitcoinj.core #_"ListMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Collections List]))

#_(ns org.bitcoinj.core #_"MemoryPoolMessage"
    (:import [java.io IOException OutputStream]))

#_(ns org.bitcoinj.core #_"Message"
    (:import [java.io *]
             [java.math BigInteger]
             [java.util Arrays])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory]))

#_(ns org.bitcoinj.core #_"MessageSerializer"
    (:import [java.io IOException OutputStream]
             [java.nio BufferUnderflowException ByteBuffer]))

#_(ns org.bitcoinj.core #_"Monetary"
    (:import [java.io Serializable]))

#_(ns org.bitcoinj.core #_"NetworkParameters"
    (:import [java.io *]
             [java.math *]
             [java.util *])
    (:import [com.google.common.base Objects])
   (:require [org.bitcoinj.core Block Coin StoredBlock VerificationException]
             [org.bitcoinj.net.discovery *]
             [org.bitcoinj.params *]
             [org.bitcoinj.script *]
             [org.bitcoinj.store BlockStore BlockStoreException]
             [org.bitcoinj.utils MonetaryFormat VersionTally]))

#_(ns org.bitcoinj.core #_"NotFoundMessage"
    (:import [java.util ArrayList List]))

#_(ns org.bitcoinj.core #_"PartialMerkleTree"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Arrays List])
    (:import [com.google.common.base Objects])
    (:import [org.bitcoinj.core Utils]))

#_(ns org.bitcoinj.core #_"Peer"
    (:import [java.util *]
             [java.util.concurrent CopyOnWriteArrayList CopyOnWriteArraySet Executor]
             [java.util.concurrent.atomic AtomicInteger]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.base * Objects]
             [com.google.common.collect Lists]
             [com.google.common.util.concurrent FutureCallback Futures ListenableFuture SettableFuture]
             [net.jcip.annotations GuardedBy]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core.listeners *]
             [org.bitcoinj.net StreamConnection]
             [org.bitcoinj.store BlockStore BlockStoreException]
             [org.bitcoinj.utils ListenerRegistration Threading]
             [org.bitcoinj.wallet Wallet]))

#_(ns org.bitcoinj.core #_"PeerAddress"
    (:import [java.io IOException OutputStream]
             [java.math BigInteger]
             [java.net InetAddress InetSocketAddress UnknownHostException])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.net InetAddresses])
    (:import [org.bitcoinj.core Utils]
             [org.bitcoinj.params MainNetParams]))

#_(ns org.bitcoinj.core #_"PeerException")

#_(ns org.bitcoinj.core #_"PeerFilterProvider")

#_(ns org.bitcoinj.core #_"PeerGroup"
    (:import [java.io *]
             [java.net *]
             [java.util *]
             [java.util.concurrent *]
             [java.util.concurrent.locks *])
    (:import [com.google.common.annotations *]
             [com.google.common.base *]
             [com.google.common.collect *]
             [com.google.common.net *]
             [com.google.common.primitives *]
             [com.google.common.util.concurrent *]
             [net.jcip.annotations *]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core.listeners *]
             [org.bitcoinj.net *]
             [org.bitcoinj.net.discovery *]
             [org.bitcoinj.script *]
             [org.bitcoinj.utils * Threading]
             [org.bitcoinj.wallet Wallet]
             [org.bitcoinj.wallet.listeners KeyChainEventListener WalletCoinsReceivedEventListener]))

#_(ns org.bitcoinj.core #_"PeerSocketHandler"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.net ConnectException InetSocketAddress]
             [java.nio BufferUnderflowException ByteBuffer]
             [java.nio.channels NotYetConnectedException]
             [java.util.concurrent.locks Lock])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.net AbstractTimeoutHandler MessageWriteTarget StreamConnection]
             [org.bitcoinj.utils Threading]))

#_(ns org.bitcoinj.core #_"Ping"
    (:import [java.io IOException OutputStream]))

#_(ns org.bitcoinj.core #_"Pong"
    (:import [java.io IOException OutputStream]))

#_(ns org.bitcoinj.core #_"ProtocolException")

#_(ns org.bitcoinj.core #_"PrunedException")

#_(ns org.bitcoinj.core #_"RejectMessage"
    (:import [java.io IOException OutputStream]
             [java.util Locale])
    (:import [com.google.common.base Objects]))

#_(ns org.bitcoinj.core #_"RejectedTransactionException")

#_(ns org.bitcoinj.core #_"ScriptException"
   (:require [org.bitcoinj.script ScriptError]))

#_(ns org.bitcoinj.core #_"Sha256Hash"
    (:import [java.io File FileInputStream IOException Serializable]
             [java.math BigInteger]
             [java.security MessageDigest NoSuchAlgorithmException]
             [java.util Arrays])
    (:import [com.google.common.base Preconditions]
             [com.google.common.io ByteStreams]
             [com.google.common.primitives *]))

#_(ns org.bitcoinj.core #_"StoredBlock"
    (:import [java.math BigInteger]
             [java.nio ByteBuffer]
             [java.util Locale])
    (:import [com.google.common.base Objects Preconditions])
   (:require [org.bitcoinj.store BlockStore BlockStoreException]))

#_(ns org.bitcoinj.core #_"StoredUndoableBlock"
    (:import [java.util List]))

#_(ns org.bitcoinj.core #_"Transaction"
    (:import [java.io *]
             [java.math BigInteger]
             [java.util *])
    (:import [com.google.common.base Preconditions Strings]
             [com.google.common.collect ImmutableMap]
             [com.google.common.primitives Ints Longs]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core TransactionConfidence Utils]
             [org.bitcoinj.crypto TransactionSignature]
             [org.bitcoinj.script Script ScriptBuilder ScriptError ScriptOpCodes]
             [org.bitcoinj.signers TransactionSigner]
             [org.bitcoinj.utils ExchangeRate]
             [org.bitcoinj.wallet Wallet WalletTransaction]))

#_(ns org.bitcoinj.core #_"TransactionBag"
    (:import [java.util Map])
   (:require [org.bitcoinj.script Script]
             [org.bitcoinj.wallet WalletTransaction]))

#_(ns org.bitcoinj.core #_"TransactionBroadcast"
    (:import [java.util *]
             [java.util.concurrent *])
    (:import [com.google.common.annotations *]
             [com.google.common.base *]
             [com.google.common.util.concurrent *]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core.listeners PreMessageReceivedEventListener]
             [org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

#_(ns org.bitcoinj.core #_"TransactionBroadcaster")

#_(ns org.bitcoinj.core #_"TransactionConfidence"
    (:import [java.util *]
             [java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect *]
             [com.google.common.util.concurrent *])
   (:require [org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

#_(ns org.bitcoinj.core #_"TransactionInput"
    (:import [java.io IOException OutputStream]
             [java.lang.ref WeakReference]
             [java.util Arrays Map])
    (:import [com.google.common.base Joiner Objects Preconditions])
   (:require [org.bitcoinj.script Script ScriptError]
             [org.bitcoinj.wallet DefaultRiskAnalysis KeyBag RedeemData]))

#_(ns org.bitcoinj.core #_"TransactionOutPoint"
    (:import [java.io *])
    (:import [com.google.common.base Objects Preconditions])
   (:require [org.bitcoinj.script *]
             [org.bitcoinj.wallet *]))

#_(ns org.bitcoinj.core #_"TransactionOutput"
    (:import [java.io *]
             [java.util *])
    (:import [com.google.common.base Objects Preconditions]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.script *]
             [org.bitcoinj.wallet Wallet]))

#_(ns org.bitcoinj.core #_"TransactionOutputChanges"
    (:import [java.io IOException InputStream OutputStream]
             [java.util LinkedList List]))

#_(ns org.bitcoinj.core #_"TxConfidenceTable"
    (:import [java.lang.ref *]
             [java.util *]
             [java.util.concurrent.locks *])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.utils *]))

#_(ns org.bitcoinj.core #_"UTXO"
    (:import [java.io *]
             [java.math *]
             [java.util Locale])
    (:import [com.google.common.base Objects])
   (:require [org.bitcoinj.script *]))

#_(ns org.bitcoinj.core #_"UnknownMessage")

#_(ns org.bitcoinj.core #_"Utils"
    (:import [java.io ByteArrayOutputStream IOException InputStream OutputStream UnsupportedEncodingException]
             [java.math BigInteger]
             [java.net URL]
             [java.text DateFormat SimpleDateFormat]
             [java.util *]
             [java.util.concurrent ArrayBlockingQueue BlockingQueue TimeUnit])
    (:import [com.google.common.base Charsets Joiner Preconditions]
             [com.google.common.collect Lists Ordering]
             [com.google.common.io BaseEncoding Resources]
             [com.google.common.primitives Ints UnsignedLongs]
             [com.google.common.util.concurrent Uninterruptibles]
             [org.spongycastle.crypto.digests RIPEMD160Digest]))

#_(ns org.bitcoinj.core #_"VarInt")

#_(ns org.bitcoinj.core #_"VerificationException")

#_(ns org.bitcoinj.core #_"VersionAck")

#_(ns org.bitcoinj.core #_"VersionMessage"
    (:import [java.io IOException OutputStream]
             [java.math BigInteger]
             [java.net InetAddress UnknownHostException]
             [java.util Locale])
    (:import [com.google.common.base Objects]
             [com.google.common.net InetAddresses]))

#_(ns org.bitcoinj.core #_"VersionedChecksummedBytes"
    (:import [java.io Serializable]
             [java.util Arrays])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.primitives Ints UnsignedBytes]))

#_(ns org.bitcoinj.core #_"WrongNetworkException"
    (:import [java.util Arrays]))

;;;
 ; <p>An AbstractBlockChain holds a series of {@link Block} objects, links them together, and knows how to verify that
 ; the chain follows the rules of the {@link NetworkParameters} for this chain.</p>
 ;
 ; <p>It can be connected to a {@link Wallet}, and also {@link TransactionReceivedInBlockListener}s that can receive
 ; transactions and notifications of re-organizations.</p>
 ;
 ; <p>An AbstractBlockChain implementation must be connected to a {@link BlockStore} implementation.  The chain object
 ; by itself doesn't store any data, that's delegated to the store.  Which store you use is a decision best made by
 ; reading the getting started guide, but briefly, fully validating block chains need fully validating stores.  In
 ; the lightweight SPV mode, a {@link org.bitcoinj.store.SPVBlockStore} is the right choice.</p>
 ;
 ; <p>This class implements an abstract class which makes it simple to create a BlockChain that does/doesn't do
 ; full verification.  It verifies headers and is implements most of what is required to implement SPV mode, but
 ; also provides callback hooks which can be used to do full verification.</p>
 ;
 ; <p>There are two subclasses of AbstractBlockChain that are useful: {@link BlockChain}, which is the simplest
 ; class and implements <i>simplified payment verification</i>.  This is a lightweight and efficient mode that
 ; does not verify the contents of blocks, just their headers.  A {@link FullPrunedBlockChain} paired with a
 ; {@link org.bitcoinj.store.H2FullPrunedBlockStore} implements full verification, which is equivalent to
 ; Bitcoin Core.  To learn more about the alternative security models, please consult the articles on the
 ; website.</p>
 ;
 ; <b>Theory</b>
 ;
 ; <p>The 'chain' is actually a tree although in normal operation it operates mostly as a list of {@link Block}s.
 ; When multiple new head blocks are found simultaneously, there are multiple stories of the economy competing to become
 ; the one true consensus.  This can happen naturally when two miners solve a block within a few seconds of each other,
 ; or it can happen when the chain is under attack.</p>
 ;
 ; <p>A reference to the head block of the best known chain is stored.  If you can reach the genesis block by repeatedly
 ; walking through the prevBlock pointers, then we say this is a full chain.  If you cannot reach the genesis block
 ; we say it is an orphan chain.  Orphan chains can occur when blocks are solved and received during the initial block
 ; chain download, or if we connect to a peer that doesn't send us blocks in order.</p>
 ;
 ; <p>A reorganize occurs when the blocks that make up the best known chain changes.  Note that simply adding a
 ; new block to the top of the best chain isn't as reorganize, but that a reorganize is always triggered by adding
 ; a new block that connects to some other (non best head) block.  By "best" we mean the chain representing the largest
 ; amount of work done.</p>
 ;
 ; <p>Every so often the block chain passes a difficulty transition point.  At that time, all the blocks in the last
 ; 2016 blocks are examined and a new difficulty target is calculated from them.</p>
 ;;
#_public
#_abstract
(ยง class AbstractBlockChain
    #_private
    #_static
    (ยง def- #_"Logger" AbstractBlockChain/log (LoggerFactory/getLogger AbstractBlockChain))

    #_protected
    (ยง field #_"ReentrantLock" :lock (Threading/lock "blockchain"))

    ;;; Keeps a map of block hashes to StoredBlocks. ;;
    #_private
    (ยง field- #_"BlockStore" :block-store)

    ;;;
     ; Tracks the top of the best known chain.
     ;
     ; Following this one down to the genesis block produces the story of the economy from the creation of Bitcoin
     ; until the present day.  The chain head can change if a new set of blocks is received that results in a chain of
     ; greater work than the one obtained by following this one down.  In that case a reorganize is triggered,
     ; potentially invalidating transactions in our wallet.
     ;;
    #_protected
    (ยง field #_"StoredBlock" :chain-head)

    ;; TODO: Scrap this and use a proper read/write for all of the block chain objects.
    ;; The chainHead field is read/written synchronized with this object rather than BlockChain.  However writing is
    ;; also guaranteed to happen whilst BlockChain is synchronized (see setChainHead).  The goal of this is to let
    ;; clients quickly access the chain head even whilst the block chain is downloading and thus the BlockChain is
    ;; locked most of the time.
    #_private
    (ยง field- #_"Object" :chain-head-lock (Object.))

    #_protected
    (ยง field #_"NetworkParameters" :params)
    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<NewBestBlockListener>>" :new-best-block-listeners)
    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<ReorganizeListener>>" :reorganize-listeners)
    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<TransactionReceivedInBlockListener>>" :transaction-received-listeners)

    ;; Holds a block header and, optionally, a list of tx hashes or block's transactions.
    (ยง class AbstractBlockChain.OrphanBlock
        (ยง field #_"Block" :block)
        (ยง field #_"List<Sha256Hash>" :filtered-tx-hashes)
        (ยง field #_"Map<Sha256Hash, Transaction>" :filtered-txn)

        (ยง constructor AbstractBlockChain.OrphanBlock [#_"Block" __block, #_nilable #_"List<Sha256Hash>" __filteredTxHashes, #_nilable #_"Map<Sha256Hash, Transaction>" __filteredTxn]
            (let [#_"boolean" __filtered (and (some? __filteredTxHashes) (some? __filteredTxn))]
                (Preconditions/checkArgument (or (and (nil? (:transactions __block)) __filtered) (and (some? (:transactions __block)) (not __filtered))))
                (ยง assoc this :block __block)
                (ยง assoc this :filtered-tx-hashes __filteredTxHashes)
                (ยง assoc this :filtered-txn __filteredTxn)
                this
            )
        )
    )
    ;; Holds blocks that we have received but can't plug into the chain yet, e.g. because they were created whilst we
    ;; were downloading the block chain.
    #_private
    (ยง field- #_"LinkedHashMap<Sha256Hash, AbstractBlockChain.OrphanBlock>" :orphan-blocks (LinkedHashMap. #_"<>"))

    ;;; False positive estimation uses a double exponential moving average. ;;
    #_public
    #_static
    (ยง def #_"double" AbstractBlockChain/FP_ESTIMATOR_ALPHA 0.0001)
    ;;; False positive estimation uses a double exponential moving average. ;;
    #_public
    #_static
    (ยง def #_"double" AbstractBlockChain/FP_ESTIMATOR_BETA 0.01)

    #_private
    (ยง field- #_"double" :false-positive-rate)
    #_private
    (ยง field- #_"double" :false-positive-trend)
    #_private
    (ยง field- #_"double" :previous-false-positive-rate)

    #_private
    (ยง field- #_"VersionTally" :version-tally)

    ;;; See {@link #AbstractBlockChain(Context, List, BlockStore)} ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor AbstractBlockChain [#_"NetworkParameters" __params, #_"List<? extends Wallet>" __transactionReceivedListeners, #_"BlockStore" __blockStore]
        (ยง this (Context/getOrCreate __params), __transactionReceivedListeners, __blockStore)
        this
    )

    ;;;
     ; Constructs a BlockChain connected to the given list of listeners (e.g. wallets) and a store.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor AbstractBlockChain [#_"Context" __context, #_"List<? extends Wallet>" __wallets, #_"BlockStore" __blockStore]
        (ยง assoc this :block-store __blockStore)
        (ยง assoc this :chain-head (.. __blockStore (getChainHead)))
        (.. AbstractBlockChain/log (info "chain head is at height {}:\n{}", (.. (:chain-head this) (getHeight)), (.. (:chain-head this) (getHeader))))
        (ยง assoc this :params (.. __context (getParams)))

        (ยง assoc this :new-best-block-listeners (CopyOnWriteArrayList. #_"<>"))
        (ยง assoc this :reorganize-listeners (CopyOnWriteArrayList. #_"<>"))
        (ยง assoc this :transaction-received-listeners (CopyOnWriteArrayList. #_"<>"))
        (doseq [#_"NewBestBlockListener" __l __wallets]
            (.. this (addNewBestBlockListener Threading/SAME_THREAD, __l))
        )
        (doseq [#_"ReorganizeListener" __l __wallets]
            (.. this (addReorganizeListener Threading/SAME_THREAD, __l))
        )
        (doseq [#_"TransactionReceivedInBlockListener" __l __wallets]
            (.. this (addTransactionReceivedListener Threading/SAME_THREAD, __l))
        )

        (ยง assoc this :version-tally (VersionTally. (.. __context (getParams))))
        (.. (:version-tally this) (initialize __blockStore, (:chain-head this)))
        this
    )

    ;;;
     ; Add a wallet to the BlockChain.  Note that the wallet will be unaffected by any blocks received while it
     ; was not part of this BlockChain.  This method is useful if the wallet has just been created, and its keys
     ; have never been in use, or if the wallet has been loaded along with the BlockChain.  Note that adding
     ; multiple wallets is not well tested!
     ;;
    #_public
    (ยง method #_"void" addWallet [#_"Wallet" __wallet]
        (.. this (addNewBestBlockListener Threading/SAME_THREAD, __wallet))
        (.. this (addReorganizeListener Threading/SAME_THREAD, __wallet))
        (.. this (addTransactionReceivedListener Threading/SAME_THREAD, __wallet))

        (let [#_"int" __walletHeight (.. __wallet (getLastBlockSeenHeight))
              #_"int" __chainHeight (.. this (getBestChainHeight))]
            (when (!= __walletHeight __chainHeight)
                (.. AbstractBlockChain/log (warn "Wallet/chain height mismatch: {} vs {}", __walletHeight, __chainHeight))
                (.. AbstractBlockChain/log (warn "Hashes: {} vs {}", (.. __wallet (getLastBlockSeenHash)), (.. this (getChainHead) (getHeader) (getHash))))

                ;; This special case happens when the VM crashes because of a transaction received.  It causes the updated
                ;; block store to persist, but not the wallet.  In order to fix the issue, we roll back the block store to
                ;; the wallet height to make it look like as if the block has never been received.
                (when (< 0 __walletHeight __chainHeight)
                    (try
                        (.. this (rollbackBlockStore __walletHeight))
                        (.. AbstractBlockChain/log (info "Rolled back block store to height {}.", __walletHeight))
                        (catch BlockStoreException _
                            (.. AbstractBlockChain/log (warn "Rollback of block store failed, continuing with mismatched heights. This can happen due to a replay."))
                        )
                    )
                )
            )
            nil
        )
    )

    ;;; Removes a wallet from the chain. ;;
    #_public
    (ยง method #_"void" removeWallet [#_"Wallet" __wallet]
        (.. this (removeNewBestBlockListener __wallet))
        (.. this (removeReorganizeListener __wallet))
        (.. this (removeTransactionReceivedListener __wallet))
        nil
    )

    ;;; Replaced with more specific listener methods: use them instead. ;;
    #_deprecated
    #_suppress #_[ "deprecation" ]
    #_public
    (ยง method #_"void" addListener [#_"BlockChainListener" __listener]
        (.. this (addListener __listener, Threading/USER_THREAD))
        nil
    )

    ;;; Replaced with more specific listener methods: use them instead. ;;
    #_deprecated
    #_public
    (ยง method #_"void" addListener [#_"BlockChainListener" __listener, #_"Executor" __executor]
        (.. this (addReorganizeListener __executor, __listener))
        (.. this (addNewBestBlockListener __executor, __listener))
        (.. this (addTransactionReceivedListener __executor, __listener))
        nil
    )

    #_deprecated
    #_public
    (ยง method #_"void" removeListener [#_"BlockChainListener" __listener]
        (.. this (removeReorganizeListener __listener))
        (.. this (removeNewBestBlockListener __listener))
        (.. this (removeTransactionReceivedListener __listener))
        nil
    )

    ;;;
     ; Adds a {@link NewBestBlockListener} listener to the chain.
     ;;
    #_public
    (ยง method #_"void" addNewBestBlockListener [#_"NewBestBlockListener" __listener]
        (.. this (addNewBestBlockListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;;
     ; Adds a {@link NewBestBlockListener} listener to the chain.
     ;;
    #_public
    (ยง method #_"void" addNewBestBlockListener [#_"Executor" __executor, #_"NewBestBlockListener" __listener]
        (.. (:new-best-block-listeners this) (add (ListenerRegistration. #_"<>" __listener, __executor)))
        nil
    )

    ;;;
     ; Adds a generic {@link ReorganizeListener} listener to the chain.
     ;;
    #_public
    (ยง method #_"void" addReorganizeListener [#_"ReorganizeListener" __listener]
        (.. this (addReorganizeListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;;
     ; Adds a generic {@link ReorganizeListener} listener to the chain.
     ;;
    #_public
    (ยง method #_"void" addReorganizeListener [#_"Executor" __executor, #_"ReorganizeListener" __listener]
        (.. (:reorganize-listeners this) (add (ListenerRegistration. #_"<>" __listener, __executor)))
        nil
    )

    ;;;
     ; Adds a generic {@link TransactionReceivedInBlockListener} listener to the chain.
     ;;
    #_public
    (ยง method #_"void" addTransactionReceivedListener [#_"TransactionReceivedInBlockListener" __listener]
        (.. this (addTransactionReceivedListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;;
     ; Adds a generic {@link TransactionReceivedInBlockListener} listener to the chain.
     ;;
    #_public
    (ยง method #_"void" addTransactionReceivedListener [#_"Executor" __executor, #_"TransactionReceivedInBlockListener" __listener]
        (.. (:transaction-received-listeners this) (add (ListenerRegistration. #_"<>" __listener, __executor)))
        nil
    )

    ;;;
     ; Removes the given {@link NewBestBlockListener} from the chain.
     ;;
    #_public
    (ยง method #_"void" removeNewBestBlockListener [#_"NewBestBlockListener" __listener]
        (ListenerRegistration/removeFromList __listener, (:new-best-block-listeners this))
        nil
    )

    ;;;
     ; Removes the given {@link ReorganizeListener} from the chain.
     ;;
    #_public
    (ยง method #_"void" removeReorganizeListener [#_"ReorganizeListener" __listener]
        (ListenerRegistration/removeFromList __listener, (:reorganize-listeners this))
        nil
    )

    ;;;
     ; Removes the given {@link TransactionReceivedInBlockListener} from the chain.
     ;;
    #_public
    (ยง method #_"void" removeTransactionReceivedListener [#_"TransactionReceivedInBlockListener" __listener]
        (ListenerRegistration/removeFromList __listener, (:transaction-received-listeners this))
        nil
    )

    ;;;
     ; Returns the {@link BlockStore} the chain was constructed with.  You can use this to iterate over the chain.
     ;;
    #_public
    (ยง method #_"BlockStore" getBlockStore []
        (:block-store this)
    )

    ;;;
     ; Adds/updates the given {@link Block} with the block store.
     ; This version is used when the transactions have not been verified.
     ; @param storedPrev The {@link StoredBlock} which immediately precedes block.
     ; @param block The {@link Block} to add/update.
     ; @return the newly created {@link StoredBlock}
     ;;
    #_protected
    #_abstract
    #_throws #_[ "BlockStoreException", "VerificationException" ]
    (ยง method #_"StoredBlock" addToBlockStore [#_"StoredBlock" __storedPrev, #_"Block" __block])

    ;;;
     ; Adds/updates the given {@link StoredBlock} with the block store.
     ; This version is used when the transactions have already been verified to properly spend txOutputChanges.
     ; @param storedPrev The {@link StoredBlock} which immediately precedes block.
     ; @param header The {@link StoredBlock} to add/update.
     ; @param txOutputChanges The total sum of all changes made by this block to the set of open transaction outputs
     ;                        (from a call to connectTransactions), if in fully verifying mode (null otherwise).
     ; @return the newly created {@link StoredBlock}
     ;;
    #_protected
    #_abstract
    #_throws #_[ "BlockStoreException", "VerificationException" ]
    (ยง method #_"StoredBlock" addToBlockStore [#_"StoredBlock" __storedPrev, #_"Block" __header, #_nilable #_"TransactionOutputChanges" __txOutputChanges])

    ;;;
     ; Rollback the block store to a given height.  This is currently only supported by {@link BlockChain} instances.
     ;
     ; @throws BlockStoreException
     ;             if the operation fails or is unsupported.
     ;;
    #_protected
    #_abstract
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" rollbackBlockStore [#_"int" __height])

    ;;;
     ; Called before setting chain head in memory.
     ; Should write the new head to block store and then commit any database transactions
     ; that were started by disconnectTransactions/connectTransactions.
     ;;
    #_protected
    #_abstract
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" doSetChainHead [#_"StoredBlock" __chainHead])

    ;;;
     ; Called if we (possibly) previously called disconnectTransaction/connectTransactions,
     ; but will not be calling preSetChainHead as a block failed verification.
     ; Can be used to abort database transactions that were started by
     ; disconnectTransactions/connectTransactions.
     ;;
    #_protected
    #_abstract
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" notSettingChainHead [])

    ;;;
     ; For a standard BlockChain, this should return blockStore.get(hash),
     ; for a FullPrunedBlockChain blockStore.getOnceUndoableStoredBlock(hash)
     ;;
    #_protected
    #_abstract
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" getStoredBlockInCurrentScope [#_"Sha256Hash" __hash])

    ;;;
     ; Processes a received block and tries to add it to the chain.  If there's something wrong with the block an
     ; exception is thrown.  If the block is OK but cannot be connected to the chain at this time, returns false.
     ; If the block can be connected to the chain, returns true.
     ; Accessing block's transactions in another thread while this method runs may result in undefined behavior.
     ;;
    #_public
    #_throws #_[ "VerificationException", "PrunedException" ]
    (ยง method #_"boolean" add [#_"Block" __block]
        (try
            (ยง return (.. this (add __block, true, nil, nil)))
            (catch BlockStoreException __e
                ;; TODO: Figure out a better way to propagate this exception to the user.
                (throw (RuntimeException. __e))
            )
            (catch VerificationException __e
                (try
                    (.. this (notSettingChainHead))
                    (catch BlockStoreException __e1
                        (throw (RuntimeException. __e1))
                    )
                )
                (throw (VerificationException. (str "Could not verify block:\n" __block), __e))
            )
        )
    )

    ;;;
     ; Processes a received block and tries to add it to the chain.  If there's something wrong with the block an
     ; exception is thrown.  If the block is OK but cannot be connected to the chain at this time, returns false.
     ; If the block can be connected to the chain, returns true.
     ;;
    #_public
    #_throws #_[ "VerificationException", "PrunedException" ]
    (ยง method #_"boolean" add [#_"FilteredBlock" __block]
        (try
            ;; The block has a list of hashes of transactions that matched the Bloom filter, and a list of associated
            ;; Transaction objects.  There may be fewer Transaction objects than hashes, this is expected.  It can happen
            ;; in the case where we were already around to witness the initial broadcast, so we downloaded the
            ;; transaction and sent it to the wallet before this point (the wallet may have thrown it away if it was
            ;; a false positive, as expected in any Bloom filtering scheme).  The filteredTxn list here will usually
            ;; only be full of data when we are catching up to the head of the chain and thus haven't witnessed any
            ;; of the transactions.
            (ยง return (.. this (add (.. __block (getBlockHeader)), true, (.. __block (getTransactionHashes)), (.. __block (getAssociatedTransactions)))))
            (catch BlockStoreException __e
                ;; TODO: Figure out a better way to propagate this exception to the user.
                (throw (RuntimeException. __e))
            )
            (catch VerificationException __e
                (try
                    (.. this (notSettingChainHead))
                    (catch BlockStoreException __e1
                        (throw (RuntimeException. __e1))
                    )
                )
                (throw (VerificationException. (str "Could not verify block " (.. __block (getHash)) "\n" __block), __e))
            )
        )
    )

    ;;;
     ; Whether or not we are maintaining a set of unspent outputs and are verifying all transactions.
     ; Also indicates that all calls to add() should provide a block containing transactions
     ;;
    #_protected
    #_abstract
    (ยง method #_"boolean" shouldVerifyTransactions [])

    ;;;
     ; Connect each transaction in block.transactions, verifying them as we go and removing spent outputs
     ; If an error is encountered in a transaction, no changes should be made to the underlying BlockStore
     ; and a VerificationException should be thrown.
     ; Only called if shouldVerifyTransactions().
     ; @throws VerificationException if an attempt was made to spend an already-spent output, or if a transaction incorrectly solved an output script.
     ; @throws BlockStoreException if the block store had an underlying error.
     ; @return The full set of all changes made to the set of open transaction outputs.
     ;;
    #_protected
    #_abstract
    #_throws #_[ "VerificationException", "BlockStoreException" ]
    (ยง method #_"TransactionOutputChanges" connectTransactions [#_"int" __height, #_"Block" __block])

    ;;;
     ; Load newBlock from BlockStore and connect its transactions, returning changes to the set of unspent transactions.
     ; If an error is encountered in a transaction, no changes should be made to the underlying BlockStore.
     ; Only called if shouldVerifyTransactions().
     ; @throws PrunedException if newBlock does not exist as a {@link StoredUndoableBlock} in the block store.
     ; @throws VerificationException if an attempt was made to spend an already-spent output, or if a transaction incorrectly solved an output script.
     ; @throws BlockStoreException if the block store had an underlying error or newBlock does not exist in the block store at all.
     ; @return The full set of all changes made to the set of open transaction outputs.
     ;;
    #_protected
    #_abstract
    #_throws #_[ "VerificationException", "BlockStoreException", "PrunedException" ]
    (ยง method #_"TransactionOutputChanges" connectTransactions [#_"StoredBlock" __newBlock])

    ;; filteredTxHashList contains all transactions, filteredTxn just a subset
    #_private
    #_throws #_[ "BlockStoreException", "VerificationException", "PrunedException" ]
    (ยง method- #_"boolean" add [#_"Block" __block, #_"boolean" __tryConnecting, #_nilable #_"List<Sha256Hash>" __filteredTxHashList, #_nilable #_"Map<Sha256Hash, Transaction>" __filteredTxn]
        ;; TODO: Use read/write locks to ensure that during chain download properties are still low latency.
        (.. (:lock this) (lock))
        (try
            ;; Quick check for duplicates to avoid an expensive check further down (in findSplit).
            ;; This can happen a lot when connecting orphan transactions due to the dumb brute force algorithm we use.
            (when (.. __block (equals (.. this (getChainHead) (getHeader))))
                (ยง return true)
            )
            (when (and __tryConnecting (.. (:orphan-blocks this) (containsKey (.. __block (getHash)))))
                (ยง return false)
            )

            ;; If we want to verify transactions (i.e. we are running with full blocks), verify that block has transactions.
            (when (and (.. this (shouldVerifyTransactions)) (nil? (:transactions __block)))
                (throw (VerificationException. "Got a block header while running in full-block mode"))
            )

            ;; Check for already-seen block, but only for full pruned mode, where the DB is
            ;; more likely able to handle these queries quickly.
            (when (and (.. this (shouldVerifyTransactions)) (some? (.. (:block-store this) (get (.. __block (getHash))))))
                (ยง return true)
            )

            (let [#_"StoredBlock" __storedPrev
                  #_"int" __height
                  #_"EnumSet<Block.VerifyFlag>" __flags]

                ;; Prove the block is internally valid: hash is lower than target, etc.  This only checks the block contents
                ;; if there is a tx sending or receiving coins using an address in one of our wallets.  And those transactions
                ;; are only lightly verified: presence in a valid connecting block is taken as proof of validity.  See the
                ;; article here for more details: https://bitcoinj.github.io/security-model
                (try
                    (.. __block (verifyHeader))
                    (ยง ass __storedPrev (.. this (getStoredBlockInCurrentScope (.. __block (getPrevBlockHash)))))
                    (if (some? __storedPrev)
                        (ยง ass __height (inc (.. __storedPrev (getHeight))))
                        (ยง ass __height Block/BLOCK_HEIGHT_UNKNOWN)
                    )
                    (ยง ass __flags (.. (:params this) (getBlockVerificationFlags __block, (:version-tally this), __height)))
                    (when (.. this (shouldVerifyTransactions))
                        (.. __block (verifyTransactions __height, __flags))
                    )
                    (catch VerificationException __e
                        (.. AbstractBlockChain/log (error "Failed to verify block: ", __e))
                        (.. AbstractBlockChain/log (error (.. __block (getHashAsString))))
                        (throw __e)
                    )
                )

                ;; Try linking it to a place in the currently known blocks.

                (when (nil? __storedPrev)
                    ;; We can't find the previous block.  Probably we are still in the process of downloading the chain and
                    ;; a block was solved whilst we were doing it.  We put it to one side and try to connect it later when we
                    ;; have more blocks.
                    (Preconditions/checkState __tryConnecting, "bug in tryConnectingOrphans")
                    (.. AbstractBlockChain/log (warn "Block does not connect: {} prev {}", (.. __block (getHashAsString)), (.. __block (getPrevBlockHash))))
                    (.. (:orphan-blocks this) (put (.. __block (getHash)), (AbstractBlockChain.OrphanBlock. __block, __filteredTxHashList, __filteredTxn)))
                    (ยง return false)
                )

                (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))
                ;; It connects to somewhere on the chain.  Not necessarily the top of the best known chain.
                (.. (:params this) (checkDifficultyTransitions __storedPrev, __block, (:block-store this)))
                (.. this (connectBlock __block, __storedPrev, (.. this (shouldVerifyTransactions)), __filteredTxHashList, __filteredTxn))

                (when __tryConnecting
                    (.. this (tryConnectingOrphans))
                )

                (ยง return true)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns the hashes of the currently stored orphan blocks and then deletes them from this objects storage.
     ; Used by Peer when a filter exhaustion event has occurred and thus any orphan blocks that have been downloaded
     ; might be inaccurate/incomplete.
     ;;
    #_public
    (ยง method #_"Set<Sha256Hash>" drainOrphanBlocks []
        (.. (:lock this) (lock))
        (try
            (let [#_"Set<Sha256Hash>" __hashes (HashSet. #_"<>" (.. (:orphan-blocks this) (keySet)))]
                (.. (:orphan-blocks this) (clear))
                (ยง return __hashes)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;; expensiveChecks enables checks that require looking at blocks further back in the chain
    ;; than the previous one when connecting (e.g. median timestamp check)
    ;; It could be exposed, but for now we just set it to shouldVerifyTransactions()
    #_private
    #_throws #_[ "BlockStoreException", "VerificationException", "PrunedException" ]
    (ยง method- #_"void" connectBlock [#_"Block" __block, #_"StoredBlock" __storedPrev, #_"boolean" __expensiveChecks, #_nilable #_"List<Sha256Hash>" __filteredTxHashList, #_nilable #_"Map<Sha256Hash, Transaction>" __filteredTxn]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))
        (let [#_"boolean" __filtered (and (some? __filteredTxHashList) (some? __filteredTxn))]
            ;; Check that we aren't connecting a block that fails a checkpoint check.
            (when (not (.. (:params this) (passesCheckpoint (inc (.. __storedPrev (getHeight))), (.. __block (getHash)))))
                (throw (VerificationException. (str "Block failed checkpoint lockin at " (inc (.. __storedPrev (getHeight))))))
            )
            (when (.. this (shouldVerifyTransactions))
                (Preconditions/checkNotNull (:transactions __block))
                (doseq [#_"Transaction" __tx (:transactions __block)]
                    (when (not (.. __tx (isFinal (inc (.. __storedPrev (getHeight))), (.. __block (getTimeSeconds)))))
                        (throw (VerificationException. "Block contains non-final transaction"))
                    )
                )
            )

            (let [#_"StoredBlock" __head (.. this (getChainHead))]
                (cond (.. __storedPrev (equals __head))
                    (do
                        (when (and __filtered (< 0 (.. __filteredTxn (size))))
                            (.. AbstractBlockChain/log (debug "Block {} connects to top of best chain with {} transaction(s) of which we were sent {}", (.. __block (getHashAsString)), (.. __filteredTxHashList (size)), (.. __filteredTxn (size))))
                            (doseq [#_"Sha256Hash" __hash __filteredTxHashList]
                                (.. AbstractBlockChain/log (debug "  matched tx {}", __hash))
                            )
                        )
                        (when (and __expensiveChecks (<= (.. __block (getTimeSeconds)) (AbstractBlockChain/getMedianTimestampOfRecentBlocks __head, (:block-store this))))
                            (throw (VerificationException. "Block's timestamp is too early"))
                        )

                        ;; BIP 66 & 65: Enforce block version 3/4 once they are a supermajority of blocks.
                        ;; NOTE: This requires 1,000 blocks since the last checkpoint (on main net, less on test) in order to be applied.
                        ;; It is also limited to stopping addition of new v2/3 blocks to the tip of the chain.
                        (when (any == (.. __block (getVersion)) Block/BLOCK_VERSION_BIP34 Block/BLOCK_VERSION_BIP66)
                            (let [#_"Integer" __count (.. (:version-tally this) (getCountAtOrAbove (inc (.. __block (getVersion)))))]
                                (when (and (some? __count) (<= (.. (:params this) (getMajorityRejectBlockOutdated)) __count))
                                    (throw (VerificationException.BlockVersionOutOfDate. (.. __block (getVersion))))
                                )
                            )
                        )

                        ;; This block connects to the best known block, it is a normal continuation of the system.
                        (let [#_"TransactionOutputChanges" __txOutChanges nil]
                            (when (.. this (shouldVerifyTransactions))
                                (ยง ass __txOutChanges (.. this (connectTransactions (inc (.. __storedPrev (getHeight))), __block)))
                            )
                            (let [#_"StoredBlock" __newStoredBlock (.. this (addToBlockStore __storedPrev, (if (nil? (:transactions __block)) __block (.. __block (cloneAsHeader))), __txOutChanges))]
                                (.. (:version-tally this) (add (.. __block (getVersion))))
                                (.. this (setChainHead __newStoredBlock))
                                (.. AbstractBlockChain/log (debug "Chain is now {} blocks high, running listeners", (.. __newStoredBlock (getHeight))))
                                (.. this (informListenersForNewBlock __block, AbstractBlockChain.NewBlockType/BEST_CHAIN, __filteredTxHashList, __filteredTxn, __newStoredBlock))
                            )
                        )
                    )
                    :else
                    (do
                        ;; This block connects to somewhere other than the top of the best known chain.  We treat these differently.
                        ;;
                        ;; Note that we send the transactions to the wallet FIRST, even if we're about to re-organize this block
                        ;; to become the new best chain head.  This simplifies handling of the re-org in the Wallet class.
                        (let [#_"StoredBlock" __newBlock (.. __storedPrev (build __block))
                              #_"boolean" __haveNewBestChain (.. __newBlock (moreWorkThan __head))]
                            (cond __haveNewBestChain
                                (do
                                    (.. AbstractBlockChain/log (info "Block is causing a re-organize"))
                                )
                                :else
                                (do
                                    (let [#_"StoredBlock" __splitPoint (AbstractBlockChain/findSplit __newBlock, __head, (:block-store this))]
                                        (when (and (some? __splitPoint) (.. __splitPoint (equals __newBlock)))
                                            ;; newStoredBlock is a part of the same chain, there's no fork.  This happens when we receive a block
                                            ;; that we already saw and linked into the chain previously, which isn't the chain head.
                                            ;; Re-processing it is confusing for the wallet so just skip.
                                            (.. AbstractBlockChain/log (warn "Saw duplicated block in main chain at height {}: {}", (.. __newBlock (getHeight)), (.. __newBlock (getHeader) (getHash))))
                                            (ยง return nil)
                                        )

                                        (cond (nil? __splitPoint)
                                            (do
                                                ;; This should absolutely never happen.
                                                ;; (lets not write the full block to disk to keep any bugs which allow this to happen from writing unreasonable amounts of data to disk)
                                                (throw (VerificationException. "Block forks the chain but splitPoint is nil"))
                                            )
                                            :else
                                            (do
                                                ;; We aren't actually spending any transactions (yet) because we are on a fork.
                                                (.. this (addToBlockStore __storedPrev, __block))
                                                (let [#_"int" __splitPointHeight (.. __splitPoint (getHeight))
                                                      #_"String" __splitPointHash (.. __splitPoint (getHeader) (getHashAsString))]
                                                    (.. AbstractBlockChain/log (info "Block forks the chain at height {}/block {}, but it did not cause a reorganize:\n{}", __splitPointHeight, __splitPointHash, (.. __newBlock (getHeader) (getHashAsString))))
                                                )
                                            )
                                        )
                                    )
                                )
                            )

                            ;; We may not have any transactions if we received only a header, which can happen during fast catchup.
                            ;; If we do, send them to the wallet but state that they are on a side chain so it knows not to try and
                            ;; spend them until they become activated.
                            (when (or (some? (:transactions __block)) __filtered)
                                (.. this (informListenersForNewBlock __block, AbstractBlockChain.NewBlockType/SIDE_CHAIN, __filteredTxHashList, __filteredTxn, __newBlock))
                            )

                            (when __haveNewBestChain
                                (.. this (handleNewBestChain __storedPrev, __newBlock, __block, __expensiveChecks))
                            )
                        )
                    )
                )
                nil
            )
        )
    )

    #_private
    #_throws #_[ "VerificationException" ]
    (ยง method- #_"void" informListenersForNewBlock [#_"Block" __block, #_"AbstractBlockChain.NewBlockType" __newBlockType, #_nilable #_"List<Sha256Hash>" __filteredTxHashList, #_nilable #_"Map<Sha256Hash, Transaction>" __filteredTxn, #_"StoredBlock" __newStoredBlock]
        ;; Notify the listeners of the new block, so the depth and workDone of stored transactions can be updated
        ;; (in the case of the listener being a wallet).  Wallets need to know how deep each transaction is, so
        ;; coinbases aren't used before maturity.
        (let [#_"boolean" __first true
              #_"Set<Sha256Hash>" __falsePositives (Sets/newHashSet)]
            (when (some? __filteredTxHashList)
                (.. __falsePositives (addAll __filteredTxHashList))
            )

            (doseq [#_"ListenerRegistration<TransactionReceivedInBlockListener>" __registration (:transaction-received-listeners this)]
                (cond (== (:executor __registration) Threading/SAME_THREAD)
                    (do
                        (AbstractBlockChain/informListenerForNewTransactions __block, __newBlockType, __filteredTxHashList, __filteredTxn, __newStoredBlock, __first, (:listener __registration), __falsePositives)
                    )
                    :else
                    (do
                        ;; Listener wants to be run on some other thread, so marshal it across here.
                        (let [#_"boolean" __notFirst (not __first)]
                            (.. (:executor __registration) (execute (Runnable.)
                            (ยง anon
                                #_override
                                #_public
                                (ยง method #_"void" run []
                                    (try
                                        ;; We can't do false-positive handling when executing on another thread.
                                        (let [#_"Set<Sha256Hash>" __ignoredFalsePositives (Sets/newHashSet)]
                                            (AbstractBlockChain/informListenerForNewTransactions __block, __newBlockType, __filteredTxHashList, __filteredTxn, __newStoredBlock, __notFirst, (:listener __registration), __ignoredFalsePositives)
                                        )
                                        (catch VerificationException __e
                                            (.. AbstractBlockChain/log (error "Block chain listener threw exception: ", __e))
                                            ;; Don't attempt to relay this back to the original peer thread if this was an async listener invocation.
                                            ;; TODO: Make exception reporting a global feature and use it here.
                                        )
                                    )
                                    nil
                                )
                            )))
                        )
                    )
                )
                (ยง ass __first false)
            )

            (doseq [#_"ListenerRegistration<NewBestBlockListener>" __registration (:new-best-block-listeners this)]
                (cond (== (:executor __registration) Threading/SAME_THREAD)
                    (do
                        (when (== __newBlockType AbstractBlockChain.NewBlockType/BEST_CHAIN)
                            (.. (:listener __registration) (notifyNewBestBlock __newStoredBlock))
                        )
                    )
                    :else
                    (do
                        ;; Listener wants to be run on some other thread, so marshal it across here.
                        (.. (:executor __registration) (execute (Runnable.)
                        (ยง anon
                            #_override
                            #_public
                            (ยง method #_"void" run []
                                (try
                                    (when (== __newBlockType AbstractBlockChain.NewBlockType/BEST_CHAIN)
                                        (.. (:listener __registration) (notifyNewBestBlock __newStoredBlock))
                                    )
                                    (catch VerificationException __e
                                        (.. AbstractBlockChain/log (error "Block chain listener threw exception: ", __e))
                                        ;; Don't attempt to relay this back to the original peer thread if this was an async listener invocation.
                                        ;; TODO: Make exception reporting a global feature and use it here.
                                    )
                                )
                                nil
                            )
                        )))
                    )
                )
                (ยง ass __first false)
            )

            (.. this (trackFalsePositives (.. __falsePositives (size))))
            nil
        )
    )

    #_private
    #_static
    #_throws #_[ "VerificationException" ]
    (ยง defn- #_"void" AbstractBlockChain/informListenerForNewTransactions [#_"Block" __block, #_"AbstractBlockChain.NewBlockType" __newBlockType, #_nilable #_"List<Sha256Hash>" __filteredTxHashList, #_nilable #_"Map<Sha256Hash, Transaction>" __filteredTxn, #_"StoredBlock" __newStoredBlock, #_"boolean" __first, #_"TransactionReceivedInBlockListener" __listener, #_"Set<Sha256Hash>" __falsePositives]
        (cond (some? (:transactions __block))
            (do
                ;; If this is not the first wallet, ask for the transactions to be duplicated before being given
                ;; to the wallet when relevant.  This ensures that if we have two connected wallets and a tx that
                ;; is relevant to both of them, they don't end up accidentally sharing the same object (which can
                ;; result in temporary in-memory corruption during re-orgs).  See bug 257.  We only duplicate in
                ;; the case of multiple wallets to avoid an unnecessary efficiency hit in the common case.
                (AbstractBlockChain/sendTransactionsToListener __newStoredBlock, __newBlockType, __listener, 0, (:transactions __block), (not __first), __falsePositives)
            )
            (some? __filteredTxHashList)
            (do
                (Preconditions/checkNotNull __filteredTxn)
                ;; We must send transactions to listeners in the order they appeared in the block - thus we iterate over the
                ;; set of hashes and call sendTransactionsToListener with individual txn when they have not already been
                ;; seen in loose broadcasts - otherwise notifyTransactionIsInBlock on the hash.
                (let [#_"int" __relativityOffset 0]
                    (doseq [#_"Sha256Hash" __hash __filteredTxHashList]
                        (let [#_"Transaction" __tx (.. __filteredTxn (get __hash))]
                            (cond (some? __tx)
                                (do
                                    (AbstractBlockChain/sendTransactionsToListener __newStoredBlock, __newBlockType, __listener, __relativityOffset, (Collections/singletonList __tx), (not __first), __falsePositives)
                                )
                                (.. __listener (notifyTransactionIsInBlock __hash, __newStoredBlock, __newBlockType, __relativityOffset))
                                (do
                                    (.. __falsePositives (remove __hash))
                                )
                            )
                            (ยง ass __relativityOffset (inc __relativityOffset))
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Gets the median timestamp of the last 11 blocks.
     ;;
    #_private
    #_static
    #_throws #_[ "BlockStoreException" ]
    (ยง defn- #_"long" AbstractBlockChain/getMedianTimestampOfRecentBlocks [#_"StoredBlock" __storedBlock, #_"BlockStore" __store]
        (let [#_"long[]" __timestamps (long-array 11)
              #_"int" __unused 9]
            (aset __timestamps 10 (.. __storedBlock (getHeader) (getTimeSeconds)))
            (loop-when-recur [] (and (<= 0 __unused) (some? (ยง ass __storedBlock (.. __storedBlock (getPrev __store))))) [(ยง ass __unused (dec __unused))]
                (aset __timestamps __unused (.. __storedBlock (getHeader) (getTimeSeconds)))
            )

            (Arrays/sort __timestamps, (inc __unused), 11)
            (aget __timestamps (+ __unused (/ (- 11 __unused) 2)))
        )
    )

    ;;;
     ; Disconnect each transaction in the block (after reading it from the block store).
     ; Only called if shouldVerifyTransactions().
     ; @throws PrunedException if block does not exist as a {@link StoredUndoableBlock} in the block store.
     ; @throws BlockStoreException if the block store had an underlying error or block does not exist in the block store at all.
     ;;
    #_protected
    #_abstract
    #_throws #_[ "PrunedException", "BlockStoreException" ]
    (ยง method #_"void" disconnectTransactions [#_"StoredBlock" __block])

    ;;;
     ; Called as part of connecting a block when the new block results in a different chain having higher total work.
     ;
     ; if (shouldVerifyTransactions)
     ;     either newChainHead needs to be in the block store as a FullStoredBlock, or (block != null && block.transactions != null)
     ;;
    #_private
    #_throws #_[ "BlockStoreException", "VerificationException", "PrunedException" ]
    (ยง method- #_"void" handleNewBestChain [#_"StoredBlock" __storedPrev, #_"StoredBlock" __newChainHead, #_"Block" __block, #_"boolean" __expensiveChecks]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))

        ;; This chain has overtaken the one we currently believe is best.  Reorganize is required.
        ;;
        ;; Firstly, calculate the block at which the chain diverged.  We only need to examine the
        ;; chain from beyond this block to find differences.

        (let [#_"StoredBlock" __head (.. this (getChainHead))
              #_"StoredBlock" __splitPoint (AbstractBlockChain/findSplit __newChainHead, __head, (:block-store this))]
            (.. AbstractBlockChain/log (info "Re-organize after split at height {}", (.. __splitPoint (getHeight))))
            (.. AbstractBlockChain/log (info "Old chain head: {}", (.. __head (getHeader) (getHashAsString))))
            (.. AbstractBlockChain/log (info "New chain head: {}", (.. __newChainHead (getHeader) (getHashAsString))))
            (.. AbstractBlockChain/log (info "Split at block: {}", (.. __splitPoint (getHeader) (getHashAsString))))

            ;; Then build a list of all blocks in the old part of the chain and the new part.
            (let [#_"LinkedList<StoredBlock>" __oldBlocks (AbstractBlockChain/getPartialChain __head, __splitPoint, (:block-store this))
                  #_"LinkedList<StoredBlock>" __newBlocks (AbstractBlockChain/getPartialChain __newChainHead, __splitPoint, (:block-store this))]

                ;; Disconnect each transaction in the previous main chain that is no longer in the new main chain.
                (let [#_"StoredBlock" __storedNewHead __splitPoint]
                    (cond (.. this (shouldVerifyTransactions))
                        (do
                            (doseq [#_"StoredBlock" __oldBlock __oldBlocks]
                                (try
                                    (.. this (disconnectTransactions __oldBlock))
                                    (catch PrunedException __e
                                        ;; We threw away the data we need to re-org this deep!  We need to go back to a peer with full
                                        ;; block contents and ask them for the relevant data then rebuild the indexs.  Or we could just
                                        ;; give up and ask the human operator to help get us unstuck (e.g. rescan from the genesis block).
                                        ;; TODO: retry adding this block when we get a block with hash e.getHash()
                                        (throw __e)
                                    )
                                )
                            )

                            (let [#_"StoredBlock" __cursor]
                                ;; Walk in ascending chronological order.
                                (loop-when-recur [#_"Iterator<StoredBlock>" __it (.. __newBlocks (descendingIterator))] (.. __it (hasNext)) []
                                    (ยง ass __cursor (.. __it (next)))
                                    (let [#_"Block" __cursorBlock (.. __cursor (getHeader))]
                                        (when (and __expensiveChecks (<= (.. __cursorBlock (getTimeSeconds)) (AbstractBlockChain/getMedianTimestampOfRecentBlocks (.. __cursor (getPrev (:block-store this))), (:block-store this))))
                                            (throw (VerificationException. "Block's timestamp is too early during reorg"))
                                        )
                                        (let [#_"TransactionOutputChanges" __txOutChanges]
                                            (if (or (!= __cursor __newChainHead) (nil? __block))
                                                (ยง ass __txOutChanges (.. this (connectTransactions __cursor)))
                                                (ยง ass __txOutChanges (.. this (connectTransactions (.. __newChainHead (getHeight)), __block)))
                                            )
                                            (ยง ass __storedNewHead (.. this (addToBlockStore __storedNewHead, (.. __cursorBlock (cloneAsHeader)), __txOutChanges)))
                                        )
                                    )
                                )
                            )
                        )
                        :else
                        (do
                            ;; (Finally) write block to block store.
                            (ยง ass __storedNewHead (.. this (addToBlockStore __storedPrev, (.. __newChainHead (getHeader)))))
                        )
                    )

                    ;; Now inform the listeners.  This is necessary so the set of currently active transactions (that we can spend)
                    ;; can be updated to take into account the re-organize.  We might also have received new coins we didn't have
                    ;; before and our previous spends might have been undone.
                    (doseq [#_"ListenerRegistration<ReorganizeListener>" __registration (:reorganize-listeners this)]
                        (cond (== (:executor __registration) Threading/SAME_THREAD)
                            (do
                                ;; Short circuit the executor so we can propagate any exceptions.
                                ;; TODO: Do we really need to do this or should it be irrelevant?
                                (.. (:listener __registration) (reorganize __splitPoint, __oldBlocks, __newBlocks))
                            )
                            :else
                            (do
                                (.. (:executor __registration) (execute (Runnable.)
                                (ยง anon
                                    #_override
                                    #_public
                                    (ยง method #_"void" run []
                                        (try
                                            (.. (:listener __registration) (reorganize __splitPoint, __oldBlocks, __newBlocks))
                                            (catch VerificationException __e
                                                (.. AbstractBlockChain/log (error "Block chain listener threw exception during reorg", __e))
                                            )
                                        )
                                        nil
                                    )
                                )))
                            )
                        )
                    )

                    ;; Update the pointer to the best known block.
                    (.. this (setChainHead __storedNewHead))
                    nil
                )
            )
        )
    )

    ;;;
     ; Returns the set of contiguous blocks between 'higher' and 'lower'.  Higher is included, lower is not.
     ;;
    #_private
    #_static
    #_throws #_[ "BlockStoreException" ]
    (ยง defn- #_"LinkedList<StoredBlock>" AbstractBlockChain/getPartialChain [#_"StoredBlock" __higher, #_"StoredBlock" __lower, #_"BlockStore" __store]
        (Preconditions/checkArgument (< (.. __lower (getHeight)) (.. __higher (getHeight))), "higher and lower are reversed")
        (let [#_"LinkedList<StoredBlock>" __results (LinkedList. #_"<>")
              #_"StoredBlock" __cursor __higher]
            (loop []
                (.. __results (add __cursor))
                (ยง ass __cursor (Preconditions/checkNotNull (.. __cursor (getPrev __store)), "Ran off the end of the chain"))
                (when (.. __cursor (equals __lower))
                    (ยง break )
                )
            )
            __results
        )
    )

    ;;;
     ; Locates the point in the chain at which newStoredBlock and chainHead diverge.  Returns null if no split point was
     ; found (i.e. they are not part of the same chain).  Returns newChainHead or chainHead if they don't actually diverge
     ; but are part of the same chain.
     ;;
    #_private
    #_static
    #_throws #_[ "BlockStoreException" ]
    (ยง defn- #_"StoredBlock" AbstractBlockChain/findSplit [#_"StoredBlock" __newChainHead, #_"StoredBlock" __oldChainHead, #_"BlockStore" __store]
        (let [#_"StoredBlock" __currentChainCursor __oldChainHead
              #_"StoredBlock" __newChainCursor __newChainHead]
            ;; Loop until we find the block both chains have in common.  Example:
            ;;
            ;;    A -> B -> C -> D
            ;;         \--> E -> F -> G
            ;;
            ;; findSplit will return block B.  oldChainHead = D and newChainHead = G.
            (while (not (.. __currentChainCursor (equals __newChainCursor)))
                (cond (< (.. __newChainCursor (getHeight)) (.. __currentChainCursor (getHeight)))
                    (do
                        (ยง ass __currentChainCursor (.. __currentChainCursor (getPrev __store)))
                        (Preconditions/checkNotNull __currentChainCursor, "Attempt to follow an orphan chain")
                    )
                    :else
                    (do
                        (ยง ass __newChainCursor (.. __newChainCursor (getPrev __store)))
                        (Preconditions/checkNotNull __newChainCursor, "Attempt to follow an orphan chain")
                    )
                )
            )
            __currentChainCursor
        )
    )

    ;;;
     ; @return the height of the best known chain, convenience for <tt>getChainHead().getHeight()</tt>
     ;;
    #_public
    (ยง method #_"int" getBestChainHeight []
        (.. this (getChainHead) (getHeight))
    )

    #_public
    (ยง enum AbstractBlockChain.NewBlockType
        (ยง item BEST_CHAIN)
        (ยง item SIDE_CHAIN)
    )

    #_private
    #_static
    #_throws #_[ "VerificationException" ]
    (ยง defn- #_"void" AbstractBlockChain/sendTransactionsToListener [#_"StoredBlock" __block, #_"AbstractBlockChain.NewBlockType" __blockType, #_"TransactionReceivedInBlockListener" __listener, #_"int" __relativityOffset, #_"List<Transaction>" __transactions, #_"boolean" __clone, #_"Set<Sha256Hash>" __falsePositives]
        (doseq [#_"Transaction" __tx __transactions]
            (try
                (.. __falsePositives (remove (.. __tx (getHash))))
                (when __clone
                    (ยง ass __tx (.. (:params __tx) (getDefaultSerializer) (makeTransaction (.. __tx (bitcoinSerialize)))))
                )
                (.. __listener (receiveFromBlock __tx, __block, __blockType, __relativityOffset))
                (ยง ass __relativityOffset (inc __relativityOffset))
                (catch ScriptException __e
                    ;; We don't want scripts we don't understand to break the block chain so just note that this tx was
                    ;; not scanned here and continue.
                    (.. AbstractBlockChain/log (warn (str "Failed to parse a script: " __e)))
                )
                (catch ProtocolException __e
                    ;; Failed to duplicate tx, should never happen.
                    (throw (RuntimeException. __e))
                )
            )
        )
        nil
    )

    #_protected
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" setChainHead [#_"StoredBlock" __chainHead]
        (.. this (doSetChainHead __chainHead))
        (ยง sync (:chain-head-lock this)
            (ยง assoc this :chain-head __chainHead)
        )
        nil
    )

    ;;;
     ; For each block in orphanBlocks, see if we can now fit it on top of the chain and if so, do so.
     ;;
    #_private
    #_throws #_[ "VerificationException", "BlockStoreException", "PrunedException" ]
    (ยง method- #_"void" tryConnectingOrphans []
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))

        ;; For each block in our orphan list, try and fit it onto the head of the chain.  If we succeed remove it
        ;; from the list and keep going.  If we changed the head of the list at the end of the round try again until
        ;; we can't fit anything else on the top.
        ;;
        ;; This algorithm is kind of crappy, we should do a topo-sort then just connect them in order, but for small
        ;; numbers of orphan blocks it does OK.

        (let [#_"int" __blocksConnectedThisRound]
            (ยง repeat
                (ยง ass __blocksConnectedThisRound 0)
                (let [#_"Iterator<AbstractBlockChain.OrphanBlock>" __iter (.. (:orphan-blocks this) (values) (iterator))]
                    (while (.. __iter (hasNext))
                        (let [#_"AbstractBlockChain.OrphanBlock" __orphanBlock (.. __iter (next))]
                            ;; Look up the blocks previous.
                            (let [#_"StoredBlock" __prev (.. this (getStoredBlockInCurrentScope (.. (:block __orphanBlock) (getPrevBlockHash))))]
                                (when (nil? __prev)
                                    ;; This is still an unconnected/orphan block.
                                    (.. AbstractBlockChain/log (debug "Orphan block {} is not connectable right now", (.. (:block __orphanBlock) (getHash))))
                                    (ยง continue )
                                )
                                ;; Otherwise we can connect it now.
                                ;; False here ensures we don't recurse infinitely downwards when connecting huge chains.
                                (.. AbstractBlockChain/log (info "Connected orphan {}", (.. (:block __orphanBlock) (getHash))))
                                (.. this (add (:block __orphanBlock), false, (:filtered-tx-hashes __orphanBlock), (:filtered-txn __orphanBlock)))
                                (.. __iter (remove))
                                (ยง ass __blocksConnectedThisRound (inc __blocksConnectedThisRound))
                            )
                        )
                    )
                    (when (< 0 __blocksConnectedThisRound)
                        (.. AbstractBlockChain/log (info "Connected {} orphan blocks.", __blocksConnectedThisRound))
                    )
                )
                (ยง again (< 0 __blocksConnectedThisRound))
            )
            nil
        )
    )

    ;;;
     ; Returns the block at the head of the current best chain.  This is the block which represents the greatest
     ; amount of cumulative work done.
     ;;
    #_public
    (ยง method #_"StoredBlock" getChainHead []
        (ยง sync (:chain-head-lock this)
            (ยง return (:chain-head this))
        )
    )

    ;;;
     ; An orphan block is one that does not connect to the chain anywhere (i.e. we can't find its parent, therefore
     ; it's an orphan).  Typically this occurs when we are downloading the chain and didn't reach the head yet, and/or
     ; if a block is solved whilst we are downloading.  It's possible that we see a small amount of orphan blocks which
     ; chain together, this method tries walking backwards through the known orphan blocks to find the bottom-most.
     ;
     ; @return from or one of from's parents, or null if "from" does not identify an orphan block
     ;;
    #_nilable
    #_public
    (ยง method #_"Block" getOrphanRoot [#_"Sha256Hash" __from]
        (.. (:lock this) (lock))
        (try
            (let [#_"AbstractBlockChain.OrphanBlock" __cursor (.. (:orphan-blocks this) (get __from))]
                (when (nil? __cursor)
                    (ยง return nil)
                )
                (let [#_"AbstractBlockChain.OrphanBlock" __tmp]
                    (while (some? (ยง ass __tmp (.. (:orphan-blocks this) (get (.. (:block __cursor) (getPrevBlockHash))))))
                        (ยง ass __cursor __tmp)
                    )
                    (ยง return (:block __cursor))
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;; Returns true if the given block is currently in the orphan blocks list. ;;
    #_public
    (ยง method #_"boolean" isOrphan [#_"Sha256Hash" __block]
        (.. (:lock this) (lock))
        (try
            (.. (:orphan-blocks this) (containsKey __block))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns an estimate of when the given block will be reached, assuming a perfect 10 minute average for each
     ; block.  This is useful for turning transaction lock times into human readable times.  Note that a height in
     ; the past will still be estimated, even though the time of solving is actually known (we won't scan backwards
     ; through the chain to obtain the right answer).
     ;;
    #_public
    (ยง method #_"Date" estimateBlockTime [#_"int" __height]
        (ยง sync (:chain-head-lock this)
            (let [#_"long" __offset (- __height (.. (:chain-head this) (getHeight)))
                  #_"long" __headTime (.. (:chain-head this) (getHeader) (getTimeSeconds))
                  #_"long" __estimated (+ (* __headTime 1000) (* 1000 60 10 __offset))]
                (ยง return (Date. __estimated))
            )
        )
    )

    ;;;
     ; Returns a future that completes when the block chain has reached the given height.  Yields the
     ; {@link StoredBlock} of the block that reaches that height first.  The future completes on a peer thread.
     ;;
    #_public
    (ยง method #_"ListenableFuture<StoredBlock>" getHeightFuture [#_"int" __height]
        (let [#_"SettableFuture<StoredBlock>" __result (SettableFuture/create)]
            (.. this (addNewBestBlockListener Threading/SAME_THREAD, (NewBestBlockListener.)
            (ยง anon
                #_override
                #_public
                #_throws #_[ "VerificationException" ]
                (ยง method #_"void" notifyNewBestBlock [#_"StoredBlock" __block]
                    (when (<= __height (.. __block (getHeight)))
                        (.. this (removeNewBestBlockListener this))
                        (.. __result (set __block))
                    )
                    nil
                )
            )))
            __result
        )
    )

    ;;;
     ; The false positive rate is the average over all blockchain transactions of:
     ;
     ; - 1.0 if the transaction was false-positive (was irrelevant to all listeners)
     ; - 0.0 if the transaction was relevant or filtered out
     ;;
    #_public
    (ยง method #_"double" getFalsePositiveRate []
        (:false-positive-rate this)
    )

    ;;
     ; We completed handling of a filtered block.  Update false-positive estimate based
     ; on the total number of transactions in the original block.
     ;
     ; count includes filtered transactions, transactions that were passed in and were relevant
     ; and transactions that were false positives (i.e. includes all transactions in the block).
     ;;
    #_protected
    (ยง method #_"void" trackFilteredTransactions [#_"int" __count]
        ;; Track non-false-positives in batch.  Each non-false-positive counts as 0.0 towards the estimate.
        ;;
        ;; This is slightly off because we are applying false positive tracking before non-FP tracking,
        ;; which counts FP as if they came at the beginning of the block.  Assuming uniform FP
        ;; spread in a block, this will somewhat underestimate the FP rate (5% for 1000 tx block).
        (let [#_"double" __alphaDecay (Math/pow (- 1 AbstractBlockChain/FP_ESTIMATOR_ALPHA), __count)]

            ;; new_rate = alpha_decay * new_rate
            (ยง assoc this :false-positive-rate (* __alphaDecay (:false-positive-rate this)))

            (let [#_"double" __betaDecay (Math/pow (- 1 AbstractBlockChain/FP_ESTIMATOR_BETA), __count)]

                ;; trend = beta * (new_rate - old_rate) + beta_decay * trend
                (ยง assoc this :false-positive-trend (+ (* AbstractBlockChain/FP_ESTIMATOR_BETA __count (- (:false-positive-rate this) (:previous-false-positive-rate this))) (* __betaDecay (:false-positive-trend this))))

                ;; new_rate += alpha_decay * trend
                (ยง assoc this :false-positive-rate (+ (:false-positive-rate this) (* __alphaDecay (:false-positive-trend this))))

                ;; stash new_rate in old_rate
                (ยง assoc this :previous-false-positive-rate (:false-positive-rate this))
                nil
            )
        )
    )

    ;;; Irrelevant transactions were received.  Update false-positive estimate. ;;
    (ยง method #_"void" trackFalsePositives [#_"int" __count]
        ;; Track false positives in batch by adding alpha to the false positive estimate once per count.
        ;; Each false positive counts as 1.0 towards the estimate.
        (ยง assoc this :false-positive-rate (+ (:false-positive-rate this) (* AbstractBlockChain/FP_ESTIMATOR_ALPHA __count)))
        (when (< 0 __count)
            (.. AbstractBlockChain/log (debug "{} false positives, current rate = {} trend = {}", __count, (:false-positive-rate this), (:false-positive-trend this)))
        )
        nil
    )

    ;;; Resets estimates of false positives.  Used when the filter is sent to the peer. ;;
    #_public
    (ยง method #_"void" resetFalsePositiveEstimate []
        (ยง assoc this :false-positive-rate 0)
        (ยง assoc this :false-positive-trend 0)
        (ยง assoc this :previous-false-positive-rate 0)
        nil
    )

    #_protected
    (ยง method #_"VersionTally" getVersionTally []
        (:version-tally this)
    )
)

;;;
 ; <p>A Bitcoin address looks like 1MsScoe2fTJoq4ZPdQgqyhgWeoNamYPevy and is derived from an elliptic curve public key
 ; plus a set of network parameters.  Not to be confused with a {@link PeerAddress} or {@link AddressMessage}
 ; which are about network (TCP) addresses.</p>
 ;
 ; <p>A standard address is built by taking the RIPE-MD160 hash of the public key bytes, with a version prefix and a
 ; checksum suffix, then encoding it textually as base58.  The version prefix is used to both denote the network for
 ; which the address is valid (see {@link NetworkParameters}, and also to indicate how the bytes inside the address
 ; should be interpreted.  Whilst almost all addresses today are hashes of public keys, another (currently unsupported
 ; type) can contain a hash of a script instead.</p>
 ;;
#_public
(ยง class Address (ยง extends VersionedChecksummedBytes)
    ;;;
     ; An address is a RIPEMD160 hash of a public key, therefore is always 160 bits or 20 bytes.
     ;;
    #_public
    #_static
    (ยง def #_"int" Address/LENGTH 20)

    #_private
    #_transient
    (ยง field- #_"NetworkParameters" :params)

    ;;;
     ; Construct an address from parameters, the address version, and the hash160 form.  Example:
     ;
     ; <pre>new Address(MainNetParams.get(), NetworkParameters.getAddressHeader(), Hex.decode("4a22c3c4cbb31e4d03b15550636762bda0baf85a"));</pre>
     ;;
    #_public
    #_throws #_[ "WrongNetworkException" ]
    (ยง constructor Address [#_"NetworkParameters" __params, #_"int" __version, #_"byte[]" __hash160]
        (ยง super __version, __hash160)

        (Preconditions/checkNotNull __params)
        (Preconditions/checkArgument (== (.. __hash160 (alength)) 20), "Addresses are 160-bit hashes, so you must provide 20 bytes")
        (when (not (Address/isAcceptableVersion __params, __version))
            (throw (WrongNetworkException. __version, (.. __params (getAcceptableAddressCodes))))
        )
        (ยง assoc this :params __params)
        this
    )

    ;;; Returns an Address that represents the given P2SH script hash. ;;
    #_public
    #_static
    (ยง defn #_"Address" Address/fromP2SHHash [#_"NetworkParameters" __params, #_"byte[]" __hash160]
        (try
            (ยง return (Address. __params, (.. __params (getP2SHHeader)), __hash160))
            (catch WrongNetworkException __e
                (throw (RuntimeException. __e)) ;; Cannot happen.
            )
        )
    )

    ;;; Returns an Address that represents the script hash extracted from the given scriptPubKey. ;;
    #_public
    #_static
    (ยง defn #_"Address" Address/fromP2SHScript [#_"NetworkParameters" __params, #_"Script" __scriptPubKey]
        (Preconditions/checkArgument (.. __scriptPubKey (isPayToScriptHash)), "Not a P2SH script")
        (Address/fromP2SHHash __params, (.. __scriptPubKey (getPubKeyHash)))
    )

    ;;;
     ; Construct an address from its Base58 representation.
     ; @param params
     ;            The expected NetworkParameters or null if you don't want validation.
     ; @param base58
     ;            The textual form of the address, such as "17kzeh4N8g49GFvdDzSf8PjaPfyoD1MndL".
     ; @throws AddressFormatException
     ;             if the given base58 doesn't parse or the checksum is invalid
     ; @throws WrongNetworkException
     ;             if the given address is valid but for a different chain (e.g. testnet vs. mainnet)
     ;;
    #_public
    #_static
    #_throws #_[ "AddressFormatException" ]
    (ยง defn #_"Address" Address/fromBase58 [#_nilable #_"NetworkParameters" __params, #_"String" __base58]
        (Address. __params, __base58)
    )

    ;;;
     ; Construct an address from parameters and the hash160 form.  Example:
     ;
     ; <pre>new Address(MainNetParams.get(), Hex.decode("4a22c3c4cbb31e4d03b15550636762bda0baf85a"));</pre>
     ;;
    #_public
    (ยง constructor Address [#_"NetworkParameters" __params, #_"byte[]" __hash160]
        (ยง super (.. __params (getAddressHeader)), __hash160)

        (Preconditions/checkArgument (== (.. __hash160 (alength)) 20), "Addresses are 160-bit hashes, so you must provide 20 bytes")
        (ยง assoc this :params __params)
        this
    )

    ;;; @deprecated Use {@link #fromBase58(NetworkParameters, String)} ;;
    #_deprecated
    #_public
    #_throws #_[ "AddressFormatException" ]
    (ยง constructor Address [#_nilable #_"NetworkParameters" __params, #_"String" __address]
        (ยง super __address)

        (cond (some? __params)
            (do
                (when (not (Address/isAcceptableVersion __params, (:version this)))
                    (throw (WrongNetworkException. (:version this), (.. __params (getAcceptableAddressCodes))))
                )
                (ยง assoc this :params __params)
            )
            :else
            (do
                (let [#_"NetworkParameters" __paramsFound nil]
                    (doseq [#_"NetworkParameters" __p (Networks/get)]
                        (when (Address/isAcceptableVersion __p, (:version this))
                            (ยง ass __paramsFound __p)
                            (ยง break )
                        )
                    )
                    (when (nil? __paramsFound)
                        (throw (AddressFormatException. (str "No network found for " __address)))
                    )

                    (ยง assoc this :params __paramsFound)
                )
            )
        )
        this
    )

    ;;; The (big endian) 20 byte hash that is the core of a Bitcoin address. ;;
    #_public
    (ยง method #_"byte[]" getHash160 []
        (:bytes this)
    )

    ;;;
     ; Returns true if this address is a Pay-To-Script-Hash (P2SH) address.
     ; See also https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki: Address Format for pay-to-script-hash
     ;;
    #_public
    (ยง method #_"boolean" isP2SHAddress []
        (let [#_"NetworkParameters" __parameters (.. this (getParameters))]
            (and (some? __parameters) (== (:version this) (:p2sh-header __parameters)))
        )
    )

    ;;;
     ; Examines the version byte of the address and attempts to find a matching NetworkParameters.  If you aren't sure
     ; which network the address is intended for (e.g. it was provided by a user), you can use this to decide if it is
     ; compatible with the current wallet.  You should be able to handle a null response from this method.  Note that
     ; the parameters returned is not necessarily the same as the one the Address was created with.
     ;
     ; @return a NetworkParameters representing the network the address is intended for
     ;;
    #_public
    (ยง method #_"NetworkParameters" getParameters []
        (:params this)
    )

    ;;;
     ; Given an address, examines the version byte and attempts to find a matching NetworkParameters.  If you aren't sure
     ; which network the address is intended for (e.g. it was provided by a user), you can use this to decide if it is
     ; compatible with the current wallet.
     ; @return a NetworkParameters of the address
     ; @throws AddressFormatException if the string wasn't of a known version
     ;;
    #_public
    #_static
    #_throws #_[ "AddressFormatException" ]
    (ยง defn #_"NetworkParameters" Address/getParametersFromAddress [#_"String" __address]
        (try
            (ยง return (.. (Address/fromBase58 nil, __address) (getParameters)))
            (catch WrongNetworkException __e
                (throw (RuntimeException. __e)) ;; Cannot happen.
            )
        )
    )

    ;;;
     ; Check if a given address version is valid given the NetworkParameters.
     ;;
    #_private
    #_static
    (ยง defn- #_"boolean" Address/isAcceptableVersion [#_"NetworkParameters" __params, #_"int" __version]
        (doseq [#_"int" __v (.. __params (getAcceptableAddressCodes))]
            (when (== __version __v)
                (ยง return true)
            )
        )
        false
    )

    ;;;
     ; This implementation narrows the return type to <code>Address</code>.
     ;;
    #_override
    #_public
    #_throws #_[ "CloneNotSupportedException" ]
    (ยง method #_"Address" clone []
        (cast Address (.. super (clone)))
    )

    ;; Java serialization

    #_private
    #_throws #_[ "IOException" ]
    (ยง method- #_"void" writeObject [#_"ObjectOutputStream" __out]
        (.. __out (defaultWriteObject))
        (.. __out (writeUTF (-> this :params :id)))
        nil
    )

    #_private
    #_throws #_[ "IOException", "ClassNotFoundException" ]
    (ยง method- #_"void" readObject [#_"ObjectInputStream" __in]
        (.. __in (defaultReadObject))
        (ยง assoc this :params (NetworkParameters/fromID (.. __in (readUTF))))
        nil
    )
)

#_public
(ยง class AddressFormatException (ยง extends IllegalArgumentException)
    #_public
    (ยง constructor AddressFormatException []
        (ยง super )
        this
    )

    #_public
    (ยง constructor AddressFormatException [#_"String" __message]
        (ยง super __message)
        this
    )
)

;;;
 ; <p>Represents an "addr" message on the P2P network, which contains broadcast IP addresses of other peers.  This is
 ; one of the ways peers can find each other without using the DNS or IRC discovery mechanisms.  However storing and
 ; using addr messages is not presently implemented.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class AddressMessage (ยง extends Message)
    #_private
    #_static
    (ยง def- #_"long" AddressMessage/MAX_ADDRESSES 1024)

    #_private
    (ยง field- #_"List<PeerAddress>" :addresses)

    ;;;
     ; Contruct a new 'addr' message.
     ; @param params NetworkParameters object.
     ; @param offset The location of the first payload byte within the array.
     ; @param parseRetain Whether to retain the backing byte array for quick reserialization.
     ; If true and the backing byte array is invalidated due to modification of a field, then
     ; the cached bytes may be repopulated and retained if the message is serialized again in the future.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_throws #_[ "ProtocolException" ]
    (ยง constructor AddressMessage [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"int" __offset, #_"MessageSerializer" __setSerializer, #_"int" __length]
        (ยง super __params, __payload, __offset, __setSerializer, __length)
        this
    )

    ;;;
     ; Contruct a new 'addr' message.
     ; @param params NetworkParameters object.
     ; @param serializer The serializer to use for this block.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_throws #_[ "ProtocolException" ]
    (ยง constructor AddressMessage [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"MessageSerializer" __serializer, #_"int" __length]
        (ยง super __params, __payload, 0, __serializer, __length)
        this
    )

    #_throws #_[ "ProtocolException" ]
    (ยง constructor AddressMessage [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"int" __offset]
        (ยง super __params, __payload, __offset, (.. __params (getDefaultSerializer)), Message/UNKNOWN_LENGTH)
        this
    )

    #_throws #_[ "ProtocolException" ]
    (ยง constructor AddressMessage [#_"NetworkParameters" __params, #_"byte[]" __payload]
        (ยง super __params, __payload, 0, (.. __params (getDefaultSerializer)), Message/UNKNOWN_LENGTH)
        this
    )

    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        (let [#_"long" __numAddresses (.. this (readVarInt))]
            ;; Guard against ultra large messages that will crash us.
            (when (< AddressMessage/MAX_ADDRESSES __numAddresses)
                (throw (ProtocolException. "Address message too large."))
            )
            (ยง assoc this :addresses (ArrayList. #_"<>" (int __numAddresses)))
            (loop-when-recur [#_"int" __i 0] (< __i __numAddresses) [(inc __i)]
                (let [#_"PeerAddress" __addr (PeerAddress. (:params this), (:payload this), (:cursor this), (:protocol-version this), this, (:serializer this))]
                    (.. (:addresses this) (add __addr))
                    (ยง assoc this :cursor (+ (:cursor this) (.. __addr (getMessageSize))))
                )
            )
            (ยง assoc this :length (.. (VarInt. (.. (:addresses this) (size))) (getSizeInBytes)))
            ;; The 4 byte difference is the uint32 timestamp that was introduced in version 31402.
            (ยง assoc this :length (+ (:length this) (* (.. (:addresses this) (size)) (if (< 31402 (:protocol-version this)) PeerAddress/MESSAGE_SIZE (- PeerAddress/MESSAGE_SIZE 4)))))
            nil
        )
    )

    #_override
    #_protected
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __stream]
        (when (some? (:addresses this))
            (.. __stream (write (.. (VarInt. (.. (:addresses this) (size))) (encode))))
            (doseq [#_"PeerAddress" __addr (:addresses this)]
                (.. __addr (bitcoinSerialize __stream))
            )
        )
        nil
    )

    ;;;
     ; @return An unmodifiableList view of the backing List of addresses.  Addresses contained within the list may be safely modified.
     ;;
    #_public
    (ยง method #_"List<PeerAddress>" getAddresses []
        (Collections/unmodifiableList (:addresses this))
    )

    #_public
    (ยง method #_"void" addAddress [#_"PeerAddress" __address]
        (.. this (unCache))
        (.. __address (setParent this))
        (.. (:addresses this) (add __address))
        (if (== (:length this) Message/UNKNOWN_LENGTH)
            (.. this (getMessageSize))
            (ยง assoc this :length (+ (:length this) (.. __address (getMessageSize))))
        )
        nil
    )

    #_public
    (ยง method #_"void" removeAddress [#_"int" __index]
        (.. this (unCache))
        (let [#_"PeerAddress" __address (.. (:addresses this) (remove __index))]
            (.. __address (setParent nil))
            (if (== (:length this) Message/UNKNOWN_LENGTH)
                (.. this (getMessageSize))
                (ยง assoc this :length (- (:length this) (.. __address (getMessageSize))))
            )
            nil
        )
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (str "addr: " (.. Utils/SPACE_JOINER (join (:addresses this))))
    )
)

;;;
 ; Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 ; The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 ; an available upgrade or a serious network problem.  Alerts have an expiration time, data that specifies what
 ; set of software versions it matches and the ability to cancel them by broadcasting another type of alert.
 ;
 ; The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 ; log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 ; For example, you could treat it as an upgrade notification specific to your app.  Satoshi designed alerts to ensure
 ; that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 ; be purely peer-to-peer.  You don't have to use this of course, and indeed it often makes more sense not to.
 ;
 ; <p>Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class AlertMessage (ยง extends Message)
    #_private
    (ยง field- #_"byte[]" :content)
    #_private
    (ยง field- #_"byte[]" :signature)

    ;; See the getters for documentation of what each field means.
    #_private
    (ยง field- #_"long" :version 1)
    #_private
    (ยง field- #_"Date" :relay-until)
    #_private
    (ยง field- #_"Date" :expiration)
    #_private
    (ยง field- #_"long" :id)
    #_private
    (ยง field- #_"long" :cancel)
    #_private
    (ยง field- #_"long" :min-ver)
    #_private
    (ยง field- #_"long" :max-ver)
    #_private
    (ยง field- #_"long" :priority)
    #_private
    (ยง field- #_"String" :comment)
    #_private
    (ยง field- #_"String" :status-bar)
    #_private
    (ยง field- #_"String" :reserved)

    ;; Chosen arbitrarily to avoid memory blowups.
    #_private
    #_static
    (ยง def- #_"long" AlertMessage/MAX_SET_SIZE 100)

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor AlertMessage [#_"NetworkParameters" __params, #_"byte[]" __payloadBytes]
        (ยง super __params, __payloadBytes, 0)
        this
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (str "ALERT: " (.. this (getStatusBar)))
    )

    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        ;; Alerts are formatted in two levels.  The top level contains two byte arrays: a signature, and a serialized
        ;; data structure containing the actual alert data.
        (let [#_"int" __startPos (:cursor this)]
            (ยง assoc this :content (.. this (readByteArray)))
            (ยง assoc this :signature (.. this (readByteArray)))
            ;; Now we need to parse out the contents of the embedded structure.  Rewind back to the start of the message.
            (ยง assoc this :cursor __startPos)
            (.. this (readVarInt)) ;; Skip the length field on the content array.
            ;; We're inside the embedded structure.
            (ยง assoc this :version (.. this (readUint32)))
            ;; Read the timestamps.  Bitcoin uses seconds since the epoch.
            (ยง assoc this :relay-until (Date. (* (.. this (readUint64) (longValue)) 1000)))
            (ยง assoc this :expiration (Date. (* (.. this (readUint64) (longValue)) 1000)))
            (ยง assoc this :id (.. this (readUint32)))
            (ยง assoc this :cancel (.. this (readUint32)))
            ;; Sets are serialized as <len><item><item><item>....
            (let [#_"long" __cancelSetSize (.. this (readVarInt))]
                (when (or (< __cancelSetSize 0) (< AlertMessage/MAX_SET_SIZE __cancelSetSize))
                    (throw (ProtocolException. (str "Bad cancel set size: " __cancelSetSize)))
                )
                ;; Using a hashset here is very inefficient given that this will normally be only one item.  But Java doesn't
                ;; make it easy to do better.  What we really want is just an array-backed set.
                (let [#_"Set<Long>" __cancelSet (HashSet. #_"<>" (int __cancelSetSize))]
                    (loop-when-recur [#_"long" __i 0] (< __i __cancelSetSize) [(inc __i)]
                        (.. __cancelSet (add (.. this (readUint32))))
                    )
                    (ยง assoc this :min-ver (.. this (readUint32)))
                    (ยง assoc this :max-ver (.. this (readUint32)))
                    ;; Read the subver matching set.
                    (let [#_"long" __subverSetSize (.. this (readVarInt))]
                        (when (or (< __subverSetSize 0) (< AlertMessage/MAX_SET_SIZE __subverSetSize))
                            (throw (ProtocolException. (str "Bad subver set size: " __subverSetSize)))
                        )
                        (let [#_"Set<String>" __matchingSubVers (HashSet. #_"<>" (int __subverSetSize))]
                            (loop-when-recur [#_"long" __i 0] (< __i __subverSetSize) [(inc __i)]
                                (.. __matchingSubVers (add (.. this (readStr))))
                            )
                            (ยง assoc this :priority (.. this (readUint32)))
                            (ยง assoc this :comment (.. this (readStr)))
                            (ยง assoc this :status-bar (.. this (readStr)))
                            (ยง assoc this :reserved (.. this (readStr)))

                            (ยง assoc this :length (- (:cursor this) (:offset this)))
                            nil
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Returns true if the digital signature attached to the message verifies.  Don't do anything with the alert if it
     ; doesn't verify, because that would allow arbitrary attackers to spam your users.
     ;;
    #_public
    (ยง method #_"boolean" isSignatureValid []
        (ECKey/verify (Sha256Hash/hashTwice (:content this)), (:signature this), (.. (:params this) (getAlertSigningKey)))
    )

    ;;;
     ; The time at which the alert should stop being broadcast across the network.  Note that you can still receive
     ; the alert after this time from other nodes if the alert still applies to them or to you.
     ;;
    #_public
    (ยง method #_"Date" getRelayUntil []
        (:relay-until this)
    )

    #_public
    (ยง method #_"void" setRelayUntil [#_"Date" __relayUntil]
        (ยง assoc this :relay-until __relayUntil)
        nil
    )

    ;;;
     ; The time at which the alert ceases to be relevant.  It should not be presented to the user or app administrator
     ; after this time.
     ;;
    #_public
    (ยง method #_"Date" getExpiration []
        (:expiration this)
    )

    #_public
    (ยง method #_"void" setExpiration [#_"Date" __expiration]
        (ยง assoc this :expiration __expiration)
        nil
    )

    ;;;
     ; The numeric identifier of this alert.  Each alert should have a unique ID, but the signer can choose any number.
     ; If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     ; @return uint32
     ;;
    #_public
    (ยง method #_"long" getId []
        (:id this)
    )

    #_public
    (ยง method #_"void" setId [#_"long" __id]
        (ยง assoc this :id __id)
        nil
    )

    ;;;
     ; A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     ; @return uint32
     ;;
    #_public
    (ยง method #_"long" getCancel []
        (:cancel this)
    )

    #_public
    (ยง method #_"void" setCancel [#_"long" __cancel]
        (ยง assoc this :cancel __cancel)
        nil
    )

    ;;;
     ; The inclusive lower bound on software versions that are considered for the purposes of this alert.  Bitcoin Core
     ; compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     ; alerts could use any version numbers.
     ; @return uint32
     ;;
    #_public
    (ยง method #_"long" getMinVer []
        (:min-ver this)
    )

    #_public
    (ยง method #_"void" setMinVer [#_"long" __minVer]
        (ยง assoc this :min-ver __minVer)
        nil
    )

    ;;;
     ; The inclusive upper bound on software versions considered for the purposes of this alert.  Bitcoin Core
     ; compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     ; alerts could use any version numbers.
     ;;
    #_public
    (ยง method #_"long" getMaxVer []
        (:max-ver this)
    )

    #_public
    (ยง method #_"void" setMaxVer [#_"long" __maxVer]
        (ยง assoc this :max-ver __maxVer)
        nil
    )

    ;;;
     ; Provides an integer ordering amongst simultaneously active alerts.
     ; @return uint32
     ;;
    #_public
    (ยง method #_"long" getPriority []
        (:priority this)
    )

    #_public
    (ยง method #_"void" setPriority [#_"long" __priority]
        (ยง assoc this :priority __priority)
        nil
    )

    ;;;
     ; This field is unused.  It is presumably intended for the author of the alert to provide a justification for it
     ; visible to protocol developers but not users.
     ;;
    #_public
    (ยง method #_"String" getComment []
        (:comment this)
    )

    #_public
    (ยง method #_"void" setComment [#_"String" __comment]
        (ยง assoc this :comment __comment)
        nil
    )

    ;;;
     ; A string that is intended to display in the status bar of Bitcoin Core's GUI client.  It contains the user-visible
     ; message.  English only.
     ;;
    #_public
    (ยง method #_"String" getStatusBar []
        (:status-bar this)
    )

    #_public
    (ยง method #_"void" setStatusBar [#_"String" __statusBar]
        (ยง assoc this :status-bar __statusBar)
        nil
    )

    ;;;
     ; This field is never used.
     ;;
    #_public
    (ยง method #_"String" getReserved []
        (:reserved this)
    )

    #_public
    (ยง method #_"void" setReserved [#_"String" __reserved]
        (ยง assoc this :reserved __reserved)
        nil
    )

    #_public
    (ยง method #_"long" getVersion []
        (:version this)
    )
)

;;;
 ; Base58 is a way to encode Bitcoin addresses (or arbitrary data) as alphanumeric strings.
 ;
 ; Note that this is not the same base58 as used by Flickr, which you may find referenced around the Internet.
 ;
 ; You may want to consider working with {@link VersionedChecksummedBytes} instead, which
 ; adds support for testing the prefix and suffix bytes commonly found in addresses.
 ;
 ; Satoshi explains: why base-58 instead of standard base-64 encoding?
 ; <ul>
 ; <li>Don't want 0OIl characters that look the same in some fonts and
 ;     could be used to create visually identical looking account numbers.</li>
 ; <li>A string with non-alphanumeric characters is not as easily accepted as an account number.</li>
 ; <li>E-mail usually won't line-break if there's no punctuation to break at.</li>
 ; <li>Doubleclicking selects the whole number as one word if it's all alphanumeric.</li>
 ; </ul>
 ;
 ; However, note that the encoding/decoding runs in O(n&sup2;) time, so it is not useful for large data.
 ;
 ; The basic idea of the encoding is to treat the data bytes as a large number represented using
 ; base-256 digits, convert the number to be represented using base-58 digits, preserve the exact
 ; number of leading zeros (which are otherwise lost during the mathematical operations on the
 ; numbers), and finally represent the resulting base-58 digits as alphanumeric ASCII characters.
 ;;
#_public
(ยง class Base58
    #_public
    #_static
    (ยง def #_"char[]" Base58/ALPHABET (.. "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" (toCharArray)))
    #_private
    #_static
    (ยง def- #_"char" Base58/ENCODED_ZERO (aget Base58/ALPHABET 0))
    #_private
    #_static
    (ยง def- #_"int[]" Base58/INDEXES (int-array 128))
    #_static
    (ยง block
        (Arrays/fill Base58/INDEXES, -1)
        (loop-when-recur [#_"int" __i 0] (< __i (.. Base58/ALPHABET (alength))) [(inc __i)]
            (ยง ass Base58/INDEXES[Base58/ALPHABET[__i]] __i)
        )
    )

    ;;;
     ; Encodes the given bytes as a base58 string (no checksum is appended).
     ;
     ; @param input the bytes to encode
     ; @return the base58-encoded string
     ;;
    #_public
    #_static
    (ยง defn #_"String" Base58/encode [#_"byte[]" __input]
        (when (== (.. __input (alength)) 0)
            (ยง return "")
        )

        ;; Count leading zeros.
        (let [#_"int" __zeros 0]
            (while (and (< __zeros (.. __input (alength))) (== (aget __input __zeros) 0))
                (ยง ass __zeros (inc __zeros))
            )

            ;; Convert base-256 digits to base-58 digits (plus conversion to ASCII characters).
            (ยง ass __input (Arrays/copyOf __input, (.. __input (alength)))) ;; since we modify it in-place
            (let [#_"char[]" __encoded (char-array (* (.. __input (alength)) 2))] ;; upper bound
                (let [#_"int" __outputStart (.. __encoded (alength))]
                    (loop-when-recur [#_"int" __inputStart __zeros] (< __inputStart (.. __input (alength))) []
                        (ยง ass __outputStart (dec __outputStart))
                        (aset __encoded __outputStart (aget Base58/ALPHABET (Base58/divmod __input, __inputStart, 256, 58)))
                        (when (== (aget __input __inputStart) 0)
                            (ยง ass __inputStart (inc __inputStart)) ;; optimization - skip leading zeros
                        )
                    )
                    ;; Preserve exactly as many leading encoded zeros in output as there were leading zeros in input.
                    (while (and (< __outputStart (.. __encoded (alength))) (== (aget __encoded __outputStart) Base58/ENCODED_ZERO))
                        (ยง ass __outputStart (inc __outputStart))
                    )
                    (loop-when-recur [] (< 0 __zeros) [(ยง ass __zeros (dec __zeros))]
                        (ยง ass __outputStart (dec __outputStart))
                        (aset __encoded __outputStart Base58/ENCODED_ZERO)
                    )

                    ;; Return encoded string (including encoded leading zeros).
                    (String. __encoded, __outputStart, (- (.. __encoded (alength)) __outputStart))
                )
            )
        )
    )

    ;;;
     ; Decodes the given base58 string into the original data bytes.
     ;
     ; @param input the base58-encoded string to decode
     ; @return the decoded data bytes
     ; @throws AddressFormatException if the given string is not a valid base58 string
     ;;
    #_public
    #_static
    #_throws #_[ "AddressFormatException" ]
    (ยง defn #_"byte[]" Base58/decode [#_"String" __input]
        (when (== (.. __input (length)) 0)
            (ยง return (byte-array 0))
        )

        ;; Convert the base58-encoded ASCII chars to a base58 byte sequence (base58 digits).
        (let [#_"byte[]" __input58 (byte-array (.. __input (length)))]
            (loop-when-recur [#_"int" __i 0] (< __i (.. __input (length))) [(inc __i)]
                (let [#_"char" __c (.. __input (charAt __i))
                      #_"int" __digit (if (< __c 128) (aget Base58/INDEXES __c) -1)]
                    (when (< __digit 0)
                        (throw (AddressFormatException. (str "Illegal character " __c " at position " __i)))
                    )
                    (aset __input58 __i (byte __digit))
                )
            )
            ;; Count leading zeros.
            (let [#_"int" __zeros 0]
                (while (and (< __zeros (.. __input58 (alength))) (== (aget __input58 __zeros) 0))
                    (ยง ass __zeros (inc __zeros))
                )
                ;; Convert base-58 digits to base-256 digits.
                (let [#_"byte[]" __decoded (byte-array (.. __input (length)))
                      #_"int" __outputStart (.. __decoded (alength))]
                    (loop-when-recur [#_"int" __inputStart __zeros] (< __inputStart (.. __input58 (alength))) []
                        (ยง ass __outputStart (dec __outputStart))
                        (aset __decoded __outputStart (Base58/divmod __input58, __inputStart, 58, 256))
                        (when (== (aget __input58 __inputStart) 0)
                            (ยง ass __inputStart (inc __inputStart)) ;; optimization - skip leading zeros
                        )
                    )
                    ;; Ignore extra leading zeroes that were added during the calculation.
                    (while (and (< __outputStart (.. __decoded (alength))) (== (aget __decoded __outputStart) 0))
                        (ยง ass __outputStart (inc __outputStart))
                    )

                    ;; Return decoded data (including original number of leading zeros).
                    (Arrays/copyOfRange __decoded, (- __outputStart __zeros), (.. __decoded (alength)))
                )
            )
        )
    )

    #_public
    #_static
    #_throws #_[ "AddressFormatException" ]
    (ยง defn #_"BigInteger" Base58/decodeToBigInteger [#_"String" __input]
        (BigInteger. 1, (Base58/decode __input))
    )

    ;;;
     ; Decodes the given base58 string into the original data bytes, using the checksum in the
     ; last 4 bytes of the decoded data to verify that the rest are correct.  The checksum is
     ; removed from the returned data.
     ;
     ; @param input the base58-encoded string to decode (which should include the checksum)
     ; @throws AddressFormatException if the input is not base 58 or the checksum does not validate
     ;;
    #_public
    #_static
    #_throws #_[ "AddressFormatException" ]
    (ยง defn #_"byte[]" Base58/decodeChecked [#_"String" __input]
        (let [#_"byte[]" __decoded (Base58/decode __input)]
            (when (< (.. __decoded (alength)) 4)
                (throw (AddressFormatException. "Input too short"))
            )
            (let [#_"byte[]" __data (Arrays/copyOfRange __decoded, 0, (- (.. __decoded (alength)) 4))
                  #_"byte[]" __checksum (Arrays/copyOfRange __decoded, (- (.. __decoded (alength)) 4), (.. __decoded (alength)))
                  #_"byte[]" __actualChecksum (Arrays/copyOfRange (Sha256Hash/hashTwice __data), 0, 4)]
                (when (not (Arrays/equals __checksum, __actualChecksum))
                    (throw (AddressFormatException. "Checksum does not validate"))
                )
                __data
            )
        )
    )

    ;;;
     ; Divides a number, represented as an array of bytes each containing a single digit
     ; in the specified base, by the given divisor.  The given number is modified in-place
     ; to contain the quotient, and the return value is the remainder.
     ;
     ; @param number the number to divide
     ; @param firstDigit the index within the array of the first non-zero digit
     ;        (this is used for optimization by skipping the leading zeros)
     ; @param base the base in which the number's digits are represented (up to 256)
     ; @param divisor the number to divide by (up to 256)
     ; @return the remainder of the division operation
     ;;
    #_private
    #_static
    (ยง defn- #_"byte" Base58/divmod [#_"byte[]" __number, #_"int" __firstDigit, #_"int" __base, #_"int" __divisor]
        ;; This is just long division which accounts for the base of the input digits.
        (let [#_"int" __remainder 0]
            (loop-when-recur [#_"int" __i __firstDigit] (< __i (.. __number (alength))) [(inc __i)]
                (let [#_"int" __digit (& (int (aget __number __i)) 0xff)
                      #_"int" __temp (+ (* __remainder __base) __digit)]
                    (aset __number __i (byte (/ __temp __divisor)))
                    (ยง ass __remainder (% __temp __divisor))
                )
            )
            (byte __remainder)
        )
    )
)

;;;
 ; <p>Methods to serialize and de-serialize messages to the Bitcoin network format as defined in
 ; <a href="https://en.bitcoin.it/wiki/Protocol_specification">the protocol specification</a>.</p>
 ;
 ; <p>To be able to serialize and deserialize new Message subclasses the following criteria needs to be met.</p>
 ;
 ; <ul>
 ; <li>The proper Class instance needs to be mapped to its message name in the NAMES variable below.</li>
 ; <li>There needs to be a constructor matching: NetworkParameters params, byte[] payload.</li>
 ; <li>Message.bitcoinSerializeToStream() needs to be properly subclassed.</li>
 ; </ul>
 ;;
#_public
(ยง class BitcoinSerializer (ยง extends MessageSerializer)
    #_private
    #_static
    (ยง def- #_"Logger" BitcoinSerializer/log (LoggerFactory/getLogger BitcoinSerializer))
    #_private
    #_static
    (ยง def- #_"int" BitcoinSerializer/COMMAND_LEN 12)

    #_private
    #_static
    (ยง def- #_"Map<Class<? extends Message>, String>" BitcoinSerializer/NAMES (HashMap. #_"<>"))
    #_static
    (ยง block
        (.. BitcoinSerializer/NAMES (put VersionMessage, "version"))
        (.. BitcoinSerializer/NAMES (put InventoryMessage, "inv"))
        (.. BitcoinSerializer/NAMES (put Block, "block"))
        (.. BitcoinSerializer/NAMES (put GetDataMessage, "getdata"))
        (.. BitcoinSerializer/NAMES (put Transaction, "tx"))
        (.. BitcoinSerializer/NAMES (put AddressMessage, "addr"))
        (.. BitcoinSerializer/NAMES (put Ping, "ping"))
        (.. BitcoinSerializer/NAMES (put Pong, "pong"))
        (.. BitcoinSerializer/NAMES (put VersionAck, "verack"))
        (.. BitcoinSerializer/NAMES (put GetBlocksMessage, "getblocks"))
        (.. BitcoinSerializer/NAMES (put GetHeadersMessage, "getheaders"))
        (.. BitcoinSerializer/NAMES (put GetAddrMessage, "getaddr"))
        (.. BitcoinSerializer/NAMES (put HeadersMessage, "headers"))
        (.. BitcoinSerializer/NAMES (put BloomFilter, "filterload"))
        (.. BitcoinSerializer/NAMES (put FilteredBlock, "merkleblock"))
        (.. BitcoinSerializer/NAMES (put NotFoundMessage, "notfound"))
        (.. BitcoinSerializer/NAMES (put MemoryPoolMessage, "mempool"))
        (.. BitcoinSerializer/NAMES (put RejectMessage, "reject"))
    )

    #_private
    (ยง field- #_"NetworkParameters" :params)
    #_private
    (ยง field- #_"boolean" :parse-retain)

    ;;;
     ; Constructs a BitcoinSerializer with the given behavior.
     ;
     ; @param params           networkParams used to create Messages instances and termining packetMagic
     ; @param parseRetain      retain the backing byte array of a message for fast reserialization
     ;;
    #_public
    (ยง constructor BitcoinSerializer [#_"NetworkParameters" __params, #_"boolean" __parseRetain]
        (ยง assoc this :params __params)
        (ยง assoc this :parse-retain __parseRetain)
        this
    )

    ;;;
     ; Writes message to to the output stream.
     ;;
    #_override
    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" serialize [#_"String" __name, #_"byte[]" __message, #_"OutputStream" __out]
        (let [#_"byte[]" __header (byte-array (+ 4 BitcoinSerializer/COMMAND_LEN 4 4))] ;; checksum
            (Utils/uint32ToByteArrayBE (.. (:params this) (getPacketMagic)), __header, 0)

            ;; The header array is initialized to zero by Java so we don't have to worry
            ;; about NULL terminating the string here.
            (loop-when-recur [#_"int" __i 0] (and (< __i (.. __name (length))) (< __i BitcoinSerializer/COMMAND_LEN)) [(inc __i)]
                (aset __header (+ 4 __i) (byte (& (.. __name (codePointAt __i)) 0xff)))
            )

            (Utils/uint32ToByteArrayLE (.. __message (alength)), __header, (+ 4 BitcoinSerializer/COMMAND_LEN))

            (let [#_"byte[]" __hash (Sha256Hash/hashTwice __message)]
                (System/arraycopy __hash, 0, __header, (+ 4 BitcoinSerializer/COMMAND_LEN 4), 4)
                (.. __out (write __header))
                (.. __out (write __message))

                (when (.. BitcoinSerializer/log (isDebugEnabled))
                    (.. BitcoinSerializer/log (debug "Sending {} message: {}", __name, (+ (.. Utils/HEX (encode __header)) (.. Utils/HEX (encode __message)))))
                )
                nil
            )
        )
    )

    ;;;
     ; Writes message to to the output stream.
     ;;
    #_override
    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" serialize [#_"Message" __message, #_"OutputStream" __out]
        (let [#_"String" __name (.. BitcoinSerializer/NAMES (get (.. __message (getClass))))]
            (when (nil? __name)
                (throw (Error. (str "BitcoinSerializer doesn't currently know how to serialize " (.. __message (getClass)))))
            )

            (.. this (serialize __name, (.. __message (bitcoinSerialize)), __out))
            nil
        )
    )

    ;;;
     ; Reads a message from the given ByteBuffer and returns it.
     ;;
    #_override
    #_public
    #_throws #_[ "ProtocolException", "IOException" ]
    (ยง method #_"Message" deserialize [#_"ByteBuffer" __in]
        ;; A Bitcoin protocol message has the following format:
        ;;
        ;;   - 4 byte magic number: 0xfabfb5da for the testnet or
        ;;                          0xf9beb4d9 for production
        ;;   - 12 byte command in ASCII
        ;;   - 4 byte payload size
        ;;   - 4 byte checksum
        ;;   - Payload data
        ;;
        ;; The checksum is the first 4 bytes of a SHA256 hash of the message payload. It isn't
        ;; present for all messages, notably, the first one on a connection.
        ;;
        ;; Bitcoin Core ignores garbage before the magic header bytes. We have to do the same because
        ;; sometimes it sends us stuff that isn't part of any message.
        (.. this (seekPastMagicBytes __in))
        (let [#_"BitcoinSerializer.BitcoinPacketHeader" __header (BitcoinSerializer.BitcoinPacketHeader. __in)]
            ;; Now try to read the whole message.
            (.. this (deserializePayload __header, __in))
        )
    )

    ;;;
     ; Deserializes only the header in case packet meta data is needed before decoding
     ; the payload.  This method assumes you have already called seekPastMagicBytes().
     ;;
    #_override
    #_public
    #_throws #_[ "ProtocolException", "IOException" ]
    (ยง method #_"BitcoinSerializer.BitcoinPacketHeader" deserializeHeader [#_"ByteBuffer" __in]
        (BitcoinSerializer.BitcoinPacketHeader. __in)
    )

    ;;;
     ; Deserialize payload only.  You must provide a header, typically obtained by calling
     ; {@link BitcoinSerializer#deserializeHeader}.
     ;;
    #_override
    #_public
    #_throws #_[ "ProtocolException", "BufferUnderflowException" ]
    (ยง method #_"Message" deserializePayload [#_"BitcoinSerializer.BitcoinPacketHeader" __header, #_"ByteBuffer" __in]
        (let [#_"byte[]" __payloadBytes (byte-array (:size __header))]
            (.. __in (get __payloadBytes, 0, (:size __header)))

            ;; Verify the checksum.
            (let [#_"byte[]" __hash]
                (ยง ass __hash (Sha256Hash/hashTwice __payloadBytes))
                (when (or (!= (aget (:checksum __header) 0) (aget __hash 0)) (!= (aget (:checksum __header) 1) (aget __hash 1)) (!= (aget (:checksum __header) 2) (aget __hash 2)) (!= (aget (:checksum __header) 3) (aget __hash 3)))
                    (throw (ProtocolException. (str "Checksum failed to verify, actual " (.. Utils/HEX (encode __hash)) " vs " (.. Utils/HEX (encode (:checksum __header))))))
                )

                (when (.. BitcoinSerializer/log (isDebugEnabled))
                    (.. BitcoinSerializer/log (debug "Received {} byte '{}' message: {}", (:size __header), (:command __header), (.. Utils/HEX (encode __payloadBytes))))
                )

                (try
                    (ยง return (.. this (makeMessage (:command __header), (:size __header), __payloadBytes, __hash, (:checksum __header))))
                    (catch Exception __e
                        (throw (ProtocolException. (str "Error deserializing message " (.. Utils/HEX (encode __payloadBytes)) "\n"), __e))
                    )
                )
            )
        )
    )

    #_private
    #_throws #_[ "ProtocolException" ]
    (ยง method- #_"Message" makeMessage [#_"String" __command, #_"int" __length, #_"byte[]" __payloadBytes, #_"byte[]" __hash, #_"byte[]" __checksum]
        ;; We use an if ladder rather than reflection because reflection is very slow on Android.
        (when (.. __command (equals "version"))
            (ยง return (VersionMessage. (:params this), __payloadBytes))
        )
        (when (.. __command (equals "inv"))
            (ยง return (.. this (makeInventoryMessage __payloadBytes, __length)))
        )
        (when (.. __command (equals "block"))
            (ยง return (.. this (makeBlock __payloadBytes, __length)))
        )
        (when (.. __command (equals "merkleblock"))
            (ยง return (.. this (makeFilteredBlock __payloadBytes)))
        )
        (when (.. __command (equals "getdata"))
            (ยง return (GetDataMessage. (:params this), __payloadBytes, this, __length))
        )
        (when (.. __command (equals "getblocks"))
            (ยง return (GetBlocksMessage. (:params this), __payloadBytes))
        )
        (when (.. __command (equals "getheaders"))
            (ยง return (GetHeadersMessage. (:params this), __payloadBytes))
        )
        (when (.. __command (equals "tx"))
            (ยง return (.. this (makeTransaction __payloadBytes, 0, __length, __hash)))
        )
        (when (.. __command (equals "addr"))
            (ยง return (.. this (makeAddressMessage __payloadBytes, __length)))
        )
        (when (.. __command (equals "ping"))
            (ยง return (Ping. (:params this), __payloadBytes))
        )
        (when (.. __command (equals "pong"))
            (ยง return (Pong. (:params this), __payloadBytes))
        )
        (when (.. __command (equals "verack"))
            (ยง return (VersionAck. (:params this), __payloadBytes))
        )
        (when (.. __command (equals "headers"))
            (ยง return (HeadersMessage. (:params this), __payloadBytes))
        )
        (when (.. __command (equals "alert"))
            (ยง return (.. this (makeAlertMessage __payloadBytes)))
        )
        (when (.. __command (equals "filterload"))
            (ยง return (.. this (makeBloomFilter __payloadBytes)))
        )
        (when (.. __command (equals "notfound"))
            (ยง return (NotFoundMessage. (:params this), __payloadBytes))
        )
        (when (.. __command (equals "mempool"))
            (ยง return (MemoryPoolMessage.))
        )
        (when (.. __command (equals "reject"))
            (ยง return (RejectMessage. (:params this), __payloadBytes))
        )
        (.. BitcoinSerializer/log (warn "No support for deserializing message with name {}", __command))
        (UnknownMessage. (:params this), __command, __payloadBytes)
    )

    ;;;
     ; Get the network parameters for this serializer.
     ;;
    #_public
    (ยง method #_"NetworkParameters" getParameters []
        (:params this)
    )

    ;;;
     ; Make an address message from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"AddressMessage" makeAddressMessage [#_"byte[]" __payloadBytes, #_"int" __length]
        (AddressMessage. (:params this), __payloadBytes, this, __length)
    )

    ;;;
     ; Make an alert message from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"Message" makeAlertMessage [#_"byte[]" __payloadBytes]
        (AlertMessage. (:params this), __payloadBytes)
    )

    ;;;
     ; Make a block from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"Block" makeBlock [#_"byte[]" __payloadBytes, #_"int" __offset, #_"int" __length]
        (Block. (:params this), __payloadBytes, __offset, this, __length)
    )

    ;;;
     ; Make an filter message from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"Message" makeBloomFilter [#_"byte[]" __payloadBytes]
        (BloomFilter. (:params this), __payloadBytes)
    )

    ;;;
     ; Make a filtered block from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"FilteredBlock" makeFilteredBlock [#_"byte[]" __payloadBytes]
        (FilteredBlock. (:params this), __payloadBytes)
    )

    ;;;
     ; Make an inventory message from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"InventoryMessage" makeInventoryMessage [#_"byte[]" __payloadBytes, #_"int" __length]
        (InventoryMessage. (:params this), __payloadBytes, this, __length)
    )

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"Transaction" makeTransaction [#_"byte[]" __payloadBytes, #_"int" __offset, #_"int" __length, #_"byte[]" __hash]
        (let [#_"Transaction" __tx (Transaction. (:params this), __payloadBytes, __offset, nil, this, __length)]
            (when (some? __hash)
                (.. __tx (setHash (Sha256Hash/wrapReversed __hash)))
            )
            __tx
        )
    )

    #_override
    #_public
    #_throws #_[ "BufferUnderflowException" ]
    (ยง method #_"void" seekPastMagicBytes [#_"ByteBuffer" __in]
        (let [#_"int" __magicCursor 3] ;; Which byte of the magic we're looking for currently.
            (loop []
                (let [#_"byte" __b (.. __in (get))]
                    ;; We're looking for a run of bytes that is the same as the packet magic but we want to ignore partial
                    ;; magics that aren't complete.  So we keep track of where we're up to with magicCursor.
                    (let [#_"byte" __expectedByte (byte (& 0xff (>>> (.. (:params this) (getPacketMagic)) (<< __magicCursor 3))))]
                        (cond (== __b __expectedByte)
                            (do
                                (ยง ass __magicCursor (dec __magicCursor))
                                (when (< __magicCursor 0)
                                    (ยง return nil) ;; We found the magic sequence.
                                )
                            )
                            :else
                            (do
                                (ยง ass __magicCursor 3)
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    ;;;
     ; Whether the serializer will produce cached mode Messages.
     ;;
    #_override
    #_public
    (ยง method #_"boolean" isParseRetainMode []
        (:parse-retain this)
    )

    #_public
    #_static
    (ยง class BitcoinSerializer.BitcoinPacketHeader
        ;;; The largest number of bytes that a header can represent. ;;
        #_public
        #_static
        (ยง def #_"int" BitcoinSerializer.BitcoinPacketHeader/HEADER_LENGTH (+ BitcoinSerializer/COMMAND_LEN 4 4))

        #_public
        (ยง field #_"byte[]" :header)
        #_public
        (ยง field #_"String" :command)
        #_public
        (ยง field #_"int" :size)
        #_public
        (ยง field #_"byte[]" :checksum)

        #_public
        #_throws #_[ "ProtocolException", "BufferUnderflowException" ]
        (ยง constructor BitcoinSerializer.BitcoinPacketHeader [#_"ByteBuffer" __in]
            (ยง assoc this :header (byte-array BitcoinSerializer.BitcoinPacketHeader/HEADER_LENGTH))
            (.. __in (get (:header this), 0, (.. (:header this) (alength))))

            (let [#_"int" __cursor 0]

                ;; The command is a NULL terminated string, unless the command fills all twelve bytes
                ;; in which case the termination is implicit.
                (while (and (!= (aget (:header this) __cursor) 0) (< __cursor BitcoinSerializer/COMMAND_LEN))
                    (ยง ass __cursor (inc __cursor))
                )
                (let [#_"byte[]" __commandBytes (byte-array __cursor)]
                    (System/arraycopy (:header this), 0, __commandBytes, 0, __cursor)
                    (ยง assoc this :command (Utils/toString __commandBytes, "US-ASCII"))
                    (ยง ass __cursor BitcoinSerializer/COMMAND_LEN)

                    (ยง assoc this :size (int (Utils/readUint32 (:header this), __cursor)))
                    (ยง ass __cursor (+ __cursor 4))

                    (when (or (< Message/MAX_SIZE (:size this)) (< (:size this) 0))
                        (throw (ProtocolException. (str "Message size too large: " (:size this))))
                    )

                    ;; Old clients don't send the checksum.
                    (ยง assoc this :checksum (byte-array 4))
                    ;; Note that the size read above includes the checksum bytes.
                    (System/arraycopy (:header this), __cursor, (:checksum this), 0, 4)
                    (ยง ass __cursor (+ __cursor 4))
                    this
                )
            )
        )
    )
)

;;;
 ; <p>A block is a group of transactions, and is one of the fundamental data structures of the Bitcoin system.
 ; It records a set of {@link Transaction}s together with some data that links it into a place in the global block chain,
 ; and proves that a difficult calculation was done over its contents.
 ; See <a href="http://www.bitcoin.org/bitcoin.pdf">the Bitcoin technical paper</a> for more detail on blocks.
 ;
 ; <p>To get a block, you can either build one from the raw bytes you can get from another implementation, or request one
 ; specifically using {@link Peer#getBlock(Sha256Hash)}, or grab one from a downloaded {@link BlockChain}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class Block (ยง extends Message)
    ;;;
     ; Flags used to control which elements of block validation are done on received blocks.
     ;;
    #_public
    (ยง enum Block.VerifyFlag
        ;;; Check that block height is in coinbase transaction (BIP 34). ;;
        (ยง item HEIGHT_IN_COINBASE)
    )

    #_private
    #_static
    (ยง def- #_"Logger" Block/log (LoggerFactory/getLogger Block))

    ;;; How many bytes are required to represent a block header WITHOUT the trailing 00 length byte. ;;
    #_public
    #_static
    (ยง def #_"int" Block/HEADER_SIZE 80)

    #_static
    (ยง def #_"long" Block/ALLOWED_TIME_DRIFT (* 2 60 60)) ;; Same value as Bitcoin Core.

    ;;;
     ; A constant shared by the entire network: how large in bytes a block is allowed to be.  One day we may have to
     ; upgrade everyone to change this, so Bitcoin can continue to grow.  For now it exists as an anti-DoS measure to
     ; avoid somebody creating a titanically huge but valid block and forcing everyone to download/store it forever.
     ;;
    #_public
    #_static
    (ยง def #_"int" Block/MAX_BLOCK_SIZE (* 1 1000 1000))
    ;;;
     ; A "sigop" is a signature verification operation.  Because they're expensive, we also impose a separate limit on
     ; the number in a block to prevent somebody mining a huge block that has way more sigops than normal, so is very
     ; expensive/slow to verify.
     ;;
    #_public
    #_static
    (ยง def #_"int" Block/MAX_BLOCK_SIGOPS (/ Block/MAX_BLOCK_SIZE 50))

    ;;; A value for difficultyTarget (nBits) that allows half of all possible hash solutions.  Used in unit testing. ;;
    #_public
    #_static
    (ยง def #_"long" Block/EASIEST_DIFFICULTY_TARGET 0x207fffff)

    ;;; Value to use if the block height is unknown. ;;
    #_public
    #_static
    (ยง def #_"int" Block/BLOCK_HEIGHT_UNKNOWN -1)
    ;;; Height of the first block. ;;
    #_public
    #_static
    (ยง def #_"int" Block/BLOCK_HEIGHT_GENESIS 0)

    #_public
    #_static
    (ยง def #_"long" Block/BLOCK_VERSION_GENESIS 1)
    ;;; Block version introduced in BIP 34: Height in coinbase. ;;
    #_public
    #_static
    (ยง def #_"long" Block/BLOCK_VERSION_BIP34 2)
    ;;; Block version introduced in BIP 66: Strict DER signatures. ;;
    #_public
    #_static
    (ยง def #_"long" Block/BLOCK_VERSION_BIP66 3)
    ;;; Block version introduced in BIP 65: OP_CHECKLOCKTIMEVERIFY ;;
    #_public
    #_static
    (ยง def #_"long" Block/BLOCK_VERSION_BIP65 4)

    ;; Fields defined as part of the protocol format.
    #_private
    (ยง field- #_"long" :version)
    #_private
    (ยง field- #_"Sha256Hash" :prev-block-hash)
    #_private
    (ยง field- #_"Sha256Hash" :merkle-root)
    #_private
    (ยง field- #_"long" :time)
    #_private
    (ยง field- #_"long" :difficulty-target) ;; "nBits"
    #_private
    (ยง field- #_"long" :nonce)

    ;; TODO: Get rid of all the direct accesses to this field.  It's a long-since unnecessary holdover from the Dalvik days.
    ;;; If null, it means this object holds only the headers. ;;
    #_nilable
    (ยง field #_"List<Transaction>" :transactions)

    ;;; Stores the hash of the block.  If null, getHash() will recalculate it. ;;
    #_private
    (ยง field- #_"Sha256Hash" :hash)

    #_protected
    (ยง field #_"boolean" :header-bytes-valid)
    #_protected
    (ยง field #_"boolean" :transaction-bytes-valid)

    ;; Blocks can be encoded in a way that will use more bytes than is optimal (due to VarInts having multiple encodings).
    ;; MAX_BLOCK_SIZE must be compared to the optimal encoding, not the actual encoding, so when parsing, we keep track
    ;; of the size of the ideal encoding in addition to the actual message size (which Message needs).
    #_protected
    (ยง field #_"int" :optimal-encoding-message-size)

    ;;; Special case constructor, used for the genesis node, cloneAsHeader and unit tests. ;;
    (ยง constructor Block [#_"NetworkParameters" __params, #_"long" __setVersion]
        (ยง super __params)

        ;; Set up a few basic things.  We are not complete after this though.
        (ยง assoc this :version __setVersion)
        (ยง assoc this :difficulty-target 0x1d07fff8)
        (ยง assoc this :time (/ (System/currentTimeMillis) 1000))
        (ยง assoc this :prev-block-hash Sha256Hash/ZERO_HASH)

        (ยง assoc this :length Block/HEADER_SIZE)
        this
    )

    ;;;
     ; Constructs a block object from the Bitcoin wire format.
     ; @deprecated Use {@link BitcoinSerializer#makeBlock(byte[])} instead.
     ;;
    #_deprecated
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor Block [#_"NetworkParameters" __params, #_"byte[]" __payloadBytes]
        (ยง super __params, __payloadBytes, 0, (.. __params (getDefaultSerializer)), (.. __payloadBytes (alength)))
        this
    )

    ;;;
     ; Construct a block object from the Bitcoin wire format.
     ; @param params NetworkParameters object.
     ; @param payloadBytes The payload to extract the block from.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor Block [#_"NetworkParameters" __params, #_"byte[]" __payloadBytes, #_"MessageSerializer" __serializer, #_"int" __length]
        (ยง super __params, __payloadBytes, 0, __serializer, __length)
        this
    )

    ;;;
     ; Construct a block object from the Bitcoin wire format.
     ; @param params NetworkParameters object.
     ; @param payloadBytes The payload to extract the block from.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor Block [#_"NetworkParameters" __params, #_"byte[]" __payloadBytes, #_"int" __offset, #_"MessageSerializer" __serializer, #_"int" __length]
        (ยง super __params, __payloadBytes, __offset, __serializer, __length)
        this
    )

    ;;;
     ; Construct a block object from the Bitcoin wire format.  Used in the case of a block
     ; contained within another message (i.e. for AuxPoW header).
     ;
     ; @param params NetworkParameters object.
     ; @param payloadBytes Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param parent The message element which contains this block, maybe null for no parent.
     ; @param serializer The serializer to use for this block.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor Block [#_"NetworkParameters" __params, #_"byte[]" __payloadBytes, #_"int" __offset, #_nilable #_"Message" __parent, #_"MessageSerializer" __serializer, #_"int" __length]
        ;; TODO: Keep the parent.
        (ยง super __params, __payloadBytes, __offset, __serializer, __length)
        this
    )

    ;;;
     ; Construct a block initialized with all the given fields.
     ; @param params Which network the block is for.
     ; @param version This should usually be set to 1 or 2, depending on if the height is in the coinbase input.
     ; @param prevBlockHash Reference to previous block in the chain or {@link Sha256Hash#ZERO_HASH} if genesis.
     ; @param merkleRoot The root of the merkle tree formed by the transactions.
     ; @param time UNIX time when the block was mined.
     ; @param difficultyTarget Number which this block hashes lower than.
     ; @param nonce Arbitrary number to make the block hash lower than the target.
     ; @param transactions List of transactions including the coinbase.
     ;;
    #_public
    (ยง constructor Block [#_"NetworkParameters" __params, #_"long" __version, #_"Sha256Hash" __prevBlockHash, #_"Sha256Hash" __merkleRoot, #_"long" __time, #_"long" __difficultyTarget, #_"long" __nonce, #_"List<Transaction>" __transactions]
        (ยง super __params)

        (ยง assoc this :version __version)
        (ยง assoc this :prev-block-hash __prevBlockHash)
        (ยง assoc this :merkle-root __merkleRoot)
        (ยง assoc this :time __time)
        (ยง assoc this :difficulty-target __difficultyTarget)
        (ยง assoc this :nonce __nonce)
        (ยง assoc this :transactions (LinkedList. #_"<>"))
        (.. (:transactions this) (addAll __transactions))
        this
    )

    ;;;
     ; <p>A utility method that calculates how much new Bitcoin would be created by the block at the given height.
     ; The inflation of Bitcoin is predictable and drops roughly every 4 years (210,000 blocks).  At the dawn of
     ; the system it was 50 coins per block, in late 2012 it went to 25 coins per block, and so on.  The size of
     ; a coinbase transaction is inflation plus fees.</p>
     ;
     ; The half-life is controlled by {@link org.bitcoinj.core.NetworkParameters#getSubsidyDecreaseBlockCount()}.
     ;;
    #_public
    (ยง method #_"Coin" getBlockInflation [#_"int" __height]
        (.. Coin/FIFTY_COINS (shiftRight (/ __height (.. (:params this) (getSubsidyDecreaseBlockCount)))))
    )

    ;;;
     ; Parse transactions from the block.
     ;
     ; @param transactionsOffset Offset of the transactions within the block.
     ; Useful for non-Bitcoin chains where the block header may not be a fixed size.
     ;;
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parseTransactions [#_"int" __transactionsOffset]
        (ยง assoc this :cursor __transactionsOffset)
        (ยง assoc this :optimal-encoding-message-size Block/HEADER_SIZE)
        (when (== (.. (:payload this) (alength)) (:cursor this))
            ;; This message is just a header, it has no transactions.
            (ยง assoc this :transaction-bytes-valid false)
            (ยง return nil)
        )

        (let [#_"int" __numTransactions (int (.. this (readVarInt)))]
            (ยง assoc this :optimal-encoding-message-size (+ (:optimal-encoding-message-size this) (VarInt/sizeOf __numTransactions)))
            (ยง assoc this :transactions (ArrayList. #_"<>" __numTransactions))
            (loop-when-recur [#_"int" __i 0] (< __i __numTransactions) [(inc __i)]
                (let [#_"Transaction" __tx (Transaction. (:params this), (:payload this), (:cursor this), this, (:serializer this), Message/UNKNOWN_LENGTH)]
                    ;; Label the transaction as coming from the P2P network, so code that cares where we first saw it knows.
                    (.. __tx (getConfidence) (setSource TransactionConfidence.Source/NETWORK))
                    (.. (:transactions this) (add __tx))
                    (ยง assoc this :cursor (+ (:cursor this) (.. __tx (getMessageSize))))
                    (ยง assoc this :optimal-encoding-message-size (+ (:optimal-encoding-message-size this) (.. __tx (getOptimalEncodingMessageSize))))
                )
            )
            (ยง assoc this :transaction-bytes-valid (.. (:serializer this) (isParseRetainMode)))
            nil
        )
    )

    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        ;; header
        (ยง assoc this :cursor (:offset this))
        (ยง assoc this :version (.. this (readUint32)))
        (ยง assoc this :prev-block-hash (.. this (readHash)))
        (ยง assoc this :merkle-root (.. this (readHash)))
        (ยง assoc this :time (.. this (readUint32)))
        (ยง assoc this :difficulty-target (.. this (readUint32)))
        (ยง assoc this :nonce (.. this (readUint32)))
        (ยง assoc this :hash (Sha256Hash/wrapReversed (Sha256Hash/hashTwice (:payload this), (:offset this), (- (:cursor this) (:offset this)))))
        (ยง assoc this :header-bytes-valid (.. (:serializer this) (isParseRetainMode)))

        ;; transactions
        (.. this (parseTransactions (+ (:offset this) Block/HEADER_SIZE)))
        (ยง assoc this :length (- (:cursor this) (:offset this)))
        nil
    )

    #_public
    (ยง method #_"int" getOptimalEncodingMessageSize []
        (when (!= (:optimal-encoding-message-size this) 0)
            (ยง return (:optimal-encoding-message-size this))
        )
        (ยง assoc this :optimal-encoding-message-size (.. this (bitcoinSerialize) (alength)))
        (:optimal-encoding-message-size this)
    )

    ;; default for testing
    #_throws #_[ "IOException" ]
    (ยง method #_"void" writeHeader [#_"OutputStream" __stream]
        ;; try for cached write first
        (when (and (:header-bytes-valid this) (some? (:payload this)) (<= (+ (:offset this) Block/HEADER_SIZE) (.. (:payload this) (alength))))
            (.. __stream (write (:payload this), (:offset this), Block/HEADER_SIZE))
            (ยง return nil)
        )

        ;; fall back to manual write
        (Utils/uint32ToByteStreamLE (:version this), __stream)
        (.. __stream (write (.. (:prev-block-hash this) (getReversedBytes))))
        (.. __stream (write (.. this (getMerkleRoot) (getReversedBytes))))
        (Utils/uint32ToByteStreamLE (:time this), __stream)
        (Utils/uint32ToByteStreamLE (:difficulty-target this), __stream)
        (Utils/uint32ToByteStreamLE (:nonce this), __stream)
        nil
    )

    #_private
    #_throws #_[ "IOException" ]
    (ยง method- #_"void" writeTransactions [#_"OutputStream" __stream]
        ;; check for no transaction conditions first
        (when (nil? (:transactions this))
            (ยง return nil)
        )

        ;; confirmed we must have transactions either cached or as objects
        (when (and (:transaction-bytes-valid this) (some? (:payload this)) (<= (+ (:offset this) (:length this)) (.. (:payload this) (alength))))
            (.. __stream (write (:payload this), (+ (:offset this) Block/HEADER_SIZE), (- (:length this) Block/HEADER_SIZE)))
            (ยง return nil)
        )

        (when (some? (:transactions this))
            (.. __stream (write (.. (VarInt. (.. (:transactions this) (size))) (encode))))
            (doseq [#_"Transaction" __tx (:transactions this)]
                (.. __tx (bitcoinSerialize __stream))
            )
        )
        nil
    )

    ;;;
     ; Special handling to check if we have a valid byte array for both header and transactions.
     ;
     ; @throws IOException
     ;;
    #_override
    #_public
    (ยง method #_"byte[]" bitcoinSerialize []
        ;; we have completely cached byte array
        (when (and (:header-bytes-valid this) (:transaction-bytes-valid this))
            (Preconditions/checkNotNull (:payload this), "Bytes should never be nil if headerBytesValid && transactionBytesValid")
            (when (== (:length this) (.. (:payload this) (alength)))
                (ยง return (:payload this))
            )

            ;; byte array is offset, so copy out the correct range
            (let [#_"byte[]" __buf (byte-array (:length this))]
                (System/arraycopy (:payload this), (:offset this), __buf, 0, (:length this))
                (ยง return __buf)
            )
        )

        ;; At least one of the two cacheable components is invalid, so fall back to stream write since we can't be sure of the length.
        (let [#_"ByteArrayOutputStream" __stream (ByteArrayOutputStream. (if (== (:length this) Message/UNKNOWN_LENGTH) (+ Block/HEADER_SIZE (.. this (guessTransactionsLength))) (:length this)))]
            (try
                (.. this (writeHeader __stream))
                (.. this (writeTransactions __stream))
                (catch IOException __e
                    ;; Cannot happen, we are serializing to a memory stream.
                )
            )
            (.. __stream (toByteArray))
        )
    )

    #_override
    #_protected
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __stream]
        (.. this (writeHeader __stream))
        ;; We may only have enough data to write the header.
        (.. this (writeTransactions __stream))
        nil
    )

    ;;;
     ; Provides a reasonable guess at the byte length of the transactions part of the block.
     ; The returned value will be accurate in 99% of cases and in those cases where not will probably slightly oversize.
     ;
     ; This is used to preallocate the underlying byte array for a ByteArrayOutputStream.  If the size is under the
     ; real value the only penalty is resizing of the underlying byte array.
     ;;
    #_private
    (ยง method- #_"int" guessTransactionsLength []
        (when (:transaction-bytes-valid this)
            (ยง return (- (.. (:payload this) (alength)) Block/HEADER_SIZE))
        )
        (when (nil? (:transactions this))
            (ยง return 0)
        )
        (let [#_"int" __len (VarInt/sizeOf (.. (:transactions this) (size)))]
            (doseq [#_"Transaction" __tx (:transactions this)]
                ;; 255 is just a guess at an average tx length
                (ยง ass __len (+ __len (if (== (:length __tx) Message/UNKNOWN_LENGTH) 255 (:length __tx))))
            )
            __len
        )
    )

    #_override
    #_protected
    (ยง method #_"void" unCache []
        ;; Since we have alternate uncache methods to use internally, this will only ever be called by a child
        ;; transaction, so we only need to invalidate that part of the cache.
        (.. this (unCacheTransactions))
        nil
    )

    #_private
    (ยง method- #_"void" unCacheHeader []
        (ยง assoc this :header-bytes-valid false)
        (when (not (:transaction-bytes-valid this))
            (ยง assoc this :payload nil)
        )
        (ยง assoc this :hash nil)
        nil
    )

    #_private
    (ยง method- #_"void" unCacheTransactions []
        (ยง assoc this :transaction-bytes-valid false)
        (when (not (:header-bytes-valid this))
            (ยง assoc this :payload nil)
        )
        ;; Current implementation has to uncache headers as well as any change to a tx will alter the merkle root.
        ;; In future, we can go more granular and cache merkle root separately so rest of the header does not need to be rewritten.
        (.. this (unCacheHeader))
        ;; Clear merkleRoot last as it may end up being parsed during unCacheHeader().
        (ยง assoc this :merkle-root nil)
        nil
    )

    ;;;
     ; Calculates the block hash by serializing the block and hashing the resulting bytes.
     ;;
    #_private
    (ยง method- #_"Sha256Hash" calculateHash []
        (try
            (let [#_"ByteArrayOutputStream" __bos (ByteArrayOutputStream. Block/HEADER_SIZE)]
                (.. this (writeHeader __bos))
                (ยง return (Sha256Hash/wrapReversed (Sha256Hash/hashTwice (.. __bos (toByteArray)))))
            )
            (catch IOException __e
                (throw (RuntimeException. __e)) ;; Cannot happen.
            )
        )
    )

    ;;;
     ; Returns the hash of the block (which for a valid, solved block should be below the target) in the form seen on
     ; the block explorer.  If you call this on block 1 in the mainnet chain,
     ; you will get "00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048".
     ;;
    #_public
    (ยง method #_"String" getHashAsString []
        (.. this (getHash) (toString))
    )

    ;;;
     ; Returns the hash of the block (which for a valid, solved block should be
     ; below the target).  Big endian.
     ;;
    #_override
    #_public
    (ยง method #_"Sha256Hash" getHash []
        (when (nil? (:hash this))
            (ยง assoc this :hash (.. this (calculateHash)))
        )
        (:hash this)
    )

    ;;;
     ; The number that is one greater than the largest representable SHA-256 hash.
     ;;
    #_private
    #_static
    (ยง def- #_"BigInteger" Block/LARGEST_HASH (.. BigInteger/ONE (shiftLeft 256)))

    ;;;
     ; Returns the work represented by this block.
     ;
     ; Work is defined as the number of tries needed to solve a block in the
     ; average case.  Consider a difficulty target that covers 5% of all possible
     ; hash values.  Then the work of the block will be 20.  As the target gets
     ; lower, the amount of work goes up.
     ;;
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"BigInteger" getWork []
        (let [#_"BigInteger" __target (.. this (getDifficultyTargetAsInteger))]
            (.. Block/LARGEST_HASH (divide (.. __target (add BigInteger/ONE))))
        )
    )

    ;;; Returns a copy of the block, but without any transactions. ;;
    #_public
    (ยง method #_"Block" cloneAsHeader []
        (let [#_"Block" __block (Block. (:params this), Block/BLOCK_VERSION_GENESIS)]
            (.. this (copyBitcoinHeaderTo __block))
            __block
        )
    )

    ;;; Copy the block without transactions into the provided empty block. ;;
    #_protected
    (ยง method #_"void" copyBitcoinHeaderTo [#_"Block" __block]
        (ยง assoc __block :nonce (:nonce this))
        (ยง assoc __block :prev-block-hash (:prev-block-hash this))
        (ยง assoc __block :merkle-root (.. this (getMerkleRoot)))
        (ยง assoc __block :version (:version this))
        (ยง assoc __block :time (:time this))
        (ยง assoc __block :difficulty-target (:difficulty-target this))
        (ยง assoc __block :transactions nil)
        (ยง assoc __block :hash (.. this (getHash)))
        nil
    )

    ;;;
     ; Returns a multi-line string containing a description of the contents of the block.
     ; Use for debugging purposes only.
     ;;
    #_override
    #_public
    (ยง method #_"String" toString []
        (let [#_"StringBuilder" __sb (StringBuilder.)]
            (.. __sb (append " block: \n"))
            (.. __sb (append "   hash: ") (append (.. this (getHashAsString))) (append "\n"))
            (.. __sb (append "   version: ") (append (:version this)))
            (let [#_"String" __bips (.. (Joiner/on ", ") (skipNulls) (join (when (.. this (isBIP34)) "BIP34"), (when (.. this (isBIP66)) "BIP66"), (when (.. this (isBIP65)) "BIP65")))]
                (when (not (.. __bips (isEmpty)))
                    (.. __sb (append " (") (append __bips) (append ")"))
                )
                (.. __sb (append "\n"))
                (.. __sb (append "   previous block: ") (append (.. this (getPrevBlockHash))) (append "\n"))
                (.. __sb (append "   merkle root: ") (append (.. this (getMerkleRoot))) (append "\n"))
                (.. __sb (append "   time: ") (append (:time this)) (append " (") (append (Utils/dateTimeFormat (* (:time this) 1000))) (append ")\n"))
                (.. __sb (append "   difficulty target (nBits): ") (append (:difficulty-target this)) (append "\n"))
                (.. __sb (append "   nonce: ") (append (:nonce this)) (append "\n"))
                (when (and (some? (:transactions this)) (< 0 (.. (:transactions this) (size))))
                    (.. __sb (append "   with ") (append (.. (:transactions this) (size))) (append " transaction(s):\n"))
                    (doseq [#_"Transaction" __tx (:transactions this)]
                        (.. __sb (append __tx))
                    )
                )
                (.. __sb (toString))
            )
        )
    )

    ;;;
     ; <p>Finds a value of nonce that makes the blocks hash lower than the difficulty target.  This is called mining,
     ; but solve() is far too slow to do real mining with.  It exists only for unit testing purposes.
     ;
     ; <p>This can loop forever if a solution cannot be found solely by incrementing nonce.  It doesn't change
     ; extraNonce.</p>
     ;;
    #_public
    (ยง method #_"void" solve []
        (loop []
            (try
                ;; Is our proof of work valid yet?
                (when (.. this (checkProofOfWork false))
                    (ยง return nil)
                )
                ;; No, so increment the nonce and try again.
                (.. this (setNonce (inc (.. this (getNonce)))))
                (catch VerificationException __e
                    (throw (RuntimeException. __e)) ;; Cannot happen.
                )
            )
        )
        nil
    )

    ;;;
     ; Returns the difficulty target as a 256 bit value that can be compared to a SHA-256 hash.  Inside a block the
     ; target is represented using a compact form.  If this form decodes to a value that is out of bounds, an exception
     ; is thrown.
     ;;
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"BigInteger" getDifficultyTargetAsInteger []
        (let [#_"BigInteger" __target (Utils/decodeCompactBits (:difficulty-target this))]
            (when (or (<= (.. __target (signum)) 0) (< 0 (.. __target (compareTo (-> this :params :max-target)))))
                (throw (VerificationException. (str "Difficulty target is bad: " __target)))
            )
            __target
        )
    )

    ;;; Returns true if the hash of the block is OK (lower than difficulty target). ;;
    #_protected
    #_throws #_[ "VerificationException" ]
    (ยง method #_"boolean" checkProofOfWork [#_"boolean" __throwException]
        ;; This part is key - it is what proves the block was as difficult to make as it claims
        ;; to be.  Note however that in the context of this function, the block can claim to be
        ;; as difficult as it wants to be .... if somebody was able to take control of our network
        ;; connection and fork us onto a different chain, they could send us valid blocks with
        ;; ridiculously easy difficulty and this function would accept them.
        ;;
        ;; To prevent this attack from being possible, elsewhere we check that the difficultyTarget
        ;; field is of the right value.  This requires us to have the preceeding blocks.
        (let [#_"BigInteger" __target (.. this (getDifficultyTargetAsInteger))]

            (let [#_"BigInteger" __h (.. this (getHash) (toBigInteger))]
                (when (< 0 (.. __h (compareTo __target)))
                    ;; Proof of work check failed!
                    (if __throwException
                        (throw (VerificationException. (str "Hash is higher than target: " (.. this (getHashAsString)) " vs " (.. __target (toString 16)))))
                        (ยง return false)
                    )
                )
                true
            )
        )
    )

    #_private
    #_throws #_[ "VerificationException" ]
    (ยง method- #_"void" checkTimestamp []
        (let [#_"long" __allowedTime (+ (Utils/currentTimeSeconds) Block/ALLOWED_TIME_DRIFT)]
            (when (< __allowedTime (:time this))
                (throw (VerificationException. (String/format Locale/US, "Block too far in future: %s (%d) vs allowed %s (%d)", (Utils/dateTimeFormat (* (:time this) 1000)), (:time this), (Utils/dateTimeFormat (* __allowedTime 1000)), __allowedTime)))
            )
            nil
        )
    )

    #_private
    #_throws #_[ "VerificationException" ]
    (ยง method- #_"void" checkSigOps []
        ;; Check there aren't too many signature verifications in the block.  This is an anti-DoS measure, see the
        ;; comments for MAX_BLOCK_SIGOPS.
        (let [#_"int" __sigOps 0]
            (doseq [#_"Transaction" __tx (:transactions this)]
                (ยง ass __sigOps (+ __sigOps (.. __tx (getSigOpCount))))
            )

            (when (< Block/MAX_BLOCK_SIGOPS __sigOps)
                (throw (VerificationException. "Block had too many Signature Operations"))
            )
            nil
        )
    )

    #_private
    #_throws #_[ "VerificationException" ]
    (ยง method- #_"void" checkMerkleRoot []
        (let [#_"Sha256Hash" __calculatedRoot (.. this (calculateMerkleRoot))]
            (when (not (.. __calculatedRoot (equals (:merkle-root this))))
                (.. Block/log (error "Merkle tree did not verify"))
                (throw (VerificationException. (str "Merkle hashes do not match: " __calculatedRoot " vs " (:merkle-root this))))
            )
            nil
        )
    )

    #_private
    (ยง method- #_"Sha256Hash" calculateMerkleRoot []
        (let [#_"List<byte[]>" __tree (.. this (buildMerkleTree))]
            (Sha256Hash/wrap (.. __tree (get (dec (.. __tree (size))))))
        )
    )

    #_private
    (ยง method- #_"List<byte[]>" buildMerkleTree []
        ;; The Merkle root is based on a tree of hashes calculated from the transactions:
        ;;
        ;;     root
        ;;     /  \
        ;;   A      B
        ;;  / \    / \
        ;; t1 t2  t3 t4
        ;;
        ;; The tree is represented as a list: (t1 t2 t3 t4 A B root), where each entry is a hash.
        ;;
        ;; The hashing algorithm is double SHA-256.  The leaves are a hash of the serialized contents of the transaction.
        ;; The interior nodes are hashes of the concenation of the two child hashes.
        ;;
        ;; This structure allows the creation of proof that a transaction was included into a block without having to
        ;; provide the full block contents.  Instead, you can provide only a Merkle branch.  For example to prove tx2 was
        ;; in a block you can just provide tx2, the hash(tx1) and B.  Now the other party has everything they need to
        ;; derive the root, which can be checked against the block header.  These proofs aren't used right now but
        ;; will be helpful later when we want to download partial block contents.
        ;;
        ;; Note that if the number of transactions is not even, the last tx is repeated to make it so (see tx3 above).
        ;; A tree with 5 transactions would look like this:
        ;;
        ;;          root
        ;;        /      \
        ;;      1          5
        ;;    /   \       / \
        ;;   2     3     4   4
        ;;  / \   / \   / \
        ;; t1 t2 t3 t4 t5 t5
        (let [#_"ArrayList<byte[]>" __tree (ArrayList. #_"<>")]
            ;; Start by adding all the hashes of the transactions as leaves of the tree.
            (doseq [#_"Transaction" __t (:transactions this)]
                (.. __tree (add (.. __t (getHash) (getBytes))))
            )

            ;; Offset in the list where the currently processed level starts.
            (let [#_"int" __levelOffset 0]
                ;; Step through each level, stopping when we reach the root (levelSize == 1).
                (loop-when-recur [#_"int" __levelSize (.. (:transactions this) (size))] (< 1 __levelSize) [(/ (inc __levelSize) 2)]
                    ;; For each pair of nodes on that level:
                    (loop-when-recur [#_"int" __left 0] (< __left __levelSize) [(+ __left 2)]
                        ;; The right hand node can be the same as the left hand, in the case where we don't have enough transactions.
                        (let [#_"int" __right (Math/min (inc __left), (dec __levelSize))
                              #_"byte[]" __leftBytes (Utils/reverseBytes (.. __tree (get (+ __levelOffset __left))))
                              #_"byte[]" __rightBytes (Utils/reverseBytes (.. __tree (get (+ __levelOffset __right))))]
                            (.. __tree (add (Utils/reverseBytes (Sha256Hash/hashTwice __leftBytes, 0, 32, __rightBytes, 0, 32))))
                        )
                    )
                    ;; Move to the next level.
                    (ยง ass __levelOffset (+ __levelOffset __levelSize))
                )
                __tree
            )
        )
    )

    ;;;
     ; Verify the transactions on a block.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;               If provided, used to validate the coinbase input script of v2 and above blocks.
     ; @throws VerificationException if there was an error verifying the block.
     ;;
    #_private
    #_throws #_[ "VerificationException" ]
    (ยง method- #_"void" checkTransactions [#_"int" __height, #_"EnumSet<Block.VerifyFlag>" __flags]
        ;; The first transaction in a block must always be a coinbase transaction.
        (when (not (.. (:transactions this) (get 0) (isCoinBase)))
            (throw (VerificationException. "First tx is not coinbase"))
        )

        (when (and (.. __flags (contains Block.VerifyFlag/HEIGHT_IN_COINBASE)) (<= Block/BLOCK_HEIGHT_GENESIS __height))
            (.. (:transactions this) (get 0) (checkCoinBaseHeight __height))
        )

        ;; The rest must not be.
        (loop-when-recur [#_"int" __i 1] (< __i (.. (:transactions this) (size))) [(inc __i)]
            (when (.. (:transactions this) (get __i) (isCoinBase))
                (throw (VerificationException. (str "TX " __i " is coinbase when it should not be.")))
            )
        )
        nil
    )

    ;;;
     ; Checks the block data to ensure it follows the rules laid out in the network parameters.  Specifically,
     ; throws an exception if the proof of work is invalid, or if the timestamp is too far from what it should be.
     ; This is <b>not</b> everything that is required for a block to be valid, only what is checkable independent
     ; of the chain and without a transaction index.
     ;
     ; @throws VerificationException
     ;;
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"void" verifyHeader []
        ;; Prove that this block is OK.  It might seem that we can just ignore most of these checks given that the
        ;; network is also verifying the blocks, but we cannot as it'd open us to a variety of obscure attacks.
        ;;
        ;; Firstly we need to ensure this block does in fact represent real work done.  If the difficulty is high
        ;; enough, it's probably been done by the network.
        (.. this (checkProofOfWork true))
        (.. this (checkTimestamp))
        nil
    )

    ;;;
     ; Checks the block contents.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;               If valid, used to validate the coinbase input script of v2 and above blocks.
     ; @param flags Flags to indicate which tests should be applied (i.e. whether to test for height in the coinbase transaction).
     ; @throws VerificationException if there was an error verifying the block.
     ;;
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"void" verifyTransactions [#_"int" __height, #_"EnumSet<Block.VerifyFlag>" __flags]
        ;; Now we need to check that the body of the block actually matches the headers.  The network won't generate
        ;; an invalid block, but if we didn't validate this then an untrusted man-in-the-middle could obtain the next
        ;; valid block from the network and simply replace the transactions in it with their own fictional
        ;; transactions that reference spent or non-existant inputs.
        (when (.. (:transactions this) (isEmpty))
            (throw (VerificationException. "Block had no transactions"))
        )
        (when (< Block/MAX_BLOCK_SIZE (.. this (getOptimalEncodingMessageSize)))
            (throw (VerificationException. "Block larger than MAX_BLOCK_SIZE"))
        )
        (.. this (checkTransactions __height, __flags))
        (.. this (checkMerkleRoot))
        (.. this (checkSigOps))
        (doseq [#_"Transaction" __transaction (:transactions this)]
            (.. __transaction (verify))
        )
        nil
    )

    ;;;
     ; Verifies both the header and that the transactions hash to the merkle root.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ; @param flags Flags to indicate which tests should be applied (i.e. whether to test for height in the coinbase transaction).
     ; @throws VerificationException if there was an error verifying the block.
     ;;
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"void" verify [#_"int" __height, #_"EnumSet<Block.VerifyFlag>" __flags]
        (.. this (verifyHeader))
        (.. this (verifyTransactions __height, __flags))
        nil
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (.. this (getHash) (equals (.. (cast Block __o) (getHash))))
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (.. this (getHash) (hashCode))
    )

    ;;;
     ; Returns the merkle root in big endian form, calculating it from transactions if necessary.
     ;;
    #_public
    (ยง method #_"Sha256Hash" getMerkleRoot []
        (when (nil? (:merkle-root this))
            ;; TODO: Check if this is really necessary.
            (.. this (unCacheHeader))
            (ยง assoc this :merkle-root (.. this (calculateMerkleRoot)))
        )
        (:merkle-root this)
    )

    ;;; Exists only for unit testing. ;;
    (ยง method #_"void" setMerkleRoot [#_"Sha256Hash" __value]
        (.. this (unCacheHeader))
        (ยง assoc this :merkle-root __value)
        (ยง assoc this :hash nil)
        nil
    )

    ;;; Adds a transaction to this block.  The nonce and merkle root are invalid after this. ;;
    #_public
    (ยง method #_"void" addTransaction [#_"Transaction" __t]
        (.. this (addTransaction __t, true))
        nil
    )

    ;;; Adds a transaction to this block, with or without checking the sanity of doing so. ;;
    (ยง method #_"void" addTransaction [#_"Transaction" __t, #_"boolean" __runSanityChecks]
        (.. this (unCacheTransactions))
        (when (nil? (:transactions this))
            (ยง assoc this :transactions (ArrayList. #_"<>"))
        )
        (.. __t (setParent this))
        (when (and __runSanityChecks (== (.. (:transactions this) (size)) 0) (not (.. __t (isCoinBase))))
            (throw (RuntimeException. (str "Attempted to add a non-coinbase transaction as the first transaction: " __t)))
        )
        (when (and __runSanityChecks (< 0 (.. (:transactions this) (size))) (.. __t (isCoinBase)))
            (throw (RuntimeException. (str "Attempted to add a coinbase transaction when there already is one: " __t)))
        )
        (.. (:transactions this) (add __t))
        (.. this (adjustLength (.. (:transactions this) (size)), (:length __t)))
        ;; Force a recalculation next time the values are needed.
        (ยง assoc this :merkle-root nil)
        (ยง assoc this :hash nil)
        nil
    )

    ;;;
     ; Returns the version of the block data structure as defined by the Bitcoin protocol.
     ;;
    #_public
    (ยง method #_"long" getVersion []
        (:version this)
    )

    ;;;
     ; Returns the hash of the previous block in the chain, as defined by the block header.
     ;;
    #_public
    (ยง method #_"Sha256Hash" getPrevBlockHash []
        (:prev-block-hash this)
    )

    (ยง method #_"void" setPrevBlockHash [#_"Sha256Hash" __prevBlockHash]
        (.. this (unCacheHeader))
        (ยง assoc this :prev-block-hash __prevBlockHash)
        (ยง assoc this :hash nil)
        nil
    )

    ;;;
     ; Returns the time at which the block was solved and broadcast, according to the clock of the solving node.
     ; This is measured in seconds since the UNIX epoch (midnight Jan 1st 1970).
     ;;
    #_public
    (ยง method #_"long" getTimeSeconds []
        (:time this)
    )

    ;;;
     ; Returns the time at which the block was solved and broadcast, according to the clock of the solving node.
     ;;
    #_public
    (ยง method #_"Date" getTime []
        (Date. (* (.. this (getTimeSeconds)) 1000))
    )

    #_public
    (ยง method #_"void" setTime [#_"long" __time]
        (.. this (unCacheHeader))
        (ยง assoc this :time __time)
        (ยง assoc this :hash nil)
        nil
    )

    ;;;
     ; Returns the difficulty of the proof of work that this block should meet encoded <b>in compact form</b>.
     ; The {@link BlockChain} verifies that this is not too easy by looking at the length of the chain when the block is added.
     ; To find the actual value the hash should be compared against, use {@link org.bitcoinj.core.Block#getDifficultyTargetAsInteger()}.
     ; Note that this is <b>not</b> the same as the difficulty value reported by the Bitcoin "getdifficulty" RPC that you may see on various block explorers.
     ; That number is the result of applying a formula to the underlying difficulty to normalize the minimum to 1.
     ; Calculating the difficulty that way is currently unsupported.
     ;;
    #_public
    (ยง method #_"long" getDifficultyTarget []
        (:difficulty-target this)
    )

    ;;; Sets the difficulty target in compact form. ;;
    #_public
    (ยง method #_"void" setDifficultyTarget [#_"long" __compactForm]
        (.. this (unCacheHeader))
        (ยง assoc this :difficulty-target __compactForm)
        (ยง assoc this :hash nil)
        nil
    )

    ;;;
     ; Returns the nonce, an arbitrary value that exists only to make the hash of the block header fall below the difficulty target.
     ;;
    #_public
    (ยง method #_"long" getNonce []
        (:nonce this)
    )

    ;;;
     ; Sets the nonce and clears any cached data.
     ;;
    #_public
    (ยง method #_"void" setNonce [#_"long" __nonce]
        (.. this (unCacheHeader))
        (ยง assoc this :nonce __nonce)
        (ยง assoc this :hash nil)
        nil
    )

    ;;; Returns an immutable list of transactions held in this block, or null if this object represents just a header. ;;
    #_nilable
    #_public
    (ยง method #_"List<Transaction>" getTransactions []
        (when (some? (:transactions this)) (ImmutableList/copyOf (:transactions this)))
    )

    ;; Used to make transactions unique.
    #_private
    #_static
    (ยง def- #_"int" Block/TX_COUNTER)

    ;;; Adds a coinbase transaction to the block.  This exists for unit tests.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;;
    #_testing
    (ยง method #_"void" addCoinbaseTransaction [#_"byte[]" __pubKeyTo, #_"Coin" __value, #_"int" __height]
        (.. this (unCacheTransactions))
        (ยง assoc this :transactions (ArrayList. #_"<>"))
        (let [#_"Transaction" __coinbase (Transaction. (:params this))
              #_"ScriptBuilder" __inputBuilder (ScriptBuilder.)]

            (when (<= Block/BLOCK_HEIGHT_GENESIS __height)
                (.. __inputBuilder (number __height))
            )
            (.. __inputBuilder (data (byte-array [ (byte Block/TX_COUNTER), (byte (>> Block/TX_COUNTER 8)) ])))
            (ยง ass Block/TX_COUNTER (inc Block/TX_COUNTER))

            ;; A real coinbase transaction has some stuff in the scriptSig like the extraNonce and difficulty.
            ;; The transactions are distinguished by every TX output going to a different key.
            ;;
            ;; Here we will do things a bit differently so a new address isn't needed every time.
            ;; We'll put a simple counter in the scriptSig, so every transaction has a different hash.
            (.. __coinbase (addInput (TransactionInput. (:params this), __coinbase, (.. __inputBuilder (build) (getProgram)))))
            (.. __coinbase (addOutput (TransactionOutput. (:params this), __coinbase, __value, (.. (ScriptBuilder/createOutputScript (ECKey/fromPublicOnly __pubKeyTo)) (getProgram)))))
            (.. (:transactions this) (add __coinbase))
            (.. __coinbase (setParent this))
            (ยง assoc __coinbase :length (.. __coinbase (unsafeBitcoinSerialize) (alength)))
            (.. this (adjustLength (.. (:transactions this) (size)), (:length __coinbase)))
            nil
        )
    )

    #_static
    (ยง def #_"byte[]" Block/EMPTY_BYTES (byte-array 32))

    ;; It's pretty weak to have this around at runtime: fix later.
    #_private
    #_static
    (ยง def- #_"byte[]" Block/PUBKEY_FOR_TESTING (.. (ECKey.) (getPubKey)))

    ;;;
     ; Returns a solved block that builds on top of this one.  This exists for unit tests.
     ;;
    #_testing
    #_public
    (ยง method #_"Block" createNextBlock [#_"Address" __to, #_"long" __version, #_"long" __time, #_"int" __blockHeight]
        (.. this (createNextBlock __to, __version, nil, __time, Block/PUBKEY_FOR_TESTING, Coin/FIFTY_COINS, __blockHeight))
    )

    ;;;
     ; Returns a solved block that builds on top of this one.  This exists for unit tests.
     ; In this variant you can specify a public key (pubkey) for use in generating coinbase blocks.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;;
    (ยง method #_"Block" createNextBlock [#_nilable #_"Address" __to, #_"long" __version, #_nilable #_"TransactionOutPoint" __prevOut, #_"long" __time, #_"byte[]" __pubKey, #_"Coin" __coinbaseValue, #_"int" __height]
        (let [#_"Block" __b (Block. (:params this), __version)]
            (.. __b (setDifficultyTarget (:difficulty-target this)))
            (.. __b (addCoinbaseTransaction __pubKey, __coinbaseValue, __height))

            (when (some? __to)
                ;; Add a transaction paying 50 coins to the "to" address.
                (let [#_"Transaction" __t (Transaction. (:params this))]
                    (.. __t (addOutput (TransactionOutput. (:params this), __t, Coin/FIFTY_COINS, __to)))
                    ;; The input does not really need to be a valid signature, as long as it has the right general form.
                    (let [#_"TransactionInput" __input]
                        (cond (nil? __prevOut)
                            (do
                                (ยง ass __input (TransactionInput. (:params this), __t, (Script/createInputScript Block/EMPTY_BYTES, Block/EMPTY_BYTES)))
                                ;; Importantly, the outpoint hash cannot be zero as that's how we detect a coinbase transaction in isolation,
                                ;; but it must be unique to avoid 'different' transactions looking the same.
                                (let [#_"byte[]" __counter (byte-array 32)]
                                    (aset __counter 0 (byte Block/TX_COUNTER))
                                    (aset __counter 1 (byte (>> Block/TX_COUNTER 8)))
                                    (ยง ass Block/TX_COUNTER (inc Block/TX_COUNTER))
                                    (.. __input (getOutpoint) (setHash (Sha256Hash/wrap __counter)))
                                )
                            )
                            :else
                            (do
                                (ยง ass __input (TransactionInput. (:params this), __t, (Script/createInputScript Block/EMPTY_BYTES, Block/EMPTY_BYTES), __prevOut))
                            )
                        )
                        (.. __t (addInput __input))
                        (.. __b (addTransaction __t))
                    )
                )
            )

            (.. __b (setPrevBlockHash (.. this (getHash))))
            ;; Don't let timestamp go backwards.
            (if (<= __time (.. this (getTimeSeconds)))
                (.. __b (setTime (inc (.. this (getTimeSeconds)))))
                (.. __b (setTime __time))
            )
            (.. __b (solve))
            (try
                (.. __b (verifyHeader))
                (catch VerificationException __e
                    (throw (RuntimeException. __e)) ;; Cannot happen.
                )
            )
            (when (!= (.. __b (getVersion)) __version)
                (throw (RuntimeException.))
            )
            __b
        )
    )

    #_testing
    #_public
    (ยง method #_"Block" createNextBlock [#_nilable #_"Address" __to, #_"TransactionOutPoint" __prevOut]
        (.. this (createNextBlock __to, Block/BLOCK_VERSION_GENESIS, __prevOut, (+ (.. this (getTimeSeconds)) 5), Block/PUBKEY_FOR_TESTING, Coin/FIFTY_COINS, Block/BLOCK_HEIGHT_UNKNOWN))
    )

    #_testing
    #_public
    (ยง method #_"Block" createNextBlock [#_nilable #_"Address" __to, #_"Coin" __value]
        (.. this (createNextBlock __to, Block/BLOCK_VERSION_GENESIS, nil, (+ (.. this (getTimeSeconds)) 5), Block/PUBKEY_FOR_TESTING, __value, Block/BLOCK_HEIGHT_UNKNOWN))
    )

    #_testing
    #_public
    (ยง method #_"Block" createNextBlock [#_nilable #_"Address" __to]
        (.. this (createNextBlock __to, Coin/FIFTY_COINS))
    )

    #_testing
    #_public
    (ยง method #_"Block" createNextBlockWithCoinbase [#_"long" __version, #_"byte[]" __pubKey, #_"Coin" __coinbaseValue, #_"int" __height]
        (.. this (createNextBlock nil, __version, (cast TransactionOutPoint nil), (Utils/currentTimeSeconds), __pubKey, __coinbaseValue, __height))
    )

    ;;;
     ; Create a block sending 50BTC as a coinbase transaction to the public key specified.
     ; This method is intended for test use only.
     ;;
    #_testing
    (ยง method #_"Block" createNextBlockWithCoinbase [#_"long" __version, #_"byte[]" __pubKey, #_"int" __height]
        (.. this (createNextBlock nil, __version, (cast TransactionOutPoint nil), (Utils/currentTimeSeconds), __pubKey, Coin/FIFTY_COINS, __height))
    )

    #_testing
    (ยง method #_"boolean" isHeaderBytesValid []
        (:header-bytes-valid this)
    )

    #_testing
    (ยง method #_"boolean" isTransactionBytesValid []
        (:transaction-bytes-valid this)
    )

    ;;;
     ; Return whether this block contains any transactions.
     ;
     ; @return true if the block contains transactions, false otherwise (is purely a header).
     ;;
    #_public
    (ยง method #_"boolean" hasTransactions []
        (not (.. (:transactions this) (isEmpty)))
    )

    ;;;
     ; Returns whether this block conforms to
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki">BIP34: Height in Coinbase</a>.
     ;;
    #_public
    (ยง method #_"boolean" isBIP34 []
        (<= Block/BLOCK_VERSION_BIP34 (:version this))
    )

    ;;;
     ; Returns whether this block conforms to
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki">BIP66: Strict DER signatures</a>.
     ;;
    #_public
    (ยง method #_"boolean" isBIP66 []
        (<= Block/BLOCK_VERSION_BIP66 (:version this))
    )

    ;;;
     ; Returns whether this block conforms to
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki">BIP65: OP_CHECKLOCKTIMEVERIFY</a>.
     ;;
    #_public
    (ยง method #_"boolean" isBIP65 []
        (<= Block/BLOCK_VERSION_BIP65 (:version this))
    )
)

;; TODO: Rename this class to SPVBlockChain at some point.

;;;
 ; A BlockChain implements the <i>simplified payment verification</i> mode of the Bitcoin protocol.  It is the right
 ; choice to use for programs that have limited resources as it won't verify transactions signatures or attempt to store
 ; all of the block chain.  Really, this class should be called SPVBlockChain but for backwards compatibility it is not.
 ;;
#_public
(ยง class BlockChain (ยง extends AbstractBlockChain)
    ;;; Keeps a map of block hashes to StoredBlocks. ;;
    #_protected
    (ยง field #_"BlockStore" :block-store)

    ;;;
     ; <p>Constructs a BlockChain connected to the given wallet and store.  To obtain a {@link Wallet} you can construct
     ; one from scratch, or you can deserialize a saved wallet from disk using {@link Wallet#loadFromFile(java.io.File)}.</p>
     ;
     ; <p>For the store, you should use {@link org.bitcoinj.store.SPVBlockStore} or you could also try a
     ; {@link org.bitcoinj.store.MemoryBlockStore} if you want to hold all headers in RAM and don't care about
     ; disk serialization (this is rare).</p>
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor BlockChain [#_"Context" __context, #_"Wallet" __wallet, #_"BlockStore" __blockStore]
        (ยง this __context, (ArrayList. #_"<Wallet>"), __blockStore)
        (.. this (addWallet __wallet))
        this
    )

    ;;; See {@link #BlockChain(Context, Wallet, BlockStore)}}. ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor BlockChain [#_"NetworkParameters" __params, #_"Wallet" __wallet, #_"BlockStore" __blockStore]
        (ยง this (Context/getOrCreate __params), __wallet, __blockStore)
        this
    )

    ;;;
     ; Constructs a BlockChain that has no wallet at all.  This is helpful when you don't actually care about sending
     ; and receiving coins but rather, just want to explore the network data structures.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor BlockChain [#_"Context" __context, #_"BlockStore" __blockStore]
        (ยง this __context, (ArrayList. #_"<Wallet>"), __blockStore)
        this
    )

    ;;; See {@link #BlockChain(Context, BlockStore)}. ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor BlockChain [#_"NetworkParameters" __params, #_"BlockStore" __blockStore]
        (ยง this __params, (ArrayList. #_"<Wallet>"), __blockStore)
        this
    )

    ;;;
     ; Constructs a BlockChain connected to the given list of listeners and a store.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor BlockChain [#_"Context" __params, #_"List<? extends Wallet>" __wallets, #_"BlockStore" __blockStore]
        (ยง super __params, __wallets, __blockStore)
        (ยง assoc this :block-store __blockStore)
        this
    )

    ;;; See {@link #BlockChain(Context, List, BlockStore)}. ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor BlockChain [#_"NetworkParameters" __params, #_"List<? extends Wallet>" __wallets, #_"BlockStore" __blockStore]
        (ยง this (Context/getOrCreate __params), __wallets, __blockStore)
        this
    )

    #_override
    #_protected
    #_throws #_[ "BlockStoreException", "VerificationException" ]
    (ยง method #_"StoredBlock" addToBlockStore [#_"StoredBlock" __storedPrev, #_"Block" __blockHeader, #_"TransactionOutputChanges" __txOutChanges]
        (let [#_"StoredBlock" __newBlock (.. __storedPrev (build __blockHeader))]
            (.. (:block-store this) (put __newBlock))
            __newBlock
        )
    )

    #_override
    #_protected
    #_throws #_[ "BlockStoreException", "VerificationException" ]
    (ยง method #_"StoredBlock" addToBlockStore [#_"StoredBlock" __storedPrev, #_"Block" __blockHeader]
        (let [#_"StoredBlock" __newBlock (.. __storedPrev (build __blockHeader))]
            (.. (:block-store this) (put __newBlock))
            __newBlock
        )
    )

    #_override
    #_protected
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" rollbackBlockStore [#_"int" __height]
        (.. (:lock this) (lock))
        (try
            (let [#_"int" __currentHeight (.. this (getBestChainHeight))]
                (Preconditions/checkArgument (<= 0 __height __currentHeight), "Bad height: %s", __height)
                (when (== __height __currentHeight)
                    (ยง return nil) ;; nothing to do
                )

                ;; Look for the block we want to be the new chain head.
                (let [#_"StoredBlock" __newChainHead (.. (:block-store this) (getChainHead))]
                    (while (< __height (.. __newChainHead (getHeight)))
                        (ยง ass __newChainHead (.. __newChainHead (getPrev (:block-store this))))
                        (when (nil? __newChainHead)
                            (throw (BlockStoreException. "Unreachable height"))
                        )
                    )

                    ;; Modify store directly.
                    (.. (:block-store this) (put __newChainHead))
                    (.. this (setChainHead __newChainHead))
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    #_override
    #_protected
    (ยง method #_"boolean" shouldVerifyTransactions []
        false
    )

    #_override
    #_protected
    (ยง method #_"TransactionOutputChanges" connectTransactions [#_"int" __height, #_"Block" __block]
        ;; Don't have to do anything as this is only called if shouldVerifyTransactions().
        (throw (UnsupportedOperationException.))
    )

    #_override
    #_protected
    (ยง method #_"TransactionOutputChanges" connectTransactions [#_"StoredBlock" __newBlock]
        ;; Don't have to do anything as this is only called if shouldVerifyTransactions().
        (throw (UnsupportedOperationException.))
    )

    #_override
    #_protected
    (ยง method #_"void" disconnectTransactions [#_"StoredBlock" __block]
        ;; Don't have to do anything as this is only called if shouldVerifyTransactions().
        (throw (UnsupportedOperationException.))
    )

    #_override
    #_protected
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" doSetChainHead [#_"StoredBlock" __chainHead]
        (.. (:block-store this) (setChainHead __chainHead))
        nil
    )

    #_override
    #_protected
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" notSettingChainHead []
        ;; We don't use DB transactions here, so we don't need to do anything.
        nil
    )

    #_override
    #_protected
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" getStoredBlockInCurrentScope [#_"Sha256Hash" __hash]
        (.. (:block-store this) (get __hash))
    )

    #_override
    #_public
    #_throws #_[ "VerificationException", "PrunedException" ]
    (ยง method #_"boolean" add [#_"FilteredBlock" __block]
        (let [#_"boolean" __success (.. super (add __block))]
            (when __success
                (.. this (trackFilteredTransactions (.. __block (getTransactionCount))))
            )
            __success
        )
    )
)

;;;
 ; <p>A Bloom filter is a probabilistic data structure which can be sent to another client so that it can avoid
 ; sending us transactions that aren't relevant to our set of keys.  This allows for significantly more efficient
 ; use of available network bandwidth and CPU time.</p>
 ;
 ; <p>Because a Bloom filter is probabilistic, it has a configurable false positive rate.  So the filter will sometimes
 ; match transactions that weren't inserted into it, but it will never fail to match transactions that were.  This is
 ; a useful privacy feature - if you have spare bandwidth the false positive rate can be increased so the remote peer
 ; gets a noisy picture of what transactions are relevant to your wallet.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class BloomFilter (ยง extends Message)
    ;;;
     ; The BLOOM_UPDATE_* constants control when the bloom filter is auto-updated by the peer using
     ; it as a filter, either never, for all outputs or only for pay-2-pubkey outputs (default).
     ;;
    #_public
    (ยง enum BloomFilter.BloomUpdate
        (ยง item UPDATE_NONE) ;; 0
        (ยง item UPDATE_ALL) ;; 1
        ;;; Only adds outpoints to the filter if the output is a pay-to-pubkey/pay-to-multisig script. ;;
        (ยง item UPDATE_P2PUBKEY_ONLY) ;; 2
    )

    #_private
    (ยง field- #_"byte[]" :data)
    #_private
    (ยง field- #_"long" :hash-funcs)
    #_private
    (ยง field- #_"long" :n-tweak)
    #_private
    (ยง field- #_"byte" :n-flags)

    ;; Same value as of Bitcoin Core.
    ;; A filter of 20,000 items and a false positive rate of 0.1% or one of 10,000 items and 0.0001% is just under 36,000 bytes.
    #_private
    #_static
    (ยง def- #_"long" BloomFilter/MAX_FILTER_SIZE 36000)
    ;; There is little reason to ever have more hash functions than 50 given a limit of 36,000 bytes.
    #_private
    #_static
    (ยง def- #_"int" BloomFilter/MAX_HASH_FUNCS 50)

    ;;;
     ; Construct a BloomFilter by deserializing payloadBytes.
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor BloomFilter [#_"NetworkParameters" __params, #_"byte[]" __payloadBytes]
        (ยง super __params, __payloadBytes, 0)
        this
    )

    ;;;
     ; Constructs a filter with the given parameters which is updated on pay2pubkey outputs only.
     ;;
    #_public
    (ยง constructor BloomFilter [#_"int" __elements, #_"double" __falsePositiveRate, #_"long" __randomNonce]
        (ยง this __elements, __falsePositiveRate, __randomNonce, BloomFilter.BloomUpdate/UPDATE_P2PUBKEY_ONLY)
        this
    )

    ;;;
     ; <p>Constructs a new Bloom Filter which will provide approximately the given false positive rate when the given
     ; number of elements have been inserted.  If the filter would otherwise be larger than the maximum allowed size,
     ; it will be automatically downsized to the maximum size.</p>
     ;
     ; <p>To check the theoretical false positive rate of a given filter, use {@link BloomFilter#getFalsePositiveRate(int)}.</p>
     ;
     ; <p>The anonymity of which coins are yours to any peer which you send a BloomFilter to is controlled by the
     ; false positive rate.  For reference, as of block 187,000, the total number of addresses used in the chain was
     ; roughly 4.5 million.  Thus, if you use a false positive rate of 0.001 (0.1%), there will be, on average, 4,500
     ; distinct public keys/addresses which will be thought to be yours by nodes which have your bloom filter, but
     ; which are not actually yours.  Keep in mind that a remote node can do a pretty good job estimating the order of
     ; magnitude of the false positive rate of a given filter you provide it when considering the anonymity of a given
     ; filter.</p>
     ;
     ; <p>In order for filtered block download to function efficiently, the number of matched transactions in any given
     ; block should be less than (with some headroom) the maximum size of the MemoryPool used by the Peer
     ; doing the downloading (default is {@link TxConfidenceTable#MAX_SIZE}).  See the comment in processBlock(FilteredBlock)
     ; for more information on this restriction.</p>
     ;
     ; <p>randomNonce is a tweak for the hash function used to prevent some theoretical DoS attacks.
     ; It should be a random value, however secureness of the random value is of no great consequence.</p>
     ;
     ; <p>updateFlag is used to control filter behaviour on the server (remote node) side when it encounters a hit.
     ; See {@link org.bitcoinj.core.BloomFilter.BloomUpdate} for a brief description of each mode.  The purpose
     ; of this flag is to reduce network round-tripping and avoid over-dirtying the filter for the most common
     ; wallet configurations.</p>
     ;;
    #_public
    (ยง constructor BloomFilter [#_"int" __elements, #_"double" __falsePositiveRate, #_"long" __randomNonce, #_"BloomFilter.BloomUpdate" __updateFlag]
        ;; The following formulas were stolen from Wikipedia's page on Bloom Filters (with the addition of min(..., MAX_...)).
        ;; Size required for a given number of elements and false-positive rate.
        (let [#_"int" __size (int (* (/ -1 (pow (log 2), 2)) __elements (log __falsePositiveRate)))]
            (ยง ass __size (max 1, (/ (min __size, (* (int BloomFilter/MAX_FILTER_SIZE) 8)) 8)))
            (ยง assoc this :data (byte-array __size))
            ;; Optimal number of hash functions for a given filter size and element count.
            (ยง assoc this :hash-funcs (int (* (/ (* (.. (:data this) (alength)) 8) (double __elements)) (log 2))))
            (ยง assoc this :hash-funcs (max 1, (min (:hash-funcs this), BloomFilter/MAX_HASH_FUNCS)))
            (ยง assoc this :n-tweak __randomNonce)
            (ยง assoc this :n-flags (byte (& 0xff (.. __updateFlag (ordinal)))))
            this
        )
    )

    ;;;
     ; Returns the theoretical false positive rate of this filter if were to contain the given number of elements.
     ;;
    #_public
    (ยง method #_"double" getFalsePositiveRate [#_"int" __elements]
        (pow (- 1 (pow E, (/ (* -1.0 (:hash-funcs this) __elements) (* (.. (:data this) (alength)) 8)))), (:hash-funcs this))
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (str "Bloom Filter of size " (.. (:data this) (alength)) " with " (:hash-funcs this) " hash functions.")
    )

    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        (ยง assoc this :data (.. this (readByteArray)))
        (when (< BloomFilter/MAX_FILTER_SIZE (.. (:data this) (alength)))
            (throw (ProtocolException. "Bloom filter out of size range."))
        )
        (ยง assoc this :hash-funcs (.. this (readUint32)))
        (when (< BloomFilter/MAX_HASH_FUNCS (:hash-funcs this))
            (throw (ProtocolException. "Bloom filter hash function count out of range"))
        )
        (ยง assoc this :n-tweak (.. this (readUint32)))
        (ยง assoc this :n-flags (aget (.. this (readBytes 1)) 0))
        (ยง assoc this :length (- (:cursor this) (:offset this)))
        nil
    )

    ;;;
     ; Serializes this message to the provided stream.  If you just want the raw bytes use bitcoinSerialize().
     ;;
    #_override
    #_protected
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __stream]
        (.. __stream (write (.. (VarInt. (.. (:data this) (alength))) (encode))))
        (.. __stream (write (:data this)))
        (Utils/uint32ToByteStreamLE (:hash-funcs this), __stream)
        (Utils/uint32ToByteStreamLE (:n-tweak this), __stream)
        (.. __stream (write (:n-flags this)))
        nil
    )

    #_private
    #_static
    (ยง defn- #_"int" BloomFilter/rotateLeft32 [#_"int" __x, #_"int" __r]
        (| (<< __x __r) (>>> __x (- 32 __r)))
    )

    ;;;
     ; Applies the MurmurHash3 (x86_32) algorithm to the given data.
     ; See <a href="https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp">this C++ code</a> for the original.
     ;;
    #_public
    #_static
    (ยง defn #_"int" BloomFilter/murmurHash3 [#_"byte[]" __data, #_"long" __nTweak, #_"int" __hashNum, #_"byte[]" __object]
        (let [#_"int" __h1 (int (+ (* __hashNum 0xfba4c795) __nTweak)) #_"int" __c1 0xcc9e2d51 #_"int" __c2 0x1b873593]

            (let [#_"int" __numBlocks (* (/ (.. __object (alength)) 4) 4)]

                ;; body
                (loop-when-recur [#_"int" __i 0] (< __i __numBlocks) [(+ __i 4)]
                    (let [#_"int" __k1 (| (& 0xff (aget __object __i)) (<< (& 0xff (aget __object (inc __i))) 8) (<< (& 0xff (aget __object (+ __i 2))) 16) (<< (& 0xff (aget __object (+ __i 3))) 24))]

                        (ยง ass __k1 (* __k1 __c1))
                        (ยง ass __k1 (BloomFilter/rotateLeft32 __k1, 15))
                        (ยง ass __k1 (* __k1 __c2))

                        (ยง ass __h1 (bit-xor __h1 __k1))
                        (ยง ass __h1 (BloomFilter/rotateLeft32 __h1, 13))
                        (ยง ass __h1 (+ (* __h1 5) 0xe6546b64))
                    )
                )

                (let [#_"int" __k1 0 #_"int" __n (& (.. __object (alength)) 3)]
                    (when (< 2 __n)
                        (ยง ass __k1 (bit-xor __k1 (<< (& 0xff (aget __object (+ __numBlocks 2))) 16)))
                    )
                    (when (< 1 __n)
                        (ยง ass __k1 (bit-xor __k1 (<< (& 0xff (aget __object (inc __numBlocks))) 8)))
                    )
                    (when (< 0 __n)
                        (ยง ass __k1 (bit-xor __k1 (& 0xff (aget __object __numBlocks))))
                        (ยง ass __k1 (* __k1 __c1))
                        (ยง ass __k1 (BloomFilter/rotateLeft32 __k1, 15))
                        (ยง ass __k1 (* __k1 __c2))
                        (ยง ass __h1 (bit-xor __h1 __k1))
                    )

                    ;; finalization
                    (ยง ass __h1 (bit-xor __h1 (.. __object (alength))))
                    (ยง ass __h1 (bit-xor __h1 (>>> __h1 16)))
                    (ยง ass __h1 (* __h1 0x85ebca6b))
                    (ยง ass __h1 (bit-xor __h1 (>>> __h1 13)))
                    (ยง ass __h1 (* __h1 0xc2b2ae35))
                    (ยง ass __h1 (bit-xor __h1 (>>> __h1 16)))

                    (int (% (& __h1 0xffffffff) (* (.. __data (alength)) 8)))
                )
            )
        )
    )

    ;;;
     ; Returns true if the given object matches the filter either because it was inserted, or because we have a false-positive.
     ;;
    #_public
    #_synchronized
    (ยง method #_"boolean" contains [#_"byte[]" __object]
        (loop-when-recur [#_"int" __i 0] (< __i (:hash-funcs this)) [(inc __i)]
            (when (not (Utils/checkBitLE (:data this), (BloomFilter/murmurHash3 (:data this), (:n-tweak this), __i, __object)))
                (ยง return false)
            )
        )

        true
    )

    ;;; Insert the given arbitrary data into the filter. ;;
    #_public
    #_synchronized
    (ยง method #_"void" insert [#_"byte[]" __object]
        (loop-when-recur [#_"int" __i 0] (< __i (:hash-funcs this)) [(inc __i)]
            (Utils/setBitLE (:data this), (BloomFilter/murmurHash3 (:data this), (:n-tweak this), __i, __object))
        )
        nil
    )

    ;;; Inserts the given key and equivalent hashed form (for the address). ;;
    #_public
    #_synchronized
    (ยง method #_"void" insert [#_"ECKey" __key]
        (.. this (insert (.. __key (getPubKey))))
        (.. this (insert (.. __key (getPubKeyHash))))
        nil
    )

    ;;;
     ; Sets this filter to match all objects.  A Bloom filter which matches everything may seem pointless, however,
     ; it is useful in order to reduce steady state bandwidth usage when you want full blocks.  Instead of receiving
     ; all transaction data twice, you will receive the vast majority of all transactions just once, at broadcast time.
     ; Solved blocks will then be send just as Merkle trees of tx hashes, meaning a constant 32 bytes of data for each
     ; transaction instead of 100-300 bytes as per usual.
     ;;
    #_public
    #_synchronized
    (ยง method #_"void" setMatchAll []
        (ยง assoc this :data (byte-array [ (byte 0xff) ]))
        nil
    )

    ;;;
     ; Copies filter into this.  Filter must have the same size, hash function count and nTweak or an
     ; IllegalArgumentException will be thrown.
     ;;
    #_public
    #_synchronized
    (ยง method #_"void" merge [#_"BloomFilter" __filter]
        (cond (and (not (.. this (matchesAll))) (not (.. __filter (matchesAll))))
            (do
                (Preconditions/checkArgument (and (== (.. (:data __filter) (alength)) (.. (:data this) (alength))) (== (:hash-funcs __filter) (:hash-funcs this)) (== (:n-tweak __filter) (:n-tweak this))))

                (loop-when-recur [#_"int" __i 0] (< __i (.. (:data this) (alength))) [(inc __i)]
                    (aset (:data this) __i (| (aget (:data this) __i) (aget (:data __filter) __i)))
                )
            )
            :else
            (do
                (ยง assoc this :data (byte-array [ (byte 0xff) ]))
            )
        )
        nil
    )

    ;;;
     ; Returns true if this filter will match anything.  See {@link org.bitcoinj.core.BloomFilter#setMatchAll()}
     ; for when this can be a useful thing to do.
     ;;
    #_public
    #_synchronized
    (ยง method #_"boolean" matchesAll []
        (doseq [#_"byte" __b (:data this)]
            (when (!= __b (byte 0xff))
                (ยง return false)
            )
        )
        true
    )

    ;;;
     ; The update flag controls how application of the filter to a block modifies the filter.  See the enum javadocs
     ; for information on what occurs and when.
     ;;
    #_public
    #_synchronized
    (ยง method #_"BloomFilter.BloomUpdate" getUpdateFlag []
        (when (== (:n-flags this) 0)
            (ยง return BloomFilter.BloomUpdate/UPDATE_NONE)
        )
        (when (== (:n-flags this) 1)
            (ยง return BloomFilter.BloomUpdate/UPDATE_ALL)
        )
        (when (== (:n-flags this) 2)
            (ยง return BloomFilter.BloomUpdate/UPDATE_P2PUBKEY_ONLY)
        )

        (throw (IllegalStateException. "Unknown flag combination"))
    )

    ;;;
     ; Creates a new FilteredBlock from the given Block, using this filter to select transactions.  Matches can cause the
     ; filter to be updated with the matched element, this ensures that when a filter is applied to a block, spends of
     ; matched transactions are also matched.  However it means this filter can be mutated by the operation.  The returned
     ; filtered block already has the matched transactions associated with it.
     ;;
    #_public
    #_synchronized
    (ยง method #_"FilteredBlock" applyAndUpdate [#_"Block" __block]
        (let [#_"List<Transaction>" __txns (.. __block (getTransactions))
              #_"List<Sha256Hash>" __txHashes (ArrayList. #_"<>" (.. __txns (size)))
              #_"List<Transaction>" __matched (Lists/newArrayList)
              #_"byte[]" __bits (byte-array (int (Math/ceil (/ (.. __txns (size)) 8.0))))]
            (loop-when-recur [#_"int" __i 0] (< __i (.. __txns (size))) [(inc __i)]
                (let [#_"Transaction" __tx (.. __txns (get __i))]
                    (.. __txHashes (add (.. __tx (getHash))))
                    (when (.. this (applyAndUpdate __tx))
                        (Utils/setBitLE __bits, __i)
                        (.. __matched (add __tx))
                    )
                )
            )
            (let [#_"PartialMerkleTree" __pmt (PartialMerkleTree/buildFromLeaves (.. __block (getParams)), __bits, __txHashes)
                  #_"FilteredBlock" __filteredBlock (FilteredBlock. (.. __block (getParams)), (.. __block (cloneAsHeader)), __pmt)]
                (doseq [#_"Transaction" __transaction __matched]
                    (.. __filteredBlock (provideTransaction __transaction))
                )
                __filteredBlock
            )
        )
    )

    #_public
    #_synchronized
    (ยง method #_"boolean" applyAndUpdate [#_"Transaction" __tx]
        (when (.. this (contains (.. __tx (getHash) (getBytes))))
            (ยง return true)
        )
        (let [#_"boolean" __found false
              #_"BloomFilter.BloomUpdate" __flag (.. this (getUpdateFlag))]
            (doseq [#_"TransactionOutput" __output (.. __tx (getOutputs))]
                (let [#_"Script" __script (.. __output (getScriptPubKey))]
                    (doseq [#_"ScriptChunk" __chunk (.. __script (getChunks))]
                        (when (and (.. __chunk (isPushData)) (.. this (contains (:data __chunk))))
                            (let [#_"boolean" __isSendingToPubKeys (or (.. __script (isSentToRawPubKey)) (.. __script (isSentToMultiSig)))]
                                (when (or (== __flag BloomFilter.BloomUpdate/UPDATE_ALL) (and (== __flag BloomFilter.BloomUpdate/UPDATE_P2PUBKEY_ONLY) __isSendingToPubKeys))
                                    (.. this (insert (.. __output (getOutPointFor) (unsafeBitcoinSerialize))))
                                )
                                (ยง ass __found true)
                            )
                        )
                    )
                )
            )
            (when __found
                (ยง return true)
            )
            (doseq [#_"TransactionInput" __input (.. __tx (getInputs))]
                (when (.. this (contains (.. __input (getOutpoint) (unsafeBitcoinSerialize))))
                    (ยง return true)
                )

                (doseq [#_"ScriptChunk" __chunk (.. __input (getScriptSig) (getChunks))]
                    (when (and (.. __chunk (isPushData)) (.. this (contains (:data __chunk))))
                        (ยง return true)
                    )
                )
            )
            false
        )
    )

    #_override
    #_public
    #_synchronized
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"BloomFilter" __other (cast BloomFilter __o)]
            (and (== (:hash-funcs this) (:hash-funcs __other)) (== (:n-tweak this) (:n-tweak __other)) (Arrays/equals (:data this), (:data __other)))
        )
    )

    #_override
    #_public
    #_synchronized
    (ยง method #_"int" hashCode []
        (Objects/hashCode (:hash-funcs this), (:n-tweak this), (Arrays/hashCode (:data this)))
    )
)

;;;
 ; <p>Vends hard-coded {@link StoredBlock}s for blocks throughout the chain.  Checkpoints serve two purposes:</p>
 ; <ol>
 ;    <li>They act as a safety mechanism against huge re-orgs that could rewrite large chunks of history, thus
 ;    constraining the block chain to be a consensus mechanism only for recent parts of the timeline.</li>
 ;    <li>They allow synchronization to the head of the chain for new wallets/users much faster than syncing all
 ;    headers from the genesis block.</li>
 ; </ol>
 ;
 ; <p>Checkpoints are used by the SPV {@link BlockChain} to initialize fresh {@link org.bitcoinj.store.SPVBlockStore}s.
 ; They are not used by fully validating mode, which instead has a different concept of checkpoints that are used
 ; to hard-code the validity of blocks that violate BIP30 (duplicate coinbase transactions).
 ; Those "checkpoints" can be found in NetworkParameters.</p>
 ;
 ; <p>The file format consists of the string "CHECKPOINTS 1", followed by a uint32 containing the number of signatures
 ; to read.  The value may not be larger than 256 (so it could have been a byte but isn't for historical reasons).
 ; If the number of signatures is larger than zero, each 65 byte ECDSA secp256k1 signature then follows.  The signatures
 ; sign the hash of all bytes that follow the last signature.</p>
 ;
 ; <p>After the signatures come an int32 containing the number of checkpoints in the file.  Then each checkpoint follows
 ; one after the other.  A checkpoint is 12 bytes for the total work done field, 4 bytes for the height, 80 bytes
 ; for the block header and then 1 zero byte at the end (i.e. number of transactions in the block: always zero).</p>
 ;;
#_public
(ยง class CheckpointManager
    #_private
    #_static
    (ยง def- #_"Logger" CheckpointManager/log (LoggerFactory/getLogger CheckpointManager))

    #_private
    #_static
    (ยง def- #_"String" CheckpointManager/BINARY_MAGIC "CHECKPOINTS 1")
    #_private
    #_static
    (ยง def- #_"String" CheckpointManager/TEXTUAL_MAGIC "TXT CHECKPOINTS 1")
    #_private
    #_static
    (ยง def- #_"int" CheckpointManager/MAX_SIGNATURES 256)

    ;; Map of block header time to data.
    #_protected
    (ยง field #_"TreeMap<Long, StoredBlock>" :checkpoints (TreeMap. #_"<>"))

    #_protected
    (ยง field #_"NetworkParameters" :params)
    #_protected
    (ยง field #_"Sha256Hash" :data-hash)

    #_public
    #_static
    (ยง def #_"BaseEncoding" CheckpointManager/BASE64 (.. (BaseEncoding/base64) (omitPadding)))

    ;;; Loads the default checkpoints bundled with bitcoinj. ;;
    #_public
    #_throws #_[ "IOException" ]
    (ยง constructor CheckpointManager [#_"Context" __context]
        (ยง this (.. __context (getParams)), nil)
        this
    )

    ;;; Loads the checkpoints from the given stream. ;;
    #_public
    #_throws #_[ "IOException" ]
    (ยง constructor CheckpointManager [#_"NetworkParameters" __params, #_nilable #_"InputStream" __inputStream]
        (ยง assoc this :params (Preconditions/checkNotNull __params))
        (when (nil? __inputStream)
            (ยง ass __inputStream (CheckpointManager/openStream __params))
        )
        (Preconditions/checkNotNull __inputStream)
        (ยง ass __inputStream (BufferedInputStream. __inputStream))
        (.. __inputStream (mark 1))
        (let [#_"int" __first (.. __inputStream (read))]
            (.. __inputStream (reset))
            (cond (== __first (.. CheckpointManager/BINARY_MAGIC (charAt 0)))
                (do
                    (ยง assoc this :data-hash (.. this (readBinary __inputStream)))
                )
                (== __first (.. CheckpointManager/TEXTUAL_MAGIC (charAt 0)))
                (do
                    (ยง assoc this :data-hash (.. this (readTextual __inputStream)))
                )
                :else
                (do
                    (throw (IOException. "Unsupported format."))
                )
            )
            this
        )
    )

    ;;; Returns a checkpoints stream pointing to inside the bitcoinj JAR. ;;
    #_public
    #_static
    (ยง defn #_"InputStream" CheckpointManager/openStream [#_"NetworkParameters" __params]
        (.. CheckpointManager (getResourceAsStream (str "/" (.. __params (getId)) ".checkpoints.txt")))
    )

    #_private
    #_throws #_[ "IOException" ]
    (ยง method- #_"Sha256Hash" readBinary [#_"InputStream" __inputStream]
        (let [#_"DataInputStream" __dis nil]
            (try
                (let [#_"MessageDigest" __digest (Sha256Hash/newDigest)
                      #_"DigestInputStream" __digestInputStream (DigestInputStream. __inputStream, __digest)]
                    (ยง ass __dis (DataInputStream. __digestInputStream))
                    (.. __digestInputStream (on false))
                    (let [#_"byte[]" __header (byte-array (.. CheckpointManager/BINARY_MAGIC (length)))]
                        (.. __dis (readFully __header))
                        (when (not (Arrays/equals __header, (.. CheckpointManager/BINARY_MAGIC (getBytes "US-ASCII"))))
                            (throw (IOException. "Header bytes did not match expected version"))
                        )
                        (let [#_"int" __numSignatures (checkPositionIndex (.. __dis (readInt)), CheckpointManager/MAX_SIGNATURES, "Num signatures out of range")]
                            (loop-when-recur [#_"int" __i 0] (< __i __numSignatures) [(inc __i)]
                                (let [#_"byte[]" __sig (byte-array 65)]
                                    (.. __dis (readFully __sig))
                                    ;; TODO: Do something with the signature here.
                                )
                            )
                            (.. __digestInputStream (on true))
                            (let [#_"int" __numCheckpoints (.. __dis (readInt))]
                                (Preconditions/checkState (< 0 __numCheckpoints))
                                (let [#_"int" __size StoredBlock/COMPACT_SERIALIZED_SIZE
                                      #_"ByteBuffer" __buffer (ByteBuffer/allocate __size)]
                                    (loop-when-recur [#_"int" __i 0] (< __i __numCheckpoints) [(inc __i)]
                                        (when (< (.. __dis (read (.. __buffer (array)), 0, __size)) __size)
                                            (throw (IOException. "Incomplete read whilst loading checkpoints."))
                                        )
                                        (let [#_"StoredBlock" __block (StoredBlock/deserializeCompact (:params this), __buffer)]
                                            (.. __buffer (position 0))
                                            (.. (:checkpoints this) (put (.. __block (getHeader) (getTimeSeconds)), __block))
                                        )
                                    )
                                    (let [#_"Sha256Hash" __dataHash (Sha256Hash/wrap (.. __digest (digest)))]
                                        (.. CheckpointManager/log (info "Read {} checkpoints, hash is {}", (.. (:checkpoints this) (size)), __dataHash))
                                        (ยง return __dataHash)
                                    )
                                )
                            )
                        )
                    )
                )
                (catch ProtocolException __e
                    (throw (IOException. __e))
                )
                (finally
                    (when (some? __dis)
                        (.. __dis (close))
                    )
                    (.. __inputStream (close))
                )
            )
        )
    )

    #_private
    #_throws #_[ "IOException" ]
    (ยง method- #_"Sha256Hash" readTextual [#_"InputStream" __inputStream]
        (let [#_"Hasher" __hasher (.. (Hashing/sha256) (newHasher))
              #_"BufferedReader" __reader nil]
            (try
                (ยง ass __reader (BufferedReader. (InputStreamReader. __inputStream, Charsets/US_ASCII)))
                (let [#_"String" __magic (.. __reader (readLine))]
                    (when (not (.. CheckpointManager/TEXTUAL_MAGIC (equals __magic)))
                        (throw (IOException. (str "unexpected magic: " __magic)))
                    )
                    (let [#_"int" __numSigs (Integer/parseInt (.. __reader (readLine)))]
                        (loop-when-recur [#_"int" __i 0] (< __i __numSigs) [(inc __i)]
                            (.. __reader (readLine)) ;; Skip sigs for now.
                        )
                        (let [#_"int" __numCheckpoints (Integer/parseInt (.. __reader (readLine)))]
                            (Preconditions/checkState (< 0 __numCheckpoints))
                            ;; Hash numCheckpoints in a way compatible to the binary format.
                            (.. __hasher (putBytes (.. (ByteBuffer/allocate 4) (order ByteOrder/BIG_ENDIAN) (putInt __numCheckpoints) (array))))
                            (let [#_"int" __size StoredBlock/COMPACT_SERIALIZED_SIZE
                                  #_"ByteBuffer" __buffer (ByteBuffer/allocate __size)]
                                (loop-when-recur [#_"int" __i 0] (< __i __numCheckpoints) [(inc __i)]
                                    (let [#_"byte[]" __bytes (.. CheckpointManager/BASE64 (decode (.. __reader (readLine))))]
                                        (.. __hasher (putBytes __bytes))
                                        (.. __buffer (position 0))
                                        (.. __buffer (put __bytes))
                                        (.. __buffer (position 0))
                                        (let [#_"StoredBlock" __block (StoredBlock/deserializeCompact (:params this), __buffer)]
                                            (.. (:checkpoints this) (put (.. __block (getHeader) (getTimeSeconds)), __block))
                                        )
                                    )
                                )
                                (let [#_"HashCode" __hash (.. __hasher (hash))]
                                    (.. CheckpointManager/log (info "Read {} checkpoints, hash is {}", (.. (:checkpoints this) (size)), __hash))
                                    (ยง return (Sha256Hash/wrap (.. __hash (asBytes))))
                                )
                            )
                        )
                    )
                )
                (finally
                    (when (some? __reader)
                        (.. __reader (close))
                    )
                )
            )
        )
    )

    ;;;
     ; Returns a {@link StoredBlock} representing the last checkpoint before the given time, for example, normally
     ; you would want to know the checkpoint before the earliest wallet birthday.
     ;;
    #_public
    (ยง method #_"StoredBlock" getCheckpointBefore [#_"long" __time]
        (try
            (Preconditions/checkArgument (< (.. (:params this) (getGenesisBlock) (getTimeSeconds)) __time))
            ;; This is thread safe because the map never changes after creation.
            (let [#_"Map.Entry<Long, StoredBlock>" __entry (.. (:checkpoints this) (floorEntry __time))]
                (when (some? __entry)
                    (ยง return (.. __entry (getValue)))
                )
                (let [#_"Block" __genesis (.. (:params this) (getGenesisBlock) (cloneAsHeader))]
                    (ยง return (StoredBlock. __genesis, (.. __genesis (getWork)), 0))
                )
            )
            (catch VerificationException __e
                (throw (RuntimeException. __e)) ;; Cannot happen.
            )
        )
    )

    ;;; Returns the number of checkpoints that were loaded. ;;
    #_public
    (ยง method #_"int" numCheckpoints []
        (.. (:checkpoints this) (size))
    )

    ;;; Returns a hash of the concatenated checkpoint data. ;;
    #_public
    (ยง method #_"Sha256Hash" getDataHash []
        (:data-hash this)
    )

    ;;;
     ; <p>Convenience method that creates a CheckpointManager, loads the given data, gets the checkpoint for the given
     ; time, then inserts it into the store and sets that to be the chain head.  Useful when you have just created
     ; a new store from scratch and want to use configure it all in one go.</p>
     ;
     ; <p>Note that time is adjusted backwards by a week to account for possible clock drift in the block headers.</p>
     ;;
    #_public
    #_static
    #_throws #_[ "IOException", "BlockStoreException" ]
    (ยง defn #_"void" CheckpointManager/checkpoint [#_"NetworkParameters" __params, #_"InputStream" __checkpoints, #_"BlockStore" __store, #_"long" __time]
        (Preconditions/checkNotNull __params)
        (Preconditions/checkNotNull __store)
        (Preconditions/checkArgument (not (instance? FullPrunedBlockStore __store)), "You cannot use checkpointing with a full store.")

        (ยง ass __time (- __time (* 86400 7)))

        (Preconditions/checkArgument (< 0 __time))
        (.. CheckpointManager/log (info "Attempting to initialize a new block store with a checkpoint for time {} ({})", __time, (Utils/dateTimeFormat (* __time 1000))))

        (let [#_"BufferedInputStream" __stream (BufferedInputStream. __checkpoints)
              #_"CheckpointManager" __manager (CheckpointManager. __params, __stream)
              #_"StoredBlock" __checkpoint (.. __manager (getCheckpointBefore __time))]
            (.. __store (put __checkpoint))
            (.. __store (setChainHead __checkpoint))
            nil
        )
    )
)

;;;
 ; <p>Represents a Message type that can be contained within another Message.  ChildMessages that have a cached
 ; backing byte array need to invalidate their parent's caches as well as their own if they are modified.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
(ยง class ChildMessage (ยง extends Message)
    #_nilable
    #_protected
    (ยง field #_"Message" :parent)

    #_public
    (ยง constructor ChildMessage [#_"NetworkParameters" __params]
        (ยง super __params)
        this
    )

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor ChildMessage [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"int" __offset, #_"int" __protocolVersion]
        (ยง super __params, __payload, __offset, __protocolVersion)
        this
    )

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor ChildMessage [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"int" __offset, #_"int" __protocolVersion, #_"Message" __parent, #_"MessageSerializer" __setSerializer, #_"int" __length]
        (ยง super __params, __payload, __offset, __protocolVersion, __setSerializer, __length)
        (ยง assoc this :parent __parent)
        this
    )

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor ChildMessage [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"int" __offset]
        (ยง super __params, __payload, __offset)
        this
    )

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor ChildMessage [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"int" __offset, #_nilable #_"Message" __parent, #_"MessageSerializer" __setSerializer, #_"int" __length]
        (ยง super __params, __payload, __offset, __setSerializer, __length)
        (ยง assoc this :parent __parent)
        this
    )

    #_public
    (ยง method #_"void" setParent [#_nilable #_"Message" __parent]
        (when (and (some? (:parent this)) (!= (:parent this) __parent) (some? __parent))
            ;; After old parent is unlinked it won't be able to receive notice if this ChildMessage changes internally.
            ;; To be safe we invalidate the parent cache to ensure it rebuilds manually on serialization.
            (.. (:parent this) (unCache))
        )
        (ยง assoc this :parent __parent)
        nil
    )

    #_override
    #_protected
    (ยง method #_"void" unCache []
        (.. super (unCache))
        (when (some? (:parent this))
            (.. (:parent this) (unCache))
        )
        nil
    )

    #_protected
    (ยง method #_"void" adjustLength [#_"int" __adjustment]
        (.. this (adjustLength 0, __adjustment))
        nil
    )

    #_override
    #_protected
    (ยง method #_"void" adjustLength [#_"int" __newArraySize, #_"int" __adjustment]
        (.. super (adjustLength __newArraySize, __adjustment))
        (when (some? (:parent this))
            (.. (:parent this) (adjustLength __newArraySize, __adjustment))
        )
        nil
    )
)

;;;
 ; Represents a monetary Bitcoin value.  This class is immutable.
 ;;
#_public
(ยง class Coin (ยง implements Monetary, Comparable #_"<Coin>", Serializable)
    ;;;
     ; Number of decimals for one Bitcoin.  This constant is useful for quick adapting to other coins because a lot of
     ; constants derive from it.
     ;;
    #_public
    #_static
    (ยง def #_"int" Coin/SMALLEST_UNIT_EXPONENT 8)

    ;;;
     ; The number of satoshis equal to one bitcoin.
     ;;
    #_private
    #_static
    (ยง def- #_"long" Coin/COIN_VALUE (LongMath/pow 10, Coin/SMALLEST_UNIT_EXPONENT))

    ;;;
     ; Zero Bitcoins.
     ;;
    #_public
    #_static
    (ยง def #_"Coin" Coin/ZERO (Coin/valueOf 0))

    ;;;
     ; One Bitcoin.
     ;;
    #_public
    #_static
    (ยง def #_"Coin" Coin/COIN (Coin/valueOf Coin/COIN_VALUE))

    ;;;
     ; 0.01 Bitcoins.  This unit is not really used much.
     ;;
    #_public
    #_static
    (ยง def #_"Coin" Coin/CENT (.. Coin/COIN (divide 100)))

    ;;;
     ; 0.001 Bitcoins, also known as 1 mBTC.
     ;;
    #_public
    #_static
    (ยง def #_"Coin" Coin/MILLICOIN (.. Coin/COIN (divide 1000)))

    ;;;
     ; 0.000001 Bitcoins, also known as 1 ยตBTC or 1 uBTC.
     ;;
    #_public
    #_static
    (ยง def #_"Coin" Coin/MICROCOIN (.. Coin/MILLICOIN (divide 1000)))

    ;;;
     ; A satoshi is the smallest unit that can be transferred.  100 million of them fit into a Bitcoin.
     ;;
    #_public
    #_static
    (ยง def #_"Coin" Coin/SATOSHI (Coin/valueOf 1))

    #_public
    #_static
    (ยง def #_"Coin" Coin/FIFTY_COINS (.. Coin/COIN (multiply 50)))

    ;;;
     ; Represents a monetary value of minus one satoshi.
     ;;
    #_public
    #_static
    (ยง def #_"Coin" Coin/NEGATIVE_SATOSHI (Coin/valueOf -1))

    ;;;
     ; The number of satoshis of this monetary value.
     ;;
    #_public
    (ยง field #_"long" :value)

    #_private
    (ยง constructor- #_"Coin" [#_"long" __satoshis]
        (ยง assoc this :value __satoshis)
        this
    )

    #_public
    #_static
    (ยง defn #_"Coin" Coin/valueOf [#_"long" __satoshis]
        (Coin. __satoshis)
    )

    #_override
    #_public
    (ยง method #_"int" smallestUnitExponent []
        Coin/SMALLEST_UNIT_EXPONENT
    )

    ;;;
     ; Returns the number of satoshis of this monetary value.
     ;;
    #_override
    #_public
    (ยง method #_"long" getValue []
        (:value this)
    )

    ;;;
     ; Convert an amount expressed in the way humans are used to into satoshis.
     ;;
    #_public
    #_static
    (ยง defn #_"Coin" Coin/valueOf [#_"int" __coins, #_"int" __cents]
        (Preconditions/checkArgument (and (<= 0 __coins) (<= 0 __cents) (< __cents 100)))

        (.. Coin/COIN (multiply __coins) (add (.. Coin/CENT (multiply __cents))))
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify fractional satoshis, or a value out of range.
     ;;
    #_public
    #_static
    (ยง defn #_"Coin" Coin/parseCoin [#_"String" __str]
        (try
            (let [#_"long" __satoshis (.. (BigDecimal. __str) (movePointRight Coin/SMALLEST_UNIT_EXPONENT) (longValueExact))]
                (ยง return (Coin/valueOf __satoshis))
            )
            (catch ArithmeticException __e
                (throw (IllegalArgumentException. __e)) ;; Repackage exception to honor method contract.
            )
        )
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.  The amount is cut to satoshi precision.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify a value out of range.
     ;;
    #_public
    #_static
    (ยง defn #_"Coin" Coin/parseCoinInexact [#_"String" __str]
        (try
            (let [#_"long" __satoshis (.. (BigDecimal. __str) (movePointRight Coin/SMALLEST_UNIT_EXPONENT) (longValue))]
                (ยง return (Coin/valueOf __satoshis))
            )
            (catch ArithmeticException __e
                (throw (IllegalArgumentException. __e)) ;; Repackage exception to honor method contract.
            )
        )
    )

    #_public
    (ยง method #_"Coin" add [#_"Coin" __value]
        (Coin. (LongMath/checkedAdd (:value this), (:value __value)))
    )

    ;;; Alias for add. ;;
    #_public
    (ยง method #_"Coin" plus [#_"Coin" __value]
        (.. this (add __value))
    )

    #_public
    (ยง method #_"Coin" subtract [#_"Coin" __value]
        (Coin. (LongMath/checkedSubtract (:value this), (:value __value)))
    )

    ;;; Alias for subtract. ;;
    #_public
    (ยง method #_"Coin" minus [#_"Coin" __value]
        (.. this (subtract __value))
    )

    #_public
    (ยง method #_"Coin" multiply [#_"long" __factor]
        (Coin. (LongMath/checkedMultiply (:value this), __factor))
    )

    ;;; Alias for multiply. ;;
    #_public
    (ยง method #_"Coin" times [#_"long" __factor]
        (.. this (multiply __factor))
    )

    ;;; Alias for multiply. ;;
    #_public
    (ยง method #_"Coin" times [#_"int" __factor]
        (.. this (multiply __factor))
    )

    #_public
    (ยง method #_"Coin" divide [#_"long" __divisor]
        (Coin. (/ (:value this) __divisor))
    )

    ;;; Alias for divide. ;;
    #_public
    (ยง method #_"Coin" div [#_"long" __divisor]
        (.. this (divide __divisor))
    )

    ;;; Alias for divide. ;;
    #_public
    (ยง method #_"Coin" div [#_"int" __divisor]
        (.. this (divide __divisor))
    )

    #_public
    (ยง method #_"Coin[]" divideAndRemainder [#_"long" __divisor]
        (into-array Coin [ (Coin. (/ (:value this) __divisor)), (Coin. (% (:value this) __divisor)) ])
    )

    #_public
    (ยง method #_"long" divide [#_"Coin" __divisor]
        (/ (:value this) (:value __divisor))
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value greater than zero,
     ; otherwise false.
     ;;
    #_public
    (ยง method #_"boolean" isPositive []
        (== (.. this (signum)) 1)
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value less than zero,
     ; otherwise false.
     ;;
    #_public
    (ยง method #_"boolean" isNegative []
        (== (.. this (signum)) -1)
    )

    ;;;
     ; Returns true if and only if this instance represents zero monetary value,
     ; otherwise false.
     ;;
    #_public
    (ยง method #_"boolean" isZero []
        (== (.. this (signum)) 0)
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is greater than that
     ; of the given other Coin, otherwise false.
     ;;
    #_public
    (ยง method #_"boolean" isGreaterThan [#_"Coin" __other]
        (< 0 (.. this (compareTo __other)))
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is less than that
     ; of the given other Coin, otherwise false.
     ;;
    #_public
    (ยง method #_"boolean" isLessThan [#_"Coin" __other]
        (< (.. this (compareTo __other)) 0)
    )

    #_public
    (ยง method #_"Coin" shiftLeft [#_"int" __n]
        (Coin. (<< (:value this) __n))
    )

    #_public
    (ยง method #_"Coin" shiftRight [#_"int" __n]
        (Coin. (>> (:value this) __n))
    )

    #_override
    #_public
    (ยง method #_"int" signum []
        (when (== (:value this) 0)
            (ยง return 0)
        )
        (if (< (:value this) 0) -1 1)
    )

    #_public
    (ยง method #_"Coin" negate []
        (Coin. (- (:value this)))
    )

    ;;;
     ; Returns the number of satoshis of this monetary value.  It's deprecated in favour of accessing {@link #value} directly.
     ;;
    #_public
    (ยง method #_"long" longValue []
        (:value this)
    )

    #_private
    #_static
    (ยง def- #_"MonetaryFormat" Coin/FRIENDLY_FORMAT (.. MonetaryFormat/BTC (minDecimals 2) (repeatOptionalDecimals 1, 6) (postfixCode)))

    ;;;
     ; Returns the value as a 0.12 type string.  More digits after the decimal place will be used
     ; if necessary, but two will always be present.
     ;;
    #_public
    (ยง method #_"String" toFriendlyString []
        (.. Coin/FRIENDLY_FORMAT (format this) (toString))
    )

    #_private
    #_static
    (ยง def- #_"MonetaryFormat" Coin/PLAIN_FORMAT (.. MonetaryFormat/BTC (minDecimals 0) (repeatOptionalDecimals 1, 8) (noCode)))

    ;;;
     ; Returns the value as a plain string denominated in BTC.
     ; The result is unformatted with no trailing zeroes.
     ; For instance, a value of 150000 satoshis gives an output string of "0.0015" BTC.
     ;;
    #_public
    (ยง method #_"String" toPlainString []
        (.. Coin/PLAIN_FORMAT (format this) (toString))
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (Long/toString (:value this))
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (== (:value this) (:value (cast Coin __o)))
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (int (:value this))
    )

    #_override
    #_public
    (ยง method #_"int" compareTo [#_"Coin" __other]
        (Longs/compare (:value this), (:value __other))
    )
)

;; TODO: Finish adding Context c'tors to all the different objects so we can start deprecating the versions that take NetworkParameters.
;; TODO: Add a working directory notion to Context and make various subsystems that want to use files default to that directory (e.g. Orchid, block stores, wallet, etc).
;; TODO: Auto-register the block chain object here, and then use it in the (newly deprecated) TransactionConfidence.getDepthInBlocks() method:
;;       the new version should take an AbstractBlockChain specifically.
;;       Also use the block chain object reference from the context in PeerGroup and remove the other constructors, as it's easy to forget to wire things up.
;; TODO: Move Threading.USER_THREAD to here and leave behind just a source code stub.  Allow different instantiations of the library to use different user threads.
;; TODO: Keep a URI to where library internal data files can be found, to abstract over the lack of JAR files on Android.
;; TODO: Stash anything else that resembles global library configuration in here and use it to clean up the rest of the API without breaking people.
;; TODO: Move the TorClient into Context, so different parts of the library can read data over Tor without having to request it directly. (or maybe a general socket factory??)

;;;
 ; <p>The Context object holds various objects and pieces of configuration that are scoped to a specific instantiation of
 ; bitcoinj for a specific network.  You can get an instance of this class through calling {@link #get()}.</p>
 ;
 ; <p>Context is new in 0.13 and the library is currently in a transitional period: you should create a Context that
 ; wraps your chosen network parameters before using the rest of the library.  However if you don't, things will still
 ; work as a Context will be created for you and stashed in thread local storage.  The context is then propagated between
 ; library created threads as needed.  This automagical propagation and creation is a temporary mechanism: one day it
 ; will be removed to avoid confusing edge cases that could occur if the developer does not fully understand it e.g.
 ; in the case where multiple instances of the library are in use simultaneously.</p>
 ;;
#_public
(ยง class Context
    #_private
    #_static
    (ยง def- #_"Logger" Context/log (LoggerFactory/getLogger Context))

    #_public
    #_static
    (ยง def #_"int" Context/DEFAULT_EVENT_HORIZON 100)

    #_private
    (ยง field- #_"TxConfidenceTable" :confidence-table)
    #_private
    (ยง field- #_"NetworkParameters" :params)
    #_private
    (ยง field- #_"int" :event-horizon)
    #_private
    (ยง field- #_"boolean" :ensure-min-required-fee)
    #_private
    (ยง field- #_"Coin" :fee-per-kb)

    ;;;
     ; Creates a new context object.  For now, this will be done for you by the framework.  Eventually you will be
     ; expected to do this yourself in the same manner as fetching a NetworkParameters object (at the start of your app).
     ;
     ; @param params The network parameters that will be associated with this context.
     ;;
    #_public
    (ยง constructor Context [#_"NetworkParameters" __params]
        (ยง this __params, Context/DEFAULT_EVENT_HORIZON, Transaction/DEFAULT_TX_FEE, true)
        this
    )

    ;;;
     ; Creates a new custom context object.  This is mainly meant for unit tests for now.
     ;
     ; @param params The network parameters that will be associated with this context.
     ; @param eventHorizon Number of blocks after which the library will delete data and be unable to always process reorgs (see {@link #getEventHorizon()}).
     ; @param feePerKb The default fee per 1000 bytes of transaction data to pay when completing transactions.  For details, see {@link SendRequest#feePerKb}.
     ; @param ensureMinRequiredFee Whether to ensure the minimum required fee by default when completing transactions.  For details, see {@link SendRequest#ensureMinRequiredFee}.
     ;;
    #_public
    (ยง constructor Context [#_"NetworkParameters" __params, #_"int" __eventHorizon, #_"Coin" __feePerKb, #_"boolean" __ensureMinRequiredFee]
        (.. Context/log (info "Creating bitcoinj {} context.", VersionMessage/BITCOINJ_VERSION))
        (ยง assoc this :confidence-table (TxConfidenceTable.))
        (ยง assoc this :params __params)
        (ยง assoc this :event-horizon __eventHorizon)
        (ยง assoc this :ensure-min-required-fee __ensureMinRequiredFee)
        (ยง assoc this :fee-per-kb __feePerKb)
        (ยง ass Context/LAST_CONSTRUCTED this)
        (.. Context/SLOT (set this))
        this
    )

    #_private
    #_static
    #_volatile
    (ยง def- #_"Context" Context/LAST_CONSTRUCTED)
    #_private
    #_static
    (ยง def- #_"boolean" Context/IS_STRICT_MODE)
    #_private
    #_static
    (ยง def- #_"ThreadLocal<Context>" Context/SLOT (ThreadLocal. #_"<>"))

    ;;;
     ; Returns the current context that is associated with the <b>calling thread</b>.  BitcoinJ is an API that has thread
     ; affinity: much like OpenGL it expects each thread that accesses it to have been configured with a global Context
     ; object.  This method returns that.  Note that to help you develop, this method will <i>also</i> propagate whichever
     ; context was created last onto the current thread, if it's missing.  However it will print an error when doing so
     ; because propagation of contexts is meant to be done manually: this is so two libraries or subsystems that
     ; independently use bitcoinj (or possibly alt coin forks of it) can operate correctly.
     ;
     ; @throws java.lang.IllegalStateException if no context exists at all or if we are in strict mode and there is no context.
     ;;
    #_public
    #_static
    (ยง defn #_"Context" Context/get []
        (let [#_"Context" __tls (.. Context/SLOT (get))]
            (when (nil? __tls)
                (when Context/IS_STRICT_MODE
                    (.. Context/log (error "Thread is missing a bitcoinj context."))
                    (.. Context/log (error "You should use Context.propagate() or a ContextPropagatingThreadFactory."))
                    (throw (IllegalStateException. "missing context"))
                )
                (when (nil? Context/LAST_CONSTRUCTED)
                    (throw (IllegalStateException. "You must construct a Context object before using bitcoinj!"))
                )
                (.. Context/SLOT (set Context/LAST_CONSTRUCTED))
                (.. Context/log (error "Performing thread fixup: you are accessing bitcoinj via a thread that has not had any context set on it."))
                (.. Context/log (error "This error has been corrected for, but doing this makes your app less robust."))
                (.. Context/log (error "You should use Context.propagate() or a ContextPropagatingThreadFactory."))
                (.. Context/log (error "Please refer to the user guide for more information about this."))
                (.. Context/log (error "Thread name is {}.", (.. (Thread/currentThread) (getName))))
                ;; TODO: Actually write the user guide section about this.
                (ยง return Context/LAST_CONSTRUCTED)
            )

            __tls
        )
    )

    ;;;
     ; Require that new threads use {@link #propagate(Context)} or {@link org.bitcoinj.utils.ContextPropagatingThreadFactory},
     ; rather than using a heuristic for the desired context.
     ;;
    #_public
    #_static
    (ยง defn #_"void" Context/enableStrictMode []
        (ยง ass Context/IS_STRICT_MODE true)
        nil
    )

    ;; A temporary internal shim designed to help us migrate internally in a way that doesn't wreck source compatibility.
    #_public
    #_static
    (ยง defn #_"Context" Context/getOrCreate [#_"NetworkParameters" __params]
        (let [#_"Context" __context]
            (try
                (ยง ass __context (Context/get))
                (catch IllegalStateException __e
                    (.. Context/log (warn "Implicitly creating context. This is a migration step and this message will eventually go away."))
                    (ยง ass __context (Context. __params))
                    (ยง return __context)
                )
            )
            (when (!= (.. __context (getParams)) __params)
                (throw (IllegalStateException. (str "Context does not match implicit network params: " (.. __context (getParams)) " vs " __params)))
            )
            __context
        )
    )

    ;;;
     ; Sets the given context as the current thread context.  You should use this if you create your own threads that
     ; want to create core BitcoinJ objects.  Generally, if a class can accept a Context in its constructor and might
     ; be used (even indirectly) by a thread, you will want to call this first.  Your task may be simplified by using
     ; a {@link org.bitcoinj.utils.ContextPropagatingThreadFactory}.
     ;;
    #_public
    #_static
    (ยง defn #_"void" Context/propagate [#_"Context" __context]
        (.. Context/SLOT (set (Preconditions/checkNotNull __context)))
        nil
    )

    ;;;
     ; Returns the {@link TxConfidenceTable} created by this context.  The pool tracks advertised
     ; and downloaded transactions so their confidence can be measured as a proportion of how many peers announced it.
     ; With an un-tampered with internet connection, the more peers announce a transaction the more confidence you can
     ; have that it's really valid.
     ;;
    #_public
    (ยง method #_"TxConfidenceTable" getConfidenceTable []
        (:confidence-table this)
    )

    ;;;
     ; Returns the {@link org.bitcoinj.core.NetworkParameters} specified when this context was (auto) created.  The
     ; network parameters defines various hard coded constants for a specific instance of a Bitcoin network, such as
     ; main net, testnet, etc.
     ;;
    #_public
    (ยง method #_"NetworkParameters" getParams []
        (:params this)
    )

    ;;;
     ; The event horizon is the number of blocks after which various bits of the library consider a transaction to be
     ; so confirmed that it's safe to delete data.  Re-orgs larger than the event horizon will not be correctly
     ; processed, so the default value is high (100).
     ;;
    #_public
    (ยง method #_"int" getEventHorizon []
        (:event-horizon this)
    )

    ;;;
     ; The default fee per 1000 bytes of transaction data to pay when completing transactions.  For details, see {@link SendRequest#feePerKb}.
     ;;
    #_public
    (ยง method #_"Coin" getFeePerKb []
        (:fee-per-kb this)
    )

    ;;;
     ; Whether to ensure the minimum required fee by default when completing transactions.  For details, see {@link SendRequest#ensureMinRequiredFee}.
     ;;
    #_public
    (ยง method #_"boolean" isEnsureMinRequiredFee []
        (:ensure-min-required-fee this)
    )
)

;;;
 ; <p>Represents an elliptic curve public and (optionally) private key, usable for digital signatures but not encryption.
 ; Creating a new ECKey with the empty constructor will generate a new random keypair.  Other static methods can be used
 ; when you already have the public or private parts.  If you create a key with only the public part, you can check
 ; signatures but not create them.</p>
 ;
 ; <p>ECKey also provides access to Bitcoin Core compatible text message signing, as accessible via the UI or JSON-RPC.
 ; This is slightly different to signing raw bytes - if you want to sign your own data and it won't be exposed as
 ; text to people, you don't want to use this.  If in doubt, ask on the mailing list.</p>
 ;
 ; <p>The ECDSA algorithm supports <i>key recovery</i> in which a signature plus a couple of discriminator bits can
 ; be reversed to find the public key used to calculate it.  This can be convenient when you have a message and a
 ; signature and want to find out who signed it, rather than requiring the user to provide the expected identity.</p>
 ;
 ; <p>This class supports a variety of serialization forms.  The methods that accept/return byte arrays serialize
 ; private keys as raw byte arrays and public keys using the SEC standard byte encoding for public keys.  Signatures
 ; are encoded using ASN.1/DER inside the Bitcoin protocol.</p>
 ;
 ; <p>A key can be <i>compressed</i> or <i>uncompressed</i>.  This refers to whether the public key is represented
 ; when encoded into bytes as an (x, y) coordinate on the elliptic curve, or whether it's represented as just an X
 ; co-ordinate and an extra byte that carries a sign bit.  With the latter form the Y coordinate can be calculated
 ; dynamically, however, <b>because the binary serialization is different the address of a key changes if its
 ; compression status is changed</b>.  If you deviate from the defaults it's important to understand this: money sent
 ; to a compressed version of the key will have a different address to the same key in uncompressed form.  Whether
 ; a public key is compressed or not is recorded in the SEC binary serialisation format, and preserved in a flag in
 ; this class so round-tripping preserves state.  Unless you're working with old software or doing unusual things, you
 ; can usually ignore the compressed/uncompressed distinction.</p>
 ;;
#_public
(ยง class ECKey (ยง implements EncryptableItem)
    #_private
    #_static
    (ยง def- #_"Logger" ECKey/log (LoggerFactory/getLogger ECKey))

    ;;; Sorts oldest keys first, newest last. ;;
    #_public
    #_static
    (ยง def #_"Comparator<ECKey>" ECKey/AGE_COMPARATOR (Comparator. #_"<ECKey>"
        (ยง anon
            #_override
            #_public
            (ยง method #_"int" compare [#_"ECKey" __k1, #_"ECKey" __k2]
                (when (== (:creation-time-seconds __k1) (:creation-time-seconds __k2))
                    (ยง return 0)
                )

                (if (< (:creation-time-seconds __k1) (:creation-time-seconds __k2)) -1 1)
            )
        )))

    ;;; Compares pub key bytes using {@link com.google.common.primitives.UnsignedBytes#lexicographicalComparator()}. ;;
    #_public
    #_static
    (ยง def #_"Comparator<ECKey>" ECKey/PUBKEY_COMPARATOR (Comparator. #_"<ECKey>"
        (ยง anon
            #_private
            (ยง field- #_"Comparator<byte[]>" :comparator (UnsignedBytes/lexicographicalComparator))

            #_override
            #_public
            (ยง method #_"int" compare [#_"ECKey" __k1, #_"ECKey" __k2]
                (.. (:comparator this) (compare (.. __k1 (getPubKey)), (.. __k2 (getPubKey))))
            )
        )))

    ;; The parameters of the secp256k1 curve that Bitcoin uses.
    #_private
    #_static
    (ยง def- #_"X9ECParameters" ECKey/CURVE_PARAMS (CustomNamedCurves/getByName "secp256k1"))

    #_static
    (ยง block
        ;; Tell Bouncy Castle to precompute data that's needed during secp256k1 calculations.  Increasing the width
        ;; number makes calculations faster, but at a cost of extra memory usage and with decreasing returns.  12 was
        ;; picked after consulting with the BC team.
        (FixedPointUtil/precompute (.. ECKey/CURVE_PARAMS (getG)), 12)
    )

    ;;; The parameters of the secp256k1 curve that Bitcoin uses. ;;
    #_public
    #_static
    (ยง def #_"ECDomainParameters" ECKey/CURVE (ECDomainParameters. (.. ECKey/CURVE_PARAMS (getCurve)), (.. ECKey/CURVE_PARAMS (getG)), (.. ECKey/CURVE_PARAMS (getN)), (.. ECKey/CURVE_PARAMS (getH))))

    ;;;
     ; Equal to CURVE.getN().shiftRight(1), used for canonicalising the S value of a signature.
     ; If you aren't sure what this is about, you can ignore it.
     ;;
    #_public
    #_static
    (ยง def #_"BigInteger" ECKey/HALF_CURVE_ORDER (.. ECKey/CURVE_PARAMS (getN) (shiftRight 1)))

    #_private
    #_static
    (ยง def- #_"SecureRandom" ECKey/SECURE_RANDOM (SecureRandom.))

    ;; The two parts of the key.  If "priv" is set, "pub" can always be calculated.  If "pub" is set but not "priv", we
    ;; can only verify signatures not make them.
    #_protected
    (ยง field #_"BigInteger" :priv) ;; A field element.
    #_protected
    (ยง field #_"LazyECPoint" :pub)

    ;; Creation time of the key in seconds since the epoch, or zero if the key was deserialized from a version that did
    ;; not have this field.
    #_protected
    (ยง field #_"long" :creation-time-seconds)

    #_protected
    (ยง field #_"KeyCrypter" :key-crypter)
    #_protected
    (ยง field #_"EncryptedData" :encrypted-private-key)

    #_private
    (ยง field- #_"byte[]" :pub-key-hash)

    ;;;
     ; Generates an entirely new keypair.  Point compression is used so the resulting public key will be 33 bytes
     ; (32 for the co-ordinate and 1 byte to represent the y bit).
     ;;
    #_public
    (ยง constructor ECKey []
        (ยง this ECKey/SECURE_RANDOM)
        this
    )

    ;;;
     ; Generates an entirely new keypair with the given {@link SecureRandom} object.  Point compression is used so the
     ; resulting public key will be 33 bytes (32 for the co-ordinate and 1 byte to represent the y bit).
     ;;
    #_public
    (ยง constructor ECKey [#_"SecureRandom" __secureRandom]
        (let [#_"ECKeyPairGenerator" __generator (ECKeyPairGenerator.)
              #_"ECKeyGenerationParameters" __keygenParams (ECKeyGenerationParameters. ECKey/CURVE, __secureRandom)]
            (.. __generator (init __keygenParams))
            (let [#_"AsymmetricCipherKeyPair" __keypair (.. __generator (generateKeyPair))
                  #_"ECPrivateKeyParameters" __privParams (cast ECPrivateKeyParameters (.. __keypair (getPrivate)))
                  #_"ECPublicKeyParameters" __pubParams (cast ECPublicKeyParameters (.. __keypair (getPublic)))]
                (ยง assoc this :priv (.. __privParams (getD)))
                (ยง assoc this :pub (LazyECPoint. (.. ECKey/CURVE (getCurve)), (.. __pubParams (getQ) (getEncoded true))))
                (ยง assoc this :creation-time-seconds (Utils/currentTimeSeconds))
                this
            )
        )
    )

    #_protected
    (ยง constructor ECKey [#_nilable #_"BigInteger" __priv, #_"ECPoint" __pub]
        (ยง this __priv, (LazyECPoint. (Preconditions/checkNotNull __pub)))
        this
    )

    #_protected
    (ยง constructor ECKey [#_nilable #_"BigInteger" __priv, #_"LazyECPoint" __pub]
        (when (some? __priv)
            (Preconditions/checkArgument (<= (.. __priv (bitLength)) (<< 32 3)), "private key exceeds 32 bytes: {} bits", (.. __priv (bitLength)))
            ;; Try and catch buggy callers or bad key imports, etc.  Zero and one are special because these are often
            ;; used as sentinel values and because scripting languages have a habit of auto-casting true and false to
            ;; 1 and 0 or vice-versa.  Type confusion bugs could therefore result in private keys with these values.
            (Preconditions/checkArgument (not (.. __priv (equals BigInteger/ZERO))))
            (Preconditions/checkArgument (not (.. __priv (equals BigInteger/ONE))))
        )
        (ยง assoc this :priv __priv)
        (ยง assoc this :pub (Preconditions/checkNotNull __pub))
        this
    )

    ;;;
     ; Utility for compressing an elliptic curve point.  Returns the same point if it's already compressed.
     ; See the ECKey class docs for a discussion of point compression.
     ;;
    #_public
    #_static
    (ยง defn #_"ECPoint" ECKey/compressPoint [#_"ECPoint" __point]
        (ECKey/getPointWithCompression __point, true)
    )

    #_public
    #_static
    (ยง defn #_"LazyECPoint" ECKey/compressPoint [#_"LazyECPoint" __point]
        (if (.. __point (isCompressed)) __point (LazyECPoint. (ECKey/compressPoint (.. __point (get)))))
    )

    ;;;
     ; Utility for decompressing an elliptic curve point.  Returns the same point if it's already compressed.
     ; See the ECKey class docs for a discussion of point compression.
     ;;
    #_public
    #_static
    (ยง defn #_"ECPoint" ECKey/decompressPoint [#_"ECPoint" __point]
        (ECKey/getPointWithCompression __point, false)
    )

    #_public
    #_static
    (ยง defn #_"LazyECPoint" ECKey/decompressPoint [#_"LazyECPoint" __point]
        (if (not (.. __point (isCompressed))) __point (LazyECPoint. (ECKey/decompressPoint (.. __point (get)))))
    )

    #_private
    #_static
    (ยง defn- #_"ECPoint" ECKey/getPointWithCompression [#_"ECPoint" __point, #_"boolean" __compressed]
        (when (== (.. __point (isCompressed)) __compressed)
            (ยง return __point)
        )

        (ยง ass __point (.. __point (normalize)))
        (let [#_"BigInteger" __x (.. __point (getAffineXCoord) (toBigInteger))
              #_"BigInteger" __y (.. __point (getAffineYCoord) (toBigInteger))]
            (.. ECKey/CURVE (getCurve) (createPoint __x, __y, __compressed))
        )
    )

    ;;;
     ; Construct an ECKey from an ASN.1 encoded private key.  These are produced by OpenSSL and stored by Bitcoin
     ; Core in its wallet.  Note that this is slow because it requires an EC point multiply.
     ;;
    #_public
    #_static
    (ยง defn #_"ECKey" ECKey/fromASN1 [#_"byte[]" __asn1privkey]
        (ECKey/extractKeyFromASN1 __asn1privkey)
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow).  The resulting
     ; public key is compressed.
     ;;
    #_public
    #_static
    (ยง defn #_"ECKey" ECKey/fromPrivate [#_"BigInteger" __privKey]
        (ECKey/fromPrivate __privKey, true)
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow), either
     ; compressed or not.
     ;;
    #_public
    #_static
    (ยง defn #_"ECKey" ECKey/fromPrivate [#_"BigInteger" __privKey, #_"boolean" __compressed]
        (let [#_"ECPoint" __point (ECKey/publicPointFromPrivate __privKey)]
            (ECKey. __privKey, (ECKey/getPointWithCompression __point, __compressed))
        )
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow).  The resulting
     ; public key is compressed.
     ;;
    #_public
    #_static
    (ยง defn #_"ECKey" ECKey/fromPrivate [#_"byte[]" __privKeyBytes]
        (ECKey/fromPrivate (BigInteger. 1, __privKeyBytes))
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow), either
     ; compressed or not.
     ;;
    #_public
    #_static
    (ยง defn #_"ECKey" ECKey/fromPrivate [#_"byte[]" __privKeyBytes, #_"boolean" __compressed]
        (ECKey/fromPrivate (BigInteger. 1, __privKeyBytes), __compressed)
    )

    ;;;
     ; Creates an ECKey that simply trusts the caller to ensure that point is really the result of multiplying the
     ; generator point by the private key.  This is used to speed things up when you know you have the right values
     ; already.  The compression state of pub will be preserved.
     ;;
    #_public
    #_static
    (ยง defn #_"ECKey" ECKey/fromPrivateAndPrecalculatedPublic [#_"BigInteger" __priv, #_"ECPoint" __pub]
        (ECKey. __priv, __pub)
    )

    ;;;
     ; Creates an ECKey that simply trusts the caller to ensure that point is really the result of multiplying the
     ; generator point by the private key.  This is used to speed things up when you know you have the right values
     ; already.  The compression state of the point will be preserved.
     ;;
    #_public
    #_static
    (ยง defn #_"ECKey" ECKey/fromPrivateAndPrecalculatedPublic [#_"byte[]" __priv, #_"byte[]" __pub]
        (Preconditions/checkNotNull __priv)
        (Preconditions/checkNotNull __pub)
        (ECKey. (BigInteger. 1, __priv), (.. ECKey/CURVE (getCurve) (decodePoint __pub)))
    )

    ;;;
     ; Creates an ECKey that cannot be used for signing, only verifying signatures, from the given point.
     ; The compression state of pub will be preserved.
     ;;
    #_public
    #_static
    (ยง defn #_"ECKey" ECKey/fromPublicOnly [#_"ECPoint" __pub]
        (ECKey. nil, __pub)
    )

    ;;;
     ; Creates an ECKey that cannot be used for signing, only verifying signatures, from the given encoded point.
     ; The compression state of pub will be preserved.
     ;;
    #_public
    #_static
    (ยง defn #_"ECKey" ECKey/fromPublicOnly [#_"byte[]" __pub]
        (ECKey. nil, (.. ECKey/CURVE (getCurve) (decodePoint __pub)))
    )

    ;;;
     ; Returns a copy of this key, but with the public point represented in uncompressed form.  Normally you would
     ; never need this: it's for specialised scenarios or when backwards compatibility in encoded form is necessary.
     ;;
    #_public
    (ยง method #_"ECKey" decompress []
        (if (.. (:pub this) (isCompressed)) (ECKey. (:priv this), (ECKey/decompressPoint (.. (:pub this) (get)))) this)
    )

    ;;;
     ; Creates an ECKey given only the private key bytes.  This is the same as using the BigInteger constructor, but
     ; is more convenient if you are importing a key from elsewhere.  The public key will be automatically derived
     ; from the private key.
     ;;
    #_deprecated
    #_public
    (ยง constructor ECKey [#_nilable #_"byte[]" __privKeyBytes, #_nilable #_"byte[]" __pubKey]
        (ยง this (when (some? __privKeyBytes) (BigInteger. 1, __privKeyBytes)), __pubKey)
        this
    )

    ;;;
     ; Create a new ECKey with an encrypted private key, a public key and a KeyCrypter.
     ;
     ; @param encryptedPrivateKey The encrypted private key.
     ; @param pubKey The public key.
     ; @param keyCrypter The KeyCrypter that will be used, with an AES key, to encrypt and decrypt the private key.
     ;;
    #_deprecated
    #_public
    (ยง constructor ECKey [#_"EncryptedData" __encryptedPrivateKey, #_"byte[]" __pubKey, #_"KeyCrypter" __keyCrypter]
        (ยง this (ยง cast #_"byte[]" nil), __pubKey)

        (ยง assoc this :key-crypter (Preconditions/checkNotNull __keyCrypter))
        (ยง assoc this :encrypted-private-key __encryptedPrivateKey)
        this
    )

    ;;;
     ; Constructs a key that has an encrypted private component.  The given object wraps encrypted bytes and an
     ; initialization vector.  Note that the key will not be decrypted during this call: the returned ECKey is
     ; unusable for signing unless a decryption key is supplied.
     ;;
    #_public
    #_static
    (ยง defn #_"ECKey" ECKey/fromEncrypted [#_"EncryptedData" __encryptedPrivateKey, #_"KeyCrypter" __crypter, #_"byte[]" __pubKey]
        (let [#_"ECKey" __key (ECKey/fromPublicOnly __pubKey)]
            (ยง assoc __key :encrypted-private-key (Preconditions/checkNotNull __encryptedPrivateKey))
            (ยง assoc __key :key-crypter (Preconditions/checkNotNull __crypter))
            __key
        )
    )

    ;;;
     ; Creates an ECKey given either the private key only, the public key only, or both.  If only the private key
     ; is supplied, the public key will be calculated from it (this is slow).  If both are supplied, it's assumed
     ; the public key already correctly matches the private key.  If only the public key is supplied, this ECKey
     ; cannot be used for signing.
     ; @param compressed If set to true and pubKey is null, the derived public key will be in compressed form.
     ;;
    #_deprecated
    #_public
    (ยง constructor ECKey [#_nilable #_"BigInteger" __privKey, #_nilable #_"byte[]" __pubKey, #_"boolean" __compressed]
        (when (and (nil? __privKey) (nil? __pubKey))
            (throw (IllegalArgumentException. "ECKey requires at least private or public key"))
        )
        (ยง assoc this :priv __privKey)
        (cond (nil? __pubKey)
            (do
                ;; Derive public from private.
                (let [#_"ECPoint" __point (ECKey/publicPointFromPrivate __privKey)]
                    (ยง ass __point (ECKey/getPointWithCompression __point, __compressed))
                    (ยง assoc this :pub (LazyECPoint. __point))
                )
            )
            :else
            (do
                ;; We expect the pubkey to be in regular encoded form, just as a BigInteger.
                ;; Therefore the first byte is a special marker byte.
                ;; TODO: This is probably not a useful API and may be confusing.
                (ยง assoc this :pub (LazyECPoint. (.. ECKey/CURVE (getCurve)), __pubKey))
            )
        )
        this
    )

    ;;;
     ; Creates an ECKey given either the private key only, the public key only, or both.  If only the private key
     ; is supplied, the public key will be calculated from it (this is slow).  If both are supplied, it's assumed
     ; the public key already correctly matches the public key.  If only the public key is supplied, this ECKey cannot
     ; be used for signing.
     ;;
    #_deprecated
    #_private
    (ยง constructor- #_"ECKey" [#_nilable #_"BigInteger" __privKey, #_nilable #_"byte[]" __pubKey]
        (ยง this __privKey, __pubKey, false)
        this
    )

    ;;;
     ; Returns true if this key doesn't have unencrypted access to private key bytes.  This may be because
     ; it was never given any private key bytes to begin with (a watching key), or because the key is encrypted.
     ; You can use {@link #isEncrypted()} to tell the cases apart.
     ;;
    #_public
    (ยง method #_"boolean" isPubKeyOnly []
        (nil? (:priv this))
    )

    ;;;
     ; Returns true if this key has unencrypted access to private key bytes.
     ; Does the opposite of {@link #isPubKeyOnly()}.
     ;;
    #_public
    (ยง method #_"boolean" hasPrivKey []
        (some? (:priv this))
    )

    ;;; Returns true if this key is watch only, meaning it has a public key but no private key. ;;
    #_public
    (ยง method #_"boolean" isWatching []
        (and (.. this (isPubKeyOnly)) (not (.. this (isEncrypted))))
    )

    ;;;
     ; Output this ECKey as an ASN.1 encoded private key, as understood by OpenSSL or used by Bitcoin Core
     ; in its wallet storage format.
     ; @throws org.bitcoinj.core.ECKey.MissingPrivateKeyException if the private key is missing or encrypted.
     ;;
    #_public
    (ยง method #_"byte[]" toASN1 []
        (try
            (let [#_"byte[]" __privKeyBytes (.. this (getPrivKeyBytes))
                  #_"ByteArrayOutputStream" __baos (ByteArrayOutputStream. 400)]

                ;; ASN1_SEQUENCE(EC_PRIVATEKEY) = {
                ;;   ASN1_SIMPLE(EC_PRIVATEKEY, version, LONG),
                ;;   ASN1_SIMPLE(EC_PRIVATEKEY, privateKey, ASN1_OCTET_STRING),
                ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, parameters, ECPKPARAMETERS, 0),
                ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, publicKey, ASN1_BIT_STRING, 1)
                ;; } ASN1_SEQUENCE_END(EC_PRIVATEKEY)
                (let [#_"DERSequenceGenerator" __seq (DERSequenceGenerator. __baos)]
                    (.. __seq (addObject (ASN1Integer. 1))) ;; version
                    (.. __seq (addObject (DEROctetString. __privKeyBytes)))
                    (.. __seq (addObject (DERTaggedObject. 0, (.. ECKey/CURVE_PARAMS (toASN1Primitive)))))
                    (.. __seq (addObject (DERTaggedObject. 1, (DERBitString. (.. this (getPubKey))))))
                    (.. __seq (close))
                    (ยง return (.. __baos (toByteArray)))
                )
            )
            (catch IOException __e
                (throw (RuntimeException. __e)) ;; Cannot happen, writing to memory stream.
            )
        )
    )

    ;;;
     ; Returns public key bytes from the given private key.  To convert a byte array into a BigInteger, use <tt>new BigInteger(1, bytes)</tt>.
     ;;
    #_public
    #_static
    (ยง defn #_"byte[]" ECKey/publicKeyFromPrivate [#_"BigInteger" __privKey, #_"boolean" __compressed]
        (.. (ECKey/publicPointFromPrivate __privKey) (getEncoded __compressed))
    )

    ;;;
     ; Returns public key point from the given private key.  To convert a byte array into a BigInteger, use <tt>new BigInteger(1, bytes)</tt>.
     ;;
    #_public
    #_static
    (ยง defn #_"ECPoint" ECKey/publicPointFromPrivate [#_"BigInteger" __privKey]
        ;;
         ; TODO: FixedPointCombMultiplier currently doesn't support scalars longer than the group order,
         ; but that could change in future versions.
         ;;
        (when (< (.. ECKey/CURVE (getN) (bitLength)) (.. __privKey (bitLength)))
            (ยง ass __privKey (.. __privKey (mod (.. ECKey/CURVE (getN)))))
        )

        (.. (FixedPointCombMultiplier.) (multiply (.. ECKey/CURVE (getG)), __privKey))
    )

    ;;; Gets the hash160 form of the public key (as seen in addresses). ;;
    #_public
    (ยง method #_"byte[]" getPubKeyHash []
        (when (nil? (:pub-key-hash this))
            (ยง assoc this :pub-key-hash (Utils/sha256hash160 (.. (:pub this) (getEncoded))))
        )

        (:pub-key-hash this)
    )

    ;;;
     ; Gets the raw public key value.  This appears in transaction scriptSigs.  Note that this is <b>not</b> the same
     ; as the pubKeyHash/address.
     ;;
    #_public
    (ยง method #_"byte[]" getPubKey []
        (.. (:pub this) (getEncoded))
    )

    ;;; Gets the public key in the form of an elliptic curve point object from Bouncy Castle. ;;
    #_public
    (ยง method #_"ECPoint" getPubKeyPoint []
        (.. (:pub this) (get))
    )

    ;;;
     ; Gets the private key in the form of an integer field element.  The public key is derived by performing EC
     ; point addition this number of times (i.e. point multiplying).
     ;
     ; @throws java.lang.IllegalStateException if the private key bytes are not available.
     ;;
    #_public
    (ยง method #_"BigInteger" getPrivKey []
        (when (nil? (:priv this))
            (throw (ECKey.MissingPrivateKeyException.))
        )

        (:priv this)
    )

    ;;;
     ; Returns whether this key is using the compressed form or not.  Compressed pubkeys are only 33 bytes, not 64.
     ;;
    #_public
    (ยง method #_"boolean" isCompressed []
        (.. (:pub this) (isCompressed))
    )

    ;;;
     ; Returns the address that corresponds to the public part of this ECKey.  Note that an address is derived from
     ; the RIPEMD-160 hash of the public key and is not the public key itself (which is too large to be convenient).
     ;;
    #_public
    (ยง method #_"Address" toAddress [#_"NetworkParameters" __params]
        (Address. __params, (.. this (getPubKeyHash)))
    )

    ;;;
     ; Groups the two components that make up a signature, and provides a way to encode to DER form, which is
     ; how ECDSA signatures are represented when embedded in other data structures in the Bitcoin protocol.
     ; The raw components can be useful for doing further EC maths on them.
     ;;
    #_public
    #_static
    (ยง class ECKey.ECDSASignature
        ;;; The two components of the signature. ;;
        #_public
        (ยง field #_"BigInteger" :r)
        #_public
        (ยง field #_"BigInteger" :s)

        ;;;
         ; Constructs a signature with the given components.  Does NOT automatically canonicalise the signature.
         ;;
        #_public
        (ยง constructor ECKey.ECDSASignature [#_"BigInteger" __r, #_"BigInteger" __s]
            (ยง assoc this :r __r)
            (ยง assoc this :s __s)
            this
        )

        ;;;
         ; Returns true if the S component is "low", that means it is below {@link ECKey#HALF_CURVE_ORDER}.  See
         ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki#Low_S_values_in_signatures">BIP62</a>.
         ;;
        #_public
        (ยง method #_"boolean" isCanonical []
            (<= (.. (:s this) (compareTo ECKey/HALF_CURVE_ORDER)) 0)
        )

        ;;;
         ; Will automatically adjust the S component to be less than or equal to half the curve order, if necessary.
         ; This is required because for every signature (r, s) the signature (r, -s (mod N)) is a valid signature of
         ; the same message.  However, we dislike the ability to modify the bits of a Bitcoin transaction after it's
         ; been signed, as that violates various assumed invariants.  Thus in future only one of those forms will be
         ; considered legal and the other will be banned.
         ;;
        #_public
        (ยง method #_"ECKey.ECDSASignature" toCanonicalised []
            (when (not (.. this (isCanonical)))
                ;; The order of the curve is the number of valid points that exist on that curve.  If S is in the upper
                ;; half of the number of valid points, then bring it back to the lower half.  Otherwise, imagine that
                ;;    N = 10
                ;;    s = 8, so (-8 % 10 == 2) thus both (r, 8) and (r, 2) are valid solutions.
                ;;    10 - 8 == 2, giving us always the latter solution, which is canonical.
                (ยง return (ECKey.ECDSASignature. (:r this), (.. ECKey/CURVE (getN) (subtract (:s this)))))
            )

            this
        )

        ;;;
         ; DER is an international standard for serializing data structures which is widely used in cryptography.
         ; It's somewhat like protocol buffers but less convenient.  This method returns a standard DER encoding
         ; of the signature, as recognized by OpenSSL and other libraries.
         ;;
        #_public
        (ยง method #_"byte[]" encodeToDER []
            (try
                (ยง return (.. this (derByteStream) (toByteArray)))
                (catch IOException __e
                    (throw (RuntimeException. __e)) ;; Cannot happen.
                )
            )
        )

        #_public
        #_static
        #_throws #_[ "IllegalArgumentException" ]
        (ยง defn #_"ECKey.ECDSASignature" ECKey.ECDSASignature/decodeFromDER [#_"byte[]" __bytes]
            (let [#_"ASN1InputStream" __decoder nil]
                (try
                    (ยง ass __decoder (ASN1InputStream. __bytes))
                    (let [#_"DLSequence" __seq (cast DLSequence (.. __decoder (readObject)))]
                        (when (nil? __seq)
                            (throw (IllegalArgumentException. "Reached past end of ASN.1 stream."))
                        )

                        (let [#_"ASN1Integer" __r
                              #_"ASN1Integer" __s]
                            (try
                                (ยง ass __r (cast ASN1Integer (.. __seq (getObjectAt 0))))
                                (ยง ass __s (cast ASN1Integer (.. __seq (getObjectAt 1))))
                                (catch ClassCastException __e
                                    (throw (IllegalArgumentException. __e))
                                )
                            )
                            ;; OpenSSL deviates from the DER spec by interpreting these values as unsigned, though they should not be.
                            ;; Thus, we always use the positive versions.  See http://r6.ca/blog/20111119T211504Z.html
                            (ยง return (ECKey.ECDSASignature. (.. __r (getPositiveValue)), (.. __s (getPositiveValue))))
                        )
                    )
                    (catch IOException __e
                        (throw (IllegalArgumentException. __e))
                    )
                    (finally
                        (when (some? __decoder)
                            (try
                                (.. __decoder (close))
                                (catch IOException _
                                )
                            )
                        )
                    )
                )
            )
        )

        #_protected
        #_throws #_[ "IOException" ]
        (ยง method #_"ByteArrayOutputStream" derByteStream []
            ;; Usually 70-72 bytes.
            (let [#_"ByteArrayOutputStream" __bos (ByteArrayOutputStream. 72)
                  #_"DERSequenceGenerator" __seq (DERSequenceGenerator. __bos)]
                (.. __seq (addObject (ASN1Integer. (:r this))))
                (.. __seq (addObject (ASN1Integer. (:s this))))
                (.. __seq (close))
                __bos
            )
        )

        #_override
        #_public
        (ยง method #_"boolean" equals [#_"Object" __o]
            (when (== this __o)
                (ยง return true)
            )
            (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
                (ยง return false)
            )
            (let [#_"ECKey.ECDSASignature" __other (cast ECKey.ECDSASignature __o)]
                (and (.. (:r this) (equals (:r __other))) (.. (:s this) (equals (:s __other))))
            )
        )

        #_override
        #_public
        (ยง method #_"int" hashCode []
            (Objects/hashCode (:r this), (:s this))
        )
    )

    ;;;
     ; Signs the given hash and returns the R and S components as BigIntegers.  In the Bitcoin protocol, they are
     ; usually encoded using ASN.1 format, so you want {@link org.bitcoinj.core.ECKey.ECDSASignature#toASN1()}
     ; instead.  However sometimes the independent components can be useful, for instance, if you're going to do
     ; further EC maths on them.
     ; @throws KeyCrypterException if this ECKey doesn't have a private part.
     ;;
    #_public
    #_throws #_[ "KeyCrypterException" ]
    (ยง method #_"ECKey.ECDSASignature" sign [#_"Sha256Hash" __input]
        (.. this (sign __input, nil))
    )

    ;;;
     ; If this global variable is set to true, sign() creates a dummy signature and verify() always returns true.
     ; This is intended to help accelerate unit tests that do a lot of signing/verifying, which in the debugger
     ; can be painfully slow.
     ;;
    #_testing
    #_public
    #_static
    (ยง def #_"boolean" ECKey/FAKE_SIGNATURES false)

    ;;;
     ; Signs the given hash and returns the R and S components as BigIntegers.  In the Bitcoin protocol, they are
     ; usually encoded using DER format, so you want {@link org.bitcoinj.core.ECKey.ECDSASignature#encodeToDER()}
     ; instead.  However sometimes the independent components can be useful, for instance, if you're doing to do further
     ; EC maths on them.
     ;
     ; @param aesKey The AES key to use for decryption of the private key.  If null, then no decryption is required.
     ; @throws KeyCrypterException if there's something wrong with aesKey.
     ; @throws ECKey.MissingPrivateKeyException if this key cannot sign because it's pubkey only.
     ;;
    #_public
    #_throws #_[ "KeyCrypterException" ]
    (ยง method #_"ECKey.ECDSASignature" sign [#_"Sha256Hash" __input, #_nilable #_"KeyParameter" __aesKey]
        (let [#_"KeyCrypter" __crypter (.. this (getKeyCrypter))]
            (cond (some? __crypter)
                (do
                    (when (nil? __aesKey)
                        (throw (ECKey.KeyIsEncryptedException.))
                    )
                    (ยง return (.. this (decrypt __aesKey) (sign __input)))
                )
                :else
                (do
                    ;; No decryption of private key required.
                    (when (nil? (:priv this))
                        (throw (ECKey.MissingPrivateKeyException.))
                    )
                )
            )
            (.. this (doSign __input, (:priv this)))
        )
    )

    #_protected
    (ยง method #_"ECKey.ECDSASignature" doSign [#_"Sha256Hash" __input, #_"BigInteger" __privateKeyForSigning]
        (when ECKey/FAKE_SIGNATURES
            (ยง return (TransactionSignature/dummy))
        )

        (Preconditions/checkNotNull __privateKeyForSigning)

        (let [#_"ECDSASigner" __signer (ECDSASigner. (HMacDSAKCalculator. (SHA256Digest.)))
              #_"ECPrivateKeyParameters" __privKey (ECPrivateKeyParameters. __privateKeyForSigning, ECKey/CURVE)]
            (.. __signer (init true, __privKey))
            (let [#_"BigInteger[]" __components (.. __signer (generateSignature (.. __input (getBytes))))]
                (.. (ECKey.ECDSASignature. (aget __components 0), (aget __components 1)) (toCanonicalised))
            )
        )
    )

    ;;;
     ; <p>Verifies the given ECDSA signature against the message bytes using the public key bytes.</p>
     ;
     ; <p>When using native ECDSA verification, data must be 32 bytes, and no element may be
     ; larger than 520 bytes.</p>
     ;
     ; @param data      Hash of the data to verify.
     ; @param signature ASN.1 encoded signature.
     ; @param pub       The public key bytes to use.
     ;;
    #_public
    #_static
    (ยง defn #_"boolean" ECKey/verify [#_"byte[]" __data, #_"ECKey.ECDSASignature" __signature, #_"byte[]" __pub]
        (when ECKey/FAKE_SIGNATURES
            (ยง return true)
        )

        (let [#_"ECDSASigner" __signer (ECDSASigner.)
              #_"ECPublicKeyParameters" __params (ECPublicKeyParameters. (.. ECKey/CURVE (getCurve) (decodePoint __pub)), ECKey/CURVE)]
            (.. __signer (init false, __params))
            (try
                (ยง return (.. __signer (verifySignature __data, (:r __signature), (:s __signature))))
                (catch NullPointerException __e
                    ;; Bouncy Castle contains a bug that can cause NPEs given specially crafted signatures.  Those signatures
                    ;; are inherently invalid/attack sigs so we just fail them here rather than crash the thread.
                    (.. ECKey/log (error "Caught NPE inside bouncy castle", __e))
                    (ยง return false)
                )
            )
        )
    )

    ;;;
     ; Verifies the given ASN.1 encoded ECDSA signature against a hash using the public key.
     ;
     ; @param data      Hash of the data to verify.
     ; @param signature ASN.1 encoded signature.
     ; @param pub       The public key bytes to use.
     ;;
    #_public
    #_static
    (ยง defn #_"boolean" ECKey/verify [#_"byte[]" __data, #_"byte[]" __signature, #_"byte[]" __pub]
        (ECKey/verify __data, (ECKey.ECDSASignature/decodeFromDER __signature), __pub)
    )

    ;;;
     ; Verifies the given ASN.1 encoded ECDSA signature against a hash using the public key.
     ;
     ; @param hash      Hash of the data to verify.
     ; @param signature ASN.1 encoded signature.
     ;;
    #_public
    (ยง method #_"boolean" verify [#_"byte[]" __hash, #_"byte[]" __signature]
        (ECKey/verify __hash, __signature, (.. this (getPubKey)))
    )

    ;;;
     ; Verifies the given R/S pair (signature) against a hash using the public key.
     ;;
    #_public
    (ยง method #_"boolean" verify [#_"Sha256Hash" __sigHash, #_"ECKey.ECDSASignature" __signature]
        (ECKey/verify (.. __sigHash (getBytes)), __signature, (.. this (getPubKey)))
    )

    ;;;
     ; Verifies the given ASN.1 encoded ECDSA signature against a hash using the public key, and throws an exception
     ; if the signature doesn't match.
     ; @throws java.security.SignatureException if the signature does not match.
     ;;
    #_public
    #_throws #_[ "SignatureException" ]
    (ยง method #_"void" verifyOrThrow [#_"byte[]" __hash, #_"byte[]" __signature]
        (when (not (ECKey/verify __hash, __signature))
            (throw (SignatureException.))
        )
        nil
    )

    ;;;
     ; Verifies the given R/S pair (signature) against a hash using the public key, and throws an exception
     ; if the signature doesn't match.
     ; @throws java.security.SignatureException if the signature does not match.
     ;;
    #_public
    #_throws #_[ "SignatureException" ]
    (ยง method #_"void" verifyOrThrow [#_"Sha256Hash" __sigHash, #_"ECKey.ECDSASignature" __signature]
        (when (not (ECKey/verify (.. __sigHash (getBytes)), __signature, (.. this (getPubKey))))
            (throw (SignatureException.))
        )
        nil
    )

    ;;;
     ; Returns true if the given pubkey is canonical, i.e. the correct length taking into account compression.
     ;;
    #_public
    #_static
    (ยง defn #_"boolean" ECKey/isPubKeyCanonical [#_"byte[]" __pubkey]
        (cond
            (< (.. __pubkey (alength)) 33)       false
            (== (aget __pubkey 0) 0x04)          (== (.. __pubkey (alength)) 65) ;; Uncompressed pubkey.
            (any == (aget __pubkey 0) 0x02 0x03) (== (.. __pubkey (alength)) 33) ;; Compressed pubkey.
            :else                                false
        )
    )

    #_private
    #_static
    (ยง defn- #_"ECKey" ECKey/extractKeyFromASN1 [#_"byte[]" __asn1privkey]
        ;; To understand this code, see the definition of the ASN.1 format for EC private keys in the OpenSSL source
        ;; code in ec_asn1.c:
        ;;
        ;; ASN1_SEQUENCE(EC_PRIVATEKEY) = {
        ;;   ASN1_SIMPLE(EC_PRIVATEKEY, version, LONG),
        ;;   ASN1_SIMPLE(EC_PRIVATEKEY, privateKey, ASN1_OCTET_STRING),
        ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, parameters, ECPKPARAMETERS, 0),
        ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, publicKey, ASN1_BIT_STRING, 1)
        ;; } ASN1_SEQUENCE_END(EC_PRIVATEKEY)
        (try
            (let [#_"ASN1InputStream" __decoder (ASN1InputStream. __asn1privkey)
                  #_"DLSequence" __seq (cast DLSequence (.. __decoder (readObject)))]
                (Preconditions/checkArgument (nil? (.. __decoder (readObject))), "Input contains extra bytes")
                (.. __decoder (close))

                (Preconditions/checkArgument (== (.. __seq (size)) 4), "Input does not appear to be an ASN.1 OpenSSL EC private key")

                (Preconditions/checkArgument (.. (cast ASN1Integer (.. __seq (getObjectAt 0))) (getValue) (equals BigInteger/ONE)), "Input is of wrong version")

                (let [#_"byte[]" __privbits (.. (cast ASN1OctetString (.. __seq (getObjectAt 1))) (getOctets))
                      #_"BigInteger" __privkey (BigInteger. 1, __privbits)]

                    (let [#_"ASN1TaggedObject" __pubkey (cast ASN1TaggedObject (.. __seq (getObjectAt 3)))]
                        (Preconditions/checkArgument (== (.. __pubkey (getTagNo)) 1), "Input has 'publicKey' with bad tag number")
                        (let [#_"byte[]" __pubbits (.. (cast DERBitString (.. __pubkey (getObject))) (getBytes))]
                            (Preconditions/checkArgument (any == (.. __pubbits (alength)) 33 65), "Input has 'publicKey' with invalid length")
                            (let [#_"int" __encoding (& 0xff (aget __pubbits 0))]
                                ;; Only allow compressed(2,3) and uncompressed(4), not infinity(0) or hybrid(6,7).
                                (Preconditions/checkArgument (<= 2 __encoding 4), "Input has 'publicKey' with invalid encoding")

                                ;; Now sanity check to ensure the pubkey bytes match the privkey.
                                (let [#_"boolean" __compressed (== (.. __pubbits (alength)) 33)
                                      #_"ECKey" __key (ECKey. __privkey, nil, __compressed)]
                                    (when (not (Arrays/equals (.. __key (getPubKey)), __pubbits))
                                        (throw (IllegalArgumentException. "Public key in ASN.1 structure does not match private key."))
                                    )
                                    (ยง return __key)
                                )
                            )
                        )
                    )
                )
            )
            (catch IOException __e
                (throw (RuntimeException. __e)) ;; Cannot happen, reading from memory stream.
            )
        )
    )

    ;;;
     ; Signs a text message using the standard Bitcoin messaging signing format and returns the signature as a base64
     ; encoded string.
     ;
     ; @throws IllegalStateException if this ECKey does not have the private part.
     ; @throws KeyCrypterException if this ECKey is encrypted and no AESKey is provided or it does not decrypt the ECKey.
     ;;
    #_public
    #_throws #_[ "KeyCrypterException" ]
    (ยง method #_"String" signMessage [#_"String" __message]
        (.. this (signMessage __message, nil))
    )

    ;;;
     ; Signs a text message using the standard Bitcoin messaging signing format and returns the signature as a base64
     ; encoded string.
     ;
     ; @throws IllegalStateException if this ECKey does not have the private part.
     ; @throws KeyCrypterException if this ECKey is encrypted and no AESKey is provided or it does not decrypt the ECKey.
     ;;
    #_public
    #_throws #_[ "KeyCrypterException" ]
    (ยง method #_"String" signMessage [#_"String" __message, #_nilable #_"KeyParameter" __aesKey]
        (let [#_"byte[]" __data (Utils/formatMessageForSigning __message)
              #_"Sha256Hash" __hash (Sha256Hash/twiceOf __data)
              #_"ECKey.ECDSASignature" __sig (.. this (sign __hash, __aesKey))]
            ;; Now we have to work backwards to figure out the recId needed to recover the signature.
            (let [#_"int" __recId -1]
                (loop-when-recur [#_"int" __i 0] (< __i 4) [(inc __i)]
                    (let [#_"ECKey" __k (ECKey/recoverFromSignature __i, __sig, __hash, (.. this (isCompressed)))]
                        (when (and (some? __k) (.. (:pub __k) (equals (:pub this))))
                            (ยง ass __recId __i)
                            (ยง break )
                        )
                    )
                )
                (when (== __recId -1)
                    (throw (RuntimeException. "Could not construct a recoverable key. This should never happen."))
                )
                (let [#_"int" __headerByte (+ __recId 27 (if (.. this (isCompressed)) 4 0))
                      #_"byte[]" __sigData (byte-array 65)] ;; 1 header + 32 bytes for R + 32 bytes for S
                    (aset __sigData 0 (byte __headerByte))
                    (System/arraycopy (Utils/bigIntegerToBytes (:r __sig), 32), 0, __sigData, 1, 32)
                    (System/arraycopy (Utils/bigIntegerToBytes (:s __sig), 32), 0, __sigData, 33, 32)
                    (String. (Base64/encode __sigData), (Charset/forName "UTF-8"))
                )
            )
        )
    )

    ;;;
     ; Given an arbitrary piece of text and a Bitcoin-format message signature encoded in base64, returns an ECKey
     ; containing the public key that was used to sign it.  This can then be compared to the expected public key to
     ; determine if the signature was correct.  These sorts of signatures are compatible with the Bitcoin-Qt/bitcoind
     ; format generated by signmessage/verifymessage RPCs and GUI menu options.  They are intended for humans to verify
     ; their communications with each other, hence the base64 format and the fact that the input is text.
     ;
     ; @param message Some piece of human readable text.
     ; @param signatureBase64 The Bitcoin-format message signature in base64.
     ; @throws SignatureException if the public key could not be recovered or if there was a signature format error.
     ;;
    #_public
    #_static
    #_throws #_[ "SignatureException" ]
    (ยง defn #_"ECKey" ECKey/signedMessageToKey [#_"String" __message, #_"String" __signatureBase64]
        (let [#_"byte[]" __signatureEncoded]
            (try
                (ยง ass __signatureEncoded (Base64/decode __signatureBase64))
                (catch RuntimeException __e
                    ;; This is what you get back from Bouncy Castle if base64 doesn't decode :( ;; )
                    (throw (SignatureException. "Could not decode base64", __e))
                )
            )
            ;; Parse the signature bytes into r/s and the selector value.
            (when (< (.. __signatureEncoded (alength)) 65)
                (throw (SignatureException. (str "Signature truncated, expected 65 bytes and got " (.. __signatureEncoded (alength)))))
            )

            (let [#_"int" __header (& 0xff (aget __signatureEncoded 0))]
                ;; The header byte: 0x1B = first key with even y, 0x1C = first key with odd y,
                ;;                  0x1D = second key with even y, 0x1E = second key with odd y.
                (when (not (<= 27 __header 34))
                    (throw (SignatureException. (str "Header byte out of range: " __header)))
                )
                (let [#_"BigInteger" __r (BigInteger. 1, (Arrays/copyOfRange __signatureEncoded, 1, 33))
                      #_"BigInteger" __s (BigInteger. 1, (Arrays/copyOfRange __signatureEncoded, 33, 65))
                      #_"ECKey.ECDSASignature" __sig (ECKey.ECDSASignature. __r, __s)
                      #_"byte[]" __messageBytes (Utils/formatMessageForSigning __message)]
                    ;; Note that the C++ code doesn't actually seem to specify any character encoding.
                    ;; Presumably it's whatever JSON-SPIRIT hands back.  Assume UTF-8 for now.
                    (let [#_"Sha256Hash" __messageHash (Sha256Hash/twiceOf __messageBytes)
                          #_"boolean" __compressed false]
                        (when (<= 31 __header)
                            (ยง ass __compressed true)
                            (ยง ass __header (- __header 4))
                        )
                        (let [#_"int" __recId (- __header 27)
                              #_"ECKey" __key (ECKey/recoverFromSignature __recId, __sig, __messageHash, __compressed)]
                            (when (nil? __key)
                                (throw (SignatureException. "Could not recover public key from signature"))
                            )
                            __key
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Convenience wrapper around {@link ECKey#signedMessageToKey(String, String)}.
     ; If the key derived from the signature is not the same as this one, throws a SignatureException.
     ;;
    #_public
    #_throws #_[ "SignatureException" ]
    (ยง method #_"void" verifyMessage [#_"String" __message, #_"String" __signatureBase64]
        (let [#_"ECKey" __key (ECKey/signedMessageToKey __message, __signatureBase64)]
            (when (not (.. (:pub __key) (equals (:pub this))))
                (throw (SignatureException. "Signature did not match for message"))
            )
            nil
        )
    )

    ;;;
     ; <p>Given the components of a signature and a selector value, recover and return the public key
     ; that generated the signature according to the algorithm in SEC1v2 section 4.1.6.</p>
     ;
     ; <p>The recId is an index from 0 to 3 which indicates which of the 4 possible keys is the correct one.  Because
     ; the key recovery operation yields multiple potential keys, the correct key must either be stored alongside the
     ; signature, or you must be willing to try each recId in turn until you find one that outputs the key you are
     ; expecting.</p>
     ;
     ; <p>If this method returns null it means recovery was not possible and recId should be iterated.</p>
     ;
     ; <p>Given the above two points, a correct usage of this method is inside a for loop from 0 to 3, and if the
     ; output is null OR a key that is not the one you expect, you try again with the next recId.</p>
     ;
     ; @param recId Which possible key to recover.
     ; @param sig The R and S components of the signature, wrapped.
     ; @param message Hash of the data that was signed.
     ; @param compressed Whether or not the original pubkey was compressed.
     ; @return An ECKey containing only the public part, or null if recovery wasn't possible.
     ;;
    #_nilable
    #_public
    #_static
    (ยง defn #_"ECKey" ECKey/recoverFromSignature [#_"int" __recId, #_"ECKey.ECDSASignature" __sig, #_"Sha256Hash" __message, #_"boolean" __compressed]
        (Preconditions/checkArgument (<= 0 __recId), "recId must be positive")
        (Preconditions/checkArgument (<= 0 (.. (:r __sig) (signum))), "r must be positive")
        (Preconditions/checkArgument (<= 0 (.. (:s __sig) (signum))), "s must be positive")
        (Preconditions/checkNotNull __message)

        ;; 1.0 For j from 0 to h   (h == recId here and the loop is outside this function)
        ;;   1.1 Let x = r + jn
        (let [#_"BigInteger" __n (.. ECKey/CURVE (getN))] ;; Curve order.
            (let [#_"BigInteger" __i (BigInteger/valueOf (/ (long __recId) 2))
                  #_"BigInteger" __x (.. (:r __sig) (add (.. __i (multiply __n))))]
                ;;   1.2. Convert the integer x to an octet string X of length mlen using the conversion routine
                ;;        specified in Section 2.3.7, where mlen = โ(log2 p)/8โ or mlen = โm/8โ.
                ;;   1.3. Convert the octet string (16 set binary digits)||X to an elliptic curve point R using the
                ;;        conversion routine specified in Section 2.3.4. If this conversion routine outputs โinvalidโ,
                ;;        then do another iteration of Step 1.
                ;;
                ;; More concisely, what these points mean is to use X as a compressed public key.
                (let [#_"BigInteger" __prime SecP256K1Curve/q]
                    ;; Cannot have point co-ordinates larger than this as everything takes place modulo Q.
                    (when (<= 0 (.. __x (compareTo __prime)))
                        (ยง return nil)
                    )

                    ;; Compressed keys require you to know an extra bit of data about the y-coord as there are two possibilities.
                    ;; So it's encoded in the recId.
                    (let [#_"ECPoint" __R (ECKey/decompressKey __x, (== (& __recId 1) 1))]
                        ;;   1.4. If nR != point at infinity, then do another iteration of Step 1 (callers responsibility).
                        (when (not (.. __R (multiply __n) (isInfinity)))
                            (ยง return nil)
                        )

                        ;;   1.5. Compute e from M using Steps 2 and 3 of ECDSA signature verification.
                        (let [#_"BigInteger" __e (.. __message (toBigInteger))]
                            ;;   1.6. For k from 1 to 2 do the following.   (loop is outside this function via iterating recId)
                            ;;   1.6.1. Compute a candidate public key as:
                            ;;               Q = mi(r) * (sR - eG)
                            ;;
                            ;; Where mi(x) is the modular multiplicative inverse. We transform this into the following:
                            ;;               Q = (mi(r) * s ** R) + (mi(r) * -e ** G)
                            ;; Where -e is the modular additive inverse of e, that is z such that z + e = 0 (mod n). In the above equation
                            ;; ** is point multiplication and + is point addition (the EC group operator).
                            ;;
                            ;; We can find the additive inverse by subtracting e from zero then taking the mod. For example the additive
                            ;; inverse of 3 modulo 11 is 8 because 3 + 8 mod 11 = 0, and -3 mod 11 = 8.
                            (let [#_"BigInteger" __eInv (.. BigInteger/ZERO (subtract __e) (mod __n))
                                  #_"BigInteger" __rInv (.. (:r __sig) (modInverse __n))
                                  #_"BigInteger" __srInv (.. __rInv (multiply (:s __sig)) (mod __n))
                                  #_"BigInteger" __eInvrInv (.. __rInv (multiply __eInv) (mod __n))
                                  #_"ECPoint" __q (ECAlgorithms/sumOfTwoMultiplies (.. ECKey/CURVE (getG)), __eInvrInv, __R, __srInv)]
                                (ECKey/fromPublicOnly (.. __q (getEncoded __compressed)))
                            )
                        )
                    )
                )
            )
        )
    )

    ;;; Decompress a compressed public key (x co-ord and low-bit of y-coord). ;;
    #_private
    #_static
    (ยง defn- #_"ECPoint" ECKey/decompressKey [#_"BigInteger" __xBN, #_"boolean" __yBit]
        (let [#_"X9IntegerConverter" __x9 (X9IntegerConverter.)
              #_"byte[]" __compEnc (.. __x9 (integerToBytes __xBN, (+ 1 (.. __x9 (getByteLength (.. ECKey/CURVE (getCurve)))))))]
            (aset __compEnc 0 (byte (if __yBit 0x03 0x02)))
            (.. ECKey/CURVE (getCurve) (decodePoint __compEnc))
        )
    )

    ;;;
     ; Returns a 32 byte array containing the private key.
     ; @throws org.bitcoinj.core.ECKey.MissingPrivateKeyException if the private key bytes are missing/encrypted.
     ;;
    #_public
    (ยง method #_"byte[]" getPrivKeyBytes []
        (Utils/bigIntegerToBytes (.. this (getPrivKey)), 32)
    )

    ;;;
     ; Returns the creation time of this key or zero if the key was deserialized from a version that did not store
     ; that data.
     ;;
    #_override
    #_public
    (ยง method #_"long" getCreationTimeSeconds []
        (:creation-time-seconds this)
    )

    ;;;
     ; Sets the creation time of this key.  Zero is a convention to mean "unavailable".  This method can be useful when
     ; you have a raw key you are importing from somewhere else.
     ;;
    #_public
    (ยง method #_"void" setCreationTimeSeconds [#_"long" __newCreationTimeSeconds]
        (when (< __newCreationTimeSeconds 0)
            (throw (IllegalArgumentException. (str "Cannot set creation time to negative value: " __newCreationTimeSeconds)))
        )
        (ยง assoc this :creation-time-seconds __newCreationTimeSeconds)
        nil
    )

    ;;;
     ; Create an encrypted private key with the keyCrypter and the AES key supplied.
     ; This method returns a new encrypted key and leaves the original unchanged.
     ;
     ; @param keyCrypter The keyCrypter that specifies exactly how the encrypted bytes are created.
     ; @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached as it is slow to create).
     ; @return encryptedKey
     ;;
    #_public
    #_throws #_[ "KeyCrypterException" ]
    (ยง method #_"ECKey" encrypt [#_"KeyCrypter" __keyCrypter, #_"KeyParameter" __aesKey]
        (Preconditions/checkNotNull __keyCrypter)

        (let [#_"byte[]" __privKeyBytes (.. this (getPrivKeyBytes))
              #_"EncryptedData" __encryptedPrivateKey (.. __keyCrypter (encrypt __privKeyBytes, __aesKey))
              #_"ECKey" __result (ECKey/fromEncrypted __encryptedPrivateKey, __keyCrypter, (.. this (getPubKey)))]
            (.. __result (setCreationTimeSeconds (:creation-time-seconds this)))
            __result
        )
    )

    ;;;
     ; Create a decrypted private key with the keyCrypter and AES key supplied.  Note that if the aesKey is wrong, this
     ; has some chance of throwing KeyCrypterException due to the corrupted padding that will result, but it can also
     ; just yield a garbage key.
     ;
     ; @param keyCrypter The keyCrypter that specifies exactly how the decrypted bytes are created.
     ; @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached).
     ;;
    #_public
    #_throws #_[ "KeyCrypterException" ]
    (ยง method #_"ECKey" decrypt [#_"KeyCrypter" __keyCrypter, #_"KeyParameter" __aesKey]
        (Preconditions/checkNotNull __keyCrypter)

        ;; Check that the keyCrypter matches the one used to encrypt the keys, if set.
        (when (and (some? (:key-crypter this)) (not (.. (:key-crypter this) (equals __keyCrypter))))
            (throw (KeyCrypterException. "The keyCrypter being used to decrypt the key is different to the one that was used to encrypt it"))
        )

        (Preconditions/checkState (some? (:encrypted-private-key this)), "This key is not encrypted")

        (let [#_"byte[]" __unencryptedPrivateKey (.. __keyCrypter (decrypt (:encrypted-private-key this), __aesKey))
              #_"ECKey" __key (ECKey/fromPrivate __unencryptedPrivateKey)]
            (when (not (.. this (isCompressed)))
                (ยง ass __key (.. __key (decompress)))
            )
            (when (not (Arrays/equals (.. __key (getPubKey)), (.. this (getPubKey))))
                (throw (KeyCrypterException. "Provided AES key is wrong"))
            )

            (.. __key (setCreationTimeSeconds (:creation-time-seconds this)))
            __key
        )
    )

    ;;;
     ; Create a decrypted private key with AES key.  Note that if the AES key is wrong, this
     ; has some chance of throwing KeyCrypterException due to the corrupted padding that will result, but it can also
     ; just yield a garbage key.
     ;
     ; @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached).
     ;;
    #_public
    #_throws #_[ "KeyCrypterException" ]
    (ยง method #_"ECKey" decrypt [#_"KeyParameter" __aesKey]
        (let [#_"KeyCrypter" __crypter (.. this (getKeyCrypter))]
            (when (nil? __crypter)
                (throw (KeyCrypterException. "No key crypter available"))
            )

            (.. this (decrypt __crypter, __aesKey))
        )
    )

    ;;;
     ; Creates decrypted private key if needed.
     ;;
    #_public
    #_throws #_[ "KeyCrypterException" ]
    (ยง method #_"ECKey" maybeDecrypt [#_nilable #_"KeyParameter" __aesKey]
        (if (and (.. this (isEncrypted)) (some? __aesKey)) (.. this (decrypt __aesKey)) this)
    )

    ;;;
     ; <p>Check that it is possible to decrypt the key with the keyCrypter and that the original key is returned.</p>
     ;
     ; <p>Because it is a critical failure if the private keys cannot be decrypted successfully (resulting of loss of
     ; all bitcoins controlled by the private key) you can use this method to check when you *encrypt* a wallet that
     ; it can definitely be decrypted successfully.</p>
     ;
     ; <p>See {@link Wallet#encrypt(KeyCrypter keyCrypter, KeyParameter aesKey)} for example usage.</p>
     ;
     ; @return true if the encrypted key can be decrypted back to the original key successfully.
     ;;
    #_public
    #_static
    (ยง defn #_"boolean" ECKey/encryptionIsReversible [#_"ECKey" __originalKey, #_"ECKey" __encryptedKey, #_"KeyCrypter" __keyCrypter, #_"KeyParameter" __aesKey]
        (try
            (let [#_"ECKey" __rebornUnencryptedKey (.. __encryptedKey (decrypt __keyCrypter, __aesKey))
                  #_"byte[]" __originalPrivateKeyBytes (.. __originalKey (getPrivKeyBytes))
                  #_"byte[]" __rebornKeyBytes (.. __rebornUnencryptedKey (getPrivKeyBytes))]
                (when (not (Arrays/equals __originalPrivateKeyBytes, __rebornKeyBytes))
                    (.. ECKey/log (error "The check that encryption could be reversed failed for {}", __originalKey))
                    (ยง return false)
                )
                (ยง return true)
            )
            (catch KeyCrypterException __kce
                (.. ECKey/log (error (.. __kce (getMessage))))
                (ยง return false)
            )
        )
    )

    ;;;
     ; Indicates whether the private key is encrypted (true) or not (false).
     ; A private key is deemed to be encrypted when there is both a KeyCrypter and the encryptedPrivateKey is non-zero.
     ;;
    #_override
    #_public
    (ยง method #_"boolean" isEncrypted []
        (and (some? (:key-crypter this)) (some? (:encrypted-private-key this)) (< 0 (.. (:encrypted-private-key this) :encrypted-bytes (alength))))
    )

    #_nilable
    #_override
    #_public
    (ยง method #_"Protos.Wallet.EncryptionType" getEncryptionType []
        (if (some? (:key-crypter this)) (.. (:key-crypter this) (getUnderstoodEncryptionType)) Protos.Wallet.EncryptionType/UNENCRYPTED)
    )

    ;;;
     ; A wrapper for {@link #getPrivKeyBytes()} that returns null if the private key bytes are missing or would have
     ; to be derived (for the HD key case).
     ;;
    #_override
    #_nilable
    #_public
    (ยง method #_"byte[]" getSecretBytes []
        (when (.. this (hasPrivKey))
            (ยง return (.. this (getPrivKeyBytes)))
        )

        nil
    )

    ;;; An alias for {@link #getEncryptedPrivateKey()}. ;;
    #_nilable
    #_override
    #_public
    (ยง method #_"EncryptedData" getEncryptedData []
        (.. this (getEncryptedPrivateKey))
    )

    ;;;
     ; Returns the the encrypted private key bytes and initialisation vector for this ECKey, or null if the ECKey
     ; is not encrypted.
     ;;
    #_nilable
    #_public
    (ยง method #_"EncryptedData" getEncryptedPrivateKey []
        (:encrypted-private-key this)
    )

    ;;;
     ; Returns the KeyCrypter that was used to encrypt to encrypt this ECKey.  You need this to decrypt the ECKey.
     ;;
    #_nilable
    #_public
    (ยง method #_"KeyCrypter" getKeyCrypter []
        (:key-crypter this)
    )

    #_public
    #_static
    (ยง class ECKey.MissingPrivateKeyException (ยง extends RuntimeException)
    )

    #_public
    #_static
    (ยง class ECKey.KeyIsEncryptedException (ยง extends ECKey.MissingPrivateKeyException)
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (not (instance? ECKey __o)))
            (ยง return false)
        )
        (let [#_"ECKey" __other (cast ECKey __o)]
            (and (Objects/equal (:priv this), (:priv __other)) (Objects/equal (:pub this), (:pub __other)) (Objects/equal (:creation-time-seconds this), (:creation-time-seconds __other)) (Objects/equal (:key-crypter this), (:key-crypter __other)) (Objects/equal (:encrypted-private-key this), (:encrypted-private-key __other)))
        )
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (.. (:pub this) (hashCode))
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (.. this (toString false, nil))
    )

    ;;;
     ; Produce a string rendering of the ECKey INCLUDING the private key.
     ; Unless you absolutely need the private key it is better for security reasons to just use {@link #toString()}.
     ;;
    #_public
    (ยง method #_"String" toStringWithPrivate [#_"NetworkParameters" __params]
        (.. this (toString true, __params))
    )

    #_public
    (ยง method #_"String" getPrivateKeyAsHex []
        (.. Utils/HEX (encode (.. this (getPrivKeyBytes))))
    )

    #_public
    (ยง method #_"String" getPublicKeyAsHex []
        (.. Utils/HEX (encode (.. (:pub this) (getEncoded))))
    )

    #_private
    (ยง method- #_"String" toString [#_"boolean" __includePrivate, #_"NetworkParameters" __params]
        (let [#_"MoreObjects.ToStringHelper" __helper (.. (MoreObjects/toStringHelper this) (omitNullValues))]
            (.. __helper (add "pub HEX", (.. this (getPublicKeyAsHex))))
            (when __includePrivate
                (try
                    (.. __helper (add "priv HEX", (.. this (getPrivateKeyAsHex))))
                    (catch IllegalStateException _
                        ;; TODO: Make hasPrivKey() work for deterministic keys and fix this.
                    )
                    (catch Exception __e
                        (let [#_"String" __message (.. __e (getMessage))]
                            (.. __helper (add "priv EXCEPTION", (str (.. __e (getClass) (getName)) (if (some? __message) (str ": " __message) ""))))
                        )
                    )
                )
            )
            (when (< 0 (:creation-time-seconds this))
                (.. __helper (add "creationTimeSeconds", (:creation-time-seconds this)))
            )
            (.. __helper (add "keyCrypter", (:key-crypter this)))
            (when __includePrivate
                (.. __helper (add "encryptedPrivateKey", (:encrypted-private-key this)))
            )
            (.. __helper (add "isEncrypted", (.. this (isEncrypted))))
            (.. __helper (add "isPubKeyOnly", (.. this (isPubKeyOnly))))
            (.. __helper (toString))
        )
    )

    #_public
    (ยง method #_"void" formatKeyWithAddress [#_"boolean" __includePrivateKeys, #_"StringBuilder" __sb, #_"NetworkParameters" __params]
        (let [#_"Address" __address (.. this (toAddress __params))]
            (.. __sb (append "  addr:"))
            (.. __sb (append (.. __address (toString))))
            (.. __sb (append "  hash160:"))
            (.. __sb (append (.. Utils/HEX (encode (.. this (getPubKeyHash))))))
            (when (< 0 (:creation-time-seconds this))
                (.. __sb (append "  creationTimeSeconds:") (append (:creation-time-seconds this)))
            )
            (.. __sb (append "\n"))
            (when __includePrivateKeys
                (.. __sb (append "  "))
                (.. __sb (append (.. this (toStringWithPrivate __params))))
                (.. __sb (append "\n"))
            )
            nil
        )
    )
)

;;;
 ; <p>Parent class for header only messages that don't have a payload.
 ; Currently this includes getaddr, verack and special bitcoinj class UnknownMessage.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
(ยง class EmptyMessage (ยง extends Message)
    #_public
    (ยง constructor EmptyMessage []
        (ยง assoc this :length 0)
        this
    )

    #_public
    (ยง constructor EmptyMessage [#_"NetworkParameters" __params]
        (ยง super __params)
        (ยง assoc this :length 0)
        this
    )

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor EmptyMessage [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"int" __offset]
        (ยง super __params, __payload, __offset)
        (ยง assoc this :length 0)
        this
    )

    #_override
    #_protected
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __stream]
        nil
    )

    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        nil
    )

    #_override
    #_public
    (ยง method #_"byte[]" bitcoinSerialize []
        (byte-array 0)
    )
)

;;;
 ; <p>A FilteredBlock is used to relay a block with its transactions filtered using a {@link BloomFilter}.  It consists
 ; of the block header and a {@link PartialMerkleTree} which contains the transactions which matched the filter.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class FilteredBlock (ยง extends Message)
    #_private
    (ยง field- #_"Block" :header)

    #_private
    (ยง field- #_"PartialMerkleTree" :merkle-tree)
    #_private
    (ยง field- #_"List<Sha256Hash>" :cached-transaction-hashes)

    ;; A set of transactions whose hashes are a subset of getTransactionHashes().
    ;; These were relayed as a part of the filteredblock getdata, i.e. likely weren't previously received as loose transactions.
    #_private
    (ยง field- #_"Map<Sha256Hash, Transaction>" :associated-transactions (HashMap. #_"<>"))

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor FilteredBlock [#_"NetworkParameters" __params, #_"byte[]" __payloadBytes]
        (ยง super __params, __payloadBytes, 0)
        this
    )

    #_public
    (ยง constructor FilteredBlock [#_"NetworkParameters" __params, #_"Block" __header, #_"PartialMerkleTree" __pmt]
        (ยง super __params)
        (ยง assoc this :header __header)
        (ยง assoc this :merkle-tree __pmt)
        this
    )

    #_override
    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __stream]
        (if (nil? (-> this :header :transactions))
            (.. (:header this) (bitcoinSerializeToStream __stream))
            (.. (:header this) (cloneAsHeader) (bitcoinSerializeToStream __stream))
        )
        (.. (:merkle-tree this) (bitcoinSerializeToStream __stream))
        nil
    )

    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        (let [#_"byte[]" __headerBytes (byte-array Block/HEADER_SIZE)]
            (System/arraycopy (:payload this), 0, __headerBytes, 0, Block/HEADER_SIZE)
            (ยง assoc this :header (.. (:params this) (getDefaultSerializer) (makeBlock __headerBytes)))

            (ยง assoc this :merkle-tree (PartialMerkleTree. (:params this), (:payload this), Block/HEADER_SIZE))

            (ยง assoc this :length (+ Block/HEADER_SIZE (.. (:merkle-tree this) (getMessageSize))))
            nil
        )
    )

    ;;;
     ; Gets a list of leaf hashes which are contained in the partial merkle tree in this filtered block.
     ;
     ; @throws ProtocolException if the partial merkle block is invalid or the merkle root of the partial merkle block doesnt match the block header.
     ;;
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"List<Sha256Hash>" getTransactionHashes []
        (when (some? (:cached-transaction-hashes this))
            (ยง return (Collections/unmodifiableList (:cached-transaction-hashes this)))
        )

        (let [#_"List<Sha256Hash>" __hashesMatched (LinkedList. #_"<>")]
            (when (.. (:header this) (getMerkleRoot) (equals (.. (:merkle-tree this) (getTxnHashAndMerkleRoot __hashesMatched))))
                (ยง assoc this :cached-transaction-hashes __hashesMatched)
                (ยง return (Collections/unmodifiableList (:cached-transaction-hashes this)))
            )

            (throw (VerificationException. "Merkle root of block header does not match merkle root of partial merkle tree."))
        )
    )

    ;;;
     ; Gets a copy of the block header.
     ;;
    #_public
    (ยง method #_"Block" getBlockHeader []
        (.. (:header this) (cloneAsHeader))
    )

    ;;; Gets the hash of the block represented in this FilteredBlock. ;;
    #_override
    #_public
    (ยง method #_"Sha256Hash" getHash []
        (.. (:header this) (getHash))
    )

    ;;;
     ; Provide this FilteredBlock with a transaction which is in its Merkle tree.
     ; @return false if the tx is not relevant to this FilteredBlock.
     ;;
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"boolean" provideTransaction [#_"Transaction" __tx]
        (let [#_"Sha256Hash" __hash (.. __tx (getHash))]
            (when (.. this (getTransactionHashes) (contains __hash))
                (.. (:associated-transactions this) (put __hash, __tx))
                (ยง return true)
            )
            false
        )
    )

    ;;; Returns the {@link PartialMerkleTree} object that provides the mathematical proof of transaction inclusion in the block. ;;
    #_public
    (ยง method #_"PartialMerkleTree" getPartialMerkleTree []
        (:merkle-tree this)
    )

    ;;; Gets the set of transactions which were provided using provideTransaction() which match in getTransactionHashes(). ;;
    #_public
    (ยง method #_"Map<Sha256Hash, Transaction>" getAssociatedTransactions []
        (Collections/unmodifiableMap (:associated-transactions this))
    )

    ;;; Number of transactions in this block, before it was filtered. ;;
    #_public
    (ยง method #_"int" getTransactionCount []
        (.. (:merkle-tree this) (getTransactionCount))
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"FilteredBlock" __other (cast FilteredBlock __o)]
            (and (.. (:associated-transactions this) (equals (:associated-transactions __other))) (.. (:header this) (equals (:header __other))) (.. (:merkle-tree this) (equals (:merkle-tree __other))))
        )
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (:associated-transactions this), (:header this), (:merkle-tree this))
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (str "FilteredBlock{merkleTree=" (:merkle-tree this) ", header=" (:header this) "}")
    )
)

;;;
 ; <p>A FullPrunedBlockChain works in conjunction with a {@link FullPrunedBlockStore} to verify all the rules of the
 ; Bitcoin system, with the downside being a large cost in system resources.  Fully verifying means all unspent
 ; transaction outputs are stored.  Once a transaction output is spent and that spend is buried deep enough, the data
 ; related to it is deleted to ensure disk space usage doesn't grow forever.  For this reason a pruning node cannot
 ; serve the full block chain to other clients, but it nevertheless provides the same security guarantees as Bitcoin
 ; Core does.</p>
 ;;
#_public
(ยง class FullPrunedBlockChain (ยง extends AbstractBlockChain)
    #_private
    #_static
    (ยง def- #_"Logger" FullPrunedBlockChain/log (LoggerFactory/getLogger FullPrunedBlockChain))

    ;;;
     ; Keeps a map of block hashes to StoredBlocks.
     ;;
    #_protected
    (ยง field #_"FullPrunedBlockStore" :block-store)

    ;; Whether or not to execute scriptPubKeys before accepting a transaction (i.e. check signatures).
    #_private
    (ยง field- #_"boolean" :run-scripts true)

    ;;;
     ; Constructs a block chain connected to the given wallet and store.  To obtain a {@link Wallet} you can construct
     ; one from scratch, or you can deserialize a saved wallet from disk using {@link Wallet#loadFromFile(java.io.File)}.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor FullPrunedBlockChain [#_"Context" __context, #_"Wallet" __wallet, #_"FullPrunedBlockStore" __blockStore]
        (ยง this __context, (ArrayList. #_"<Wallet>"), __blockStore)
        (.. this (addWallet __wallet))
        this
    )

    ;;;
     ; Constructs a block chain connected to the given wallet and store.  To obtain a {@link Wallet} you can construct
     ; one from scratch, or you can deserialize a saved wallet from disk using {@link Wallet#loadFromFile(java.io.File)}.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor FullPrunedBlockChain [#_"NetworkParameters" __params, #_"Wallet" __wallet, #_"FullPrunedBlockStore" __blockStore]
        (ยง this (Context/getOrCreate __params), __wallet, __blockStore)
        this
    )

    ;;;
     ; Constructs a block chain connected to the given store.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor FullPrunedBlockChain [#_"Context" __context, #_"FullPrunedBlockStore" __blockStore]
        (ยง this __context, (ArrayList. #_"<Wallet>"), __blockStore)
        this
    )

    ;;;
     ; See {@link #FullPrunedBlockChain(Context, Wallet, FullPrunedBlockStore)}.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor FullPrunedBlockChain [#_"NetworkParameters" __params, #_"FullPrunedBlockStore" __blockStore]
        (ยง this (Context/getOrCreate __params), __blockStore)
        this
    )

    ;;;
     ; Constructs a block chain connected to the given list of wallets and a store.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor FullPrunedBlockChain [#_"Context" __context, #_"List<Wallet>" __listeners, #_"FullPrunedBlockStore" __blockStore]
        (ยง super __context, __listeners, __blockStore)
        (ยง assoc this :block-store __blockStore)
        ;; Ignore upgrading for now.
        (ยง assoc this :chain-head (.. __blockStore (getVerifiedChainHead)))
        this
    )

    ;;;
     ; See {@link #FullPrunedBlockChain(Context, List, FullPrunedBlockStore)}.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor FullPrunedBlockChain [#_"NetworkParameters" __params, #_"List<Wallet>" __listeners, #_"FullPrunedBlockStore" __blockStore]
        (ยง this (Context/getOrCreate __params), __listeners, __blockStore)
        this
    )

    #_override
    #_protected
    #_throws #_[ "BlockStoreException", "VerificationException" ]
    (ยง method #_"StoredBlock" addToBlockStore [#_"StoredBlock" __storedPrev, #_"Block" __header, #_"TransactionOutputChanges" __txOutChanges]
        (let [#_"StoredBlock" __newBlock (.. __storedPrev (build __header))]
            (.. (:block-store this) (put __newBlock, (StoredUndoableBlock. (.. __newBlock (getHeader) (getHash)), __txOutChanges)))
            __newBlock
        )
    )

    #_override
    #_protected
    #_throws #_[ "BlockStoreException", "VerificationException" ]
    (ยง method #_"StoredBlock" addToBlockStore [#_"StoredBlock" __storedPrev, #_"Block" __block]
        (let [#_"StoredBlock" __newBlock (.. __storedPrev (build __block))]
            (.. (:block-store this) (put __newBlock, (StoredUndoableBlock. (.. __newBlock (getHeader) (getHash)), (:transactions __block))))
            __newBlock
        )
    )

    #_override
    #_protected
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" rollbackBlockStore [#_"int" __height]
        (throw (BlockStoreException. "Unsupported"))
    )

    #_override
    #_protected
    (ยง method #_"boolean" shouldVerifyTransactions []
        true
    )

    ;;;
     ; Whether or not to run scripts whilst accepting blocks (i.e. checking signatures, for most transactions).
     ; If you're accepting data from an untrusted node, such as one found via the P2P network, this should be set
     ; to true (which is the default).  If you're downloading a chain from a node you control, script execution
     ; is redundant because you know the connected node won't relay bad data to you.  In that case it's safe to set
     ; this to false and obtain a significant speedup.
     ;;
    #_public
    (ยง method #_"void" setRunScripts [#_"boolean" __value]
        (ยง assoc this :run-scripts __value)
        nil
    )

    ;; TODO: Remove lots of duplicated code in the two connectTransactions.

    ;; TODO: Execute in order of largest transaction (by input count) first.
    (ยง field #_"ExecutorService" :script-verification-executor (Executors/newFixedThreadPool (.. (Runtime/getRuntime) (availableProcessors)), (ContextPropagatingThreadFactory. "Script verification")))

    ;;;
     ; A job submitted to the executor which verifies signatures.
     ;;
    #_private
    #_static
    (ยง class- FullPrunedBlockChain.Verifier (ยง implements Callable #_"<VerificationException>")
        (ยง field #_"Transaction" :tx)
        (ยง field #_"List<Script>" :prev-out-scripts)
        (ยง field #_"Set<Script.VerifyFlag>" :verify-flags)

        #_public
        (ยง constructor FullPrunedBlockChain.Verifier [#_"Transaction" __tx, #_"List<Script>" __prevOutScripts, #_"Set<Script.VerifyFlag>" __verifyFlags]
            (ยง assoc this :tx __tx)
            (ยง assoc this :prev-out-scripts __prevOutScripts)
            (ยง assoc this :verify-flags __verifyFlags)
            this
        )

        #_nilable
        #_override
        #_public
        #_throws #_[ "Exception" ]
        (ยง method #_"VerificationException" call []
            (try
                (let [#_"ListIterator<Script>" __prevOutIt (.. (:prev-out-scripts this) (listIterator))]
                    (loop-when-recur [#_"int" __index 0] (< __index (.. (:tx this) (getInputs) (size))) [(inc __index)]
                        (.. (:tx this) (getInputs) (get __index) (getScriptSig) (correctlySpends (:tx this), __index, (.. __prevOutIt (next)), (:verify-flags this)))
                    )
                    (ยง return nil)
                )
                (catch VerificationException __e
                    (ยง return __e)
                )
            )
        )
    )

    ;;;
     ; Get the {@link Script} from the script bytes or return Script of empty byte array.
     ;;
    #_private
    (ยง method- #_"Script" getScript [#_"byte[]" __scriptBytes]
        (try
            (ยง return (Script. __scriptBytes))
            (catch Exception _
                (ยง return (Script. (byte-array 0)))
            )
        )
    )

    ;;;
     ; Get the address from the {@link Script} if it exists, otherwise return empty string "".
     ;
     ; @param script The script.
     ; @return The address.
     ;;
    #_private
    (ยง method- #_"String" getScriptAddress [#_nilable #_"Script" __script]
        (let [#_"String" __address ""]
            (try
                (when (some? __script)
                    (ยง ass __address (.. __script (getToAddress (:params this), true) (toString)))
                )
                (catch Exception _
                )
            )
            __address
        )
    )

    #_override
    #_protected
    #_throws #_[ "VerificationException", "BlockStoreException" ]
    (ยง method #_"TransactionOutputChanges" connectTransactions [#_"int" __height, #_"Block" __block]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))

        (when (nil? (:transactions __block))
            (throw (RuntimeException. "connectTransactions called with Block that didn't have transactions!"))
        )
        (when (not (.. (:params this) (passesCheckpoint __height, (.. __block (getHash)))))
            (throw (VerificationException. (str "Block failed checkpoint lockin at " __height)))
        )

        (.. (:block-store this) (beginDatabaseBatchWrite))

        (let [#_"LinkedList<UTXO>" __txOutsSpent (LinkedList. #_"<>")
              #_"LinkedList<UTXO>" __txOutsCreated (LinkedList. #_"<>")
              #_"long" __sigOps 0]

            (when (.. (:script-verification-executor this) (isShutdown))
                (ยง assoc this :script-verification-executor (Executors/newFixedThreadPool (.. (Runtime/getRuntime) (availableProcessors))))
            )

            (let [#_"List<Future<VerificationException>>" __listScriptVerificationResults (ArrayList. #_"<>" (.. (:transactions __block) (size)))]
                (try
                    (when (not (.. (:params this) (isCheckpoint __height)))
                        ;; BIP30 violator blocks are ones that contain a duplicated transaction.  They are all in the checkpoints list
                        ;; and we therefore only check non-checkpoints for duplicated transactions here.  See the BIP30 document
                        ;; for more details on this: https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki
                        (doseq [#_"Transaction" __tx (:transactions __block)]
                            (let [#_"Set<Script.VerifyFlag>" __verifyFlags (.. (:params this) (getTransactionVerificationFlags __block, __tx, (.. this (getVersionTally)), __height))
                                  #_"Sha256Hash" __hash (.. __tx (getHash))]
                                ;; If we already have unspent outputs for this hash, we saw the tx already.
                                ;; Either the block is being added twice (bug) or the block is a BIP30 violator.
                                (when (.. (:block-store this) (hasUnspentOutputs __hash, (.. __tx (getOutputs) (size))))
                                    (throw (VerificationException. "Block failed BIP30 test!"))
                                )
                                ;; We already check non-BIP16 sigops in Block.verifyTransactions(true).
                                (when (.. __verifyFlags (contains Script.VerifyFlag/P2SH))
                                    (ยง ass __sigOps (+ __sigOps (.. __tx (getSigOpCount))))
                                )
                            )
                        )
                    )
                    (let [#_"Coin" __totalFees Coin/ZERO
                          #_"Coin" __coinbaseValue nil]
                        (doseq [#_"Transaction" __tx (:transactions __block)]
                            (let [#_"boolean" __isCoinBase (.. __tx (isCoinBase))
                                  #_"Coin" __valueIn Coin/ZERO
                                  #_"Coin" __valueOut Coin/ZERO
                                  #_"List<Script>" __prevOutScripts (LinkedList. #_"<>")
                                  #_"Set<Script.VerifyFlag>" __verifyFlags (.. (:params this) (getTransactionVerificationFlags __block, __tx, (.. this (getVersionTally)), __height))]
                                (when (not __isCoinBase)
                                    ;; For each input of the transaction remove the corresponding output from the set of unspent outputs.
                                    (loop-when-recur [#_"int" __index 0] (< __index (.. __tx (getInputs) (size))) [(inc __index)]
                                        (let [#_"TransactionInput" __in (.. __tx (getInputs) (get __index))
                                              #_"UTXO" __prevOut (.. (:block-store this) (getTransactionOutput (.. __in (getOutpoint) (getHash)), (.. __in (getOutpoint) (getIndex))))]
                                            (when (nil? __prevOut)
                                                (throw (VerificationException. "Attempted to spend a non-existent or already spent output!"))
                                            )
                                            ;; Coinbases can't be spent until they mature, to avoid re-orgs destroying entire transaction chains.
                                            ;; The assumption is there will ~never be re-orgs deeper than the spendable coinbase chain depth.
                                            (when (.. __prevOut (isCoinbase))
                                                (when (< (- __height (.. __prevOut (getHeight))) (.. (:params this) (getSpendableCoinbaseDepth)))
                                                    (throw (VerificationException. (str "Tried to spend coinbase at depth " (- __height (.. __prevOut (getHeight))))))
                                                )
                                            )
                                            ;; TODO: Check we're not spending the genesis transaction here. Bitcoin Core won't allow it.
                                            (ยง ass __valueIn (.. __valueIn (add (.. __prevOut (getValue)))))
                                            (when (.. __verifyFlags (contains Script.VerifyFlag/P2SH))
                                                (when (.. __prevOut (getScript) (isPayToScriptHash))
                                                    (ยง ass __sigOps (+ __sigOps (Script/getP2SHSigOpCount (.. __in (getScriptBytes)))))
                                                )
                                                (when (< Block/MAX_BLOCK_SIGOPS __sigOps)
                                                    (throw (VerificationException. "Too many P2SH SigOps in block"))
                                                )
                                            )

                                            (.. __prevOutScripts (add (.. __prevOut (getScript))))
                                            (.. (:block-store this) (removeUnspentTransactionOutput __prevOut))
                                            (.. __txOutsSpent (add __prevOut))
                                        )
                                    )
                                )
                                (let [#_"Sha256Hash" __hash (.. __tx (getHash))]
                                    (doseq [#_"TransactionOutput" __out (.. __tx (getOutputs))]
                                        (ยง ass __valueOut (.. __valueOut (add (.. __out (getValue)))))
                                        ;; For each output, add it to the set of unspent outputs so it can be consumed in future.
                                        (let [#_"Script" __script (.. this (getScript (.. __out (getScriptBytes))))
                                              #_"UTXO" __newOut (UTXO. __hash, (.. __out (getIndex)), (.. __out (getValue)), __height, __isCoinBase, __script, (.. this (getScriptAddress __script)))]
                                            (.. (:block-store this) (addUnspentTransactionOutput __newOut))
                                            (.. __txOutsCreated (add __newOut))
                                        )
                                    )
                                    ;; All values were already checked for being non-negative (as it is verified in Transaction.verify()),
                                    ;; but we check again here just for defence in depth.  Transactions with zero output value are OK.
                                    (when (or (< (.. __valueOut (signum)) 0) (< 0 (.. __valueOut (compareTo (.. (:params this) (getMaxMoney))))))
                                        (throw (VerificationException. "Transaction output value out of range"))
                                    )

                                    (cond __isCoinBase
                                        (do
                                            (ยง ass __coinbaseValue __valueOut)
                                        )
                                        :else
                                        (do
                                            (when (or (< (.. __valueIn (compareTo __valueOut)) 0) (< 0 (.. __valueIn (compareTo (.. (:params this) (getMaxMoney))))))
                                                (throw (VerificationException. "Transaction input value out of range"))
                                            )
                                            (ยง ass __totalFees (.. __totalFees (add (.. __valueIn (subtract __valueOut)))))
                                        )
                                    )

                                    (when (and (not __isCoinBase) (:run-scripts this))
                                        ;; Because correctlySpends modifies transactions, this must come after we are done with tx.
                                        (let [#_"FutureTask<VerificationException>" __future (FutureTask. #_"<>" (FullPrunedBlockChain.Verifier. __tx, __prevOutScripts, __verifyFlags))]
                                            (.. (:script-verification-executor this) (execute __future))
                                            (.. __listScriptVerificationResults (add __future))
                                        )
                                    )
                                )
                            )
                        )
                        (when (or (< 0 (.. __totalFees (compareTo (.. (:params this) (getMaxMoney))))) (< (.. __block (getBlockInflation __height) (add __totalFees) (compareTo __coinbaseValue)) 0))
                            (throw (VerificationException. "Transaction fees out of range"))
                        )

                        (doseq [#_"Future<VerificationException>" __future __listScriptVerificationResults]
                            (let [#_"VerificationException" __e]
                                (try
                                    (ยง ass __e (.. __future (get)))
                                    (catch InterruptedException __ie
                                        (throw (RuntimeException. __ie)) ;; Shouldn't happen.
                                    )
                                    (catch ExecutionException __ee
                                        (.. FullPrunedBlockChain/log (error (str "Script.correctlySpends threw a non-normal exception: " (.. __ee (getCause)))))
                                        (throw (VerificationException. "Bug in Script.correctlySpends, likely script malformed in some new and interesting way.", __ee))
                                    )
                                )
                                (when (some? __e)
                                    (throw __e)
                                )
                            )
                        )
                    )
                    (catch VerificationException __e
                        (.. (:script-verification-executor this) (shutdownNow))
                        (.. (:block-store this) (abortDatabaseBatchWrite))
                        (throw __e)
                    )
                    (catch BlockStoreException __e
                        (.. (:script-verification-executor this) (shutdownNow))
                        (.. (:block-store this) (abortDatabaseBatchWrite))
                        (throw __e)
                    )
                )

                (TransactionOutputChanges. __txOutsCreated, __txOutsSpent)
            )
        )
    )

    #_override
    ;;;
     ; Used during reorgs to connect a block previously on a fork.
     ;;
    #_protected
    #_synchronized
    #_throws #_[ "VerificationException", "BlockStoreException", "PrunedException" ]
    (ยง method #_"TransactionOutputChanges" connectTransactions [#_"StoredBlock" __newBlock]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))
        (when (not (.. (:params this) (passesCheckpoint (.. __newBlock (getHeight)), (.. __newBlock (getHeader) (getHash)))))
            (throw (VerificationException. (str "Block failed checkpoint lockin at " (.. __newBlock (getHeight)))))
        )

        (.. (:block-store this) (beginDatabaseBatchWrite))
        (let [#_"StoredUndoableBlock" __block (.. (:block-store this) (getUndoBlock (.. __newBlock (getHeader) (getHash))))]
            (when (nil? __block)
                ;; We're trying to re-org too deep and the data needed has been deleted.
                (.. (:block-store this) (abortDatabaseBatchWrite))
                (throw (PrunedException. (.. __newBlock (getHeader) (getHash))))
            )

            (let [#_"TransactionOutputChanges" __txOutChanges]
                (try
                    (let [#_"List<Transaction>" __transactions (.. __block (getTransactions))]
                        (cond (some? __transactions)
                            (do
                                (let [#_"LinkedList<UTXO>" __txOutsSpent (LinkedList. #_"<>")
                                      #_"LinkedList<UTXO>" __txOutsCreated (LinkedList. #_"<>")
                                      #_"long" __sigOps 0]

                                    (when (not (.. (:params this) (isCheckpoint (.. __newBlock (getHeight)))))
                                        (doseq [#_"Transaction" __tx __transactions]
                                            (let [#_"Sha256Hash" __hash (.. __tx (getHash))]
                                                (when (.. (:block-store this) (hasUnspentOutputs __hash, (.. __tx (getOutputs) (size))))
                                                    (throw (VerificationException. "Block failed BIP30 test!"))
                                                )
                                            )
                                        )
                                    )

                                    (let [#_"Coin" __totalFees Coin/ZERO
                                          #_"Coin" __coinbaseValue nil]

                                        (when (.. (:script-verification-executor this) (isShutdown))
                                            (ยง assoc this :script-verification-executor (Executors/newFixedThreadPool (.. (Runtime/getRuntime) (availableProcessors))))
                                        )

                                        (let [#_"List<Future<VerificationException>>" __listScriptVerificationResults (ArrayList. #_"<>" (.. __transactions (size)))]
                                            (doseq [#_"Transaction" __tx (:transactions this)]
                                                (let [#_"Set<Script.VerifyFlag>" __verifyFlags (.. (:params this) (getTransactionVerificationFlags (.. __newBlock (getHeader)), __tx, (.. this (getVersionTally)), Integer/SIZE))
                                                      #_"boolean" __isCoinBase (.. __tx (isCoinBase))
                                                      #_"Coin" __valueIn Coin/ZERO
                                                      #_"Coin" __valueOut Coin/ZERO
                                                      #_"List<Script>" __prevOutScripts (LinkedList. #_"<>")]

                                                    (when (not __isCoinBase)
                                                        (loop-when-recur [#_"int" __index 0] (< __index (.. __tx (getInputs) (size))) [(inc __index)]
                                                            (let [#_"TransactionInput" __in (.. __tx (getInputs) (get __index))
                                                                  #_"UTXO" __prevOut (.. (:block-store this) (getTransactionOutput (.. __in (getOutpoint) (getHash)), (.. __in (getOutpoint) (getIndex))))]
                                                                (when (nil? __prevOut)
                                                                    (throw (VerificationException. "Attempted spend of a non-existent or already spent output!"))
                                                                )
                                                                (when (and (.. __prevOut (isCoinbase)) (< (- (.. __newBlock (getHeight)) (.. __prevOut (getHeight))) (.. (:params this) (getSpendableCoinbaseDepth))))
                                                                    (throw (VerificationException. (str "Tried to spend coinbase at depth " (- (.. __newBlock (getHeight)) (.. __prevOut (getHeight))))))
                                                                )
                                                                (ยง ass __valueIn (.. __valueIn (add (.. __prevOut (getValue)))))
                                                                (when (.. __verifyFlags (contains Script.VerifyFlag/P2SH))
                                                                    (when (.. __prevOut (getScript) (isPayToScriptHash))
                                                                        (ยง ass __sigOps (+ __sigOps (Script/getP2SHSigOpCount (.. __in (getScriptBytes)))))
                                                                    )
                                                                    (when (< Block/MAX_BLOCK_SIGOPS __sigOps)
                                                                        (throw (VerificationException. "Too many P2SH SigOps in block"))
                                                                    )
                                                                )

                                                                ;; TODO: Enforce DER signature format.

                                                                (.. __prevOutScripts (add (.. __prevOut (getScript))))

                                                                (.. (:block-store this) (removeUnspentTransactionOutput __prevOut))
                                                                (.. __txOutsSpent (add __prevOut))
                                                            )
                                                        )
                                                    )
                                                    (let [#_"Sha256Hash" __hash (.. __tx (getHash))]
                                                        (doseq [#_"TransactionOutput" __out (.. __tx (getOutputs))]
                                                            (ยง ass __valueOut (.. __valueOut (add (.. __out (getValue)))))
                                                            (let [#_"Script" __script (.. this (getScript (.. __out (getScriptBytes))))
                                                                  #_"UTXO" __newOut (UTXO. __hash, (.. __out (getIndex)), (.. __out (getValue)), (.. __newBlock (getHeight)), __isCoinBase, __script, (.. this (getScriptAddress __script)))]
                                                                (.. (:block-store this) (addUnspentTransactionOutput __newOut))
                                                                (.. __txOutsCreated (add __newOut))
                                                            )
                                                        )
                                                        ;; All values were already checked for being non-negative (as it is verified in Transaction.verify())
                                                        ;; but we check again here just for defence in depth.  Transactions with zero output value are OK.
                                                        (when (or (< (.. __valueOut (signum)) 0) (< 0 (.. __valueOut (compareTo (.. (:params this) (getMaxMoney))))))
                                                            (throw (VerificationException. "Transaction output value out of range"))
                                                        )

                                                        (cond __isCoinBase
                                                            (do
                                                                (ยง ass __coinbaseValue __valueOut)
                                                            )
                                                            :else
                                                            (do
                                                                (when (or (< (.. __valueIn (compareTo __valueOut)) 0) (< 0 (.. __valueIn (compareTo (.. (:params this) (getMaxMoney))))))
                                                                    (throw (VerificationException. "Transaction input value out of range"))
                                                                )
                                                                (ยง ass __totalFees (.. __totalFees (add (.. __valueIn (subtract __valueOut)))))
                                                            )
                                                        )

                                                        (when (not __isCoinBase)
                                                            ;; Because correctlySpends modifies transactions, this must come after we are done with tx.
                                                            (let [#_"FutureTask<VerificationException>" __future (FutureTask. #_"<>" (FullPrunedBlockChain.Verifier. __tx, (:prev-out-scripts this), __verifyFlags))]
                                                                (.. (:script-verification-executor this) (execute __future))
                                                                (.. __listScriptVerificationResults (add __future))
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                            (when (or (< 0 (.. __totalFees (compareTo (.. (:params this) (getMaxMoney))))) (< (.. __newBlock (getHeader) (getBlockInflation (.. __newBlock (getHeight))) (add __totalFees) (compareTo __coinbaseValue)) 0))
                                                (throw (VerificationException. "Transaction fees out of range"))
                                            )

                                            (ยง ass __txOutChanges (TransactionOutputChanges. __txOutsCreated, __txOutsSpent))
                                            (doseq [#_"Future<VerificationException>" __future __listScriptVerificationResults]
                                                (let [#_"VerificationException" __e]
                                                    (try
                                                        (ยง ass __e (.. __future (get)))
                                                        (catch InterruptedException __ie
                                                            (throw (RuntimeException. __ie)) ;; Shouldn't happen.
                                                        )
                                                        (catch ExecutionException __ee
                                                            (.. FullPrunedBlockChain/log (error (str "Script.correctlySpends threw a non-normal exception: " (.. __ee (getCause)))))
                                                            (throw (VerificationException. "Bug in Script.correctlySpends, likely script malformed in some new and interesting way.", __ee))
                                                        )
                                                    )
                                                    (when (some? __e)
                                                        (throw __e)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            :else
                            (do
                                (ยง ass __txOutChanges (.. __block (getTxOutChanges)))
                                (when (not (.. (:params this) (isCheckpoint (.. __newBlock (getHeight)))))
                                    (doseq [#_"UTXO" __out (-> this :tx-out-changes :tx-outs-created)]
                                        (let [#_"Sha256Hash" __hash (.. __out (getHash))]
                                            (when (some? (.. (:block-store this) (getTransactionOutput __hash, (.. __out (getIndex)))))
                                                (throw (VerificationException. "Block failed BIP30 test!"))
                                            )
                                        )
                                    )
                                )
                                (doseq [#_"UTXO" __out (-> this :tx-out-changes :tx-outs-created)]
                                    (.. (:block-store this) (addUnspentTransactionOutput __out))
                                )
                                (doseq [#_"UTXO" __out (-> this :tx-out-changes :tx-outs-spent)]
                                    (.. (:block-store this) (removeUnspentTransactionOutput __out))
                                )
                            )
                        )
                    )
                    (catch VerificationException __e
                        (.. (:script-verification-executor this) (shutdownNow))
                        (.. (:block-store this) (abortDatabaseBatchWrite))
                        (throw __e)
                    )
                    (catch BlockStoreException __e
                        (.. (:script-verification-executor this) (shutdownNow))
                        (.. (:block-store this) (abortDatabaseBatchWrite))
                        (throw __e)
                    )
                )
                (:tx-out-changes this)
            )
        )
    )

    ;;;
     ; This is broken for blocks that do not pass BIP30, so all BIP30-failing blocks which are allowed to fail BIP30
     ; must be checkpointed.
     ;;
    #_override
    #_protected
    #_throws #_[ "PrunedException", "BlockStoreException" ]
    (ยง method #_"void" disconnectTransactions [#_"StoredBlock" __oldBlock]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))
        (.. (:block-store this) (beginDatabaseBatchWrite))
        (try
            (let [#_"StoredUndoableBlock" __undoBlock (.. (:block-store this) (getUndoBlock (.. __oldBlock (getHeader) (getHash))))]
                (when (nil? __undoBlock)
                    (throw (PrunedException. (.. __oldBlock (getHeader) (getHash))))
                )

                (let [#_"TransactionOutputChanges" __txOutChanges (.. __undoBlock (getTxOutChanges))]
                    (doseq [#_"UTXO" __out (:tx-outs-spent __txOutChanges)]
                        (.. (:block-store this) (addUnspentTransactionOutput __out))
                    )
                    (doseq [#_"UTXO" __out (:tx-outs-created __txOutChanges)]
                        (.. (:block-store this) (removeUnspentTransactionOutput __out))
                    )
                )
            )
            (catch PrunedException __e
                (.. (:block-store this) (abortDatabaseBatchWrite))
                (throw __e)
            )
            (catch BlockStoreException __e
                (.. (:block-store this) (abortDatabaseBatchWrite))
                (throw __e)
            )
        )
        nil
    )

    #_override
    #_protected
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" doSetChainHead [#_"StoredBlock" __chainHead]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))
        (.. (:block-store this) (setVerifiedChainHead __chainHead))
        (.. (:block-store this) (commitDatabaseBatchWrite))
        nil
    )

    #_override
    #_protected
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" notSettingChainHead []
        (.. (:block-store this) (abortDatabaseBatchWrite))
        nil
    )

    #_override
    #_protected
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" getStoredBlockInCurrentScope [#_"Sha256Hash" __hash]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))
        (.. (:block-store this) (getOnceUndoableStoredBlock __hash))
    )
)

;;;
 ; <p>Represents the "getaddr" P2P protocol message, which requests network {@link AddressMessage}s from a peer.
 ; Not to be confused with {@link Address} which is sort of like an account number.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class GetAddrMessage (ยง extends EmptyMessage)
    #_public
    (ยง constructor GetAddrMessage [#_"NetworkParameters" __params]
        (ยง super __params)
        this
    )
)

;;;
 ; <p>Represents the "getblocks" P2P network message, which requests the hashes of the parts of the block chain we're missing.
 ; Those blocks can then be downloaded with a {@link GetDataMessage}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class GetBlocksMessage (ยง extends Message)
    #_protected
    (ยง field #_"long" :version)
    #_protected
    (ยง field #_"List<Sha256Hash>" :locator)
    #_protected
    (ยง field #_"Sha256Hash" :stop-hash)

    #_public
    (ยง constructor GetBlocksMessage [#_"NetworkParameters" __params, #_"List<Sha256Hash>" __locator, #_"Sha256Hash" __stopHash]
        (ยง super __params)

        (ยง assoc this :version (:protocol-version this))
        (ยง assoc this :locator __locator)
        (ยง assoc this :stop-hash __stopHash)
        this
    )

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor GetBlocksMessage [#_"NetworkParameters" __params, #_"byte[]" __payload]
        (ยง super __params, __payload, 0)
        this
    )

    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        (ยง assoc this :cursor (:offset this))
        (ยง assoc this :version (.. this (readUint32)))
        (let [#_"int" __startCount (int (.. this (readVarInt)))]
            (when (< 500 __startCount)
                (throw (ProtocolException. (str "Number of locators cannot be > 500, received: " __startCount)))
            )

            (ยง assoc this :length (+ (- (:cursor this) (:offset this)) (* (inc __startCount) 32)))
            (ยง assoc this :locator (ArrayList. #_"<>" __startCount))
            (loop-when-recur [#_"int" __i 0] (< __i __startCount) [(inc __i)]
                (.. (:locator this) (add (.. this (readHash))))
            )
            (ยง assoc this :stop-hash (.. this (readHash)))
            nil
        )
    )

    #_public
    (ยง method #_"List<Sha256Hash>" getLocator []
        (:locator this)
    )

    #_public
    (ยง method #_"Sha256Hash" getStopHash []
        (:stop-hash this)
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (str "getblocks: " (.. Utils/SPACE_JOINER (join (:locator this))))
    )

    #_override
    #_protected
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __stream]
        ;; Version, for some reason.
        (Utils/uint32ToByteStreamLE (.. (:params this) (getProtocolVersionNum NetworkParameters.ProtocolVersion/CURRENT)), __stream)
        ;; Then a vector of block hashes.  This is actually a "block locator", a set of block
        ;; identifiers that spans the entire chain with exponentially increasing gaps between
        ;; them, until we end up at the genesis block.  See CBlockLocator::Set().
        (.. __stream (write (.. (VarInt. (.. (:locator this) (size))) (encode))))
        (doseq [#_"Sha256Hash" __hash (:locator this)]
            ;; Have to reverse as wire format is little endian.
            (.. __stream (write (.. __hash (getReversedBytes))))
        )
        ;; Next, a block ID to stop at.
        (.. __stream (write (.. (:stop-hash this) (getReversedBytes))))
        nil
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"GetBlocksMessage" __other (cast GetBlocksMessage __o)]
            (and (== (:version this) (:version __other)) (.. (:stop-hash this) (equals (:stop-hash __other))) (== (.. (:locator this) (size)) (.. (:locator __other) (size))) (.. (:locator this) (containsAll (:locator __other)))) ;; ignores locator ordering
        )
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (let [#_"int" __hashCode (bit-xor (int (:version this)) (.. "getblocks" (hashCode)) (.. (:stop-hash this) (hashCode)))]
            (doseq [#_"Sha256Hash" __l (:locator this)]
                (ยง ass __hashCode (bit-xor __hashCode (.. __l (hashCode)))) ;; ignores locator ordering
            )
            __hashCode
        )
    )
)

;;;
 ; <p>Represents the "getdata" P2P network message, which requests the contents of blocks or transactions given their hashes.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class GetDataMessage (ยง extends ListMessage)
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor GetDataMessage [#_"NetworkParameters" __params, #_"byte[]" __payloadBytes]
        (ยง super __params, __payloadBytes)
        this
    )

    ;;;
     ; Deserializes a 'getdata' message.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor GetDataMessage [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"MessageSerializer" __serializer, #_"int" __length]
        (ยง super __params, __payload, __serializer, __length)
        this
    )

    #_public
    (ยง constructor GetDataMessage [#_"NetworkParameters" __params]
        (ยง super __params)
        this
    )

    #_public
    (ยง method #_"void" addTransaction [#_"Sha256Hash" __hash]
        (.. this (addItem (InventoryItem. InventoryItem.Type/Transaction, __hash)))
        nil
    )

    #_public
    (ยง method #_"void" addBlock [#_"Sha256Hash" __hash]
        (.. this (addItem (InventoryItem. InventoryItem.Type/Block, __hash)))
        nil
    )

    #_public
    (ยง method #_"void" addFilteredBlock [#_"Sha256Hash" __hash]
        (.. this (addItem (InventoryItem. InventoryItem.Type/FilteredBlock, __hash)))
        nil
    )

    #_public
    (ยง method #_"Sha256Hash" getHashOf [#_"int" __i]
        (.. this (getItems) (get __i) :hash)
    )
)

;;;
 ; <p>The "getheaders" command is structurally identical to "getblocks", but has different meaning.  On receiving this
 ; message a Bitcoin node returns matching blocks up to the limit, but without the bodies.  It is useful as an
 ; optimization: when your wallet does not contain any keys created before a particular time, you don't have to download
 ; the bodies for those blocks because you know there are no relevant transactions.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class GetHeadersMessage (ยง extends GetBlocksMessage)
    #_public
    (ยง constructor GetHeadersMessage [#_"NetworkParameters" __params, #_"List<Sha256Hash>" __locator, #_"Sha256Hash" __stopHash]
        (ยง super __params, __locator, __stopHash)
        this
    )

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor GetHeadersMessage [#_"NetworkParameters" __params, #_"byte[]" __payload]
        (ยง super __params, __payload)
        this
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (str "getheaders: " (.. Utils/SPACE_JOINER (join (:locator this))))
    )

    ;;;
     ; Compares two getheaders messages.  Note that even though they are structurally identical a GetHeadersMessage
     ; will not compare equal to a GetBlocksMessage containing the same data.
     ;;
    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"GetHeadersMessage" __other (cast GetHeadersMessage __o)]
            (and (== (:version this) (:version __other)) (.. (:stop-hash this) (equals (:stop-hash __other))) (== (.. (:locator this) (size)) (.. (:locator __other) (size))) (.. (:locator this) (containsAll (:locator __other)))) ;; ignores locator ordering
        )
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (let [#_"int" __hashCode (bit-xor (int (:version this)) (.. "getheaders" (hashCode)) (.. (:stop-hash this) (hashCode)))]
            (doseq [#_"Sha256Hash" __l (:locator this)]
                (ยง ass __hashCode (bit-xor __hashCode (.. __l (hashCode)))) ;; ignores locator ordering
            )
            __hashCode
        )
    )
)

;;;
 ; <p>A protocol message that contains a repeated series of block headers, sent in response to the "getheaders" command.
 ; This is useful when you want to traverse the chain but know you don't care about the block contents, for example,
 ; because you have a freshly created wallet with no keys.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class HeadersMessage (ยง extends Message)
    #_private
    #_static
    (ยง def- #_"Logger" HeadersMessage/log (LoggerFactory/getLogger HeadersMessage))

    ;; The main client will never send us more than this number of headers.
    #_public
    #_static
    (ยง def #_"int" HeadersMessage/MAX_HEADERS 2000)

    #_private
    (ยง field- #_"List<Block>" :block-headers)

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor HeadersMessage [#_"NetworkParameters" __params, #_"byte[]" __payload]
        (ยง super __params, __payload, 0)
        this
    )

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor HeadersMessage [#_"NetworkParameters" __params, #_"Block..." __headers]
        (ยง super __params)
        (ยง assoc this :block-headers (Arrays/asList __headers))
        this
    )

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor HeadersMessage [#_"NetworkParameters" __params, #_"List<Block>" __headers]
        (ยง super __params)
        (ยง assoc this :block-headers __headers)
        this
    )

    #_override
    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __stream]
        (.. __stream (write (.. (VarInt. (.. (:block-headers this) (size))) (encode))))
        (doseq [#_"Block" __header (:block-headers this)]
            (.. __header (cloneAsHeader) (bitcoinSerializeToStream __stream))
            (.. __stream (write 0))
        )
        nil
    )

    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        (let [#_"long" __numHeaders (.. this (readVarInt))]
            (when (< HeadersMessage/MAX_HEADERS __numHeaders)
                (throw (ProtocolException. (str "Too many headers: got " __numHeaders " which is larger than " HeadersMessage/MAX_HEADERS)))
            )

            (ยง assoc this :block-headers (ArrayList. #_"<>"))
            (let [#_"BitcoinSerializer" __serializer (.. (:params this) (getSerializer true))]

                (loop-when-recur [#_"int" __i 0] (< __i __numHeaders) [(inc __i)]
                    (let [#_"Block" __newBlockHeader (.. __serializer (makeBlock (:payload this), (:cursor this), Message/UNKNOWN_LENGTH))]
                        (when (.. __newBlockHeader (hasTransactions))
                            (throw (ProtocolException. "Block header does not end with a nil byte"))
                        )

                        (ยง assoc this :cursor (+ (:cursor this) (:optimal-encoding-message-size __newBlockHeader)))
                        (.. (:block-headers this) (add __newBlockHeader))
                    )
                )

                (when (== (:length this) Message/UNKNOWN_LENGTH)
                    (ยง assoc this :length (- (:cursor this) (:offset this)))
                )

                (when (.. HeadersMessage/log (isDebugEnabled))
                    (loop-when-recur [#_"int" __i 0] (< __i __numHeaders) [(inc __i)]
                        (.. HeadersMessage/log (debug (.. (:block-headers this) (get __i) (toString))))
                    )
                )
                nil
            )
        )
    )

    #_public
    (ยง method #_"List<Block>" getBlockHeaders []
        (:block-headers this)
    )
)

;;;
 ; Thrown to indicate that you don't have enough money available to perform the requested operation.
 ;;
#_public
(ยง class InsufficientMoneyException (ยง extends Exception)
    ;;; Contains the number of satoshis that would have been required to complete the operation. ;;
    #_nilable
    #_public
    (ยง field #_"Coin" :missing)

    #_protected
    (ยง constructor InsufficientMoneyException []
        (ยง assoc this :missing nil)
        this
    )

    #_public
    (ยง constructor InsufficientMoneyException [#_"Coin" __missing]
        (ยง this __missing, (str "Insufficient money, missing " (.. __missing (toFriendlyString))))
        this
    )

    #_public
    (ยง constructor InsufficientMoneyException [#_"Coin" __missing, #_"String" __message]
        (ยง super __message)
        (ยง assoc this :missing (Preconditions/checkNotNull __missing))
        this
    )
)

#_public
(ยง class InventoryItem
    ;;;
     ; 4 byte uint32 type field + 32 byte hash
     ;;
    #_static
    (ยง def #_"int" InventoryItem/MESSAGE_LENGTH 36)

    #_public
    (ยง enum InventoryItem.Type
        (ยง item Error)
        (ยง item Transaction)
        (ยง item Block)
        (ยง item FilteredBlock)
    )

    #_public
    (ยง field #_"InventoryItem.Type" :type)
    #_public
    (ยง field #_"Sha256Hash" :hash)

    #_public
    (ยง constructor InventoryItem [#_"InventoryItem.Type" __type, #_"Sha256Hash" __hash]
        (ยง assoc this :type __type)
        (ยง assoc this :hash __hash)
        this
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (str (:type this) ": " (:hash this))
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"InventoryItem" __other (cast InventoryItem __o)]
            (and (== (:type this) (:type __other)) (.. (:hash this) (equals (:hash __other))))
        )
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (:type this), (:hash this))
    )
)

;;;
 ; <p>Represents the "inv" P2P network message.  An inv contains a list of hashes of either blocks or transactions.
 ; It's a bandwidth optimization - on receiving some data, a (fully validating) peer sends every connected peer an inv
 ; containing the hash of what it saw.  It'll only transmit the full thing if a peer asks for it with a
 ; {@link GetDataMessage}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class InventoryMessage (ยง extends ListMessage)
    ;;; A hard coded constant in the protocol. ;;
    #_public
    #_static
    (ยง def #_"int" InventoryMessage/MAX_INV_SIZE 50000)

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor InventoryMessage [#_"NetworkParameters" __params, #_"byte[]" __bytes]
        (ยง super __params, __bytes)
        this
    )

    ;;;
     ; Deserializes an 'inv' message.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor InventoryMessage [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"MessageSerializer" __serializer, #_"int" __length]
        (ยง super __params, __payload, __serializer, __length)
        this
    )

    #_public
    (ยง constructor InventoryMessage [#_"NetworkParameters" __params]
        (ยง super __params)
        this
    )

    #_public
    (ยง method #_"void" addBlock [#_"Block" __block]
        (.. this (addItem (InventoryItem. InventoryItem.Type/Block, (.. __block (getHash)))))
        nil
    )

    #_public
    (ยง method #_"void" addTransaction [#_"Transaction" __tx]
        (.. this (addItem (InventoryItem. InventoryItem.Type/Transaction, (.. __tx (getHash)))))
        nil
    )

    ;;; Creates a new inv message for the given transactions. ;;
    #_public
    #_static
    (ยง defn #_"InventoryMessage" InventoryMessage/with [#_"Transaction..." __txs]
        (Preconditions/checkArgument (< 0 (.. __txs (alength))))
        (let [#_"InventoryMessage" __result (InventoryMessage. (.. (aget __txs 0) (getParams)))]
            (doseq [#_"Transaction" __tx __txs]
                (.. __result (addTransaction __tx))
            )
            __result
        )
    )
)

;;;
 ; <p>Abstract superclass of classes with list based payload, i.e. InventoryMessage and GetDataMessage.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
(ยง class ListMessage (ยง extends Message)
    #_public
    #_static
    (ยง def #_"long" ListMessage/MAX_INVENTORY_ITEMS 50000)

    #_private
    (ยง field- #_"long" :array-len)
    ;; For some reason the compiler complains if this is inside InventoryItem.
    #_protected
    (ยง field #_"List<InventoryItem>" :items)

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor ListMessage [#_"NetworkParameters" __params, #_"byte[]" __bytes]
        (ยง super __params, __bytes, 0)
        this
    )

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor ListMessage [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"MessageSerializer" __serializer, #_"int" __length]
        (ยง super __params, __payload, 0, __serializer, __length)
        this
    )

    #_public
    (ยง constructor ListMessage [#_"NetworkParameters" __params]
        (ยง super __params)

        (ยง assoc this :items (ArrayList. #_"<>"))
        (ยง assoc this :length 1) ;; length of 0 varint
        this
    )

    #_public
    (ยง method #_"List<InventoryItem>" getItems []
        (Collections/unmodifiableList (:items this))
    )

    #_public
    (ยง method #_"void" addItem [#_"InventoryItem" __item]
        (.. this (unCache))
        (ยง assoc this :length (- (:length this) (VarInt/sizeOf (.. (:items this) (size)))))
        (.. (:items this) (add __item))
        (ยง assoc this :length (+ (:length this) (VarInt/sizeOf (.. (:items this) (size))) InventoryItem/MESSAGE_LENGTH))
        nil
    )

    #_public
    (ยง method #_"void" removeItem [#_"int" __index]
        (.. this (unCache))
        (ยง assoc this :length (- (:length this) (VarInt/sizeOf (.. (:items this) (size)))))
        (.. (:items this) (remove __index))
        (ยง assoc this :length (+ (:length this) (VarInt/sizeOf (.. (:items this) (size))) (- InventoryItem/MESSAGE_LENGTH)))
        nil
    )

    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        (ยง assoc this :array-len (.. this (readVarInt)))
        (when (< ListMessage/MAX_INVENTORY_ITEMS (:array-len this))
            (throw (ProtocolException. (str "Too many items in INV message: " (:array-len this))))
        )
        (ยง assoc this :length (int (+ (- (:cursor this) (:offset this)) (* (:array-len this) InventoryItem/MESSAGE_LENGTH))))

        ;; An inv is vector<CInv> where CInv is int+hash.  The int is either 1 or 2 for tx or block.
        (ยง assoc this :items (ArrayList. #_"<>" (int (:array-len this))))
        (loop-when-recur [#_"int" __i 0] (< __i (:array-len this)) [(inc __i)]
            (when (< (.. (:payload this) (alength)) (+ (:cursor this) InventoryItem/MESSAGE_LENGTH))
                (throw (ProtocolException. "Ran off the end of the INV"))
            )

            (let [#_"int" __typeCode (int (.. this (readUint32)))
                  ;; see ppszTypeName in net.h
                  #_"InventoryItem.Type" __type
                    (case __typeCode
                        0 InventoryItem.Type/Error
                        1 InventoryItem.Type/Transaction
                        2 InventoryItem.Type/Block
                        3 InventoryItem.Type/FilteredBlock
                        (throw (ProtocolException. (str "Unknown CInv type: " __typeCode)))
                    )]
                (.. (:items this) (add (InventoryItem. __type, (.. this (readHash)))))
            )
        )
        (ยง assoc this :payload nil)
        nil
    )

    #_override
    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __stream]
        (.. __stream (write (.. (VarInt. (.. (:items this) (size))) (encode))))
        (doseq [#_"InventoryItem" __i (:items this)]
            ;; Write out the type code.
            (Utils/uint32ToByteStreamLE (.. (:type __i) (ordinal)), __stream)
            ;; And now the hash.
            (.. __stream (write (.. (:hash __i) (getReversedBytes))))
        )
        nil
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (.. (:items this) (equals (:items (cast ListMessage __o))))
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (.. (:items this) (hashCode))
    )
)

;;;
 ; <p>The "mempool" message asks a remote peer to announce all transactions in its memory pool, possibly restricted by
 ; any Bloom filter set on the connection.  The list of transaction hashes comes back in an inv message.  Note that
 ; this is different to the {@link TxConfidenceTable} object which doesn't try to keep track of all pending transactions,
 ; it's just a holding area for transactions that a part of the app may find interesting.  The mempool message has
 ; no fields.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class MemoryPoolMessage (ยง extends Message)
    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        nil
    )

    #_override
    #_protected
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __stream]
        nil
    )
)

;;;
 ; <p>A Message is a data structure that can be serialized/deserialized using the Bitcoin serialization format.
 ; Specific types of messages that are used both in the block chain, and on the wire, are derived from this class.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
(ยง class Message
    #_private
    #_static
    (ยง def- #_"Logger" Message/log (LoggerFactory/getLogger Message))

    #_public
    #_static
    (ยง def #_"int" Message/MAX_SIZE 0x02000000) ;; 32MB

    #_public
    #_static
    (ยง def #_"int" Message/UNKNOWN_LENGTH Integer/MIN_VALUE)

    ;; Useful to ensure serialize/deserialize are consistent with each other.
    #_private
    #_static
    (ยง def- #_"boolean" Message/SELF_CHECK false)

    ;; The offset is how many bytes into the provided byte array this message payload starts at.
    #_protected
    (ยง field #_"int" :offset)
    ;; The cursor keeps track of where we are in the byte array as we parse it.
    ;; Note that it's relative to the start of the array NOT the start of the message payload.
    #_protected
    (ยง field #_"int" :cursor)

    #_protected
    (ยง field #_"int" :length Message/UNKNOWN_LENGTH)

    ;; The raw message payload bytes themselves.
    #_protected
    (ยง field #_"byte[]" :payload)

    #_protected
    (ยง field #_"boolean" :recached false)
    #_protected
    (ยง field #_"MessageSerializer" :serializer)

    #_protected
    (ยง field #_"int" :protocol-version)

    #_protected
    (ยง field #_"NetworkParameters" :params)

    #_protected
    (ยง constructor Message [#_"NetworkParameters" __params]
        (ยง assoc this :params __params)
        (ยง assoc this :serializer (.. __params (getDefaultSerializer)))
        this
    )

    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง constructor Message [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"int" __offset, #_"int" __protocolVersion]
        (ยง this __params, __payload, __offset, __protocolVersion, (.. __params (getDefaultSerializer)), Message/UNKNOWN_LENGTH)
        this
    )

    ;;;
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param protocolVersion Bitcoin protocol version.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message payload if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง constructor Message [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"int" __offset, #_"int" __protocolVersion, #_"MessageSerializer" __serializer, #_"int" __length]
        (ยง assoc this :serializer __serializer)
        (ยง assoc this :protocol-version __protocolVersion)
        (ยง assoc this :params __params)
        (ยง assoc this :payload __payload)
        (ยง assoc this :cursor (ยง assoc this :offset __offset))
        (ยง assoc this :length __length)

        (.. this (parse))

        (when (== (:length this) Message/UNKNOWN_LENGTH)
            (Preconditions/checkState false, "Length field has not been set in constructor for %s after parse.", (.. (getClass) (getSimpleName)))
        )

        (when Message/SELF_CHECK
            (.. this (selfCheck __payload, __offset))
        )

        (when (not (.. __serializer (isParseRetainMode)))
            (ยง assoc this :payload nil)
        )
        this
    )

    #_private
    (ยง method- #_"void" selfCheck [#_"byte[]" __payload, #_"int" __offset]
        (when (not (instance? VersionMessage this))
            (let [#_"byte[]" __payloadBytes (byte-array (- (:cursor this) __offset))]
                (System/arraycopy __payload, __offset, __payloadBytes, 0, (- (:cursor this) __offset))
                (let [#_"byte[]" __reserialized (.. this (bitcoinSerialize))]
                    (when (not (Arrays/equals __reserialized, __payloadBytes))
                        (throw (RuntimeException. (str "Serialization is wrong: \n" (.. Utils/HEX (encode __reserialized)) " vs \n" (.. Utils/HEX (encode __payloadBytes)))))
                    )
                )
            )
        )
        nil
    )

    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง constructor Message [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"int" __offset]
        (ยง this __params, __payload, __offset, (.. __params (getProtocolVersionNum NetworkParameters.ProtocolVersion/CURRENT)), (.. __params (getDefaultSerializer)), Message/UNKNOWN_LENGTH)
        this
    )

    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง constructor Message [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"int" __offset, #_"MessageSerializer" __serializer, #_"int" __length]
        (ยง this __params, __payload, __offset, (.. __params (getProtocolVersionNum NetworkParameters.ProtocolVersion/CURRENT)), __serializer, __length)
        this
    )

    ;; These methods handle the serialization/deserialization using the custom Bitcoin protocol.

    #_protected
    #_abstract
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse [])

    ;;;
     ; <p>To be called before any change of internal values including any setters.  This ensures any cached byte array is
     ; removed.<p/>
     ; <p>Child messages of this object (e.g. Transactions belonging to a Block) will not have their internal byte caches
     ; invalidated unless they are also modified internally.</p>
     ;;
    #_protected
    (ยง method #_"void" unCache []
        (ยง assoc this :payload nil)
        (ยง assoc this :recached false)
        nil
    )

    #_protected
    (ยง method #_"void" adjustLength [#_"int" __newArraySize, #_"int" __adjustment]
        (when (== (:length this) Message/UNKNOWN_LENGTH)
            (ยง return nil)
        )
        ;; Our own length is now unknown if we have an unknown length adjustment.
        (when (== __adjustment Message/UNKNOWN_LENGTH)
            (ยง assoc this :length Message/UNKNOWN_LENGTH)
            (ยง return nil)
        )
        (ยง assoc this :length (+ (:length this) __adjustment))
        ;; Check if we will need more bytes to encode the length prefix.
        (cond (== __newArraySize 1)
            (do
                (ยง assoc this :length (inc (:length this))) ;; The assumption here is we never call adjustLength with the same arraySize as before.
            )
            (!= __newArraySize 0)
            (do
                (ยง assoc this :length (+ (:length this) (- (VarInt/sizeOf __newArraySize) (VarInt/sizeOf (dec __newArraySize)))))
            )
        )
        nil
    )

    ;;;
     ; used for unit testing
     ;;
    #_public
    (ยง method #_"boolean" isCached []
        (some? (:payload this))
    )

    #_public
    (ยง method #_"boolean" isRecached []
        (:recached this)
    )

    ;;;
     ; Returns a copy of the array returned by {@link Message#unsafeBitcoinSerialize()}, which is safe to mutate.
     ; If you need extra performance and can guarantee you won't write to the array, you can use the unsafe version.
     ;
     ; @return a freshly allocated serialized byte array.
     ;;
    #_public
    (ยง method #_"byte[]" bitcoinSerialize []
        (let [#_"byte[]" __bytes (.. this (unsafeBitcoinSerialize))
              #_"byte[]" __copy (byte-array (.. __bytes (alength)))]
            (System/arraycopy __bytes, 0, __copy, 0, (.. __bytes (alength)))
            __copy
        )
    )

    ;;;
     ; Serialize this message to a byte array that conforms to the bitcoin wire protocol.
     ;
     ; This method may return the original byte array used to construct this message if the
     ; following conditions are met:
     ; <ol>
     ; <li>1. The message was parsed from a byte array with parseRetain = true.</li>
     ; <li>2. The message has not been modified.</li>
     ; <li>3. The array had an offset of 0 and no surplus bytes.</li>
     ; </ol>
     ;
     ; If condition 3 is not met then an copy of the relevant portion of the array will be returned.
     ; Otherwise a full serialize will occur.  For this reason you should only use this API
     ; if you can guarantee you will treat the resulting array as read only.
     ;
     ; @return a byte array owned by this object, do NOT mutate it.
     ;;
    #_public
    (ยง method #_"byte[]" unsafeBitcoinSerialize []
        ;; 1st attempt to use a cached array.
        (when (some? (:payload this))
            ;; Cached byte array is the entire message with no extras so we can return as is and avoid an array copy.
            (when (and (== (:offset this) 0) (== (:length this) (.. (:payload this) (alength))))
                (ยง return (:payload this))
            )

            (let [#_"byte[]" __buf (byte-array (:length this))]
                (System/arraycopy (:payload this), (:offset this), __buf, 0, (:length this))
                (ยง return __buf)
            )
        )

        ;; No cached array available so serialize parts by stream.
        (let [#_"ByteArrayOutputStream" __stream (ByteArrayOutputStream. (if (< (:length this) 32) 32 (+ (:length this) 32)))]
            (try
                (.. this (bitcoinSerializeToStream __stream))
                (catch IOException _
                    ;; Cannot happen, we are serializing to a memory stream.
                )
            )

            (when (.. (:serializer this) (isParseRetainMode))
                ;; A free set of steak knives!
                ;; If there happens to be a call to this method we gain an opportunity to recache
                ;; the byte array and in this case it contains no bytes from parent messages.
                ;; This give a dual benefit.  Releasing references to the larger byte array so that it
                ;; it is more likely to be GC'd.  And preventing double serializations.  E.g. calculating
                ;; merkle root calls this method.  It is will frequently happen prior to serializing the block
                ;; which means another call to bitcoinSerialize is coming.  If we didn't recache then internal
                ;; serialization would occur a 2nd time and every subsequent time the message is serialized.
                (ยง assoc this :payload (.. __stream (toByteArray)))
                (ยง assoc this :cursor (- (:cursor this) (:offset this)))
                (ยง assoc this :offset 0)
                (ยง assoc this :recached true)
                (ยง assoc this :length (.. (:payload this) (alength)))
                (ยง return (:payload this))
            )
            ;; Record length.  If this Message wasn't parsed from a byte stream it won't have length field
            ;; set (except for static length message types).  Setting it makes future streaming more efficient
            ;; because we can preallocate the ByteArrayOutputStream buffer and avoid resizing.
            (let [#_"byte[]" __buf (.. __stream (toByteArray))]
                (ยง assoc this :length (.. __buf (alength)))
                __buf
            )
        )
    )

    ;;;
     ; Serialize this message to the provided OutputStream using the bitcoin wire format.
     ;
     ; @param stream
     ; @throws IOException
     ;;
    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerialize [#_"OutputStream" __stream]
        ;; 1st check for cached bytes.
        (when (and (some? (:payload this)) (!= (:length this) Message/UNKNOWN_LENGTH))
            (.. __stream (write (:payload this), (:offset this), (:length this)))
            (ยง return nil)
        )

        (.. this (bitcoinSerializeToStream __stream))
        nil
    )

    ;;;
     ; Serializes this message to the provided stream.  If you just want the raw bytes use bitcoinSerialize().
     ;;
    #_protected
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __stream]
        (.. Message/log (error "Error: {} class has not implemented bitcoinSerializeToStream method.  Generating message with no payload", (getClass)))
        nil
    )

    ;;;
     ; This method is a NOP for all classes except Block and Transaction.  It is only declared in Message
     ; so BitcoinSerializer can avoid 2 instanceof checks + a casting.
     ;;
    #_public
    (ยง method #_"Sha256Hash" getHash []
        (throw (UnsupportedOperationException.))
    )

    ;;;
     ; This returns a correct value by parsing the message.
     ;;
    #_public
    (ยง method #_"int" getMessageSize []
        (when (== (:length this) Message/UNKNOWN_LENGTH)
            (Preconditions/checkState false, "Length field has not been set in %s.", (.. (getClass) (getSimpleName)))
        )
        (:length this)
    )

    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"long" readUint32 []
        (try
            (let [#_"long" __u (Utils/readUint32 (:payload this), (:cursor this))]
                (ยง assoc this :cursor (+ (:cursor this) 4))
                (ยง return __u)
            )
            (catch ArrayIndexOutOfBoundsException __e
                (throw (ProtocolException. __e))
            )
        )
    )

    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"long" readInt64 []
        (try
            (let [#_"long" __u (Utils/readInt64 (:payload this), (:cursor this))]
                (ยง assoc this :cursor (+ (:cursor this) 8))
                (ยง return __u)
            )
            (catch ArrayIndexOutOfBoundsException __e
                (throw (ProtocolException. __e))
            )
        )
    )

    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"BigInteger" readUint64 []
        ;; Java does not have an unsigned 64 bit type. So scrape it off the wire then flip.
        (BigInteger. (Utils/reverseBytes (.. this (readBytes 8))))
    )

    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"long" readVarInt []
        (.. this (readVarInt 0))
    )

    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"long" readVarInt [#_"int" __offset]
        (try
            (let [#_"VarInt" __varint (VarInt. (:payload this), (+ (:cursor this) __offset))]
                (ยง assoc this :cursor (+ (:cursor this) __offset (.. __varint (getOriginalSizeInBytes))))
                (ยง return (:value __varint))
            )
            (catch ArrayIndexOutOfBoundsException __e
                (throw (ProtocolException. __e))
            )
        )
    )

    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"byte[]" readBytes [#_"int" __length]
        (when (< Message/MAX_SIZE __length)
            (throw (ProtocolException. (str "Claimed value length too large: " __length)))
        )

        (try
            (let [#_"byte[]" __b (byte-array __length)]
                (System/arraycopy (:payload this), (:cursor this), __b, 0, __length)
                (ยง assoc this :cursor (+ (:cursor this) __length))
                (ยง return __b)
            )
            (catch IndexOutOfBoundsException __e
                (throw (ProtocolException. __e))
            )
        )
    )

    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"byte[]" readByteArray []
        (let [#_"long" __len (.. this (readVarInt))]
            (.. this (readBytes (int __len)))
        )
    )

    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"String" readStr []
        (let [#_"long" __length (.. this (readVarInt))]
            (if (== __length 0) "" (Utils/toString (.. this (readBytes (int __length))), "UTF-8")) ;; optimization for empty strings
        )
    )

    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"Sha256Hash" readHash []
        ;; We have to flip it around, as it's been read off the wire in little endian.
        ;; Not the most efficient way to do this but the clearest.
        (Sha256Hash/wrapReversed (.. this (readBytes 32)))
    )

    #_protected
    (ยง method #_"boolean" hasMoreBytes []
        (< (:cursor this) (.. (:payload this) (alength)))
    )

    ;;; Network parameters this message was created with. ;;
    #_public
    (ยง method #_"NetworkParameters" getParams []
        (:params this)
    )

    ;;;
     ; Set the serializer for this message when deserialized by Java.
     ;;
    #_private
    #_throws #_[ "IOException", "ClassNotFoundException" ]
    (ยง method- #_"void" readObject [#_"java.io.ObjectInputStream" __in]
        (.. __in (defaultReadObject))
        (when (some? (:params this))
            (ยง assoc this :serializer (.. (:params this) (getDefaultSerializer)))
        )
        nil
    )
)

;;;
 ; Generic interface for classes which serialize/deserialize messages.
 ; Implementing classes should be immutable.
 ;;
#_public
#_abstract
(ยง class MessageSerializer
    ;;;
     ; Reads a message from the given ByteBuffer and returns it.
     ;;
    #_public
    #_abstract
    #_throws #_[ "ProtocolException", "IOException", "UnsupportedOperationException" ]
    (ยง method #_"Message" deserialize [#_"ByteBuffer" __in])

    ;;;
     ; Deserializes only the header in case packet meta data is needed before decoding
     ; the payload.  This method assumes you have already called seekPastMagicBytes().
     ;;
    #_public
    #_abstract
    #_throws #_[ "ProtocolException", "IOException", "UnsupportedOperationException" ]
    (ยง method #_"BitcoinSerializer.BitcoinPacketHeader" deserializeHeader [#_"ByteBuffer" __in])

    ;;;
     ; Deserialize payload only.  You must provide a header, typically obtained by calling
     ; {@link BitcoinSerializer#deserializeHeader}.
     ;;
    #_public
    #_abstract
    #_throws #_[ "ProtocolException", "BufferUnderflowException", "UnsupportedOperationException" ]
    (ยง method #_"Message" deserializePayload [#_"BitcoinSerializer.BitcoinPacketHeader" __header, #_"ByteBuffer" __in])

    ;;;
     ; Whether the serializer will produce cached mode Messages.
     ;;
    #_public
    #_abstract
    (ยง method #_"boolean" isParseRetainMode [])

    ;;;
     ; Make an address message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    #_throws #_[ "ProtocolException", "UnsupportedOperationException" ]
    (ยง method #_"AddressMessage" makeAddressMessage [#_"byte[]" __payloadBytes, #_"int" __length])

    ;;;
     ; Make an alert message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    #_throws #_[ "ProtocolException", "UnsupportedOperationException" ]
    (ยง method #_"Message" makeAlertMessage [#_"byte[]" __payloadBytes])

    ;;;
     ; Make a block from the payload, using an offset of zero and the payload
     ; length as block length.
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"Block" makeBlock [#_"byte[]" __payloadBytes]
        (.. this (makeBlock __payloadBytes, 0, (.. __payloadBytes (alength))))
    )

    ;;;
     ; Make a block from the payload, using an offset of zero and the provided
     ; length as block length.
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"Block" makeBlock [#_"byte[]" __payloadBytes, #_"int" __length]
        (.. this (makeBlock __payloadBytes, 0, __length))
    )

    ;;;
     ; Make a block from the payload, using an offset of zero and the provided
     ; length as block length.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    #_throws #_[ "ProtocolException", "UnsupportedOperationException" ]
    (ยง method #_"Block" makeBlock [#_"byte[]" __payloadBytes, #_"int" __offset, #_"int" __length])

    ;;;
     ; Make an filter message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    #_throws #_[ "ProtocolException", "UnsupportedOperationException" ]
    (ยง method #_"Message" makeBloomFilter [#_"byte[]" __payloadBytes])

    ;;;
     ; Make a filtered block from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    #_throws #_[ "ProtocolException", "UnsupportedOperationException" ]
    (ยง method #_"FilteredBlock" makeFilteredBlock [#_"byte[]" __payloadBytes])

    ;;;
     ; Make an inventory message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    #_throws #_[ "ProtocolException", "UnsupportedOperationException" ]
    (ยง method #_"InventoryMessage" makeInventoryMessage [#_"byte[]" __payloadBytes, #_"int" __length])

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative
     ; serialization format support.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support deserialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support deserializing transactions.
     ;;
    #_public
    #_abstract
    #_throws #_[ "ProtocolException", "UnsupportedOperationException" ]
    (ยง method #_"Transaction" makeTransaction [#_"byte[]" __payloadBytes, #_"int" __offset, #_"int" __length, #_"byte[]" __hash])

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative
     ; serialization format support.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support deserialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support deserializing transactions.
     ;;
    #_public
    #_throws #_[ "ProtocolException", "UnsupportedOperationException" ]
    (ยง method #_"Transaction" makeTransaction [#_"byte[]" __payloadBytes]
        (.. this (makeTransaction __payloadBytes, 0))
    )

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative
     ; serialization format support.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support deserialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support deserializing transactions.
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"Transaction" makeTransaction [#_"byte[]" __payloadBytes, #_"int" __offset]
        (.. this (makeTransaction __payloadBytes, __offset, (.. __payloadBytes (alength)), nil))
    )

    #_public
    #_abstract
    #_throws #_[ "BufferUnderflowException" ]
    (ยง method #_"void" seekPastMagicBytes [#_"ByteBuffer" __in])

    ;;;
     ; Writes message to to the output stream.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support serialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support serializing the given message.
     ;;
    #_public
    #_abstract
    #_throws #_[ "IOException", "UnsupportedOperationException" ]
    (ยง method #_"void" serialize [#_"String" __name, #_"byte[]" __message, #_"OutputStream" __out])

    ;;;
     ; Writes message to to the output stream.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support serialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support serializing the given message.
     ;;
    #_public
    #_abstract
    #_throws #_[ "IOException", "UnsupportedOperationException" ]
    (ยง method #_"void" serialize [#_"Message" __message, #_"OutputStream" __out])
)

;;;
 ; Classes implementing this interface represent a monetary value, such as a Bitcoin or fiat amount.
 ;;
#_public
(ยง interface Monetary (ยง extends Serializable)
    ;;;
     ; Returns the absolute value of exponent of the value of a "smallest unit" in scientific notation.
     ; For Bitcoin, a satoshi is worth 1E-8 so this would be 8.
     ;;
    (ยง method #_"int" smallestUnitExponent [])

    ;;;
     ; Returns the number of "smallest units" of this monetary value.
     ; For Bitcoin, this would be the number of satoshis.
     ;;
    (ยง method #_"long" getValue [])

    (ยง method #_"int" signum [])
)

;;;
 ; <p>NetworkParameters contains the data needed for working with an instantiation of a Bitcoin chain.</p>
 ;
 ; <p>This is an abstract class, concrete instantiations can be found in the params package.  There are four:
 ; one for the main network ({@link MainNetParams}), one for the public test network, and two others that are
 ; intended for unit testing and local app development purposes.  Although this class contains some aliases for
 ; them, you are encouraged to call the static get() methods on each specific params class directly.</p>
 ;;
#_public
#_abstract
(ยง class NetworkParameters
    ;;;
     ; The alert signing key originally owned by Satoshi, and now passed on to Gavin along with a few others.
     ;;
    #_public
    #_static
    (ยง def #_"byte[]" NetworkParameters/SATOSHI_KEY (.. Utils/HEX (decode "04fc9702847840aaf195de8442ebecedf5b095cdbb9bc716bda9110971b28a49e0ead8564ff0db22209e0374782c093bb899692d524e9d6a6956e7c5ecbcd68284")))

    ;;; The string returned by getId() for the main, production network where people trade things. ;;
    #_public
    #_static
    (ยง def #_"String" NetworkParameters/ID_MAINNET "org.bitcoin.production")
    ;;; The string returned by getId() for the testnet. ;;
    #_public
    #_static
    (ยง def #_"String" NetworkParameters/ID_TESTNET "org.bitcoin.test")
    ;;; Unit test network. ;;
    #_public
    #_static
    (ยง def #_"String" NetworkParameters/ID_UNITTESTNET "org.bitcoinj.unittest")

    ;;; The string used by the payment protocol to represent the main net. ;;
    #_public
    #_static
    (ยง def #_"String" NetworkParameters/PAYMENT_PROTOCOL_ID_MAINNET "main")
    ;;; The string used by the payment protocol to represent the test net. ;;
    #_public
    #_static
    (ยง def #_"String" NetworkParameters/PAYMENT_PROTOCOL_ID_TESTNET "test")
    ;;; The string used by the payment protocol to represent unit testing (note that this is non-standard). ;;
    #_public
    #_static
    (ยง def #_"String" NetworkParameters/PAYMENT_PROTOCOL_ID_UNIT_TESTS "unittest")

    ;; TODO: Seed nodes should be here as well.

    #_protected
    (ยง field #_"Block" :genesis-block)
    #_protected
    (ยง field #_"BigInteger" :max-target)
    #_protected
    (ยง field #_"int" :port)
    #_protected
    (ยง field #_"long" :packet-magic) ;; Indicates message origin network and is used to seek to the next message when stream state is unknown.
    #_protected
    (ยง field #_"int" :address-header)
    #_protected
    (ยง field #_"int" :p2sh-header)
    #_protected
    (ยง field #_"int" :interval)
    #_protected
    (ยง field #_"int" :target-timespan)
    #_protected
    (ยง field #_"byte[]" :alert-signing-key)
    #_protected
    (ยง field #_"int" :bip32-header-pub)
    #_protected
    (ยง field #_"int" :bip32-header-priv)

    ;;; Used to check majorities for block version upgrade. ;;
    #_protected
    (ยง field #_"int" :majority-enforce-block-upgrade)
    #_protected
    (ยง field #_"int" :majority-reject-block-outdated)
    #_protected
    (ยง field #_"int" :majority-window)

    ;;;
     ; See getId().  This may be null for old deserialized wallets.  In that case we derive it heuristically
     ; by looking at the port number.
     ;;
    #_protected
    (ยง field #_"String" :id)

    ;;;
     ; The depth of blocks required for a coinbase transaction to be spendable.
     ;;
    #_protected
    (ยง field #_"int" :spendable-coinbase-depth)
    #_protected
    (ยง field #_"int" :subsidy-decrease-block-count)

    #_protected
    (ยง field #_"int[]" :acceptable-address-codes)
    #_protected
    (ยง field #_"String[]" :dns-seeds)
    #_protected
    (ยง field #_"int[]" :addr-seeds)
    #_protected
    (ยง field #_"Map<Integer, Sha256Hash>" :checkpoints (HashMap. #_"<>"))
    #_protected
    #_transient
    (ยง field #_"MessageSerializer" :default-serializer)

    #_protected
    (ยง constructor NetworkParameters []
        (ยง assoc this :alert-signing-key NetworkParameters/SATOSHI_KEY)
        (ยง assoc this :genesis-block (NetworkParameters/createGenesis this))
        this
    )

    #_private
    #_static
    (ยง defn- #_"Block" NetworkParameters/createGenesis [#_"NetworkParameters" __n]
        (let [#_"Block" __genesisBlock (Block. __n, Block/BLOCK_VERSION_GENESIS)
              #_"Transaction" __t (Transaction. __n)]
            (try
                ;; A script containing the difficulty bits and the following message: "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks".
                (let [#_"byte[]" __bytes (.. Utils/HEX (decode "04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73"))]
                    (.. __t (addInput (TransactionInput. __n, __t, __bytes)))
                    (let [#_"ByteArrayOutputStream" __scriptPubKeyBytes (ByteArrayOutputStream.)]
                        (Script/writeBytes __scriptPubKeyBytes, (.. Utils/HEX (decode "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f")))
                        (.. __scriptPubKeyBytes (write ScriptOpCodes/OP_CHECKSIG))
                        (.. __t (addOutput (TransactionOutput. __n, __t, Coin/FIFTY_COINS, (.. __scriptPubKeyBytes (toByteArray)))))
                    )
                )
                (catch Exception __e
                    (throw (RuntimeException. __e)) ;; Cannot happen.
                )
            )
            (.. __genesisBlock (addTransaction __t))
            __genesisBlock
        )
    )

    #_public
    #_static
    (ยง def #_"int" NetworkParameters/TARGET_TIMESPAN (* 14 24 60 60)) ;; 2 weeks per difficulty cycle, on average.
    #_public
    #_static
    (ยง def #_"int" NetworkParameters/TARGET_SPACING (* 10 60)) ;; 10 minutes per block.
    #_public
    #_static
    (ยง def #_"int" NetworkParameters/INTERVAL (/ NetworkParameters/TARGET_TIMESPAN NetworkParameters/TARGET_SPACING))

    ;;;
     ; Blocks with a timestamp after this should enforce BIP 16, aka "Pay to script hash".  This BIP changed
     ; the network rules in a soft-forking manner, that is, blocks that don't follow the rules are accepted
     ; but not mined upon and thus will be quickly re-orged out as long as the majority are enforcing the rule.
     ;;
    #_public
    #_static
    (ยง def #_"int" NetworkParameters/BIP16_ENFORCE_TIME 1333238400)

    ;;;
     ; The maximum number of coins to be generated.
     ;;
    #_public
    #_static
    (ยง def #_"long" NetworkParameters/MAX_COINS 21000000)

    ;;;
     ; The maximum money to be generated.
     ;;
    #_public
    #_static
    (ยง def #_"Coin" NetworkParameters/MAX_MONEY (.. Coin/COIN (multiply NetworkParameters/MAX_COINS)))

    ;;;
     ; A Java package style string acting as unique ID for these parameters.
     ;;
    #_public
    (ยง method #_"String" getId []
        (:id this)
    )

    #_public
    #_abstract
    (ยง method #_"String" getPaymentProtocolId [])

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (.. this (getId) (equals (.. (cast NetworkParameters __o) (getId))))
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (.. this (getId)))
    )

    ;;; Returns the network parameters for the given string ID or NULL if not recognized. ;;
    #_nilable
    #_public
    #_static
    (ยง defn #_"NetworkParameters" NetworkParameters/fromID [#_"String" __id]
        (when (.. __id (equals NetworkParameters/ID_MAINNET))
            (ยง return (MainNetParams/get))
        )
        (when (.. __id (equals NetworkParameters/ID_TESTNET))
            (ยง return (TestNet3Params/get))
        )
        (when (.. __id (equals NetworkParameters/ID_UNITTESTNET))
            (ยง return (UnitTestParams/get))
        )
        nil
    )

    ;;; Returns the network parameters for the given string paymentProtocolID or NULL if not recognized. ;;
    #_nilable
    #_public
    #_static
    (ยง defn #_"NetworkParameters" NetworkParameters/fromPmtProtocolID [#_"String" __pmtProtocolId]
        (when (.. __pmtProtocolId (equals NetworkParameters/PAYMENT_PROTOCOL_ID_MAINNET))
            (ยง return (MainNetParams/get))
        )
        (when (.. __pmtProtocolId (equals NetworkParameters/PAYMENT_PROTOCOL_ID_TESTNET))
            (ยง return (TestNet3Params/get))
        )
        (when (.. __pmtProtocolId (equals NetworkParameters/PAYMENT_PROTOCOL_ID_UNIT_TESTS))
            (ยง return (UnitTestParams/get))
        )
        nil
    )

    #_public
    (ยง method #_"int" getSpendableCoinbaseDepth []
        (:spendable-coinbase-depth this)
    )

    ;;;
     ; Throws an exception if the block's difficulty is not correct.
     ;
     ; @throws VerificationException if the block's difficulty is not correct.
     ;;
    #_public
    #_abstract
    #_throws #_[ "VerificationException", "BlockStoreException" ]
    (ยง method #_"void" checkDifficultyTransitions [#_"StoredBlock" __storedPrev, #_"Block" __next, #_"BlockStore" __blockStore])

    ;;;
     ; Returns true if the block height is either not a checkpoint, or is a checkpoint and the hash matches.
     ;;
    #_public
    (ยง method #_"boolean" passesCheckpoint [#_"int" __height, #_"Sha256Hash" __hash]
        (let [#_"Sha256Hash" __checkpointHash (.. (:checkpoints this) (get __height))]
            (or (nil? __checkpointHash) (.. __checkpointHash (equals __hash)))
        )
    )

    ;;;
     ; Returns true if the given height has a recorded checkpoint.
     ;;
    #_public
    (ยง method #_"boolean" isCheckpoint [#_"int" __height]
        (let [#_"Sha256Hash" __checkpointHash (.. (:checkpoints this) (get __height))]
            (some? __checkpointHash)
        )
    )

    #_public
    (ยง method #_"int" getSubsidyDecreaseBlockCount []
        (:subsidy-decrease-block-count this)
    )

    ;;; Returns DNS names that when resolved, give IP addresses of active peers. ;;
    #_public
    (ยง method #_"String[]" getDnsSeeds []
        (:dns-seeds this)
    )

    ;;; Returns IP address of active peers. ;;
    #_public
    (ยง method #_"int[]" getAddrSeeds []
        (:addr-seeds this)
    )

    ;;;
     ; <p>Genesis block for this chain.</p>
     ;
     ; <p>The first block in every chain is a well known constant shared between all Bitcoin implemenetations.
     ; For a block to be valid, it must be eventually possible to work backwards to the genesis block by following
     ; the prevBlockHash pointers in the block headers.</p>
     ;
     ; <p>The genesis blocks for both test and main networks contain the timestamp of when they were created,
     ; and a message in the coinbase transaction.  It says,
     ; <i>"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"</i>.</p>
     ;;
    #_public
    (ยง method #_"Block" getGenesisBlock []
        (:genesis-block this)
    )

    ;;; Default TCP port on which to connect to nodes. ;;
    #_public
    (ยง method #_"int" getPort []
        (:port this)
    )

    ;;; The header bytes that identify the start of a packet on this network. ;;
    #_public
    (ยง method #_"long" getPacketMagic []
        (:packet-magic this)
    )

    ;;;
     ; First byte of a base58 encoded address.  See {@link org.bitcoinj.core.Address}.
     ; This is the same as acceptableAddressCodes[0] and is the one used for "normal" addresses.
     ; Other types of address may be encountered with version codes found in the acceptableAddressCodes array.
     ;;
    #_public
    (ยง method #_"int" getAddressHeader []
        (:address-header this)
    )

    ;;;
     ; First byte of a base58 encoded P2SH address.  P2SH addresses are defined as part of BIP0013.
     ;;
    #_public
    (ยง method #_"int" getP2SHHeader []
        (:p2sh-header this)
    )

    ;;;
     ; How much time in seconds is supposed to pass between "interval" blocks.  If the actual elapsed time is
     ; significantly different from this value, the network difficulty formula will produce a different value.
     ; Both test and main Bitcoin networks use 2 weeks (1209600 seconds).
     ;;
    #_public
    (ยง method #_"int" getTargetTimespan []
        (:target-timespan this)
    )

    ;;;
     ; The version codes that prefix addresses which are acceptable on this network.  Although Satoshi intended these
     ; to be used for "versioning", in fact they are today used to discriminate what kind of data is contained in the
     ; address and to prevent accidentally sending coins across chains which would destroy them.
     ;;
    #_public
    (ยง method #_"int[]" getAcceptableAddressCodes []
        (:acceptable-address-codes this)
    )

    ;;;
     ; If we are running in testnet-in-a-box mode, we allow connections to nodes with 0 non-genesis blocks.
     ;;
    #_public
    (ยง method #_"boolean" allowEmptyPeerChain []
        true
    )

    ;;; How many blocks pass between difficulty adjustment periods.  Bitcoin standardises this to be 2016. ;;
    #_public
    (ยง method #_"int" getInterval []
        (:interval this)
    )

    ;;; Maximum target represents the easiest allowable proof of work. ;;
    #_public
    (ยง method #_"BigInteger" getMaxTarget []
        (:max-target this)
    )

    ;;;
     ; The key used to sign {@link org.bitcoinj.core.AlertMessage}s.
     ; You can use {@link org.bitcoinj.core.ECKey#verify(byte[], byte[], byte[])} to verify signatures using it.
     ;;
    #_public
    (ยง method #_"byte[]" getAlertSigningKey []
        (:alert-signing-key this)
    )

    ;;; Returns the 4 byte header for BIP32 (HD) wallet - public key part. ;;
    #_public
    (ยง method #_"int" getBip32HeaderPub []
        (:bip32-header-pub this)
    )

    ;;; Returns the 4 byte header for BIP32 (HD) wallet - private key part. ;;
    #_public
    (ยง method #_"int" getBip32HeaderPriv []
        (:bip32-header-priv this)
    )

    ;;;
     ; Returns the number of coins that will be produced in total, on this network.
     ; Where not applicable, a very large number of coins is returned
     ; instead (i.e. the main coin issue for Dogecoin).
     ;;
    #_public
    #_abstract
    (ยง method #_"Coin" getMaxMoney [])

    ;;;
     ; Any standard (i.e. pay-to-address) output smaller than this value will
     ; most likely be rejected by the network.
     ;;
    #_public
    #_abstract
    (ยง method #_"Coin" getMinNonDustOutput [])

    ;;;
     ; The monetary object for this currency.
     ;;
    #_public
    #_abstract
    (ยง method #_"MonetaryFormat" getMonetaryFormat [])

    ;;;
     ; Scheme part for URIs, for example "bitcoin".
     ;;
    #_public
    #_abstract
    (ยง method #_"String" getUriScheme [])

    ;;;
     ; Returns whether this network has a maximum number of coins (finite supply) or not.
     ; Always returns true for Bitcoin, but exists to be overriden for other networks.
     ;;
    #_public
    #_abstract
    (ยง method #_"boolean" hasMaxMoney [])

    ;;;
     ; Return the default serializer for this network.  This is a shared serializer.
     ;;
    #_public
    (ยง method #_"MessageSerializer" getDefaultSerializer []
        ;; Construct a default serializer if we don't have one.
        (when (nil? (:default-serializer this))
            ;; Don't grab a lock unless we absolutely need it.
            (ยง sync this
                ;; Now we have a lock, double check there's still no serializer and create one if so.
                (when (nil? (:default-serializer this))
                    ;; As the serializers are intended to be immutable, creating
                    ;; two due to a race condition should not be a problem, however
                    ;; to be safe we ensure only one exists for each network.
                    (ยง assoc this :default-serializer (.. this (getSerializer false)))
                )
            )
        )
        (:default-serializer this)
    )

    ;;;
     ; Construct and return a custom serializer.
     ;;
    #_public
    #_abstract
    (ยง method #_"BitcoinSerializer" getSerializer [#_"boolean" __parseRetain])

    ;;;
     ; The number of blocks in the last {@link getMajorityWindow()} blocks
     ; at which to trigger a notice to the user to upgrade their client, where
     ; the client does not understand those blocks.
     ;;
    #_public
    (ยง method #_"int" getMajorityEnforceBlockUpgrade []
        (:majority-enforce-block-upgrade this)
    )

    ;;;
     ; The number of blocks in the last {@link getMajorityWindow()} blocks
     ; at which to enforce the requirement that all new blocks are of the
     ; newer type (i.e. outdated blocks are rejected).
     ;;
    #_public
    (ยง method #_"int" getMajorityRejectBlockOutdated []
        (:majority-reject-block-outdated this)
    )

    ;;;
     ; The sampling window from which the version numbers of blocks are taken
     ; in order to determine if a new block version is now the majority.
     ;;
    #_public
    (ยง method #_"int" getMajorityWindow []
        (:majority-window this)
    )

    ;;;
     ; The flags indicating which block validation tests should be applied to
     ; the given block.  Enables support for alternative blockchains which enable
     ; tests based on different criteria.
     ;
     ; @param block Block to determine flags for.
     ; @param height Height of the block, if known, null otherwise.  Returned
     ; tests should be a safe subset if block height is unknown.
     ;;
    #_public
    (ยง method #_"EnumSet<Block.VerifyFlag>" getBlockVerificationFlags [#_"Block" __block, #_"VersionTally" __tally, #_"Integer" __height]
        (let [#_"EnumSet<Block.VerifyFlag>" __flags (EnumSet/noneOf Block.VerifyFlag)]

            (when (.. __block (isBIP34))
                (let [#_"Integer" __count (.. __tally (getCountAtOrAbove Block/BLOCK_VERSION_BIP34))]
                    (when (and (some? __count) (<= (.. this (getMajorityEnforceBlockUpgrade)) __count))
                        (.. __flags (add Block.VerifyFlag/HEIGHT_IN_COINBASE))
                    )
                )
            )

            __flags
        )
    )

    ;;;
     ; The flags indicating which script validation tests should be applied to
     ; the given transaction.  Enables support for alternative blockchains which enable
     ; tests based on different criteria.
     ;
     ; @param block Block the transaction belongs to.
     ; @param transaction to determine flags for.
     ; @param height Height of the block, if known, null otherwise.  Returned
     ; tests should be a safe subset if block height is unknown.
     ;;
    #_public
    (ยง method #_"EnumSet<Script.VerifyFlag>" getTransactionVerificationFlags [#_"Block" __block, #_"Transaction" __transaction, #_"VersionTally" __tally, #_"Integer" __height]
        (let [#_"EnumSet<Script.VerifyFlag>" __verifyFlags (EnumSet/noneOf Script.VerifyFlag)]
            (when (<= NetworkParameters/BIP16_ENFORCE_TIME (.. __block (getTimeSeconds)))
                (.. __verifyFlags (add Script.VerifyFlag/P2SH))
            )

            ;; Start enforcing CHECKLOCKTIMEVERIFY (BIP65) for block.nVersion=4 blocks,
            ;; when 75% of the network has been upgraded:
            (when (and (<= Block/BLOCK_VERSION_BIP65 (.. __block (getVersion))) (< (.. this (getMajorityEnforceBlockUpgrade)) (.. __tally (getCountAtOrAbove Block/BLOCK_VERSION_BIP65))))
                (.. __verifyFlags (add Script.VerifyFlag/CHECKLOCKTIMEVERIFY))
            )

            __verifyFlags
        )
    )

    #_public
    #_abstract
    (ยง method #_"int" getProtocolVersionNum [#_"NetworkParameters.ProtocolVersion" __version])

    #_public
    #_static
    (ยง enum NetworkParameters.ProtocolVersion
        (ยง item (MINIMUM 70000))
        (ยง item (PONG 60001))
        (ยง item (BLOOM_FILTER 70000))
        (ยง item (CURRENT 70001))

        #_private
        (ยง field- #_"int" :bitcoin-protocol)

        (ยง constructor NetworkParameters.ProtocolVersion [#_"int" __bitcoinProtocol]
            (ยง assoc this :bitcoin-protocol __bitcoinProtocol)
            this
        )

        #_public
        (ยง method #_"int" getBitcoinProtocolVersion []
            (:bitcoin-protocol this)
        )
    )
)

;;;
 ; <p>Sent by a peer when a getdata request doesn't find the requested data in the mempool.  It has the same format
 ; as an inventory message and lists the hashes of the missing items.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class NotFoundMessage (ยง extends InventoryMessage)
    #_public
    #_static
    (ยง def #_"int" NotFoundMessage/MIN_PROTOCOL_VERSION 70001)

    #_public
    (ยง constructor NotFoundMessage [#_"NetworkParameters" __params]
        (ยง super __params)
        this
    )

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor NotFoundMessage [#_"NetworkParameters" __params, #_"byte[]" __payloadBytes]
        (ยง super __params, __payloadBytes)
        this
    )

    #_public
    (ยง constructor NotFoundMessage [#_"NetworkParameters" __params, #_"List<InventoryItem>" __items]
        (ยง super __params)
        (ยง assoc this :items (ArrayList. #_"<>" __items))
        this
    )
)

;;;
 ; <p>A data structure that contains proofs of block inclusion for one or more transactions, in an efficient manner.</p>
 ;
 ; <p>The encoding works as follows: we traverse the tree in depth-first order, storing a bit for each traversed node,
 ; signifying whether the node is the parent of at least one matched leaf txid (or a matched txid itself).  In case we
 ; are at the leaf level, or this bit is 0, its merkle node hash is stored, and its children are not explored further.
 ; Otherwise, no hash is stored, but we recurse into both (or the only) child branch.  During decoding, the same
 ; depth-first traversal is performed, consuming bits and hashes as they were written during encoding.</p>
 ;
 ; <p>The serialization is fixed and provides a hard guarantee about the encoded size,
 ; <tt>SIZE &lt;= 10 + ceil(32.25 * N)</tt> where N represents the number of leaf nodes of the partial tree.
 ; N itself is bounded by:</p>
 ;
 ; N &lt;= total_transactions
 ; N &lt;= 1 + matched_transactions * tree_height
 ;
 ; <p><pre>The serialization format:
 ;  - uint32     total_transactions (4 bytes)
 ;  - varint     number of hashes (1-3 bytes)
 ;  - uint256[]  hashes in depth-first order (&lt;= 32*N bytes)
 ;  - varint     number of bytes of flag bits (1-3 bytes)
 ;  - byte[]     flag bits, packed per 8 in a byte, least significant bit first (&lt;= 2*N-1 bits)
 ; The size constraints follow from this.</pre></p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class PartialMerkleTree (ยง extends Message)
    ;; the total number of transactions in the block
    #_private
    (ยง field- #_"int" :transaction-count)

    ;; node-is-parent-of-matched-txid bits
    #_private
    (ยง field- #_"byte[]" :matched-child-bits)

    ;; txids and internal hashes
    #_private
    (ยง field- #_"List<Sha256Hash>" :hashes)

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor PartialMerkleTree [#_"NetworkParameters" __params, #_"byte[]" __payloadBytes, #_"int" __offset]
        (ยง super __params, __payloadBytes, __offset)
        this
    )

    ;;;
     ; Constructs a new PMT with the given bit set (little endian) and the raw list of hashes including internal hashes,
     ; taking ownership of the list.
     ;;
    #_public
    (ยง constructor PartialMerkleTree [#_"NetworkParameters" __params, #_"byte[]" __bits, #_"List<Sha256Hash>" __hashes, #_"int" __origTxCount]
        (ยง super __params)

        (ยง assoc this :matched-child-bits __bits)
        (ยง assoc this :hashes __hashes)
        (ยง assoc this :transaction-count __origTxCount)
        this
    )

    ;;;
     ; Calculates a PMT given the list of leaf hashes and which leaves need to be included.  The relevant interior hashes
     ; are calculated and a new PMT returned.
     ;;
    #_public
    #_static
    (ยง defn #_"PartialMerkleTree" PartialMerkleTree/buildFromLeaves [#_"NetworkParameters" __params, #_"byte[]" __includeBits, #_"List<Sha256Hash>" __allLeafHashes]
        ;; Calculate height of the tree.
        (let [#_"int" __height 0]
            (while (< 1 (PartialMerkleTree/getTreeWidth (.. __allLeafHashes (size)), __height))
                (ยง ass __height (inc __height))
            )
            (let [#_"List<Boolean>" __bitList (ArrayList. #_"<>")
                  #_"List<Sha256Hash>" __hashes (ArrayList. #_"<>")]
                (PartialMerkleTree/traverseAndBuild __height, 0, __allLeafHashes, __includeBits, __bitList, __hashes)
                (let [#_"byte[]" __bits (byte-array (int (Math/ceil (/ (.. __bitList (size)) 8.0))))]
                    (loop-when-recur [#_"int" __i 0] (< __i (.. __bitList (size))) [(inc __i)]
                        (when (.. __bitList (get __i))
                            (Utils/setBitLE __bits, __i)
                        )
                    )
                    (PartialMerkleTree. __params, __bits, __hashes, (.. __allLeafHashes (size)))
                )
            )
        )
    )

    #_override
    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __stream]
        (Utils/uint32ToByteStreamLE (:transaction-count this), __stream)

        (.. __stream (write (.. (VarInt. (.. (:hashes this) (size))) (encode))))
        (doseq [#_"Sha256Hash" __hash (:hashes this)]
            (.. __stream (write (.. __hash (getReversedBytes))))
        )

        (.. __stream (write (.. (VarInt. (.. (:matched-child-bits this) (alength))) (encode))))
        (.. __stream (write (:matched-child-bits this)))
        nil
    )

    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        (ยง assoc this :transaction-count (int (.. this (readUint32))))

        (let [#_"int" __nHashes (int (.. this (readVarInt)))]
            (ยง assoc this :hashes (ArrayList. #_"<>" __nHashes))
            (loop-when-recur [#_"int" __i 0] (< __i __nHashes) [(inc __i)]
                (.. (:hashes this) (add (.. this (readHash))))
            )

            (let [#_"int" __nFlagBytes (int (.. this (readVarInt)))]
                (ยง assoc this :matched-child-bits (.. this (readBytes __nFlagBytes)))

                (ยง assoc this :length (- (:cursor this) (:offset this)))
                nil
            )
        )
    )

    ;; Based on CPartialMerkleTree::TraverseAndBuild in Bitcoin Core.
    #_private
    #_static
    (ยง defn- #_"void" PartialMerkleTree/traverseAndBuild [#_"int" __height, #_"int" __pos, #_"List<Sha256Hash>" __allLeafHashes, #_"byte[]" __includeBits, #_"List<Boolean>" __matchedChildBits, #_"List<Sha256Hash>" __resultHashes]
        (let [#_"boolean" __parentOfMatch false]
            ;; Is this node a parent of at least one matched hash?
            (loop-when-recur [#_"int" __p (<< __pos __height)] (and (< __p (<< (inc __pos) __height)) (< __p (.. __allLeafHashes (size)))) [(inc __p)]
                (when (Utils/checkBitLE __includeBits, __p)
                    (ยง ass __parentOfMatch true)
                    (ยง break )
                )
            )
            ;; Store as a flag bit.
            (.. __matchedChildBits (add __parentOfMatch))
            (cond (or (== __height 0) (not __parentOfMatch))
                (do
                    ;; If at height 0, or nothing interesting below, store hash and stop.
                    (.. __resultHashes (add (PartialMerkleTree/calcHash __height, __pos, __allLeafHashes)))
                )
                :else
                (do
                    ;; Otherwise descend into the subtrees.
                    (let [#_"int" __h (dec __height)
                          #_"int" __p (* __pos 2)]
                        (PartialMerkleTree/traverseAndBuild __h, __p, __allLeafHashes, __includeBits, __matchedChildBits, __resultHashes)
                        (when (< (inc __p) (PartialMerkleTree/getTreeWidth (.. __allLeafHashes (size)), __h))
                            (PartialMerkleTree/traverseAndBuild __h, (inc __p), __allLeafHashes, __includeBits, __matchedChildBits, __resultHashes)
                        )
                    )
                )
            )
            nil
        )
    )

    #_private
    #_static
    (ยง defn- #_"Sha256Hash" PartialMerkleTree/calcHash [#_"int" __height, #_"int" __pos, #_"List<Sha256Hash>" __hashes]
        ;; Hash at height 0 is just the regular tx hash itself.
        (when (== __height 0)
            (ยง return (.. __hashes (get __pos)))
        )

        (let [#_"int" __h (dec __height)
              #_"int" __p (* __pos 2)
              #_"Sha256Hash" __left (PartialMerkleTree/calcHash __h, __p, __hashes)]
            ;; Calculate right hash if not beyond the end of the array - copy left hash otherwise.
            (let [#_"Sha256Hash" __right (if (< (inc __p) (PartialMerkleTree/getTreeWidth (.. __hashes (size)), __h)) (PartialMerkleTree/calcHash __h, (inc __p), __hashes) __left)]

                (PartialMerkleTree/combineLeftRight (.. __left (getBytes)), (.. __right (getBytes)))
            )
        )
    )

    ;; Helper function to efficiently calculate the number of nodes at given height in the merkle tree.
    #_private
    #_static
    (ยง defn- #_"int" PartialMerkleTree/getTreeWidth [#_"int" __transactionCount, #_"int" __height]
        (>> (dec (+ __transactionCount (<< 1 __height))) __height)
    )

    #_private
    #_static
    (ยง class- PartialMerkleTree.ValuesUsed
        #_public
        (ยง field #_"int" :bits-used 0)
        (ยง field #_"int" :hashes-used 0)
    )

    ;; Recursive function that traverses tree nodes, consuming the bits and hashes produced by TraverseAndBuild.
    ;; It returns the hash of the respective node.
    #_private
    #_throws #_[ "VerificationException" ]
    (ยง method- #_"Sha256Hash" recursiveExtractHashes [#_"int" __height, #_"int" __pos, #_"PartialMerkleTree.ValuesUsed" __used, #_"List<Sha256Hash>" __matchedHashes]
        ;; overflowed bits array - failure
        (when (<= (* (.. (:matched-child-bits this) (alength)) 8) (:bits-used __used))
            (throw (VerificationException. "PartialMerkleTree overflowed its bits array"))
        )

        (let [#_"boolean" __parentOfMatch (Utils/checkBitLE (:matched-child-bits this), (:bits-used __used))]
            (ยง assoc __used :bits-used (inc (:bits-used __used)))

            ;; if at height 0, or nothing interesting below, use stored hash and do not descend
            (cond (or (== __height 0) (not __parentOfMatch))
                (do
                    ;; overflowed hash array - failure
                    (when (<= (.. (:hashes this) (size)) (:hashes-used __used))
                        (throw (VerificationException. "PartialMerkleTree overflowed its hash array"))
                    )

                    (let [#_"Sha256Hash" __hash (.. (:hashes this) (get (:hashes-used __used)))]
                        (ยง assoc __used :hashes-used (inc (:hashes-used __used)))
                        ;; in case of height 0, we have a matched txid
                        (when (and (== __height 0) __parentOfMatch)
                            (.. __matchedHashes (add __hash))
                        )

                        (ยง return __hash)
                    )
                )
                :else
                (do
                    ;; otherwise, descend into the subtrees to extract matched txids and hashes
                    (let [#_"byte[]" __left (.. this (recursiveExtractHashes (dec __height), (* __pos 2), __used, __matchedHashes) (getBytes))
                          #_"byte[]" __right]
                        (cond (< (inc (* __pos 2)) (PartialMerkleTree/getTreeWidth (:transaction-count this), (dec __height)))
                            (do
                                (ยง ass __right (.. this (recursiveExtractHashes (dec __height), (inc (* __pos 2)), __used, __matchedHashes) (getBytes)))
                                (when (Arrays/equals __right, __left)
                                    (throw (VerificationException. "Invalid merkle tree with duplicated left/right branches"))
                                )
                            )
                            :else
                            (do
                                (ยง ass __right __left)
                            )
                        )
                        ;; and combine them before returning
                        (ยง return (PartialMerkleTree/combineLeftRight __left, __right))
                    )
                )
            )
        )
    )

    #_private
    #_static
    (ยง defn- #_"Sha256Hash" PartialMerkleTree/combineLeftRight [#_"byte[]" __left, #_"byte[]" __right]
        (Sha256Hash/wrapReversed (Sha256Hash/hashTwice (Utils/reverseBytes __left), 0, 32, (Utils/reverseBytes __right), 0, 32))
    )

    ;;;
     ; Extracts tx hashes that are in this merkle tree and returns the merkle root of this tree.
     ;
     ; The returned root should be checked against the merkle root contained in the block header for security.
     ;
     ; @param matchedHashesOut A list which will contain the matched txn (will be cleared).
     ; @return the merkle root of this merkle tree.
     ; @throws ProtocolException if this partial merkle tree is invalid.
     ;;
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"Sha256Hash" getTxnHashAndMerkleRoot [#_"List<Sha256Hash>" __matchedHashesOut]
        (.. __matchedHashesOut (clear))

        ;; an empty set will not work
        (when (== (:transaction-count this) 0)
            (throw (VerificationException. "Got a CPartialMerkleTree with 0 transactions"))
        )
        ;; check for excessively high numbers of transactions
        (when (< (/ Block/MAX_BLOCK_SIZE 60) (:transaction-count this)) ;; 60 is the lower bound for the size of a serialized CTransaction
            (throw (VerificationException. "Got a CPartialMerkleTree with more transactions than is possible"))
        )
        ;; there can never be more hashes provided than one for every txid
        (when (< (:transaction-count this) (.. (:hashes this) (size)))
            (throw (VerificationException. "Got a CPartialMerkleTree with more hashes than transactions"))
        )
        ;; there must be at least one bit per node in the partial tree, and at least one node per hash
        (when (< (* (.. (:matched-child-bits this) (alength)) 8) (.. (:hashes this) (size)))
            (throw (VerificationException. "Got a CPartialMerkleTree with fewer matched bits than hashes"))
        )

        ;; calculate height of tree
        (let [#_"int" __height 0]
            (while (< 1 (PartialMerkleTree/getTreeWidth (:transaction-count this), __height))
                (ยง ass __height (inc __height))
            )
            ;; traverse the partial tree
            (let [#_"PartialMerkleTree.ValuesUsed" __used (PartialMerkleTree.ValuesUsed.)
                  #_"Sha256Hash" __merkleRoot (.. this (recursiveExtractHashes __height, 0, __used, __matchedHashesOut))]
                ;; verify that all bits were consumed (except for the padding caused by serializing it as a byte sequence)
                ;; verify that all hashes were consumed
                (when (or (!= (/ (+ (:bits-used __used) 7) 8) (.. (:matched-child-bits this) (alength))) (!= (:hashes-used __used) (.. (:hashes this) (size))))
                    (throw (VerificationException. "Got a CPartialMerkleTree that didn't need all the data it provided"))
                )

                __merkleRoot
            )
        )
    )

    #_public
    (ยง method #_"int" getTransactionCount []
        (:transaction-count this)
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"PartialMerkleTree" __other (cast PartialMerkleTree __o)]
            (and (== (:transaction-count this) (:transaction-count __other)) (.. (:hashes this) (equals (:hashes __other))) (Arrays/equals (:matched-child-bits this), (:matched-child-bits __other)))
        )
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (:transaction-count this), (:hashes this), (Arrays/hashCode (:matched-child-bits this)))
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (str "PartialMerkleTree{" "transactionCount=" (:transaction-count this) ", matchedChildBits=" (Arrays/toString (:matched-child-bits this)) ", hashes=" (:hashes this) "}")
    )
)

;;;
 ; <p>A Peer handles the high level communication with a Bitcoin node, extending a {@link PeerSocketHandler} which
 ; handles low-level message (de)serialization.</p>
 ;
 ; <p>Note that timeouts are handled by the extended
 ; {@link org.bitcoinj.net.AbstractTimeoutHandler} and timeout is automatically disabled (using
 ; {@link org.bitcoinj.net.AbstractTimeoutHandler#setTimeoutEnabled(boolean)}) once the version
 ; handshake completes.</p>
 ;;
#_public
(ยง class Peer (ยง extends PeerSocketHandler)
    #_private
    #_static
    (ยง def- #_"Logger" Peer/log (LoggerFactory/getLogger Peer))

    #_protected
    (ยง field #_"ReentrantLock" :lock (Threading/lock "peer"))

    #_private
    (ยง field- #_"NetworkParameters" :params)
    #_private
    (ยง field- #_"AbstractBlockChain" :block-chain)
    #_private
    (ยง field- #_"Context" :context)

    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<BlocksDownloadedEventListener>>" :blocks-downloaded-event-listeners (CopyOnWriteArrayList. #_"<>"))
    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<ChainDownloadStartedEventListener>>" :chain-download-started-event-listeners (CopyOnWriteArrayList. #_"<>"))
    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<PeerConnectedEventListener>>" :connected-event-listeners (CopyOnWriteArrayList. #_"<>"))
    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<PeerDisconnectedEventListener>>" :disconnected-event-listeners (CopyOnWriteArrayList. #_"<>"))
    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<GetDataEventListener>>" :get-data-event-listeners (CopyOnWriteArrayList. #_"<>"))
    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<PreMessageReceivedEventListener>>" :pre-message-received-event-listeners (CopyOnWriteArrayList. #_"<>"))
    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<OnTransactionBroadcastListener>>" :on-transaction-event-listeners (CopyOnWriteArrayList. #_"<>"))

    ;; Whether to try and download blocks and transactions from this peer.  Set to false by PeerGroup if not the
    ;; primary peer.  This is to avoid redundant work and concurrency problems with downloading the same chain
    ;; in parallel.
    #_private
    #_volatile
    (ยง field- #_"boolean" :v-download-data)
    ;; The version data to announce to the other side of the connections we make: useful for setting our "user agent"
    ;; equivalent and other things.
    #_private
    (ยง field- #_"VersionMessage" :version-message)
    ;; Maximum depth up to which pending transaction dependencies are downloaded, or 0 for disabled.
    #_private
    #_volatile
    (ยง field- #_"int" :v-download-tx-dependency-depth)
    ;; How many block messages the peer has announced to us.  Peers only announce blocks that attach to their best chain
    ;; so we can use this to calculate the height of the peers chain, by adding it to the initial height in the version
    ;; message.  This method can go wrong if the peer re-orgs onto a shorter (but harder) chain, however, this is rare.
    #_private
    (ยง field- #_"AtomicInteger" :blocks-announced (AtomicInteger.))
    ;; Each wallet added to the peer will be notified of downloaded transaction data.
    #_private
    (ยง field- #_"CopyOnWriteArrayList<Wallet>" :wallets)
    ;; A time before which we only download block headers, after that point we download block bodies.
    #_private
    (ยง field- #_"long" :fast-catchup-time-secs)
    ;; Whether we are currently downloading headers only or block bodies.  Starts at true.  If the fast catchup time is
    ;; set AND our best block is before that date, switch to false until block headers beyond that point have been
    ;; received at which point it gets set to true again.  This isn't relevant unless vDownloadData is true.
    #_private
    (ยง field- #_"boolean" :download-block-bodies true)
    ;; Whether to request filtered blocks instead of full blocks if the protocol version allows for them.
    #_private
    (ยง field- #_"boolean" :use-filtered-blocks false)
    ;; The current Bloom filter set on the connection, used to tell the remote peer what transactions to send us.
    #_private
    #_volatile
    (ยง field- #_"BloomFilter" :v-bloom-filter)
    ;; The last filtered block we received, we're waiting to fill it out with transactions.
    #_private
    (ยง field- #_"FilteredBlock" :current-filtered-block nil)
    ;; How many filtered blocks have been received during the lifetime of this connection.  Used to decide when to
    ;; refresh the server-side side filter by sending a new one (it degrades over time as false positives are added
    ;; on the remote side, see BIP 37 for a discussion of this).
    ;; TODO: Is this still needed?  It should not be since the auto FP tracking logic was added.
    #_private
    (ยง field- #_"int" :filtered-blocks-received)
    ;; If non-null, we should discard incoming filtered blocks because we ran out of keys and are awaiting a new filter
    ;; to be calculated by the PeerGroup.  The discarded block hashes should be added here so we can re-request them
    ;; once we've recalculated and resent a new filter.
    #_nilable
    #_private
    (ยง field- #_"List<Sha256Hash>" :awaiting-fresh-filter)
    ;; How frequently to refresh the filter.  This should become dynamic in future and calculated depending on the
    ;; actual false positive rate.  For now a good value was determined empirically around January 2013.
    #_private
    #_static
    (ยง def- #_"int" Peer/RESEND_BLOOM_FILTER_BLOCK_COUNT 25000)
    ;; Keeps track of things we requested internally with getdata but didn't receive yet, so we can avoid re-requests.
    ;; It's not quite the same as getDataFutures, as this is used only for getdatas done as part of downloading
    ;; the chain and so is lighter weight (we just keep a bunch of hashes not futures).
    ;;
    ;; It is important to avoid a nasty edge case where we can end up with parallel chain downloads proceeding
    ;; simultaneously if we were to receive a newly solved block whilst parts of the chain are streaming to us.
    #_private
    (ยง field- #_"HashSet<Sha256Hash>" :pending-block-downloads (HashSet. #_"<>"))
    ;; Keep references to TransactionConfidence objects for transactions that were announced by a remote peer, but
    ;; which we haven't downloaded yet.  These objects are de-duplicated by the TxConfidenceTable class.
    ;; Once the tx is downloaded (by some peer), the Transaction object that is created will have a reference to
    ;; the confidence object held inside it, and it's then up to the event listeners that receive the Transaction
    ;; to keep it pinned to the root set if they care about this data.
    #_suppress #_[ "MismatchedQueryAndUpdateOfCollection" ]
    #_private
    (ยง field- #_"HashSet<TransactionConfidence>" :pending-tx-downloads (HashSet. #_"<>"))
    ;; The lowest version number we're willing to accept.  Lower than this will result in an immediate disconnect.
    #_private
    #_volatile
    (ยง field- #_"int" :v-min-protocol-version)
    ;; When an API user explicitly requests a block or transaction from a peer, the InventoryItem is put here
    ;; whilst waiting for the response.  Is not used for downloads Peer generates itself.
    #_private
    #_static
    (ยง class- Peer.GetDataRequest
        (ยง field #_"Sha256Hash" :hash)
        (ยง field #_"SettableFuture" :future)

        #_public
        (ยง constructor Peer.GetDataRequest [#_"Sha256Hash" __hash, #_"SettableFuture" __future]
            (ยง assoc this :hash __hash)
            (ยง assoc this :future __future)
            this
        )
    )
    ;; TODO: The types/locking should be rationalised a bit.
    #_private
    (ยง field- #_"CopyOnWriteArrayList<Peer.GetDataRequest>" :get-data-futures)
    #_private
    (ยง field- #_"LinkedList<SettableFuture<AddressMessage>>" :get-addr-futures)

    #_private
    #_static
    (ยง def- #_"int" Peer/PING_MOVING_AVERAGE_WINDOW 20)

    ;; Outstanding pings against this peer and how long the last one took to complete.
    #_private
    (ยง field- #_"ReentrantLock" :last-ping-times-lock (ReentrantLock.))
    #_private
    (ยง field- #_"long[]" :last-ping-times)
    #_private
    (ยง field- #_"CopyOnWriteArrayList<Peer.PendingPing>" :pending-pings)

    #_private
    #_volatile
    (ยง field- #_"VersionMessage" :v-peer-version-message)

    ;; A settable future which completes (with this) when the connection is open.
    #_private
    (ยง field- #_"SettableFuture<Peer>" :connection-open-future (SettableFuture/create))
    #_private
    (ยง field- #_"SettableFuture<Peer>" :outgoing-version-handshake-future (SettableFuture/create))
    #_private
    (ยง field- #_"SettableFuture<Peer>" :incoming-version-handshake-future (SettableFuture/create))
    #_private
    (ยง field- #_"ListenableFuture<Peer>" :version-handshake-future (Futures/transform (Futures/allAsList (:outgoing-version-handshake-future this), (:incoming-version-handshake-future this)), (Function. #_"<List<Peer>, Peer>")
        (ยง anon
            #_override
            #_nilable
            #_public
            (ยง method #_"Peer" apply [#_nilable #_"List<Peer>" __peers]
                (Preconditions/checkNotNull __peers)
                (Preconditions/checkState (and (== (.. __peers (size)) 2) (== (.. __peers (get 0)) (.. __peers (get 1)))))
                (.. __peers (get 0))
            )
        )))

    ;;;
     ; <p>Construct a peer that reads/writes from the given block chain.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection.  If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
    #_public
    (ยง constructor Peer [#_"NetworkParameters" __params, #_"VersionMessage" __ver, #_nilable #_"AbstractBlockChain" __chain, #_"PeerAddress" __remoteAddress]
        (ยง this __params, __ver, __remoteAddress, __chain)
        this
    )

    ;;;
     ; <p>Construct a peer that reads/writes from the given block chain.  Transactions stored in a {@link org.bitcoinj.core.TxConfidenceTable}
     ; will have their confidence levels updated when a peer announces it, to reflect the greater likelyhood that
     ; the transaction is valid.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection.  If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
    #_public
    (ยง constructor Peer [#_"NetworkParameters" __params, #_"VersionMessage" __ver, #_"PeerAddress" __remoteAddress, #_nilable #_"AbstractBlockChain" __chain]
        (ยง this __params, __ver, __remoteAddress, __chain, Integer/MAX_VALUE)
        this
    )

    ;;;
     ; <p>Construct a peer that reads/writes from the given block chain.  Transactions stored in a {@link org.bitcoinj.core.TxConfidenceTable}
     ; will have their confidence levels updated when a peer announces it, to reflect the greater likelyhood that
     ; the transaction is valid.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection.  If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
    #_public
    (ยง constructor Peer [#_"NetworkParameters" __params, #_"VersionMessage" __ver, #_"PeerAddress" __remoteAddress, #_nilable #_"AbstractBlockChain" __chain, #_"int" __downloadTxDependencyDepth]
        (ยง super __params, __remoteAddress)

        (ยง assoc this :params (Preconditions/checkNotNull __params))
        (ยง assoc this :version-message (Preconditions/checkNotNull __ver))
        (ยง assoc this :v-download-tx-dependency-depth (if (some? __chain) __downloadTxDependencyDepth 0))
        (ยง assoc this :block-chain __chain) ;; Allowed to be nil.
        (ยง assoc this :v-download-data (some? __chain))
        (ยง assoc this :get-data-futures (CopyOnWriteArrayList. #_"<>"))
        (ยง assoc this :get-addr-futures (LinkedList. #_"<>"))
        (ยง assoc this :fast-catchup-time-secs (.. __params (getGenesisBlock) (getTimeSeconds)))
        (ยง assoc this :pending-pings (CopyOnWriteArrayList. #_"<>"))
        (ยง assoc this :v-min-protocol-version (.. __params (getProtocolVersionNum NetworkParameters.ProtocolVersion/PONG)))
        (ยง assoc this :wallets (CopyOnWriteArrayList. #_"<>"))
        (ยง assoc this :context (Context/get))

        (.. (:version-handshake-future this) (addListener (Runnable.)
        (ยง anon
            #_override
            #_public
            (ยง method #_"void" run []
                (.. this (versionHandshakeComplete))
                nil
            )
        ), Threading/SAME_THREAD))
        this
    )

    ;;;
     ; <p>Construct a peer that reads/writes from the given chain.  Automatically creates a VersionMessage for you from
     ; the given software name/version strings, which should be something like "MySimpleTool", "1.0" and which will tell
     ; the remote node to relay transaction inv messages before it has received a filter.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection. If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
    #_public
    (ยง constructor Peer [#_"NetworkParameters" __params, #_"AbstractBlockChain" __blockChain, #_"PeerAddress" __peerAddress, #_"String" __thisSoftwareName, #_"String" __thisSoftwareVersion]
        (ยง this __params, (VersionMessage. __params, (.. __blockChain (getBestChainHeight))), __blockChain, __peerAddress)
        (.. (:version-message this) (appendToSubVer __thisSoftwareName, __thisSoftwareVersion, nil))
        this
    )

    ;;; Registers a listener that is invoked when new blocks are downloaded. ;;
    #_public
    (ยง method #_"void" addBlocksDownloadedEventListener [#_"BlocksDownloadedEventListener" __listener]
        (.. this (addBlocksDownloadedEventListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;; Registers a listener that is invoked when new blocks are downloaded. ;;
    #_public
    (ยง method #_"void" addBlocksDownloadedEventListener [#_"Executor" __executor, #_"BlocksDownloadedEventListener" __listener]
        (.. (:blocks-downloaded-event-listeners this) (add (ListenerRegistration. __listener, __executor)))
        nil
    )

    ;;; Registers a listener that is invoked when a blockchain downloaded starts. ;;
    #_public
    (ยง method #_"void" addChainDownloadStartedEventListener [#_"ChainDownloadStartedEventListener" __listener]
        (.. this (addChainDownloadStartedEventListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;; Registers a listener that is invoked when a blockchain downloaded starts. ;;
    #_public
    (ยง method #_"void" addChainDownloadStartedEventListener [#_"Executor" __executor, #_"ChainDownloadStartedEventListener" __listener]
        (.. (:chain-download-started-event-listeners this) (add (ListenerRegistration. __listener, __executor)))
        nil
    )

    ;;; Registers a listener that is invoked when a peer is connected. ;;
    #_public
    (ยง method #_"void" addConnectedEventListener [#_"PeerConnectedEventListener" __listener]
        (.. this (addConnectedEventListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;; Registers a listener that is invoked when a peer is connected. ;;
    #_public
    (ยง method #_"void" addConnectedEventListener [#_"Executor" __executor, #_"PeerConnectedEventListener" __listener]
        (.. (:connected-event-listeners this) (add (ListenerRegistration. __listener, __executor)))
        nil
    )

    ;;; Registers a listener that is invoked when a peer is disconnected. ;;
    #_public
    (ยง method #_"void" addDisconnectedEventListener [#_"PeerDisconnectedEventListener" __listener]
        (.. this (addDisconnectedEventListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;; Registers a listener that is invoked when a peer is disconnected. ;;
    #_public
    (ยง method #_"void" addDisconnectedEventListener [#_"Executor" __executor, #_"PeerDisconnectedEventListener" __listener]
        (.. (:disconnected-event-listeners this) (add (ListenerRegistration. __listener, __executor)))
        nil
    )

    ;;; Registers a listener that is called when messages are received. ;;
    #_public
    (ยง method #_"void" addGetDataEventListener [#_"GetDataEventListener" __listener]
        (.. this (addGetDataEventListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;; Registers a listener that is called when messages are received. ;;
    #_public
    (ยง method #_"void" addGetDataEventListener [#_"Executor" __executor, #_"GetDataEventListener" __listener]
        (.. (:get-data-event-listeners this) (add (ListenerRegistration. #_"<>" __listener, __executor)))
        nil
    )

    ;;; Registers a listener that is called when a transaction is broadcast across the network. ;;
    #_public
    (ยง method #_"void" addOnTransactionBroadcastListener [#_"OnTransactionBroadcastListener" __listener]
        (.. this (addOnTransactionBroadcastListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;; Registers a listener that is called when a transaction is broadcast across the network. ;;
    #_public
    (ยง method #_"void" addOnTransactionBroadcastListener [#_"Executor" __executor, #_"OnTransactionBroadcastListener" __listener]
        (.. (:on-transaction-event-listeners this) (add (ListenerRegistration. #_"<>" __listener, __executor)))
        nil
    )

    ;;; Registers a listener that is called immediately before a message is received. ;;
    #_public
    (ยง method #_"void" addPreMessageReceivedEventListener [#_"PreMessageReceivedEventListener" __listener]
        (.. this (addPreMessageReceivedEventListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;; Registers a listener that is called immediately before a message is received. ;;
    #_public
    (ยง method #_"void" addPreMessageReceivedEventListener [#_"Executor" __executor, #_"PreMessageReceivedEventListener" __listener]
        (.. (:pre-message-received-event-listeners this) (add (ListenerRegistration. #_"<>" __listener, __executor)))
        nil
    )

    #_public
    (ยง method #_"boolean" removeBlocksDownloadedEventListener [#_"BlocksDownloadedEventListener" __listener]
        (ListenerRegistration/removeFromList __listener, (:blocks-downloaded-event-listeners this))
    )

    #_public
    (ยง method #_"boolean" removeChainDownloadStartedEventListener [#_"ChainDownloadStartedEventListener" __listener]
        (ListenerRegistration/removeFromList __listener, (:chain-download-started-event-listeners this))
    )

    #_public
    (ยง method #_"boolean" removeConnectedEventListener [#_"PeerConnectedEventListener" __listener]
        (ListenerRegistration/removeFromList __listener, (:connected-event-listeners this))
    )

    #_public
    (ยง method #_"boolean" removeDisconnectedEventListener [#_"PeerDisconnectedEventListener" __listener]
        (ListenerRegistration/removeFromList __listener, (:disconnected-event-listeners this))
    )

    #_public
    (ยง method #_"boolean" removeGetDataEventListener [#_"GetDataEventListener" __listener]
        (ListenerRegistration/removeFromList __listener, (:get-data-event-listeners this))
    )

    #_public
    (ยง method #_"boolean" removeOnTransactionBroadcastListener [#_"OnTransactionBroadcastListener" __listener]
        (ListenerRegistration/removeFromList __listener, (:on-transaction-event-listeners this))
    )

    #_public
    (ยง method #_"boolean" removePreMessageReceivedEventListener [#_"PreMessageReceivedEventListener" __listener]
        (ListenerRegistration/removeFromList __listener, (:pre-message-received-event-listeners this))
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (let [#_"PeerAddress" __addr (.. this (getAddress))]
            ;; if null, it's a user-provided NetworkConnection object
            (if (some? __addr) (.. __addr (toString)) "Peer()")
        )
    )

    #_override
    #_protected
    (ยง method #_"void" timeoutOccurred []
        (.. super (timeoutOccurred))

        (when (not (.. (:connection-open-future this) (isDone)))
            ;; Invoke the event handlers to tell listeners e.g. PeerGroup that we never managed to connect.
            (.. this (connectionClosed))
        )
        nil
    )

    #_override
    #_public
    (ยง method #_"void" connectionClosed []
        (doseq [#_"ListenerRegistration<PeerDisconnectedEventListener>" __registration (:disconnected-event-listeners this)]
            (.. (:executor __registration) (execute (Runnable.)
            (ยง anon
                #_override
                #_public
                (ยง method #_"void" run []
                    (.. (:listener __registration) (onPeerDisconnected (ยง dhis Peer), 0))
                    nil
                )
            )))
        )
        nil
    )

    #_override
    #_public
    (ยง method #_"void" connectionOpened []
        ;; Announce ourselves.  This has to come first to connect to clients beyond v0.3.20.2 which wait to hear
        ;; from us until they send their version message back.
        (let [#_"PeerAddress" __address (.. this (getAddress))]
            (.. Peer/log (info "Announcing to {} as: {}", (if (some? __address) (.. __address (toSocketAddress)) "Peer"), (-> this :version-message :sub-ver)))
            (.. this (sendMessage (:version-message this)))
            (.. (:connection-open-future this) (set this))
            ;; When connecting, the remote peer sends us a version message with various bits of
            ;; useful data in it.  We need to know the peer protocol version before we can talk to it.
            nil
        )
    )

    ;;;
     ; Provides a ListenableFuture that can be used to wait for the socket to connect.  A socket connection does not
     ; mean that protocol handshake has occurred.
     ;;
    #_public
    (ยง method #_"ListenableFuture<Peer>" getConnectionOpenFuture []
        (:connection-open-future this)
    )

    #_public
    (ยง method #_"ListenableFuture<Peer>" getVersionHandshakeFuture []
        (:version-handshake-future this)
    )

    #_override
    #_protected
    #_throws #_[ "Exception" ]
    (ยง method #_"void" processMessage [#_"Message" __m]
        ;; Allow event listeners to filter the message stream.  Listeners are allowed to drop messages by returning null.
        (doseq [#_"ListenerRegistration<PreMessageReceivedEventListener>" __registration (:pre-message-received-event-listeners this)]
            ;; Skip any listeners that are supposed to run in another thread as we don't want to block waiting for it,
            ;; which might cause circular deadlock.
            (when (== (:executor __registration) Threading/SAME_THREAD)
                (ยง ass __m (.. (:listener __registration) (onPreMessageReceived this, __m)))
                (when (nil? __m)
                    (ยง break )
                )
            )
        )
        (when (nil? __m)
            (ยง return nil)
        )

        ;; If we are in the middle of receiving transactions as part of a filtered block push from the remote node,
        ;; and we receive something that's not a transaction, then we're done.
        (when (and (some? (:current-filtered-block this)) (not (instance? Transaction __m)))
            (.. this (endFilteredBlock (:current-filtered-block this)))
            (ยง assoc this :current-filtered-block nil)
        )

        ;; No further communication is possible until version handshake is complete.
        (when (not (or (instance? VersionMessage __m) (instance? VersionAck __m) (and (.. (:version-handshake-future this) (isDone)) (not (.. (:version-handshake-future this) (isCancelled))))))
            (throw (ProtocolException. (str "Received " (.. __m (getClass) (getSimpleName)) " before version handshake is complete.")))
        )

        (condp instance? __m
            Ping             (.. this (processPing (cast Ping __m)))
            Pong             (.. this (processPong (cast Pong __m)))
            ;; This is sent to us when we did a getdata on some transactions that aren't in the peers memory pool.
            ;; Because NotFoundMessage is a subclass of InventoryMessage, the test for it must come before the next.
            NotFoundMessage  (.. this (processNotFoundMessage (cast NotFoundMessage __m)))
            InventoryMessage (.. this (processInv (cast InventoryMessage __m)))
            Block            (.. this (processBlock (cast Block __m)))
            FilteredBlock    (.. this (startFilteredBlock (cast FilteredBlock __m)))
            Transaction      (.. this (processTransaction (cast Transaction __m)))
            GetDataMessage   (.. this (processGetData (cast GetDataMessage __m)))
            ;; We don't care about addresses of the network right now.  But in future, we should save them
            ;; in the wallet so we don't put too much load on the seed nodes and can properly explore the network.
            AddressMessage   (.. this (processAddressMessage (cast AddressMessage __m)))
            HeadersMessage   (.. this (processHeaders (cast HeadersMessage __m)))
            AlertMessage     (.. this (processAlert (cast AlertMessage __m)))
            VersionMessage   (.. this (processVersionMessage (cast VersionMessage __m)))
            VersionAck       (.. this (processVersionAck (cast VersionAck __m)))
            RejectMessage    (.. Peer/log (error "{} {}: Received {}", this, (:sub-ver (.. this (getPeerVersionMessage))), __m))
                             (.. Peer/log (warn "{}: Received unhandled message: {}", this, __m))
        )
        nil
    )

    #_private
    (ยง method- #_"void" processAddressMessage [#_"AddressMessage" __m]
        (let [#_"SettableFuture<AddressMessage>" __future]
            (ยง sync (:get-addr-futures this)
                (ยง ass __future (.. (:get-addr-futures this) (poll)))
                (when (nil? __future) ;; Not an addr message we are waiting for.
                    (ยง return nil)
                )
            )
            (.. __future (set __m))
            nil
        )
    )

    #_private
    #_throws #_[ "ProtocolException" ]
    (ยง method- #_"void" processVersionMessage [#_"VersionMessage" __m]
        (when (some? (:v-peer-version-message this))
            (throw (ProtocolException. "Got two version messages from peer"))
        )

        (ยง assoc this :v-peer-version-message __m)
        ;; Switch to the new protocol version.
        (let [#_"long" __peerTime (* (-> this :v-peer-version-message :time) 1000)]
            (.. Peer/log (info "{}: Got version={}, subVer='{}', services=0x{}, time={}, blocks={}", this, (-> this :v-peer-version-message :client-version), (-> this :v-peer-version-message :sub-ver), (-> this :v-peer-version-message :local-services), (String/format Locale/US, "%tF %tT", __peerTime, __peerTime), (-> this :v-peer-version-message :best-height)))
            ;; bitcoinj is a client mode implementation.  That means there's not much point in us talking to other client
            ;; mode nodes because we can't download the data from them we need to find/verify transactions.  Some bogus
            ;; implementations claim to have a block chain in their services field but then report a height of zero, filter
            ;; them out here.
            (when (or (not (.. (:v-peer-version-message this) (hasBlockChain))) (and (not (.. (:params this) (allowEmptyPeerChain))) (== (-> this :v-peer-version-message :best-height) 0)))
                ;; Shut down the channel gracefully.
                (.. Peer/log (info "{}: Peer does not have a copy of the block chain.", this))
                (.. this (close))
                (ยง return nil)
            )

            (when (< (-> this :v-peer-version-message :best-height) 0)
                ;; In this case, it's a protocol violation.
                (throw (ProtocolException. (str "Peer reports invalid best height: " (-> this :v-peer-version-message :best-height))))
            )
            ;; Now it's our turn ...
            ;; Send an ACK message stating we accept the peers protocol version.
            (.. this (sendMessage (VersionAck.)))
            (.. Peer/log (debug "{}: Incoming version handshake complete.", this))
            (.. (:incoming-version-handshake-future this) (set this))
            nil
        )
    )

    #_private
    #_throws #_[ "ProtocolException" ]
    (ยง method- #_"void" processVersionAck [#_"VersionAck" __m]
        (when (nil? (:v-peer-version-message this))
            (throw (ProtocolException. "got a version ack before version"))
        )

        (when (.. (:outgoing-version-handshake-future this) (isDone))
            (throw (ProtocolException. "got more than one version ack"))
        )

        (.. Peer/log (debug "{}: Outgoing version handshake complete.", this))
        (.. (:outgoing-version-handshake-future this) (set this))
        nil
    )

    #_private
    (ยง method- #_"void" versionHandshakeComplete []
        (.. Peer/log (debug "{}: Handshake complete.", this))
        (.. this (setTimeoutEnabled false))
        (doseq [#_"ListenerRegistration<PeerConnectedEventListener>" __registration (:connected-event-listeners this)]
            (.. (:executor __registration) (execute (Runnable.)
            (ยง anon
                #_override
                #_public
                (ยง method #_"void" run []
                    (.. (:listener __registration) (onPeerConnected (ยง dhis Peer), 1))
                    nil
                )
            )))
        )
        ;; We check min version after onPeerConnected as channel.close() will
        ;; call onPeerDisconnected, and we should probably call onPeerConnected first.
        (let [#_"int" __version (:v-min-protocol-version this)]
            (when (< (-> this :v-peer-version-message :client-version) __version)
                (.. Peer/log (warn "Connected to a peer speaking protocol version {} but need {}, closing", (-> this :v-peer-version-message :client-version), __version))
                (.. this (close))
            )
            nil
        )
    )

    #_protected
    (ยง method #_"void" startFilteredBlock [#_"FilteredBlock" __m]
        ;; Filtered blocks come before the data that they refer to, so stash it here and then fill it out as
        ;; messages stream in.  We'll call endFilteredBlock when a non-tx message arrives (e.g. another
        ;; FilteredBlock) or when a tx that isn't needed by that block is found.  A ping message is sent after
        ;; a getblocks, to force the non-tx message path.
        (ยง assoc this :current-filtered-block __m)
        ;; Potentially refresh the server side filter.  Because the remote node adds hits back into the filter
        ;; to save round-tripping back through us, the filter degrades over time as false positives get added,
        ;; triggering yet more false positives.  We refresh it every so often to get the FP rate back down.
        (ยง assoc this :filtered-blocks-received (inc (:filtered-blocks-received this)))
        (when (== (% (:filtered-blocks-received this) Peer/RESEND_BLOOM_FILTER_BLOCK_COUNT) (dec Peer/RESEND_BLOOM_FILTER_BLOCK_COUNT))
            (.. this (sendMessage (:v-bloom-filter this)))
        )
        nil
    )

    #_protected
    (ยง method #_"void" processNotFoundMessage [#_"NotFoundMessage" __m]
        ;; This is received when we previously did a getdata but the peer couldn't find what we requested in it's
        ;; memory pool.  Typically, because we are downloading dependencies of a relevant transaction and reached
        ;; the bottom of the dependency tree (where the unconfirmed transactions connect to transactions that are
        ;; in the chain).
        ;;
        ;; We go through and cancel the pending getdata futures for the items we were told weren't found.
        (doseq [#_"Peer.GetDataRequest" __req (:get-data-futures this)]
            (doseq [#_"InventoryItem" __item (.. __m (getItems))]
                (when (.. (:hash __item) (equals (:hash __req)))
                    (.. Peer/log (info "{}: Bottomed out dep tree at {}", this, (:hash __req)))
                    (.. (:future __req) (cancel true))
                    (.. (:get-data-futures this) (remove __req))
                    (ยง break )
                )
            )
        )
        nil
    )

    #_protected
    (ยง method #_"void" processAlert [#_"AlertMessage" __m]
        (try
            (if (.. __m (isSignatureValid))
                (.. Peer/log (info "Received alert from peer {}: {}", this, (.. __m (getStatusBar))))
                (.. Peer/log (warn "Received alert with invalid signature from peer {}: {}", this, (.. __m (getStatusBar))))
            )
            (catch Throwable __t
                ;; Signature checking can FAIL on Android platforms before Gingerbread apparently due to bugs in their
                ;; BigInteger implementations!  See https://github.com/bitcoinj/bitcoinj/issues/526 for discussion.
                ;; As alerts are just optional and not that useful, we just swallow the error here.
                (.. Peer/log (error "Failed to check signature: bug in platform libraries?", __t))
            )
        )
        nil
    )

    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" processHeaders [#_"HeadersMessage" __m]
        ;; Runs in network loop thread for this peer.
        ;;
        ;; This method can run if a peer just randomly sends us a "headers" message (should never happen), or more
        ;; likely when we've requested them as part of chain download using fast catchup.  We need to add each block to
        ;; the chain if it pre-dates the fast catchup time.  If we go past it, we can stop processing the headers and
        ;; request the full blocks from that point on instead.
        (let [#_"boolean" __downloadBlockBodies
              #_"long" __fastCatchupTimeSecs]

            (.. (:lock this) (lock))
            (try
                (when (nil? (:block-chain this))
                    ;; Can happen if we are receiving unrequested data, or due to programmer error.
                    (.. Peer/log (warn "Received headers when Peer is not configured with a chain."))
                    (ยง return nil)
                )
                (ยง ass __fastCatchupTimeSecs (:fast-catchup-time-secs this))
                (ยง ass __downloadBlockBodies (:download-block-bodies this))
                (finally
                    (.. (:lock this) (unlock))
                )
            )

            (try
                (Preconditions/checkState (not __downloadBlockBodies), (.. this (toString)))

                (loop-when-recur [#_"int" __i 0] (< __i (.. __m (getBlockHeaders) (size))) [(inc __i)]
                    (let [#_"Block" __header (.. __m (getBlockHeaders) (get __i))]
                        ;; Process headers until we pass the fast catchup time, or are about to catch up with the head
                        ;; of the chain - always process the last block as a full/filtered block to kick us out of the
                        ;; fast catchup mode (in which we ignore new blocks).
                        (let [#_"boolean" __passedTime (<= __fastCatchupTimeSecs (.. __header (getTimeSeconds)))
                              #_"boolean" __reachedTop (<= (-> this :v-peer-version-message :best-height) (.. (:block-chain this) (getBestChainHeight)))]
                            (cond (and (not __passedTime) (not __reachedTop))
                                (do
                                    (when (not (:v-download-data this))
                                        ;; Not download peer anymore, some other peer probably became better.
                                        (.. Peer/log (info "Lost download peer status, throwing away downloaded headers."))
                                        (ยง return nil)
                                    )
                                    (cond (.. (:block-chain this) (add __header))
                                        (do
                                            ;; The block was successfully linked into the chain. Notify the user of our progress.
                                            (.. this (invokeOnBlocksDownloaded __header, nil))
                                        )
                                        :else
                                        (do
                                            ;; This block is unconnected - we don't know how to get from it back to the genesis block yet.
                                            ;; That must mean that the peer is buggy or malicious because we specifically requested for
                                            ;; headers that are part of the best chain.
                                            (throw (ProtocolException. (str "Got unconnected header from peer: " (.. __header (getHashAsString)))))
                                        )
                                    )
                                )
                                :else
                                (do
                                    (.. (:lock this) (lock))
                                    (try
                                        (.. Peer/log (info "Passed the fast catchup time ({}) at height {}, discarding {} headers and requesting full blocks", (Utils/dateTimeFormat (* __fastCatchupTimeSecs 1000)), (inc (.. (:block-chain this) (getBestChainHeight))), (- (.. __m (getBlockHeaders) (size)) __i)))
                                        (ยง assoc this :download-block-bodies true)
                                        ;; Prevent this request being seen as a duplicate.
                                        (ยง assoc this :last-get-blocks-begin Sha256Hash/ZERO_HASH)
                                        (.. this (blockChainDownloadLocked Sha256Hash/ZERO_HASH))
                                        (finally
                                            (.. (:lock this) (unlock))
                                        )
                                    )
                                    (ยง return nil)
                                )
                            )
                        )
                    )
                )
                ;; We added all headers in the message to the chain.
                ;; Request some more if we got up to the limit, otherwise we are at the end of the chain.
                (when (<= HeadersMessage/MAX_HEADERS (.. __m (getBlockHeaders) (size)))
                    (.. (:lock this) (lock))
                    (try
                        (.. this (blockChainDownloadLocked Sha256Hash/ZERO_HASH))
                        (finally
                            (.. (:lock this) (unlock))
                        )
                    )
                )
                (catch VerificationException __e
                    (.. Peer/log (warn "Block header verification failed", __e))
                )
                (catch PrunedException __e
                    ;; Unreachable when in SPV mode.
                    (throw (RuntimeException. __e))
                )
            )
            nil
        )
    )

    #_protected
    (ยง method #_"void" processGetData [#_"GetDataMessage" __getdata]
        (.. Peer/log (info "{}: Received getdata message: {}", (.. this (getAddress)), (.. __getdata (toString))))
        (let [#_"ArrayList<Message>" __items (ArrayList. #_"<>")]
            (doseq [#_"ListenerRegistration<GetDataEventListener>" __registration (:get-data-event-listeners this)]
                (when (!= (:executor __registration) Threading/SAME_THREAD)
                    (ยง continue )
                )
                (let [#_"List<Message>" __listenerItems (.. (:listener __registration) (getData this, __getdata))]
                    (when (nil? __listenerItems)
                        (ยง continue )
                    )
                    (.. __items (addAll __listenerItems))
                )
            )
            (when (not (.. __items (isEmpty)))
                (.. Peer/log (info "{}: Sending {} items gathered from listeners to peer", (.. this (getAddress)), (.. __items (size))))
                (doseq [#_"Message" __item __items]
                    (.. this (sendMessage __item))
                )
            )
            nil
        )
    )

    #_protected
    #_throws #_[ "VerificationException" ]
    (ยง method #_"void" processTransaction [#_"Transaction" __tx]
        ;; Check a few basic syntax issues to ensure the received TX isn't nonsense.
        (.. __tx (verify))
        (.. (:lock this) (lock))
        (try
            (.. Peer/log (debug "{}: Received tx {}", (.. this (getAddress)), (.. __tx (getHashAsString))))
            ;; Label the transaction as coming in from the P2P network (as opposed to being created by us, direct import,
            ;; etc).  This helps the wallet decide how to risk analyze it later.
            ;;
            ;; Additionally, by invoking tx.getConfidence(), this tx now pins the confidence data into the heap, meaning
            ;; we can stop holding a reference to the confidence object ourselves.  It's up to event listeners on the
            ;; Peer to stash the tx object somewhere if they want to keep receiving updates about network propagation
            ;; and so on.
            (let [#_"TransactionConfidence" __confidence (.. __tx (getConfidence))]
                (.. __confidence (setSource TransactionConfidence.Source/NETWORK))
                (.. (:pending-tx-downloads this) (remove __confidence))
                (when (.. this (maybeHandleRequestedData __tx))
                    (ยง return nil)
                )

                (when (some? (:current-filtered-block this))
                    (when (not (.. (:current-filtered-block this) (provideTransaction __tx)))
                        ;; Got a tx that didn't fit into the filtered block, so we must have received everything.
                        (.. this (endFilteredBlock (:current-filtered-block this)))
                        (ยง assoc this :current-filtered-block nil)
                    )
                    ;; Don't tell wallets or listeners about this tx as they'll learn about it when the filtered block is
                    ;; fully downloaded instead.
                    (ยง return nil)
                )

                ;; It's a broadcast transaction.  Tell all wallets about this tx so they can check if it's relevant or not.
                (doseq [#_"Wallet" __wallet (:wallets this)]
                    (try
                        (when (.. __wallet (isPendingTransactionRelevant __tx))
                            (cond (< 0 (:v-download-tx-dependency-depth this))
                                (do
                                    ;; This transaction seems interesting to us, so let's download its dependencies.  This has
                                    ;; several purposes: we can check that the sender isn't attacking us by engaging in protocol
                                    ;; abuse games, like depending on a time-locked transaction that will never confirm, or
                                    ;; building huge chains of unconfirmed transactions (again - so they don't confirm and the
                                    ;; money can be taken back with a Finney attack).  Knowing the dependencies also lets us
                                    ;; store them in a serialized wallet so we always have enough data to re-announce to the
                                    ;; network and get the payment into the chain, in case the sender goes away and the network
                                    ;; starts to forget.
                                    ;;
                                    ;; TODO: Not all the above things are implemented.
                                    ;;
                                    ;; Note that downloading of dependencies can end up walking around 15 minutes back even
                                    ;; through transactions that have confirmed, as getdata on the remote peer also checks
                                    ;; relay memory not only the mempool.  Unfortunately we have no way to know that here.
                                    ;; In practice it should not matter much.
                                    (Futures/addCallback (.. this (downloadDependencies __tx)), (FutureCallback. #_"<List<Transaction>>")
                                    (ยง anon
                                        #_override
                                        #_public
                                        (ยง method #_"void" onSuccess [#_"List<Transaction>" __dependencies]
                                            (try
                                                (.. Peer/log (info "{}: Dependency download complete!", (.. this (getAddress))))
                                                (.. __wallet (receivePending __tx, __dependencies))
                                                (catch VerificationException __e
                                                    (.. Peer/log (error "{}: Wallet failed to process pending transaction {}", (.. this (getAddress)), (.. __tx (getHash))))
                                                    (.. Peer/log (error "Error was: ", __e))
                                                    ;; Not much more we can do at this point.
                                                )
                                            )
                                            nil
                                        )

                                        #_override
                                        #_public
                                        (ยง method #_"void" onFailure [#_"Throwable" __throwable]
                                            (.. Peer/log (error "Could not download dependencies of tx {}", (.. __tx (getHashAsString))))
                                            (.. Peer/log (error "Error was: ", __throwable))
                                            ;; Not much more we can do at this point.
                                            nil
                                        )
                                    ))
                                )
                                :else
                                (do
                                    (.. __wallet (receivePending __tx, nil))
                                )
                            )
                        )
                        (catch VerificationException __e
                            (.. Peer/log (error "Wallet failed to verify tx", __e))
                            ;; Carry on, listeners may still want to know.
                        )
                    )
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        ;; Tell all listeners about this tx so they can decide whether to keep it or not.  If no listener keeps a
        ;; reference around then the memory pool will forget about it after a while too because it uses weak references.
        (doseq [#_"ListenerRegistration<OnTransactionBroadcastListener>" __registration (:on-transaction-event-listeners this)]
            (.. (:executor __registration) (execute (Runnable.)
            (ยง anon
                #_override
                #_public
                (ยง method #_"void" run []
                    (.. (:listener __registration) (onTransaction (ยง dhis Peer), __tx))
                    nil
                )
            )))
        )
        nil
    )

    ;;;
     ; <p>Returns a future that wraps a list of all transactions that the given transaction depends on, recursively.
     ; Only transactions in peers memory pools are included; the recursion stops at transactions that are in the
     ; current best chain.  So it doesn't make much sense to provide a tx that was already in the best chain and
     ; a precondition checks this.</p>
     ;
     ; <p>For example, if tx has 2 inputs that connect to transactions A and B, and transaction B is unconfirmed and
     ; has one input connecting to transaction C that is unconfirmed, and transaction C connects to transaction D
     ; that is in the chain, then this method will return either {B, C} or {C, B}.  No ordering is guaranteed.</p>
     ;
     ; <p>This method is useful for apps that want to learn about how long an unconfirmed transaction might take
     ; to confirm, by checking for unexpectedly time locked transactions, unusually deep dependency trees or fee-paying
     ; transactions that depend on unconfirmed free transactions.</p>
     ;
     ; <p>Note that dependencies downloaded this way will not trigger the onTransaction method of event listeners.</p>
     ;;
    #_public
    (ยง method #_"ListenableFuture<List<Transaction>>" downloadDependencies [#_"Transaction" __tx]
        (let [#_"TransactionConfidence.ConfidenceType" __txConfidence (.. __tx (getConfidence) (getConfidenceType))]
            (Preconditions/checkArgument (!= __txConfidence TransactionConfidence.ConfidenceType/BUILDING))
            (.. Peer/log (info "{}: Downloading dependencies of {}", (.. this (getAddress)), (.. __tx (getHashAsString))))
            (let [#_"LinkedList<Transaction>" __results (LinkedList. #_"<>")]
                ;; future will be invoked when the entire dependency tree has been walked and the results compiled.
                (let [#_"ListenableFuture<Object>" __future (.. this (downloadDependenciesInternal (:v-download-tx-dependency-depth this), 0, __tx, (Object.), __results))
                      #_"SettableFuture<List<Transaction>>" __resultFuture (SettableFuture/create)]
                    (Futures/addCallback __future, (FutureCallback. #_"<Object>")
                    (ยง anon
                        #_override
                        #_public
                        (ยง method #_"void" onSuccess [#_"Object" __ignored]
                            (.. __resultFuture (set __results))
                            nil
                        )

                        #_override
                        #_public
                        (ยง method #_"void" onFailure [#_"Throwable" __throwable]
                            (.. __resultFuture (setException __throwable))
                            nil
                        )
                    ))
                    __resultFuture
                )
            )
        )
    )

    ;; The marker object in the future returned is the same as the parameter.  It is arbitrary and can be anything.
    #_protected
    (ยง method #_"ListenableFuture<Object>" downloadDependenciesInternal [#_"int" __maxDepth, #_"int" __depth, #_"Transaction" __tx, #_"Object" __marker, #_"List<Transaction>" __results]
        (let [#_"SettableFuture<Object>" __resultFuture (SettableFuture/create)
              #_"Sha256Hash" __rootTxHash (.. __tx (getHash))]
            ;; We want to recursively grab its dependencies.  This is so listeners can learn important information like
            ;; whether a transaction is dependent on a timelocked transaction or has an unexpectedly deep dependency tree
            ;; or depends on a no-fee transaction.

            ;; We may end up requesting transactions that we've already downloaded and thrown away here.
            (let [#_"Set<Sha256Hash>" __needToRequest (CopyOnWriteArraySet. #_"<>")]
                (doseq [#_"TransactionInput" __input (.. __tx (getInputs))]
                    ;; There may be multiple inputs that connect to the same transaction.
                    (.. __needToRequest (add (.. __input (getOutpoint) (getHash))))
                )

                (.. (:lock this) (lock))
                (try
                    ;; Build the request for the missing dependencies.
                    (let [#_"List<ListenableFuture<Transaction>>" __futures (Lists/newArrayList)
                          #_"GetDataMessage" __getdata (GetDataMessage. (:params this))]

                        (when (< 1 (.. __needToRequest (size)))
                            (.. Peer/log (info "{}: Requesting {} transactions for depth {} dep resolution", (.. this (getAddress)), (.. __needToRequest (size)), (inc __depth)))
                        )

                        (doseq [#_"Sha256Hash" __hash __needToRequest]
                            (.. __getdata (addTransaction __hash))
                            (let [#_"Peer.GetDataRequest" __req (Peer.GetDataRequest. __hash, (SettableFuture/create))]
                                (.. __futures (add (:future __req)))
                                (.. (:get-data-futures this) (add __req))
                            )
                        )

                        (let [#_"ListenableFuture<List<Transaction>>" __successful (Futures/successfulAsList __futures)]
                            (Futures/addCallback __successful, (FutureCallback. #_"<List<Transaction>>")
                            (ยง anon
                                #_override
                                #_public
                                (ยง method #_"void" onSuccess [#_"List<Transaction>" __transactions]
                                    ;; Once all transactions either were received, or we know there are no more to come, ...
                                    ;; Note that transactions will contain "null" for any positions that weren't successful.
                                    (let [#_"List<ListenableFuture<Object>>" __childFutures (Lists/newLinkedList)]
                                        (doseq [#_"Transaction" __tx __transactions]
                                            (when (nil? __tx)
                                                (ยง continue )
                                            )
                                            (.. Peer/log (info "{}: Downloaded dependency of {}: {}", (.. this (getAddress)), __rootTxHash, (.. __tx (getHashAsString))))
                                            (.. __results (add __tx))
                                            ;; Now recurse into the dependencies of this transaction too.
                                            (when (< (inc __depth) __maxDepth)
                                                (.. __childFutures (add (.. this (downloadDependenciesInternal __maxDepth, (inc __depth), __tx, __marker, __results))))
                                            )
                                        )
                                        (cond (== (.. __childFutures (size)) 0)
                                            (do
                                                ;; Short-circuit: we're at the bottom of this part of the tree.
                                                (.. __resultFuture (set __marker))
                                            )
                                            :else
                                            (do
                                                ;; There are some children to download.  Wait until it's done (and their children, and their
                                                ;; children, ...) to inform the caller that we're finished.
                                                (Futures/addCallback (Futures/successfulAsList __childFutures), (FutureCallback. #_"<List<Object>>")
                                                (ยง anon
                                                    #_override
                                                    #_public
                                                    (ยง method #_"void" onSuccess [#_"List<Object>" __objects]
                                                        (.. __resultFuture (set __marker))
                                                        nil
                                                    )

                                                    #_override
                                                    #_public
                                                    (ยง method #_"void" onFailure [#_"Throwable" __throwable]
                                                        (.. __resultFuture (setException __throwable))
                                                        nil
                                                    )
                                                ))
                                            )
                                        )
                                        nil
                                    )
                                )

                                #_override
                                #_public
                                (ยง method #_"void" onFailure [#_"Throwable" __throwable]
                                    (.. __resultFuture (setException __throwable))
                                    nil
                                )
                            ))

                            ;; Start the operation.
                            (.. this (sendMessage __getdata))
                        )
                    )
                    (catch Exception __e
                        (.. Peer/log (error "{}: Couldn't send getdata in downloadDependencies({})", this, (.. __tx (getHash)), __e))
                        (.. __resultFuture (setException __e))
                    )
                    (finally
                        (.. (:lock this) (unlock))
                    )
                )

                __resultFuture
            )
        )
    )

    #_protected
    (ยง method #_"void" processBlock [#_"Block" __m]
        (when (.. Peer/log (isDebugEnabled))
            (.. Peer/log (debug "{}: Received broadcast block {}", (.. this (getAddress)), (.. __m (getHashAsString))))
        )

        ;; Was this block requested by getBlock()?
        (when (.. this (maybeHandleRequestedData __m))
            (ยง return nil)
        )

        (when (nil? (:block-chain this))
            (.. Peer/log (debug "Received block but was not configured with an AbstractBlockChain"))
            (ยง return nil)
        )

        ;; Did we lose download peer status after requesting block data?
        (when (not (:v-download-data this))
            (.. Peer/log (debug "{}: Received block we did not ask for: {}", (.. this (getAddress)), (.. __m (getHashAsString))))
            (ยง return nil)
        )

        (.. (:pending-block-downloads this) (remove (.. __m (getHash))))

        (try
            ;; Otherwise it's a block sent to us because the peer thought we needed it, so add it to the block chain.
            (cond (.. (:block-chain this) (add __m))
                (do
                    ;; The block was successfully linked into the chain.  Notify the user of our progress.
                    (.. this (invokeOnBlocksDownloaded __m, nil))
                )
                :else
                (do
                    ;; This block is an orphan - we don't know how to get from it back to the genesis block yet.  That
                    ;; must mean that there are blocks we are missing, so do another getblocks with a new block locator
                    ;; to ask the peer to send them to us.  This can happen during the initial block chain download where
                    ;; the peer will only send us 500 at a time and then sends us the head block expecting us to request
                    ;; the others.
                    ;;
                    ;; We must do two things here:
                    ;; (1) Request from current top of chain to the oldest ancestor of the received block in the orphan set.
                    ;; (2) Filter out duplicate getblock requests (done in blockChainDownloadLocked).
                    ;;
                    ;; The reason for (1) is that otherwise if new blocks were solved during the middle of chain download
                    ;; we'd do a blockChainDownloadLocked() on the new best chain head, which would cause us to try and grab the
                    ;; chain twice (or more!) on the same connection!  The block chain would filter out the duplicates but
                    ;; only at a huge speed penalty.  By finding the orphan root we ensure every getblocks looks the same
                    ;; no matter how many blocks are solved, and therefore that the (2) duplicate filtering can work.
                    ;;
                    ;; We only do this if we are not currently downloading headers.  If we are then we don't want to kick
                    ;; off a request for lots more headers in parallel.
                    (.. (:lock this) (lock))
                    (try
                        (cond (:download-block-bodies this)
                            (do
                                (let [#_"Block" __orphanRoot (Preconditions/checkNotNull (.. (:block-chain this) (getOrphanRoot (.. __m (getHash)))))]
                                    (.. this (blockChainDownloadLocked (.. __orphanRoot (getHash))))
                                )
                            )
                            :else
                            (do
                                (.. Peer/log (info "Did not start chain download on solved block due to in-flight header download."))
                            )
                        )
                        (finally
                            (.. (:lock this) (unlock))
                        )
                    )
                )
            )
            (catch VerificationException __e
                ;; We don't want verification failures to kill the thread.
                (.. Peer/log (warn "{}: Block verification failed", (.. this (getAddress)), __e))
            )
            (catch PrunedException __e
                ;; Unreachable when in SPV mode.
                (throw (RuntimeException. __e))
            )
        )
        nil
    )

    ;; TODO: Fix this duplication.
    #_protected
    (ยง method #_"void" endFilteredBlock [#_"FilteredBlock" __m]
        (when (.. Peer/log (isDebugEnabled))
            (.. Peer/log (debug "{}: Received broadcast filtered block {}", (.. this (getAddress)), (.. __m (getHash) (toString))))
        )

        (when (not (:v-download-data this))
            (.. Peer/log (debug "{}: Received block we did not ask for: {}", (.. this (getAddress)), (.. __m (getHash) (toString))))
            (ยง return nil)
        )

        (when (nil? (:block-chain this))
            (.. Peer/log (debug "Received filtered block but was not configured with an AbstractBlockChain"))
            (ยง return nil)
        )

        ;; Note that we currently do nothing about peers which maliciously do not include transactions which
        ;; actually match our filter or which simply do not send us all the transactions we need: it can be fixed
        ;; by cross-checking peers against each other.
        (.. (:pending-block-downloads this) (remove (.. __m (getBlockHeader) (getHash))))

        (try
            ;; It's a block sent to us because the peer thought we needed it, so maybe add it to the block chain.
            ;; The FilteredBlock m here contains a list of hashes, and may contain Transaction objects for a subset
            ;; of the hashes (those that were sent to us by the remote peer).  Any hashes that haven't had a tx
            ;; provided in processTransaction are ones that were announced to us previously via an 'inv' so the
            ;; assumption is we have already downloaded them and either put them in the wallet, or threw them away
            ;; for being false positives.
            ;;
            ;; TODO: Fix the following protocol race.
            ;; It is possible for this code to go wrong such that we miss a confirmation.  If the remote peer announces
            ;; a relevant transaction via an 'inv' and then it immediately announces the block that confirms
            ;; the tx before we had a chance to download it+its dependencies and provide them to the wallet, then we
            ;; will add the block to the chain here without the tx being in the wallet and thus it will miss its
            ;; confirmation and become stuck forever.  The fix is to notice that there's a pending getdata for a tx
            ;; that appeared in this block and delay processing until it arrived ... it's complicated by the fact that
            ;; the data may be requested by a different peer to this one.

            ;; Ask each wallet attached to the peer/blockchain if this block exhausts the list of data items
            ;; (keys/addresses) that were used to calculate the previous filter.  If so, then it's possible this block
            ;; is only partial.  Check for discarding first so we don't check for exhaustion on blocks we already know
            ;; we're going to discard, otherwise redundant filters might end up being queued and calculated.
            (.. (:lock this) (lock))
            (try
                (when (some? (:awaiting-fresh-filter this))
                    (.. Peer/log (info "Discarding block {} because we're still waiting for a fresh filter", (.. __m (getHash))))
                    ;; We must record the hashes of blocks we discard because you cannot do getblocks twice on the same
                    ;; range of blocks and get an inv both times, due to the codepath in Bitcoin Core hitting
                    ;; CPeer::PushInventory() which checks CPeer::setInventoryKnown and thus deduplicates.
                    (.. (:awaiting-fresh-filter this) (add (.. __m (getHash))))
                    (ยง return nil) ;; Chain download process is restarted via a call to setBloomFilter.
                )

                (when (.. this (checkForFilterExhaustion __m))
                    ;; Yes, so we must abandon the attempt to process this block and any further blocks we receive,
                    ;; then wait for the Bloom filter to be recalculated, sent to this peer and for the peer to acknowledge
                    ;; that the new filter is now in use (which we have to simulate with a ping/pong), and then we can
                    ;; safely restart the chain download with the new filter that contains a new set of lookahead keys.
                    (.. Peer/log (info "Bloom filter exhausted whilst processing block {}, discarding", (.. __m (getHash))))
                    (ยง assoc this :awaiting-fresh-filter (LinkedList. #_"<>"))
                    (.. (:awaiting-fresh-filter this) (add (.. __m (getHash))))
                    (.. (:awaiting-fresh-filter this) (addAll (.. (:block-chain this) (drainOrphanBlocks))))
                    (ยง return nil) ;; Chain download process is restarted via a call to setBloomFilter.
                )
                (finally
                    (.. (:lock this) (unlock))
                )
            )

            (cond (.. (:block-chain this) (add __m))
                (do
                    ;; The block was successfully linked into the chain.  Notify the user of our progress.
                    (.. this (invokeOnBlocksDownloaded (.. __m (getBlockHeader)), __m))
                )
                :else
                (do
                    ;; This block is an orphan - we don't know how to get from it back to the genesis block yet.  That
                    ;; must mean that there are blocks we are missing, so do another getblocks with a new block locator
                    ;; to ask the peer to send them to us.  This can happen during the initial block chain download where
                    ;; the peer will only send us 500 at a time and then sends us the head block expecting us to request
                    ;; the others.
                    ;;
                    ;; We must do two things here:
                    ;; (1) Request from current top of chain to the oldest ancestor of the received block in the orphan set.
                    ;; (2) Filter out duplicate getblock requests (done in blockChainDownloadLocked).
                    ;;
                    ;; The reason for (1) is that otherwise if new blocks were solved during the middle of chain download
                    ;; we'd do a blockChainDownloadLocked() on the new best chain head, which would cause us to try and grab the
                    ;; chain twice (or more!) on the same connection!  The block chain would filter out the duplicates but
                    ;; only at a huge speed penalty.  By finding the orphan root we ensure every getblocks looks the same
                    ;; no matter how many blocks are solved, and therefore that the (2) duplicate filtering can work.
                    (.. (:lock this) (lock))
                    (try
                        (let [#_"Block" __orphanRoot (Preconditions/checkNotNull (.. (:block-chain this) (getOrphanRoot (.. __m (getHash)))))]
                            (.. this (blockChainDownloadLocked (.. __orphanRoot (getHash))))
                        )
                        (finally
                            (.. (:lock this) (unlock))
                        )
                    )
                )
            )
            (catch VerificationException __e
                ;; We don't want verification failures to kill the thread.
                (.. Peer/log (warn "{}: FilteredBlock verification failed", (.. this (getAddress)), __e))
            )
            (catch PrunedException __e
                ;; We pruned away some of the data we need to properly handle this block.  We need to request the needed
                ;; data from the remote peer and fix things.  Or just give up.
                ;; TODO: Request e.getHash() and submit it to the block store before any other blocks.
                (throw (RuntimeException. __e))
            )
        )
        nil
    )

    #_private
    (ยง method- #_"boolean" checkForFilterExhaustion [#_"FilteredBlock" __m]
        (let [#_"boolean" __exhausted false]
            (doseq [#_"Wallet" __wallet (:wallets this)]
                (ยง ass __exhausted (| __exhausted (.. __wallet (checkForFilterExhaustion __m))))
            )
            __exhausted
        )
    )

    #_private
    (ยง method- #_"boolean" maybeHandleRequestedData [#_"Message" __m]
        (let [#_"boolean" __found false
              #_"Sha256Hash" __hash (.. __m (getHash))]
            (doseq [#_"Peer.GetDataRequest" __req (:get-data-futures this)]
                (when (.. __hash (equals (:hash __req)))
                    (.. (:future __req) (set __m))
                    (.. (:get-data-futures this) (remove __req))
                    (ยง ass __found true)
                    ;; Keep going in case there are more.
                )
            )
            __found
        )
    )

    #_private
    (ยง method- #_"void" invokeOnBlocksDownloaded [#_"Block" __block, #_nilable #_"FilteredBlock" __fb]
        ;; It is possible for the peer block height difference to be negative when blocks have been solved and broadcast
        ;; since the time we first connected to the peer.  However, it's weird and unexpected to receive a callback
        ;; with negative "blocks left" in this case, so we clamp to zero so the API user doesn't have to think about it.
        (let [#_"int" __blocksLeft (Math/max 0, (- (int (-> this :v-peer-version-message :best-height)) (.. (Preconditions/checkNotNull (:block-chain this)) (getBestChainHeight))))]
            (doseq [#_"ListenerRegistration<BlocksDownloadedEventListener>" __registration (:blocks-downloaded-event-listeners this)]
                (.. (:executor __registration) (execute (Runnable.)
                (ยง anon
                    #_override
                    #_public
                    (ยง method #_"void" run []
                        (.. (:listener __registration) (onBlocksDownloaded (ยง dhis Peer), __block, __fb, __blocksLeft))
                        nil
                    )
                )))
            )
            nil
        )
    )

    #_protected
    (ยง method #_"void" processInv [#_"InventoryMessage" __inv]
        (let [#_"List<InventoryItem>" __items (.. __inv (getItems))]

            ;; Separate out the blocks and transactions, we'll handle them differently.
            (let [#_"List<InventoryItem>" __transactions (LinkedList. #_"<>")
                  #_"List<InventoryItem>" __blocks (LinkedList. #_"<>")]

                (doseq [#_"InventoryItem" __item __items]
                    (condp == (:type __item)
                        Transaction (.. __transactions (add __item))
                        Block       (.. __blocks (add __item))
                        (throw (IllegalStateException. (str "Not implemented: " (:type __item))))
                    )
                )

                (let [#_"boolean" __downloadData (:v-download-data this)]

                    (when (and (== (.. __transactions (size)) 0) (== (.. __blocks (size)) 1))
                        ;; Single block announcement.  If we're downloading the chain this is just a tickle to make us continue
                        ;; (the block chain download protocol is very implicit and not well thought out).  If we're not downloading
                        ;; the chain then this probably means a new block was solved and the peer believes it connects to the best
                        ;; chain, so count it.  This way getBestChainHeight() can be accurate.
                        (cond (and __downloadData (some? (:block-chain this)))
                            (do
                                (when (not (.. (:block-chain this) (isOrphan (:hash (.. __blocks (get 0))))))
                                    (.. (:blocks-announced this) (incrementAndGet))
                                )
                            )
                            :else
                            (do
                                (.. (:blocks-announced this) (incrementAndGet))
                            )
                        )
                    )

                    (let [#_"GetDataMessage" __getdata (GetDataMessage. (:params this))]

                        (let [#_"Iterator<InventoryItem>" __it (.. __transactions (iterator))]
                            (while (.. __it (hasNext))
                                (let [#_"InventoryItem" __item (.. __it (next))]
                                    ;; Only download the transaction if we are the first peer that saw it be advertised.  Other peers will also
                                    ;; see it be advertised in inv packets asynchronously, they co-ordinate via the memory pool.  We could
                                    ;; potentially download transactions faster by always asking every peer for a tx when advertised, as remote
                                    ;; peers run at different speeds.  However to conserve bandwidth on mobile devices we try to only download a
                                    ;; transaction once.  This means we can miss broadcasts if the peer disconnects between sending us an inv and
                                    ;; sending us the transaction: currently we'll never try to re-fetch after a timeout.
                                    ;;
                                    ;; The line below can trigger confidence listeners.
                                    (let [#_"TransactionConfidence" __conf (.. (:context this) (getConfidenceTable) (seen (:hash __item), (.. this (getAddress))))]
                                        (cond (< 1 (.. __conf (numBroadcastPeers)))
                                            (do
                                                ;; Some other peer already announced this so don't download.
                                                (.. __it (remove))
                                            )
                                            (.. __conf (getSource) (equals TransactionConfidence.Source/SELF))
                                            (do
                                                ;; We created this transaction ourselves, so don't download.
                                                (.. __it (remove))
                                            )
                                            :else
                                            (do
                                                (.. Peer/log (debug "{}: getdata on tx {}", (.. this (getAddress)), (:hash __item)))
                                                (.. __getdata (addItem __item))
                                                ;; Register with the garbage collector that we care about the confidence data for a while.
                                                (.. (:pending-tx-downloads this) (add __conf))
                                            )
                                        )
                                    )
                                )
                            )

                            ;; If we are requesting filteredblocks, we have to send a ping after the getdata so that we have a clear
                            ;; end to the final FilteredBlock's transactions (in the form of a pong) sent to us.
                            (let [#_"boolean" __pingAfterGetData false]

                                (.. (:lock this) (lock))
                                (try
                                    (when (and (< 0 (.. __blocks (size))) __downloadData (some? (:block-chain this)))
                                        ;; Ideally, we'd only ask for the data here if we actually needed it.  However that can imply a lot of
                                        ;; disk IO to figure out what we've got.  Normally peers will not send us inv for things we already have
                                        ;; so we just re-request it here, and if we get duplicates the block chain / wallet will filter them out.
                                        (doseq [#_"InventoryItem" __item __blocks]
                                            (cond (and (.. (:block-chain this) (isOrphan (:hash __item))) (:download-block-bodies this))
                                                (do
                                                    ;; If an orphan was re-advertised, ask for more blocks unless we are not currently downloading
                                                    ;; full block data because we have a getheaders outstanding.
                                                    (let [#_"Block" __orphanRoot (Preconditions/checkNotNull (.. (:block-chain this) (getOrphanRoot (:hash __item))))]
                                                        (.. this (blockChainDownloadLocked (.. __orphanRoot (getHash))))
                                                    )
                                                )
                                                :else
                                                (do
                                                    ;; Don't re-request blocks we already requested.  Normally this should not happen.  However there is
                                                    ;; an edge case: if a block is solved and we complete the inv<->getdata<->block<->getblocks cycle
                                                    ;; whilst other parts of the chain are streaming in, then the new getblocks request won't match the
                                                    ;; previous one: whilst the stopHash is the same (because we use the orphan root), the start hash
                                                    ;; will be different and so the getblocks req won't be dropped as a duplicate.  We'll end up
                                                    ;; requesting a subset of what we already requested, which can lead to parallel chain downloads
                                                    ;; and other nastyness.  So we just do a quick removal of redundant getdatas here too.
                                                    ;;
                                                    ;; Note that as of June 2012 Bitcoin Core won't actually ever interleave blocks pushed as
                                                    ;; part of chain download with newly announced blocks, so it should always be taken care of by
                                                    ;; the duplicate check in blockChainDownloadLocked().  But Bitcoin Core may change in future so
                                                    ;; it's better to be safe here.
                                                    (when (not (.. (:pending-block-downloads this) (contains (:hash __item))))
                                                        (cond (and (.. (:v-peer-version-message this) (isBloomFilteringSupported)) (:use-filtered-blocks this))
                                                            (do
                                                                (.. __getdata (addFilteredBlock (:hash __item)))
                                                                (ยง ass __pingAfterGetData true)
                                                            )
                                                            :else
                                                            (do
                                                                (.. __getdata (addItem __item))
                                                            )
                                                        )
                                                        (.. (:pending-block-downloads this) (add (:hash __item)))
                                                    )
                                                )
                                            )
                                        )
                                        ;; If we're downloading the chain, doing a getdata on the last block we were told about will cause the
                                        ;; peer to advertize the head block to us in a single-item inv.  When we download THAT, it will be an
                                        ;; orphan block, meaning we'll re-enter blockChainDownloadLocked() to trigger another getblocks between the
                                        ;; current best block we have and the orphan block.  If more blocks arrive in the meantime they'll also
                                        ;; become orphan.
                                    )
                                    (finally
                                        (.. (:lock this) (unlock))
                                    )
                                )

                                (when (not (.. __getdata (getItems) (isEmpty)))
                                    ;; This will cause us to receive a bunch of block or tx messages.
                                    (.. this (sendMessage __getdata))
                                )

                                (when __pingAfterGetData
                                    (.. this (sendMessage (Ping. (long (* (Math/random) Long/MAX_VALUE)))))
                                )
                                nil
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Asks the connected peer for the block of the given hash, and returns a future representing the answer.
     ; If you want the block right away and don't mind waiting for it, just call .get() on the result.  Your thread
     ; will block until the peer answers.
     ;;
    #_suppress #_[ "unchecked" ]
    ;; The 'unchecked conversion' warning being suppressed here comes from the sendSingleGetData() formally returning
    ;; ListenableFuture instead of ListenableFuture<Block>.  This is okay as sendSingleGetData() actually returns
    ;; ListenableFuture<Block> in this context.  Note that sendSingleGetData() is also used for Transactions.
    #_public
    (ยง method #_"ListenableFuture<Block>" getBlock [#_"Sha256Hash" __blockHash]
        ;; This does not need to be locked.
        (.. Peer/log (info "Request to fetch block {}", __blockHash))
        (let [#_"GetDataMessage" __getdata (GetDataMessage. (:params this))]
            (.. __getdata (addBlock __blockHash))
            (.. this (sendSingleGetData __getdata))
        )
    )

    ;;;
     ; Asks the connected peer for the given transaction from its memory pool.  Transactions in the chain cannot be
     ; retrieved this way because peers don't have a transaction ID to transaction-pos-on-disk index, and besides,
     ; in future many peers will delete old transaction data they don't need.
     ;;
    #_suppress #_[ "unchecked" ]
    ;; The 'unchecked conversion' warning being suppressed here comes from the sendSingleGetData() formally returning
    ;; ListenableFuture instead of ListenableFuture<Transaction>.  This is okay as sendSingleGetData() actually returns
    ;; ListenableFuture<Transaction> in this context.  Note that sendSingleGetData() is also used for Blocks.
    #_public
    (ยง method #_"ListenableFuture<Transaction>" getPeerMempoolTransaction [#_"Sha256Hash" __hash]
        ;; This does not need to be locked.
        (.. Peer/log (info "Request to fetch peer mempool tx  {}", __hash))
        (let [#_"GetDataMessage" __getdata (GetDataMessage. (:params this))]
            (.. __getdata (addTransaction __hash))
            (.. this (sendSingleGetData __getdata))
        )
    )

    ;;; Sends a getdata with a single item in it. ;;
    #_private
    (ยง method- #_"ListenableFuture" sendSingleGetData [#_"GetDataMessage" __getdata]
        ;; This does not need to be locked.
        (Preconditions/checkArgument (== (.. __getdata (getItems) (size)) 1))
        (let [#_"Peer.GetDataRequest" __req (Peer.GetDataRequest. (.. __getdata (getItems) (get 0) :hash), (SettableFuture/create))]
            (.. (:get-data-futures this) (add __req))
            (.. this (sendMessage __getdata))
            (:future __req)
        )
    )

    ;;; Sends a getaddr request to the peer and returns a future that completes with the answer once the peer has replied. ;;
    #_public
    (ยง method #_"ListenableFuture<AddressMessage>" getAddr []
        (let [#_"SettableFuture<AddressMessage>" __future (SettableFuture/create)]
            (ยง sync (:get-addr-futures this)
                (.. (:get-addr-futures this) (add __future))
            )
            (.. this (sendMessage (GetAddrMessage. (:params this))))
            __future
        )
    )

    ;;;
     ; When downloading the block chain, the bodies will be skipped for blocks created before the given date.
     ; Any transactions relevant to the wallet will therefore not be found, but if you know your wallet has no such
     ; transactions it doesn't matter and can save a lot of bandwidth and processing time.  Note that the times of blocks
     ; isn't known until their headers are available and they are requested in chunks, so some headers may be downloaded
     ; twice using this scheme, but this optimization can still be a large win for newly created wallets.
     ;
     ; @param secondsSinceEpoch Time in seconds since the epoch or 0 to reset to always downloading block bodies.
     ;;
    #_public
    (ยง method #_"void" setDownloadParameters [#_"long" __secondsSinceEpoch, #_"boolean" __useFilteredBlocks]
        (.. (:lock this) (lock))
        (try
            (cond (== __secondsSinceEpoch 0)
                (do
                    (ยง assoc this :fast-catchup-time-secs (.. (:params this) (getGenesisBlock) (getTimeSeconds)))
                    (ยง assoc this :download-block-bodies true)
                )
                :else
                (do
                    (ยง assoc this :fast-catchup-time-secs __secondsSinceEpoch)
                    ;; If the given time is before the current chains head block time, then this has no effect (we already
                    ;; downloaded everything we need).
                    (when (and (some? (:block-chain this)) (< (.. (:block-chain this) (getChainHead) (getHeader) (getTimeSeconds)) (:fast-catchup-time-secs this)))
                        (ยง assoc this :download-block-bodies false)
                    )
                )
            )
            (ยง assoc this :use-filtered-blocks __useFilteredBlocks)
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Links the given wallet to this peer.  If you have multiple peers, you should use a {@link PeerGroup} to manage
     ; them and use the {@link PeerGroup#addWallet(Wallet)} method instead of registering the wallet with each peer
     ; independently, otherwise the wallet will receive duplicate notifications.
     ;;
    #_public
    (ยง method #_"void" addWallet [#_"Wallet" __wallet]
        (.. (:wallets this) (add __wallet))
        nil
    )

    ;;; Unlinks the given wallet from peer.  See {@link Peer#addWallet(Wallet)}. ;;
    #_public
    (ยง method #_"void" removeWallet [#_"Wallet" __wallet]
        (.. (:wallets this) (remove __wallet))
        nil
    )

    ;; Keep track of the last request we made to the peer in blockChainDownloadLocked so we can avoid redundant and harmful
    ;; getblocks requests.
    #_private
    (ยง field- #_"Sha256Hash" :last-get-blocks-begin)
    #_private
    (ยง field- #_"Sha256Hash" :last-get-blocks-end)

    #_private
    (ยง method- #_"void" blockChainDownloadLocked [#_"Sha256Hash" __toHash]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))

        ;; The block chain download process is a bit complicated.  Basically, we start with one or more blocks in a
        ;; chain that we have from a previous session.  We want to catch up to the head of the chain BUT we don't know
        ;; where that chain is up to or even if the top block we have is even still in the chain - we
        ;; might have got ourselves onto a fork that was later resolved by the network.
        ;;
        ;; To solve this, we send the peer a block locator which is just a list of block hashes.  It contains the
        ;; blocks we know about, but not all of them, just enough of them so the peer can figure out if we did end up
        ;; on a fork and if so, what the earliest still valid block we know about is likely to be.
        ;;
        ;; Once it has decided which blocks we need, it will send us an inv with up to 500 block messages.  We may
        ;; have some of them already if we already have a block chain and just need to catch up.  Once we request the
        ;; last block, if there are still more to come it sends us an "inv" containing only the hash of the head
        ;; block.
        ;;
        ;; That causes us to download the head block but then we find (in processBlock) that we can't connect
        ;; it to the chain yet because we don't have the intermediate blocks.  So we rerun this function building a
        ;; new block locator describing where we're up to.
        ;;
        ;; The getblocks with the new locator gets us another inv with another bunch of blocks.  We download them once
        ;; again.  This time when the peer sends us an inv with the head block, we already have it so we won't download
        ;; it again - but we recognize this case as special and call back into blockChainDownloadLocked to continue the
        ;; process.
        ;;
        ;; So this is a complicated process but it has the advantage that we can download a chain of enormous length
        ;; in a relatively stateless manner and with constant memory usage.
        ;;
        ;; All this is made more complicated by the desire to skip downloading the bodies of blocks that pre-date the
        ;; 'fast catchup time', which is usually set to the creation date of the earliest key in the wallet.  Because
        ;; we know there are no transactions using our keys before that date, we need only the headers.  To do that we
        ;; use the "getheaders" command.  Once we find we've gone past the target date, we throw away the downloaded
        ;; headers and then request the blocks from that point onwards.  "getheaders" does not send us an inv, it just
        ;; sends us the data we requested in a "headers" message.

        ;; TODO: Block locators should be abstracted out rather than special cased here.
        (let [#_"List<Sha256Hash>" __blockLocator (ArrayList. #_"<>" 51)]

            ;; For now, we don't do the exponential thinning as suggested here:
            ;;
            ;;   https://en.bitcoin.it/wiki/Protocol_specification#getblocks
            ;;
            ;; This is because it requires scanning all the block chain headers, which is very slow.  Instead we add the
            ;; top 100 block headers.  If there is a re-org deeper than that, we'll end up downloading the entire chain.
            ;; We must always put the genesis block as the first entry.

            (let [#_"BlockStore" __store (.. (Preconditions/checkNotNull (:block-chain this)) (getBlockStore))
                  #_"StoredBlock" __chainHead (.. (:block-chain this) (getChainHead))
                  #_"Sha256Hash" __chainHeadHash (.. __chainHead (getHeader) (getHash))]

                ;; Did we already make this request?  If so, don't do it again.
                (when (and (Objects/equal (:last-get-blocks-begin this), __chainHeadHash) (Objects/equal (:last-get-blocks-end this), __toHash))
                    (.. Peer/log (info "blockChainDownloadLocked({}): ignoring duplicated request: {}", __toHash, __chainHeadHash))
                    (doseq [#_"Sha256Hash" __hash (:pending-block-downloads this)]
                        (.. Peer/log (info "Pending block download: {}", __hash))
                    )
                    (.. Peer/log (info (Throwables/getStackTraceAsString (Throwable.))))
                    (ยง return nil)
                )

                (when (.. Peer/log (isDebugEnabled))
                    (.. Peer/log (debug "{}: blockChainDownloadLocked({}) current head = {}", this, __toHash, (.. __chainHead (getHeader) (getHashAsString))))
                )

                (let [#_"StoredBlock" __cursor __chainHead]
                    (loop-when-recur [#_"int" __i 100] (and (some? __cursor) (< 0 __i)) [(dec __i)]
                        (.. __blockLocator (add (.. __cursor (getHeader) (getHash))))
                        (try
                            (ยง ass __cursor (.. __cursor (getPrev __store)))
                            (catch BlockStoreException __e
                                (.. Peer/log (error "Failed to walk the block chain whilst constructing a locator"))
                                (throw (RuntimeException. __e))
                            )
                        )
                    )

                    ;; Only add the locator if we didn't already do so.  If the chain is < 50 blocks we already reached it.
                    (when (some? __cursor)
                        (.. __blockLocator (add (.. (:params this) (getGenesisBlock) (getHash))))
                    )

                    ;; Record that we requested this range of blocks so we can filter out duplicate requests in the event
                    ;; of a block being solved during chain download.
                    (ยง assoc this :last-get-blocks-begin __chainHeadHash)
                    (ยง assoc this :last-get-blocks-end __toHash)

                    (cond (:download-block-bodies this)
                        (do
                            (let [#_"GetBlocksMessage" __message (GetBlocksMessage. (:params this), __blockLocator, __toHash)]
                                (.. this (sendMessage __message))
                            )
                        )
                        :else
                        (do
                            ;; Downloading headers for a while instead of full blocks.
                            (let [#_"GetHeadersMessage" __message (GetHeadersMessage. (:params this), __blockLocator, __toHash)]
                                (.. this (sendMessage __message))
                            )
                        )
                    )
                    nil
                )
            )
        )
    )

    ;;;
     ; Starts an asynchronous download of the block chain.  The chain download is deemed to be complete once we've
     ; downloaded the same number of blocks that the peer advertised having in its version handshake message.
     ;;
    #_public
    (ยง method #_"void" startBlockChainDownload []
        (.. this (setDownloadData true))
        ;; TODO: Peer might still have blocks that we don't have, and even have a heavier
        ;; chain even if the chain block count is lower.
        (let [#_"int" __blocksLeft (.. this (getPeerBlockHeightDifference))]
            (when (<= 0 __blocksLeft)
                (doseq [#_"ListenerRegistration<ChainDownloadStartedEventListener>" __registration (:chain-download-started-event-listeners this)]
                    (.. (:executor __registration) (execute (Runnable.)
                    (ยง anon
                        #_override
                        #_public
                        (ยง method #_"void" run []
                            (.. (:listener __registration) (onChainDownloadStarted (ยง dhis Peer), __blocksLeft))
                            nil
                        )
                    )))
                )
                ;; When we just want as many blocks as possible, we can set the target hash to zero.
                (.. (:lock this) (lock))
                (try
                    (.. this (blockChainDownloadLocked Sha256Hash/ZERO_HASH))
                    (finally
                        (.. (:lock this) (unlock))
                    )
                )
            )
            nil
        )
    )

    #_private
    (ยง class- Peer.PendingPing
        ;; The future that will be invoked when the pong is heard back.
        #_public
        (ยง field #_"SettableFuture<Long>" :future)
        ;; The random nonce that lets us tell apart overlapping pings/pongs.
        #_public
        (ยง field #_"long" :nonce)
        ;; Measurement of the time elapsed.
        #_public
        (ยง field #_"long" :start-time-msec)

        #_public
        (ยง constructor Peer.PendingPing [#_"long" __nonce]
            (ยง assoc this :future (SettableFuture/create))
            (ยง assoc this :nonce __nonce)
            (ยง assoc this :start-time-msec (Utils/currentTimeMillis))
            this
        )

        #_public
        (ยง method #_"void" complete []
            (when (not (.. (:future this) (isDone)))
                (let [#_"Long" __elapsed (- (Utils/currentTimeMillis) (:start-time-msec this))]
                    (.. (ยง dhis Peer) (addPingTimeData __elapsed))
                    (.. Peer/log (debug "{}: ping time is {} msec", (.. (ยง dhis Peer) (toString)), __elapsed))
                    (.. (:future this) (set __elapsed))
                )
            )
            nil
        )
    )

    ;;; Adds a ping time sample to the averaging window. ;;
    #_private
    (ยง method- #_"void" addPingTimeData [#_"long" __sample]
        (.. (:last-ping-times-lock this) (lock))
        (try
            (cond (nil? (:last-ping-times this))
                (do
                    (ยง assoc this :last-ping-times (long-array Peer/PING_MOVING_AVERAGE_WINDOW))
                    ;; Initialize the averaging window to the first sample.
                    (Arrays/fill (:last-ping-times this), __sample)
                )
                :else
                (do
                    ;; Shift all elements backwards by one.
                    (System/arraycopy (:last-ping-times this), 1, (:last-ping-times this), 0, (dec (.. (:last-ping-times this) (alength))))
                    ;; And append the new sample to the end.
                    (aset (:last-ping-times this) (dec (.. (:last-ping-times this) (alength))) __sample)
                )
            )
            (finally
                (.. (:last-ping-times-lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Sends the peer a ping message and returns a future that will be invoked when the pong is received back.
     ; The future provides a number which is the number of milliseconds elapsed between the ping and the pong.
     ; Once the pong is received the value returned by {@link org.bitcoinj.core.Peer#getLastPingTime()} is
     ; updated.
     ; @throws ProtocolException if the peer version is too low to support measurable pings.
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"ListenableFuture<Long>" ping []
        (.. this (ping (long (* (Math/random) Long/MAX_VALUE))))
    )

    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"ListenableFuture<Long>" ping [#_"long" __nonce]
        (let [#_"VersionMessage" __ver (:v-peer-version-message this)]
            (when (not (.. __ver (isPingPongSupported)))
                (throw (ProtocolException. (str "Peer version is too low for measurable pings: " __ver)))
            )

            (let [#_"Peer.PendingPing" __pendingPing (Peer.PendingPing. __nonce)]
                (.. (:pending-pings this) (add __pendingPing))
                (.. this (sendMessage (Ping. (:nonce __pendingPing))))

                (:future __pendingPing)
            )
        )
    )

    ;;;
     ; Returns the elapsed time of the last ping/pong cycle.  If {@link org.bitcoinj.core.Peer#ping()} has
     ; never been called or we did not hear back the "pong" message yet, returns {@link Long#MAX_VALUE}.
     ;;
    #_public
    (ยง method #_"long" getLastPingTime []
        (.. (:last-ping-times-lock this) (lock))
        (try
            (if (some? (:last-ping-times this)) (aget (:last-ping-times this) (dec (.. (:last-ping-times this) (alength)))) Long/MAX_VALUE)
            (finally
                (.. (:last-ping-times-lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns a moving average of the last N ping/pong cycles.  If {@link org.bitcoinj.core.Peer#ping()} has never
     ; been called or we did not hear back the "pong" message yet, returns {@link Long#MAX_VALUE}.  The moving average
     ; window is 5 buckets.
     ;;
    #_public
    (ยง method #_"long" getPingTime []
        (.. (:last-ping-times-lock this) (lock))
        (try
            (when (nil? (:last-ping-times this))
                (ยง return Long/MAX_VALUE)
            )
            (let [#_"long" __sum 0]
                (doseq [#_"long" __i (:last-ping-times this)]
                    (ยง ass __sum (+ __sum __i))
                )
                (ยง return (long (/ (double __sum) (.. (:last-ping-times this) (alength)))))
            )
            (finally
                (.. (:last-ping-times-lock this) (unlock))
            )
        )
    )

    #_private
    (ยง method- #_"void" processPing [#_"Ping" __m]
        (when (.. __m (hasNonce))
            (.. this (sendMessage (Pong. (.. __m (getNonce)))))
        )
        nil
    )

    #_protected
    (ยง method #_"void" processPong [#_"Pong" __m]
        ;; Iterates over a snapshot of the list, so we can run unlocked here.
        (doseq [#_"Peer.PendingPing" __ping (:pending-pings this)]
            (when (== (.. __m (getNonce)) (:nonce __ping))
                (.. (:pending-pings this) (remove __ping))
                ;; This line may trigger an event listener that re-runs ping().
                (.. __ping (complete))
                (ยง return nil)
            )
        )
        nil
    )

    ;;;
     ; Returns the difference between our best chain height and the peers, which can either be positive if we are
     ; behind the peer, or negative if the peer is ahead of us.
     ;;
    #_public
    (ยง method #_"int" getPeerBlockHeightDifference []
        (Preconditions/checkNotNull (:block-chain this), "No block chain configured")

        ;; Chain will overflow signed int blocks in ~41,000 years.
        (let [#_"int" __chainHeight (int (.. this (getBestHeight)))]
            ;; chainHeight should not be zero/negative because we shouldn't have given the user a Peer that is to another
            ;; client-mode node, nor should it be unconnected.  If that happens it means the user overrode us somewhere or
            ;; there is a bug in the peer management code.
            (Preconditions/checkState (or (.. (:params this) (allowEmptyPeerChain)) (< 0 __chainHeight)), "Connected to peer with zero/negative chain height", __chainHeight)
            (- __chainHeight (.. (:block-chain this) (getBestChainHeight)))
        )
    )

    #_private
    (ยง method- #_"boolean" isNotFoundMessageSupported []
        (<= NotFoundMessage/MIN_PROTOCOL_VERSION (-> this :v-peer-version-message :client-version))
    )

    ;;;
     ; Returns true if this peer will try and download things it is sent in "inv" messages.
     ; Normally you only need one peer to be downloading data.  Defaults to true.
     ;;
    #_public
    (ยง method #_"boolean" isDownloadData []
        (:v-download-data this)
    )

    ;;;
     ; If set to false, the peer won't try and fetch blocks and transactions it hears about.  Normally, only one
     ; peer should download missing blocks.  Defaults to true.  Changing this value from false to true may trigger
     ; a request to the remote peer for the contents of its memory pool, if Bloom filtering is active.
     ;;
    #_public
    (ยง method #_"void" setDownloadData [#_"boolean" __downloadData]
        (ยง assoc this :v-download-data __downloadData)
        nil
    )

    ;;; Returns version data announced by the remote peer. ;;
    #_public
    (ยง method #_"VersionMessage" getPeerVersionMessage []
        (:v-peer-version-message this)
    )

    ;;; Returns version data we announce to our remote peers. ;;
    #_public
    (ยง method #_"VersionMessage" getVersionMessage []
        (:version-message this)
    )

    ;;;
     ; @return the height of the best chain as claimed by peer: sum of its ver announcement and blocks announced since.
     ;;
    #_public
    (ยง method #_"long" getBestHeight []
        (+ (-> this :v-peer-version-message :best-height) (.. (:blocks-announced this) (get)))
    )

    ;;;
     ; The minimum P2P protocol version that is accepted.  If the peer speaks a protocol version lower than this, it
     ; will be disconnected.
     ; @return true if the peer was disconnected as a result.
     ;;
    #_public
    (ยง method #_"boolean" setMinProtocolVersion [#_"int" __minProtocolVersion]
        (ยง assoc this :v-min-protocol-version __minProtocolVersion)

        (let [#_"VersionMessage" __ver (.. this (getPeerVersionMessage))]
            (when (and (some? __ver) (< (:client-version __ver) __minProtocolVersion))
                (.. Peer/log (warn "{}: Disconnecting due to new min protocol version {}, got: {}", this, __minProtocolVersion, (:client-version __ver)))
                (.. this (close))
                (ยง return true)
            )

            false
        )
    )

    ;;;
     ; <p>Sets a Bloom filter on this connection.  This will cause the given {@link BloomFilter} object to be sent
     ; to the remote peer and if either a memory pool has been set using the constructor or the
     ; vDownloadData property is true, a {@link MemoryPoolMessage} is sent as well to trigger downloading of any
     ; pending transactions that may be relevant.</p>
     ;
     ; <p>The Peer does not automatically request filters from any wallets added using {@link Peer#addWallet(Wallet)}.
     ; This is to allow callers to avoid redundantly recalculating the same filter repeatedly when using multiple peers
     ; and multiple wallets together.</p>
     ;
     ; <p>Therefore, you should not use this method if your app uses a {@link PeerGroup}.  It is called for you.</p>
     ;
     ; <p>If the remote peer doesn't support Bloom filtering, then this call is ignored.  Once set you presently cannot
     ; unset a filter, though the underlying p2p protocol does support it.</p>
     ;;
    #_public
    (ยง method #_"void" setBloomFilter [#_"BloomFilter" __filter]
        (.. this (setBloomFilter __filter, true))
        nil
    )

    ;;;
     ; <p>Sets a Bloom filter on this connection.  This will cause the given {@link BloomFilter} object to be sent
     ; to the remote peer and if requested, a {@link MemoryPoolMessage} is sent as well to trigger downloading of any
     ; pending transactions that may be relevant.</p>
     ;
     ; <p>The Peer does not automatically request filters from any wallets added using {@link Peer#addWallet(Wallet)}.
     ; This is to allow callers to avoid redundantly recalculating the same filter repeatedly when using multiple peers
     ; and multiple wallets together.</p>
     ;
     ; <p>Therefore, you should not use this method if your app uses a {@link PeerGroup}.  It is called for you.</p>
     ;
     ; <p>If the remote peer doesn't support Bloom filtering, then this call is ignored.  Once set you presently cannot
     ; unset a filter, though the underlying p2p protocol does support it.</p>
     ;;
    #_public
    (ยง method #_"void" setBloomFilter [#_"BloomFilter" __filter, #_"boolean" __andQueryMemPool]
        (Preconditions/checkNotNull __filter, "Clearing filters is not currently supported")

        (let [#_"VersionMessage" __ver (:v-peer-version-message this)]
            (when (and (some? __ver) (.. __ver (isBloomFilteringSupported)))
                (ยง assoc this :v-bloom-filter __filter)
                (.. Peer/log (debug "{}: Sending Bloom filter{}", this, (if __andQueryMemPool " and querying mempool" "")))
                (.. this (sendMessage __filter))
                (when __andQueryMemPool
                    (.. this (sendMessage (MemoryPoolMessage.)))
                )
                (.. this (maybeRestartChainDownload))
            )
            nil
        )
    )

    #_private
    (ยง method- #_"void" maybeRestartChainDownload []
        (.. (:lock this) (lock))
        (try
            (when (nil? (:awaiting-fresh-filter this))
                (ยง return nil)
            )

            (when (not (:v-download-data this))
                ;; This branch should be harmless but I want to know how often it happens in reality.
                (.. Peer/log (warn "Lost download peer status whilst awaiting fresh filter."))
                (ยง return nil)
            )

            ;; Ping/pong to wait for blocks that are still being streamed to us to finish being downloaded and discarded.
            (.. this (ping) (addListener (Runnable.)
            (ยง anon
                #_override
                #_public
                (ยง method #_"void" run []
                    (.. (:lock this) (lock))
                    (Preconditions/checkNotNull (:awaiting-fresh-filter this))
                    (let [#_"GetDataMessage" __getdata (GetDataMessage. (:params this))]
                        (doseq [#_"Sha256Hash" __hash (:awaiting-fresh-filter this)]
                            (.. __getdata (addFilteredBlock __hash))
                        )
                        (ยง assoc this :awaiting-fresh-filter nil)
                        (.. (:lock this) (unlock))

                        (.. Peer/log (info "Restarting chain download"))
                        (.. this (sendMessage __getdata))
                        ;; TODO: This bizarre ping-after-getdata hack probably isn't necessary.
                        ;; It's to ensure we know when the end of a filtered block stream of txns is, but we should just be
                        ;; able to match txns with the merkleblock.  Ask Matt why it's written this way.
                        (.. this (sendMessage (Ping. (long (* (Math/random) Long/MAX_VALUE)))))
                        nil
                    )
                )
            ), Threading/SAME_THREAD))
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Returns the last {@link BloomFilter} set by {@link Peer#setBloomFilter(BloomFilter)}.  Bloom filters tell
     ; the remote node what transactions to send us, in a compact manner.
     ;;
    #_public
    (ยง method #_"BloomFilter" getBloomFilter []
        (:v-bloom-filter this)
    )

    ;;;
     ; Returns true if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     ; before handing the transaction off to the wallet.  The wallet can do risk analysis on pending/recent transactions
     ; to try and discover if a pending tx might be at risk of double spending.
     ;;
    #_public
    (ยง method #_"boolean" isDownloadTxDependencies []
        (< 0 (:v-download-tx-dependency-depth this))
    )

    ;;;
     ; Sets if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     ; before handing the transaction off to the wallet.  The wallet can do risk analysis on pending/recent transactions
     ; to try and discover if a pending tx might be at risk of double spending.
     ;;
    #_public
    (ยง method #_"void" setDownloadTxDependencies [#_"boolean" __enable]
        (ยง assoc this :v-download-tx-dependency-depth (if __enable Integer/MAX_VALUE 0))
        nil
    )

    ;;;
     ; Sets if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     ; before handing the transaction off to the wallet.  The wallet can do risk analysis on pending/recent transactions
     ; to try and discover if a pending tx might be at risk of double spending.
     ;;
    #_public
    (ยง method #_"void" setDownloadTxDependencies [#_"int" __depth]
        (ยง assoc this :v-download-tx-dependency-depth __depth)
        nil
    )
)

;;;
 ; <p>A PeerAddress holds an IP address and port number representing the network location of
 ; a peer in the Bitcoin P2P network.  It exists primarily for serialization purposes.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class PeerAddress (ยง extends ChildMessage)
    #_static
    (ยง def #_"int" PeerAddress/MESSAGE_SIZE 30)

    #_private
    (ยง field- #_"InetAddress" :addr)
    #_private
    (ยง field- #_"String" :hostname) ;; Used for .onion addresses.
    #_private
    (ยง field- #_"int" :port)
    #_private
    (ยง field- #_"BigInteger" :services)
    #_private
    (ยง field- #_"long" :time)

    ;;;
     ; Construct a peer address from a serialized payload.
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor PeerAddress [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"int" __offset, #_"int" __protocolVersion]
        (ยง super __params, __payload, __offset, __protocolVersion)
        this
    )

    ;;;
     ; Construct a peer address from a serialized payload.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param protocolVersion Bitcoin protocol version.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor PeerAddress [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"int" __offset, #_"int" __protocolVersion, #_"Message" __parent, #_"MessageSerializer" __serializer]
        (ยง super __params, __payload, __offset, __protocolVersion, __parent, __serializer, Message/UNKNOWN_LENGTH)
        this
    )

    ;;;
     ; Construct a peer address from a memorized or hardcoded address.
     ;;
    #_public
    (ยง constructor PeerAddress [#_"NetworkParameters" __params, #_"InetAddress" __addr, #_"int" __port, #_"int" __protocolVersion, #_"BigInteger" __services]
        (ยง super __params)

        (ยง assoc this :addr (Preconditions/checkNotNull __addr))
        (ยง assoc this :port __port)
        (ยง assoc this :protocol-version __protocolVersion)
        (ยง assoc this :services __services)

        (ยง assoc this :length (if (< 31402 __protocolVersion) PeerAddress/MESSAGE_SIZE (- PeerAddress/MESSAGE_SIZE 4)))
        this
    )

    ;;;
     ; Constructs a peer address from the given IP address and port.  Version number is default for the given parameters.
     ;;
    #_public
    (ยง constructor PeerAddress [#_"NetworkParameters" __params, #_"InetAddress" __addr, #_"int" __port]
        (ยง this __params, __addr, __port, (.. __params (getProtocolVersionNum NetworkParameters.ProtocolVersion/CURRENT)), BigInteger/ZERO)
        this
    )

    ;;;
     ; Constructs a peer address from the given IP address.  Port and version number are default for the given parameters.
     ;;
    #_public
    (ยง constructor PeerAddress [#_"NetworkParameters" __params, #_"InetAddress" __addr]
        (ยง this __params, __addr, (.. __params (getPort)))
        this
    )

    ;;;
     ; Constructs a peer address from an {@link InetSocketAddress}.  An InetSocketAddress can take in as parameters an
     ; InetAddress or a String hostname.  If you want to connect to a .onion, set the hostname to the .onion address.
     ;;
    #_public
    (ยง constructor PeerAddress [#_"NetworkParameters" __params, #_"InetSocketAddress" __addr]
        (ยง this __params, (.. __addr (getAddress)), (.. __addr (getPort)))
        this
    )

    ;;;
     ; Constructs a peer address from a stringified hostname+port.  Use this if you want to connect to a Tor .onion address.
     ;;
    #_public
    (ยง constructor PeerAddress [#_"NetworkParameters" __params, #_"String" __hostname, #_"int" __port]
        (ยง super __params)

        (ยง assoc this :hostname __hostname)
        (ยง assoc this :port __port)
        (ยง assoc this :protocol-version (.. __params (getProtocolVersionNum NetworkParameters.ProtocolVersion/CURRENT)))
        (ยง assoc this :services BigInteger/ZERO)
        this
    )

    #_public
    #_static
    (ยง defn #_"PeerAddress" PeerAddress/localhost [#_"NetworkParameters" __params]
        (PeerAddress. __params, (InetAddresses/forString "127.0.0.1"), (.. __params (getPort)))
    )

    #_override
    #_protected
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __stream]
        (when (<= 31402 (:protocol-version this))
            ;; TODO: This appears to be dynamic because the client only ever sends out it's own address
            ;; so assumes itself to be up.  For a fuller implementation this needs to be dynamic only if
            ;; the address refers to this client.
            (let [#_"int" __secs (int (Utils/currentTimeSeconds))]
                (Utils/uint32ToByteStreamLE __secs, __stream)
            )
        )
        (Utils/uint64ToByteStreamLE (:services this), __stream) ;; nServices.
        ;; Java does not provide any utility to map an IPv4 address into IPv6 space, so we have to do it by hand.
        (let [#_"byte[]" __ipBytes (.. (:addr this) (getAddress))]
            (when (== (.. __ipBytes (alength)) 4)
                (let [#_"byte[]" __v6addr (byte-array 16)]
                    (System/arraycopy __ipBytes, 0, __v6addr, 12, 4)
                    (aset __v6addr 10 (byte 0xff))
                    (aset __v6addr 11 (byte 0xff))
                    (ยง ass __ipBytes __v6addr)
                )
            )
            (.. __stream (write __ipBytes))
            ;; And write out the port.  Unlike the rest of the protocol, address and port is in big endian byte order.
            (.. __stream (write (byte (& 0xff (>> (:port this) 8)))))
            (.. __stream (write (byte (& 0xff (:port this)))))
            nil
        )
    )

    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        ;; Format of a serialized address:
        ;;   uint32 timestamp
        ;;   uint64 services (flags determining what the node can do)
        ;;   16 bytes ip address
        ;;   2 bytes port num
        (ยง assoc this :time (if (< 31402 (:protocol-version this)) (.. this (readUint32)) -1))
        (ยง assoc this :services (.. this (readUint64)))
        (let [#_"byte[]" __addrBytes (.. this (readBytes 16))]
            (try
                (ยง assoc this :addr (InetAddress/getByAddress __addrBytes))
                (catch UnknownHostException __e
                    (throw (RuntimeException. __e)) ;; Cannot happen.
                )
            )
            (ยง assoc this :port (| (<< (& 0xff (aget (:payload this) (:cursor this))) 8) (& 0xff (aget (:payload this) (inc (:cursor this))))))
            (ยง assoc this :cursor (+ (:cursor this) 2))
            ;; The 4 byte difference is the uint32 timestamp that was introduced in version 31402.
            (ยง assoc this :length (if (< 31402 (:protocol-version this)) PeerAddress/MESSAGE_SIZE (- PeerAddress/MESSAGE_SIZE 4)))
            nil
        )
    )

    #_public
    (ยง method #_"String" getHostname []
        (:hostname this)
    )

    #_public
    (ยง method #_"InetAddress" getAddr []
        (:addr this)
    )

    #_public
    (ยง method #_"InetSocketAddress" getSocketAddress []
        (InetSocketAddress. (.. this (getAddr)), (.. this (getPort)))
    )

    #_public
    (ยง method #_"int" getPort []
        (:port this)
    )

    #_public
    (ยง method #_"BigInteger" getServices []
        (:services this)
    )

    #_public
    (ยง method #_"long" getTime []
        (:time this)
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (if (some? (:hostname this)) (str "[" (:hostname this) "]:" (:port this)) (str "[" (.. (:addr this) (getHostAddress)) "]:" (:port this)))
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"PeerAddress" __other (cast PeerAddress __o)]
            (and (.. (:addr __other) (equals (:addr this))) (== (:port __other) (:port this)) (== (:time __other) (:time this)) (.. (:services __other) (equals (:services this))))
        )
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (:addr this), (:port this), (:time this), (:services this))
    )

    #_public
    (ยง method #_"InetSocketAddress" toSocketAddress []
        ;; Reconstruct the InetSocketAddress properly.
        (if (some? (:hostname this)) (InetSocketAddress/createUnresolved (:hostname this), (:port this)) (InetSocketAddress. (:addr this), (:port this)))
    )
)

;;;
 ; Thrown when a problem occurs in communicating with a peer, and we should retry.
 ;;
#_public
(ยง class PeerException (ยง extends Exception)
    #_public
    (ยง constructor PeerException [#_"String" __msg]
        (ยง super __msg)
        this
    )

    #_public
    (ยง constructor PeerException [#_"Exception" __e]
        (ยง super __e)
        this
    )

    #_public
    (ยง constructor PeerException [#_"String" __msg, #_"Exception" __e]
        (ยง super __msg, __e)
        this
    )
)

;;;
 ; An interface which provides the information required to properly filter data downloaded from Peers.
 ; Note that an implementer is responsible for calling {@link PeerGroup#recalculateFastCatchupAndFilter(org.bitcoinj.core.PeerGroup.FilterRecalculateMode)}
 ; whenever a change occurs which effects the data provided via this interface.
 ;;
#_public
(ยง interface PeerFilterProvider
    ;;;
     ; Returns the earliest timestamp (seconds since epoch) for which full/bloom-filtered blocks must be downloaded.
     ; Blocks with timestamps before this time will only have headers downloaded.  0 requires that all blocks be
     ; downloaded, and thus this should default to {@link System#currentTimeMillis()}/1000.
     ;;
    (ยง method #_"long" getEarliestKeyCreationTime [])

    ;;;
     ; Called on all registered filter providers before getBloomFilterElementCount and getBloomFilter are called.
     ; Once called, the provider should ensure that the items it will want to insert into the filter don't change.
     ; The reason is that all providers will have their element counts queried, and then a filter big enough for
     ; all of them will be specified.  So the provider must use consistent state.  There is guaranteed to be
     ; a matching call to endBloomFilterCalculation that can be used to e.g. unlock a lock.
     ;;
    (ยง method #_"void" beginBloomFilterCalculation [])

    ;;;
     ; Gets the number of elements that will be added to a bloom filter returned by
     ; {@link PeerFilterProvider#getBloomFilter(int, double, long)}.
     ;;
    (ยง method #_"int" getBloomFilterElementCount [])

    ;;;
     ; Gets a bloom filter that contains all the necessary elements for the listener to receive relevant transactions.
     ; Default value should be an empty bloom filter with the given size, falsePositiveRate, and nTweak.
     ;;
    (ยง method #_"BloomFilter" getBloomFilter [#_"int" __size, #_"double" __falsePositiveRate, #_"long" __nTweak])

    (ยง method #_"void" endBloomFilterCalculation [])
)

;;;
 ; <p>Runs a set of connections to the P2P network, brings up connections to replace disconnected nodes and manages
 ; the interaction between them all.  Most applications will want to use one of these.</p>
 ;
 ; <p>PeerGroup tries to maintain a constant number of connections to a set of distinct peers.
 ; Each peer runs a network listener in its own thread.  When a connection is lost, a new peer
 ; will be tried after a delay as long as the number of connections less than the maximum.</p>
 ;
 ; <p>Connections are made to addresses from a provided list.  When that list is exhausted,
 ; we start again from the head of the list.</p>
 ;
 ; <p>The PeerGroup can broadcast a transaction to the currently connected set of peers.  It can
 ; also handle download of the blockchain from peers, restarting the process when peers die.</p>
 ;
 ; <p>A PeerGroup won't do anything until you call the {@link PeerGroup#start()} method
 ; which will block until peer discovery is completed and some outbound connections
 ; have been initiated (it will return before handshaking is done, however).
 ; You should call {@link PeerGroup#stop()} when finished.  Note that not all methods
 ; of PeerGroup are safe to call from a UI thread as some may do network IO,
 ; but starting and stopping the service should be fine.</p>
 ;;
#_public
(ยง class PeerGroup (ยง implements TransactionBroadcaster)
    #_private
    #_static
    (ยง def- #_"Logger" PeerGroup/log (LoggerFactory/getLogger PeerGroup))

    ;; All members in this class should be marked with final, volatile, @GuardedBy or a mix as appropriate to define
    ;; their thread safety semantics.  Volatile requires a Hungarian-style v prefix.

    ;; By default we don't require any services because any peer will do.
    #_private
    (ยง field- #_"long" :required-services 0)

    ;;;
     ; The default number of connections to the p2p network the library will try to build.  This is set to 12 empirically.
     ; It used to be 4, but because we divide the connection pool in two for broadcasting transactions, that meant we
     ; were only sending transactions to two peers and sometimes this wasn't reliable enough: transactions wouldn't
     ; get through.
     ;;
    #_public
    #_static
    (ยง def #_"int" PeerGroup/DEFAULT_CONNECTIONS 12)
    #_private
    #_volatile
    (ยง field- #_"int" :v-max-peers-to-discover-count 100)
    #_private
    #_static
    (ยง def- #_"long" PeerGroup/DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS 5000)
    #_private
    #_volatile
    (ยง field- #_"long" :v-peer-discovery-timeout-millis PeerGroup/DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS)

    #_protected
    (ยง field #_"ReentrantLock" :lock (Threading/lock "peergroup"))

    #_protected
    (ยง field #_"NetworkParameters" :params)
    #_nilable
    #_protected
    (ยง field #_"AbstractBlockChain" :chain)

    ;; This executor is used to queue up jobs: it's used when we don't want to use locks for mutual exclusion,
    ;; typically because the job might call in to user provided code that needs/wants the freedom to use the API
    ;; however it wants, or because a job needs to be ordered relative to other jobs like that.
    #_protected
    (ยง field #_"ListeningScheduledExecutorService" :executor)

    ;; Whether the peer group is currently running.  Once shut down it cannot be restarted.
    #_private
    #_volatile
    (ยง field- #_"boolean" :v-running)
    ;; Whether the peer group has been started or not.  An unstarted PG does not try to access the network.
    #_private
    #_volatile
    (ยง field- #_"boolean" :v-used-up)

    ;; Addresses to try to connect to, excluding active peers.
    #_private
    (ยง field- #_"PriorityQueue<PeerAddress>" :inactives)
    #_private
    (ยง field- #_"Map<PeerAddress, ExponentialBackoff>" :backoff-map)

    ;; Currently active peers.  This is an ordered list rather than a set to make unit tests predictable.
    #_private
    (ยง field- #_"CopyOnWriteArrayList<Peer>" :peers)
    ;; Currently connecting peers.
    #_private
    (ยง field- #_"CopyOnWriteArrayList<Peer>" :pending-peers)
    #_private
    (ยง field- #_"ClientConnectionManager" :channels)

    ;; The peer that has been selected for the purposes of downloading announced data.
    #_private
    (ยง field- #_"Peer" :download-peer)
    ;; Callback for events related to chain download.
    #_nilable
    #_private
    (ยง field- #_"PeerDataEventListener" :download-listener)

    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<BlocksDownloadedEventListener>>" :peers-blocks-downloaded-event-listeners (CopyOnWriteArrayList. #_"<>"))
    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<ChainDownloadStartedEventListener>>" :peers-chain-download-started-event-listeners (CopyOnWriteArrayList. #_"<>"))
    ;;; Callbacks for events related to peers connecting. ;;
    #_protected
    (ยง field #_"CopyOnWriteArrayList<ListenerRegistration<PeerConnectedEventListener>>" :peer-connected-event-listeners (CopyOnWriteArrayList. #_"<>"))
    ;;; Callbacks for events related to peer connection/disconnection. ;;
    #_protected
    (ยง field #_"CopyOnWriteArrayList<ListenerRegistration<PeerDiscoveredEventListener>>" :peer-discovered-event-listeners (CopyOnWriteArrayList. #_"<>"))
    ;;; Callbacks for events related to peers disconnecting. ;;
    #_protected
    (ยง field #_"CopyOnWriteArrayList<ListenerRegistration<PeerDisconnectedEventListener>>" :peer-disconnected-event-listeners (CopyOnWriteArrayList. #_"<>"))
    ;;; Callbacks for events related to peer data being received. ;;
    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<GetDataEventListener>>" :peer-get-data-event-listeners (CopyOnWriteArrayList. #_"<>"))
    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<PreMessageReceivedEventListener>>" :peers-pre-message-received-event-listeners (CopyOnWriteArrayList. #_"<>"))
    #_protected
    (ยง field #_"CopyOnWriteArrayList<ListenerRegistration<OnTransactionBroadcastListener>>" :peers-transaction-broadast-event-listeners (CopyOnWriteArrayList. #_"<>"))

    ;; Peer discovery sources, will be polled occasionally if there aren't enough inactives.
    #_private
    (ยง field- #_"CopyOnWriteArraySet<PeerDiscovery>" :peer-discoverers)
    ;; The version message to use for new connections.
    #_private
    (ยง field- #_"VersionMessage" :version-message)
    ;; Maximum depth up to which pending transaction dependencies are downloaded, or 0 for disabled.
    #_private
    (ยง field- #_"int" :download-tx-dependency-depth)
    ;; How many connections we want to have open at the current time.  If we lose connections, we'll try opening more
    ;; until we reach this count.
    #_private
    (ยง field- #_"int" :max-connections)
    ;; Minimum protocol version we will allow ourselves to connect to: require Bloom filtering.
    #_private
    #_volatile
    (ยง field- #_"int" :v-min-required-protocol-version)

    ;;; How many milliseconds to wait after receiving a pong before sending another ping. ;;
    #_public
    #_static
    (ยง def #_"long" PeerGroup/DEFAULT_PING_INTERVAL_MSEC 2000)
    #_private
    (ยง field- #_"long" :ping-interval-msec PeerGroup/DEFAULT_PING_INTERVAL_MSEC)

    #_private
    (ยง field- #_"boolean" :use-localhost-peer-when-possible true)
    #_private
    (ยง field- #_"boolean" :ipv6-unreachable false)

    #_private
    (ยง field- #_"long" :fast-catchup-time-secs)
    #_private
    (ยง field- #_"CopyOnWriteArrayList<Wallet>" :wallets)
    #_private
    (ยง field- #_"CopyOnWriteArrayList<PeerFilterProvider>" :peer-filter-providers)

    ;; This event listener is added to every peer.  It's here so when we announce transactions via an "inv",
    ;; every peer can fetch them.
    #_private
    (ยง field- #_"PeerGroup.PeerListener" :peer-listener (PeerGroup.PeerListener.))

    #_private
    (ยง field- #_"int" :min-broadcast-connections 0)

    #_private
    (ยง field- #_"KeyChainEventListener" :wallet-key-event-listener (KeyChainEventListener.
        (ยง anon
            #_override
            #_public
            (ยง method #_"void" onKeysAdded [#_"List<ECKey>" __keys]
                (.. this (recalculateFastCatchupAndFilter PeerGroup.FilterRecalculateMode/SEND_IF_CHANGED))
                nil
            )
        )))

    #_private
    (ยง field- #_"WalletCoinsReceivedEventListener" :wallet-coins-received-event-listener (WalletCoinsReceivedEventListener.
        (ยง anon
            #_override
            #_public
            (ยง method #_"void" onCoinsReceived [#_"Wallet" __wallet, #_"Transaction" __tx, #_"Coin" __prevBalance, #_"Coin" __newBalance]
                ;; We received a relevant transaction.  We MAY need to recalculate and resend the Bloom filter, but only
                ;; if we have received a transaction that includes a relevant pay-to-pubkey output.
                ;;
                ;; The reason is that pay-to-pubkey outputs, when spent, will not repeat any data we can predict in their
                ;; inputs.  So a remote peer will update the Bloom filter for us when such an output is seen matching the
                ;; existing filter, so that it includes the tx hash in which the pay-to-pubkey output was observed.  Thus
                ;; the spending transaction will always match (due to the outpoint structure).
                ;;
                ;; Unfortunately, whilst this is required for correct sync of the chain in blocks, there are two edge cases.
                ;;
                ;; (1) If a wallet receives a relevant, confirmed p2pubkey output that was not broadcast across the network,
                ;; for example in a coinbase transaction, then the node that's serving us the chain will update its filter
                ;; but the rest will not.  If another transaction then spends it, the other nodes won't match/relay it.
                ;;
                ;; (2) If we receive a p2pubkey output broadcast across the network, all currently connected nodes will see
                ;; it and update their filter themselves, but any newly connected nodes will receive the last filter we
                ;; calculated, which would not include this transaction.
                ;;
                ;; For this reason we check if the transaction contained any relevant pay to pubkeys and force a recalc
                ;; and possibly retransmit if so.  The recalculation process will end up including the tx hash into the
                ;; filter.  In case (1), we need to retransmit the filter to the connected peers.  In case (2), we don't
                ;; and shouldn't, we should just recalculate and cache the new filter for next time.

                (doseq [#_"TransactionOutput" __output (.. __tx (getOutputs))]
                    (when (and (.. __output (getScriptPubKey) (isSentToRawPubKey)) (.. __output (isMine __wallet)))
                        (if (== (.. __tx (getConfidence) (getConfidenceType)) TransactionConfidence.ConfidenceType/BUILDING)
                            (.. this (recalculateFastCatchupAndFilter PeerGroup.FilterRecalculateMode/SEND_IF_CHANGED))
                            (.. this (recalculateFastCatchupAndFilter PeerGroup.FilterRecalculateMode/DONT_SEND))
                        )
                        (ยง return nil)
                    )
                )
                nil
            )
        )))

    ;; Exponential backoff for peers starts at 1 second and maxes at 10 minutes.
    #_private
    (ยง field- #_"ExponentialBackoff.Params" :peer-backoff-params (ExponentialBackoff.Params. 1000, 1.5, (* 10 60 1000)))
    ;; Tracks failures globally in case of a network failure.
    #_private
    (ยง field- #_"ExponentialBackoff" :group-backoff (ExponentialBackoff. (ExponentialBackoff.Params. 1000, 1.5, (* 10 1000))))

    ;; This is a synchronized set, so it locks on itself.  We use it to prevent TransactionBroadcast objects from
    ;; being garbage collected if nothing in the apps code holds on to them transitively.  See the discussion
    ;; in broadcastTransaction.
    #_private
    (ยง field- #_"Set<TransactionBroadcast>" :running-broadcasts)

    #_private
    (ยง class- PeerGroup.PeerListener (ยง implements GetDataEventListener, BlocksDownloadedEventListener)
        #_public
        (ยง constructor PeerGroup.PeerListener []
            this
        )

        #_override
        #_public
        (ยง method #_"List<Message>" getData [#_"Peer" __peer, #_"GetDataMessage" __m]
            (.. this (handleGetData __m))
        )

        #_override
        #_public
        (ยง method #_"void" onBlocksDownloaded [#_"Peer" __peer, #_"Block" __block, #_nilable #_"FilteredBlock" __filteredBlock, #_"int" __blocksLeft]
            (when (some? (:chain this))
                (let [#_"double" __rate (.. (:chain this) (getFalsePositiveRate))
                      #_"double" __target (* (.. (:bloom-filter-merger this) (getBloomFilterFPRate)) PeerGroup/MAX_FP_RATE_INCREASE)]
                    (when (< __target __rate)
                        ;; TODO: Avoid hitting this path if the remote peer didn't acknowledge applying a new filter yet.
                        (when (.. PeerGroup/log (isDebugEnabled))
                            (.. PeerGroup/log (debug "Force update Bloom filter due to high false positive rate ({} vs {})", __rate, __target))
                        )

                        (.. this (recalculateFastCatchupAndFilter PeerGroup.FilterRecalculateMode/FORCE_SEND_FOR_REFRESH))
                    )
                )
            )
            nil
        )
    )

    #_private
    (ยง class- PeerGroup.PeerStartupListener (ยง implements PeerConnectedEventListener, PeerDisconnectedEventListener)
        #_override
        #_public
        (ยง method #_"void" onPeerConnected [#_"Peer" __peer, #_"int" __peerCount]
            (.. this (handleNewPeer __peer))
            nil
        )

        #_override
        #_public
        (ยง method #_"void" onPeerDisconnected [#_"Peer" __peer, #_"int" __peerCount]
            ;; The channel will be automatically removed from channels.
            (.. this (handlePeerDeath __peer, nil))
            nil
        )
    )

    #_private
    (ยง field- #_"PeerGroup.PeerStartupListener" :startup-listener (PeerGroup.PeerStartupListener.))

    ;;;
     ; The default Bloom filter false positive rate, which is selected to be extremely low such that you hardly ever
     ; download false positives.  This provides maximum performance.  Although this default can be overridden to push
     ; the FP rate higher, due to <a href="https://groups.google.com/forum/#!msg/bitcoinj/Ys13qkTwcNg/9qxnhwnkeoIJ">
     ; various complexities</a> there are still ways a remote peer can deanonymize the users wallet.  This is why the
     ; FP rate is chosen for performance rather than privacy.  If a future version of bitcoinj fixes the known
     ; de-anonymization attacks this FP rate may rise again (or more likely, become expressed as a bandwidth allowance).
     ;;
    #_public
    #_static
    (ยง def #_"double" PeerGroup/DEFAULT_BLOOM_FILTER_FP_RATE 0.00001)
    ;;; Maximum increase in FP rate before forced refresh of the bloom filter. ;;
    #_public
    #_static
    (ยง def #_"double" PeerGroup/MAX_FP_RATE_INCREASE 10.0)
    ;; An object that calculates bloom filters given a list of filter providers, whilst tracking some state useful
    ;; for privacy purposes.
    #_private
    (ยง field- #_"FilterMerger" :bloom-filter-merger)

    ;;; The default timeout between when a connection attempt begins and version message exchange completes. ;;
    #_public
    #_static
    (ยง def #_"int" PeerGroup/DEFAULT_CONNECT_TIMEOUT_MILLIS 5000)
    #_private
    #_volatile
    (ยง field- #_"int" :v-connect-timeout-millis PeerGroup/DEFAULT_CONNECT_TIMEOUT_MILLIS)

    ;;; Whether bloom filter support is enabled when using a non FullPrunedBlockchain. ;;
    #_private
    #_volatile
    (ยง field- #_"boolean" :v-bloom-filtering-enabled true)

    ;;; See {@link #PeerGroup(Context)}. ;;
    #_public
    (ยง constructor PeerGroup [#_"NetworkParameters" __params]
        (ยง this __params, nil)
        this
    )

    ;;;
     ; Creates a PeerGroup with the given context.  No chain is provided so this node will report its chain height
     ; as zero to other peers.  This constructor is useful if you just want to explore the network but aren't interested
     ; in downloading block data.
     ;;
    #_public
    (ยง constructor PeerGroup [#_"Context" __context]
        (ยง this __context, nil)
        this
    )

    ;;; See {@link #PeerGroup(Context, AbstractBlockChain)}. ;;
    #_public
    (ยง constructor PeerGroup [#_"NetworkParameters" __params, #_nilable #_"AbstractBlockChain" __chain]
        (ยง this (Context/getOrCreate __params), __chain, (NioClientManager.))
        this
    )

    ;;;
     ; Creates a PeerGroup for the given context and chain.  Blocks will be passed to the chain as they are broadcast
     ; and downloaded.  This is probably the constructor you want to use.
     ;;
    #_public
    (ยง constructor PeerGroup [#_"Context" __context, #_nilable #_"AbstractBlockChain" __chain]
        (ยง this __context, __chain, (NioClientManager.))
        this
    )

    ;;; See {@link #PeerGroup(Context, AbstractBlockChain, ClientConnectionManager)}. ;;
    #_public
    (ยง constructor PeerGroup [#_"NetworkParameters" __params, #_nilable #_"AbstractBlockChain" __chain, #_"ClientConnectionManager" __connectionManager]
        (ยง this (Context/getOrCreate __params), __chain, __connectionManager)
        this
    )

    ;;;
     ; Creates a new PeerGroup allowing you to specify the {@link ClientConnectionManager} which is used to create new
     ; connections and keep track of existing ones.
     ;;
    #_private
    (ยง constructor- #_"PeerGroup" [#_"Context" __context, #_nilable #_"AbstractBlockChain" __chain, #_"ClientConnectionManager" __connectionManager]
        (Preconditions/checkNotNull __context)

        (ยง assoc this :params (.. __context (getParams)))
        (ยง assoc this :chain __chain)
        (ยง assoc this :fast-catchup-time-secs (.. (:params this) (getGenesisBlock) (getTimeSeconds)))
        (ยง assoc this :wallets (CopyOnWriteArrayList. #_"<>"))
        (ยง assoc this :peer-filter-providers (CopyOnWriteArrayList. #_"<>"))

        (ยง assoc this :executor (.. this (createPrivateExecutor)))

        ;; This default sentinel value will be overridden by one of two actions:
        ;;   - adding a peer discovery source sets it to the default.
        ;;   - using connectTo() will increment it by one.
        (ยง assoc this :max-connections 0)

        (let [#_"int" __height (if (some? __chain) (.. __chain (getBestChainHeight)) 0)]
            (ยง assoc this :version-message (VersionMessage. (:params this), __height))
            ;; We never request that the remote node wait for a bloom filter yet, as we have no wallets.
            (ยง assoc-in this [:version-message :relay-txes-before-filter] true)

            (ยง assoc this :download-tx-dependency-depth Integer/MAX_VALUE)

            (ยง assoc this :inactives (PriorityQueue. #_"<>" 1, (Comparator. #_"<PeerAddress>")
            (ยง anon
                #_suppress #_[ "FieldAccessNotGuarded" ] ;; Only called when inactives is accessed, and lock is held then.
                #_override
                #_public
                (ยง method #_"int" compare [#_"PeerAddress" __a, #_"PeerAddress" __b]
                    (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))

                    (let [#_"int" __result (.. (:backoff-map this) (get __a) (compareTo (.. (:backoff-map this) (get __b))))]
                        ;; Sort by port if otherwise equals - for testing.
                        (when (== __result 0)
                            (ยง ass __result (Ints/compare (.. __a (getPort)), (.. __b (getPort))))
                        )
                        __result
                    )
                )
            )))
            (ยง assoc this :backoff-map (HashMap. #_"<>"))
            (ยง assoc this :peers (CopyOnWriteArrayList. #_"<>"))
            (ยง assoc this :pending-peers (CopyOnWriteArrayList. #_"<>"))
            (ยง assoc this :channels __connectionManager)
            (ยง assoc this :peer-discoverers (CopyOnWriteArraySet. #_"<>"))
            (ยง assoc this :running-broadcasts (Collections/synchronizedSet (HashSet. #_"<TransactionBroadcast>")))
            (ยง assoc this :bloom-filter-merger (FilterMerger. PeerGroup/DEFAULT_BLOOM_FILTER_FP_RATE))
            (ยง assoc this :v-min-required-protocol-version (.. (:params this) (getProtocolVersionNum NetworkParameters.ProtocolVersion/BLOOM_FILTER)))
            this
        )
    )

    #_private
    (ยง field- #_"CountDownLatch" :executor-startup-latch (CountDownLatch. 1))

    #_protected
    (ยง method #_"ListeningScheduledExecutorService" createPrivateExecutor []
        (let [#_"ListeningScheduledExecutorService" __result (MoreExecutors/listeningDecorator (ScheduledThreadPoolExecutor. 1, (ContextPropagatingThreadFactory. "PeerGroup Thread")))]
            ;; Hack: jam the executor so jobs just queue up until the user calls start() on us.  For example, adding a wallet
            ;; results in a bloom filter recalc being queued, but we don't want to do that until we're actually started.
            (.. __result (execute (Runnable.)
            (ยง anon
                #_override
                #_public
                (ยง method #_"void" run []
                    (Uninterruptibles/awaitUninterruptibly (:executor-startup-latch this))
                    nil
                )
            )))
            __result
        )
    )

    ;;;
     ; This is how many milliseconds we wait for peer discoveries to return their results.
     ;;
    #_public
    (ยง method #_"void" setPeerDiscoveryTimeoutMillis [#_"long" __peerDiscoveryTimeoutMillis]
        (ยง assoc this :v-peer-discovery-timeout-millis __peerDiscoveryTimeoutMillis)
        nil
    )

    ;;;
     ; Adjusts the desired number of connections that we will create to peers.  Note that if there are already peers
     ; open and the new value is lower than the current number of peers, those connections will be terminated.
     ; Likewise if there aren't enough current connections to meet the new requested max size, some will be added.
     ;;
    #_public
    (ยง method #_"void" setMaxConnections [#_"int" __maxConnections]
        (.. (:lock this) (lock))
        (try
            (ยง assoc this :max-connections __maxConnections)
            (when (not (.. this (isRunning)))
                (ยง return nil)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )

        ;; We may now have too many or too few open connections.  Add more or drop some to get to the right amount.
        (let [#_"int" __adjustment (- __maxConnections (.. (:channels this) (getConnectedClientCount)))]
            (when (< 0 __adjustment)
                (.. this (triggerConnections))
            )

            (when (< __adjustment 0)
                (.. (:channels this) (closeConnections (- __adjustment)))
            )
            nil
        )
    )

    ;;;
     ; Configure download of pending transaction dependencies.  A change of values only takes effect for newly connected peers.
     ;;
    #_public
    (ยง method #_"void" setDownloadTxDependencies [#_"int" __depth]
        (.. (:lock this) (lock))
        (try
            (ยง assoc this :download-tx-dependency-depth __depth)
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    #_private
    (ยง field- #_"Runnable" :trigger-connections-job (Runnable.
        (ยง anon
            #_private
            (ยง field- #_"boolean" :first-run true)
            #_private
            #_static
            (ยง def- #_"long" PeerGroup/MIN_PEER_DISCOVERY_INTERVAL 1000)

            #_override
            #_public
            (ยง method #_"void" run []
                (try
                    (.. this (go))
                    (catch Throwable __e
                        (.. PeerGroup/log (error "Exception when trying to build connections", __e)) ;; The executor swallows exceptions :( ;; )
                    )
                )
                nil
            )

            #_public
            (ยง method #_"void" go []
                (when (not (:v-running this))
                    (ยง return nil)
                )

                (let [#_"boolean" __doDiscovery false
                      #_"long" __now (Utils/currentTimeMillis)]
                    (.. (:lock this) (lock))
                    (try
                        ;; First run: try and use a local node if there is one, for the additional security it can provide.
                        ;; But, not on Android as there are none for this platform: it could only be a malicious app trying
                        ;; to hijack our traffic.
                        (when (and (not (Utils/isAndroidRuntime)) (:use-localhost-peer-when-possible this) (.. this (maybeCheckForLocalhostPeer)) (:first-run this))
                            (.. PeerGroup/log (info "Localhost peer detected, trying to use it instead of P2P discovery"))
                            (ยง assoc this :max-connections 0)
                            (.. this (connectToLocalHost))
                            (ยง return nil)
                        )

                        (let [#_"boolean" __havePeerWeCanTry (and (not (.. (:inactives this) (isEmpty))) (<= (.. (:backoff-map this) (get (.. (:inactives this) (peek))) (getRetryTime)) __now))]
                            (ยง ass __doDiscovery (not __havePeerWeCanTry))
                        )
                        (finally
                            (ยง assoc this :first-run false)
                            (.. (:lock this) (unlock))
                        )
                    )

                    ;; Don't hold the lock across discovery as this process can be very slow.
                    (let [#_"boolean" __discoverySuccess false]
                        (when __doDiscovery
                            (try
                                (ยง ass __discoverySuccess (< 0 (.. this (discoverPeers))))
                                (catch PeerDiscoveryException __e
                                    (.. PeerGroup/log (error "Peer discovery failure", __e))
                                )
                            )
                        )

                        (let [#_"long" __retryTime
                              #_"PeerAddress" __addrToTry]
                            (.. (:lock this) (lock))
                            (try
                                (when __doDiscovery
                                    ;; Require that we have enough connections, to consider this a success,
                                    ;; or we just constantly test for new peers.
                                    (if (and __discoverySuccess (<= (.. this (getMaxConnections)) (.. this (countConnectedAndPendingPeers))))
                                        (.. (:group-backoff this) (trackSuccess))
                                        (.. (:group-backoff this) (trackFailure))
                                    )
                                )
                                ;; Inactives is sorted by backoffMap time.
                                (cond (.. (:inactives this) (isEmpty))
                                    (do
                                        (cond (< (.. this (countConnectedAndPendingPeers)) (.. this (getMaxConnections)))
                                            (do
                                                (let [#_"long" __interval (Math/max (- (.. (:group-backoff this) (getRetryTime)) __now), PeerGroup/MIN_PEER_DISCOVERY_INTERVAL)]
                                                    (.. PeerGroup/log (info (str "Peer discovery didn't provide us any more peers, will try again in " __interval "ms.")))
                                                    (.. (:executor this) (schedule this, __interval, TimeUnit/MILLISECONDS))
                                                )
                                            )
                                            :else
                                            (do
                                                ;; We have enough peers and discovery provided no more, so just settle down.
                                                ;; Most likely we were given a fixed set of addresses in some test scenario.
                                            )
                                        )
                                        (ยง return nil)
                                    )
                                    :else
                                    (do
                                        (ยง repeat
                                            (ยง ass __addrToTry (.. (:inactives this) (poll)))
                                            (ยง again (and (:ipv6-unreachable this) (instance? Inet6Address (.. __addrToTry (getAddr)))))
                                        )
                                        (ยง ass __retryTime (.. (:backoff-map this) (get __addrToTry) (getRetryTime)))
                                    )
                                )
                                (ยง ass __retryTime (Math/max __retryTime, (.. (:group-backoff this) (getRetryTime))))
                                (when (< __now __retryTime)
                                    (let [#_"long" __delay (- __retryTime __now)]
                                        (.. PeerGroup/log (info "Waiting {} msec before next connect attempt {}", __delay, (if (some? __addrToTry) (str "to " __addrToTry) "")))
                                        (.. (:inactives this) (add __addrToTry))
                                        (.. (:executor this) (schedule this, __delay, TimeUnit/MILLISECONDS))
                                        (ยง return nil)
                                    )
                                )
                                (.. this (connectTo __addrToTry, false, (:v-connect-timeout-millis this)))
                                (finally
                                    (.. (:lock this) (unlock))
                                )
                            )
                            (when (< (.. this (countConnectedAndPendingPeers)) (.. this (getMaxConnections)))
                                (.. (:executor this) (execute this)) ;; Try next peer immediately.
                            )
                            nil
                        )
                    )
                )
            )
        )))

    #_private
    (ยง method- #_"void" triggerConnections []
        ;; Run on a background thread due to the need to potentially retry and back off in the background.
        (when (not (.. (:executor this) (isShutdown)))
            (.. (:executor this) (execute (:trigger-connections-job this)))
        )
        nil
    )

    ;;; The maximum number of connections that we will create to peers. ;;
    #_public
    (ยง method #_"int" getMaxConnections []
        (.. (:lock this) (lock))
        (try
            (:max-connections this)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_private
    (ยง method- #_"List<Message>" handleGetData [#_"GetDataMessage" __m]
        ;; Scans the wallets and memory pool for transactions in the getdata message and returns them.
        ;; Runs on peer threads.
        (.. (:lock this) (lock))
        (try
            (let [#_"LinkedList<Message>" __transactions (LinkedList. #_"<>")
                  #_"LinkedList<InventoryItem>" __items (LinkedList. #_"<>" (.. __m (getItems)))
                  #_"Iterator<InventoryItem>" __it (.. __items (iterator))]
                (while (.. __it (hasNext))
                    (let [#_"InventoryItem" __item (.. __it (next))]
                        ;; Check the wallets.
                        (doseq [#_"Wallet" __w (:wallets this)]
                            (let [#_"Transaction" __tx (.. __w (getTransaction (:hash __item)))]
                                (when (some? __tx)
                                    (.. __transactions (add __tx))
                                    (.. __it (remove))
                                    (ยง break )
                                )
                            )
                        )
                    )
                )
                (ยง return __transactions)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Sets the {@link VersionMessage} that will be announced on newly created connections.  A version message is
     ; primarily interesting because it lets you customize the "subVer" field which is used a bit like the User-Agent
     ; field from HTTP.  It means your client tells the other side what it is, see
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki">BIP 14</a>.
     ;
     ; The VersionMessage you provide is copied and the best chain height/time filled in for each new connection,
     ; therefore you don't have to worry about setting that.  The provided object is really more of a template.
     ;;
    #_public
    (ยง method #_"void" setVersionMessage [#_"VersionMessage" __ver]
        (.. (:lock this) (lock))
        (try
            (ยง assoc this :version-message __ver)
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Returns the version message provided by setVersionMessage or a default if none was given.
     ;;
    #_public
    (ยง method #_"VersionMessage" getVersionMessage []
        (.. (:lock this) (lock))
        (try
            (:version-message this)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Sets information that identifies this software to remote nodes.  This is a convenience wrapper for creating
     ; a new {@link VersionMessage}, calling {@link VersionMessage#appendToSubVer(String, String, String)} on it,
     ; and then calling {@link PeerGroup#setVersionMessage(VersionMessage)} on the result of that.  See the docs for
     ; {@link VersionMessage#appendToSubVer(String, String, String)} for information on what the fields should contain.
     ;;
    #_public
    (ยง method #_"void" setUserAgent [#_"String" __name, #_"String" __version, #_nilable #_"String" __comments]
        ;; TODO: Check that height is needed here (it wasnt, but it should be, no?)
        (let [#_"int" __height (if (some? (:chain this)) (.. (:chain this) (getBestChainHeight)) 0)
              #_"VersionMessage" __ver (VersionMessage. (:params this), __height)]
            (ยง assoc __ver :relay-txes-before-filter false)
            (.. this (updateVersionMessageRelayTxesBeforeFilter __ver))
            (.. __ver (appendToSubVer __name, __version, __comments))
            (.. this (setVersionMessage __ver))
            nil
        )
    )

    ;; Updates the relayTxesBeforeFilter flag of ver.
    #_private
    (ยง method- #_"void" updateVersionMessageRelayTxesBeforeFilter [#_"VersionMessage" __ver]
        ;; We will provide the remote node with a bloom filter (i.e. they shouldn't relay yet)
        ;; if chain == null || !chain.shouldVerifyTransactions() and a wallet is added and bloom filters are enabled.
        ;; Note that the default here means that no tx invs will be received if no wallet is ever added.
        (.. (:lock this) (lock))
        (try
            (let [#_"boolean" __spvMode (and (some? (:chain this)) (not (.. (:chain this) (shouldVerifyTransactions))))
                  #_"boolean" __willSendFilter (and __spvMode (< 0 (.. (:peer-filter-providers this) (size))) (:v-bloom-filtering-enabled this))]
                (ยง assoc __ver :relay-txes-before-filter (not __willSendFilter))
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Sets information that identifies this software to remote nodes.  This is a convenience wrapper for creating
     ; a new {@link VersionMessage}, calling {@link VersionMessage#appendToSubVer(String, String, String)} on it,
     ; and then calling {@link PeerGroup#setVersionMessage(VersionMessage)} on the result of that.  See the docs for
     ; {@link VersionMessage#appendToSubVer(String, String, String)} for information on what the fields should contain.
     ;;
    #_public
    (ยง method #_"void" setUserAgent [#_"String" __name, #_"String" __version]
        (.. this (setUserAgent __name, __version, nil))
        nil
    )

    ;;; See {@link Peer#addBlocksDownloadedEventListener(BlocksDownloadedEventListener)}. ;;
    #_public
    (ยง method #_"void" addBlocksDownloadedEventListener [#_"BlocksDownloadedEventListener" __listener]
        (.. this (addBlocksDownloadedEventListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; blocks are downloaded by the download peer.</p>
     ; @see Peer#addBlocksDownloadedEventListener(Executor, BlocksDownloadedEventListener)
     ;;
    #_public
    (ยง method #_"void" addBlocksDownloadedEventListener [#_"Executor" __executor, #_"BlocksDownloadedEventListener" __listener]
        (.. (:peers-blocks-downloaded-event-listeners this) (add (ListenerRegistration. #_"<>" (Preconditions/checkNotNull __listener), __executor)))
        (doseq [#_"Peer" __peer (.. this (getConnectedPeers))]
            (.. __peer (addBlocksDownloadedEventListener __executor, __listener))
        )
        (doseq [#_"Peer" __peer (.. this (getPendingPeers))]
            (.. __peer (addBlocksDownloadedEventListener __executor, __listener))
        )
        nil
    )

    ;;; See {@link Peer#addBlocksDownloadedEventListener(BlocksDownloadedEventListener)}. ;;
    #_public
    (ยง method #_"void" addChainDownloadStartedEventListener [#_"ChainDownloadStartedEventListener" __listener]
        (.. this (addChainDownloadStartedEventListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; chain download starts.</p>
     ;;
    #_public
    (ยง method #_"void" addChainDownloadStartedEventListener [#_"Executor" __executor, #_"ChainDownloadStartedEventListener" __listener]
        (.. (:peers-chain-download-started-event-listeners this) (add (ListenerRegistration. #_"<>" (Preconditions/checkNotNull __listener), __executor)))
        (doseq [#_"Peer" __peer (.. this (getConnectedPeers))]
            (.. __peer (addChainDownloadStartedEventListener __executor, __listener))
        )
        (doseq [#_"Peer" __peer (.. this (getPendingPeers))]
            (.. __peer (addChainDownloadStartedEventListener __executor, __listener))
        )
        nil
    )

    ;;; See {@link Peer#addConnectedEventListener(PeerConnectedEventListener)}. ;;
    #_public
    (ยง method #_"void" addConnectedEventListener [#_"PeerConnectedEventListener" __listener]
        (.. this (addConnectedEventListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; new peers are connected to.</p>
     ;;
    #_public
    (ยง method #_"void" addConnectedEventListener [#_"Executor" __executor, #_"PeerConnectedEventListener" __listener]
        (.. (:peer-connected-event-listeners this) (add (ListenerRegistration. #_"<>" (Preconditions/checkNotNull __listener), __executor)))
        (doseq [#_"Peer" __peer (.. this (getConnectedPeers))]
            (.. __peer (addConnectedEventListener __executor, __listener))
        )
        (doseq [#_"Peer" __peer (.. this (getPendingPeers))]
            (.. __peer (addConnectedEventListener __executor, __listener))
        )
        nil
    )

    ;;; See {@link Peer#addDisconnectedEventListener(PeerDisconnectedEventListener)}. ;;
    #_public
    (ยง method #_"void" addDisconnectedEventListener [#_"PeerDisconnectedEventListener" __listener]
        (.. this (addDisconnectedEventListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; peers are disconnected from.</p>
     ;;
    #_public
    (ยง method #_"void" addDisconnectedEventListener [#_"Executor" __executor, #_"PeerDisconnectedEventListener" __listener]
        (.. (:peer-disconnected-event-listeners this) (add (ListenerRegistration. #_"<>" (Preconditions/checkNotNull __listener), __executor)))
        (doseq [#_"Peer" __peer (.. this (getConnectedPeers))]
            (.. __peer (addDisconnectedEventListener __executor, __listener))
        )
        (doseq [#_"Peer" __peer (.. this (getPendingPeers))]
            (.. __peer (addDisconnectedEventListener __executor, __listener))
        )
        nil
    )

    ;;; See {@link Peer#addDiscoveredEventListener(PeerDiscoveredEventListener)}. ;;
    #_public
    (ยง method #_"void" addDiscoveredEventListener [#_"PeerDiscoveredEventListener" __listener]
        (.. this (addDiscoveredEventListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when new
     ; peers are discovered.</p>
     ;;
    #_public
    (ยง method #_"void" addDiscoveredEventListener [#_"Executor" __executor, #_"PeerDiscoveredEventListener" __listener]
        (.. (:peer-discovered-event-listeners this) (add (ListenerRegistration. #_"<>" (Preconditions/checkNotNull __listener), __executor)))
        nil
    )

    ;;; See {@link Peer#addGetDataEventListener(GetDataEventListener)}. ;;
    #_public
    (ยง method #_"void" addGetDataEventListener [#_"GetDataEventListener" __listener]
        (.. this (addGetDataEventListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;; See {@link Peer#addGetDataEventListener(Executor, GetDataEventListener)}. ;;
    #_public
    (ยง method #_"void" addGetDataEventListener [#_"Executor" __executor, #_"GetDataEventListener" __listener]
        (.. (:peer-get-data-event-listeners this) (add (ListenerRegistration. #_"<>" (Preconditions/checkNotNull __listener), __executor)))
        (doseq [#_"Peer" __peer (.. this (getConnectedPeers))]
            (.. __peer (addGetDataEventListener __executor, __listener))
        )
        (doseq [#_"Peer" __peer (.. this (getPendingPeers))]
            (.. __peer (addGetDataEventListener __executor, __listener))
        )
        nil
    )

    ;;; See {@link Peer#addOnTransactionBroadcastListener(OnTransactionBroadcastListener)}. ;;
    #_public
    (ยง method #_"void" addOnTransactionBroadcastListener [#_"OnTransactionBroadcastListener" __listener]
        (.. this (addOnTransactionBroadcastListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;; See {@link Peer#addOnTransactionBroadcastListener(OnTransactionBroadcastListener)}. ;;
    #_public
    (ยง method #_"void" addOnTransactionBroadcastListener [#_"Executor" __executor, #_"OnTransactionBroadcastListener" __listener]
        (.. (:peers-transaction-broadast-event-listeners this) (add (ListenerRegistration. #_"<>" (Preconditions/checkNotNull __listener), __executor)))
        (doseq [#_"Peer" __peer (.. this (getConnectedPeers))]
            (.. __peer (addOnTransactionBroadcastListener __executor, __listener))
        )
        (doseq [#_"Peer" __peer (.. this (getPendingPeers))]
            (.. __peer (addOnTransactionBroadcastListener __executor, __listener))
        )
        nil
    )

    ;;; See {@link Peer#addPreMessageReceivedEventListener(PreMessageReceivedEventListener)}. ;;
    #_public
    (ยง method #_"void" addPreMessageReceivedEventListener [#_"PreMessageReceivedEventListener" __listener]
        (.. this (addPreMessageReceivedEventListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;; See {@link Peer#addPreMessageReceivedEventListener(Executor, PreMessageReceivedEventListener)}. ;;
    #_public
    (ยง method #_"void" addPreMessageReceivedEventListener [#_"Executor" __executor, #_"PreMessageReceivedEventListener" __listener]
        (.. (:peers-pre-message-received-event-listeners this) (add (ListenerRegistration. #_"<>" (Preconditions/checkNotNull __listener), __executor)))
        (doseq [#_"Peer" __peer (.. this (getConnectedPeers))]
            (.. __peer (addPreMessageReceivedEventListener __executor, __listener))
        )
        (doseq [#_"Peer" __peer (.. this (getPendingPeers))]
            (.. __peer (addPreMessageReceivedEventListener __executor, __listener))
        )
        nil
    )

    #_public
    (ยง method #_"boolean" removeBlocksDownloadedEventListener [#_"BlocksDownloadedEventListener" __listener]
        (let [#_"boolean" __result (ListenerRegistration/removeFromList __listener, (:peers-blocks-downloaded-event-listeners this))]
            (doseq [#_"Peer" __peer (.. this (getConnectedPeers))]
                (.. __peer (removeBlocksDownloadedEventListener __listener))
            )
            (doseq [#_"Peer" __peer (.. this (getPendingPeers))]
                (.. __peer (removeBlocksDownloadedEventListener __listener))
            )
            __result
        )
    )

    #_public
    (ยง method #_"boolean" removeChainDownloadStartedEventListener [#_"ChainDownloadStartedEventListener" __listener]
        (let [#_"boolean" __result (ListenerRegistration/removeFromList __listener, (:peers-chain-download-started-event-listeners this))]
            (doseq [#_"Peer" __peer (.. this (getConnectedPeers))]
                (.. __peer (removeChainDownloadStartedEventListener __listener))
            )
            (doseq [#_"Peer" __peer (.. this (getPendingPeers))]
                (.. __peer (removeChainDownloadStartedEventListener __listener))
            )
            __result
        )
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (ยง method #_"boolean" removeConnectedEventListener [#_"PeerConnectedEventListener" __listener]
        (let [#_"boolean" __result (ListenerRegistration/removeFromList __listener, (:peer-connected-event-listeners this))]
            (doseq [#_"Peer" __peer (.. this (getConnectedPeers))]
                (.. __peer (removeConnectedEventListener __listener))
            )
            (doseq [#_"Peer" __peer (.. this (getPendingPeers))]
                (.. __peer (removeConnectedEventListener __listener))
            )
            __result
        )
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (ยง method #_"boolean" removeDisconnectedEventListener [#_"PeerDisconnectedEventListener" __listener]
        (let [#_"boolean" __result (ListenerRegistration/removeFromList __listener, (:peer-disconnected-event-listeners this))]
            (doseq [#_"Peer" __peer (.. this (getConnectedPeers))]
                (.. __peer (removeDisconnectedEventListener __listener))
            )
            (doseq [#_"Peer" __peer (.. this (getPendingPeers))]
                (.. __peer (removeDisconnectedEventListener __listener))
            )
            __result
        )
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (ยง method #_"boolean" removeDiscoveredEventListener [#_"PeerDiscoveredEventListener" __listener]
        (let [#_"boolean" __result (ListenerRegistration/removeFromList __listener, (:peer-discovered-event-listeners this))]
            __result
        )
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (ยง method #_"boolean" removeGetDataEventListener [#_"GetDataEventListener" __listener]
        (let [#_"boolean" __result (ListenerRegistration/removeFromList __listener, (:peer-get-data-event-listeners this))]
            (doseq [#_"Peer" __peer (.. this (getConnectedPeers))]
                (.. __peer (removeGetDataEventListener __listener))
            )
            (doseq [#_"Peer" __peer (.. this (getPendingPeers))]
                (.. __peer (removeGetDataEventListener __listener))
            )
            __result
        )
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (ยง method #_"boolean" removeOnTransactionBroadcastListener [#_"OnTransactionBroadcastListener" __listener]
        (let [#_"boolean" __result (ListenerRegistration/removeFromList __listener, (:peers-transaction-broadast-event-listeners this))]
            (doseq [#_"Peer" __peer (.. this (getConnectedPeers))]
                (.. __peer (removeOnTransactionBroadcastListener __listener))
            )
            (doseq [#_"Peer" __peer (.. this (getPendingPeers))]
                (.. __peer (removeOnTransactionBroadcastListener __listener))
            )
            __result
        )
    )

    #_public
    (ยง method #_"boolean" removePreMessageReceivedEventListener [#_"PreMessageReceivedEventListener" __listener]
        (let [#_"boolean" __result (ListenerRegistration/removeFromList __listener, (:peers-pre-message-received-event-listeners this))]
            (doseq [#_"Peer" __peer (.. this (getConnectedPeers))]
                (.. __peer (removePreMessageReceivedEventListener __listener))
            )
            (doseq [#_"Peer" __peer (.. this (getPendingPeers))]
                (.. __peer (removePreMessageReceivedEventListener __listener))
            )
            __result
        )
    )

    ;;;
     ; Returns a newly allocated list containing the currently connected peers.
     ; If all you care about is the count, use numConnectedPeers().
     ;;
    #_public
    (ยง method #_"List<Peer>" getConnectedPeers []
        (.. (:lock this) (lock))
        (try
            (ArrayList. #_"<>" (:peers this))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns a list containing Peers that did not complete connection yet.
     ;;
    #_public
    (ยง method #_"List<Peer>" getPendingPeers []
        (.. (:lock this) (lock))
        (try
            (ArrayList. #_"<>" (:pending-peers this))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Add an address to the list of potential peers to connect to.  It won't necessarily be used unless there's a need
     ; to build new connections to reach the max connection count.
     ;
     ; @param peerAddress IP/port to use.
     ;;
    #_public
    (ยง method #_"void" addAddress [#_"PeerAddress" __peerAddress]
        (let [#_"int" __newMax]
            (.. (:lock this) (lock))
            (try
                (.. this (addInactive __peerAddress))
                (ยง ass __newMax (inc (.. this (getMaxConnections))))
                (finally
                    (.. (:lock this) (unlock))
                )
            )
            (.. this (setMaxConnections __newMax))
            nil
        )
    )

    #_private
    (ยง method- #_"void" addInactive [#_"PeerAddress" __peerAddress]
        (.. (:lock this) (lock))
        (try
            ;; Deduplicate.
            (when (.. (:backoff-map this) (containsKey __peerAddress))
                (ยง return nil)
            )
            (.. (:backoff-map this) (put __peerAddress, (ExponentialBackoff. (:peer-backoff-params this))))
            (.. (:inactives this) (offer __peerAddress))
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Convenience for connecting only to peers that can serve specific services.
     ; It will configure suitable peer discoveries.
     ; @param requiredServices Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     ;;
    #_public
    (ยง method #_"void" setRequiredServices [#_"long" __requiredServices]
        (.. (:lock this) (lock))
        (try
            (ยง assoc this :required-services __requiredServices)
            (.. (:peer-discoverers this) (clear))
            (.. this (addPeerDiscovery (MultiplexingDiscovery/forServices (:params this), __requiredServices)))
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;; Convenience method for addAddress(PeerAddress.(address, params.port)). ;;
    #_public
    (ยง method #_"void" addAddress [#_"InetAddress" __address]
        (.. this (addAddress (PeerAddress. (:params this), __address, (.. (:params this) (getPort)))))
        nil
    )

    ;;;
     ; Add addresses from a discovery source to the list of potential peers to connect to.
     ; If max connections has not been configured, or set to zero, then it's set to the default at this point.
     ;;
    #_public
    (ยง method #_"void" addPeerDiscovery [#_"PeerDiscovery" __peerDiscovery]
        (.. (:lock this) (lock))
        (try
            (when (== (.. this (getMaxConnections)) 0)
                (.. this (setMaxConnections PeerGroup/DEFAULT_CONNECTIONS))
            )
            (.. (:peer-discoverers this) (add __peerDiscovery))
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;; Returns number of discovered peers. ;;
    #_protected
    #_throws #_[ "PeerDiscoveryException" ]
    (ยง method #_"int" discoverPeers []
        ;; Don't hold the lock whilst doing peer discovery: it can take a long time and cause high API latency.
        (Preconditions/checkState (not (.. (:lock this) (isHeldByCurrentThread))))

        (let [#_"int" __maxPeersToDiscoverCount (:v-max-peers-to-discover-count this)
              #_"long" __peerDiscoveryTimeoutMillis (:v-peer-discovery-timeout-millis this)
              #_"Stopwatch" __watch (Stopwatch/createStarted)
              #_"List<PeerAddress>" __addressList (Lists/newLinkedList)]

            (doseq [#_"PeerDiscovery" __peerDiscovery (:peer-discoverers this)] ;; COW
                (let [#_"InetSocketAddress[]" __addresses (.. __peerDiscovery (getPeers (:required-services this), __peerDiscoveryTimeoutMillis, TimeUnit/MILLISECONDS))]
                    (doseq [#_"InetSocketAddress" __address __addresses]
                        (.. __addressList (add (PeerAddress. (:params this), __address)))
                    )
                    (when (<= __maxPeersToDiscoverCount (.. __addressList (size)))
                        (ยง break )
                    )
                )
            )

            (when (not (.. __addressList (isEmpty)))
                (doseq [#_"PeerAddress" __address __addressList]
                    (.. this (addInactive __address))
                )

                (let [#_"ImmutableSet<PeerAddress>" __peersDiscoveredSet (ImmutableSet/copyOf __addressList)]
                    (doseq [#_"ListenerRegistration<PeerDiscoveredEventListener>" __registration (:peer-discovered-event-listeners this)] ;; COW
                        (.. (:executor __registration) (execute (Runnable.)
                        (ยง anon
                            #_override
                            #_public
                            (ยง method #_"void" run []
                                (.. (:listener __registration) (onPeersDiscovered __peersDiscoveredSet))
                                nil
                            )
                        )))
                    )
                )
            )
            (.. __watch (stop))
            (.. PeerGroup/log (info "Peer discovery took {} and returned {} items", __watch, (.. __addressList (size))))
            (.. __addressList (size))
        )
    )

    #_testing
    (ยง method #_"void" waitForJobQueue []
        (Futures/getUnchecked (.. (:executor this) (submit (Runnables/doNothing))))
        nil
    )

    #_private
    (ยง method- #_"int" countConnectedAndPendingPeers []
        (.. (:lock this) (lock))
        (try
            (+ (.. (:peers this) (size)) (.. (:pending-peers this) (size)))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_private
    (ยง enum- PeerGroup.LocalhostCheckState
        (ยง item NOT_TRIED)
        (ยง item FOUND)
        (ยง item FOUND_AND_CONNECTED)
        (ยง item NOT_THERE)
    )
    #_private
    (ยง field- #_"PeerGroup.LocalhostCheckState" :localhost-check-state PeerGroup.LocalhostCheckState/NOT_TRIED)

    #_private
    (ยง method- #_"boolean" maybeCheckForLocalhostPeer []
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))

        (when (== (:localhost-check-state this) PeerGroup.LocalhostCheckState/NOT_TRIED)
            ;; Do a fast blocking connect to see if anything is listening.
            (let [#_"Socket" __socket nil]
                (try
                    (ยง ass __socket (Socket.))
                    (.. __socket (connect (InetSocketAddress. (InetAddresses/forString "127.0.0.1"), (.. (:params this) (getPort))), (:v-connect-timeout-millis this)))
                    (ยง assoc this :localhost-check-state PeerGroup.LocalhostCheckState/FOUND)
                    (ยง return true)
                    (catch IOException __e
                        (.. PeerGroup/log (info "Localhost peer not detected."))
                        (ยง assoc this :localhost-check-state PeerGroup.LocalhostCheckState/NOT_THERE)
                    )
                    (finally
                        (when (some? __socket)
                            (try
                                (.. __socket (close))
                                (catch IOException _
                                    ;; Ignore.
                                )
                            )
                        )
                    )
                )
            )
        )
        false
    )

    ;;;
     ; Starts the PeerGroup and begins network activity.
     ; @return A future that completes when first connection activity has been triggered (note: not first connection made).
     ;;
    #_public
    (ยง method #_"ListenableFuture" startAsync []
        ;; This is run in a background thread by the Service implementation.
        (when (nil? (:chain this))
            ;; Just try to help catch what might be a programming error.
            (.. PeerGroup/log (warn "Starting up with no attached block chain. Did you forget to pass one to the constructor?"))
        )
        (Preconditions/checkState (not (:v-used-up this)), "Cannot start a peer group twice")

        (ยง assoc this :v-running true)
        (ยง assoc this :v-used-up true)
        (.. (:executor-startup-latch this) (countDown))

        ;; We do blocking waits during startup, so run on the executor thread.
        (ยง return (.. (:executor this) (submit (Runnable.)
        (ยง anon
            #_override
            #_public
            (ยง method #_"void" run []
                (try
                    (.. PeerGroup/log (info "Starting ..."))
                    (.. (:channels this) (startAsync))
                    (.. (:channels this) (awaitRunning))
                    (.. this (triggerConnections))
                    (.. this (setupPinging))
                    (catch Throwable __e
                        (.. PeerGroup/log (error "Exception when starting up", __e)) ;; The executor swallows exceptions :( ;; )
                    )
                )
                nil
            )
        ))))
    )

    ;;; Does a blocking startup. ;;
    #_public
    (ยง method #_"void" start []
        (Futures/getUnchecked (.. this (startAsync)))
        nil
    )

    ;;; Can just use start() for a blocking start here instead of startAsync/awaitRunning: PeerGroup is no longer a Guava service. ;;
    #_deprecated
    #_public
    (ยง method #_"void" awaitRunning []
        (.. this (waitForJobQueue))
        nil
    )

    #_public
    (ยง method #_"ListenableFuture" stopAsync []
        (Preconditions/checkState (:v-running this))
        (ยง assoc this :v-running false)
        (let [#_"ListenableFuture" __future (.. (:executor this) (submit (Runnable.)
            (ยง anon
                #_override
                #_public
                (ยง method #_"void" run []
                    (try
                        (.. PeerGroup/log (info "Stopping ..."))
                        ;; Blocking close of all sockets.
                        (.. (:channels this) (stopAsync))
                        (.. (:channels this) (awaitTerminated))
                        (doseq [#_"PeerDiscovery" __peerDiscovery (:peer-discoverers this)]
                            (.. __peerDiscovery (shutdown))
                        )
                        (ยง assoc this :v-running false)
                        (.. PeerGroup/log (info "Stopped."))
                        (catch Throwable __e
                            (.. PeerGroup/log (error "Exception when shutting down", __e)) ;; The executor swallows exceptions :( ;; )
                        )
                    )
                    nil
                )
            )))]
            (.. (:executor this) (shutdown))
            (:future this)
        )
    )

    ;;; Does a blocking stop. ;;
    #_public
    (ยง method #_"void" stop []
        (try
            (.. this (stopAsync))
            (.. PeerGroup/log (info "Awaiting PeerGroup shutdown ..."))
            (.. (:executor this) (awaitTermination Long/MAX_VALUE, TimeUnit/SECONDS))
            (catch InterruptedException __e
                (throw (RuntimeException. __e))
            )
        )
        nil
    )

    ;;; Can just use stop() here instead of stopAsync/awaitTerminated: PeerGroup is no longer a Guava service. ;;
    #_deprecated
    #_public
    (ยง method #_"void" awaitTerminated []
        (try
            (.. (:executor this) (awaitTermination Long/MAX_VALUE, TimeUnit/SECONDS))
            (catch InterruptedException __e
                (throw (RuntimeException. __e))
            )
        )
        nil
    )

    ;;;
     ; <p>Link the given wallet to this PeerGroup.  This is used for three purposes:</p>
     ;
     ; <ol>
     ;   <li>So the wallet receives broadcast transactions.</li>
     ;   <li>Announcing pending transactions that didn't get into the chain yet to our peers.</li>
     ;   <li>Set the fast catchup time using {@link PeerGroup#setFastCatchupTimeSecs(long)} to optimize chain download.</li>
     ; </ol>
     ;
     ; <p>Note that this should be done before chain download commences because if you add a wallet with keys earlier
     ; than the current chain head, the relevant parts of the chain won't be redownloaded for you.</p>
     ;
     ; <p>The Wallet will have an event listener registered on it, so to avoid leaks remember to use
     ; {@link PeerGroup#removeWallet(Wallet)} on it if you wish to keep the Wallet but lose the PeerGroup.</p>
     ;;
    #_public
    (ยง method #_"void" addWallet [#_"Wallet" __wallet]
        (.. (:lock this) (lock))
        (try
            (Preconditions/checkNotNull __wallet)
            (Preconditions/checkState (not (.. (:wallets this) (contains __wallet))))
            (.. (:wallets this) (add __wallet))
            (.. __wallet (setTransactionBroadcaster this))
            (.. __wallet (addCoinsReceivedEventListener Threading/SAME_THREAD, (:wallet-coins-received-event-listener this)))
            (.. __wallet (addKeyChainEventListener Threading/SAME_THREAD, (:wallet-key-event-listener this)))
            (.. this (addPeerFilterProvider __wallet))
            (doseq [#_"Peer" __peer (:peers this)]
                (.. __peer (addWallet __wallet))
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; <p>Link the given PeerFilterProvider to this PeerGroup.
     ; DO NOT use this for Wallets, use {@link PeerGroup#addWallet(Wallet)} instead.</p>
     ;
     ; <p>Note that this should be done before chain download commences because if you add a listener with keys earlier
     ; than the current chain head, the relevant parts of the chain won't be redownloaded for you.</p>
     ;
     ; <p>This method invokes {@link PeerGroup#recalculateFastCatchupAndFilter(FilterRecalculateMode)}.
     ; The return value of this method is the <code>ListenableFuture</code> returned by that invocation.</p>
     ;
     ; @return a future that completes once each <code>Peer</code> in this group has had its <code>BloomFilter</code> (re)set.
     ;;
    #_public
    (ยง method #_"ListenableFuture<BloomFilter>" addPeerFilterProvider [#_"PeerFilterProvider" __provider]
        (.. (:lock this) (lock))
        (try
            (Preconditions/checkNotNull __provider)
            (Preconditions/checkState (not (.. (:peer-filter-providers this) (contains __provider))))
            ;; Insert provider at the start.  This avoids various concurrency problems that could occur because we need
            ;; all providers to be in a consistent, unchanging state whilst the filter is built.  Providers can give
            ;; this guarantee by taking a lock in their begin method, but if we add to the end of the list here, it
            ;; means we establish a lock ordering a > b > c if that's the order the providers were added in.  Given that
            ;; the main wallet will usually be first, this establishes an ordering wallet > other-provider, which means
            ;; other-provider can then not call into the wallet itself.  Other providers installed by the API user should
            ;; come first so the expected ordering is preserved.  This can also manifest itself in providers that use
            ;; synchronous RPCs into an actor instead of locking, but the same issue applies.
            (.. (:peer-filter-providers this) (add 0, __provider))

            ;; Don't bother downloading block bodies before the oldest keys in all our wallets.  Make sure we recalculate
            ;; if a key is added.  Of course, by then we may have downloaded the chain already.  Ideally adding keys would
            ;; automatically rewind the block chain and redownload the blocks to find transactions relevant to those keys,
            ;; all transparently and in the background.  But we are a long way from that yet.
            (let [#_"ListenableFuture<BloomFilter>" __future (.. this (recalculateFastCatchupAndFilter PeerGroup.FilterRecalculateMode/SEND_IF_CHANGED))]
                (.. this (updateVersionMessageRelayTxesBeforeFilter (.. this (getVersionMessage))))
                (ยง return __future)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Opposite of {@link #addPeerFilterProvider(PeerFilterProvider)}.  Again, don't use this for wallets.  Does not
     ; trigger recalculation of the filter.
     ;;
    #_public
    (ยง method #_"void" removePeerFilterProvider [#_"PeerFilterProvider" __provider]
        (.. (:lock this) (lock))
        (try
            (Preconditions/checkNotNull __provider)
            (Preconditions/checkArgument (.. (:peer-filter-providers this) (remove __provider)))
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Unlinks the given wallet so it no longer receives broadcast transactions or has its transactions announced.
     ;;
    #_public
    (ยง method #_"void" removeWallet [#_"Wallet" __wallet]
        (.. (:wallets this) (remove (Preconditions/checkNotNull __wallet)))
        (.. (:peer-filter-providers this) (remove __wallet))
        (.. __wallet (removeCoinsReceivedEventListener (:wallet-coins-received-event-listener this)))
        (.. __wallet (removeKeyChainEventListener (:wallet-key-event-listener this)))
        (.. __wallet (setTransactionBroadcaster nil))
        (doseq [#_"Peer" __peer (:peers this)]
            (.. __peer (removeWallet __wallet))
        )
        nil
    )

    #_public
    (ยง enum PeerGroup.FilterRecalculateMode
        (ยง item SEND_IF_CHANGED)
        (ยง item FORCE_SEND_FOR_REFRESH)
        (ยง item DONT_SEND)
    )

    #_private
    (ยง field- #_"Map<PeerGroup.FilterRecalculateMode, SettableFuture<BloomFilter>>" :in-flight-recalculations (Maps/newHashMap))

    ;;;
     ; Recalculates the bloom filter given to peers as well as the timestamp after which full blocks are downloaded
     ; (instead of only headers).  Note that calls made one after another may return the same future, if the request
     ; wasn't processed yet (i.e. calls are deduplicated).
     ;
     ; @param mode In what situations to send the filter to connected peers.
     ; @return A future that completes once the filter has been calculated (note: this does not mean acknowledged by remote peers).
     ;;
    #_public
    (ยง method #_"ListenableFuture<BloomFilter>" recalculateFastCatchupAndFilter [#_"PeerGroup.FilterRecalculateMode" __mode]
        (let [#_"SettableFuture<BloomFilter>" __future (SettableFuture/create)]
            (ยง sync (:in-flight-recalculations this)
                (when (some? (.. (:in-flight-recalculations this) (get __mode)))
                    (ยง return (.. (:in-flight-recalculations this) (get __mode)))
                )

                (.. (:in-flight-recalculations this) (put __mode, __future))
            )
            (let [#_"Runnable" __command (Runnable.)
                (ยง anon
                    #_override
                    #_public
                    (ยง method #_"void" run []
                        (try
                            (.. this (go))
                            (catch Throwable __e
                                (.. PeerGroup/log (error "Exception when trying to recalculate Bloom filter", __e)) ;; The executor swallows exceptions :( ;; )
                            )
                        )
                        nil
                    )

                    #_public
                    (ยง method #_"void" go []
                        (Preconditions/checkState (not (.. (:lock this) (isHeldByCurrentThread))))
                        ;; Fully verifying mode doesn't use this optimization (it can't as it needs to see all transactions).
                        (when (or (and (some? (:chain this)) (.. (:chain this) (shouldVerifyTransactions))) (not (:v-bloom-filtering-enabled this)))
                            (ยง return nil)
                        )

                        ;; We only ever call bloomFilterMerger.calculate on jobQueue, so we cannot be calculating two filters at once.
                        (let [#_"FilterMerger.Result" __result (.. (:bloom-filter-merger this) (calculate (ImmutableList/copyOf (:peer-filter-providers this))))] ;; COW
                            (let [#_"boolean" __send
                                    (condp == __mode
                                        SEND_IF_CHANGED        (:changed __result)
                                        DONT_SEND              false
                                        FORCE_SEND_FOR_REFRESH true
                                        (throw (UnsupportedOperationException.))
                                    )]
                                (when __send
                                    (doseq [#_"Peer" __peer (:peers this)] ;; COW
                                        ;; Only query the mempool if this recalculation request is not in order to lower the observed FP
                                        ;; rate.  There's no point querying the mempool when doing this because the FP rate can only go
                                        ;; down, and we will have seen all the relevant txns before: it's pointless to ask for them again.
                                        (.. __peer (setBloomFilter (:filter __result), (!= __mode PeerGroup.FilterRecalculateMode/FORCE_SEND_FOR_REFRESH)))
                                    )
                                    ;; Reset the false positive estimate so that we don't send a flood of filter updates
                                    ;; if the estimate temporarily overshoots our threshold.
                                    (when (some? (:chain this))
                                        (.. (:chain this) (resetFalsePositiveEstimate))
                                    )
                                )
                                ;; Do this last so that bloomFilter is already set when it gets called.
                                (.. this (setFastCatchupTimeSecs (:earliest-key-time-secs __result)))
                                (ยง sync (:in-flight-recalculations this)
                                    (.. (:in-flight-recalculations this) (put __mode, nil))
                                )
                                (.. __future (set (:filter __result)))
                                nil
                            )
                        )
                    )
                )]
                (try
                    (.. (:executor this) (execute (.. this __command)))
                    (catch RejectedExecutionException _
                        ;; Can happen during shutdown.
                    )
                )
            )
            __future
        )
    )

    ;;;
     ; <p>Sets the false positive rate of bloom filters given to peers.  The default is {@link #DEFAULT_BLOOM_FILTER_FP_RATE}.</p>
     ;
     ; <p>Be careful regenerating the bloom filter too often, as it decreases anonymity because remote nodes can
     ; compare transactions against both the new and old filters to significantly decrease the false positive rate.</p>
     ;
     ; <p>See the docs for {@link BloomFilter#BloomFilter(int, double, long, BloomFilter.BloomUpdate)} for a brief
     ; explanation of anonymity when using bloom filters.</p>
     ;;
    #_public
    (ยง method #_"void" setBloomFilterFalsePositiveRate [#_"double" __bloomFilterFPRate]
        (.. (:lock this) (lock))
        (try
            (.. (:bloom-filter-merger this) (setBloomFilterFPRate __bloomFilterFPRate))
            (.. this (recalculateFastCatchupAndFilter PeerGroup.FilterRecalculateMode/SEND_IF_CHANGED))
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Returns the number of currently connected peers.  To be informed when this count changes, register a
     ; {@link org.bitcoinj.core.listeners.PeerConnectedEventListener}/{@link org.bitcoinj.core.listeners.PeerDisconnectedEventListener}
     ; and use the onPeerConnected/onPeerDisconnected methods.
     ;;
    #_public
    (ยง method #_"int" numConnectedPeers []
        (.. (:peers this) (size))
    )

    ;;;
     ; Connect to a peer by creating a channel to the destination address.  This should not be
     ; used normally - let the PeerGroup manage connections through {@link #start()}.
     ;
     ; @param address Destination IP and port.
     ; @return The newly created Peer object or null if the peer could not be connected.
     ;         Use {@link org.bitcoinj.core.Peer#getConnectionOpenFuture()} if you
     ;         want a future which completes when the connection is open.
     ;;
    #_nilable
    #_public
    (ยง method #_"Peer" connectTo [#_"InetSocketAddress" __address]
        (.. (:lock this) (lock))
        (try
            (let [#_"PeerAddress" __peerAddress (PeerAddress. (:params this), __address)]
                (.. (:backoff-map this) (put __peerAddress, (ExponentialBackoff. (:peer-backoff-params this))))
                (ยง return (.. this (connectTo __peerAddress, true, (:v-connect-timeout-millis this))))
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Helper for forcing a connection to localhost.  Useful when using test mode.  Returns the peer object.
     ;;
    #_nilable
    #_public
    (ยง method #_"Peer" connectToLocalHost []
        (.. (:lock this) (lock))
        (try
            (let [#_"PeerAddress" __localhost (PeerAddress/localhost (:params this))]
                (.. (:backoff-map this) (put __localhost, (ExponentialBackoff. (:peer-backoff-params this))))
                (ยง return (.. this (connectTo __localhost, true, (:v-connect-timeout-millis this))))
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Creates a version message to send, constructs a Peer object and attempts to connect it.
     ; Returns the peer on success or null on failure.
     ; @param address Remote network address.
     ; @param incrementMaxConnections Whether to consider this connection an attempt to fill our quota, or something explicitly requested.
     ; @return Peer or null.
     ;;
    #_nilable
    #_protected
    (ยง method #_"Peer" connectTo [#_"PeerAddress" __address, #_"boolean" __incrementMaxConnections, #_"int" __connectTimeoutMillis]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))
        (let [#_"VersionMessage" __ver (.. this (getVersionMessage) (duplicate))]
            (ยง assoc __ver :best-height (if (some? (:chain this)) (.. (:chain this) (getBestChainHeight)) 0))
            (ยง assoc __ver :time (Utils/currentTimeSeconds))

            (let [#_"Peer" __peer (.. this (createPeer __address, __ver))]
                (.. __peer (addConnectedEventListener Threading/SAME_THREAD, (:startup-listener this)))
                (.. __peer (addDisconnectedEventListener Threading/SAME_THREAD, (:startup-listener this)))
                (.. __peer (setMinProtocolVersion (:v-min-required-protocol-version this)))
                (.. (:pending-peers this) (add __peer))

                (try
                    (.. PeerGroup/log (info "Attempting connection to {}     ({} connected, {} pending, {} max)", __address, (.. (:peers this) (size)), (.. (:pending-peers this) (size)), (:max-connections this)))
                    (let [#_"ListenableFuture<SocketAddress>" __future (.. (:channels this) (openConnection (.. __address (toSocketAddress)), __peer))]
                        (when (.. __future (isDone))
                            (Uninterruptibles/getUninterruptibly __future)
                        )
                    )
                    (catch ExecutionException __e
                        (let [#_"Throwable" __cause (Throwables/getRootCause __e)]
                            (.. PeerGroup/log (warn (str "Failed to connect to " __address ": " (.. __cause (getMessage)))))
                            (.. this (handlePeerDeath __peer, __cause))
                            (ยง return nil)
                        )
                    )
                )
                (.. __peer (setSocketTimeout __connectTimeoutMillis))
                ;; When the channel has connected and version negotiated successfully, handleNewPeer will end up being called
                ;; on a worker thread.
                (when __incrementMaxConnections
                    ;; We don't use setMaxConnections here as that would trigger a recursive attempt to establish a new
                    ;; outbound connection.
                    (ยง assoc this :max-connections (inc (:max-connections this)))
                )
                __peer
            )
        )
    )

    ;;; You can override this to customise the creation of {@link Peer} objects. ;;
    #_protected
    (ยง method #_"Peer" createPeer [#_"PeerAddress" __address, #_"VersionMessage" __ver]
        (Peer. (:params this), __ver, __address, (:chain this), (:download-tx-dependency-depth this))
    )

    ;;;
     ; Sets the timeout between when a connection attempt to a peer begins and when the version message exchange completes.
     ; This does not apply to currently pending peers.
     ;;
    #_public
    (ยง method #_"void" setConnectTimeoutMillis [#_"int" __connectTimeoutMillis]
        (ยง assoc this :v-connect-timeout-millis __connectTimeoutMillis)
        nil
    )

    ;;;
     ; <p>Start downloading the blockchain from the first available peer.</p>
     ;
     ; <p>If no peers are currently connected, the download will be started once a peer starts.  If the peer dies,
     ; the download will resume with another peer.</p>
     ;
     ; @param listener A listener for chain download events, may not be null.
     ;;
    #_public
    (ยง method #_"void" startBlockChainDownload [#_"PeerDataEventListener" __listener]
        (.. (:lock this) (lock))
        (try
            (when (some? (:download-peer this))
                (when (some? (:download-listener this))
                    (PeerGroup/removeDataEventListenerFromPeer (:download-peer this), (:download-listener this))
                )
                (when (some? __listener)
                    (PeerGroup/addDataEventListenerToPeer Threading/USER_THREAD, (:download-peer this), __listener)
                )
            )
            (ยง assoc this :download-listener __listener)
            ;; TODO: Be more nuanced about which peer to download from.  We can also try
            ;; downloading from multiple peers and handle the case when a new peer comes along
            ;; with a longer chain after we thought we were done.
            (when (not (.. (:peers this) (isEmpty)))
                (.. this (startBlockChainDownloadFromPeer (.. (:peers this) (iterator) (next)))) ;; Will add the new download listener.
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Register a data event listener against a single peer (i.e. for blockchain download).
     ; Handling registration/deregistration on peer death/add is outside the scope of these methods.
     ;;
    #_private
    #_static
    (ยง defn- #_"void" PeerGroup/addDataEventListenerToPeer [#_"Executor" __executor, #_"Peer" __peer, #_"PeerDataEventListener" __downloadListener]
        (.. __peer (addBlocksDownloadedEventListener __executor, __downloadListener))
        (.. __peer (addChainDownloadStartedEventListener __executor, __downloadListener))
        (.. __peer (addGetDataEventListener __executor, __downloadListener))
        (.. __peer (addPreMessageReceivedEventListener __executor, __downloadListener))
        nil
    )

    ;;;
     ; Remove a registered data event listener against a single peer (i.e. for blockchain download).
     ; Handling registration/deregistration on peer death/add is outside the scope of these methods.
     ;;
    #_private
    #_static
    (ยง defn- #_"void" PeerGroup/removeDataEventListenerFromPeer [#_"Peer" __peer, #_"PeerDataEventListener" __listener]
        (.. __peer (removeBlocksDownloadedEventListener __listener))
        (.. __peer (removeChainDownloadStartedEventListener __listener))
        (.. __peer (removeGetDataEventListener __listener))
        (.. __peer (removePreMessageReceivedEventListener __listener))
        nil
    )

    ;;;
     ; Download the blockchain from peers.  Convenience that uses a {@link DownloadProgressTracker} for you.
     ;
     ; This method waits until the download is complete.  "Complete" is defined as downloading
     ; from at least one peer all the blocks that are in that peer's inventory.
     ;;
    #_public
    (ยง method #_"void" downloadBlockChain []
        (let [#_"DownloadProgressTracker" __listener (DownloadProgressTracker.)]
            (.. this (startBlockChainDownload __listener))
            (try
                (.. __listener (await))
                (catch InterruptedException __e
                    (throw (RuntimeException. __e))
                )
            )
            nil
        )
    )

    #_protected
    (ยง method #_"void" handleNewPeer [#_"Peer" __peer]
        (let [#_"int" __newSize -1]
            (.. (:lock this) (lock))
            (try
                (.. (:group-backoff this) (trackSuccess))
                (.. (:backoff-map this) (get (.. __peer (getAddress))) (trackSuccess))

                ;; Sets up the newly connected peer so it can do everything it needs to.
                (.. (:pending-peers this) (remove __peer))
                (.. (:peers this) (add __peer))
                (ยง ass __newSize (.. (:peers this) (size)))
                (.. PeerGroup/log (info "{}: New peer      ({} connected, {} pending, {} max)", __peer, __newSize, (.. (:pending-peers this) (size)), (:max-connections this)))
                ;; Give the peer a filter that can be used to probabilistically drop transactions that
                ;; aren't relevant to our wallet.  We may still receive some false positives, which is
                ;; OK because it helps improve wallet privacy.  Old nodes will just ignore the message.
                (when (some? (.. (:bloom-filter-merger this) (getLastFilter)))
                    (.. __peer (setBloomFilter (.. (:bloom-filter-merger this) (getLastFilter))))
                )
                (.. __peer (setDownloadData false))
                ;; TODO: The peer should calculate the fast catchup time from the added wallets here.
                (doseq [#_"Wallet" __wallet (:wallets this)]
                    (.. __peer (addWallet __wallet))
                )
                (when (nil? (:download-peer this))
                    ;; Kick off chain download if we aren't already doing it.
                    (.. this (setDownloadPeer (.. this (selectDownloadPeer (:peers this)))))
                    (let [#_"boolean" __shouldDownloadChain (and (some? (:download-listener this)) (some? (:chain this)))]
                        (when __shouldDownloadChain
                            (.. this (startBlockChainDownloadFromPeer (:download-peer this)))
                        )
                    )
                )
                ;; Make sure the peer knows how to upload transactions that are requested from us.
                (.. __peer (addBlocksDownloadedEventListener Threading/SAME_THREAD, (:peer-listener this)))
                (.. __peer (addGetDataEventListener Threading/SAME_THREAD, (:peer-listener this)))

                ;; And set up event listeners for clients.  This will allow them to find out about new transactions and blocks.
                (doseq [#_"ListenerRegistration<BlocksDownloadedEventListener>" __registration (:peers-blocks-downloaded-event-listeners this)]
                    (.. __peer (addBlocksDownloadedEventListener (:executor __registration), (:listener __registration)))
                )
                (doseq [#_"ListenerRegistration<ChainDownloadStartedEventListener>" __registration (:peers-chain-download-started-event-listeners this)]
                    (.. __peer (addChainDownloadStartedEventListener (:executor __registration), (:listener __registration)))
                )
                (doseq [#_"ListenerRegistration<PeerConnectedEventListener>" __registration (:peer-connected-event-listeners this)]
                    (.. __peer (addConnectedEventListener (:executor __registration), (:listener __registration)))
                )

                ;; We intentionally do not add disconnect listeners to peers.
                (doseq [#_"ListenerRegistration<GetDataEventListener>" __registration (:peer-get-data-event-listeners this)]
                    (.. __peer (addGetDataEventListener (:executor __registration), (:listener __registration)))
                )
                (doseq [#_"ListenerRegistration<OnTransactionBroadcastListener>" __registration (:peers-transaction-broadast-event-listeners this)]
                    (.. __peer (addOnTransactionBroadcastListener (:executor __registration), (:listener __registration)))
                )
                (doseq [#_"ListenerRegistration<PreMessageReceivedEventListener>" __registration (:peers-pre-message-received-event-listeners this)]
                    (.. __peer (addPreMessageReceivedEventListener (:executor __registration), (:listener __registration)))
                )
                (finally
                    (.. (:lock this) (unlock))
                )
            )

            (let [#_"int" __fNewSize __newSize]
                (doseq [#_"ListenerRegistration<PeerConnectedEventListener>" __registration (:peer-connected-event-listeners this)]
                    (.. (:executor __registration) (execute (Runnable.)
                    (ยง anon
                        #_override
                        #_public
                        (ยง method #_"void" run []
                            (.. (:listener __registration) (onPeerConnected __peer, __fNewSize))
                            nil
                        )
                    )))
                )
                nil
            )
        )
    )

    #_nilable
    #_private
    #_volatile
    (ยง field- #_"ListenableScheduledFuture<?>" :v-ping-task)

    #_suppress #_[ "NonAtomicOperationOnVolatileField" ]
    #_private
    (ยง method- #_"void" setupPinging []
        (when (<= (.. this (getPingIntervalMsec)) 0)
            (ยง return nil) ;; Disabled.
        )

        (ยง assoc this :v-ping-task (.. (:executor this) (scheduleAtFixedRate (Runnable.)
        (ยง anon
            #_override
            #_public
            (ยง method #_"void" run []
                (try
                    (when (<= (.. this (getPingIntervalMsec)) 0)
                        (let [#_"ListenableScheduledFuture<?>" __task (:v-ping-task this)]
                            (when (some? __task)
                                (.. __task (cancel false))
                                (ยง assoc this :v-ping-task nil)
                            )
                            (ยง return nil) ;; Disabled.
                        )
                    )
                    (doseq [#_"Peer" __peer (.. this (getConnectedPeers))]
                        (when (< (:client-version (.. __peer (getPeerVersionMessage))) (.. (:params this) (getProtocolVersionNum NetworkParameters.ProtocolVersion/PONG)))
                            (ยง continue )
                        )
                        (.. __peer (ping))
                    )
                    (catch Throwable __e
                        (.. PeerGroup/log (error "Exception in ping loop", __e)) ;; The executor swallows exceptions :( ;; )
                    )
                )
                nil
            )
        ), (.. this (getPingIntervalMsec)), (.. this (getPingIntervalMsec)), TimeUnit/MILLISECONDS)))
        nil
    )

    #_private
    (ยง method- #_"void" setDownloadPeer [#_nilable #_"Peer" __peer]
        (.. (:lock this) (lock))
        (try
            (when (== (:download-peer this) __peer)
                (ยง return nil)
            )
            (when (some? (:download-peer this))
                (.. PeerGroup/log (info "Unsetting download peer: {}", (:download-peer this)))
                (when (some? (:download-listener this))
                    (PeerGroup/removeDataEventListenerFromPeer (:download-peer this), (:download-listener this))
                )
                (.. (:download-peer this) (setDownloadData false))
            )
            (ยง assoc this :download-peer __peer)
            (when (some? (:download-peer this))
                (.. PeerGroup/log (info "Setting download peer: {}", (:download-peer this)))
                (when (some? (:download-listener this))
                    (PeerGroup/addDataEventListenerToPeer Threading/SAME_THREAD, __peer, (:download-listener this))
                )
                (.. (:download-peer this) (setDownloadData true))
                (when (some? (:chain this))
                    (.. (:download-peer this) (setDownloadParameters (:fast-catchup-time-secs this), (some? (.. (:bloom-filter-merger this) (getLastFilter)))))
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Tells the PeerGroup to download only block headers before a certain time and bodies after that.
     ; Call this before starting block chain download.
     ; Do not use a time > NOW - 1 block, as it will break some block download logic.
     ;;
    #_public
    (ยง method #_"void" setFastCatchupTimeSecs [#_"long" __secondsSinceEpoch]
        (.. (:lock this) (lock))
        (try
            (Preconditions/checkState (or (nil? (:chain this)) (not (.. (:chain this) (shouldVerifyTransactions)))), "Fast catchup is incompatible with fully verifying")

            (ยง assoc this :fast-catchup-time-secs __secondsSinceEpoch)
            (when (some? (:download-peer this))
                (.. (:download-peer this) (setDownloadParameters __secondsSinceEpoch, (some? (.. (:bloom-filter-merger this) (getLastFilter)))))
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Returns the current fast catchup time.  The contents of blocks before this time won't be downloaded as they
     ; cannot contain any interesting transactions.  If you use {@link PeerGroup#addWallet(Wallet)} this just returns
     ; the min of the wallets earliest key times.
     ; @return a time in seconds since the epoch.
     ;;
    #_public
    (ยง method #_"long" getFastCatchupTimeSecs []
        (.. (:lock this) (lock))
        (try
            (:fast-catchup-time-secs this)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_protected
    (ยง method #_"void" handlePeerDeath [#_"Peer" __peer, #_nilable #_"Throwable" __exception]
        ;; Peer deaths can occur during startup if a connect attempt after peer discovery aborts immediately.
        (when (not (.. this (isRunning)))
            (ยง return nil)
        )

        (let [#_"int" __numPeers
              #_"int" __numConnectedPeers 0]
            (.. (:lock this) (lock))
            (try
                (.. (:pending-peers this) (remove __peer))
                (.. (:peers this) (remove __peer))

                (let [#_"PeerAddress" __address (.. __peer (getAddress))]

                    (.. PeerGroup/log (info "{}: Peer died      ({} connected, {} pending, {} max)", __address, (.. (:peers this) (size)), (.. (:pending-peers this) (size)), (:max-connections this)))
                    (when (== __peer (:download-peer this))
                        (.. PeerGroup/log (info "Download peer died. Picking a new one."))
                        (.. this (setDownloadPeer nil))
                        ;; Pick a new one and possibly tell it to download the chain.
                        (let [#_"Peer" __newDownloadPeer (.. this (selectDownloadPeer (:peers this)))]
                            (when (some? __newDownloadPeer)
                                (.. this (setDownloadPeer __newDownloadPeer))
                                (when (some? (:download-listener this))
                                    (.. this (startBlockChainDownloadFromPeer __newDownloadPeer))
                                )
                            )
                        )
                    )
                    (ยง ass __numPeers (+ (.. (:peers this) (size)) (.. (:pending-peers this) (size))))
                    (ยง ass __numConnectedPeers (.. (:peers this) (size)))

                    (.. (:group-backoff this) (trackFailure))

                    (cond (instance? NoRouteToHostException __exception)
                        (do
                            (when (and (instance? Inet6Address (.. __address (getAddr))) (not (:ipv6-unreachable this)))
                                (ยง assoc this :ipv6-unreachable true)
                                (.. PeerGroup/log (warn "IPv6 peer connect failed due to routing failure, ignoring IPv6 addresses from now on"))
                            )
                        )
                        :else
                        (do
                            (.. (:backoff-map this) (get __address) (trackFailure))
                            ;; Put back on inactive list.
                            (.. (:inactives this) (offer __address))
                        )
                    )

                    (when (< __numPeers (.. this (getMaxConnections)))
                        (.. this (triggerConnections))
                    )
                )
                (finally
                    (.. (:lock this) (unlock))
                )
            )

            (.. __peer (removeBlocksDownloadedEventListener (:peer-listener this)))
            (.. __peer (removeGetDataEventListener (:peer-listener this)))
            (doseq [#_"Wallet" __wallet (:wallets this)]
                (.. __peer (removeWallet __wallet))
            )

            (let [#_"int" __fNumConnectedPeers __numConnectedPeers]

                (doseq [#_"ListenerRegistration<BlocksDownloadedEventListener>" __registration (:peers-blocks-downloaded-event-listeners this)]
                    (.. __peer (removeBlocksDownloadedEventListener (:listener __registration)))
                )
                (doseq [#_"ListenerRegistration<ChainDownloadStartedEventListener>" __registration (:peers-chain-download-started-event-listeners this)]
                    (.. __peer (removeChainDownloadStartedEventListener (:listener __registration)))
                )
                (doseq [#_"ListenerRegistration<GetDataEventListener>" __registration (:peer-get-data-event-listeners this)]
                    (.. __peer (removeGetDataEventListener (:listener __registration)))
                )
                (doseq [#_"ListenerRegistration<PreMessageReceivedEventListener>" __registration (:peers-pre-message-received-event-listeners this)]
                    (.. __peer (removePreMessageReceivedEventListener (:listener __registration)))
                )
                (doseq [#_"ListenerRegistration<OnTransactionBroadcastListener>" __registration (:peers-transaction-broadast-event-listeners this)]
                    (.. __peer (removeOnTransactionBroadcastListener (:listener __registration)))
                )

                (doseq [#_"ListenerRegistration<PeerDisconnectedEventListener>" __registration (:peer-disconnected-event-listeners this)]
                    (.. (:executor __registration) (execute (Runnable.)
                    (ยง anon
                        #_override
                        #_public
                        (ยง method #_"void" run []
                            (.. (:listener __registration) (onPeerDisconnected __peer, __fNumConnectedPeers))
                            nil
                        )
                    )))
                    (.. __peer (removeDisconnectedEventListener (:listener __registration)))
                )
                nil
            )
        )
    )

    #_private
    (ยง field- #_"int" :stall-period-seconds 10)
    #_private
    (ยง field- #_"int" :stall-min-speed-bytes-sec (* Block/HEADER_SIZE 20))

    ;;;
     ; Configures the stall speed: the speed at which a peer is considered to be serving us the block chain
     ; unacceptably slowly.  Once a peer has served us data slower than the given data rate for the given
     ; number of seconds, it is considered stalled and will be disconnected, forcing the chain download to continue
     ; from a different peer.  The defaults are chosen conservatively, but if you are running on a platform that is
     ; CPU constrained or on a very slow network e.g. EDGE, the default settings may need adjustment to
     ; avoid false stalls.
     ;
     ; @param periodSecs How many seconds the download speed must be below blocksPerSec, defaults to 10.
     ; @param bytesPerSecond Download speed (only blocks/txns count) must be consistently below this for a stall, defaults to the bandwidth required for 20 block headers per second.
     ;;
    #_public
    (ยง method #_"void" setStallThreshold [#_"int" __periodSecs, #_"int" __bytesPerSecond]
        (.. (:lock this) (lock))
        (try
            (ยง assoc this :stall-period-seconds __periodSecs)
            (ยง assoc this :stall-min-speed-bytes-sec __bytesPerSecond)
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    #_private
    (ยง class- PeerGroup.ChainDownloadSpeedCalculator (ยง implements BlocksDownloadedEventListener, Runnable)
        #_private
        (ยง field- #_"int" :blocks-in-last-second)
        #_private
        (ยง field- #_"int" :txns-in-last-second)
        #_private
        (ยง field- #_"int" :orig-txns-in-last-second)
        #_private
        (ยง field- #_"long" :bytes-in-last-second)

        ;; If we take more stalls than this, we assume we're on some kind of terminally slow network and the
        ;; stall threshold just isn't set properly.  We give up on stall disconnects after that.
        #_private
        (ยง field- #_"int" :max-stalls 3)

        ;; How many seconds the peer has until we start measuring its speed.
        #_private
        (ยง field- #_"int" :warmup-seconds -1)

        ;; Used to calculate a moving average.
        #_private
        (ยง field- #_"long[]" :samples)
        #_private
        (ยง field- #_"int" :cursor)

        #_private
        (ยง field- #_"boolean" :sync-done)

        #_override
        #_public
        #_synchronized
        (ยง method #_"void" onBlocksDownloaded [#_"Peer" __peer, #_"Block" __block, #_nilable #_"FilteredBlock" __filteredBlock, #_"int" __blocksLeft]
            (ยง assoc this :blocks-in-last-second (inc (:blocks-in-last-second this)))
            (ยง assoc this :bytes-in-last-second (+ (:bytes-in-last-second this) Block/HEADER_SIZE))
            (let [#_"List<Transaction>" __blockTransactions (.. __block (getTransactions))]
                ;; This whole area of the type hierarchy is a mess.
                (let [#_"int" __txCount (+ (if (some? __blockTransactions) (.. this (countAndMeasureSize __blockTransactions)) 0) (if (some? __filteredBlock) (.. this (countAndMeasureSize (.. __filteredBlock (getAssociatedTransactions) (values)))) 0))]
                    (ยง assoc this :txns-in-last-second (+ (:txns-in-last-second this) __txCount))
                    (when (some? __filteredBlock)
                        (ยง assoc this :orig-txns-in-last-second (+ (:orig-txns-in-last-second this) (.. __filteredBlock (getTransactionCount))))
                    )
                    nil
                )
            )
        )

        #_private
        (ยง method- #_"int" countAndMeasureSize [#_"Collection<Transaction>" __transactions]
            (doseq [#_"Transaction" __transaction __transactions]
                (ยง assoc this :bytes-in-last-second (+ (:bytes-in-last-second this) (.. __transaction (getMessageSize))))
            )
            (.. __transactions (size))
        )

        #_override
        #_public
        (ยง method #_"void" run []
            (try
                (.. this (calculate))
                (catch Throwable __e
                    (.. PeerGroup/log (error "Error in speed calculator", __e))
                )
            )
            nil
        )

        #_private
        (ยง method- #_"void" calculate []
            (let [#_"int" __minSpeedBytesPerSec
                  #_"int" __period]

                (.. (:lock this) (lock))
                (try
                    (ยง ass __minSpeedBytesPerSec (:stall-min-speed-bytes-sec this))
                    (ยง ass __period (:stall-period-seconds this))
                    (finally
                        (.. (:lock this) (unlock))
                    )
                )

                (ยง sync this
                    (when (or (nil? (:samples this)) (!= (.. (:samples this) (alength)) __period))
                        (ยง assoc this :samples (long-array __period))
                        ;; *2 because otherwise a single low sample could cause an immediate disconnect which is too harsh.
                        (Arrays/fill (:samples this), (* __minSpeedBytesPerSec 2))
                        (ยง assoc this :warmup-seconds 15)
                    )

                    (let [#_"boolean" __behindPeers (and (some? (:chain this)) (< (.. (:chain this) (getBestChainHeight)) (PeerGroup/getMostCommonChainHeight)))]
                        (when (not __behindPeers)
                            (ยง assoc this :sync-done true)
                        )
                        (when (not (:sync-done this))
                            (cond (< (:warmup-seconds this) 0)
                                (do
                                    ;; Calculate the moving average.
                                    (aset (:samples this) (:cursor this) (:bytes-in-last-second this))
                                    (ยง assoc this :cursor (inc (:cursor this)))
                                    (when (== (:cursor this) (.. (:samples this) (alength)))
                                        (ยง assoc this :cursor 0)
                                    )
                                    (let [#_"long" __average 0]
                                        (doseq [#_"long" __sample (:samples this)]
                                            (ยง ass __average (+ __average __sample))
                                        )
                                        (ยง ass __average (/ __average (.. (:samples this) (alength))))

                                        (.. PeerGroup/log (info (String/format Locale/US, "%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, avg/last %.2f/%.2f kilobytes per sec (stall threshold <%.2f KB/sec for %d seconds)", (:blocks-in-last-second this), (:txns-in-last-second this), (:orig-txns-in-last-second this), (/ __average 1024.0), (/ (:bytes-in-last-second this) 1024.0), (/ __minSpeedBytesPerSec 1024.0), (.. (:samples this) (alength)))))

                                        (when (and (< __average __minSpeedBytesPerSec) (< 0 (:max-stalls this)))
                                            (ยง assoc this :max-stalls (dec (:max-stalls this)))
                                            (cond (== (:max-stalls this) 0)
                                                (do
                                                    ;; We could consider starting to drop the Bloom filtering FP rate at this point, because
                                                    ;; we tried a bunch of peers and no matter what we don't seem to be able to go any faster.
                                                    ;; This implies we're bandwidth bottlenecked and might want to start using bandwidth
                                                    ;; more effectively.  Of course if there's a MITM that is deliberately throttling us,
                                                    ;; this is a good way to make us take away all the FPs from our Bloom filters ... but
                                                    ;; as they don't give us a whole lot of privacy either way that's not inherently a big
                                                    ;; deal.
                                                    (.. PeerGroup/log (warn "This network seems to be slower than the requested stall threshold - won't do stall disconnects any more."))
                                                )
                                                :else
                                                (do
                                                    (let [#_"Peer" __peer (.. this (getDownloadPeer))]
                                                        (.. PeerGroup/log (warn (String/format Locale/US, "Chain download stalled: received %.2f KB/sec for %d seconds, require average of %.2f KB/sec, disconnecting %s", (/ __average 1024.0), (.. (:samples this) (alength)), (/ __minSpeedBytesPerSec 1024.0), __peer)))
                                                        (.. __peer (close))
                                                        ;; Reset the sample buffer and give the next peer time to get going.
                                                        (ยง assoc this :samples nil)
                                                        (ยง assoc this :warmup-seconds __period)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                                :else
                                (do
                                    (ยง assoc this :warmup-seconds (dec (:warmup-seconds this)))
                                    (when (< 0 (:bytes-in-last-second this))
                                        (.. PeerGroup/log (info (String/format Locale/US, "%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, last %.2f kilobytes per sec", (:blocks-in-last-second this), (:txns-in-last-second this), (:orig-txns-in-last-second this), (/ (:bytes-in-last-second this) 1024.0))))
                                    )
                                )
                            )
                        )
                        (ยง assoc this :blocks-in-last-second 0)
                        (ยง assoc this :txns-in-last-second 0)
                        (ยง assoc this :orig-txns-in-last-second 0)
                        (ยง assoc this :bytes-in-last-second 0)
                    )
                )
                nil
            )
        )
    )
    #_nilable
    #_private
    (ยง field- #_"PeerGroup.ChainDownloadSpeedCalculator" :chain-download-speed-calculator)

    #_private
    (ยง method- #_"void" startBlockChainDownloadFromPeer [#_"Peer" __peer]
        (.. (:lock this) (lock))
        (try
            (.. this (setDownloadPeer __peer))

            (when (nil? (:chain-download-speed-calculator this))
                ;; Every second, run the calculator which will log how fast we are downloading the chain.
                (ยง assoc this :chain-download-speed-calculator (PeerGroup.ChainDownloadSpeedCalculator.))
                (.. (:executor this) (scheduleAtFixedRate (:chain-download-speed-calculator this), 1, 1, TimeUnit/SECONDS))
            )
            (.. __peer (addBlocksDownloadedEventListener Threading/SAME_THREAD, (:chain-download-speed-calculator this)))

            ;; startBlockChainDownload will setDownloadData(true) on itself automatically.
            (.. __peer (startBlockChainDownload))
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Returns a future that is triggered when the number of connected peers is equal to the given number of peers.
     ; By using this with {@link org.bitcoinj.core.PeerGroup#getMaxConnections()} you can wait until the
     ; network is fully online.  To block immediately, just call get() on the result.  Just calls
     ; {@link #waitForPeersOfVersion(int, long)} with zero as the protocol version.
     ;
     ; @param numPeers How many peers to wait for.
     ; @return a future that will be triggered when the number of connected peers >= numPeers.
     ;;
    #_public
    (ยง method #_"ListenableFuture<List<Peer>>" waitForPeers [#_"int" __numPeers]
        (.. this (waitForPeersOfVersion __numPeers, 0))
    )

    ;;;
     ; Returns a future that is triggered when there are at least the requested number of connected peers that support
     ; the given protocol version or higher.  To block immediately, just call get() on the result.
     ;
     ; @param numPeers How many peers to wait for.
     ; @param protocolVersion The protocol version the awaited peers must implement (or better).
     ; @return a future that will be triggered when the number of connected peers implementing protocolVersion or higher >= numPeers.
     ;;
    #_public
    (ยง method #_"ListenableFuture<List<Peer>>" waitForPeersOfVersion [#_"int" __numPeers, #_"long" __protocolVersion]
        (let [#_"List<Peer>" __foundPeers (.. this (findPeersOfAtLeastVersion __protocolVersion))]
            (when (<= __numPeers (.. __foundPeers (size)))
                (ยง return (Futures/immediateFuture __foundPeers))
            )

            (let [#_"SettableFuture<List<Peer>>" __future (SettableFuture/create)]
                (.. this (addConnectedEventListener (PeerConnectedEventListener.)
                (ยง anon
                    #_override
                    #_public
                    (ยง method #_"void" onPeerConnected [#_"Peer" __peer, #_"int" __peerCount]
                        (let [#_"List<Peer>" __peers (.. this (findPeersOfAtLeastVersion __protocolVersion))]
                            (when (<= __numPeers (.. __peers (size)))
                                (.. __future (set __peers))
                                (.. this (removeConnectedEventListener this))
                            )
                            nil
                        )
                    )
                )))
                __future
            )
        )
    )

    ;;;
     ; Returns an array list of peers that implement the given protocol version or better.
     ;;
    #_public
    (ยง method #_"List<Peer>" findPeersOfAtLeastVersion [#_"long" __protocolVersion]
        (.. (:lock this) (lock))
        (try
            (let [#_"ArrayList<Peer>" __results (ArrayList. #_"<Peer>" (.. (:peers this) (size)))]
                (doseq [#_"Peer" __peer (:peers this)]
                    (when (<= __protocolVersion (:client-version (.. __peer (getPeerVersionMessage))))
                        (.. __results (add __peer))
                    )
                )
                (ยง return __results)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns a future that is triggered when there are at least the requested number of connected peers that support
     ; the given protocol version or higher.  To block immediately, just call get() on the result.
     ;
     ; @param numPeers How many peers to wait for.
     ; @param mask An integer representing a bit mask that will be ANDed with the peers advertised service masks.
     ; @return a future that will be triggered when the number of connected peers implementing protocolVersion or higher >= numPeers.
     ;;
    #_public
    (ยง method #_"ListenableFuture<List<Peer>>" waitForPeersWithServiceMask [#_"int" __numPeers, #_"int" __mask]
        (.. (:lock this) (lock))
        (try
            (let [#_"List<Peer>" __foundPeers (.. this (findPeersWithServiceMask __mask))]
                (when (<= __numPeers (.. __foundPeers (size)))
                    (ยง return (Futures/immediateFuture __foundPeers))
                )

                (let [#_"SettableFuture<List<Peer>>" __future (SettableFuture/create)]
                    (.. this (addConnectedEventListener (PeerConnectedEventListener.)
                    (ยง anon
                        #_override
                        #_public
                        (ยง method #_"void" onPeerConnected [#_"Peer" __peer, #_"int" __peerCount]
                            (let [#_"List<Peer>" __peers (.. this (findPeersWithServiceMask __mask))]
                                (when (<= __numPeers (.. __peers (size)))
                                    (.. __future (set __peers))
                                    (.. this (removeConnectedEventListener this))
                                )
                                nil
                            )
                        )
                    )))
                    (ยง return __future)
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns an array list of peers that match the requested service bit mask.
     ;;
    #_public
    (ยง method #_"List<Peer>" findPeersWithServiceMask [#_"int" __mask]
        (.. (:lock this) (lock))
        (try
            (let [#_"ArrayList<Peer>" __results (ArrayList. #_"<Peer>" (.. (:peers this) (size)))]
                (doseq [#_"Peer" __peer (:peers this)]
                    (when (== (& (:local-services (.. __peer (getPeerVersionMessage))) __mask) __mask)
                        (.. __results (add __peer))
                    )
                )
                (ยง return __results)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns the number of connections that are required before transactions will be broadcast.  If there aren't
     ; enough, {@link PeerGroup#broadcastTransaction(Transaction)} will wait until the minimum number is reached so
     ; propagation across the network can be observed.  If no value has been set using
     ; {@link PeerGroup#setMinBroadcastConnections(int)} a default of 80% of whatever
     ; {@link org.bitcoinj.core.PeerGroup#getMaxConnections()} returns is used.
     ;;
    #_public
    (ยง method #_"int" getMinBroadcastConnections []
        (.. (:lock this) (lock))
        (try
            (when (== (:min-broadcast-connections this) 0)
                (let [#_"int" __max (.. this (getMaxConnections))]
                    (if (<= __max 1)
                        (ยง return __max)
                        (ยง return (int (Math/round (* (.. this (getMaxConnections)) 0.8))))
                    )
                )
            )
            (:min-broadcast-connections this)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; See {@link org.bitcoinj.core.PeerGroup#getMinBroadcastConnections()}.
     ;;
    #_public
    (ยง method #_"void" setMinBroadcastConnections [#_"int" __value]
        (.. (:lock this) (lock))
        (try
            (ยง assoc this :min-broadcast-connections __value)
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Calls {@link PeerGroup#broadcastTransaction(Transaction, int)} with getMinBroadcastConnections() as the number
     ; of connections to wait for before commencing broadcast.
     ;;
    #_override
    #_public
    (ยง method #_"TransactionBroadcast" broadcastTransaction [#_"Transaction" __tx]
        (.. this (broadcastTransaction __tx, (Math/max 1, (.. this (getMinBroadcastConnections)))))
    )

    ;;;
     ; <p>Given a transaction, sends it un-announced to one peer and then waits for it to be received back from
     ; other peers.  Once all connected peers have announced the transaction, the future available via the
     ; {@link org.bitcoinj.core.TransactionBroadcast#future()} method will be completed.  If anything goes
     ; wrong the exception will be thrown when get() is called, or you can receive it via a callback on the
     ; {@link ListenableFuture}.  This method returns immediately, so if you want it to block just call get() on the
     ; result.</p>
     ;
     ; <p>Note that if the PeerGroup is limited to only one connection (discovery is not activated) then the future
     ; will complete as soon as the transaction was successfully written to that peer.</p>
     ;
     ; <p>The transaction won't be sent until there are at least minConnections active connections available.
     ; A good choice for proportion would be between 0.5 and 0.8 but if you want faster transmission during initial
     ; bringup of the peer group you can lower it.</p>
     ;
     ; <p>The returned {@link org.bitcoinj.core.TransactionBroadcast} object can be used to get progress feedback,
     ; which is calculated by watching the transaction propagate across the network and be announced by peers.</p>
     ;;
    #_public
    (ยง method #_"TransactionBroadcast" broadcastTransaction [#_"Transaction" __tx, #_"int" __minConnections]
        ;; If we don't have a record of where this tx came from already, set it to be ourselves so Peer doesn't end up
        ;; redownloading it from the network redundantly.
        (when (.. __tx (getConfidence) (getSource) (equals TransactionConfidence.Source/UNKNOWN))
            (.. PeerGroup/log (info "Transaction source unknown, setting to SELF: {}", (.. __tx (getHashAsString))))
            (.. __tx (getConfidence) (setSource TransactionConfidence.Source/SELF))
        )
        (let [#_"TransactionBroadcast" __broadcast (TransactionBroadcast. this, __tx)]
            (.. __broadcast (setMinConnections __minConnections))
            ;; Send the TX to the wallet once we have a successful broadcast.
            (Futures/addCallback (.. __broadcast (future)), (FutureCallback. #_"<Transaction>")
            (ยง anon
                #_override
                #_public
                (ยง method #_"void" onSuccess [#_"Transaction" __transaction]
                    (.. (:running-broadcasts this) (remove __broadcast))
                    ;; OK, now tell the wallet about the transaction.  If the wallet created the transaction,
                    ;; then it already knows and will ignore this.  If it's a transaction we received from
                    ;; somebody else via a side channel and are now broadcasting, this will put it into the
                    ;; wallet now we know it's valid.
                    (doseq [#_"Wallet" __wallet (:wallets this)]
                        ;; Assumption here is there are no dependencies of the created transaction.
                        ;;
                        ;; We may end up with two threads trying to do this in parallel - the wallet will
                        ;; ignore whichever one loses the race.
                        (try
                            (.. __wallet (receivePending __transaction, nil))
                            (catch VerificationException __e
                                (throw (RuntimeException. __e)) ;; Cannot fail to verify a tx we created ourselves.
                            )
                        )
                    )
                    nil
                )

                #_override
                #_public
                (ยง method #_"void" onFailure [#_"Throwable" __throwable]
                    ;; This can happen if we get a reject message from a peer.
                    (.. (:running-broadcasts this) (remove __broadcast))
                    nil
                )
            ))
            ;; Keep a reference to the TransactionBroadcast object.  This is important because otherwise, the entire tree
            ;; of objects we just created would become garbage if the user doesn't hold on to the returned future, and
            ;; eventually be collected.  This in turn could result in the transaction not being committed to the wallet
            ;; at all.
            (.. (:running-broadcasts this) (add __broadcast))
            (.. __broadcast (broadcast))
            __broadcast
        )
    )

    ;;;
     ; Returns the period between pings for an individual peer.  Setting this lower means more accurate and timely
     ; ping times are available via {@link org.bitcoinj.core.Peer#getLastPingTime()} but it increases load on the
     ; remote node.  It defaults to {@link PeerGroup#DEFAULT_PING_INTERVAL_MSEC}.
     ;;
    #_public
    (ยง method #_"long" getPingIntervalMsec []
        (.. (:lock this) (lock))
        (try
            (:ping-interval-msec this)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Sets the period between pings for an individual peer.  Setting this lower means more accurate and timely
     ; ping times are available via {@link org.bitcoinj.core.Peer#getLastPingTime()} but it increases load on the
     ; remote node.  It defaults to {@link PeerGroup#DEFAULT_PING_INTERVAL_MSEC}.
     ; Setting the value to be <= 0 disables pinging entirely, although you can still request one yourself
     ; using {@link org.bitcoinj.core.Peer#ping()}.
     ;;
    #_public
    (ยง method #_"void" setPingIntervalMsec [#_"long" __pingIntervalMsec]
        (.. (:lock this) (lock))
        (try
            (ยง assoc this :ping-interval-msec __pingIntervalMsec)
            (let [#_"ListenableScheduledFuture<?>" __task (:v-ping-task this)]
                (when (some? __task)
                    (.. __task (cancel false))
                )
                (.. this (setupPinging))
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; If a peer is connected to that claims to speak a protocol version lower than the given version, it will
     ; be disconnected and another one will be tried instead.
     ;;
    #_public
    (ยง method #_"void" setMinRequiredProtocolVersion [#_"int" __minRequiredProtocolVersion]
        (ยง assoc this :v-min-required-protocol-version __minRequiredProtocolVersion)
        nil
    )

    ;;; The minimum protocol version required: defaults to the version required for Bloom filtering. ;;
    #_public
    (ยง method #_"int" getMinRequiredProtocolVersion []
        (:v-min-required-protocol-version this)
    )

    ;;;
     ; Returns our peers most commonly reported chain height.  If multiple heights are tied, the highest is returned.
     ; If no peers are connected, returns zero.
     ;;
    #_public
    (ยง method #_"int" getMostCommonChainHeight []
        (.. (:lock this) (lock))
        (try
            (PeerGroup/getMostCommonChainHeight (:peers this))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns most commonly reported chain height from the given list of {@link Peer}s.
     ; If multiple heights are tied, the highest is returned.  If no peers are connected, returns zero.
     ;;
    #_public
    #_static
    (ยง defn #_"int" PeerGroup/getMostCommonChainHeight [#_"List<Peer>" __peers]
        (when (.. __peers (isEmpty))
            (ยง return 0)
        )

        (let [#_"List<Integer>" __heights (ArrayList. #_"<>" (.. __peers (size)))]
            (doseq [#_"Peer" __peer __peers]
                (.. __heights (add (int (.. __peer (getBestHeight)))))
            )
            (Utils/maxOfMostFreq __heights)
        )
    )

    ;;;
     ; Given a list of Peers, return a Peer to be used as the download peer.  If you don't want PeerGroup to manage
     ; download peer statuses for you, just override this and always return null.
     ;;
    #_nilable
    #_protected
    (ยง method #_"Peer" selectDownloadPeer [#_"List<Peer>" __peers]
        ;; Characteristics to select for in order of importance:
        ;;  - Chain height is reasonable (majority of nodes).
        ;;  - High enough protocol version for the features we want (but we'll settle for less).
        ;;  - Randomly, to try and spread the load.
        (when (.. __peers (isEmpty))
            (ยง return nil)
        )

        ;; Make sure we don't select a peer that is behind/synchronizing itself.
        (let [#_"int" __mostCommonChainHeight (PeerGroup/getMostCommonChainHeight __peers)
              #_"List<Peer>" __candidates (ArrayList. #_"<>")]
            (doseq [#_"Peer" __peer __peers]
                (when (== (.. __peer (getBestHeight)) __mostCommonChainHeight)
                    (.. __candidates (add __peer))
                )
            )

            ;; Of the candidates, find the peers that meet the minimum protocol version we want to target.  We could select
            ;; the highest version we've seen on the assumption that newer versions are always better but we don't want to
            ;; zap peers if they upgrade early.  If we can't find any peers that have our preferred protocol version or
            ;; better then we'll settle for the highest we found instead.
            (let [#_"int" __highestVersion 0
                  #_"int" __preferredVersion 0]

                ;; if/when PREFERRED_VERSION is not equal to vMinRequiredProtocolVersion, reenable the last test in PeerGroupTest.downloadPeerSelection
                (let [#_"int" __PREFERRED_VERSION (.. (:params this) (getProtocolVersionNum NetworkParameters.ProtocolVersion/BLOOM_FILTER))]
                    (doseq [#_"Peer" __peer __candidates]
                        (ยง ass __highestVersion (Math/max (:client-version (.. __peer (getPeerVersionMessage))), __highestVersion))
                        (ยง ass __preferredVersion (Math/min __highestVersion, __PREFERRED_VERSION))
                    )
                    (let [#_"ArrayList<Peer>" __candidates2 (ArrayList. #_"<>" (.. __candidates (size)))]
                        (doseq [#_"Peer" __peer __candidates]
                            (when (<= __preferredVersion (:client-version (.. __peer (getPeerVersionMessage))))
                                (.. __candidates2 (add __peer))
                            )
                        )
                        (let [#_"int" __index (int (* (Math/random) (.. __candidates2 (size))))]
                            (.. __candidates2 (get __index))
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Returns the currently selected download peer.  Bear in mind that it may have changed as soon as this method
     ; returns.  Can return null if no peer was selected.
     ;;
    #_public
    (ยง method #_"Peer" getDownloadPeer []
        (.. (:lock this) (lock))
        (try
            (:download-peer this)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns the maximum number of {@link Peer}s to discover.  This maximum is checked after
     ; each {@link PeerDiscovery} so this max number can be surpassed.
     ; @return the maximum number of peers to discover.
     ;;
    #_public
    (ยง method #_"int" getMaxPeersToDiscoverCount []
        (:v-max-peers-to-discover-count this)
    )

    ;;;
     ; Sets the maximum number of {@link Peer}s to discover.  This maximum is checked after
     ; each {@link PeerDiscovery} so this max number can be surpassed.
     ; @param maxPeersToDiscoverCount the maximum number of peers to discover.
     ;;
    #_public
    (ยง method #_"void" setMaxPeersToDiscoverCount [#_"int" __maxPeersToDiscoverCount]
        (ยง assoc this :v-max-peers-to-discover-count __maxPeersToDiscoverCount)
        nil
    )

    ;;; See {@link #setUseLocalhostPeerWhenPossible(boolean)}. ;;
    #_public
    (ยง method #_"boolean" getUseLocalhostPeerWhenPossible []
        (.. (:lock this) (lock))
        (try
            (:use-localhost-peer-when-possible this)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; When true (the default), PeerGroup will attempt to connect to a Bitcoin node running on localhost before
     ; attempting to use the P2P network.  If successful, only localhost will be used.  This makes for a simple
     ; and easy way for a user to upgrade a bitcoinj based app running in SPV mode to fully validating security.
     ;;
    #_public
    (ยง method #_"void" setUseLocalhostPeerWhenPossible [#_"boolean" __useLocalhostPeerWhenPossible]
        (.. (:lock this) (lock))
        (try
            (ยง assoc this :use-localhost-peer-when-possible __useLocalhostPeerWhenPossible)
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    #_public
    (ยง method #_"boolean" isRunning []
        (:v-running this)
    )

    ;;;
     ; Can be used to disable Bloom filtering entirely, even in SPV mode.  You are very unlikely to need this, it is
     ; an optimisation for rare cases when full validation is not required but it's still more efficient to download
     ; full blocks than filtered blocks.
     ;;
    #_public
    (ยง method #_"void" setBloomFilteringEnabled [#_"boolean" __bloomFilteringEnabled]
        (ยง assoc this :v-bloom-filtering-enabled __bloomFilteringEnabled)
        nil
    )

    ;;; Returns whether the Bloom filtering protocol optimisation is in use: defaults to true. ;;
    #_public
    (ยง method #_"boolean" isBloomFilteringEnabled []
        (:v-bloom-filtering-enabled this)
    )
)

;;;
 ; Handles high-level message (de)serialization for peers, acting as the bridge between the
 ; {@link org.bitcoinj.net} classes and {@link Peer}.
 ;;
#_public
#_abstract
(ยง class PeerSocketHandler (ยง extends AbstractTimeoutHandler) (ยง implements StreamConnection)
    #_private
    #_static
    (ยง def- #_"Logger" PeerSocketHandler/log (LoggerFactory/getLogger PeerSocketHandler))

    #_private
    (ยง field- #_"MessageSerializer" :serializer)
    #_protected
    (ยง field #_"PeerAddress" :peer-address)
    ;; If we close() before we know our writeTarget, set this to true to call writeTarget.closeConnection() right away.
    #_private
    (ยง field- #_"boolean" :close-pending)
    ;; writeTarget will be thread-safe, and may call into PeerGroup, which calls us, so we should call it unlocked.
    #_testing
    #_protected
    (ยง field #_"MessageWriteTarget" :write-target)

    ;; The ByteBuffers passed to us from the writeTarget are static in size, and usually smaller than some messages we
    ;; will receive.  For SPV clients, this should be rare (i.e. we're mostly dealing with small transactions), but for
    ;; messages which are larger than the read buffer, we have to keep a temporary buffer with its bytes.
    #_private
    (ยง field- #_"byte[]" :large-read-buffer)
    #_private
    (ยง field- #_"int" :large-read-buffer-pos)
    #_private
    (ยง field- #_"BitcoinSerializer.BitcoinPacketHeader" :header)

    #_private
    (ยง field- #_"Lock" :lock (Threading/lock "PeerSocketHandler"))

    #_public
    (ยง constructor PeerSocketHandler [#_"NetworkParameters" __params, #_"InetSocketAddress" __remoteIp]
        (Preconditions/checkNotNull __params)
        (ยง assoc this :serializer (.. __params (getDefaultSerializer)))
        (ยง assoc this :peer-address (PeerAddress. __params, __remoteIp))
        this
    )

    #_public
    (ยง constructor PeerSocketHandler [#_"NetworkParameters" __params, #_"PeerAddress" __peerAddress]
        (Preconditions/checkNotNull __params)
        (ยง assoc this :serializer (.. __params (getDefaultSerializer)))
        (ยง assoc this :peer-address (Preconditions/checkNotNull __peerAddress))
        this
    )

    ;;;
     ; Sends the given message to the peer.  Due to the asynchronousness of network programming, there is no guarantee
     ; the peer will have received it.  Throws NotYetConnectedException if we are not yet connected to the remote peer.
     ; TODO: Maybe use something other than the unchecked NotYetConnectedException here.
     ;;
    #_public
    #_throws #_[ "NotYetConnectedException" ]
    (ยง method #_"void" sendMessage [#_"Message" __message]
        (.. (:lock this) (lock))
        (try
            (when (nil? (:write-target this))
                (throw (NotYetConnectedException.))
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        ;; TODO: Some round-tripping could be avoided here.
        (let [#_"ByteArrayOutputStream" __out (ByteArrayOutputStream.)]
            (try
                (.. (:serializer this) (serialize __message, __out))
                (.. (:write-target this) (writeBytes (.. __out (toByteArray))))
                (catch IOException __e
                    (.. this (exceptionCaught __e))
                )
            )
            nil
        )
    )

    ;;;
     ; Closes the connection to the peer if one exists, or immediately closes the connection as soon as it opens.
     ;;
    #_public
    (ยง method #_"void" close []
        (.. (:lock this) (lock))
        (try
            (when (nil? (:write-target this))
                (ยง assoc this :close-pending true)
                (ยง return nil)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        (.. (:write-target this) (closeConnection))
        nil
    )

    #_override
    #_protected
    (ยง method #_"void" timeoutOccurred []
        (.. PeerSocketHandler/log (info "{}: Timed out", (.. this (getAddress))))
        (.. this (close))
        nil
    )

    ;;;
     ; Called every time a message is received from the network.
     ;;
    #_protected
    #_abstract
    #_throws #_[ "Exception" ]
    (ยง method #_"void" processMessage [#_"Message" __m])

    #_override
    #_public
    (ยง method #_"int" receiveBytes [#_"ByteBuffer" __buff]
        (Preconditions/checkArgument (and (== (.. __buff (position)) 0) (<= (+ BitcoinSerializer.BitcoinPacketHeader/HEADER_LENGTH 4) (.. __buff (capacity)))))
        (try
            ;; Repeatedly try to deserialize messages until we hit a BufferUnderflowException.
            (let [#_"boolean" __firstMessage true]
                (loop []
                    ;; If we are in the middle of reading a message, try to fill that one first, before we expect another.
                    (when (some? (:large-read-buffer this))
                        ;; This can only happen in the first iteration.
                        (Preconditions/checkState __firstMessage)
                        ;; Read new bytes into the largeReadBuffer.
                        (let [#_"int" __bytesToGet (Math/min (.. __buff (remaining)), (- (.. (:large-read-buffer this) (alength)) (:large-read-buffer-pos this)))]
                            (.. __buff (get (:large-read-buffer this), (:large-read-buffer-pos this), __bytesToGet))
                            (ยง assoc this :large-read-buffer-pos (+ (:large-read-buffer-pos this) __bytesToGet))
                            ;; Check the largeReadBuffer's status.
                            (cond (== (:large-read-buffer-pos this) (.. (:large-read-buffer this) (alength)))
                                (do
                                    ;; ...processing a message if one is available.
                                    (.. this (processMessage (.. (:serializer this) (deserializePayload (:header this), (ByteBuffer/wrap (:large-read-buffer this))))))
                                    (ยง assoc this :large-read-buffer nil)
                                    (ยง assoc this :header nil)
                                    (ยง ass __firstMessage false)
                                )
                                :else ;; ...or just returning if we don't have enough bytes yet.
                                (do
                                    (ยง return (.. __buff (position)))
                                )
                            )
                        )
                    )
                    ;; Now try to deserialize any messages left in buff.
                    (let [#_"Message" __message
                          #_"int" __preSerializePosition (.. __buff (position))]
                        (try
                            (ยง ass __message (.. (:serializer this) (deserialize __buff)))
                            (catch BufferUnderflowException __e
                                ;; If we went through the whole buffer without a full message, we need to use the largeReadBuffer.
                                (cond (and __firstMessage (== (.. __buff (limit)) (.. __buff (capacity))))
                                    (do
                                        ;; ...so reposition the buffer to 0 and read the next message header.
                                        (.. __buff (position 0))
                                        (try
                                            (.. (:serializer this) (seekPastMagicBytes __buff))
                                            (ยง assoc this :header (.. (:serializer this) (deserializeHeader __buff)))
                                            ;; Initialize the largeReadBuffer with the next message's size and fill it with any bytes left in buff.
                                            (ยง assoc this :large-read-buffer (byte-array (-> this :header :size)))
                                            (ยง assoc this :large-read-buffer-pos (.. __buff (remaining)))
                                            (.. __buff (get (:large-read-buffer this), 0, (:large-read-buffer-pos this)))
                                            (catch BufferUnderflowException __e1
                                                ;; If we went through a whole buffer's worth of bytes without getting a header, give up.
                                                ;; In cases where the buff is just really small, we could create a second largeReadBuffer
                                                ;; that we use to deserialize the magic+header, but that is rather complicated when the buff
                                                ;; should probably be at least that big anyway (for efficiency).
                                                (throw (ProtocolException. (str "No magic bytes+header after reading " (.. __buff (capacity)) " bytes")))
                                            )
                                        )
                                    )
                                    :else
                                    (do
                                        ;; Reposition the buffer to its original position, which saves us from skipping messages by
                                        ;; seeking past part of the magic bytes before all of them are in the buffer.
                                        (.. __buff (position __preSerializePosition))
                                    )
                                )
                                (ยง return (.. __buff (position)))
                            )
                        )
                        ;; Process our freshly deserialized message.
                        (.. this (processMessage __message))
                        (ยง ass __firstMessage false)
                    )
                )
            )
            (catch Exception __e
                (.. this (exceptionCaught __e))
                ;; Returning -1 also throws an IllegalStateException upstream and kills the connection.
                (ยง return -1)
            )
        )
    )

    ;;;
     ; Sets the {@link MessageWriteTarget} used to write messages to the peer.  This should almost never be called,
     ; it is called automatically by {@link org.bitcoinj.net.NioClient} or
     ; {@link org.bitcoinj.net.NioClientManager} once the socket finishes initialization.
     ;;
    #_override
    #_public
    (ยง method #_"void" setWriteTarget [#_"MessageWriteTarget" __writeTarget]
        (Preconditions/checkArgument (some? __writeTarget))

        (.. (:lock this) (lock))
        (let [#_"boolean" __closeNow false]
            (try
                (Preconditions/checkArgument (nil? (:write-target this)))

                (ยง ass __closeNow (:close-pending this))
                (ยง assoc this :write-target __writeTarget)
                (finally
                    (.. (:lock this) (unlock))
                )
            )
            (when __closeNow
                (.. __writeTarget (closeConnection))
            )
            nil
        )
    )

    #_override
    #_public
    (ยง method #_"int" getMaxMessageSize []
        Message/MAX_SIZE
    )

    ;;;
     ; @return the IP address and port of peer.
     ;;
    #_public
    (ยง method #_"PeerAddress" getAddress []
        (:peer-address this)
    )

    ;;; Catch any exceptions, logging them and then closing the channel. ;;
    #_private
    (ยง method- #_"void" exceptionCaught [#_"Exception" __e]
        (let [#_"PeerAddress" __addr (.. this (getAddress))
              #_"String" __s (if (some? __addr) (.. __addr (toString)) "?")]
            (cond (or (instance? ConnectException __e) (instance? IOException __e))
                (do
                    ;; Short message for network errors
                    (.. PeerSocketHandler/log (info (str __s " - " (.. __e (getMessage)))))
                )
                :else
                (do
                    (.. PeerSocketHandler/log (warn (str __s " - "), __e))
                    (let [#_"Thread.UncaughtExceptionHandler" __handler Threading/UNCAUGHT_EXCEPTION_HANDLER]
                        (when (some? __handler)
                            (.. __handler (uncaughtException (Thread/currentThread), __e))
                        )
                    )
                )
            )

            (.. this (close))
            nil
        )
    )
)

;;;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class Ping (ยง extends Message)
    #_private
    (ยง field- #_"long" :nonce)
    #_private
    (ยง field- #_"boolean" :has-nonce)

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor Ping [#_"NetworkParameters" __params, #_"byte[]" __payloadBytes]
        (ยง super __params, __payloadBytes, 0)
        this
    )

    ;;;
     ; Create a Ping with a nonce value.
     ; Only use this if the remote node has a protocol version > 60000.
     ;;
    #_public
    (ยง constructor Ping [#_"long" __nonce]
        (ยง assoc this :nonce __nonce)
        (ยง assoc this :has-nonce true)
        this
    )

    ;;;
     ; Create a Ping without a nonce value.
     ; Only use this if the remote node has a protocol version <= 60000.
     ;;
    #_public
    (ยง constructor Ping []
        (ยง assoc this :has-nonce false)
        this
    )

    #_override
    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __stream]
        (when (:has-nonce this)
            (Utils/int64ToByteStreamLE (:nonce this), __stream)
        )
        nil
    )

    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        (try
            (ยง assoc this :nonce (.. this (readInt64)))
            (ยง assoc this :has-nonce true)
            (catch ProtocolException __e
                (ยง assoc this :has-nonce false)
            )
        )
        (ยง assoc this :length (if (:has-nonce this) 8 0))
        nil
    )

    #_public
    (ยง method #_"boolean" hasNonce []
        (:has-nonce this)
    )

    #_public
    (ยง method #_"long" getNonce []
        (:nonce this)
    )
)

;;;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class Pong (ยง extends Message)
    #_private
    (ยง field- #_"long" :nonce)

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor Pong [#_"NetworkParameters" __params, #_"byte[]" __payloadBytes]
        (ยง super __params, __payloadBytes, 0)
        this
    )

    ;;;
     ; Create a Pong with a nonce value.
     ; Only use this if the remote node has a protocol version > 60000.
     ;;
    #_public
    (ยง constructor Pong [#_"long" __nonce]
        (ยง assoc this :nonce __nonce)
        this
    )

    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        (ยง assoc this :nonce (.. this (readInt64)))
        (ยง assoc this :length 8)
        nil
    )

    #_override
    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __stream]
        (Utils/int64ToByteStreamLE (:nonce this), __stream)
        nil
    )

    ;;; Returns the nonce sent by the remote peer. ;;
    #_public
    (ยง method #_"long" getNonce []
        (:nonce this)
    )
)

#_public
(ยง class ProtocolException (ยง extends VerificationException)
    #_public
    (ยง constructor ProtocolException [#_"String" __msg]
        (ยง super __msg)
        this
    )

    #_public
    (ยง constructor ProtocolException [#_"Exception" __e]
        (ยง super __e)
        this
    )

    #_public
    (ยง constructor ProtocolException [#_"String" __msg, #_"Exception" __e]
        (ยง super __msg, __e)
        this
    )
)

;; TODO: Rename PrunedException to something like RequiredDataWasPrunedException.

;;;
 ; PrunedException is thrown in cases where a fully verifying node has deleted (pruned) old block data that turned
 ; out to be necessary for handling a re-org.  Normally this should never happen unless you're playing with the testnet
 ; as the pruning parameters should be set very conservatively, such that an absolutely enormous re-org would be
 ; required to trigger it.
 ;;
#_public
(ยง class PrunedException (ยง extends Exception)
    #_private
    (ยง field- #_"Sha256Hash" :hash)

    #_public
    (ยง constructor PrunedException [#_"Sha256Hash" __hash]
        (ยง super (.. __hash (toString)))

        (ยง assoc this :hash __hash)
        this
    )

    #_public
    (ยง method #_"Sha256Hash" getHash []
        (:hash this)
    )
)

;;;
 ; <p>A message sent by nodes when a message we sent was rejected (i.e. a transaction had too little fee/was invalid/etc).</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class RejectMessage (ยง extends Message)
    #_private
    (ยง field- #_"String" :message)
    #_private
    (ยง field- #_"String" :reason)

    #_public
    (ยง enum RejectMessage.RejectCode
        ;;; The message was not able to be parsed. ;;
        (ยง item (MALFORMED (byte 0x01)))
        ;;; The message described an invalid object. ;;
        (ยง item (INVALID (byte 0x10)))
        ;;; The message was obsolete or described an object which is obsolete (e.g. unsupported, old version, v1 block). ;;
        (ยง item (OBSOLETE (byte 0x11)))
        ;;;
         ; The message was relayed multiple times or described an object which is in conflict with another.
         ; This message can describe errors in protocol implementation or the presence of an attempt to DOUBLE SPEND.
         ;;
        (ยง item (DUPLICATE (byte 0x12)))
        ;;;
         ; The message described an object was not standard and was thus not accepted.
         ; Bitcoin Core has a concept of standard transaction forms, which describe scripts and encodings which
         ; it is willing to relay further.  Other transactions are neither relayed nor mined, though they are considered
         ; valid if they appear in a block.
         ;;
        (ยง item (NONSTANDARD (byte 0x40)))
        ;;;
         ; This refers to a specific form of NONSTANDARD transactions, which have an output smaller than some constant
         ; defining them as dust (this is no longer used).
         ;;
        (ยง item (DUST (byte 0x41)))
        ;;; The messages described an object which did not have sufficient fee to be relayed further. ;;
        (ยง item (INSUFFICIENTFEE (byte 0x42)))
        ;;; The message described a block which was invalid according to hard-coded checkpoint blocks. ;;
        (ยง item (CHECKPOINT (byte 0x43)))
        (ยง item (OTHER (byte 0xff)))

        (let [#_"byte" __code]

            (ยง constructor RejectMessage.RejectCode [#_"byte" __code]
                (ยง assoc this :code __code)
                this
            )

            #_static
            (ยง defn #_"RejectMessage.RejectCode" RejectMessage.RejectCode/fromCode [#_"byte" __code]
                (doseq [#_"RejectMessage.RejectCode" __rejectCode (RejectMessage.RejectCode/values)]
                    (when (== (:code __rejectCode) __code)
                        (ยง return __rejectCode)
                    )
                )

                OTHER
            )
        )
    )

    #_private
    (ยง field- #_"RejectMessage.RejectCode" :code)
    #_private
    (ยง field- #_"Sha256Hash" :message-hash)

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor RejectMessage [#_"NetworkParameters" __params, #_"byte[]" __payload]
        (ยง super __params, __payload, 0)
        this
    )

    ;;; Constructs a reject message that fingers the object with the given hash as rejected for the given reason. ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor RejectMessage [#_"NetworkParameters" __params, #_"RejectMessage.RejectCode" __code, #_"Sha256Hash" __hash, #_"String" __message, #_"String" __reason]
        (ยง super __params)

        (ยง assoc this :code __code)
        (ยง assoc this :message-hash __hash)
        (ยง assoc this :message __message)
        (ยง assoc this :reason __reason)
        this
    )

    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        (ยง assoc this :message (.. this (readStr)))
        (ยง assoc this :code (RejectMessage.RejectCode/fromCode (aget (.. this (readBytes 1)) 0)))
        (ยง assoc this :reason (.. this (readStr)))
        (when (or (.. (:message this) (equals "block")) (.. (:message this) (equals "tx")))
            (ยง assoc this :message-hash (.. this (readHash)))
        )
        (ยง assoc this :length (- (:cursor this) (:offset this)))
        nil
    )

    #_override
    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __stream]
        (let [#_"byte[]" __messageBytes (.. (:message this) (getBytes "UTF-8"))]
            (.. __stream (write (.. (VarInt. (.. __messageBytes (alength))) (encode))))
            (.. __stream (write __messageBytes))
            (.. __stream (write (-> this :code :code)))
            (let [#_"byte[]" __reasonBytes (.. (:reason this) (getBytes "UTF-8"))]
                (.. __stream (write (.. (VarInt. (.. __reasonBytes (alength))) (encode))))
                (.. __stream (write __reasonBytes))
                (when (or (.. "block" (equals (:message this))) (.. "tx" (equals (:message this))))
                    (.. __stream (write (.. (:message-hash this) (getReversedBytes))))
                )
                nil
            )
        )
    )

    ;;;
     ; Provides the type of message which was rejected by the peer.
     ; Note that this is ENTIRELY UNTRUSTED and should be sanity-checked before it is printed or processed.
     ;;
    #_public
    (ยง method #_"String" getRejectedMessage []
        (:message this)
    )

    ;;;
     ; Provides the hash of the rejected object (if getRejectedMessage() is either "tx" or "block"), otherwise null.
     ;;
    #_public
    (ยง method #_"Sha256Hash" getRejectedObjectHash []
        (:message-hash this)
    )

    ;;;
     ; The reason code given for why the peer rejected the message.
     ;;
    #_public
    (ยง method #_"RejectMessage.RejectCode" getReasonCode []
        (:code this)
    )

    ;;;
     ; The reason message given for rejection.
     ; Note that this is ENTIRELY UNTRUSTED and should be sanity-checked before it is printed or processed.
     ;;
    #_public
    (ยง method #_"String" getReasonString []
        (:reason this)
    )

    ;;;
     ; A String representation of the relevant details of this reject message.
     ; Be aware that the value returned by this method includes the value returned by
     ; {@link #getReasonString() getReasonString}, which is taken from the reject message unchecked.
     ; Through malice or otherwise, it might contain control characters or other harmful content.
     ;;
    #_override
    #_public
    (ยง method #_"String" toString []
        (let [#_"Sha256Hash" __hash (.. this (getRejectedObjectHash))]
            (String/format Locale/US, "Reject: %s %s for reason '%s' (%d)", (.. this (getRejectedMessage)), (or __hash ""), (.. this (getReasonString)), (:code (.. this (getReasonCode))))
        )
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"RejectMessage" __other (cast RejectMessage __o)]
            (and (.. (:message this) (equals (:message __other))) (.. (:code this) (equals (:code __other))) (.. (:reason this) (equals (:reason __other))) (.. (:message-hash this) (equals (:message-hash __other))))
        )
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (:message this), (:code this), (:reason this), (:message-hash this))
    )
)

;;;
 ; This exception is used by the TransactionBroadcast class to indicate that a broadcast
 ; Transaction has been rejected by the network, for example because it violates a
 ; protocol rule.  Note that not all invalid transactions generate a reject message, and
 ; some peers may never do so.
 ;;
#_public
(ยง class RejectedTransactionException (ยง extends Exception)
    #_private
    (ยง field- #_"Transaction" :tx)
    #_private
    (ยง field- #_"RejectMessage" :reject-message)

    #_public
    (ยง constructor RejectedTransactionException [#_"Transaction" __tx, #_"RejectMessage" __rejectMessage]
        (ยง super (.. __rejectMessage (toString)))

        (ยง assoc this :tx __tx)
        (ยง assoc this :reject-message __rejectMessage)
        this
    )

    ;;; Return the original Transaction object whose broadcast was rejected. ;;
    #_public
    (ยง method #_"Transaction" getTransaction []
        (:tx this)
    )

    ;;; Return the RejectMessage object representing the broadcast rejection. ;;
    #_public
    (ยง method #_"RejectMessage" getRejectMessage []
        (:reject-message this)
    )
)

#_public
(ยง class ScriptException (ยง extends VerificationException)
    #_private
    (ยง field- #_"ScriptError" :err)

    #_public
    (ยง constructor ScriptException [#_"ScriptError" __err, #_"String" __msg]
        (ยง super __msg)
        (ยง assoc this :err __err)
        this
    )

    #_public
    (ยง constructor ScriptException [#_"ScriptError" __err, #_"String" __msg, #_"Exception" __e]
        (ยง super __msg, __e)
        (ยง assoc this :err __err)
        this
    )

    #_public
    (ยง method #_"ScriptError" getError []
        (:err this)
    )
)

;;;
 ; A Sha256Hash just wraps a byte[] so that equals and hashcode work correctly,
 ; allowing it to be used as keys in a map.
 ; It also checks that the length is correct and provides a bit more type safety.
 ;;
#_public
(ยง class Sha256Hash (ยง implements Serializable, Comparable #_"<Sha256Hash>")
    #_public
    #_static
    (ยง def #_"int" Sha256Hash/LENGTH 32) ;; bytes
    #_public
    #_static
    (ยง def #_"Sha256Hash" Sha256Hash/ZERO_HASH (Sha256Hash/wrap (byte-array Sha256Hash/LENGTH)))

    #_private
    (ยง field- #_"byte[]" :bytes)

    ;;;
     ; Use {@link #wrap(byte[])} instead.
     ;;
    #_protected
    (ยง constructor Sha256Hash [#_"byte[]" __rawHashBytes]
        (Preconditions/checkArgument (== (.. __rawHashBytes (alength)) Sha256Hash/LENGTH))
        (ยง assoc this :bytes __rawHashBytes)
        this
    )

    ;;;
     ; Creates a new instance that wraps the given hash value.
     ;
     ; @param rawHashBytes The raw hash bytes to wrap.
     ; @return a new instance.
     ; @throws IllegalArgumentException if the given array length is not exactly 32.
     ;;
    #_public
    #_static
    (ยง defn #_"Sha256Hash" Sha256Hash/wrap [#_"byte[]" __rawHashBytes]
        (Sha256Hash. __rawHashBytes)
    )

    ;;;
     ; Creates a new instance that wraps the given hash value (represented as a hex string).
     ;
     ; @param hexString A hash value represented as a hex string.
     ; @return a new instance.
     ; @throws IllegalArgumentException if the given string is not a valid hex string, or if it does not represent exactly 32 bytes.
     ;;
    #_public
    #_static
    (ยง defn #_"Sha256Hash" Sha256Hash/wrap [#_"String" __hexString]
        (Sha256Hash/wrap (.. Utils/HEX (decode __hexString)))
    )

    ;;;
     ; Creates a new instance that wraps the given hash value, but with byte order reversed.
     ;
     ; @param rawHashBytes The raw hash bytes to wrap.
     ; @return a new instance.
     ; @throws IllegalArgumentException if the given array length is not exactly 32.
     ;;
    #_public
    #_static
    (ยง defn #_"Sha256Hash" Sha256Hash/wrapReversed [#_"byte[]" __rawHashBytes]
        (Sha256Hash/wrap (Utils/reverseBytes __rawHashBytes))
    )

    ;;;
     ; Creates a new instance containing the calculated (one-time) hash of the given bytes.
     ;
     ; @param contents The bytes on which the hash value is calculated.
     ; @return a new instance containing the calculated (one-time) hash.
     ;;
    #_public
    #_static
    (ยง defn #_"Sha256Hash" Sha256Hash/of [#_"byte[]" __contents]
        (Sha256Hash/wrap (Sha256Hash/hash __contents))
    )

    ;;;
     ; Creates a new instance containing the hash of the calculated hash of the given bytes.
     ;
     ; @param contents The bytes on which the hash value is calculated.
     ; @return a new instance containing the calculated (two-time) hash.
     ;;
    #_public
    #_static
    (ยง defn #_"Sha256Hash" Sha256Hash/twiceOf [#_"byte[]" __contents]
        (Sha256Hash/wrap (Sha256Hash/hashTwice __contents))
    )

    ;;;
     ; Creates a new instance containing the calculated (one-time) hash of the given file's contents.
     ;
     ; The file contents are read fully into memory, so this method should only be used with small files.
     ;
     ; @param file The file on which the hash value is calculated.
     ; @return a new instance containing the calculated (one-time) hash.
     ; @throws IOException if an error occurs while reading the file.
     ;;
    #_public
    #_static
    #_throws #_[ "IOException" ]
    (ยง defn #_"Sha256Hash" Sha256Hash/of [#_"File" __file]
        (let [#_"FileInputStream" __in (FileInputStream. __file)]
            (try
                (Sha256Hash/of (ByteStreams/toByteArray __in))
                (finally
                    (.. __in (close))
                )
            )
        )
    )

    ;;;
     ; Returns a new SHA-256 MessageDigest instance.
     ;
     ; This is a convenience method which wraps the checked
     ; exception that can never occur with a RuntimeException.
     ;
     ; @return a new SHA-256 MessageDigest instance.
     ;;
    #_public
    #_static
    (ยง defn #_"MessageDigest" Sha256Hash/newDigest []
        (try
            (ยง return (MessageDigest/getInstance "SHA-256"))
            (catch NoSuchAlgorithmException __e
                (throw (RuntimeException. __e)) ;; Can't happen.
            )
        )
    )

    ;;;
     ; Calculates the SHA-256 hash of the given bytes.
     ;
     ; @param input The bytes to hash.
     ; @return the hash (in big-endian order).
     ;;
    #_public
    #_static
    (ยง defn #_"byte[]" Sha256Hash/hash [#_"byte[]" __input]
        (Sha256Hash/hash __input, 0, (.. __input (alength)))
    )

    ;;;
     ; Calculates the SHA-256 hash of the given byte range.
     ;
     ; @param input The array containing the bytes to hash.
     ; @param offset The offset within the array of the bytes to hash.
     ; @param length The number of bytes to hash.
     ; @return the hash (in big-endian order).
     ;;
    #_public
    #_static
    (ยง defn #_"byte[]" Sha256Hash/hash [#_"byte[]" __input, #_"int" __offset, #_"int" __length]
        (let [#_"MessageDigest" __digest (Sha256Hash/newDigest)]
            (.. __digest (update __input, __offset, __length))
            (.. __digest (digest))
        )
    )

    ;;;
     ; Calculates the SHA-256 hash of the given bytes,
     ; and then hashes the resulting hash again.
     ;
     ; @param input The bytes to hash.
     ; @return the double-hash (in big-endian order).
     ;;
    #_public
    #_static
    (ยง defn #_"byte[]" Sha256Hash/hashTwice [#_"byte[]" __input]
        (Sha256Hash/hashTwice __input, 0, (.. __input (alength)))
    )

    ;;;
     ; Calculates the SHA-256 hash of the given byte range,
     ; and then hashes the resulting hash again.
     ;
     ; @param input The array containing the bytes to hash.
     ; @param offset The offset within the array of the bytes to hash.
     ; @param length The number of bytes to hash.
     ; @return the double-hash (in big-endian order).
     ;;
    #_public
    #_static
    (ยง defn #_"byte[]" Sha256Hash/hashTwice [#_"byte[]" __input, #_"int" __offset, #_"int" __length]
        (let [#_"MessageDigest" __digest (Sha256Hash/newDigest)]
            (.. __digest (update __input, __offset, __length))
            (.. __digest (digest (.. __digest (digest))))
        )
    )

    ;;;
     ; Calculates the hash of hash on the given byte ranges.  This is equivalent to
     ; concatenating the two ranges and then passing the result to {@link #hashTwice(byte[])}.
     ;;
    #_public
    #_static
    (ยง defn #_"byte[]" Sha256Hash/hashTwice [#_"byte[]" __input1, #_"int" __offset1, #_"int" __length1, #_"byte[]" __input2, #_"int" __offset2, #_"int" __length2]
        (let [#_"MessageDigest" __digest (Sha256Hash/newDigest)]
            (.. __digest (update __input1, __offset1, __length1))
            (.. __digest (update __input2, __offset2, __length2))
            (.. __digest (digest (.. __digest (digest))))
        )
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (Arrays/equals (:bytes this), (:bytes (cast Sha256Hash __o)))
    )

    ;;;
     ; Returns the last four bytes of the wrapped hash.  This should be unique enough to be a suitable hash code
     ; even for blocks, where the goal is to try and get the first bytes to be zeros (i.e. the value as a big integer
     ; lower than the target value).
     ;;
    #_override
    #_public
    (ยง method #_"int" hashCode []
        ;; Use the last 4 bytes, not the first 4 which are often zeros in Bitcoin.
        (Ints/fromBytes (aget (:bytes this) (- Sha256Hash/LENGTH 4)), (aget (:bytes this) (- Sha256Hash/LENGTH 3)), (aget (:bytes this) (- Sha256Hash/LENGTH 2)), (aget (:bytes this) (dec Sha256Hash/LENGTH)))
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (.. Utils/HEX (encode (:bytes this)))
    )

    ;;;
     ; Returns the bytes interpreted as a positive integer.
     ;;
    #_public
    (ยง method #_"BigInteger" toBigInteger []
        (BigInteger. 1, (:bytes this))
    )

    ;;;
     ; Returns the internal byte array, without defensively copying.  Therefore do NOT modify the returned array.
     ;;
    #_public
    (ยง method #_"byte[]" getBytes []
        (:bytes this)
    )

    ;;;
     ; Returns a reversed copy of the internal byte array.
     ;;
    #_public
    (ยง method #_"byte[]" getReversedBytes []
        (Utils/reverseBytes (:bytes this))
    )

    #_override
    #_public
    (ยง method #_"int" compareTo [#_"Sha256Hash" __other]
        (loop-when-recur [#_"int" __i (dec Sha256Hash/LENGTH)] (<= 0 __i) [(dec __i)]
            (let [#_"int" __thisByte (& 0xff (aget (:bytes this) __i))
                  #_"int" __otherByte (& 0xff (aget (:bytes __other) __i))]
                (when (> __thisByte __otherByte)
                    (ยง return 1)
                )
                (when (< __thisByte __otherByte)
                    (ยง return -1)
                )
            )
        )
        0
    )
)

;;;
 ; Wraps a {@link Block} object with extra data that can be derived from the block chain but is slow or inconvenient
 ; to calculate.  By storing it alongside the block header we reduce the amount of work required significantly.
 ; Recalculation is slow because the fields are cumulative - to find the chainWork you have to iterate over every
 ; block in the chain back to the genesis block, which involves lots of seeking/loading etc.  So we just keep a
 ; running total: it's a disk space vs cpu/io tradeoff.
 ;
 ; StoredBlocks are put inside a {@link BlockStore} which saves them to memory or disk.
 ;;
#_public
(ยง class StoredBlock
    ;; A BigInteger representing the total amount of work done so far on this chain.  As of May 2011 it takes
    ;; 8 bytes to represent this field, so 12 bytes should be plenty for now.
    #_public
    #_static
    (ยง def #_"int" StoredBlock/CHAIN_WORK_BYTES 12)
    #_public
    #_static
    (ยง def #_"byte[]" StoredBlock/EMPTY_BYTES (byte-array StoredBlock/CHAIN_WORK_BYTES))
    #_public
    #_static
    (ยง def #_"int" StoredBlock/COMPACT_SERIALIZED_SIZE (+ Block/HEADER_SIZE StoredBlock/CHAIN_WORK_BYTES 4)) ;; for height

    #_private
    (ยง field- #_"Block" :header)
    #_private
    (ยง field- #_"BigInteger" :chain-work)
    #_private
    (ยง field- #_"int" :height)

    #_public
    (ยง constructor StoredBlock [#_"Block" __header, #_"BigInteger" __chainWork, #_"int" __height]
        (ยง assoc this :header __header)
        (ยง assoc this :chain-work __chainWork)
        (ยง assoc this :height __height)
        this
    )

    ;;;
     ; The block header this object wraps.  The referenced block object must not have any transactions in it.
     ;;
    #_public
    (ยง method #_"Block" getHeader []
        (:header this)
    )

    ;;;
     ; The total sum of work done in this block, and all the blocks below it in the chain.  Work is a measure of
     ; how many tries are needed to solve a block.  If the target is set to cover 10% of the total hash value space,
     ; then the work represented by a block is 10.
     ;;
    #_public
    (ยง method #_"BigInteger" getChainWork []
        (:chain-work this)
    )

    ;;;
     ; Position in the chain for this block.  The genesis block has a height of zero.
     ;;
    #_public
    (ยง method #_"int" getHeight []
        (:height this)
    )

    ;;; Returns true if this objects chainWork is higher than the others. ;;
    #_public
    (ยง method #_"boolean" moreWorkThan [#_"StoredBlock" __other]
        (< 0 (.. (:chain-work this) (compareTo (:chain-work __other))))
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"StoredBlock" __other (cast StoredBlock __o)]
            (and (.. (:header this) (equals (:header __other))) (.. (:chain-work this) (equals (:chain-work __other))) (== (:height this) (:height __other)))
        )
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (:header this), (:chain-work this), (:height this))
    )

    ;;;
     ; Creates a new StoredBlock, calculating the additional fields by adding to the values in this block.
     ;;
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"StoredBlock" build [#_"Block" __block]
        ;; Stored blocks track total work done in this chain, because the canonical chain is the one that represents
        ;; the largest amount of work done not the tallest.
        (let [#_"BigInteger" __chainWork (.. (:chain-work this) (add (.. __block (getWork))))
              #_"int" __height (inc (:height this))]
            (StoredBlock. __block, __chainWork, __height)
        )
    )

    ;;;
     ; Given a block store, looks up the previous block in this chain.  Convenience method for doing
     ; <tt>store.get(this.getHeader().getPrevBlockHash())</tt>.
     ;
     ; @return the previous block in the chain or null if it was not found in the store.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" getPrev [#_"BlockStore" __store]
        (.. __store (get (.. this (getHeader) (getPrevBlockHash))))
    )

    ;;; Serializes the stored block to a custom packed format.  Used by {@link CheckpointManager}. ;;
    #_public
    (ยง method #_"void" serializeCompact [#_"ByteBuffer" __buffer]
        (let [#_"byte[]" __chainWorkBytes (.. this (getChainWork) (toByteArray))]
            (Preconditions/checkState (<= (.. __chainWorkBytes (alength)) StoredBlock/CHAIN_WORK_BYTES), "Ran out of space to store chain work!")
            (when (< (.. __chainWorkBytes (alength)) StoredBlock/CHAIN_WORK_BYTES)
                ;; Pad to the right size.
                (.. __buffer (put StoredBlock/EMPTY_BYTES, 0, (- StoredBlock/CHAIN_WORK_BYTES (.. __chainWorkBytes (alength)))))
            )
            (.. __buffer (put __chainWorkBytes))
            (.. __buffer (putInt (.. this (getHeight))))
            ;; Using unsafeBitcoinSerialize here can give us direct access to the same bytes we read off the wire,
            ;; avoiding serialization round-trips.
            (let [#_"byte[]" __bytes (.. this (getHeader) (unsafeBitcoinSerialize))]
                (.. __buffer (put __bytes, 0, Block/HEADER_SIZE)) ;; Trim the trailing 00 byte (zero transactions).
                nil
            )
        )
    )

    ;;; De-serializes the stored block from a custom packed format.  Used by {@link CheckpointManager}. ;;
    #_public
    #_static
    #_throws #_[ "ProtocolException" ]
    (ยง defn #_"StoredBlock" StoredBlock/deserializeCompact [#_"NetworkParameters" __params, #_"ByteBuffer" __buffer]
        (let [#_"byte[]" __chainWorkBytes (byte-array StoredBlock/CHAIN_WORK_BYTES)]
            (.. __buffer (get __chainWorkBytes))
            (let [#_"BigInteger" __chainWork (BigInteger. 1, __chainWorkBytes)
                  #_"int" __height (.. __buffer (getInt))] ;; +4 bytes
                (let [#_"byte[]" __header (byte-array (inc Block/HEADER_SIZE))] ;; Extra byte for the 00 transactions length.
                    (.. __buffer (get __header, 0, Block/HEADER_SIZE))
                    (StoredBlock. (.. __params (getDefaultSerializer) (makeBlock __header)), __chainWork, __height)
                )
            )
        )
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (String/format Locale/US, "Block %s at height %d: %s", (.. this (getHeader) (getHashAsString)), (.. this (getHeight)), (.. this (getHeader) (toString)))
    )
)

;;;
 ; Contains minimal data neccessary to disconnect/connect the transactions
 ; in the stored block at will.  Can either store the full set of
 ; transactions (if the inputs for the block have not been tested to work)
 ; or the set of transaction outputs created/destroyed when the block is
 ; connected.
 ;;
#_public
(ยง class StoredUndoableBlock
    (ยง field #_"Sha256Hash" :block-hash)

    ;; Only one of either txOutChanges or transactions will be set.
    #_private
    (ยง field- #_"TransactionOutputChanges" :tx-out-changes)
    #_private
    (ยง field- #_"List<Transaction>" :transactions)

    #_public
    (ยง constructor StoredUndoableBlock [#_"Sha256Hash" __hash, #_"TransactionOutputChanges" __txOutChanges]
        (ยง assoc this :block-hash __hash)
        (ยง assoc this :transactions nil)
        (ยง assoc this :tx-out-changes __txOutChanges)
        this
    )

    #_public
    (ยง constructor StoredUndoableBlock [#_"Sha256Hash" __hash, #_"List<Transaction>" __transactions]
        (ยง assoc this :block-hash __hash)
        (ยง assoc this :tx-out-changes nil)
        (ยง assoc this :transactions __transactions)
        this
    )

    ;;;
     ; Get the transaction output changes if they have been calculated, otherwise null.
     ; Only one of this and getTransactions() will return a non-null value.
     ;;
    #_public
    (ยง method #_"TransactionOutputChanges" getTxOutChanges []
        (:tx-out-changes this)
    )

    ;;;
     ; Get the full list of transactions if it is stored, otherwise null.
     ; Only one of this and getTxOutChanges() will return a non-null value.
     ;;
    #_public
    (ยง method #_"List<Transaction>" getTransactions []
        (:transactions this)
    )

    ;;;
     ; Get the hash of the represented block.
     ;;
    #_public
    (ยง method #_"Sha256Hash" getHash []
        (:block-hash this)
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (.. (:block-hash this) (hashCode))
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (.. this (getHash) (equals (.. (cast StoredUndoableBlock __o) (getHash))))
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (str "Undoable Block " (:block-hash this))
    )
)

;;;
 ; <p>A transaction represents the movement of coins from some addresses to some other addresses.  It can also represent
 ; the minting of new coins.  A Transaction object corresponds to the equivalent in the Bitcoin C++ implementation.</p>
 ;
 ; <p>Transactions are the fundamental atoms of Bitcoin and have many powerful features.  Read
 ; <a href="https://bitcoinj.github.io/working-with-transactions">"Working with transactions"</a> in the
 ; documentation to learn more about how to use this class.</p>
 ;
 ; <p>All Bitcoin transactions are at risk of being reversed, though the risk is much less than with traditional payment
 ; systems.  Transactions have <i>confidence levels</i>, which help you decide whether to trust a transaction or not.
 ; Whether to trust a transaction is something that needs to be decided on a case by case basis - a rule that makes
 ; sense for selling MP3s might not make sense for selling cars, or accepting payments from a family member.  If you
 ; are building a wallet, how to present confidence to your users is something to consider carefully.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class Transaction (ยง extends ChildMessage)
    ;;;
     ; A comparator that can be used to sort transactions by their updateTime field.
     ; The ordering goes from most recent into the past.
     ;;
    #_public
    #_static
    (ยง def #_"Comparator<Transaction>" Transaction/SORT_TX_BY_UPDATE_TIME (Comparator. #_"<Transaction>"
        (ยง anon
            #_override
            #_public
            (ยง method #_"int" compare [#_"Transaction" __tx1, #_"Transaction" __tx2]
                (let [#_"long" __time1 (.. __tx1 (getUpdateTime) (getTime))
                      #_"long" __time2 (.. __tx2 (getUpdateTime) (getTime))
                      #_"int" __updateTimeComparison (- (Longs/compare __time1, __time2))]
                    ;; If time1 == time2, compare by tx hash to make comparator consistent with equals.
                    (if (!= __updateTimeComparison 0) __updateTimeComparison (.. __tx1 (getHash) (compareTo (.. __tx2 (getHash)))))
                )
            )
        )))

    ;;; A comparator that can be used to sort transactions by their chain height. ;;
    #_public
    #_static
    (ยง def #_"Comparator<Transaction>" Transaction/SORT_TX_BY_HEIGHT (Comparator. #_"<Transaction>"
        (ยง anon
            #_override
            #_public
            (ยง method #_"int" compare [#_"Transaction" __tx1, #_"Transaction" __tx2]
                (let [#_"TransactionConfidence" __confidence1 (.. __tx1 (getConfidence))
                      #_"int" __height1 (if (== (.. __confidence1 (getConfidenceType)) TransactionConfidence.ConfidenceType/BUILDING) (.. __confidence1 (getAppearedAtChainHeight)) Block/BLOCK_HEIGHT_UNKNOWN)
                      #_"TransactionConfidence" __confidence2 (.. __tx2 (getConfidence))
                      #_"int" __height2 (if (== (.. __confidence2 (getConfidenceType)) TransactionConfidence.ConfidenceType/BUILDING) (.. __confidence2 (getAppearedAtChainHeight)) Block/BLOCK_HEIGHT_UNKNOWN)
                      #_"int" __heightComparison (- (Ints/compare __height1, __height2))]
                    ;; If height1 == height2, compare by tx hash to make comparator consistent with equals.
                    (if (!= __heightComparison 0) __heightComparison (.. __tx1 (getHash) (compareTo (.. __tx2 (getHash)))))
                )
            )
        )))

    #_private
    #_static
    (ยง def- #_"Logger" Transaction/log (LoggerFactory/getLogger Transaction))

    ;;; Threshold for lockTime: below this value it is interpreted as block number, otherwise as timestamp. ;;
    #_public
    #_static
    (ยง def #_"int" Transaction/LOCKTIME_THRESHOLD 500000000) ;; Tue Nov  5 00:53:20 1985 UTC
    ;;; Same, but as a BigInteger for CHECKLOCKTIMEVERIFY. ;;
    #_public
    #_static
    (ยง def #_"BigInteger" Transaction/LOCKTIME_THRESHOLD_BIG (BigInteger/valueOf Transaction/LOCKTIME_THRESHOLD))

    ;;; How many bytes a transaction can be before it won't be relayed anymore.  Currently 100kb. ;;
    #_public
    #_static
    (ยง def #_"int" Transaction/MAX_STANDARD_TX_SIZE 100000)

    ;;;
     ; If feePerKb is lower than this, Bitcoin Core will treat it as if there were no fee.
     ;;
    #_public
    #_static
    (ยง def #_"Coin" Transaction/REFERENCE_DEFAULT_MIN_TX_FEE (Coin/valueOf 5000)) ;; 0.05 mBTC

    ;;;
     ; If using this feePerKb, transactions will get confirmed within the next couple of blocks.
     ; This should be adjusted from time to time.  Last adjustment: February 2017.
     ;;
    #_public
    #_static
    (ยง def #_"Coin" Transaction/DEFAULT_TX_FEE (Coin/valueOf 100000)) ;; 1 mBTC

    ;;;
     ; Any standard (i.e. pay-to-address) output smaller than this value (in satoshis) will most likely be rejected by the network.
     ; This is calculated by assuming a standard output will be 34 bytes, and then using the formula used in
     ; {@link TransactionOutput#getMinNonDustValue(Coin)}.
     ;;
    #_public
    #_static
    (ยง def #_"Coin" Transaction/MIN_NONDUST_OUTPUT (Coin/valueOf 2730)) ;; satoshis

    ;; These are bitcoin serialized.
    #_private
    (ยง field- #_"long" :version)
    #_private
    (ยง field- #_"ArrayList<TransactionInput>" :inputs)
    #_private
    (ยง field- #_"ArrayList<TransactionOutput>" :outputs)

    #_private
    (ยง field- #_"long" :lock-time)

    ;; This is either the time the transaction was broadcast as measured from the local clock, or the time from the
    ;; block in which it was included.  Note that this can be changed by re-orgs so the wallet may update this field.
    ;; Old serialized transactions don't have this field, thus null is valid.  It is used for returning an ordered
    ;; list of transactions from a wallet, which is helpful for presenting to users.
    #_private
    (ยง field- #_"Date" :updated-at)

    ;; This is an in memory helper only.
    #_private
    (ยง field- #_"Sha256Hash" :hash)

    ;; Data about how confirmed this tx is.  Serialized, may be null.
    #_nilable
    #_private
    (ยง field- #_"TransactionConfidence" :confidence)

    ;; Records a map of which blocks the transaction has appeared in (keys) to an index within that block (values).
    ;; The "index" is not a real index, instead the values are only meaningful relative to each other.  For example,
    ;; consider two transactions that appear in the same block, t1 and t2, where t2 spends an output of t1.  Both
    ;; will have the same block hash as a key in their appearsInHashes, but the counter would be 1 and 2 respectively
    ;; regardless of where they actually appeared in the block.
    ;;
    ;; If this transaction is not stored in the wallet, appearsInHashes is null.
    #_private
    (ยง field- #_"Map<Sha256Hash, Integer>" :appears-in-hashes)

    ;; Transactions can be encoded in a way that will use more bytes than is optimal
    ;; (due to VarInts having multiple encodings).
    ;; MAX_BLOCK_SIZE must be compared to the optimal encoding, not the actual encoding, so when parsing, we keep track
    ;; of the size of the ideal encoding in addition to the actual message size (which Message needs) so that Blocks
    ;; can properly keep track of optimal encoded size.
    #_private
    (ยง field- #_"int" :optimal-encoding-message-size)

    ;;;
     ; This enum describes the underlying reason the transaction was created.  It's useful for rendering wallet GUIs
     ; more appropriately.
     ;;
    #_public
    (ยง enum Transaction.Purpose
        ;;; Used when the purpose of a transaction is genuinely unknown. ;;
        (ยง item UNKNOWN)
        ;;; Transaction created to satisfy a user payment request. ;;
        (ยง item USER_PAYMENT)
        ;;; Transaction automatically created and broadcast in order to reallocate money from old to new keys. ;;
        (ยง item KEY_ROTATION)
        ;;; Transaction that uses up pledges to an assurance contract. ;;
        (ยง item ASSURANCE_CONTRACT_CLAIM)
        ;;; Transaction that makes a pledge to an assurance contract. ;;
        (ยง item ASSURANCE_CONTRACT_PLEDGE)
        ;;; Send-to-self transaction that exists just to create an output of the right size we can pledge. ;;
        (ยง item ASSURANCE_CONTRACT_STUB)
        ;;; Raise fee, e.g. child-pays-for-parent. ;;
        (ยง item RAISE_FEE)
        ;; In future: de/refragmentation, privacy boosting/mixing, etc.
        ;; When adding a value, it also needs to be added to wallet.proto, WalletProtobufSerialize.makeTxProto()
        ;; and WalletProtobufSerializer.readTransaction()!
    )

    #_private
    (ยง field- #_"Transaction.Purpose" :purpose Transaction.Purpose/UNKNOWN)

    ;;;
     ; This field can be used by applications to record the exchange rate that was valid when the transaction happened.
     ; It's optional.
     ;;
    #_nilable
    #_private
    (ยง field- #_"ExchangeRate" :exchange-rate)

    ;;;
     ; This field can be used to record the memo of the payment request that initiated the transaction.
     ; It's optional.
     ;;
    #_nilable
    #_private
    (ยง field- #_"String" :memo)

    ;; Below flags apply in the context of BIP 68.
     ; If this flag set, CTxIn::nSequence is NOT interpreted as a relative lock-time.
     ;;
    #_public
    #_static
    (ยง def #_"long" Transaction/SEQUENCE_LOCKTIME_DISABLE_FLAG (<< 1 31))

    ;; If CTxIn::nSequence encodes a relative lock-time and this flag
     ; is set, the relative lock-time has units of 512 seconds,
     ; otherwise it specifies blocks with a granularity of 1.
     ;;
    #_public
    #_static
    (ยง def #_"long" Transaction/SEQUENCE_LOCKTIME_TYPE_FLAG (<< 1 22))

    ;; If CTxIn::nSequence encodes a relative lock-time, this mask is
     ; applied to extract that lock-time from the sequence field.
     ;;
    #_public
    #_static
    (ยง def #_"long" Transaction/SEQUENCE_LOCKTIME_MASK 0x0000ffff)

    #_public
    (ยง constructor Transaction [#_"NetworkParameters" __params]
        (ยง super __params)

        (ยง assoc this :version 1)
        (ยง assoc this :inputs (ArrayList. #_"<>"))
        (ยง assoc this :outputs (ArrayList. #_"<>"))
        ;; We don't initialize appearsIn deliberately as it's only useful for transactions stored in the wallet.
        (ยง assoc this :length 8) ;; 8 for std fields
        this
    )

    ;;;
     ; Creates a transaction from the given serialized bytes, e.g. from a block or a tx network message.
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor Transaction [#_"NetworkParameters" __params, #_"byte[]" __payloadBytes]
        (ยง super __params, __payloadBytes, 0)
        this
    )

    ;;;
     ; Creates a transaction by reading payload starting from offset bytes in.  Length of a transaction is fixed.
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor Transaction [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"int" __offset]
        (ยง super __params, __payload, __offset)
        ;; inputs/outputs will be created in parse()
        this
    )

    ;;;
     ; Creates a transaction by reading payload starting from offset bytes in.  Length of a transaction is fixed.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param parseRetain Whether to retain the backing byte array for quick reserialization.
     ; If true and the backing byte array is invalidated due to modification of a field, then
     ; the cached bytes may be repopulated and retained if the message is serialized again in the future.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor Transaction [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"int" __offset, #_nilable #_"Message" __parent, #_"MessageSerializer" __setSerializer, #_"int" __length]
        (ยง super __params, __payload, __offset, __parent, __setSerializer, __length)
        this
    )

    ;;;
     ; Creates a transaction by reading payload.  Length of a transaction is fixed.
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor Transaction [#_"NetworkParameters" __params, #_"byte[]" __payload, #_nilable #_"Message" __parent, #_"MessageSerializer" __setSerializer, #_"int" __length]
        (ยง super __params, __payload, 0, __parent, __setSerializer, __length)
        this
    )

    ;;;
     ; Returns the transaction hash as you see them in the block explorer.
     ;;
    #_override
    #_public
    (ยง method #_"Sha256Hash" getHash []
        (when (nil? (:hash this))
            (ยง assoc this :hash (Sha256Hash/wrapReversed (Sha256Hash/hashTwice (.. this (unsafeBitcoinSerialize)))))
        )
        (:hash this)
    )

    ;;;
     ; Used by BitcoinSerializer.  The serializer has to calculate a hash for checksumming so to
     ; avoid wasting the considerable effort a set method is provided so the serializer can set it.
     ;
     ; No verification is performed on this hash.
     ;;
    (ยง method #_"void" setHash [#_"Sha256Hash" __hash]
        (ยง assoc this :hash __hash)
        nil
    )

    #_public
    (ยง method #_"String" getHashAsString []
        (.. this (getHash) (toString))
    )

    ;;;
     ; Gets the sum of the inputs, regardless of who owns them.
     ;;
    #_public
    (ยง method #_"Coin" getInputSum []
        (let [#_"Coin" __inputTotal Coin/ZERO]

            (doseq [#_"TransactionInput" __input (:inputs this)]
                (let [#_"Coin" __inputValue (.. __input (getValue))]
                    (when (some? __inputValue)
                        (ยง ass __inputTotal (.. __inputTotal (add __inputValue)))
                    )
                )
            )

            __inputTotal
        )
    )

    ;;;
     ; Calculates the sum of the outputs that are sending coins to a key in the wallet.
     ;;
    #_public
    (ยง method #_"Coin" getValueSentToMe [#_"TransactionBag" __transactionBag]
        ;; This is tested in WalletTest.
        (let [#_"Coin" __v Coin/ZERO]
            (doseq [#_"TransactionOutput" __o (:outputs this)]
                (when (.. __o (isMine __transactionBag))
                    (ยง ass __v (.. __v (add (.. __o (getValue)))))
                )
            )
            __v
        )
    )

    ;;;
     ; Returns a map of block [hashes] which contain the transaction mapped to relativity counters, or null if this
     ; transaction doesn't have that data because it's not stored in the wallet or because it has never appeared in a
     ; block.
     ;;
    #_nilable
    #_public
    (ยง method #_"Map<Sha256Hash, Integer>" getAppearsInHashes []
        (when (some? (:appears-in-hashes this)) (ImmutableMap/copyOf (:appears-in-hashes this)))
    )

    ;;;
     ; Convenience wrapper around getConfidence().getConfidenceType().
     ; @return true if this transaction hasn't been seen in any block yet.
     ;;
    #_public
    (ยง method #_"boolean" isPending []
        (== (.. this (getConfidence) (getConfidenceType)) TransactionConfidence.ConfidenceType/PENDING)
    )

    ;;;
     ; <p>Puts the given block in the internal set of blocks in which this transaction appears.  This is
     ; used by the wallet to ensure transactions that appear on side chains are recorded properly even though
     ; the block stores do not save the transaction data at all.</p>
     ;
     ; <p>If there is a re-org this will be called once for each block that was previously seen, to update which block
     ; is the best chain.  The best chain block is guaranteed to be called last. So this must be idempotent.</p>
     ;
     ; <p>Sets updatedAt to be the earliest valid block time where this tx was seen.</p>
     ;
     ; @param block     The {@link StoredBlock} in which the transaction has appeared.
     ; @param bestChain Whether to set the updatedAt timestamp from the block header (only if not already set).
     ; @param relativityOffset A number that disambiguates the order of transactions within a block.
     ;;
    #_public
    (ยง method #_"void" setBlockAppearance [#_"StoredBlock" __block, #_"boolean" __bestChain, #_"int" __relativityOffset]
        (let [#_"long" __blockTime (* (.. __block (getHeader) (getTimeSeconds)) 1000)]
            (when (and __bestChain (or (nil? (:updated-at this)) (== (.. (:updated-at this) (getTime)) 0) (< __blockTime (.. (:updated-at this) (getTime)))))
                (ยง assoc this :updated-at (Date. __blockTime))
            )

            (.. this (addBlockAppearance (.. __block (getHeader) (getHash)), __relativityOffset))

            (when __bestChain
                (let [#_"TransactionConfidence" __transactionConfidence (.. this (getConfidence))]
                    ;; This sets type to BUILDING and depth to one.
                    (.. __transactionConfidence (setAppearedAtChainHeight (.. __block (getHeight))))
                )
            )
            nil
        )
    )

    #_public
    (ยง method #_"void" addBlockAppearance [#_"Sha256Hash" __blockHash, #_"int" __relativityOffset]
        ;; TODO: This could be a lot more memory efficient as we'll typically only store one element.
        (when (nil? (:appears-in-hashes this))
            (ยง assoc this :appears-in-hashes (TreeMap. #_"<>"))
        )

        (.. (:appears-in-hashes this) (put __blockHash, __relativityOffset))
        nil
    )

    ;;;
     ; Calculates the sum of the inputs that are spending coins with keys in the wallet.  This requires the
     ; transactions sending coins to those keys to be in the wallet.  This method will not attempt to download
     ; the blocks containing the input transactions if the key is in the wallet but the transactions are not.
     ;
     ; @return sum of the inputs that are spending coins with keys in the wallet.
     ;;
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"Coin" getValueSentFromMe [#_"TransactionBag" __wallet]
        ;; This is tested in WalletTest.
        (let [#_"Coin" __v Coin/ZERO]
            (doseq [#_"TransactionInput" __input (:inputs this)]
                ;; This input is taking value from a transaction in our wallet.  To discover the value,
                ;; we must find the connected transaction.
                (let [#_"TransactionOutput" __connected (.. __input (getConnectedOutput (.. __wallet (getTransactionPool WalletTransaction.Pool/UNSPENT))))]
                    (when (nil? __connected)
                        (ยง ass __connected (.. __input (getConnectedOutput (.. __wallet (getTransactionPool WalletTransaction.Pool/SPENT)))))
                    )
                    (when (nil? __connected)
                        (ยง ass __connected (.. __input (getConnectedOutput (.. __wallet (getTransactionPool WalletTransaction.Pool/PENDING)))))
                    )

                    ;; The connected output may be the change to the sender of a previous input sent to this wallet.
                    ;; In this case we ignore it.
                    (when (and (some? __connected) (.. __connected (isMine __wallet)))
                        (ยง ass __v (.. __v (add (.. __connected (getValue)))))
                    )
                )
            )
            __v
        )
    )

    ;;;
     ; Gets the sum of the outputs of the transaction.  If the outputs are less than the inputs, it does not count the fee.
     ; @return the sum of the outputs regardless of who owns them.
     ;;
    #_public
    (ยง method #_"Coin" getOutputSum []
        (let [#_"Coin" __totalOut Coin/ZERO]

            (doseq [#_"TransactionOutput" __output (:outputs this)]
                (ยง ass __totalOut (.. __totalOut (add (.. __output (getValue)))))
            )

            __totalOut
        )
    )

    #_nilable
    #_private
    (ยง field- #_"Coin" :cached-value)
    #_nilable
    #_private
    (ยง field- #_"TransactionBag" :cached-for-bag)

    ;;;
     ; Returns the difference of {@link Transaction#getValueSentToMe(TransactionBag)} and {@link Transaction#getValueSentFromMe(TransactionBag)}.
     ;;
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"Coin" getValue [#_"TransactionBag" __wallet]
        ;; FIXME: TEMP PERF HACK FOR ANDROID - this crap can go away once we have a real payments API.
        (let [#_"boolean" __isAndroid (Utils/isAndroidRuntime)]
            (when (and __isAndroid (some? (:cached-value this)) (== (:cached-for-bag this) __wallet))
                (ยง return (:cached-value this))
            )

            (let [#_"Coin" __result (.. this (getValueSentToMe __wallet) (subtract (.. this (getValueSentFromMe __wallet))))]
                (when __isAndroid
                    (ยง assoc this :cached-value __result)
                    (ยง assoc this :cached-for-bag __wallet)
                )
                __result
            )
        )
    )

    ;;;
     ; The transaction fee is the difference of the value of all inputs and the value of all outputs.
     ; Currently, the fee can only be determined for transactions created by us.
     ;
     ; @return fee, or null if it cannot be determined.
     ;;
    #_public
    (ยง method #_"Coin" getFee []
        (let [#_"Coin" __fee Coin/ZERO]
            (when (or (.. (:inputs this) (isEmpty)) (.. (:outputs this) (isEmpty))) ;; Incomplete transaction.
                (ยง return nil)
            )

            (doseq [#_"TransactionInput" __input (:inputs this)]
                (when (nil? (.. __input (getValue)))
                    (ยง return nil)
                )
                (ยง ass __fee (.. __fee (add (.. __input (getValue)))))
            )
            (doseq [#_"TransactionOutput" __output (:outputs this)]
                (ยง ass __fee (.. __fee (subtract (.. __output (getValue)))))
            )
            __fee
        )
    )

    ;;;
     ; Returns true if any of the outputs is marked as spent.
     ;;
    #_public
    (ยง method #_"boolean" isAnyOutputSpent []
        (doseq [#_"TransactionOutput" __output (:outputs this)]
            (when (not (.. __output (isAvailableForSpending)))
                (ยง return true)
            )
        )

        false
    )

    ;;;
     ; Returns false if this transaction has at least one output that is owned by the given wallet and unspent,
     ; true otherwise.
     ;;
    #_public
    (ยง method #_"boolean" isEveryOwnedOutputSpent [#_"TransactionBag" __transactionBag]
        (doseq [#_"TransactionOutput" __output (:outputs this)]
            (when (and (.. __output (isAvailableForSpending)) (.. __output (isMine __transactionBag)))
                (ยง return false)
            )
        )

        true
    )

    ;;;
     ; Returns the earliest time at which the transaction was seen (broadcast or included into the chain),
     ; or the epoch if that information isn't available.
     ;;
    #_public
    (ยง method #_"Date" getUpdateTime []
        ;; Older wallets did not store this field.  Set to the epoch.
        (when (nil? (:updated-at this))
            (ยง assoc this :updated-at (Date. 0))
        )
        (:updated-at this)
    )

    #_public
    (ยง method #_"void" setUpdateTime [#_"Date" __updatedAt]
        (ยง assoc this :updated-at __updatedAt)
        nil
    )

    ;;;
     ; These constants are a part of a scriptSig signature on the inputs.  They define the details of how a
     ; transaction can be redeemed, specifically, they control how the hash of the transaction is calculated.
     ;;
    #_public
    (ยง enum Transaction.SigHash
        (ยง item (ALL 1))
        (ยง item (NONE 2))
        (ยง item (SINGLE 3))
        (ยง item (ANYONECANPAY 0x80)) ;; Caution: Using this type in isolation is non-standard.  Treated similar to ANYONECANPAY_ALL.
        (ยง item (ANYONECANPAY_ALL 0x81))
        (ยง item (ANYONECANPAY_NONE 0x82))
        (ยง item (ANYONECANPAY_SINGLE 0x83))
        (ยง item (UNSET 0)) ;; Caution: Using this type in isolation is non-standard.  Treated similar to ALL.

        #_public
        (ยง field #_"int" :value)

        ;;;
         ; @param value
         ;;
        #_private
        (ยง constructor- #_"Transaction.SigHash" [#_"int" __value]
            (ยง assoc this :value __value)
            this
        )

        ;;;
         ; @return the value as a byte.
         ;;
        #_public
        (ยง method #_"byte" byteValue []
            (byte (:value this))
        )
    )

    #_override
    #_protected
    (ยง method #_"void" unCache []
        (.. super (unCache))
        (ยง assoc this :hash nil)
        nil
    )

    #_protected
    #_static
    (ยง defn #_"int" Transaction/calcLength [#_"byte[]" __buf, #_"int" __offset]
        ;; jump past version (uint32)
        (let [#_"int" __cursor (+ __offset 4)]

            (let [#_"VarInt" __varint (VarInt. __buf, __cursor)
                  #_"long" __txInCount (:value __varint)]
                (ยง ass __cursor (+ __cursor (.. __varint (getOriginalSizeInBytes))))

                (loop-when-recur [#_"int" __i 0] (< __i __txInCount) [(inc __i)]
                    ;; 36 = length of previous_outpoint
                    (ยง ass __cursor (+ __cursor 36))
                    (ยง ass __varint (VarInt. __buf, __cursor))
                    (let [#_"long" __scriptLen (:value __varint)]
                        ;; 4 = length of sequence field (unint32)
                        (ยง ass __cursor (+ __cursor __scriptLen 4 (.. __varint (getOriginalSizeInBytes))))
                    )
                )

                (ยง ass __varint (VarInt. __buf, __cursor))
                (let [#_"long" __txOutCount (:value __varint)]
                    (ยง ass __cursor (+ __cursor (.. __varint (getOriginalSizeInBytes))))

                    (loop-when-recur [#_"int" __i 0] (< __i __txOutCount) [(inc __i)]
                        ;; 8 = length of tx value field (uint64)
                        (ยง ass __cursor (+ __cursor 8))
                        (ยง ass __varint (VarInt. __buf, __cursor))
                        (let [#_"long" __scriptLen (:value __varint)]
                            (ยง ass __cursor (+ __cursor __scriptLen (.. __varint (getOriginalSizeInBytes))))
                        )
                    )
                    ;; 4 = length of lock_time field (uint32)
                    (+ (- __cursor __offset) 4)
                )
            )
        )
    )

    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        (ยง assoc this :cursor (:offset this))

        (ยง assoc this :version (.. this (readUint32)))
        (ยง assoc this :optimal-encoding-message-size 4)

        ;; First come the inputs.
        (let [#_"long" __numInputs (.. this (readVarInt))]
            (ยง assoc this :optimal-encoding-message-size (+ (:optimal-encoding-message-size this) (VarInt/sizeOf __numInputs)))
            (ยง assoc this :inputs (ArrayList. #_"<>" (int __numInputs)))
            (loop-when-recur [#_"long" __i 0] (< __i __numInputs) [(inc __i)]
                (let [#_"TransactionInput" __input (TransactionInput. (:params this), this, (:payload this), (:cursor this), (:serializer this))]
                    (.. (:inputs this) (add __input))
                    (let [#_"long" __scriptLen (.. this (readVarInt TransactionOutPoint/MESSAGE_LENGTH))]
                        (ยง assoc this :optimal-encoding-message-size (+ (:optimal-encoding-message-size this) TransactionOutPoint/MESSAGE_LENGTH (VarInt/sizeOf __scriptLen) __scriptLen 4))
                        (ยง assoc this :cursor (+ (:cursor this) __scriptLen 4))
                    )
                )
            )
            ;; Now the outputs.
            (let [#_"long" __numOutputs (.. this (readVarInt))]
                (ยง assoc this :optimal-encoding-message-size (+ (:optimal-encoding-message-size this) (VarInt/sizeOf __numOutputs)))
                (ยง assoc this :outputs (ArrayList. #_"<>" (int __numOutputs)))
                (loop-when-recur [#_"long" __i 0] (< __i __numOutputs) [(inc __i)]
                    (let [#_"TransactionOutput" __output (TransactionOutput. (:params this), this, (:payload this), (:cursor this), (:serializer this))]
                        (.. (:outputs this) (add __output))
                        (let [#_"long" __scriptLen (.. this (readVarInt 8))]
                            (ยง assoc this :optimal-encoding-message-size (+ (:optimal-encoding-message-size this) 8 (VarInt/sizeOf __scriptLen) __scriptLen))
                            (ยง assoc this :cursor (+ (:cursor this) __scriptLen))
                        )
                    )
                )
                (ยง assoc this :lock-time (.. this (readUint32)))
                (ยง assoc this :optimal-encoding-message-size (+ (:optimal-encoding-message-size this) 4))
                (ยง assoc this :length (- (:cursor this) (:offset this)))
                nil
            )
        )
    )

    #_public
    (ยง method #_"int" getOptimalEncodingMessageSize []
        (when (!= (:optimal-encoding-message-size this) 0)
            (ยง return (:optimal-encoding-message-size this))
        )

        (ยง assoc this :optimal-encoding-message-size (.. this (getMessageSize)))
        (:optimal-encoding-message-size this)
    )

    ;;;
     ; The priority (coin age) calculation doesn't use the regular message size, but rather one adjusted downwards
     ; for the number of inputs.  The goal is to incentivise cleaning up the UTXO set with free transactions, if one
     ; can do so.
     ;;
    #_public
    (ยง method #_"int" getMessageSizeForPriorityCalc []
        (let [#_"int" __size (.. this (getMessageSize))]
            (doseq [#_"TransactionInput" __input (:inputs this)]
                ;; 41: min size of an input
                ;; 110: enough to cover a compressed pubkey p2sh redemption (somewhat arbitrary)
                (let [#_"int" __benefit (+ 41 (Math/min 110, (.. __input (getScriptSig) (getProgram) (alength))))]
                    (when (< __benefit __size)
                        (ยง ass __size (- __size __benefit))
                    )
                )
            )
            __size
        )
    )

    ;;;
     ; A coinbase transaction is one that creates a new coin.  They are the first transaction in each block and their
     ; value is determined by a formula that all implementations of Bitcoin share.  In 2011 the value of a coinbase
     ; transaction is 50 coins, but in future it will be less.  A coinbase transaction is defined not only by its
     ; position in a block but by the data in the inputs.
     ;;
    #_public
    (ยง method #_"boolean" isCoinBase []
        (and (== (.. (:inputs this) (size)) 1) (.. (:inputs this) (get 0) (isCoinBase)))
    )

    ;;;
     ; A transaction is mature if it is either a building coinbase tx that is as deep or deeper than the required coinbase depth, or a non-coinbase tx.
     ;;
    #_public
    (ยง method #_"boolean" isMature []
        (when (not (.. this (isCoinBase)))
            (ยง return true)
        )

        (when (!= (.. this (getConfidence) (getConfidenceType)) TransactionConfidence.ConfidenceType/BUILDING)
            (ยง return false)
        )

        (<= (.. (:params this) (getSpendableCoinbaseDepth)) (.. this (getConfidence) (getDepthInBlocks)))
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (.. this (toString nil))
    )

    ;;;
     ; A human readable version of the transaction useful for debugging.  The format is not guaranteed to be stable.
     ; @param chain If provided, will be used to estimate lock times (if set).  Can be null.
     ;;
    #_public
    (ยง method #_"String" toString [#_nilable #_"AbstractBlockChain" __chain]
        (let [#_"StringBuilder" __sb (StringBuilder.)]
            (.. __sb (append "  ") (append (.. this (getHashAsString))) (append "\n"))
            (when (some? (:updated-at this))
                (.. __sb (append "  updated: ") (append (Utils/dateTimeFormat (:updated-at this))) (append "\n"))
            )
            (when (!= (:version this) 1)
                (.. __sb (append "  version ") (append (:version this)) (append "\n"))
            )
            (when (.. this (isTimeLocked))
                (.. __sb (append "  time locked until "))
                (cond (< (:lock-time this) Transaction/LOCKTIME_THRESHOLD)
                    (do
                        (.. __sb (append "block ") (append (:lock-time this)))
                        (when (some? __chain)
                            (.. __sb (append " (estimated to be reached at ") (append (Utils/dateTimeFormat (.. __chain (estimateBlockTime (int (:lock-time this)))))) (append ")"))
                        )
                    )
                    :else
                    (do
                        (.. __sb (append (Utils/dateTimeFormat (* (:lock-time this) 1000))))
                    )
                )
                (.. __sb (append "\n"))
            )
            (when (.. this (isOptInFullRBF))
                (.. __sb (append "  opts into full replace-by-fee\n"))
            )
            (when (.. this (isCoinBase))
                (let [#_"String" __script
                      #_"String" __script2]
                    (try
                        (ยง ass __script (.. (:inputs this) (get 0) (getScriptSig) (toString)))
                        (ยง ass __script2 (.. (:outputs this) (get 0) (getScriptPubKey) (toString)))
                        (catch ScriptException _
                            (ยง ass __script "???")
                            (ยง ass __script2 "???")
                        )
                    )
                    (.. __sb (append "     == COINBASE TXN (scriptSig ") (append __script) (append ")  (scriptPubKey ") (append __script2) (append ")\n"))
                    (ยง return (.. __sb (toString)))
                )
            )

            (cond (not (.. (:inputs this) (isEmpty)))
                (do
                    (doseq [#_"TransactionInput" __in (:inputs this)]
                        (.. __sb (append "     in   "))

                        (try
                            (let [#_"String" __scriptSigStr (.. __in (getScriptSig) (toString))]
                                (.. __sb (append (if (not (Strings/isNullOrEmpty __scriptSigStr)) __scriptSigStr "<no scriptSig>")))
                                (let [#_"Coin" __value (.. __in (getValue))]
                                    (when (some? __value)
                                        (.. __sb (append " ") (append (.. __value (toFriendlyString))))
                                    )
                                    (.. __sb (append "\n          outpoint:"))
                                    (let [#_"TransactionOutPoint" __outpoint (.. __in (getOutpoint))]
                                        (.. __sb (append (.. __outpoint (toString))))
                                        (let [#_"TransactionOutput" __connectedOutput (.. __outpoint (getConnectedOutput))]
                                            (when (some? __connectedOutput)
                                                (let [#_"Script" __scriptPubKey (.. __connectedOutput (getScriptPubKey))]
                                                    (when (or (.. __scriptPubKey (isSentToAddress)) (.. __scriptPubKey (isPayToScriptHash)))
                                                        (.. __sb (append " hash160:") (append (.. Utils/HEX (encode (.. __scriptPubKey (getPubKeyHash))))))
                                                    )
                                                )
                                            )
                                            (when (.. __in (hasSequence))
                                                (.. __sb (append "\n          sequence:") (append (Long/toHexString (.. __in (getSequenceNumber)))))
                                                (when (.. __in (isOptInFullRBF))
                                                    (.. __sb (append ", opts into full RBF"))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            (catch Exception __e
                                (.. __sb (append "[exception: ") (append (.. __e (getMessage))) (append "]"))
                            )
                        )
                        (.. __sb (append "\n"))
                    )
                )
                :else
                (do
                    (.. __sb (append "     INCOMPLETE: No inputs!\n"))
                )
            )

            (doseq [#_"TransactionOutput" __out (:outputs this)]
                (.. __sb (append "     out  "))
                (try
                    (let [#_"String" __scriptPubKeyStr (.. __out (getScriptPubKey) (toString))]
                        (.. __sb (append (if (not (Strings/isNullOrEmpty __scriptPubKeyStr)) __scriptPubKeyStr "<no scriptPubKey>")) (append " ") (append (.. __out (getValue) (toFriendlyString))))
                        (when (not (.. __out (isAvailableForSpending)))
                            (.. __sb (append " Spent"))
                        )
                        (let [#_"TransactionInput" __spentBy (.. __out (getSpentBy))]
                            (when (some? __spentBy)
                                (.. __sb (append " by ") (append (.. __spentBy (getParentTransaction) (getHashAsString))))
                            )
                        )
                    )
                    (catch Exception __e
                        (.. __sb (append "[exception: ") (append (.. __e (getMessage))) (append "]"))
                    )
                )
                (.. __sb (append "\n"))
            )

            (let [#_"Coin" __fee (.. this (getFee))]
                (when (some? __fee)
                    (let [#_"int" __size (.. this (unsafeBitcoinSerialize) (alength))]
                        (.. __sb (append "     fee  ") (append (.. __fee (multiply 1000) (divide __size) (toFriendlyString))) (append "/kB, ") (append (.. __fee (toFriendlyString))) (append " for ") (append __size) (append " bytes\n"))
                    )
                )
                (when (some? (:purpose this))
                    (.. __sb (append "     prps ") (append (:purpose this)) (append "\n"))
                )
                (.. __sb (toString))
            )
        )
    )

    ;;;
     ; Removes all the inputs from this transaction.
     ; Note that this also invalidates the length attribute.
     ;;
    #_public
    (ยง method #_"void" clearInputs []
        (.. this (unCache))
        (doseq [#_"TransactionInput" __input (:inputs this)]
            (.. __input (setParent nil))
        )
        (.. (:inputs this) (clear))
        ;; You wanted to reserialize, right?
        (ยง assoc this :length (.. this (unsafeBitcoinSerialize) (alength)))
        nil
    )

    ;;;
     ; Adds an input to this transaction that imports value from the given output.  Note that this input is <i>not</i>
     ; complete and after every input is added with {@link #addInput()} and every output is added with {@link #addOutput()},
     ; a {@link TransactionSigner} must be used to finalize the transaction and finish the inputs off.
     ; Otherwise it won't be accepted by the network.
     ; @return the newly created input.
     ;;
    #_public
    (ยง method #_"TransactionInput" addInput [#_"TransactionOutput" __from]
        (.. this (addInput (TransactionInput. (:params this), this, __from)))
    )

    ;;;
     ; Adds an input directly, with no checking that it's valid.
     ; @return the new input.
     ;;
    #_public
    (ยง method #_"TransactionInput" addInput [#_"TransactionInput" __input]
        (.. this (unCache))
        (.. __input (setParent this))
        (.. (:inputs this) (add __input))
        (.. this (adjustLength (.. (:inputs this) (size)), (:length __input)))
        __input
    )

    ;;;
     ; Creates and adds an input to this transaction, with no checking that it's valid.
     ; @return the newly created input.
     ;;
    #_public
    (ยง method #_"TransactionInput" addInput [#_"Sha256Hash" __spendTxHash, #_"long" __outputIndex, #_"Script" __script]
        (.. this (addInput (TransactionInput. (:params this), this, (.. __script (getProgram)), (TransactionOutPoint. (:params this), __outputIndex, __spendTxHash))))
    )

    ;;;
     ; Adds a new and fully signed input for the given parameters.  Note that this method is <b>not</b> thread safe
     ; and requires external synchronization.  Please refer to general documentation on Bitcoin scripting and contracts
     ; to understand the values of sigHash and anyoneCanPay: otherwise you can use the other form of this method
     ; that sets them to typical defaults.
     ;
     ; @throws ScriptException if the scriptPubKey is not a pay to address or pay to pubkey script.
     ;;
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"TransactionInput" addSignedInput [#_"TransactionOutPoint" __prevOut, #_"Script" __scriptPubKey, #_"ECKey" __sigKey, #_"Transaction.SigHash" __sigHash, #_"boolean" __anyoneCanPay]
        ;; Verify the API user didn't try to do operations out of order.
        (Preconditions/checkState (not (.. (:outputs this) (isEmpty))), "Attempting to sign tx without outputs.")

        (let [#_"TransactionInput" __input (TransactionInput. (:params this), this, (byte-array 0), __prevOut)]
            (.. this (addInput __input))
            (let [#_"Sha256Hash" __hash (.. this (hashForSignature (dec (.. (:inputs this) (size))), __scriptPubKey, __sigHash, __anyoneCanPay))
                  #_"ECKey.ECDSASignature" __ecSig (.. __sigKey (sign __hash))
                  #_"TransactionSignature" __txSig (TransactionSignature. __ecSig, __sigHash, __anyoneCanPay)]
                (cond (.. __scriptPubKey (isSentToRawPubKey))
                    (do
                        (.. __input (setScriptSig (ScriptBuilder/createInputScript __txSig)))
                    )
                    (.. __scriptPubKey (isSentToAddress))
                    (do
                        (.. __input (setScriptSig (ScriptBuilder/createInputScript __txSig, __sigKey)))
                    )
                    :else
                    (do
                        (throw (ScriptException. ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, (str "Don't know how to sign for this kind of scriptPubKey: " __scriptPubKey)))
                    )
                )
                __input
            )
        )
    )

    ;;;
     ; Same as {@link #addSignedInput(TransactionOutPoint, org.bitcoinj.script.Script, ECKey, org.bitcoinj.core.Transaction.SigHash, boolean)},
     ; but defaults to {@link SigHash#ALL} and "false" for the anyoneCanPay flag.  This is normally what you want.
     ;;
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"TransactionInput" addSignedInput [#_"TransactionOutPoint" __prevOut, #_"Script" __scriptPubKey, #_"ECKey" __sigKey]
        (.. this (addSignedInput __prevOut, __scriptPubKey, __sigKey, Transaction.SigHash/ALL, false))
    )

    ;;;
     ; Adds an input that points to the given output and contains a valid signature for it, calculated using the
     ; signing key.
     ;;
    #_public
    (ยง method #_"TransactionInput" addSignedInput [#_"TransactionOutput" __output, #_"ECKey" __signingKey]
        (.. this (addSignedInput (.. __output (getOutPointFor)), (.. __output (getScriptPubKey)), __signingKey))
    )

    ;;;
     ; Adds an input that points to the given output and contains a valid signature for it, calculated using the
     ; signing key.
     ;;
    #_public
    (ยง method #_"TransactionInput" addSignedInput [#_"TransactionOutput" __output, #_"ECKey" __signingKey, #_"Transaction.SigHash" __sigHash, #_"boolean" __anyoneCanPay]
        (.. this (addSignedInput (.. __output (getOutPointFor)), (.. __output (getScriptPubKey)), __signingKey, __sigHash, __anyoneCanPay))
    )

    ;;;
     ; Removes all the outputs from this transaction.
     ; Note that this also invalidates the length attribute.
     ;;
    #_public
    (ยง method #_"void" clearOutputs []
        (.. this (unCache))
        (doseq [#_"TransactionOutput" __output (:outputs this)]
            (.. __output (setParent nil))
        )
        (.. (:outputs this) (clear))
        ;; You wanted to reserialize, right?
        (ยง assoc this :length (.. this (unsafeBitcoinSerialize) (alength)))
        nil
    )

    ;;;
     ; Adds the given output to this transaction.  The output must be completely initialized.  Returns the given output.
     ;;
    #_public
    (ยง method #_"TransactionOutput" addOutput [#_"TransactionOutput" __to]
        (.. this (unCache))
        (.. __to (setParent this))
        (.. (:outputs this) (add __to))
        (.. this (adjustLength (.. (:outputs this) (size)), (:length __to)))
        __to
    )

    ;;;
     ; Creates an output based on the given address and value, adds it to this transaction, and returns the new output.
     ;;
    #_public
    (ยง method #_"TransactionOutput" addOutput [#_"Coin" __value, #_"Address" __address]
        (.. this (addOutput (TransactionOutput. (:params this), this, __value, __address)))
    )

    ;;;
     ; Creates an output that pays to the given pubkey directly (no address) with the given value, adds it to this
     ; transaction, and returns the new output.
     ;;
    #_public
    (ยง method #_"TransactionOutput" addOutput [#_"Coin" __value, #_"ECKey" __pubkey]
        (.. this (addOutput (TransactionOutput. (:params this), this, __value, __pubkey)))
    )

    ;;;
     ; Creates an output that pays to the given script.  The address and key forms are specialisations of this method,
     ; you won't normally need to use it unless you're doing unusual things.
     ;;
    #_public
    (ยง method #_"TransactionOutput" addOutput [#_"Coin" __value, #_"Script" __script]
        (.. this (addOutput (TransactionOutput. (:params this), this, __value, (.. __script (getProgram)))))
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.  The key
     ; must be usable for signing as-is: if the key is encrypted it must be decrypted first external to this method.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param redeemScript Byte-exact contents of the scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
    #_public
    (ยง method #_"TransactionSignature" calculateSignature [#_"int" __inputIndex, #_"ECKey" __key, #_"byte[]" __redeemScript, #_"Transaction.SigHash" __hashType, #_"boolean" __anyoneCanPay]
        (let [#_"Sha256Hash" __hash (.. this (hashForSignature __inputIndex, __redeemScript, __hashType, __anyoneCanPay))]
            (TransactionSignature. (.. __key (sign __hash)), __hashType, __anyoneCanPay)
        )
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param redeemScript The scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
    #_public
    (ยง method #_"TransactionSignature" calculateSignature [#_"int" __inputIndex, #_"ECKey" __key, #_"Script" __redeemScript, #_"Transaction.SigHash" __hashType, #_"boolean" __anyoneCanPay]
        (let [#_"Sha256Hash" __hash (.. this (hashForSignature __inputIndex, (.. __redeemScript (getProgram)), __hashType, __anyoneCanPay))]
            (TransactionSignature. (.. __key (sign __hash)), __hashType, __anyoneCanPay)
        )
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.  The key
     ; must be usable for signing as-is: if the key is encrypted it must be decrypted first external to this method.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param aesKey The AES key to use for decryption of the private key.  If null then no decryption is required.
     ; @param redeemScript Byte-exact contents of the scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
    #_public
    (ยง method #_"TransactionSignature" calculateSignature [#_"int" __inputIndex, #_"ECKey" __key, #_nilable #_"KeyParameter" __aesKey, #_"byte[]" __redeemScript, #_"Transaction.SigHash" __hashType, #_"boolean" __anyoneCanPay]
        (let [#_"Sha256Hash" __hash (.. this (hashForSignature __inputIndex, __redeemScript, __hashType, __anyoneCanPay))]
            (TransactionSignature. (.. __key (sign __hash, __aesKey)), __hashType, __anyoneCanPay)
        )
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param aesKey The AES key to use for decryption of the private key.  If null then no decryption is required.
     ; @param redeemScript The scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
    #_public
    (ยง method #_"TransactionSignature" calculateSignature [#_"int" __inputIndex, #_"ECKey" __key, #_nilable #_"KeyParameter" __aesKey, #_"Script" __redeemScript, #_"Transaction.SigHash" __hashType, #_"boolean" __anyoneCanPay]
        (let [#_"Sha256Hash" __hash (.. this (hashForSignature __inputIndex, (.. __redeemScript (getProgram)), __hashType, __anyoneCanPay))]
            (TransactionSignature. (.. __key (sign __hash, __aesKey)), __hashType, __anyoneCanPay)
        )
    )

    ;;;
     ; <p>Calculates a signature hash, that is, a hash of a simplified form of the transaction.  How exactly the transaction
     ; is simplified is specified by the type and anyoneCanPay parameters.</p>
     ;
     ; <p>This is a low level API and when using the regular {@link Wallet} class you don't have to call this yourself.
     ; When working with more complex transaction types and contracts, it can be necessary.  When signing a P2SH output
     ; the redeemScript should be the script encoded into the scriptSig field, for normal transactions, it's the
     ; scriptPubKey of the output you're signing for.</p>
     ;
     ; @param inputIndex Input the signature is being calculated for.  Tx signatures are always relative to an input.
     ; @param redeemScript The bytes that should be in the given input during signing.
     ; @param type Should be SigHash.ALL.
     ; @param anyoneCanPay Should be false.
     ;;
    #_public
    (ยง method #_"Sha256Hash" hashForSignature [#_"int" __inputIndex, #_"byte[]" __redeemScript, #_"Transaction.SigHash" __type, #_"boolean" __anyoneCanPay]
        (let [#_"byte" __sigHashType (byte (TransactionSignature/calcSigHashValue __type, __anyoneCanPay))]
            (.. this (hashForSignature __inputIndex, __redeemScript, __sigHashType))
        )
    )

    ;;;
     ; <p>Calculates a signature hash, that is, a hash of a simplified form of the transaction.  How exactly the transaction
     ; is simplified is specified by the type and anyoneCanPay parameters.</p>
     ;
     ; <p>This is a low level API and when using the regular {@link Wallet} class you don't have to call this yourself.
     ; When working with more complex transaction types and contracts, it can be necessary.  When signing a P2SH output
     ; the redeemScript should be the script encoded into the scriptSig field, for normal transactions, it's the
     ; scriptPubKey of the output you're signing for.</p>
     ;
     ; @param inputIndex Input the signature is being calculated for.  Tx signatures are always relative to an input.
     ; @param redeemScript The script that should be in the given input during signing.
     ; @param type Should be SigHash.ALL.
     ; @param anyoneCanPay Should be false.
     ;;
    #_public
    (ยง method #_"Sha256Hash" hashForSignature [#_"int" __inputIndex, #_"Script" __redeemScript, #_"Transaction.SigHash" __type, #_"boolean" __anyoneCanPay]
        (let [#_"int" __sigHash (TransactionSignature/calcSigHashValue __type, __anyoneCanPay)]
            (.. this (hashForSignature __inputIndex, (.. __redeemScript (getProgram)), (byte __sigHash)))
        )
    )

    ;;;
     ; This is required for signatures which use a sigHashType which cannot be represented using SigHash and anyoneCanPay.
     ; See transaction c99c49da4c38af669dea436d3e73780dfdb6c1ecf9958baa52960e8baee30e73, which has sigHashType 0.
     ;;
    #_public
    (ยง method #_"Sha256Hash" hashForSignature [#_"int" __inputIndex, #_"byte[]" __connectedScript, #_"byte" __sigHashType]
        ;; The SIGHASH flags are used in the design of contracts, please see this page for a further understanding of
        ;; the purposes of the code in this method:
        ;;
        ;;   https://en.bitcoin.it/wiki/Contracts

        (try
            ;; Create a copy of this transaction to operate upon because we need make changes to the inputs and outputs.
            ;; It would not be thread-safe to change the attributes of the transaction object itself.
            (let [#_"Transaction" __tx (.. (:params this) (getDefaultSerializer) (makeTransaction (.. this (bitcoinSerialize))))]

                ;; Clear input scripts in preparation for signing.  If we're signing a fresh transaction that step isn't very
                ;; helpful, but it doesn't add much cost relative to the actual EC math so we'll do it anyway.
                (loop-when-recur [#_"int" __i 0] (< __i (.. (:inputs __tx) (size))) [(inc __i)]
                    (.. (:inputs __tx) (get __i) (clearScriptBytes))
                )

                ;; This step has no purpose beyond being synchronized with Bitcoin Core's bugs.  OP_CODESEPARATOR
                ;; is a legacy holdover from a previous, broken design of executing scripts that shipped in Bitcoin 0.1.
                ;; It was seriously flawed and would have let anyone take anyone elses money.  Later versions switched to
                ;; the design we use today where scripts are executed independently but share a stack.  This left the
                ;; OP_CODESEPARATOR instruction having no purpose as it was only meant to be used internally, not actually
                ;; ever put into scripts.  Deleting OP_CODESEPARATOR is a step that should never be required but if we don't
                ;; do it, we could split off the main chain.
                (ยง ass __connectedScript (Script/removeAllInstancesOfOp __connectedScript, ScriptOpCodes/OP_CODESEPARATOR))

                ;; Set the input to the script of its output.  Bitcoin Core does this but the step has no obvious purpose as
                ;; the signature covers the hash of the prevout transaction which obviously includes the output script
                ;; already.  Perhaps it felt safer to him in some way, or is another leftover from how the code was written.
                (let [#_"TransactionInput" __input (.. (:inputs __tx) (get __inputIndex))]
                    (.. __input (setScriptBytes __connectedScript))

                    (cond (== (& __sigHashType 0x1f) (:value Transaction.SigHash/NONE))
                        (do
                            ;; SIGHASH_NONE means no outputs are signed at all - the signature is effectively for a "blank cheque".
                            (ยง assoc __tx :outputs (ArrayList. #_"<>" 0))
                            ;; The signature isn't broken by new versions of the transaction issued by other parties.
                            (loop-when-recur [#_"int" __i 0] (< __i (.. (:inputs __tx) (size))) [(inc __i)]
                                (when (!= __i __inputIndex)
                                    (.. (:inputs __tx) (get __i) (setSequenceNumber 0))
                                )
                            )
                        )
                        (== (& __sigHashType 0x1f) (:value Transaction.SigHash/SINGLE))
                        (do
                            ;; SIGHASH_SINGLE means only sign the output at the same index as the input (i.e. my output).
                            (when (<= (.. (:outputs __tx) (size)) __inputIndex)
                                ;; The input index is beyond the number of outputs, it's a buggy signature made by a broken
                                ;; Bitcoin implementation.  Bitcoin Core also contains a bug in handling this case:
                                ;; any transaction output that is signed in this case will result in both the signed output
                                ;; and any future outputs to this public key being steal-able by anyone who has
                                ;; the resulting signature and the public key (both of which are part of the signed tx input).

                                ;; Bitcoin Core's bug is that SignatureHash was supposed to return a hash and on this codepath it
                                ;; actually returns the constant "1" to indicate an error, which is never checked for.  Oops.
                                (ยง return (Sha256Hash/wrap "0100000000000000000000000000000000000000000000000000000000000000"))
                            )
                            ;; In SIGHASH_SINGLE the outputs after the matching input index are deleted, and the outputs before
                            ;; that position are "nulled out".  Unintuitively, the value in a "null" transaction is set to -1.
                            (ยง assoc __tx :outputs (ArrayList. #_"<>" (.. (:outputs __tx) (subList 0, (inc __inputIndex)))))
                            (loop-when-recur [#_"int" __i 0] (< __i __inputIndex) [(inc __i)]
                                (.. (:outputs __tx) (set __i, (TransactionOutput. (:params __tx), __tx, Coin/NEGATIVE_SATOSHI, (byte-array 0))))
                            )
                            ;; The signature isn't broken by new versions of the transaction issued by other parties.
                            (loop-when-recur [#_"int" __i 0] (< __i (.. (:inputs __tx) (size))) [(inc __i)]
                                (when (!= __i __inputIndex)
                                    (.. (:inputs __tx) (get __i) (setSequenceNumber 0))
                                )
                            )
                        )
                    )

                    (when (== (& __sigHashType (:value Transaction.SigHash/ANYONECANPAY)) (:value Transaction.SigHash/ANYONECANPAY))
                        ;; SIGHASH_ANYONECANPAY means the signature in the input is not broken by changes/additions/removals
                        ;; of other inputs.  For example, this is useful for building assurance contracts.
                        (ยง assoc __tx :inputs (ArrayList. #_"<TransactionInput>"))
                        (.. (:inputs __tx) (add __input))
                    )

                    (let [#_"ByteArrayOutputStream" __bos (ByteArrayOutputStream. (if (== (:length __tx) Message/UNKNOWN_LENGTH) 256 (+ (:length __tx) 4)))]
                        (.. __tx (bitcoinSerialize __bos))
                        ;; We also have to write a hash type (sigHashType is actually an unsigned char).
                        (Utils/uint32ToByteStreamLE (& 0x000000ff __sigHashType), __bos)
                        ;; Note that this is NOT reversed to ensure it will be signed correctly.  If it were to be printed out
                        ;; however then we would expect that it is IS reversed.
                        (let [#_"Sha256Hash" __hash (Sha256Hash/twiceOf (.. __bos (toByteArray)))]
                            (.. __bos (close))

                            (ยง return __hash)
                        )
                    )
                )
            )
            (catch IOException __e
                (throw (RuntimeException. __e)) ;; Cannot happen.
            )
        )
    )

    #_override
    #_protected
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __stream]
        (Utils/uint32ToByteStreamLE (:version this), __stream)
        (.. __stream (write (.. (VarInt. (.. (:inputs this) (size))) (encode))))
        (doseq [#_"TransactionInput" __in (:inputs this)]
            (.. __in (bitcoinSerialize __stream))
        )
        (.. __stream (write (.. (VarInt. (.. (:outputs this) (size))) (encode))))
        (doseq [#_"TransactionOutput" __out (:outputs this)]
            (.. __out (bitcoinSerialize __stream))
        )
        (Utils/uint32ToByteStreamLE (:lock-time this), __stream)
        nil
    )

    ;;;
     ; Transactions can have an associated lock time, specified either as a block height or in seconds since the
     ; UNIX epoch.  A transaction is not allowed to be confirmed by miners until the lock time is reached, and
     ; since Bitcoin 0.8+ a transaction that did not end its lock period (non final) is considered to be non
     ; standard and won't be relayed or included in the memory pool either.
     ;;
    #_public
    (ยง method #_"long" getLockTime []
        (:lock-time this)
    )

    ;;;
     ; Transactions can have an associated lock time, specified either as a block height or in seconds since the
     ; UNIX epoch.  A transaction is not allowed to be confirmed by miners until the lock time is reached, and
     ; since Bitcoin 0.8+ a transaction that did not end its lock period (non final) is considered to be non
     ; standard and won't be relayed or included in the memory pool either.
     ;;
    #_public
    (ยง method #_"void" setLockTime [#_"long" __lockTime]
        (.. this (unCache))
        (let [#_"boolean" __seqNumSet false]
            (doseq [#_"TransactionInput" __input (:inputs this)]
                (when (!= (.. __input (getSequenceNumber)) TransactionInput/NO_SEQUENCE)
                    (ยง ass __seqNumSet true)
                    (ยง break )
                )
            )
            (when (and (!= __lockTime 0) (or (not __seqNumSet) (.. (:inputs this) (isEmpty))))
                ;; At least one input must have a non-default sequence number for lock times to have any effect.
                ;; For instance one of them can be set to zero to make this feature work.
                (.. Transaction/log (warn "You are setting the lock time on a transaction but none of the inputs have non-default sequence numbers. This will not do what you expect!"))
            )
            (ยง assoc this :lock-time __lockTime)
            nil
        )
    )

    #_public
    (ยง method #_"long" getVersion []
        (:version this)
    )

    #_public
    (ยง method #_"void" setVersion [#_"int" __version]
        (ยง assoc this :version __version)
        (.. this (unCache))
        nil
    )

    ;;; Returns an unmodifiable view of all inputs. ;;
    #_public
    (ยง method #_"List<TransactionInput>" getInputs []
        (Collections/unmodifiableList (:inputs this))
    )

    ;;; Returns an unmodifiable view of all outputs. ;;
    #_public
    (ยง method #_"List<TransactionOutput>" getOutputs []
        (Collections/unmodifiableList (:outputs this))
    )

    ;;;
     ; <p>Returns the list of transacion outputs, whether spent or unspent, that match a wallet by address or that are
     ; watched by a wallet, i.e. transaction outputs whose script's address is controlled by the wallet and transaction
     ; outputs whose script is watched by the wallet.</p>
     ;
     ; @param transactionBag The wallet that controls addresses and watches scripts.
     ; @return linked list of outputs relevant to the wallet in this transaction.
     ;;
    #_public
    (ยง method #_"List<TransactionOutput>" getWalletOutputs [#_"TransactionBag" __transactionBag]
        (let [#_"List<TransactionOutput>" __walletOutputs (LinkedList. #_"<>")]

            (doseq [#_"TransactionOutput" __o (:outputs this)]
                (when (.. __o (isMine __transactionBag))
                    (.. __walletOutputs (add __o))
                )
            )

            __walletOutputs
        )
    )

    ;;; Randomly re-orders the transaction outputs: good for privacy. ;;
    #_public
    (ยง method #_"void" shuffleOutputs []
        (Collections/shuffle (:outputs this))
        nil
    )

    ;;; Same as getInputs().get(index). ;;
    #_public
    (ยง method #_"TransactionInput" getInput [#_"long" __index]
        (.. (:inputs this) (get (int __index)))
    )

    ;;; Same as getOutputs().get(index). ;;
    #_public
    (ยง method #_"TransactionOutput" getOutput [#_"long" __index]
        (.. (:outputs this) (get (int __index)))
    )

    ;;;
     ; Returns the confidence object for this transaction from the {@link org.bitcoinj.core.TxConfidenceTable}
     ; referenced by the implicit {@link Context}.
     ;;
    #_public
    (ยง method #_"TransactionConfidence" getConfidence []
        (.. this (getConfidence (Context/get)))
    )

    ;;;
     ; Returns the confidence object for this transaction from the {@link org.bitcoinj.core.TxConfidenceTable}
     ; referenced by the given {@link Context}.
     ;;
    #_public
    (ยง method #_"TransactionConfidence" getConfidence [#_"Context" __context]
        (.. this (getConfidence (.. __context (getConfidenceTable))))
    )

    ;;;
     ; Returns the confidence object for this transaction from the {@link org.bitcoinj.core.TxConfidenceTable}.
     ;;
    #_public
    (ยง method #_"TransactionConfidence" getConfidence [#_"TxConfidenceTable" __table]
        (when (nil? (:confidence this))
            (ยง assoc this :confidence (.. __table (getOrCreate (.. this (getHash)))))
        )
        (:confidence this)
    )

    ;;; Check if the transaction has a known confidence. ;;
    #_public
    (ยง method #_"boolean" hasConfidence []
        (!= (.. this (getConfidence) (getConfidenceType)) TransactionConfidence.ConfidenceType/UNKNOWN)
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (.. this (getHash) (equals (.. (cast Transaction __o) (getHash))))
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (.. this (getHash) (hashCode))
    )

    ;;;
     ; Gets the count of regular SigOps in this transactions.
     ;;
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"int" getSigOpCount []
        (let [#_"int" __sigOps 0]
            (doseq [#_"TransactionInput" __input (:inputs this)]
                (ยง ass __sigOps (+ __sigOps (Script/getSigOpCount (.. __input (getScriptBytes)))))
            )
            (doseq [#_"TransactionOutput" __output (:outputs this)]
                (ยง ass __sigOps (+ __sigOps (Script/getSigOpCount (.. __output (getScriptBytes)))))
            )
            __sigOps
        )
    )

    ;;;
     ; Check block height is in coinbase input script, for use after BIP 34
     ; enforcement is enabled.
     ;;
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"void" checkCoinBaseHeight [#_"int" __height]
        (Preconditions/checkArgument (<= Block/BLOCK_HEIGHT_GENESIS __height))
        (Preconditions/checkState (.. this (isCoinBase)))

        ;; Check block height is in coinbase input script.
        (let [#_"TransactionInput" __in (.. this (getInputs) (get 0))
              #_"ScriptBuilder" __builder (ScriptBuilder.)]
            (.. __builder (number __height))
            (let [#_"byte[]" __expected (.. __builder (build) (getProgram))
                  #_"byte[]" __actual (.. __in (getScriptBytes))]
                (when (< (.. __actual (alength)) (.. __expected (alength)))
                    (throw (VerificationException.CoinbaseHeightMismatch. "Block height mismatch in coinbase."))
                )

                (loop-when-recur [#_"int" __scriptIdx 0] (< __scriptIdx (.. __expected (alength))) [(inc __scriptIdx)]
                    (when (!= (aget __actual __scriptIdx) (aget __expected __scriptIdx))
                        (throw (VerificationException.CoinbaseHeightMismatch. "Block height mismatch in coinbase."))
                    )
                )
                nil
            )
        )
    )

    ;;;
     ; <p>Checks the transaction contents for sanity, in ways that can be done in a standalone manner.
     ; Does <b>not</b> perform all checks on a transaction such as whether the inputs are already spent.
     ; Specifically this method verifies:</p>
     ;
     ; <ul>
     ;     <li>That there is at least one input and output.</li>
     ;     <li>That the serialized size is not larger than the max block size.</li>
     ;     <li>That no outputs have negative value.</li>
     ;     <li>That the outputs do not sum to larger than the max allowed quantity of coin in the system.</li>
     ;     <li>If the tx is a coinbase tx, the coinbase scriptSig size is within range.  Otherwise that
     ;     there are no coinbase inputs in the tx.</li>
     ; </ul>
     ;
     ; @throws VerificationException
     ;;
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"void" verify []
        (when (or (== (.. (:inputs this) (size)) 0) (== (.. (:outputs this) (size)) 0))
            (throw (VerificationException.EmptyInputsOrOutputs.))
        )
        (when (< Block/MAX_BLOCK_SIZE (.. this (getMessageSize)))
            (throw (VerificationException.LargerThanMaxBlockSize.))
        )

        (let [#_"Coin" __valueOut Coin/ZERO
              #_"HashSet<TransactionOutPoint>" __outpoints (HashSet. #_"<>")]
            (doseq [#_"TransactionInput" __input (:inputs this)]
                (when (.. __outpoints (contains (.. __input (getOutpoint))))
                    (throw (VerificationException.DuplicatedOutPoint.))
                )
                (.. __outpoints (add (.. __input (getOutpoint))))
            )
            (try
                (doseq [#_"TransactionOutput" __output (:outputs this)]
                    (when (< (.. __output (getValue) (signum)) 0) ;; getValue() can throw IllegalStateException
                        (throw (VerificationException.NegativeValueOutput.))
                    )

                    (ยง ass __valueOut (.. __valueOut (add (.. __output (getValue)))))
                    (when (and (.. (:params this) (hasMaxMoney)) (< 0 (.. __valueOut (compareTo (.. (:params this) (getMaxMoney))))))
                        (throw (IllegalArgumentException.))
                    )
                )
                (catch IllegalStateException _
                    (throw (VerificationException.ExcessiveValue.))
                )
                (catch IllegalArgumentException _
                    (throw (VerificationException.ExcessiveValue.))
                )
            )

            (cond (.. this (isCoinBase))
                (do
                    (let [#_"int" __n (.. (:inputs this) (get 0) (getScriptBytes) (alength))]
                        (when (not (<= 2 __n 100))
                            (throw (VerificationException.CoinbaseScriptSizeOutOfRange.))
                        )
                    )
                )
                :else
                (do
                    (doseq [#_"TransactionInput" __input (:inputs this)]
                        (when (.. __input (isCoinBase))
                            (throw (VerificationException.UnexpectedCoinbaseInput.))
                        )
                    )
                )
            )
            nil
        )
    )

    ;;;
     ; <p>A transaction is time locked if at least one of its inputs is non-final and it has a lock time.</p>
     ;
     ; <p>To check if this transaction is final at a given height and time, see {@link Transaction#isFinal(int, long)}.</p>
     ;;
    #_public
    (ยง method #_"boolean" isTimeLocked []
        (when (== (.. this (getLockTime)) 0)
            (ยง return false)
        )
        (doseq [#_"TransactionInput" __input (.. this (getInputs))]
            (when (.. __input (hasSequence))
                (ยง return true)
            )
        )
        false
    )

    ;;;
     ; Returns whether this transaction will opt into the
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki">full replace-by-fee</a> semantics.
     ;;
    #_public
    (ยง method #_"boolean" isOptInFullRBF []
        (doseq [#_"TransactionInput" __input (.. this (getInputs))]
            (when (.. __input (isOptInFullRBF))
                (ยง return true)
            )
        )
        false
    )

    ;;;
     ; <p>Returns true if this transaction is considered finalized and can be placed in a block.  Non-finalized
     ; transactions won't be included by miners and can be replaced with newer versions using sequence numbers.
     ; This is useful in certain types of <a href="http://en.bitcoin.it/wiki/Contracts">contracts</a>, such as
     ; micropayment channels.</p>
     ;
     ; <p>Note that currently the replacement feature is disabled in Bitcoin Core and will need to be
     ; re-activated before this functionality is useful.</p>
     ;;
    #_public
    (ยง method #_"boolean" isFinal [#_"int" __height, #_"long" __blockTimeSeconds]
        (let [#_"long" __time (.. this (getLockTime))]
            (or (< __time (if (< __time Transaction/LOCKTIME_THRESHOLD) __height __blockTimeSeconds)) (not (.. this (isTimeLocked))))
        )
    )

    ;;;
     ; Returns either the lock time as a date, if it was specified in seconds, or an estimate based on the time in
     ; the current head block if it was specified as a block time.
     ;;
    #_public
    (ยง method #_"Date" estimateLockTime [#_"AbstractBlockChain" __chain]
        (if (< (:lock-time this) Transaction/LOCKTIME_THRESHOLD) (.. __chain (estimateBlockTime (int (.. this (getLockTime))))) (Date. (* (.. this (getLockTime)) 1000)))
    )

    ;;;
     ; Returns the purpose for which this transaction was created.  See the javadoc for {@link Purpose} for more
     ; information on the point of this field and what it can be.
     ;;
    #_public
    (ยง method #_"Transaction.Purpose" getPurpose []
        (:purpose this)
    )

    ;;;
     ; Marks the transaction as being created for the given purpose.  See the javadoc for {@link Purpose} for more
     ; information on the point of this field and what it can be.
     ;;
    #_public
    (ยง method #_"void" setPurpose [#_"Transaction.Purpose" __purpose]
        (ยง assoc this :purpose __purpose)
        nil
    )

    ;;;
     ; Getter for {@link #exchangeRate}.
     ;;
    #_nilable
    #_public
    (ยง method #_"ExchangeRate" getExchangeRate []
        (:exchange-rate this)
    )

    ;;;
     ; Setter for {@link #exchangeRate}.
     ;;
    #_public
    (ยง method #_"void" setExchangeRate [#_"ExchangeRate" __exchangeRate]
        (ยง assoc this :exchange-rate __exchangeRate)
        nil
    )

    ;;;
     ; Returns the transaction {@link #memo}.
     ;;
    #_public
    (ยง method #_"String" getMemo []
        (:memo this)
    )

    ;;;
     ; Set the transaction {@link #memo}.  It can be used to record the memo of the payment request that initiated the
     ; transaction.
     ;;
    #_public
    (ยง method #_"void" setMemo [#_"String" __memo]
        (ยง assoc this :memo __memo)
        nil
    )
)

;;;
 ; This interface is used to abstract the {@link org.bitcoinj.wallet.Wallet} and the {@link org.bitcoinj.core.Transaction}.
 ;;
#_public
(ยง interface TransactionBag
    ;;; Returns true if this wallet contains a public key which hashes to the given hash. ;;
    (ยง method #_"boolean" isPubKeyHashMine [#_"byte[]" __pubkeyHash])

    ;;; Returns true if this wallet contains a keypair with the given public key. ;;
    (ยง method #_"boolean" isPubKeyMine [#_"byte[]" __pubkey])

    ;;; Returns true if this wallet knows the script corresponding to the given hash. ;;
    (ยง method #_"boolean" isPayToScriptHashMine [#_"byte[]" __payToScriptHash])

    ;;; Returns transactions from a specific pool. ;;
    (ยง method #_"Map<Sha256Hash, Transaction>" getTransactionPool [#_"WalletTransaction.Pool" __pool])
)

;;;
 ; Represents a single transaction broadcast that we are performing.  A broadcast occurs after a new transaction is created
 ; (typically by a {@link Wallet}) and needs to be sent to the network.  A broadcast can succeed or fail.  A success is
 ; defined as seeing the transaction be announced by peers via inv messages, thus indicating their acceptance.  A failure
 ; is defined as not reaching acceptance within a timeout period, or getting an explicit reject message from a peer
 ; indicating that the transaction was not acceptable.
 ;;
#_public
(ยง class TransactionBroadcast
    #_private
    #_static
    (ยง def- #_"Logger" TransactionBroadcast/log (LoggerFactory/getLogger TransactionBroadcast))

    #_private
    (ยง field- #_"SettableFuture<Transaction>" :future (SettableFuture/create))
    #_private
    (ยง field- #_"PeerGroup" :peer-group)
    #_private
    (ยง field- #_"Transaction" :tx)
    #_private
    (ยง field- #_"int" :min-connections)
    #_private
    (ยง field- #_"int" :num-waiting-for)

    ;;; Used for shuffling the peers before broadcast: unit tests can replace this to make themselves deterministic. ;;
    #_testing
    #_public
    #_static
    (ยง def #_"Random" TransactionBroadcast/RANDOM (Random.))

    ;; Tracks which nodes sent us a reject message about this broadcast, if any.  Useful for debugging.
    #_private
    (ยง field- #_"Map<Peer, RejectMessage>" :rejects (Collections/synchronizedMap (HashMap. #_"<Peer, RejectMessage>")))

    (ยง constructor TransactionBroadcast [#_"PeerGroup" __peerGroup, #_"Transaction" __tx]
        (ยง assoc this :peer-group __peerGroup)
        (ยง assoc this :tx __tx)
        (ยง assoc this :min-connections (Math/max 1, (.. __peerGroup (getMinBroadcastConnections))))
        this
    )

    ;; Only for mock broadcasts.
    #_private
    (ยง constructor- #_"TransactionBroadcast" [#_"Transaction" __tx]
        (ยง assoc this :peer-group nil)
        (ยง assoc this :tx __tx)
        this
    )

    #_testing
    #_public
    #_static
    (ยง defn #_"TransactionBroadcast" TransactionBroadcast/createMockBroadcast [#_"Transaction" __tx, #_"SettableFuture<Transaction>" __future]
        (ยง return (TransactionBroadcast. __tx)
        (ยง anon
            #_override
            #_public
            (ยง method #_"ListenableFuture<Transaction>" broadcast []
                __future
            )

            #_override
            #_public
            (ยง method #_"ListenableFuture<Transaction>" future []
                __future
            )
        ))
    )

    #_public
    (ยง method #_"ListenableFuture<Transaction>" future []
        (:future this)
    )

    #_public
    (ยง method #_"void" setMinConnections [#_"int" __minConnections]
        (ยง assoc this :min-connections __minConnections)
        nil
    )

    #_private
    (ยง field- #_"PreMessageReceivedEventListener" :rejection-listener (PreMessageReceivedEventListener.
        (ยง anon
            #_override
            #_public
            (ยง method #_"Message" onPreMessageReceived [#_"Peer" __peer, #_"Message" __m]
                (when (instance? RejectMessage __m)
                    (let [#_"RejectMessage" __rejectMessage (cast RejectMessage __m)]
                        (when (.. (:tx this) (getHash) (equals (.. __rejectMessage (getRejectedObjectHash))))
                            (.. (:rejects this) (put __peer, __rejectMessage))
                            (let [#_"int" __size (.. (:rejects this) (size))
                                  #_"long" __threshold (Math/round (/ (:num-waiting-for this) 2.0))]
                                (when (< __threshold __size)
                                    (.. TransactionBroadcast/log (warn "Threshold for considering broadcast rejected has been reached ({}/{})", __size, __threshold))
                                    (.. (:future this) (setException (RejectedTransactionException. (:tx this), __rejectMessage)))
                                    (.. (:peer-group this) (removePreMessageReceivedEventListener this))
                                )
                            )
                        )
                    )
                )
                __m
            )
        )))

    #_public
    (ยง method #_"ListenableFuture<Transaction>" broadcast []
        (.. (:peer-group this) (addPreMessageReceivedEventListener Threading/SAME_THREAD, (:rejection-listener this)))
        (.. TransactionBroadcast/log (info "Waiting for {} peers required for broadcast, we have {} ...", (:min-connections this), (.. (:peer-group this) (getConnectedPeers) (size))))
        (.. (:peer-group this) (waitForPeers (:min-connections this)) (addListener (TransactionBroadcast.EnoughAvailablePeers.), Threading/SAME_THREAD))
        (:future this)
    )

    #_private
    (ยง class- TransactionBroadcast.EnoughAvailablePeers (ยง implements Runnable)
        #_override
        #_public
        (ยง method #_"void" run []
            ;; We now have enough connected peers to send the transaction.
            ;; This can be called immediately if we already have enough.  Otherwise it'll be called from a peer thread.

            ;; We will send the tx simultaneously to half the connected peers and wait to hear back from at least half
            ;; of the other half, i.e. with 4 peers connected we will send the tx to 2 randomly chosen peers, and then
            ;; wait for it to show up on one of the other two.  This will be taken as sign of network acceptance.  As can
            ;; be seen, 4 peers is probably too little - it doesn't taken many broken peers for tx propagation to have
            ;; a big effect.
            (let [#_"List<Peer>" __peers (.. (:peer-group this) (getConnectedPeers))] ;; snapshots
                ;; Prepare to send the transaction by adding a listener that'll be called when confidence changes.
                ;; Only bother with this if we might actually hear back:
                (when (< 1 (:min-connections this))
                    (.. (:tx this) (getConfidence) (addEventListener (TransactionBroadcast.ConfidenceChange.)))
                )
                ;; Bitcoin Core sends an inv in this case and then lets the peer request the tx data.  We just
                ;; blast out the TX here for a couple of reasons.  Firstly it's simpler: in the case where we have
                ;; just a single connection we don't have to wait for getdata to be received and handled before
                ;; completing the future in the code immediately below.  Secondly, it's faster.  The reason the
                ;; Bitcoin Core sends an inv is privacy - it means you can't tell if the peer originated the
                ;; transaction or not.  However, we are not a fully validating node and this is advertised in
                ;; our version message, as SPV nodes cannot relay it doesn't give away any additional information
                ;; to skip the inv here - we wouldn't send invs anyway.
                (let [#_"int" __numConnected (.. __peers (size))
                      #_"int" __numToBroadcastTo (int (Math/max 1, (Math/round (Math/ceil (/ (.. __peers (size)) 2.0)))))]
                    (ยง assoc this :num-waiting-for (int (Math/ceil (/ (- (.. __peers (size)) __numToBroadcastTo) 2.0))))
                    (Collections/shuffle __peers, TransactionBroadcast/RANDOM)
                    (ยง ass __peers (.. __peers (subList 0, __numToBroadcastTo)))
                    (.. TransactionBroadcast/log (info "broadcastTransaction: We have {} peers, adding {} to the memory pool", __numConnected, (.. (:tx this) (getHashAsString))))
                    (.. TransactionBroadcast/log (info "Sending to {} peers, will wait for {}, sending to: {}", __numToBroadcastTo, (:num-waiting-for this), (.. (Joiner/on ",") (join __peers))))
                    (doseq [#_"Peer" __peer __peers]
                        (try
                            (.. __peer (sendMessage (:tx this)))
                            ;; We don't record the peer as having seen the tx in the memory pool because we want to track only
                            ;; how many peers announced to us.
                            (catch Exception __e
                                (.. TransactionBroadcast/log (error "Caught exception sending to {}", __peer, __e))
                            )
                        )
                    )
                    ;; If we've been limited to talk to only one peer, we can't wait to hear back because the
                    ;; remote peer won't tell us about transactions we just announced to it for obvious reasons.
                    ;; So we just have to assume we're done, at that point.  This happens when we're not given
                    ;; any peer discovery source and the user just calls connectTo() once.
                    (when (== (:min-connections this) 1)
                        (.. (:peer-group this) (removePreMessageReceivedEventListener (:rejection-listener this)))
                        (.. (:future this) (set (:tx this)))
                    )
                    nil
                )
            )
        )
    )

    #_private
    (ยง field- #_"int" :num-seem-peers)
    #_private
    (ยง field- #_"boolean" :mined)

    #_private
    (ยง class- TransactionBroadcast.ConfidenceChange (ยง implements TransactionConfidence.Listener)
        #_override
        #_public
        (ยง method #_"void" onConfidenceChanged [#_"TransactionConfidence" __conf, #_"TransactionConfidence.Listener.ChangeReason" __reason]
            ;; The number of peers that announced this tx has gone up.
            (let [#_"int" __numSeenPeers (+ (.. __conf (numBroadcastPeers)) (.. (:rejects this) (size)))
                  #_"boolean" __mined (some? (.. (:tx this) (getAppearsInHashes)))]
                (.. TransactionBroadcast/log (info "broadcastTransaction: {}:  TX {} seen by {} peers{}", __reason, (.. (:tx this) (getHashAsString)), __numSeenPeers, (if __mined " and mined" "")))

                ;; Progress callback on the requested thread.
                (.. this (invokeAndRecord __numSeenPeers, __mined))

                (when (or (<= (:num-waiting-for this) __numSeenPeers) __mined)
                    ;; We've seen the min required number of peers announce the transaction, or it was included
                    ;; in a block.  Normally we'd expect to see it fully propagate before it gets mined, but
                    ;; it can be that a block is solved very soon after broadcast, and it's also possible that
                    ;; due to version skew and changes in the relay rules our transaction is not going to
                    ;; fully propagate yet can get mined anyway.
                    ;;
                    ;; Note that we can't wait for the current number of connected peers right now because we
                    ;; could have added more peers after the broadcast took place, which means they won't
                    ;; have seen the transaction.  In future when peers sync up their memory pools after they
                    ;; connect we could come back and change this.
                    ;;
                    ;; We're done!  It's important that the PeerGroup lock is not held (by this thread) at this
                    ;; point to avoid triggering inversions when the Future completes.
                    (.. TransactionBroadcast/log (info "broadcastTransaction: {} complete", (.. (:tx this) (getHash))))
                    (.. (:peer-group this) (removePreMessageReceivedEventListener (:rejection-listener this)))
                    (.. __conf (removeEventListener this))
                    (.. (:future this) (set (:tx this))) ;; RE-ENTRANCY POINT
                )
                nil
            )
        )
    )

    #_private
    (ยง method- #_"void" invokeAndRecord [#_"int" __numSeenPeers, #_"boolean" __mined]
        (ยง sync this
            (ยง assoc this :num-seem-peers __numSeenPeers)
            (ยง assoc this :mined __mined)
        )
        (.. this (invokeProgressCallback __numSeenPeers, __mined))
        nil
    )

    #_private
    (ยง method- #_"void" invokeProgressCallback [#_"int" __numSeenPeers, #_"boolean" __mined]
        (let [#_"TransactionBroadcast.ProgressCallback" __callback
              #_"Executor" __executor]
            (ยง sync this
                (ยง ass __callback (:callback this))
                (ยง ass __executor (:progress-callback-executor this))
            )
            (when (some? __callback)
                (let [#_"double" __progress (Math/min 1.0, (if __mined 1.0 (/ __numSeenPeers (double (:num-waiting-for this)))))]
                    (Preconditions/checkState (<= 0.0 __progress 1.0), __progress)
                    (try
                        (cond (nil? __executor)
                            (do
                                (.. __callback (onBroadcastProgress __progress))
                            )
                            :else
                            (do
                                (.. __executor (execute (Runnable.)
                                (ยง anon
                                    #_override
                                    #_public
                                    (ยง method #_"void" run []
                                        (.. __callback (onBroadcastProgress __progress))
                                        nil
                                    )
                                )))
                            )
                        )
                        (catch Throwable __e
                            (.. TransactionBroadcast/log (error "Exception during progress callback", __e))
                        )
                    )
                )
            )
            nil
        )
    )

    ;;; An interface for receiving progress information on the propagation of the tx, from 0.0 to 1.0 ;;
    #_public
    (ยง interface TransactionBroadcast.ProgressCallback
        ;;;
         ; onBroadcastProgress will be invoked on the provided executor when the progress of the transaction
         ; broadcast has changed, because the transaction has been announced by another peer or because the transaction
         ; was found inside a mined block (in this case progress will go to 1.0 immediately).  Any exceptions thrown
         ; by this callback will be logged and ignored.
         ;;
        (ยง method #_"void" onBroadcastProgress [#_"double" __progress])
    )

    #_nilable
    #_private
    (ยง field- #_"TransactionBroadcast.ProgressCallback" :callback)
    #_nilable
    #_private
    (ยง field- #_"Executor" :progress-callback-executor)

    ;;;
     ; Sets the given callback for receiving progress values, which will run on the user thread.
     ; See {@link org.bitcoinj.utils.Threading} for details.  If the broadcast has already started then the callback will
     ; be invoked immediately with the current progress.
     ;;
    #_public
    (ยง method #_"void" setProgressCallback [#_"TransactionBroadcast.ProgressCallback" __callback]
        (.. this (setProgressCallback __callback, Threading/USER_THREAD))
        nil
    )

    ;;;
     ; Sets the given callback for receiving progress values, which will run on the given executor.  If the executor
     ; is null, then the callback will run on a network thread and may be invoked multiple times in parallel.  You
     ; probably want to provide your UI thread or Threading.USER_THREAD for the second parameter.  If the broadcast
     ; has already started, then the callback will be invoked immediately with the current progress.
     ;;
    #_public
    (ยง method #_"void" setProgressCallback [#_"TransactionBroadcast.ProgressCallback" __callback, #_nilable #_"Executor" __executor]
        (let [#_"boolean" __shouldInvoke
              #_"int" __num
              #_"boolean" __mined]
            (ยง sync this
                (ยง assoc this :callback __callback)
                (ยง assoc this :progress-callback-executor __executor)
                (ยง ass __num (:num-seem-peers this))
                (ยง ass __mined (:mined this))
                (ยง ass __shouldInvoke (< 0 (:num-waiting-for this)))
            )
            (when __shouldInvoke
                (.. this (invokeProgressCallback __num, __mined))
            )
            nil
        )
    )
)

;;;
 ; A general interface which declares the ability to broadcast transactions.
 ; This is implemented by {@link org.bitcoinj.core.PeerGroup}.
 ;;
#_public
(ยง interface TransactionBroadcaster
    ;;; Broadcast the given transaction on the network. ;;
    (ยง method #_"TransactionBroadcast" broadcastTransaction [#_"Transaction" __tx])
)

;; TODO: Modify the getDepthInBlocks method to require the chain height to be specified, in preparation for ceasing to touch every tx on every block.

;;;
 ; <p>A TransactionConfidence object tracks data you can use to make a confidence decision about a transaction.
 ; It also contains some pre-canned rules for common scenarios: if you aren't really sure what level of confidence
 ; you need, these should prove useful.  You can get a confidence object using {@link Transaction#getConfidence()}.
 ; They cannot be constructed directly.</p>
 ;
 ; <p>Confidence in a transaction can come in multiple ways:</p>
 ;
 ; <ul>
 ; <li>Because you created it yourself and only you have the necessary keys.</li>
 ; <li>Receiving it from a fully validating peer you know is trustworthy, for instance, because it's run by yourself.</li>
 ; <li>Receiving it from a peer on the network you randomly chose.  If your network connection is not being
 ;     intercepted, you have a pretty good chance of connecting to a node that is following the rules.</li>
 ; <li>Receiving it from multiple peers on the network.  If your network connection is not being intercepted,
 ;     hearing about a transaction from multiple peers indicates the network has accepted the transaction and
 ;     thus miners likely have too (miners have the final say in whether a transaction becomes valid or not).</li>
 ; <li>Seeing the transaction appear appear in a block on the main chain.  Your confidence increases as the transaction
 ;     becomes further buried under work.  Work can be measured either in blocks (roughly, units of time), or
 ;     amount of work done.</li>
 ; </ul>
 ;
 ; <p>Alternatively, you may know that the transaction is "dead", that is, one or more of its inputs have
 ; been double spent and will never confirm unless there is another re-org.</p>
 ;
 ; <p>TransactionConfidence is updated via the {@link org.bitcoinj.core.TransactionConfidence#incrementDepthInBlocks()}
 ; method to ensure the block depth is up to date.</p>
 ; To make a copy that won't be changed, use {@link org.bitcoinj.core.TransactionConfidence#duplicate()}.
 ;;
#_public
(ยง class TransactionConfidence
    ;;;
     ; The peers that have announced the transaction to us.  Network nodes don't have stable identities, so we use
     ; IP address as an approximation.  It's obviously vulnerable to being gamed if we allow arbitrary people to connect
     ; to us, so only peers we explicitly connected to should go here.
     ;;
    #_private
    (ยง field- #_"CopyOnWriteArrayList<PeerAddress>" :broadcast-by)
    ;;; The time the transaction was last announced to us. ;;
    #_private
    (ยง field- #_"Date" :last-broadcasted-at)
    ;;; The Transaction that this confidence object is associated with. ;;
    #_private
    (ยง field- #_"Sha256Hash" :hash)
    ;; Lazily created listeners array.
    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<TransactionConfidence.Listener>>" :listeners)

    ;; The depth of the transaction on the best chain in blocks.  An unconfirmed block has depth 0.
    #_private
    (ยง field- #_"int" :depth)

    ;;; Describes the state of the transaction in general terms.  Properties can be read to learn specifics. ;;
    #_public
    (ยง enum TransactionConfidence.ConfidenceType
        ;;; If BUILDING, then the transaction is included in the best chain and your confidence in it is increasing. ;;
        (ยง item (BUILDING 1))

        ;;;
         ; If PENDING, then the transaction is unconfirmed and should be included shortly, as long as it is being
         ; announced and is considered valid by the network.  A pending transaction will be announced if the containing
         ; wallet has been attached to a live {@link PeerGroup} using {@link PeerGroup#addWallet(Wallet)}.
         ; You can estimate how likely the transaction is to be included by connecting to a bunch of nodes then measuring
         ; how many announce it, using {@link org.bitcoinj.core.TransactionConfidence#numBroadcastPeers()}.
         ; Or if you saw it from a trusted peer, you can assume it's valid and will get mined sooner or later as well.
         ;;
        (ยง item (PENDING 2))

        ;;;
         ; If DEAD, then it means the transaction won't confirm unless there is another re-org,
         ; because some other transaction is spending one of its inputs.  Such transactions should be alerted to the user
         ; so they can take action, e.g. suspending shipment of goods if they are a merchant.
         ; It can also mean that a coinbase transaction has been made dead from it being moved onto a side chain.
         ;;
        (ยง item (DEAD 4))

        ;;;
         ; If IN_CONFLICT, then it means there is another transaction (or several other transactions) spending one
         ; (or several) of its inputs but nor this transaction nor the other/s transaction/s are included in the best chain.
         ; The other/s transaction/s should be IN_CONFLICT too.
         ; IN_CONFLICT can be thought as an intermediary state between a. PENDING and BUILDING or b. PENDING and DEAD.
         ; Another common name for this situation is "double spend".
         ;;
        (ยง item (IN_CONFLICT 5))

        ;;;
         ; If a transaction hasn't been broadcast yet, or there's no record of it, its confidence is UNKNOWN.
         ;;
        (ยง item (UNKNOWN 0))

        #_private
        (ยง field- #_"int" :value)

        (ยง constructor TransactionConfidence.ConfidenceType [#_"int" __value]
            (ยง assoc this :value __value)
            this
        )

        #_public
        (ยง method #_"int" getValue []
            (:value this)
        )
    )

    #_private
    (ยง field- #_"TransactionConfidence.ConfidenceType" :confidence-type TransactionConfidence.ConfidenceType/UNKNOWN)
    #_private
    (ยง field- #_"int" :appeared-at-chain-height -1)
    ;; The transaction that double spent this one, if any.
    #_private
    (ยง field- #_"Transaction" :overriding-transaction)

    ;;;
     ; Information about where the transaction was first seen (network, sent direct from peer, created by ourselves).
     ; Useful for risk analyzing pending transactions.  Probably not that useful after a tx is included in the chain,
     ; unless re-org double spends start happening frequently.
     ;;
    #_public
    (ยง enum TransactionConfidence.Source
        ;;; We don't know where the transaction came from. ;;
        (ยง item UNKNOWN)
        ;;; We got this transaction from a network peer. ;;
        (ยง item NETWORK)
        ;;; This transaction was created by our own wallet, so we know it's not a double spend. ;;
        (ยง item SELF)
    )
    #_private
    (ยง field- #_"TransactionConfidence.Source" :source TransactionConfidence.Source/UNKNOWN)

    #_public
    (ยง constructor TransactionConfidence [#_"Sha256Hash" __hash]
        ;; Assume a default number of peers for our set.
        (ยง assoc this :broadcast-by (CopyOnWriteArrayList. #_"<>"))
        (ยง assoc this :listeners (CopyOnWriteArrayList. #_"<>"))
        (ยง assoc this :hash __hash)
        this
    )

    ;;;
     ; <p>A confidence listener is informed when the level of {@link TransactionConfidence} is updated by something, like
     ; for example a {@link Wallet}.  You can add listeners to update your user interface or manage your order tracking
     ; system when confidence levels pass a certain threshold.  <b>Note that confidence can go down as well as up.</b>
     ; For example, this can happen if somebody is doing a double-spend attack against you.  Whilst it's unlikely, your
     ; code should be able to handle that in order to be correct.</p>
     ;
     ; <p>During listener execution, it's safe to remove the current listener but not others.</p>
     ;;
    #_public
    (ยง interface TransactionConfidence.Listener
        ;;; An enum that describes why a transaction confidence listener is being invoked (i.e. the class of change). ;;
        (ยง enum TransactionConfidence.Listener.ChangeReason
            ;;;
             ; Occurs when the type returned by {@link org.bitcoinj.core.TransactionConfidence#getConfidenceType()}
             ; has changed.  For example, if a PENDING transaction changes to BUILDING or DEAD, then this reason will
             ; be given.  It's a high level summary.
             ;;
            (ยง item TYPE)

            ;;;
             ; Occurs when a transaction that is in the best known block chain gets buried by another block.  If you're
             ; waiting for a certain number of confirmations, this is the reason to watch out for.
             ;;
            (ยง item DEPTH)

            ;;;
             ; Occurs when a pending transaction (not in the chain) was announced by another connected peers.  By
             ; watching the number of peers that announced a transaction go up, you can see whether it's being
             ; accepted by the network or not.  If all your peers announce, it's a pretty good bet the transaction
             ; is considered relayable and has thus reached the miners.
             ;;
            (ยง item SEEN_PEERS)
        )

        (ยง method #_"void" onConfidenceChanged [#_"TransactionConfidence" __confidence, #_"TransactionConfidence.Listener.ChangeReason" __reason])
    )

    ;; This is used to ensure that confidence objects which aren't referenced from anywhere but which have an event
    ;; listener set on them don't become eligible for garbage collection.  Otherwise the TxConfidenceTable, which only
    ;; has weak references to these objects, would not be enough to keep the event listeners working as transactions
    ;; propagate around the network - it cannot know directly if the API user is interested in the object, so it uses
    ;; heap reachability as a proxy for interest.
    ;;
    ;; We add ourselves to this set when a listener is added and remove ourselves when the listener list is empty.
    #_private
    #_static
    (ยง def- #_"Set<TransactionConfidence>" TransactionConfidence/PINNED_CONFIDENCE_OBJECTS (Collections/synchronizedSet (HashSet. #_"<TransactionConfidence>")))

    ;;;
     ; <p>Adds an event listener that will be run when this confidence object is updated.  The listener will be locked
     ; and is likely to be invoked on a peer thread.</p>
     ;
     ; <p>Note that this is NOT called when every block arrives.  Instead it is called when the transaction
     ; transitions between confidence states, i.e. from not being seen in the chain to being seen (not necessarily in
     ; the best chain).  If you want to know when the transaction gets buried under another block, consider using
     ; a future from {@link #getDepthFuture(int)}.</p>
     ;;
    #_public
    (ยง method #_"void" addEventListener [#_"Executor" __executor, #_"TransactionConfidence.Listener" __listener]
        (Preconditions/checkNotNull __listener)

        (.. (:listeners this) (addIfAbsent (ListenerRegistration. #_"<>" __listener, __executor)))
        (.. TransactionConfidence/PINNED_CONFIDENCE_OBJECTS (add this))
        nil
    )

    ;;;
     ; <p>Adds an event listener that will be run when this confidence object is updated.  The listener will be locked
     ; and is likely to be invoked on a peer thread.</p>
     ;
     ; <p>Note that this is NOT called when every block arrives.  Instead it is called when the transaction
     ; transitions between confidence states, i.e. from not being seen in the chain to being seen (not necessarily in
     ; the best chain).  If you want to know when the transaction gets buried under another block, implement a
     ; {@link BlockChainListener}, attach it to a {@link BlockChain} and then use the getters on the
     ; confidence object to determine the new depth.</p>
     ;;
    #_public
    (ยง method #_"void" addEventListener [#_"TransactionConfidence.Listener" __listener]
        (.. this (addEventListener Threading/USER_THREAD, __listener))
        nil
    )

    #_public
    (ยง method #_"boolean" removeEventListener [#_"TransactionConfidence.Listener" __listener]
        (Preconditions/checkNotNull __listener)

        (let [#_"boolean" __removed (ListenerRegistration/removeFromList __listener, (:listeners this))]
            (when (.. (:listeners this) (isEmpty))
                (.. TransactionConfidence/PINNED_CONFIDENCE_OBJECTS (remove this))
            )
            __removed
        )
    )

    ;;;
     ; Returns the chain height at which the transaction appeared if confidence type is BUILDING.
     ; @throws IllegalStateException if the confidence type is not BUILDING.
     ;;
    #_public
    #_synchronized
    (ยง method #_"int" getAppearedAtChainHeight []
        (when (!= (.. this (getConfidenceType)) TransactionConfidence.ConfidenceType/BUILDING)
            (throw (IllegalStateException. (str "Confidence type is " (.. this (getConfidenceType)) ", not BUILDING")))
        )
        (:appeared-at-chain-height this)
    )

    ;;;
     ; The chain height at which the transaction appeared, if it has been seen in the best chain.
     ; Automatically sets the current type to {@link ConfidenceType#BUILDING} and depth to one.
     ;;
    #_public
    #_synchronized
    (ยง method #_"void" setAppearedAtChainHeight [#_"int" __appearedAtChainHeight]
        (when (< __appearedAtChainHeight 0)
            (throw (IllegalArgumentException. "appearedAtChainHeight out of range"))
        )

        (ยง assoc this :appeared-at-chain-height __appearedAtChainHeight)
        (ยง assoc this :depth 1)
        (.. this (setConfidenceType TransactionConfidence.ConfidenceType/BUILDING))
        nil
    )

    ;;;
     ; Returns a general statement of the level of confidence you can have in this transaction.
     ;;
    #_public
    #_synchronized
    (ยง method #_"TransactionConfidence.ConfidenceType" getConfidenceType []
        (:confidence-type this)
    )

    ;;;
     ; Called by other objects in the system, like a {@link Wallet}, when new information about the confidence
     ; of a transaction becomes available.
     ;;
    #_public
    #_synchronized
    (ยง method #_"void" setConfidenceType [#_"TransactionConfidence.ConfidenceType" __confidenceType]
        (when (== __confidenceType (:confidence-type this))
            (ยง return nil)
        )

        (ยง assoc this :confidence-type __confidenceType)
        (when (!= __confidenceType TransactionConfidence.ConfidenceType/DEAD)
            (ยง assoc this :overriding-transaction nil)
        )
        (when (any == __confidenceType TransactionConfidence.ConfidenceType/PENDING TransactionConfidence.ConfidenceType/IN_CONFLICT)
            (ยง assoc this :depth 0)
            (ยง assoc this :appeared-at-chain-height -1)
        )
        nil
    )

    ;;;
     ; Called by a {@link Peer} when a transaction is pending and announced by a peer.  The more peers announce
     ; the transaction, the more peers have validated it (assuming your internet connection is not being intercepted).
     ; If confidence is currently unknown, sets it to {@link ConfidenceType#PENDING}.  Does not run listeners.
     ;
     ; @param address IP address of the peer, used as a proxy for identity.
     ; @return true if marked, false if this address was already seen.
     ;;
    #_public
    (ยง method #_"boolean" markBroadcastBy [#_"PeerAddress" __address]
        (ยง assoc this :last-broadcasted-at (Utils/now))
        (when (not (.. (:broadcast-by this) (addIfAbsent __address)))
            (ยง return false) ;; Duplicate.
        )

        (ยง sync this
            (when (== (.. this (getConfidenceType)) TransactionConfidence.ConfidenceType/UNKNOWN)
                (ยง assoc this :confidence-type TransactionConfidence.ConfidenceType/PENDING)
            )
        )
        true
    )

    ;;;
     ; Returns how many peers have been passed to {@link TransactionConfidence#markBroadcastBy}.
     ;;
    #_public
    (ยง method #_"int" numBroadcastPeers []
        (.. (:broadcast-by this) (size))
    )

    ;;;
     ; Returns a snapshot of {@link PeerAddress}es that announced the transaction.
     ;;
    #_public
    (ยง method #_"Set<PeerAddress>" getBroadcastBy []
        (let [#_"ListIterator<PeerAddress>" __iterator (.. (:broadcast-by this) (listIterator))]
            (Sets/newHashSet __iterator)
        )
    )

    ;;; Returns true if the given address has been seen via markBroadcastBy(). ;;
    #_public
    (ยง method #_"boolean" wasBroadcastBy [#_"PeerAddress" __address]
        (.. (:broadcast-by this) (contains __address))
    )

    ;;; Return the time the transaction was last announced to us. ;;
    #_public
    (ยง method #_"Date" getLastBroadcastedAt []
        (:last-broadcasted-at this)
    )

    ;;; Set the time the transaction was last announced to us. ;;
    #_public
    (ยง method #_"void" setLastBroadcastedAt [#_"Date" __lastBroadcastedAt]
        (ยง assoc this :last-broadcasted-at __lastBroadcastedAt)
        nil
    )

    #_override
    #_public
    #_synchronized
    (ยง method #_"String" toString []
        (let [#_"StringBuilder" __sb (StringBuilder.)
              #_"int" __peers (.. this (numBroadcastPeers))]
            (when (< 0 __peers)
                (.. __sb (append "Seen by ") (append __peers) (append (if (< 1 __peers) " peers" " peer")))
                (when (some? (:last-broadcasted-at this))
                    (.. __sb (append " (most recently: ") (append (Utils/dateTimeFormat (:last-broadcasted-at this))) (append ")"))
                )
                (.. __sb (append ". "))
            )
            (condp == (.. this (getConfidenceType))
                UNKNOWN     (.. __sb (append "Unknown confidence level."))
                DEAD        (.. __sb (append "Dead: overridden by double spend and will not confirm."))
                PENDING     (.. __sb (append "Pending/unconfirmed."))
                IN_CONFLICT (.. __sb (append "In conflict."))
                BUILDING    (.. __sb (append (String/format Locale/US, "Appeared in best chain at height %d, depth %d.", (.. this (getAppearedAtChainHeight)), (.. this (getDepthInBlocks)))))
            )
            (when (!= (:source this) TransactionConfidence.Source/UNKNOWN)
                (.. __sb (append " Source: ") (append (:source this)))
            )
            (.. __sb (toString))
        )
    )

    ;;;
     ; Called by the wallet when the tx appears on the best chain and a new block is added to the top.
     ; Updates the internal counter that tracks how deeply buried the block is.
     ;
     ; @return the new depth
     ;;
    #_public
    #_synchronized
    (ยง method #_"int" incrementDepthInBlocks []
        (ยง assoc this :depth (inc (:depth this)))
        (:depth this)
    )

    ;;;
     ; <p>Depth in the chain is an approximation of how much time has elapsed since the transaction has been confirmed.
     ; On average there is supposed to be a new block every 10 minutes, but the actual rate may vary.  Bitcoin Core
     ; considers a transaction impractical to reverse after 6 blocks, but as of EOY 2011 network
     ; security is high enough that often only one block is considered enough even for high value transactions.
     ; For low value transactions like songs, or other cheap items, no blocks at all may be necessary.</p>
     ;
     ; <p>If the transaction appears in the top block, the depth is one.  If it's anything else (pending, dead, unknown)
     ; the depth is zero.</p>
     ;;
    #_public
    #_synchronized
    (ยง method #_"int" getDepthInBlocks []
        (:depth this)
    )

    ;;
     ; Set the depth in blocks.  Having one block confirmation is a depth of one.
     ;;
    #_public
    #_synchronized
    (ยง method #_"void" setDepthInBlocks [#_"int" __depth]
        (ยง assoc this :depth __depth)
        nil
    )

    ;;;
     ; Erases the set of broadcast/seen peers.  This cannot be called whilst the confidence is PENDING.  It is useful
     ; for saving memory and wallet space once a tx is buried so deep it doesn't seem likely to go pending again.
     ;;
    #_public
    (ยง method #_"void" clearBroadcastBy []
        (Preconditions/checkState (!= (.. this (getConfidenceType)) TransactionConfidence.ConfidenceType/PENDING))
        (.. (:broadcast-by this) (clear))
        (ยง assoc this :last-broadcasted-at nil)
        nil
    )

    ;;;
     ; If this transaction has been overridden by a double spend (is dead), this call returns the overriding transaction.
     ; Note that this call <b>can return null</b> if you have migrated an old wallet, as pre-Jan 2012 wallets did not
     ; store this information.
     ;
     ; @return the transaction that double spent this one.
     ; @throws IllegalStateException if confidence type is not DEAD.
     ;;
    #_public
    #_synchronized
    (ยง method #_"Transaction" getOverridingTransaction []
        (when (!= (.. this (getConfidenceType)) TransactionConfidence.ConfidenceType/DEAD)
            (throw (IllegalStateException. (str "Confidence type is " (.. this (getConfidenceType)) ", not DEAD")))
        )
        (:overriding-transaction this)
    )

    ;;;
     ; Called when the transaction becomes newly dead, that is, we learn that one of its inputs has already been spent
     ; in such a way that the double-spending transaction takes precedence over this one.  It will not become valid now
     ; unless there is a re-org.  Automatically sets the confidence type to DEAD.  The overriding transaction may not
     ; directly double spend this one, but could also have double spent a dependency of this tx.
     ;;
    #_public
    #_synchronized
    (ยง method #_"void" setOverridingTransaction [#_nilable #_"Transaction" __overridingTransaction]
        (ยง assoc this :overriding-transaction __overridingTransaction)
        (.. this (setConfidenceType TransactionConfidence.ConfidenceType/DEAD))
        nil
    )

    ;;; Returns a copy of this object.  Event listeners are not duplicated. ;;
    #_public
    (ยง method #_"TransactionConfidence" duplicate []
        (let [#_"TransactionConfidence" __c (TransactionConfidence. (:hash this))]
            (.. (:broadcast-by __c) (addAll (:broadcast-by this)))
            (ยง assoc __c :last-broadcasted-at (:last-broadcasted-at this))
            (ยง sync this
                (ยง assoc __c :confidence-type (:confidence-type this))
                (ยง assoc __c :overriding-transaction (:overriding-transaction this))
                (ยง assoc __c :appeared-at-chain-height (:appeared-at-chain-height this))
            )
            __c
        )
    )

    ;;;
     ; Call this after adjusting the confidence, for cases where listeners should be notified.  This has to be done
     ; explicitly rather than being done automatically because sometimes complex changes to transaction states can
     ; result in a series of confidence changes that are not really useful to see separately.  By invoking listeners
     ; explicitly, more precise control is available.  Note that this will run the listeners on the user code thread.
     ;;
    #_public
    (ยง method #_"void" queueListeners [#_"TransactionConfidence.Listener.ChangeReason" __reason]
        (doseq [#_"ListenerRegistration<TransactionConfidence.Listener>" __registration (:listeners this)]
            (.. (:executor __registration) (execute (Runnable.)
            (ยง anon
                #_override
                #_public
                (ยง method #_"void" run []
                    (.. (:listener __registration) (onConfidenceChanged (ยง dhis TransactionConfidence), __reason))
                    nil
                )
            )))
        )
        nil
    )

    ;;;
     ; The source of a transaction tries to identify where it came from originally.  For instance, did we download it
     ; from the peer to peer network, or make it ourselves, or receive it via Bluetooth, or import it from another app,
     ; and so on.  This information is useful for {@link org.bitcoinj.wallet.CoinSelector} implementations to risk analyze
     ; transactions and decide when to spend them.
     ;;
    #_public
    #_synchronized
    (ยง method #_"TransactionConfidence.Source" getSource []
        (:source this)
    )

    ;;;
     ; The source of a transaction tries to identify where it came from originally.  For instance, did we download it
     ; from the peer to peer network, or make it ourselves, or receive it via Bluetooth, or import it from another app,
     ; and so on.  This information is useful for {@link org.bitcoinj.wallet.CoinSelector} implementations to risk analyze
     ; transactions and decide when to spend them.
     ;;
    #_public
    #_synchronized
    (ยง method #_"void" setSource [#_"TransactionConfidence.Source" __source]
        (ยง assoc this :source __source)
        nil
    )

    ;;;
     ; Returns a future that completes when the transaction has been confirmed by "depth" blocks.  For instance setting
     ; depth to one will wait until it appears in a block on the best chain, and zero will wait until it has been seen
     ; on the network.
     ;;
    #_public
    #_synchronized
    (ยง method #_"ListenableFuture<TransactionConfidence>" getDepthFuture [#_"int" __depth, #_"Executor" __executor]
        (let [#_"SettableFuture<TransactionConfidence>" __result (SettableFuture/create)]
            (when (<= __depth (.. this (getDepthInBlocks)))
                (.. __result (set this))
            )

            (.. this (addEventListener __executor, (TransactionConfidence.Listener.)
            (ยง anon
                #_override
                #_public
                (ยง method #_"void" onConfidenceChanged [#_"TransactionConfidence" __confidence, #_"TransactionConfidence.Listener.ChangeReason" __reason]
                    (when (<= __depth (.. this (getDepthInBlocks)))
                        (.. this (removeEventListener this))
                        (.. __result (set __confidence))
                    )
                    nil
                )
            )))
            __result
        )
    )

    #_public
    #_synchronized
    (ยง method #_"ListenableFuture<TransactionConfidence>" getDepthFuture [#_"int" __depth]
        (.. this (getDepthFuture __depth, Threading/USER_THREAD))
    )

    #_public
    (ยง method #_"Sha256Hash" getTransactionHash []
        (:hash this)
    )
)

;;;
 ; <p>A transfer of coins from one address to another creates a transaction in which the outputs
 ; can be claimed by the recipient in the input of another transaction.  You can imagine a
 ; transaction as being a module which is wired up to others, the inputs of one have to be wired
 ; to the outputs of another.  The exceptions are coinbase transactions, which create new coins.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class TransactionInput (ยง extends ChildMessage)
    ;;; Magic sequence number that indicates there is no sequence number. ;;
    #_public
    #_static
    (ยง def #_"long" TransactionInput/NO_SEQUENCE 0xffffffff)
    #_private
    #_static
    (ยง def- #_"byte[]" TransactionInput/EMPTY_ARRAY (byte-array 0))
    ;; Magic outpoint index that indicates the input is in fact unconnected.
    #_private
    #_static
    (ยง def- #_"long" TransactionInput/UNCONNECTED 0xffffffff)

    ;; Allows for altering transactions after they were broadcast.  Values below NO_SEQUENCE-1 mean it can be altered.
    #_private
    (ยง field- #_"long" :sequence)
    ;; Data needed to connect to the output of the transaction we're gathering coins from.
    #_private
    (ยง field- #_"TransactionOutPoint" :outpoint)
    ;; The "script bytes" might not actually be a script.  In coinbase transactions where new coins are minted there
    ;; is no input transaction, so instead the scriptBytes contains some extra stuff (like a rollover nonce) that we
    ;; don't care about much.  The bytes are turned into a Script object (cached below) on demand via a getter.
    #_private
    (ยง field- #_"byte[]" :script-bytes)
    ;; The Script object obtained from parsing scriptBytes.  Only filled in on demand and if the transaction is not
    ;; coinbase.
    #_private
    (ยง field- #_"WeakReference<Script>" :script-sig)
    ;;; Value of the output connected to the input, if known.  This field does not participate in equals()/hashCode(). ;;
    #_nilable
    #_private
    (ยง field- #_"Coin" :value)

    ;;;
     ; Creates an input that connects to nothing - used only in creation of coinbase transactions.
     ;;
    #_public
    (ยง constructor TransactionInput [#_"NetworkParameters" __params, #_nilable #_"Transaction" __parentTransaction, #_"byte[]" __scriptBytes]
        (ยง this __params, __parentTransaction, __scriptBytes, (TransactionOutPoint. __params, TransactionInput/UNCONNECTED, (cast Transaction nil)))
        this
    )

    #_public
    (ยง constructor TransactionInput [#_"NetworkParameters" __params, #_nilable #_"Transaction" __parentTransaction, #_"byte[]" __scriptBytes, #_"TransactionOutPoint" __outpoint]
        (ยง this __params, __parentTransaction, __scriptBytes, __outpoint, nil)
        this
    )

    #_public
    (ยง constructor TransactionInput [#_"NetworkParameters" __params, #_nilable #_"Transaction" __parentTransaction, #_"byte[]" __scriptBytes, #_"TransactionOutPoint" __outpoint, #_nilable #_"Coin" __value]
        (ยง super __params)

        (ยง assoc this :script-bytes __scriptBytes)
        (ยง assoc this :outpoint __outpoint)
        (ยง assoc this :sequence TransactionInput/NO_SEQUENCE)
        (ยง assoc this :value __value)
        (.. this (setParent __parentTransaction))
        (ยง assoc this :length (+ 40 (if (some? __scriptBytes) (+ (VarInt/sizeOf (.. __scriptBytes (alength))) (.. __scriptBytes (alength))) 1)))
        this
    )

    ;;;
     ; Creates an UNSIGNED input that links to the given output.
     ;;
    (ยง constructor TransactionInput [#_"NetworkParameters" __params, #_"Transaction" __parentTransaction, #_"TransactionOutput" __output]
        (ยง super __params)

        (let [#_"long" __outputIndex (.. __output (getIndex))]
            (if (some? (.. __output (getParentTransaction)))
                (ยง assoc this :outpoint (TransactionOutPoint. __params, __outputIndex, (.. __output (getParentTransaction))))
                (ยง assoc this :outpoint (TransactionOutPoint. __params, __output))
            )
            (ยง assoc this :script-bytes TransactionInput/EMPTY_ARRAY)
            (ยง assoc this :sequence TransactionInput/NO_SEQUENCE)
            (.. this (setParent __parentTransaction))
            (ยง assoc this :value (.. __output (getValue)))
            (ยง assoc this :length 41)
            this
        )
    )

    ;;;
     ; Deserializes an input message.  This is usually part of a transaction message.
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor TransactionInput [#_"NetworkParameters" __params, #_nilable #_"Transaction" __parentTransaction, #_"byte[]" __payload, #_"int" __offset]
        (ยง super __params, __payload, __offset)

        (.. this (setParent __parentTransaction))
        (ยง assoc this :value nil)
        this
    )

    ;;;
     ; Deserializes an input message.  This is usually part of a transaction message.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor TransactionInput [#_"NetworkParameters" __params, #_"Transaction" __parentTransaction, #_"byte[]" __payload, #_"int" __offset, #_"MessageSerializer" __serializer]
        (ยง super __params, __payload, __offset, __parentTransaction, __serializer, Message/UNKNOWN_LENGTH)

        (ยง assoc this :value nil)
        this
    )

    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        (ยง assoc this :outpoint (TransactionOutPoint. (:params this), (:payload this), (:cursor this), this, (:serializer this)))
        (ยง assoc this :cursor (+ (:cursor this) (.. (:outpoint this) (getMessageSize))))
        (let [#_"int" __scriptLen (int (.. this (readVarInt)))]
            (ยง assoc this :length (+ (- (:cursor this) (:offset this)) __scriptLen 4))
            (ยง assoc this :script-bytes (.. this (readBytes __scriptLen)))
            (ยง assoc this :sequence (.. this (readUint32)))
            nil
        )
    )

    #_override
    #_protected
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __stream]
        (.. (:outpoint this) (bitcoinSerialize __stream))
        (.. __stream (write (.. (VarInt. (.. (:script-bytes this) (alength))) (encode))))
        (.. __stream (write (:script-bytes this)))
        (Utils/uint32ToByteStreamLE (:sequence this), __stream)
        nil
    )

    ;;;
     ; Coinbase transactions have special inputs with hashes of zero.  If this is such an input, returns true.
     ;;
    #_public
    (ยง method #_"boolean" isCoinBase []
        (and (.. (:outpoint this) (getHash) (equals Sha256Hash/ZERO_HASH)) (== (& (.. (:outpoint this) (getIndex)) 0xffffffff) 0xffffffff)) ;; -1 but all is serialized to the wire as unsigned int.
    )

    ;;;
     ; Returns the script that is fed to the referenced output (scriptPubKey) script in order to satisfy it: usually
     ; contains signatures and maybe keys, but can contain arbitrary data if the output script accepts it.
     ;;
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"Script" getScriptSig []
        ;; Transactions that generate new coins don't actually have a script.
        ;; Instead this parameter is overloaded to be something totally different.
        (let [#_"Script" __script (when (some? (:script-sig this)) (.. (:script-sig this) (get)))]
            (when (nil? __script)
                (ยง ass __script (Script. (:script-bytes this)))
                (ยง assoc this :script-sig (WeakReference. #_"<>" __script))
            )
            __script
        )
    )

    ;;; Set the given program as the scriptSig that is supposed to satisfy the connected output script. ;;
    #_public
    (ยง method #_"void" setScriptSig [#_"Script" __scriptSig]
        (ยง assoc this :script-sig (WeakReference. #_"<>" (Preconditions/checkNotNull __scriptSig)))
        ;; TODO: This should all be cleaned up so we have a consistent internal representation.
        (.. this (setScriptBytes (.. __scriptSig (getProgram))))
        nil
    )

    ;;;
     ; Convenience method that returns the from address of this input by parsing the scriptSig.  The concept of
     ; a "from address" is not well defined in Bitcoin and you should not assume that senders of a transaction can
     ; actually receive coins on the same address they used to sign (e.g. this is not true for shared wallets).
     ;;
    #_deprecated
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"Address" getFromAddress []
        (when (.. this (isCoinBase))
            (throw (ScriptException. ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "This is a coinbase transaction which generates new coins. It does not have a from address."))
        )

        (.. this (getScriptSig) (getFromAddress (:params this)))
    )

    ;;;
     ; Sequence numbers allow participants in a multi-party transaction signing protocol to create new versions of the
     ; transaction independently of each other.  Newer versions of a transaction can replace an existing version that's
     ; in nodes memory pools if the existing version is time locked.  See the Contracts page on the Bitcoin wiki for
     ; examples of how you can use this feature to build contract protocols.
     ;;
    #_public
    (ยง method #_"long" getSequenceNumber []
        (:sequence this)
    )

    ;;;
     ; Sequence numbers allow participants in a multi-party transaction signing protocol to create new versions of the
     ; transaction independently of each other.  Newer versions of a transaction can replace an existing version that's
     ; in nodes memory pools if the existing version is time locked.  See the Contracts page on the Bitcoin wiki for
     ; examples of how you can use this feature to build contract protocols.
     ;;
    #_public
    (ยง method #_"void" setSequenceNumber [#_"long" __sequence]
        (.. this (unCache))
        (ยง assoc this :sequence __sequence)
        nil
    )

    ;;;
     ; @return The previous output transaction reference, as an OutPoint structure.  This contains the
     ; data needed to connect to the output of the transaction we're gathering coins from.
     ;;
    #_public
    (ยง method #_"TransactionOutPoint" getOutpoint []
        (:outpoint this)
    )

    ;;;
     ; The "script bytes" might not actually be a script.  In coinbase transactions where new coins are minted there
     ; is no input transaction, so instead the scriptBytes contains some extra stuff (like a rollover nonce) that we
     ; don't care about much.  The bytes are turned into a Script object (cached below) on demand via a getter.
     ; @return the scriptBytes
     ;;
    #_public
    (ยง method #_"byte[]" getScriptBytes []
        (:script-bytes this)
    )

    ;;; Clear input scripts, e.g. in preparation for signing. ;;
    #_public
    (ยง method #_"void" clearScriptBytes []
        (.. this (setScriptBytes TransactionInput/EMPTY_ARRAY))
        nil
    )

    ;;;
     ; @param scriptBytes The scriptBytes to set.
     ;;
    (ยง method #_"void" setScriptBytes [#_"byte[]" __scriptBytes]
        (.. this (unCache))
        (ยง assoc this :script-sig nil)
        (let [#_"int" __oldLength (:length this)]
            (ยง assoc this :script-bytes __scriptBytes)
            ;; 40 = previous_outpoint (36) + sequence (4)
            (let [#_"int" __newLength (+ 40 (if (some? __scriptBytes) (+ (VarInt/sizeOf (.. __scriptBytes (alength))) (.. __scriptBytes (alength))) 1))]
                (.. this (adjustLength (- __newLength __oldLength)))
                nil
            )
        )
    )

    ;;;
     ; @return the Transaction that owns this input.
     ;;
    #_public
    (ยง method #_"Transaction" getParentTransaction []
        (cast Transaction (:parent this))
    )

    ;;;
     ; @return the value of the output connected to this input.
     ;;
    #_nilable
    #_public
    (ยง method #_"Coin" getValue []
        (:value this)
    )

    #_public
    (ยง enum TransactionInput.ConnectionResult
        (ยง item NO_SUCH_TX)
        (ยง item ALREADY_SPENT)
        (ยง item SUCCESS)
    )

    ;; TODO: Clean all this up once TransactionOutPoint disappears.

    ;;;
     ; Locates the referenced output from the given pool of transactions.
     ;
     ; @return the TransactionOutput (or null) if the transaction's map doesn't contain the referenced tx.
     ;;
    #_nilable
    (ยง method #_"TransactionOutput" getConnectedOutput [#_"Map<Sha256Hash, Transaction>" __transactions]
        (let [#_"Transaction" __tx (.. __transactions (get (.. (:outpoint this) (getHash))))]
            (when (some? __tx) (.. __tx (getOutputs) (get (int (.. (:outpoint this) (getIndex))))))
        )
    )

    ;;;
     ; Alias for getOutpoint().getConnectedRedeemData(keyBag).
     ; @see TransactionOutPoint#getConnectedRedeemData(org.bitcoinj.wallet.KeyBag)
     ;;
    #_nilable
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"RedeemData" getConnectedRedeemData [#_"KeyBag" __keyBag]
        (.. this (getOutpoint) (getConnectedRedeemData __keyBag))
    )

    #_public
    (ยง enum TransactionInput.ConnectMode
        (ยง item DISCONNECT_ON_CONFLICT)
        (ยง item ABORT_ON_CONFLICT)
    )

    ;;;
     ; Connects this input to the relevant output of the referenced transaction if it's in the given map.
     ; Connecting means updating the internal pointers and spent flags.  If the mode is to ABORT_ON_CONFLICT,
     ; then the spent output won't be changed, but the outpoint.fromTx pointer will still be updated.
     ;
     ; @param transactions Map of txhash->transaction.
     ; @param mode Whether to abort if there's a pre-existing connection or not.
     ; @return NO_SUCH_TX if the prevtx wasn't found, ALREADY_SPENT if there was a conflict, SUCCESS if not.
     ;;
    #_public
    (ยง method #_"TransactionInput.ConnectionResult" connect [#_"Map<Sha256Hash, Transaction>" __transactions, #_"TransactionInput.ConnectMode" __mode]
        (let [#_"Transaction" __tx (.. __transactions (get (.. (:outpoint this) (getHash))))]
            (if (some? __tx) (.. this (connect __tx, __mode)) TransactionInput.ConnectionResult/NO_SUCH_TX)
        )
    )

    ;;;
     ; Connects this input to the relevant output of the referenced transaction.
     ; Connecting means updating the internal pointers and spent flags.  If the mode is to ABORT_ON_CONFLICT,
     ; then the spent output won't be changed, but the outpoint.fromTx pointer will still be updated.
     ;
     ; @param transaction The transaction to try.
     ; @param mode Whether to abort if there's a pre-existing connection or not.
     ; @return NO_SUCH_TX if transaction is not the prevtx, ALREADY_SPENT if there was a conflict, SUCCESS if not.
     ;;
    #_public
    (ยง method #_"TransactionInput.ConnectionResult" connect [#_"Transaction" __transaction, #_"TransactionInput.ConnectMode" __mode]
        (when (not (.. __transaction (getHash) (equals (.. (:outpoint this) (getHash)))))
            (ยง return TransactionInput.ConnectionResult/NO_SUCH_TX)
        )

        (Preconditions/checkElementIndex (int (.. (:outpoint this) (getIndex))), (.. __transaction (getOutputs) (size)), "Corrupt transaction")

        (let [#_"TransactionOutput" __out (.. __transaction (getOutput (int (.. (:outpoint this) (getIndex)))))]
            (when (not (.. __out (isAvailableForSpending)))
                (cond (.. this (getParentTransaction) (equals (-> this :outpoint :from-tx)))
                    (do
                        ;; Already connected.
                        (ยง return TransactionInput.ConnectionResult/SUCCESS)
                    )
                    (== __mode TransactionInput.ConnectMode/DISCONNECT_ON_CONFLICT)
                    (do
                        (.. __out (markAsUnspent))
                    )
                    (== __mode TransactionInput.ConnectMode/ABORT_ON_CONFLICT)
                    (do
                        (ยง assoc-in this [:outpoint :from-tx] (.. __out (getParentTransaction)))
                        (ยง return TransactionInput.ConnectionResult/ALREADY_SPENT)
                    )
                )
            )
            (.. this (connect __out))
            TransactionInput.ConnectionResult/SUCCESS
        )
    )

    ;;; Internal use only: connects this TransactionInput to the given output (updates pointers and spent flags). ;;
    #_public
    (ยง method #_"void" connect [#_"TransactionOutput" __out]
        (ยง assoc-in this [:outpoint :from-tx] (.. __out (getParentTransaction)))
        (.. __out (markAsSpent this))
        (ยง assoc this :value (.. __out (getValue)))
        nil
    )

    ;;;
     ; If this input is connected, check the output is connected back to this input and release it if so, making
     ; it spendable once again.
     ;
     ; @return true if the disconnection took place, false if it was not connected.
     ;;
    #_public
    (ยง method #_"boolean" disconnect []
        (let [#_"TransactionOutput" __connectedOutput]
            (cond (some? (-> this :outpoint :from-tx))
                (do
                    ;; The outpoint is connected using a "standard" wallet, disconnect it.
                    (ยง ass __connectedOutput (.. (:outpoint this) :from-tx (getOutput (int (.. (:outpoint this) (getIndex))))))
                    (ยง assoc-in this [:outpoint :from-tx] nil)
                )
                (some? (-> this :outpoint :connected-output))
                (do
                    ;; The outpoint is connected using a UTXO based wallet, disconnect it.
                    (ยง ass __connectedOutput (-> this :outpoint :connected-output))
                    (ยง assoc-in this [:outpoint :connected-output] nil)
                )
                :else
                (do
                    ;; The outpoint is not connected, do nothing.
                    (ยง return false)
                )
            )

            (when (and (some? __connectedOutput) (== (.. __connectedOutput (getSpentBy)) this))
                ;; The outpoint was connected to an output, disconnect the output.
                (.. __connectedOutput (markAsUnspent))
                (ยง return true)
            )

            false
        )
    )

    ;;;
     ; @return true if this transaction's sequence number is set (i.e. it may be a part of a time-locked transaction).
     ;;
    #_public
    (ยง method #_"boolean" hasSequence []
        (!= (:sequence this) TransactionInput/NO_SEQUENCE)
    )

    ;;;
     ; Returns whether this input will cause a transaction to opt into the
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki">full replace-by-fee</a> semantics.
     ;;
    #_public
    (ยง method #_"boolean" isOptInFullRBF []
        (< (:sequence this) (dec TransactionInput/NO_SEQUENCE))
    )

    ;;;
     ; For a connected transaction, runs the script against the connected pubkey and verifies they are correct.
     ; @throws ScriptException if the script did not verify.
     ; @throws VerificationException if the outpoint doesn't match the given output.
     ;;
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"void" verify []
        (let [#_"Transaction" __fromTx (:from-tx (.. this (getOutpoint)))
              #_"long" __spendingIndex (.. this (getOutpoint) (getIndex))]

            (Preconditions/checkNotNull __fromTx, "Not connected")

            (let [#_"TransactionOutput" __output (.. __fromTx (getOutput (int __spendingIndex)))]
                (ECKey/verify __output)
                nil
            )
        )
    )

    ;;;
     ; Verifies that this input can spend the given output.  Note that this input must be a part of a transaction.
     ; Also note that the consistency of the outpoint will be checked, even if this input has not been connected.
     ;
     ; @param output The output that this input is supposed to spend.
     ; @throws ScriptException if the script doesn't verify.
     ; @throws VerificationException if the outpoint doesn't match the given output.
     ;;
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"void" verify [#_"TransactionOutput" __output]
        (when (some? (:parent __output))
            (when (not (.. this (getOutpoint) (getHash) (equals (.. __output (getParentTransaction) (getHash)))))
                (throw (VerificationException. "This input does not refer to the tx containing the output."))
            )
            (when (!= (.. this (getOutpoint) (getIndex)) (.. __output (getIndex)))
                (throw (VerificationException. "This input refers to a different output on the given tx."))
            )
        )
        (let [#_"Script" __pubKey (.. __output (getScriptPubKey))
              #_"int" __myIndex (.. this (getParentTransaction) (getInputs) (indexOf this))]
            (.. this (getScriptSig) (correctlySpends (.. this (getParentTransaction)), __myIndex, __pubKey))
            nil
        )
    )

    ;;;
     ; Returns the connected output, assuming the input was connected with
     ; {@link TransactionInput#connect(TransactionOutput)} or variants at some point.
     ; If it wasn't connected, then this method returns null.
     ;;
    #_nilable
    #_public
    (ยง method #_"TransactionOutput" getConnectedOutput []
        (.. this (getOutpoint) (getConnectedOutput))
    )

    ;;;
     ; Returns the connected transaction, assuming the input was connected with
     ; {@link TransactionInput#connect(TransactionOutput)} or variants at some point.
     ; If it wasn't connected, then this method returns null.
     ;;
    #_nilable
    #_public
    (ยง method #_"Transaction" getConnectedTransaction []
        (:from-tx (.. this (getOutpoint)))
    )

    ;;; Returns a copy of the input detached from its containing transaction, if need be. ;;
    #_public
    (ยง method #_"TransactionInput" duplicateDetached []
        (TransactionInput. (:params this), nil, (.. this (bitcoinSerialize)), 0)
    )

    ;;;
     ; <p>Returns either RuleViolation.NONE if the input is standard, or which rule makes it non-standard if so.
     ; The "IsStandard" rules control whether the default Bitcoin Core client blocks relay of a tx / refuses to mine it,
     ; however, non-standard transactions can still be included in blocks and will be accepted as valid if so.</p>
     ;
     ; <p>This method simply calls <tt>DefaultRiskAnalysis.isInputStandard(this)</tt>.</p>
     ;;
    #_public
    (ยง method #_"DefaultRiskAnalysis.RuleViolation" isStandard []
        (DefaultRiskAnalysis/isInputStandard this)
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"TransactionInput" __other (cast TransactionInput __o)]
            (and (== (:sequence this) (:sequence __other)) (== (:parent this) (:parent __other)) (.. (:outpoint this) (equals (:outpoint __other))) (Arrays/equals (:script-bytes this), (:script-bytes __other)))
        )
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (:sequence this), (:outpoint this), (Arrays/hashCode (:script-bytes this)))
    )

    ;;;
     ; Returns a human readable debug string.
     ;;
    #_override
    #_public
    (ยง method #_"String" toString []
        (try
            (let [#_"StringBuilder" __sb (StringBuilder. "TxIn")]
                (cond (.. this (isCoinBase))
                    (do
                        (.. __sb (append ": COINBASE"))
                    )
                    :else
                    (do
                        (.. __sb (append " for [") (append (:outpoint this)) (append "]: ") (append (.. this (getScriptSig))))
                        (let [#_"String" __flags (.. (Joiner/on ", ") (skipNulls) (join (when (.. this (hasSequence)) (str "sequence: " (Long/toHexString (:sequence this)))), (when (.. this (isOptInFullRBF)) "opts into full RBF")))]
                            (when (not (.. __flags (isEmpty)))
                                (.. __sb (append " (") (append __flags) (append ")"))
                            )
                        )
                    )
                )
                (ยง return (.. __sb (toString)))
            )
            (catch ScriptException __e
                (throw (RuntimeException. __e))
            )
        )
    )
)

;;;
 ; <p>This message is a reference or pointer to an output of a different transaction.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class TransactionOutPoint (ยง extends ChildMessage)
    #_static
    (ยง def #_"int" TransactionOutPoint/MESSAGE_LENGTH 36)

    ;;; Hash of the transaction to which we refer. ;;
    #_private
    (ยง field- #_"Sha256Hash" :hash)
    ;;; Which output of that transaction we are talking about. ;;
    #_private
    (ยง field- #_"long" :index)

    ;; This is not part of bitcoin serialization.  It points to the connected transaction.
    (ยง field #_"Transaction" :from-tx)

    ;; The connected output.
    (ยง field #_"TransactionOutput" :connected-output)

    #_public
    (ยง constructor TransactionOutPoint [#_"NetworkParameters" __params, #_"long" __index, #_nilable #_"Transaction" __fromTx]
        (ยง super __params)

        (ยง assoc this :index __index)
        (cond (some? __fromTx)
            (do
                (ยง assoc this :hash (.. __fromTx (getHash)))
                (ยง assoc this :from-tx __fromTx)
            )
            :else
            (do
                ;; This happens when constructing the genesis block.
                (ยง assoc this :hash Sha256Hash/ZERO_HASH)
            )
        )
        (ยง assoc this :length TransactionOutPoint/MESSAGE_LENGTH)
        this
    )

    #_public
    (ยง constructor TransactionOutPoint [#_"NetworkParameters" __params, #_"long" __index, #_"Sha256Hash" __hash]
        (ยง super __params)

        (ยง assoc this :index __index)
        (ยง assoc this :hash __hash)
        (ยง assoc this :length TransactionOutPoint/MESSAGE_LENGTH)
        this
    )

    #_public
    (ยง constructor TransactionOutPoint [#_"NetworkParameters" __params, #_"TransactionOutput" __connectedOutput]
        (ยง this __params, (.. __connectedOutput (getIndex)), (.. __connectedOutput (getParentTransactionHash)))
        (ยง assoc this :connected-output __connectedOutput)
        this
    )

    ;;;
     ; Deserializes the message.  This is usually part of a transaction message.
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor TransactionOutPoint [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"int" __offset]
        (ยง super __params, __payload, __offset)
        this
    )

    ;;;
     ; Deserializes the message.  This is usually part of a transaction message.
     ; @param params NetworkParameters object.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor TransactionOutPoint [#_"NetworkParameters" __params, #_"byte[]" __payload, #_"int" __offset, #_"Message" __parent, #_"MessageSerializer" __serializer]
        (ยง super __params, __payload, __offset, __parent, __serializer, TransactionOutPoint/MESSAGE_LENGTH)
        this
    )

    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        (ยง assoc this :length TransactionOutPoint/MESSAGE_LENGTH)
        (ยง assoc this :hash (.. this (readHash)))
        (ยง assoc this :index (.. this (readUint32)))
        nil
    )

    #_override
    #_protected
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __stream]
        (.. __stream (write (.. (:hash this) (getReversedBytes))))
        (Utils/uint32ToByteStreamLE (:index this), __stream)
        nil
    )

    ;;;
     ; An outpoint is a part of a transaction input that points to the output of another transaction.  If we have both
     ; sides in memory, and they have been linked together, this returns a pointer to the connected output, or null
     ; if there is no such connection.
     ;;
    #_nilable
    #_public
    (ยง method #_"TransactionOutput" getConnectedOutput []
        (when (some? (:from-tx this))
            (ยง return (.. (:from-tx this) (getOutputs) (get (int (:index this)))))
        )
        (when (some? (:connected-output this))
            (ยง return (:connected-output this))
        )
        nil
    )

    ;;;
     ; Returns the pubkey script from the connected output.
     ; @throws java.lang.NullPointerException if there is no connected output.
     ;;
    #_public
    (ยง method #_"byte[]" getConnectedPubKeyScript []
        (let [#_"byte[]" __result (.. (Preconditions/checkNotNull (.. this (getConnectedOutput))) (getScriptBytes))]
            (Preconditions/checkState (< 0 (.. __result (alength))))
            __result
        )
    )

    ;;;
     ; Returns the ECKey identified in the connected output, for either pay-to-address scripts or pay-to-key scripts.
     ; For P2SH scripts you can use {@link #getConnectedRedeemData(org.bitcoinj.wallet.KeyBag)} and then get the
     ; key from RedeemData.
     ; If the script form cannot be understood, throws ScriptException.
     ;
     ; @return an ECKey or null if the connected key cannot be found in the wallet.
     ;;
    #_nilable
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"ECKey" getConnectedKey [#_"KeyBag" __keyBag]
        (let [#_"TransactionOutput" __connectedOutput (.. this (getConnectedOutput))]
            (Preconditions/checkNotNull __connectedOutput, "Input is not connected so cannot retrieve key")
            (let [#_"Script" __connectedScript (.. __connectedOutput (getScriptPubKey))]

                (when (.. __connectedScript (isSentToAddress))
                    (let [#_"byte[]" __addressBytes (.. __connectedScript (getPubKeyHash))]
                        (ยง return (.. __keyBag (findKeyFromPubHash __addressBytes)))
                    )
                )

                (when (.. __connectedScript (isSentToRawPubKey))
                    (let [#_"byte[]" __pubkeyBytes (.. __connectedScript (getPubKey))]
                        (ยง return (.. __keyBag (findKeyFromPubKey __pubkeyBytes)))
                    )
                )

                (throw (ScriptException. ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, (str "Could not understand form of connected output script: " __connectedScript)))
            )
        )
    )

    ;;;
     ; Returns the RedeemData identified in the connected output, for either pay-to-address scripts, pay-to-key
     ; or P2SH scripts.
     ; If the script forms cannot be understood, throws ScriptException.
     ;
     ; @return a RedeemData or null if the connected data cannot be found in the wallet.
     ;;
    #_nilable
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"RedeemData" getConnectedRedeemData [#_"KeyBag" __keyBag]
        (let [#_"TransactionOutput" __connectedOutput (.. this (getConnectedOutput))]
            (Preconditions/checkNotNull __connectedOutput, "Input is not connected so cannot retrieve key")
            (let [#_"Script" __connectedScript (.. __connectedOutput (getScriptPubKey))]

                (when (.. __connectedScript (isSentToAddress))
                    (let [#_"byte[]" __addressBytes (.. __connectedScript (getPubKeyHash))]
                        (ยง return (RedeemData/of (.. __keyBag (findKeyFromPubHash __addressBytes)), __connectedScript))
                    )
                )

                (when (.. __connectedScript (isSentToRawPubKey))
                    (let [#_"byte[]" __pubkeyBytes (.. __connectedScript (getPubKey))]
                        (ยง return (RedeemData/of (.. __keyBag (findKeyFromPubKey __pubkeyBytes)), __connectedScript))
                    )
                )

                (when (.. __connectedScript (isPayToScriptHash))
                    (let [#_"byte[]" __scriptHash (.. __connectedScript (getPubKeyHash))]
                        (ยง return (.. __keyBag (findRedeemDataFromScriptHash __scriptHash)))
                    )
                )

                (throw (ScriptException. ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, (str "Could not understand form of connected output script: " __connectedScript)))
            )
        )
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (str (:hash this) ":" (:index this))
    )

    ;;;
     ; Returns the hash of the transaction this outpoint references/spends/is connected to.
     ;;
    #_override
    #_public
    (ยง method #_"Sha256Hash" getHash []
        (:hash this)
    )

    (ยง method #_"void" setHash [#_"Sha256Hash" __hash]
        (ยง assoc this :hash __hash)
        nil
    )

    #_public
    (ยง method #_"long" getIndex []
        (:index this)
    )

    #_public
    (ยง method #_"void" setIndex [#_"long" __index]
        (ยง assoc this :index __index)
        nil
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"TransactionOutPoint" __other (cast TransactionOutPoint __o)]
            (and (== (.. this (getIndex)) (.. __other (getIndex))) (.. this (getHash) (equals (.. __other (getHash)))))
        )
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (.. this (getIndex)), (.. this (getHash)))
    )
)

;;;
 ; <p>A TransactionOutput message contains a scriptPubKey that controls who is able to spend its value.
 ; It is a sub-part of the Transaction message.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class TransactionOutput (ยง extends ChildMessage)
    #_private
    #_static
    (ยง def- #_"Logger" TransactionOutput/log (LoggerFactory/getLogger TransactionOutput))

    ;; The output's value is kept as a native type in order to save class instances.
    #_private
    (ยง field- #_"long" :value)

    ;; A transaction output has a script used for authenticating that the redeemer is allowed to spend
    ;; this output.
    #_private
    (ยง field- #_"byte[]" :script-bytes)

    ;; The script bytes are parsed and turned into a Script on demand.
    #_private
    (ยง field- #_"Script" :script-pub-key)

    ;; These fields are not Bitcoin serialized.  They are used for tracking purposes in our wallet only.
    ;; If set to true, this output is counted towards our balance.  If false and spentBy is null the tx output
    ;; was owned by us and was sent to somebody else.  If false and spentBy is set it means this output was owned
    ;; by us and used in one of our own transactions (e.g. because it is a change output).
    #_private
    (ยง field- #_"boolean" :available-for-spending)
    #_nilable
    #_private
    (ยง field- #_"TransactionInput" :spent-by)

    #_private
    (ยง field- #_"int" :script-len)

    ;;;
     ; Deserializes a transaction output message.  This is usually part of a transaction message.
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor TransactionOutput [#_"NetworkParameters" __params, #_nilable #_"Transaction" __parent, #_"byte[]" __payload, #_"int" __offset]
        (ยง super __params, __payload, __offset)

        (.. this (setParent __parent))
        (ยง assoc this :available-for-spending true)
        this
    )

    ;;;
     ; Deserializes a transaction output message.  This is usually part of a transaction message.
     ;
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor TransactionOutput [#_"NetworkParameters" __params, #_nilable #_"Transaction" __parent, #_"byte[]" __payload, #_"int" __offset, #_"MessageSerializer" __serializer]
        (ยง super __params, __payload, __offset, __parent, __serializer, Message/UNKNOWN_LENGTH)

        (ยง assoc this :available-for-spending true)
        this
    )

    ;;;
     ; Creates an output that sends 'value' to the given address (public key hash).  The amount should be
     ; created with something like {@link Coin#valueOf(int, int)}.  Typically you would use
     ; {@link Transaction#addOutput(Coin, Address)} instead of creating a TransactionOutput directly.
     ;;
    #_public
    (ยง constructor TransactionOutput [#_"NetworkParameters" __params, #_nilable #_"Transaction" __parent, #_"Coin" __value, #_"Address" __to]
        (ยง this __params, __parent, __value, (.. (ScriptBuilder/createOutputScript __to) (getProgram)))
        this
    )

    ;;;
     ; Creates an output that sends 'value' to the given public key using a simple CHECKSIG script (no addresses).
     ; The amount should be created with something like {@link Coin#valueOf(int, int)}.  Typically you would use
     ; {@link Transaction#addOutput(Coin, ECKey)} instead of creating an output directly.
     ;;
    #_public
    (ยง constructor TransactionOutput [#_"NetworkParameters" __params, #_nilable #_"Transaction" __parent, #_"Coin" __value, #_"ECKey" __to]
        (ยง this __params, __parent, __value, (.. (ScriptBuilder/createOutputScript __to) (getProgram)))
        this
    )

    #_public
    (ยง constructor TransactionOutput [#_"NetworkParameters" __params, #_nilable #_"Transaction" __parent, #_"Coin" __value, #_"byte[]" __scriptBytes]
        (ยง super __params)

        ;; Negative values obviously make no sense, except for -1 which is used as a sentinel value when calculating
        ;; SIGHASH_SINGLE signatures, so unfortunately we have to allow that here.
        (Preconditions/checkArgument (or (<= 0 (.. __value (signum))) (.. __value (equals Coin/NEGATIVE_SATOSHI))), "Negative values not allowed")
        (Preconditions/checkArgument (or (not (.. __params (hasMaxMoney))) (<= (.. __value (compareTo (.. __params (getMaxMoney)))) 0)), "Values larger than MAX_MONEY not allowed")

        (ยง assoc this :value (:value __value))
        (ยง assoc this :script-bytes __scriptBytes)
        (.. this (setParent __parent))
        (ยง assoc this :available-for-spending true)
        (ยง assoc this :length (+ 8 (VarInt/sizeOf (.. __scriptBytes (alength))) (.. __scriptBytes (alength))))
        this
    )

    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"Script" getScriptPubKey []
        (when (nil? (:script-pub-key this))
            (ยง assoc this :script-pub-key (Script. (:script-bytes this)))
        )
        (:script-pub-key this)
    )

    ;;;
     ; <p>If the output script pays to an address as in <a href="https://bitcoin.org/en/developer-guide#term-p2pkh">P2PKH</a>,
     ; return the address of the receiver, i.e. a base58 encoded hash of the public key in the script.</p>
     ;
     ; @param networkParameters Needed to specify an address.
     ; @return null, if the output script is not the form <i>OP_DUP OP_HASH160 <PubkeyHash> OP_EQUALVERIFY OP_CHECKSIG</i>,
     ; i.e. not P2PKH.
     ; @return an address made out of the public key hash.
     ;;
    #_nilable
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"Address" getAddressFromP2PKHScript [#_"NetworkParameters" __networkParameters]
        (when (.. this (getScriptPubKey) (isSentToAddress)) (.. this (getScriptPubKey) (getToAddress __networkParameters)))
    )

    ;;;
     ; <p>If the output script pays to a redeem script, return the address of the redeem script as described by,
     ; i.e. a base58 encoding of [one-byte version][20-byte hash][4-byte checksum], where the 20-byte hash refers to
     ; the redeem script.</p>
     ;
     ; <p>P2SH is described by <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP 16</a> and
     ; <a href="https://bitcoin.org/en/developer-guide#p2sh-scripts">documented in the Bitcoin Developer Guide</a>.</p>
     ;
     ; @param networkParameters Needed to specify an address.
     ; @return null if the output script does not pay to a script hash.
     ; @return an address that belongs to the redeem script.
     ;;
    #_nilable
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"Address" getAddressFromP2SH [#_"NetworkParameters" __networkParameters]
        (when (.. this (getScriptPubKey) (isPayToScriptHash)) (.. this (getScriptPubKey) (getToAddress __networkParameters)))
    )

    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        (ยง assoc this :value (.. this (readInt64)))
        (ยง assoc this :script-len (int (.. this (readVarInt))))
        (ยง assoc this :length (+ (- (:cursor this) (:offset this)) (:script-len this)))
        (ยง assoc this :script-bytes (.. this (readBytes (:script-len this))))
        nil
    )

    #_override
    #_protected
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __stream]
        (Preconditions/checkNotNull (:script-bytes this))

        (Utils/int64ToByteStreamLE (:value this), __stream)
        ;; TODO: Move script serialization into the Script class, where it belongs.
        (.. __stream (write (.. (VarInt. (.. (:script-bytes this) (alength))) (encode))))
        (.. __stream (write (:script-bytes this)))
        nil
    )

    ;;;
     ; Returns the value of this output.
     ; This is the amount of currency that the destination address receives.
     ;;
    #_public
    (ยง method #_"Coin" getValue []
        (try
            (ยง return (Coin/valueOf (:value this)))
            (catch IllegalArgumentException __e
                (throw (IllegalStateException. (.. __e (getMessage)), __e))
            )
        )
    )

    ;;;
     ; Sets the value of this output.
     ;;
    #_public
    (ยง method #_"void" setValue [#_"Coin" __value]
        (Preconditions/checkNotNull __value)

        (.. this (unCache))
        (ยง assoc this :value (:value __value))
        nil
    )

    ;;;
     ; Gets the index of this output in the parent transaction, or throws if this output is free standing.
     ; Iterates over the parents list to discover this.
     ;;
    #_public
    (ยง method #_"int" getIndex []
        (let [#_"List<TransactionOutput>" __outputs (.. this (getParentTransaction) (getOutputs))]
            (loop-when-recur [#_"int" __i 0] (< __i (.. __outputs (size))) [(inc __i)]
                (when (== (.. __outputs (get __i)) this)
                    (ยง return __i)
                )
            )

            (throw (IllegalStateException. "Output linked to wrong parent transaction?"))
        )
    )

    ;;;
     ; Will this transaction be relayable and mined by default miners?
     ;;
    #_public
    (ยง method #_"boolean" isDust []
        ;; Transactions that are OP_RETURN can't be dust regardless of their value.
        (if (.. this (getScriptPubKey) (isOpReturn)) false (.. this (getValue) (isLessThan (.. this (getMinNonDustValue)))))
    )

    ;;;
     ; <p>Gets the minimum value for a txout of this size to be considered non-dust by Bitcoin Core
     ; (and thus relayed).  See CTxOut::IsDust() in Bitcoin Core.  The assumption is that any output that would
     ; consume more than a third of its value in fees is not something the Bitcoin system wants to deal with right now,
     ; so we call them "dust outputs" and they're made non standard.  The choice of one third is somewhat arbitrary and
     ; may change in future.</p>
     ;
     ; <p>You probably should use {@link org.bitcoinj.core.TransactionOutput#getMinNonDustValue()} which uses
     ; a safe fee-per-kb by default.</p>
     ;
     ; @param feePerKb The fee required per kilobyte.  Note that this is the same as Bitcoin Core's -minrelaytxfee * 3.
     ;;
    #_public
    (ยง method #_"Coin" getMinNonDustValue [#_"Coin" __feePerKb]
        ;; A typical output is 33 bytes (pubkey hash + opcodes) and requires an input of 148 bytes to spend so we add
        ;; that together to find out the total amount of data used to transfer this amount of value.  Note that this
        ;; formula is wrong for anything that's not a pay-to-address output, unfortunately, we must follow Bitcoin Core's
        ;; wrongness in order to ensure we're considered standard.  A better formula would either estimate the
        ;; size of data needed to satisfy all different script types, or just hard code 33 below.
        (let [#_"long" __size (+ (.. this (unsafeBitcoinSerialize) (alength)) 148)]
            (.. __feePerKb (multiply __size) (divide 1000))
        )
    )

    ;;;
     ; Returns the minimum value for this output to be considered "not dust", i.e. the transaction will be relayable
     ; and mined by default miners.  For normal pay to address outputs, this is 2730 satoshis, the same as
     ; {@link Transaction#MIN_NONDUST_OUTPUT}.
     ;;
    #_public
    (ยง method #_"Coin" getMinNonDustValue []
        (.. this (getMinNonDustValue (.. Transaction/REFERENCE_DEFAULT_MIN_TX_FEE (multiply 3))))
    )

    ;;;
     ; Sets this objects availableForSpending flag to false and the spentBy pointer to the given input.
     ; If the input is null, it means this output was signed over to somebody else rather than one of our own keys.
     ; @throws IllegalStateException if the transaction was already marked as spent.
     ;;
    #_public
    (ยง method #_"void" markAsSpent [#_"TransactionInput" __input]
        (Preconditions/checkState (:available-for-spending this))

        (ยง assoc this :available-for-spending false)
        (ยง assoc this :spent-by __input)

        (when (.. TransactionOutput/log (isDebugEnabled))
            (if (some? (:parent this))
                (.. TransactionOutput/log (debug "Marked {}:{} as spent by {}", (.. this (getParentTransactionHash)), (.. this (getIndex)), __input))
                (.. TransactionOutput/log (debug "Marked floating output as spent by {}", __input))
            )
        )
        nil
    )

    ;;;
     ; Resets the spent pointer / availableForSpending flag to null.
     ;;
    #_public
    (ยง method #_"void" markAsUnspent []
        (when (.. TransactionOutput/log (isDebugEnabled))
            (if (some? (:parent this))
                (.. TransactionOutput/log (debug "Un-marked {}:{} as spent by {}", (.. this (getParentTransactionHash)), (.. this (getIndex)), (:spent-by this)))
                (.. TransactionOutput/log (debug "Un-marked floating output as spent by {}", (:spent-by this)))
            )
        )

        (ยง assoc this :available-for-spending true)
        (ยง assoc this :spent-by nil)
        nil
    )

    ;;;
     ; Returns whether {@link TransactionOutput#markAsSpent(TransactionInput)} has been called on this class.
     ; A {@link Wallet} will mark a transaction output as spent once it sees a transaction input that is connected to it.
     ; Note that this flag can be false when an output has in fact been spent according to the rest of the network if
     ; the spending transaction wasn't downloaded yet, and it can be marked as spent when in reality the rest of the
     ; network believes it to be unspent if the signature or script connecting to it was not actually valid.
     ;;
    #_public
    (ยง method #_"boolean" isAvailableForSpending []
        (:available-for-spending this)
    )

    ;;;
     ; The backing script bytes which can be turned into a Script object.
     ; @return the scriptBytes
    ;;
    #_public
    (ยง method #_"byte[]" getScriptBytes []
        (:script-bytes this)
    )

    ;;;
     ; Returns true if this output is to a key, or an address we have the keys for, in the wallet.
     ;;
    #_public
    (ยง method #_"boolean" isMine [#_"TransactionBag" __transactionBag]
        (try
            (let [#_"Script" __script (.. this (getScriptPubKey))]
                (when (.. __script (isSentToRawPubKey))
                    (ยง return (.. __transactionBag (isPubKeyMine (.. __script (getPubKey)))))
                )
                (when (.. __script (isPayToScriptHash))
                    (ยง return (.. __transactionBag (isPayToScriptHashMine (.. __script (getPubKeyHash)))))
                )
                (ยง return (.. __transactionBag (isPubKeyHashMine (.. __script (getPubKeyHash)))))
            )
            (catch ScriptException __e
                ;; Just means we didn't understand the output of this transaction: ignore it.
                (.. TransactionOutput/log (debug "Could not parse tx {} output script: {}", (if (some? (:parent this)) (.. (:parent this) (getHash)) "(no parent)"), (.. __e (toString))))
                (ยง return false)
            )
        )
    )

    ;;;
     ; Returns a human readable debug string.
     ;;
    #_override
    #_public
    (ยง method #_"String" toString []
        (try
            (let [#_"Script" __script (.. this (getScriptPubKey))
                  #_"StringBuilder" __sb (StringBuilder. "TxOut of ")]
                (.. __sb (append (.. (Coin/valueOf (:value this)) (toFriendlyString))))
                (cond
                    (or (.. __script (isSentToAddress)) (.. __script (isPayToScriptHash)))
                        (.. __sb (append " to ") (append (.. __script (getToAddress (:params this)))))
                    (.. __script (isSentToRawPubKey))
                        (.. __sb (append " to pubkey ") (append (.. Utils/HEX (encode (.. __script (getPubKey))))))
                    (.. __script (isSentToMultiSig))
                        (.. __sb (append " to multisig"))
                    :else
                        (.. __sb (append " (unknown type)"))
                )
                (.. __sb (append " script:") (append __script))
                (ยง return (.. __sb (toString)))
            )
            (catch ScriptException __e
                (throw (RuntimeException. __e))
            )
        )
    )

    ;;;
     ; Returns the connected input.
     ;;
    #_nilable
    #_public
    (ยง method #_"TransactionInput" getSpentBy []
        (:spent-by this)
    )

    ;;;
     ; Returns the transaction that owns this output.
     ;;
    #_nilable
    #_public
    (ยง method #_"Transaction" getParentTransaction []
        (cast Transaction (:parent this))
    )

    ;;;
     ; Returns the transaction hash that owns this output.
     ;;
    #_nilable
    #_public
    (ยง method #_"Sha256Hash" getParentTransactionHash []
        (when (some? (:parent this)) (.. (:parent this) (getHash)))
    )

    ;;;
     ; Returns the depth in blocks of the parent tx.
     ;
     ; <p>If the transaction appears in the top block, the depth is one.
     ; If it's anything else (pending, dead, unknown), then -1.</p>
     ; @return the tx depth or -1.
     ;;
    #_public
    (ยง method #_"int" getParentTransactionDepthInBlocks []
        (when (some? (.. this (getParentTransaction)))
            (let [#_"TransactionConfidence" __confidence (.. this (getParentTransaction) (getConfidence))]
                (when (== (.. __confidence (getConfidenceType)) TransactionConfidence.ConfidenceType/BUILDING)
                    (ยง return (.. __confidence (getDepthInBlocks)))
                )
            )
        )
        -1
    )

    ;;;
     ; Returns a new {@link TransactionOutPoint}, which is essentially a structure pointing to this output.
     ; Requires that this output is not detached.
     ;;
    #_public
    (ยง method #_"TransactionOutPoint" getOutPointFor []
        (TransactionOutPoint. (:params this), (.. this (getIndex)), (.. this (getParentTransaction)))
    )

    ;;; Returns a copy of the output detached from its containing transaction, if need be. ;;
    #_public
    (ยง method #_"TransactionOutput" duplicateDetached []
        (TransactionOutput. (:params this), nil, (Coin/valueOf (:value this)), (org.spongycastle.util.Arrays/clone (:script-bytes this)))
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"TransactionOutput" __other (cast TransactionOutput __o)]
            (and (== (:value this) (:value __other)) (or (nil? (:parent this)) (and (== (:parent this) (:parent __other)) (== (.. this (getIndex)) (.. __other (getIndex))))) (Arrays/equals (:script-bytes this), (:script-bytes __other)))
        )
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (:value this), (:parent this), (Arrays/hashCode (:script-bytes this)))
    )
)

;;;
 ; <p>TransactionOutputChanges represents a delta to the set of unspent outputs.  It used as a return value for
 ; {@link AbstractBlockChain#connectTransactions(int, Block)}.  It contains the full list of transaction outputs created
 ; and spent in a block.  It DOES contain outputs created that were spent later in the block, as those are needed for
 ; BIP30 (no duplicate txid creation if the previous one was not fully spent prior to this block) verification.</p>
 ;;
#_public
(ยง class TransactionOutputChanges
    #_public
    (ยง field #_"List<UTXO>" :tx-outs-created)
    #_public
    (ยง field #_"List<UTXO>" :tx-outs-spent)

    #_public
    (ยง constructor TransactionOutputChanges [#_"List<UTXO>" __txOutsCreated, #_"List<UTXO>" __txOutsSpent]
        (ยง assoc this :tx-outs-created __txOutsCreated)
        (ยง assoc this :tx-outs-spent __txOutsSpent)
        this
    )

    #_private
    #_static
    #_throws #_[ "IOException" ]
    (ยง defn- #_"int" TransactionOutputChanges/read4x8le [#_"InputStream" __is]
        (| (& 0xff (.. __is (read))) (<< (& 0xff (.. __is (read))) 8) (<< (& 0xff (.. __is (read))) 16) (<< (& 0xff (.. __is (read))) 24))
    )

    #_public
    #_throws #_[ "IOException" ]
    (ยง constructor TransactionOutputChanges [#_"InputStream" __is]
        (let [#_"int" __nCreated (TransactionOutputChanges/read4x8le __is)]
            (ยง assoc this :tx-outs-created (LinkedList. #_"<>"))
            (loop-when-recur [#_"int" __i 0] (< __i __nCreated) [(inc __i)]
                (.. (:tx-outs-created this) (add (UTXO. __is)))
            )

            (let [#_"int" __nSpent (TransactionOutputChanges/read4x8le __is)]
                (ยง assoc this :tx-outs-spent (LinkedList. #_"<>"))
                (loop-when-recur [#_"int" __i 0] (< __i __nSpent) [(inc __i)]
                    (.. (:tx-outs-spent this) (add (UTXO. __is)))
                )
                this
            )
        )
    )

    #_private
    #_static
    #_throws #_[ "IOException" ]
    (ยง defn- #_"void" TransactionOutputChanges/write4x8le [#_"OutputStream" __os, #_"int" __n]
        (.. __os (write (& 0xff __n)))
        (.. __os (write (& 0xff (>> __n 8))))
        (.. __os (write (& 0xff (>> __n 16))))
        (.. __os (write (& 0xff (>> __n 24))))
        nil
    )

    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" serializeToStream [#_"OutputStream" __os]
        (TransactionOutputChanges/write4x8le __os, (.. (:tx-outs-created this) (size)))
        (doseq [#_"UTXO" __output (:tx-outs-created this)]
            (.. __output (serializeToStream __os))
        )

        (TransactionOutputChanges/write4x8le __os, (.. (:tx-outs-spent this) (size)))
        (doseq [#_"UTXO" __output (:tx-outs-spent this)]
            (.. __output (serializeToStream __os))
        )
        nil
    )
)

;;;
 ; <p>Tracks transactions that are being announced across the network.  Typically one is created for you by a
 ; {@link PeerGroup} and then given to each Peer to update.  The current purpose is to let Peers update the confidence
 ; (number of peers broadcasting).  It helps address an attack scenario in which a malicious remote peer (or several)
 ; feeds you invalid transactions, e.g. ones that spend coins which don't exist.  If you don't see most of the peers
 ; announce the transaction within a reasonable time, it may be that the TX is not valid.  Alternatively, an attacker
 ; may control your entire internet connection: in this scenario counting broadcasting peers does not help you.</p>
 ;
 ; <p>It is <b>not</b> at this time directly equivalent to the Bitcoin Core memory pool, which tracks
 ; all transactions not currently included in the best chain - it's simply a cache.</p>
 ;;
#_public
(ยง class TxConfidenceTable
    #_protected
    (ยง field #_"ReentrantLock" :lock (Threading/lock "txconfidencetable"))

    #_private
    #_static
    (ยง class- TxConfidenceTable.WeakConfidenceReference (ยง extends WeakReference #_"<TransactionConfidence>")
        #_public
        (ยง field #_"Sha256Hash" :hash)

        #_public
        (ยง constructor TxConfidenceTable.WeakConfidenceReference [#_"TransactionConfidence" __confidence, #_"ReferenceQueue<TransactionConfidence>" __queue]
            (ยง super __confidence, __queue)

            (ยง assoc this :hash (.. __confidence (getTransactionHash)))
            this
        )
    )
    #_private
    (ยง field- #_"LinkedHashMap<Sha256Hash, TxConfidenceTable.WeakConfidenceReference>" :table)

    ;; This ReferenceQueue gets entries added to it when they are only weakly reachable, i.e. the TxConfidenceTable is
    ;; the only thing that is tracking the confidence data anymore.  We check it from time to time and delete table entries
    ;; corresponding to expired transactions.  In this way memory usage of the system is in line with however many
    ;; transactions you actually care to track the confidence of.  We can still end up with lots of hashes being stored
    ;; if our peers flood us with invs but the MAX_SIZE param caps this.
    #_private
    (ยง field- #_"ReferenceQueue<TransactionConfidence>" :reference-queue)

    ;;; The max size of a table created with the no-args constructor. ;;
    #_public
    #_static
    (ยง def #_"int" TxConfidenceTable/MAX_SIZE 1000)

    ;;;
     ; Creates a table that will track at most the given number of transactions (allowing you to bound memory usage).
     ; @param size Max number of transactions to track.  The table will fill up to this size then stop growing.
     ;;
    #_public
    (ยง constructor TxConfidenceTable [#_"int" __size]
        (ยง assoc this :table (LinkedHashMap. #_"<Sha256Hash, TxConfidenceTable.WeakConfidenceReference>"
        (ยง anon
            #_override
            #_protected
            (ยง method #_"boolean" removeEldestEntry [#_"Map.Entry<Sha256Hash, TxConfidenceTable.WeakConfidenceReference>" __entry]
                ;; An arbitrary choice to stop the memory used by tracked transactions getting too huge in the event
                ;; of some kind of DoS attack.
                (< __size (.. this (size)))
            )
        )))
        (ยง assoc this :reference-queue (ReferenceQueue. #_"<>"))
        this
    )

    ;;;
     ; Creates a table that will track at most {@link TxConfidenceTable#MAX_SIZE} entries.
     ; You should normally use this constructor.
     ;;
    #_public
    (ยง constructor TxConfidenceTable []
        (ยง this TxConfidenceTable/MAX_SIZE)
        this
    )

    ;;;
     ; If any transactions have expired due to being only weakly reachable through us, go ahead and delete their
     ; table entries - it means we downloaded the transaction and sent it to various event listeners, none of
     ; which bothered to keep a reference.  Typically, this is because the transaction does not involve any keys
     ; that are relevant to any of our wallets.
     ;;
    #_private
    (ยง method- #_"void" cleanTable []
        (.. (:lock this) (lock))
        (try
            (let [#_"Reference<? extends TransactionConfidence>" __ref]
                (while (some? (ยง ass __ref (.. (:reference-queue this) (poll))))
                    ;; Find which transaction got deleted by the GC.
                    (let [#_"TxConfidenceTable.WeakConfidenceReference" __txRef (cast TxConfidenceTable.WeakConfidenceReference __ref)]
                        ;; And remove the associated map entry, so the other bits of memory can also be reclaimed.
                        (.. (:table this) (remove (:hash __txRef)))
                    )
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Returns the number of peers that have seen the given hash recently.
     ;;
    #_public
    (ยง method #_"int" numBroadcastPeers [#_"Sha256Hash" __txHash]
        (.. (:lock this) (lock))
        (try
            (.. this (cleanTable))
            (let [#_"TxConfidenceTable.WeakConfidenceReference" __entry (.. (:table this) (get __txHash))]
                (when (nil? __entry)
                    (ยง return 0) ;; No such TX known.
                )

                (let [#_"TransactionConfidence" __confidence (.. __entry (get))]
                    (when (nil? __confidence)
                        ;; Such a TX hash was seen, but nothing seemed to care, so we ended up throwing away the data.
                        (.. (:table this) (remove __txHash))
                        (ยง return 0)
                    )

                    (ยง return (.. __confidence (numBroadcastPeers)))
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Called by peers when they see a transaction advertised in an "inv" message.  It passes the data on to the relevant
     ; {@link org.bitcoinj.core.TransactionConfidence} object, creating it if needed.
     ;
     ; @return the number of peers that have now announced this hash (including the caller).
     ;;
    #_public
    (ยง method #_"TransactionConfidence" seen [#_"Sha256Hash" __hash, #_"PeerAddress" __byPeer]
        (let [#_"TransactionConfidence" __confidence
              #_"boolean" __fresh false]
            (.. (:lock this) (lock))
            (do
                (.. this (cleanTable))
                (ยง ass __confidence (Context/getOrCreate __hash))
                (ยง ass __fresh (.. __confidence (markBroadcastBy __byPeer)))
            )
            (.. (:lock this) (unlock))
            (when __fresh
                (.. __confidence (queueListeners TransactionConfidence.Listener.ChangeReason/SEEN_PEERS))
            )
            __confidence
        )
    )

    ;;;
     ; Returns the {@link TransactionConfidence} for the given hash if we have downloaded it, or null if that tx hash
     ; is unknown to the system at this time.
     ;;
    #_public
    (ยง method #_"TransactionConfidence" getOrCreate [#_"Sha256Hash" __hash]
        (Preconditions/checkNotNull __hash)

        (.. (:lock this) (lock))
        (try
            (let [#_"TxConfidenceTable.WeakConfidenceReference" __reference (.. (:table this) (get __hash))]
                (when (some? __reference)
                    (let [#_"TransactionConfidence" __confidence (.. __reference (get))]
                        (when (some? __confidence)
                            (ยง return __confidence)
                        )
                    )
                )
                (let [#_"TransactionConfidence" __newConfidence (TransactionConfidence. __hash)]
                    (.. (:table this) (put __hash, (TxConfidenceTable.WeakConfidenceReference. __newConfidence, (:reference-queue this))))
                    (ยง return __newConfidence)
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns the {@link TransactionConfidence} for the given hash if we have downloaded it, or null if that tx hash
     ; is unknown to the system at this time.
     ;;
    #_nilable
    #_public
    (ยง method #_"TransactionConfidence" get [#_"Sha256Hash" __hash]
        (.. (:lock this) (lock))
        (try
            (let [#_"TxConfidenceTable.WeakConfidenceReference" __ref (.. (:table this) (get __hash))]
                (ยง return (when (some? __ref) (.. __ref (get))))
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )
)

;; TODO: Fix this class: should not talk about addresses, height should be optional/support mempool height etc.

;;;
 ; A UTXO message contains the information necessary to check a spending transaction.
 ; It avoids having to store the entire parentTransaction just to get the hash and index.
 ; Useful when working with free standing outputs.
 ;;
#_public
(ยง class UTXO (ยง implements Serializable)
    #_private
    (ยง field- #_"Coin" :value)
    #_private
    (ยง field- #_"Script" :script)
    #_private
    (ยง field- #_"Sha256Hash" :hash)
    #_private
    (ยง field- #_"long" :index)
    #_private
    (ยง field- #_"int" :height)
    #_private
    (ยง field- #_"boolean" :coinbase)
    #_private
    (ยง field- #_"String" :address)

    ;;;
     ; Creates a stored transaction output.
     ;
     ; @param hash     The hash of the containing transaction.
     ; @param index    The outpoint.
     ; @param value    The value available.
     ; @param height   The height this output was created in.
     ; @param coinbase The coinbase flag.
     ;;
    #_public
    (ยง constructor UTXO [#_"Sha256Hash" __hash, #_"long" __index, #_"Coin" __value, #_"int" __height, #_"boolean" __coinbase, #_"Script" __script]
        (ยง assoc this :hash __hash)
        (ยง assoc this :index __index)
        (ยง assoc this :value __value)
        (ยง assoc this :height __height)
        (ยง assoc this :script __script)
        (ยง assoc this :coinbase __coinbase)
        (ยง assoc this :address "")
        this
    )

    ;;;
     ; Creates a stored transaction output.
     ;
     ; @param hash     The hash of the containing transaction.
     ; @param index    The outpoint.
     ; @param value    The value available.
     ; @param height   The height this output was created in.
     ; @param coinbase The coinbase flag.
     ; @param address  The address.
     ;;
    #_public
    (ยง constructor UTXO [#_"Sha256Hash" __hash, #_"long" __index, #_"Coin" __value, #_"int" __height, #_"boolean" __coinbase, #_"Script" __script, #_"String" __address]
        (ยง this __hash, __index, __value, __height, __coinbase, __script)
        (ยง assoc this :address __address)
        this
    )

    #_public
    #_throws #_[ "IOException" ]
    (ยง constructor UTXO [#_"InputStream" __in]
        (.. this (deserializeFromStream __in))
        this
    )

    ;;; The value which this Transaction output holds. ;;
    #_public
    (ยง method #_"Coin" getValue []
        (:value this)
    )

    ;;; The Script object which you can use to get address, script bytes or script type. ;;
    #_public
    (ยง method #_"Script" getScript []
        (:script this)
    )

    ;;; The hash of the transaction which holds this output. ;;
    #_public
    (ยง method #_"Sha256Hash" getHash []
        (:hash this)
    )

    ;;; The index of this output in the transaction which holds it. ;;
    #_public
    (ยง method #_"long" getIndex []
        (:index this)
    )

    ;;; Gets the height of the block that created this output. ;;
    #_public
    (ยง method #_"int" getHeight []
        (:height this)
    )

    ;;; Gets the flag of whether this was created by a coinbase tx. ;;
    #_public
    (ยง method #_"boolean" isCoinbase []
        (:coinbase this)
    )

    ;;; The address of this output, can be the empty string if none was provided at construction time or was deserialized. ;;
    #_public
    (ยง method #_"String" getAddress []
        (:address this)
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (String/format Locale/US, "Stored TxOut of %s (%s:%d)", (.. (:value this) (toFriendlyString)), (:hash this), (:index this))
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (.. this (getIndex)), (.. this (getHash)))
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"UTXO" __other (cast UTXO __o)]
            (and (== (.. this (getIndex)) (.. __other (getIndex))) (.. this (getHash) (equals (.. __other (getHash)))))
        )
    )

    #_private
    #_static
    #_throws #_[ "IOException" ]
    (ยง defn- #_"void" UTXO/write4x8le [#_"OutputStream" __os, #_"int" __n]
        (.. __os (write (& 0xff __n)))
        (.. __os (write (& 0xff (>> __n 8))))
        (.. __os (write (& 0xff (>> __n 16))))
        (.. __os (write (& 0xff (>> __n 24))))
        nil
    )

    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" serializeToStream [#_"OutputStream" __os]
        (Utils/uint64ToByteStreamLE (BigInteger/valueOf (-> this :value :value)), __os)

        (let [#_"byte[]" __scriptBytes (.. (:script this) (getProgram))]
            (UTXO/write4x8le __os, (.. __scriptBytes (alength)))
            (.. __os (write __scriptBytes))

            (.. __os (write (.. (:hash this) (getBytes))))
            (Utils/uint32ToByteStreamLE (:index this), __os)

            (UTXO/write4x8le __os, (:height this))
            (.. __os (write (byte-array [ (byte (if (:coinbase this) 1 0)) ])))
            nil
        )
    )

    #_private
    #_static
    #_throws #_[ "IOException" ]
    (ยง defn- #_"int" UTXO/read4x8le [#_"InputStream" __is]
        (| (& 0xff (.. __is (read))) (<< (& 0xff (.. __is (read))) 8) (<< (& 0xff (.. __is (read))) 16) (<< (& 0xff (.. __is (read))) 24))
    )

    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" deserializeFromStream [#_"InputStream" __is]
        (let [#_"byte[]" __valueBytes (byte-array 8)]
            (when (!= (.. __is (read __valueBytes, 0, 8)) 8)
                (throw (EOFException.))
            )
            (ยง assoc this :value (Coin/valueOf (Utils/readInt64 __valueBytes, 0)))

            (let [#_"int" __scriptBytesLength (UTXO/read4x8le __is)
                  #_"byte[]" __scriptBytes (byte-array __scriptBytesLength)]
                (when (!= (.. __is (read __scriptBytes)) __scriptBytesLength)
                    (throw (EOFException.))
                )
                (ยง assoc this :script (Script. __scriptBytes))

                (let [#_"byte[]" __hashBytes (byte-array 32)]
                    (when (!= (.. __is (read __hashBytes)) 32)
                        (throw (EOFException.))
                    )
                    (ยง assoc this :hash (Sha256Hash/wrap __hashBytes))

                    (let [#_"byte[]" __indexBytes (byte-array 4)]
                        (when (!= (.. __is (read __indexBytes)) 4)
                            (throw (EOFException.))
                        )
                        (ยง assoc this :index (Utils/readUint32 __indexBytes, 0))

                        (ยง assoc this :height (UTXO/read4x8le __is))

                        (let [#_"byte[]" __coinbaseByte (byte-array 1)]
                            (.. __is (read __coinbaseByte))
                            (ยง assoc this :coinbase (== (aget __coinbaseByte 0) 1))
                            nil
                        )
                    )
                )
            )
        )
    )

    #_private
    #_throws #_[ "IOException" ]
    (ยง method- #_"void" writeObject [#_"ObjectOutputStream" __o]
        (.. this (serializeToStream __o))
        nil
    )

    #_private
    #_throws #_[ "IOException", "ClassNotFoundException" ]
    (ยง method- #_"void" readObject [#_"ObjectInputStream" __o]
        (.. this (deserializeFromStream __o))
        nil
    )
)

;;;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class UnknownMessage (ยง extends EmptyMessage)
    #_private
    (ยง field- #_"String" :name)

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor UnknownMessage [#_"NetworkParameters" __params, #_"String" __name, #_"byte[]" __payloadBytes]
        (ยง super __params, __payloadBytes, 0)

        (ยง assoc this :name __name)
        this
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (str "Unknown message [" (:name this) "]: " (if (some? (:payload this)) (.. Utils/HEX (encode (:payload this))) ""))
    )
)

;;;
 ; A collection of various utility methods that are helpful for working with the Bitcoin protocol.
 ; To enable debug logging from the library, run with -Dbitcoinj.logging=true on your command line.
 ;;
#_public
(ยง class Utils
    ;;; The string that prefixes all text messages signed using Bitcoin keys. ;;
    #_public
    #_static
    (ยง def #_"String" Utils/BITCOIN_SIGNED_MESSAGE_HEADER "Bitcoin Signed Message:\n")
    #_public
    #_static
    (ยง def #_"byte[]" Utils/BITCOIN_SIGNED_MESSAGE_HEADER_BYTES (.. Utils/BITCOIN_SIGNED_MESSAGE_HEADER (getBytes Charsets/UTF_8)))

    #_public
    #_static
    (ยง def #_"Joiner" Utils/SPACE_JOINER (Joiner/on " "))

    #_private
    #_static
    (ยง def- #_"BlockingQueue<Boolean>" Utils/MOCK_SLEEP_QUEUE)

    ;;;
     ; The regular {@link java.math.BigInteger#toByteArray()} includes the sign bit of the number and
     ; might result in an extra byte addition.  This method removes this extra byte.
     ;
     ; Assuming only positive numbers, it's possible to discriminate if an extra byte
     ; is added by checking if the first element of the array is 0 (0000_0000).
     ; Due to the minimal representation provided by BigInteger, it means that the bit sign
     ; is the least significant bit 0000_000<b>0</b>.  Otherwise the representation is not minimal.
     ; For example, if the sign bit is 0000_00<b>0</b>0, then the representation is not minimal due to the rightmost zero.
     ;
     ; @param b The integer to format into a byte array.
     ; @param numBytes The desired size of the resulting byte array.
     ; @return numBytes byte long array.
     ;;
    #_public
    #_static
    (ยง defn #_"byte[]" Utils/bigIntegerToBytes [#_"BigInteger" __b, #_"int" __numBytes]
        (Preconditions/checkArgument (<= 0 (.. __b (signum))), "b must be positive or zero")
        (Preconditions/checkArgument (< 0 __numBytes), "numBytes must be positive")

        (let [#_"byte[]" __src (.. __b (toByteArray))
              #_"byte[]" __dest (byte-array __numBytes)
              #_"boolean" __isFirstByteOnlyForSign (== (aget __src 0) 0)
              #_"int" __length (if __isFirstByteOnlyForSign (dec (.. __src (alength))) (.. __src (alength)))]

            (Preconditions/checkArgument (<= __length __numBytes), (str "The given number does not fit in " __numBytes))

            (let [#_"int" __srcPos (if __isFirstByteOnlyForSign 1 0)
                  #_"int" __destPos (- __numBytes __length)]
                (System/arraycopy __src, __srcPos, __dest, __destPos, __length)
                __dest
            )
        )
    )

    #_public
    #_static
    (ยง defn #_"void" Utils/uint32ToByteArrayBE [#_"long" __val, #_"byte[]" __out, #_"int" __offset]
        (aset __out __offset (byte (& 0xff (>> __val 24))))
        (aset __out (inc __offset) (byte (& 0xff (>> __val 16))))
        (aset __out (+ __offset 2) (byte (& 0xff (>> __val 8))))
        (aset __out (+ __offset 3) (byte (& 0xff __val)))
        nil
    )

    #_public
    #_static
    (ยง defn #_"void" Utils/uint32ToByteArrayLE [#_"long" __val, #_"byte[]" __out, #_"int" __offset]
        (aset __out __offset (byte (& 0xff __val)))
        (aset __out (inc __offset) (byte (& 0xff (>> __val 8))))
        (aset __out (+ __offset 2) (byte (& 0xff (>> __val 16))))
        (aset __out (+ __offset 3) (byte (& 0xff (>> __val 24))))
        nil
    )

    #_public
    #_static
    (ยง defn #_"void" Utils/uint64ToByteArrayLE [#_"long" __val, #_"byte[]" __out, #_"int" __offset]
        (aset __out __offset (byte (& 0xff __val)))
        (aset __out (inc __offset) (byte (& 0xff (>> __val 8))))
        (aset __out (+ __offset 2) (byte (& 0xff (>> __val 16))))
        (aset __out (+ __offset 3) (byte (& 0xff (>> __val 24))))
        (aset __out (+ __offset 4) (byte (& 0xff (>> __val 32))))
        (aset __out (+ __offset 5) (byte (& 0xff (>> __val 40))))
        (aset __out (+ __offset 6) (byte (& 0xff (>> __val 48))))
        (aset __out (+ __offset 7) (byte (& 0xff (>> __val 56))))
        nil
    )

    #_public
    #_static
    #_throws #_[ "IOException" ]
    (ยง defn #_"void" Utils/uint32ToByteStreamLE [#_"long" __val, #_"OutputStream" __stream]
        (.. __stream (write (int (& 0xff __val))))
        (.. __stream (write (int (& 0xff (>> __val 8)))))
        (.. __stream (write (int (& 0xff (>> __val 16)))))
        (.. __stream (write (int (& 0xff (>> __val 24)))))
        nil
    )

    #_public
    #_static
    #_throws #_[ "IOException" ]
    (ยง defn #_"void" Utils/int64ToByteStreamLE [#_"long" __val, #_"OutputStream" __stream]
        (.. __stream (write (int (& 0xff __val))))
        (.. __stream (write (int (& 0xff (>> __val 8)))))
        (.. __stream (write (int (& 0xff (>> __val 16)))))
        (.. __stream (write (int (& 0xff (>> __val 24)))))
        (.. __stream (write (int (& 0xff (>> __val 32)))))
        (.. __stream (write (int (& 0xff (>> __val 40)))))
        (.. __stream (write (int (& 0xff (>> __val 48)))))
        (.. __stream (write (int (& 0xff (>> __val 56)))))
        nil
    )

    #_public
    #_static
    #_throws #_[ "IOException" ]
    (ยง defn #_"void" Utils/uint64ToByteStreamLE [#_"BigInteger" __val, #_"OutputStream" __stream]
        (let [#_"byte[]" __bytes (.. __val (toByteArray))]
            (when (< 8 (.. __bytes (alength)))
                (throw (RuntimeException. "Input too large to encode into a uint64"))
            )

            (ยง ass __bytes (Utils/reverseBytes __bytes))
            (.. __stream (write __bytes))
            (when (< (.. __bytes (alength)) 8)
                (loop-when-recur [#_"int" __i 0] (< __i (- 8 (.. __bytes (alength)))) [(inc __i)]
                    (.. __stream (write 0))
                )
            )
            nil
        )
    )

    ;;;
     ; Work around lack of unsigned types in Java.
     ;;
    #_public
    #_static
    (ยง defn #_"boolean" Utils/isLessThanUnsigned [#_"long" __n1, #_"long" __n2]
        (< (UnsignedLongs/compare __n1, __n2) 0)
    )

    ;;;
     ; Work around lack of unsigned types in Java.
     ;;
    #_public
    #_static
    (ยง defn #_"boolean" Utils/isLessThanOrEqualToUnsigned [#_"long" __n1, #_"long" __n2]
        (<= (UnsignedLongs/compare __n1, __n2) 0)
    )

    ;;;
     ; Hex encoding used throughout the framework.  Use with HEX.encode(byte[]) or HEX.decode(CharSequence).
     ;;
    #_public
    #_static
    (ยง def #_"BaseEncoding" Utils/HEX (.. (BaseEncoding/base16) (lowerCase)))

    ;;;
     ; Returns a copy of the given byte array in reverse order.
     ;;
    #_public
    #_static
    (ยง defn #_"byte[]" Utils/reverseBytes [#_"byte[]" __bytes]
        ;; We could use the XOR trick here, but it's easier to understand if we don't.
        ;; If we find this is really a performance issue, the matter can be revisited.
        (let [#_"byte[]" __buf (byte-array (.. __bytes (alength)))]
            (loop-when-recur [#_"int" __i 0] (< __i (.. __bytes (alength))) [(inc __i)]
                (aset __buf __i (aget __bytes (- (.. __bytes (alength)) 1 __i)))
            )
            __buf
        )
    )

    ;;;
     ; Returns a copy of the given byte array with the bytes of each double-word (4 bytes) reversed.
     ;
     ; @param bytes Length must be divisible by 4.
     ; @param trimLength Trim output to this length.  If positive, must be divisible by 4.
     ;;
    #_public
    #_static
    (ยง defn #_"byte[]" Utils/reverseDwordBytes [#_"byte[]" __bytes, #_"int" __trimLength]
        (Preconditions/checkArgument (== (% (.. __bytes (alength)) 4) 0))
        (Preconditions/checkArgument (or (< __trimLength 0) (== (% __trimLength 4) 0)))

        (let [#_"byte[]" __rev (byte-array (if (< -1 __trimLength (.. __bytes (alength))) __trimLength (.. __bytes (alength))))]

            (loop-when-recur [#_"int" __i 0] (< __i (.. __rev (alength))) [(+ __i 4)]
                (System/arraycopy __bytes, __i, __rev, __i, 4)
                (loop-when-recur [#_"int" __j 0] (< __j 4) [(inc __j)]
                    (aset __rev (+ __i __j) (aget __bytes (- (+ __i 3) __j)))
                )
            )
            __rev
        )
    )

    ;;; Parse 4 bytes from the byte array (starting at the offset) as unsigned 32-bit integer in little endian format. ;;
    #_public
    #_static
    (ยง defn #_"long" Utils/readUint32 [#_"byte[]" __bytes, #_"int" __offset]
        (| (& 0xff (aget __bytes __offset)) (<< (& 0xff (aget __bytes (inc __offset))) 8) (<< (& 0xff (aget __bytes (+ __offset 2))) 16) (<< (& 0xff (aget __bytes (+ __offset 3))) 24))
    )

    ;;; Parse 8 bytes from the byte array (starting at the offset) as signed 64-bit integer in little endian format. ;;
    #_public
    #_static
    (ยง defn #_"long" Utils/readInt64 [#_"byte[]" __bytes, #_"int" __offset]
        (| (& 0xff (aget __bytes __offset)) (<< (& 0xff (aget __bytes (inc __offset))) 8) (<< (& 0xff (aget __bytes (+ __offset 2))) 16) (<< (& 0xff (aget __bytes (+ __offset 3))) 24) (<< (& 0xff (aget __bytes (+ __offset 4))) 32) (<< (& 0xff (aget __bytes (+ __offset 5))) 40) (<< (& 0xff (aget __bytes (+ __offset 6))) 48) (<< (& 0xff (aget __bytes (+ __offset 7))) 56))
    )

    ;;; Parse 4 bytes from the byte array (starting at the offset) as unsigned 32-bit integer in big endian format. ;;
    #_public
    #_static
    (ยง defn #_"long" Utils/readUint32BE [#_"byte[]" __bytes, #_"int" __offset]
        (| (<< (& 0xff (aget __bytes __offset)) 24) (<< (& 0xff (aget __bytes (inc __offset))) 16) (<< (& 0xff (aget __bytes (+ __offset 2))) 8) (& 0xff (aget __bytes (+ __offset 3))))
    )

    ;;; Parse 2 bytes from the byte array (starting at the offset) as unsigned 16-bit integer in big endian format. ;;
    #_public
    #_static
    (ยง defn #_"int" Utils/readUint16BE [#_"byte[]" __bytes, #_"int" __offset]
        (| (<< (& 0xff (aget __bytes __offset)) 8) (& 0xff (aget __bytes (inc __offset))))
    )

    ;;;
     ; Calculates RIPEMD160(SHA256(input)).  This is used in Address calculations.
     ;;
    #_public
    #_static
    (ยง defn #_"byte[]" Utils/sha256hash160 [#_"byte[]" __input]
        (let [#_"byte[]" __sha256 (Sha256Hash/hash __input)
              #_"RIPEMD160Digest" __digest (RIPEMD160Digest.)]
            (.. __digest (update __sha256, 0, (.. __sha256 (alength))))
            (let [#_"byte[]" __out (byte-array 20)]
                (.. __digest (doFinal __out, 0))
                __out
            )
        )
    )

    ;;;
     ; MPI encoded numbers are produced by the OpenSSL BN_bn2mpi function.  They consist of
     ; a 4 byte big endian length field, followed by the stated number of bytes representing
     ; the number in big endian format (with a sign bit).
     ; @param hasLength can be set to false if the given array is missing the 4 byte length field.
     ;;
    #_public
    #_static
    (ยง defn #_"BigInteger" Utils/decodeMPI [#_"byte[]" __mpi, #_"boolean" __hasLength]
        (let [#_"byte[]" __buf]
            (cond __hasLength
                (do
                    (let [#_"int" __length (int (Utils/readUint32BE __mpi, 0))]
                        (ยง ass __buf (byte-array __length))
                        (System/arraycopy __mpi, 4, __buf, 0, __length)
                    )
                )
                :else
                (do
                    (ยง ass __buf __mpi)
                )
            )
            (when (== (.. __buf (alength)) 0)
                (ยง return BigInteger/ZERO)
            )

            (let [#_"boolean" __isNegative (== (& (aget __buf 0) 0x80) 0x80)]
                (when __isNegative
                    (aset __buf 0 (& (aget __buf 0) 0x7f))
                )
                (let [#_"BigInteger" __result (BigInteger. __buf)]
                    (if __isNegative (.. __result (negate)) __result)
                )
            )
        )
    )

    ;;;
     ; MPI encoded numbers are produced by the OpenSSL BN_bn2mpi function.  They consist of
     ; a 4 byte big endian length field, followed by the stated number of bytes representing
     ; the number in big endian format (with a sign bit).
     ; @param includeLength indicates whether the 4 byte length field should be included.
     ;;
    #_public
    #_static
    (ยง defn #_"byte[]" Utils/encodeMPI [#_"BigInteger" __value, #_"boolean" __includeLength]
        (when (.. __value (equals BigInteger/ZERO))
            (ยง return (if __includeLength (byte-array [ 0x00, 0x00, 0x00, 0x00 ]) (byte-array 0)))
        )

        (let [#_"boolean" __isNegative (< (.. __value (signum)) 0)]
            (when __isNegative
                (ยง ass __value (.. __value (negate)))
            )
            (let [#_"byte[]" __array (.. __value (toByteArray))
                  #_"int" __length (.. __array (alength))]
                (when (== (& (aget __array 0) 0x80) 0x80)
                    (ยง ass __length (inc __length))
                )

                (cond __includeLength
                    (do
                        (let [#_"byte[]" __result (byte-array (+ __length 4))]
                            (System/arraycopy __array, 0, __result, (+ (- __length (.. __array (alength))) 3), (.. __array (alength)))
                            (Utils/uint32ToByteArrayBE __length, __result, 0)
                            (when __isNegative
                                (aset __result 4 (| (aget __result 4) 0x80))
                            )
                            (ยง return __result)
                        )
                    )
                    :else
                    (do
                        (let [#_"byte[]" __result]
                            (cond (!= __length (.. __array (alength)))
                                (do
                                    (ยง ass __result (byte-array __length))
                                    (System/arraycopy __array, 0, __result, 1, (.. __array (alength)))
                                )
                                :else
                                (do
                                    (ยง ass __result __array)
                                )
                            )
                            (when __isNegative
                                (aset __result 0 (| (aget __result 0) 0x80))
                            )
                            (ยง return __result)
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; <p>The "compact" format is a representation of a whole number N using an unsigned 32 bit number similar to
     ; a floating point format.  The most significant 8 bits are the unsigned exponent of base 256.  This exponent
     ; can be thought of as "number of bytes of N".  The lower 23 bits are the mantissa.  Bit number 24 (0x800000)
     ; represents the sign of N.  Therefore, N = (-1^sign) * mantissa * 256^(exponent-3).</p>
     ;
     ; <p>Satoshi's original implementation used BN_bn2mpi() and BN_mpi2bn().  MPI uses the most significant bit of
     ; the first byte as sign.  Thus 0x1234560000 is compact 0x05123456 and 0xc0de000000 is compact 0x0600c0de.
     ; Compact 0x05c0de00 would be -0x40de000000.</p>
     ;
     ; <p>Bitcoin only uses this "compact" format for encoding difficulty targets, which are unsigned 256bit quantities.
     ; Thus, all the complexities of the sign bit and using base 256 are probably an implementation accident.</p>
     ;;
    #_public
    #_static
    (ยง defn #_"BigInteger" Utils/decodeCompactBits [#_"long" __compact]
        (let [#_"int" __size (& (int (>> __compact 24)) 0xff)
              #_"byte[]" __bytes (byte-array (+ 4 __size))]
            (aset __bytes 3 (byte __size))
            (when (<= 1 __size)
                (aset __bytes 4 (byte (& (>> __compact 16) 0xff)))
            )
            (when (<= 2 __size)
                (aset __bytes 5 (byte (& (>> __compact 8) 0xff)))
            )
            (when (<= 3 __size)
                (aset __bytes 6 (byte (& __compact 0xff)))
            )
            (Utils/decodeMPI __bytes, true)
        )
    )

    ;;;
     ; @see Utils#decodeCompactBits(long)
     ;;
    #_public
    #_static
    (ยง defn #_"long" Utils/encodeCompactBits [#_"BigInteger" __value]
        (let [#_"long" __result
              #_"int" __size (.. __value (toByteArray) (alength))]
            (if (<= __size 3)
                (ยง ass __result (<< (.. __value (longValue)) (* 8 (- 3 __size))))
                (ยง ass __result (.. __value (shiftRight (* 8 (- __size 3))) (longValue)))
            )
            ;; The 0x00800000 bit denotes the sign.
            ;; Thus, if it is already set, divide the mantissa by 256 and increase the exponent.
            (when (!= (& __result 0x00800000) 0)
                (ยง ass __result (>> __result 8))
                (ยง ass __size (inc __size))
            )
            (ยง ass __result (| __result (<< __size 24)))
            (ยง ass __result (| __result (if (== (.. __value (signum)) -1) 0x00800000 0)))
            __result
        )
    )

    ;;;
     ; If non-null, overrides the return value of now().
     ;;
    #_public
    #_static
    #_volatile
    (ยง def #_"Date" Utils/MOCK_TIME)

    ;;;
     ; Advances (or rewinds) the mock clock by the given number of seconds.
     ;;
    #_public
    #_static
    (ยง defn #_"Date" Utils/rollMockClock [#_"int" __seconds]
        (Utils/rollMockClockMillis (* __seconds 1000))
    )

    ;;;
     ; Advances (or rewinds) the mock clock by the given number of milliseconds.
     ;;
    #_public
    #_static
    (ยง defn #_"Date" Utils/rollMockClockMillis [#_"long" __millis]
        (when (nil? Utils/MOCK_TIME)
            (throw (IllegalStateException. "You need to use setMockClock() first."))
        )

        (ยง ass Utils/MOCK_TIME (Date. (+ (.. Utils/MOCK_TIME (getTime)) __millis)))
        Utils/MOCK_TIME
    )

    ;;;
     ; Sets the mock clock to the current time.
     ;;
    #_public
    #_static
    (ยง defn #_"void" Utils/setMockClock []
        (ยง ass Utils/MOCK_TIME (Date.))
        nil
    )

    ;;;
     ; Sets the mock clock to the given time (in seconds).
     ;;
    #_public
    #_static
    (ยง defn #_"void" Utils/setMockClock [#_"long" __mockClockSeconds]
        (ยง ass Utils/MOCK_TIME (Date. (* __mockClockSeconds 1000)))
        nil
    )

    ;;;
     ; Returns the current time, or a mocked out equivalent.
     ;;
    #_public
    #_static
    (ยง defn #_"Date" Utils/now []
        (or Utils/MOCK_TIME (Date.))
    )

    ;; TODO: Replace usages of this where the result is / 1000 with currentTimeSeconds.
    ;;; Returns the current time in milliseconds since the epoch, or a mocked out equivalent. ;;
    #_public
    #_static
    (ยง defn #_"long" Utils/currentTimeMillis []
        (if (some? Utils/MOCK_TIME) (.. Utils/MOCK_TIME (getTime)) (System/currentTimeMillis))
    )

    #_public
    #_static
    (ยง defn #_"long" Utils/currentTimeSeconds []
        (/ (Utils/currentTimeMillis) 1000)
    )

    #_private
    #_static
    (ยง def- #_"TimeZone" Utils/UTC (TimeZone/getTimeZone "UTC"))

    ;;;
     ; Formats a given date+time value to an ISO 8601 string.
     ; @param dateTime value to format, as a Date
     ;;
    #_public
    #_static
    (ยง defn #_"String" Utils/dateTimeFormat [#_"Date" __dateTime]
        (let [#_"DateFormat" __iso8601 (SimpleDateFormat. "yyyy-MM-dd'T'HH:mm:ss'Z'", Locale/US)]
            (.. __iso8601 (setTimeZone Utils/UTC))
            (.. __iso8601 (format __dateTime))
        )
    )

    ;;;
     ; Formats a given date+time value to an ISO 8601 string.
     ; @param dateTime value to format, unix time (ms)
     ;;
    #_public
    #_static
    (ยง defn #_"String" Utils/dateTimeFormat [#_"long" __dateTime]
        (let [#_"DateFormat" __iso8601 (SimpleDateFormat. "yyyy-MM-dd'T'HH:mm:ss'Z'", Locale/US)]
            (.. __iso8601 (setTimeZone Utils/UTC))
            (.. __iso8601 (format __dateTime))
        )
    )

    #_public
    #_static
    (ยง defn #_"byte[]" Utils/copyOf [#_"byte[]" __in, #_"int" __length]
        (let [#_"byte[]" __out (byte-array __length)]
            (System/arraycopy __in, 0, __out, 0, (Math/min __length, (.. __in (alength))))
            __out
        )
    )

    ;;;
     ; Creates a copy of bytes and appends b to the end of it.
     ;;
    #_public
    #_static
    (ยง defn #_"byte[]" Utils/appendByte [#_"byte[]" __bytes, #_"byte" __b]
        (let [#_"byte[]" __result (Arrays/copyOf __bytes, (inc (.. __bytes (alength))))]
            (aset __result (dec (.. __result (alength))) __b)
            __result
        )
    )

    ;;;
     ; Constructs a new String by decoding the given bytes using the specified charset.
     ;
     ; This is a convenience method which wraps the checked exception with a RuntimeException.
     ; The exception can never occur given the charsets
     ; US-ASCII, ISO-8859-1, UTF-8, UTF-16, UTF-16LE or UTF-16BE.
     ;
     ; @param bytes The bytes to be decoded into characters.
     ; @param charsetName The name of a supported {@linkplain java.nio.charset.Charset charset}.
     ; @return the decoded String.
     ;;
    #_public
    #_static
    (ยง defn #_"String" Utils/toString [#_"byte[]" __bytes, #_"String" __charsetName]
        (try
            (ยง return (String. __bytes, __charsetName))
            (catch UnsupportedEncodingException __e
                (throw (RuntimeException. __e))
            )
        )
    )

    ;;;
     ; Encodes the given string into a sequence of bytes using the named charset.
     ;
     ; This is a convenience method which wraps the checked exception with a RuntimeException.
     ; The exception can never occur given the charsets
     ; US-ASCII, ISO-8859-1, UTF-8, UTF-16, UTF-16LE or UTF-16BE.
     ;
     ; @param str The string to encode into bytes.
     ; @param charsetName The name of a supported {@linkplain java.nio.charset.Charset charset}.
     ; @return the encoded bytes.
     ;;
    #_public
    #_static
    (ยง defn #_"byte[]" Utils/toBytes [#_"CharSequence" __str, #_"String" __charsetName]
        (try
            (ยง return (.. __str (toString) (getBytes __charsetName)))
            (catch UnsupportedEncodingException __e
                (throw (RuntimeException. __e))
            )
        )
    )

    ;;;
     ; Attempts to parse the given string as arbitrary-length hex or base58 and then return the results,
     ; or null if neither parse was successful.
     ;;
    #_public
    #_static
    (ยง defn #_"byte[]" Utils/parseAsHexOrBase58 [#_"String" __data]
        (try
            (ยง return (.. Utils/HEX (decode __data)))
            (catch Exception _
                ;; Didn't decode as hex, try base58.
                (try
                    (ยง return (Base58/decodeChecked __data))
                    (catch AddressFormatException __
                        (ยง return nil)
                    )
                )
            )
        )
    )

    #_public
    #_static
    (ยง defn #_"boolean" Utils/isWindows []
        (.. (System/getProperty "os.name") (toLowerCase) (contains "win"))
    )

    ;;;
     ; <p>Given a textual message, returns a byte buffer formatted as follows:</p>
     ;
     ; <p><tt>[24] "Bitcoin Signed Message:\n" [message.length as a varint] message</tt>.</p>
     ;;
    #_public
    #_static
    (ยง defn #_"byte[]" Utils/formatMessageForSigning [#_"String" __message]
        (try
            (let [#_"ByteArrayOutputStream" __bos (ByteArrayOutputStream.)]
                (.. __bos (write (.. Utils/BITCOIN_SIGNED_MESSAGE_HEADER_BYTES (alength))))
                (.. __bos (write Utils/BITCOIN_SIGNED_MESSAGE_HEADER_BYTES))
                (let [#_"byte[]" __messageBytes (.. __message (getBytes Charsets/UTF_8))
                      #_"VarInt" __size (VarInt. (.. __messageBytes (alength)))]
                    (.. __bos (write (.. __size (encode))))
                    (.. __bos (write __messageBytes))
                    (ยง return (.. __bos (toByteArray)))
                )
            )
            (catch IOException __e
                (throw (RuntimeException. __e)) ;; Cannot happen.
            )
        )
    )

    ;; 00000001, 00000010, 00000100, 00001000, ...
    #_private
    #_static
    (ยง def- #_"int[]" Utils/BIT_MASK (int-array [ 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 ]))

    ;;; Checks if the given bit is set in data, using little endian (not the same as Java native big endian). ;;
    #_public
    #_static
    (ยง defn #_"boolean" Utils/checkBitLE [#_"byte[]" __data, #_"int" __index]
        (!= (& (aget __data (>>> __index 3)) (aget Utils/BIT_MASK (& 7 __index))) 0)
    )

    ;;; Sets the given bit in data to one, using little endian (not the same as Java native big endian). ;;
    #_public
    #_static
    (ยง defn #_"void" Utils/setBitLE [#_"byte[]" __data, #_"int" __index]
        (aset __data (>>> __index 3) (| (aget __data (>>> __index 3)) (aget Utils/BIT_MASK (& 7 __index))))
        nil
    )

    ;;; Sleep for a span of time, or mock sleep if enabled. ;;
    #_public
    #_static
    (ยง defn #_"void" Utils/sleep [#_"long" __millis]
        (cond (nil? Utils/MOCK_SLEEP_QUEUE)
            (do
                (Uninterruptibles/sleepUninterruptibly __millis, TimeUnit/MILLISECONDS)
            )
            :else
            (do
                (try
                    (let [#_"boolean" __isMultiPass (.. Utils/MOCK_SLEEP_QUEUE (take))]
                        (Utils/rollMockClockMillis __millis)
                        (when __isMultiPass
                            (.. Utils/MOCK_SLEEP_QUEUE (offer true))
                        )
                    )
                    (catch InterruptedException _
                        ;; Ignored.
                    )
                )
            )
        )
        nil
    )

    ;;; Enable or disable mock sleep.  If enabled, set mock time to current time. ;;
    #_public
    #_static
    (ยง defn #_"void" Utils/setMockSleep [#_"boolean" __isEnable]
        (cond __isEnable
            (do
                (ยง ass Utils/MOCK_SLEEP_QUEUE (ArrayBlockingQueue. #_"<>" 1))
                (ยง ass Utils/MOCK_TIME (Date. (System/currentTimeMillis)))
            )
            :else
            (do
                (ยง ass Utils/MOCK_SLEEP_QUEUE nil)
            )
        )
        nil
    )

    ;;; Let sleeping thread pass the synchronization point. ;;
    #_public
    #_static
    (ยง defn #_"void" Utils/passMockSleep []
        (.. Utils/MOCK_SLEEP_QUEUE (offer false))
        nil
    )

    ;;; Let the sleeping thread pass the synchronization point any number of times. ;;
    #_public
    #_static
    (ยง defn #_"void" Utils/finishMockSleep []
        (when (some? Utils/MOCK_SLEEP_QUEUE)
            (.. Utils/MOCK_SLEEP_QUEUE (offer true))
        )
        nil
    )

    #_private
    #_static
    (ยง def- #_"int" Utils/IS_ANDROID -1)
    #_public
    #_static
    (ยง defn #_"boolean" Utils/isAndroidRuntime []
        (when (== Utils/IS_ANDROID -1)
            (let [#_"String" __runtime (System/getProperty "java.runtime.name")]
                (ยง ass Utils/IS_ANDROID (if (and (some? __runtime) (.. __runtime (equals "Android Runtime"))) 1 0))
            )
        )
        (== Utils/IS_ANDROID 1)
    )

    #_private
    #_static
    (ยง class- Utils.Pair (ยง implements Comparable #_"<Utils.Pair>")
        (ยง field- #_"int" :item)
        (ยง field- #_"int" :count)

        #_public
        (ยง constructor Utils.Pair [#_"int" __item, #_"int" __count]
            (ยง assoc this :count __count)
            (ยง assoc this :item __item)
            this
        )

        ;; Note that in this implementation compareTo() is not consistent with equals().
        #_override
        #_public
        (ยง method #_"int" compareTo [#_"Utils.Pair" __o]
            (- (Ints/compare (:count this), (:count __o)))
        )
    )

    #_public
    #_static
    (ยง defn #_"int" Utils/maxOfMostFreq [#_"int..." __items]
        ;; Java 6 sucks.
        (let [#_"ArrayList<Integer>" __list (ArrayList. #_"<>" (.. __items (alength)))]
            (doseq [#_"int" __item __items]
                (.. __list (add __item))
            )
            (Utils/maxOfMostFreq __list)
        )
    )

    #_public
    #_static
    (ยง defn #_"int" Utils/maxOfMostFreq [#_"List<Integer>" __items]
        (when (.. __items (isEmpty))
            (ยง return 0)
        )

        ;; This would be much easier in a functional language (or in Java 8).
        (ยง ass __items (.. (Ordering/natural) (reverse) (sortedCopy __items)))
        (let [#_"LinkedList<Utils.Pair>" __pairs (Lists/newLinkedList)]
            (.. __pairs (add (Utils.Pair. (.. __items (get 0)), 0)))
            (doseq [#_"int" __item __items]
                (let [#_"Utils.Pair" __pair (.. __pairs (getLast))]
                    (when (!= (:item __pair) __item)
                        (.. __pairs (add (ยง ass __pair (Utils.Pair. __item, 0))))
                    )
                    (ยง assoc __pair :count (inc (:count __pair)))
                )
            )
            ;; pairs now contains a uniqified list of the sorted inputs, with counts for how often that item appeared.
            ;; Now sort by how frequently they occur, and pick the max of the most frequent.
            (Collections/sort __pairs)
            (let [#_"int" __maxCount (:count (.. __pairs (getFirst)))
                  #_"int" __maxItem (:item (.. __pairs (getFirst)))]
                (doseq [#_"Utils.Pair" __pair __pairs]
                    (when (!= (:count __pair) __maxCount)
                        (ยง break )
                    )
                    (ยง ass __maxItem (Math/max __maxItem, (:item __pair)))
                )
                __maxItem
            )
        )
    )

    ;;;
     ; Reads and joins together with LF char (\n) all the lines from given file.
     ; It's assumed that file is in UTF-8.
     ;;
    #_public
    #_static
    #_throws #_[ "IOException" ]
    (ยง defn #_"String" Utils/getResourceAsString [#_"URL" __url]
        (let [#_"List<String>" __lines (Resources/readLines __url, Charsets/UTF_8)]
            (.. (Joiner/on "\n") (join __lines))
        )
    )

    ;; Can't use Closeable here because it's Java 7 only and Android devices only got that with KitKat.
    #_public
    #_static
    (ยง defn #_"InputStream" Utils/closeUnchecked [#_"InputStream" __stream]
        (try
            (.. __stream (close))
            (ยง return __stream)
            (catch IOException __e
                (throw (RuntimeException. __e))
            )
        )
    )

    #_public
    #_static
    (ยง defn #_"OutputStream" Utils/closeUnchecked [#_"OutputStream" __stream]
        (try
            (.. __stream (close))
            (ยง return __stream)
            (catch IOException __e
                (throw (RuntimeException. __e))
            )
        )
    )
)

;;;
 ; A variable-length encoded unsigned integer using Satoshi's encoding (a.k.a. "CompactSize").
 ;;
#_public
(ยง class VarInt
    #_public
    (ยง field #_"long" :value)
    #_private
    (ยง field- #_"int" :originally-encoded-size)

    ;;;
     ; Constructs a new VarInt with the given unsigned long value.
     ;
     ; @param value the unsigned long value (beware widening conversion of negatives!)
     ;;
    #_public
    (ยง constructor VarInt [#_"long" __value]
        (ยง assoc this :value __value)
        (ยง assoc this :originally-encoded-size (.. this (getSizeInBytes)))
        this
    )

    ;;;
     ; Constructs a new VarInt with the value parsed from the specified offset of the given buffer.
     ;
     ; @param buf The buffer containing the value.
     ; @param offset The offset of the value.
     ;;
    #_public
    (ยง constructor VarInt [#_"byte[]" __buf, #_"int" __offset]
        (let [#_"int" __first (& 0xff (aget __buf __offset))]
            (cond (< __first 253)
                (do
                    (ยง assoc this :value __first)
                    (ยง assoc this :originally-encoded-size 1) ;; 1 data byte (8 bits)
                )
                (== __first 253)
                (do
                    (ยง assoc this :value (| (& 0xff (aget __buf (inc __offset))) (<< (& 0xff (aget __buf (+ __offset 2))) 8)))
                    (ยง assoc this :originally-encoded-size 3) ;; 1 marker + 2 data bytes (16 bits)
                )
                (== __first 254)
                (do
                    (ยง assoc this :value (Utils/readUint32 __buf, (inc __offset)))
                    (ยง assoc this :originally-encoded-size 5) ;; 1 marker + 4 data bytes (32 bits)
                )
                :else
                (do
                    (ยง assoc this :value (Utils/readInt64 __buf, (inc __offset)))
                    (ยง assoc this :originally-encoded-size 9) ;; 1 marker + 8 data bytes (64 bits)
                )
            )
            this
        )
    )

    ;;;
     ; Returns the original number of bytes used to encode the value if it was
     ; deserialized from a byte array, or the minimum encoded size if it was not.
     ;;
    #_public
    (ยง method #_"int" getOriginalSizeInBytes []
        (:originally-encoded-size this)
    )

    ;;;
     ; Returns the minimum encoded size of the value.
     ;;
    #_public
    (ยง method #_"int" getSizeInBytes []
        (VarInt/sizeOf (:value this))
    )

    ;;;
     ; Returns the minimum encoded size of the given unsigned long value.
     ;
     ; @param value the unsigned long value (beware widening conversion of negatives!)
     ;;
    #_public
    #_static
    (ยง defn #_"int" VarInt/sizeOf [#_"long" __value]
        ;; if negative, it's actually a very large unsigned long value
        (when (< __value 0)
            (ยง return 9) ;; 1 marker + 8 data bytes
        )
        (when (< __value 253)
            (ยง return 1) ;; 1 data byte
        )
        (when (<= __value 0xffff)
            (ยง return 3) ;; 1 marker + 2 data bytes
        )
        (when (<= __value 0xffffffff)
            (ยง return 5) ;; 1 marker + 4 data bytes
        )
        9 ;; 1 marker + 8 data bytes
    )

    ;;;
     ; Encodes the value into its minimal representation.
     ;
     ; @return the minimal encoded bytes of the value.
     ;;
    #_public
    (ยง method #_"byte[]" encode []
        (case (VarInt/sizeOf (:value this))
            1 (byte-array [ (byte (:value this)) ])
            3 (byte-array [ (byte 253), (byte (:value this)), (byte (>> (:value this) 8)) ])
            5 (let [#_"byte[]" __bytes (byte-array 5)]
                    (aset __bytes 0 (byte 254))
                    (Utils/uint32ToByteArrayLE (:value this), __bytes, 1)
                    __bytes)
              (let [#_"byte[]" __bytes (byte-array 9)]
                    (aset __bytes 0 (byte 255))
                    (Utils/uint64ToByteArrayLE (:value this), __bytes, 1)
                    __bytes)
        )
    )
)

#_public
(ยง class VerificationException (ยง extends RuntimeException)
    #_public
    (ยง constructor VerificationException [#_"String" __msg]
        (ยง super __msg)
        this
    )

    #_public
    (ยง constructor VerificationException [#_"Exception" __e]
        (ยง super __e)
        this
    )

    #_public
    (ยง constructor VerificationException [#_"String" __msg, #_"Throwable" __t]
        (ยง super __msg, __t)
        this
    )

    #_public
    #_static
    (ยง class VerificationException.EmptyInputsOrOutputs (ยง extends VerificationException)
        #_public
        (ยง constructor VerificationException.EmptyInputsOrOutputs []
            (ยง super "Transaction had no inputs or no outputs.")
            this
        )
    )

    #_public
    #_static
    (ยง class VerificationException.LargerThanMaxBlockSize (ยง extends VerificationException)
        #_public
        (ยง constructor VerificationException.LargerThanMaxBlockSize []
            (ยง super "Transaction larger than MAX_BLOCK_SIZE")
            this
        )
    )

    #_public
    #_static
    (ยง class VerificationException.DuplicatedOutPoint (ยง extends VerificationException)
        #_public
        (ยง constructor VerificationException.DuplicatedOutPoint []
            (ยง super "Duplicated outpoint")
            this
        )
    )

    #_public
    #_static
    (ยง class VerificationException.NegativeValueOutput (ยง extends VerificationException)
        #_public
        (ยง constructor VerificationException.NegativeValueOutput []
            (ยง super "Transaction output negative")
            this
        )
    )

    #_public
    #_static
    (ยง class VerificationException.ExcessiveValue (ยง extends VerificationException)
        #_public
        (ยง constructor VerificationException.ExcessiveValue []
            (ยง super "Total transaction output value greater than possible")
            this
        )
    )

    #_public
    #_static
    (ยง class VerificationException.CoinbaseScriptSizeOutOfRange (ยง extends VerificationException)
        #_public
        (ยง constructor VerificationException.CoinbaseScriptSizeOutOfRange []
            (ยง super "Coinbase script size out of range")
            this
        )
    )

    #_public
    #_static
    (ยง class VerificationException.BlockVersionOutOfDate (ยง extends VerificationException)
        #_public
        (ยง constructor VerificationException.BlockVersionOutOfDate [#_"long" __version]
            (ยง super (str "Block version #" __version " is outdated."))
            this
        )
    )

    #_public
    #_static
    (ยง class VerificationException.UnexpectedCoinbaseInput (ยง extends VerificationException)
        #_public
        (ยง constructor VerificationException.UnexpectedCoinbaseInput []
            (ยง super "Coinbase input as input in non-coinbase transaction")
            this
        )
    )

    #_public
    #_static
    (ยง class VerificationException.CoinbaseHeightMismatch (ยง extends VerificationException)
        #_public
        (ยง constructor VerificationException.CoinbaseHeightMismatch [#_"String" __message]
            (ยง super __message)
            this
        )
    )
)

;;;
 ; <p>The verack message, sent by a client accepting the version message they
 ; received from their peer.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class VersionAck (ยง extends EmptyMessage)
    #_public
    (ยง constructor VersionAck []
        this
    )

    ;; this is needed by the BitcoinSerializer
    #_public
    (ยง constructor VersionAck [#_"NetworkParameters" __params, #_"byte[]" __payload]
        this
    )
)

;;;
 ; <p>A VersionMessage holds information exchanged during connection setup with another peer.  Most of the fields are
 ; not particularly interesting.  The subVer field, since BIP 14, acts as a User-Agent string would.  You can and should
 ; append to or change the subVer for your own software so other implementations can identify it, and you can look at
 ; the subVer field received from other nodes to see what they are running.</p>
 ;
 ; <p>After creating yourself a VersionMessage, you can pass it to {@link PeerGroup#setVersionMessage(VersionMessage)}
 ; to ensure it will be used for each new connection.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(ยง class VersionMessage (ยง extends Message)
    ;;; The version of this library release, as a string. ;;
    #_public
    #_static
    (ยง def #_"String" VersionMessage/BITCOINJ_VERSION "0.15-SNAPSHOT")
    ;;; The value that is prepended to the subVer field of this application. ;;
    #_public
    #_static
    (ยง def #_"String" VersionMessage/LIBRARY_SUBVER (str "/bitcoinj:" VersionMessage/BITCOINJ_VERSION "/"))

    ;;; A services flag that denotes whether the peer has a copy of the block chain or not. ;;
    #_public
    #_static
    (ยง def #_"int" VersionMessage/NODE_NETWORK 1)

    ;;;
     ; The version number of the protocol spoken.
     ;;
    #_public
    (ยง field #_"int" :client-version)
    ;;;
     ; Flags defining what optional services are supported.
     ;;
    #_public
    (ยง field #_"long" :local-services)
    ;;;
     ; What the other side believes the current time to be, in seconds.
     ;;
    #_public
    (ยง field #_"long" :time)
    ;;;
     ; What the other side believes the address of this program is.  Not used.
     ;;
    #_public
    (ยง field #_"PeerAddress" :my-addr)
    ;;;
     ; What the other side believes their own address is.  Not used.
     ;;
    #_public
    (ยง field #_"PeerAddress" :their-addr)
    ;;;
     ; User-Agent as defined in <a href="https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki">BIP 14</a>.
     ; Bitcoin Core sets it to something like "/Satoshi:0.9.1/".
     ;;
    #_public
    (ยง field #_"String" :sub-ver)
    ;;;
     ; How many blocks are in the chain, according to the other side.
     ;;
    #_public
    (ยง field #_"long" :best-height)
    ;;;
     ; Whether or not to relay tx invs before a filter is received.
     ; See <a href="https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki#extensions-to-existing-messages">BIP 37</a>.
     ;;
    #_public
    (ยง field #_"boolean" :relay-txes-before-filter)

    #_public
    #_throws #_[ "ProtocolException" ]
    (ยง constructor VersionMessage [#_"NetworkParameters" __params, #_"byte[]" __payload]
        (ยง super __params, __payload, 0)
        this
    )

    ;; It doesn't really make sense to ever lazily parse a version message or to retain the backing bytes.
    ;; If you're receiving this on the wire you need to check the protocol version and it will never need
    ;; to be sent back down the wire.

    #_public
    (ยง constructor VersionMessage [#_"NetworkParameters" __params, #_"int" __newBestHeight]
        (ยง super __params)

        (ยง assoc this :client-version (.. __params (getProtocolVersionNum NetworkParameters.ProtocolVersion/CURRENT)))
        (ยง assoc this :local-services 0)
        (ยง assoc this :time (/ (System/currentTimeMillis) 1000))
        ;; Note that the Bitcoin Core doesn't do anything with these, and finding out your own external IP address
        ;; is kind of tricky anyway, so we just put nonsense here for now.
        (let [#_"InetAddress" __localhost (InetAddresses/forString "127.0.0.1")]
            (ยง assoc this :my-addr (PeerAddress. __params, __localhost, (.. __params (getPort)), 0, BigInteger/ZERO))
            (ยง assoc this :their-addr (PeerAddress. __params, __localhost, (.. __params (getPort)), 0, BigInteger/ZERO))
            (ยง assoc this :sub-ver VersionMessage/LIBRARY_SUBVER)
            (ยง assoc this :best-height __newBestHeight)
            (ยง assoc this :relay-txes-before-filter true)

            (ยง assoc this :length 85)
            (when (< 31402 (:protocol-version this))
                (ยง assoc this :length (+ (:length this) 8))
            )
            (ยง assoc this :length (+ (:length this) (VarInt/sizeOf (.. (:sub-ver this) (length))) (.. (:sub-ver this) (length))))
            this
        )
    )

    #_override
    #_protected
    #_throws #_[ "ProtocolException" ]
    (ยง method #_"void" parse []
        (ยง assoc this :client-version (int (.. this (readUint32))))
        (ยง assoc this :local-services (.. this (readUint64) (longValue)))
        (ยง assoc this :time (.. this (readUint64) (longValue)))
        (ยง assoc this :my-addr (PeerAddress. (:params this), (:payload this), (:cursor this), 0))
        (ยง assoc this :cursor (+ (:cursor this) (.. (:my-addr this) (getMessageSize))))
        (ยง assoc this :their-addr (PeerAddress. (:params this), (:payload this), (:cursor this), 0))
        (ยง assoc this :cursor (+ (:cursor this) (.. (:their-addr this) (getMessageSize))))
        ;; uint64 localHostNonce (random data)
        ;; We don't care about the localhost nonce.  It's used to detect connecting back to yourself in cases where
        ;; there are NATs and proxies in the way.  However we don't listen for inbound connections so it's irrelevant.
        (.. this (readUint64))
        (try
            ;; Initialize default values for flags which may not be sent by old nodes.
            (ยง assoc this :sub-ver "")
            (ยง assoc this :best-height 0)
            (ยง assoc this :relay-txes-before-filter true)
            (when (not (.. this (hasMoreBytes)))
                (ยง return nil)
            )

            ;; string subVer (currently "")
            (ยง assoc this :sub-ver (.. this (readStr)))
            (when (not (.. this (hasMoreBytes)))
                (ยง return nil)
            )

            ;; int bestHeight (size of known block chain)
            (ยง assoc this :best-height (.. this (readUint32)))
            (when (not (.. this (hasMoreBytes)))
                (ยง return nil)
            )

            (ยง assoc this :relay-txes-before-filter (!= (aget (.. this (readBytes 1)) 0) 0))
            (finally
                (ยง assoc this :length (- (:cursor this) (:offset this)))
            )
        )
        nil
    )

    #_override
    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" bitcoinSerializeToStream [#_"OutputStream" __buf]
        (Utils/uint32ToByteStreamLE (:client-version this), __buf)
        (Utils/uint32ToByteStreamLE (:local-services this), __buf)
        (Utils/uint32ToByteStreamLE (>> (:local-services this) 32), __buf)
        (Utils/uint32ToByteStreamLE (:time this), __buf)
        (Utils/uint32ToByteStreamLE (>> (:time this) 32), __buf)
        (try
            ;; My address.
            (.. (:my-addr this) (bitcoinSerialize __buf))
            ;; Their address.
            (.. (:their-addr this) (bitcoinSerialize __buf))
            (catch UnknownHostException __e
                (throw (RuntimeException. __e)) ;; Can't happen.
            )
            (catch IOException __e
                (throw (RuntimeException. __e)) ;; Can't happen.
            )
        )
        ;; Next up is the "local host nonce", this is to detect the case of connecting back to yourself.
        ;; We don't care about this as we won't be accepting inbound connections.
        (Utils/uint32ToByteStreamLE 0, __buf)
        (Utils/uint32ToByteStreamLE 0, __buf)
        ;; Now comes subVer.
        (let [#_"byte[]" __subVerBytes (.. (:sub-ver this) (getBytes "UTF-8"))]
            (.. __buf (write (.. (VarInt. (.. __subVerBytes (alength))) (encode))))
            (.. __buf (write __subVerBytes))
            ;; Size of known block chain.
            (Utils/uint32ToByteStreamLE (:best-height this), __buf)
            (.. __buf (write (if (:relay-txes-before-filter this) 1 0)))
            nil
        )
    )

    ;;;
     ; Returns true if the version message indicates the sender has a full copy of the block chain,
     ; or if it's running in client mode (only has the headers).
     ;;
    #_public
    (ยง method #_"boolean" hasBlockChain []
        (== (& (:local-services this) VersionMessage/NODE_NETWORK) VersionMessage/NODE_NETWORK)
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"VersionMessage" __other (cast VersionMessage __o)]
            (and (== (:best-height __other) (:best-height this)) (== (:client-version __other) (:client-version this)) (== (:local-services __other) (:local-services this)) (== (:time __other) (:time this)) (.. (:sub-ver __other) (equals (:sub-ver this))) (.. (:my-addr __other) (equals (:my-addr this))) (.. (:their-addr __other) (equals (:their-addr this))) (== (:relay-txes-before-filter __other) (:relay-txes-before-filter this)))
        )
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (:best-height this), (:client-version this), (:local-services this), (:time this), (:sub-ver this), (:my-addr this), (:their-addr this), (:relay-txes-before-filter this))
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (let [#_"StringBuilder" __sb (StringBuilder.)]
            (.. __sb (append "\n"))
            (.. __sb (append "client version: ") (append (:client-version this)) (append "\n"))
            (.. __sb (append "local services: ") (append (:local-services this)) (append "\n"))
            (.. __sb (append "time:           ") (append (:time this)) (append "\n"))
            (.. __sb (append "my addr:        ") (append (:my-addr this)) (append "\n"))
            (.. __sb (append "their addr:     ") (append (:their-addr this)) (append "\n"))
            (.. __sb (append "sub version:    ") (append (:sub-ver this)) (append "\n"))
            (.. __sb (append "best height:    ") (append (:best-height this)) (append "\n"))
            (.. __sb (append "delay tx relay: ") (append (not (:relay-txes-before-filter this))) (append "\n"))
            (.. __sb (toString))
        )
    )

    #_public
    (ยง method #_"VersionMessage" duplicate []
        (let [#_"VersionMessage" __v (VersionMessage. (:params this), (int (:best-height this)))]
            (ยง assoc __v :client-version (:client-version this))
            (ยง assoc __v :local-services (:local-services this))
            (ยง assoc __v :time (:time this))
            (ยง assoc __v :my-addr (:my-addr this))
            (ยง assoc __v :their-addr (:their-addr this))
            (ยง assoc __v :sub-ver (:sub-ver this))
            (ยง assoc __v :relay-txes-before-filter (:relay-txes-before-filter this))
            __v
        )
    )

    ;;;
     ; Appends the given user-agent information to the subVer field.  The subVer is composed of a series of
     ; name:version pairs separated by slashes in the form of a path.  For example a typical subVer field for bitcoinj
     ; users might look like "/bitcoinj:0.13/MultiBit:1.2/" where libraries come further to the left.
     ;
     ; There can be as many components as you feel a need for, and the version string can be anything, but it is
     ; recommended to use A.B.C where A = major, B = minor and C = revision for software releases, and dates for
     ; auto-generated source repository snapshots.  A valid subVer begins and ends with a slash, therefore name
     ; and version are not allowed to contain such characters.
     ;
     ; Anything put in the "comments" field will appear in brackets and may be used for platform info, or anything
     ; else.  For example, calling <tt>appendToSubVer("MultiBit", "1.0", "Windows")</tt> will result in a subVer being
     ; set of "/bitcoinj:1.0/MultiBit:1.0(Windows)/".  Therefore the / ( and ) characters are reserved in all these
     ; components.  If you don't want to add a comment (recommended), pass null.
     ;
     ; See <a href="https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki">BIP 14</a> for more information.
     ;
     ; @param comments Optional (can be null) platform or other node specific information.
     ; @throws IllegalArgumentException if name, version or comments contains invalid characters.
     ;;
    #_public
    (ยง method #_"void" appendToSubVer [#_"String" __name, #_"String" __version, #_nilable #_"String" __comments]
        (VersionMessage/checkSubVerComponent __name)
        (VersionMessage/checkSubVerComponent __version)

        (cond (some? __comments)
            (do
                (VersionMessage/checkSubVerComponent __comments)
                (ยง assoc this :sub-ver (.. (:sub-ver this) (concat (String/format Locale/US, "%s:%s(%s)/", __name, __version, __comments))))
            )
            :else
            (do
                (ยง assoc this :sub-ver (.. (:sub-ver this) (concat (String/format Locale/US, "%s:%s/", __name, __version))))
            )
        )
        nil
    )

    #_private
    #_static
    (ยง defn- #_"void" VersionMessage/checkSubVerComponent [#_"String" __component]
        (when (or (.. __component (contains "/")) (.. __component (contains "(")) (.. __component (contains ")")))
            (throw (IllegalArgumentException. "name contains invalid characters"))
        )
        nil
    )

    ;;;
     ; Returns true if the clientVersion field is >= Pong.MIN_PROTOCOL_VERSION.  If it is then ping() is usable.
     ;;
    #_public
    (ยง method #_"boolean" isPingPongSupported []
        (<= (.. (:params this) (getProtocolVersionNum NetworkParameters.ProtocolVersion/PONG)) (:client-version this))
    )

    ;;;
     ; Returns true if the clientVersion field is >= FilteredBlock.MIN_PROTOCOL_VERSION.  If it is then Bloom filtering
     ; is available and the memory pool of the remote peer will be queried when the downloadData property is true.
     ;;
    #_public
    (ยง method #_"boolean" isBloomFilteringSupported []
        (<= (.. (:params this) (getProtocolVersionNum NetworkParameters.ProtocolVersion/BLOOM_FILTER)) (:client-version this))
    )
)

;;;
 ; <p>In Bitcoin the following format is often used to represent some type of key:</p>
 ;
 ; <pre>[one version byte] [data bytes] [4 checksum bytes]</pre>
 ;
 ; <p>and the result is then Base58 encoded.
 ; This format is used for addresses, and private keys exported using the dumpprivkey command.</p>
 ;;
#_public
(ยง class VersionedChecksummedBytes (ยง implements Serializable, Cloneable, Comparable #_"<VersionedChecksummedBytes>")
    #_protected
    (ยง field #_"int" :version)
    #_protected
    (ยง field #_"byte[]" :bytes)

    #_protected
    #_throws #_[ "AddressFormatException" ]
    (ยง constructor VersionedChecksummedBytes [#_"String" __encoded]
        (let [#_"byte[]" __versionAndDataBytes (Base58/decodeChecked __encoded)
              #_"byte" __versionByte (aget __versionAndDataBytes 0)]
            (ยง assoc this :version (& __versionByte 0xff))
            (ยง assoc this :bytes (byte-array (dec (.. __versionAndDataBytes (alength)))))
            (System/arraycopy __versionAndDataBytes, 1, (:bytes this), 0, (dec (.. __versionAndDataBytes (alength))))
            this
        )
    )

    #_protected
    (ยง constructor VersionedChecksummedBytes [#_"int" __version, #_"byte[]" __bytes]
        (Preconditions/checkArgument (< -1 __version 256))

        (ยง assoc this :version __version)
        (ยง assoc this :bytes __bytes)
        this
    )

    ;;;
     ; Returns the base-58 encoded String representation of this object,
     ; including version and checksum bytes.
     ;;
    #_public
    (ยง method #_"String" toBase58 []
        ;; A stringified buffer is: 1 byte version + data bytes + 4 bytes check code (a truncated hash).
        (let [#_"byte[]" __addressBytes (byte-array (+ 1 (.. (:bytes this) (alength)) 4))]
            (aset __addressBytes 0 (byte (:version this)))
            (System/arraycopy (:bytes this), 0, __addressBytes, 1, (.. (:bytes this) (alength)))
            (let [#_"byte[]" __checksum (Sha256Hash/hashTwice __addressBytes, 0, (inc (.. (:bytes this) (alength))))]
                (System/arraycopy __checksum, 0, __addressBytes, (inc (.. (:bytes this) (alength))), 4)
                (Base58/encode __addressBytes)
            )
        )
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (DeterministicKey/toBase58)
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (:version this), (Arrays/hashCode (:bytes this)))
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"VersionedChecksummedBytes" __other (cast VersionedChecksummedBytes __o)]
            (and (== (:version this) (:version __other)) (Arrays/equals (:bytes this), (:bytes __other)))
        )
    )

    ;;;
     ; {@inheritDoc}
     ;
     ; This implementation narrows the return type to <code>VersionedChecksummedBytes</code>
     ; and allows subclasses to throw <code>CloneNotSupportedException</code> even though it
     ; is never thrown by this implementation.
     ;;
    #_override
    #_public
    #_throws #_[ "CloneNotSupportedException" ]
    (ยง method #_"VersionedChecksummedBytes" clone []
        (cast VersionedChecksummedBytes (.. super (clone)))
    )

    ;;;
     ; {@inheritDoc}
     ;
     ; This implementation uses an optimized Google Guava method to compare <code>bytes</code>.
     ;;
    #_override
    #_public
    (ยง method #_"int" compareTo [#_"VersionedChecksummedBytes" __o]
        (let [#_"int" __result (Ints/compare (:version this), (:version __o))]
            (if (!= __result 0) __result (.. (UnsignedBytes/lexicographicalComparator) (compare (:bytes this), (:bytes __o))))
        )
    )

    ;;;
     ; Returns the "version" or "header" byte: the first byte of the data.  This is used to disambiguate what
     ; the contents apply to, for example, which network the key or address is valid on.
     ;
     ; @return a positive number between 0 and 255.
     ;;
    #_public
    (ยง method #_"int" getVersion []
        (:version this)
    )
)

;;;
 ; This exception is thrown by the Address class when you try and decode an address with a version code that isn't
 ; used by that network.  You shouldn't allow the user to proceed in this case as they are trying to send money across
 ; different chains, an operation that is guaranteed to destroy the money.
 ;;
#_public
(ยง class WrongNetworkException (ยง extends AddressFormatException)
    ;;; The version code that was provided in the address. ;;
    #_public
    (ยง field #_"int" :ver-code)
    ;;; The list of acceptable versions that were expected given the addresses network parameters. ;;
    #_public
    (ยง field #_"int[]" :acceptable-versions)

    #_public
    (ยง constructor WrongNetworkException [#_"int" __verCode, #_"int[]" __acceptableVersions]
        (ยง super (str "Version code of address did not match acceptable versions for network: " __verCode " not in " (Arrays/toString __acceptableVersions)))

        (ยง assoc this :ver-code __verCode)
        (ยง assoc this :acceptable-versions __acceptableVersions)
        this
    )
)

#_(ns org.bitcoinj.core.listeners #_"AbstractPeerDataEventListener"
    (:import [java.util *])
   (:require [org.bitcoinj.core *]))

#_(ns org.bitcoinj.core.listeners #_"BlockChainListener")

#_(ns org.bitcoinj.core.listeners #_"BlocksDownloadedEventListener"
   (:require [org.bitcoinj.core *]))

#_(ns org.bitcoinj.core.listeners #_"ChainDownloadStartedEventListener"
   (:require [org.bitcoinj.core *]))

#_(ns org.bitcoinj.core.listeners #_"DownloadProgressTracker"
    (:import [java.util Date Locale]
             [java.util.concurrent ExecutionException])
    (:import [com.google.common.util.concurrent ListenableFuture SettableFuture]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core Block FilteredBlock Peer Utils]))

#_(ns org.bitcoinj.core.listeners #_"GetDataEventListener"
    (:import [java.util *])
   (:require [org.bitcoinj.core *]))

#_(ns org.bitcoinj.core.listeners #_"NewBestBlockListener"
   (:require [org.bitcoinj.core StoredBlock VerificationException]))

#_(ns org.bitcoinj.core.listeners #_"OnTransactionBroadcastListener"
   (:require [org.bitcoinj.core *]))

#_(ns org.bitcoinj.core.listeners #_"PeerConnectedEventListener"
   (:require [org.bitcoinj.core Peer]))

#_(ns org.bitcoinj.core.listeners #_"PeerDataEventListener"
   (:require [org.bitcoinj.core *]))

#_(ns org.bitcoinj.core.listeners #_"PeerDisconnectedEventListener"
   (:require [org.bitcoinj.core Peer]))

#_(ns org.bitcoinj.core.listeners #_"PeerDiscoveredEventListener"
    (:import [java.util Set])
   (:require [org.bitcoinj.core Peer PeerAddress]))

#_(ns org.bitcoinj.core.listeners #_"PreMessageReceivedEventListener"
   (:require [org.bitcoinj.core *]))

#_(ns org.bitcoinj.core.listeners #_"ReorganizeListener"
    (:import [java.util List])
   (:require [org.bitcoinj.core StoredBlock VerificationException]))

#_(ns org.bitcoinj.core.listeners #_"TransactionConfidenceEventListener"
   (:require [org.bitcoinj.core Transaction]
             [org.bitcoinj.wallet Wallet]))

#_(ns org.bitcoinj.core.listeners #_"TransactionReceivedInBlockListener"
   (:require [org.bitcoinj.core BlockChain Sha256Hash StoredBlock Transaction VerificationException]))

;;;
 ; Deprecated: implement the more specific event listener interfaces instead to fill out only what you need.
 ;;
#_deprecated
#_public
#_abstract
(ยง class AbstractPeerDataEventListener (ยง implements PeerDataEventListener)
    #_override
    #_public
    (ยง method #_"void" onBlocksDownloaded [#_"Peer" __peer, #_"Block" __block, #_nilable #_"FilteredBlock" __filteredBlock, #_"int" __blocksLeft]
        nil
    )

    #_override
    #_public
    (ยง method #_"void" onChainDownloadStarted [#_"Peer" __peer, #_"int" __blocksLeft]
        nil
    )

    #_override
    #_public
    (ยง method #_"Message" onPreMessageReceived [#_"Peer" __peer, #_"Message" __m]
        ;; Just pass the message right through for further processing.
        __m
    )

    #_override
    #_public
    (ยง method #_"List<Message>" getData [#_"Peer" __peer, #_"GetDataMessage" __m]
        nil
    )
)

;;;
 ; Old interface for backwards compatibility. Implement the more specific interfaces instead.
 ;;
#_deprecated
#_public
(ยง interface BlockChainListener (ยง extends NewBestBlockListener, TransactionReceivedInBlockListener, ReorganizeListener))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(ยง interface BlocksDownloadedEventListener
    ;; TODO: Fix the Block/FilteredBlock type hierarchy so we can avoid the stupid typeless API here.
    ;;;
     ; <p>Called on a Peer thread when a block is received.</p>
     ;
     ; <p>The block may be a Block object that contains transactions, a Block object that is only a header when
     ; fast catchup is being used.  If set, filteredBlock can be used to retrieve the list of associated transactions.</p>
     ;
     ; @param peer The peer receiving the block.
     ; @param block The downloaded block.
     ; @param filteredBlock If non-null, the object that wraps the block header passed as the block param.
     ; @param blocksLeft The number of blocks left to download.
     ;;
    (ยง method #_"void" onBlocksDownloaded [#_"Peer" __peer, #_"Block" __block, #_nilable #_"FilteredBlock" __filteredBlock, #_"int" __blocksLeft])
)

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(ยง interface ChainDownloadStartedEventListener
    ;;;
     ; Called when a download is started with the initial number of blocks to be downloaded.
     ;
     ; @param peer The peer receiving the block.
     ; @param blocksLeft The number of blocks left to download.
     ;;
    (ยง method #_"void" onChainDownloadStarted [#_"Peer" __peer, #_"int" __blocksLeft])
)

;;;
 ; <p>An implementation of {@link AbstractPeerDataEventListener} that listens to chain download events and tracks
 ; progress as a percentage.  The default implementation prints progress to stdout, but you can subclass it and
 ; override the progress method to update a GUI instead.</p>
 ;;
#_public
(ยง class DownloadProgressTracker (ยง extends AbstractPeerDataEventListener)
    #_private
    #_static
    (ยง def- #_"Logger" DownloadProgressTracker/log (LoggerFactory/getLogger DownloadProgressTracker))

    #_private
    (ยง field- #_"int" :original-blocks-left -1)
    #_private
    (ยง field- #_"int" :last-percent 0)
    #_private
    (ยง field- #_"SettableFuture<Long>" :future (SettableFuture/create))
    #_private
    (ยง field- #_"boolean" :caught-up false)

    #_override
    #_public
    (ยง method #_"void" onChainDownloadStarted [#_"Peer" __peer, #_"int" __blocksLeft]
        (when (and (< 0 __blocksLeft) (== (:original-blocks-left this) -1))
            (.. this (startDownload __blocksLeft))
        )
        ;; Only mark this the first time, because this method can be called more than once during a chain download
        ;; if we switch peers during it.
        (if (== (:original-blocks-left this) -1)
            (ยง assoc this :original-blocks-left __blocksLeft)
            (.. DownloadProgressTracker/log (info "Chain download switched to {}", __peer))
        )
        (when (== __blocksLeft 0)
            (.. this (doneDownload))
            (.. (:future this) (set (.. __peer (getBestHeight))))
        )
        nil
    )

    #_override
    #_public
    (ยง method #_"void" onBlocksDownloaded [#_"Peer" __peer, #_"Block" __block, #_nilable #_"FilteredBlock" __filteredBlock, #_"int" __blocksLeft]
        (when (:caught-up this)
            (ยง return nil)
        )

        (when (== __blocksLeft 0)
            (ยง assoc this :caught-up true)
            (.. this (doneDownload))
            (.. (:future this) (set (.. __peer (getBestHeight))))
        )

        (when (or (< __blocksLeft 0) (<= (:original-blocks-left this) 0))
            (ยง return nil)
        )

        (let [#_"double" __pct (- 100.0 (* 100.0 (/ __blocksLeft (double (:original-blocks-left this)))))]
            (when (!= (int __pct) (:last-percent this))
                (.. this (progress __pct, __blocksLeft, (Date. (* (.. __block (getTimeSeconds)) 1000))))
                (ยง assoc this :last-percent (int __pct))
            )
            nil
        )
    )

    ;;;
     ; Called when download progress is made.
     ;
     ; @param pct The percentage of chain downloaded, estimated.
     ; @param date The date of the last block downloaded.
     ;;
    #_protected
    (ยง method #_"void" progress [#_"double" __pct, #_"int" __blocksSoFar, #_"Date" __date]
        (.. DownloadProgressTracker/log (info (String/format Locale/US, "Chain download %d%% done with %d blocks to go, block date %s", (int __pct), __blocksSoFar, (Utils/dateTimeFormat __date))))
        nil
    )

    ;;;
     ; Called when download is initiated.
     ;
     ; @param blocks The number of blocks to download, estimated.
     ;;
    #_protected
    (ยง method #_"void" startDownload [#_"int" __blocks]
        (.. DownloadProgressTracker/log (info (str "Downloading block chain of size " __blocks ". " (if (< 1000 __blocks) "This may take a while." ""))))
        nil
    )

    ;;;
     ; Called when we are done downloading the block chain.
     ;;
    #_protected
    (ยง method #_"void" doneDownload []
        nil
    )

    ;;;
     ; Wait for the chain to be downloaded.
     ;;
    #_public
    #_throws #_[ "InterruptedException" ]
    (ยง method #_"void" await []
        (try
            (.. (:future this) (get))
            (catch ExecutionException __e
                (throw (RuntimeException. __e))
            )
        )
        nil
    )

    ;;;
     ; Returns a listenable future that completes with the height of the best chain (as reported by the peer) once chain
     ; download seems to be finished.
     ;;
    #_public
    (ยง method #_"ListenableFuture<Long>" getFuture []
        (:future this)
    )
)

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(ยง interface GetDataEventListener
    ;;;
     ; <p>Called when a peer receives a getdata message, usually in response to an "inv" being broadcast.  Return as many
     ; items as possible which appear in the {@link GetDataMessage}, or null if you're not interested in responding.</p>
     ;
     ; <p>Note that this will never be called if registered with any executor other than
     ; {@link org.bitcoinj.utils.Threading#SAME_THREAD}</p>
     ;;
    #_nilable
    (ยง method #_"List<Message>" getData [#_"Peer" __peer, #_"GetDataMessage" __m])
)

;;;
 ; Listener interface for when a new block on the best chain is seen.
 ;;
#_public
(ยง interface NewBestBlockListener
    ;;;
     ; Called when a new block on the best chain is seen, after relevant transactions are extracted and sent to us via either
     ; {@link TransactionReceivedInBlockListener#receiveFromBlock(org.bitcoinj.core.Transaction, org.bitcoinj.core.StoredBlock, org.bitcoinj.core.BlockChain.NewBlockType, int relativityOffset)}
     ; or {@link TransactionReceivedInBlockListener#notifyTransactionIsInBlock(org.bitcoinj.core.Sha256Hash, org.bitcoinj.core.StoredBlock, org.bitcoinj.core.BlockChain.NewBlockType, int)}.
     ;
     ; If this block is causing a re-organise to a new chain, this method is NOT
     ; called even though the block may be the new best block: your reorganize
     ; implementation is expected to do whatever would normally be done do for a
     ; new best block in this case.
     ;;
    #_throws #_[ "VerificationException" ]
    (ยง method #_"void" notifyNewBestBlock [#_"StoredBlock" __block])
)

;;;
 ; Called when a new transaction is broadcast over the network.
 ;;
#_public
(ยง interface OnTransactionBroadcastListener
    ;;;
     ; Called when a new transaction is broadcast over the network.
     ;;
    (ยง method #_"void" onTransaction [#_"Peer" __peer, #_"Transaction" __t])
)

;;;
 ; <p>Implementors can listen to events indicating a new peer connecting.</p>
 ;;
#_public
(ยง interface PeerConnectedEventListener
    ;;;
     ; Called when a peer is connected.  If this listener is registered to a {@link Peer} instead of a {@link PeerGroup},
     ; peerCount will always be 1.
     ;
     ; @param peer
     ; @param peerCount The total number of connected peers.
     ;;
    (ยง method #_"void" onPeerConnected [#_"Peer" __peer, #_"int" __peerCount])
)

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are processed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(ยง interface PeerDataEventListener (ยง extends BlocksDownloadedEventListener, ChainDownloadStartedEventListener, GetDataEventListener, PreMessageReceivedEventListener))

;;;
 ; <p>Implementors can listen to events indicating a peer disconnecting.</p>
 ;;
#_public
(ยง interface PeerDisconnectedEventListener
    ;;;
     ; Called when a peer is disconnected.  Note that this won't be called if the listener is registered on
     ; a {@link PeerGroup} and the group is in the process of shutting down.  If this listener is registered to
     ; a {@link Peer} instead of a {@link PeerGroup}, peerCount will always be 0.  This handler can be called
     ; without a corresponding invocation of onPeerConnected if the initial connection is never successful.
     ;
     ; @param peer
     ; @param peerCount The total number of connected peers.
     ;;
    (ยง method #_"void" onPeerDisconnected [#_"Peer" __peer, #_"int" __peerCount])
)

;;;
 ; <p>Implementors can listen to events for peers being discovered.</p>
 ;;
#_public
(ยง interface PeerDiscoveredEventListener
    ;;;
     ; <p>Called when peers are discovered, this happens at startup of {@link PeerGroup}
     ; or if we run out of suitable {@link Peer}s to connect to.</p>
     ;
     ; @param peerAddresses The set of discovered {@link PeerAddress}es.
     ;;
    (ยง method #_"void" onPeersDiscovered [#_"Set<PeerAddress>" __peerAddresses])
)

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(ยง interface PreMessageReceivedEventListener
    ;;;
     ; <p>Called when a message is received by a peer, before the message is processed.  The returned message is
     ; processed instead.  Returning null will cause the message to be ignored by the Peer returning the same message
     ; object allows you to see the messages received but not change them.  The result from one event listeners
     ; callback is passed as "m" to the next, forming a chain.</p>
     ;
     ; <p>Note that this will never be called if registered with any executor other than
     ; {@link org.bitcoinj.utils.Threading#SAME_THREAD}.</p>
     ;;
    (ยง method #_"Message" onPreMessageReceived [#_"Peer" __peer, #_"Message" __m])
)

;;;
 ; Listener interface for when the best chain has changed.
 ;;
#_public
(ยง interface ReorganizeListener
    ;;;
     ; Called by the {@link org.bitcoinj.core.BlockChain} when the best chain (representing total work done)
     ; has changed.  In this case, we need to go through our transactions and find out if any have become invalid.
     ; It's possible for our balance to go down in this case: money we thought we had can suddenly vanish
     ; if the rest of the network agrees it should be so.
     ;
     ; The oldBlocks/newBlocks lists are ordered height-wise from top first to bottom last (i.e. newest blocks first).
     ;;
    #_throws #_[ "VerificationException" ]
    (ยง method #_"void" reorganize [#_"StoredBlock" __splitPoint, #_"List<StoredBlock>" __oldBlocks, #_"List<StoredBlock>" __newBlocks])
)

;;;
 ; <p>Implementors are called when confidence of a transaction changes.</p>
 ;;
#_public
(ยง interface TransactionConfidenceEventListener
    ;;;
     ; <p>Called when a transaction changes its confidence level.  You can also attach event listeners to
     ; the individual transactions, if you don't care about all of them.  Usually you would save the wallet to disk
     ; after receiving this callback unless you already set up autosaving.</p>
     ;
     ; <p>You should pay attention to this callback in case a transaction becomes <i>dead</i>, that is, a transaction
     ; you believed to be active (send or receive) becomes overridden by the network.  This can happen if</p>
     ;
     ; <ol>
     ;     <li>You are sharing keys between wallets and accidentally create/broadcast a double spend.</li>
     ;     <li>Somebody is attacking the network and reversing transactions, i.e. the user is a victim of fraud.</li>
     ;     <li>A bug: for example you create a transaction, broadcast it but fail to commit it.
     ;     The {@link Wallet} will then re-use the same outputs when creating the next spend.</li>
     ; </ol>
     ;
     ; <p>To find if the transaction is dead, you can use <tt>tx.getConfidence().getConfidenceType() ==
     ; TransactionConfidence.ConfidenceType.DEAD</tt>.  If it is, you should notify the user in some way
     ; so they know the thing they bought may not arrive/the thing they sold should not be dispatched.</p>
     ;
     ; <p>Note that this callback will be invoked for every transaction in the wallet, for every new block that is
     ; received (because the depth has changed).  <b>If you want to update a UI view from the contents of the wallet
     ; it is more efficient to use onWalletChanged instead.</b></p>
     ;;
    (ยง method #_"void" onTransactionConfidenceChanged [#_"Wallet" __wallet, #_"Transaction" __tx])
)

;;;
 ; Listener interface for when we receive a new block that contains a relevant transaction.
 ;;
#_public
(ยง interface TransactionReceivedInBlockListener
    ;;;
     ; <p>Called by the {@link BlockChain} when we receive a new block that contains a relevant transaction.</p>
     ;
     ; <p>A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.</p>
     ;
     ; <p>The relativityOffset parameter is an arbitrary number used to establish an ordering between transactions
     ; within the same block.  In the case where full blocks are being downloaded, it is simply the index of the
     ; transaction within that block.  When Bloom filtering is in use, we don't find out the exact offset into a block
     ; that a transaction occurred at, so the relativity count is not reflective of anything in an absolute sense but
     ; rather exists only to order the transaction relative to the others.</p>
     ;;
    #_throws #_[ "VerificationException" ]
    (ยง method #_"void" receiveFromBlock [#_"Transaction" __tx, #_"StoredBlock" __block, #_"BlockChain.NewBlockType" __blockType, #_"int" __relativityOffset])

    ;;;
     ; <p>Called by the {@link BlockChain} when we receive a new {@link FilteredBlock} that contains the given
     ; transaction hash in its merkle tree.</p>
     ;
     ; <p>A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.</p>
     ;
     ; <p>The relativityOffset parameter in this case is an arbitrary (meaningless) number, that is useful only when
     ; compared to the relativity count of another transaction received inside the same block.  It is used to establish
     ; an ordering of transactions relative to one another.</p>
     ;
     ; <p>This method should return false if the given tx hash isn't known about, e.g. because the the transaction was
     ; a Bloom false positive.  If it was known about and stored, it should return true.  The caller may need to know
     ; this to calculate the effective FP rate.</p>
     ;
     ; @return whether the transaction is known about i.e. was considered relevant previously.
     ;;
    #_throws #_[ "VerificationException" ]
    (ยง method #_"boolean" notifyTransactionIsInBlock [#_"Sha256Hash" __txHash, #_"StoredBlock" __block, #_"BlockChain.NewBlockType" __blockType, #_"int" __relativityOffset])
)

#_(ns org.bitcoinj.crypto #_"ChildNumber"
    (:import [java.util Locale])
    (:import [com.google.common.primitives Ints]))

#_(ns org.bitcoinj.crypto #_"DeterministicHierarchy"
    (:import [java.util List Locale Map])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect ImmutableList Maps]))

#_(ns org.bitcoinj.crypto #_"DeterministicKey"
    (:import [java.math BigInteger]
             [java.nio ByteBuffer]
             [java.util Arrays Comparator])
    (:import [com.google.common.base MoreObjects Objects Preconditions]
             [com.google.common.collect ImmutableList]
             [org.spongycastle.crypto.params KeyParameter]
             [org.spongycastle.math.ec ECPoint])
   (:require [org.bitcoinj.core *]))

#_(ns org.bitcoinj.crypto #_"EncryptableItem"
   (:require [org.bitcoinj.wallet Protos]))

#_(ns org.bitcoinj.crypto #_"EncryptedData"
    (:import [java.util Arrays])
    (:import [com.google.common.base Objects]))

#_(ns org.bitcoinj.crypto #_"HDDerivationException")

#_(ns org.bitcoinj.crypto #_"HDKeyDerivation"
    (:import [java.math *]
             [java.nio *]
             [java.security *]
             [java.util *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect *]
             [org.spongycastle.math.ec *])
   (:require [org.bitcoinj.core *]))

#_(ns org.bitcoinj.crypto #_"HDUtils"
    (:import [java.nio ByteBuffer]
             [java.util ArrayList Arrays Collections List])
    (:import [com.google.common.base Joiner]
             [com.google.common.collect ImmutableList Iterables]
             [org.spongycastle.crypto.digests SHA512Digest]
             [org.spongycastle.crypto.macs HMac]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core ECKey]))

#_(ns org.bitcoinj.crypto #_"KeyCrypter"
    (:import [java.io Serializable])
    (:import [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.wallet Protos]))

#_(ns org.bitcoinj.crypto #_"KeyCrypterException")

#_(ns org.bitcoinj.crypto #_"KeyCrypterScrypt"
    (:import [java.security SecureRandom]
             [java.util Arrays])
    (:import [com.google.common.base Objects Preconditions Stopwatch]
             [com.google.protobuf ByteString]
             [com.lambdaworks.crypto SCrypt]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto BufferedBlockCipher]
             [org.spongycastle.crypto.engines AESFastEngine]
             [org.spongycastle.crypto.modes CBCBlockCipher]
             [org.spongycastle.crypto.paddings PaddedBufferedBlockCipher]
             [org.spongycastle.crypto.params KeyParameter ParametersWithIV])
   (:require [org.bitcoinj.core Utils]
             [org.bitcoinj.wallet Protos]))

#_(ns org.bitcoinj.crypto #_"LazyECPoint"
    (:import [java.math BigInteger]
             [java.util Arrays])
    (:import [com.google.common.base Preconditions]
             [org.spongycastle.math.ec ECCurve ECFieldElement ECPoint]))

#_(ns org.bitcoinj.crypto #_"MnemonicCode"
    (:import [java.io BufferedReader FileNotFoundException IOException InputStream InputStreamReader]
             [java.security MessageDigest]
             [java.util ArrayList Collections List])
    (:import [com.google.common.base Stopwatch]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core Sha256Hash Utils]))

#_(ns org.bitcoinj.crypto #_"MnemonicException")

#_(ns org.bitcoinj.crypto #_"PBKDF2SHA512"
    (:import [java.io ByteArrayOutputStream]
             [java.nio ByteBuffer ByteOrder]
             [javax.crypto Mac]
             [javax.crypto.spec SecretKeySpec]))

#_(ns org.bitcoinj.crypto #_"TransactionSignature"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.math BigInteger])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.core ECKey Transaction VerificationException]))

;;;
 ; <p>This is just a wrapper for the i (child number) as per BIP 32 with a boolean getter for the most significant bit
 ; and a getter for the actual 0-based child number.  A {@link java.util.List} of these forms a <i>path</i> through a
 ; {@link DeterministicHierarchy}.  This class is immutable.
 ;;
#_public
(ยง class ChildNumber (ยง implements Comparable #_"<ChildNumber>")
    ;;;
     ; The bit that's set in the child number to indicate whether this key is "hardened".  Given a hardened key, it is
     ; not possible to derive a child public key if you know only the hardened public key.  With a non-hardened key this
     ; is possible, so you can derive trees of public keys given only a public parent, but the downside is that it's
     ; possible to leak private keys if you disclose a parent public key and a child private key (elliptic curve maths
     ; allows you to work upwards).
     ;;
    #_public
    #_static
    (ยง def #_"int" ChildNumber/HARDENED_BIT 0x80000000)

    #_public
    #_static
    (ยง def #_"ChildNumber" ChildNumber/ZERO (ChildNumber. 0))
    #_public
    #_static
    (ยง def #_"ChildNumber" ChildNumber/ONE (ChildNumber. 1))
    #_public
    #_static
    (ยง def #_"ChildNumber" ChildNumber/ZERO_HARDENED (ChildNumber. 0, true))

    ;;; Integer i as per BIP 32 spec, including the MSB denoting derivation type (0 = public, 1 = private). ;;
    #_private
    (ยง field- #_"int" :i)

    #_public
    (ยง constructor ChildNumber [#_"int" __childNumber, #_"boolean" __isHardened]
        (when (ChildNumber/hasHardenedBit __childNumber)
            (throw (IllegalArgumentException. (str "Most significant bit is reserved and shouldn't be set: " __childNumber)))
        )

        (ยง assoc this :i (if __isHardened (| __childNumber ChildNumber/HARDENED_BIT) __childNumber))
        this
    )

    #_public
    (ยง constructor ChildNumber [#_"int" __i]
        (ยง assoc this :i __i)
        this
    )

    ;;; Returns the uint32 encoded form of the path element, including the most significant bit. ;;
    #_public
    (ยง method #_"int" getI []
        (:i this)
    )

    ;;; Returns the uint32 encoded form of the path element, including the most significant bit. ;;
    #_public
    (ยง method #_"int" i []
        (:i this)
    )

    #_public
    (ยง method #_"boolean" isHardened []
        (ChildNumber/hasHardenedBit (:i this))
    )

    #_private
    #_static
    (ยง defn- #_"boolean" ChildNumber/hasHardenedBit [#_"int" __a]
        (!= (& __a ChildNumber/HARDENED_BIT) 0)
    )

    ;;; Returns the child number without the hardening bit set (i.e. index in that part of the tree). ;;
    #_public
    (ยง method #_"int" num []
        (& (:i this) (bit-not ChildNumber/HARDENED_BIT))
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (String/format Locale/US, "%d%s", (.. this (num)), (if (.. this (isHardened)) "H" ""))
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (== (:i this) (:i (cast ChildNumber __o)))
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (:i this)
    )

    #_override
    #_public
    (ยง method #_"int" compareTo [#_"ChildNumber" __other]
        ;; Note that in this implementation compareTo() is not consistent with equals().
        (Ints/compare (.. this (num)), (.. __other (num)))
    )
)

;; TODO: This whole API feels a bit object heavy.  Do we really need ChildNumber and so many maps, etc?
;; TODO: Should we be representing this using an actual tree arrangement in memory instead of a bunch of hashmaps?

;;;
 ; <p>A DeterministicHierarchy calculates and keeps a whole tree (hierarchy) of keys originating from a single
 ; root key.  This implements part of the BIP 32 specification.  A deterministic key tree is useful because
 ; Bitcoin's privacy system require new keys to be created for each transaction, but managing all these
 ; keys quickly becomes unwieldy.  In particular it becomes hard to back up and distribute them.  By having
 ; a way to derive random-looking but deterministic keys we can make wallet backup simpler and gain the
 ; ability to hand out {@link DeterministicKey}s to other people who can then create new addresses
 ; on the fly, without having to contact us.</p>
 ;
 ; <p>The hierarchy is started from a single root key, and a location in the tree is given by a path which
 ; is a list of {@link ChildNumber}s.</p>
 ;;
#_public
(ยง class DeterministicHierarchy
    #_private
    (ยง field- #_"Map<ImmutableList<ChildNumber>, DeterministicKey>" :keys (Maps/newHashMap))
    #_private
    (ยง field- #_"ImmutableList<ChildNumber>" :root-path)
    ;; Keep track of how many child keys each node has.  This is kind of weak.
    #_private
    (ยง field- #_"Map<ImmutableList<ChildNumber>, ChildNumber>" :last-child-numbers (Maps/newHashMap))

    #_public
    #_static
    (ยง def #_"int" DeterministicHierarchy/BIP32_STANDARDISATION_TIME_SECS 1369267200)

    ;;;
     ; Constructs a new hierarchy rooted at the given key.  Note that this does not have to be the top of the tree.
     ; You can construct a DeterministicHierarchy for a subtree of a larger tree that you may not own.
     ;;
    #_public
    (ยง constructor DeterministicHierarchy [#_"DeterministicKey" __rootKey]
        (.. this (putKey __rootKey))
        (ยง assoc this :root-path (.. __rootKey (getPath)))
        this
    )

    ;;;
     ; Inserts a key into the heirarchy.  Used during deserialization: you normally don't need this.  Keys must be
     ; inserted in order.
     ;;
    #_public
    (ยง method #_"void" putKey [#_"DeterministicKey" __key]
        (let [#_"ImmutableList<ChildNumber>" __path (.. __key (getPath))]
            ;; Update our tracking of what the next child in each branch of the tree should be.  Just assume that keys
            ;; are inserted in order here.
            (let [#_"DeterministicKey" __parent (.. __key (getParent))]
                (when (some? __parent)
                    (.. (:last-child-numbers this) (put (.. __parent (getPath)), (.. __key (getChildNumber))))
                )
                (.. (:keys this) (put __path, __key))
                nil
            )
        )
    )

    ;;;
     ; Returns a key for the given path, optionally creating it.
     ;
     ; @param path The path to the key.
     ; @param relativePath Whether the path is relative to the root path.
     ; @param create Whether the key corresponding to path should be created (with any necessary ancestors) if it doesn't exist already.
     ; @return next newly created key using the child derivation function.
     ; @throws IllegalArgumentException if create is false and the path was not found.
     ;;
    #_public
    (ยง method #_"DeterministicKey" get [#_"List<ChildNumber>" __path, #_"boolean" __relativePath, #_"boolean" __create]
        (let [#_"ImmutableList<ChildNumber>" __absolutePath (if __relativePath (.. (ImmutableList/builder #_"ImmutableList<ChildNumber>") (addAll (:root-path this)) (addAll __path) (build)) (ImmutableList/copyOf __path))]
            (when (not (.. (:keys this) (containsKey __absolutePath)))
                (when (not __create)
                    (throw (IllegalArgumentException. (String/format Locale/US, "No key found for %s path %s.", (if __relativePath "relative" "absolute"), (HDUtils/formatPath __path))))
                )
                (Preconditions/checkArgument (< 0 (.. __absolutePath (size))), "Can't derive the master key: nothing to derive from.")
                (let [#_"DeterministicKey" __parent (.. this (get (.. __absolutePath (subList 0, (dec (.. __absolutePath (size))))), false, true))]
                    (.. this (putKey (HDKeyDerivation/deriveChildKey __parent, (.. __absolutePath (get (dec (.. __absolutePath (size))))))))
                )
            )
            (.. (:keys this) (get __absolutePath))
        )
    )

    ;;;
     ; Extends the tree by calculating the next key that hangs off the given parent path.  For example, if you pass
     ; a path of 1/2 here and there are already keys 1/2/1 and 1/2/2 then it will derive 1/2/3.
     ;
     ; @param parentPath The path to the parent.
     ; @param relative Whether the path is relative to the root path.
     ; @param createParent Whether the parent corresponding to path should be created (with any necessary ancestors) if it doesn't exist already.
     ; @param privateDerivation Whether to use private or public derivation.
     ; @return next newly created key using the child derivation funtcion.
     ; @throws IllegalArgumentException if the parent doesn't exist and createParent is false.
     ;;
    #_public
    (ยง method #_"DeterministicKey" deriveNextChild [#_"ImmutableList<ChildNumber>" __parentPath, #_"boolean" __relative, #_"boolean" __createParent, #_"boolean" __privateDerivation]
        (let [#_"DeterministicKey" __parent (.. this (get __parentPath, __relative, __createParent))]
            (loop-when-recur [#_"int" __i 0] (< __i HDKeyDerivation/MAX_CHILD_DERIVATION_ATTEMPTS) [(inc __i)]
                (try
                    (let [#_"ChildNumber" __createChildNumber (.. this (getNextChildNumberToDerive (.. __parent (getPath)), __privateDerivation))]
                        (ยง return (.. this (deriveChild __parent, __createChildNumber)))
                    )
                    (catch HDDerivationException _
                    )
                )
            )
            (throw (HDDerivationException. "Maximum number of child derivation attempts reached, this is probably an indication of a bug."))
        )
    )

    #_private
    (ยง method- #_"ChildNumber" getNextChildNumberToDerive [#_"ImmutableList<ChildNumber>" __path, #_"boolean" __privateDerivation]
        (let [#_"ChildNumber" __lastChildNumber (.. (:last-child-numbers this) (get __path))
              #_"ChildNumber" __nextChildNumber (ChildNumber. (if (some? __lastChildNumber) (inc (.. __lastChildNumber (num))) 0), __privateDerivation)]
            (.. (:last-child-numbers this) (put __path, __nextChildNumber))
            __nextChildNumber
        )
    )

    #_public
    (ยง method #_"int" getNumChildren [#_"ImmutableList<ChildNumber>" __path]
        (let [#_"ChildNumber" __cn (.. (:last-child-numbers this) (get __path))]
            ;; Children start with zero based childnumbers.
            (if (some? __cn) (+ 1 (.. __cn (num))) 0)
        )
    )

    ;;;
     ; Extends the tree by calculating the requested child for the given path.  For example, to get the key at position
     ; 1/2/3 you would pass 1/2 as the parent path and 3 as the child number.
     ;
     ; @param parentPath The path to the parent.
     ; @param relative Whether the path is relative to the root path.
     ; @param createParent Whether the parent corresponding to path should be created (with any necessary ancestors) if it doesn't exist already.
     ; @return the requested key.
     ; @throws IllegalArgumentException if the parent doesn't exist and createParent is false.
     ;;
    #_public
    (ยง method #_"DeterministicKey" deriveChild [#_"List<ChildNumber>" __parentPath, #_"boolean" __relative, #_"boolean" __createParent, #_"ChildNumber" __createChildNumber]
        (.. this (deriveChild (.. this (get __parentPath, __relative, __createParent)), __createChildNumber))
    )

    #_private
    (ยง method- #_"DeterministicKey" deriveChild [#_"DeterministicKey" __parent, #_"ChildNumber" __createChildNumber]
        (let [#_"DeterministicKey" __childKey (HDKeyDerivation/deriveChildKey __parent, __createChildNumber)]
            (.. this (putKey __childKey))
            __childKey
        )
    )

    ;;;
     ; Returns the root key that the {@link DeterministicHierarchy} was created with.
     ;;
    #_public
    (ยง method #_"DeterministicKey" getRootKey []
        (.. this (get (:root-path this), false, false))
    )
)

;;;
 ; A deterministic key is a node in a {@link DeterministicHierarchy}.  As per
 ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">the BIP 32 specification</a> it is a pair
 ; (key, chaincode).  If you know its path in the tree and its chain code you can derive more keys from this.
 ; To obtain one of these, you can call {@link HDKeyDerivation#createMasterPrivateKey(byte[])}.
 ;;
#_public
(ยง class DeterministicKey (ยง extends ECKey)
    ;;; Sorts deterministic keys in the order of their child number.  That's <i>usually</i> the order used to derive them. ;;
    #_public
    #_static
    (ยง def #_"Comparator<ECKey>" DeterministicKey/CHILDNUM_ORDER (Comparator. #_"<ECKey>"
        (ยง anon
            #_override
            #_public
            (ยง method #_"int" compare [#_"ECKey" __k1, #_"ECKey" __k2]
                (let [#_"ChildNumber" __cn1 (.. (cast DeterministicKey __k1) (getChildNumber))
                      #_"ChildNumber" __cn2 (.. (cast DeterministicKey __k2) (getChildNumber))]
                    (.. __cn1 (compareTo __cn2))
                )
            )
        )))

    #_private
    (ยง field- #_"DeterministicKey" :parent)
    #_private
    (ยง field- #_"ImmutableList<ChildNumber>" :child-number-path)
    #_private
    (ยง field- #_"int" :depth)
    #_private
    (ยง field- #_"int" :parent-fingerprint) ;; 0 if this key is root node of key hierarchy

    ;;; 32 bytes ;;
    #_private
    (ยง field- #_"byte[]" :chain-code)

    ;;; Constructs a key from its components.  This is not normally something you should use. ;;
    #_public
    (ยง constructor DeterministicKey [#_"ImmutableList<ChildNumber>" __childNumberPath, #_"byte[]" __chainCode, #_"LazyECPoint" __publicAsPoint, #_nilable #_"BigInteger" __priv, #_nilable #_"DeterministicKey" __parent]
        (ยง super __priv, (ECKey/compressPoint (Preconditions/checkNotNull __publicAsPoint)))

        (Preconditions/checkArgument (== (.. __chainCode (alength)) 32))

        (ยง assoc this :parent __parent)
        (ยง assoc this :child-number-path (Preconditions/checkNotNull __childNumberPath))
        (ยง assoc this :chain-code (Arrays/copyOf __chainCode, (.. __chainCode (alength))))
        (ยง assoc this :depth (if (some? __parent) (inc (:depth __parent)) 0))
        (ยง assoc this :parent-fingerprint (if (some? __parent) (.. __parent (getFingerprint)) 0))
        this
    )

    #_public
    (ยง constructor DeterministicKey [#_"ImmutableList<ChildNumber>" __childNumberPath, #_"byte[]" __chainCode, #_"ECPoint" __publicAsPoint, #_nilable #_"BigInteger" __priv, #_nilable #_"DeterministicKey" __parent]
        (ยง this __childNumberPath, __chainCode, (LazyECPoint. __publicAsPoint), __priv, __parent)
        this
    )

    ;;; Constructs a key from its components.  This is not normally something you should use. ;;
    #_public
    (ยง constructor DeterministicKey [#_"ImmutableList<ChildNumber>" __childNumberPath, #_"byte[]" __chainCode, #_"BigInteger" __priv, #_nilable #_"DeterministicKey" __parent]
        (ยง super __priv, (ECKey/compressPoint (ECKey/publicPointFromPrivate __priv)))

        (Preconditions/checkArgument (== (.. __chainCode (alength)) 32))

        (ยง assoc this :parent __parent)
        (ยง assoc this :child-number-path (Preconditions/checkNotNull __childNumberPath))
        (ยง assoc this :chain-code (Arrays/copyOf __chainCode, (.. __chainCode (alength))))
        (ยง assoc this :depth (if (some? __parent) (inc (:depth __parent)) 0))
        (ยง assoc this :parent-fingerprint (if (some? __parent) (.. __parent (getFingerprint)) 0))
        this
    )

    ;;; Constructs a key from its components.  This is not normally something you should use. ;;
    #_public
    (ยง constructor DeterministicKey [#_"ImmutableList<ChildNumber>" __childNumberPath, #_"byte[]" __chainCode, #_"KeyCrypter" __crypter, #_"LazyECPoint" __pub, #_"EncryptedData" __priv, #_nilable #_"DeterministicKey" __parent]
        (ยง this __childNumberPath, __chainCode, __pub, nil, __parent)
        (ยง assoc this :encrypted-private-key (Preconditions/checkNotNull __priv))
        (ยง assoc this :key-crypter (Preconditions/checkNotNull __crypter))
        this
    )

    ;;;
     ; Return the fingerprint of this key's parent as an int value, or zero if this key is the
     ; root node of the key hierarchy.  Raise an exception if the arguments are inconsistent.
     ; This method exists to avoid code repetition in the constructors.
     ;;
    #_private
    #_throws #_[ "IllegalArgumentException" ]
    (ยง method- #_"int" ascertainParentFingerprint [#_"DeterministicKey" __parentKey, #_"int" __parentFingerprint]
        (when (!= __parentFingerprint 0)
            (when (some? (:parent this))
                (Preconditions/checkArgument (== (.. (:parent this) (getFingerprint)) __parentFingerprint), "parent fingerprint mismatch", (Integer/toHexString (.. (:parent this) (getFingerprint))), (Integer/toHexString __parentFingerprint))
            )
            (ยง return __parentFingerprint)
        )

        0
    )

    ;;;
     ; Constructs a key from its components, including its public key data and possibly-redundant
     ; information about its parent key.  Invoked when deserializing, but otherwise not something
     ; that you normally should use.
     ;;
    #_public
    (ยง constructor DeterministicKey [#_"ImmutableList<ChildNumber>" __childNumberPath, #_"byte[]" __chainCode, #_"LazyECPoint" __publicAsPoint, #_nilable #_"DeterministicKey" __parent, #_"int" __depth, #_"int" __parentFingerprint]
        (ยง super nil, (ECKey/compressPoint (Preconditions/checkNotNull __publicAsPoint)))

        (Preconditions/checkArgument (== (.. __chainCode (alength)) 32))

        (ยง assoc this :parent __parent)
        (ยง assoc this :child-number-path (Preconditions/checkNotNull __childNumberPath))
        (ยง assoc this :chain-code (Arrays/copyOf __chainCode, (.. __chainCode (alength))))
        (ยง assoc this :depth __depth)
        (ยง assoc this :parent-fingerprint (.. this (ascertainParentFingerprint __parent, __parentFingerprint)))
        this
    )

    ;;;
     ; Constructs a key from its components, including its private key data and possibly-redundant
     ; information about its parent key.  Invoked when deserializing, but otherwise not something that
     ; you normally should use.
     ;;
    #_public
    (ยง constructor DeterministicKey [#_"ImmutableList<ChildNumber>" __childNumberPath, #_"byte[]" __chainCode, #_"BigInteger" __priv, #_nilable #_"DeterministicKey" __parent, #_"int" __depth, #_"int" __parentFingerprint]
        (ยง super __priv, (ECKey/compressPoint (ECKey/publicPointFromPrivate __priv)))

        (Preconditions/checkArgument (== (.. __chainCode (alength)) 32))

        (ยง assoc this :parent __parent)
        (ยง assoc this :child-number-path (Preconditions/checkNotNull __childNumberPath))
        (ยง assoc this :chain-code (Arrays/copyOf __chainCode, (.. __chainCode (alength))))
        (ยง assoc this :depth __depth)
        (ยง assoc this :parent-fingerprint (.. this (ascertainParentFingerprint __parent, __parentFingerprint)))
        this
    )

    ;;; Clones the key. ;;
    #_public
    (ยง constructor DeterministicKey [#_"DeterministicKey" __keyToClone, #_"DeterministicKey" __newParent]
        (ยง super (:priv __keyToClone), (.. (:pub __keyToClone) (get)))

        (ยง assoc this :parent __newParent)
        (ยง assoc this :child-number-path (:child-number-path __keyToClone))
        (ยง assoc this :chain-code (:chain-code __keyToClone))
        (ยง assoc this :encrypted-private-key (:encrypted-private-key __keyToClone))
        (ยง assoc this :depth (.. (:child-number-path this) (size)))
        (ยง assoc this :parent-fingerprint (.. (:parent this) (getFingerprint)))
        this
    )

    ;;;
     ; Returns the path through some {@link DeterministicHierarchy} which reaches this keys position in the tree.
     ; A path can be written as 1/2/1 which means the first child of the root, the second child of that node, then
     ; the first child of that node.
     ;;
    #_public
    (ยง method #_"ImmutableList<ChildNumber>" getPath []
        (:child-number-path this)
    )

    ;;;
     ; Returns the path of this key as a human readable string starting with M to indicate the master key.
     ;;
    #_public
    (ยง method #_"String" getPathAsString []
        (HDUtils/formatPath (.. this (getPath)))
    )

    ;;;
     ; Return this key's depth in the hierarchy, where the root node is at depth zero.
     ; This may be different than the number of segments in the path if this key was
     ; deserialized without access to its parent.
     ;;
    #_public
    (ยง method #_"int" getDepth []
        (:depth this)
    )

    ;;; Returns the last element of the path returned by {@link DeterministicKey#getPath()}. ;;
    #_public
    (ยง method #_"ChildNumber" getChildNumber []
        (if (== (.. (:child-number-path this) (size)) 0) ChildNumber/ZERO (.. (:child-number-path this) (get (dec (.. (:child-number-path this) (size))))))
    )

    ;;;
     ; Returns the chain code associated with this key.  See the specification to learn more about chain codes.
     ;;
    #_public
    (ยง method #_"byte[]" getChainCode []
        (:chain-code this)
    )

    ;;;
     ; Returns RIPE-MD160(SHA256(pub key bytes)).
     ;;
    #_public
    (ยง method #_"byte[]" getIdentifier []
        (Utils/sha256hash160 (.. this (getPubKey)))
    )

    ;;; Returns the first 32 bits of the result of {@link #getIdentifier()}. ;;
    #_public
    (ยง method #_"int" getFingerprint []
        ;; TODO: Why is this different than armory's fingerprint?  BIP 32: "The first 32 bits of the identifier are called the fingerprint."
        (.. (ByteBuffer/wrap (Arrays/copyOfRange (.. this (getIdentifier)), 0, 4)) (getInt))
    )

    #_nilable
    #_public
    (ยง method #_"DeterministicKey" getParent []
        (:parent this)
    )

    ;;;
     ; Return the fingerprint of the key from which this key was derived, if this is
     ; a child key, or else an array of four zero-value bytes.
     ;;
    #_public
    (ยง method #_"int" getParentFingerprint []
        (:parent-fingerprint this)
    )

    ;;;
     ; Returns private key bytes, padded with zeros to 33 bytes.
     ; @throws java.lang.IllegalStateException if the private key bytes are missing.
     ;;
    #_public
    (ยง method #_"byte[]" getPrivKeyBytes33 []
        (let [#_"byte[]" __bytes33 (byte-array 33)
              #_"byte[]" __priv (.. this (getPrivKeyBytes))]
            (System/arraycopy __priv, 0, __bytes33, (- 33 (.. __priv (alength))), (.. __priv (alength)))
            __bytes33
        )
    )

    ;;;
     ; Returns the same key with the private bytes removed.  May return the same instance.  The purpose of this is to
     ; save memory: the private key can always be very efficiently rederived from a parent that a private key, so storing
     ; all the private keys in RAM is a poor tradeoff especially on constrained devices.  This means that the returned
     ; key may still be usable for signing and so on, so don't expect it to be a true pubkey-only object!  If you want
     ; that then you should follow this call with a call to {@link #dropParent()}.
     ;;
    #_public
    (ยง method #_"DeterministicKey" dropPrivateBytes []
        (if (.. this (isPubKeyOnly)) this (DeterministicKey. (.. this (getPath)), (.. this (getChainCode)), (:pub this), nil, (:parent this)))
    )

    ;;;
     ; <p>Returns the same key with the parent pointer removed (it still knows its own path and the parent fingerprint).</p>
     ;
     ; <p>If this key doesn't have private key bytes stored/cached itself, but could rederive them from the parent, then
     ; the new key returned by this method won't be able to do that.  Thus, using dropPrivateBytes().dropParent() on a
     ; regular DeterministicKey will yield a new DeterministicKey that cannot sign or do other things involving the
     ; private key at all.</p>
     ;;
    #_public
    (ยง method #_"DeterministicKey" dropParent []
        (let [#_"DeterministicKey" __key (DeterministicKey. (.. this (getPath)), (.. this (getChainCode)), (:pub this), (:priv this), nil)]
            (ยง assoc __key :parent-fingerprint (:parent-fingerprint this))
            __key
        )
    )

    #_static
    (ยง defn #_"byte[]" DeterministicKey/addChecksum [#_"byte[]" __input]
        (let [#_"int" __inputLength (.. __input (alength))
              #_"byte[]" __checksummed (byte-array (+ __inputLength 4))]
            (System/arraycopy __input, 0, __checksummed, 0, __inputLength)
            (let [#_"byte[]" __checksum (Sha256Hash/hashTwice __input)]
                (System/arraycopy __checksum, 0, __checksummed, __inputLength, 4)
                __checksummed
            )
        )
    )

    #_override
    #_public
    #_throws #_[ "KeyCrypterException" ]
    (ยง method #_"DeterministicKey" encrypt [#_"KeyCrypter" __keyCrypter, #_"KeyParameter" __aesKey]
        (throw (UnsupportedOperationException. "Must supply a new parent for encryption"))
    )

    #_public
    #_throws #_[ "KeyCrypterException" ]
    (ยง method #_"DeterministicKey" encrypt [#_"KeyCrypter" __keyCrypter, #_"KeyParameter" __aesKey, #_nilable #_"DeterministicKey" __newParent]
        ;; Same as the parent code, except we construct a DeterministicKey instead of an ECKey.
        (Preconditions/checkNotNull __keyCrypter)
        (when (some? __newParent)
            (Preconditions/checkArgument (.. __newParent (isEncrypted)))
        )

        (let [#_"byte[]" __privKeyBytes (.. this (getPrivKeyBytes))]
            (Preconditions/checkState (some? __privKeyBytes), "Private key is not available")

            (let [#_"EncryptedData" __encryptedPrivateKey (.. __keyCrypter (encrypt __privKeyBytes, __aesKey))
                  #_"DeterministicKey" __key (DeterministicKey. (:child-number-path this), (:chain-code this), __keyCrypter, (:pub this), __encryptedPrivateKey, __newParent)]
                (when (nil? __newParent)
                    (.. __key (setCreationTimeSeconds (.. this (getCreationTimeSeconds))))
                )
                __key
            )
        )
    )

    ;;;
     ; A deterministic key is considered to be 'public key only' if it hasn't got a private key part and it cannot be
     ; rederived.  If the hierarchy is encrypted this returns true.
     ;;
    #_override
    #_public
    (ยง method #_"boolean" isPubKeyOnly []
        (and (.. super (isPubKeyOnly)) (or (nil? (:parent this)) (.. (:parent this) (isPubKeyOnly))))
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (ยง method #_"boolean" hasPrivKey []
        (some? (.. this (findParentWithPrivKey)))
    )

    #_nilable
    #_override
    #_public
    (ยง method #_"byte[]" getSecretBytes []
        (when (some? (:priv this)) (.. this (getPrivKeyBytes)))
    )

    ;;;
     ; A deterministic key is considered to be encrypted if it has access to encrypted private key bytes, OR if its
     ; parent does.  The reason is because the parent would be encrypted under the same key and this key knows how to
     ; rederive its own private key bytes from the parent, if needed.
     ;;
    #_override
    #_public
    (ยง method #_"boolean" isEncrypted []
        (and (nil? (:priv this)) (or (.. super (isEncrypted)) (and (some? (:parent this)) (.. (:parent this) (isEncrypted)))))
    )

    ;;;
     ; Returns this keys {@link org.bitcoinj.crypto.KeyCrypter} <b>or</b> the keycrypter of its parent key.
     ;;
    #_override
    #_nilable
    #_public
    (ยง method #_"KeyCrypter" getKeyCrypter []
        (when (some? (:key-crypter this))
            (ยง return (:key-crypter this))
        )
        (when (some? (:parent this))
            (ยง return (.. (:parent this) (getKeyCrypter)))
        )

        nil
    )

    #_override
    #_public
    #_throws #_[ "KeyCrypterException" ]
    (ยง method #_"ECKey.ECDSASignature" sign [#_"Sha256Hash" __input, #_nilable #_"KeyParameter" __aesKey]
        (cond (.. this (isEncrypted))
            (do
                ;; If the key is encrypted, ECKey.sign will decrypt it first before rerunning sign.  Decryption walks
                ;; the key heirarchy to find the private key (see below), so, we can just run the inherited method.
                (ยง return (.. super (sign __input, __aesKey)))
            )
            :else
            (do
                ;; If it's not encrypted, derive the private via the parents.
                (let [#_"BigInteger" __privateKey (.. this (findOrDerivePrivateKey))]
                    ;; This key is a part of a public-key only heirarchy and cannot be used for signing.
                    (when (nil? __privateKey)
                        (throw (ECKey.MissingPrivateKeyException.))
                    )

                    (ยง return (.. super (doSign __input, __privateKey)))
                )
            )
        )
    )

    #_override
    #_public
    #_throws #_[ "KeyCrypterException" ]
    (ยง method #_"DeterministicKey" decrypt [#_"KeyCrypter" __keyCrypter, #_"KeyParameter" __aesKey]
        (Preconditions/checkNotNull __keyCrypter)
        ;; Check that the keyCrypter matches the one used to encrypt the keys, if set.
        (when (and (some? (:key-crypter this)) (not (.. (:key-crypter this) (equals __keyCrypter))))
            (throw (KeyCrypterException. "The keyCrypter being used to decrypt the key is different to the one that was used to encrypt it"))
        )

        (let [#_"BigInteger" __privKey (.. this (findOrDeriveEncryptedPrivateKey __keyCrypter, __aesKey))
              #_"DeterministicKey" __key (DeterministicKey. (:child-number-path this), (:chain-code this), __privKey, (:parent this))]
            (when (not (Arrays/equals (.. __key (getPubKey)), (.. this (getPubKey))))
                (throw (KeyCrypterException. "Provided AES key is wrong"))
            )

            (when (nil? (:parent this))
                (.. __key (setCreationTimeSeconds (.. this (getCreationTimeSeconds))))
            )
            __key
        )
    )

    #_override
    #_public
    #_throws #_[ "KeyCrypterException" ]
    (ยง method #_"DeterministicKey" decrypt [#_"KeyParameter" __aesKey]
        (cast DeterministicKey (.. super (decrypt __aesKey)))
    )

    ;; For when a key is encrypted, either decrypt our encrypted private key bytes, or work up the tree asking parents
    ;; to decrypt and re-derive.
    #_private
    (ยง method- #_"BigInteger" findOrDeriveEncryptedPrivateKey [#_"KeyCrypter" __keyCrypter, #_"KeyParameter" __aesKey]
        (when (some? (:encrypted-private-key this))
            (ยง return (BigInteger. 1, (.. __keyCrypter (decrypt (:encrypted-private-key this), __aesKey))))
        )

        ;; Otherwise we don't have it, but maybe we can figure it out from our parents.  Walk up the tree looking for
        ;; the first key that has some encrypted private key data.
        (let [#_"DeterministicKey" __cursor (:parent this)]
            (while (some? __cursor)
                (when (some? (:encrypted-private-key __cursor))
                    (ยง break )
                )
                (ยง ass __cursor (:parent __cursor))
            )
            (when (nil? __cursor)
                (throw (KeyCrypterException. "Neither this key nor its parents have an encrypted private key"))
            )

            (let [#_"byte[]" __parentalPrivateKeyBytes (.. __keyCrypter (decrypt (:encrypted-private-key __cursor), __aesKey))]
                (.. this (derivePrivateKeyDownwards __cursor, __parentalPrivateKeyBytes))
            )
        )
    )

    #_private
    (ยง method- #_"DeterministicKey" findParentWithPrivKey []
        (let [#_"DeterministicKey" __cursor this]
            (while (some? __cursor)
                (when (some? (:priv __cursor))
                    (ยง break )
                )
                (ยง ass __cursor (:parent __cursor))
            )
            __cursor
        )
    )

    #_nilable
    #_private
    (ยง method- #_"BigInteger" findOrDerivePrivateKey []
        (let [#_"DeterministicKey" __cursor (.. this (findParentWithPrivKey))]
            (when (nil? __cursor)
                (ยง return nil)
            )

            (.. this (derivePrivateKeyDownwards __cursor, (.. (:priv __cursor) (toByteArray))))
        )
    )

    #_private
    (ยง method- #_"BigInteger" derivePrivateKeyDownwards [#_"DeterministicKey" __cursor, #_"byte[]" __parentalPrivateKeyBytes]
        (let [#_"DeterministicKey" __downCursor (DeterministicKey. (:child-number-path __cursor), (:chain-code __cursor), (:pub __cursor), (BigInteger. 1, __parentalPrivateKeyBytes), (:parent __cursor))]
            ;; Now we have to rederive the keys along the path back to ourselves.  That path can be found by just truncating
            ;; our path with the length of the parents path.
            (let [#_"ImmutableList<ChildNumber>" __path (.. (:child-number-path this) (subList (.. __cursor (getPath) (size)), (.. (:child-number-path this) (size))))]
                (doseq [#_"ChildNumber" __num __path]
                    (ยง ass __downCursor (HDKeyDerivation/deriveChildKey __downCursor, __num))
                )
                ;; downCursor is now the same key as us, but with private key bytes.
                ;; If it's not, it means we tried decrypting with an invalid password and earlier checks e.g. for padding didn't
                ;; catch it.
                (when (not (.. (:pub __downCursor) (equals (:pub this))))
                    (throw (KeyCrypterException. "Could not decrypt bytes"))
                )

                (Preconditions/checkNotNull (:priv __downCursor))
            )
        )
    )

    ;;;
     ; Derives a child at the given index using hardened derivation.  Note: <code>index</code>
     ; is not the "i" value.  If you want the softened derivation, then use instead
     ; <code>HDKeyDerivation.deriveChildKey(this, new ChildNumber(child, false))</code>.
     ;;
    #_public
    (ยง method #_"DeterministicKey" derive [#_"int" __child]
        (HDKeyDerivation/deriveChildKey this, (ChildNumber. __child, true))
    )

    ;;;
     ; Returns the private key of this deterministic key.  Even if this object isn't storing the private key,
     ; it can be re-derived by walking up to the parents if necessary and this is what will happen.
     ; @throws java.lang.IllegalStateException if the parents are encrypted or a watching chain.
     ;;
    #_override
    #_public
    (ยง method #_"BigInteger" getPrivKey []
        (let [#_"BigInteger" __key (.. this (findOrDerivePrivateKey))]
            (Preconditions/checkState (some? __key), "Private key bytes not available")
            __key
        )
    )

    #_public
    (ยง method #_"byte[]" serializePublic [#_"NetworkParameters" __params]
        (.. this (serialize __params, true))
    )

    #_public
    (ยง method #_"byte[]" serializePrivate [#_"NetworkParameters" __params]
        (.. this (serialize __params, false))
    )

    #_private
    (ยง method- #_"byte[]" serialize [#_"NetworkParameters" __params, #_"boolean" __pub]
        (let [#_"ByteBuffer" __ser (ByteBuffer/allocate 78)]
            (.. __ser (putInt (if __pub (.. __params (getBip32HeaderPub)) (.. __params (getBip32HeaderPriv)))))
            (.. __ser (put (byte (.. this (getDepth)))))
            (.. __ser (putInt (.. this (getParentFingerprint))))
            (.. __ser (putInt (.. this (getChildNumber) (i))))
            (.. __ser (put (.. this (getChainCode))))
            (.. __ser (put (if __pub (.. this (getPubKey)) (.. this (getPrivKeyBytes33)))))
            (Preconditions/checkState (== (.. __ser (position)) 78))
            (.. __ser (array))
        )
    )

    #_public
    (ยง method #_"String" serializePubB58 [#_"NetworkParameters" __params]
        (DeterministicKey/toBase58 (.. this (serialize __params, true)))
    )

    #_public
    (ยง method #_"String" serializePrivB58 [#_"NetworkParameters" __params]
        (DeterministicKey/toBase58 (.. this (serialize __params, false)))
    )

    #_static
    (ยง defn #_"String" DeterministicKey/toBase58 [#_"byte[]" __ser]
        (Base58/encode (DeterministicKey/addChecksum __ser))
    )

    ;;; Deserialize a base-58-encoded HD Key with no parent. ;;
    #_public
    #_static
    (ยง defn #_"DeterministicKey" DeterministicKey/deserializeB58 [#_"String" __base58, #_"NetworkParameters" __params]
        (DeterministicKey/deserializeB58 nil, __base58, __params)
    )

    ;;;
     ; Deserialize a base-58-encoded HD Key.
     ; @param parent The parent node in the given key's deterministic hierarchy.
     ; @throws IllegalArgumentException if the base58 encoded key could not be parsed.
     ;;
    #_public
    #_static
    (ยง defn #_"DeterministicKey" DeterministicKey/deserializeB58 [#_nilable #_"DeterministicKey" __parent, #_"String" __base58, #_"NetworkParameters" __params]
        (DeterministicKey/deserialize __params, (Base58/decodeChecked __base58), __parent)
    )

    ;;;
     ; Deserialize an HD Key with no parent.
     ;;
    #_public
    #_static
    (ยง defn #_"DeterministicKey" DeterministicKey/deserialize [#_"NetworkParameters" __params, #_"byte[]" __serializedKey]
        (DeterministicKey/deserialize __params, __serializedKey, nil)
    )

    ;;;
     ; Deserialize an HD Key.
     ; @param parent The parent node in the given key's deterministic hierarchy.
     ;;
    #_public
    #_static
    (ยง defn #_"DeterministicKey" DeterministicKey/deserialize [#_"NetworkParameters" __params, #_"byte[]" __serializedKey, #_nilable #_"DeterministicKey" __parent]
        (let [#_"ByteBuffer" __buffer (ByteBuffer/wrap __serializedKey)
              #_"int" __header (.. __buffer (getInt))]
            (when (and (!= __header (.. __params (getBip32HeaderPriv))) (!= __header (.. __params (getBip32HeaderPub))))
                (throw (IllegalArgumentException. (str "Unknown header bytes: " (.. (DeterministicKey/toBase58 __serializedKey) (substring 0, 4)))))
            )

            (let [#_"boolean" __pub (== __header (.. __params (getBip32HeaderPub)))
                  #_"int" __depth (& (.. __buffer (get)) 0xff)] ;; convert signed byte to positive int since depth cannot be negative
                (let [#_"int" __parentFingerprint (.. __buffer (getInt))
                      #_"int" __i (.. __buffer (getInt))
                      #_"ChildNumber" __childNumber (ChildNumber. __i)
                      #_"ImmutableList<ChildNumber>" __path]
                    (cond (some? __parent)
                        (do
                            (when (== __parentFingerprint 0)
                                (throw (IllegalArgumentException. "Parent was provided but this key doesn't have one"))
                            )
                            (when (!= (.. __parent (getFingerprint)) __parentFingerprint)
                                (throw (IllegalArgumentException. "Parent fingerprints don't match"))
                            )
                            (ยง ass __path (HDUtils/append (.. __parent (getPath)), __childNumber))
                            (when (!= (.. __path (size)) __depth)
                                (throw (IllegalArgumentException. "Depth does not match"))
                            )
                        )
                        :else
                        (do
                            ;; We have been given a key that is not a root key, yet we lack the object representing the parent.
                            ;; This can happen when deserializing an account key for a watching wallet.  In this case, we assume
                            ;; that the client wants to conceal the key's position in the hierarchy.  The path is truncated at
                            ;; the parent's node.
                            (if (<= 1 __depth)
                                (ยง ass __path (ImmutableList/of __childNumber))
                                (ยง ass __path (ImmutableList/of))
                            )
                        )
                    )
                    (let [#_"byte[]" __chainCode (byte-array 32)]
                        (.. __buffer (get __chainCode))
                        (let [#_"byte[]" __data (byte-array 33)]
                            (.. __buffer (get __data))
                            (Preconditions/checkArgument (not (.. __buffer (hasRemaining))), "Found unexpected data in key")
                            (if __pub
                                (ยง return (DeterministicKey. __path, __chainCode, (LazyECPoint. (.. ECKey/CURVE (getCurve)), __data), __parent, __depth, __parentFingerprint))
                                (ยง return (DeterministicKey. __path, __chainCode, (BigInteger. 1, __data), __parent, __depth, __parentFingerprint))
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; The creation time of a deterministic key is equal to that of its parent, unless this key is the root of a tree
     ; in which case the time is stored alongside the key as per normal, see {@link org.bitcoinj.core.ECKey#getCreationTimeSeconds()}.
     ;;
    #_override
    #_public
    (ยง method #_"long" getCreationTimeSeconds []
        (if (some? (:parent this))
            (ยง return (.. (:parent this) (getCreationTimeSeconds)))
            (ยง return (.. super (getCreationTimeSeconds)))
        )
    )

    ;;;
     ; The creation time of a deterministic key is equal to that of its parent, unless this key is the root of a tree.
     ; Thus, setting the creation time on a leaf is forbidden.
     ;;
    #_override
    #_public
    (ยง method #_"void" setCreationTimeSeconds [#_"long" __newCreationTimeSeconds]
        (if (some? (:parent this))
            (throw (IllegalStateException. "Creation time can only be set on root keys."))
            (.. super (setCreationTimeSeconds __newCreationTimeSeconds))
        )
        nil
    )

    ;;;
     ; Verifies equality of all fields but NOT the parent pointer, thus the same key derived in two separate heirarchy
     ; objects will equal each other.
     ;;
    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"DeterministicKey" __other (cast DeterministicKey __o)]
            (and (.. super (equals __other)) (Arrays/equals (:chain-code this), (:chain-code __other)) (Objects/equal (:child-number-path this), (:child-number-path __other)))
        )
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (.. super (hashCode)), (Arrays/hashCode (:chain-code this)), (:child-number-path this))
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (let [#_"MoreObjects.ToStringHelper" __helper (.. (MoreObjects/toStringHelper this) (omitNullValues))]
            (.. __helper (add "pub", (.. Utils/HEX (encode (.. (:pub this) (getEncoded))))))
            (.. __helper (add "chainCode", (.. Utils/HEX (encode (:chain-code this)))))
            (.. __helper (add "path", (.. this (getPathAsString))))
            (when (< 0 (:creation-time-seconds this))
                (.. __helper (add "creationTimeSeconds", (:creation-time-seconds this)))
            )
            (.. __helper (add "isEncrypted", (.. this (isEncrypted))))
            (.. __helper (add "isPubKeyOnly", (.. this (isPubKeyOnly))))
            (.. __helper (toString))
        )
    )

    #_override
    #_public
    (ยง method #_"void" formatKeyWithAddress [#_"boolean" __includePrivateKeys, #_"StringBuilder" __sb, #_"NetworkParameters" __params]
        (let [#_"Address" __address (.. this (toAddress __params))]
            (.. __sb (append "  addr:") (append __address))
            (.. __sb (append "  hash160:") (append (.. Utils/HEX (encode (.. this (getPubKeyHash))))))
            (.. __sb (append "  (") (append (.. this (getPathAsString))) (append ")\n"))
            (when __includePrivateKeys
                (.. __sb (append "  ") (append (.. this (toStringWithPrivate __params))) (append "\n"))
            )
            nil
        )
    )
)

;;;
 ; Provides a uniform way to access something that can be optionally encrypted with a
 ; {@link org.bitcoinj.crypto.KeyCrypter}, yielding an {@link org.bitcoinj.crypto.EncryptedData},
 ; and which can have a creation time associated with it.
 ;;
#_public
(ยง interface EncryptableItem
    ;;; Returns whether the item is encrypted or not.  If it is, then {@link #getSecretBytes()} will return null. ;;
    (ยง method #_"boolean" isEncrypted [])

    ;;; Returns the raw bytes of the item, if not encrypted, or null if encrypted or the secret is missing. ;;
    #_nilable
    (ยง method #_"byte[]" getSecretBytes [])

    ;;; Returns the initialization vector and encrypted secret bytes, or null if not encrypted. ;;
    #_nilable
    (ยง method #_"EncryptedData" getEncryptedData [])

    ;;; Returns an enum constant describing what algorithm was used to encrypt the key or UNENCRYPTED. ;;
    (ยง method #_"Protos.Wallet.EncryptionType" getEncryptionType [])

    ;;; Returns the time in seconds since the UNIX epoch at which this encryptable item was first created/derived. ;;
    (ยง method #_"long" getCreationTimeSeconds [])
)

;;;
 ; <p>An instance of EncryptedData is a holder for an initialization vector and encrypted bytes.
 ; It is typically used to hold encrypted private key bytes.</p>
 ;
 ; <p>The initialisation vector is random data that is used to initialise the AES block cipher when
 ; the private key bytes were encrypted.  You need these for decryption.</p>
 ;;
#_public
(ยง class EncryptedData
    #_public
    (ยง field #_"byte[]" :initialisation-vector)
    #_public
    (ยง field #_"byte[]" :encrypted-bytes)

    #_public
    (ยง constructor EncryptedData [#_"byte[]" __initialisationVector, #_"byte[]" __encryptedBytes]
        (ยง assoc this :initialisation-vector (Arrays/copyOf __initialisationVector, (.. __initialisationVector (alength))))
        (ยง assoc this :encrypted-bytes (Arrays/copyOf __encryptedBytes, (.. __encryptedBytes (alength))))
        this
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"EncryptedData" __other (cast EncryptedData __o)]
            (and (Arrays/equals (:encrypted-bytes this), (:encrypted-bytes __other)) (Arrays/equals (:initialisation-vector this), (:initialisation-vector __other)))
        )
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (Arrays/hashCode (:encrypted-bytes this)), (Arrays/hashCode (:initialisation-vector this)))
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (str "EncryptedData [initialisationVector=" (Arrays/toString (:initialisation-vector this)) ", encryptedPrivateKey=" (Arrays/toString (:encrypted-bytes this)) "]")
    )
)

#_public
(ยง class HDDerivationException (ยง extends RuntimeException)
    #_public
    (ยง constructor HDDerivationException [#_"String" __message]
        (ยง super __message)
        this
    )
)

;;;
 ; Implementation of the <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP 32</a>
 ; deterministic wallet child key generation algorithm.
 ;;
#_public
(ยง class HDKeyDerivation
    ;; Some arbitrary random number.  Doesn't matter what it is.
    #_private
    #_static
    (ยง def- #_"BigInteger" HDKeyDerivation/RAND_INT (BigInteger. 256, (SecureRandom.)))

    #_private
    (ยง constructor- #_"HDKeyDerivation" []
        this
    )

    ;;;
     ; Child derivation may fail (although with extremely low probability); in such case it is re-attempted.
     ; This is the maximum number of re-attempts (to avoid an infinite loop in case of bugs etc.)
     ;;
    #_public
    #_static
    (ยง def #_"int" HDKeyDerivation/MAX_CHILD_DERIVATION_ATTEMPTS 100)

    ;;;
     ; Generates a new deterministic key from the given seed, which can be any arbitrary byte array.
     ; However resist the temptation to use a string as the seed - any key derived from a password
     ; is likely to be weak and easily broken by attackers (this is not theoretical, people have had
     ; money stolen that way).  This method checks that the given seed is at least 64 bits long.
     ;
     ; @throws HDDerivationException if generated master key is invalid (private key 0 or >= n).
     ; @throws IllegalArgumentException if the seed is less than 8 bytes and could be brute forced.
     ;;
    #_public
    #_static
    #_throws #_[ "HDDerivationException" ]
    (ยง defn #_"DeterministicKey" HDKeyDerivation/createMasterPrivateKey [#_"byte[]" __seed]
        (Preconditions/checkArgument (< 8 (.. __seed (alength))), "Seed is too short and could be brute forced")

        ;; Calculate I = HMAC-SHA512(key="Bitcoin seed", msg=S).
        (let [#_"byte[]" __i (HDUtils/hmacSha512 (HDUtils/createHmacSha512Digest (.. "Bitcoin seed" (getBytes))), __seed)]
            ;; Split I into two 32-byte sequences, Il and Ir.
            ;; Use Il as master secret key, and Ir as master chain code.
            (Preconditions/checkState (== (.. __i (alength)) 64), (.. __i (alength)))

            (let [#_"byte[]" __il (Arrays/copyOfRange __i, 0, 32)
                  #_"byte[]" __ir (Arrays/copyOfRange __i, 32, 64)]
                (Arrays/fill __i, (byte 0))
                (let [#_"DeterministicKey" __masterPrivKey (HDKeyDerivation/createMasterPrivKeyFromBytes __il, __ir)]
                    (Arrays/fill __il, (byte 0))
                    (Arrays/fill __ir, (byte 0))

                    ;; Child deterministic keys will chain up to their parents to find the keys.
                    (.. __masterPrivKey (setCreationTimeSeconds (Utils/currentTimeSeconds)))
                    __masterPrivKey
                )
            )
        )
    )

    ;;;
     ; @throws HDDerivationException if privKeyBytes is invalid (0 or >= n).
     ;;
    #_public
    #_static
    #_throws #_[ "HDDerivationException" ]
    (ยง defn #_"DeterministicKey" HDKeyDerivation/createMasterPrivKeyFromBytes [#_"byte[]" __privKeyBytes, #_"byte[]" __chainCode]
        (let [#_"BigInteger" __priv (BigInteger. 1, __privKeyBytes)]
            (HDKeyDerivation/assertNonZero __priv, "Generated master key is invalid.")
            (HDKeyDerivation/assertLessThanN __priv, "Generated master key is invalid.")
            (DeterministicKey. (ImmutableList/of #_"ImmutableList<ChildNumber>"), __chainCode, __priv, nil)
        )
    )

    #_public
    #_static
    (ยง defn #_"DeterministicKey" HDKeyDerivation/createMasterPubKeyFromBytes [#_"byte[]" __pubKeyBytes, #_"byte[]" __chainCode]
        (DeterministicKey. (ImmutableList/of #_"ImmutableList<ChildNumber>"), __chainCode, (LazyECPoint. (.. ECKey/CURVE (getCurve)), __pubKeyBytes), nil, nil)
    )

    ;;;
     ; Derives a key given the "extended" child number, i.e. the 0x80000000 bit of the value that you
     ; pass for <code>childNumber</code> will determine whether to use hardened derivation or not.
     ; Consider whether your code would benefit from the clarity of the equivalent, but explicit, form
     ; of this method that takes a <code>ChildNumber</code> rather than an <code>int</code>, for example:
     ; <code>deriveChildKey(parent, new ChildNumber(childNumber, true))</code>
     ; where the value of the hardened bit of <code>childNumber</code> is zero.
     ;;
    #_public
    #_static
    (ยง defn #_"DeterministicKey" HDKeyDerivation/deriveChildKey [#_"DeterministicKey" __parent, #_"int" __childNumber]
        (HDKeyDerivation/deriveChildKey __parent, (ChildNumber. __childNumber))
    )

    ;;;
     ; Derives a key of the "extended" child number, i.e. with the 0x80000000 bit specifying whether
     ; to use hardened derivation or not.  If derivation fails, tries a next child.
     ;;
    #_public
    #_static
    (ยง defn #_"DeterministicKey" HDKeyDerivation/deriveThisOrNextChildKey [#_"DeterministicKey" __parent, #_"int" __childNumber]
        (let [#_"ChildNumber" __child (ChildNumber. __childNumber)
              #_"boolean" __isHardened (.. __child (isHardened))]
            (loop-when-recur [#_"int" __i 0] (< __i HDKeyDerivation/MAX_CHILD_DERIVATION_ATTEMPTS) [(inc __i)]
                (try
                    (ยง ass __child (ChildNumber. (+ (.. __child (num)) __i), __isHardened))
                    (ยง return (HDKeyDerivation/deriveChildKey __parent, __child))
                    (catch HDDerivationException _
                    )
                )
            )
            (throw (HDDerivationException. "Maximum number of child derivation attempts reached, this is probably an indication of a bug."))
        )
    )

    ;;;
     ; @throws HDDerivationException if private derivation is attempted for a public-only parent key, or
     ; if the resulting derived key is invalid (e.g. private key == 0).
     ;;
    #_public
    #_static
    #_throws #_[ "HDDerivationException" ]
    (ยง defn #_"DeterministicKey" HDKeyDerivation/deriveChildKey [#_"DeterministicKey" __parent, #_"ChildNumber" __childNumber]
        (cond (not (.. __parent (hasPrivKey)))
            (do
                (let [#_"HDKeyDerivation.RawKeyBytes" __rawKey (HDKeyDerivation/deriveChildKeyBytesFromPublic __parent, __childNumber, HDKeyDerivation.PublicDeriveMode/NORMAL)]
                    (ยง return (DeterministicKey. (HDUtils/append (.. __parent (getPath)), __childNumber), (:chain-code __rawKey), (LazyECPoint. (.. ECKey/CURVE (getCurve)), (:key-bytes __rawKey)), nil, __parent))
                )
            )
            :else
            (do
                (let [#_"HDKeyDerivation.RawKeyBytes" __rawKey (HDKeyDerivation/deriveChildKeyBytesFromPrivate __parent, __childNumber)]
                    (ยง return (DeterministicKey. (HDUtils/append (.. __parent (getPath)), __childNumber), (:chain-code __rawKey), (BigInteger. 1, (:key-bytes __rawKey)), __parent))
                )
            )
        )
    )

    #_public
    #_static
    #_throws #_[ "HDDerivationException" ]
    (ยง defn #_"HDKeyDerivation.RawKeyBytes" HDKeyDerivation/deriveChildKeyBytesFromPrivate [#_"DeterministicKey" __parent, #_"ChildNumber" __childNumber]
        (Preconditions/checkArgument (.. __parent (hasPrivKey)), "Parent key must have private key bytes for this method.")

        (let [#_"byte[]" __parentPublicKey (.. __parent (getPubKeyPoint) (getEncoded true))]
            (Preconditions/checkState (== (.. __parentPublicKey (alength)) 33), (str "Parent pubkey must be 33 bytes, but is " (.. __parentPublicKey (alength))))

            (let [#_"ByteBuffer" __data (ByteBuffer/allocate 37)]
                (.. __data (put (if (.. __childNumber (isHardened)) (.. __parent (getPrivKeyBytes33)) __parentPublicKey)))
                (.. __data (putInt (.. __childNumber (i))))

                (let [#_"byte[]" __i (HDUtils/hmacSha512 (.. __parent (getChainCode)), (.. __data (array)))]
                    (Preconditions/checkState (== (.. __i (alength)) 64), (.. __i (alength)))

                    (let [#_"byte[]" __il (Arrays/copyOfRange __i, 0, 32)
                          #_"byte[]" __chainCode (Arrays/copyOfRange __i, 32, 64)
                          #_"BigInteger" __ilInt (BigInteger. 1, __il)]
                        (HDKeyDerivation/assertLessThanN __ilInt, "Illegal derived key: I_L >= n")

                        (let [#_"BigInteger" __priv (.. __parent (getPrivKey))
                              #_"BigInteger" __ki (.. __priv (add __ilInt) (mod (.. ECKey/CURVE (getN))))]
                            (HDKeyDerivation/assertNonZero __ki, "Illegal derived key: derived private key equals 0.")

                            (HDKeyDerivation.RawKeyBytes. (.. __ki (toByteArray)), __chainCode)
                        )
                    )
                )
            )
        )
    )

    #_public
    (ยง enum HDKeyDerivation.PublicDeriveMode
        (ยง item NORMAL)
        (ยง item WITH_INVERSION)
    )

    #_public
    #_static
    #_throws #_[ "HDDerivationException" ]
    (ยง defn #_"HDKeyDerivation.RawKeyBytes" HDKeyDerivation/deriveChildKeyBytesFromPublic [#_"DeterministicKey" __parent, #_"ChildNumber" __childNumber, #_"HDKeyDerivation.PublicDeriveMode" __mode]
        (Preconditions/checkArgument (not (.. __childNumber (isHardened))), "Can't use private derivation with public keys only.")

        (let [#_"byte[]" __parentPublicKey (.. __parent (getPubKeyPoint) (getEncoded true))]
            (Preconditions/checkState (== (.. __parentPublicKey (alength)) 33), (str "Parent pubkey must be 33 bytes, but is " (.. __parentPublicKey (alength))))

            (let [#_"ByteBuffer" __data (ByteBuffer/allocate 37)]
                (.. __data (put __parentPublicKey))
                (.. __data (putInt (.. __childNumber (i))))

                (let [#_"byte[]" __i (HDUtils/hmacSha512 (.. __parent (getChainCode)), (.. __data (array)))]
                    (Preconditions/checkState (== (.. __i (alength)) 64), (.. __i (alength)))

                    (let [#_"byte[]" __il (Arrays/copyOfRange __i, 0, 32)
                          #_"byte[]" __chainCode (Arrays/copyOfRange __i, 32, 64)
                          #_"BigInteger" __ilInt (BigInteger. 1, __il)]
                        (HDKeyDerivation/assertLessThanN __ilInt, "Illegal derived key: I_L >= n")

                        (let [#_"BigInteger" __N (.. ECKey/CURVE (getN))
                              #_"ECPoint" __Ki]
                            (condp == __mode
                                NORMAL
                                    (ยง ass __Ki (.. (ECKey/publicPointFromPrivate __ilInt) (add (.. __parent (getPubKeyPoint)))))
                                WITH_INVERSION
                                    (ยง do
                                        ;; This trick comes from Gregory Maxwell.  Check the homomorphic properties of our curve hold.  The
                                        ;; below calculations should be redundant and give the same result as NORMAL but if the precalculated
                                        ;; tables have taken a bit flip will yield a different answer.  This mode is used when vending a key
                                        ;; to perform a last-ditch sanity check trying to catch bad RAM.
                                        (ยง ass __Ki (ECKey/publicPointFromPrivate (.. __ilInt (add HDKeyDerivation/RAND_INT) (mod __N))))
                                        (let [#_"BigInteger" __additiveInverse (.. HDKeyDerivation/RAND_INT (negate) (mod __N))]
                                            (ยง ass __Ki (Ki/add (ECKey/publicPointFromPrivate __additiveInverse)))
                                            (ยง ass __Ki (Ki/add (.. __parent (getPubKeyPoint))))
                                        )
                                    )
                                (throw (AssertionError.))
                            )

                            (HDKeyDerivation/assertNonInfinity __Ki, "Illegal derived key: derived public key equals infinity.")
                            (HDKeyDerivation.RawKeyBytes. (Ki/getEncoded true), __chainCode)
                        )
                    )
                )
            )
        )
    )

    #_private
    #_static
    (ยง defn- #_"void" HDKeyDerivation/assertNonZero [#_"BigInteger" __integer, #_"String" __errorMessage]
        (when (.. __integer (equals BigInteger/ZERO))
            (throw (HDDerivationException. __errorMessage))
        )
        nil
    )

    #_private
    #_static
    (ยง defn- #_"void" HDKeyDerivation/assertNonInfinity [#_"ECPoint" __point, #_"String" __errorMessage]
        (when (.. __point (equals (.. ECKey/CURVE (getCurve) (getInfinity))))
            (throw (HDDerivationException. __errorMessage))
        )
        nil
    )

    #_private
    #_static
    (ยง defn- #_"void" HDKeyDerivation/assertLessThanN [#_"BigInteger" __integer, #_"String" __errorMessage]
        (when (> (.. __integer (compareTo (.. ECKey/CURVE (getN)))) 0)
            (throw (HDDerivationException. __errorMessage))
        )
        nil
    )

    #_public
    #_static
    (ยง class HDKeyDerivation.RawKeyBytes
        #_public
        (ยง field #_"byte[]" :key-bytes)
        #_public
        (ยง field #_"byte[]" :chain-code)

        #_public
        (ยง constructor HDKeyDerivation.RawKeyBytes [#_"byte[]" __keyBytes, #_"byte[]" __chainCode]
            (ยง assoc this :key-bytes __keyBytes)
            (ยง assoc this :chain-code __chainCode)
            this
        )
    )
)

;;;
 ; Static utilities used in BIP 32 Hierarchical Deterministic Wallets (HDW).
 ;;
#_public
(ยง class HDUtils
    #_private
    #_static
    (ยง def- #_"Joiner" HDUtils/PATH_JOINER (Joiner/on "/"))

    #_static
    (ยง defn #_"HMac" HDUtils/createHmacSha512Digest [#_"byte[]" __key]
        (let [#_"SHA512Digest" __digest (SHA512Digest.)
              #_"HMac" __hMac (HMac. __digest)]
            (.. __hMac (init (KeyParameter. __key)))
            __hMac
        )
    )

    #_static
    (ยง defn #_"byte[]" HDUtils/hmacSha512 [#_"HMac" __hmacSha512, #_"byte[]" __input]
        (.. __hmacSha512 (reset))
        (.. __hmacSha512 (update __input, 0, (.. __input (alength))))
        (let [#_"byte[]" __out (byte-array 64)]
            (.. __hmacSha512 (doFinal __out, 0))
            __out
        )
    )

    #_public
    #_static
    (ยง defn #_"byte[]" HDUtils/hmacSha512 [#_"byte[]" __key, #_"byte[]" __data]
        (HDUtils/hmacSha512 (HDUtils/createHmacSha512Digest __key), __data)
    )

    #_static
    (ยง defn #_"byte[]" HDUtils/toCompressed [#_"byte[]" __uncompressedPoint]
        (.. ECKey/CURVE (getCurve) (decodePoint __uncompressedPoint) (getEncoded true))
    )

    #_static
    (ยง defn #_"byte[]" HDUtils/longTo4ByteArray [#_"long" __n]
        (let [#_"byte[]" __bytes (Arrays/copyOfRange (.. (ByteBuffer/allocate 8) (putLong __n) (array)), 4, 8)]
            (assert (== (.. __bytes (alength)) 4) (.. __bytes (alength)))
            __bytes
        )
    )

    ;;; Append a derivation level to an existing path. ;;
    #_public
    #_static
    (ยง defn #_"ImmutableList<ChildNumber>" HDUtils/append [#_"List<ChildNumber>" __path, #_"ChildNumber" __childNumber]
        (.. (ImmutableList/builder #_"ImmutableList<ChildNumber>") (addAll __path) (add __childNumber) (build))
    )

    ;;; Concatenate two derivation paths. ;;
    #_public
    #_static
    (ยง defn #_"ImmutableList<ChildNumber>" HDUtils/concat [#_"List<ChildNumber>" __path, #_"List<ChildNumber>" __path2]
        (.. (ImmutableList/builder #_"ImmutableList<ChildNumber>") (addAll __path) (addAll __path2) (build))
    )

    ;;; Convert to a string path, starting with "M/". ;;
    #_public
    #_static
    (ยง defn #_"String" HDUtils/formatPath [#_"List<ChildNumber>" __path]
        (.. HDUtils/PATH_JOINER (join (Iterables/concat (Collections/singleton "M"), __path)))
    )

    ;;;
     ; The path is a human-friendly representation of the deterministic path.  For example:
     ;
     ; "44H / 0H / 0H / 1 / 1"
     ;
     ; Where a letter "H" means hardened key.  Spaces are ignored.
     ;;
    #_public
    #_static
    (ยง defn #_"List<ChildNumber>" HDUtils/parsePath [#_non-nil #_"String" __path]
        (let [#_"String[]" __parsedNodes (.. __path (replace "M", "") (split "/"))
              #_"List<ChildNumber>" __nodes (ArrayList. #_"<>")]

            (doseq [#_"String" __n __parsedNodes]
                (ยง ass __n (.. __n (replaceAll " ", "")))
                (when (!= (.. __n (length)) 0)
                    (let [#_"boolean" __isHard (.. __n (endsWith "H"))]
                        (when __isHard
                            (ยง ass __n (.. __n (substring 0, (dec (.. __n (length))))))
                        )
                        (let [#_"int" __nodeNumber (Integer/parseInt __n)]
                            (.. __nodes (add (ChildNumber. __nodeNumber, __isHard)))
                        )
                    )
                )
            )

            __nodes
        )
    )
)

;;;
 ; <p>A KeyCrypter can be used to encrypt and decrypt a message.  The sequence of events to encrypt and then decrypt
 ; a message are as follows:</p>
 ;
 ; <p>(1) Ask the user for a password.  deriveKey() is then called to create an KeyParameter.  This contains the AES
 ; key that will be used for encryption.</p>
 ; <p>(2) Encrypt the message using encrypt(), providing the message bytes and the KeyParameter from (1).  This returns
 ; an EncryptedData which contains the encryptedPrivateKey bytes and an initialisation vector.</p>
 ; <p>(3) To decrypt an EncryptedData, repeat step (1) to get a KeyParameter, then call decrypt().</p>
 ;
 ; <p>There can be different algorithms used for encryption/ decryption so the getUnderstoodEncryptionType is used
 ; to determine whether any given KeyCrypter can understand the type of encrypted data you have.</p>
 ;;
#_public
(ยง interface KeyCrypter (ยง extends Serializable)
    ;;;
     ; Return the EncryptionType enum value which denotes the type of encryption/ decryption that this KeyCrypter
     ; can understand.
     ;;
    (ยง method #_"Protos.Wallet.EncryptionType" getUnderstoodEncryptionType [])

    ;;;
     ; Create a KeyParameter (which typically contains an AES key).
     ; @param password
     ; @return the KeyParameter which typically contains the AES key to use for encrypting and decrypting.
     ; @throws KeyCrypterException
     ;;
    #_throws #_[ "KeyCrypterException" ]
    (ยง method #_"KeyParameter" deriveKey [#_"CharSequence" __password])

    ;;;
     ; Decrypt the provided encrypted bytes, converting them into unencrypted bytes.
     ;
     ; @throws KeyCrypterException if decryption was unsuccessful.
     ;;
    #_throws #_[ "KeyCrypterException" ]
    (ยง method #_"byte[]" decrypt [#_"EncryptedData" __encryptedBytesToDecode, #_"KeyParameter" __aesKey])

    ;;;
     ; Encrypt the supplied bytes, converting them into ciphertext.
     ;
     ; @return an encryptedPrivateKey containing the encrypted bytes and an initialisation vector.
     ; @throws KeyCrypterException if encryption was unsuccessful.
     ;;
    #_throws #_[ "KeyCrypterException" ]
    (ยง method #_"EncryptedData" encrypt [#_"byte[]" __plainBytes, #_"KeyParameter" __aesKey])
)

;;;
 ; <p>Exception to provide the following:</p>
 ; <ul>
 ; <li>Provision of encryption / decryption exception.</li>
 ; </ul>
 ; <p>This base exception acts as a general failure mode not attributable to a specific cause (other than
 ; that reported in the exception message).  Since this is in English, it may not be worth reporting directly
 ; to the user other than as part of a "general failure to parse" response.</p>
 ;;
#_public
(ยง class KeyCrypterException (ยง extends RuntimeException)
    #_public
    (ยง constructor KeyCrypterException [#_"String" __s]
        (ยง super __s)
        this
    )

    #_public
    (ยง constructor KeyCrypterException [#_"String" __s, #_"Throwable" __throwable]
        (ยง super __s, __throwable)
        this
    )
)

;;;
 ; <p>This class encrypts and decrypts byte arrays and strings using scrypt as the
 ; key derivation function and AES for the encryption.</p>
 ;
 ; <p>You can use this class to:</p>
 ;
 ; <p>1. Using a user password, create an AES key that can encrypt and decrypt your private keys.
 ; To convert the password to the AES key, scrypt is used.  This is an algorithm resistant
 ; to brute force attacks.  You can use the ScryptParameters to tune how difficult you
 ; want this to be generation to be.</p>
 ;
 ; <p>2. Using the AES Key generated above, you then can encrypt and decrypt any bytes using
 ; the AES symmetric cipher.  Eight bytes of salt is used to prevent dictionary attacks.</p>
 ;;
#_public
(ยง class KeyCrypterScrypt (ยง implements KeyCrypter)
    #_private
    #_static
    (ยง def- #_"Logger" KeyCrypterScrypt/log (LoggerFactory/getLogger KeyCrypterScrypt))

    ;;;
     ; Key length in bytes.
     ;;
    #_public
    #_static
    (ยง def #_"int" KeyCrypterScrypt/KEY_LENGTH 32) ;; = 256 bits.

    ;;;
     ; The size of an AES block in bytes.
     ; This is also the length of the initialisation vector.
     ;;
    #_public
    #_static
    (ยง def #_"int" KeyCrypterScrypt/BLOCK_LENGTH 16) ;; = 128 bits.

    ;;;
     ; The length of the salt used.
     ;;
    #_public
    #_static
    (ยง def #_"int" KeyCrypterScrypt/SALT_LENGTH 8)

    #_private
    #_static
    (ยง def- #_"SecureRandom" KeyCrypterScrypt/SECURE_RANDOM (SecureRandom.))

    ;;; Returns SALT_LENGTH (8) bytes of random data. ;;
    #_public
    #_static
    (ยง defn #_"byte[]" KeyCrypterScrypt/randomSalt []
        (let [#_"byte[]" __salt (byte-array KeyCrypterScrypt/SALT_LENGTH)]
            (.. KeyCrypterScrypt/SECURE_RANDOM (nextBytes __salt))
            __salt
        )
    )

    ;; Scrypt parameters.
    #_private
    (ยง field- #_"Protos.ScryptParameters" :scrypt-parameters)

    ;;;
     ; Encryption/Decryption using default parameters and a random salt.
     ;;
    #_public
    (ยง constructor KeyCrypterScrypt []
        (let [#_"Protos.ScryptParameters.Builder" __builder (.. (Protos.ScryptParameters/newBuilder) (setSalt (ByteString/copyFrom (KeyCrypterScrypt/randomSalt))))]
            (ยง assoc this :scrypt-parameters (.. __builder (build)))
            this
        )
    )

    ;;;
     ; Encryption/Decryption using custom number of iterations parameters and a random salt.
     ; As of August 2016, a useful value for mobile devices is 4096 (derivation takes about 1 second).
     ;
     ; @param iterations Number of scrypt iterations.
     ;;
    #_public
    (ยง constructor KeyCrypterScrypt [#_"int" __iterations]
        (let [#_"Protos.ScryptParameters.Builder" __builder (.. (Protos.ScryptParameters/newBuilder) (setSalt (ByteString/copyFrom (KeyCrypterScrypt/randomSalt))) (setN __iterations))]
            (ยง assoc this :scrypt-parameters (.. __builder (build)))
            this
        )
    )

    ;;;
     ; Encryption/ Decryption using specified Scrypt parameters.
     ;
     ; @param scryptParameters ScryptParameters to use.
     ; @throws NullPointerException if the scryptParameters or any of its N, R or P is null.
     ;;
    #_public
    (ยง constructor KeyCrypterScrypt [#_"Protos.ScryptParameters" __scryptParameters]
        (ยง assoc this :scrypt-parameters (Preconditions/checkNotNull __scryptParameters))

        ;; Check there is a non-empty salt.  Some early MultiBit wallets has a missing salt, so it is not a hard fail.
        (when (or (nil? (.. __scryptParameters (getSalt))) (nil? (.. __scryptParameters (getSalt) (toByteArray))) (== (.. __scryptParameters (getSalt) (toByteArray) (alength)) 0))
            (.. KeyCrypterScrypt/log (warn "You are using a ScryptParameters with no salt. Your encryption may be vulnerable to a dictionary attack."))
        )
        this
    )

    ;;;
     ; Generate AES key.
     ;
     ; This is a very slow operation compared to encrypt/ decrypt so it is normally worth caching the result.
     ;
     ; @param password The password to use in key generation.
     ; @return the KeyParameter containing the created AES key.
     ; @throws KeyCrypterException
     ;;
    #_override
    #_public
    #_throws #_[ "KeyCrypterException" ]
    (ยง method #_"KeyParameter" deriveKey [#_"CharSequence" __password]
        (let [#_"byte[]" __passwordBytes nil]
            (try
                (ยง ass __passwordBytes (KeyCrypterScrypt/convertToByteArray __password))
                (let [#_"byte[]" __salt (byte-array 0)]
                    (cond (some? (.. (:scrypt-parameters this) (getSalt)))
                        (do
                            (ยง ass __salt (.. (:scrypt-parameters this) (getSalt) (toByteArray)))
                        )
                        :else
                        (do
                            ;; Warn the user that they are not using a salt.  Some early MultiBit wallets had a blank salt.
                            (.. KeyCrypterScrypt/log (warn "You are using a ScryptParameters with no salt. Your encryption may be vulnerable to a dictionary attack."))
                        )
                    )

                    (let [#_"Stopwatch" __watch (Stopwatch/createStarted)
                          #_"byte[]" __keyBytes (SCrypt/scrypt __passwordBytes, __salt, (int (.. (:scrypt-parameters this) (getN))), (.. (:scrypt-parameters this) (getR)), (.. (:scrypt-parameters this) (getP)), KeyCrypterScrypt/KEY_LENGTH)]
                        (.. __watch (stop))
                        (.. KeyCrypterScrypt/log (info "Deriving key took {} for {} scrypt iterations.", __watch, (.. (:scrypt-parameters this) (getN))))
                        (ยง return (KeyParameter. __keyBytes))
                    )
                )
                (catch Exception __e
                    (throw (KeyCrypterException. "Could not generate key from password and salt.", __e))
                )
                (finally
                    ;; Zero the password bytes.
                    (when (some? __passwordBytes)
                        (java.util.Arrays/fill __passwordBytes, (byte 0))
                    )
                )
            )
        )
    )

    ;;;
     ; Password based encryption using AES - CBC 256 bits.
     ;;
    #_override
    #_public
    #_throws #_[ "KeyCrypterException" ]
    (ยง method #_"EncryptedData" encrypt [#_"byte[]" __plainBytes, #_"KeyParameter" __aesKey]
        (Preconditions/checkNotNull __plainBytes)
        (Preconditions/checkNotNull __aesKey)

        (try
            ;; Generate iv - each encryption call has a different iv.
            (let [#_"byte[]" __iv (byte-array KeyCrypterScrypt/BLOCK_LENGTH)]
                (.. KeyCrypterScrypt/SECURE_RANDOM (nextBytes __iv))

                (let [#_"ParametersWithIV" __keyWithIv (ParametersWithIV. __aesKey, __iv)]

                    ;; Encrypt using AES.
                    (let [#_"BufferedBlockCipher" __cipher (PaddedBufferedBlockCipher. (CBCBlockCipher. (AESFastEngine.)))]
                        (.. __cipher (init true, __keyWithIv))
                        (let [#_"byte[]" __encryptedBytes (byte-array (.. __cipher (getOutputSize (.. __plainBytes (alength)))))
                              #_"int" __length1 (.. __cipher (processBytes __plainBytes, 0, (.. __plainBytes (alength)), __encryptedBytes, 0))
                              #_"int" __length2 (.. __cipher (doFinal __encryptedBytes, __length1))]

                            (ยง return (EncryptedData. __iv, (Arrays/copyOf __encryptedBytes, (+ __length1 __length2))))
                        )
                    )
                )
            )
            (catch Exception __e
                (throw (KeyCrypterException. "Could not encrypt bytes.", __e))
            )
        )
    )

    ;;;
     ; Decrypt bytes previously encrypted with this class.
     ;
     ; @param dataToDecrypt The data to decrypt.
     ; @param aesKey The AES key to use for decryption.
     ; @return the decrypted bytes.
     ; @throws KeyCrypterException if bytes could not be decrypted.
     ;;
    #_override
    #_public
    #_throws #_[ "KeyCrypterException" ]
    (ยง method #_"byte[]" decrypt [#_"EncryptedData" __dataToDecrypt, #_"KeyParameter" __aesKey]
        (Preconditions/checkNotNull __dataToDecrypt)
        (Preconditions/checkNotNull __aesKey)

        (try
            (let [#_"ParametersWithIV" __keyWithIv (ParametersWithIV. (KeyParameter. (.. __aesKey (getKey))), (:initialisation-vector __dataToDecrypt))]

                ;; Decrypt the message.
                (let [#_"BufferedBlockCipher" __cipher (PaddedBufferedBlockCipher. (CBCBlockCipher. (AESFastEngine.)))]
                    (.. __cipher (init false, __keyWithIv))

                    (let [#_"byte[]" __cipherBytes (:encrypted-bytes __dataToDecrypt)
                          #_"byte[]" __decryptedBytes (byte-array (.. __cipher (getOutputSize (.. __cipherBytes (alength)))))
                          #_"int" __length1 (.. __cipher (processBytes __cipherBytes, 0, (.. __cipherBytes (alength)), __decryptedBytes, 0))
                          #_"int" __length2 (.. __cipher (doFinal __decryptedBytes, __length1))]

                        (ยง return (Arrays/copyOf __decryptedBytes, (+ __length1 __length2)))
                    )
                )
            )
            (catch Exception __e
                (throw (KeyCrypterException. "Could not decrypt bytes", __e))
            )
        )
    )

    ;;;
     ; Convert a CharSequence (which are UTF16) into a byte array.
     ;
     ; Note: a String.getBytes() is not used to avoid creating a String of the password in the JVM.
     ;;
    #_private
    #_static
    (ยง defn- #_"byte[]" KeyCrypterScrypt/convertToByteArray [#_"CharSequence" __charSequence]
        (Preconditions/checkNotNull __charSequence)

        (let [#_"byte[]" __byteArray (byte-array (<< (.. __charSequence (length)) 1))]
            (loop-when-recur [#_"int" __i 0] (< __i (.. __charSequence (length))) [(inc __i)]
                (let [#_"int" __bytePosition (<< __i 1)]
                    (aset __byteArray __bytePosition (byte (>> (& (.. __charSequence (charAt __i)) 0xff00) 8)))
                    (aset __byteArray (inc __bytePosition) (byte (& (.. __charSequence (charAt __i)) 0x00ff)))
                )
            )
            __byteArray
        )
    )

    #_public
    (ยง method #_"Protos.ScryptParameters" getScryptParameters []
        (:scrypt-parameters this)
    )

    ;;;
     ; Return the EncryptionType enum value which denotes the type of encryption/ decryption that this KeyCrypter
     ; can understand.
     ;;
    #_override
    #_public
    (ยง method #_"Protos.Wallet.EncryptionType" getUnderstoodEncryptionType []
        Protos.Wallet.EncryptionType/ENCRYPTED_SCRYPT_AES
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (str "AES-" (* KeyCrypterScrypt/KEY_LENGTH 8) "-CBC, Scrypt (N: " (.. (:scrypt-parameters this) (getN)) ")")
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (:scrypt-parameters this))
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (Objects/equal (:scrypt-parameters this), (:scrypt-parameters (cast KeyCrypterScrypt __o)))
    )
)

;;;
 ; A wrapper around ECPoint that delays decoding of the point for as long as possible.  This is useful because point
 ; encode/decode in Bouncy Castle is quite slow especially on Dalvik, as it often involves decompression/recompression.
 ;;
#_public
(ยง class LazyECPoint
    ;; If curve is set, bits is also set.  If curve is unset, point is set and bits is unset.  Point can be set along
    ;; with curve and bits when the cached form has been accessed and thus must have been converted.
    #_private
    (ยง field- #_"ECCurve" :curve)
    #_private
    (ยง field- #_"byte[]" :bits)

    ;; This field is effectively final - once set it won't change again.  However it can be set after construction.
    #_nilable
    #_private
    (ยง field- #_"ECPoint" :point)

    #_public
    (ยง constructor LazyECPoint [#_"ECCurve" __curve, #_"byte[]" __bits]
        (ยง assoc this :curve __curve)
        (ยง assoc this :bits __bits)
        this
    )

    #_public
    (ยง constructor LazyECPoint [#_"ECPoint" __point]
        (ยง assoc this :point (Preconditions/checkNotNull __point))
        (ยง assoc this :curve nil)
        (ยง assoc this :bits nil)
        this
    )

    #_public
    (ยง method #_"ECPoint" get []
        (when (nil? (:point this))
            (ยง assoc this :point (.. (:curve this) (decodePoint (:bits this))))
        )
        (:point this)
    )

    ;; Delegated methods.

    #_public
    (ยง method #_"ECPoint" getDetachedPoint []
        (.. this (get) (getDetachedPoint))
    )

    #_public
    (ยง method #_"byte[]" getEncoded []
        (if (some? (:bits this))
            (ยง return (Arrays/copyOf (:bits this), (.. (:bits this) (alength))))
            (ยง return (.. this (get) (getEncoded)))
        )
    )

    #_public
    (ยง method #_"boolean" isInfinity []
        (.. this (get) (isInfinity))
    )

    #_public
    (ยง method #_"ECPoint" timesPow2 [#_"int" __e]
        (.. this (get) (timesPow2 __e))
    )

    #_public
    (ยง method #_"ECFieldElement" getYCoord []
        (.. this (get) (getYCoord))
    )

    #_public
    (ยง method #_"ECFieldElement[]" getZCoords []
        (.. this (get) (getZCoords))
    )

    #_public
    (ยง method #_"boolean" isNormalized []
        (.. this (get) (isNormalized))
    )

    #_public
    (ยง method #_"boolean" isCompressed []
        (if (some? (:bits this)) (any == (aget (:bits this) 0) 2 3) (.. this (get) (isCompressed)))
    )

    #_public
    (ยง method #_"ECPoint" multiply [#_"BigInteger" __k]
        (.. this (get) (multiply __k))
    )

    #_public
    (ยง method #_"ECPoint" subtract [#_"ECPoint" __b]
        (.. this (get) (subtract __b))
    )

    #_public
    (ยง method #_"boolean" isValid []
        (.. this (get) (isValid))
    )

    #_public
    (ยง method #_"ECPoint" scaleY [#_"ECFieldElement" __scale]
        (.. this (get) (scaleY __scale))
    )

    #_public
    (ยง method #_"ECFieldElement" getXCoord []
        (.. this (get) (getXCoord))
    )

    #_public
    (ยง method #_"ECPoint" scaleX [#_"ECFieldElement" __scale]
        (.. this (get) (scaleX __scale))
    )

    #_public
    (ยง method #_"boolean" equals [#_"ECPoint" __other]
        (.. this (get) (equals __other))
    )

    #_public
    (ยง method #_"ECPoint" negate []
        (.. this (get) (negate))
    )

    #_public
    (ยง method #_"ECPoint" threeTimes []
        (.. this (get) (threeTimes))
    )

    #_public
    (ยง method #_"ECFieldElement" getZCoord [#_"int" __index]
        (.. this (get) (getZCoord __index))
    )

    #_public
    (ยง method #_"byte[]" getEncoded [#_"boolean" __compressed]
        (if (and (== __compressed (.. this (isCompressed))) (some? (:bits this)))
            (ยง return (Arrays/copyOf (:bits this), (.. (:bits this) (alength))))
            (ยง return (.. this (get) (getEncoded __compressed)))
        )
    )

    #_public
    (ยง method #_"ECPoint" add [#_"ECPoint" __b]
        (.. this (get) (add __b))
    )

    #_public
    (ยง method #_"ECPoint" twicePlus [#_"ECPoint" __b]
        (.. this (get) (twicePlus __b))
    )

    #_public
    (ยง method #_"ECCurve" getCurve []
        (.. this (get) (getCurve))
    )

    #_public
    (ยง method #_"ECPoint" normalize []
        (.. this (get) (normalize))
    )

    #_public
    (ยง method #_"ECFieldElement" getY []
        (.. this (normalize) (getYCoord))
    )

    #_public
    (ยง method #_"ECPoint" twice []
        (.. this (get) (twice))
    )

    #_public
    (ยง method #_"ECFieldElement" getAffineYCoord []
        (.. this (get) (getAffineYCoord))
    )

    #_public
    (ยง method #_"ECFieldElement" getAffineXCoord []
        (.. this (get) (getAffineXCoord))
    )

    #_public
    (ยง method #_"ECFieldElement" getX []
        (.. this (normalize) (getXCoord))
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (Arrays/equals (.. this (getCanonicalEncoding)), (.. (cast LazyECPoint __o) (getCanonicalEncoding)))
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Arrays/hashCode (.. this (getCanonicalEncoding)))
    )

    #_private
    (ยง method- #_"byte[]" getCanonicalEncoding []
        (.. this (getEncoded true))
    )
)

;;;
 ; A MnemonicCode object may be used to convert between binary seed values and lists of words per
 ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">the BIP 39 specification</a>.
 ;;

#_public
(ยง class MnemonicCode
    #_private
    #_static
    (ยง def- #_"Logger" MnemonicCode/log (LoggerFactory/getLogger MnemonicCode))

    #_private
    (ยง field- #_"ArrayList<String>" :word-list)

    #_private
    #_static
    (ยง def- #_"String" MnemonicCode/BIP39_ENGLISH_RESOURCE_NAME "mnemonic/wordlist/english.txt")
    #_private
    #_static
    (ยง def- #_"String" MnemonicCode/BIP39_ENGLISH_SHA256 "ad90bf3beb7b0eb7e5acd74727dc0da96e0a280a258354e7293fb7e211ac03db")

    ;;; UNIX time for when the BIP39 standard was finalised.  This can be used as a default seed birthday. ;;
    #_public
    #_static
    (ยง def #_"long" MnemonicCode/BIP39_STANDARDISATION_TIME_SECS 1381276800)

    #_private
    #_static
    (ยง def- #_"int" MnemonicCode/PBKDF2_ROUNDS 2048)

    #_public
    #_static
    (ยง def #_"MnemonicCode" MnemonicCode/INSTANCE)

    #_static
    (ยง block
        (try
            (ยง ass MnemonicCode/INSTANCE (MnemonicCode.))
            (catch FileNotFoundException __e
                ;; We expect failure on Android.  The developer has to set INSTANCE themselves.
                (when (not (Utils/isAndroidRuntime))
                    (.. MnemonicCode/log (error "Could not find word list", __e))
                )
            )
            (catch IOException __e
                (.. MnemonicCode/log (error "Failed to load word list", __e))
            )
        )
    )

    ;;; Initialise from the included word list.  Won't work on Android. ;;
    #_public
    #_throws #_[ "IOException" ]
    (ยง constructor MnemonicCode []
        (ยง this (MnemonicCode/openDefaultWords), MnemonicCode/BIP39_ENGLISH_SHA256)
        this
    )

    #_private
    #_static
    #_throws #_[ "IOException" ]
    (ยง defn- #_"InputStream" MnemonicCode/openDefaultWords []
        (let [#_"InputStream" __stream (.. MnemonicCode (getResourceAsStream MnemonicCode/BIP39_ENGLISH_RESOURCE_NAME))]
            (when (nil? __stream)
                (throw (FileNotFoundException. MnemonicCode/BIP39_ENGLISH_RESOURCE_NAME))
            )
            __stream
        )
    )

    ;;;
     ; Creates an MnemonicCode object, initializing with words read from the supplied input stream.
     ; If a wordListDigest is supplied, the digest of the words will be checked.
     ;;
    #_public
    #_throws #_[ "IOException", "IllegalArgumentException" ]
    (ยง constructor MnemonicCode [#_"InputStream" __wordstream, #_"String" __wordListDigest]
        (let [#_"BufferedReader" __br (BufferedReader. (InputStreamReader. __wordstream, "UTF-8"))]
            (ยง assoc this :word-list (ArrayList. #_"<>" 2048))
            (let [#_"MessageDigest" __md (Sha256Hash/newDigest)
                  #_"String" __word]
                (while (some? (ยง ass __word (.. __br (readLine))))
                    (.. __md (update (.. __word (getBytes))))
                    (.. (:word-list this) (add __word))
                )
                (.. __br (close))

                (when (!= (.. (:word-list this) (size)) 2048)
                    (throw (IllegalArgumentException. "input stream did not contain 2048 words"))
                )

                ;; If a wordListDigest is supplied, check to make sure it matches.
                (when (some? __wordListDigest)
                    (let [#_"byte[]" __digest (.. __md (digest))
                          #_"String" __hexdigest (.. Utils/HEX (encode __digest))]
                        (when (not (.. __hexdigest (equals __wordListDigest)))
                            (throw (IllegalArgumentException. "wordlist digest mismatch"))
                        )
                    )
                )
                this
            )
        )
    )

    ;;;
     ; Gets the word list this code uses.
     ;;
    #_public
    (ยง method #_"List<String>" getWordList []
        (:word-list this)
    )

    ;;;
     ; Convert mnemonic word list to seed.
     ;;
    #_public
    #_static
    (ยง defn #_"byte[]" MnemonicCode/toSeed [#_"List<String>" __words, #_"String" __passphrase]
        ;; To create binary seed from mnemonic, we use PBKDF2 function with mnemonic sentence (in UTF-8) used as a password
        ;; and string "mnemonic" + passphrase (again in UTF-8) used as a salt.  Iteration count is set to 4096 and HMAC-SHA512
        ;; is used as a pseudo-random function.  Desired length of the derived key is 512 bits (= 64 bytes).

        (let [#_"String" __pass (.. Utils/SPACE_JOINER (join __words))
              #_"String" __salt (str "mnemonic" __passphrase)]

            (let [#_"Stopwatch" __watch (Stopwatch/createStarted)
                  #_"byte[]" __seed (PBKDF2SHA512/derive __pass, __salt, MnemonicCode/PBKDF2_ROUNDS, 64)]
                (.. __watch (stop))
                (.. MnemonicCode/log (info "PBKDF2 took {}", __watch))
                __seed
            )
        )
    )

    ;;;
     ; Convert mnemonic word list to original entropy value.
     ;;
    #_public
    #_throws #_[ "MnemonicException.MnemonicLengthException", "MnemonicException.MnemonicWordException", "MnemonicException.MnemonicChecksumException" ]
    (ยง method #_"byte[]" toEntropy [#_"List<String>" __words]
        (when (< 0 (% (.. __words (size)) 3))
            (throw (MnemonicException.MnemonicLengthException. "Word list size must be multiple of three words."))
        )

        (when (== (.. __words (size)) 0)
            (throw (MnemonicException.MnemonicLengthException. "Word list is empty."))
        )

        ;; Look up all the words in the list and construct the concatenation of the original entropy and the checksum.

        (let [#_"int" __concatLenBits (* (.. __words (size)) 11)
              #_"boolean[]" __concatBits (boolean-array __concatLenBits)
              #_"int" __wordindex 0]
            (doseq [#_"String" __word __words]
                ;; Find the words index in the wordlist.
                (let [#_"int" __ndx (Collections/binarySearch (:word-list this), __word)]
                    (when (< __ndx 0)
                        (throw (MnemonicException.MnemonicWordException. __word))
                    )

                    ;; Set the next 11 bits to the value of the index.
                    (loop-when-recur [#_"int" __i 0] (< __i 11) [(inc __i)]
                        (aset __concatBits (+ (* __wordindex 11) __i) (!= (& __ndx (<< 1 (- 10 __i))) 0))
                    )
                    (ยง ass __wordindex (inc __wordindex))
                )
            )

            (let [#_"int" __checksumLengthBits (/ __concatLenBits 33)
                  #_"int" __entropyLengthBits (- __concatLenBits __checksumLengthBits)]

                ;; Extract original entropy as bytes.
                (let [#_"byte[]" __entropy (byte-array (/ __entropyLengthBits 8))]
                    (loop-when-recur [#_"int" __i 0] (< __i (.. __entropy (alength))) [(inc __i)]
                        (loop-when-recur [#_"int" __j 0] (< __j 8) [(inc __j)]
                            (when (aget __concatBits (+ (* __i 8) __j))
                                (aset __entropy __i (| (aget __entropy __i) (<< 1 (- 7 __j))))
                            )
                        )
                    )

                    ;; Take the digest of the entropy.
                    (let [#_"byte[]" __hash (Sha256Hash/hash __entropy)
                          #_"boolean[]" __hashBits (MnemonicCode/bytesToBits __hash)]

                        ;; Check all the checksum bits.
                        (loop-when-recur [#_"int" __i 0] (< __i __checksumLengthBits) [(inc __i)]
                            (when (!= (aget __concatBits (+ __entropyLengthBits __i)) (aget __hashBits __i))
                                (throw (MnemonicException.MnemonicChecksumException.))
                            )
                        )

                        __entropy
                    )
                )
            )
        )
    )

    ;;;
     ; Convert entropy data to mnemonic word list.
     ;;
    #_public
    #_throws #_[ "MnemonicException.MnemonicLengthException" ]
    (ยง method #_"List<String>" toMnemonic [#_"byte[]" __entropy]
        (when (< 0 (% (.. __entropy (alength)) 4))
            (throw (MnemonicException.MnemonicLengthException. "Entropy length not multiple of 32 bits."))
        )

        (when (== (.. __entropy (alength)) 0)
            (throw (MnemonicException.MnemonicLengthException. "Entropy is empty."))
        )

        ;; We take initial entropy of ENT bits and compute its checksum by taking first ENT / 32 bits of its SHA256 hash.

        (let [#_"byte[]" __hash (Sha256Hash/hash __entropy)
              #_"boolean[]" __hashBits (MnemonicCode/bytesToBits __hash)]

            (let [#_"boolean[]" __entropyBits (MnemonicCode/bytesToBits __entropy)
                  #_"int" __checksumLengthBits (/ (.. __entropyBits (alength)) 32)]

                ;; We append these bits to the end of the initial entropy.
                (let [#_"boolean[]" __concatBits (boolean-array (+ (.. __entropyBits (alength)) __checksumLengthBits))]
                    (System/arraycopy __entropyBits, 0, __concatBits, 0, (.. __entropyBits (alength)))
                    (System/arraycopy __hashBits, 0, __concatBits, (.. __entropyBits (alength)), __checksumLengthBits)

                    ;; Next we take these concatenated bits and split them into groups of 11 bits.  Each group encodes number from 0-2047
                    ;; which is a position in a wordlist.  We convert numbers into words and use joined words as mnemonic sentence.

                    (let [#_"ArrayList<String>" __words (ArrayList. #_"<>")
                          #_"int" __nwords (/ (.. __concatBits (alength)) 11)]
                        (loop-when-recur [#_"int" __i 0] (< __i __nwords) [(inc __i)]
                            (let [#_"int" __index 0]
                                (loop-when-recur [#_"int" __j 0] (< __j 11) [(inc __j)]
                                    (ยง ass __index (<< __index 1))
                                    (when (aget __concatBits (+ (* __i 11) __j))
                                        (ยง ass __index (| __index 0x1))
                                    )
                                )
                                (.. __words (add (.. (:word-list this) (get __index))))
                            )
                        )

                        __words
                    )
                )
            )
        )
    )

    ;;;
     ; Check to see if a mnemonic word list is valid.
     ;;
    #_public
    #_throws #_[ "MnemonicException" ]
    (ยง method #_"void" check [#_"List<String>" __words]
        (.. this (toEntropy __words))
        nil
    )

    #_private
    #_static
    (ยง defn- #_"boolean[]" MnemonicCode/bytesToBits [#_"byte[]" __data]
        (let [#_"boolean[]" __bits (boolean-array (* (.. __data (alength)) 8))]
            (loop-when-recur [#_"int" __i 0] (< __i (.. __data (alength))) [(inc __i)]
                (loop-when-recur [#_"int" __j 0] (< __j 8) [(inc __j)]
                    (aset __bits (+ (* __i 8) __j) (!= (& (aget __data __i) (<< 1 (- 7 __j))) 0))
                )
            )
            __bits
        )
    )
)

;;;
 ; Exceptions thrown by the MnemonicCode module.
 ;;
#_public
(ยง class MnemonicException (ยง extends Exception)
    #_public
    (ยง constructor MnemonicException []
        (ยง super )
        this
    )

    #_public
    (ยง constructor MnemonicException [#_"String" __msg]
        (ยง super __msg)
        this
    )

    ;;;
     ; Thrown when an argument to MnemonicCode is the wrong length.
     ;;
    #_public
    #_static
    (ยง class MnemonicException.MnemonicLengthException (ยง extends MnemonicException)
        #_public
        (ยง constructor MnemonicException.MnemonicLengthException [#_"String" __msg]
            (ยง super __msg)
            this
        )
    )

    ;;;
     ; Thrown when a list of MnemonicCode words fails the checksum check.
     ;;
    #_public
    #_static
    (ยง class MnemonicException.MnemonicChecksumException (ยง extends MnemonicException)
        #_public
        (ยง constructor MnemonicException.MnemonicChecksumException []
            (ยง super )
            this
        )
    )

    ;;;
     ; Thrown when a word is encountered which is not in the MnemonicCode's word list.
     ;;
    #_public
    #_static
    (ยง class MnemonicException.MnemonicWordException (ยง extends MnemonicException)
        ;;; Contains the word that was not found in the word list. ;;
        #_public
        (ยง field #_"String" :bad-word)

        #_public
        (ยง constructor MnemonicException.MnemonicWordException [#_"String" __badWord]
            (ยง super )
            (ยง assoc this :bad-word __badWord)
            this
        )
    )
)

;;;
 ; This is a clean-room implementation of PBKDF2 using RFC 2898 as a reference.
 ;
 ; RFC 2898: http://tools.ietf.org/html/rfc2898#section-5.2
 ;
 ; This code passes all RFC 6070 test vectors: http://tools.ietf.org/html/rfc6070
 ;
 ; http://cryptofreek.org/2012/11/29/pbkdf2-pure-java-implementation/
 ; Modified to use SHA-512 - Ken Sedgwick ken@bonsai.com
 ;;
#_public
(ยง class PBKDF2SHA512
    #_public
    #_static
    (ยง defn #_"byte[]" PBKDF2SHA512/derive [#_"String" __P, #_"String" __S, #_"int" __c, #_"int" __dkLen]
        (let [#_"ByteArrayOutputStream" __baos (ByteArrayOutputStream.)]

            (try
                (let [#_"int" __hLen 20]

                    (when (< (* (dec (Math/pow 2, 32)) __hLen) __dkLen)
                        (throw (IllegalArgumentException. "derived key too long"))
                    )

                    (let [#_"int" __l (int (Math/ceil (/ (double __dkLen) (double __hLen))))]
                    ;; int r = dkLen - (l - 1) * hLen;

                        (loop-when-recur [#_"int" __i 1] (<= __i __l) [(inc __i)]
                            (let [#_"byte[]" __T (PBKDF2SHA512/F __P, __S, __c, __i)]
                                (.. __baos (write __T))
                            )
                        )
                    )
                )
                (catch Exception __e
                    (throw (RuntimeException. __e))
                )
            )

            (let [#_"byte[]" __baDerived (byte-array __dkLen)]
                (System/arraycopy (.. __baos (toByteArray)), 0, __baDerived, 0, (.. __baDerived (alength)))

                __baDerived
            )
        )
    )

    #_private
    #_static
    #_throws #_[ "Exception" ]
    (ยง defn- #_"byte[]" PBKDF2SHA512/F [#_"String" __P, #_"String" __S, #_"int" __c, #_"int" __i]
        (let [#_"byte[]" __U_LAST nil
              #_"byte[]" __U_XOR nil]

            (let [#_"SecretKeySpec" __key (SecretKeySpec. (.. __P (getBytes "UTF-8")), "HmacSHA512")
                  #_"Mac" __mac (Mac/getInstance (.. __key (getAlgorithm)))]
                (.. __mac (init __key))

                (loop-when-recur [#_"int" __j 0] (< __j __c) [(inc __j)]
                    (cond (== __j 0)
                        (do
                            (let [#_"byte[]" __baS (.. __S (getBytes "UTF-8"))
                                  #_"byte[]" __baI (PBKDF2SHA512/INT __i)
                                  #_"byte[]" __baU (byte-array (+ (.. __baS (alength)) (.. __baI (alength))))]

                                (System/arraycopy __baS, 0, __baU, 0, (.. __baS (alength)))
                                (System/arraycopy __baI, 0, __baU, (.. __baS (alength)), (.. __baI (alength)))

                                (ยง ass __U_XOR (.. __mac (doFinal __baU)))
                                (ยง ass __U_LAST __U_XOR)
                                (.. __mac (reset))
                            )
                        )
                        :else
                        (do
                            (let [#_"byte[]" __baU (.. __mac (doFinal __U_LAST))]
                                (.. __mac (reset))

                                (loop-when-recur [#_"int" __k 0] (< __k (.. __U_XOR (alength))) [(inc __k)]
                                    (aset __U_XOR __k (byte (bit-xor (aget __U_XOR __k) (aget __baU __k))))
                                )

                                (ยง ass __U_LAST __baU)
                            )
                        )
                    )
                )

                __U_XOR
            )
        )
    )

    #_private
    #_static
    (ยง defn- #_"byte[]" PBKDF2SHA512/INT [#_"int" __i]
        (let [#_"ByteBuffer" __bb (ByteBuffer/allocate 4)]
            (.. __bb (order ByteOrder/BIG_ENDIAN))
            (.. __bb (putInt __i))

            (.. __bb (array))
        )
    )
)

;;;
 ; A TransactionSignature wraps an {@link org.bitcoinj.core.ECKey.ECDSASignature} and adds methods for handling
 ; the additional SIGHASH mode byte that is used.
 ;;
#_public
(ยง class TransactionSignature (ยง extends ECKey.ECDSASignature)
    ;;;
     ; A byte that controls which parts of a transaction are signed.  This is exposed because signatures
     ; parsed off the wire may have sighash flags that aren't "normal" serializations of the enum values.
     ; Because Bitcoin Core works via bit testing, we must not lose the exact value when round-tripping
     ; otherwise we'll fail to verify signature hashes.
     ;;
    #_public
    (ยง field #_"int" :sighash-flags)

    ;;; Constructs a signature with the given components and SIGHASH_ALL. ;;
    #_public
    (ยง constructor TransactionSignature [#_"BigInteger" __r, #_"BigInteger" __s]
        (ยง this __r, __s, (:value Transaction.SigHash/ALL))
        this
    )

    ;;; Constructs a signature with the given components and raw sighash flag bytes (needed for rule compatibility). ;;
    #_public
    (ยง constructor TransactionSignature [#_"BigInteger" __r, #_"BigInteger" __s, #_"int" __sighashFlags]
        (ยง super __r, __s)
        (ยง assoc this :sighash-flags __sighashFlags)
        this
    )

    ;;; Constructs a transaction signature based on the ECDSA signature. ;;
    #_public
    (ยง constructor TransactionSignature [#_"ECKey.ECDSASignature" __signature, #_"Transaction.SigHash" __mode, #_"boolean" __anyoneCanPay]
        (ยง super (:r __signature), (:s __signature))
        (ยง assoc this :sighash-flags (TransactionSignature/calcSigHashValue __mode, __anyoneCanPay))
        this
    )

    ;;;
     ; Returns a dummy invalid signature whose R/S values are set such that they will take up the same number of
     ; encoded bytes as a real signature.  This can be useful when you want to fill out a transaction to be of
     ; the right size (e.g. for fee calculations) but don't have the requisite signing key yet and will fill out
     ; the real signature later.
     ;;
    #_public
    #_static
    (ยง defn #_"TransactionSignature" TransactionSignature/dummy []
        (let [#_"BigInteger" __val ECKey/HALF_CURVE_ORDER]
            (TransactionSignature. __val, __val)
        )
    )

    ;;; Calculates the byte used in the protocol to represent the combination of mode and anyoneCanPay. ;;
    #_public
    #_static
    (ยง defn #_"int" TransactionSignature/calcSigHashValue [#_"Transaction.SigHash" __mode, #_"boolean" __anyoneCanPay]
        ;; Enforce compatibility since this code was made before the SigHash enum was updated.
        (Preconditions/checkArgument (any == __mode Transaction.SigHash/ALL Transaction.SigHash/NONE Transaction.SigHash/SINGLE))

        (let [#_"int" __sighashFlags (:value __mode)]
            (when __anyoneCanPay
                (ยง ass __sighashFlags (| __sighashFlags (:value Transaction.SigHash/ANYONECANPAY)))
            )
            __sighashFlags
        )
    )

    ;;;
     ; Returns true if the given signature is has canonical encoding, and will thus be accepted as standard by
     ; Bitcoin Core.  DER and the SIGHASH encoding allow for quite some flexibility in how the same structures
     ; are encoded, and this can open up novel attacks in which a man in the middle takes a transaction and then
     ; changes its signature such that the transaction hash is different but it's still valid.  This can confuse
     ; wallets and generally violates people's mental model of how Bitcoin should work, thus non-canonical
     ; signatures are now not relayed by default.
     ;;
    #_public
    #_static
    (ยง defn #_"boolean" TransactionSignature/isEncodingCanonical [#_"byte[]" __signature]
        ;; See Bitcoin Core's IsCanonicalSignature, https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623
        ;; A canonical signature exists of: <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>
        ;; Where R and S are not negative (their first byte has its highest bit not set), and not
        ;; excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,
        ;; in which case a single 0 byte is necessary and even required).
        (when (not (<= 9 (.. __signature (alength)) 73))
            (ยง return false)
        )

        (let [#_"int" __hashType (& (& (aget __signature (dec (.. __signature (alength)))) 0xff) (bit-not (:value Transaction.SigHash/ANYONECANPAY)))] ;; mask the byte to prevent sign-extension hurting us
            (when (not (<= (:value Transaction.SigHash/ALL) __hashType (:value Transaction.SigHash/SINGLE)))
                (ยง return false)
            )

            ;;                   "wrong type"                  "wrong length marker"
            (when (or (!= (& 0xff (aget __signature 0)) 0x30) (!= (& 0xff (aget __signature 1)) (- (.. __signature (alength)) 3)))
                (ยง return false)
            )

            (let [#_"int" __lenR (& 0xff (aget __signature 3))]
                (when (or (<= (.. __signature (alength)) (+ 5 __lenR)) (== __lenR 0))
                    (ยง return false)
                )
                (let [#_"int" __lenS (& 0xff (aget __signature (+ 5 __lenR)))]
                    (when (or (!= (+ __lenR __lenS 7) (.. __signature (alength))) (== __lenS 0))
                        (ยง return false)
                    )

                    ;;    R value type mismatch          R value negative
                    (when (or (!= (aget __signature (- 4 2)) 0x02) (== (& 0x80 (aget __signature 4)) 0x80))
                        (ยง return false)
                    )
                    (when (and (< 1 __lenR) (== (aget __signature 4) 0x00) (!= (& 0x80 (aget __signature (+ 4 1))) 0x80))
                        (ยง return false) ;; R value excessively padded
                    )

                    ;;       S value type mismatch                    S value negative
                    (when (or (!= (aget __signature (+ 6 __lenR -2)) 0x02) (== (& 0x80 (aget __signature (+ 6 __lenR))) 0x80))
                        (ยง return false)
                    )
                    (when (and (< 1 __lenS) (== (aget __signature (+ 6 __lenR)) 0x00) (!= (& 0x80 (aget __signature (+ 6 __lenR 1))) 0x80))
                        (ยง return false) ;; S value excessively padded
                    )

                    true
                )
            )
        )
    )

    #_public
    (ยง method #_"boolean" anyoneCanPay []
        (!= (& (:sighash-flags this) (:value Transaction.SigHash/ANYONECANPAY)) 0)
    )

    #_public
    (ยง method #_"Transaction.SigHash" sigHashMode []
        (let [#_"int" __mode (& (:sighash-flags this) 0x1f)]

            (when (== __mode (:value Transaction.SigHash/NONE))
                (ยง return Transaction.SigHash/NONE)
            )
            (when (== __mode (:value Transaction.SigHash/SINGLE))
                (ยง return Transaction.SigHash/SINGLE)
            )

            Transaction.SigHash/ALL
        )
    )

    ;;;
     ; What we get back from the signer are the two components of a signature, r and s.  To get a flat byte stream
     ; of the type used by Bitcoin we have to encode them using DER encoding, which is just a way to pack the two
     ; components into a structure, and then we append a byte to the end for the sighash flags.
     ;;
    #_public
    (ยง method #_"byte[]" encodeToBitcoin []
        (try
            (let [#_"ByteArrayOutputStream" __bos (.. this (derByteStream))]
                (.. __bos (write (:sighash-flags this)))
                (ยง return (.. __bos (toByteArray)))
            )
            (catch IOException __e
                (throw (RuntimeException. __e)) ;; Cannot happen.
            )
        )
    )

    #_override
    #_public
    (ยง method #_"ECKey.ECDSASignature" toCanonicalised []
        (TransactionSignature. (.. super (toCanonicalised)), (.. this (sigHashMode)), (.. this (anyoneCanPay)))
    )

    ;;;
     ; Returns a decoded signature.
     ;
     ; @param requireCanonicalEncoding if the encoding of the signature must be canonical.
     ; @throws RuntimeException if the signature is invalid or unparseable in some way.
     ; @deprecated use {@link #decodeFromBitcoin(byte[], boolean, boolean)} instead.
     ;;
    #_deprecated
    #_public
    #_static
    #_throws #_[ "VerificationException" ]
    (ยง defn #_"TransactionSignature" TransactionSignature/decodeFromBitcoin [#_"byte[]" __bytes, #_"boolean" __requireCanonicalEncoding]
        (TransactionSignature/decodeFromBitcoin __bytes, __requireCanonicalEncoding, false)
    )

    ;;;
     ; Returns a decoded signature.
     ;
     ; @param requireCanonicalEncoding if the encoding of the signature must be canonical.
     ; @param requireCanonicalSValue if the S-value must be canonical (below half the order of the curve).
     ; @throws RuntimeException if the signature is invalid or unparseable in some way.
     ;;
    #_public
    #_static
    #_throws #_[ "VerificationException" ]
    (ยง defn #_"TransactionSignature" TransactionSignature/decodeFromBitcoin [#_"byte[]" __bytes, #_"boolean" __requireCanonicalEncoding, #_"boolean" __requireCanonicalSValue]
        ;; Bitcoin encoding is DER signature + sighash byte.
        (when (and __requireCanonicalEncoding (not (TransactionSignature/isEncodingCanonical __bytes)))
            (throw (VerificationException. "Signature encoding is not canonical."))
        )

        (let [#_"ECKey.ECDSASignature" __sig]
            (try
                (ยง ass __sig (ECKey.ECDSASignature/decodeFromDER __bytes))
                (catch IllegalArgumentException __e
                    (throw (VerificationException. "Could not decode DER", __e))
                )
            )
            (when (and __requireCanonicalSValue (not (.. __sig (isCanonical))))
                (throw (VerificationException. "S-value is not canonical."))
            )

            ;; In Bitcoin, any value of the final byte is valid, but not necessarily canonical.  See javadocs
            ;; for isEncodingCanonical to learn more about this.  So we must store the exact byte found.
            (TransactionSignature. (:r __sig), (:s __sig), (aget __bytes (dec (.. __bytes (alength)))))
        )
    )
)

#_(ns org.bitcoinj.kits #_"WalletAppKit"
    (:import [java.io *]
             [java.net *]
             [java.nio.channels *]
             [java.util *]
             [java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect *]
             [com.google.common.util.concurrent *]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core.listeners *]
             [org.bitcoinj.core *]
             [org.bitcoinj.net.discovery *]
             [org.bitcoinj.store *]
             [org.bitcoinj.wallet *]))

;;;
 ; <p>Utility class that wraps the boilerplate needed to set up a new SPV bitcoinj app.  Instantiate it with a directory
 ; and file prefix, optionally configure a few things, then use startAsync and optionally awaitRunning.  The object will
 ; construct and configure a {@link BlockChain}, {@link SPVBlockStore}, {@link Wallet} and {@link PeerGroup}.  Depending
 ; on the value of the blockingStartup property, startup will be considered complete once the block chain has fully
 ; synchronized, so it can take a while.</p>
 ;
 ; <p>To add listeners and modify the objects that are constructed, you can either do that by overriding the
 ; {@link #onSetupCompleted()} method (which will run on a background thread) and make your changes there,
 ; or by waiting for the service to start and then accessing the objects from wherever you want.  However, you cannot
 ; access the objects this class creates until startup is complete.</p>
 ;
 ; <p>The asynchronous design of this class may seem puzzling (just use {@link #awaitRunning()} if you don't want that).
 ; It is to make it easier to fit bitcoinj into GUI apps, which require a high degree of responsiveness on their main
 ; thread which handles all the animation and user interaction.  Even when blockingStart is false, initializing bitcoinj
 ; means doing potentially blocking file IO, generating keys and other potentially intensive operations.  By running it
 ; on a background thread, there's no risk of accidentally causing UI lag.</p>
 ;
 ; <p>Note that {@link #awaitRunning()} can throw an unchecked {@link java.lang.IllegalStateException}
 ; if anything goes wrong during startup - you should probably handle it and use {@link Exception#getCause()} to figure
 ; out what went wrong more precisely.  Same thing if you just use the {@link #startAsync()} method.</p>
 ;;
#_public
(ยง class WalletAppKit (ยง extends AbstractIdleService)
    #_protected
    #_static
    (ยง def #_"Logger" WalletAppKit/log (LoggerFactory/getLogger WalletAppKit))

    #_protected
    (ยง field #_"String" :file-prefix)
    #_protected
    (ยง field #_"NetworkParameters" :params)
    #_protected
    #_volatile
    (ยง field #_"BlockChain" :v-chain)
    #_protected
    #_volatile
    (ยง field #_"BlockStore" :v-store)
    #_protected
    #_volatile
    (ยง field #_"Wallet" :v-wallet)
    #_protected
    #_volatile
    (ยง field #_"PeerGroup" :v-peer-group)

    #_protected
    (ยง field #_"File" :directory)
    #_protected
    #_volatile
    (ยง field #_"File" :v-wallet-file)

    #_protected
    (ยง field #_"boolean" :use-auto-save true)
    #_protected
    (ยง field #_"PeerAddress[]" :peer-addresses)
    #_protected
    (ยง field #_"DownloadProgressTracker" :download-listener)
    #_protected
    (ยง field #_"boolean" :auto-stop true)
    #_protected
    (ยง field #_"InputStream" :checkpoints)
    #_protected
    (ยง field #_"boolean" :blocking-startup true)
    #_protected
    (ยง field #_"String" :user-agent)
    #_protected
    (ยง field #_"String" :version)
    #_protected
    (ยง field #_"WalletProtobufSerializer.WalletFactory" :wallet-factory)
    #_nilable
    #_protected
    (ยง field #_"DeterministicSeed" :restore-from-seed)
    #_nilable
    #_protected
    (ยง field #_"PeerDiscovery" :discovery)

    #_protected
    #_volatile
    (ยง field #_"Context" :context)

    ;;;
     ; Creates a new WalletAppKit, with a newly created {@link Context}.  Files will be stored in the given directory.
     ;;
    #_public
    (ยง constructor WalletAppKit [#_"NetworkParameters" __params, #_"File" __directory, #_"String" __filePrefix]
        (ยง this (Context. __params), __directory, __filePrefix)
        this
    )

    ;;;
     ; Creates a new WalletAppKit, with the given {@link Context}.  Files will be stored in the given directory.
     ;;
    #_public
    (ยง constructor WalletAppKit [#_"Context" __context, #_"File" __directory, #_"String" __filePrefix]
        (ยง assoc this :context __context)
        (ยง assoc this :params (Preconditions/checkNotNull (.. __context (getParams))))
        (ยง assoc this :directory (Preconditions/checkNotNull __directory))
        (ยง assoc this :file-prefix (Preconditions/checkNotNull __filePrefix))
        this
    )

    ;;; Will only connect to the given addresses.  Cannot be called after startup. ;;
    #_public
    (ยง method #_"WalletAppKit" setPeerNodes [#_"PeerAddress..." __addresses]
        (Preconditions/checkState (== (state) BasicKeyChain.State/NEW), "Cannot call after startup")
        (ยง assoc this :peer-addresses __addresses)
        this
    )

    ;;; Will only connect to localhost.  Cannot be called after startup. ;;
    #_public
    (ยง method #_"WalletAppKit" connectToLocalHost []
        (try
            (let [#_"InetAddress" __localHost (InetAddress/getLocalHost)]
                (ยง return (.. this (setPeerNodes (PeerAddress. (:params this), __localHost, (.. (:params this) (getPort))))))
            )
            (catch UnknownHostException __e
                ;; Borked machine with no loopback adapter configured properly.
                (throw (RuntimeException. __e))
            )
        )
    )

    ;;; If true, the wallet will save itself to disk automatically whenever it changes. ;;
    #_public
    (ยง method #_"WalletAppKit" setAutoSave [#_"boolean" __value]
        (Preconditions/checkState (== (state) BasicKeyChain.State/NEW), "Cannot call after startup")
        (ยง assoc this :use-auto-save __value)
        this
    )

    ;;;
     ; If you want to learn about the sync process, you can provide a listener here.  For instance,
     ; a {@link org.bitcoinj.core.DownloadProgressTracker} is a good choice.  This has no effect unless
     ; setBlockingStartup(false) has been called too, due to some missing implementation code.
     ;;
    #_public
    (ยง method #_"WalletAppKit" setDownloadListener [#_"DownloadProgressTracker" __listener]
        (ยง assoc this :download-listener __listener)
        this
    )

    ;;; If true, will register a shutdown hook to stop the library.  Defaults to true. ;;
    #_public
    (ยง method #_"WalletAppKit" setAutoStop [#_"boolean" __autoStop]
        (ยง assoc this :auto-stop __autoStop)
        this
    )

    ;;;
     ; If set, the file is expected to contain a checkpoints file calculated with BuildCheckpoints.
     ; It makes initial block sync faster for new users - please refer to the documentation on the
     ; bitcoinj website (https://bitcoinj.github.io/speeding-up-chain-sync) for further details.
     ;;
    #_public
    (ยง method #_"WalletAppKit" setCheckpoints [#_"InputStream" __checkpoints]
        (when (some? (:checkpoints this))
            (Utils/closeUnchecked (:checkpoints this))
        )
        (ยง assoc this :checkpoints (Preconditions/checkNotNull __checkpoints))
        this
    )

    ;;;
     ; If true (the default) then the startup of this service won't be considered complete until the network has been
     ; brought up, peer connections established and the block chain synchronised.  Therefore {@link #awaitRunning()} can
     ; potentially take a very long time.  If false, then startup is considered complete once the network activity
     ; begins and peer connections/block chain sync will continue in the background.
     ;;
    #_public
    (ยง method #_"WalletAppKit" setBlockingStartup [#_"boolean" __blockingStartup]
        (ยง assoc this :blocking-startup __blockingStartup)
        this
    )

    ;;;
     ; Sets the string that will appear in the subver field of the version message.
     ; @param userAgent A short string that should be the name of your app, e.g. "My Wallet".
     ; @param version A short string that contains the version number, e.g. "1.0-BETA".
     ;;
    #_public
    (ยง method #_"WalletAppKit" setUserAgent [#_"String" __userAgent, #_"String" __version]
        (ยง assoc this :user-agent (Preconditions/checkNotNull __userAgent))
        (ยง assoc this :version (Preconditions/checkNotNull __version))
        this
    )

    ;;;
     ; Sets a wallet factory which will be used when the kit creates a new wallet.
     ;;
    #_public
    (ยง method #_"WalletAppKit" setWalletFactory [#_"WalletProtobufSerializer.WalletFactory" __walletFactory]
        (ยง assoc this :wallet-factory __walletFactory)
        this
    )

    ;;;
     ; If a seed is set here then any existing wallet that matches the file name will be renamed to a backup name,
     ; the chain file will be deleted, and the wallet object will be instantiated with the given seed instead of
     ; a fresh one being created.  This is intended for restoring a wallet from the original seed.  To implement
     ; restore, you would shut down the existing appkit, if any, then recreate it with the seed given by the user,
     ; then start up the new kit.  The next time your app starts it should work as normal (that is, don't keep
     ; calling this each time).
     ;;
    #_public
    (ยง method #_"WalletAppKit" restoreWalletFromSeed [#_"DeterministicSeed" __seed]
        (ยง assoc this :restore-from-seed __seed)
        this
    )

    ;;;
     ; Sets the peer discovery class to use.  If none is provided then DNS is used, which is a reasonable default.
     ;;
    #_public
    (ยง method #_"WalletAppKit" setDiscovery [#_nilable #_"PeerDiscovery" __discovery]
        (ยง assoc this :discovery __discovery)
        this
    )

    ;;;
     ; Override this to use a {@link BlockStore} that isn't the default of {@link SPVBlockStore}.
     ;;
    #_protected
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"BlockStore" provideBlockStore [#_"File" __file]
        (SPVBlockStore. (:params this), __file)
    )

    ;;;
     ; This method is invoked on a background thread after all objects are initialised, but before the peer group
     ; or block chain download is started.  You can tweak the objects configuration here.
     ;;
    #_protected
    (ยง method #_"void" onSetupCompleted []
        nil
    )

    ;;;
     ; Tests to see if the spvchain file has an operating system file lock on it.  Useful for checking if your app
     ; is already running.  If another copy of your app is running and you start the appkit anyway, an exception will
     ; be thrown during the startup process.  Returns false if the chain file does not exist or is a directory.
     ;;
    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"boolean" isChainFileLocked []
        (let [#_"RandomAccessFile" __file2 nil]
            (try
                (let [#_"File" __file (File. (:directory this), (str (:file-prefix this) ".spvchain"))]
                    (when (not (.. __file (exists)))
                        (ยง return false)
                    )
                    (when (.. __file (isDirectory))
                        (ยง return false)
                    )
                    (ยง ass __file2 (RandomAccessFile. __file, "rw"))
                    (let [#_"FileLock" __lock (.. __file2 (getChannel) (tryLock))]
                        (when (nil? __lock)
                            (ยง return true)
                        )
                        (.. __lock (release))
                        (ยง return false)
                    )
                )
                (finally
                    (when (some? __file2)
                        (.. __file2 (close))
                    )
                )
            )
        )
    )

    #_override
    #_protected
    #_throws #_[ "Exception" ]
    (ยง method #_"void" startUp []
        ;; Runs in a separate thread.
        (Context/propagate (:context this))
        (when (and (not (.. (:directory this) (exists))) (not (.. (:directory this) (mkdirs))))
            (throw (IOException. (str "Could not create directory " (.. (:directory this) (getAbsolutePath)))))
        )

        (.. WalletAppKit/log (info "Starting up with directory = {}", (:directory this)))
        (try
            (let [#_"File" __chainFile (File. (:directory this), (str (:file-prefix this) ".spvchain"))
                  #_"boolean" __chainFileExists (.. __chainFile (exists))]
                (ยง assoc this :v-wallet-file (File. (:directory this), (str (:file-prefix this) ".wallet")))
                (let [#_"boolean" __shouldReplayWallet (or (and (.. (:v-wallet-file this) (exists)) (not __chainFileExists)) (some? (:restore-from-seed this)))]
                    (ยง assoc this :v-wallet (.. this (createOrLoadWallet __shouldReplayWallet)))

                    ;; Initiate Bitcoin network objects (block store, blockchain and peer group).
                    (ยง assoc this :v-store (.. this (provideBlockStore __chainFile)))
                    (when (or (not __chainFileExists) (some? (:restore-from-seed this)))
                        (when (and (nil? (:checkpoints this)) (not (Utils/isAndroidRuntime)))
                            (ยง assoc this :checkpoints (CheckpointManager/openStream (:params this)))
                        )

                        (cond (some? (:checkpoints this))
                            (do
                                ;; Initialize the chain file with a checkpoint to speed up first-run sync.
                                (let [#_"long" __time]
                                    (cond (some? (:restore-from-seed this))
                                        (do
                                            (ยง ass __time (.. (:restore-from-seed this) (getCreationTimeSeconds)))
                                            (when __chainFileExists
                                                (.. WalletAppKit/log (info "Deleting the chain file in preparation from restore."))
                                                (.. (:v-store this) (close))
                                                (when (not (.. __chainFile (delete)))
                                                    (throw (IOException. "Failed to delete chain file in preparation for restore."))
                                                )

                                                (ยง assoc this :v-store (SPVBlockStore. (:params this), __chainFile))
                                            )
                                        )
                                        :else
                                        (do
                                            (ยง ass __time (.. (:v-wallet this) (getEarliestKeyCreationTime)))
                                        )
                                    )
                                    (if (< 0 __time)
                                        (CheckpointManager/checkpoint (:params this), (:checkpoints this), (:v-store this), __time)
                                        (.. WalletAppKit/log (warn "Creating a new uncheckpointed block store due to a wallet with a creation time of zero: this will result in a very slow chain sync"))
                                    )
                                )
                            )
                            __chainFileExists
                            (do
                                (.. WalletAppKit/log (info "Deleting the chain file in preparation from restore."))
                                (.. (:v-store this) (close))
                                (when (not (.. __chainFile (delete)))
                                    (throw (IOException. "Failed to delete chain file in preparation for restore."))
                                )

                                (ยง assoc this :v-store (SPVBlockStore. (:params this), __chainFile))
                            )
                        )
                    )
                    (ยง assoc this :v-chain (BlockChain. (:params this), (:v-store this)))
                    (ยง assoc this :v-peer-group (.. this (createPeerGroup)))
                    (when (some? (:user-agent this))
                        (.. (:v-peer-group this) (setUserAgent (:user-agent this), (:version this)))
                    )

                    ;; Set up peer addresses or discovery first, so if wallet extensions try to broadcast a transaction
                    ;; before we're actually connected the broadcast waits for an appropriate number of connections.
                    (cond (some? (:peer-addresses this))
                        (do
                            (doseq [#_"PeerAddress" __addr (:peer-addresses this)]
                                (.. (:v-peer-group this) (addAddress __addr))
                            )
                            (.. (:v-peer-group this) (setMaxConnections (.. (:peer-addresses this) (alength))))
                            (ยง assoc this :peer-addresses nil)
                        )
                        :else
                        (do
                            (.. (:v-peer-group this) (addPeerDiscovery (or (:discovery this) (DnsDiscovery. (:params this)))))
                        )
                    )
                    (.. (:v-chain this) (addWallet (:v-wallet this)))
                    (.. (:v-peer-group this) (addWallet (:v-wallet this)))
                    (.. this (onSetupCompleted))

                    (cond (:blocking-startup this)
                        (do
                            (.. (:v-peer-group this) (start))
                            ;; Make sure we shut down cleanly.
                            (.. this (installShutdownHook))

                            ;; TODO: Be able to use the provided download listener when doing a blocking startup.
                            (let [#_"DownloadProgressTracker" __listener (DownloadProgressTracker.)]
                                (.. (:v-peer-group this) (startBlockChainDownload __listener))
                                (.. __listener (await))
                            )
                        )
                        :else
                        (do
                            (Futures/addCallback (.. (:v-peer-group this) (startAsync)), (FutureCallback.)
                            (ยง anon
                                #_override
                                #_public
                                (ยง method #_"void" onSuccess [#_nilable #_"Object" __result]
                                    (let [#_"DownloadProgressTracker" __l (or (:download-listener this) (DownloadProgressTracker.))]
                                        (.. (:v-peer-group this) (startBlockChainDownload __l))
                                        nil
                                    )
                                )

                                #_override
                                #_public
                                (ยง method #_"void" onFailure [#_"Throwable" __t]
                                    (throw (RuntimeException. __t))
                                )
                            ))
                        )
                    )
                )
            )
            (catch BlockStoreException __e
                (throw (IOException. __e))
            )
        )
        nil
    )

    #_private
    #_throws #_[ "Exception" ]
    (ยง method- #_"Wallet" createOrLoadWallet [#_"boolean" __shouldReplayWallet]
        (let [#_"Wallet" __wallet]

            (.. this (maybeMoveOldWalletOutOfTheWay))

            (cond (.. (:v-wallet-file this) (exists))
                (do
                    (ยง ass __wallet (.. this (loadWallet __shouldReplayWallet)))
                )
                :else
                (do
                    (ยง ass __wallet (.. this (createWallet)))
                    (.. __wallet (freshReceiveKey))

                    ;; Currently the only way we can be sure that an extension is aware of its containing wallet is
                    ;; by deserializing the extension.
                    ;; Hence, we first save and then load wallet to ensure any extensions are correctly initialized.
                    (.. __wallet (saveToFile (:v-wallet-file this)))
                    (ยง ass __wallet (.. this (loadWallet false)))
                )
            )

            (when (:use-auto-save this)
                (.. this (setupAutoSave __wallet))
            )

            __wallet
        )
    )

    #_protected
    (ยง method #_"void" setupAutoSave [#_"Wallet" __wallet]
        (.. __wallet (autosaveToFile (:v-wallet-file this), 5, TimeUnit/SECONDS, nil))
        nil
    )

    #_private
    #_throws #_[ "Exception" ]
    (ยง method- #_"Wallet" loadWallet [#_"boolean" __shouldReplayWallet]
        (let [#_"Wallet" __wallet
              #_"FileInputStream" __walletStream (FileInputStream. (:v-wallet-file this))]
            (try
                (let [#_"Protos.Wallet" __proto (WalletProtobufSerializer/parseToProto __walletStream)
                      #_"WalletProtobufSerializer" __serializer]
                    (if (some? (:wallet-factory this))
                        (ยง ass __serializer (WalletProtobufSerializer. (:wallet-factory this)))
                        (ยง ass __serializer (WalletProtobufSerializer.))
                    )
                    (ยง ass __wallet (.. __serializer (readWallet (:params this), __proto)))
                    (when __shouldReplayWallet
                        (.. __wallet (reset))
                    )
                )
                (finally
                    (.. __walletStream (close))
                )
            )
            __wallet
        )
    )

    #_protected
    (ยง method #_"Wallet" createWallet []
        (let [#_"KeyChainGroup" __kcg]
            (if (some? (:restore-from-seed this))
                (ยง ass __kcg (KeyChainGroup. (:params this), (:restore-from-seed this)))
                (ยง ass __kcg (KeyChainGroup. (:params this)))
            )
            (if (some? (:wallet-factory this)) (.. (:wallet-factory this) (create (:params this), __kcg)) (Wallet. (:params this), __kcg)) ;; default
        )
    )

    #_private
    (ยง method- #_"void" maybeMoveOldWalletOutOfTheWay []
        (when (nil? (:restore-from-seed this))
            (ยง return nil)
        )
        (when (not (.. (:v-wallet-file this) (exists)))
            (ยง return nil)
        )

        (let [#_"int" __counter 1
              #_"File" __newName]
            (ยง repeat
                (ยง ass __newName (File. (.. (:v-wallet-file this) (getParent)), (str "Backup " __counter " for " (.. (:v-wallet-file this) (getName)))))
                (ยง ass __counter (inc __counter))
                (ยง again (.. __newName (exists)))
            )

            (.. WalletAppKit/log (info "Renaming old wallet file {} to {}", (:v-wallet-file this), __newName))

            ;; This should not happen unless something is really messed up.
            (when (not (.. (:v-wallet-file this) (renameTo __newName)))
                (throw (RuntimeException. "Failed to rename wallet for restore"))
            )
            nil
        )
    )

    #_protected
    #_throws #_[ "TimeoutException" ]
    (ยง method #_"PeerGroup" createPeerGroup []
        (PeerGroup. (:params this), (:v-chain this))
    )

    #_private
    (ยง method- #_"void" installShutdownHook []
        (when (:auto-stop this)
            (.. (Runtime/getRuntime) (addShutdownHook (Thread.)
            (ยง anon
                #_override
                #_public
                (ยง method #_"void" run []
                    (try
                        (.. (ยง dhis WalletAppKit) (stopAsync))
                        (.. (ยง dhis WalletAppKit) (awaitTerminated))
                        (catch Exception __e
                            (throw (RuntimeException. __e))
                        )
                    )
                    nil
                )
            )))
        )
        nil
    )

    #_override
    #_protected
    #_throws #_[ "Exception" ]
    (ยง method #_"void" shutDown []
        ;; Runs in a separate thread.
        (try
            (Context/propagate (:context this))
            (.. (:v-peer-group this) (stop))
            (.. (:v-wallet this) (saveToFile (:v-wallet-file this)))
            (.. (:v-store this) (close))

            (ยง assoc this :v-peer-group nil)
            (ยง assoc this :v-wallet nil)
            (ยง assoc this :v-store nil)
            (ยง assoc this :v-chain nil)
            (catch BlockStoreException __e
                (throw (IOException. __e))
            )
        )
        nil
    )

    #_public
    (ยง method #_"NetworkParameters" params []
        (:params this)
    )

    #_public
    (ยง method #_"BlockChain" chain []
        (Preconditions/checkState (any == (state) BasicKeyChain.State/STARTING BasicKeyChain.State/RUNNING), "Cannot call until startup is complete")
        (:v-chain this)
    )

    #_public
    (ยง method #_"BlockStore" store []
        (Preconditions/checkState (any == (state) BasicKeyChain.State/STARTING BasicKeyChain.State/RUNNING), "Cannot call until startup is complete")
        (:v-store this)
    )

    #_public
    (ยง method #_"Wallet" wallet []
        (Preconditions/checkState (any == (state) BasicKeyChain.State/STARTING BasicKeyChain.State/RUNNING), "Cannot call until startup is complete")
        (:v-wallet this)
    )

    #_public
    (ยง method #_"PeerGroup" peerGroup []
        (Preconditions/checkState (any == (state) BasicKeyChain.State/STARTING BasicKeyChain.State/RUNNING), "Cannot call until startup is complete")
        (:v-peer-group this)
    )

    #_public
    (ยง method #_"File" directory []
        (:directory this)
    )
)

#_(ns org.bitcoinj.net #_"AbstractTimeoutHandler"
    (:import [java.util Timer TimerTask]))

#_(ns org.bitcoinj.net #_"BlockingClient"
    (:import [java.io *]
             [java.net *]
             [java.nio *]
             [java.util *]
             [javax.net *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.util.concurrent *]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]))

#_(ns org.bitcoinj.net #_"BlockingClientManager"
    (:import [java.io IOException]
             [java.net SocketAddress]
             [java.util Collections HashSet Iterator Set]
             [javax.net SocketFactory])
    (:import [com.google.common.base Preconditions]
             [com.google.common.util.concurrent AbstractIdleService ListenableFuture]))

#_(ns org.bitcoinj.net #_"ClientConnectionManager"
    (:import [java.net SocketAddress])
    (:import [com.google.common.util.concurrent ListenableFuture Service]))

#_(ns org.bitcoinj.net #_"ConnectionHandler"
    (:import [java.io IOException]
             [java.nio ByteBuffer]
             [java.nio.channels CancelledKeyException SelectionKey SocketChannel]
             [java.util Arrays Iterator LinkedList Set]
             [java.util.concurrent.locks ReentrantLock]
             [javax.annotation.concurrent GuardedBy])
    (:import [com.google.common.base Preconditions Throwables]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core Message]
             [org.bitcoinj.utils Threading]))

#_(ns org.bitcoinj.net #_"FilterMerger"
    (:import [java.util LinkedList])
    (:import [com.google.common.collect ImmutableList Lists])
   (:require [org.bitcoinj.core BloomFilter PeerFilterProvider]))

#_(ns org.bitcoinj.net #_"MessageWriteTarget"
    (:import [java.io IOException]))

#_(ns org.bitcoinj.net #_"NioClient"
    (:import [java.io *]
             [java.net *]
             [java.nio *])
    (:import [com.google.common.base *]
             [com.google.common.util.concurrent *]
             [org.slf4j Logger LoggerFactory]))

#_(ns org.bitcoinj.net #_"NioClientManager"
    (:import [java.io IOException]
             [java.net ConnectException SocketAddress]
             [java.nio.channels *]
             [java.nio.channels.spi SelectorProvider]
             [java.util *]
             [java.util.concurrent *])
    (:import [com.google.common.base Throwables]
             [com.google.common.util.concurrent *]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.utils *]))

#_(ns org.bitcoinj.net #_"NioServer"
    (:import [java.io IOException]
             [java.net InetSocketAddress]
             [java.nio.channels *]
             [java.nio.channels.spi SelectorProvider]
             [java.util Iterator])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base Throwables]
             [com.google.common.util.concurrent AbstractExecutionThreadService]
             [org.slf4j Logger LoggerFactory]))

#_(ns org.bitcoinj.net #_"ProtobufConnection"
    (:import [java.io IOException]
             [java.nio ByteBuffer ByteOrder]
             [java.util.concurrent.atomic AtomicReference]
             [java.util.concurrent.locks ReentrantLock]
             [javax.annotation.concurrent GuardedBy])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base Preconditions]
             [com.google.protobuf ByteString MessageLite]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core Utils]
             [org.bitcoinj.utils Threading]))

#_(ns org.bitcoinj.net #_"StreamConnection"
    (:import [java.nio ByteBuffer]))

#_(ns org.bitcoinj.net #_"StreamConnectionFactory"
    (:import [java.net InetAddress]))

;;;
 ; <p>A base class which provides basic support for socket timeouts.  It is used instead of integrating timeouts into the
 ; NIO select thread both for simplicity and to keep code shared between NIO and blocking sockets as much as possible.
 ; </p>
 ;;
#_public
#_abstract
(ยง class AbstractTimeoutHandler
    ;; TimerTask and timeout value which are added to a timer to kill the connection on timeout.
    #_private
    (ยง field- #_"TimerTask" :timeout-task)
    #_private
    (ยง field- #_"long" :timeout-millis 0)
    #_private
    (ยง field- #_"boolean" :timeout-enabled true)

    ;; A timer which manages expiring channels as their timeouts occur (if configured).
    #_private
    #_static
    (ยง def- #_"Timer" AbstractTimeoutHandler/TIMEOUT_TIMER (Timer. "AbstractTimeoutHandler timeouts", true))

    ;;;
     ; <p>Enables or disables the timeout entirely.  This may be useful if you want to store the timeout value
     ; but wish to temporarily disable/enable timeouts.</p>
     ;
     ; <p>The default is for timeoutEnabled to be true but timeoutMillis to be set to 0 (i.e. disabled).</p>
     ;
     ; <p>This call will reset the current progress towards the timeout.</p>
     ;;
    #_public
    #_synchronized
    (ยง method #_"void" setTimeoutEnabled [#_"boolean" __timeoutEnabled]
        (ยง assoc this :timeout-enabled __timeoutEnabled)
        (.. this (resetTimeout))
        nil
    )

    ;;;
     ; <p>Sets the receive timeout to the given number of milliseconds, automatically killing the connection
     ; if no messages are received for this long.</p>
     ;
     ; <p>A timeout of 0 is interpreted as no timeout.</p>
     ;
     ; <p>The default is for timeoutEnabled to be true but timeoutMillis to be set to 0 (i.e. disabled).</p>
     ;
     ; <p>This call will reset the current progress towards the timeout.</p>
     ;;
    #_public
    #_synchronized
    (ยง method #_"void" setSocketTimeout [#_"int" __timeoutMillis]
        (ยง assoc this :timeout-millis __timeoutMillis)
        (.. this (resetTimeout))
        nil
    )

    ;;;
     ; Resets the current progress towards timeout to 0.
     ;;
    #_protected
    #_synchronized
    (ยง method #_"void" resetTimeout []
        (when (some? (:timeout-task this))
            (.. (:timeout-task this) (cancel))
        )
        (when (or (== (:timeout-millis this) 0) (not (:timeout-enabled this)))
            (ยง return nil)
        )

        (ยง assoc this :timeout-task (TimerTask.
        (ยง anon
            #_override
            #_public
            (ยง method #_"void" run []
                (.. this (timeoutOccurred))
                nil
            )
        )))
        (.. AbstractTimeoutHandler/TIMEOUT_TIMER (schedule (:timeout-task this), (:timeout-millis this)))
        nil
    )

    #_protected
    #_abstract
    (ยง method #_"void" timeoutOccurred [])
)

;;;
 ; <p>Creates a simple connection to a server using a {@link StreamConnection} to process data.</p>
 ;
 ; <p>Generally, using {@link NioClient} and {@link NioClientManager} should be preferred over {@link BlockingClient}
 ; and {@link BlockingClientManager}, unless you wish to connect over a proxy or use some other network settings that
 ; cannot be set using NIO.</p>
 ;;
#_public
(ยง class BlockingClient (ยง implements MessageWriteTarget)
    #_private
    #_static
    (ยง def- #_"Logger" BlockingClient/log (LoggerFactory/getLogger BlockingClient))

    #_private
    #_static
    (ยง def- #_"int" BlockingClient/BUFFER_SIZE_LOWER_BOUND 4096)
    #_private
    #_static
    (ยง def- #_"int" BlockingClient/BUFFER_SIZE_UPPER_BOUND 65536)

    #_private
    (ยง field- #_"Socket" :socket)
    #_private
    #_volatile
    (ยง field- #_"boolean" :v-close-requested false)
    #_private
    (ยง field- #_"SettableFuture<SocketAddress>" :connect-future)

    ;;;
     ; <p>Creates a new client to the given server address using the given {@link StreamConnection} to decode the data.
     ; The given connection <b>MUST</b> be unique to this object.  This does not block while waiting for the connection
     ; to open, but will call either the {@link StreamConnection#connectionOpened()} or
     ; {@link StreamConnection#connectionClosed()} callback on the created network event processing thread.</p>
     ;
     ; @param connectTimeoutMillis The connect timeout set on the connection (in milliseconds).
     ;                             0 is interpreted as no timeout.
     ; @param socketFactory An object that creates {@link Socket} objects on demand, which may be customised to control
     ;                      how this client connects to the internet.  If not sure, use SocketFactory.getDefault().
     ; @param clientSet A set which this object will add itself to after initialization, and then remove itself from.
     ;;
    #_public
    #_throws #_[ "IOException" ]
    (ยง constructor BlockingClient [#_"SocketAddress" __serverAddress, #_"StreamConnection" __connection, #_"int" __connectTimeoutMillis, #_"SocketFactory" __socketFactory, #_nilable #_"Set<BlockingClient>" __clientSet]
        (ยง assoc this :connect-future (SettableFuture/create))
        ;; Try to fit at least one message in the network buffer, but place an upper and lower limit on its size to make
        ;; sure it doesnt get too large or have to call read too often.
        (.. __connection (setWriteTarget this))
        (ยง assoc this :socket (.. __socketFactory (createSocket)))
        (let [#_"Context" __context (Context/get)]
            (let [#_"Thread" __t (Thread.)
                (ยง anon
                    #_override
                    #_public
                    (ยง method #_"void" run []
                        (Context/propagate __context)
                        (when (some? __clientSet)
                            (.. __clientSet (add (ยง dhis BlockingClient)))
                        )
                        (try
                            (.. (:socket this) (connect __serverAddress, __connectTimeoutMillis))
                            (.. __connection (connectionOpened))
                            (.. (:connect-future this) (set __serverAddress))
                            (let [#_"InputStream" __stream (.. (:socket this) (getInputStream))]
                                (BlockingClient/runReadLoop __stream, __connection)
                            )
                            (catch Exception __e
                                (when (not (:v-close-requested this))
                                    (.. BlockingClient/log (error "Error trying to open/read from connection: {}: {}", __serverAddress, (.. __e (getMessage))))
                                    (.. (:connect-future this) (setException __e))
                                )
                            )
                            (finally
                                (try
                                    (.. (:socket this) (close))
                                    (catch IOException __e1
                                        ;; At this point there isn't much we can do, and we can probably assume the channel is closed.
                                    )
                                )
                                (when (some? __clientSet)
                                    (.. __clientSet (remove (ยง dhis BlockingClient)))
                                )
                                (.. __connection (connectionClosed))
                            )
                        )
                        nil
                    )
                )]
                (.. __t (setName (str "BlockingClient network thread for " __serverAddress)))
                (.. __t (setDaemon true))
                (.. __t (start))
                this
            )
        )
    )

    ;;;
     ; A blocking call that never returns, except by throwing an exception.  It reads bytes from the input stream
     ; and feeds them to the provided {@link StreamConnection}, for example, a {@link Peer}.
     ;;
    #_public
    #_static
    #_throws #_[ "Exception" ]
    (ยง defn #_"void" BlockingClient/runReadLoop [#_"InputStream" __stream, #_"StreamConnection" __connection]
        (let [#_"ByteBuffer" __dbuf (ByteBuffer/allocateDirect (Math/min (Math/max (.. __connection (getMaxMessageSize)), BlockingClient/BUFFER_SIZE_LOWER_BOUND), BlockingClient/BUFFER_SIZE_UPPER_BOUND))
              #_"byte[]" __readBuff (byte-array (.. __dbuf (capacity)))]
            (loop []
                ;; TODO: Kill the message duplication here.
                (Preconditions/checkState (and (< 0 (.. __dbuf (remaining))) (<= (.. __dbuf (remaining)) (.. __readBuff (alength)))))
                (let [#_"int" __read (.. __stream (read __readBuff, 0, (Math/max 1, (Math/min (.. __dbuf (remaining)), (.. __stream (available))))))]
                    (when (== __read -1)
                        (ยง return nil)
                    )

                    (.. __dbuf (put __readBuff, 0, __read))
                    ;; "flip" the buffer - setting the limit to the current position and setting position to 0
                    (.. __dbuf (flip))
                    ;; Use connection.receiveBytes's return value as a double-check that it stopped reading at the right location.
                    (let [#_"int" __bytesConsumed (.. __connection (receiveBytes __dbuf))]
                        (Preconditions/checkState (== (.. __dbuf (position)) __bytesConsumed))
                        ;; Now drop the bytes which were read by compacting dbuf (resetting limit and keeping relative position).
                        (.. __dbuf (compact))
                    )
                )
            )
            nil
        )
    )

    ;;;
     ; Closes the connection to the server, triggering the {@link StreamConnection#connectionClosed()}
     ; event on the network-handling thread where all callbacks occur.
     ;;
    #_override
    #_public
    (ยง method #_"void" closeConnection []
        ;; Closes the channel, triggering an exception in the network-handling thread triggering connectionClosed().
        (try
            (ยง assoc this :v-close-requested true)
            (.. (:socket this) (close))
            (catch IOException __e
                (throw (RuntimeException. __e))
            )
        )
        nil
    )

    #_override
    #_public
    #_synchronized
    #_throws #_[ "IOException" ]
    (ยง method #_"void" writeBytes [#_"byte[]" __message]
        (try
            (let [#_"OutputStream" __stream (.. (:socket this) (getOutputStream))]
                (.. __stream (write __message))
                (.. __stream (flush))
            )
            (catch IOException __e
                (.. BlockingClient/log (error "Error writing message to connection, closing connection", __e))
                (.. this (closeConnection))
                (throw __e)
            )
        )
        nil
    )

    ;;; Returns a future that completes once connection has occurred at the socket level or with an exception if failed to connect. ;;
    #_public
    (ยง method #_"ListenableFuture<SocketAddress>" getConnectFuture []
        (:connect-future this)
    )
)

;;;
 ; <p>A thin wrapper around a set of {@link BlockingClient}s.</p>
 ;
 ; <p>Generally, using {@link NioClient} and {@link NioClientManager} should be preferred over {@link BlockingClient}
 ; and {@link BlockingClientManager} as they scale significantly better, unless you wish to connect over a proxy or use
 ; some other network settings that cannot be set using NIO.</p>
 ;;
#_public
(ยง class BlockingClientManager (ยง extends AbstractIdleService) (ยง implements ClientConnectionManager)
    #_private
    (ยง field- #_"SocketFactory" :socket-factory)
    #_private
    (ยง field- #_"Set<BlockingClient>" :clients (Collections/synchronizedSet (HashSet. #_"<BlockingClient>")))

    #_private
    (ยง field- #_"int" :connect-timeout-millis 1000)

    #_public
    (ยง constructor BlockingClientManager []
        (ยง assoc this :socket-factory (SocketFactory/getDefault))
        this
    )

    ;;;
     ; Creates a blocking client manager that will obtain sockets from the given factory.
     ; Useful for customising how bitcoinj connects to the P2P network.
     ;;
    #_public
    (ยง constructor BlockingClientManager [#_"SocketFactory" __socketFactory]
        (ยง assoc this :socket-factory (Preconditions/checkNotNull __socketFactory))
        this
    )

    #_override
    #_public
    (ยง method #_"ListenableFuture<SocketAddress>" openConnection [#_"SocketAddress" __serverAddress, #_"StreamConnection" __connection]
        (try
            (when (not (.. this (isRunning)))
                (throw (IllegalStateException.))
            )

            (ยง return (.. (BlockingClient. __serverAddress, __connection, (:connect-timeout-millis this), (:socket-factory this), (:clients this)) (getConnectFuture)))
            (catch IOException __e
                (throw (RuntimeException. __e)) ;; This should only happen if we are, e.g. out of system resources.
            )
        )
    )

    ;;; Sets the number of milliseconds to wait before giving up on a connect attempt. ;;
    #_public
    (ยง method #_"void" setConnectTimeoutMillis [#_"int" __connectTimeoutMillis]
        (ยง assoc this :connect-timeout-millis __connectTimeoutMillis)
        nil
    )

    #_override
    #_protected
    #_throws #_[ "Exception" ]
    (ยง method #_"void" startUp []
        nil
    )

    #_override
    #_protected
    #_throws #_[ "Exception" ]
    (ยง method #_"void" shutDown []
        (ยง sync (:clients this)
            (doseq [#_"BlockingClient" __client (:clients this)]
                (.. __client (closeConnection))
            )
        )
        nil
    )

    #_override
    #_public
    (ยง method #_"int" getConnectedClientCount []
        (.. (:clients this) (size))
    )

    #_override
    #_public
    (ยง method #_"void" closeConnections [#_"int" __n]
        (when (not (.. this (isRunning)))
            (throw (IllegalStateException.))
        )

        (ยง sync (:clients this)
            (loop-when-recur [#_"Iterator<BlockingClient>" __it (.. (:clients this) (iterator))] (and (< 0 __n) (.. __it (hasNext))) [(ยง ass __n (dec __n))]
                (.. __it (next) (closeConnection))
            )
        )
        nil
    )
)

;;;
 ; <p>A generic interface for an object which keeps track of a set of open client connections, creates new ones and
 ; ensures they are serviced properly.</p>
 ;
 ; <p>When the service is {@link com.google.common.util.concurrent.Service#stop()}ed, all connections will be closed
 ; and the appropriate connectionClosed() calls must be made.</p>
 ;;
#_public
(ยง interface ClientConnectionManager (ยง extends Service)
    ;;;
     ; Creates a new connection to the given address, with the given connection used to handle incoming data.  Any errors
     ; that occur during connection will be returned in the given future, including errors that can occur immediately.
     ;;
    (ยง method #_"ListenableFuture<SocketAddress>" openConnection [#_"SocketAddress" __serverAddress, #_"StreamConnection" __connection])

    ;;; Gets the number of connected peers. ;;
    (ยง method #_"int" getConnectedClientCount [])

    ;;; Closes n peer connections. ;;
    (ยง method #_"void" closeConnections [#_"int" __n])
)

;; TODO: The locking in all this class is horrible and not really necessary.  We should just run all network stuff on one thread.

;;;
 ; A simple NIO MessageWriteTarget which handles all the business logic of a connection (reading+writing bytes).
 ; Used only by the NioClient and NioServer classes.
 ;;
(ยง class ConnectionHandler (ยง implements MessageWriteTarget)
    #_private
    #_static
    (ยง def- #_"Logger" ConnectionHandler/log (LoggerFactory/getLogger ConnectionHandler))

    #_private
    #_static
    (ยง def- #_"int" ConnectionHandler/BUFFER_SIZE_LOWER_BOUND 4096)
    #_private
    #_static
    (ยง def- #_"int" ConnectionHandler/BUFFER_SIZE_UPPER_BOUND 65536)

    #_private
    #_static
    (ยง def- #_"int" ConnectionHandler/OUTBOUND_BUFFER_BYTE_COUNT (+ Message/MAX_SIZE 24)) ;; 24 byte message header

    ;; We lock when touching local flags and when writing data, but NEVER when calling any methods which leave
    ;; this class into non-Java classes.
    #_private
    (ยง field- #_"ReentrantLock" :lock (Threading/lock "nioConnectionHandler"))
    #_private
    (ยง field- #_"ByteBuffer" :read-buff)
    #_private
    (ยง field- #_"SocketChannel" :channel)
    #_private
    (ยง field- #_"SelectionKey" :key)
    (ยง field #_"StreamConnection" :connection)
    #_private
    (ยง field- #_"boolean" :close-called false)

    #_private
    (ยง field- #_"long" :bytes-to-write-remaining 0)
    #_private
    (ยง field- #_"LinkedList<ByteBuffer>" :bytes-to-write (LinkedList. #_"<>"))

    #_private
    (ยง field- #_"Set<ConnectionHandler>" :connected-handlers)

    #_public
    #_throws #_[ "IOException" ]
    (ยง constructor ConnectionHandler [#_"StreamConnectionFactory" __connectionFactory, #_"SelectionKey" __key]
        (ยง this (.. __connectionFactory (getNewConnection (.. (cast SocketChannel (.. __key (channel))) (socket) (getInetAddress)), (.. (cast SocketChannel (.. __key (channel))) (socket) (getPort)))), __key)
        (when (nil? (:connection this))
            (throw (IOException. "Parser factory.getNewConnection returned nil"))
        )
        this
    )

    #_private
    (ยง constructor- #_"ConnectionHandler" [#_nilable #_"StreamConnection" __connection, #_"SelectionKey" __key]
        (ยง assoc this :key __key)
        (ยง assoc this :channel (Preconditions/checkNotNull (cast SocketChannel (.. __key (channel)))))
        (when (nil? __connection)
            (ยง assoc this :read-buff nil)
            (ยง return nil)
        )

        (ยง assoc this :connection __connection)
        (ยง assoc this :read-buff (ByteBuffer/allocateDirect (Math/min (Math/max (.. __connection (getMaxMessageSize)), ConnectionHandler/BUFFER_SIZE_LOWER_BOUND), ConnectionHandler/BUFFER_SIZE_UPPER_BOUND)))
        (.. __connection (setWriteTarget this)) ;; May callback into us (e.g. closeConnection() now).
        (ยง assoc this :connected-handlers nil)
        this
    )

    #_public
    (ยง constructor ConnectionHandler [#_"StreamConnection" __connection, #_"SelectionKey" __key, #_"Set<ConnectionHandler>" __connectedHandlers]
        (ยง this (Preconditions/checkNotNull __connection), __key)

        ;; closeConnection() may have already happened because we invoked the other c'tor above, which called
        ;; connection.setWriteTarget which might have re-entered already.  In this case we shouldn't add ourselves
        ;; to the connectedHandlers set.
        (.. (:lock this) (lock))
        (try
            (ยง assoc this :connected-handlers __connectedHandlers)
            (when (not (:close-called this))
                (Preconditions/checkState (.. (:connected-handlers this) (add this)))
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        this
    )

    #_private
    (ยง method- #_"void" setWriteOps []
        ;; Make sure we are registered to get updated when writing is available again.
        (.. (:key this) (interestOps (| (.. (:key this) (interestOps)) SelectionKey/OP_WRITE)))
        ;; Refresh the selector to make sure it gets the new interestOps.
        (.. (:key this) (selector) (wakeup))
        nil
    )

    ;; Tries to write any outstanding write bytes, runs in any thread (possibly unlocked).
    #_private
    #_throws #_[ "IOException" ]
    (ยง method- #_"void" tryWriteBytes []
        (.. (:lock this) (lock))
        (try
            ;; Iterate through the outbound ByteBuff queue, pushing as much as possible into the OS' network buffer.
            (let [#_"Iterator<ByteBuffer>" __bytesIterator (.. (:bytes-to-write this) (iterator))]
                (while (.. __bytesIterator (hasNext))
                    (let [#_"ByteBuffer" __buff (.. __bytesIterator (next))]
                        (ยง assoc this :bytes-to-write-remaining (- (:bytes-to-write-remaining this) (.. (:channel this) (write __buff))))
                        (cond (not (.. __buff (hasRemaining)))
                            (do
                                (.. __bytesIterator (remove))
                            )
                            :else
                            (do
                                (.. this (setWriteOps))
                                (ยง break )
                            )
                        )
                    )
                )
                ;; If we are done writing, clear the OP_WRITE interestOps.
                (when (.. (:bytes-to-write this) (isEmpty))
                    (.. (:key this) (interestOps (& (.. (:key this) (interestOps)) (bit-not SelectionKey/OP_WRITE))))
                )
                ;; Don't bother waking up the selector here, since we're just removing an op, not adding.
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    #_override
    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" writeBytes [#_"byte[]" __message]
        (let [#_"boolean" __andUnlock true]
            (.. (:lock this) (lock))
            (try
                ;; Network buffers are not unlimited (and are often smaller than some messages we may wish to send), and
                ;; thus we have to buffer outbound messages sometimes.  To do this, we use a queue of ByteBuffers and just
                ;; append to it when we want to send a message.  We then let tryWriteBytes() either send the message or
                ;; register our SelectionKey to wakeup when we have free outbound buffer space available.
                (when (< ConnectionHandler/OUTBOUND_BUFFER_BYTE_COUNT (+ (:bytes-to-write-remaining this) (.. __message (alength))))
                    (throw (IOException. "Outbound buffer overflowed"))
                )

                ;; Just dump the message onto the write buffer and call tryWriteBytes.
                ;; TODO: Kill the needless message duplication when the write completes right away.
                (.. (:bytes-to-write this) (offer (ByteBuffer/wrap (Arrays/copyOf __message, (.. __message (alength))))))
                (ยง assoc this :bytes-to-write-remaining (+ (:bytes-to-write-remaining this) (.. __message (alength))))
                (.. this (setWriteOps))
                (catch IOException __e
                    (.. (:lock this) (unlock))
                    (ยง ass __andUnlock false)
                    (.. ConnectionHandler/log (warn "Error writing message to connection, closing connection", __e))
                    (.. this (closeConnection))
                    (throw __e)
                )
                (catch CancelledKeyException __e
                    (.. (:lock this) (unlock))
                    (ยง ass __andUnlock false)
                    (.. ConnectionHandler/log (warn "Error writing message to connection, closing connection", __e))
                    (.. this (closeConnection))
                    (throw (IOException. __e))
                )
                (finally
                    (when __andUnlock
                        (.. (:lock this) (unlock))
                    )
                )
            )
            nil
        )
    )

    ;; May NOT be called with lock held.
    #_override
    #_public
    (ยง method #_"void" closeConnection []
        (Preconditions/checkState (not (.. (:lock this) (isHeldByCurrentThread))))
        (try
            (.. (:channel this) (close))
            (catch IOException __e
                (throw (RuntimeException. __e))
            )
        )
        (.. this (connectionClosed))
        nil
    )

    #_private
    (ยง method- #_"void" connectionClosed []
        (let [#_"boolean" __callClosed false]
            (.. (:lock this) (lock))
            (try
                (ยง ass __callClosed (not (:close-called this)))
                (ยง assoc this :close-called true)
                (finally
                    (.. (:lock this) (unlock))
                )
            )
            (when __callClosed
                (Preconditions/checkState (or (nil? (:connected-handlers this)) (.. (:connected-handlers this) (remove this))))
                (.. (:connection this) (connectionClosed))
            )
            nil
        )
    )

    ;; Handle a SelectionKey which was selected.
    ;; Runs unlocked as the caller is single-threaded (or if not, should enforce that handleKey is only called
    ;; atomically for a given ConnectionHandler).
    #_public
    #_static
    (ยง defn #_"void" ConnectionHandler/handleKey [#_"SelectionKey" __key]
        (let [#_"ConnectionHandler" __handler (cast ConnectionHandler (.. __key (attachment)))]
            (try
                (when (nil? __handler)
                    (ยง return nil)
                )
                (when (not (.. __key (isValid)))
                    (.. __handler (closeConnection)) ;; Key has been cancelled, make sure the socket gets closed.
                    (ยง return nil)
                )
                (when (.. __key (isReadable))
                    ;; Do a socket read and invoke the connection's receiveBytes message.
                    (let [#_"int" __read (.. (:channel __handler) (read (:read-buff __handler)))]
                        (cond (== __read 0)
                            (do
                                (ยง return nil) ;; Was probably waiting on a write.
                            )
                            (== __read -1) ;; Socket was closed.
                            (do
                                (.. __key (cancel))
                                (.. __handler (closeConnection))
                                (ยง return nil)
                            )
                        )
                        ;; "flip" the buffer - setting the limit to the current position and setting position to 0
                        (.. (:read-buff __handler) (flip))
                        ;; Use connection.receiveBytes's return value as a check that it stopped reading at the right location.
                        (let [#_"int" __bytesConsumed (.. (Preconditions/checkNotNull (:connection __handler)) (receiveBytes (:read-buff __handler)))]
                            (Preconditions/checkState (== (.. (:read-buff __handler) (position)) __bytesConsumed))
                            ;; Now drop the bytes which were read by compacting readBuff (resetting limit and keeping relative position).
                            (.. (:read-buff __handler) (compact))
                        )
                    )
                )
                (when (.. __key (isWritable))
                    (.. __handler (tryWriteBytes))
                )
                (catch Exception __e
                    ;; This can happen e.g. if the channel closes while the thread is about to get killed
                    ;; (ClosedByInterruptException), or if handler.connection.receiveBytes throws something.
                    (let [#_"Throwable" __t (Throwables/getRootCause __e)]
                        (.. ConnectionHandler/log (warn "Error handling SelectionKey: {} {}", (.. __t (getClass) (getName)), (if (some? (.. __t (getMessage))) (.. __t (getMessage)) ""), __e))
                        (.. __handler (closeConnection))
                    )
                )
            )
            nil
        )
    )
)

;;;
 ; <p>A reusable object that will calculate, given a list of {@link org.bitcoinj.core.PeerFilterProvider}s, a merged
 ; {@link org.bitcoinj.core.BloomFilter} and earliest key time for all of them.
 ; Used by the {@link org.bitcoinj.core.PeerGroup} class internally.</p>
 ;
 ; <p>Thread safety: threading here can be complicated.  Each filter provider is given a begin event, which may acquire
 ; a lock (and is guaranteed to receive an end event).  This class is mostly thread unsafe and is meant to be used from
 ; a single thread only, PeerGroup ensures this by only accessing it from the dedicated PeerGroup thread.  PeerGroup
 ; does not hold any locks whilst this object is used, relying on the single thread to prevent multiple filters being
 ; calculated in parallel, thus a filter provider can do things like make blocking calls into PeerGroup from a separate
 ; thread.  However the bloomFilterFPRate property IS thread safe, for convenience.</p>
 ;;
#_public
(ยง class FilterMerger
    ;; We use a constant tweak to avoid giving up privacy when we regenerate our filter with new keys.
    #_private
    (ยง field- #_"long" :bloom-filter-tweak (long (* (Math/random) Long/MAX_VALUE)))

    #_private
    #_volatile
    (ยง field- #_"double" :v-bloom-filter-fp-rate)
    #_private
    (ยง field- #_"int" :last-bloom-filter-element-count)
    #_private
    (ยง field- #_"BloomFilter" :last-filter)

    #_public
    (ยง constructor FilterMerger [#_"double" __bloomFilterFPRate]
        (ยง assoc this :v-bloom-filter-fp-rate __bloomFilterFPRate)
        this
    )

    #_public
    #_static
    (ยง class FilterMerger.Result
        #_public
        (ยง field #_"BloomFilter" :filter)
        #_public
        (ยง field #_"long" :earliest-key-time-secs)
        #_public
        (ยง field #_"boolean" :changed)
    )

    #_public
    (ยง method #_"FilterMerger.Result" calculate [#_"ImmutableList<PeerFilterProvider>" __providers]
        (let [#_"LinkedList<PeerFilterProvider>" __begunProviders (Lists/newLinkedList)]
            (try
                ;; All providers must be in a consistent, unchanging state because the filter is a merged one that's
                ;; large enough for all providers elements: if a provider were to get more elements in the middle of the
                ;; calculation, we might assert or calculate the filter wrongly.  Most providers use a lock here but
                ;; snapshotting required state is also a legitimate strategy.
                (doseq [#_"PeerFilterProvider" __provider __providers]
                    (.. __provider (beginBloomFilterCalculation))
                    (.. __begunProviders (add __provider))
                )
                (let [#_"FilterMerger.Result" __result (FilterMerger.Result.)]
                    (ยง assoc __result :earliest-key-time-secs Long/MAX_VALUE)
                    (let [#_"int" __elements 0
                          #_"boolean" __requiresUpdateAll false]
                        (doseq [#_"PeerFilterProvider" __p __providers]
                            (ยง assoc __result :earliest-key-time-secs (Math/min (:earliest-key-time-secs __result), (.. __p (getEarliestKeyCreationTime))))
                            (ยง ass __elements (+ __elements (.. __p (getBloomFilterElementCount))))
                        )

                        (when (< 0 __elements)
                            ;; We stair-step our element count so that we avoid creating a filter with different parameters
                            ;; as much as possible as that results in a loss of privacy.
                            ;; The constant 100 here is somewhat arbitrary, but makes sense for small to medium wallets -
                            ;; it will likely mean we never need to create a filter with different parameters.
                            (ยง assoc this :last-bloom-filter-element-count (if (< (:last-bloom-filter-element-count this) __elements) (+ __elements 100) (:last-bloom-filter-element-count this)))
                            (let [#_"BloomFilter.BloomUpdate" __bloomFlags (if __requiresUpdateAll BloomFilter.BloomUpdate/UPDATE_ALL BloomFilter.BloomUpdate/UPDATE_P2PUBKEY_ONLY)
                                  #_"double" __fpRate (:v-bloom-filter-fp-rate this)
                                  #_"BloomFilter" __filter (BloomFilter. (:last-bloom-filter-element-count this), __fpRate, (:bloom-filter-tweak this), __bloomFlags)]
                                (doseq [#_"PeerFilterProvider" __p __providers]
                                    (.. __filter (merge (.. __p (getBloomFilter (:last-bloom-filter-element-count this), __fpRate, (:bloom-filter-tweak this)))))
                                )

                                (ยง assoc __result :changed (not (.. __filter (equals (:last-filter this)))))
                                (ยง assoc __result :filter (ยง assoc this :last-filter __filter))
                            )
                        )
                        ;; Now adjust the earliest key time backwards by a week to handle the case of clock drift.  This can occur
                        ;; both in block header timestamps and if the users clock was out of sync when the key was first created
                        ;; (to within a small amount of tolerance).
                        (ยง assoc __result :earliest-key-time-secs (- (:earliest-key-time-secs this) (* 86400 7)))
                        (ยง return __result)
                    )
                )
                (finally
                    (doseq [#_"PeerFilterProvider" __provider __begunProviders]
                        (.. __provider (endBloomFilterCalculation))
                    )
                )
            )
        )
    )

    #_public
    (ยง method #_"void" setBloomFilterFPRate [#_"double" __bloomFilterFPRate]
        (ยง assoc this :v-bloom-filter-fp-rate __bloomFilterFPRate)
        nil
    )

    #_public
    (ยง method #_"double" getBloomFilterFPRate []
        (:v-bloom-filter-fp-rate this)
    )

    #_public
    (ยง method #_"BloomFilter" getLastFilter []
        (:last-filter this)
    )
)

;;;
 ; A target to which messages can be written/connection can be closed.
 ;;
#_public
(ยง interface MessageWriteTarget
    ;;;
     ; Writes the given bytes to the remote server.
     ;;
    #_throws #_[ "IOException" ]
    (ยง method #_"void" writeBytes [#_"byte[]" __message])
    ;;;
     ; Closes the connection to the server, triggering the {@link StreamConnection#connectionClosed()}
     ; event on the network-handling thread where all callbacks occur.
     ;;
    (ยง method #_"void" closeConnection [])
)

;;;
 ; Creates a simple connection to a server using a {@link StreamConnection} to process data.
 ;;
#_public
(ยง class NioClient (ยง implements MessageWriteTarget)
    #_private
    #_static
    (ยง def- #_"Logger" NioClient/log (LoggerFactory/getLogger NioClient))

    #_private
    (ยง field- #_"NioClient.Handler" :handler)
    #_private
    (ยง field- #_"NioClientManager" :manager (NioClientManager.))

    (ยง class NioClient.Handler (ยง extends AbstractTimeoutHandler) (ยง implements StreamConnection)
        #_private
        (ยง field- #_"StreamConnection" :upstream-connection)
        #_private
        (ยง field- #_"MessageWriteTarget" :write-target)
        #_private
        (ยง field- #_"boolean" :close-on-open)
        #_private
        (ยง field- #_"boolean" :close-called)

        (ยง constructor NioClient.Handler [#_"StreamConnection" __upstreamConnection, #_"int" __connectTimeoutMillis]
            (ยง assoc this :upstream-connection __upstreamConnection)
            (.. this (setSocketTimeout __connectTimeoutMillis))
            (.. this (setTimeoutEnabled true))
            this
        )

        #_override
        #_protected
        #_synchronized
        (ยง method #_"void" timeoutOccurred []
            (ยง assoc this :close-on-open true)
            (.. this (connectionClosed))
            nil
        )

        #_override
        #_public
        #_synchronized
        (ยง method #_"void" connectionClosed []
            (.. (:manager this) (stopAsync))
            (when (not (:close-called this))
                (ยง assoc this :close-called true)
                (.. (:upstream-connection this) (connectionClosed))
            )
            nil
        )

        #_override
        #_public
        #_synchronized
        (ยง method #_"void" connectionOpened []
            (when (not (:close-on-open this))
                (.. (:upstream-connection this) (connectionOpened))
            )
            nil
        )

        #_override
        #_public
        #_throws #_[ "Exception" ]
        (ยง method #_"int" receiveBytes [#_"ByteBuffer" __buff]
            (.. (:upstream-connection this) (receiveBytes __buff))
        )

        #_override
        #_public
        #_synchronized
        (ยง method #_"void" setWriteTarget [#_"MessageWriteTarget" __writeTarget]
            (cond (:close-on-open this)
                (do
                    (.. __writeTarget (closeConnection))
                )
                :else
                (do
                    (.. this (setTimeoutEnabled false))
                    (ยง assoc this :write-target __writeTarget)
                    (.. (:upstream-connection this) (setWriteTarget __writeTarget))
                )
            )
            nil
        )

        #_override
        #_public
        (ยง method #_"int" getMaxMessageSize []
            (.. (:upstream-connection this) (getMaxMessageSize))
        )
    )

    ;;;
     ; <p>Creates a new client to the given server address using the given {@link StreamConnection} to decode the data.
     ; The given connection <b>MUST</b> be unique to this object.  This does not block while waiting for the connection
     ; to open, but will call either the {@link StreamConnection#connectionOpened()} or
     ; {@link StreamConnection#connectionClosed()} callback on the created network event processing thread.</p>
     ;
     ; @param connectTimeoutMillis The connect timeout set on the connection (in milliseconds).
     ;                             0 is interpreted as no timeout.
     ;;
    #_public
    #_throws #_[ "IOException" ]
    (ยง constructor NioClient [#_"SocketAddress" __serverAddress, #_"StreamConnection" __parser, #_"int" __connectTimeoutMillis]
        (.. (:manager this) (startAsync))
        (.. (:manager this) (awaitRunning))
        (ยง assoc this :handler (NioClient.Handler. __parser, __connectTimeoutMillis))
        (Futures/addCallback (.. (:manager this) (openConnection __serverAddress, (:handler this))), (FutureCallback. #_"<SocketAddress>")
        (ยง anon
            #_override
            #_public
            (ยง method #_"void" onSuccess [#_"SocketAddress" __result]
                nil
            )

            #_override
            #_public
            (ยง method #_"void" onFailure [#_"Throwable" __t]
                (.. NioClient/log (error "Connect to {} failed: {}", __serverAddress, (Throwables/getRootCause __t)))
                nil
            )
        ))
        this
    )

    #_override
    #_public
    (ยง method #_"void" closeConnection []
        (.. (:handler this) :write-target (closeConnection))
        nil
    )

    #_override
    #_public
    #_synchronized
    #_throws #_[ "IOException" ]
    (ยง method #_"void" writeBytes [#_"byte[]" __message]
        (.. (:handler this) :write-target (writeBytes __message))
        nil
    )
)

;;;
 ; A class which manages a set of client connections.  Uses Java NIO to select network events and processes them
 ; in a single network processing thread.
 ;;
#_public
(ยง class NioClientManager (ยง extends AbstractExecutionThreadService) (ยง implements ClientConnectionManager)
    #_private
    #_static
    (ยง def- #_"Logger" NioClientManager/log (LoggerFactory/getLogger NioClientManager))

    #_private
    (ยง field- #_"Selector" :selector)

    (ยง class NioClientManager.PendingConnect
        (ยง field- #_"SocketChannel" :sc)
        (ยง field- #_"StreamConnection" :connection)
        (ยง field- #_"SocketAddress" :address)
        (ยง field- #_"SettableFuture<SocketAddress>" :future (SettableFuture/create))

        (ยง constructor NioClientManager.PendingConnect [#_"SocketChannel" __sc, #_"StreamConnection" __connection, #_"SocketAddress" __address]
            (ยง assoc this :sc __sc)
            (ยง assoc this :connection __connection)
            (ยง assoc this :address __address)
            this
        )
    )
    (ยง field #_"Queue<NioClientManager.PendingConnect>" :new-connection-channels (LinkedBlockingQueue. #_"<>"))

    ;; Added to/removed from by the individual ConnectionHandler's, thus must by synchronized on its own.
    #_private
    (ยง field- #_"Set<ConnectionHandler>" :connected-handlers (Collections/synchronizedSet (HashSet. #_"<ConnectionHandler>")))

    ;; Handle a SelectionKey which was selected.
    #_private
    #_throws #_[ "IOException" ]
    (ยง method- #_"void" handleKey [#_"SelectionKey" __key]
        ;; We could have a !isValid() key here if the connection is already closed at this point,
        ;; i.e. a client connection which has finished the initial connect process.
        (cond (and (.. __key (isValid)) (.. __key (isConnectable)))
            (do
                ;; Create a ConnectionHandler and hook everything together.
                (let [#_"NioClientManager.PendingConnect" __data (cast NioClientManager.PendingConnect (.. __key (attachment)))
                      #_"StreamConnection" __connection (:connection __data)
                      #_"SocketChannel" __sc (cast SocketChannel (.. __key (channel)))
                      #_"ConnectionHandler" __handler (ConnectionHandler. __connection, __key, (:connected-handlers this))]
                    (try
                        (cond (.. __sc (finishConnect))
                            (do
                                (.. NioClientManager/log (info "Connected to {}", (.. __sc (socket) (getRemoteSocketAddress))))
                                (.. __key (interestOps (& (| (.. __key (interestOps)) SelectionKey/OP_READ) (bit-not SelectionKey/OP_CONNECT))) (attach __handler))
                                (.. __connection (connectionOpened))
                                (.. (:future __data) (set (:address __data)))
                            )
                            :else
                            (do
                                (.. NioClientManager/log (warn "Failed to connect to {}", (.. __sc (socket) (getRemoteSocketAddress))))
                                (.. __handler (closeConnection)) ;; Failed to connect for some reason.
                                (.. (:future __data) (setException (ConnectException. "Unknown reason")))
                                (ยง assoc __data :future nil)
                            )
                        )
                        (catch Exception __e
                            ;; If e is a CancelledKeyException, there is a race to get to interestOps after finishConnect() which
                            ;; may cause this.  Otherwise it may be any arbitrary kind of connection failure.
                            ;; Calling sc.socket().getRemoteSocketAddress() here throws an exception, so we can only log the error itself.
                            (let [#_"Throwable" __cause (Throwables/getRootCause __e)]
                                (.. NioClientManager/log (warn "Failed to connect with exception: {}: {}", (.. __cause (getClass) (getName)), (.. __cause (getMessage)), __e))
                                (.. __handler (closeConnection))
                                (.. (:future __data) (setException __cause))
                                (ยง assoc __data :future nil)
                            )
                        )
                    )
                )
            )
            :else ;; Process bytes read.
            (do
                (ConnectionHandler/handleKey __key)
            )
        )
        nil
    )

    ;;;
     ; Creates a new client manager which uses Java NIO for socket management.
     ; Uses a single thread to handle all select calls.
     ;;
    #_public
    (ยง constructor NioClientManager []
        (try
            (ยง assoc this :selector (.. (SelectorProvider/provider) (openSelector)))
            (catch IOException __e
                (throw (RuntimeException. __e)) ;; Shouldn't ever happen.
            )
        )
        this
    )

    #_override
    #_public
    (ยง method #_"void" run []
        (try
            (.. (Thread/currentThread) (setPriority Thread/MIN_PRIORITY))
            (while (.. this (isRunning))
                (let [#_"NioClientManager.PendingConnect" __conn]
                    (while (some? (ยง ass __conn (.. (:new-connection-channels this) (poll))))
                        (try
                            (let [#_"SelectionKey" __key (.. (:sc __conn) (register (:selector this), SelectionKey/OP_CONNECT))]
                                (.. __key (attach __conn))
                            )
                            (catch ClosedChannelException _
                                (.. NioClientManager/log (warn "SocketChannel was closed before it could be registered"))
                            )
                        )
                    )

                    (.. (:selector this) (select))

                    (let [#_"Iterator<SelectionKey>" __keyIterator (.. (:selector this) (selectedKeys) (iterator))]
                        (while (.. __keyIterator (hasNext))
                            (let [#_"SelectionKey" __key (.. __keyIterator (next))]
                                (.. __keyIterator (remove))
                                (ConnectionHandler/handleKey __key)
                            )
                        )
                    )
                )
            )
            (catch Exception __e
                (.. NioClientManager/log (warn "Error trying to open/read from connection: ", __e))
            )
            (finally
                ;; Go through and close everything, without letting IOExceptions get in our way.
                (doseq [#_"SelectionKey" __key (.. (:selector this) (keys))]
                    (try
                        (.. __key (channel) (close))
                        (catch IOException __e
                            (.. NioClientManager/log (warn "Error closing channel", __e))
                        )
                    )
                    (.. __key (cancel))
                    (when (instance? ConnectionHandler (.. __key (attachment)))
                        (ConnectionHandler/handleKey __key) ;; Close connection if relevant.
                    )
                )
                (try
                    (.. (:selector this) (close))
                    (catch IOException __e
                        (.. NioClientManager/log (warn "Error closing client manager selector", __e))
                    )
                )
            )
        )
        nil
    )

    #_override
    #_public
    (ยง method #_"ListenableFuture<SocketAddress>" openConnection [#_"SocketAddress" __serverAddress, #_"StreamConnection" __connection]
        (when (not (.. this (isRunning)))
            (throw (IllegalStateException.))
        )

        ;; Create a new connection, give it a connection as an attachment.
        (try
            (let [#_"SocketChannel" __sc (SocketChannel/open)]
                (.. __sc (configureBlocking false))
                (.. __sc (connect __serverAddress))
                (let [#_"NioClientManager.PendingConnect" __data (NioClientManager.PendingConnect. __sc, __connection, __serverAddress)]
                    (.. (:new-connection-channels this) (offer __data))
                    (.. (:selector this) (wakeup))
                    (ยง return (:future __data))
                )
            )
            (catch Throwable __e
                (ยง return (Futures/immediateFailedFuture __e))
            )
        )
    )

    #_override
    #_public
    (ยง method #_"void" triggerShutdown []
        (.. (:selector this) (wakeup))
        nil
    )

    #_override
    #_public
    (ยง method #_"int" getConnectedClientCount []
        (.. (:connected-handlers this) (size))
    )

    #_override
    #_public
    (ยง method #_"void" closeConnections [#_"int" __n]
        (loop-when-recur [] (< 0 __n) [(ยง ass __n (dec __n))]
            (let [#_"ConnectionHandler" __handler]
                (ยง sync (:connected-handlers this)
                    (ยง ass __handler (.. (:connected-handlers this) (iterator) (next)))
                )
                (when (some? __handler)
                    (.. __handler (closeConnection)) ;; Removes handler from connectedHandlers before returning.
                )
            )
        )
        nil
    )

    #_override
    #_protected
    (ยง method #_"Executor" executor []
        (ยง return (Executor.)
        (ยง anon
            #_override
            #_public
            (ยง method #_"void" execute [#_"Runnable" __command]
                (.. (ContextPropagatingThreadFactory. "NioClientManager") (newThread __command) (start))
                nil
            )
        ))
    )
)

;;;
 ; Creates a simple server listener which listens for incoming client connections and uses a {@link StreamConnection}
 ; to process data.
 ;;
#_public
(ยง class NioServer (ยง extends AbstractExecutionThreadService)
    #_private
    #_static
    (ยง def- #_"Logger" NioServer/log (LoggerFactory/getLogger NioServer))

    #_private
    (ยง field- #_"StreamConnectionFactory" :connection-factory)

    #_private
    (ยง field- #_"ServerSocketChannel" :sc)
    #_testing
    (ยง field #_"Selector" :selector)

    ;; Handle a SelectionKey which was selected.
    #_private
    #_throws #_[ "IOException" ]
    (ยง method- #_"void" handleKey [#_"Selector" __selector, #_"SelectionKey" __key]
        (cond (and (.. __key (isValid)) (.. __key (isAcceptable)))
            (do
                ;; Accept a new connection, give it a stream connection as an attachment.
                (let [#_"SocketChannel" __newChannel (.. (:sc this) (accept))]
                    (.. __newChannel (configureBlocking false))
                    (let [#_"SelectionKey" __newKey (.. __newChannel (register __selector, SelectionKey/OP_READ))]
                        (try
                            (let [#_"ConnectionHandler" __handler (ConnectionHandler. (:connection-factory this), __newKey)]
                                (.. __newKey (attach __handler))
                                (.. (:connection __handler) (connectionOpened))
                            )
                            (catch IOException __e
                                ;; This can happen if ConnectionHandler's call to get a new handler returned null.
                                (.. NioServer/log (error "Error handling new connection", (.. (Throwables/getRootCause __e) (getMessage))))
                                (.. __newKey (channel) (close))
                            )
                        )
                    )
                )
            )
            :else ;; Got a closing channel or a channel to a client connection.
            (do
                (ConnectionHandler/handleKey __key)
            )
        )
        nil
    )

    ;;;
     ; Creates a new server which is capable of listening for incoming connections and processing client provided data
     ; using {@link StreamConnection}s created by the given {@link StreamConnectionFactory}.
     ;
     ; @throws IOException if there is an issue opening the server socket or binding fails for some reason.
     ;;
    #_public
    #_throws #_[ "IOException" ]
    (ยง constructor NioServer [#_"StreamConnectionFactory" __connectionFactory, #_"InetSocketAddress" __bindAddress]
        (ยง assoc this :connection-factory __connectionFactory)

        (ยง assoc this :sc (ServerSocketChannel/open))
        (.. (:sc this) (configureBlocking false))
        (.. (:sc this) (socket) (bind __bindAddress))
        (ยง assoc this :selector (.. (SelectorProvider/provider) (openSelector)))
        (.. (:sc this) (register (:selector this), SelectionKey/OP_ACCEPT))
        this
    )

    #_override
    #_protected
    #_throws #_[ "Exception" ]
    (ยง method #_"void" run []
        (try
            (while (.. this (isRunning))
                (.. (:selector this) (select))

                (let [#_"Iterator<SelectionKey>" __keyIterator (.. (:selector this) (selectedKeys) (iterator))]
                    (while (.. __keyIterator (hasNext))
                        (let [#_"SelectionKey" __key (.. __keyIterator (next))]
                            (.. __keyIterator (remove))

                            (ConnectionHandler/handleKey (:selector this), __key)
                        )
                    )
                )
            )
            (catch Exception __e
                (.. NioServer/log (error "Error trying to open/read from connection: {}", __e))
            )
            (finally
                ;; Go through and close everything, without letting IOExceptions get in our way.
                (doseq [#_"SelectionKey" __key (.. (:selector this) (keys))]
                    (try
                        (.. __key (channel) (close))
                        (catch IOException __e
                            (.. NioServer/log (error "Error closing channel", __e))
                        )
                    )
                    (try
                        (.. __key (cancel))
                        (ConnectionHandler/handleKey (:selector this), __key)
                        (catch IOException __e
                            (.. NioServer/log (error "Error closing selection key", __e))
                        )
                    )
                )
                (try
                    (.. (:selector this) (close))
                    (catch IOException __e
                        (.. NioServer/log (error "Error closing server selector", __e))
                    )
                )
                (try
                    (.. (:sc this) (close))
                    (catch IOException __e
                        (.. NioServer/log (error "Error closing server channel", __e))
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Invoked by the Execution service when it's time to stop.
     ; Calling this method directly will NOT stop the service, call
     ; {@link com.google.common.util.concurrent.AbstractExecutionThreadService#stop()} instead.
     ;;
    #_override
    #_public
    (ยง method #_"void" triggerShutdown []
        ;; Wake up the selector and let the selection thread break its loop as the ExecutionService !isRunning().
        (.. (:selector this) (wakeup))
        nil
    )
)

;;;
 ; <p>A handler which is used in {@link NioServer} and {@link NioClient} to split up incoming data streams
 ; into protobufs and provide an interface for writing protobufs to the connections.</p>
 ;
 ; <p>Messages are encoded with a 4-byte signed integer (big endian) prefix to indicate their length followed
 ; by the serialized protobuf.</p>
 ;;
#_public
(ยง class ProtobufConnection #_"<MessageType extends MessageLite>" (ยง extends AbstractTimeoutHandler) (ยง implements StreamConnection)
    #_private
    #_static
    (ยง def- #_"Logger" ProtobufConnection/log #_"<MessageType extends MessageLite>" (LoggerFactory/getLogger ProtobufConnection))

    ;;;
     ; An interface which can be implemented to handle callbacks as new messages are generated and socket events occur.
     ; @param <MessageType> The protobuf type which is used on this socket.
     ;                      This <b>MUST</b> match the MessageType used in the parent {@link ProtobufConnection}.
     ;;
    #_public
    (ยง interface ProtobufConnection.Listener #_"<MessageType extends MessageLite>"
        ;;; Called when a new protobuf is received from the remote side. ;;
        (ยง method #_"void" messageReceived [#_"ProtobufConnection<MessageType>" __handler, #_"MessageType" __msg])
        ;;; Called when the connection is opened and available for writing data to. ;;
        (ยง method #_"void" connectionOpen [#_"ProtobufConnection<MessageType>" __handler])
        ;;; Called when the connection is closed and no more data should be provided. ;;
        (ยง method #_"void" connectionClosed [#_"ProtobufConnection<MessageType>" __handler])
    )

    ;; The callback listener.
    #_private
    (ยง field- #_"ProtobufConnection.Listener<MessageType>" :handler)
    ;; The prototype which is used to deserialize messages.
    #_private
    (ยง field- #_"MessageLite" :prototype)

    ;; The maximum message size (NOT INCLUDING LENGTH PREFIX).
    (ยง field #_"int" :max-message-size)

    ;; A temporary buffer used when the message size is larger than the buffer being used by the network code.
    ;; Because the networking code uses a constant size buffer and we want to allow for very large message sizes, we use
    ;; a smaller network buffer per client and only allocate more memory when we need it to deserialize large messages.
    ;; Though this is not in of itself a DoS protection, it allows for handling more legitimate clients per server and
    ;; attacking clients can be made to timeout/get blocked if they are sending crap to fill buffers.
    #_private
    (ยง field- #_"int" :message-bytes-offset 0)
    #_private
    (ยง field- #_"byte[]" :message-bytes)
    #_private
    (ยง field- #_"ReentrantLock" :lock (Threading/lock "ProtobufConnection"))

    #_testing
    (ยง field #_"AtomicReference<MessageWriteTarget>" :write-target (AtomicReference. #_"<>"))

    ;;;
     ; Creates a new protobuf handler.
     ;
     ; @param handler The callback listener.
     ; @param prototype The default instance of the message type used in both directions of this channel.
     ;                  This should be the return value from {@link MessageType#getDefaultInstanceForType()}.
     ; @param maxMessageSize The maximum message size (not including the 4-byte length prefix).
     ;                       Note that this has an upper bound of {@link Integer#MAX_VALUE} - 4.
     ; @param timeoutMillis The timeout between messages before the connection is automatically closed.
     ;                      Only enabled after the connection is established.
     ;;
    #_public
    (ยง constructor ProtobufConnection [#_"ProtobufConnection.Listener<MessageType>" __handler, #_"MessageType" __prototype, #_"int" __maxMessageSize, #_"int" __timeoutMillis]
        (ยง assoc this :handler __handler)
        (ยง assoc this :prototype __prototype)
        (ยง assoc this :max-message-size (Math/min __maxMessageSize, (- Integer/MAX_VALUE 4)))
        (.. this (setTimeoutEnabled false))
        (.. this (setSocketTimeout __timeoutMillis))
        this
    )

    #_override
    #_public
    (ยง method #_"void" setWriteTarget [#_"MessageWriteTarget" __writeTarget]
        ;; Only allow it to be set once.
        (Preconditions/checkState (nil? (.. (:write-target this) (getAndSet (Preconditions/checkNotNull __writeTarget)))))
        nil
    )

    #_override
    #_public
    (ยง method #_"int" getMaxMessageSize []
        (:max-message-size this)
    )

    ;;;
     ; Closes this connection, eventually triggering a {@link ProtobufConnection.Listener#connectionClosed()} event.
     ;;
    #_public
    (ยง method #_"void" closeConnection []
        (.. (:write-target this) (get) (closeConnection))
        nil
    )

    #_override
    #_protected
    (ยง method #_"void" timeoutOccurred []
        (.. ProtobufConnection/log #_"<MessageType extends MessageLite>" (warn (str "Timeout occurred for " (:handler this))))
        (.. this (closeConnection))
        nil
    )

    ;; Deserializes and provides a listener event (buff must not have the length prefix in it).
    ;; Does set the buffers's position to its limit.
    #_suppress #_[ "unchecked" ]
    ;; The warning 'unchecked cast' being suppressed here comes from the build() formally returning
    ;; a MessageLite-derived class that cannot be statically guaranteed to be the MessageType.
    #_private
    #_throws #_[ "Exception" ]
    (ยง method- #_"void" deserializeMessage [#_"ByteBuffer" __buff]
        (let [#_"MessageType" __msg (cast MessageType (.. (:prototype this) (newBuilderForType) (mergeFrom (ByteString/copyFrom __buff)) (build)))]
            (.. this (resetTimeout))
            (.. (:handler this) (messageReceived this, __msg))
            nil
        )
    )

    #_override
    #_public
    #_throws #_[ "Exception" ]
    (ยง method #_"int" receiveBytes [#_"ByteBuffer" __buff]
        (.. (:lock this) (lock))
        (try
            (when (some? (:message-bytes this))
                ;; Just keep filling up the currently being worked on message.
                (let [#_"int" __bytesToGet (Math/min (- (.. (:message-bytes this) (alength)) (:message-bytes-offset this)), (.. __buff (remaining)))]
                    (.. __buff (get (:message-bytes this), (:message-bytes-offset this), __bytesToGet))
                    (ยง assoc this :message-bytes-offset (+ (:message-bytes-offset this) __bytesToGet))
                    (when (== (:message-bytes-offset this) (.. (:message-bytes this) (alength)))
                        ;; Filled up our buffer, decode the message.
                        (.. this (deserializeMessage (ByteBuffer/wrap (:message-bytes this))))
                        (ยง assoc this :message-bytes nil)
                        (when (.. __buff (hasRemaining))
                            (ยง return (+ __bytesToGet (.. this (receiveBytes __buff))))
                        )
                    )
                    (ยง return __bytesToGet)
                )
            )

            ;; If we cant read the length prefix yet, give up.
            (when (< (.. __buff (remaining)) 4)
                (ยง return 0)
            )

            ;; Read one integer in big endian.
            (.. __buff (order ByteOrder/BIG_ENDIAN))
            (let [#_"int" __len (.. __buff (getInt))]

                ;; If length is larger than the maximum message size (or is negative/overflows) throw an exception and close
                ;; the connection.
                (when (or (< (:max-message-size this) __len) (< (+ __len 4) 4))
                    (throw (IllegalStateException. "Message too large or length underflowed"))
                )

                ;; If the buffer's capacity is less than the next messages length + 4 (length prefix), we must use messageBytes
                ;; as a temporary buffer to store the message.
                (when (< (.. __buff (capacity)) (+ __len 4))
                    (ยง assoc this :message-bytes (byte-array __len))
                    ;; Now copy all remaining bytes into the new buffer, set messageBytesOffset and tell the caller how many
                    ;; bytes we consumed.
                    (let [#_"int" __bytesToRead (.. __buff (remaining))]
                        (.. __buff (get (:message-bytes this), 0, __bytesToRead))
                        (ยง assoc this :message-bytes-offset __bytesToRead)
                        (ยง return (+ __bytesToRead 4))
                    )
                )

                ;; Wait until the whole message is available in the buffer.
                (when (< (.. __buff (remaining)) __len)
                    ;; Make sure the buffer's position is right at the end.
                    (.. __buff (position (- (.. __buff (position)) 4)))
                    (ยง return 0)
                )

                ;; Temporarily limit the buffer to the size of the message, so that the protobuf decode doesn't get messed up.
                (let [#_"int" __limit (.. __buff (limit))]
                    (.. __buff (limit (+ (.. __buff (position)) __len)))
                    (.. this (deserializeMessage __buff))
                    (Preconditions/checkState (== (.. __buff (remaining)) 0))
                    ;; Reset the limit in case we have to recurse.
                    (.. __buff (limit __limit))

                    ;; If there are still bytes remaining, see if we can pull out another message since we won't get called again.
                    (if (.. __buff (hasRemaining))
                        (ยง return (+ __len 4 (.. this (receiveBytes __buff))))
                        (ยง return (+ __len 4))
                    )
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_override
    #_public
    (ยง method #_"void" connectionClosed []
        (.. (:handler this) (connectionClosed this))
        nil
    )

    #_override
    #_public
    (ยง method #_"void" connectionOpened []
        (.. this (setTimeoutEnabled true))
        (.. (:handler this) (connectionOpen this))
        nil
    )

    ;;;
     ; <p>Writes the given message to the other side of the connection, prefixing it with the proper 4-byte prefix.</p>
     ;
     ; <p>Provides a write-order guarantee.</p>
     ;
     ; @throws IllegalStateException if the encoded message is larger than the maximum message size.
     ;;
    #_public
    #_throws #_[ "IllegalStateException" ]
    (ยง method #_"void" write [#_"MessageType" __msg]
        (let [#_"byte[]" __messageBytes (.. __msg (toByteArray))]
            (Preconditions/checkState (<= (.. __messageBytes (alength)) (:max-message-size this)))

            (let [#_"byte[]" __messageLength (byte-array 4)]
                (Utils/uint32ToByteArrayBE (.. __messageBytes (alength)), __messageLength, 0)
                (try
                    (let [#_"MessageWriteTarget" __target (.. (:write-target this) (get))]
                        (.. __target (writeBytes __messageLength))
                        (.. __target (writeBytes __messageBytes))
                    )
                    (catch IOException __e
                        (.. this (closeConnection))
                    )
                )
                nil
            )
        )
    )
)

;;;
 ; A generic handler which is used in {@link NioServer}, {@link NioClient} and {@link BlockingClient} to handle incoming
 ; data streams.
 ;;
#_public
(ยง interface StreamConnection
    ;;; Called when the connection socket is closed. ;;
    (ยง method #_"void" connectionClosed [])

    ;;; Called when the connection socket is first opened. ;;
    (ยง method #_"void" connectionOpened [])

    ;;;
     ; <p>Called when new bytes are available from the remote end.  This should only ever be called by the single
     ; writeTarget associated with any given StreamConnection, multiple callers will likely confuse implementations.</p>
     ;
     ; Implementers/callers must follow the following conventions exactly:
     ; <ul>
     ; <li>buff will start with its limit set to the position we can read to and its position set to the location we
     ;     will start reading at (always 0).</li>
     ; <li>May read more than one message (recursively) if there are enough bytes available.</li>
     ; <li>Uses some internal buffering to store message which are larger (incl. their length prefix) than buff's
     ;     capacity(), i.e. it is up to this method to ensure we dont run out of buffer space to decode the next message.</li>
     ; <li>buff will end with its limit the same as it was previously, and its position set to the position up to which
     ;     bytes have been read (the same as its return value).</li>
     ; <li>buff must be at least the size of a Bitcoin header (incl. magic bytes).</li>
     ; </ul>
     ;
     ; @return the amount of bytes consumed which should not be provided again.
     ;;
    #_throws #_[ "Exception" ]
    (ยง method #_"int" receiveBytes [#_"ByteBuffer" __buff])

    ;;;
     ; Called when this connection is attached to an upstream write target (i.e. a low-level connection handler).
     ; This writeTarget should be stored and used to close the connection or write data to the socket.
     ;;
    (ยง method #_"void" setWriteTarget [#_"MessageWriteTarget" __writeTarget])

    ;;;
     ; Returns the maximum message size of a message on the socket. This is used in calculating size of buffers
     ; to allocate.
     ;;
    (ยง method #_"int" getMaxMessageSize [])
)

;;;
 ; A factory which generates new {@link StreamConnection}s when a new connection is opened.
 ;;
#_public
(ยง interface StreamConnectionFactory
    ;;;
     ; Returns a new handler or null to have the connection close.
     ; @param inetAddress The client's (IP) address.
     ; @param port The remote port on the client side.
     ;;
    #_nilable
    (ยง method #_"StreamConnection" getNewConnection [#_"InetAddress" __inetAddress, #_"int" __port])
)

#_(ns org.bitcoinj.net.discovery #_"DnsDiscovery"
    (:import [java.net *]
             [java.util *]
             [java.util.concurrent *])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.utils *]))

#_(ns org.bitcoinj.net.discovery #_"MultiplexingDiscovery"
    (:import [java.net InetSocketAddress]
             [java.util ArrayList Collections List]
             [java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core NetworkParameters VersionMessage]
             [org.bitcoinj.net.discovery DnsDiscovery]
             [org.bitcoinj.utils *]))

#_(ns org.bitcoinj.net.discovery #_"PeerDiscovery"
    (:import [java.net InetSocketAddress]
             [java.util.concurrent TimeUnit]))

#_(ns org.bitcoinj.net.discovery #_"PeerDiscoveryException")

#_(ns org.bitcoinj.net.discovery #_"SeedPeers"
    (:import [java.net InetAddress InetSocketAddress UnknownHostException]
             [java.util.concurrent TimeUnit])
   (:require [org.bitcoinj.core NetworkParameters]))

;;;
 ; <p>Supports peer discovery through DNS.</p>
 ;
 ; <p>Failure to resolve individual host names will not cause an Exception to be thrown.
 ; However, if all hosts passed fail to resolve a PeerDiscoveryException will be thrown during getPeers().</p>
 ;
 ; <p>DNS seeds do not attempt to enumerate every peer on the network.
 ; {@link DnsDiscovery#getPeers(long, java.util.concurrent.TimeUnit)} will return up to 30 random peers
 ; from the set of those returned within the timeout period.  If you want more peers to connect to,
 ; you need to discover them via other means (like addr broadcasts).</p>
 ;;
#_public
(ยง class DnsDiscovery (ยง extends MultiplexingDiscovery)
    ;;;
     ; Supports finding peers through DNS A records.  Community run DNS entry points will be used.
     ;
     ; @param netParams Network parameters to be used for port information.
     ;;
    #_public
    (ยง constructor DnsDiscovery [#_"NetworkParameters" __netParams]
        (ยง this (.. __netParams (getDnsSeeds)), __netParams)
        this
    )

    ;;;
     ; Supports finding peers through DNS A records.
     ;
     ; @param dnsSeeds Host names to be examined for seed addresses.
     ; @param params Network parameters to be used for port information.
     ;;
    #_public
    (ยง constructor DnsDiscovery [#_"String[]" __dnsSeeds, #_"NetworkParameters" __params]
        (ยง super __params, (DnsDiscovery/buildDiscoveries __params, __dnsSeeds))
        this
    )

    #_private
    #_static
    (ยง defn- #_"List<PeerDiscovery>" DnsDiscovery/buildDiscoveries [#_"NetworkParameters" __params, #_"String[]" __seeds]
        (let [#_"List<PeerDiscovery>" __discoveries (ArrayList. #_"<>")]
            (when (some? __seeds)
                (doseq [#_"String" __seed __seeds]
                    (.. __discoveries (add (DnsDiscovery.DnsSeedDiscovery. __params, __seed)))
                )
            )
            __discoveries
        )
    )

    #_override
    #_protected
    (ยง method #_"ExecutorService" createExecutor []
        ;; Attempted workaround for reported bugs on Linux in which gethostbyname does not appear to be properly
        ;; thread safe and can cause segfaults on some libc versions.
        (if (.. (System/getProperty "os.name") (toLowerCase) (contains "linux"))
            (ยง return (Executors/newSingleThreadExecutor (ContextPropagatingThreadFactory. "DNS seed lookups")))
            (ยง return (Executors/newFixedThreadPool (.. (:seeds this) (size)), (DaemonThreadFactory. "DNS seed lookups")))
        )
    )

    ;;; Implements discovery from a single DNS host. ;;
    #_public
    #_static
    (ยง class DnsDiscovery.DnsSeedDiscovery (ยง implements PeerDiscovery)
        #_private
        (ยง field- #_"String" :hostname)
        #_private
        (ยง field- #_"NetworkParameters" :params)

        #_public
        (ยง constructor DnsDiscovery.DnsSeedDiscovery [#_"NetworkParameters" __params, #_"String" __hostname]
            (ยง assoc this :hostname __hostname)
            (ยง assoc this :params __params)
            this
        )

        #_override
        #_public
        #_throws #_[ "PeerDiscoveryException" ]
        (ยง method #_"InetSocketAddress[]" getPeers [#_"long" __services, #_"long" __timeoutValue, #_"TimeUnit" __timeoutUnit]
            (when (!= __services 0)
                (throw (PeerDiscoveryException. (str "DNS seeds cannot filter by services: " __services)))
            )

            (try
                (let [#_"InetAddress[]" __response (InetAddress/getAllByName (:hostname this))
                      #_"InetSocketAddress[]" __result (make-array InetSocketAddress (.. __response (alength)))]
                    (loop-when-recur [#_"int" __i 0] (< __i (.. __response (alength))) [(inc __i)]
                        (aset __result __i (InetSocketAddress. (aget __response __i), (.. (:params this) (getPort))))
                    )
                    (ยง return __result)
                )
                (catch UnknownHostException __e
                    (throw (PeerDiscoveryException. __e))
                )
            )
        )

        #_override
        #_public
        (ยง method #_"void" shutdown []
            nil
        )

        #_override
        #_public
        (ยง method #_"String" toString []
            (:hostname this)
        )
    )
)

;;;
 ; MultiplexingDiscovery queries multiple PeerDiscovery objects, shuffles their responses and then returns the results,
 ; thus selecting randomly between them and reducing the influence of any particular seed.  Any that don't respond
 ; within the timeout are ignored.  Backends are queried in parallel.  Backends may block.
 ;;
#_public
(ยง class MultiplexingDiscovery (ยง implements PeerDiscovery)
    #_private
    #_static
    (ยง def- #_"Logger" MultiplexingDiscovery/log (LoggerFactory/getLogger MultiplexingDiscovery))

    #_protected
    (ยง field #_"List<PeerDiscovery>" :seeds)
    #_protected
    (ยง field #_"NetworkParameters" :net-params)
    #_private
    #_volatile
    (ยง field- #_"ExecutorService" :v-thread-pool)

    ;;;
     ; Builds a suitable set of peer discoveries.  Will query them in parallel before producing a merged response.
     ; If specific services are required, DNS is not used as the protocol can't handle it.
     ; @param params Network to use.
     ; @param services Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     ;;
    #_public
    #_static
    (ยง defn #_"MultiplexingDiscovery" MultiplexingDiscovery/forServices [#_"NetworkParameters" __params, #_"long" __services]
        (let [#_"List<PeerDiscovery>" __discoveries (Lists/newArrayList)]
            ;; Also use DNS seeds if there is no specific service requirement.
            (when (== __services 0)
                (let [#_"String[]" __dnsSeeds (.. __params (getDnsSeeds))]
                    (when (some? __dnsSeeds)
                        (doseq [#_"String" __dnsSeed __dnsSeeds]
                            (.. __discoveries (add (DnsDiscovery.DnsSeedDiscovery. __params, __dnsSeed)))
                        )
                    )
                )
            )
            (MultiplexingDiscovery. __params, __discoveries)
        )
    )

    ;;;
     ; Will query the given seeds in parallel before producing a merged response.
     ;;
    #_public
    (ยง constructor MultiplexingDiscovery [#_"NetworkParameters" __params, #_"List<PeerDiscovery>" __seeds]
        (Preconditions/checkArgument (not (.. __seeds (isEmpty))))

        (ยง assoc this :net-params __params)
        (ยง assoc this :seeds __seeds)
        this
    )

    #_override
    #_public
    #_throws #_[ "PeerDiscoveryException" ]
    (ยง method #_"InetSocketAddress[]" getPeers [#_"long" __services, #_"long" __timeoutValue, #_"TimeUnit" __timeoutUnit]
        (ยง assoc this :v-thread-pool (.. this (createExecutor)))
        (try
            (let [#_"List<Callable<InetSocketAddress[]>>" __tasks (Lists/newArrayList)]
                (doseq [#_"PeerDiscovery" __seed (:seeds this)]
                    (.. __tasks (add (Callable. #_"<InetSocketAddress[]>"
                    (ยง anon
                        #_override
                        #_public
                        #_throws #_[ "Exception" ]
                        (ยง method #_"InetSocketAddress[]" call []
                            (.. __seed (getPeers __services, __timeoutValue, __timeoutUnit))
                        )
                    ))))
                )
                (let [#_"List<Future<InetSocketAddress[]>>" __futures (.. (:v-thread-pool this) (invokeAll __tasks, __timeoutValue, __timeoutUnit))
                      #_"ArrayList<InetSocketAddress>" __addrs (Lists/newArrayList)]
                    (loop-when-recur [#_"int" __i 0] (< __i (.. __futures (size))) [(inc __i)]
                        (let [#_"Future<InetSocketAddress[]>" __future (.. __futures (get __i))]
                            (when (.. __future (isCancelled))
                                (.. MultiplexingDiscovery/log (warn "Seed {}: timed out", (.. (:seeds this) (get __i))))
                                (ยง continue ) ;; Timed out.
                            )
                            (let [#_"InetSocketAddress[]" __inetAddresses]
                                (try
                                    (ยง ass __inetAddresses (.. __future (get)))
                                    (catch ExecutionException __e
                                        (.. MultiplexingDiscovery/log (warn "Seed {}: failed to look up: {}", (.. (:seeds this) (get __i)), (.. __e (getMessage))))
                                        (ยง continue )
                                    )
                                )
                                (Collections/addAll __addrs, __inetAddresses)
                            )
                        )
                    )
                    (when (== (.. __addrs (size)) 0)
                        (throw (PeerDiscoveryException. (str "No peer discovery returned any results in " (.. __timeoutUnit (toMillis __timeoutValue)) "ms. Check internet connection?")))
                    )

                    (Collections/shuffle __addrs)
                    (.. (:v-thread-pool this) (shutdownNow))
                    (ยง return (.. __addrs (toArray (make-array InetSocketAddress (.. __addrs (size))))))
                )
            )
            (catch InterruptedException __e
                (throw (PeerDiscoveryException. __e))
            )
            (finally
                (.. (:v-thread-pool this) (shutdown))
            )
        )
    )

    #_protected
    (ยง method #_"ExecutorService" createExecutor []
        (Executors/newFixedThreadPool (.. (:seeds this) (size)), (ContextPropagatingThreadFactory. "Multiplexing discovery"))
    )

    #_override
    #_public
    (ยง method #_"void" shutdown []
        (let [#_"ExecutorService" __tp (:v-thread-pool this)]
            (when (some? __tp)
                (.. __tp (shutdown))
            )
            nil
        )
    )
)

;;;
 ; A PeerDiscovery object is responsible for finding addresses of other nodes in the Bitcoin P2P network.
 ; Note that the addresses returned may or may not be accepting connections.
 ;;
#_public
(ยง interface PeerDiscovery
    ;; TODO: Flesh out this interface a lot more.

    ;;;
     ; Returns an array of addresses.  This method may block.
     ; @param services Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     ;;
    #_throws #_[ "PeerDiscoveryException" ]
    (ยง method #_"InetSocketAddress[]" getPeers [#_"long" __services, #_"long" __timeoutValue, #_"TimeUnit" __timeoutUnit])

    ;;; Stops any discovery in progress when we want to shut down quickly. ;;
    (ยง method #_"void" shutdown [])
)

#_public
(ยง class PeerDiscoveryException (ยง extends Exception)
    #_public
    (ยง constructor PeerDiscoveryException []
        (ยง super )
        this
    )

    #_public
    (ยง constructor PeerDiscoveryException [#_"String" __message]
        (ยง super __message)
        this
    )

    #_public
    (ยง constructor PeerDiscoveryException [#_"Throwable" __arg0]
        (ยง super __arg0)
        this
    )

    #_public
    (ยง constructor PeerDiscoveryException [#_"String" __message, #_"Throwable" __arg0]
        (ยง super __message, __arg0)
        this
    )
)

;;;
 ; SeedPeers stores a pre-determined list of Bitcoin node addresses.  These nodes are selected based on
 ; being active on the network for a long period of time.  The intention is to be a last resort way of finding
 ; a connection to the network, in case IRC and DNS fail.  The list comes from the Bitcoin C++ source code.
 ;;
#_public
(ยง class SeedPeers (ยง implements PeerDiscovery)
    #_private
    (ยง field- #_"NetworkParameters" :params)
    #_private
    (ยง field- #_"int[]" :seed-addrs)
    #_private
    (ยง field- #_"int" :pnseed-index)

    ;;;
     ; Supports finding peers by IP addresses.
     ;
     ; @param params Network parameters to be used for port information.
     ;;
    #_public
    (ยง constructor SeedPeers [#_"NetworkParameters" __params]
        (ยง this (.. __params (getAddrSeeds)), __params)
        this
    )

    ;;;
     ; Supports finding peers by IP addresses.
     ;
     ; @param seedAddrs IP addresses for seed addresses.
     ; @param params Network parameters to be used for port information.
     ;;
    #_public
    (ยง constructor SeedPeers [#_"int[]" __seedAddrs, #_"NetworkParameters" __params]
        (ยง assoc this :seed-addrs __seedAddrs)
        (ยง assoc this :params __params)
        this
    )

    ;;;
     ; Acts as an iterator, returning the address of each node in the list sequentially.
     ; Once all the list has been iterated, null will be returned for each subsequent query.
     ;
     ; @return InetSocketAddress - the address/port of the next node.
     ; @throws PeerDiscoveryException
     ;;
    #_nilable
    #_public
    #_throws #_[ "PeerDiscoveryException" ]
    (ยง method #_"InetSocketAddress" getPeer []
        (try
            (ยง return (.. this (nextPeer)))
            (catch UnknownHostException __e
                (throw (PeerDiscoveryException. __e))
            )
        )
    )

    #_nilable
    #_private
    #_throws #_[ "UnknownHostException", "PeerDiscoveryException" ]
    (ยง method- #_"InetSocketAddress" nextPeer []
        (when (or (nil? (:seed-addrs this)) (== (.. (:seed-addrs this) (alength)) 0))
            (throw (PeerDiscoveryException. "No IP address seeds configured; unable to find any peers"))
        )

        (when (<= (.. (:seed-addrs this) (alength)) (:pnseed-index this))
            (ยง return nil)
        )

        (let [#_"int" __i (:pnseed-index this)]
            (ยง assoc this :pnseed-index (inc (:pnseed-index this)))
            (InetSocketAddress. (.. this (convertAddress (aget (:seed-addrs this) __i))), (.. (:params this) (getPort)))
        )
    )

    ;;;
     ; Returns an array containing all the Bitcoin nodes within the list.
     ;;
    #_override
    #_public
    #_throws #_[ "PeerDiscoveryException" ]
    (ยง method #_"InetSocketAddress[]" getPeers [#_"long" __services, #_"long" __timeoutValue, #_"TimeUnit" __timeoutUnit]
        (when (!= __services 0)
            (throw (PeerDiscoveryException. (str "Pre-determined peers cannot be filtered by services: " __services)))
        )

        (try
            (ยง return (.. this (allPeers)))
            (catch UnknownHostException __e
                (throw (PeerDiscoveryException. __e))
            )
        )
    )

    #_private
    #_throws #_[ "UnknownHostException" ]
    (ยง method- #_"InetSocketAddress[]" allPeers []
        (let [#_"InetSocketAddress[]" __addresses (make-array InetSocketAddress (.. (:seed-addrs this) (alength)))]
            (loop-when-recur [#_"int" __i 0] (< __i (.. (:seed-addrs this) (alength))) [(inc __i)]
                (aset __addresses __i (InetSocketAddress. (.. this (convertAddress (aget (:seed-addrs this) __i))), (.. (:params this) (getPort))))
            )
            __addresses
        )
    )

    #_private
    #_throws #_[ "UnknownHostException" ]
    (ยง method- #_"InetAddress" convertAddress [#_"int" __seed]
        (let [#_"byte[]" __v4addr (byte-array 4)]
            (aset __v4addr 0 (byte (& 0xff __seed)))
            (aset __v4addr 1 (byte (& 0xff (>> __seed 8))))
            (aset __v4addr 2 (byte (& 0xff (>> __seed 16))))
            (aset __v4addr 3 (byte (& 0xff (>> __seed 24))))
            (InetAddress/getByAddress __v4addr)
        )
    )

    #_override
    #_public
    (ยง method #_"void" shutdown []
        nil
    )
)

#_(ns org.bitcoinj.params #_"AbstractBitcoinNetParams"
    (:import [java.math BigInteger]
             [java.util.concurrent TimeUnit])
    (:import [com.google.common.base Preconditions Stopwatch]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core BitcoinSerializer Block Coin NetworkParameters Sha256Hash StoredBlock Transaction Utils VerificationException]
             [org.bitcoinj.utils MonetaryFormat]
             [org.bitcoinj.store BlockStore BlockStoreException]))

#_(ns org.bitcoinj.params #_"MainNetParams"
    (:import [java.net *])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.net.discovery *]))

#_(ns org.bitcoinj.params #_"Networks"
    (:import [java.util Collection Set])
    (:import [com.google.common.collect ImmutableSet Lists])
   (:require [org.bitcoinj.core NetworkParameters]))

#_(ns org.bitcoinj.params #_"TestNet3Params"
    (:import [java.math BigInteger]
             [java.util Date])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.core Block NetworkParameters StoredBlock Utils VerificationException]
             [org.bitcoinj.store BlockStore BlockStoreException]))

#_(ns org.bitcoinj.params #_"UnitTestParams"
    (:import [java.math BigInteger])
   (:require [org.bitcoinj.core *]))

;;;
 ; Parameters for Bitcoin-like networks.
 ;;
#_public
#_abstract
(ยง class AbstractBitcoinNetParams (ยง extends NetworkParameters)
    ;;;
     ; Scheme part for Bitcoin URIs.
     ;;
    #_public
    #_static
    (ยง def #_"String" AbstractBitcoinNetParams/BITCOIN_SCHEME "bitcoin")
    #_public
    #_static
    (ยง def #_"int" AbstractBitcoinNetParams/REWARD_HALVING_INTERVAL 210000)

    #_private
    #_static
    (ยง def- #_"Logger" AbstractBitcoinNetParams/log (LoggerFactory/getLogger AbstractBitcoinNetParams))

    #_public
    (ยง constructor AbstractBitcoinNetParams []
        (ยง super )
        this
    )

    ;;;
     ; Checks if we are at a reward halving point.
     ; @param height The height of the previous stored block.
     ; @return if this is a reward halving point.
     ;;
    #_public
    (ยง method #_"boolean" isRewardHalvingPoint [#_"int" __height]
        (== (% (inc __height) AbstractBitcoinNetParams/REWARD_HALVING_INTERVAL) 0)
    )

    ;;;
     ; Checks if we are at a difficulty transition point.
     ; @param height The height of the previous stored block.
     ; @return if this is a difficulty transition point.
     ;;
    #_public
    (ยง method #_"boolean" isDifficultyTransitionPoint [#_"int" __height]
        (== (% (inc __height) (.. this (getInterval))) 0)
    )

    #_override
    #_public
    #_throws #_[ "VerificationException", "BlockStoreException" ]
    (ยง method #_"void" checkDifficultyTransitions [#_"StoredBlock" __storedPrev, #_"Block" __nextBlock, #_"BlockStore" __blockStore]
        (let [#_"Block" __prev (.. __storedPrev (getHeader))]

            ;; Is this supposed to be a difficulty transition point?
            (when (not (.. this (isDifficultyTransitionPoint (.. __storedPrev (getHeight)))))
                ;; No ... so check the difficulty didn't actually change.
                (when (!= (.. __nextBlock (getDifficultyTarget)) (.. __prev (getDifficultyTarget)))
                    (throw (VerificationException. (str "Unexpected change in difficulty at height " (.. __storedPrev (getHeight)) ": " (Long/toHexString (.. __nextBlock (getDifficultyTarget))) " vs " (Long/toHexString (.. __prev (getDifficultyTarget))))))
                )
                (ยง return nil)
            )

            ;; We need to find a block far back in the chain.  It's OK that this is expensive because it only occurs every
            ;; two weeks after the initial block chain download.
            (let [#_"Stopwatch" __watch (Stopwatch/createStarted)]

                (let [#_"Sha256Hash" __hash (.. __prev (getHash))
                      #_"StoredBlock" __cursor nil
                      #_"int" __interval (.. this (getInterval))]
                    (loop-when-recur [#_"int" __i 0] (< __i __interval) [(inc __i)]
                        (ยง ass __cursor (.. __blockStore (get __hash)))
                        (when (nil? __cursor)
                            ;; This should never happen.  If it does, it means we are following an incorrect or busted chain.
                            (throw (VerificationException. (str "Difficulty transition point but we did not find a way back to the last transition point. Not found: " __hash)))
                        )
                        (ยง ass __hash (.. __cursor (getHeader) (getPrevBlockHash)))
                    )
                    (Preconditions/checkState (and (some? __cursor) (.. this (isDifficultyTransitionPoint (dec (.. __cursor (getHeight)))))), "Didn't arrive at a transition point.")

                    (.. __watch (stop))
                    (when (< 50 (.. __watch (elapsed TimeUnit/MILLISECONDS)))
                        (.. AbstractBitcoinNetParams/log (info "Difficulty transition traversal took {}", __watch))
                    )

                    (let [#_"Block" __blockIntervalAgo (.. __cursor (getHeader))
                          #_"int" __timespan (int (- (.. __prev (getTimeSeconds)) (.. __blockIntervalAgo (getTimeSeconds))))]
                        ;; Limit the adjustment step.
                        (let [#_"int" __targetTimespan (.. this (getTargetTimespan))]
                            (when (< __timespan (/ __targetTimespan 4))
                                (ยง ass __timespan (/ __targetTimespan 4))
                            )
                            (when (> __timespan (* __targetTimespan 4))
                                (ยง ass __timespan (* __targetTimespan 4))
                            )

                            (let [#_"BigInteger" __newTarget (Utils/decodeCompactBits (.. __prev (getDifficultyTarget)))]
                                (ยง ass __newTarget (.. __newTarget (multiply (BigInteger/valueOf __timespan))))
                                (ยง ass __newTarget (.. __newTarget (divide (BigInteger/valueOf __targetTimespan))))

                                (when (< 0 (.. __newTarget (compareTo (.. this (getMaxTarget)))))
                                    (.. AbstractBitcoinNetParams/log (info "Difficulty hit proof of work limit: {}", (.. __newTarget (toString 16))))
                                    (ยง ass __newTarget (.. this (getMaxTarget)))
                                )

                                (let [#_"int" __accuracyBytes (- (int (>>> (.. __nextBlock (getDifficultyTarget)) 24)) 3)
                                      #_"long" __receivedTargetCompact (.. __nextBlock (getDifficultyTarget))]

                                    ;; The calculated difficulty is to a higher precision than received, so reduce here.
                                    (let [#_"BigInteger" __mask (.. (BigInteger/valueOf 0xffffff) (shiftLeft (* __accuracyBytes 8)))]
                                        (ยง ass __newTarget (.. __newTarget (and __mask)))
                                        (let [#_"long" __newTargetCompact (Utils/encodeCompactBits __newTarget)]

                                            (when (!= __newTargetCompact __receivedTargetCompact)
                                                (throw (VerificationException. (str "Network provided difficulty bits do not match what was calculated: " (Long/toHexString __newTargetCompact) " vs " (Long/toHexString __receivedTargetCompact))))
                                            )
                                            nil
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_override
    #_public
    (ยง method #_"Coin" getMaxMoney []
        NetworkParameters/MAX_MONEY
    )

    #_override
    #_public
    (ยง method #_"Coin" getMinNonDustOutput []
        Transaction/MIN_NONDUST_OUTPUT
    )

    #_override
    #_public
    (ยง method #_"MonetaryFormat" getMonetaryFormat []
        (MonetaryFormat.)
    )

    #_override
    #_public
    (ยง method #_"int" getProtocolVersionNum [#_"NetworkParameters.ProtocolVersion" __version]
        (.. __version (getBitcoinProtocolVersion))
    )

    #_override
    #_public
    (ยง method #_"BitcoinSerializer" getSerializer [#_"boolean" __parseRetain]
        (BitcoinSerializer. this, __parseRetain)
    )

    #_override
    #_public
    (ยง method #_"String" getUriScheme []
        AbstractBitcoinNetParams/BITCOIN_SCHEME
    )

    #_override
    #_public
    (ยง method #_"boolean" hasMaxMoney []
        true
    )
)

;;;
 ; Parameters for the main production network on which people trade goods and services.
 ;;
#_public
(ยง class MainNetParams (ยง extends AbstractBitcoinNetParams)
    #_public
    #_static
    (ยง def #_"int" MainNetParams/MAINNET_MAJORITY_WINDOW 1000)
    #_public
    #_static
    (ยง def #_"int" MainNetParams/MAINNET_MAJORITY_REJECT_BLOCK_OUTDATED 950)
    #_public
    #_static
    (ยง def #_"int" MainNetParams/MAINNET_MAJORITY_ENFORCE_BLOCK_UPGRADE 750)

    #_public
    (ยง constructor MainNetParams []
        (ยง super )

        (ยง assoc this :interval NetworkParameters/INTERVAL)
        (ยง assoc this :target-timespan NetworkParameters/TARGET_TIMESPAN)
        (ยง assoc this :max-target (Utils/decodeCompactBits 0x1d00ffff))
        (ยง assoc this :address-header 0)
        (ยง assoc this :p2sh-header 5)
        (ยง assoc this :acceptable-address-codes (int-array [ (:address-header this), (:p2sh-header this) ]))
        (ยง assoc this :port 8333)
        (ยง assoc this :packet-magic 0xf9beb4d9)
        (ยง assoc this :bip32-header-pub 0x0488b21e) ;; 4 byte header that serializes in base58 to "xpub"
        (ยง assoc this :bip32-header-priv 0x0488ade4) ;; 4 byte header that serializes in base58 to "xprv"

        (ยง assoc this :majority-enforce-block-upgrade MainNetParams/MAINNET_MAJORITY_ENFORCE_BLOCK_UPGRADE)
        (ยง assoc this :majority-reject-block-outdated MainNetParams/MAINNET_MAJORITY_REJECT_BLOCK_OUTDATED)
        (ยง assoc this :majority-window MainNetParams/MAINNET_MAJORITY_WINDOW)

        (.. (:genesis-block this) (setDifficultyTarget 0x1d00ffff))
        (.. (:genesis-block this) (setTime 1231006505))
        (.. (:genesis-block this) (setNonce 2083236893))
        (ยง assoc this :id NetworkParameters/ID_MAINNET)
        (ยง assoc this :subsidy-decrease-block-count 210000)
        (ยง assoc this :spendable-coinbase-depth 100)
        (let [#_"String" __genesisHash (.. (:genesis-block this) (getHashAsString))]
            (Preconditions/checkState (.. __genesisHash (equals "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f")), __genesisHash)

            ;; This contains (at a minimum) the blocks which are not BIP30 compliant.  BIP30 changed how duplicate
            ;; transactions are handled.  Duplicated transactions could occur in the case where a coinbase had the same
            ;; extraNonce and the same outputs but appeared at different heights, and greatly complicated re-org handling.
            ;; Having these here simplifies block connection logic considerably.
            (.. (:checkpoints this) (put 91722, (Sha256Hash/wrap "00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e")))
            (.. (:checkpoints this) (put 91812, (Sha256Hash/wrap "00000000000af0aed4792b1acee3d966af36cf5def14935db8de83d6f9306f2f")))
            (.. (:checkpoints this) (put 91842, (Sha256Hash/wrap "00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec")))
            (.. (:checkpoints this) (put 91880, (Sha256Hash/wrap "00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721")))
            (.. (:checkpoints this) (put 200000, (Sha256Hash/wrap "000000000000034a7dedef4a161fa058a2d67a173a90155f3a2fe6fc132e0ebf")))

            (ยง assoc this :dns-seeds (into-array String
            [
                "seed.bitcoin.sipa.be",          ;; Pieter Wuille
                "dnsseed.bluematt.me",           ;; Matt Corallo
                "dnsseed.bitcoin.dashjr.org",    ;; Luke Dashjr
                "seed.bitcoinstats.com",         ;; Chris Decker
                "seed.bitnodes.io",              ;; Addy Yeow
                "bitseed.xf2.org",               ;; Jeff Garzik
                "seed.bitcoin.jonasschnelli.ch", ;; Jonas Schnelli
            ]))

            (ยง assoc this :addr-seeds (int-array
            [
                0x1ddb1032, 0x6242ce40, 0x52d6a445, 0x2dd7a445, 0x8a53cd47, 0x73263750, 0xda23c257, 0xecd4ed57,
                0x0a40ec59, 0x75dce160, 0x7df76791, 0x89370bad, 0xa4f214ad, 0x767700ae, 0x638b0418, 0x868a1018,
                0xcd9f332e, 0x0129653e, 0xcc92dc3e, 0x96671640, 0x56487e40, 0x5b66f440, 0xb1d01f41, 0xf1dc6041,
                0xc1d12b42, 0x86ba1243, 0x6be4df43, 0x6d4cef43, 0xd18e0644, 0x1ab0b344, 0x6584a345, 0xe7c1a445,
                0x58cea445, 0xc5daa445, 0x21dda445, 0x3d3b5346, 0x13e55347, 0x1080d24a, 0x8e611e4b, 0x81518e4b,
                0x6c839e4b, 0xe2ad0a4c, 0xfbbc0a4c, 0x7f5b6e4c, 0x7244224e, 0x1300554e, 0x20690652, 0x5a48b652,
                0x75c5c752, 0x4335cc54, 0x340fd154, 0x87c07455, 0x087b2b56, 0x8a133a57, 0xac23c257, 0x70374959,
                0xfb63d45b, 0xb9a1685c, 0x180d765c, 0x674f645d, 0x04d3495e, 0x1de44b5e, 0x4ee8a362, 0x0ded1b63,
                0xc1b04b6d, 0x8d921581, 0x97b7ea82, 0x1cf83a8e, 0x91490bad, 0x09dc75ae, 0x9a6d79ae, 0xa26d79ae,
                0x0fd08fae, 0x0f3e3fb2, 0x4f944fb2, 0xcca448b8, 0x3ecd6ab8, 0xa9d5a5bc, 0x8d0119c1, 0x045997d5,
                0xca019dd9, 0x0d526c4d, 0xabf1ba44, 0x66b1ab55, 0x1165f462, 0x3ed7cbad, 0xa38fae6e, 0x3bd2cbad,
                0xd36f0547, 0x20df7840, 0x7a337742, 0x549f8e4b, 0x9062365c, 0xd399f562, 0x2b5274a1, 0x8edfa153,
                0x3bffb347, 0x7074bf58, 0xb74fcbad, 0x5b5a795b, 0x02fa29ce, 0x5a6738d4, 0xe8a1d23e, 0xef98c445,
                0x4b0f494c, 0xa2bc1e56, 0x7694ad63, 0xa4a800c3, 0x05fda6cd, 0x9f22175e, 0x364a795b, 0x536285d5,
                0xac44c9d4, 0x0b06254d, 0x150c2fd4, 0x32a50dcc, 0xfd79ce48, 0xf15cfa53, 0x66c01e60, 0x6bc26661,
                0xc03b47ae, 0x4dda1b81, 0x3285a4c1, 0x883ca96d, 0x35d60a4c, 0xdae09744, 0x2e314d61, 0x84e247cf,
                0x6c814552, 0x3a1cc658, 0x98d8f382, 0xe584cb5b, 0x15e86057, 0x7b01504e, 0xd852dd48, 0x56382f56,
                0x0a5df454, 0xa0d18d18, 0x2e89b148, 0xa79c114c, 0xcbdcd054, 0x5523bc43, 0xa9832640, 0x8a066144,
                0x3894c3bc, 0xab76bf58, 0x6a018ac1, 0xfebf4f43, 0x2f26c658, 0x31102f4e, 0x85e929d5, 0x2a1c175e,
                0xfc6c2cd1, 0x27b04b6d, 0xdf024650, 0x161748b8, 0x28be6580, 0x57be6580, 0x1cee677a, 0xaa6bb742,
                0x9a53964b, 0x0a5a2d4d, 0x2434c658, 0x9a494f57, 0x1ebb0e48, 0xf610b85d, 0x077ecf44, 0x085128bc,
                0x5ba17a18, 0x27ca1b42, 0xf8a00b56, 0xfcd4c257, 0xcf2fc15e, 0xd897e052, 0x4cada04f, 0x2f35f6d5,
                0x382ce8c9, 0xe523984b, 0x3f946846, 0x60c8be43, 0x41da6257, 0xde0be142, 0xae8a544b, 0xeff0c254,
                0x1e0f795b, 0xaeb28890, 0xca16acd9, 0x1e47ddd8, 0x8c8c4829, 0xd27dc747, 0xd53b1663, 0x4096b163,
                0x9c8dd958, 0xcb12f860, 0x9e79305c, 0x40c1a445, 0x4a90c2bc, 0x2c3a464d, 0x2727f23c, 0x30b04b6d,
                0x59024cb8, 0xa091e6ad, 0x31b04b6d, 0xc29d46a6, 0x63934fb2, 0xd9224dbe, 0x9f5910d8, 0x7f530a6b,
                0x752e9c95, 0x65453548, 0xa484be46, 0xce5a1b59, 0x710e0718, 0x46a13d18, 0xdaaf5318, 0xc4a8ff53,
                0x87abaa52, 0xb764cf51, 0xb2025d4a, 0x6d351e41, 0xc035c33e, 0xa432c162, 0x61ef34ae, 0xd16fddbc,
                0x0870e8c1, 0x3070e8c1, 0x9c71e8c1, 0xa4992363, 0x85a1f663, 0x4184e559, 0x18d96ed8, 0x17b8dbd5,
                0x60e7cd18, 0xe5ee104c, 0xab17ac62, 0x1e786e1b, 0x5d23b762, 0xf2388fae, 0x88270360, 0x9e5b3d80,
                0x7da518b2, 0xb5613b45, 0x1ad41f3e, 0xd550854a, 0x8617e9a9, 0x925b229c, 0xf2e92542, 0x47af0544,
                0x73b5a843, 0xb9b7a0ad, 0x03a748d0, 0x0a6ff862, 0x6694df62, 0x3bfac948, 0x8e098f4f, 0x746916c3,
                0x02f38e4f, 0x40bb1243, 0x6a54d162, 0x6008414b, 0xa513794c, 0x514aa343, 0x63781747, 0xdbb6795b,
                0xed065058, 0x42d24b46, 0x1518794c, 0x9b271681, 0x73e4ffad, 0x0654784f, 0x438dc945, 0x641846a6,
                0x2d1b0944, 0x94b59148, 0x8d369558, 0xa5a97662, 0x8b705b42, 0xce9204ae, 0x8d584450, 0x2df61555,
                0xeebff943, 0x2e75fb4d, 0x3ef8fc57, 0x9921135e, 0x8e31042e, 0xb5afad43, 0x89ecedd1, 0x9cfcc047,
                0x8fcd0f4c, 0xbe49f5ad, 0x146a8d45, 0x98669ab8, 0x98d9175e, 0xd1a8e46d, 0x839a3ab8, 0x40a0016c,
                0x6d27c257, 0x977fffad, 0x7baa5d5d, 0x1213be43, 0xb167e5a9, 0x640fe8ca, 0xbc9ea655, 0x0f820a4c,
                0x0f097059, 0x69ac957c, 0x366d8453, 0xb1ba2844, 0x8857f081, 0x70b5be63, 0xc545454b, 0xaf36ded1,
                0xb5a4b052, 0x21f062d1, 0x72ab89b2, 0x74a45318, 0x8312e6bc, 0xb916965f, 0x8aa7c858, 0xfe7effad,
            ]))
            this
        )
    )

    #_private
    #_static
    (ยง def- #_"MainNetParams" MainNetParams/INSTANCE)

    #_public
    #_static
    #_synchronized
    (ยง defn #_"MainNetParams" MainNetParams/get []
        (when (nil? MainNetParams/INSTANCE)
            (ยง ass MainNetParams/INSTANCE (MainNetParams.))
        )
        MainNetParams/INSTANCE
    )

    #_override
    #_public
    (ยง method #_"String" getPaymentProtocolId []
        NetworkParameters/PAYMENT_PROTOCOL_ID_MAINNET
    )
)

;;;
 ; Utility class that holds all the registered NetworkParameters types used for Address auto discovery.
 ; By default only MainNetParams and TestNet3Params are used.  If you want to use UnitTestParams, use
 ; the register and unregister the TestNet3Params as they don't have their own address version/type code.
 ;;
#_public
(ยง class Networks
    ;;; Registered networks. ;;
    #_private
    #_static
    (ยง def- #_"Set<? extends NetworkParameters>" Networks/NETWORKS (ImmutableSet/of (TestNet3Params/get), (MainNetParams/get)))

    #_public
    #_static
    (ยง defn #_"Set<? extends NetworkParameters>" Networks/get []
        Networks/NETWORKS
    )

    #_public
    #_static
    (ยง defn #_"void" Networks/register [#_"NetworkParameters" __network]
        (Networks/register (Lists/newArrayList __network))
        nil
    )

    #_public
    #_static
    (ยง defn #_"void" Networks/register [#_"Collection<? extends NetworkParameters>" __networks]
        (let [#_"ImmutableSet.Builder<NetworkParameters>" __builder (ImmutableSet/builder)]
            (.. __builder (addAll Networks/NETWORKS))
            (.. __builder (addAll __networks))
            (ยง ass Networks/NETWORKS (.. __builder (build)))
            nil
        )
    )

    #_public
    #_static
    (ยง defn #_"void" Networks/unregister [#_"NetworkParameters" __network]
        (when (.. Networks/NETWORKS (contains __network))
            (let [#_"ImmutableSet.Builder<NetworkParameters>" __builder (ImmutableSet/builder)]

                (doseq [#_"NetworkParameters" __parameters Networks/NETWORKS]
                    (when (not (.. __parameters (equals __network)))
                        (.. __builder (add __parameters))
                    )
                )

                (ยง ass Networks/NETWORKS (.. __builder (build)))
            )
        )
        nil
    )
)

;;;
 ; Parameters for the testnet, a separate public instance of Bitcoin that has relaxed rules suitable for development
 ; and testing of applications and new Bitcoin versions.
 ;;
#_public
(ยง class TestNet3Params (ยง extends AbstractBitcoinNetParams)
    #_public
    #_static
    (ยง def #_"int" TestNet3Params/TESTNET_MAJORITY_WINDOW 100)
    #_public
    #_static
    (ยง def #_"int" TestNet3Params/TESTNET_MAJORITY_REJECT_BLOCK_OUTDATED 75)
    #_public
    #_static
    (ยง def #_"int" TestNet3Params/TESTNET_MAJORITY_ENFORCE_BLOCK_UPGRADE 51)

    #_public
    (ยง constructor TestNet3Params []
        (ยง super )

        (ยง assoc this :id NetworkParameters/ID_TESTNET)
        (ยง assoc this :packet-magic 0x0b110907)
        (ยง assoc this :interval NetworkParameters/INTERVAL)
        (ยง assoc this :target-timespan NetworkParameters/TARGET_TIMESPAN)
        (ยง assoc this :max-target (Utils/decodeCompactBits 0x1d00ffff))
        (ยง assoc this :port 18333)
        (ยง assoc this :address-header 111)
        (ยง assoc this :p2sh-header 196)
        (ยง assoc this :acceptable-address-codes (int-array [ (:address-header this), (:p2sh-header this) ]))
        (.. (:genesis-block this) (setTime 1296688602))
        (.. (:genesis-block this) (setDifficultyTarget 0x1d00ffff))
        (.. (:genesis-block this) (setNonce 414098458))
        (ยง assoc this :spendable-coinbase-depth 100)
        (ยง assoc this :subsidy-decrease-block-count 210000)
        (let [#_"String" __genesisHash (.. (:genesis-block this) (getHashAsString))]
            (Preconditions/checkState (.. __genesisHash (equals "000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943")))
            (ยง assoc this :alert-signing-key (.. Utils/HEX (decode "04302390343f91cc401d56d68b123028bf52e5fca1939df127f63c6467cdf9c8e2c14b61104cf817d0b780da337893ecc4aaff1309e536162dabbdb45200ca2b0a")))

            (ยง assoc this :dns-seeds (into-array String
            [
                "testnet-seed.bitcoin.jonasschnelli.ch", ;; Jonas Schnelli
                "testnet-seed.bluematt.me",              ;; Matt Corallo
                "testnet-seed.bitcoin.petertodd.org",    ;; Peter Todd
                "testnet-seed.bitcoin.schildbach.de",    ;; Andreas Schildbach
            ]))
            (ยง assoc this :addr-seeds nil)
            (ยง assoc this :bip32-header-pub 0x043587cf)
            (ยง assoc this :bip32-header-priv 0x04358394)

            (ยง assoc this :majority-enforce-block-upgrade TestNet3Params/TESTNET_MAJORITY_ENFORCE_BLOCK_UPGRADE)
            (ยง assoc this :majority-reject-block-outdated TestNet3Params/TESTNET_MAJORITY_REJECT_BLOCK_OUTDATED)
            (ยง assoc this :majority-window TestNet3Params/TESTNET_MAJORITY_WINDOW)
            this
        )
    )

    #_private
    #_static
    (ยง def- #_"TestNet3Params" TestNet3Params/INSTANCE)

    #_public
    #_static
    #_synchronized
    (ยง defn #_"TestNet3Params" TestNet3Params/get []
        (when (nil? TestNet3Params/INSTANCE)
            (ยง ass TestNet3Params/INSTANCE (TestNet3Params.))
        )
        TestNet3Params/INSTANCE
    )

    #_override
    #_public
    (ยง method #_"String" getPaymentProtocolId []
        NetworkParameters/PAYMENT_PROTOCOL_ID_TESTNET
    )

    ;; February 16th 2012
    #_private
    #_static
    (ยง def- #_"Date" TestNet3Params/TESTNET_DIFF_DATE (Date. 1329264000000))

    #_override
    #_public
    #_throws #_[ "VerificationException", "BlockStoreException" ]
    (ยง method #_"void" checkDifficultyTransitions [#_"StoredBlock" __storedPrev, #_"Block" __nextBlock, #_"BlockStore" __blockStore]
        (cond (and (not (.. this (isDifficultyTransitionPoint (.. __storedPrev (getHeight))))) (.. __nextBlock (getTime) (after TestNet3Params/TESTNET_DIFF_DATE)))
            (do
                (let [#_"Block" __prev (.. __storedPrev (getHeader))]

                    ;; After 15th February 2012 the rules on the testnet change to avoid people running up the difficulty
                    ;; and then leaving, making it too hard to mine a block.  On non-difficulty transition points, easy
                    ;; blocks are allowed if there has been a span of 20 minutes without one.
                    (let [#_"long" __timeDelta (- (.. __nextBlock (getTimeSeconds)) (.. __prev (getTimeSeconds)))]
                        ;; There is an integer underflow bug in bitcoin-qt that means mindiff blocks are accepted when time
                        ;; goes backwards.
                        (when (and (<= 0 __timeDelta) (<= __timeDelta (* 2 NetworkParameters/TARGET_SPACING)))
                            ;; Walk backwards until we find a block that doesn't have the easiest proof of work, then check
                            ;; that difficulty is equal to that one.
                            (let [#_"StoredBlock" __cursor __storedPrev]
                                (while (and (not (.. __cursor (getHeader) (equals (.. this (getGenesisBlock))))) (!= (% (.. __cursor (getHeight)) (.. this (getInterval))) 0) (.. __cursor (getHeader) (getDifficultyTargetAsInteger) (equals (.. this (getMaxTarget)))))
                                    (ยง ass __cursor (.. __cursor (getPrev __blockStore)))
                                )
                                (let [#_"BigInteger" __cursorTarget (.. __cursor (getHeader) (getDifficultyTargetAsInteger))
                                      #_"BigInteger" __newTarget (.. __nextBlock (getDifficultyTargetAsInteger))]
                                    (when (not (.. __cursorTarget (equals __newTarget)))
                                        (throw (VerificationException. (str "Testnet block transition that is not allowed: " (Long/toHexString (.. __cursor (getHeader) (getDifficultyTarget))) " vs " (Long/toHexString (.. __nextBlock (getDifficultyTarget))))))
                                    )
                                )
                            )
                        )
                    )
                )
            )
            :else
            (do
                (.. super (checkDifficultyTransitions __storedPrev, __nextBlock, __blockStore))
            )
        )
        nil
    )
)

;;;
 ; Network parameters used by the bitcoinj unit tests (and potentially your own).  This lets you solve a block using
 ; {@link org.bitcoinj.core.Block#solve()} by setting difficulty to the easiest possible.
 ;;
#_public
(ยง class UnitTestParams (ยง extends AbstractBitcoinNetParams)
    #_public
    #_static
    (ยง def #_"int" UnitTestParams/UNITNET_MAJORITY_WINDOW 8)
    #_public
    #_static
    (ยง def #_"int" UnitTestParams/UNITNET_MAJORITY_REJECT_BLOCK_OUTDATED 6)
    #_public
    #_static
    (ยง def #_"int" UnitTestParams/UNITNET_MAJORITY_ENFORCE_BLOCK_UPGRADE 4)

    #_public
    (ยง constructor UnitTestParams []
        (ยง super )

        (ยง assoc this :id NetworkParameters/ID_UNITTESTNET)
        (ยง assoc this :packet-magic 0x0b110907)
        (ยง assoc this :address-header 111)
        (ยง assoc this :p2sh-header 196)
        (ยง assoc this :acceptable-address-codes (int-array [ (:address-header this), (:p2sh-header this) ]))
        (ยง assoc this :max-target (BigInteger. "00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16))
        (.. (:genesis-block this) (setTime (/ (System/currentTimeMillis) 1000)))
        (.. (:genesis-block this) (setDifficultyTarget Block/EASIEST_DIFFICULTY_TARGET))
        (.. (:genesis-block this) (solve))
        (ยง assoc this :port 18333)
        (ยง assoc this :interval 10)
        (ยง assoc this :target-timespan 200000000) ;; 6 years.  Just a very big number.
        (ยง assoc this :spendable-coinbase-depth 5)
        (ยง assoc this :subsidy-decrease-block-count 100)
        (ยง assoc this :dns-seeds nil)
        (ยง assoc this :addr-seeds nil)
        (ยง assoc this :bip32-header-pub 0x043587cf)
        (ยง assoc this :bip32-header-priv 0x04358394)

        (ยง assoc this :majority-enforce-block-upgrade 3)
        (ยง assoc this :majority-reject-block-outdated 4)
        (ยง assoc this :majority-window 7)
        this
    )

    #_private
    #_static
    (ยง def- #_"UnitTestParams" UnitTestParams/INSTANCE)

    #_public
    #_static
    #_synchronized
    (ยง defn #_"UnitTestParams" UnitTestParams/get []
        (when (nil? UnitTestParams/INSTANCE)
            (ยง ass UnitTestParams/INSTANCE (UnitTestParams.))
        )
        UnitTestParams/INSTANCE
    )

    #_override
    #_public
    (ยง method #_"String" getPaymentProtocolId []
        "unittest"
    )
)

#_(ns org.bitcoinj.script #_"Script"
    (:import [java.io ByteArrayInputStream ByteArrayOutputStream IOException OutputStream]
             [java.math BigInteger]
             [java.security MessageDigest NoSuchAlgorithmException]
             [java.util *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto.digests RIPEMD160Digest])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.crypto TransactionSignature]
             [org.bitcoinj.script ScriptOpCodes]))

#_(ns org.bitcoinj.script #_"ScriptBuilder"
    (:import [java.math BigInteger]
             [java.util ArrayList Arrays Collections List Stack])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists])
   (:require [org.bitcoinj.core Address ECKey Utils]
             [org.bitcoinj.crypto TransactionSignature]
             [org.bitcoinj.script ScriptOpCodes]))

#_(ns org.bitcoinj.script #_"ScriptChunk"
    (:import [java.io IOException OutputStream]
             [java.util Arrays])
    (:import [com.google.common.base Objects Preconditions])
   (:require [org.bitcoinj.core Utils]
             [org.bitcoinj.script ScriptOpCodes]))

#_(ns org.bitcoinj.script #_"ScriptError"
    (:import [java.util HashMap Map]))

#_(ns org.bitcoinj.script #_"ScriptOpCodes"
    (:import [java.util Map])
    (:import [com.google.common.collect ImmutableMap]))

;; TODO: Redesign this entire API to be more type safe and organised.

;;;
 ; <p>Programs embedded inside transactions that control redemption of payments.</p>
 ;
 ; <p>Bitcoin transactions don't specify what they do directly.  Instead
 ; <a href="https://en.bitcoin.it/wiki/Script">a small binary stack language</a> is used to define programs that
 ; when evaluated, return whether the transaction "accepts" or rejects the other transactions connected to it.</p>
 ;
 ; <p>In SPV mode, scripts are not run, because that would require all transactions to be available and lightweight
 ; clients don't have that data.  In full mode, this class is used to run the interpreted language.  It also has
 ; static methods for building scripts.</p>
 ;;
#_public
(ยง class Script
    ;;; Enumeration to encapsulate the type of this script. ;;
    #_public
    (ยง enum Script.ScriptType
        ;; Do NOT change the ordering of the following definitions because their ordinals are stored in databases.
        (ยง item NO_TYPE)
        (ยง item P2PKH)
        (ยง item PUB_KEY)
        (ยง item P2SH)
    )

    ;;; Flags to pass to {@link Script#correctlySpends(Transaction, long, Script, Set)}.
     ; Note currently only P2SH, DERSIG and NULLDUMMY are actually supported.
     ;;
    #_public
    (ยง enum Script.VerifyFlag
        (ยง item P2SH) ;; Enable BIP16-style subscript evaluation.
        (ยง item STRICTENC) ;; Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.
        (ยง item DERSIG) ;; Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP66 rule 1).
        (ยง item LOW_S) ;; Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure.
        (ยง item NULLDUMMY) ;; Verify dummy stack item consumed by CHECKMULTISIG is of zero-length.
        (ยง item SIGPUSHONLY) ;; Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).
        (ยง item MINIMALDATA) ;; Require minimal encodings for all push operations.
        (ยง item DISCOURAGE_UPGRADABLE_NOPS) ;; Discourage use of NOPs reserved for upgrades (NOP1-10).
        (ยง item CLEANSTACK) ;; Require that only a single stack element remains after evaluation.
        (ยง item CHECKLOCKTIMEVERIFY) ;; Enable CHECKLOCKTIMEVERIFY operation.
        (ยง item CHECKSEQUENCEVERIFY) ;; Enable CHECKSEQUENCEVERIFY operation.
    )
    #_public
    #_static
    (ยง def #_"EnumSet<Script.VerifyFlag>" Script/ALL_VERIFY_FLAGS (EnumSet/allOf Script.VerifyFlag))

    #_private
    #_static
    (ยง def- #_"Logger" Script/log (LoggerFactory/getLogger Script))

    #_public
    #_static
    (ยง def #_"long" Script/MAX_SCRIPT_ELEMENT_SIZE 520) ;; bytes
    #_private
    #_static
    (ยง def- #_"int" Script/MAX_OPS_PER_SCRIPT 201)
    #_private
    #_static
    (ยง def- #_"int" Script/MAX_STACK_SIZE 1000)
    #_private
    #_static
    (ยง def- #_"int" Script/MAX_PUBKEYS_PER_MULTISIG 20)
    #_private
    #_static
    (ยง def- #_"int" Script/MAX_SCRIPT_SIZE 10000)
    #_public
    #_static
    (ยง def #_"int" Script/SIG_SIZE 75)
    ;;; Max number of sigops allowed in a standard p2sh redeem script. ;;
    #_public
    #_static
    (ยง def #_"int" Script/MAX_P2SH_SIGOPS 15)

    ;; The program is a set of chunks where each element is either [opcode] or [data, data, data ...].
    #_protected
    (ยง field #_"List<ScriptChunk>" :chunks)
    ;; Unfortunately, scripts are not ever re-serialized or canonicalized when used in signature hashing.
    ;; Thus we must preserve the exact bytes that we read off the wire, along with the parsed form.
    #_protected
    (ยง field #_"byte[]" :program)

    ;; Creation time of the associated keys in seconds since the epoch.
    #_private
    (ยง field- #_"long" :creation-time-seconds)

    ;;; Creates an empty script that serializes to nothing. ;;
    #_private
    (ยง constructor- #_"Script" []
        (ยง assoc this :chunks (Lists/newArrayList))
        this
    )

    ;; Used from ScriptBuilder.
    (ยง constructor Script [#_"List<ScriptChunk>" __chunks]
        (ยง assoc this :chunks (Collections/unmodifiableList (ArrayList. #_"<>" __chunks)))
        (ยง assoc this :creation-time-seconds (Utils/currentTimeSeconds))
        this
    )

    ;;;
     ; Construct a Script that copies and wraps the programBytes array.
     ; The array is parsed and checked for syntactic validity.
     ; @param programBytes Array of program bytes from a transaction.
     ;;
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง constructor Script [#_"byte[]" __programBytes]
        (ยง assoc this :program __programBytes)
        (.. this (parse __programBytes))
        (ยง assoc this :creation-time-seconds 0)
        this
    )

    #_public
    #_throws #_[ "ScriptException" ]
    (ยง constructor Script [#_"byte[]" __programBytes, #_"long" __creationTimeSeconds]
        (ยง assoc this :program __programBytes)
        (.. this (parse __programBytes))
        (ยง assoc this :creation-time-seconds __creationTimeSeconds)
        this
    )

    #_public
    (ยง method #_"long" getCreationTimeSeconds []
        (:creation-time-seconds this)
    )

    #_public
    (ยง method #_"void" setCreationTimeSeconds [#_"long" __creationTimeSeconds]
        (ยง assoc this :creation-time-seconds __creationTimeSeconds)
        nil
    )

    ;;;
     ; Returns the program opcodes as a string, for example "[1234] DUP HASH160".
     ;;
    #_override
    #_public
    (ยง method #_"String" toString []
        (.. Utils/SPACE_JOINER (join (:chunks this)))
    )

    ;;; Returns the serialized program as a newly created byte array. ;;
    #_public
    (ยง method #_"byte[]" getProgram []
        (try
            ;; Don't round-trip as Bitcoin Core doesn't and it would introduce a mismatch.
            (when (some? (:program this))
                (ยง return (Arrays/copyOf (:program this), (.. (:program this) (alength))))
            )

            (let [#_"ByteArrayOutputStream" __bos (ByteArrayOutputStream.)]
                (doseq [#_"ScriptChunk" __chunk (:chunks this)]
                    (.. __chunk (write __bos))
                )
                (ยง assoc this :program (.. __bos (toByteArray)))
                (ยง return (:program this))
            )
            (catch IOException __e
                (throw (RuntimeException. __e)) ;; Cannot happen.
            )
        )
    )

    ;;; Returns an immutable list of the scripts parsed form.  Each chunk is either an opcode or data element. ;;
    #_public
    (ยง method #_"List<ScriptChunk>" getChunks []
        (Collections/unmodifiableList (:chunks this))
    )

    #_private
    #_static
    (ยง def- #_"ScriptChunk[]" Script/STANDARD_TRANSACTION_SCRIPT_CHUNKS
    (ยง coll
        (ScriptChunk. ScriptOpCodes/OP_DUP, nil, 0)
        (ScriptChunk. ScriptOpCodes/OP_HASH160, nil, 1)
        (ScriptChunk. ScriptOpCodes/OP_EQUALVERIFY, nil, 23)
        (ScriptChunk. ScriptOpCodes/OP_CHECKSIG, nil, 24)
    ))

    ;;;
     ; <p>To run a script, first we parse it which breaks it up into chunks representing pushes of data
     ; or logical opcodes.  Then we can run the parsed chunks.</p>
     ;
     ; <p>The reason for this split, instead of just interpreting directly, is to make it easier
     ; to reach into a programs structure and pull out bits of data without having to run it.
     ; This is necessary to render the to/from addresses of transactions in a user interface.
     ; Bitcoin Core does something similar.</p>
     ;;
    #_private
    #_throws #_[ "ScriptException" ]
    (ยง method- #_"void" parse [#_"byte[]" __program]
        (ยง assoc this :chunks (ArrayList. #_"<>" 5)) ;; Common size.
        (let [#_"ByteArrayInputStream" __bis (ByteArrayInputStream. __program)
              #_"int" __initialSize (.. __bis (available))]
            (while (< 0 (.. __bis (available)))
                (let [#_"int" __startLocationInProgram (- __initialSize (.. __bis (available)))
                      #_"int" __opcode (.. __bis (read))]

                    (let [#_"long" __dataToRead -1]
                        (cond (< -1 __opcode ScriptOpCodes/OP_PUSHDATA1)
                            (do
                                ;; Read some bytes of data, where how many is the opcode value itself.
                                (ยง ass __dataToRead __opcode)
                            )
                            (== __opcode ScriptOpCodes/OP_PUSHDATA1)
                            (do
                                (when (< (.. __bis (available)) 1)
                                    (throw (ScriptException. ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Unexpected end of script"))
                                )
                                (ยง ass __dataToRead (.. __bis (read)))
                            )
                            (== __opcode ScriptOpCodes/OP_PUSHDATA2)
                            (do
                                ;; Read a short, then read that many bytes of data.
                                (when (< (.. __bis (available)) 2)
                                    (throw (ScriptException. ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Unexpected end of script"))
                                )
                                (ยง ass __dataToRead (| (.. __bis (read)) (<< (.. __bis (read)) 8)))
                            )
                            (== __opcode ScriptOpCodes/OP_PUSHDATA4)
                            (do
                                ;; Read a uint32, then read that many bytes of data.
                                ;; Though this is allowed, because its value cannot be > 520, it should never actually be used.
                                (when (< (.. __bis (available)) 4)
                                    (throw (ScriptException. ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Unexpected end of script"))
                                )
                                (ยง ass __dataToRead (| (long (.. __bis (read))) (<< (long (.. __bis (read))) 8) (<< (long (.. __bis (read))) 16) (<< (long (.. __bis (read))) 24)))
                            )
                        )

                        (let [#_"ScriptChunk" __chunk]
                            (cond (== __dataToRead -1)
                                (do
                                    (ยง ass __chunk (ScriptChunk. __opcode, nil, __startLocationInProgram))
                                )
                                :else
                                (do
                                    (when (< (.. __bis (available)) __dataToRead)
                                        (throw (ScriptException. ScriptError/SCRIPT_ERR_BAD_OPCODE, "Push of data element that is larger than remaining data"))
                                    )

                                    (let [#_"byte[]" __data (byte-array (int __dataToRead))]
                                        (Preconditions/checkState (or (== __dataToRead 0) (== (.. __bis (read __data, 0, (int __dataToRead))) __dataToRead)))
                                        (ยง ass __chunk (ScriptChunk. __opcode, __data, __startLocationInProgram))
                                    )
                                )
                            )
                            ;; Save some memory by eliminating redundant copies of the same chunk objects.
                            (doseq [#_"ScriptChunk" __c Script/STANDARD_TRANSACTION_SCRIPT_CHUNKS]
                                (when (.. __c (equals __chunk))
                                    (ยง ass __chunk __c)
                                )
                            )
                            (.. (:chunks this) (add __chunk))
                        )
                    )
                )
            )
            nil
        )
    )

    ;;;
     ; Returns true if this script is of the form <pubkey> OP_CHECKSIG.  This form was originally intended for
     ; transactions where the peers talked to each other directly via TCP/IP, but has fallen out of favor with time
     ; due to that mode of operation being susceptible to man-in-the-middle attacks.  It is still used in coinbase
     ; outputs and can be useful more exotic types of transaction, but today most payments are to addresses.
     ;;
    #_public
    (ยง method #_"boolean" isSentToRawPubKey []
        (and (== (.. (:chunks this) (size)) 2) (.. (:chunks this) (get 1) (equalsOpCode ScriptOpCodes/OP_CHECKSIG)) (not (.. (:chunks this) (get 0) (isOpCode))) (< 1 (.. (:chunks this) (get 0) :data (alength))))
    )

    ;;;
     ; Returns true if this script is of the form DUP HASH160 <pubkey hash> EQUALVERIFY CHECKSIG, i.e. payment to an
     ; address like 1VayNert3x1KzbpzMGt2qdqrAThiRovi8.  This form was originally intended for the case where you wish
     ; to send somebody money with a written code because their node is offline, but over time has become the standard
     ; way to make payments due to the short and recognizable base58 form addresses come in.
     ;;
    #_public
    (ยง method #_"boolean" isSentToAddress []
        (and (== (.. (:chunks this) (size)) 5) (.. (:chunks this) (get 0) (equalsOpCode ScriptOpCodes/OP_DUP)) (.. (:chunks this) (get 1) (equalsOpCode ScriptOpCodes/OP_HASH160)) (== (.. (:chunks this) (get 2) :data (alength)) Address/LENGTH) (.. (:chunks this) (get 3) (equalsOpCode ScriptOpCodes/OP_EQUALVERIFY)) (.. (:chunks this) (get 4) (equalsOpCode ScriptOpCodes/OP_CHECKSIG)))
    )

    ;;;
     ; <p>If a program matches the standard template DUP HASH160 &lt;pubkey hash&gt; EQUALVERIFY CHECKSIG,
     ; then this function retrieves the third element.
     ; In this case, this is useful for fetching the destination address of a transaction.</p>
     ;
     ; <p>If a program matches the standard template HASH160 &lt;script hash&gt; EQUAL,
     ; then this function retrieves the second element.
     ; In this case, this is useful for fetching the hash of the redeem script of a transaction.</p>
     ;
     ; <p>Otherwise it throws a ScriptException.</p>
     ;
     ;;
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"byte[]" getPubKeyHash []
        (when (.. this (isSentToAddress))
            (ยง return (.. (:chunks this) (get 2) :data))
        )
        (when (.. this (isPayToScriptHash))
            (ยง return (.. (:chunks this) (get 1) :data))
        )

        (throw (ScriptException. ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Script not in the standard scriptPubKey form"))
    )

    ;;;
     ; Returns the public key in this script.  If a script contains two constants and nothing else, it is assumed
     ; to be a scriptSig (input) for a pay-to-address output and the second constant is returned (the first is the
     ; signature).  If a script contains a constant and an OP_CHECKSIG opcode, the constant is returned as it is
     ; assumed to be a direct pay-to-key scriptPubKey (output) and the first constant is the public key.
     ;
     ; @throws ScriptException if the script is none of the named forms.
     ;;
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"byte[]" getPubKey []
        (when (!= (.. (:chunks this) (size)) 2)
            (throw (ScriptException. ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, (str "Script not of right size, expecting 2 but got " (.. (:chunks this) (size)))))
        )

        (let [#_"ScriptChunk" __chunk0 (.. (:chunks this) (get 0))
              #_"byte[]" __chunk0data (:data __chunk0)
              #_"ScriptChunk" __chunk1 (.. (:chunks this) (get 1))
              #_"byte[]" __chunk1data (:data __chunk1)]

            ;; If we have two large constants assume the input to a pay-to-address output.
            (when (and (some? __chunk0data) (< 2 (.. __chunk0data (alength))) (some? __chunk1data) (< 2 (.. __chunk1data (alength))))
                (ยง return __chunk1data)
            )

            ;; A large constant followed by an OP_CHECKSIG is the key.
            (when (and (.. __chunk1 (equalsOpCode ScriptOpCodes/OP_CHECKSIG)) (some? __chunk0data) (< 2 (.. __chunk0data (alength))))
                (ยง return __chunk0data)
            )

            (throw (ScriptException. ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, (str "Script did not match expected form: " this)))
        )
    )

    ;;;
     ; Retrieves the sender public key from a LOCKTIMEVERIFY transaction.
     ;
     ; @throws ScriptException
     ;;
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"byte[]" getCLTVPaymentChannelSenderPubKey []
        (when (.. this (isSentToCLTVPaymentChannel))
            (ยง return (.. (:chunks this) (get 8) :data))
        )

        (throw (ScriptException. ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, (str "Script not a standard CHECKLOCKTIMVERIFY transaction: " this)))
    )

    ;;;
     ; Retrieves the recipient public key from a LOCKTIMEVERIFY transaction.
     ;
     ; @throws ScriptException
     ;;
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"byte[]" getCLTVPaymentChannelRecipientPubKey []
        (when (.. this (isSentToCLTVPaymentChannel))
            (ยง return (.. (:chunks this) (get 1) :data))
        )

        (throw (ScriptException. ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, (str "Script not a standard CHECKLOCKTIMVERIFY transaction: " this)))
    )

    #_public
    (ยง method #_"BigInteger" getCLTVPaymentChannelExpiry []
        (when (.. this (isSentToCLTVPaymentChannel))
            (ยง return (Script/castToBigInteger (.. (:chunks this) (get 4) :data), 5, false))
        )

        (throw (ScriptException. ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, (str "Script not a standard CHECKLOCKTIMEVERIFY transaction: " this)))
    )

    ;;;
     ; For 2-element [input] scripts assumes that the paid-to-address can be derived from the public key.
     ; The concept of a "from address" isn't well defined in Bitcoin and you should not assume the sender
     ; of a transaction can actually receive coins on it. This method may be removed in future.
     ;;
    #_deprecated
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"Address" getFromAddress [#_"NetworkParameters" __params]
        (Address. __params, (Utils/sha256hash160 (.. this (getPubKey))))
    )

    ;;;
     ; Gets the destination address from this script, if it's in the required form (see getPubKey).
     ;;
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"Address" getToAddress [#_"NetworkParameters" __params]
        (.. this (getToAddress __params, false))
    )

    ;;;
     ; Gets the destination address from this script, if it's in the required form (see getPubKey).
     ;
     ; @param forcePayToPubKey If true, allow payToPubKey to be casted to the corresponding address.
     ;                         This is useful if you prefer showing addresses rather than pubkeys.
     ;;
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"Address" getToAddress [#_"NetworkParameters" __params, #_"boolean" __forcePayToPubKey]
        (when (.. this (isSentToAddress))
            (ยง return (Address. __params, (.. this (getPubKeyHash))))
        )
        (when (.. this (isPayToScriptHash))
            (ยง return (Address/fromP2SHScript __params, this))
        )
        (when (and __forcePayToPubKey (.. this (isSentToRawPubKey)))
            (ยง return (.. (ECKey/fromPublicOnly (.. this (getPubKey))) (toAddress __params)))
        )

        (throw (ScriptException. ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Cannot cast this script to a pay-to-address type"))
    )

    ;;;
     ; Writes out the given byte buffer to the output stream with the correct opcode prefix.
     ; To write an integer call writeBytes(out, Utils.reverseBytes(Utils.encodeMPI(val, false))).
     ;;
    #_public
    #_static
    #_throws #_[ "IOException" ]
    (ยง defn #_"void" Script/writeBytes [#_"OutputStream" __os, #_"byte[]" __buf]
        (cond (< (.. __buf (alength)) ScriptOpCodes/OP_PUSHDATA1)
            (do
                (.. __os (write (.. __buf (alength))))
                (.. __os (write __buf))
            )
            (< (.. __buf (alength)) 256)
            (do
                (.. __os (write ScriptOpCodes/OP_PUSHDATA1))
                (.. __os (write (.. __buf (alength))))
                (.. __os (write __buf))
            )
            (< (.. __buf (alength)) 65536)
            (do
                (.. __os (write ScriptOpCodes/OP_PUSHDATA2))
                (.. __os (write (& 0xff (.. __buf (alength)))))
                (.. __os (write (& 0xff (>> (.. __buf (alength)) 8))))
                (.. __os (write __buf))
            )
            :else
            (do
                (throw (RuntimeException. "Unimplemented"))
            )
        )
        nil
    )

    ;;; Creates a program that requires at least N of the given keys to sign, using OP_CHECKMULTISIG. ;;
    #_public
    #_static
    (ยง defn #_"byte[]" Script/createMultiSigOutputScript [#_"int" __threshold, #_"List<ECKey>" __pubkeys]
        (Preconditions/checkArgument (< 0 __threshold))
        (Preconditions/checkArgument (<= __threshold (.. __pubkeys (size))))
        (Preconditions/checkArgument (<= (.. __pubkeys (size)) 16)) ;; That's the max we can represent with a single opcode.

        (when (< 3 (.. __pubkeys (size)))
            (.. Script/log (warn "Creating a multi-signature output that is non-standard: {} pubkeys, should be <= 3", (.. __pubkeys (size))))
        )

        (try
            (let [#_"ByteArrayOutputStream" __bits (ByteArrayOutputStream.)]
                (.. __bits (write (Script/encodeToOpN __threshold)))
                (doseq [#_"ECKey" __key __pubkeys]
                    (Script/writeBytes __bits, (.. __key (getPubKey)))
                )
                (.. __bits (write (Script/encodeToOpN (.. __pubkeys (size)))))
                (.. __bits (write ScriptOpCodes/OP_CHECKMULTISIG))
                (ยง return (.. __bits (toByteArray)))
            )
            (catch IOException __e
                (throw (RuntimeException. __e)) ;; Cannot happen.
            )
        )
    )

    #_public
    #_static
    (ยง defn #_"byte[]" Script/createInputScript [#_"byte[]" __signature, #_"byte[]" __pubkey]
        (try
            ;; TODO: Do this by creating a Script *first* then having the script reassemble itself into bytes.
            (let [#_"ByteArrayOutputStream" __bits (ByteArrayOutputStream. (+ (.. __signature (alength)) (.. __pubkey (alength)) 2))]
                (Script/writeBytes __bits, __signature)
                (Script/writeBytes __bits, __pubkey)
                (ยง return (.. __bits (toByteArray)))
            )
            (catch IOException __e
                (throw (RuntimeException. __e))
            )
        )
    )

    #_public
    #_static
    (ยง defn #_"byte[]" Script/createInputScript [#_"byte[]" __signature]
        (try
            ;; TODO: Do this by creating a Script *first* then having the script reassemble itself into bytes.
            (let [#_"ByteArrayOutputStream" __bits (ByteArrayOutputStream. (+ (.. __signature (alength)) 2))]
                (Script/writeBytes __bits, __signature)
                (ยง return (.. __bits (toByteArray)))
            )
            (catch IOException __e
                (throw (RuntimeException. __e))
            )
        )
    )

    ;;;
     ; Creates an incomplete scriptSig that, once filled with signatures, can redeem output containing this scriptPubKey.
     ; Instead of the signatures resulting script has OP_0.
     ; Having incomplete input script allows to pass around partially signed tx.
     ; It is expected that this program later on will be updated with proper signatures.
     ;;
    #_public
    (ยง method #_"Script" createEmptyInputScript [#_nilable #_"ECKey" __key, #_nilable #_"Script" __redeemScript]
        (when (.. this (isSentToAddress))
            (Preconditions/checkArgument (some? __key), "Key required to create pay-to-address input script")
            (ยง return (ScriptBuilder/createInputScript nil, __key))
        )

        (when (.. this (isSentToRawPubKey))
            (ยง return (ScriptBuilder/createInputScript nil))
        )

        (when (.. this (isPayToScriptHash))
            (Preconditions/checkArgument (some? __redeemScript), "Redeem script required to create P2SH input script")
            (ยง return (ScriptBuilder/createP2SHMultiSigInputScript nil, __redeemScript))
        )

        (throw (ScriptException. ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, (str "Do not understand script type: " this)))
    )

    ;;;
     ; Returns a copy of the given scriptSig with the signature inserted in the given position.
     ;;
    #_public
    (ยง method #_"Script" getScriptSigWithSignature [#_"Script" __scriptSig, #_"byte[]" __sigBytes, #_"int" __index]
        (let [#_"int" __sigsPrefixCount 0
              #_"int" __sigsSuffixCount 0]
            (cond (.. this (isPayToScriptHash))
                (do
                    (ยง ass __sigsPrefixCount 1) ;; OP_0 <sig>* <redeemScript>
                    (ยง ass __sigsSuffixCount 1)
                )
                (.. this (isSentToMultiSig))
                (do
                    (ยง ass __sigsPrefixCount 1) ;; OP_0 <sig>*
                )
                (.. this (isSentToAddress))
                (do
                    (ยง ass __sigsSuffixCount 1) ;; <sig> <pubkey>
                )
            )
            (ScriptBuilder/updateScriptWithSignature __scriptSig, __sigBytes, __index, __sigsPrefixCount, __sigsSuffixCount)
        )
    )

    ;;;
     ; Returns the index where a signature by the key should be inserted.
     ; Only applicable to a P2SH scriptSig.
     ;;
    #_public
    (ยง method #_"int" getSigInsertionIndex [#_"Sha256Hash" __hash, #_"ECKey" __signingKey]
        ;; Iterate over existing signatures, skipping the initial OP_0, the final redeem script
        ;; and any placeholder OP_0 sigs.
        (let [#_"List<ScriptChunk>" __existingChunks (.. (:chunks this) (subList 1, (dec (.. (:chunks this) (size)))))
              #_"ScriptChunk" __redeemScriptChunk (.. (:chunks this) (get (dec (.. (:chunks this) (size)))))]
            (Preconditions/checkNotNull (:data __redeemScriptChunk))
            (let [#_"Script" __redeemScript (Script. (:data __redeemScriptChunk))]

                (let [#_"int" __sigCount 0
                      #_"int" __myIndex (.. __redeemScript (findKeyInRedeem __signingKey))]
                    (doseq [#_"ScriptChunk" __chunk __existingChunks]
                        (cond (== (:opcode __chunk) ScriptOpCodes/OP_0)
                            (do
                                ;; OP_0, skip
                            )
                            :else
                            (do
                                (Preconditions/checkNotNull (:data __chunk))
                                (when (< __myIndex (.. __redeemScript (findSigInRedeem (:data __chunk), __hash)))
                                    (ยง return __sigCount)
                                )
                                (ยง ass __sigCount (inc __sigCount))
                            )
                        )
                    )
                    __sigCount
                )
            )
        )
    )

    #_private
    (ยง method- #_"int" findKeyInRedeem [#_"ECKey" __key]
        (Preconditions/checkArgument (.. (:chunks this) (get 0) (isOpCode))) ;; P2SH scriptSig

        (let [#_"int" __numKeys (Script/decodeFromOpN (.. (:chunks this) (get (- (.. (:chunks this) (size)) 2)) :opcode))]
            (loop-when-recur [#_"int" __i 0] (< __i __numKeys) [(inc __i)]
                (when (Arrays/equals (.. (:chunks this) (get (+ 1 __i)) :data), (.. __key (getPubKey)))
                    (ยง return __i)
                )
            )

            (throw (IllegalStateException. (str "Could not find matching key " __key " in script " this)))
        )
    )

    ;;;
     ; Returns a list of the keys required by this script, assuming a multi-sig script.
     ;
     ; @throws ScriptException if the script type is not understood or is pay to address or is P2SH (run this method on the "Redeem script" instead).
     ;;
    #_public
    (ยง method #_"List<ECKey>" getPubKeys []
        (when (not (.. this (isSentToMultiSig)))
            (throw (ScriptException. ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Only usable for multisig scripts."))
        )

        (let [#_"ArrayList<ECKey>" __result (Lists/newArrayList)
              #_"int" __numKeys (Script/decodeFromOpN (.. (:chunks this) (get (- (.. (:chunks this) (size)) 2)) :opcode))]
            (loop-when-recur [#_"int" __i 0] (< __i __numKeys) [(inc __i)]
                (.. __result (add (ECKey/fromPublicOnly (.. (:chunks this) (get (+ 1 __i)) :data))))
            )
            __result
        )
    )

    #_private
    (ยง method- #_"int" findSigInRedeem [#_"byte[]" __signatureBytes, #_"Sha256Hash" __hash]
        (Preconditions/checkArgument (.. (:chunks this) (get 0) (isOpCode))) ;; P2SH scriptSig

        (let [#_"int" __numKeys (Script/decodeFromOpN (.. (:chunks this) (get (- (.. (:chunks this) (size)) 2)) :opcode))
              #_"TransactionSignature" __signature (TransactionSignature/decodeFromBitcoin __signatureBytes, true)]
            (loop-when-recur [#_"int" __i 0] (< __i __numKeys) [(inc __i)]
                (when (.. (ECKey/fromPublicOnly (.. (:chunks this) (get (inc __i)) :data)) (verify __hash, __signature))
                    (ยง return __i)
                )
            )

            (throw (IllegalStateException. (str "Could not find matching key for signature on " __hash " sig " (.. Utils/HEX (encode __signatureBytes)))))
        )
    )

    #_private
    #_static
    #_throws #_[ "ScriptException" ]
    (ยง defn- #_"int" Script/getSigOpCount [#_"List<ScriptChunk>" __chunks, #_"boolean" __accurate]
        (let [#_"int" __sigOps 0
              #_"int" __lastOpCode ScriptOpCodes/OP_INVALIDOPCODE]
            (doseq [#_"ScriptChunk" __chunk __chunks]
                (when (.. __chunk (isOpCode))
                    (ยง ass __sigOps
                        (condp ==? (:opcode __chunk)
                            [ScriptOpCodes/OP_CHECKSIG ScriptOpCodes/OP_CHECKSIGVERIFY]
                                (inc __sigOps)
                            [ScriptOpCodes/OP_CHECKMULTISIG ScriptOpCodes/OP_CHECKMULTISIGVERIFY]
                                (if (and __accurate (<= ScriptOpCodes/OP_1 __lastOpCode ScriptOpCodes/OP_16))
                                    (+ __sigOps (Script/decodeFromOpN __lastOpCode))
                                    (+ __sigOps 20)
                                )
                            __sigOps
                        )
                    )
                    (ยง ass __lastOpCode (:opcode __chunk))
                )
            )
            __sigOps
        )
    )

    #_static
    (ยง defn #_"int" Script/decodeFromOpN [#_"int" __opcode]
        (Preconditions/checkArgument (or (== __opcode ScriptOpCodes/OP_0) (== __opcode ScriptOpCodes/OP_1NEGATE) (<= ScriptOpCodes/OP_1 __opcode ScriptOpCodes/OP_16)), "decodeFromOpN called on non OP_N opcode")

        (when (== __opcode ScriptOpCodes/OP_0)
            (ยง return 0)
        )
        (when (== __opcode ScriptOpCodes/OP_1NEGATE)
            (ยง return -1)
        )

        (- (inc __opcode) ScriptOpCodes/OP_1)
    )

    #_static
    (ยง defn #_"int" Script/encodeToOpN [#_"int" __value]
        (Preconditions/checkArgument (<= -1 __value 16), (str "encodeToOpN called for " __value " which we cannot encode in an opcode."))

        (when (== __value 0)
            (ยง return ScriptOpCodes/OP_0)
        )
        (when (== __value -1)
            (ยง return ScriptOpCodes/OP_1NEGATE)
        )

        (+ (dec __value) ScriptOpCodes/OP_1)
    )

    ;;;
     ; Gets the count of regular SigOps in the script program (counting multisig ops as 20).
     ;;
    #_public
    #_static
    #_throws #_[ "ScriptException" ]
    (ยง defn #_"int" Script/getSigOpCount [#_"byte[]" __program]
        (let [#_"Script" __script (Script.)]
            (try
                (.. __script (parse __program))
                (catch ScriptException _
                    ;; Ignore errors and count up to the parse-able length.
                )
            )
            (Script/getSigOpCount (:chunks __script), false)
        )
    )

    ;;;
     ; Gets the count of P2SH Sig Ops in the Script scriptSig.
     ;;
    #_public
    #_static
    #_throws #_[ "ScriptException" ]
    (ยง defn #_"long" Script/getP2SHSigOpCount [#_"byte[]" __scriptSig]
        (let [#_"Script" __script (Script.)]
            (try
                (.. __script (parse __scriptSig))
                (catch ScriptException _
                    ;; Ignore errors and count up to the parse-able length.
                )
            )
            (loop-when-recur [#_"int" __i (dec (.. (:chunks __script) (size)))] (<= 0 __i) [(dec __i)]
                (when (not (.. (:chunks __script) (get __i) (isOpCode)))
                    (let [#_"Script" __subScript (Script.)]
                        (.. __subScript (parse (.. (:chunks __script) (get __i) :data)))
                        (ยง return (Script/getSigOpCount (:chunks __subScript), true))
                    )
                )
            )
            0
        )
    )

    ;;;
     ; Returns number of signatures required to satisfy this script.
     ;;
    #_public
    (ยง method #_"int" getNumberOfSignaturesRequiredToSpend []
        ;; For N of M CHECKMULTISIG script we will need N signatures to spend.
        (when (.. this (isSentToMultiSig))
            (ยง return (Script/decodeFromOpN (.. (:chunks this) (get 0) :opcode)))
        )

        ;; pay-to-address and pay-to-pubkey require single sig
        (when (or (.. this (isSentToAddress)) (.. this (isSentToRawPubKey)))
            (ยง return 1)
        )

        (when (.. this (isPayToScriptHash))
            (throw (IllegalStateException. "For P2SH number of signatures depends on redeem script"))
        )

        (throw (IllegalStateException. "Unsupported script type"))
    )

    ;;;
     ; Returns number of bytes required to spend this script.  It accepts optional ECKey and redeemScript
     ; that may be required for certain types of script to estimate target size.
     ;;
    #_public
    (ยง method #_"int" getNumberOfBytesRequiredToSpend [#_nilable #_"ECKey" __pubKey, #_nilable #_"Script" __redeemScript]
        (cond (.. this (isPayToScriptHash))
            (do
                ;; scriptSig: <sig> [sig] [sig...] <redeemscript>
                (Preconditions/checkArgument (some? __redeemScript), "P2SH script requires redeemScript to be spent")
                (ยง return (+ (* (.. __redeemScript (getNumberOfSignaturesRequiredToSpend)) Script/SIG_SIZE) (.. __redeemScript (getProgram) (alength))))
            )
            (.. this (isSentToMultiSig))
            (do
                ;; scriptSig: OP_0 <sig> [sig] [sig...]
                (ยง return (inc (* (.. this (getNumberOfSignaturesRequiredToSpend)) Script/SIG_SIZE)))
            )
            (.. this (isSentToRawPubKey))
            (do
                ;; scriptSig: <sig>
                (ยง return Script/SIG_SIZE)
            )
            (.. this (isSentToAddress))
            (do
                ;; scriptSig: <sig> <pubkey>
                (let [#_"int" __uncompressedPubKeySize 65]
                    (ยง return (+ Script/SIG_SIZE (if (some? __pubKey) (.. __pubKey (getPubKey) (alength)) __uncompressedPubKeySize)))
                )
            )
            :else
            (do
                (throw (IllegalStateException. "Unsupported script type"))
            )
        )
    )

    ;;;
     ; <p>Whether or not this is a scriptPubKey representing a pay-to-script-hash output.  In such outputs, the logic
     ; that controls reclamation is not actually in the output at all.  Instead there's just a hash, and it's up to the
     ; spending input to provide a program matching that hash.  This rule is "soft enforced" by the network as it does
     ; not exist in Bitcoin Core.  It means blocks containing P2SH transactions that don't match
     ; correctly are considered valid, but won't be mined upon, so they'll be rapidly re-orgd out of the chain.  This
     ; logic is defined by <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP 16</a>.</p>
     ;
     ; <p>bitcoinj does not support creation of P2SH transactions today.  The goal of P2SH is to allow short addresses
     ; even for complex scripts (e.g. multi-sig outputs) so they are convenient to work with in things like QRcodes or
     ; with copy/paste, and also to minimize the size of the unspent output set (which improves performance of the
     ; Bitcoin system).</p>
     ;;
    #_public
    (ยง method #_"boolean" isPayToScriptHash []
        ;; We have to check against the serialized form because BIP16 defines a P2SH output using an exact byte
        ;; template, not the logical program structure.  Thus you can have two programs that look identical when
        ;; printed out but one is a P2SH script and the other isn't! :( ;; )
        (let [#_"byte[]" __program (.. this (getProgram))]
            (and (== (.. __program (alength)) 23) (== (& 0xff (aget __program 0)) ScriptOpCodes/OP_HASH160) (== (& 0xff (aget __program 1)) 0x14) (== (& 0xff (aget __program 22)) ScriptOpCodes/OP_EQUAL))
        )
    )

    ;;;
     ; Returns whether this script matches the format used for multisig outputs: [n] [keys...] [m] CHECKMULTISIG.
     ;;
    #_public
    (ยง method #_"boolean" isSentToMultiSig []
        (when (< (.. (:chunks this) (size)) 4)
            (ยง return false)
        )

        (let [#_"ScriptChunk" __chunk (.. (:chunks this) (get (dec (.. (:chunks this) (size)))))]
            ;; Must end in OP_CHECKMULTISIG[VERIFY].
            (when (not (.. __chunk (isOpCode)))
                (ยง return false)
            )
            (when (not (or (.. __chunk (equalsOpCode ScriptOpCodes/OP_CHECKMULTISIG)) (.. __chunk (equalsOpCode ScriptOpCodes/OP_CHECKMULTISIGVERIFY))))
                (ยง return false)
            )

            (try
                ;; Second to last chunk must be an OP_N opcode and there should be that many data chunks (keys).
                (let [#_"ScriptChunk" __m (.. (:chunks this) (get (- (.. (:chunks this) (size)) 2)))]
                    (when (not (.. __m (isOpCode)))
                        (ยง return false)
                    )

                    (let [#_"int" __numKeys (Script/decodeFromOpN (:opcode __m))]
                        (when (or (< __numKeys 1) (!= (.. (:chunks this) (size)) (+ 3 __numKeys)))
                            (ยง return false)
                        )

                        (loop-when-recur [#_"int" __i 1] (< __i (- (.. (:chunks this) (size)) 2)) [(inc __i)]
                            (when (.. (:chunks this) (get __i) (isOpCode))
                                (ยง return false)
                            )
                        )

                        ;; First chunk must be an OP_N opcode too.
                        (when (< (Script/decodeFromOpN (.. (:chunks this) (get 0) :opcode)) 1)
                            (ยง return false)
                        )
                    )
                )
                (catch IllegalStateException __e
                    (ยง return false) ;; Not an OP_N opcode.
                )
            )
            true
        )
    )

    #_public
    (ยง method #_"boolean" isSentToCLTVPaymentChannel []
        ;; Check that opcodes match the pre-determined format.
        ;; chunk[1] = recipient pubkey
        ;; chunk[4] = locktime
        ;; chunk[8] = sender pubkey
        (and (== (.. (:chunks this) (size)) 10) (.. (:chunks this) (get 0) (equalsOpCode ScriptOpCodes/OP_IF)) (.. (:chunks this) (get 2) (equalsOpCode ScriptOpCodes/OP_CHECKSIGVERIFY)) (.. (:chunks this) (get 3) (equalsOpCode ScriptOpCodes/OP_ELSE)) (.. (:chunks this) (get 5) (equalsOpCode ScriptOpCodes/OP_CHECKLOCKTIMEVERIFY)) (.. (:chunks this) (get 6) (equalsOpCode ScriptOpCodes/OP_DROP)) (.. (:chunks this) (get 7) (equalsOpCode ScriptOpCodes/OP_ENDIF)) (.. (:chunks this) (get 9) (equalsOpCode ScriptOpCodes/OP_CHECKSIG)))
    )

    #_private
    #_static
    (ยง defn- #_"boolean" Script/equalsRange [#_"byte[]" __a, #_"int" __start, #_"byte[]" __b]
        (when (< (.. __a (alength)) (+ __start (.. __b (alength))))
            (ยง return false)
        )

        (loop-when-recur [#_"int" __i 0] (< __i (.. __b (alength))) [(inc __i)]
            (when (!= (aget __a (+ __i __start)) (aget __b __i))
                (ยง return false)
            )
        )

        true
    )

    ;;;
     ; Returns the script bytes of inputScript with all instances of the specified script object removed.
     ;;
    #_public
    #_static
    (ยง defn #_"byte[]" Script/removeAllInstancesOf [#_"byte[]" __inputScript, #_"byte[]" __chunkToRemove]
        ;; We usually don't end up removing anything.
        (let [#_"ByteArrayOutputStream" __bos (ByteArrayOutputStream. (.. __inputScript (alength)))]

            (let [#_"int" __cursor 0]
                (while (< __cursor (.. __inputScript (alength)))
                    (let [#_"boolean" __skip (Script/equalsRange __inputScript, __cursor, __chunkToRemove)]

                        (let [#_"int" __opcode (& 0xff (aget __inputScript __cursor))]
                            (ยง ass __cursor (inc __cursor))
                            (let [#_"int" __additionalBytes
                                    (cond
                                        (<= 0 __opcode (dec ScriptOpCodes/OP_PUSHDATA1))
                                            __opcode
                                        (== __opcode ScriptOpCodes/OP_PUSHDATA1)
                                            (inc (& 0xff (aget __inputScript __cursor)))
                                        (== __opcode ScriptOpCodes/OP_PUSHDATA2)
                                            (+ (| (& 0xff (aget __inputScript __cursor))
                                              (<< (& 0xff (aget __inputScript (inc __cursor))) 8)) 2)
                                        (== __opcode ScriptOpCodes/OP_PUSHDATA4)
                                            (+ (| (& 0xff (aget __inputScript __cursor))
                                              (<< (& 0xff (aget __inputScript (inc __cursor))) 8)
                                              (<< (& 0xff (aget __inputScript (inc __cursor))) 16)
                                              (<< (& 0xff (aget __inputScript (inc __cursor))) 24)) 4)
                                        :else
                                            0
                                    )]
                                (when (not __skip)
                                    (try
                                        (.. __bos (write __opcode))
                                        (.. __bos (write (Arrays/copyOfRange __inputScript, __cursor, (+ __cursor __additionalBytes))))
                                        (catch IOException __e
                                            (throw (RuntimeException. __e))
                                        )
                                    )
                                )
                                (ยง ass __cursor (+ __cursor __additionalBytes))
                            )
                        )
                    )
                )
                (.. __bos (toByteArray))
            )
        )
    )

    ;;;
     ; Returns the script bytes of inputScript with all instances of the given op code removed.
     ;;
    #_public
    #_static
    (ยง defn #_"byte[]" Script/removeAllInstancesOfOp [#_"byte[]" __inputScript, #_"int" __opCode]
        (Script/removeAllInstancesOf __inputScript, (byte-array [ (byte __opCode)]))
    )

    #_private
    #_static
    (ยง defn- #_"boolean" Script/castToBool [#_"byte[]" __data]
        (loop-when-recur [#_"int" __i 0] (< __i (.. __data (alength))) [(inc __i)]
            ;; "Can be negative zero" - Bitcoin Core (see OpenSSL's BN_bn2mpi)
            (when (!= (aget __data __i) 0)
                (ยง return (or (!= __i (dec (.. __data (alength)))) (!= (& 0xff (aget __data __i)) 0x80)))
            )
        )
        false
    )

    ;;;
     ; Cast a script chunk to a BigInteger.
     ;
     ; @see #castToBigInteger(byte[], int) for values with different maximum sizes.
     ; @throws ScriptException if the chunk is longer than 4 bytes.
     ;;
    #_private
    #_static
    #_throws #_[ "ScriptException" ]
    (ยง defn- #_"BigInteger" Script/castToBigInteger [#_"byte[]" __chunk, #_"boolean" __requireMinimal]
        (Script/castToBigInteger __chunk, 4, __requireMinimal)
    )

    ;;;
     ; Cast a script chunk to a BigInteger.  Normally you would want {@link #castToBigInteger(byte[])} instead, this
     ; is only for cases where the normal maximum length does not apply (i.e. CHECKLOCKTIMEVERIFY, CHECKSEQUENCEVERIFY).
     ;
     ; @param maxLength The maximum length in bytes.
     ; @param requireMinimal Check if the number is encoded with the minimum possible number of bytes.
     ; @throws ScriptException if the chunk is longer than the specified maximum.
     ;;
    #_private
    #_static
    #_throws #_[ "ScriptException" ]
    (ยง defn- #_"BigInteger" Script/castToBigInteger [#_"byte[]" __chunk, #_"int" __maxLength, #_"boolean" __requireMinimal]
        (when (< __maxLength (.. __chunk (alength)))
            (throw (ScriptException. ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, (str "Script attempted to use an integer larger than " __maxLength " bytes")))
        )

        (when (and __requireMinimal (< 0 (.. __chunk (alength))))
            ;; Check that the number is encoded with the minimum possible number of bytes.
            ;;
            ;; If the most-significant-byte - excluding the sign bit - is zero, then we're not minimal.
            ;; Note how this test also rejects the negative-zero encoding, 0x80.
            (when (== (& 0x7f (aget __chunk (dec (.. __chunk (alength))))) 0)
                ;; One exception: if there's more than one byte and the most significant bit
                ;; of the second-most-significant-byte is set, it would conflict with the sign bit.
                ;; An example of this case is +-255, which encode to 0xff00 and 0xff80 respectively.
                ;; (big-endian)
                (when (or (<= (.. __chunk (alength)) 1) (== (& 0x80 (aget __chunk (- (.. __chunk (alength)) 2))) 0))
                    (throw (ScriptException. ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "non-minimally encoded script number"))
                )
            )
        )

        (Utils/decodeMPI (Utils/reverseBytes __chunk), false)
    )

    #_public
    (ยง method #_"boolean" isOpReturn []
        (and (< 0 (.. (:chunks this) (size))) (.. (:chunks this) (get 0) (equalsOpCode ScriptOpCodes/OP_RETURN)))
    )

    ;;;
     ; Exposes the script interpreter.  Normally you should not use this directly, instead use
     ; {@link org.bitcoinj.core.TransactionInput#verify(org.bitcoinj.core.TransactionOutput)} or
     ; {@link org.bitcoinj.script.Script#correctlySpends(org.bitcoinj.core.Transaction, long, Script)}.
     ; This method is useful if you need more precise control or access to the final state of the stack.
     ; This interface is very likely to change in future.
     ;
     ; @deprecated Use {@link #executeScript(org.bitcoinj.core.Transaction, long, org.bitcoinj.script.Script, java.util.LinkedList, java.util.Set)}
     ; instead.
     ;;
    #_deprecated
    #_public
    #_static
    #_throws #_[ "ScriptException" ]
    (ยง defn #_"void" Script/executeScript [#_nilable #_"Transaction" __txContainingThis, #_"long" __index, #_"Script" __script, #_"LinkedList<byte[]>" __stack, #_"boolean" __enforceNullDummy]
        (let [#_"EnumSet<Script.VerifyFlag>" __flags (if __enforceNullDummy (EnumSet/of Script.VerifyFlag/NULLDUMMY) (EnumSet/noneOf Script.VerifyFlag))]

            (Script/executeScript __txContainingThis, __index, __script, __stack, __flags)
            nil
        )
    )

    ;;;
     ; Exposes the script interpreter.  Normally you should not use this directly, instead use
     ; {@link org.bitcoinj.core.TransactionInput#verify(org.bitcoinj.core.TransactionOutput)} or
     ; {@link org.bitcoinj.script.Script#correctlySpends(org.bitcoinj.core.Transaction, long, Script)}.
     ; This method is useful if you need more precise control or access to the final state of the stack.
     ; This interface is very likely to change in future.
     ;;
    #_public
    #_static
    #_throws #_[ "ScriptException" ]
    (ยง defn #_"void" Script/executeScript [#_nilable #_"Transaction" __txContainingThis, #_"long" __index, #_"Script" __script, #_"LinkedList<byte[]>" __stack, #_"Set<Script.VerifyFlag>" __verifyFlags]
        (let [#_"int" __opCount 0
              #_"int" __lastCodeSepLocation 0]

            (let [#_"LinkedList<byte[]>" __altstack (LinkedList. #_"<>")
                  #_"LinkedList<Boolean>" __ifStack (LinkedList. #_"<>")]

                (doseq [#_"ScriptChunk" __chunk (:chunks __script)]
                    (let [#_"boolean" __shouldExecute (not (.. __ifStack (contains false)))
                          #_"int" __opcode (:opcode __chunk)]

                        ;; Check stack element size.
                        (when (and (some? (:data __chunk)) (< Script/MAX_SCRIPT_ELEMENT_SIZE (.. (:data __chunk) (alength))))
                            (throw (ScriptException. ScriptError/SCRIPT_ERR_PUSH_SIZE, "Attempted to push a data string larger than 520 bytes"))
                        )

                        ;; Note how OP_RESERVED does not count towards the opcode limit.
                        (when (< ScriptOpCodes/OP_16 __opcode)
                            (ยง ass __opCount (inc __opCount))
                            (when (< Script/MAX_OPS_PER_SCRIPT __opCount)
                                (throw (ScriptException. ScriptError/SCRIPT_ERR_OP_COUNT, "More script operations than is allowed"))
                            )
                        )

                        ;; Disabled opcodes.
                        (when (any == __opcode ScriptOpCodes/OP_CAT ScriptOpCodes/OP_SUBSTR ScriptOpCodes/OP_LEFT ScriptOpCodes/OP_RIGHT ScriptOpCodes/OP_INVERT ScriptOpCodes/OP_AND ScriptOpCodes/OP_OR ScriptOpCodes/OP_XOR ScriptOpCodes/OP_2MUL ScriptOpCodes/OP_2DIV ScriptOpCodes/OP_MUL ScriptOpCodes/OP_DIV ScriptOpCodes/OP_MOD ScriptOpCodes/OP_LSHIFT ScriptOpCodes/OP_RSHIFT)
                            (throw (ScriptException. ScriptError/SCRIPT_ERR_DISABLED_OPCODE, "Script included a disabled Script Op."))
                        )

                        (cond (and __shouldExecute (<= ScriptOpCodes/OP_0 __opcode ScriptOpCodes/OP_PUSHDATA4))
                            (do
                                ;; Check minimal push.
                                (when (and (.. __verifyFlags (contains Script.VerifyFlag/MINIMALDATA)) (not (.. __chunk (isShortestPossiblePushData))))
                                    (throw (ScriptException. ScriptError/SCRIPT_ERR_MINIMALDATA, "Script included a not minimal push operation."))
                                )

                                (if (== __opcode ScriptOpCodes/OP_0)
                                    (.. __stack (add (byte-array 0)))
                                    (.. __stack (add (:data __chunk)))
                                )
                            )
                            (or __shouldExecute (<= ScriptOpCodes/OP_IF __opcode ScriptOpCodes/OP_ENDIF))
                            (do
                                (condp ==? __opcode
                                    ScriptOpCodes/OP_IF
                                        (do
                                            (when (not __shouldExecute)
                                                (.. __ifStack (add false))
                                                (ยง continue )
                                            )
                                            (when (< (.. __stack (size)) 1)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_IF on an empty stack"))
                                            )
                                            (.. __ifStack (add (Script/castToBool (.. __stack (pollLast)))))
                                            (ยง continue )
                                        )
                                    ScriptOpCodes/OP_NOTIF
                                        (do
                                            (when (not __shouldExecute)
                                                (.. __ifStack (add false))
                                                (ยง continue )
                                            )
                                            (when (< (.. __stack (size)) 1)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_NOTIF on an empty stack"))
                                            )
                                            (.. __ifStack (add (not (Script/castToBool (.. __stack (pollLast))))))
                                            (ยง continue )
                                        )
                                    ScriptOpCodes/OP_ELSE
                                        (do
                                            (when (.. __ifStack (isEmpty))
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_ELSE without OP_IF/NOTIF"))
                                            )
                                            (.. __ifStack (add (not (.. __ifStack (pollLast)))))
                                            (ยง continue )
                                        )
                                    ScriptOpCodes/OP_ENDIF
                                        (do
                                            (when (.. __ifStack (isEmpty))
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_ENDIF without OP_IF/NOTIF"))
                                            )
                                            (.. __ifStack (pollLast))
                                            (ยง continue )
                                        )

                                    ;; OP_0 is no opcode
                                    ScriptOpCodes/OP_1NEGATE
                                        (do
                                            (.. __stack (add (Utils/reverseBytes (Utils/encodeMPI (.. BigInteger/ONE (negate)), false))))
                                        )
                                   [ScriptOpCodes/OP_1
                                    ScriptOpCodes/OP_2
                                    ScriptOpCodes/OP_3
                                    ScriptOpCodes/OP_4
                                    ScriptOpCodes/OP_5
                                    ScriptOpCodes/OP_6
                                    ScriptOpCodes/OP_7
                                    ScriptOpCodes/OP_8
                                    ScriptOpCodes/OP_9
                                    ScriptOpCodes/OP_10
                                    ScriptOpCodes/OP_11
                                    ScriptOpCodes/OP_12
                                    ScriptOpCodes/OP_13
                                    ScriptOpCodes/OP_14
                                    ScriptOpCodes/OP_15
                                    ScriptOpCodes/OP_16]
                                        (do
                                            (.. __stack (add (Utils/reverseBytes (Utils/encodeMPI (BigInteger/valueOf (Script/decodeFromOpN __opcode)), false))))
                                        )

                                    ScriptOpCodes/OP_NOP
                                        (do
                                        )

                                    ScriptOpCodes/OP_VERIFY
                                        (do
                                            (when (< (.. __stack (size)) 1)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_VERIFY on an empty stack"))
                                            )
                                            (when (not (Script/castToBool (.. __stack (pollLast))))
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_VERIFY, "OP_VERIFY failed"))
                                            )
                                        )

                                    ScriptOpCodes/OP_RETURN
                                        (throw (ScriptException. ScriptError/SCRIPT_ERR_OP_RETURN, "Script called OP_RETURN"))

                                    ScriptOpCodes/OP_TOALTSTACK
                                        (do
                                            (when (< (.. __stack (size)) 1)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_TOALTSTACK on an empty stack"))
                                            )
                                            (.. __altstack (add (.. __stack (pollLast))))
                                        )
                                    ScriptOpCodes/OP_FROMALTSTACK
                                        (do
                                            (when (< (.. __altstack (size)) 1)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_ALTSTACK_OPERATION, "Attempted OP_FROMALTSTACK on an empty altstack"))
                                            )
                                            (.. __stack (add (.. __altstack (pollLast))))
                                        )

                                    ScriptOpCodes/OP_2DROP
                                        (do
                                            (when (< (.. __stack (size)) 2)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2DROP on a stack with size < 2"))
                                            )
                                            (.. __stack (pollLast))
                                            (.. __stack (pollLast))
                                        )
                                    ScriptOpCodes/OP_2DUP
                                        (do
                                            (when (< (.. __stack (size)) 2)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2DUP on a stack with size < 2"))
                                            )
                                            (let [#_"Iterator<byte[]>" __it (.. __stack (descendingIterator)) #_"byte[]" __data2 (.. __it (next))]
                                                (.. __stack (add (.. __it (next))))
                                                (.. __stack (add __data2))
                                            )
                                        )
                                    ScriptOpCodes/OP_3DUP
                                        (do
                                            (when (< (.. __stack (size)) 3)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_3DUP on a stack with size < 3"))
                                            )
                                            (let [#_"Iterator<byte[]>" __it (.. __stack (descendingIterator)) #_"byte[]" __data3 (.. __it (next)) #_"byte[]" __data2 (.. __it (next))]
                                                (.. __stack (add (.. __it (next))))
                                                (.. __stack (add __data2))
                                                (.. __stack (add __data3))
                                            )
                                        )
                                    ScriptOpCodes/OP_2OVER
                                        (do
                                            (when (< (.. __stack (size)) 4)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2OVER on a stack with size < 4"))
                                            )
                                            (let [#_"Iterator<byte[]>" __it (.. __stack (descendingIterator))]
                                                (.. __it (next))
                                                (.. __it (next))
                                                (let [#_"byte[]" __data2 (.. __it (next))]
                                                    (.. __stack (add (.. __it (next))))
                                                    (.. __stack (add __data2))
                                                )
                                            )
                                        )
                                    ScriptOpCodes/OP_2ROT
                                        (do
                                            (when (< (.. __stack (size)) 6)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2ROT on a stack with size < 6"))
                                            )
                                            (let [#_"byte[]" __data6 (.. __stack (pollLast))
                                                  #_"byte[]" __data5 (.. __stack (pollLast))
                                                  #_"byte[]" __data4 (.. __stack (pollLast))
                                                  #_"byte[]" __data3 (.. __stack (pollLast))
                                                  #_"byte[]" __data2 (.. __stack (pollLast))
                                                  #_"byte[]" __data1 (.. __stack (pollLast))]
                                                (.. __stack (add __data3))
                                                (.. __stack (add __data4))
                                                (.. __stack (add __data5))
                                                (.. __stack (add __data6))
                                                (.. __stack (add __data1))
                                                (.. __stack (add __data2))
                                            )
                                        )
                                    ScriptOpCodes/OP_2SWAP
                                        (do
                                            (when (< (.. __stack (size)) 4)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2SWAP on a stack with size < 4"))
                                            )
                                            (let [#_"byte[]" __data4 (.. __stack (pollLast))
                                                  #_"byte[]" __data3 (.. __stack (pollLast))
                                                  #_"byte[]" __data2 (.. __stack (pollLast))
                                                  #_"byte[]" __data1 (.. __stack (pollLast))]
                                                (.. __stack (add __data3))
                                                (.. __stack (add __data4))
                                                (.. __stack (add __data1))
                                                (.. __stack (add __data2))
                                            )
                                        )

                                    ScriptOpCodes/OP_IFDUP
                                        (do
                                            (when (< (.. __stack (size)) 1)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_IFDUP on an empty stack"))
                                            )
                                            (when (Script/castToBool (.. __stack (getLast)))
                                                (.. __stack (add (.. __stack (getLast))))
                                            )
                                        )

                                    ScriptOpCodes/OP_DEPTH
                                        (do
                                            (.. __stack (add (Utils/reverseBytes (Utils/encodeMPI (BigInteger/valueOf (.. __stack (size))), false))))
                                        )

                                    ScriptOpCodes/OP_DROP
                                        (do
                                            (when (< (.. __stack (size)) 1)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_DROP on an empty stack"))
                                            )
                                            (.. __stack (pollLast))
                                        )
                                    ScriptOpCodes/OP_DUP
                                        (do
                                            (when (< (.. __stack (size)) 1)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_DUP on an empty stack"))
                                            )
                                            (.. __stack (add (.. __stack (getLast))))
                                        )
                                    ScriptOpCodes/OP_NIP
                                        (do
                                            (when (< (.. __stack (size)) 2)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_NIP on a stack with size < 2"))
                                            )
                                            (let [#_"byte[]" __data (.. __stack (pollLast))]
                                                (.. __stack (pollLast))
                                                (.. __stack (add __data))
                                            )
                                        )
                                    ScriptOpCodes/OP_OVER
                                        (do
                                            (when (< (.. __stack (size)) 2)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_OVER on a stack with size < 2"))
                                            )
                                            (let [#_"Iterator<byte[]>" __it (.. __stack (descendingIterator))]
                                                (.. __it (next))
                                                (.. __stack (add (.. __it (next))))
                                            )
                                        )
                                   [ScriptOpCodes/OP_PICK
                                    ScriptOpCodes/OP_ROLL]
                                        (do
                                            (when (< (.. __stack (size)) 1)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_PICK/OP_ROLL on an empty stack"))
                                            )
                                            (let [#_"long" __n (.. (Script/castToBigInteger (.. __stack (pollLast)), (.. __verifyFlags (contains Script.VerifyFlag/MINIMALDATA))) (longValue))]
                                                (when (not (< -1 __n (.. __stack (size))))
                                                    (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "OP_PICK/OP_ROLL attempted to get data deeper than stack size"))
                                                )
                                                (let [#_"Iterator<byte[]>" __it (.. __stack (descendingIterator))]
                                                    (dotimes [_ __n]
                                                        (.. __it (next))
                                                    )
                                                    (let [#_"byte[]" __data (.. __it (next))]
                                                        (when (== __opcode ScriptOpCodes/OP_ROLL)
                                                            (.. __it (remove))
                                                        )
                                                        (.. __stack (add __data))
                                                    )
                                                )
                                            )
                                        )
                                    ScriptOpCodes/OP_ROT
                                        (do
                                            (when (< (.. __stack (size)) 3)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_ROT on a stack with size < 3"))
                                            )
                                            (let [#_"byte[]" __data3 (.. __stack (pollLast))
                                                  #_"byte[]" __data2 (.. __stack (pollLast))
                                                  #_"byte[]" __data1 (.. __stack (pollLast))]
                                                (.. __stack (add __data2))
                                                (.. __stack (add __data3))
                                                (.. __stack (add __data1))
                                            )
                                        )
                                   [ScriptOpCodes/OP_SWAP
                                    ScriptOpCodes/OP_TUCK]
                                        (do
                                            (when (< (.. __stack (size)) 2)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SWAP on a stack with size < 2"))
                                            )
                                            (let [#_"byte[]" __data2 (.. __stack (pollLast)) #_"byte[]" __data1 (.. __stack (pollLast))]
                                                (.. __stack (add __data2))
                                                (.. __stack (add __data1))
                                                (when (== __opcode ScriptOpCodes/OP_TUCK)
                                                    (.. __stack (add __data2))
                                                )
                                            )
                                        )

                                    ScriptOpCodes/OP_SIZE
                                        (do
                                            (when (< (.. __stack (size)) 1)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SIZE on an empty stack"))
                                            )
                                            (.. __stack (add (Utils/reverseBytes (Utils/encodeMPI (BigInteger/valueOf (.. __stack (getLast) (alength))), false))))
                                        )
                                    ScriptOpCodes/OP_EQUAL
                                        (do
                                            (when (< (.. __stack (size)) 2)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_EQUAL on a stack with size < 2"))
                                            )
                                            (.. __stack (add (if (Arrays/equals (.. __stack (pollLast)), (.. __stack (pollLast))) (byte-array [ 1 ]) (byte-array 0))))
                                        )
                                    ScriptOpCodes/OP_EQUALVERIFY
                                        (do
                                            (when (< (.. __stack (size)) 2)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_EQUALVERIFY on a stack with size < 2"))
                                            )
                                            (when (not (Arrays/equals (.. __stack (pollLast)), (.. __stack (pollLast))))
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_EQUALVERIFY, "OP_EQUALVERIFY: non-equal data"))
                                            )
                                        )

                                   [ScriptOpCodes/OP_1ADD
                                    ScriptOpCodes/OP_1SUB
                                    ScriptOpCodes/OP_NEGATE
                                    ScriptOpCodes/OP_ABS
                                    ScriptOpCodes/OP_NOT
                                    ScriptOpCodes/OP_0NOTEQUAL]
                                        (do
                                            (when (< (.. __stack (size)) 1)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted a numeric op on an empty stack"))
                                            )
                                            (let [#_"BigInteger" __n (Script/castToBigInteger (.. __stack (pollLast)), (.. __verifyFlags (contains Script.VerifyFlag/MINIMALDATA)))
                                                  __n (condp == __opcode
                                                        ScriptOpCodes/OP_1ADD      (.. __n (add BigInteger/ONE))
                                                        ScriptOpCodes/OP_1SUB      (.. __n (subtract BigInteger/ONE))
                                                        ScriptOpCodes/OP_NEGATE    (.. __n (negate))
                                                        ScriptOpCodes/OP_ABS       (if (< (.. __n (signum)) 0) (.. __n (negate)) __n)
                                                        ScriptOpCodes/OP_NOT       (if (.. __n (equals BigInteger/ZERO)) BigInteger/ONE BigInteger/ZERO)
                                                        ScriptOpCodes/OP_0NOTEQUAL (if (.. __n (equals BigInteger/ZERO)) BigInteger/ZERO BigInteger/ONE)
                                                        (throw (AssertionError. "Unreachable"))
                                                    )]
                                                (.. __stack (add (Utils/reverseBytes (Utils/encodeMPI __n, false))))
                                            )
                                        )
                                   [ScriptOpCodes/OP_ADD
                                    ScriptOpCodes/OP_SUB
                                    ScriptOpCodes/OP_BOOLAND
                                    ScriptOpCodes/OP_BOOLOR
                                    ScriptOpCodes/OP_NUMEQUAL
                                    ScriptOpCodes/OP_NUMNOTEQUAL
                                    ScriptOpCodes/OP_LESSTHAN
                                    ScriptOpCodes/OP_GREATERTHAN
                                    ScriptOpCodes/OP_LESSTHANOREQUAL
                                    ScriptOpCodes/OP_GREATERTHANOREQUAL
                                    ScriptOpCodes/OP_MIN
                                    ScriptOpCodes/OP_MAX]
                                        (do
                                            (when (< (.. __stack (size)) 2)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted a numeric op on a stack with size < 2"))
                                            )
                                            (let [#_"BigInteger" __n2 (Script/castToBigInteger (.. __stack (pollLast)), (.. __verifyFlags (contains Script.VerifyFlag/MINIMALDATA)))
                                                  #_"BigInteger" __n1 (Script/castToBigInteger (.. __stack (pollLast)), (.. __verifyFlags (contains Script.VerifyFlag/MINIMALDATA)))
                                                  #_"BigInteger" __n
                                                    (condp == __opcode
                                                        ScriptOpCodes/OP_ADD                (.. __n1 (add __n2))
                                                        ScriptOpCodes/OP_SUB                (.. __n1 (subtract __n2))
                                                        ScriptOpCodes/OP_BOOLAND            (if (and (not (.. __n1 (equals BigInteger/ZERO))) (not (.. __n2 (equals BigInteger/ZERO)))) BigInteger/ONE BigInteger/ZERO)
                                                        ScriptOpCodes/OP_BOOLOR             (if (or (not (.. __n1 (equals BigInteger/ZERO))) (not (.. __n2 (equals BigInteger/ZERO)))) BigInteger/ONE BigInteger/ZERO)
                                                        ScriptOpCodes/OP_NUMEQUAL           (if (.. __n1 (equals __n2)) BigInteger/ONE BigInteger/ZERO)
                                                        ScriptOpCodes/OP_NUMNOTEQUAL        (if (not (.. __n1 (equals __n2))) BigInteger/ONE BigInteger/ZERO)
                                                        ScriptOpCodes/OP_LESSTHAN           (if (< (.. __n1 (compareTo __n2)) 0) BigInteger/ONE BigInteger/ZERO)
                                                        ScriptOpCodes/OP_GREATERTHAN        (if (> (.. __n1 (compareTo __n2)) 0) BigInteger/ONE BigInteger/ZERO)
                                                        ScriptOpCodes/OP_LESSTHANOREQUAL    (if (<= (.. __n1 (compareTo __n2)) 0) BigInteger/ONE BigInteger/ZERO)
                                                        ScriptOpCodes/OP_GREATERTHANOREQUAL (if (>= (.. __n1 (compareTo __n2)) 0) BigInteger/ONE BigInteger/ZERO)
                                                        ScriptOpCodes/OP_MIN                (if (< (.. __n1 (compareTo __n2)) 0) __n1 __n2)
                                                        ScriptOpCodes/OP_MAX                (if (> (.. __n1 (compareTo __n2)) 0) __n1 __n2)
                                                        (throw (RuntimeException. "Opcode switched at runtime?"))
                                                    )]
                                                (.. __stack (add (Utils/reverseBytes (Utils/encodeMPI __n, false))))
                                            )
                                        )

                                    ScriptOpCodes/OP_NUMEQUALVERIFY
                                        (do
                                            (when (< (.. __stack (size)) 2)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_NUMEQUALVERIFY on a stack with size < 2"))
                                            )
                                            (let [#_"BigInteger" __n2 (Script/castToBigInteger (.. __stack (pollLast)), (.. __verifyFlags (contains Script.VerifyFlag/MINIMALDATA)))
                                                  #_"BigInteger" __n1 (Script/castToBigInteger (.. __stack (pollLast)), (.. __verifyFlags (contains Script.VerifyFlag/MINIMALDATA)))]

                                                (when (not (.. __n1 (equals __n2)))
                                                    (throw (ScriptException. ScriptError/SCRIPT_ERR_NUMEQUALVERIFY, "OP_NUMEQUALVERIFY failed"))
                                                )
                                            )
                                        )

                                    ScriptOpCodes/OP_WITHIN
                                        (do
                                            (when (< (.. __stack (size)) 3)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_WITHIN on a stack with size < 3"))
                                            )
                                            (let [#_"BigInteger" __n3 (Script/castToBigInteger (.. __stack (pollLast)), (.. __verifyFlags (contains Script.VerifyFlag/MINIMALDATA)))
                                                  #_"BigInteger" __n2 (Script/castToBigInteger (.. __stack (pollLast)), (.. __verifyFlags (contains Script.VerifyFlag/MINIMALDATA)))
                                                  #_"BigInteger" __n1 (Script/castToBigInteger (.. __stack (pollLast)), (.. __verifyFlags (contains Script.VerifyFlag/MINIMALDATA)))]
                                                (if (and (<= (.. __n2 (compareTo __n1)) 0) (< (.. __n1 (compareTo __n3)) 0))
                                                    (.. __stack (add (Utils/reverseBytes (Utils/encodeMPI BigInteger/ONE, false))))
                                                    (.. __stack (add (Utils/reverseBytes (Utils/encodeMPI BigInteger/ZERO, false))))
                                                )
                                            )
                                        )

                                    ScriptOpCodes/OP_RIPEMD160
                                        (do
                                            (when (< (.. __stack (size)) 1)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_RIPEMD160 on an empty stack"))
                                            )
                                            (let [#_"RIPEMD160Digest" __digest (RIPEMD160Digest.) #_"byte[]" __dataToHash (.. __stack (pollLast))]
                                                (.. __digest (update __dataToHash, 0, (.. __dataToHash (alength))))
                                                (let [#_"byte[]" __ripmemdHash (byte-array 20)]
                                                    (.. __digest (doFinal __ripmemdHash, 0))
                                                    (.. __stack (add __ripmemdHash))
                                                )
                                            )
                                        )
                                    ScriptOpCodes/OP_SHA1
                                        (do
                                            (when (< (.. __stack (size)) 1)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SHA1 on an empty stack"))
                                            )
                                            (try
                                                (.. __stack (add (.. (MessageDigest/getInstance "SHA-1") (digest (.. __stack (pollLast))))))
                                                (catch NoSuchAlgorithmException __e
                                                    (throw (RuntimeException. __e)) ;; Cannot happen.
                                                )
                                            )
                                        )
                                    ScriptOpCodes/OP_SHA256
                                        (do
                                            (when (< (.. __stack (size)) 1)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SHA256 on an empty stack"))
                                            )
                                            (.. __stack (add (Sha256Hash/hash (.. __stack (pollLast)))))
                                        )
                                    ScriptOpCodes/OP_HASH160
                                        (do
                                            (when (< (.. __stack (size)) 1)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_HASH160 on an empty stack"))
                                            )
                                            (.. __stack (add (Utils/sha256hash160 (.. __stack (pollLast)))))
                                        )
                                    ScriptOpCodes/OP_HASH256
                                        (do
                                            (when (< (.. __stack (size)) 1)
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SHA256 on an empty stack"))
                                            )
                                            (.. __stack (add (Sha256Hash/hashTwice (.. __stack (pollLast)))))
                                        )

                                    ScriptOpCodes/OP_CODESEPARATOR
                                        (do
                                            (ยง ass __lastCodeSepLocation (inc (.. __chunk (getStartLocationInProgram))))
                                        )

                                   [ScriptOpCodes/OP_CHECKSIG
                                    ScriptOpCodes/OP_CHECKSIGVERIFY]
                                        (do
                                            (when (nil? __txContainingThis)
                                                (throw (IllegalStateException. "Script attempted signature check but no tx was provided"))
                                            )
                                            (Script/executeCheckSig __txContainingThis, (int __index), __script, __stack, __lastCodeSepLocation, __opcode, __verifyFlags)
                                        )
                                   [ScriptOpCodes/OP_CHECKMULTISIG
                                    ScriptOpCodes/OP_CHECKMULTISIGVERIFY]
                                        (do
                                            (when (nil? __txContainingThis)
                                                (throw (IllegalStateException. "Script attempted signature check but no tx was provided"))
                                            )
                                            (ยง ass __opCount (Script/executeMultiSig __txContainingThis, (int __index), __script, __stack, __opCount, __lastCodeSepLocation, __opcode, __verifyFlags))
                                        )
                                    ScriptOpCodes/OP_CHECKLOCKTIMEVERIFY
                                        (if (not (.. __verifyFlags (contains Script.VerifyFlag/CHECKLOCKTIMEVERIFY)))
                                            ;; not enabled; treat as a NOP2
                                            (when (.. __verifyFlags (contains Script.VerifyFlag/DISCOURAGE_UPGRADABLE_NOPS))
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, (str "Script used a reserved opcode " __opcode)))
                                            )
                                            (Script/executeCheckLockTimeVerify __txContainingThis, (int __index), __stack, __verifyFlags)
                                        )
                                    ScriptOpCodes/OP_CHECKSEQUENCEVERIFY
                                        (if (not (.. __verifyFlags (contains Script.VerifyFlag/CHECKSEQUENCEVERIFY)))
                                            ;; not enabled; treat as a NOP3
                                            (when (.. __verifyFlags (contains Script.VerifyFlag/DISCOURAGE_UPGRADABLE_NOPS))
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, (str "Script used a reserved opcode " __opcode)))
                                            )
                                            (Script/executeCheckSequenceVerify __txContainingThis, (int __index), __stack, __verifyFlags)
                                        )

                                   [ScriptOpCodes/OP_NOP1
                                    ScriptOpCodes/OP_NOP4
                                    ScriptOpCodes/OP_NOP5
                                    ScriptOpCodes/OP_NOP6
                                    ScriptOpCodes/OP_NOP7
                                    ScriptOpCodes/OP_NOP8
                                    ScriptOpCodes/OP_NOP9
                                    ScriptOpCodes/OP_NOP10]
                                        (do
                                            (when (.. __verifyFlags (contains Script.VerifyFlag/DISCOURAGE_UPGRADABLE_NOPS))
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, (str "Script used a reserved opcode " __opcode)))
                                            )
                                        )

                                    (throw (ScriptException. ScriptError/SCRIPT_ERR_BAD_OPCODE, (str "Script used a reserved or disabled opcode: " __opcode)))
                                )
                            )
                        )

                        (when (not (<= 0 (+ (.. __stack (size)) (.. __altstack (size))) Script/MAX_STACK_SIZE))
                            (throw (ScriptException. ScriptError/SCRIPT_ERR_STACK_SIZE, "Stack size exceeded range"))
                        )
                    )
                )

                (when (not (.. __ifStack (isEmpty)))
                    (throw (ScriptException. ScriptError/SCRIPT_ERR_UNBALANCED_CONDITIONAL, "OP_IF/OP_NOTIF without OP_ENDIF"))
                )
                nil
            )
        )
    )

    ;; This is more or less a direct translation of the code in Bitcoin Core.
    #_private
    #_static
    #_throws #_[ "ScriptException" ]
    (ยง defn- #_"void" Script/executeCheckLockTimeVerify [#_"Transaction" __txContainingThis, #_"int" __index, #_"LinkedList<byte[]>" __stack, #_"Set<Script.VerifyFlag>" __verifyFlags]
        (when (< (.. __stack (size)) 1)
            (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKLOCKTIMEVERIFY on a stack with size < 1"))
        )

        ;; Thus as a special case we tell CScriptNum to accept up to 5-byte bignums to avoid year 2038 issue.
        (let [#_"BigInteger" __nLockTime (Script/castToBigInteger (.. __stack (getLast)), 5, (.. __verifyFlags (contains Script.VerifyFlag/MINIMALDATA)))]

            (when (< (.. __nLockTime (compareTo BigInteger/ZERO)) 0)
                (throw (ScriptException. ScriptError/SCRIPT_ERR_NEGATIVE_LOCKTIME, "Negative locktime"))
            )

            ;; There are two kinds of nLockTime, need to ensure we're comparing apples-to-apples.
            (when (not (or (and (< (.. __txContainingThis (getLockTime)) Transaction/LOCKTIME_THRESHOLD) (< (.. __nLockTime (compareTo Transaction/LOCKTIME_THRESHOLD_BIG)) 0)) (and (<= Transaction/LOCKTIME_THRESHOLD (.. __txContainingThis (getLockTime))) (<= 0 (.. __nLockTime (compareTo Transaction/LOCKTIME_THRESHOLD_BIG))))))
                (throw (ScriptException. ScriptError/SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Locktime requirement type mismatch"))
            )

            ;; Now that we know we're comparing apples-to-apples, the comparison is a simple numeric one.
            (when (< 0 (.. __nLockTime (compareTo (BigInteger/valueOf (.. __txContainingThis (getLockTime))))))
                (throw (ScriptException. ScriptError/SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Locktime requirement not satisfied"))
            )

            ;; Finally the nLockTime feature can be disabled and thus CHECKLOCKTIMEVERIFY bypassed if every txin has been
            ;; finalized by setting nSequence to maxint.  The transaction would be allowed into the blockchain, making
            ;; the opcode ineffective.
            ;;
            ;; Testing if this vin is not final is sufficient to prevent this condition.  Alternatively we could test all
            ;; inputs, but testing just this input minimizes the data required to prove correct CHECKLOCKTIMEVERIFY execution.
            (when (not (.. __txContainingThis (getInput __index) (hasSequence)))
                (throw (ScriptException. ScriptError/SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Transaction contains a final transaction input for a CHECKLOCKTIMEVERIFY script."))
            )
            nil
        )
    )

    #_private
    #_static
    #_throws #_[ "ScriptException" ]
    (ยง defn- #_"void" Script/executeCheckSequenceVerify [#_"Transaction" __txContainingThis, #_"int" __index, #_"LinkedList<byte[]>" __stack, #_"Set<Script.VerifyFlag>" __verifyFlags]
        (when (< (.. __stack (size)) 1)
            (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKSEQUENCEVERIFY on a stack with size < 1"))
        )

        ;; Note that elsewhere numeric opcodes are limited to operands in the range -2**31+1 to 2**31-1, however
        ;; it is legal for opcodes to produce results exceeding that range.  This limitation is implemented by
        ;; CScriptNum's default 4-byte limit.
        ;;
        ;; Thus as a special case we tell CScriptNum to accept up to 5-byte bignums, which are good until 2**39-1,
        ;; well beyond the 2**32-1 limit of the nSequence field itself.
        (let [#_"long" __nSequence (.. (Script/castToBigInteger (.. __stack (getLast)), 5, (.. __verifyFlags (contains Script.VerifyFlag/MINIMALDATA))) (longValue))]

            ;; In the rare event that the argument may be < 0 due to some arithmetic being done first, you can always
            ;; use 0 MAX CHECKSEQUENCEVERIFY.
            (when (< __nSequence 0)
                (throw (ScriptException. ScriptError/SCRIPT_ERR_NEGATIVE_LOCKTIME, "Negative sequence"))
            )

            ;; To provide for future soft-fork extensibility, if the operand has the disabled lock-time flag set,
            ;; CHECKSEQUENCEVERIFY behaves as a NOP.
            (when (!= (& __nSequence Transaction/SEQUENCE_LOCKTIME_DISABLE_FLAG) 0)
                (ยง return nil)
            )

            ;; Compare the specified sequence number with the input.
            (when (not (Script/checkSequence __nSequence, __txContainingThis, __index))
                (throw (ScriptException. ScriptError/SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Unsatisfied CHECKLOCKTIMEVERIFY lock time"))
            )
            nil
        )
    )

    #_private
    #_static
    (ยง defn- #_"boolean" Script/checkSequence [#_"long" __nSequence, #_"Transaction" __txContainingThis, #_"int" __index]
        ;; Relative lock times are supported by comparing the passed in operand to the sequence number
        ;; of the input.
        (let [#_"long" __txToSequence (.. __txContainingThis (getInput __index) (getSequenceNumber))]

            ;; Fail if the transaction's version number is not set high enough to trigger BIP 68 rules.
            (when (< (.. __txContainingThis (getVersion)) 2)
                (ยง return false)
            )

            ;; Sequence numbers with their most significant bit set are not consensus constrained.  Testing
            ;; that the transaction's sequence number do not have this bit set prevents using this property
            ;; to get around a CHECKSEQUENCEVERIFY check.
            (when (!= (& __txToSequence Transaction/SEQUENCE_LOCKTIME_DISABLE_FLAG) 0)
                (ยง return false)
            )

            ;; Mask off any bits that do not have consensus-enforced meaning before doing the integer comparisons.
            (let [#_"long" __nLockTimeMask (| Transaction/SEQUENCE_LOCKTIME_TYPE_FLAG Transaction/SEQUENCE_LOCKTIME_MASK)
                  #_"long" __txToSequenceMasked (& __txToSequence __nLockTimeMask)
                  #_"long" __nSequenceMasked (& __nSequence __nLockTimeMask)]

                ;; There are two kinds of nSequence: lock-by-blockheight and lock-by-blocktime, distinguished by
                ;; whether nSequenceMasked < CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.
                ;;
                ;; We want to compare apples to apples, so fail the script unless the type of nSequenceMasked
                ;; being tested is the same as the nSequenceMasked in the transaction.
                (when (not (or (and (< __txToSequenceMasked Transaction/SEQUENCE_LOCKTIME_TYPE_FLAG) (< __nSequenceMasked Transaction/SEQUENCE_LOCKTIME_TYPE_FLAG)) (and (<= Transaction/SEQUENCE_LOCKTIME_TYPE_FLAG __txToSequenceMasked) (<= Transaction/SEQUENCE_LOCKTIME_TYPE_FLAG __nSequenceMasked))))
                    (ยง return false)
                )

                ;; Now that we know we're comparing apples-to-apples, the comparison is a simple numeric one.
                (when (< __txToSequenceMasked __nSequenceMasked)
                    (ยง return false)
                )

                true
            )
        )
    )

    #_private
    #_static
    #_throws #_[ "ScriptException" ]
    (ยง defn- #_"void" Script/executeCheckSig [#_"Transaction" __txContainingThis, #_"int" __index, #_"Script" __script, #_"LinkedList<byte[]>" __stack, #_"int" __lastCodeSepLocation, #_"int" __opcode, #_"Set<Script.VerifyFlag>" __verifyFlags]
        (let [#_"boolean" __requireCanonical (or (.. __verifyFlags (contains Script.VerifyFlag/STRICTENC)) (.. __verifyFlags (contains Script.VerifyFlag/DERSIG)) (.. __verifyFlags (contains Script.VerifyFlag/LOW_S)))]
            (when (< (.. __stack (size)) 2)
                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKSIG(VERIFY) on a stack with size < 2"))
            )

            (let [#_"byte[]" __pubKey (.. __stack (pollLast))
                  #_"byte[]" __sigBytes (.. __stack (pollLast))]

                (let [#_"byte[]" __prog (.. __script (getProgram))
                      #_"byte[]" __connectedScript (Arrays/copyOfRange __prog, __lastCodeSepLocation, (.. __prog (alength)))]

                    (let [#_"ByteArrayOutputStream" __outStream (ByteArrayOutputStream. (inc (.. __sigBytes (alength))))]
                        (try
                            (Script/writeBytes __outStream, __sigBytes)
                            (catch IOException __e
                                (throw (RuntimeException. __e)) ;; Cannot happen.
                            )
                        )
                        (ยง ass __connectedScript (Script/removeAllInstancesOf __connectedScript, (.. __outStream (toByteArray))))

                        ;; TODO: Use int for indexes everywhere, we can't have that many inputs/outputs.
                        (let [#_"boolean" __sigValid false]
                            (try
                                (let [#_"TransactionSignature" __sig (TransactionSignature/decodeFromBitcoin __sigBytes, __requireCanonical, (.. __verifyFlags (contains Script.VerifyFlag/LOW_S)))]

                                    ;; TODO: Should check hash type is known.
                                    (let [#_"Sha256Hash" __hash (.. __txContainingThis (hashForSignature __index, __connectedScript, (byte (:sighash-flags __sig))))]
                                        (ยง ass __sigValid (ECKey/verify (.. __hash (getBytes)), __sig, __pubKey))
                                    )
                                )
                                (catch Exception __e
                                    ;; There is (at least) one exception that could be hit here (EOFException, if the sig is too short).
                                    ;; Because I can't verify there aren't more, we use a very generic Exception catch.

                                    ;; This RuntimeException occurs when signing as we run partial/invalid scripts to see if they need more
                                    ;; signing work to be done inside LocalTransactionSigner.signInputs.
                                    (when (not (.. __e (getMessage) (contains "Reached past end of ASN.1 stream")))
                                        (.. Script/log (warn "Signature checking failed!", __e))
                                    )
                                )
                            )

                            (cond (== __opcode ScriptOpCodes/OP_CHECKSIG)
                                (do
                                    (.. __stack (add (if __sigValid (byte-array [ 1 ]) (byte-array 0))))
                                )
                                (and (== __opcode ScriptOpCodes/OP_CHECKSIGVERIFY) (not __sigValid))
                                (do
                                    (throw (ScriptException. ScriptError/SCRIPT_ERR_CHECKSIGVERIFY, "Script failed OP_CHECKSIGVERIFY"))
                                )
                            )
                            nil
                        )
                    )
                )
            )
        )
    )

    #_private
    #_static
    #_throws #_[ "ScriptException" ]
    (ยง defn- #_"int" Script/executeMultiSig [#_"Transaction" __txContainingThis, #_"int" __index, #_"Script" __script, #_"LinkedList<byte[]>" __stack, #_"int" __opCount, #_"int" __lastCodeSepLocation, #_"int" __opcode, #_"Set<Script.VerifyFlag>" __verifyFlags]
        (let [#_"boolean" __requireCanonical (or (.. __verifyFlags (contains Script.VerifyFlag/STRICTENC)) (.. __verifyFlags (contains Script.VerifyFlag/DERSIG)) (.. __verifyFlags (contains Script.VerifyFlag/LOW_S)))]
            (when (< (.. __stack (size)) 1)
                (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size < 2"))
            )

            (let [#_"int" __pubKeyCount (.. (Script/castToBigInteger (.. __stack (pollLast)), (.. __verifyFlags (contains Script.VerifyFlag/MINIMALDATA))) (intValue))]
                (when (or (< __pubKeyCount 0) (< Script/MAX_PUBKEYS_PER_MULTISIG __pubKeyCount))
                    (throw (ScriptException. ScriptError/SCRIPT_ERR_PUBKEY_COUNT, "OP_CHECKMULTISIG(VERIFY) with pubkey count out of range"))
                )

                (ยง ass __opCount (+ __opCount __pubKeyCount))
                (when (< Script/MAX_OPS_PER_SCRIPT __opCount)
                    (throw (ScriptException. ScriptError/SCRIPT_ERR_OP_COUNT, "Total op count > 201 during OP_CHECKMULTISIG(VERIFY)"))
                )
                (when (< (.. __stack (size)) (inc __pubKeyCount))
                    (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size < num_of_pubkeys + 2"))
                )

                (let [#_"LinkedList<byte[]>" __pubkeys (LinkedList. #_"<>")]
                    (loop-when-recur [#_"int" __i 0] (< __i __pubKeyCount) [(inc __i)]
                        (.. __pubkeys (add (.. __stack (pollLast))))
                    )

                    (let [#_"int" __sigCount (.. (Script/castToBigInteger (.. __stack (pollLast)), (.. __verifyFlags (contains Script.VerifyFlag/MINIMALDATA))) (intValue))]
                        (when (or (< __sigCount 0) (< __pubKeyCount __sigCount))
                            (throw (ScriptException. ScriptError/SCRIPT_ERR_SIG_COUNT, "OP_CHECKMULTISIG(VERIFY) with sig count out of range"))
                        )
                        (when (< (.. __stack (size)) (inc __sigCount))
                            (throw (ScriptException. ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size < num_of_pubkeys + num_of_signatures + 3"))
                        )

                        (let [#_"LinkedList<byte[]>" __sigs (LinkedList. #_"<>")]
                            (loop-when-recur [#_"int" __i 0] (< __i __sigCount) [(inc __i)]
                                (.. __sigs (add (.. __stack (pollLast))))
                            )

                            (let [#_"byte[]" __prog (.. __script (getProgram))
                                  #_"byte[]" __connectedScript (Arrays/copyOfRange __prog, __lastCodeSepLocation, (.. __prog (alength)))]

                                (doseq [#_"byte[]" __sig __sigs]
                                    (let [#_"ByteArrayOutputStream" __outStream (ByteArrayOutputStream. (inc (.. __sig (alength))))]
                                        (try
                                            (Script/writeBytes __outStream, __sig)
                                            (catch IOException __e
                                                (throw (RuntimeException. __e)) ;; Cannot happen.
                                            )
                                        )
                                        (ยง ass __connectedScript (Script/removeAllInstancesOf __connectedScript, (.. __outStream (toByteArray))))
                                    )
                                )

                                (let [#_"boolean" __valid true]
                                    (while (< 0 (.. __sigs (size)))
                                        (let [#_"byte[]" __pubKey (.. __pubkeys (pollFirst))]
                                            ;; We could reasonably move this out of the loop, but because signature verification is significantly
                                            ;; more expensive than hashing, its not a big deal.
                                            (try
                                                (let [#_"TransactionSignature" __sig (TransactionSignature/decodeFromBitcoin (.. __sigs (getFirst)), __requireCanonical)
                                                      #_"Sha256Hash" __hash (.. __txContainingThis (hashForSignature __index, __connectedScript, (byte (:sighash-flags __sig))))]
                                                    (when (ECKey/verify (.. __hash (getBytes)), __sig, __pubKey)
                                                        (.. __sigs (pollFirst))
                                                    )
                                                )
                                                (catch Exception _
                                                    ;; There is (at least) one exception that could be hit here (EOFException, if the sig is too short).
                                                    ;; Because I can't verify there aren't more, we use a very generic Exception catch.
                                                )
                                            )

                                            (when (< (.. __pubkeys (size)) (.. __sigs (size)))
                                                (ยง ass __valid false)
                                                (ยง break )
                                            )
                                        )
                                    )

                                    ;; We uselessly remove a stack object to emulate a Bitcoin Core bug.
                                    (let [#_"byte[]" __nullDummy (.. __stack (pollLast))]
                                        (when (and (.. __verifyFlags (contains Script.VerifyFlag/NULLDUMMY)) (< 0 (.. __nullDummy (alength))))
                                            (throw (ScriptException. ScriptError/SCRIPT_ERR_SIG_NULLFAIL, (str "OP_CHECKMULTISIG(VERIFY) with non-null nulldummy: " (Arrays/toString __nullDummy))))
                                        )

                                        (cond (== __opcode ScriptOpCodes/OP_CHECKMULTISIG)
                                            (do
                                                (.. __stack (add (if __valid (byte-array [ 1 ]) (byte-array 0))))
                                            )
                                            (and (== __opcode ScriptOpCodes/OP_CHECKMULTISIGVERIFY) (not __valid))
                                            (do
                                                (throw (ScriptException. ScriptError/SCRIPT_ERR_SIG_NULLFAIL, "Script failed OP_CHECKMULTISIGVERIFY"))
                                            )
                                        )

                                        __opCount
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey, enabling all validation rules.
     ; @param txContainingThis The transaction in which this input scriptSig resides.
     ;                         Accessing txContainingThis from another thread while this method runs results in undefined behavior.
     ; @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
     ; @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
     ; @deprecated Use {@link #correctlySpends(org.bitcoinj.core.Transaction, long, org.bitcoinj.script.Script, java.util.Set)}
     ; instead so that verification flags do not change as new verification options are added.
     ;;
    #_deprecated
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"void" correctlySpends [#_"Transaction" __txContainingThis, #_"long" __scriptSigIndex, #_"Script" __scriptPubKey]
        (.. this (correctlySpends __txContainingThis, __scriptSigIndex, __scriptPubKey, Script/ALL_VERIFY_FLAGS))
        nil
    )

    ;;;
     ; Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey.
     ; @param txContainingThis The transaction in which this input scriptSig resides.
     ;                         Accessing txContainingThis from another thread while this method runs results in undefined behavior.
     ; @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
     ; @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
     ; @param verifyFlags Each flag enables one validation rule.  If in doubt, use {@link #correctlySpends(Transaction, long, Script)}
     ;                    which sets all flags.
     ;;
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"void" correctlySpends [#_"Transaction" __txContainingThis, #_"long" __scriptSigIndex, #_"Script" __scriptPubKey, #_"Set<Script.VerifyFlag>" __verifyFlags]
        ;; Clone the transaction because executing the script involves editing it, and if we die, we'll leave
        ;; the tx half broken (also it's not so thread safe to work on it directly).
        (try
            (ยง ass __txContainingThis (.. __txContainingThis (getParams) (getDefaultSerializer) (makeTransaction (.. __txContainingThis (bitcoinSerialize)))))
            (catch ProtocolException __e
                (throw (RuntimeException. __e)) ;; Should not happen unless we were given a totally broken transaction.
            )
        )

        (when (or (< Script/MAX_SCRIPT_SIZE (.. this (getProgram) (alength))) (< Script/MAX_SCRIPT_SIZE (.. __scriptPubKey (getProgram) (alength))))
            (throw (ScriptException. ScriptError/SCRIPT_ERR_SCRIPT_SIZE, "Script larger than 10,000 bytes"))
        )

        (let [#_"LinkedList<byte[]>" __stack (LinkedList. #_"<>")
              #_"LinkedList<byte[]>" __p2shStack nil]

            (Script/executeScript __txContainingThis, __scriptSigIndex, this, __stack, __verifyFlags)
            (when (.. __verifyFlags (contains Script.VerifyFlag/P2SH))
                (ยง ass __p2shStack (LinkedList. #_"<>" __stack))
            )
            (Script/executeScript __txContainingThis, __scriptSigIndex, __scriptPubKey, __stack, __verifyFlags)

            (when (== (.. __stack (size)) 0)
                (throw (ScriptException. ScriptError/SCRIPT_ERR_EVAL_FALSE, "Stack empty at end of script execution."))
            )

            (when (not (Script/castToBool (.. __stack (pollLast))))
                (throw (ScriptException. ScriptError/SCRIPT_ERR_EVAL_FALSE, (str "Script resulted in a non-true stack: " __stack)))
            )

            ;; P2SH is pay to script hash.  It means that the scriptPubKey has a special form which is a valid
            ;; program but it has "useless" form that if evaluated as a normal program always returns true.
            ;; Instead, miners recognize it as special based on its template - it provides a hash of the real scriptPubKey
            ;; and that must be provided by the input.  The goal of this bizarre arrangement is twofold:
            ;;
            ;; (1) You can sum up a large, complex script (like a CHECKMULTISIG script) with an address that's the same
            ;;     size as a regular address.  This means it doesn't overload scannable QR codes/NFC tags or become
            ;;     un-wieldy to copy/paste.
            ;; (2) It allows the working set to be smaller: nodes perform best when they can store as many unspent outputs
            ;;     in RAM as possible, so if the outputs are made smaller and the inputs get bigger, then it's better for
            ;;     overall scalability and performance.

            ;; TODO: Check if we can take out enforceP2SH if there's a checkpoint at the enforcement block.
            (when (and (.. __verifyFlags (contains Script.VerifyFlag/P2SH)) (.. __scriptPubKey (isPayToScriptHash)))
                (doseq [#_"ScriptChunk" __chunk (:chunks this)]
                    (when (and (.. __chunk (isOpCode)) (< ScriptOpCodes/OP_16 (:opcode __chunk)))
                        (throw (ScriptException. ScriptError/SCRIPT_ERR_SIG_PUSHONLY, "Attempted to spend a P2SH scriptPubKey with a script that contained script ops"))
                    )
                )

                (let [#_"byte[]" __scriptPubKeyBytes (.. __p2shStack (pollLast))
                      #_"Script" __scriptPubKeyP2SH (Script. __scriptPubKeyBytes)]

                    (Script/executeScript __txContainingThis, __scriptSigIndex, __scriptPubKeyP2SH, __p2shStack, __verifyFlags)

                    (when (== (.. __p2shStack (size)) 0)
                        (throw (ScriptException. ScriptError/SCRIPT_ERR_EVAL_FALSE, "P2SH stack empty at end of script execution."))
                    )

                    (when (not (Script/castToBool (.. __p2shStack (pollLast))))
                        (throw (ScriptException. ScriptError/SCRIPT_ERR_EVAL_FALSE, "P2SH script execution resulted in a non-true stack"))
                    )
                )
            )
            nil
        )
    )

    ;; Utility that doesn't copy for internal use.
    #_private
    (ยง method- #_"byte[]" getQuickProgram []
        (or (:program this) (.. this (getProgram)))
    )

    ;;;
     ; Get the {@link org.bitcoinj.script.Script.ScriptType}.
     ; @return The script type.
     ;;
    #_public
    (ยง method #_"Script.ScriptType" getScriptType []
        (when (.. this (isSentToAddress))
            (ยง return Script.ScriptType/P2PKH)
        )
        (when (.. this (isSentToRawPubKey))
            (ยง return Script.ScriptType/PUB_KEY)
        )
        (when (.. this (isPayToScriptHash))
            (ยง return Script.ScriptType/P2SH)
        )

        Script.ScriptType/NO_TYPE
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (Arrays/equals (.. this (getQuickProgram)), (.. (cast Script __o) (getQuickProgram)))
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Arrays/hashCode (.. this (getQuickProgram)))
    )
)

;;;
 ; <p>Tools for the construction of commonly used script types.  You don't normally need this as it's hidden
 ; behind convenience methods on {@link org.bitcoinj.core.Transaction}, but they are useful when working with
 ; the protocol at a lower level.</p>
 ;;
#_public
(ยง class ScriptBuilder
    #_private
    (ยง field- #_"List<ScriptChunk>" :chunks)

    ;;; Creates a fresh ScriptBuilder with an empty program. ;;
    #_public
    (ยง constructor ScriptBuilder []
        (ยง assoc this :chunks (Lists/newLinkedList))
        this
    )

    ;;; Creates a fresh ScriptBuilder with the given program as the starting point. ;;
    #_public
    (ยง constructor ScriptBuilder [#_"Script" __template]
        (ยง assoc this :chunks (ArrayList. #_"<>" (.. __template (getChunks))))
        this
    )

    ;;; Adds the given chunk to the end of the program. ;;
    #_public
    (ยง method #_"ScriptBuilder" addChunk [#_"ScriptChunk" __chunk]
        (.. this (addChunk (.. (:chunks this) (size)), __chunk))
    )

    ;;; Adds the given chunk at the given index in the program. ;;
    #_public
    (ยง method #_"ScriptBuilder" addChunk [#_"int" __index, #_"ScriptChunk" __chunk]
        (.. (:chunks this) (add __index, __chunk))
        this
    )

    ;;; Adds the given opcode to the end of the program. ;;
    #_public
    (ยง method #_"ScriptBuilder" op [#_"int" __opcode]
        (.. this (op (.. (:chunks this) (size)), __opcode))
    )

    ;;; Adds the given opcode to the given index in the program. ;;
    #_public
    (ยง method #_"ScriptBuilder" op [#_"int" __index, #_"int" __opcode]
        (Preconditions/checkArgument (< ScriptOpCodes/OP_PUSHDATA4 __opcode))
        (.. this (addChunk __index, (ScriptChunk. __opcode, nil)))
    )

    ;;; Adds a copy of the given byte array as a data element (i.e. PUSHDATA) at the end of the program. ;;
    #_public
    (ยง method #_"ScriptBuilder" data [#_"byte[]" __data]
        (if (== (.. __data (alength)) 0) (.. this (smallNum 0)) (.. this (data (.. (:chunks this) (size)), __data)))
    )

    ;;; Adds a copy of the given byte array as a data element (i.e. PUSHDATA) at the given index in the program. ;;
    #_public
    (ยง method #_"ScriptBuilder" data [#_"int" __index, #_"byte[]" __data]
        ;; implements BIP62
        (let [#_"byte[]" __copy (Arrays/copyOf __data, (.. __data (alength)))
              #_"int" __opcode]
            (cond (== (.. __data (alength)) 0)
                (do
                    (ยง ass __opcode ScriptOpCodes/OP_0)
                )
                (== (.. __data (alength)) 1)
                (do
                    (let [#_"byte" __b (aget __data 0)]
                        (if (<= 1 __b 16)
                            (ยง ass __opcode (Script/encodeToOpN __b))
                            (ยง ass __opcode 1)
                        )
                    )
                )
                (< (.. __data (alength)) ScriptOpCodes/OP_PUSHDATA1)
                (do
                    (ยง ass __opcode (.. __data (alength)))
                )
                (< (.. __data (alength)) 256)
                (do
                    (ยง ass __opcode ScriptOpCodes/OP_PUSHDATA1)
                )
                (< (.. __data (alength)) 65536)
                (do
                    (ยง ass __opcode ScriptOpCodes/OP_PUSHDATA2)
                )
                :else
                (do
                    (throw (RuntimeException. "Unimplemented"))
                )
            )
            (.. this (addChunk __index, (ScriptChunk. __opcode, __copy)))
        )
    )

    ;;;
     ; Adds the given number to the end of the program.
     ; Automatically uses shortest encoding possible.
     ;;
    #_public
    (ยง method #_"ScriptBuilder" number [#_"long" __num]
        (if (<= 0 __num 16) (.. this (smallNum (int __num))) (.. this (bigNum __num)))
    )

    ;;;
     ; Adds the given number to the given index in the program.
     ; Automatically uses shortest encoding possible.
     ;;
    #_public
    (ยง method #_"ScriptBuilder" number [#_"int" __index, #_"long" __num]
        (if (<= 0 __num 16) (.. this (smallNum __index, (int __num))) (.. this (bigNum __index, __num)))
    )

    ;;;
     ; Adds the given number as a OP_N opcode to the end of the program.
     ; Only handles values 0-16 inclusive.
     ;
     ; @see #number(int)
     ;;
    #_public
    (ยง method #_"ScriptBuilder" smallNum [#_"int" __num]
        (.. this (smallNum (.. (:chunks this) (size)), __num))
    )

    ;;; Adds the given number as a push data chunk.
     ; This is intended to use for negative numbers or values > 16, and although
     ; it will accept numbers in the range 0-16 inclusive, the encoding would be
     ; considered non-standard.
     ;
     ; @see #number(int)
     ;;
    #_protected
    (ยง method #_"ScriptBuilder" bigNum [#_"long" __num]
        (.. this (bigNum (.. (:chunks this) (size)), __num))
    )

    ;;;
     ; Adds the given number as a OP_N opcode to the given index in the program.
     ; Only handles values 0-16 inclusive.
     ;
     ; @see #number(int)
     ;;
    #_public
    (ยง method #_"ScriptBuilder" smallNum [#_"int" __index, #_"int" __num]
        (Preconditions/checkArgument (<= 0 __num), "Cannot encode negative numbers with smallNum")
        (Preconditions/checkArgument (<= __num 16), "Cannot encode numbers larger than 16 with smallNum")

        (.. this (addChunk __index, (ScriptChunk. (Script/encodeToOpN __num), nil)))
    )

    ;;;
     ; Adds the given number as a push data chunk to the given index in the program.
     ; This is intended to use for negative numbers or values > 16, and although
     ; it will accept numbers in the range 0-16 inclusive, the encoding would be
     ; considered non-standard.
     ;
     ; @see #number(int)
     ;;
    #_protected
    (ยง method #_"ScriptBuilder" bigNum [#_"int" __index, #_"long" __num]
        (let [#_"byte[]" __data]

            (cond (== __num 0)
                (do
                    (ยง ass __data (byte-array 0))
                )
                :else
                (do
                    (let [#_"Stack<Byte>" __result (Stack. #_"<>")
                          #_"boolean" __neg (< __num 0)
                          #_"long" __absvalue (Math/abs __num)]

                        (while (!= __absvalue 0)
                            (.. __result (push (byte (& __absvalue 0xff))))
                            (ยง ass __absvalue (>> __absvalue 8))
                        )

                        (cond (!= (& (.. __result (peek)) 0x80) 0)
                            (do
                                ;; The most significant byte is >= 0x80, so push an extra byte that
                                ;; contains just the sign of the value.
                                (.. __result (push (byte (if __neg 0x80 0))))
                            )
                            __neg
                            (do
                                ;; The most significant byte is < 0x80 and the value is negative,
                                ;; set the sign bit so it is subtracted and interpreted as a
                                ;; negative when converting back to an integral.
                                (.. __result (push (byte (| (.. __result (pop)) 0x80))))
                            )
                        )

                        (ยง ass __data (byte-array (.. __result (size))))
                        (loop-when-recur [#_"int" __byteIdx 0] (< __byteIdx (.. __data (alength))) [(inc __byteIdx)]
                            (aset __data __byteIdx (.. __result (get __byteIdx)))
                        )
                    )
                )
            )

            ;; At most the encoded value could take up to 8 bytes, so we don't need
            ;; to use OP_PUSHDATA opcodes.
            (.. this (addChunk __index, (ScriptChunk. (.. __data (alength)), __data)))
        )
    )

    ;;; Creates a new immutable Script based on the state of the builder. ;;
    #_public
    (ยง method #_"Script" build []
        (Script. (:chunks this))
    )

    ;;; Creates a scriptPubKey that encodes payment to the given address. ;;
    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createOutputScript [#_"Address" __to]
        (if (.. __to (isP2SHAddress))
            ;; OP_HASH160 <scriptHash> OP_EQUAL
            (.. (ScriptBuilder.) (op ScriptOpCodes/OP_HASH160) (data (.. __to (getHash160))) (op ScriptOpCodes/OP_EQUAL) (build))
            ;; OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
            (.. (ScriptBuilder.) (op ScriptOpCodes/OP_DUP) (op ScriptOpCodes/OP_HASH160) (data (.. __to (getHash160))) (op ScriptOpCodes/OP_EQUALVERIFY) (op ScriptOpCodes/OP_CHECKSIG) (build))
        )
    )

    ;;; Creates a scriptPubKey that encodes payment to the given raw public key. ;;
    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createOutputScript [#_"ECKey" __key]
        (.. (ScriptBuilder.) (data (.. __key (getPubKey))) (op ScriptOpCodes/OP_CHECKSIG) (build))
    )

    ;;;
     ; Creates a scriptSig that can redeem a pay-to-address output.
     ; If given signature is null, incomplete scriptSig will be created with OP_0 instead of signature.
     ;;
    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createInputScript [#_nilable #_"TransactionSignature" __signature, #_"ECKey" __pubKey]
        (let [#_"byte[]" __pubkeyBytes (.. __pubKey (getPubKey))
              #_"byte[]" __sigBytes (if (some? __signature) (.. __signature (encodeToBitcoin)) (byte-array 0))]
            (.. (ScriptBuilder.) (data __sigBytes) (data __pubkeyBytes) (build))
        )
    )

    ;;;
     ; Creates a scriptSig that can redeem a pay-to-pubkey output.
     ; If given signature is null, incomplete scriptSig will be created with OP_0 instead of signature.
     ;;
    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createInputScript [#_nilable #_"TransactionSignature" __signature]
        (let [#_"byte[]" __sigBytes (if (some? __signature) (.. __signature (encodeToBitcoin)) (byte-array 0))]
            (.. (ScriptBuilder.) (data __sigBytes) (build))
        )
    )

    ;;; Creates a program that requires at least N of the given keys to sign, using OP_CHECKMULTISIG. ;;
    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createMultiSigOutputScript [#_"int" __threshold, #_"List<ECKey>" __pubkeys]
        (Preconditions/checkArgument (< 0 __threshold))
        (Preconditions/checkArgument (<= __threshold (.. __pubkeys (size))))
        (Preconditions/checkArgument (<= (.. __pubkeys (size)) 16)) ;; That's the max we can represent with a single opcode.

        (let [#_"ScriptBuilder" __builder (ScriptBuilder.)]
            (.. __builder (smallNum __threshold))
            (doseq [#_"ECKey" __key __pubkeys]
                (.. __builder (data (.. __key (getPubKey))))
            )
            (.. __builder (smallNum (.. __pubkeys (size))))
            (.. __builder (op ScriptOpCodes/OP_CHECKMULTISIG))
            (.. __builder (build))
        )
    )

    ;;; Create a program that satisfies an OP_CHECKMULTISIG program. ;;
    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createMultiSigInputScript [#_"List<TransactionSignature>" __signatures]
        (let [#_"List<byte[]>" __sigs (ArrayList. #_"<>" (.. __signatures (size)))]
            (doseq [#_"TransactionSignature" __signature __signatures]
                (.. __sigs (add (.. __signature (encodeToBitcoin))))
            )

            (ScriptBuilder/createMultiSigInputScriptBytes __sigs, nil)
        )
    )

    ;;; Create a program that satisfies an OP_CHECKMULTISIG program. ;;
    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createMultiSigInputScript [#_"TransactionSignature..." __signatures]
        (ScriptBuilder/createMultiSigInputScript (Arrays/asList __signatures))
    )

    ;;; Create a program that satisfies an OP_CHECKMULTISIG program, using pre-encoded signatures. ;;
    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createMultiSigInputScriptBytes [#_"List<byte[]>" __signatures]
        (ScriptBuilder/createMultiSigInputScriptBytes __signatures, nil)
    )

    ;;;
     ; Create a program that satisfies a pay-to-script hashed OP_CHECKMULTISIG program.
     ; If given signature list is null, incomplete scriptSig will be created with OP_0 instead of signatures.
     ;;
    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createP2SHMultiSigInputScript [#_nilable #_"List<TransactionSignature>" __signatures, #_"Script" __multisigProgram]
        (let [#_"List<byte[]>" __sigs (ArrayList. #_"<>")]
            (cond (nil? __signatures)
                (do
                    ;; Create correct number of empty signatures.
                    (let [#_"int" __numSigs (.. __multisigProgram (getNumberOfSignaturesRequiredToSpend))]
                        (loop-when-recur [#_"int" __i 0] (< __i __numSigs) [(inc __i)]
                            (.. __sigs (add (byte-array 0)))
                        )
                    )
                )
                :else
                (do
                    (doseq [#_"TransactionSignature" __signature __signatures]
                        (.. __sigs (add (.. __signature (encodeToBitcoin))))
                    )
                )
            )
            (ScriptBuilder/createMultiSigInputScriptBytes __sigs, (.. __multisigProgram (getProgram)))
        )
    )

    ;;;
     ; Create a program that satisfies an OP_CHECKMULTISIG program, using pre-encoded signatures.
     ; Optionally, appends the script program bytes if spending a P2SH output.
     ;;
    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createMultiSigInputScriptBytes [#_"List<byte[]>" __signatures, #_nilable #_"byte[]" __multisigProgramBytes]
        (Preconditions/checkArgument (<= (.. __signatures (size)) 16))

        (let [#_"ScriptBuilder" __builder (ScriptBuilder.)]
            (.. __builder (smallNum 0)) ;; Work around a bug in CHECKMULTISIG that is now a required part of the protocol.
            (doseq [#_"byte[]" __signature __signatures]
                (.. __builder (data __signature))
            )
            (when (some? __multisigProgramBytes)
                (.. __builder (data __multisigProgramBytes))
            )
            (.. __builder (build))
        )
    )

    ;;;
     ; Returns a copy of the given scriptSig with the signature inserted in the given position.
     ;
     ; This function assumes that any missing sigs have OP_0 placeholders.  If given scriptSig
     ; already has all the signatures in place, IllegalArgumentException will be thrown.
     ;
     ; @param targetIndex Where to insert the signature.
     ; @param sigsPrefixCount How many items to copy verbatim (e.g. initial OP_0 for multisig).
     ; @param sigsSuffixCount How many items to copy verbatim at end (e.g. redeemScript for P2SH).
     ;;
    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/updateScriptWithSignature [#_"Script" __scriptSig, #_"byte[]" __signature, #_"int" __targetIndex, #_"int" __sigsPrefixCount, #_"int" __sigsSuffixCount]
        (let [#_"List<ScriptChunk>" __inputChunks (.. __scriptSig (getChunks))
              #_"int" __totalChunks (.. __inputChunks (size))]

            ;; Check if we have a place to insert, otherwise just return given scriptSig unchanged.
            ;; We assume here that OP_0 placeholders always go after the sigs, so
            ;; to find if we have sigs missing, we can just check the chunk in latest sig position.
            (let [#_"boolean" __hasMissingSigs (.. __inputChunks (get (- __totalChunks __sigsSuffixCount 1)) (equalsOpCode ScriptOpCodes/OP_0))]
                (Preconditions/checkArgument __hasMissingSigs, "ScriptSig is already filled with signatures")

                ;; copy the prefix
                (let [#_"ScriptBuilder" __builder (ScriptBuilder.)]
                    (doseq [#_"ScriptChunk" __chunk (.. __inputChunks (subList 0, __sigsPrefixCount))]
                        (.. __builder (addChunk __chunk))
                    )

                    ;; Copy the sigs.
                    (let [#_"int" __pos 0
                          #_"boolean" __inserted false]
                        (doseq [#_"ScriptChunk" __chunk (.. __inputChunks (subList __sigsPrefixCount, (- __totalChunks __sigsSuffixCount)))]
                            (when (== __pos __targetIndex)
                                (ยง ass __inserted true)
                                (.. __builder (data __signature))
                                (ยง ass __pos (inc __pos))
                            )
                            (when (not (.. __chunk (equalsOpCode ScriptOpCodes/OP_0)))
                                (.. __builder (addChunk __chunk))
                                (ยง ass __pos (inc __pos))
                            )
                        )

                        ;; Add OP_0's if needed, since we skipped them in the previous loop.
                        (while (< __pos (- __totalChunks __sigsPrefixCount __sigsSuffixCount))
                            (cond (== __pos __targetIndex)
                                (do
                                    (ยง ass __inserted true)
                                    (.. __builder (data __signature))
                                )
                                :else
                                (do
                                    (.. __builder (addChunk (ScriptChunk. ScriptOpCodes/OP_0, nil)))
                                )
                            )
                            (ยง ass __pos (inc __pos))
                        )

                        ;; Copy the suffix.
                        (doseq [#_"ScriptChunk" __chunk (.. __inputChunks (subList (- __totalChunks __sigsSuffixCount), __totalChunks))]
                            (.. __builder (addChunk __chunk))
                        )

                        (Preconditions/checkState __inserted)
                        (.. __builder (build))
                    )
                )
            )
        )
    )

    ;;;
     ; Creates a scriptPubKey that sends to the given script hash.  Read
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP 16</a>
     ; to learn more about this kind of script.
     ;;
    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createP2SHOutputScript [#_"byte[]" __hash]
        (Preconditions/checkArgument (== (.. __hash (alength)) 20))

        (.. (ScriptBuilder.) (op ScriptOpCodes/OP_HASH160) (data __hash) (op ScriptOpCodes/OP_EQUAL) (build))
    )

    ;;;
     ; Creates a scriptPubKey for the given redeem script.
     ;;
    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createP2SHOutputScript [#_"Script" __redeemScript]
        (let [#_"byte[]" __hash (Utils/sha256hash160 (.. __redeemScript (getProgram)))]
            (ScriptBuilder/createP2SHOutputScript __hash)
        )
    )

    ;;;
     ; Creates a P2SH output script with given public keys and threshold.
     ; Given public keys will be placed in redeem script in the lexicographical sorting order.
     ;;
    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createP2SHOutputScript [#_"int" __threshold, #_"List<ECKey>" __pubkeys]
        (let [#_"Script" __redeemScript (ScriptBuilder/createRedeemScript __threshold, __pubkeys)]
            (ScriptBuilder/createP2SHOutputScript __redeemScript)
        )
    )

    ;;;
     ; Creates redeem script with given public keys and threshold.
     ; Given public keys will be placed in redeem script in the lexicographical sorting order.
     ;;
    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createRedeemScript [#_"int" __threshold, #_"List<ECKey>" __pubkeys]
        (ยง ass __pubkeys (ArrayList. #_"<>" __pubkeys))
        (Collections/sort __pubkeys, ECKey/PUBKEY_COMPARATOR)
        (ScriptBuilder/createMultiSigOutputScript __threshold, __pubkeys)
    )

    ;;;
     ; Creates a script of the form OP_RETURN [data].  This feature allows you to attach
     ; a small piece of data (like a hash of something stored elsewhere) to a zero valued
     ; output which can never be spent and thus does not pollute the ledger.
     ;;
    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createOpReturnScript [#_"byte[]" __data]
        (Preconditions/checkArgument (<= (.. __data (alength)) 80))

        (.. (ScriptBuilder.) (op ScriptOpCodes/OP_RETURN) (data __data) (build))
    )

    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createCLTVPaymentChannelOutput [#_"BigInteger" __time, #_"ECKey" __from, #_"ECKey" __to]
        (let [#_"byte[]" __timeBytes (Utils/reverseBytes (Utils/encodeMPI __time, false))]
            (when (< 5 (.. __timeBytes (alength)))
                (throw (RuntimeException. "Time too large to encode as 5-byte int"))
            )

            (.. (ScriptBuilder.) (op ScriptOpCodes/OP_IF) (data (.. __to (getPubKey))) (op ScriptOpCodes/OP_CHECKSIGVERIFY) (op ScriptOpCodes/OP_ELSE) (data __timeBytes) (op ScriptOpCodes/OP_CHECKLOCKTIMEVERIFY) (op ScriptOpCodes/OP_DROP) (op ScriptOpCodes/OP_ENDIF) (data (.. __from (getPubKey))) (op ScriptOpCodes/OP_CHECKSIG) (build))
        )
    )

    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createCLTVPaymentChannelRefund [#_"TransactionSignature" __signature]
        (let [#_"ScriptBuilder" __builder (ScriptBuilder.)]
            (.. __builder (data (.. __signature (encodeToBitcoin))))
            (.. __builder (data (byte-array [ 0 ]))) ;; Use the CHECKLOCKTIMEVERIFY if branch.
            (.. __builder (build))
        )
    )

    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createCLTVPaymentChannelP2SHRefund [#_"TransactionSignature" __signature, #_"Script" __redeemScript]
        (let [#_"ScriptBuilder" __builder (ScriptBuilder.)]
            (.. __builder (data (.. __signature (encodeToBitcoin))))
            (.. __builder (data (byte-array [ 0 ]))) ;; Use the CHECKLOCKTIMEVERIFY if branch.
            (.. __builder (data (.. __redeemScript (getProgram))))
            (.. __builder (build))
        )
    )

    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createCLTVPaymentChannelP2SHInput [#_"byte[]" __from, #_"byte[]" __to, #_"Script" __redeemScript]
        (let [#_"ScriptBuilder" __builder (ScriptBuilder.)]
            (.. __builder (data __from))
            (.. __builder (data __to))
            (.. __builder (smallNum 1)) ;; Use the CHECKLOCKTIMEVERIFY if branch.
            (.. __builder (data (.. __redeemScript (getProgram))))
            (.. __builder (build))
        )
    )

    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createCLTVPaymentChannelInput [#_"TransactionSignature" __from, #_"TransactionSignature" __to]
        (ScriptBuilder/createCLTVPaymentChannelInput (.. __from (encodeToBitcoin)), (.. __to (encodeToBitcoin)))
    )

    #_public
    #_static
    (ยง defn #_"Script" ScriptBuilder/createCLTVPaymentChannelInput [#_"byte[]" __from, #_"byte[]" __to]
        (let [#_"ScriptBuilder" __builder (ScriptBuilder.)]
            (.. __builder (data __from))
            (.. __builder (data __to))
            (.. __builder (smallNum 1)) ;; Use the CHECKLOCKTIMEVERIFY if branch.
            (.. __builder (build))
        )
    )
)

;;;
 ; A script element that is either a data push (signature, pubkey, etc.) or a non-push (logic, numeric, etc.) operation.
 ;;
#_public
(ยง class ScriptChunk
    ;;; Operation to be executed.  Opcodes are defined in {@link ScriptOpCodes}. ;;
    #_public
    (ยง field #_"int" :opcode)
    ;;;
     ; For push operations, this is the vector to be pushed on the stack.
     ; For {@link ScriptOpCodes#OP_0}, the vector is empty.
     ; Null for non-push operations.
     ;;
    #_nilable
    #_public
    (ยง field #_"byte[]" :data)
    #_private
    (ยง field- #_"int" :start-location-in-program)

    #_public
    (ยง constructor ScriptChunk [#_"int" __opcode, #_"byte[]" __data]
        (ยง this __opcode, __data, -1)
        this
    )

    #_public
    (ยง constructor ScriptChunk [#_"int" __opcode, #_"byte[]" __data, #_"int" __startLocationInProgram]
        (ยง assoc this :opcode __opcode)
        (ยง assoc this :data __data)
        (ยง assoc this :start-location-in-program __startLocationInProgram)
        this
    )

    #_public
    (ยง method #_"boolean" equalsOpCode [#_"int" __opcode]
        (== __opcode (:opcode this))
    )

    ;;;
     ; If this chunk is a single byte of non-pushdata content (could be OP_RESERVED or some invalid Opcode).
     ;;
    #_public
    (ยง method #_"boolean" isOpCode []
        (< ScriptOpCodes/OP_PUSHDATA4 (:opcode this))
    )

    ;;;
     ; Returns true if this chunk is pushdata content, including the single-byte pushdatas.
     ;;
    #_public
    (ยง method #_"boolean" isPushData []
        (<= (:opcode this) ScriptOpCodes/OP_16)
    )

    #_public
    (ยง method #_"int" getStartLocationInProgram []
        (Preconditions/checkState (<= 0 (:start-location-in-program this)))

        (:start-location-in-program this)
    )

    ;;; If this chunk is an OP_N opcode returns the equivalent integer value. ;;
    #_public
    (ยง method #_"int" decodeOpN []
        (Preconditions/checkState (.. this (isOpCode)))

        (Script/decodeFromOpN (:opcode this))
    )

    ;;;
     ; Called on a pushdata chunk, returns true if it uses the smallest possible way (according to BIP62) to push the data.
     ;;
    #_public
    (ยง method #_"boolean" isShortestPossiblePushData []
        (Preconditions/checkState (.. this (isPushData)))

        (when (nil? (:data this))
            (ยง return true) ;; OP_N
        )
        (when (== (.. (:data this) (alength)) 0)
            (ยง return (== (:opcode this) ScriptOpCodes/OP_0))
        )
        (when (== (.. (:data this) (alength)) 1)
            (let [#_"byte" __b (aget (:data this) 0)]
                (when (<= 0x01 __b 0x10)
                    (ยง return (== (:opcode this) (dec (+ ScriptOpCodes/OP_1 __b))))
                )
                (when (== (& __b 0xff) 0x81)
                    (ยง return (== (:opcode this) ScriptOpCodes/OP_1NEGATE))
                )
            )
        )
        (when (< (.. (:data this) (alength)) ScriptOpCodes/OP_PUSHDATA1)
            (ยง return (== (:opcode this) (.. (:data this) (alength))))
        )
        (when (< (.. (:data this) (alength)) 256)
            (ยง return (== (:opcode this) ScriptOpCodes/OP_PUSHDATA1))
        )
        (when (< (.. (:data this) (alength)) 65536)
            (ยง return (== (:opcode this) ScriptOpCodes/OP_PUSHDATA2))
        )

        ;; Can never be used, but implemented for completeness.
        (== (:opcode this) ScriptOpCodes/OP_PUSHDATA4)
    )

    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" write [#_"OutputStream" __stream]
        (cond (.. this (isOpCode))
            (do
                (Preconditions/checkState (nil? (:data this)))
                (.. __stream (write (:opcode this)))
            )
            (some? (:data this))
            (do
                (cond (< (:opcode this) ScriptOpCodes/OP_PUSHDATA1)
                    (do
                        (Preconditions/checkState (== (.. (:data this) (alength)) (:opcode this)))
                        (.. __stream (write (:opcode this)))
                    )
                    (== (:opcode this) ScriptOpCodes/OP_PUSHDATA1)
                    (do
                        (Preconditions/checkState (<= (.. (:data this) (alength)) 0xff))
                        (.. __stream (write ScriptOpCodes/OP_PUSHDATA1))
                        (.. __stream (write (.. (:data this) (alength))))
                    )
                    (== (:opcode this) ScriptOpCodes/OP_PUSHDATA2)
                    (do
                        (Preconditions/checkState (<= (.. (:data this) (alength)) 0xffff))
                        (.. __stream (write ScriptOpCodes/OP_PUSHDATA2))
                        (.. __stream (write (& 0xff (.. (:data this) (alength)))))
                        (.. __stream (write (& 0xff (>> (.. (:data this) (alength)) 8))))
                    )
                    (== (:opcode this) ScriptOpCodes/OP_PUSHDATA4)
                    (do
                        (Preconditions/checkState (<= (.. (:data this) (alength)) Script/MAX_SCRIPT_ELEMENT_SIZE))
                        (.. __stream (write ScriptOpCodes/OP_PUSHDATA4))
                        (Utils/uint32ToByteStreamLE (.. (:data this) (alength)), __stream)
                    )
                    :else
                    (do
                        (throw (RuntimeException. "Unimplemented"))
                    )
                )
                (.. __stream (write (:data this)))
            )
            :else
            (do
                (.. __stream (write (:opcode this))) ;; smallNum
            )
        )
        nil
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (cond (.. this (isOpCode))
                (str (ScriptOpCodes/getOpCodeName (:opcode this)))
            (some? (:data this)) ;; Data chunk.
                (str (ScriptOpCodes/getPushDataName (:opcode this)) "[" (.. Utils/HEX (encode (:data this))) "]")
            :else ;; Small num.
                (str (Script/decodeFromOpN (:opcode this)))
        )
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"ScriptChunk" __other (cast ScriptChunk __o)]
            (and (== (:opcode this) (:opcode __other)) (== (:start-location-in-program this) (:start-location-in-program __other)) (Arrays/equals (:data this), (:data __other)))
        )
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (:opcode this), (:start-location-in-program this), (Arrays/hashCode (:data this)))
    )
)

#_public
(ยง enum ScriptError
    (ยง item (SCRIPT_ERR_OK "OK"))
    (ยง item (SCRIPT_ERR_UNKNOWN_ERROR "UNKNOWN_ERROR"))
    (ยง item (SCRIPT_ERR_EVAL_FALSE "EVAL_FALSE"))
    (ยง item (SCRIPT_ERR_OP_RETURN "OP_RETURN"))

    ;;; max sizes ;;
    (ยง item (SCRIPT_ERR_SCRIPT_SIZE "SCRIPT_SIZE"))
    (ยง item (SCRIPT_ERR_PUSH_SIZE "PUSH_SIZE"))
    (ยง item (SCRIPT_ERR_OP_COUNT "OP_COUNT"))
    (ยง item (SCRIPT_ERR_STACK_SIZE "STACK_SIZE"))
    (ยง item (SCRIPT_ERR_SIG_COUNT "SIG_COUNT"))
    (ยง item (SCRIPT_ERR_PUBKEY_COUNT "PUBKEY_COUNT"))

    ;;; failed verify operations ;;
    (ยง item (SCRIPT_ERR_VERIFY "VERIFY"))
    (ยง item (SCRIPT_ERR_EQUALVERIFY "EQUALVERIFY"))
    (ยง item (SCRIPT_ERR_CHECKMULTISIGVERIFY "CHECKMULTISIGVERIFY"))
    (ยง item (SCRIPT_ERR_CHECKSIGVERIFY "CHECKSIGVERIFY"))
    (ยง item (SCRIPT_ERR_NUMEQUALVERIFY "NUMEQUALVERIFY"))

    ;;; logical/format/canonical errors ;;
    (ยง item (SCRIPT_ERR_BAD_OPCODE "BAD_OPCODE"))
    (ยง item (SCRIPT_ERR_DISABLED_OPCODE "DISABLED_OPCODE"))
    (ยง item (SCRIPT_ERR_INVALID_STACK_OPERATION "INVALID_STACK_OPERATION"))
    (ยง item (SCRIPT_ERR_INVALID_ALTSTACK_OPERATION "INVALID_ALTSTACK_OPERATION"))
    (ยง item (SCRIPT_ERR_UNBALANCED_CONDITIONAL "UNBALANCED_CONDITIONAL"))

    ;;; CHECKLOCKTIMEVERIFY and CHECKSEQUENCEVERIFY ;;
    (ยง item (SCRIPT_ERR_NEGATIVE_LOCKTIME "NEGATIVE_LOCKTIME"))
    (ยง item (SCRIPT_ERR_UNSATISFIED_LOCKTIME "UNSATISFIED_LOCKTIME"))

    ;;; malleability ;;
    (ยง item (SCRIPT_ERR_SIG_HASHTYPE "SIG_HASHTYPE"))
    (ยง item (SCRIPT_ERR_SIG_DER "SIG_DER"))
    (ยง item (SCRIPT_ERR_MINIMALDATA "MINIMALDATA"))
    (ยง item (SCRIPT_ERR_SIG_PUSHONLY "SIG_PUSHONLY"))
    (ยง item (SCRIPT_ERR_SIG_HIGH_S "SIG_HIGH_S"))
    (ยง item (SCRIPT_ERR_SIG_NULLDUMMY "SIG_NULLDUMMY"))
    (ยง item (SCRIPT_ERR_PUBKEYTYPE "PUBKEYTYPE"))
    (ยง item (SCRIPT_ERR_CLEANSTACK "CLEANSTACK"))
    (ยง item (SCRIPT_ERR_MINIMALIF "MINIMALIF"))
    (ยง item (SCRIPT_ERR_SIG_NULLFAIL "NULLFAIL"))

    ;;; softfork safeness ;;
    (ยง item (SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS "DISCOURAGE_UPGRADABLE_NOPS"))
    (ยง item (SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM "DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM"))

    ;;; segregated witness ;;
    (ยง item (SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH "WITNESS_PROGRAM_WRONG_LENGTH"))
    (ยง item (SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY "WITNESS_PROGRAM_WITNESS_EMPTY"))
    (ยง item (SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH "WITNESS_PROGRAM_MISMATCH"))
    (ยง item (SCRIPT_ERR_WITNESS_MALLEATED "WITNESS_MALLEATED"))
    (ยง item (SCRIPT_ERR_WITNESS_MALLEATED_P2SH "WITNESS_MALLEATED_P2SH"))
    (ยง item (SCRIPT_ERR_WITNESS_UNEXPECTED "WITNESS_UNEXPECTED"))
    (ยง item (SCRIPT_ERR_WITNESS_PUBKEYTYPE "WITNESS_PUBKEYTYPE"))

    (ยง item (SCRIPT_ERR_ERROR_COUNT "ERROR_COUNT"))

    #_private
    (ยง field- #_"String" :mnemonic)
    #_private
    #_static
    (ยง def- #_"Map<String, ScriptError>" ScriptError/MNEMONIC_TO_SCRIPT_ERROR_MAP)

    #_private
    (ยง constructor- #_"ScriptError" [#_"String" __name]
        (ยง assoc this :mnemonic __name)
        this
    )

    #_static
    (ยง block
        (ยง ass ScriptError/MNEMONIC_TO_SCRIPT_ERROR_MAP (HashMap. #_"<>"))
        (doseq [#_"ScriptError" __err (ScriptError/values)]
            (.. ScriptError/MNEMONIC_TO_SCRIPT_ERROR_MAP (put (.. __err (getMnemonic)), __err))
        )
    )

    #_public
    (ยง method #_"String" getMnemonic []
        (:mnemonic this)
    )

    #_public
    #_static
    (ยง defn #_"ScriptError" ScriptError/fromMnemonic [#_"String" __name]
        (let [#_"ScriptError" __err (.. ScriptError/MNEMONIC_TO_SCRIPT_ERROR_MAP (get __name))]
            (when (nil? __err)
                (throw (IllegalArgumentException. (str __name " is not a valid name")))
            )
            __err
        )
    )
)

;;;
 ; Various constants that define the assembly-like scripting language that forms part of the Bitcoin protocol.
 ; See {@link org.bitcoinj.script.Script} for details.  Also provides a method to convert them to a string.
 ;;
#_public
(ยง class ScriptOpCodes
    ;; push value
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_0 0x00) ;; push empty vector
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_FALSE ScriptOpCodes/OP_0)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_PUSHDATA1 0x4c)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_PUSHDATA2 0x4d)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_PUSHDATA4 0x4e)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_1NEGATE 0x4f)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_RESERVED 0x50)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_1 0x51)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_TRUE ScriptOpCodes/OP_1)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_2 0x52)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_3 0x53)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_4 0x54)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_5 0x55)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_6 0x56)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_7 0x57)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_8 0x58)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_9 0x59)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_10 0x5a)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_11 0x5b)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_12 0x5c)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_13 0x5d)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_14 0x5e)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_15 0x5f)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_16 0x60)

    ;; control
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_NOP 0x61)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_VER 0x62)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_IF 0x63)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_NOTIF 0x64)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_VERIF 0x65)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_VERNOTIF 0x66)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_ELSE 0x67)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_ENDIF 0x68)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_VERIFY 0x69)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_RETURN 0x6a)

    ;; stack ops
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_TOALTSTACK 0x6b)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_FROMALTSTACK 0x6c)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_2DROP 0x6d)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_2DUP 0x6e)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_3DUP 0x6f)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_2OVER 0x70)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_2ROT 0x71)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_2SWAP 0x72)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_IFDUP 0x73)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_DEPTH 0x74)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_DROP 0x75)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_DUP 0x76)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_NIP 0x77)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_OVER 0x78)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_PICK 0x79)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_ROLL 0x7a)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_ROT 0x7b)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_SWAP 0x7c)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_TUCK 0x7d)

    ;; splice ops
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_CAT 0x7e)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_SUBSTR 0x7f)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_LEFT 0x80)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_RIGHT 0x81)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_SIZE 0x82)

    ;; bit logic
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_INVERT 0x83)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_AND 0x84)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_OR 0x85)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_XOR 0x86)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_EQUAL 0x87)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_EQUALVERIFY 0x88)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_RESERVED1 0x89)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_RESERVED2 0x8a)

    ;; numeric
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_1ADD 0x8b)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_1SUB 0x8c)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_2MUL 0x8d)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_2DIV 0x8e)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_NEGATE 0x8f)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_ABS 0x90)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_NOT 0x91)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_0NOTEQUAL 0x92)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_ADD 0x93)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_SUB 0x94)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_MUL 0x95)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_DIV 0x96)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_MOD 0x97)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_LSHIFT 0x98)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_RSHIFT 0x99)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_BOOLAND 0x9a)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_BOOLOR 0x9b)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_NUMEQUAL 0x9c)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_NUMEQUALVERIFY 0x9d)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_NUMNOTEQUAL 0x9e)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_LESSTHAN 0x9f)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_GREATERTHAN 0xa0)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_LESSTHANOREQUAL 0xa1)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_GREATERTHANOREQUAL 0xa2)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_MIN 0xa3)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_MAX 0xa4)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_WITHIN 0xa5)

    ;; crypto
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_RIPEMD160 0xa6)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_SHA1 0xa7)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_SHA256 0xa8)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_HASH160 0xa9)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_HASH256 0xaa)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_CODESEPARATOR 0xab)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_CHECKSIG 0xac)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_CHECKSIGVERIFY 0xad)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_CHECKMULTISIG 0xae)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_CHECKMULTISIGVERIFY 0xaf)

    ;; block state
    ;;; Check lock time of the block.  Introduced in BIP 65, replacing OP_NOP2 ;;
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_CHECKLOCKTIMEVERIFY 0xb1)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_CHECKSEQUENCEVERIFY 0xb2)

    ;; expansion
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_NOP1 0xb0)
    ;;; Deprecated by BIP 65 ;;
    #_deprecated
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_NOP2 ScriptOpCodes/OP_CHECKLOCKTIMEVERIFY)
    ;;; Deprecated by BIP 112 ;;
    #_deprecated
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_NOP3 ScriptOpCodes/OP_CHECKSEQUENCEVERIFY)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_NOP4 0xb3)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_NOP5 0xb4)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_NOP6 0xb5)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_NOP7 0xb6)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_NOP8 0xb7)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_NOP9 0xb8)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_NOP10 0xb9)
    #_public
    #_static
    (ยง def #_"int" ScriptOpCodes/OP_INVALIDOPCODE 0xff)

    #_private
    #_static
    (ยง def- #_"Map<Integer, String>" ScriptOpCodes/OP_CODE_MAP (.. (ImmutableMap/builder #_"ImmutableMap<Integer, String>") (put ScriptOpCodes/OP_0, "0") (put ScriptOpCodes/OP_PUSHDATA1, "PUSHDATA1") (put ScriptOpCodes/OP_PUSHDATA2, "PUSHDATA2") (put ScriptOpCodes/OP_PUSHDATA4, "PUSHDATA4") (put ScriptOpCodes/OP_1NEGATE, "1NEGATE") (put ScriptOpCodes/OP_RESERVED, "RESERVED") (put ScriptOpCodes/OP_1, "1") (put ScriptOpCodes/OP_2, "2") (put ScriptOpCodes/OP_3, "3") (put ScriptOpCodes/OP_4, "4") (put ScriptOpCodes/OP_5, "5") (put ScriptOpCodes/OP_6, "6") (put ScriptOpCodes/OP_7, "7") (put ScriptOpCodes/OP_8, "8") (put ScriptOpCodes/OP_9, "9") (put ScriptOpCodes/OP_10, "10") (put ScriptOpCodes/OP_11, "11") (put ScriptOpCodes/OP_12, "12") (put ScriptOpCodes/OP_13, "13") (put ScriptOpCodes/OP_14, "14") (put ScriptOpCodes/OP_15, "15") (put ScriptOpCodes/OP_16, "16") (put ScriptOpCodes/OP_NOP, "NOP") (put ScriptOpCodes/OP_VER, "VER") (put ScriptOpCodes/OP_IF, "IF") (put ScriptOpCodes/OP_NOTIF, "NOTIF") (put ScriptOpCodes/OP_VERIF, "VERIF") (put ScriptOpCodes/OP_VERNOTIF, "VERNOTIF") (put ScriptOpCodes/OP_ELSE, "ELSE") (put ScriptOpCodes/OP_ENDIF, "ENDIF") (put ScriptOpCodes/OP_VERIFY, "VERIFY") (put ScriptOpCodes/OP_RETURN, "RETURN") (put ScriptOpCodes/OP_TOALTSTACK, "TOALTSTACK") (put ScriptOpCodes/OP_FROMALTSTACK, "FROMALTSTACK") (put ScriptOpCodes/OP_2DROP, "2DROP") (put ScriptOpCodes/OP_2DUP, "2DUP") (put ScriptOpCodes/OP_3DUP, "3DUP") (put ScriptOpCodes/OP_2OVER, "2OVER") (put ScriptOpCodes/OP_2ROT, "2ROT") (put ScriptOpCodes/OP_2SWAP, "2SWAP") (put ScriptOpCodes/OP_IFDUP, "IFDUP") (put ScriptOpCodes/OP_DEPTH, "DEPTH") (put ScriptOpCodes/OP_DROP, "DROP") (put ScriptOpCodes/OP_DUP, "DUP") (put ScriptOpCodes/OP_NIP, "NIP") (put ScriptOpCodes/OP_OVER, "OVER") (put ScriptOpCodes/OP_PICK, "PICK") (put ScriptOpCodes/OP_ROLL, "ROLL") (put ScriptOpCodes/OP_ROT, "ROT") (put ScriptOpCodes/OP_SWAP, "SWAP") (put ScriptOpCodes/OP_TUCK, "TUCK") (put ScriptOpCodes/OP_CAT, "CAT") (put ScriptOpCodes/OP_SUBSTR, "SUBSTR") (put ScriptOpCodes/OP_LEFT, "LEFT") (put ScriptOpCodes/OP_RIGHT, "RIGHT") (put ScriptOpCodes/OP_SIZE, "SIZE") (put ScriptOpCodes/OP_INVERT, "INVERT") (put ScriptOpCodes/OP_AND, "AND") (put ScriptOpCodes/OP_OR, "OR") (put ScriptOpCodes/OP_XOR, "XOR") (put ScriptOpCodes/OP_EQUAL, "EQUAL") (put ScriptOpCodes/OP_EQUALVERIFY, "EQUALVERIFY") (put ScriptOpCodes/OP_RESERVED1, "RESERVED1") (put ScriptOpCodes/OP_RESERVED2, "RESERVED2") (put ScriptOpCodes/OP_1ADD, "1ADD") (put ScriptOpCodes/OP_1SUB, "1SUB") (put ScriptOpCodes/OP_2MUL, "2MUL") (put ScriptOpCodes/OP_2DIV, "2DIV") (put ScriptOpCodes/OP_NEGATE, "NEGATE") (put ScriptOpCodes/OP_ABS, "ABS") (put ScriptOpCodes/OP_NOT, "NOT") (put ScriptOpCodes/OP_0NOTEQUAL, "0NOTEQUAL") (put ScriptOpCodes/OP_ADD, "ADD") (put ScriptOpCodes/OP_SUB, "SUB") (put ScriptOpCodes/OP_MUL, "MUL") (put ScriptOpCodes/OP_DIV, "DIV") (put ScriptOpCodes/OP_MOD, "MOD") (put ScriptOpCodes/OP_LSHIFT, "LSHIFT") (put ScriptOpCodes/OP_RSHIFT, "RSHIFT") (put ScriptOpCodes/OP_BOOLAND, "BOOLAND") (put ScriptOpCodes/OP_BOOLOR, "BOOLOR") (put ScriptOpCodes/OP_NUMEQUAL, "NUMEQUAL") (put ScriptOpCodes/OP_NUMEQUALVERIFY, "NUMEQUALVERIFY") (put ScriptOpCodes/OP_NUMNOTEQUAL, "NUMNOTEQUAL") (put ScriptOpCodes/OP_LESSTHAN, "LESSTHAN") (put ScriptOpCodes/OP_GREATERTHAN, "GREATERTHAN") (put ScriptOpCodes/OP_LESSTHANOREQUAL, "LESSTHANOREQUAL") (put ScriptOpCodes/OP_GREATERTHANOREQUAL, "GREATERTHANOREQUAL") (put ScriptOpCodes/OP_MIN, "MIN") (put ScriptOpCodes/OP_MAX, "MAX") (put ScriptOpCodes/OP_WITHIN, "WITHIN") (put ScriptOpCodes/OP_RIPEMD160, "RIPEMD160") (put ScriptOpCodes/OP_SHA1, "SHA1") (put ScriptOpCodes/OP_SHA256, "SHA256") (put ScriptOpCodes/OP_HASH160, "HASH160") (put ScriptOpCodes/OP_HASH256, "HASH256") (put ScriptOpCodes/OP_CODESEPARATOR, "CODESEPARATOR") (put ScriptOpCodes/OP_CHECKSIG, "CHECKSIG") (put ScriptOpCodes/OP_CHECKSIGVERIFY, "CHECKSIGVERIFY") (put ScriptOpCodes/OP_CHECKMULTISIG, "CHECKMULTISIG") (put ScriptOpCodes/OP_CHECKMULTISIGVERIFY, "CHECKMULTISIGVERIFY") (put ScriptOpCodes/OP_NOP1, "NOP1") (put ScriptOpCodes/OP_CHECKLOCKTIMEVERIFY, "CHECKLOCKTIMEVERIFY") (put ScriptOpCodes/OP_CHECKSEQUENCEVERIFY, "CHECKSEQUENCEVERIFY") (put ScriptOpCodes/OP_NOP4, "NOP4") (put ScriptOpCodes/OP_NOP5, "NOP5") (put ScriptOpCodes/OP_NOP6, "NOP6") (put ScriptOpCodes/OP_NOP7, "NOP7") (put ScriptOpCodes/OP_NOP8, "NOP8") (put ScriptOpCodes/OP_NOP9, "NOP9") (put ScriptOpCodes/OP_NOP10, "NOP10") (build)))

    #_private
    #_static
    (ยง def- #_"Map<String, Integer>" ScriptOpCodes/OP_CODE_NAME_MAP (.. (ImmutableMap/builder #_"ImmutableMap<String, Integer>") (put "0", ScriptOpCodes/OP_0) (put "PUSHDATA1", ScriptOpCodes/OP_PUSHDATA1) (put "PUSHDATA2", ScriptOpCodes/OP_PUSHDATA2) (put "PUSHDATA4", ScriptOpCodes/OP_PUSHDATA4) (put "1NEGATE", ScriptOpCodes/OP_1NEGATE) (put "RESERVED", ScriptOpCodes/OP_RESERVED) (put "1", ScriptOpCodes/OP_1) (put "2", ScriptOpCodes/OP_2) (put "3", ScriptOpCodes/OP_3) (put "4", ScriptOpCodes/OP_4) (put "5", ScriptOpCodes/OP_5) (put "6", ScriptOpCodes/OP_6) (put "7", ScriptOpCodes/OP_7) (put "8", ScriptOpCodes/OP_8) (put "9", ScriptOpCodes/OP_9) (put "10", ScriptOpCodes/OP_10) (put "11", ScriptOpCodes/OP_11) (put "12", ScriptOpCodes/OP_12) (put "13", ScriptOpCodes/OP_13) (put "14", ScriptOpCodes/OP_14) (put "15", ScriptOpCodes/OP_15) (put "16", ScriptOpCodes/OP_16) (put "NOP", ScriptOpCodes/OP_NOP) (put "VER", ScriptOpCodes/OP_VER) (put "IF", ScriptOpCodes/OP_IF) (put "NOTIF", ScriptOpCodes/OP_NOTIF) (put "VERIF", ScriptOpCodes/OP_VERIF) (put "VERNOTIF", ScriptOpCodes/OP_VERNOTIF) (put "ELSE", ScriptOpCodes/OP_ELSE) (put "ENDIF", ScriptOpCodes/OP_ENDIF) (put "VERIFY", ScriptOpCodes/OP_VERIFY) (put "RETURN", ScriptOpCodes/OP_RETURN) (put "TOALTSTACK", ScriptOpCodes/OP_TOALTSTACK) (put "FROMALTSTACK", ScriptOpCodes/OP_FROMALTSTACK) (put "2DROP", ScriptOpCodes/OP_2DROP) (put "2DUP", ScriptOpCodes/OP_2DUP) (put "3DUP", ScriptOpCodes/OP_3DUP) (put "2OVER", ScriptOpCodes/OP_2OVER) (put "2ROT", ScriptOpCodes/OP_2ROT) (put "2SWAP", ScriptOpCodes/OP_2SWAP) (put "IFDUP", ScriptOpCodes/OP_IFDUP) (put "DEPTH", ScriptOpCodes/OP_DEPTH) (put "DROP", ScriptOpCodes/OP_DROP) (put "DUP", ScriptOpCodes/OP_DUP) (put "NIP", ScriptOpCodes/OP_NIP) (put "OVER", ScriptOpCodes/OP_OVER) (put "PICK", ScriptOpCodes/OP_PICK) (put "ROLL", ScriptOpCodes/OP_ROLL) (put "ROT", ScriptOpCodes/OP_ROT) (put "SWAP", ScriptOpCodes/OP_SWAP) (put "TUCK", ScriptOpCodes/OP_TUCK) (put "CAT", ScriptOpCodes/OP_CAT) (put "SUBSTR", ScriptOpCodes/OP_SUBSTR) (put "LEFT", ScriptOpCodes/OP_LEFT) (put "RIGHT", ScriptOpCodes/OP_RIGHT) (put "SIZE", ScriptOpCodes/OP_SIZE) (put "INVERT", ScriptOpCodes/OP_INVERT) (put "AND", ScriptOpCodes/OP_AND) (put "OR", ScriptOpCodes/OP_OR) (put "XOR", ScriptOpCodes/OP_XOR) (put "EQUAL", ScriptOpCodes/OP_EQUAL) (put "EQUALVERIFY", ScriptOpCodes/OP_EQUALVERIFY) (put "RESERVED1", ScriptOpCodes/OP_RESERVED1) (put "RESERVED2", ScriptOpCodes/OP_RESERVED2) (put "1ADD", ScriptOpCodes/OP_1ADD) (put "1SUB", ScriptOpCodes/OP_1SUB) (put "2MUL", ScriptOpCodes/OP_2MUL) (put "2DIV", ScriptOpCodes/OP_2DIV) (put "NEGATE", ScriptOpCodes/OP_NEGATE) (put "ABS", ScriptOpCodes/OP_ABS) (put "NOT", ScriptOpCodes/OP_NOT) (put "0NOTEQUAL", ScriptOpCodes/OP_0NOTEQUAL) (put "ADD", ScriptOpCodes/OP_ADD) (put "SUB", ScriptOpCodes/OP_SUB) (put "MUL", ScriptOpCodes/OP_MUL) (put "DIV", ScriptOpCodes/OP_DIV) (put "MOD", ScriptOpCodes/OP_MOD) (put "LSHIFT", ScriptOpCodes/OP_LSHIFT) (put "RSHIFT", ScriptOpCodes/OP_RSHIFT) (put "BOOLAND", ScriptOpCodes/OP_BOOLAND) (put "BOOLOR", ScriptOpCodes/OP_BOOLOR) (put "NUMEQUAL", ScriptOpCodes/OP_NUMEQUAL) (put "NUMEQUALVERIFY", ScriptOpCodes/OP_NUMEQUALVERIFY) (put "NUMNOTEQUAL", ScriptOpCodes/OP_NUMNOTEQUAL) (put "LESSTHAN", ScriptOpCodes/OP_LESSTHAN) (put "GREATERTHAN", ScriptOpCodes/OP_GREATERTHAN) (put "LESSTHANOREQUAL", ScriptOpCodes/OP_LESSTHANOREQUAL) (put "GREATERTHANOREQUAL", ScriptOpCodes/OP_GREATERTHANOREQUAL) (put "MIN", ScriptOpCodes/OP_MIN) (put "MAX", ScriptOpCodes/OP_MAX) (put "WITHIN", ScriptOpCodes/OP_WITHIN) (put "RIPEMD160", ScriptOpCodes/OP_RIPEMD160) (put "SHA1", ScriptOpCodes/OP_SHA1) (put "SHA256", ScriptOpCodes/OP_SHA256) (put "HASH160", ScriptOpCodes/OP_HASH160) (put "HASH256", ScriptOpCodes/OP_HASH256) (put "CODESEPARATOR", ScriptOpCodes/OP_CODESEPARATOR) (put "CHECKSIG", ScriptOpCodes/OP_CHECKSIG) (put "CHECKSIGVERIFY", ScriptOpCodes/OP_CHECKSIGVERIFY) (put "CHECKMULTISIG", ScriptOpCodes/OP_CHECKMULTISIG) (put "CHECKMULTISIGVERIFY", ScriptOpCodes/OP_CHECKMULTISIGVERIFY) (put "NOP1", ScriptOpCodes/OP_NOP1) (put "CHECKLOCKTIMEVERIFY", ScriptOpCodes/OP_CHECKLOCKTIMEVERIFY) (put "CHECKSEQUENCEVERIFY", ScriptOpCodes/OP_CHECKSEQUENCEVERIFY) (put "NOP2", ScriptOpCodes/OP_NOP2) (put "NOP3", ScriptOpCodes/OP_NOP3) (put "NOP4", ScriptOpCodes/OP_NOP4) (put "NOP5", ScriptOpCodes/OP_NOP5) (put "NOP6", ScriptOpCodes/OP_NOP6) (put "NOP7", ScriptOpCodes/OP_NOP7) (put "NOP8", ScriptOpCodes/OP_NOP8) (put "NOP9", ScriptOpCodes/OP_NOP9) (put "NOP10", ScriptOpCodes/OP_NOP10) (build)))

    ;;;
     ; Converts the given OpCode into a string (e.g. "0", "PUSHDATA", or "NON_OP(10)")
     ;;
    #_public
    #_static
    (ยง defn #_"String" ScriptOpCodes/getOpCodeName [#_"int" __opcode]
        (when (.. ScriptOpCodes/OP_CODE_MAP (containsKey __opcode))
            (ยง return (.. ScriptOpCodes/OP_CODE_MAP (get __opcode)))
        )

        (str "NON_OP(" __opcode ")")
    )

    ;;;
     ; Converts the given pushdata OpCode into a string (e.g. "PUSHDATA2", or "PUSHDATA(23)")
     ;;
    #_public
    #_static
    (ยง defn #_"String" ScriptOpCodes/getPushDataName [#_"int" __opcode]
        (when (.. ScriptOpCodes/OP_CODE_MAP (containsKey __opcode))
            (ยง return (.. ScriptOpCodes/OP_CODE_MAP (get __opcode)))
        )

        (str "PUSHDATA(" __opcode ")")
    )

    ;;;
     ; Converts the given OpCodeName into an int.
     ;;
    #_public
    #_static
    (ยง defn #_"int" ScriptOpCodes/getOpCode [#_"String" __opCodeName]
        (if (.. ScriptOpCodes/OP_CODE_NAME_MAP (containsKey __opCodeName)) (.. ScriptOpCodes/OP_CODE_NAME_MAP (get __opCodeName)) ScriptOpCodes/OP_INVALIDOPCODE)
    )
)

#_(ns org.bitcoinj.signers #_"CustomTransactionSigner"
    (:import [java.util List])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.crypto ChildNumber TransactionSignature]
             [org.bitcoinj.script Script]
             [org.bitcoinj.wallet KeyBag RedeemData]))

#_(ns org.bitcoinj.signers #_"LocalTransactionSigner"
    (:import [java.util EnumSet])
    (:import [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core ECKey ScriptException Transaction TransactionInput]
             [org.bitcoinj.crypto DeterministicKey TransactionSignature]
             [org.bitcoinj.script Script]
             [org.bitcoinj.wallet KeyBag RedeemData]))

#_(ns org.bitcoinj.signers #_"MissingSigResolutionSigner"
    (:import [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core ECKey TransactionInput]
             [org.bitcoinj.crypto TransactionSignature]
             [org.bitcoinj.script Script ScriptChunk]
             [org.bitcoinj.wallet KeyBag Wallet]))

#_(ns org.bitcoinj.signers #_"StatelessTransactionSigner")

#_(ns org.bitcoinj.signers #_"TransactionSigner"
    (:import [java.util HashMap List Map])
   (:require [org.bitcoinj.core Transaction]
             [org.bitcoinj.crypto ChildNumber]
             [org.bitcoinj.script Script]
             [org.bitcoinj.wallet KeyBag]))

;;;
 ; <p>This signer may be used as a template for creating custom multisig transaction signers.</p>
 ;
 ; Concrete implementations have to implement {@link #getSignature(org.bitcoinj.core.Sha256Hash, java.util.List)}
 ; method returning a signature and a public key of the keypair used to created that signature.
 ; It's up to custom implementation where to locate signatures: it may be a network connection,
 ; some local API or something else.
 ; </p>
 ;;
#_public
#_abstract
(ยง class CustomTransactionSigner (ยง extends StatelessTransactionSigner)
    #_private
    #_static
    (ยง def- #_"Logger" CustomTransactionSigner/log (LoggerFactory/getLogger CustomTransactionSigner))

    #_override
    #_public
    (ยง method #_"boolean" isReady []
        true
    )

    #_override
    #_public
    (ยง method #_"boolean" signInputs [#_"TransactionSigner.ProposedTransaction" __propTx, #_"KeyBag" __keyBag]
        (let [#_"Transaction" __tx (:partial-tx __propTx)
              #_"int" __numInputs (.. __tx (getInputs) (size))]
            (loop-when-recur [#_"int" __i 0] (< __i __numInputs) [(inc __i)]
                (let [#_"TransactionInput" __txIn (.. __tx (getInput __i))
                      #_"TransactionOutput" __txOut (.. __txIn (getConnectedOutput))]
                    (when (nil? __txOut)
                        (ยง continue )
                    )

                    (let [#_"Script" __scriptPubKey (.. __txOut (getScriptPubKey))]
                        (when (not (.. __scriptPubKey (isPayToScriptHash)))
                            (.. CustomTransactionSigner/log (warn "CustomTransactionSigner works only with P2SH transactions"))
                            (ยง return false)
                        )

                        (let [#_"Script" __inputScript (Preconditions/checkNotNull (.. __txIn (getScriptSig)))]

                            (try
                                ;; We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                                ;; we sign missing pieces (to check this would require either assuming any signatures are signing
                                ;; standard output types or a way to get processed signatures out of script execution).
                                (.. __txIn (getScriptSig) (correctlySpends __tx, __i, (.. __txIn (getConnectedOutput) (getScriptPubKey))))
                                (.. CustomTransactionSigner/log (warn "Input {} already correctly spends output, assuming SIGHASH type used will be safe and skipping signing.", __i))
                                (ยง continue )
                                (catch ScriptException _
                                    ;; Expected.
                                )
                            )

                            (let [#_"RedeemData" __redeemData (.. __txIn (getConnectedRedeemData __keyBag))]
                                (when (nil? __redeemData)
                                    (.. CustomTransactionSigner/log (warn "No redeem data found for input {}", __i))
                                    (ยง continue )
                                )

                                (let [#_"Sha256Hash" __sighash (.. __tx (hashForSignature __i, (:redeem-script __redeemData), Transaction.SigHash/ALL, false))
                                      #_"CustomTransactionSigner.SignatureAndKey" __sigKey (.. this (getSignature __sighash, (.. (:key-paths __propTx) (get __scriptPubKey))))
                                      #_"TransactionSignature" __txSig (TransactionSignature. (:sig __sigKey), Transaction.SigHash/ALL, false)
                                      #_"int" __sigIndex (.. __inputScript (getSigInsertionIndex __sighash, (:pub-key __sigKey)))]
                                    (ยง ass __inputScript (.. __scriptPubKey (getScriptSigWithSignature __inputScript, (.. __txSig (encodeToBitcoin)), __sigIndex)))
                                    (.. __txIn (setScriptSig __inputScript))
                                )
                            )
                        )
                    )
                )
            )
            true
        )
    )

    #_protected
    #_abstract
    (ยง method #_"CustomTransactionSigner.SignatureAndKey" getSignature [#_"Sha256Hash" __sighash, #_"List<ChildNumber>" __derivationPath])

    #_public
    (ยง class CustomTransactionSigner.SignatureAndKey
        #_public
        (ยง field #_"ECKey.ECDSASignature" :sig)
        #_public
        (ยง field #_"ECKey" :pub-key)

        #_public
        (ยง constructor CustomTransactionSigner.SignatureAndKey [#_"ECKey.ECDSASignature" __sig, #_"ECKey" __pubKey]
            (ยง assoc this :sig __sig)
            (ยง assoc this :pub-key __pubKey)
            this
        )
    )
)

;;;
 ; <p>{@link TransactionSigner} implementation for signing inputs using keys from provided {@link org.bitcoinj.wallet.KeyBag}.</p>
 ; <p>This signer doesn't create input scripts for tx inputs.  Instead it expects inputs to contain scripts with
 ; empty sigs and replaces one of the empty sigs with calculated signature.
 ; </p>
 ; <p>This signer is always implicitly added into every wallet and it is the first signer to be executed during tx
 ; completion.  As the first signer to create a signature, it stores derivation path of the signing key in a given
 ; {@link ProposedTransaction} object that will be also passed then to the next signer in chain.  This allows other
 ; signers to use correct signing key for P2SH inputs, because all the keys involved in a single P2SH address have
 ; the same derivation path.</p>
 ; <p>This signer always uses {@link org.bitcoinj.core.Transaction.SigHash#ALL} signing mode.</p>
 ;;
#_public
(ยง class LocalTransactionSigner (ยง extends StatelessTransactionSigner)
    #_private
    #_static
    (ยง def- #_"Logger" LocalTransactionSigner/log (LoggerFactory/getLogger LocalTransactionSigner))

    ;;;
     ; Verify flags that are safe to use when testing if an input is already signed.
     ;;
    #_private
    #_static
    (ยง def- #_"EnumSet<Script.VerifyFlag>" LocalTransactionSigner/MINIMUM_VERIFY_FLAGS (EnumSet/of Script.VerifyFlag/P2SH, Script.VerifyFlag/NULLDUMMY))

    #_override
    #_public
    (ยง method #_"boolean" isReady []
        true
    )

    #_override
    #_public
    (ยง method #_"boolean" signInputs [#_"TransactionSigner.ProposedTransaction" __propTx, #_"KeyBag" __keyBag]
        (let [#_"Transaction" __tx (:partial-tx __propTx)
              #_"int" __numInputs (.. __tx (getInputs) (size))]
            (loop-when-recur [#_"int" __i 0] (< __i __numInputs) [(inc __i)]
                (let [#_"TransactionInput" __txIn (.. __tx (getInput __i))]
                    (when (nil? (.. __txIn (getConnectedOutput)))
                        (.. LocalTransactionSigner/log (warn "Missing connected output, assuming input {} is already signed.", __i))
                        (ยง continue )
                    )

                    (try
                        ;; We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                        ;; we sign missing pieces (to check this would require either assuming any signatures are signing
                        ;; standard output types or a way to get processed signatures out of script execution).
                        (.. __txIn (getScriptSig) (correctlySpends __tx, __i, (.. __txIn (getConnectedOutput) (getScriptPubKey)), LocalTransactionSigner/MINIMUM_VERIFY_FLAGS))
                        (.. LocalTransactionSigner/log (warn "Input {} already correctly spends output, assuming SIGHASH type used will be safe and skipping signing.", __i))
                        (ยง continue )
                        (catch ScriptException _
                            ;; Expected.
                        )
                    )

                    (let [#_"RedeemData" __redeemData (.. __txIn (getConnectedRedeemData __keyBag))]

                        (let [#_"Script" __scriptPubKey (.. __txIn (getConnectedOutput) (getScriptPubKey))]

                            ;; For P2SH inputs we need to share derivation path of the signing key with other signers, so that they
                            ;; use correct key to calculate their signatures.
                            ;; Married keys all have the same derivation path, so we can safely just take first one here.
                            (let [#_"ECKey" __pubKey (.. (:keys __redeemData) (get 0))]
                                (when (instance? DeterministicKey __pubKey)
                                    (.. (:key-paths __propTx) (put __scriptPubKey, (.. (cast DeterministicKey __pubKey) (getPath))))
                                )

                                (let [#_"ECKey" __key]
                                    ;; Locate private key in redeem data.  For pay-to-address and pay-to-key inputs RedeemData will always contain
                                    ;; only one key (with private bytes).  For P2SH inputs RedeemData will contain multiple keys, one of which MAY
                                    ;; have private bytes.
                                    (when (nil? (ยง ass __key (.. __redeemData (getFullKey))))
                                        (.. LocalTransactionSigner/log (warn "No local key found for input {}", __i))
                                        (ยง continue )
                                    )

                                    (let [#_"Script" __inputScript (.. __txIn (getScriptSig))]
                                        ;; script here would be either a standard CHECKSIG program for pay-to-address or pay-to-pubkey inputs or
                                        ;; a CHECKMULTISIG program for P2SH inputs.
                                        (let [#_"byte[]" __script (.. (:redeem-script __redeemData) (getProgram))]
                                            (try
                                                (let [#_"TransactionSignature" __signature (.. __tx (calculateSignature __i, __key, __script, Transaction.SigHash/ALL, false))]

                                                    ;; At this point we have incomplete inputScript with OP_0 in place of one or more signatures.  We already
                                                    ;; have calculated the signature using the local key and now need to insert it in the correct place
                                                    ;; within inputScript.  For pay-to-address and pay-to-key script there is only one signature and it always
                                                    ;; goes first in an inputScript (sigIndex = 0).  In P2SH input scripts we need to figure out our relative
                                                    ;; position relative to other signers.  Since we don't have that information at this point, and since
                                                    ;; we always run first, we have to depend on the other signers rearranging the signatures as needed.
                                                    ;; Therefore, always place as first signature.
                                                    (let [#_"int" __sigIndex 0]
                                                        (ยง ass __inputScript (.. __scriptPubKey (getScriptSigWithSignature __inputScript, (.. __signature (encodeToBitcoin)), __sigIndex)))
                                                        (.. __txIn (setScriptSig __inputScript))
                                                    )
                                                )
                                                (catch ECKey.KeyIsEncryptedException __e
                                                    (throw __e)
                                                )
                                                (catch ECKey.MissingPrivateKeyException _
                                                    (.. LocalTransactionSigner/log (warn "No private key in keypair for input {}", __i))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            true
        )
    )
)

;;;
 ; This transaction signer resolves missing signatures in accordance with the given {@link org.bitcoinj.wallet.Wallet.MissingSigsMode}.
 ; If missingSigsMode is USE_OP_ZERO this signer does nothing assuming missing signatures are already presented in scriptSigs as OP_0.
 ; In MissingSigsMode.THROW mode this signer will throw an exception.  It would be MissingSignatureException
 ; for P2SH or MissingPrivateKeyException for other transaction types.
 ;;
#_public
(ยง class MissingSigResolutionSigner (ยง extends StatelessTransactionSigner)
    #_private
    #_static
    (ยง def- #_"Logger" MissingSigResolutionSigner/log (LoggerFactory/getLogger MissingSigResolutionSigner))

    #_public
    (ยง field #_"Wallet.MissingSigsMode" :missing-sigs-mode Wallet.MissingSigsMode/USE_DUMMY_SIG)

    #_public
    (ยง constructor MissingSigResolutionSigner []
        this
    )

    #_public
    (ยง constructor MissingSigResolutionSigner [#_"Wallet.MissingSigsMode" __missingSigsMode]
        (ยง assoc this :missing-sigs-mode __missingSigsMode)
        this
    )

    #_override
    #_public
    (ยง method #_"boolean" isReady []
        true
    )

    #_override
    #_public
    (ยง method #_"boolean" signInputs [#_"TransactionSigner.ProposedTransaction" __propTx, #_"KeyBag" __keyBag]
        (when (== (:missing-sigs-mode this) Wallet.MissingSigsMode/USE_OP_ZERO)
            (ยง return true)
        )

        (let [#_"int" __numInputs (.. (:partial-tx __propTx) (getInputs) (size))
              #_"byte[]" __dummySig (.. (TransactionSignature/dummy) (encodeToBitcoin))]
            (loop-when-recur [#_"int" __i 0] (< __i __numInputs) [(inc __i)]
                (let [#_"TransactionInput" __txIn (.. (:partial-tx __propTx) (getInput __i))]
                    (when (nil? (.. __txIn (getConnectedOutput)))
                        (.. MissingSigResolutionSigner/log (warn "Missing connected output, assuming input {} is already signed.", __i))
                        (ยง continue )
                    )

                    (let [#_"Script" __scriptPubKey (.. __txIn (getConnectedOutput) (getScriptPubKey))
                          #_"Script" __inputScript (.. __txIn (getScriptSig))]
                        (cond (or (.. __scriptPubKey (isPayToScriptHash)) (.. __scriptPubKey (isSentToMultiSig)))
                            (do
                                (let [#_"int" __sigSuffixCount (if (.. __scriptPubKey (isPayToScriptHash)) 1 0)]
                                    ;; All chunks except the first one (OP_0) and the last (redeem script) are signatures.
                                    (loop-when-recur [#_"int" __j 1] (< __j (- (.. __inputScript (getChunks) (size)) __sigSuffixCount)) [(inc __j)]
                                        (let [#_"ScriptChunk" __scriptChunk (.. __inputScript (getChunks) (get __j))]
                                            (when (.. __scriptChunk (equalsOpCode 0))
                                                (when (== (:missing-sigs-mode this) Wallet.MissingSigsMode/THROW)
                                                    (throw (TransactionSigner.MissingSignatureException.))
                                                )

                                                (when (== (:missing-sigs-mode this) Wallet.MissingSigsMode/USE_DUMMY_SIG)
                                                    (.. __txIn (setScriptSig (.. __scriptPubKey (getScriptSigWithSignature __inputScript, __dummySig, (dec __j)))))
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                            :else
                            (do
                                (when (.. __inputScript (getChunks) (get 0) (equalsOpCode 0))
                                    (when (== (:missing-sigs-mode this) Wallet.MissingSigsMode/THROW)
                                        (throw (ECKey.MissingPrivateKeyException.))
                                    )

                                    (when (== (:missing-sigs-mode this) Wallet.MissingSigsMode/USE_DUMMY_SIG)
                                        (.. __txIn (setScriptSig (.. __scriptPubKey (getScriptSigWithSignature __inputScript, __dummySig, 0))))
                                    )
                                )
                            )
                        )
                        ;; TODO: Handle non-P2SH multisig.
                    )
                )
            )
            true
        )
    )
)

;;;
 ; A signer that doesn't have any state to be serialized.
 ;;
#_public
#_abstract
(ยง class StatelessTransactionSigner (ยง implements TransactionSigner)
    #_override
    #_public
    (ยง method #_"void" deserialize [#_"byte[]" __data]
        nil
    )

    #_override
    #_public
    (ยง method #_"byte[]" serialize []
        (byte-array 0)
    )
)

;;;
 ; <p>Implementations of this interface are intended to sign inputs of the given transaction.
 ; Given transaction may already be partially signed or somehow altered by other signers.</p>
 ; <p>To make use of the signer, you need to add it into the wallet by calling
 ; {@link org.bitcoinj.wallet.Wallet#addTransactionSigner(TransactionSigner)}.
 ; Signer will be serialized along with the wallet data.  In order for a wallet to recreate
 ; signer after deserialization, each signer should have no-args constructor.</p>
 ;;
#_public
(ยง interface TransactionSigner
    ;;;
     ; This class wraps transaction proposed to complete keeping a metadata that may be updated, used and effectively
     ; shared by transaction signers.
     ;;
    (ยง class TransactionSigner.ProposedTransaction
        #_public
        (ยง field #_"Transaction" :partial-tx)

        ;;;
         ; HD key paths used for each input to derive a signing key.  It's useful for multisig inputs only.
         ; The keys used to create a single P2SH address have the same derivation path, so to use a correct key each signer
         ; has to know a derivation path of signing keys used by previous signers.  For each input signers will use the
         ; same derivation path and we need to store only one key path per input.  As TransactionInput is mutable, inputs
         ; are identified by their scriptPubKeys (keys in this map).
         ;;
        #_public
        (ยง field #_"Map<Script, List<ChildNumber>>" :key-paths)

        #_public
        (ยง constructor TransactionSigner.ProposedTransaction [#_"Transaction" __partialTx]
            (ยง assoc this :partial-tx __partialTx)
            (ยง assoc this :key-paths (HashMap. #_"<>"))
            this
        )
    )

    (ยง class TransactionSigner.MissingSignatureException (ยง extends RuntimeException)
    )

    ;;;
     ; Returns true if this signer is ready to be used.
     ;;
    (ยง method #_"boolean" isReady [])

    ;;;
     ; Returns byte array of data representing state of this signer.
     ; It's used to serialize/deserialize this signer.
     ;;
    (ยง method #_"byte[]" serialize [])

    ;;;
     ; Uses given byte array of data to reconstruct internal state of this signer.
     ;;
    (ยง method #_"void" deserialize [#_"byte[]" __data])

    ;;;
     ; Signs given transaction's inputs.
     ; Returns true if signer is compatible with given transaction (can do something meaningful with it).
     ; Otherwise this method returns false.
     ;;
    (ยง method #_"boolean" signInputs [#_"TransactionSigner.ProposedTransaction" __propTx, #_"KeyBag" __keyBag])
)

#_(ns org.bitcoinj.store #_"BlockStore"
   (:require [org.bitcoinj.core NetworkParameters Sha256Hash StoredBlock]))

#_(ns org.bitcoinj.store #_"BlockStoreException")

#_(ns org.bitcoinj.store #_"ChainFileLockedException")

#_(ns org.bitcoinj.store #_"DatabaseFullPrunedBlockStore"
    (:import [java.io ByteArrayInputStream ByteArrayOutputStream IOException]
             [java.math BigInteger]
             [java.sql *]
             [java.util *])
    (:import [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.script Script]))

#_(ns org.bitcoinj.store #_"FullPrunedBlockStore"
   (:require [org.bitcoinj.core *]))

#_(ns org.bitcoinj.store #_"H2FullPrunedBlockStore"
    (:import [java.sql *]
             [java.util ArrayList Collections List])
   (:require [org.bitcoinj.core *]))

#_(ns org.bitcoinj.store #_"MemoryBlockStore"
    (:import [java.util LinkedHashMap Map])
   (:require [org.bitcoinj.core *]))

#_(ns org.bitcoinj.store #_"MemoryFullPrunedBlockStore"
    (:import [java.util *])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.collect Lists])
   (:require [org.bitcoinj.core *]))

#_(ns org.bitcoinj.store #_"PostgresFullPrunedBlockStore"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.sql PreparedStatement ResultSet SQLException Types]
             [java.util ArrayList List])
    (:import [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]))

#_(ns org.bitcoinj.store #_"SPVBlockStore"
    (:import [java.io *]
             [java.nio *]
             [java.nio.channels *]
             [java.util *]
             [java.util.concurrent.locks *])
    (:import [com.google.common.base Charsets Preconditions]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.utils *]))

;;;
 ; An implementor of BlockStore saves StoredBlock objects to disk.  Different implementations store them in
 ; different ways.  An in-memory implementation (MemoryBlockStore) exists for unit testing but real apps will
 ; want to use implementations that save to disk.
 ;
 ; A BlockStore is a map of hashes to StoredBlock.  The hash is the double digest of the Bitcoin serialization
 ; of the block header, <b>not</b> the header with the extra data as well.
 ;
 ; BlockStores are thread safe.
 ;;
#_public
(ยง interface BlockStore
    ;;;
     ; Saves the given block header+extra data.  The key isn't specified explicitly as it can be calculated
     ; from the StoredBlock directly.  Can throw if there is a problem with the underlying storage layer such
     ; as running out of disk space.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" put [#_"StoredBlock" __block])

    ;;;
     ; Returns the StoredBlock given a hash.  The returned values block.getHash() method will be equal to the
     ; parameter. If no such block is found, returns null.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" get [#_"Sha256Hash" __hash])

    ;;;
     ; Returns the {@link StoredBlock} that represents the top of the chain of greatest total work.  Note that
     ; this can be arbitrarily expensive, you probably should use {@link org.bitcoinj.core.BlockChain#getChainHead()}
     ; or perhaps {@link org.bitcoinj.core.BlockChain#getBestChainHeight()} which will run in constant time and
     ; not take any heavyweight locks.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" getChainHead [])

    ;;;
     ; Sets the {@link StoredBlock} that represents the top of the chain of greatest total work.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" setChainHead [#_"StoredBlock" __chainHead])

    ;;; Closes the store. ;;
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" close [])

    ;;;
     ; Get the {@link org.bitcoinj.core.NetworkParameters} of this store.
     ; @return the network params.
     ;;
    (ยง method #_"NetworkParameters" getParams [])
)

;;;
 ; Thrown when something goes wrong with storing a block.  Examples: out of disk space.
 ;;
#_public
(ยง class BlockStoreException (ยง extends Exception)
    #_public
    (ยง constructor BlockStoreException [#_"String" __message]
        (ยง super __message)
        this
    )

    #_public
    (ยง constructor BlockStoreException [#_"Throwable" __t]
        (ยง super __t)
        this
    )

    #_public
    (ยง constructor BlockStoreException [#_"String" __message, #_"Throwable" __t]
        (ยง super __message, __t)
        this
    )
)

;;;
 ; Thrown by {@link SPVBlockStore} when the process cannot gain exclusive access to the chain file.
 ;;
#_public
(ยง class ChainFileLockedException (ยง extends BlockStoreException)
    #_public
    (ยง constructor ChainFileLockedException [#_"String" __message]
        (ยง super __message)
        this
    )

    #_public
    (ยง constructor ChainFileLockedException [#_"Throwable" __t]
        (ยง super __t)
        this
    )
)

;;;
 ; <p>A generic full pruned block store for a relational database.  This generic class
 ; requires certain table structures for the block store.</p>
 ;
 ; <p>The following are the tables and field names/types that are assumed:</p>
 ;
 ; <p>
 ; <b>setting</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>name</td><td>string</td></tr>
 ;     <tr><td>value</td><td>binary</td></tr>
 ; </table>
 ; </p>
 ;
 ; <p>
 ; <b>headers</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>hash</td><td>binary</td></tr>
 ;     <tr><td>chainwork</td><td>binary</td></tr>
 ;     <tr><td>height</td><td>integer</td></tr>
 ;     <tr><td>header</td><td>binary</td></tr>
 ;     <tr><td>wasundoable</td><td>boolean</td></tr>
 ; </table>
 ; </p>
 ;
 ; <p>
 ; <b>undoableblocks</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>hash</td><td>binary</td></tr>
 ;     <tr><td>height</td><td>integer</td></tr>
 ;     <tr><td>txoutchanges</td><td>binary</td></tr>
 ;     <tr><td>transactions</td><td>binary</td></tr>
 ; </table>
 ; </p>
 ;
 ; <p>
 ; <b>openoutputs</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>hash</td><td>binary</td></tr>
 ;     <tr><td>index</td><td>integer</td></tr>
 ;     <tr><td>height</td><td>integer</td></tr>
 ;     <tr><td>value</td><td>integer</td></tr>
 ;     <tr><td>scriptbytes</td><td>binary</td></tr>
 ;     <tr><td>toaddress</td><td>string</td></tr>
 ;     <tr><td>addresstargetable</td><td>integer</td></tr>
 ;     <tr><td>coinbase</td><td>boolean</td></tr>
 ; </table>
 ; </p>
 ;
 ;;
#_public
#_abstract
(ยง class DatabaseFullPrunedBlockStore (ยง implements FullPrunedBlockStore)
    #_private
    #_static
    (ยง def- #_"Logger" DatabaseFullPrunedBlockStore/log (LoggerFactory/getLogger DatabaseFullPrunedBlockStore))

    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/CHAIN_HEAD_SETTING "chainhead")
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/VERIFIED_CHAIN_HEAD_SETTING "verifiedchainhead")
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/VERSION_SETTING "version")

    ;; Drop table SQL.
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/DROP_SETTINGS_TABLE "DROP TABLE settings")
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/DROP_HEADERS_TABLE "DROP TABLE headers")
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/DROP_UNDOABLE_TABLE "DROP TABLE undoableblocks")
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/DROP_OPEN_OUTPUT_TABLE "DROP TABLE openoutputs")

    ;; Queries SQL.
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/SELECT_SETTINGS_SQL "SELECT value FROM settings WHERE name = ?")
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/INSERT_SETTINGS_SQL "INSERT INTO settings(name, value) VALUES(?, ?)")
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/UPDATE_SETTINGS_SQL "UPDATE settings SET value = ? WHERE name = ?")

    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/SELECT_HEADERS_SQL "SELECT chainwork, height, header, wasundoable FROM headers WHERE hash = ?")
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/INSERT_HEADERS_SQL "INSERT INTO headers(hash, chainwork, height, header, wasundoable) VALUES(?, ?, ?, ?, ?)")
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/UPDATE_HEADERS_SQL "UPDATE headers SET wasundoable=? WHERE hash=?")

    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/SELECT_UNDOABLEBLOCKS_SQL "SELECT txoutchanges, transactions FROM undoableblocks WHERE hash = ?")
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/INSERT_UNDOABLEBLOCKS_SQL "INSERT INTO undoableblocks(hash, height, txoutchanges, transactions) VALUES(?, ?, ?, ?)")
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/UPDATE_UNDOABLEBLOCKS_SQL "UPDATE undoableblocks SET txoutchanges=?, transactions=? WHERE hash = ?")
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/DELETE_UNDOABLEBLOCKS_SQL "DELETE FROM undoableblocks WHERE height <= ?")

    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/SELECT_OPENOUTPUTS_SQL "SELECT height, value, scriptbytes, coinbase, toaddress, addresstargetable FROM openoutputs WHERE hash = ? AND index = ?")
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/SELECT_OPENOUTPUTS_COUNT_SQL "SELECT COUNT(*) FROM openoutputs WHERE hash = ?")
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/INSERT_OPENOUTPUTS_SQL "INSERT INTO openoutputs (hash, index, height, value, scriptbytes, toaddress, addresstargetable, coinbase) VALUES (?, ?, ?, ?, ?, ?, ?, ?)")
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/DELETE_OPENOUTPUTS_SQL "DELETE FROM openoutputs WHERE hash = ? AND index = ?")

    ;; Dump table SQL (this is just for data sizing statistics).
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/SELECT_DUMP_SETTINGS_SQL "SELECT name, value FROM settings")
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/SELECT_DUMP_HEADERS_SQL "SELECT chainwork, header FROM headers")
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/SELECT_DUMP_UNDOABLEBLOCKS_SQL "SELECT txoutchanges, transactions FROM undoableblocks")
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/SELECT_DUMP_OPENOUTPUTS_SQL "SELECT value, scriptbytes FROM openoutputs")

    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/SELECT_TRANSACTION_OUTPUTS_SQL "SELECT hash, value, scriptbytes, height, index, coinbase, toaddress, addresstargetable FROM openoutputs where toaddress = ?")

    ;; Select the balance of an address SQL.
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/SELECT_BALANCE_SQL "select sum(value) from openoutputs where toaddress = ?")

    ;; Tables exist SQL.
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/SELECT_CHECK_TABLES_EXIST_SQL "SELECT * FROM settings WHERE 1 = 2")

    ;; Compatibility SQL.
    #_private
    #_static
    (ยง def- #_"String" DatabaseFullPrunedBlockStore/SELECT_COMPATIBILITY_COINBASE_SQL "SELECT coinbase FROM openoutputs WHERE 1 = 2")

    #_protected
    (ยง field #_"Sha256Hash" :chain-head-hash)
    #_protected
    (ยง field #_"StoredBlock" :chain-head-block)
    #_protected
    (ยง field #_"Sha256Hash" :verified-chain-head-hash)
    #_protected
    (ยง field #_"StoredBlock" :verified-chain-head-block)
    #_protected
    (ยง field #_"NetworkParameters" :params)
    #_protected
    (ยง field #_"ThreadLocal<Connection>" :conn)
    #_protected
    (ยง field #_"List<Connection>" :all-connections)
    #_protected
    (ยง field #_"String" :connection-url)
    #_protected
    (ยง field #_"int" :full-store-depth)
    #_protected
    (ยง field #_"String" :username)
    #_protected
    (ยง field #_"String" :password)
    #_protected
    (ยง field #_"String" :schema-name)

    ;;;
     ; <p>Create a new DatabaseFullPrunedBlockStore, using the full connection URL instead of a hostname and password,
     ; and optionally allowing a schema to be specified.</p>
     ;
     ; @param params A copy of the NetworkParameters used.
     ; @param connectionURL The jdbc url to connect to the database.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param username The database username.
     ; @param password The password to the database.
     ; @param schemaName The name of the schema to put the tables in.  May be null if no schema is being used.
     ; @throws BlockStoreException if there is a failure to connect and/or initialise the database.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor DatabaseFullPrunedBlockStore [#_"NetworkParameters" __params, #_"String" __connectionURL, #_"int" __fullStoreDepth, #_nilable #_"String" __username, #_nilable #_"String" __password, #_nilable #_"String" __schemaName]
        (ยง assoc this :params __params)
        (ยง assoc this :full-store-depth __fullStoreDepth)
        (ยง assoc this :connection-url __connectionURL)
        (ยง assoc this :schema-name __schemaName)
        (ยง assoc this :username __username)
        (ยง assoc this :password __password)
        (ยง assoc this :conn (ThreadLocal. #_"<>"))
        (ยง assoc this :all-connections (LinkedList. #_"<>"))

        (try
            (Class/forName (.. this (getDatabaseDriverClass)))
            (.. DatabaseFullPrunedBlockStore/log (info (str (.. this (getDatabaseDriverClass)) " loaded. ")))
            (catch ClassNotFoundException __e
                (.. DatabaseFullPrunedBlockStore/log (error "check CLASSPATH for database driver jar ", __e))
            )
        )

        (.. this (maybeConnect))

        (try
            ;; Create tables if needed.
            (if (not (.. this (tablesExist)))
                (.. this (createTables))
                (.. this (checkCompatibility))
            )
            (.. this (initFromDatabase))
            (catch SQLException __e
                (throw (BlockStoreException. __e))
            )
        )
        this
    )

    ;;;
     ; Get the database driver class, i.e <i>org.postgresql.Driver</i>.
     ; @return the fully qualified database driver class.
     ;;
    #_protected
    #_abstract
    (ยง method #_"String" getDatabaseDriverClass [])

    ;;;
     ; Get the SQL statements that create the schema (DDL).
     ; @return the list of SQL statements.
     ;;
    #_protected
    #_abstract
    (ยง method #_"List<String>" getCreateSchemeSQL [])

    ;;;
     ; Get the SQL statements that create the tables (DDL).
     ; @return the list of SQL statements.
     ;;
    #_protected
    #_abstract
    (ยง method #_"List<String>" getCreateTablesSQL [])

    ;;;
     ; Get the SQL statements that create the indexes (DDL).
     ; @return the list of SQL statements.
     ;;
    #_protected
    #_abstract
    (ยง method #_"List<String>" getCreateIndexesSQL [])

    ;;;
     ; Get the database specific error code that indicated a duplicate key error when inserting a record.
     ; <p>This is the code returned by {@link java.sql.SQLException#getSQLState()}.</p>
     ; @return the database duplicate error code.
     ;;
    #_protected
    #_abstract
    (ยง method #_"String" getDuplicateKeyErrorCode [])

    ;;;
     ; Get the SQL to select the total balance for a given address.
     ; @return the SQL prepared statement.
     ;;
    #_protected
    (ยง method #_"String" getBalanceSelectSQL []
        DatabaseFullPrunedBlockStore/SELECT_BALANCE_SQL
    )

    ;;;
     ; Get the SQL statement that checks if tables exist.
     ; @return the SQL prepared statement.
     ;;
    #_protected
    (ยง method #_"String" getTablesExistSQL []
        DatabaseFullPrunedBlockStore/SELECT_CHECK_TABLES_EXIST_SQL
    )

    ;;;
     ; Get the SQL statements to check if the database is compatible.
     ; @return the SQL prepared statements.
     ;;
    #_protected
    (ยง method #_"List<String>" getCompatibilitySQL []
        (let [#_"List<String>" __sql (ArrayList. #_"<>")]
            (.. __sql (add DatabaseFullPrunedBlockStore/SELECT_COMPATIBILITY_COINBASE_SQL))
            __sql
        )
    )

    ;;;
     ; Get the SQL to select the transaction outputs for a given address.
     ; @return the SQL prepared statement.
     ;;
    #_protected
    (ยง method #_"String" getTransactionOutputSelectSQL []
        DatabaseFullPrunedBlockStore/SELECT_TRANSACTION_OUTPUTS_SQL
    )

    ;;;
     ; Get the SQL to drop all the tables (DDL).
     ; @return the SQL drop statements.
     ;;
    #_protected
    (ยง method #_"List<String>" getDropTablesSQL []
        (let [#_"List<String>" __sql (ArrayList. #_"<>")]
            (.. __sql (add DatabaseFullPrunedBlockStore/DROP_SETTINGS_TABLE))
            (.. __sql (add DatabaseFullPrunedBlockStore/DROP_HEADERS_TABLE))
            (.. __sql (add DatabaseFullPrunedBlockStore/DROP_UNDOABLE_TABLE))
            (.. __sql (add DatabaseFullPrunedBlockStore/DROP_OPEN_OUTPUT_TABLE))
            __sql
        )
    )

    ;;;
     ; Get the SQL to select a setting value.
     ; @return the SQL select statement.
     ;;
    #_protected
    (ยง method #_"String" getSelectSettingsSQL []
        DatabaseFullPrunedBlockStore/SELECT_SETTINGS_SQL
    )

    ;;;
     ; Get the SQL to insert a settings record.
     ; @return the SQL insert statement.
     ;;
    #_protected
    (ยง method #_"String" getInsertSettingsSQL []
        DatabaseFullPrunedBlockStore/INSERT_SETTINGS_SQL
    )

    ;;;
     ; Get the SQL to update a setting value.
     ; @return the SQL update statement.
     ;;
    #_protected
    (ยง method #_"String" getUpdateSettingsSLQ []
        DatabaseFullPrunedBlockStore/UPDATE_SETTINGS_SQL
    )

    ;;;
     ; Get the SQL to select a headers record.
     ; @return the SQL select statement.
     ;;
    #_protected
    (ยง method #_"String" getSelectHeadersSQL []
        DatabaseFullPrunedBlockStore/SELECT_HEADERS_SQL
    )

    ;;;
     ; Get the SQL to insert a headers record.
     ; @return the SQL insert statement.
     ;;
    #_protected
    (ยง method #_"String" getInsertHeadersSQL []
        DatabaseFullPrunedBlockStore/INSERT_HEADERS_SQL
    )

    ;;;
     ; Get the SQL to update a headers record.
     ; @return the SQL update statement.
     ;;
    #_protected
    (ยง method #_"String" getUpdateHeadersSQL []
        DatabaseFullPrunedBlockStore/UPDATE_HEADERS_SQL
    )

    ;;;
     ; Get the SQL to select an undoableblocks record.
     ; @return the SQL select statement.
     ;;
    #_protected
    (ยง method #_"String" getSelectUndoableBlocksSQL []
        DatabaseFullPrunedBlockStore/SELECT_UNDOABLEBLOCKS_SQL
    )

    ;;;
     ; Get the SQL to insert a undoableblocks record.
     ; @return the SQL insert statement.
     ;;
    #_protected
    (ยง method #_"String" getInsertUndoableBlocksSQL []
        DatabaseFullPrunedBlockStore/INSERT_UNDOABLEBLOCKS_SQL
    )

    ;;;
     ; Get the SQL to update a undoableblocks record.
     ; @return the SQL update statement.
     ;;
    #_protected
    (ยง method #_"String" getUpdateUndoableBlocksSQL []
        DatabaseFullPrunedBlockStore/UPDATE_UNDOABLEBLOCKS_SQL
    )

    ;;;
     ; Get the SQL to delete a undoableblocks record.
     ; @return the SQL delete statement.
     ;;
    #_protected
    (ยง method #_"String" getDeleteUndoableBlocksSQL []
        DatabaseFullPrunedBlockStore/DELETE_UNDOABLEBLOCKS_SQL
    )

    ;;;
     ; Get the SQL to select a openoutputs record.
     ; @return the SQL select statement.
     ;;
    #_protected
    (ยง method #_"String" getSelectOpenoutputsSQL []
        DatabaseFullPrunedBlockStore/SELECT_OPENOUTPUTS_SQL
    )

    ;;;
     ; Get the SQL to select count of openoutputs.
     ; @return the SQL select statement.
     ;;
    #_protected
    (ยง method #_"String" getSelectOpenoutputsCountSQL []
        DatabaseFullPrunedBlockStore/SELECT_OPENOUTPUTS_COUNT_SQL
    )

    ;;;
     ; Get the SQL to insert a openoutputs record.
     ; @return the SQL insert statement.
     ;;
    #_protected
    (ยง method #_"String" getInsertOpenoutputsSQL []
        DatabaseFullPrunedBlockStore/INSERT_OPENOUTPUTS_SQL
    )

    ;;;
     ; Get the SQL to delete a openoutputs record.
     ; @return the SQL delete statement.
     ;;
    #_protected
    (ยง method #_"String" getDeleteOpenoutputsSQL []
        DatabaseFullPrunedBlockStore/DELETE_OPENOUTPUTS_SQL
    )

    ;;;
     ; Get the SQL to select the setting dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
    #_protected
    (ยง method #_"String" getSelectSettingsDumpSQL []
        DatabaseFullPrunedBlockStore/SELECT_DUMP_SETTINGS_SQL
    )

    ;;;
     ; Get the SQL to select the headers dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
    #_protected
    (ยง method #_"String" getSelectHeadersDumpSQL []
        DatabaseFullPrunedBlockStore/SELECT_DUMP_HEADERS_SQL
    )

    ;;;
     ; Get the SQL to select the undoableblocks dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
    #_protected
    (ยง method #_"String" getSelectUndoableblocksDumpSQL []
        DatabaseFullPrunedBlockStore/SELECT_DUMP_UNDOABLEBLOCKS_SQL
    )

    ;;;
     ; Get the SQL to select the openoutouts dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
    #_protected
    (ยง method #_"String" getSelectopenoutputsDumpSQL []
        DatabaseFullPrunedBlockStore/SELECT_DUMP_OPENOUTPUTS_SQL
    )

    ;;;
     ; <p>If there isn't a connection on the {@link ThreadLocal} then create and store it.</p>
     ; <p>This will also automatically set up the schema if it does not exist within the DB.</p>
     ; @throws BlockStoreException if successful connection to the DB couldn't be made.
     ;;
    #_protected
    #_synchronized
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" maybeConnect []
        (try
            (when (and (some? (.. (:conn this) (get))) (not (.. (:conn this) (get) (isClosed))))
                (ยง return nil)
            )

            (cond (or (nil? (:username this)) (nil? (:password this)))
                (do
                    (.. (:conn this) (set (DriverManager/getConnection (:connection-url this))))
                )
                :else
                (do
                    (let [#_"Properties" __props (Properties.)]
                        (.. __props (setProperty "user", (:username this)))
                        (.. __props (setProperty "password", (:password this)))
                        (.. (:conn this) (set (DriverManager/getConnection (:connection-url this), __props)))
                    )
                )
            )
            (.. (:all-connections this) (add (.. (:conn this) (get))))
            (let [#_"Connection" __connection (.. (:conn this) (get))]
                ;; Set the schema if one is needed.
                (when (some? (:schema-name this))
                    (let [#_"Statement" __s (.. __connection (createStatement))]
                        (doseq [#_"String" __sql (.. this (getCreateSchemeSQL))]
                            (.. __s (execute __sql))
                        )
                    )
                )
                (.. DatabaseFullPrunedBlockStore/log (info (str "Made a new connection to database " (:connection-url this))))
            )
            (catch SQLException __e
                (throw (BlockStoreException. __e))
            )
        )
        nil
    )

    #_override
    #_public
    #_synchronized
    (ยง method #_"void" close []
        (doseq [#_"Connection" __conn (:all-connections this)]
            (try
                (when (not (.. __conn (getAutoCommit)))
                    (.. __conn (rollback))
                )
                (.. __conn (close))
                (when (== __conn (.. (:conn this) (get)))
                    (.. (:conn this) (set nil))
                )
                (catch SQLException __e
                    (throw (RuntimeException. __e))
                )
            )
        )
        (.. (:all-connections this) (clear))
        nil
    )

    ;;;
     ; <p>Check if a tables exists within the database.</p>
     ;
     ; <p>This specifically checks for the 'settings' table and
     ; if it exists makes an assumption that the rest of the data
     ; structures are present.</p>
     ;
     ; @return if the tables exist.
     ; @throws java.sql.SQLException
     ;;
    #_private
    #_throws #_[ "SQLException" ]
    (ยง method- #_"boolean" tablesExist []
        (let [#_"PreparedStatement" __ps nil]
            (try
                (ยง ass __ps (.. (:conn this) (get) (prepareStatement (.. this (getTablesExistSQL)))))
                (let [#_"ResultSet" __results (.. __ps (executeQuery))]
                    (.. __results (close))
                    (ยง return true)
                )
                (catch SQLException _
                    (ยง return false)
                )
                (finally
                    (when (and (some? __ps) (not (.. __ps (isClosed))))
                        (.. __ps (close))
                    )
                )
            )
        )
    )

    ;;;
     ; Check that the database is compatible with this version of the {@link DatabaseFullPrunedBlockStore}.
     ; @throws BlockStoreException if the database is not compatible.
     ;;
    #_private
    #_throws #_[ "SQLException", "BlockStoreException" ]
    (ยง method- #_"void" checkCompatibility []
        (doseq [#_"String" __sql (.. this (getCompatibilitySQL))]
            (let [#_"PreparedStatement" __ps nil]
                (try
                    (ยง ass __ps (.. (:conn this) (get) (prepareStatement __sql)))
                    (let [#_"ResultSet" __results (.. __ps (executeQuery))]
                        (.. __results (close))
                    )
                    (catch SQLException __e
                        (throw (BlockStoreException. (str "Database block store is not compatible with the current release.  See bitcoinj release notes for further information: " (.. __e (getMessage)))))
                    )
                    (finally
                        (when (and (some? __ps) (not (.. __ps (isClosed))))
                            (.. __ps (close))
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Create the tables in the database.
     ; @throws java.sql.SQLException if there is a database error.
     ; @throws BlockStoreException if the block store could not be created.
     ;;
    #_private
    #_throws #_[ "SQLException", "BlockStoreException" ]
    (ยง method- #_"void" createTables []
        (let [#_"Statement" __s (.. (:conn this) (get) (createStatement))]
            ;; Create all the database tables.
            (doseq [#_"String" __sql (.. this (getCreateTablesSQL))]
                (when (.. DatabaseFullPrunedBlockStore/log (isDebugEnabled))
                    (.. DatabaseFullPrunedBlockStore/log (debug "DatabaseFullPrunedBlockStore : CREATE table [SQL= {0}]", __sql))
                )
                (.. __s (executeUpdate __sql))
            )
            ;; Create all the database indexes.
            (doseq [#_"String" __sql (.. this (getCreateIndexesSQL))]
                (when (.. DatabaseFullPrunedBlockStore/log (isDebugEnabled))
                    (.. DatabaseFullPrunedBlockStore/log (debug "DatabaseFullPrunedBlockStore : CREATE index [SQL= {0}]", __sql))
                )
                (.. __s (executeUpdate __sql))
            )
            (.. __s (close))

            ;; Insert the initial settings for this store.
            (let [#_"PreparedStatement" __ps (.. (:conn this) (get) (prepareStatement (.. this (getInsertSettingsSQL))))]
                (.. __ps (setString 1, DatabaseFullPrunedBlockStore/CHAIN_HEAD_SETTING))
                (.. __ps (setNull 2, Types/BINARY))
                (.. __ps (execute))
                (.. __ps (setString 1, DatabaseFullPrunedBlockStore/VERIFIED_CHAIN_HEAD_SETTING))
                (.. __ps (setNull 2, Types/BINARY))
                (.. __ps (execute))
                (.. __ps (setString 1, DatabaseFullPrunedBlockStore/VERSION_SETTING))
                (.. __ps (setBytes 2, (.. "03" (getBytes))))
                (.. __ps (execute))
                (.. __ps (close))

                (.. this (createNewStore (:params this)))
                nil
            )
        )
    )

    ;;;
     ; Create a new store for the given {@link org.bitcoinj.core.NetworkParameters}.
     ; @param params The network.
     ; @throws BlockStoreException if the store couldn't be created.
     ;;
    #_private
    #_throws #_[ "BlockStoreException" ]
    (ยง method- #_"void" createNewStore [#_"NetworkParameters" __params]
        (try
            ;; Set up the genesis block.  When we start out fresh, it is by definition the top of the chain.
            (let [#_"StoredBlock" __storedGenesisHeader (StoredBlock. (.. __params (getGenesisBlock) (cloneAsHeader)), (.. __params (getGenesisBlock) (getWork)), 0)]
                ;; The coinbase in the genesis block is not spendable.  This is because of how Bitcoin Core inits
                ;; its database - the genesis transaction isn't actually in the db so its spent flags can never be updated.
                (let [#_"List<Transaction>" __genesisTransactions (Lists/newLinkedList)
                      #_"StoredUndoableBlock" __storedGenesis (StoredUndoableBlock. (.. __params (getGenesisBlock) (getHash)), __genesisTransactions)]
                    (.. this (put __storedGenesisHeader, __storedGenesis))
                    (.. this (setChainHead __storedGenesisHeader))
                    (.. this (setVerifiedChainHead __storedGenesisHeader))
                )
            )
            (catch VerificationException __e
                (throw (RuntimeException. __e)) ;; Cannot happen.
            )
        )
        nil
    )

    ;;;
     ; Initialise the store state from the database.
     ; @throws java.sql.SQLException if there is a database error.
     ; @throws BlockStoreException if there is a block store error.
     ;;
    #_private
    #_throws #_[ "SQLException", "BlockStoreException" ]
    (ยง method- #_"void" initFromDatabase []
        (let [#_"PreparedStatement" __ps (.. (:conn this) (get) (prepareStatement (.. this (getSelectSettingsSQL))))
              #_"ResultSet" __rs]
            (.. __ps (setString 1, DatabaseFullPrunedBlockStore/CHAIN_HEAD_SETTING))
            (ยง ass __rs (.. __ps (executeQuery)))
            (when (not (.. __rs (next)))
                (throw (BlockStoreException. "corrupt database block store - no chain head pointer"))
            )

            (let [#_"Sha256Hash" __hash (Sha256Hash/wrap (.. __rs (getBytes 1)))]
                (.. __rs (close))
                (ยง assoc this :chain-head-block (.. this (get __hash)))
                (ยง assoc this :chain-head-hash __hash)
                (when (nil? (:chain-head-block this))
                    (throw (BlockStoreException. "corrupt database block store - head block not found"))
                )

                (.. __ps (setString 1, DatabaseFullPrunedBlockStore/VERIFIED_CHAIN_HEAD_SETTING))
                (ยง ass __rs (.. __ps (executeQuery)))
                (when (not (.. __rs (next)))
                    (throw (BlockStoreException. "corrupt database block store - no verified chain head pointer"))
                )

                (ยง ass __hash (Sha256Hash/wrap (.. __rs (getBytes 1))))
                (.. __rs (close))
                (.. __ps (close))
                (ยง assoc this :verified-chain-head-block (.. this (get __hash)))
                (ยง assoc this :verified-chain-head-hash __hash)
                (when (nil? (:verified-chain-head-block this))
                    (throw (BlockStoreException. "corrupt database block store - verified head block not found"))
                )
                nil
            )
        )
    )

    #_protected
    #_throws #_[ "SQLException" ]
    (ยง method #_"void" putUpdateStoredBlock [#_"StoredBlock" __storedBlock, #_"boolean" __wasUndoable]
        (try
            (let [#_"PreparedStatement" __ps (.. (:conn this) (get) (prepareStatement (.. this (getInsertHeadersSQL))))]
                ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
                (let [#_"byte[]" __hashBytes (byte-array 28)]
                    (System/arraycopy (.. __storedBlock (getHeader) (getHash) (getBytes)), 4, __hashBytes, 0, 28)
                    (.. __ps (setBytes 1, __hashBytes))
                    (.. __ps (setBytes 2, (.. __storedBlock (getChainWork) (toByteArray))))
                    (.. __ps (setInt 3, (.. __storedBlock (getHeight))))
                    (.. __ps (setBytes 4, (.. __storedBlock (getHeader) (cloneAsHeader) (unsafeBitcoinSerialize))))
                    (.. __ps (setBoolean 5, __wasUndoable))
                    (.. __ps (executeUpdate))
                    (.. __ps (close))
                )
            )
            (catch SQLException __e
                ;; It is possible we try to add a duplicate StoredBlock if we upgraded.
                ;; In that case, we just update the entry to mark it wasUndoable.
                (when (or (not (.. __e (getSQLState) (equals (.. this (getDuplicateKeyErrorCode))))) (not __wasUndoable))
                    (throw __e)
                )

                (let [#_"PreparedStatement" __ps (.. (:conn this) (get) (prepareStatement (.. this (getUpdateHeadersSQL))))]
                    (.. __ps (setBoolean 1, true))
                    ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
                    (let [#_"byte[]" __hashBytes (byte-array 28)]
                        (System/arraycopy (.. __storedBlock (getHeader) (getHash) (getBytes)), 4, __hashBytes, 0, 28)
                        (.. __ps (setBytes 2, __hashBytes))
                        (.. __ps (executeUpdate))
                        (.. __ps (close))
                    )
                )
            )
        )
        nil
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" put [#_"StoredBlock" __storedBlock]
        (.. this (maybeConnect))
        (try
            (.. this (putUpdateStoredBlock __storedBlock, false))
            (catch SQLException __e
                (throw (BlockStoreException. __e))
            )
        )
        nil
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" put [#_"StoredBlock" __storedBlock, #_"StoredUndoableBlock" __undoableBlock]
        (.. this (maybeConnect))
        ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
        (let [#_"byte[]" __hashBytes (byte-array 28)]
            (System/arraycopy (.. __storedBlock (getHeader) (getHash) (getBytes)), 4, __hashBytes, 0, 28)
            (let [#_"int" __height (.. __storedBlock (getHeight))
                  #_"byte[]" __transactions nil
                  #_"byte[]" __txOutChanges nil]
                (try
                    (let [#_"ByteArrayOutputStream" __bos (ByteArrayOutputStream.)]
                        (cond (some? (.. __undoableBlock (getTxOutChanges)))
                            (do
                                (.. __undoableBlock (getTxOutChanges) (serializeToStream __bos))
                                (ยง ass __txOutChanges (.. __bos (toByteArray)))
                            )
                            :else
                            (do
                                (let [#_"int" __numTxn (.. __undoableBlock (getTransactions) (size))]
                                    (.. __bos (write (& 0xff __numTxn)))
                                    (.. __bos (write (& 0xff (>> __numTxn 8))))
                                    (.. __bos (write (& 0xff (>> __numTxn 16))))
                                    (.. __bos (write (& 0xff (>> __numTxn 24))))
                                    (doseq [#_"Transaction" __tx (.. __undoableBlock (getTransactions))]
                                        (.. __tx (bitcoinSerialize __bos))
                                    )
                                    (ยง ass __transactions (.. __bos (toByteArray)))
                                )
                            )
                        )
                        (.. __bos (close))
                    )
                    (catch IOException __e
                        (throw (BlockStoreException. __e))
                    )
                )

                (try
                    (try
                        (let [#_"PreparedStatement" __ps (.. (:conn this) (get) (prepareStatement (.. this (getInsertUndoableBlocksSQL))))]
                            (.. __ps (setBytes 1, __hashBytes))
                            (.. __ps (setInt 2, __height))
                            (cond (nil? __transactions)
                                (do
                                    (.. __ps (setBytes 3, __txOutChanges))
                                    (.. __ps (setNull 4, Types/BINARY))
                                )
                                :else
                                (do
                                    (.. __ps (setNull 3, Types/BINARY))
                                    (.. __ps (setBytes 4, __transactions))
                                )
                            )
                            (.. __ps (executeUpdate))
                            (.. __ps (close))
                            (try
                                (.. this (putUpdateStoredBlock __storedBlock, true))
                                (catch SQLException __e
                                    (throw (BlockStoreException. __e))
                                )
                            )
                        )
                        (catch SQLException __e
                            (when (not (.. __e (getSQLState) (equals (.. this (getDuplicateKeyErrorCode)))))
                                (throw (BlockStoreException. __e))
                            )

                            ;; There is probably an update-or-insert statement, but it wasn't obvious from the docs.
                            (let [#_"PreparedStatement" __ps (.. (:conn this) (get) (prepareStatement (.. this (getUpdateUndoableBlocksSQL))))]
                                (.. __ps (setBytes 3, __hashBytes))
                                (cond (nil? __transactions)
                                    (do
                                        (.. __ps (setBytes 1, __txOutChanges))
                                        (.. __ps (setNull 2, Types/BINARY))
                                    )
                                    :else
                                    (do
                                        (.. __ps (setNull 1, Types/BINARY))
                                        (.. __ps (setBytes 2, __transactions))
                                    )
                                )
                                (.. __ps (executeUpdate))
                                (.. __ps (close))
                            )
                        )
                    )
                    (catch SQLException __e
                        (throw (BlockStoreException. __e))
                    )
                )
                nil
            )
        )
    )

    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" get [#_"Sha256Hash" __hash, #_"boolean" __wasUndoableOnly]
        ;; Optimize for chain head.
        (when (and (some? (:chain-head-hash this)) (.. (:chain-head-hash this) (equals __hash)))
            (ยง return (:chain-head-block this))
        )

        (when (and (some? (:verified-chain-head-hash this)) (.. (:verified-chain-head-hash this) (equals __hash)))
            (ยง return (:verified-chain-head-block this))
        )

        (.. this (maybeConnect))
        (let [#_"PreparedStatement" __ps nil]
            (try
                (ยง ass __ps (.. (:conn this) (get) (prepareStatement (.. this (getSelectHeadersSQL)))))
                ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
                (let [#_"byte[]" __hashBytes (byte-array 28)]
                    (System/arraycopy (.. __hash (getBytes)), 4, __hashBytes, 0, 28)
                    (.. __ps (setBytes 1, __hashBytes))
                    (let [#_"ResultSet" __results (.. __ps (executeQuery))]
                        (when (not (.. __results (next)))
                            (ยง return nil)
                        )

                        ;; Parse it.
                        (when (and __wasUndoableOnly (not (.. __results (getBoolean 4))))
                            (ยง return nil)
                        )

                        (let [#_"BigInteger" __chainWork (BigInteger. (.. __results (getBytes 1)))
                              #_"int" __height (.. __results (getInt 2))
                              #_"Block" __b (.. (:params this) (getDefaultSerializer) (makeBlock (.. __results (getBytes 3))))]
                            (.. __b (verifyHeader))
                            (let [#_"StoredBlock" __stored (StoredBlock. __b, __chainWork, __height)]
                                (ยง return __stored)
                            )
                        )
                    )
                )
                (catch SQLException __e
                    (throw (BlockStoreException. __e))
                )
                (catch ProtocolException __e
                    ;; Corrupted database.
                    (throw (BlockStoreException. __e))
                )
                (catch VerificationException __e
                    ;; Should not be able to happen unless the database contains bad blocks.
                    (throw (BlockStoreException. __e))
                )
                (finally
                    (when (some? __ps)
                        (try
                            (.. __ps (close))
                            (catch SQLException _
                                (throw (BlockStoreException. "Failed to close PreparedStatement"))
                            )
                        )
                    )
                )
            )
        )
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" get [#_"Sha256Hash" __hash]
        (.. this (get __hash, false))
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" getOnceUndoableStoredBlock [#_"Sha256Hash" __hash]
        (.. this (get __hash, true))
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredUndoableBlock" getUndoBlock [#_"Sha256Hash" __hash]
        (.. this (maybeConnect))
        (let [#_"PreparedStatement" __ps nil]
            (try
                (ยง ass __ps (.. (:conn this) (get) (prepareStatement (.. this (getSelectUndoableBlocksSQL)))))
                ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.

                (let [#_"byte[]" __hashBytes (byte-array 28)]
                    (System/arraycopy (.. __hash (getBytes)), 4, __hashBytes, 0, 28)
                    (.. __ps (setBytes 1, __hashBytes))
                    (let [#_"ResultSet" __results (.. __ps (executeQuery))]
                        (when (not (.. __results (next)))
                            (ยง return nil)
                        )

                        ;; Parse it.
                        (let [#_"byte[]" __txOutChanges (.. __results (getBytes 1))
                              #_"byte[]" __transactions (.. __results (getBytes 2))
                              #_"StoredUndoableBlock" __block]
                            (cond (nil? __txOutChanges)
                                (do
                                    (let [#_"int" __numTxn (| (& 0xff (aget __transactions 0)) (<< (& 0xff (aget __transactions 1)) 8) (<< (& 0xff (aget __transactions 2)) 16) (<< (& 0xff (aget __transactions 3)) 24))
                                          #_"int" __offset 4
                                          #_"List<Transaction>" __transactionList (LinkedList. #_"<>")]
                                        (loop-when-recur [#_"int" __i 0] (< __i __numTxn) [(inc __i)]
                                            (let [#_"Transaction" __tx (.. (:params this) (getDefaultSerializer) (makeTransaction __transactions, __offset))]
                                                (.. __transactionList (add __tx))
                                                (ยง ass __offset (+ __offset (.. __tx (getMessageSize))))
                                            )
                                        )
                                        (ยง ass __block (StoredUndoableBlock. __hash, __transactionList))
                                    )
                                )
                                :else
                                (do
                                    (let [#_"TransactionOutputChanges" __outChangesObject (TransactionOutputChanges. (ByteArrayInputStream. __txOutChanges))]
                                        (ยง ass __block (StoredUndoableBlock. __hash, __outChangesObject))
                                    )
                                )
                            )
                            (ยง return __block)
                        )
                    )
                )
                (catch SQLException __e
                    (throw (BlockStoreException. __e))
                )
                (catch NullPointerException __e
                    ;; Corrupted database.
                    (throw (BlockStoreException. __e))
                )
                (catch ClassCastException __e
                    ;; Corrupted database.
                    (throw (BlockStoreException. __e))
                )
                (catch ProtocolException __e
                    ;; Corrupted database.
                    (throw (BlockStoreException. __e))
                )
                (catch IOException __e
                    ;; Corrupted database.
                    (throw (BlockStoreException. __e))
                )
                (finally
                    (when (some? __ps)
                        (try
                            (.. __ps (close))
                            (catch SQLException _
                                (throw (BlockStoreException. "Failed to close PreparedStatement"))
                            )
                        )
                    )
                )
            )
        )
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" getChainHead []
        (:chain-head-block this)
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" setChainHead [#_"StoredBlock" __chainHead]
        (let [#_"Sha256Hash" __hash (.. __chainHead (getHeader) (getHash))]
            (ยง assoc this :chain-head-hash __hash)
            (ยง assoc this :chain-head-block __chainHead)
            (.. this (maybeConnect))
            (try
                (let [#_"PreparedStatement" __ps (.. (:conn this) (get) (prepareStatement (.. this (getUpdateSettingsSLQ))))]
                    (.. __ps (setString 2, DatabaseFullPrunedBlockStore/CHAIN_HEAD_SETTING))
                    (.. __ps (setBytes 1, (.. __hash (getBytes))))
                    (.. __ps (executeUpdate))
                    (.. __ps (close))
                )
                (catch SQLException __e
                    (throw (BlockStoreException. __e))
                )
            )
            nil
        )
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" getVerifiedChainHead []
        (:verified-chain-head-block this)
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" setVerifiedChainHead [#_"StoredBlock" __chainHead]
        (let [#_"Sha256Hash" __hash (.. __chainHead (getHeader) (getHash))]
            (ยง assoc this :verified-chain-head-hash __hash)
            (ยง assoc this :verified-chain-head-block __chainHead)
            (.. this (maybeConnect))
            (try
                (let [#_"PreparedStatement" __ps (.. (:conn this) (get) (prepareStatement (.. this (getUpdateSettingsSLQ))))]
                    (.. __ps (setString 2, DatabaseFullPrunedBlockStore/VERIFIED_CHAIN_HEAD_SETTING))
                    (.. __ps (setBytes 1, (.. __hash (getBytes))))
                    (.. __ps (executeUpdate))
                    (.. __ps (close))
                )
                (catch SQLException __e
                    (throw (BlockStoreException. __e))
                )
            )
            (when (< (.. (:chain-head-block this) (getHeight)) (.. __chainHead (getHeight)))
                (.. this (setChainHead __chainHead))
            )
            (.. this (removeUndoableBlocksWhereHeightIsLessThan (- (.. __chainHead (getHeight)) (:full-store-depth this))))
            nil
        )
    )

    #_private
    #_throws #_[ "BlockStoreException" ]
    (ยง method- #_"void" removeUndoableBlocksWhereHeightIsLessThan [#_"int" __height]
        (try
            (let [#_"PreparedStatement" __ps (.. (:conn this) (get) (prepareStatement (.. this (getDeleteUndoableBlocksSQL))))]
                (.. __ps (setInt 1, __height))
                (when (.. DatabaseFullPrunedBlockStore/log (isDebugEnabled))
                    (.. DatabaseFullPrunedBlockStore/log (debug (str "Deleting undoable undoable block with height <= " __height)))
                )
                (.. __ps (executeUpdate))
                (.. __ps (close))
            )
            (catch SQLException __e
                (throw (BlockStoreException. __e))
            )
        )
        nil
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"UTXO" getTransactionOutput [#_"Sha256Hash" __hash, #_"long" __index]
        (.. this (maybeConnect))
        (let [#_"PreparedStatement" __ps nil]
            (try
                (ยง ass __ps (.. (:conn this) (get) (prepareStatement (.. this (getSelectOpenoutputsSQL)))))
                (.. __ps (setBytes 1, (.. __hash (getBytes))))
                ;; index is actually an unsigned int
                (.. __ps (setInt 2, (int __index)))
                (let [#_"ResultSet" __results (.. __ps (executeQuery))]
                    (when (not (.. __results (next)))
                        (ยง return nil)
                    )

                    ;; Parse it.
                    (let [#_"int" __height (.. __results (getInt 1))
                          #_"Coin" __value (Coin/valueOf (.. __results (getLong 2)))
                          #_"byte[]" __scriptBytes (.. __results (getBytes 3))
                          #_"boolean" __coinbase (.. __results (getBoolean 4))
                          #_"String" __address (.. __results (getString 5))]
                        (ยง return (UTXO. __hash, __index, __value, __height, __coinbase, (Script. __scriptBytes), __address))
                    )
                )
                (catch SQLException __e
                    (throw (BlockStoreException. __e))
                )
                (finally
                    (when (some? __ps)
                        (try
                            (.. __ps (close))
                            (catch SQLException _
                                (throw (BlockStoreException. "Failed to close PreparedStatement"))
                            )
                        )
                    )
                )
            )
        )
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" addUnspentTransactionOutput [#_"UTXO" __out]
        (.. this (maybeConnect))
        (let [#_"PreparedStatement" __ps nil]
            (try
                (ยง ass __ps (.. (:conn this) (get) (prepareStatement (.. this (getInsertOpenoutputsSQL)))))
                (.. __ps (setBytes 1, (.. __out (getHash) (getBytes))))
                ;; index is actually an unsigned int
                (.. __ps (setInt 2, (int (.. __out (getIndex)))))
                (.. __ps (setInt 3, (.. __out (getHeight))))
                (.. __ps (setLong 4, (:value (.. __out (getValue)))))
                (.. __ps (setBytes 5, (.. __out (getScript) (getProgram))))
                (.. __ps (setString 6, (.. __out (getAddress))))
                (.. __ps (setInt 7, (.. __out (getScript) (getScriptType) (ordinal))))
                (.. __ps (setBoolean 8, (.. __out (isCoinbase))))
                (.. __ps (executeUpdate))
                (.. __ps (close))
                (catch SQLException __e
                    (when (not (.. __e (getSQLState) (equals (.. this (getDuplicateKeyErrorCode)))))
                        (throw (BlockStoreException. __e))
                    )
                )
                (finally
                    (when (some? __ps)
                        (try
                            (.. __ps (close))
                            (catch SQLException __e
                                (throw (BlockStoreException. __e))
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" removeUnspentTransactionOutput [#_"UTXO" __out]
        (.. this (maybeConnect))
        ;; TODO: This should only need one query (maybe a stored procedure).
        (when (nil? (.. this (getTransactionOutput (.. __out (getHash)), (.. __out (getIndex)))))
            (throw (BlockStoreException. "Tried to remove a UTXO from DatabaseFullPrunedBlockStore that it didn't have!"))
        )

        (try
            (let [#_"PreparedStatement" __ps (.. (:conn this) (get) (prepareStatement (.. this (getDeleteOpenoutputsSQL))))]
                (.. __ps (setBytes 1, (.. __out (getHash) (getBytes))))
                ;; index is actually an unsigned int
                (.. __ps (setInt 2, (int (.. __out (getIndex)))))
                (.. __ps (executeUpdate))
                (.. __ps (close))
            )
            (catch SQLException __e
                (throw (BlockStoreException. __e))
            )
        )
        nil
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" beginDatabaseBatchWrite []
        (.. this (maybeConnect))
        (when (.. DatabaseFullPrunedBlockStore/log (isDebugEnabled))
            (.. DatabaseFullPrunedBlockStore/log (debug (str "Starting database batch write with connection: " (.. (:conn this) (get)))))
        )

        (try
            (.. (:conn this) (get) (setAutoCommit false))
            (catch SQLException __e
                (throw (BlockStoreException. __e))
            )
        )
        nil
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" commitDatabaseBatchWrite []
        (.. this (maybeConnect))
        (when (.. DatabaseFullPrunedBlockStore/log (isDebugEnabled))
            (.. DatabaseFullPrunedBlockStore/log (debug (str "Committing database batch write with connection: " (.. (:conn this) (get)))))
        )

        (try
            (.. (:conn this) (get) (commit))
            (.. (:conn this) (get) (setAutoCommit true))
            (catch SQLException __e
                (throw (BlockStoreException. __e))
            )
        )
        nil
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" abortDatabaseBatchWrite []
        (.. this (maybeConnect))
        (when (.. DatabaseFullPrunedBlockStore/log (isDebugEnabled))
            (.. DatabaseFullPrunedBlockStore/log (debug (str "Rollback database batch write with connection: " (.. (:conn this) (get)))))
        )

        (try
            (cond (not (.. (:conn this) (get) (getAutoCommit)))
                (do
                    (.. (:conn this) (get) (rollback))
                    (.. (:conn this) (get) (setAutoCommit true))
                )
                :else
                (do
                    (.. DatabaseFullPrunedBlockStore/log (warn "Warning: Rollback attempt without transaction"))
                )
            )
            (catch SQLException __e
                (throw (BlockStoreException. __e))
            )
        )
        nil
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"boolean" hasUnspentOutputs [#_"Sha256Hash" __hash, #_"int" __numOutputs]
        (.. this (maybeConnect))
        (let [#_"PreparedStatement" __ps nil]
            (try
                (ยง ass __ps (.. (:conn this) (get) (prepareStatement (.. this (getSelectOpenoutputsCountSQL)))))
                (.. __ps (setBytes 1, (.. __hash (getBytes))))
                (let [#_"ResultSet" __results (.. __ps (executeQuery))]
                    (when (not (.. __results (next)))
                        (throw (BlockStoreException. "Got no results from a COUNT(*) query"))
                    )

                    (let [#_"int" __count (.. __results (getInt 1))]
                        (ยง return (!= __count 0))
                    )
                )
                (catch SQLException __e
                    (throw (BlockStoreException. __e))
                )
                (finally
                    (when (some? __ps)
                        (try
                            (.. __ps (close))
                            (catch SQLException _
                                (throw (BlockStoreException. "Failed to close PreparedStatement"))
                            )
                        )
                    )
                )
            )
        )
    )

    #_override
    #_public
    (ยง method #_"NetworkParameters" getParams []
        (:params this)
    )

    ;;;
     ; Resets the store by deleting the contents of the tables and reinitialising them.
     ; @throws BlockStoreException if the tables couldn't be cleared and initialised.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" resetStore []
        (.. this (maybeConnect))
        (try
            (.. this (deleteStore))
            (.. this (createTables))
            (.. this (initFromDatabase))
            (catch SQLException __e
                (throw (RuntimeException. __e))
            )
        )
        nil
    )

    ;;;
     ; Deletes the store by deleting the tables within the database.
     ; @throws BlockStoreException if tables couldn't be deleted.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" deleteStore []
        (.. this (maybeConnect))
        (try
            (let [#_"Statement" __s (.. (:conn this) (get) (createStatement))]
                (doseq [#_"String" __sql (.. this (getDropTablesSQL))]
                    (.. __s (execute __sql))
                )
                (.. __s (close))
            )
            (catch SQLException __e
                (throw (RuntimeException. __e))
            )
        )
        nil
    )

    ;;;
     ; Calculate the balance for a coinbase, to-address, or p2sh address.
     ;
     ; <p>The balance {@link org.bitcoinj.store.DatabaseFullPrunedBlockStore#getBalanceSelectSQL()} returns
     ; the balance (summed) as a number, then use calculateClientSide=false.</p>
     ;
     ; <p>The balance {@link org.bitcoinj.store.DatabaseFullPrunedBlockStore#getBalanceSelectSQL()} returns
     ; all the open outputs as stored in the DB (binary), then use calculateClientSide=true.</p>
     ;
     ; @param address The address to calculate the balance of.
     ; @return The balance of the address supplied.  If the address has not been seen,
     ;         or there are no outputs open for this address, the return value is 0.
     ; @throws BlockStoreException if there is an error getting the balance.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"BigInteger" calculateBalanceForAddress [#_"Address" __address]
        (.. this (maybeConnect))
        (let [#_"PreparedStatement" __ps nil]
            (try
                (ยง ass __ps (.. (:conn this) (get) (prepareStatement (.. this (getBalanceSelectSQL)))))
                (.. __ps (setString 1, (.. __address (toString))))
                (let [#_"ResultSet" __rs (.. __ps (executeQuery))
                      #_"BigInteger" __balance BigInteger/ZERO]
                    (ยง return (if (.. __rs (next)) (BigInteger/valueOf (.. __rs (getLong 1))) __balance))
                )
                (catch SQLException __e
                    (throw (BlockStoreException. __e))
                )
                (finally
                    (when (some? __ps)
                        (try
                            (.. __ps (close))
                            (catch SQLException _
                                (throw (BlockStoreException. "Could not close statement"))
                            )
                        )
                    )
                )
            )
        )
    )
)

;;;
 ; <p>An implementor of FullPrunedBlockStore saves StoredBlock objects to some storage mechanism.</p>
 ;
 ; <p>In addition to keeping track of a chain using {@link StoredBlock}s, it should also keep track of
 ; a second copy of the chain which holds {@link StoredUndoableBlock}s.  In this way, an application can
 ; perform a headers-only initial sync and then use that information to more efficiently download a locally
 ; verified full copy of the block chain.</p>
 ;
 ; <p>A FullPrunedBlockStore should function well as a standard {@link BlockStore} and then be able to
 ; trivially switch to being used as a FullPrunedBlockStore.</p>
 ;
 ; <p>It should store the {@link StoredUndoableBlock}s of a number of recent blocks before verifiedHead.height
 ; and all those after verifiedHead.height.
 ; It is advisable to store any {@link StoredUndoableBlock} which has a height > verifiedHead.height - N.
 ; Because N determines the memory usage, it is recommended that N be customizable.  N should be chosen such
 ; that re-orgs beyond that point are vanishingly unlikely, e.g. a few thousand blocks is a reasonable choice.</p>
 ;
 ; <p>It must store the {@link StoredBlock} of all blocks.</p>
 ;
 ; <p>A FullPrunedBlockStore contains a map of hashes to [Full]StoredBlock.  The hash is the double digest of
 ; the Bitcoin serialization of the block header, <b>not</b> the header with the extra data as well.</p>
 ;
 ; <p>A FullPrunedBlockStore also contains a map of hash+index to UTXO.  Again, the hash is
 ; a standard Bitcoin double-SHA256 hash of the transaction.</p>
 ;
 ; <p>FullPrunedBlockStores are thread safe.</p>
 ;;
#_public
(ยง interface FullPrunedBlockStore (ยง extends BlockStore)
    ;;;
     ; <p>Saves the given {@link StoredUndoableBlock} and {@link StoredBlock}.  Calculates keys from the {@link StoredBlock}.</p>
     ;
     ; <p>Though not required for proper function of a FullPrunedBlockStore, any user of a FullPrunedBlockStore should ensure
     ; that a StoredUndoableBlock for each block up to the fully verified chain head has been added to this block store using
     ; this function (not put(StoredBlock)), so that the ability to perform reorgs is maintained.</p>
     ;
     ; @throws BlockStoreException if there is a problem with the underlying storage layer, such as running out of disk space.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" put [#_"StoredBlock" __storedBlock, #_"StoredUndoableBlock" __undoableBlock])

    ;;;
     ; Returns the StoredBlock that was added as a StoredUndoableBlock given a hash.  The returned values block.getHash()
     ; method will be equal to the parameter.  If no such block is found, returns null.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" getOnceUndoableStoredBlock [#_"Sha256Hash" __hash])

    ;;;
     ; Returns a {@link StoredUndoableBlock} whose block.getHash() method will be equal to the parameter.  If no such
     ; block is found, returns null.  Note that this may return null more often than get(Sha256Hash hash) as not all
     ; {@link StoredBlock}s have a {@link StoredUndoableBlock} copy stored as well.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredUndoableBlock" getUndoBlock [#_"Sha256Hash" __hash])

    ;;;
     ; Gets a {@link org.bitcoinj.core.UTXO} with the given hash and index, or null if none is found.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"UTXO" getTransactionOutput [#_"Sha256Hash" __hash, #_"long" __index])

    ;;;
     ; Adds a {@link org.bitcoinj.core.UTXO} to the list of unspent TransactionOutputs.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" addUnspentTransactionOutput [#_"UTXO" __out])

    ;;;
     ; Removes a {@link org.bitcoinj.core.UTXO} from the list of unspent TransactionOutputs.
     ; Note that the coinbase of the genesis block should NEVER be spendable and thus never in the list.
     ; @throws BlockStoreException if there is an underlying storage issue, or out was not in the list.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" removeUnspentTransactionOutput [#_"UTXO" __out])

    ;;;
     ; True if this store has any unspent outputs from a transaction with a hash equal to the first parameter.
     ; @param numOutputs The number of outputs the given transaction has.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"boolean" hasUnspentOutputs [#_"Sha256Hash" __hash, #_"int" __numOutputs])

    ;;;
     ; Returns the {@link StoredBlock} that represents the top of the chain of greatest total work that has
     ; been fully verified and the point in the chain at which the unspent transaction output set in this
     ; store represents.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" getVerifiedChainHead [])

    ;;;
     ; Sets the {@link StoredBlock} that represents the top of the chain of greatest total work that has been
     ; fully verified.  It should generally be set after a batch of updates to the transaction unspent output set,
     ; before a call to commitDatabaseBatchWrite.
     ;
     ; If chainHead has a greater height than the non-verified chain head (i.e. that set with
     ; {@link BlockStore#setChainHead}) the non-verified chain head should be set to the one set here.
     ; In this way a class using a FullPrunedBlockStore only in full-verification mode can ignore the regular
     ; {@link BlockStore} functions implemented as a part of a FullPrunedBlockStore.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" setVerifiedChainHead [#_"StoredBlock" __chainHead])

    ;;;
     ; <p>Begins/Commits/Aborts a database transaction.</p>
     ;
     ; <p>If abortDatabaseBatchWrite() is called by the same thread that called beginDatabaseBatchWrite(),
     ; any data writes between this call and abortDatabaseBatchWrite() made by the same thread
     ; should be discarded.</p>
     ;
     ; <p>Furthermore, any data written after a call to beginDatabaseBatchWrite() should not be readable
     ; by any other threads until commitDatabaseBatchWrite() has been called by this thread.
     ; Multiple calls to beginDatabaseBatchWrite() in any given thread should be ignored and treated as one call.</p>
     ;;
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" beginDatabaseBatchWrite [])

    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" commitDatabaseBatchWrite [])

    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" abortDatabaseBatchWrite [])
)

;;;
 ; A full pruned block store using the H2 pure-java embedded database.
 ;
 ; Note that because of the heavy delete load on the database, during IBD,
 ; you may see the database files grow quite large (around 1.5G).
 ; H2 automatically frees some space at shutdown, so close()ing the database
 ; decreases the space usage somewhat (to only around 1.3G).
 ;;
#_public
(ยง class H2FullPrunedBlockStore (ยง extends DatabaseFullPrunedBlockStore)
    #_private
    #_static
    (ยง def- #_"String" H2FullPrunedBlockStore/H2_DUPLICATE_KEY_ERROR_CODE "23505")
    #_private
    #_static
    (ยง def- #_"String" H2FullPrunedBlockStore/DATABASE_DRIVER_CLASS "org.h2.Driver")
    #_private
    #_static
    (ยง def- #_"String" H2FullPrunedBlockStore/DATABASE_CONNECTION_URL_PREFIX "jdbc:h2:")

    ;; create table SQL
    #_private
    #_static
    (ยง def- #_"String" H2FullPrunedBlockStore/CREATE_SETTINGS_TABLE (str "CREATE TABLE settings ("
              "name VARCHAR(32) NOT NULL CONSTRAINT settings_pk PRIMARY KEY, "
              "value BLOB"
              ")"))

    #_private
    #_static
    (ยง def- #_"String" H2FullPrunedBlockStore/CREATE_HEADERS_TABLE (str "CREATE TABLE headers ("
              "hash BINARY(28) NOT NULL CONSTRAINT headers_pk PRIMARY KEY, "
              "chainwork BLOB NOT NULL, "
              "height INT NOT NULL, "
              "header BLOB NOT NULL, "
              "wasundoable BOOL NOT NULL"
              ")"))

    #_private
    #_static
    (ยง def- #_"String" H2FullPrunedBlockStore/CREATE_UNDOABLE_TABLE (str "CREATE TABLE undoableblocks ("
              "hash BINARY(28) NOT NULL CONSTRAINT undoableblocks_pk PRIMARY KEY, "
              "height INT NOT NULL, "
              "txoutchanges BLOB, "
              "transactions BLOB"
              ")"))

    #_private
    #_static
    (ยง def- #_"String" H2FullPrunedBlockStore/CREATE_OPEN_OUTPUT_TABLE (str "CREATE TABLE openoutputs ("
              "hash BINARY(32) NOT NULL, "
              "index INT NOT NULL, "
              "height INT NOT NULL, "
              "value BIGINT NOT NULL, "
              "scriptbytes BLOB NOT NULL, "
              "toaddress VARCHAR(35), "
              "addresstargetable TINYINT, "
              "coinbase BOOLEAN, "
              "PRIMARY KEY (hash, index)"
              ")"))

    ;; Some indexes to speed up inserts.
    #_private
    #_static
    (ยง def- #_"String" H2FullPrunedBlockStore/CREATE_OUTPUTS_ADDRESS_MULTI_INDEX "CREATE INDEX openoutputs_hash_index_height_toaddress_idx ON openoutputs (hash, index, height, toaddress)")
    #_private
    #_static
    (ยง def- #_"String" H2FullPrunedBlockStore/CREATE_OUTPUTS_TOADDRESS_INDEX "CREATE INDEX openoutputs_toaddress_idx ON openoutputs (toaddress)")
    #_private
    #_static
    (ยง def- #_"String" H2FullPrunedBlockStore/CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX "CREATE INDEX openoutputs_addresstargetable_idx ON openoutputs (addresstargetable)")
    #_private
    #_static
    (ยง def- #_"String" H2FullPrunedBlockStore/CREATE_OUTPUTS_HASH_INDEX "CREATE INDEX openoutputs_hash_idx ON openoutputs (hash)")
    #_private
    #_static
    (ยง def- #_"String" H2FullPrunedBlockStore/CREATE_UNDOABLE_TABLE_INDEX "CREATE INDEX undoableblocks_height_idx ON undoableblocks (height)")

    ;;;
     ; Creates a new H2FullPrunedBlockStore, with given credentials for H2 database.
     ; @param params A copy of the NetworkParameters used.
     ; @param dbName The path to the database on disk.
     ; @param username The username to use in the database.
     ; @param password The username's password to use in the database.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor H2FullPrunedBlockStore [#_"NetworkParameters" __params, #_"String" __dbName, #_"String" __username, #_"String" __password, #_"int" __fullStoreDepth]
        (ยง super __params, (str H2FullPrunedBlockStore/DATABASE_CONNECTION_URL_PREFIX __dbName ";create=true;LOCK_TIMEOUT=60000;DB_CLOSE_ON_EXIT=FALSE"), __fullStoreDepth, __username, __password, nil)
        this
    )

    ;;;
     ; Creates a new H2FullPrunedBlockStore.
     ; @param params A copy of the NetworkParameters used.
     ; @param dbName The path to the database on disk.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor H2FullPrunedBlockStore [#_"NetworkParameters" __params, #_"String" __dbName, #_"int" __fullStoreDepth]
        (ยง this __params, __dbName, nil, nil, __fullStoreDepth)
        this
    )

    ;;;
     ; Creates a new H2FullPrunedBlockStore with the given cache size.
     ; @param params A copy of the NetworkParameters used.
     ; @param dbName The path to the database on disk.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param cacheSize The number of kilobytes to dedicate to H2 Cache.  The default value of 16MB (16384) is a safe bet
     ;                  to achieve good performance/cost when importing blocks from disk, past 32MB makes little sense,
     ;                  and below 4MB sees a sharp drop in performance.
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor H2FullPrunedBlockStore [#_"NetworkParameters" __params, #_"String" __dbName, #_"int" __fullStoreDepth, #_"int" __cacheSize]
        (ยง this __params, __dbName, __fullStoreDepth)

        (try
            (let [#_"Statement" __s (.. (:conn this) (get) (createStatement))]
                (.. __s (executeUpdate (str "SET CACHE_SIZE " __cacheSize)))
                (.. __s (close))
            )
            (catch SQLException __e
                (throw (BlockStoreException. __e))
            )
        )
        this
    )

    #_override
    #_protected
    (ยง method #_"String" getDuplicateKeyErrorCode []
        H2FullPrunedBlockStore/H2_DUPLICATE_KEY_ERROR_CODE
    )

    #_override
    #_protected
    (ยง method #_"List<String>" getCreateTablesSQL []
        (let [#_"List<String>" __sql (ArrayList. #_"<>")]
            (.. __sql (add H2FullPrunedBlockStore/CREATE_SETTINGS_TABLE))
            (.. __sql (add H2FullPrunedBlockStore/CREATE_HEADERS_TABLE))
            (.. __sql (add H2FullPrunedBlockStore/CREATE_UNDOABLE_TABLE))
            (.. __sql (add H2FullPrunedBlockStore/CREATE_OPEN_OUTPUT_TABLE))
            __sql
        )
    )

    #_override
    #_protected
    (ยง method #_"List<String>" getCreateIndexesSQL []
        (let [#_"List<String>" __sql (ArrayList. #_"<>")]
            (.. __sql (add H2FullPrunedBlockStore/CREATE_UNDOABLE_TABLE_INDEX))
            (.. __sql (add H2FullPrunedBlockStore/CREATE_OUTPUTS_ADDRESS_MULTI_INDEX))
            (.. __sql (add H2FullPrunedBlockStore/CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX))
            (.. __sql (add H2FullPrunedBlockStore/CREATE_OUTPUTS_HASH_INDEX))
            (.. __sql (add H2FullPrunedBlockStore/CREATE_OUTPUTS_TOADDRESS_INDEX))
            __sql
        )
    )

    #_override
    #_protected
    (ยง method #_"List<String>" getCreateSchemeSQL []
        ;; do nothing
        (Collections/emptyList)
    )

    #_override
    #_protected
    (ยง method #_"String" getDatabaseDriverClass []
        H2FullPrunedBlockStore/DATABASE_DRIVER_CLASS
    )
)

;;;
 ; Keeps {@link org.bitcoinj.core.StoredBlock}s in memory.  Used primarily for unit testing.
 ;;
#_public
(ยง class MemoryBlockStore (ยง implements BlockStore)
    #_private
    (ยง field- #_"LinkedHashMap<Sha256Hash, StoredBlock>" :block-map (LinkedHashMap. #_"<Sha256Hash, StoredBlock>"
        (ยง anon
            #_override
            #_protected
            (ยง method #_"boolean" removeEldestEntry [#_"Map.Entry<Sha256Hash, StoredBlock>" __eldest]
                (< 5000 (.. (:block-map this) (size)))
            )
        )))
    #_private
    (ยง field- #_"StoredBlock" :chain-head)
    #_private
    (ยง field- #_"NetworkParameters" :params)

    #_public
    (ยง constructor MemoryBlockStore [#_"NetworkParameters" __params]
        ;; Insert the genesis block.
        (try
            (let [#_"Block" __genesisHeader (.. __params (getGenesisBlock) (cloneAsHeader))
                  #_"StoredBlock" __storedGenesis (StoredBlock. __genesisHeader, (.. __genesisHeader (getWork)), 0)]
                (.. this (put __storedGenesis))
                (.. this (setChainHead __storedGenesis))
                (ยง assoc this :params __params)
            )
            (catch BlockStoreException __e
                (throw (RuntimeException. __e)) ;; Cannot happen.
            )
            (catch VerificationException __e
                (throw (RuntimeException. __e)) ;; Cannot happen.
            )
        )
        this
    )

    #_override
    #_public
    #_synchronized
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" put [#_"StoredBlock" __block]
        (when (nil? (:block-map this))
            (throw (BlockStoreException. "MemoryBlockStore is closed"))
        )

        (let [#_"Sha256Hash" __hash (.. __block (getHeader) (getHash))]
            (.. (:block-map this) (put __hash, __block))
            nil
        )
    )

    #_override
    #_public
    #_synchronized
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" get [#_"Sha256Hash" __hash]
        (when (nil? (:block-map this))
            (throw (BlockStoreException. "MemoryBlockStore is closed"))
        )

        (.. (:block-map this) (get __hash))
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" getChainHead []
        (when (nil? (:block-map this))
            (throw (BlockStoreException. "MemoryBlockStore is closed"))
        )

        (:chain-head this)
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" setChainHead [#_"StoredBlock" __chainHead]
        (when (nil? (:block-map this))
            (throw (BlockStoreException. "MemoryBlockStore is closed"))
        )

        (ยง assoc this :chain-head __chainHead)
        nil
    )

    #_override
    #_public
    (ยง method #_"void" close []
        (ยง assoc this :block-map nil)
        nil
    )

    #_override
    #_public
    (ยง method #_"NetworkParameters" getParams []
        (:params this)
    )
)

;;;
 ; Used as a key for memory map (to avoid having to think about NetworkParameters,
 ; which is required for {@link TransactionOutPoint}.
 ;;
(ยง class StoredTransactionOutPoint
    ;;; Hash of the transaction to which we refer. ;;
    (ยง field #_"Sha256Hash" :hash)
    ;;; Which output of that transaction we are talking about. ;;
    (ยง field #_"long" :index)

    (ยง constructor StoredTransactionOutPoint [#_"Sha256Hash" __hash, #_"long" __index]
        (ยง assoc this :hash __hash)
        (ยง assoc this :index __index)
        this
    )

    (ยง constructor StoredTransactionOutPoint [#_"UTXO" __out]
        (ยง assoc this :hash (.. __out (getHash)))
        (ยง assoc this :index (.. __out (getIndex)))
        this
    )

    ;;;
     ; The hash of the transaction to which we refer.
     ;;
    (ยง method #_"Sha256Hash" getHash []
        (:hash this)
    )

    ;;;
     ; The index of the output in transaction to which we refer.
     ;;
    (ยง method #_"long" getIndex []
        (:index this)
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (.. this (getIndex)), (.. this (getHash)))
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (str "Stored transaction out point: " (:hash this) ":" (:index this))
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"StoredTransactionOutPoint" __other (cast StoredTransactionOutPoint __o)]
            (and (== (.. this (getIndex)) (.. __other (getIndex))) (Objects/equal (.. this (getHash)), (.. __other (getHash))))
        )
    )
)

;;;
 ; A HashMap<KeyType, ValueType> that is DB transaction-aware.
 ; This class is not thread-safe.
 ;;
(ยง class TransactionalHashMap #_"<KeyType, ValueType>"
    (ยง field #_"ThreadLocal<HashMap<KeyType, ValueType>>" :temp-map)
    (ยง field #_"ThreadLocal<HashSet<KeyType>>" :temp-set-removed)
    #_private
    (ยง field- #_"ThreadLocal<Boolean>" :in-transaction)

    (ยง field #_"HashMap<KeyType, ValueType>" :map)

    #_public
    (ยง constructor TransactionalHashMap []
        (ยง assoc this :temp-map (ThreadLocal. #_"<>"))
        (ยง assoc this :temp-set-removed (ThreadLocal. #_"<>"))
        (ยง assoc this :in-transaction (ThreadLocal. #_"<>"))
        (ยง assoc this :map (HashMap. #_"<>"))
        this
    )

    #_public
    (ยง method #_"void" beginDatabaseBatchWrite []
        (.. (:in-transaction this) (set true))
        nil
    )

    #_public
    (ยง method #_"void" commitDatabaseBatchWrite []
        (when (some? (.. (:temp-set-removed this) (get)))
            (doseq [#_"KeyType" __key (.. (:temp-set-removed this) (get))]
                (.. (:map this) (remove __key))
            )
        )
        (when (some? (.. (:temp-map this) (get)))
            (doseq [#_"Map.Entry<KeyType, ValueType>" __entry (.. (:temp-map this) (get) (entrySet))]
                (.. (:map this) (put (.. __entry (getKey)), (.. __entry (getValue))))
            )
        )
        (.. this (abortDatabaseBatchWrite))
        nil
    )

    #_public
    (ยง method #_"void" abortDatabaseBatchWrite []
        (.. (:in-transaction this) (set false))
        (.. (:temp-set-removed this) (remove))
        (.. (:temp-map this) (remove))
        nil
    )

    #_nilable
    #_public
    (ยง method #_"ValueType" get [#_"KeyType" __key]
        (when (.. Boolean/TRUE (equals (.. (:in-transaction this) (get))))
            (when (some? (.. (:temp-map this) (get)))
                (let [#_"ValueType" __value (.. (:temp-map this) (get) (get __key))]
                    (when (some? __value)
                        (ยง return __value)
                    )
                )
            )
            (when (and (some? (.. (:temp-set-removed this) (get))) (.. (:temp-set-removed this) (get) (contains __key)))
                (ยง return nil)
            )
        )
        (.. (:map this) (get __key))
    )

    #_public
    (ยง method #_"List<ValueType>" values []
        (let [#_"List<ValueType>" __valueTypes (ArrayList. #_"<>")]
            (doseq [#_"KeyType" __keyType (.. (:map this) (keySet))]
                (.. __valueTypes (add (.. this (get __keyType))))
            )
            __valueTypes
        )
    )

    #_public
    (ยง method #_"void" put [#_"KeyType" __key, #_"ValueType" __value]
        (cond (.. Boolean/TRUE (equals (.. (:in-transaction this) (get))))
            (do
                (when (some? (.. (:temp-set-removed this) (get)))
                    (.. (:temp-set-removed this) (get) (remove __key))
                )
                (when (nil? (.. (:temp-map this) (get)))
                    (.. (:temp-map this) (set (HashMap. #_"<KeyType, ValueType>")))
                )
                (.. (:temp-map this) (get) (put __key, __value))
            )
            :else
            (do
                (.. (:map this) (put __key, __value))
            )
        )
        nil
    )

    #_nilable
    #_public
    (ยง method #_"ValueType" remove [#_"KeyType" __key]
        (cond (.. Boolean/TRUE (equals (.. (:in-transaction this) (get))))
            (do
                (let [#_"ValueType" __retVal (.. (:map this) (get __key))]
                    (when (some? __retVal)
                        (when (nil? (.. (:temp-set-removed this) (get)))
                            (.. (:temp-set-removed this) (set (HashSet. #_"<KeyType>")))
                        )
                        (.. (:temp-set-removed this) (get) (add __key))
                    )
                    (when (some? (.. (:temp-map this) (get)))
                        (let [#_"ValueType" __tempVal (.. (:temp-map this) (get) (remove __key))]
                            (when (some? __tempVal)
                                (ยง return __tempVal)
                            )
                        )
                    )
                    (ยง return __retVal)
                )
            )
            :else
            (do
                (ยง return (.. (:map this) (remove __key)))
            )
        )
    )
)

;;;
 ; A Map with multiple key types that is DB per-thread-transaction-aware.
 ; However, this class is not thread-safe.
 ; @param <UniqueKeyType> Is a key that must be unique per object.
 ; @param <MultiKeyType> Is a key that can have multiple values.
 ;;
(ยง class TransactionalMultiKeyHashMap #_"<UniqueKeyType, MultiKeyType, ValueType>"
    (ยง field #_"TransactionalHashMap<UniqueKeyType, ValueType>" :map-values)
    (ยง field #_"HashMap<MultiKeyType, Set<UniqueKeyType>>" :map-keys)

    #_public
    (ยง constructor TransactionalMultiKeyHashMap []
        (ยง assoc this :map-values (TransactionalHashMap. #_"<>"))
        (ยง assoc this :map-keys (HashMap. #_"<>"))
        this
    )

    #_public
    (ยง method #_"void" beginTransaction []
        (.. (:map-values this) (beginDatabaseBatchWrite))
        nil
    )

    #_public
    (ยง method #_"void" commitTransaction []
        (.. (:map-values this) (commitDatabaseBatchWrite))
        nil
    )

    #_public
    (ยง method #_"void" abortTransaction []
        (.. (:map-values this) (abortDatabaseBatchWrite))
        nil
    )

    #_nilable
    #_public
    (ยง method #_"ValueType" get [#_"UniqueKeyType" __key]
        (.. (:map-values this) (get __key))
    )

    #_public
    (ยง method #_"void" put [#_"UniqueKeyType" __uniqueKey, #_"MultiKeyType" __multiKey, #_"ValueType" __value]
        (.. (:map-values this) (put __uniqueKey, __value))
        (let [#_"Set<UniqueKeyType>" __set (.. (:map-keys this) (get __multiKey))]
            (cond (nil? __set)
                (do
                    (ยง ass __set (HashSet. #_"<>"))
                    (.. __set (add __uniqueKey))
                    (.. (:map-keys this) (put __multiKey, __set))
                )
                :else
                (do
                    (.. __set (add __uniqueKey))
                )
            )
            nil
        )
    )

    #_nilable
    #_public
    (ยง method #_"ValueType" removeByUniqueKey [#_"UniqueKeyType" __key]
        (.. (:map-values this) (remove __key))
    )

    #_public
    (ยง method #_"void" removeByMultiKey [#_"MultiKeyType" __key]
        (let [#_"Set<UniqueKeyType>" __set (.. (:map-keys this) (remove __key))]
            (when (some? __set)
                (doseq [#_"UniqueKeyType" __uniqueKey __set]
                    (.. this (removeByUniqueKey __uniqueKey))
                )
            )
            nil
        )
    )
)

;;;
 ; Keeps {@link StoredBlock}s, {@link StoredUndoableBlock}s and {@link org.bitcoinj.core.UTXO}s in memory.
 ; Used primarily for unit testing.
 ;;
#_public
(ยง class MemoryFullPrunedBlockStore (ยง implements FullPrunedBlockStore)
    #_protected
    #_static
    (ยง class MemoryFullPrunedBlockStore.StoredBlockAndWasUndoableFlag
        #_public
        (ยง field #_"StoredBlock" :block)
        #_public
        (ยง field #_"boolean" :was-undoable)
        #_public
        (ยง constructor MemoryFullPrunedBlockStore.StoredBlockAndWasUndoableFlag [#_"StoredBlock" __block, #_"boolean" __wasUndoable]
            (ยง assoc this :block __block)
            (ยง assoc this :was-undoable __wasUndoable)
            this
        )
    )
    #_private
    (ยง field- #_"TransactionalHashMap<Sha256Hash, MemoryFullPrunedBlockStore.StoredBlockAndWasUndoableFlag>" :block-map)
    #_private
    (ยง field- #_"TransactionalMultiKeyHashMap<Sha256Hash, Integer, StoredUndoableBlock>" :full-block-map)
    ;; TODO: Use something more suited to remove-heavy use?
    #_private
    (ยง field- #_"TransactionalHashMap<StoredTransactionOutPoint, UTXO>" :transaction-output-map)
    #_private
    (ยง field- #_"StoredBlock" :chain-head)
    #_private
    (ยง field- #_"StoredBlock" :verified-chain-head)
    #_private
    (ยง field- #_"int" :full-store-depth)
    #_private
    (ยง field- #_"NetworkParameters" :params)

    ;;;
     ; Set up the MemoryFullPrunedBlockStore.
     ; @param params The network parameters of this block store - used to get genesis block.
     ; @param fullStoreDepth The depth of blocks to keep FullStoredBlocks instead of StoredBlocks.
     ;;
    #_public
    (ยง constructor MemoryFullPrunedBlockStore [#_"NetworkParameters" __params, #_"int" __fullStoreDepth]
        (ยง assoc this :block-map (TransactionalHashMap. #_"<>"))
        (ยง assoc this :full-block-map (TransactionalMultiKeyHashMap. #_"<>"))
        (ยง assoc this :transaction-output-map (TransactionalHashMap. #_"<>"))
        (ยง assoc this :full-store-depth (if (< 0 __fullStoreDepth) __fullStoreDepth 1))
        ;; Insert the genesis block.
        (try
            (let [#_"StoredBlock" __storedGenesisHeader (StoredBlock. (.. __params (getGenesisBlock) (cloneAsHeader)), (.. __params (getGenesisBlock) (getWork)), 0)]
                ;; The coinbase in the genesis block is not spendable.
                (let [#_"List<Transaction>" __genesisTransactions (Lists/newLinkedList)
                      #_"StoredUndoableBlock" __storedGenesis (StoredUndoableBlock. (.. __params (getGenesisBlock) (getHash)), __genesisTransactions)]
                    (.. this (put __storedGenesisHeader, __storedGenesis))
                    (.. this (setChainHead __storedGenesisHeader))
                    (.. this (setVerifiedChainHead __storedGenesisHeader))
                    (ยง assoc this :params __params)
                )
            )
            (catch BlockStoreException __e
                (throw (RuntimeException. __e)) ;; Cannot happen.
            )
            (catch VerificationException __e
                (throw (RuntimeException. __e)) ;; Cannot happen.
            )
        )
        this
    )

    #_override
    #_public
    #_synchronized
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" put [#_"StoredBlock" __block]
        (Preconditions/checkNotNull (:block-map this), "MemoryFullPrunedBlockStore is closed")
        (let [#_"Sha256Hash" __hash (.. __block (getHeader) (getHash))]
            (.. (:block-map this) (put __hash, (MemoryFullPrunedBlockStore.StoredBlockAndWasUndoableFlag. __block, false)))
            nil
        )
    )

    #_override
    #_public
    #_synchronized
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" put [#_"StoredBlock" __storedBlock, #_"StoredUndoableBlock" __undoableBlock]
        (Preconditions/checkNotNull (:block-map this), "MemoryFullPrunedBlockStore is closed")
        (let [#_"Sha256Hash" __hash (.. __storedBlock (getHeader) (getHash))]
            (.. (:full-block-map this) (put __hash, (.. __storedBlock (getHeight)), __undoableBlock))
            (.. (:block-map this) (put __hash, (MemoryFullPrunedBlockStore.StoredBlockAndWasUndoableFlag. __storedBlock, true)))
            nil
        )
    )

    #_override
    #_nilable
    #_public
    #_synchronized
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" get [#_"Sha256Hash" __hash]
        (Preconditions/checkNotNull (:block-map this), "MemoryFullPrunedBlockStore is closed")
        (let [#_"MemoryFullPrunedBlockStore.StoredBlockAndWasUndoableFlag" __storedBlock (.. (:block-map this) (get __hash))]
            (when (some? __storedBlock) (:block __storedBlock))
        )
    )

    #_override
    #_nilable
    #_public
    #_synchronized
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" getOnceUndoableStoredBlock [#_"Sha256Hash" __hash]
        (Preconditions/checkNotNull (:block-map this), "MemoryFullPrunedBlockStore is closed")
        (let [#_"MemoryFullPrunedBlockStore.StoredBlockAndWasUndoableFlag" __storedBlock (.. (:block-map this) (get __hash))]
            (when (and (some? __storedBlock) (:was-undoable __storedBlock)) (:block __storedBlock))
        )
    )

    #_override
    #_nilable
    #_public
    #_synchronized
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredUndoableBlock" getUndoBlock [#_"Sha256Hash" __hash]
        (Preconditions/checkNotNull (:full-block-map this), "MemoryFullPrunedBlockStore is closed")
        (.. (:full-block-map this) (get __hash))
    )

    #_override
    #_public
    #_synchronized
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" getChainHead []
        (Preconditions/checkNotNull (:block-map this), "MemoryFullPrunedBlockStore is closed")
        (:chain-head this)
    )

    #_override
    #_public
    #_synchronized
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" setChainHead [#_"StoredBlock" __chainHead]
        (Preconditions/checkNotNull (:block-map this), "MemoryFullPrunedBlockStore is closed")
        (ยง assoc this :chain-head __chainHead)
        nil
    )

    #_override
    #_public
    #_synchronized
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" getVerifiedChainHead []
        (Preconditions/checkNotNull (:block-map this), "MemoryFullPrunedBlockStore is closed")
        (:verified-chain-head this)
    )

    #_override
    #_public
    #_synchronized
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" setVerifiedChainHead [#_"StoredBlock" __chainHead]
        (Preconditions/checkNotNull (:block-map this), "MemoryFullPrunedBlockStore is closed")
        (ยง assoc this :verified-chain-head __chainHead)
        (when (< (.. (:chain-head this) (getHeight)) (.. __chainHead (getHeight)))
            (.. this (setChainHead __chainHead))
        )
        ;; Potential leak here if not all blocks get setChainHead'd.
        ;; Though the FullPrunedBlockStore allows for this, the current AbstractBlockChain will not do it.
        (.. (:full-block-map this) (removeByMultiKey (- (.. __chainHead (getHeight)) (:full-store-depth this))))
        nil
    )

    #_override
    #_public
    (ยง method #_"void" close []
        (ยง assoc this :block-map nil)
        (ยง assoc this :full-block-map nil)
        (ยง assoc this :transaction-output-map nil)
        nil
    )

    #_override
    #_nilable
    #_public
    #_synchronized
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"UTXO" getTransactionOutput [#_"Sha256Hash" __hash, #_"long" __index]
        (Preconditions/checkNotNull (:transaction-output-map this), "MemoryFullPrunedBlockStore is closed")
        (.. (:transaction-output-map this) (get (StoredTransactionOutPoint. __hash, __index)))
    )

    #_override
    #_public
    #_synchronized
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" addUnspentTransactionOutput [#_"UTXO" __out]
        (Preconditions/checkNotNull (:transaction-output-map this), "MemoryFullPrunedBlockStore is closed")
        (.. (:transaction-output-map this) (put (StoredTransactionOutPoint. __out), __out))
        nil
    )

    #_override
    #_public
    #_synchronized
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" removeUnspentTransactionOutput [#_"UTXO" __out]
        (Preconditions/checkNotNull (:transaction-output-map this), "MemoryFullPrunedBlockStore is closed")
        (when (nil? (.. (:transaction-output-map this) (remove (StoredTransactionOutPoint. __out))))
            (throw (BlockStoreException. "Tried to remove a UTXO from MemoryFullPrunedBlockStore that it didn't have!"))
        )
        nil
    )

    #_override
    #_public
    #_synchronized
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" beginDatabaseBatchWrite []
        (.. (:block-map this) (beginDatabaseBatchWrite))
        (.. (:full-block-map this) (beginTransaction))
        (.. (:transaction-output-map this) (beginDatabaseBatchWrite))
        nil
    )

    #_override
    #_public
    #_synchronized
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" commitDatabaseBatchWrite []
        (.. (:block-map this) (commitDatabaseBatchWrite))
        (.. (:full-block-map this) (commitTransaction))
        (.. (:transaction-output-map this) (commitDatabaseBatchWrite))
        nil
    )

    #_override
    #_public
    #_synchronized
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" abortDatabaseBatchWrite []
        (.. (:block-map this) (abortDatabaseBatchWrite))
        (.. (:full-block-map this) (abortTransaction))
        (.. (:transaction-output-map this) (abortDatabaseBatchWrite))
        nil
    )

    #_override
    #_public
    #_synchronized
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"boolean" hasUnspentOutputs [#_"Sha256Hash" __hash, #_"int" __numOutputs]
        (loop-when-recur [#_"int" __i 0] (< __i __numOutputs) [(inc __i)]
            (when (some? (.. this (getTransactionOutput __hash, __i)))
                (ยง return true)
            )
        )
        false
    )

    #_override
    #_public
    (ยง method #_"NetworkParameters" getParams []
        (:params this)
    )
)

;;;
 ; <p>A full pruned block store using the Postgres database engine.  As an added bonus an address index is calculated,
 ; so you can use {@link #calculateBalanceForAddress(org.bitcoinj.core.Address)} to quickly look up
 ; the quantity of bitcoins controlled by that address.</p>
 ;;
#_public
(ยง class PostgresFullPrunedBlockStore (ยง extends DatabaseFullPrunedBlockStore)
    #_private
    #_static
    (ยง def- #_"Logger" PostgresFullPrunedBlockStore/log (LoggerFactory/getLogger PostgresFullPrunedBlockStore))

    #_private
    #_static
    (ยง def- #_"String" PostgresFullPrunedBlockStore/POSTGRES_DUPLICATE_KEY_ERROR_CODE "23505")
    #_private
    #_static
    (ยง def- #_"String" PostgresFullPrunedBlockStore/DATABASE_DRIVER_CLASS "org.postgresql.Driver")
    #_private
    #_static
    (ยง def- #_"String" PostgresFullPrunedBlockStore/DATABASE_CONNECTION_URL_PREFIX "jdbc:postgresql://")

    ;; create table SQL
    #_private
    #_static
    (ยง def- #_"String" PostgresFullPrunedBlockStore/CREATE_SETTINGS_TABLE (str "CREATE TABLE settings ("
            "name character varying(32) NOT NULL, "
            "value bytea, "
            "CONSTRAINT setting_pk PRIMARY KEY (name)"
            ")"))

    #_private
    #_static
    (ยง def- #_"String" PostgresFullPrunedBlockStore/CREATE_HEADERS_TABLE (str "CREATE TABLE headers ("
            "hash bytea NOT NULL, "
            "chainwork bytea NOT NULL, "
            "height integer NOT NULL, "
            "header bytea NOT NULL, "
            "wasundoable boolean NOT NULL, "
            "CONSTRAINT headers_pk PRIMARY KEY (hash)"
            ")"))

    #_private
    #_static
    (ยง def- #_"String" PostgresFullPrunedBlockStore/CREATE_UNDOABLE_TABLE (str "CREATE TABLE undoableblocks ("
            "hash bytea NOT NULL, "
            "height integer NOT NULL, "
            "txoutchanges bytea, "
            "transactions bytea, "
            "CONSTRAINT undoableblocks_pk PRIMARY KEY (hash)"
            ")"))

    #_private
    #_static
    (ยง def- #_"String" PostgresFullPrunedBlockStore/CREATE_OPEN_OUTPUT_TABLE (str "CREATE TABLE openoutputs ("
            "hash bytea NOT NULL, "
            "index integer NOT NULL, "
            "height integer NOT NULL, "
            "value bigint NOT NULL, "
            "scriptbytes bytea NOT NULL, "
            "toaddress character varying(35), "
            "addresstargetable smallint, "
            "coinbase boolean, "
            "CONSTRAINT openoutputs_pk PRIMARY KEY (hash, index)"
            ")"))

    ;; Some indexes to speed up inserts.
    #_private
    #_static
    (ยง def- #_"String" PostgresFullPrunedBlockStore/CREATE_OUTPUTS_ADDRESS_MULTI_INDEX "CREATE INDEX openoutputs_hash_index_num_height_toaddress_idx ON openoutputs USING btree (hash, index, height, toaddress)")
    #_private
    #_static
    (ยง def- #_"String" PostgresFullPrunedBlockStore/CREATE_OUTPUTS_TOADDRESS_INDEX "CREATE INDEX openoutputs_toaddress_idx ON openoutputs USING btree (toaddress)")
    #_private
    #_static
    (ยง def- #_"String" PostgresFullPrunedBlockStore/CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX "CREATE INDEX openoutputs_addresstargetable_idx ON openoutputs USING btree (addresstargetable)")
    #_private
    #_static
    (ยง def- #_"String" PostgresFullPrunedBlockStore/CREATE_OUTPUTS_HASH_INDEX "CREATE INDEX openoutputs_hash_idx ON openoutputs USING btree (hash)")
    #_private
    #_static
    (ยง def- #_"String" PostgresFullPrunedBlockStore/CREATE_UNDOABLE_TABLE_INDEX "CREATE INDEX undoableblocks_height_idx ON undoableBlocks USING btree (height)")

    #_private
    #_static
    (ยง def- #_"String" PostgresFullPrunedBlockStore/SELECT_UNDOABLEBLOCKS_EXISTS_SQL "select 1 from undoableblocks where hash = ?")

    ;;;
     ; Creates a new PostgresFullPrunedBlockStore.
     ;
     ; @param params A copy of the NetworkParameters used.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param hostname The hostname of the database to connect to.
     ; @param dbName The database to connect to.
     ; @param username The database username.
     ; @param password The password to the database.
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor PostgresFullPrunedBlockStore [#_"NetworkParameters" __params, #_"int" __fullStoreDepth, #_"String" __hostname, #_"String" __dbName, #_"String" __username, #_"String" __password]
        (ยง super __params, (str PostgresFullPrunedBlockStore/DATABASE_CONNECTION_URL_PREFIX __hostname "/" __dbName), __fullStoreDepth, __username, __password, nil)
        this
    )

    ;;;
     ; <p>Create a new PostgresFullPrunedBlockStore, storing the tables in the schema specified.  You may want to
     ; specify a schema to avoid name collisions, or just to keep the database better organized.  The schema is not
     ; required, and if one is not provided than the default schema for the username will be used.  See
     ; <a href="http://www.postgres.org/docs/9.3/static/ddl-schemas.html">the postgres schema docs</a>
     ; for more on schemas.</p>
     ;
     ; @param params A copy of the NetworkParameters used.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param hostname The hostname of the database to connect to.
     ; @param dbName The database to connect to.
     ; @param username The database username.
     ; @param password The password to the database.
     ; @param schemaName The name of the schema to put the tables in.  May be null if no schema is being used.
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor PostgresFullPrunedBlockStore [#_"NetworkParameters" __params, #_"int" __fullStoreDepth, #_"String" __hostname, #_"String" __dbName, #_"String" __username, #_"String" __password, #_nilable #_"String" __schemaName]
        (ยง super __params, (str PostgresFullPrunedBlockStore/DATABASE_CONNECTION_URL_PREFIX __hostname "/" __dbName), __fullStoreDepth, __username, __password, __schemaName)
        this
    )

    #_override
    #_protected
    (ยง method #_"String" getDuplicateKeyErrorCode []
        PostgresFullPrunedBlockStore/POSTGRES_DUPLICATE_KEY_ERROR_CODE
    )

    #_override
    #_protected
    (ยง method #_"List<String>" getCreateTablesSQL []
        (let [#_"List<String>" __sql (ArrayList. #_"<>")]
            (.. __sql (add PostgresFullPrunedBlockStore/CREATE_SETTINGS_TABLE))
            (.. __sql (add PostgresFullPrunedBlockStore/CREATE_HEADERS_TABLE))
            (.. __sql (add PostgresFullPrunedBlockStore/CREATE_UNDOABLE_TABLE))
            (.. __sql (add PostgresFullPrunedBlockStore/CREATE_OPEN_OUTPUT_TABLE))
            __sql
        )
    )

    #_override
    #_protected
    (ยง method #_"List<String>" getCreateIndexesSQL []
        (let [#_"List<String>" __sql (ArrayList. #_"<>")]
            (.. __sql (add PostgresFullPrunedBlockStore/CREATE_UNDOABLE_TABLE_INDEX))
            (.. __sql (add PostgresFullPrunedBlockStore/CREATE_OUTPUTS_ADDRESS_MULTI_INDEX))
            (.. __sql (add PostgresFullPrunedBlockStore/CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX))
            (.. __sql (add PostgresFullPrunedBlockStore/CREATE_OUTPUTS_HASH_INDEX))
            (.. __sql (add PostgresFullPrunedBlockStore/CREATE_OUTPUTS_TOADDRESS_INDEX))
            __sql
        )
    )

    #_override
    #_protected
    (ยง method #_"List<String>" getCreateSchemeSQL []
        (let [#_"List<String>" __sql (ArrayList. #_"<>")]
            (.. __sql (add (str "CREATE SCHEMA IF NOT EXISTS " (:schema-name this))))
            (.. __sql (add (str "set search_path to '" (:schema-name this) "'")))
            __sql
        )
    )

    #_override
    #_protected
    (ยง method #_"String" getDatabaseDriverClass []
        PostgresFullPrunedBlockStore/DATABASE_DRIVER_CLASS
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" put [#_"StoredBlock" __storedBlock, #_"StoredUndoableBlock" __undoableBlock]
        (.. this (maybeConnect))
        ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
        (let [#_"byte[]" __hashBytes (byte-array 28)]
            (System/arraycopy (.. __storedBlock (getHeader) (getHash) (getBytes)), 4, __hashBytes, 0, 28)
            (let [#_"int" __height (.. __storedBlock (getHeight))
                  #_"byte[]" __transactions nil
                  #_"byte[]" __txOutChanges nil]
                (try
                    (let [#_"ByteArrayOutputStream" __bos (ByteArrayOutputStream.)]
                        (cond (some? (.. __undoableBlock (getTxOutChanges)))
                            (do
                                (.. __undoableBlock (getTxOutChanges) (serializeToStream __bos))
                                (ยง ass __txOutChanges (.. __bos (toByteArray)))
                            )
                            :else
                            (do
                                (let [#_"int" __numTxn (.. __undoableBlock (getTransactions) (size))]
                                    (.. __bos (write (& 0xff __numTxn)))
                                    (.. __bos (write (& 0xff (>> __numTxn 8))))
                                    (.. __bos (write (& 0xff (>> __numTxn 16))))
                                    (.. __bos (write (& 0xff (>> __numTxn 24))))
                                    (doseq [#_"Transaction" __tx (.. __undoableBlock (getTransactions))]
                                        (.. __tx (bitcoinSerialize __bos))
                                    )
                                    (ยง ass __transactions (.. __bos (toByteArray)))
                                )
                            )
                        )
                        (.. __bos (close))
                    )
                    (catch IOException __e
                        (throw (BlockStoreException. __e))
                    )
                )

                (try
                    (when (.. PostgresFullPrunedBlockStore/log (isDebugEnabled))
                        (.. PostgresFullPrunedBlockStore/log (debug (str "Looking for undoable block with hash: " (.. Utils/HEX (encode __hashBytes)))))
                    )

                    (let [#_"PreparedStatement" __findS (.. (:conn this) (get) (prepareStatement PostgresFullPrunedBlockStore/SELECT_UNDOABLEBLOCKS_EXISTS_SQL))]
                        (.. __findS (setBytes 1, __hashBytes))

                        (let [#_"ResultSet" __rs (.. __findS (executeQuery))]
                            (when (.. __rs (next))
                                ;; We already have this output, update it.
                                (.. __findS (close))

                                ;; Postgres insert-or-updates are very complex (and finnicky).
                                ;; This level of transaction isolation seems to work for bitcoinj.
                                (let [#_"PreparedStatement" __ps (.. (:conn this) (get) (prepareStatement (.. this (getUpdateUndoableBlocksSQL))))]
                                    (.. __ps (setBytes 3, __hashBytes))

                                    (when (.. PostgresFullPrunedBlockStore/log (isDebugEnabled))
                                        (.. PostgresFullPrunedBlockStore/log (debug (str "Updating undoable block with hash: " (.. Utils/HEX (encode __hashBytes)))))
                                    )

                                    (cond (nil? __transactions)
                                        (do
                                            (.. __ps (setBytes 1, __txOutChanges))
                                            (.. __ps (setNull 2, Types/BINARY))
                                        )
                                        :else
                                        (do
                                            (.. __ps (setNull 1, Types/BINARY))
                                            (.. __ps (setBytes 2, __transactions))
                                        )
                                    )
                                    (.. __ps (executeUpdate))
                                    (.. __ps (close))

                                    (ยง return nil)
                                )
                            )

                            (let [#_"PreparedStatement" __ps (.. (:conn this) (get) (prepareStatement (.. this (getInsertUndoableBlocksSQL))))]
                                (.. __ps (setBytes 1, __hashBytes))
                                (.. __ps (setInt 2, __height))

                                (when (.. PostgresFullPrunedBlockStore/log (isDebugEnabled))
                                    (.. PostgresFullPrunedBlockStore/log (debug (str "Inserting undoable block with hash: " (.. Utils/HEX (encode __hashBytes))  " at height " __height)))
                                )

                                (cond (nil? __transactions)
                                    (do
                                        (.. __ps (setBytes 3, __txOutChanges))
                                        (.. __ps (setNull 4, Types/BINARY))
                                    )
                                    :else
                                    (do
                                        (.. __ps (setNull 3, Types/BINARY))
                                        (.. __ps (setBytes 4, __transactions))
                                    )
                                )
                                (.. __ps (executeUpdate))
                                (.. __ps (close))
                                (try
                                    (.. this (putUpdateStoredBlock __storedBlock, true))
                                    (catch SQLException __e
                                        (throw (BlockStoreException. __e))
                                    )
                                )
                            )
                        )
                    )
                    (catch SQLException __e
                        (when (not (.. __e (getSQLState) (equals PostgresFullPrunedBlockStore/POSTGRES_DUPLICATE_KEY_ERROR_CODE)))
                            (throw (BlockStoreException. __e))
                        )
                    )
                )
                nil
            )
        )
    )
)

;; TODO: Lose the mmap in this class.  There are too many platform bugs that require odd workarounds.

;;;
 ; An SPVBlockStore holds a limited number of block headers in a memory mapped ring buffer.  With such a store,
 ; you may not be able to process very deep re-orgs and could be disconnected from the chain (requiring a replay),
 ; but as they are virtually unheard of this is not a significant risk.
 ;;
#_public
(ยง class SPVBlockStore (ยง implements BlockStore)
    #_private
    #_static
    (ยง def- #_"Logger" SPVBlockStore/log (LoggerFactory/getLogger SPVBlockStore))

    ;;; The default number of headers that will be stored in the ring buffer. ;;
    #_public
    #_static
    (ยง def #_"int" SPVBlockStore/DEFAULT_CAPACITY 5000)
    #_public
    #_static
    (ยง def #_"String" SPVBlockStore/HEADER_MAGIC "SPVB")

    #_protected
    #_volatile
    (ยง field #_"MappedByteBuffer" :buffer)
    #_protected
    (ยง field #_"int" :capacity)
    #_protected
    (ยง field #_"NetworkParameters" :params)

    #_protected
    (ยง field #_"ReentrantLock" :lock (Threading/lock "SPVBlockStore"))

    ;; The entire ring-buffer is mmapped and accessing it should be as fast as accessing regular memory once it's
    ;; faulted in.  Unfortunately, in theory practice and theory are the same.  In practice they aren't.
    ;;
    ;; MMapping a file in Java does not give us a byte[] as you may expect but rather a ByteBuffer, and whilst on
    ;; the OpenJDK/Oracle JVM calls into the get() methods are compiled down to inlined native code on Android each
    ;; get() call is actually a full-blown JNI method under the hood, meaning it's unbelievably slow.  The caches
    ;; below let us stay in the JIT-compiled Java world without expensive JNI transitions and make a 10x difference!
    #_protected
    (ยง field #_"LinkedHashMap<Sha256Hash, StoredBlock>" :block-cache (LinkedHashMap. #_"<Sha256Hash, StoredBlock>"
        (ยง anon
            #_override
            #_protected
            (ยง method #_"boolean" removeEldestEntry [#_"Map.Entry<Sha256Hash, StoredBlock>" __entry]
                (< 2050 (.. this (size))) ;; Slightly more than the difficulty transition period.
            )
        )))

    ;; Use a separate cache to track get() misses.  This is to efficiently handle the case of an unconnected block
    ;; during chain download.  Each new block will do a get() on the unconnected block so if we haven't seen it yet
    ;; we must efficiently respond.
    ;;
    ;; We don't care about the value in this cache.  It is always notFoundMarker.  Unfortunately LinkedHashSet does
    ;; not provide the removeEldestEntry control.
    #_private
    #_static
    (ยง def- #_"Object" SPVBlockStore/NOT_FOUND_MARKER (Object.))
    #_protected
    (ยง field #_"LinkedHashMap<Sha256Hash, Object>" :not-found-cache (LinkedHashMap. #_"<Sha256Hash, Object>"
        (ยง anon
            #_override
            #_protected
            (ยง method #_"boolean" removeEldestEntry [#_"Map.Entry<Sha256Hash, Object>" __entry]
                (< 100 (.. this (size))) ;; This was chosen arbitrarily.
            )
        )))

    ;; Used to stop other applications/processes from opening the store.
    #_protected
    (ยง field #_"FileLock" :file-lock)
    #_protected
    (ยง field #_"RandomAccessFile" :random-access-file)

    ;;;
     ; Creates and initializes an SPV block store that can hold {@link #DEFAULT_CAPACITY} blocks.
     ; Will create the given file if it's missing.  This operation will block on disk.
     ; @param file File to use for the block store.
     ; @throws BlockStoreException if something goes wrong.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor SPVBlockStore [#_"NetworkParameters" __params, #_"File" __file]
        (ยง this __params, __file, SPVBlockStore/DEFAULT_CAPACITY)
        this
    )

    ;;;
     ; Creates and initializes an SPV block store that can hold a given amount of blocks.
     ; Will create the given file if it's missing.  This operation will block on disk.
     ; @param file File to use for the block store.
     ; @param capacity Custom capacity.
     ; @throws BlockStoreException if something goes wrong.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง constructor SPVBlockStore [#_"NetworkParameters" __params, #_"File" __file, #_"int" __capacity]
        (Preconditions/checkNotNull __file)
        (ยง assoc this :params (Preconditions/checkNotNull __params))
        (Preconditions/checkArgument (> __capacity 0))

        (ยง assoc this :capacity __capacity)
        (try
            (let [#_"boolean" __exists (.. __file (exists))]
                ;; Set up the backing file.
                (ยง assoc this :random-access-file (RandomAccessFile. __file, "rw"))
                (let [#_"long" __fileSize (SPVBlockStore/getFileSize __capacity)]
                    (cond (not __exists)
                        (do
                            (.. SPVBlockStore/log (info (str "Creating new SPV block chain file " __file)))
                            (.. (:random-access-file this) (setLength __fileSize))
                        )
                        (!= (.. (:random-access-file this) (length)) __fileSize)
                        (do
                            (throw (BlockStoreException. (str "File size on disk does not match expected size: " (.. (:random-access-file this) (length)) " vs " __fileSize)))
                        )
                    )

                    (let [#_"FileChannel" __channel (.. (:random-access-file this) (getChannel))]
                        (ยง assoc this :file-lock (.. __channel (tryLock)))
                        (when (nil? (:file-lock this))
                            (throw (ChainFileLockedException. "Store file is already locked by another process"))
                        )

                        ;; Map it into memory read/write.  The kernel will take care of flushing writes to disk at the most
                        ;; efficient times, which may mean that until the map is deallocated the data on disk is randomly
                        ;; inconsistent.  However the only process accessing it is us, via this mapping, so our own view will
                        ;; always be correct.  Once we establish the mmap the underlying file and channel can go away.  Note
                        ;; that the details of mmapping vary between platforms.
                        (ยง assoc this :buffer (.. __channel (map FileChannel.MapMode/READ_WRITE, 0, __fileSize)))

                        ;; Check or initialize the header bytes to ensure we don't try to open some random file.
                        (let [#_"byte[]" __header]
                            (cond __exists
                                (do
                                    (ยง ass __header (byte-array 4))
                                    (.. (:buffer this) (get __header))
                                    (when (not (.. (String. __header, Charsets/US_ASCII) (equals SPVBlockStore/HEADER_MAGIC)))
                                        (throw (BlockStoreException. (str "Header bytes do not equal " SPVBlockStore/HEADER_MAGIC)))
                                    )
                                )
                                :else
                                (do
                                    (.. this (initNewStore __params))
                                )
                            )
                        )
                    )
                )
            )
            (catch Exception __e1
                (try
                    (when (some? (:random-access-file this))
                        (.. (:random-access-file this) (close))
                    )
                    (catch IOException __e2
                        (throw (BlockStoreException. __e2))
                    )
                )
                (throw (BlockStoreException. __e1))
            )
        )
        this
    )

    #_private
    #_throws #_[ "Exception" ]
    (ยง method- #_"void" initNewStore [#_"NetworkParameters" __params]
        (let [#_"byte[]" __header (.. SPVBlockStore/HEADER_MAGIC (getBytes "US-ASCII"))]
            (.. (:buffer this) (put __header))
            ;; Insert the genesis block.
            (.. (:lock this) (lock))
            (try
                (.. this (setRingCursor (:buffer this), SPVBlockStore/FILE_PROLOGUE_BYTES))
                (finally
                    (.. (:lock this) (unlock))
                )
            )
            (let [#_"Block" __genesis (.. __params (getGenesisBlock) (cloneAsHeader))
                  #_"StoredBlock" __storedGenesis (StoredBlock. __genesis, (.. __genesis (getWork)), 0)]
                (.. this (put __storedGenesis))
                (.. this (setChainHead __storedGenesis))
                nil
            )
        )
    )

    ;;; Returns the size in bytes of the file that is used to store the chain with the current parameters. ;;
    #_public
    #_static
    (ยง defn #_"int" SPVBlockStore/getFileSize [#_"int" __capacity]
        (+ (* SPVBlockStore/RECORD_SIZE __capacity) SPVBlockStore/FILE_PROLOGUE_BYTES) ;; extra kilobyte for stuff
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" put [#_"StoredBlock" __block]
        (let [#_"MappedByteBuffer" __buffer (:buffer this)]
            (when (nil? __buffer)
                (throw (BlockStoreException. "Store closed"))
            )

            (.. (:lock this) (lock))
            (try
                (let [#_"int" __cursor (.. this (getRingCursor __buffer))]
                    ;; Wrapped around.
                    (when (== __cursor (SPVBlockStore/getFileSize (:capacity this)))
                        (ยง ass __cursor SPVBlockStore/FILE_PROLOGUE_BYTES)
                    )
                    (.. __buffer (position __cursor))
                    (let [#_"Sha256Hash" __hash (.. __block (getHeader) (getHash))]
                        (.. (:not-found-cache this) (remove __hash))
                        (.. __buffer (put (.. __hash (getBytes))))
                        (.. __block (serializeCompact __buffer))
                        (.. this (setRingCursor __buffer, (.. __buffer (position))))
                        (.. (:block-cache this) (put __hash, __block))
                    )
                )
                (finally
                    (.. (:lock this) (unlock))
                )
            )
            nil
        )
    )

    #_override
    #_nilable
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" get [#_"Sha256Hash" __hash]
        (let [#_"MappedByteBuffer" __buffer (:buffer this)]
            (when (nil? __buffer)
                (throw (BlockStoreException. "Store closed"))
            )

            (.. (:lock this) (lock))
            (try
                (let [#_"StoredBlock" __cacheHit (.. (:block-cache this) (get __hash))]
                    (when (some? __cacheHit)
                        (ยง return __cacheHit)
                    )
                    (when (some? (.. (:not-found-cache this) (get __hash)))
                        (ยง return nil)
                    )

                    ;; Starting from the current tip of the ring work backwards until we have either
                    ;; found the block or wrapped around.
                    (let [#_"int" __cursor (.. this (getRingCursor __buffer))
                          #_"int" __startingPoint __cursor
                          #_"int" __fileSize (SPVBlockStore/getFileSize (:capacity this))
                          #_"byte[]" __targetHashBytes (.. __hash (getBytes))
                          #_"byte[]" __scratch (byte-array 32)]
                        (ยง repeat
                            (ยง ass __cursor (- __cursor SPVBlockStore/RECORD_SIZE))
                            ;; We hit the start, so wrap around.
                            (when (< __cursor SPVBlockStore/FILE_PROLOGUE_BYTES)
                                (ยง ass __cursor (- __fileSize SPVBlockStore/RECORD_SIZE))
                            )
                            ;; Cursor is now at the start of the next record to check, so read the hash and compare it.
                            (.. __buffer (position __cursor))
                            (.. __buffer (get __scratch))
                            (when (Arrays/equals __scratch, __targetHashBytes)
                                ;; Found the target.
                                (let [#_"StoredBlock" __storedBlock (StoredBlock/deserializeCompact (:params this), __buffer)]
                                    (.. (:block-cache this) (put __hash, __storedBlock))
                                    (ยง return __storedBlock)
                                )
                            )
                            (ยง again (!= __cursor __startingPoint))
                        )

                        ;; Not found.
                        (.. (:not-found-cache this) (put __hash, SPVBlockStore/NOT_FOUND_MARKER))
                        (ยง return nil)
                    )
                )
                (catch ProtocolException __e
                    (throw (RuntimeException. __e)) ;; Cannot happen.
                )
                (finally
                    (.. (:lock this) (unlock))
                )
            )
        )
    )

    #_protected
    (ยง field #_"StoredBlock" :last-chain-head)

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"StoredBlock" getChainHead []
        (let [#_"MappedByteBuffer" __buffer (:buffer this)]
            (when (nil? __buffer)
                (throw (BlockStoreException. "Store closed"))
            )

            (.. (:lock this) (lock))
            (try
                (when (nil? (:last-chain-head this))
                    (let [#_"byte[]" __headHash (byte-array 32)]
                        (.. __buffer (position 8))
                        (.. __buffer (get __headHash))
                        (let [#_"Sha256Hash" __hash (Sha256Hash/wrap __headHash)
                              #_"StoredBlock" __block (.. this (get __hash))]
                            (when (nil? __block)
                                (throw (BlockStoreException. (str "Corrupted block store: could not find chain head: " __hash)))
                            )

                            (ยง assoc this :last-chain-head __block)
                        )
                    )
                )
                (:last-chain-head this)
                (finally
                    (.. (:lock this) (unlock))
                )
            )
        )
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" setChainHead [#_"StoredBlock" __chainHead]
        (let [#_"MappedByteBuffer" __buffer (:buffer this)]
            (when (nil? __buffer)
                (throw (BlockStoreException. "Store closed"))
            )

            (.. (:lock this) (lock))
            (try
                (ยง assoc this :last-chain-head __chainHead)
                (let [#_"byte[]" __headHash (.. __chainHead (getHeader) (getHash) (getBytes))]
                    (.. __buffer (position 8))
                    (.. __buffer (put __headHash))
                )
                (finally
                    (.. (:lock this) (unlock))
                )
            )
            nil
        )
    )

    #_override
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" close []
        (try
            (.. (:buffer this) (force))
            (ยง assoc this :buffer nil) ;; Allow it to be GCd and the underlying file mapping to go away.
            (.. (:random-access-file this) (close))
            (catch IOException __e
                (throw (BlockStoreException. __e))
            )
        )
        nil
    )

    #_override
    #_public
    (ยง method #_"NetworkParameters" getParams []
        (:params this)
    )

    #_protected
    #_static
    (ยง def #_"int" SPVBlockStore/RECORD_SIZE (+ 32 StoredBlock/COMPACT_SERIALIZED_SIZE)) ;; hash

    ;; File format:
    ;;   4 header bytes = "SPVB"
    ;;   4 cursor bytes, which indicate the offset from the first kb where the next block header should be written
    ;;   32 bytes for the hash of the chain head
    ;;
    ;; For each header (128 bytes)
    ;;   32 bytes hash of the header
    ;;   12 bytes of chain work
    ;;    4 bytes of height
    ;;   80 bytes of block header data
    #_protected
    #_static
    (ยง def #_"int" SPVBlockStore/FILE_PROLOGUE_BYTES 1024)

    ;;; Returns the offset from the file start where the latest block should be written (end of prev block). ;;
    #_private
    (ยง method- #_"int" getRingCursor [#_"ByteBuffer" __buffer]
        (let [#_"int" __c (.. __buffer (getInt 4))]
            (Preconditions/checkState (<= SPVBlockStore/FILE_PROLOGUE_BYTES __c), "Integer overflow")
            __c
        )
    )

    #_private
    (ยง method- #_"void" setRingCursor [#_"ByteBuffer" __buffer, #_"int" __newCursor]
        (Preconditions/checkArgument (<= 0 __newCursor))
        (.. __buffer (putInt 4, __newCursor))
        nil
    )
)

#_(ns org.bitcoinj.uri #_"BitcoinURI"
    (:import [java.io UnsupportedEncodingException]
             [java.net URI URISyntaxException URLDecoder URLEncoder]
             [java.util ArrayList Collections LinkedHashMap List Locale Map])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.core Address AddressFormatException Coin NetworkParameters]
             [org.bitcoinj.params AbstractBitcoinNetParams]))

#_(ns org.bitcoinj.uri #_"BitcoinURIParseException")

#_(ns org.bitcoinj.uri #_"OptionalFieldValidationException")

#_(ns org.bitcoinj.uri #_"RequiredFieldValidationException")

;;;
 ; <p>Provides a standard implementation of a Bitcoin URI with support for the following:</p>
 ;
 ; <ul>
 ; <li>URLEncoded URIs (as passed in by IE on the command line)</li>
 ; <li>BIP21 names (including the "req-" prefix handling requirements)</li>
 ; </ul>
 ;
 ; <h2>Accepted formats</h2>
 ;
 ; <p>The following input forms are accepted:</p>
 ;
 ; <ul>
 ; <li>{@code bitcoin:<address>}</li>
 ; <li>{@code bitcoin:<address>?<name1>=<value1>&<name2>=<value2>} with multiple additional name/value pairs</li>
 ; </ul>
 ;
 ; <p>The name/value pairs are processed as follows.</p>
 ; <ol>
 ; <li>URL encoding is stripped and treated as UTF-8</li>
 ; <li>names prefixed with {@code req-} are treated as required and if unknown or conflicting cause a parse exception</li>
 ; <li>Unknown names not prefixed with {@code req-} are added to a Map, accessible by parameter name</li>
 ; <li>Known names not prefixed with {@code req-} are processed unless they are malformed</li>
 ; </ol>
 ;
 ; <p>The following names are known and have the following formats:</p>
 ; <ul>
 ; <li>{@code amount} decimal value to 8 dp (e.g. 0.12345678) <b>Note that the exponent notation is not supported any more.</b></li>
 ; <li>{@code label} any URL encoded alphanumeric</li>
 ; <li>{@code message} any URL encoded alphanumeric</li>
 ; </ul>
 ;
 ; @author Andreas Schildbach (initial code)
 ; @author Jim Burton (enhancements for MultiBit)
 ; @author Gary Rowe (BIP21 support)
 ; @see <a href="https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki">BIP 0021</a>
 ;;
#_public
(ยง class BitcoinURI
    ;; Not worth turning into an enum.
    #_public
    #_static
    (ยง def #_"String" BitcoinURI/FIELD_MESSAGE "message")
    #_public
    #_static
    (ยง def #_"String" BitcoinURI/FIELD_LABEL "label")
    #_public
    #_static
    (ยง def #_"String" BitcoinURI/FIELD_AMOUNT "amount")
    #_public
    #_static
    (ยง def #_"String" BitcoinURI/FIELD_ADDRESS "address")
    #_public
    #_static
    (ยง def #_"String" BitcoinURI/FIELD_PAYMENT_REQUEST_URL "r")

    ;;;
     ; URI for Bitcoin network.  Use {@link org.bitcoinj.params.AbstractBitcoinNetParams#BITCOIN_SCHEME}
     ; if you specifically need Bitcoin, or use {@link org.bitcoinj.core.NetworkParameters#getUriScheme}
     ; to get the scheme from network parameters.
     ;;
    #_deprecated
    #_public
    #_static
    (ยง def #_"String" BitcoinURI/BITCOIN_SCHEME "bitcoin")
    #_private
    #_static
    (ยง def- #_"String" BitcoinURI/ENCODED_SPACE_CHARACTER "%20")
    #_private
    #_static
    (ยง def- #_"String" BitcoinURI/AMPERSAND_SEPARATOR "&")
    #_private
    #_static
    (ยง def- #_"String" BitcoinURI/QUESTION_MARK_SEPARATOR "?")

    ;;;
     ; Contains all the parameters in the order in which they were processed.
     ;;
    #_private
    (ยง field- #_"Map<String, Object>" :parameter-map (LinkedHashMap. #_"<>"))

    ;;;
     ; Constructs a new BitcoinURI from the given string.  Can be for any network.
     ;
     ; @param uri The raw URI data to be parsed (see class comments for accepted formats).
     ; @throws BitcoinURIParseException if the URI is not syntactically or semantically valid.
     ;;
    #_public
    #_throws #_[ "BitcoinURIParseException" ]
    (ยง constructor BitcoinURI [#_"String" __uri]
        (ยง this nil, __uri)
        this
    )

    ;;;
     ; Constructs a new object by trying to parse the input as a valid Bitcoin URI.
     ;
     ; @param params The network parameters that determine which network the URI is from, or null if you
     ;               don't have any expectation about what network the URI is for and wish to check yourself.
     ; @param input The raw URI data to be parsed (see class comments for accepted formats).
     ;
     ; @throws BitcoinURIParseException if the input fails Bitcoin URI syntax and semantic checks.
     ;;
    #_public
    #_throws #_[ "BitcoinURIParseException" ]
    (ยง constructor BitcoinURI [#_nilable #_"NetworkParameters" __params, #_"String" __input]
        (Preconditions/checkNotNull __input)

        (let [#_"String" __scheme (if (some? __params) (.. __params (getUriScheme)) AbstractBitcoinNetParams/BITCOIN_SCHEME)]

            ;; Attempt to form the URI (fail fast syntax checking to official standards).
            (let [#_"URI" __uri]
                (try
                    (ยง ass __uri (URI. __input))
                    (catch URISyntaxException __e
                        (throw (BitcoinURIParseException. "Bad URI syntax", __e))
                    )
                )

                ;; URI is formed as  bitcoin:<address>?<query parameters>
                ;; blockchain.info generates URIs of non-BIP compliant form bitcoin://address?....
                ;; We support both until Ben fixes his code.

                ;; Remove the bitcoin scheme.
                ;; (Note: getSchemeSpecificPart() is not used as it unescapes the label and parse then fails.
                ;; For instance with  bitcoin:129mVqKUmJ9uwPxKJBnNdABbuaaNfho4Ha?amount=0.06&label=Tom%20%26%20Jerry
                ;; the & (%26) in Tom and Jerry gets interpreted as a separator and the label then gets parsed
                ;; as 'Tom ' instead of 'Tom & Jerry'.)
                (let [#_"String" __blockchainInfoScheme (str __scheme "://")
                      #_"String" __correctScheme (str __scheme ":")
                      #_"String" __schemeSpecificPart]
                    (cond
                        (.. __input (startsWith __blockchainInfoScheme))
                            (ยง ass __schemeSpecificPart (.. __input (substring (.. __blockchainInfoScheme (length)))))
                        (.. __input (startsWith __correctScheme))
                            (ยง ass __schemeSpecificPart (.. __input (substring (.. __correctScheme (length)))))
                        :else
                            (throw (BitcoinURIParseException. (str "Unsupported URI scheme: " (.. __uri (getScheme)))))
                    )

                    ;; Split off the address from the rest of the query parameters.
                    (let [#_"String[]" __addressSplitTokens (.. __schemeSpecificPart (split "\\?", 2))]
                        (when (== (.. __addressSplitTokens (alength)) 0)
                            (throw (BitcoinURIParseException. "No data found after the bitcoin: prefix"))
                        )

                        (let [#_"String" __addressToken (aget __addressSplitTokens 0)] ;; may be empty!

                            (let [#_"String[]" __nameValuePairTokens]
                                (if (== (.. __addressSplitTokens (alength)) 1)
                                    ;; Only an address is specified - use an empty '<name>=<value>' token array.
                                    (ยง ass __nameValuePairTokens (make-array String 0))
                                    ;; Split into '<name>=<value>' tokens.
                                    (ยง ass __nameValuePairTokens (.. (aget __addressSplitTokens 1) (split "&")))
                                )

                                ;; Attempt to parse the rest of the URI parameters.
                                (.. this (parseParameters __params, __addressToken, __nameValuePairTokens))

                                (when (not (.. __addressToken (isEmpty)))
                                    ;; Attempt to parse the addressToken as a Bitcoin address for this network.
                                    (try
                                        (let [#_"Address" __address (Address/fromBase58 __params, __addressToken)]
                                            (.. this (putWithValidation BitcoinURI/FIELD_ADDRESS, __address))
                                        )
                                        (catch [#_"AddressFormatException" __e]
                                            (throw (BitcoinURIParseException. "Bad address", __e))
                                        )
                                    )
                                )

                                (when (and (.. __addressToken (isEmpty)) (nil? (.. this (getPaymentRequestUrl))))
                                    (throw (BitcoinURIParseException. "No address and no r= parameter found"))
                                )
                                this
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; @param params The network parameters or null.
     ; @param nameValuePairTokens The tokens representing the name value pairs (assumed to be separated by '=' e.g. 'amount=0.2').
     ;;
    #_private
    #_throws #_[ "BitcoinURIParseException" ]
    (ยง method- #_"void" parseParameters [#_nilable #_"NetworkParameters" __params, #_"String" __addressToken, #_"String[]" __nameValuePairTokens]
        ;; Attempt to decode the rest of the tokens into a parameter map.
        (doseq [#_"String" __nameValuePairToken __nameValuePairTokens]
            (let [#_"int" __sepIndex (.. __nameValuePairToken (indexOf "="))]
                (when (== __sepIndex -1)
                    (throw (BitcoinURIParseException. (str "Malformed Bitcoin URI - no separator in '" __nameValuePairToken "'")))
                )
                (when (== __sepIndex 0)
                    (throw (BitcoinURIParseException. (str "Malformed Bitcoin URI - empty name '" __nameValuePairToken "'")))
                )

                (let [#_"String" __nameToken (.. __nameValuePairToken (substring 0, __sepIndex) (toLowerCase Locale/ENGLISH))
                      #_"String" __valueToken (.. __nameValuePairToken (substring (inc __sepIndex)))]

                    ;; Parse the amount.
                    (cond (.. BitcoinURI/FIELD_AMOUNT (equals __nameToken))
                        (do
                            ;; Decode the amount (contains an optional decimal component to 8dp).
                            (try
                                (let [#_"Coin" __amount (Coin/parseCoin __valueToken)]
                                    (when (and (some? __params) (.. __amount (isGreaterThan (.. __params (getMaxMoney)))))
                                        (throw (BitcoinURIParseException. "Max number of coins exceeded"))
                                    )
                                    (when (< (.. __amount (signum)) 0)
                                        (throw (ArithmeticException. "Negative coins specified"))
                                    )

                                    (.. this (putWithValidation BitcoinURI/FIELD_AMOUNT, __amount))
                                )
                                (catch IllegalArgumentException __e
                                    (throw (OptionalFieldValidationException. (String/format Locale/US, "'%s' is not a valid amount", __valueToken), __e))
                                )
                                (catch ArithmeticException __e
                                    (throw (OptionalFieldValidationException. (String/format Locale/US, "'%s' has too many decimal places", __valueToken), __e))
                                )
                            )
                        )
                        :else
                        (do
                            (when (.. __nameToken (startsWith "req-"))
                                ;; A required parameter that we do not know about.
                                (throw (RequiredFieldValidationException. (str "'" __nameToken "' is required but not known, this URI is not valid")))
                            )

                            ;; Known fields and unknown parameters that are optional.
                            (try
                                (when (< 0 (.. __valueToken (length)))
                                    (.. this (putWithValidation __nameToken, (URLDecoder/decode __valueToken, "UTF-8")))
                                )
                                (catch UnsupportedEncodingException __e
                                    (throw (RuntimeException. __e)) ;; Can't happen.
                                )
                            )
                        )
                    )
                )
            )
        )

        ;; Note to the future:
        ;; when you want to implement 'req-expires', have a look at commit 410a53791841 which had it in.
        nil
    )

    ;;;
     ; Put the value against the key in the map checking for duplication.  This avoids address field overwrite etc.
     ;
     ; @param key The key for the map.
     ; @param value The value to store.
     ;;
    #_private
    #_throws #_[ "BitcoinURIParseException" ]
    (ยง method- #_"void" putWithValidation [#_"String" __key, #_"Object" __value]
        (when (.. (:parameter-map this) (containsKey __key))
            (throw (BitcoinURIParseException. (String/format Locale/US, "'%s' is duplicated, URI is invalid", __key)))
        )

        (.. (:parameter-map this) (put __key, __value))
        nil
    )

    ;;;
     ; The Bitcoin Address from the URI, if one was present.  It's possible to have Bitcoin URI's with no address
     ; if a r= payment protocol parameter is specified, though this form is not recommended as older wallets
     ; can't understand it.
     ;;
    #_nilable
    #_public
    (ยง method #_"Address" getAddress []
        (cast Address (.. (:parameter-map this) (get BitcoinURI/FIELD_ADDRESS)))
    )

    ;;;
     ; @return The amount name encoded using a pure integer value based at 10,000,000 units is 1 BTC.
     ;         May be null if no amount is specified.
     ;;
    #_public
    (ยง method #_"Coin" getAmount []
        (cast Coin (.. (:parameter-map this) (get BitcoinURI/FIELD_AMOUNT)))
    )

    ;;;
     ; @return the label from the URI.
     ;;
    #_public
    (ยง method #_"String" getLabel []
        (cast String (.. (:parameter-map this) (get BitcoinURI/FIELD_LABEL)))
    )

    ;;;
     ; @return the message from the URI.
     ;;
    #_public
    (ยง method #_"String" getMessage []
        (cast String (.. (:parameter-map this) (get BitcoinURI/FIELD_MESSAGE)))
    )

    ;;;
     ; @return the URL where a payment request (as specified in BIP 70) may be fetched.
     ;;
    #_public
    (ยง method #_"String" getPaymentRequestUrl []
        (cast String (.. (:parameter-map this) (get BitcoinURI/FIELD_PAYMENT_REQUEST_URL)))
    )

    ;;;
     ; Returns the URLs where a payment request (as specified in BIP 70) may be fetched.
     ; The first URL is the main URL, all subsequent URLs are fallbacks.
     ;;
    #_public
    (ยง method #_"List<String>" getPaymentRequestUrls []
        (let [#_"ArrayList<String>" __urls (ArrayList. #_"<>")]
            (loop []
                (let [#_"int" __i (.. __urls (size))
                      #_"String" __paramName (str BitcoinURI/FIELD_PAYMENT_REQUEST_URL (if (< 0 __i) (Integer/toString __i) ""))
                      #_"String" __url (cast String (.. (:parameter-map this) (get __paramName)))]
                    (when (nil? __url)
                        (ยง break )
                    )
                    (.. __urls (add __url))
                )
            )
            (Collections/reverse __urls)
            __urls
        )
    )

    ;;;
     ; @param name The name of the parameter.
     ; @return the parameter value, or null if not present.
     ;;
    #_public
    (ยง method #_"Object" getParameterByName [#_"String" __name]
        (.. (:parameter-map this) (get __name))
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (let [#_"StringBuilder" __sb (StringBuilder. "BitcoinURI[")
              #_"boolean" __first true]
            (doseq [#_"Map.Entry<String, Object>" __entry (.. (:parameter-map this) (entrySet))]
                (if __first
                    (ยง ass __first false)
                    (.. __sb (append ","))
                )
                (.. __sb (append "'") (append (.. __entry (getKey))) (append "'='") (append (.. __entry (getValue))) (append "'"))
            )
            (.. __sb (append "]"))
            (.. __sb (toString))
        )
    )

    ;;;
     ; Simple Bitcoin URI builder using known good fields.
     ;
     ; @param address The Bitcoin address.
     ; @param amount The amount.
     ; @param label A label.
     ; @param message A message.
     ; @return a String containing the Bitcoin URI.
     ;;
    #_public
    #_static
    (ยง defn #_"String" BitcoinURI/convertToBitcoinURI [#_"Address" __address, #_"Coin" __amount, #_"String" __label, #_"String" __message]
        (BitcoinURI/convertToBitcoinURI (.. __address (getParameters)), (.. __address (toString)), __amount, __label, __message)
    )

    ;;;
     ; Simple Bitcoin URI builder using known good fields.
     ;
     ; @param params The network parameters that determine which network the URI is for.
     ; @param address The Bitcoin address.
     ; @param amount The amount.
     ; @param label A label.
     ; @param message A message.
     ; @return a String containing the Bitcoin URI.
     ;;
    #_public
    #_static
    (ยง defn #_"String" BitcoinURI/convertToBitcoinURI [#_"NetworkParameters" __params, #_"String" __address, #_nilable #_"Coin" __amount, #_nilable #_"String" __label, #_nilable #_"String" __message]
        (Preconditions/checkNotNull __params)
        (Preconditions/checkNotNull __address)

        (when (and (some? __amount) (< (.. __amount (signum)) 0))
            (throw (IllegalArgumentException. "Coin must be positive"))
        )

        (let [#_"StringBuilder" __sb (StringBuilder.)
              #_"String" __scheme (.. __params (getUriScheme))]
            (.. __sb (append __scheme) (append ":") (append __address))

            (let [#_"boolean" __questionMarkHasBeenOutput false]

                (when (some? __amount)
                    (.. __sb (append BitcoinURI/QUESTION_MARK_SEPARATOR) (append BitcoinURI/FIELD_AMOUNT) (append "="))
                    (.. __sb (append (.. __amount (toPlainString))))
                    (ยง ass __questionMarkHasBeenOutput true)
                )

                (when (and (some? __label) (not (.. "" (equals __label))))
                    (cond __questionMarkHasBeenOutput
                        (do
                            (.. __sb (append BitcoinURI/AMPERSAND_SEPARATOR))
                        )
                        :else
                        (do
                            (.. __sb (append BitcoinURI/QUESTION_MARK_SEPARATOR))
                            (ยง ass __questionMarkHasBeenOutput true)
                        )
                    )
                    (.. __sb (append BitcoinURI/FIELD_LABEL) (append "=") (append (BitcoinURI/encodeURLString __label)))
                )

                (when (and (some? __message) (not (.. "" (equals __message))))
                    (if __questionMarkHasBeenOutput
                        (.. __sb (append BitcoinURI/AMPERSAND_SEPARATOR))
                        (.. __sb (append BitcoinURI/QUESTION_MARK_SEPARATOR))
                    )
                    (.. __sb (append BitcoinURI/FIELD_MESSAGE) (append "=") (append (BitcoinURI/encodeURLString __message)))
                )

                (.. __sb (toString))
            )
        )
    )

    ;;;
     ; Encode a string using URL encoding.
     ;
     ; @param stringToEncode The string to URL encode.
     ;;
    #_static
    (ยง defn #_"String" BitcoinURI/encodeURLString [#_"String" __stringToEncode]
        (try
            (ยง return (.. (URLEncoder/encode __stringToEncode, "UTF-8") (replace "+", BitcoinURI/ENCODED_SPACE_CHARACTER)))
            (catch UnsupportedEncodingException __e
                (throw (RuntimeException. __e)) ;; Can't happen.
            )
        )
    )
)

;;;
 ; <p>Exception to provide the following to {@link BitcoinURI}:</p>
 ; <ul>
 ; <li>Provision of parsing error messages.</li>
 ; </ul>
 ; <p>This base exception acts as a general failure mode not attributable to a specific cause (other than
 ; that reported in the exception message).  Since this is in English, it may not be worth reporting directly
 ; to the user other than as part of a "general failure to parse" response.</p>
 ;;
#_public
(ยง class BitcoinURIParseException (ยง extends Exception)
    #_public
    (ยง constructor BitcoinURIParseException [#_"String" __s]
        (ยง super __s)
        this
    )

    #_public
    (ยง constructor BitcoinURIParseException [#_"String" __s, #_"Throwable" __throwable]
        (ยง super __s, __throwable)
        this
    )
)

;;;
 ; <p>Exception to provide the following to {@link org.bitcoinj.uri.BitcoinURI}:</p>
 ; <ul>
 ; <li>Provision of parsing error messages.</li>
 ; </ul>
 ; <p>This exception occurs when an optional field is detected (under the Bitcoin URI scheme) and fails
 ; to pass the associated test (such as {@code amount} not being a valid number).</p>
 ;
 ; @since 0.3.0
 ;
 ;;
#_public
(ยง class OptionalFieldValidationException (ยง extends BitcoinURIParseException)
    #_public
    (ยง constructor OptionalFieldValidationException [#_"String" __s]
        (ยง super __s)
        this
    )

    #_public
    (ยง constructor OptionalFieldValidationException [#_"String" __s, #_"Throwable" __throwable]
        (ยง super __s, __throwable)
        this
    )
)

;;;
 ; <p>Exception to provide the following to {@link BitcoinURI}:</p>
 ; <ul>
 ; <li>Provision of parsing error messages.</li>
 ; </ul>
 ; <p>This exception occurs when a required field is detected (under the BIP21 rules) and fails
 ; to pass the associated test (such as {@code req-expires} being out of date), or the required field is unknown
 ; to this version of the client in which case it should fail for security reasons.</p>
 ;
 ; @since 0.3.0
 ;
 ;;
#_public
(ยง class RequiredFieldValidationException (ยง extends BitcoinURIParseException)
    #_public
    (ยง constructor RequiredFieldValidationException [#_"String" __s]
        (ยง super __s)
        this
    )

    #_public
    (ยง constructor RequiredFieldValidationException [#_"String" __s, #_"Throwable" __throwable]
        (ยง super __s, __throwable)
        this
    )
)

#_(ns org.bitcoinj.utils #_"ContextPropagatingThreadFactory"
    (:import [java.util.concurrent *])
    (:import [com.google.common.base *]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]))

#_(ns org.bitcoinj.utils #_"DaemonThreadFactory"
    (:import [java.util.concurrent Executors ThreadFactory]))

#_(ns org.bitcoinj.utils #_"ExchangeRate"
    (:import [java.io Serializable]
             [java.math BigInteger])
    (:import [com.google.common.base Objects Preconditions])
   (:require [org.bitcoinj.core Coin]))

#_(ns org.bitcoinj.utils #_"ExponentialBackoff"
    (:import [com.google.common.base Preconditions]
             [com.google.common.primitives Longs])
   (:require [org.bitcoinj.core Utils]))

#_(ns org.bitcoinj.utils #_"Fiat"
    (:import [java.io Serializable]
             [java.math BigDecimal])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.math LongMath]
             [com.google.common.primitives Longs])
   (:require [org.bitcoinj.core Monetary]))

#_(ns org.bitcoinj.utils #_"ListenerRegistration"
    (:import [java.util List]
             [java.util.concurrent Executor])
    (:import [com.google.common.base Preconditions]))

#_(ns org.bitcoinj.utils #_"MonetaryFormat"
    (:import [java.math RoundingMode]
             [java.text DecimalFormatSymbols]
             [java.util ArrayList Arrays List Locale])
    (:import [com.google.common.base Preconditions]
             [com.google.common.math LongMath])
   (:require [org.bitcoinj.core Coin Monetary]))

#_(ns org.bitcoinj.utils #_"Threading"
    (:import [java.util.concurrent *]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.util.concurrent CycleDetectingLockFactory ListeningExecutorService MoreExecutors Uninterruptibles]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]))

#_(ns org.bitcoinj.utils #_"VersionTally"
    (:import [java.util Stack])
   (:require [org.bitcoinj.core NetworkParameters StoredBlock]
             [org.bitcoinj.store BlockStore BlockStoreException]))

;;;
 ; A {@link java.util.concurrent.ThreadFactory} that propagates a {@link org.bitcoinj.core.Context}
 ; from the creating thread into the new thread.  This factory creates daemon threads.
 ;;
#_public
(ยง class ContextPropagatingThreadFactory (ยง implements ThreadFactory)
    #_private
    #_static
    (ยง def- #_"Logger" ContextPropagatingThreadFactory/log (LoggerFactory/getLogger ContextPropagatingThreadFactory))

    #_private
    (ยง field- #_"String" :name)
    #_private
    (ยง field- #_"int" :priority)

    #_public
    (ยง constructor ContextPropagatingThreadFactory [#_"String" __name, #_"int" __priority]
        (ยง assoc this :name __name)
        (ยง assoc this :priority __priority)
        this
    )

    #_public
    (ยง constructor ContextPropagatingThreadFactory [#_"String" __name]
        (ยง this __name, Thread/NORM_PRIORITY)
        this
    )

    #_override
    #_public
    (ยง method #_"Thread" newThread [#_"Runnable" __r]
        (let [#_"Context" __context (Context/get)]
            (let [#_"Thread" __thread (Thread. (Runnable.)
                (ยง anon
                    #_override
                    #_public
                    (ยง method #_"void" run []
                        (try
                            (Context/propagate __context)
                            (.. __r (run))
                            (catch Exception __e
                                (.. ContextPropagatingThreadFactory/log (error "Exception in thread", __e))
                                (Throwables/propagate __e)
                            )
                        )
                        nil
                    )
                ), (:name this))]
                (.. __thread (setPriority (:priority this)))
                (.. __thread (setDaemon true))
                (let [#_"Thread.UncaughtExceptionHandler" __handler Threading/UNCAUGHT_EXCEPTION_HANDLER]
                    (when (some? __handler)
                        (.. __thread (setUncaughtExceptionHandler __handler))
                    )
                    __thread
                )
            )
        )
    )
)

;;; Thread factory whose threads are marked as daemon and won't prevent process exit. ;;
#_public
(ยง class DaemonThreadFactory (ยง implements ThreadFactory)
    #_nilable
    #_private
    (ยง field- #_"String" :name)

    #_public
    (ยง constructor DaemonThreadFactory [#_nilable #_"String" __name]
        (ยง assoc this :name __name)
        this
    )

    #_public
    (ยง constructor DaemonThreadFactory []
        (ยง this nil)
        this
    )

    #_override
    #_public
    (ยง method #_"Thread" newThread [#_non-nil #_"Runnable" __runnable]
        (let [#_"Thread" __thread (.. (Executors/defaultThreadFactory) (newThread __runnable))]
            (.. __thread (setDaemon true))
            (when (some? (:name this))
                (.. __thread (setName (:name this)))
            )
            __thread
        )
    )
)

;;;
 ; An exchange rate is expressed as a ratio of a {@link Coin} and a {@link Fiat} amount.
 ;;
#_public
(ยง class ExchangeRate (ยง implements Serializable)
    #_public
    (ยง field #_"Coin" :coin)
    #_public
    (ยง field #_"Fiat" :fiat)

    ;;; Construct exchange rate.  This amount of coin is worth that amount of fiat. ;;
    #_public
    (ยง constructor ExchangeRate [#_"Coin" __coin, #_"Fiat" __fiat]
        (Preconditions/checkArgument (.. __coin (isPositive)))
        (Preconditions/checkArgument (.. __fiat (isPositive)))
        (Preconditions/checkArgument (some? (:currency-code __fiat)), "currency code required")

        (ยง assoc this :coin __coin)
        (ยง assoc this :fiat __fiat)
        this
    )

    ;;; Construct exchange rate.  One coin is worth this amount of fiat. ;;
    #_public
    (ยง constructor ExchangeRate [#_"Fiat" __fiat]
        (ยง this Coin/COIN, __fiat)
        this
    )

    ;;;
     ; Convert a coin amount to a fiat amount using this exchange rate.
     ; @throws ArithmeticException if the converted fiat amount is too high or too low.
     ;;
    #_public
    (ยง method #_"Fiat" coinToFiat [#_"Coin" __convertCoin]
        ;; Use BigInteger because it's much easier to maintain full precision without overflowing.
        (let [#_"BigInteger" __converted (.. (BigInteger/valueOf (:value __convertCoin)) (multiply (BigInteger/valueOf (-> this :fiat :value))) (divide (BigInteger/valueOf (-> this :coin :value))))]

            (when (or (< 0 (.. __converted (compareTo (BigInteger/valueOf Long/MAX_VALUE)))) (< (.. __converted (compareTo (BigInteger/valueOf Long/MIN_VALUE))) 0))
                (throw (ArithmeticException. "Overflow"))
            )

            (Fiat/valueOf (-> this :fiat :currency-code), (.. __converted (longValue)))
        )
    )

    ;;;
     ; Convert a fiat amount to a coin amount using this exchange rate.
     ; @throws ArithmeticException if the converted coin amount is too high or too low.
     ;;
    #_public
    (ยง method #_"Coin" fiatToCoin [#_"Fiat" __convertFiat]
        (Preconditions/checkArgument (.. (:currency-code __convertFiat) (equals (-> this :fiat :currency-code))), "Currency mismatch: %s vs %s", (:currency-code __convertFiat), (-> this :fiat :currency-code))

        ;; Use BigInteger because it's much easier to maintain full precision without overflowing.
        (let [#_"BigInteger" __converted (.. (BigInteger/valueOf (:value __convertFiat)) (multiply (BigInteger/valueOf (-> this :coin :value))) (divide (BigInteger/valueOf (-> this :fiat :value))))]

            (when (or (< 0 (.. __converted (compareTo (BigInteger/valueOf Long/MAX_VALUE)))) (< (.. __converted (compareTo (BigInteger/valueOf Long/MIN_VALUE))) 0))
                (throw (ArithmeticException. "Overflow"))
            )

            (try
                (ยง return (Coin/valueOf (.. __converted (longValue))))
                (catch IllegalArgumentException __e
                    (throw (ArithmeticException. (str "Overflow: " (.. __e (getMessage)))))
                )
            )
        )
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"ExchangeRate" __other (cast ExchangeRate __o)]
            (and (Objects/equal (:coin this), (:coin __other)) (Objects/equal (:fiat this), (:fiat __other)))
        )
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (:coin this), (:fiat this))
    )
)

;;;
 ; <p>Tracks successes and failures and calculates a time to retry the operation.</p>
 ;
 ; <p>The retries are exponentially backed off, up to a maximum interval.  On success the back off interval is reset.</p>
 ;;
#_public
(ยง class ExponentialBackoff (ยง implements Comparable #_"<ExponentialBackoff>")
    #_public
    #_static
    (ยง def #_"int" ExponentialBackoff/DEFAULT_INITIAL_MILLIS 100)
    #_public
    #_static
    (ยง def #_"float" ExponentialBackoff/DEFAULT_MULTIPLIER 1.1)
    #_public
    #_static
    (ยง def #_"int" ExponentialBackoff/DEFAULT_MAXIMUM_MILLIS (* 30 1000))

    #_private
    (ยง field- #_"float" :backoff)
    #_private
    (ยง field- #_"long" :retry-time)
    #_private
    (ยง field- #_"ExponentialBackoff.Params" :params)

    ;;;
     ; Parameters to configure a particular kind of exponential backoff.
     ;;
    #_public
    #_static
    (ยง class ExponentialBackoff.Params
        #_private
        (ยง field- #_"float" :initial)
        #_private
        (ยง field- #_"float" :multiplier)
        #_private
        (ยง field- #_"float" :maximum)

        ;;;
         ; @param initialMillis The initial interval to wait, in milliseconds.
         ; @param multiplier The multiplier to apply on each failure.
         ; @param maximumMillis The maximum interval to wait, in milliseconds.
         ;;
        #_public
        (ยง constructor ExponentialBackoff.Params [#_"long" __initialMillis, #_"float" __multiplier, #_"long" __maximumMillis]
            (Preconditions/checkArgument (< 1.0 __multiplier), "multiplier must be greater than 1.0")
            (Preconditions/checkArgument (<= __initialMillis __maximumMillis), "maximum must not be less than initial")

            (ยง assoc this :initial __initialMillis)
            (ยง assoc this :multiplier __multiplier)
            (ยง assoc this :maximum __maximumMillis)
            this
        )

        ;;;
         ; Construct params with default values.
         ;;
        #_public
        (ยง constructor ExponentialBackoff.Params []
            (ยง assoc this :initial ExponentialBackoff/DEFAULT_INITIAL_MILLIS)
            (ยง assoc this :multiplier ExponentialBackoff/DEFAULT_MULTIPLIER)
            (ยง assoc this :maximum ExponentialBackoff/DEFAULT_MAXIMUM_MILLIS)
            this
        )
    )

    #_public
    (ยง constructor ExponentialBackoff [#_"ExponentialBackoff.Params" __params]
        (ยง assoc this :params __params)
        (.. this (trackSuccess))
        this
    )

    ;;; Track a success - reset back off interval to the initial value. ;;
    #_public
    (ยง method #_"void" trackSuccess []
        (ยง assoc this :backoff (-> this :params :initial))
        (ยง assoc this :retry-time (Utils/currentTimeMillis))
        nil
    )

    ;;; Track a failure - multiply the back off interval by the multiplier. ;;
    #_public
    (ยง method #_"void" trackFailure []
        (ยง assoc this :retry-time (+ (Utils/currentTimeMillis) (long (:backoff this))))
        (ยง assoc this :backoff (Math/min (* (:backoff this) (-> this :params :multiplier)), (-> this :params :maximum)))
        nil
    )

    ;;; Get the next time to retry, in milliseconds since the epoch. ;;
    #_public
    (ยง method #_"long" getRetryTime []
        (:retry-time this)
    )

    #_override
    #_public
    (ยง method #_"int" compareTo [#_"ExponentialBackoff" __other]
        ;; Note that in this implementation compareTo() is not consistent with equals().
        (Longs/compare (:retry-time this), (:retry-time __other))
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (str "ExponentialBackoff retry=" (:retry-time this) " backoff=" (:backoff this))
    )
)

;;;
 ; Represents a monetary fiat value.  It was decided to not fold this into {@link org.bitcoinj.core.Coin}
 ; because of type safety.  Fiat values always come with an attached currency code.
 ;
 ; This class is immutable.
 ;;
#_public
(ยง class Fiat (ยง implements Monetary, Comparable #_"<Fiat>", Serializable)
    ;;;
     ; The absolute value of exponent of the value of a "smallest unit" in scientific notation.
     ; We picked 4 rather than 2, because in financial applications it's common to use sub-cent precision.
     ;;
    #_public
    #_static
    (ยง def #_"int" Fiat/SMALLEST_UNIT_EXPONENT 4)

    ;;;
     ; The number of smallest units of this monetary value.
     ;;
    #_public
    (ยง field #_"long" :value)
    #_public
    (ยง field #_"String" :currency-code)

    #_private
    (ยง constructor- #_"Fiat" [#_"String" __currencyCode, #_"long" __value]
        (ยง assoc this :value __value)
        (ยง assoc this :currency-code __currencyCode)
        this
    )

    #_public
    #_static
    (ยง defn #_"Fiat" Fiat/valueOf [#_"String" __currencyCode, #_"long" __value]
        (Fiat. __currencyCode, __value)
    )

    #_override
    #_public
    (ยง method #_"int" smallestUnitExponent []
        Fiat/SMALLEST_UNIT_EXPONENT
    )

    ;;;
     ; Returns the number of "smallest units" of this monetary value.
     ;;
    #_override
    #_public
    (ยง method #_"long" getValue []
        (:value this)
    )

    #_public
    (ยง method #_"String" getCurrencyCode []
        (:currency-code this)
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify more than 4 digits after the comma, or a value out of range.
     ;;
    #_public
    #_static
    (ยง defn #_"Fiat" Fiat/parseFiat [#_"String" __currencyCode, #_"String" __str]
        (try
            (let [#_"long" __val (.. (BigDecimal. __str) (movePointRight Fiat/SMALLEST_UNIT_EXPONENT) (longValueExact))]
                (ยง return (Fiat/valueOf __currencyCode, __val))
            )
            (catch ArithmeticException __e
                (throw (IllegalArgumentException. __e))
            )
        )
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.  The amount is cut to 4 digits after the comma.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify a value out of range.
     ;;
    #_public
    #_static
    (ยง defn #_"Fiat" Fiat/parseFiatInexact [#_"String" __currencyCode, #_"String" __str]
        (try
            (let [#_"long" __val (.. (BigDecimal. __str) (movePointRight Fiat/SMALLEST_UNIT_EXPONENT) (longValue))]
                (ยง return (Fiat/valueOf __currencyCode, __val))
            )
            (catch ArithmeticException __e
                (throw (IllegalArgumentException. __e))
            )
        )
    )

    #_public
    (ยง method #_"Fiat" add [#_"Fiat" __value]
        (Preconditions/checkArgument (.. (:currency-code __value) (equals (:currency-code this))))

        (Fiat. (:currency-code this), (LongMath/checkedAdd (:value this), (:value __value)))
    )

    #_public
    (ยง method #_"Fiat" subtract [#_"Fiat" __value]
        (Preconditions/checkArgument (.. (:currency-code __value) (equals (:currency-code this))))

        (Fiat. (:currency-code this), (LongMath/checkedSubtract (:value this), (:value __value)))
    )

    #_public
    (ยง method #_"Fiat" multiply [#_"long" __factor]
        (Fiat. (:currency-code this), (LongMath/checkedMultiply (:value this), __factor))
    )

    #_public
    (ยง method #_"Fiat" divide [#_"long" __divisor]
        (Fiat. (:currency-code this), (/ (:value this) __divisor))
    )

    #_public
    (ยง method #_"Fiat[]" divideAndRemainder [#_"long" __divisor]
        (into-array Fiat [ (Fiat. (:currency-code this), (/ (:value this) __divisor)), (Fiat. (:currency-code this), (% (:value this) __divisor)) ])
    )

    #_public
    (ยง method #_"long" divide [#_"Fiat" __divisor]
        (Preconditions/checkArgument (.. (:currency-code __divisor) (equals (:currency-code this))))

        (/ (:value this) (:value __divisor))
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value greater than zero, otherwise false.
     ;;
    #_public
    (ยง method #_"boolean" isPositive []
        (== (.. this (signum)) 1)
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value less than zero, otherwise false.
     ;;
    #_public
    (ยง method #_"boolean" isNegative []
        (== (.. this (signum)) -1)
    )

    ;;;
     ; Returns true if and only if this instance represents zero monetary value, otherwise false.
     ;;
    #_public
    (ยง method #_"boolean" isZero []
        (== (.. this (signum)) 0)
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is greater than that of the given other Fiat,
     ; otherwise false.
     ;;
    #_public
    (ยง method #_"boolean" isGreaterThan [#_"Fiat" __other]
        (> (.. this (compareTo __other)) 0)
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is less than that of the given other Fiat,
     ; otherwise false.
     ;;
    #_public
    (ยง method #_"boolean" isLessThan [#_"Fiat" __other]
        (< (.. this (compareTo __other)) 0)
    )

    #_override
    #_public
    (ยง method #_"int" signum []
        (if (== (:value this) 0) 0 (if (< (:value this) 0) -1 1))
    )

    #_public
    (ยง method #_"Fiat" negate []
        (Fiat. (:currency-code this), (- (:value this)))
    )

    ;;;
     ; Returns the number of "smallest units" of this monetary value.
     ; It's deprecated in favour of accessing {@link #value} directly.
     ;;
    #_public
    (ยง method #_"long" longValue []
        (:value this)
    )

    #_private
    #_static
    (ยง def- #_"MonetaryFormat" Fiat/FRIENDLY_FORMAT (.. MonetaryFormat/FIAT (postfixCode)))

    ;;;
     ; Returns the value as a 0.12 type string.
     ; More digits after the decimal place will be used if necessary, but two will always be present.
     ;;
    #_public
    (ยง method #_"String" toFriendlyString []
        (.. Fiat/FRIENDLY_FORMAT (code 0, (:currency-code this)) (format this) (toString))
    )

    #_private
    #_static
    (ยง def- #_"MonetaryFormat" Fiat/PLAIN_FORMAT (.. MonetaryFormat/FIAT (minDecimals 0) (repeatOptionalDecimals 1, 4) (noCode)))

    ;;;
     ; Returns the value as a plain string.  The result is unformatted with no trailing zeroes.
     ; For instance, a value of 150000 "smallest units" gives an output string of "0.0015".
     ;;
    #_public
    (ยง method #_"String" toPlainString []
        (.. Fiat/PLAIN_FORMAT (format this) (toString))
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (Long/toString (:value this))
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== __o this)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (.. __o (getClass)) (getClass)))
            (ยง return false)
        )
        (let [#_"Fiat" __other (cast Fiat __o)]
            (and (== (:value this) (:value __other)) (.. (:currency-code this) (equals (:currency-code __other))))
        )
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (:value this), (:currency-code this))
    )

    #_override
    #_public
    (ยง method #_"int" compareTo [#_"Fiat" __other]
        (if (.. (:currency-code this) (equals (:currency-code __other))) (Longs/compare (:value this), (:value __other)) (.. (:currency-code this) (compareTo (:currency-code __other))))
    )
)

;;;
 ; A simple wrapper around a listener and an executor, with some utility methods.
 ;;
#_public
(ยง class ListenerRegistration #_"<T>"
    #_public
    (ยง field #_"T" :listener)
    #_public
    (ยง field #_"Executor" :executor)

    #_public
    (ยง constructor ListenerRegistration [#_"T" __listener, #_"Executor" __executor]
        (ยง assoc this :listener (Preconditions/checkNotNull __listener))
        (ยง assoc this :executor (Preconditions/checkNotNull __executor))
        this
    )

    ;;; Returns true if the listener was removed, else false. ;;
    #_public
    #_static
    (ยง defn #_"<T> boolean" ListenerRegistration/removeFromList #_"<T>" [#_"T" __listener, #_"List<? extends ListenerRegistration<T>>" __list]
        (Preconditions/checkNotNull __listener)

        (let [#_"ListenerRegistration<T>" __item nil]
            (doseq [#_"ListenerRegistration<T>" __registration __list]
                (when (== (:listener __registration) __listener)
                    (ยง ass __item __registration)
                    (ยง break )
                )
            )
            (and (some? __item) (.. __list (remove __item)))
        )
    )
)

;;;
 ; Utility for formatting and parsing coin values to and from human readable form.
 ;
 ; MonetaryFormat instances are immutable.  Invoking a configuration method has no effect on the receiving instance;
 ; you must store and use the new instance it returns, instead.  Instances are thread safe, so they may be stored safely
 ; as static constants.
 ;;
#_public
(ยง class MonetaryFormat
    ;;; Standard format for the BTC denomination. ;;
    #_public
    #_static
    (ยง def #_"MonetaryFormat" MonetaryFormat/BTC (.. (MonetaryFormat.) (shift 0) (minDecimals 2) (repeatOptionalDecimals 2, 3)))
    ;;; Standard format for the mBTC denomination. ;;
    #_public
    #_static
    (ยง def #_"MonetaryFormat" MonetaryFormat/MBTC (.. (MonetaryFormat.) (shift 3) (minDecimals 2) (optionalDecimals 2)))
    ;;; Standard format for the ยตBTC denomination. ;;
    #_public
    #_static
    (ยง def #_"MonetaryFormat" MonetaryFormat/UBTC (.. (MonetaryFormat.) (shift 6) (minDecimals 0) (optionalDecimals 2)))
    ;;; Standard format for fiat amounts. ;;
    #_public
    #_static
    (ยง def #_"MonetaryFormat" MonetaryFormat/FIAT (.. (MonetaryFormat.) (shift 0) (minDecimals 2) (repeatOptionalDecimals 2, 1)))
    ;;; Currency code for base 1 Bitcoin. ;;
    #_public
    #_static
    (ยง def #_"String" MonetaryFormat/CODE_BTC "BTC")
    ;;; Currency code for base 1/1000 Bitcoin. ;;
    #_public
    #_static
    (ยง def #_"String" MonetaryFormat/CODE_MBTC "mBTC")
    ;;; Currency code for base 1/1000000 Bitcoin. ;;
    #_public
    #_static
    (ยง def #_"String" MonetaryFormat/CODE_UBTC "ยตBTC")

    #_public
    #_static
    (ยง def #_"int" MonetaryFormat/MAX_DECIMALS 8)

    #_private
    (ยง field- #_"char" :negative-sign)
    #_private
    (ยง field- #_"char" :positive-sign)
    #_private
    (ยง field- #_"char" :zero-digit)
    #_private
    (ยง field- #_"char" :decimal-mark)
    #_private
    (ยง field- #_"int" :min-decimals)
    #_private
    (ยง field- #_"List<Integer>" :decimal-groups)
    #_private
    (ยง field- #_"int" :shift)
    #_private
    (ยง field- #_"RoundingMode" :rounding-mode)
    #_private
    (ยง field- #_"String[]" :codes)
    #_private
    (ยง field- #_"char" :code-separator)
    #_private
    (ยง field- #_"boolean" :code-prefixed)

    #_private
    #_static
    (ยง def- #_"String" MonetaryFormat/DECIMALS_PADDING "0000000000000000") ;; a few more than necessary for Bitcoin

    ;;;
     ; Set character to prefix negative values.
     ;;
    #_public
    (ยง method #_"MonetaryFormat" negativeSign [#_"char" __negativeSign]
        (Preconditions/checkArgument (not (Character/isDigit __negativeSign)))
        (Preconditions/checkArgument (< 0 __negativeSign))

        (if (== __negativeSign (:negative-sign this)) this (MonetaryFormat. __negativeSign, (:positive-sign this), (:zero-digit this), (:decimal-mark this), (:min-decimals this), (:decimal-groups this), (:shift this), (:rounding-mode this), (:codes this), (:code-separator this), (:code-prefixed this)))
    )

    ;;;
     ; Set character to prefix positive values.  A zero value means no sign is used in this case.
     ; For parsing, a missing sign will always be interpreted as if the positive sign was used.
     ;;
    #_public
    (ยง method #_"MonetaryFormat" positiveSign [#_"char" __positiveSign]
        (Preconditions/checkArgument (not (Character/isDigit __positiveSign)))

        (if (== __positiveSign (:positive-sign this)) this (MonetaryFormat. (:negative-sign this), __positiveSign, (:zero-digit this), (:decimal-mark this), (:min-decimals this), (:decimal-groups this), (:shift this), (:rounding-mode this), (:codes this), (:code-separator this), (:code-prefixed this)))
    )

    ;;;
     ; Set character range to use for representing digits.  It starts with the specified character representing zero.
     ;;
    #_public
    (ยง method #_"MonetaryFormat" digits [#_"char" __zeroDigit]
        (if (== __zeroDigit (:zero-digit this)) this (MonetaryFormat. (:negative-sign this), (:positive-sign this), __zeroDigit, (:decimal-mark this), (:min-decimals this), (:decimal-groups this), (:shift this), (:rounding-mode this), (:codes this), (:code-separator this), (:code-prefixed this)))
    )

    ;;;
     ; Set character to use as the decimal mark.  If the formatted value does not have any decimals,
     ; no decimal mark is used either.
     ;;
    #_public
    (ยง method #_"MonetaryFormat" decimalMark [#_"char" __decimalMark]
        (Preconditions/checkArgument (not (Character/isDigit __decimalMark)))
        (Preconditions/checkArgument (< 0 __decimalMark))

        (if (== __decimalMark (:decimal-mark this)) this (MonetaryFormat. (:negative-sign this), (:positive-sign this), (:zero-digit this), __decimalMark, (:min-decimals this), (:decimal-groups this), (:shift this), (:rounding-mode this), (:codes this), (:code-separator this), (:code-prefixed this)))
    )

    ;;;
     ; Set minimum number of decimals to use for formatting.  If the value precision exceeds all decimals specified
     ; (including additional decimals specified by {@link #optionalDecimals(int...)} or {@link #repeatOptionalDecimals(int, int)}),
     ; the value will be rounded.  This configuration is not relevant for parsing.
     ;;
    #_public
    (ยง method #_"MonetaryFormat" minDecimals [#_"int" __minDecimals]
        (if (== __minDecimals (:min-decimals this)) this (MonetaryFormat. (:negative-sign this), (:positive-sign this), (:zero-digit this), (:decimal-mark this), __minDecimals, (:decimal-groups this), (:shift this), (:rounding-mode this), (:codes this), (:code-separator this), (:code-prefixed this)))
    )

    ;;;
     ; Set additional groups of decimals to use after the minimum decimals, if they are useful for expressing precision.
     ; Each value is a number of decimals in that group.  If the value precision exceeds all decimals specified
     ; (including minimum decimals), the value will be rounded.  This configuration is not relevant for parsing.
     ;
     ; For example, if you pass <tt>4,2</tt> it will add four decimals to your formatted string if needed, and then add
     ; another two decimals if needed.  At this point, rather than adding further decimals the value will be rounded.
     ;
     ; @param groups Any number numbers of decimals, one for each group.
     ;;
    #_public
    (ยง method #_"MonetaryFormat" optionalDecimals [#_"int..." __groups]
        (let [#_"List<Integer>" __decimalGroups (ArrayList. #_"<>" (.. __groups (alength)))]
            (doseq [#_"int" __group __groups]
                (.. __decimalGroups (add __group))
            )
            (MonetaryFormat. (:negative-sign this), (:positive-sign this), (:zero-digit this), (:decimal-mark this), (:min-decimals this), __decimalGroups, (:shift this), (:rounding-mode this), (:codes this), (:code-separator this), (:code-prefixed this))
        )
    )

    ;;;
     ; Set repeated additional groups of decimals to use after the minimum decimals, if they are useful for expressing
     ; precision.  If the value precision exceeds all decimals specified (including minimum decimals), the value will be
     ; rounded.  This configuration is not relevant for parsing.
     ;
     ; For example, if you pass <tt>1,8</tt> it will up to eight decimals to your formatted string if needed.
     ; After these have been used up, rather than adding further decimals the value will be rounded.
     ;
     ; @param decimals Value of the group to be repeated.
     ; @param repetitions Number of repetitions.
     ;;
    #_public
    (ยง method #_"MonetaryFormat" repeatOptionalDecimals [#_"int" __decimals, #_"int" __repetitions]
        (Preconditions/checkArgument (<= 0 __repetitions))

        (let [#_"List<Integer>" __decimalGroups (ArrayList. #_"<>" __repetitions)]
            (loop-when-recur [#_"int" __i 0] (< __i __repetitions) [(inc __i)]
                (.. __decimalGroups (add __decimals))
            )
            (MonetaryFormat. (:negative-sign this), (:positive-sign this), (:zero-digit this), (:decimal-mark this), (:min-decimals this), __decimalGroups, (:shift this), (:rounding-mode this), (:codes this), (:code-separator this), (:code-prefixed this))
        )
    )

    ;;;
     ; Set number of digits to shift the decimal separator to the right, coming from the standard BTC notation that was
     ; common pre-2014.  Note this will change the currency code if enabled.
     ;;
    #_public
    (ยง method #_"MonetaryFormat" shift [#_"int" __shift]
        (if (== __shift (:shift this)) this (MonetaryFormat. (:negative-sign this), (:positive-sign this), (:zero-digit this), (:decimal-mark this), (:min-decimals this), (:decimal-groups this), __shift, (:rounding-mode this), (:codes this), (:code-separator this), (:code-prefixed this)))
    )

    ;;;
     ; Set rounding mode to use when it becomes necessary.
     ;;
    #_public
    (ยง method #_"MonetaryFormat" roundingMode [#_"RoundingMode" __roundingMode]
        (if (== __roundingMode (:rounding-mode this)) this (MonetaryFormat. (:negative-sign this), (:positive-sign this), (:zero-digit this), (:decimal-mark this), (:min-decimals this), (:decimal-groups this), (:shift this), __roundingMode, (:codes this), (:code-separator this), (:code-prefixed this)))
    )

    ;;;
     ; Don't display currency code when formatting.  This configuration is not relevant for parsing.
     ;;
    #_public
    (ยง method #_"MonetaryFormat" noCode []
        (if (nil? (:codes this)) this (MonetaryFormat. (:negative-sign this), (:positive-sign this), (:zero-digit this), (:decimal-mark this), (:min-decimals this), (:decimal-groups this), (:shift this), (:rounding-mode this), nil, (:code-separator this), (:code-prefixed this)))
    )

    ;;;
     ; Configure currency code for given decimal separator shift.  This configuration is not relevant for parsing.
     ;
     ; @param codeShift Decimal separator shift, see {@link #shift}.
     ; @param code Currency code.
     ;;
    #_public
    (ยง method #_"MonetaryFormat" code [#_"int" __codeShift, #_"String" __code]
        (Preconditions/checkArgument (<= 0 __codeShift))

        (let [#_"String[]" __codes (if (some? (:codes this)) (Arrays/copyOf (:codes this), (.. (:codes this) (alength))) (make-array String MonetaryFormat/MAX_DECIMALS))]

            (aset __codes __codeShift __code)
            (MonetaryFormat. (:negative-sign this), (:positive-sign this), (:zero-digit this), (:decimal-mark this), (:min-decimals this), (:decimal-groups this), (:shift this), (:rounding-mode this), __codes, (:code-separator this), (:code-prefixed this))
        )
    )

    ;;;
     ; Separator between currency code and formatted value.  This configuration is not relevant for parsing.
     ;;
    #_public
    (ยง method #_"MonetaryFormat" codeSeparator [#_"char" __codeSeparator]
        (Preconditions/checkArgument (not (Character/isDigit __codeSeparator)))
        (Preconditions/checkArgument (< 0 __codeSeparator))

        (if (== __codeSeparator (:code-separator this)) this (MonetaryFormat. (:negative-sign this), (:positive-sign this), (:zero-digit this), (:decimal-mark this), (:min-decimals this), (:decimal-groups this), (:shift this), (:rounding-mode this), (:codes this), __codeSeparator, (:code-prefixed this)))
    )

    ;;;
     ; Prefix formatted output by currency code.  This configuration is not relevant for parsing.
     ;;
    #_public
    (ยง method #_"MonetaryFormat" prefixCode []
        (if (:code-prefixed this) this (MonetaryFormat. (:negative-sign this), (:positive-sign this), (:zero-digit this), (:decimal-mark this), (:min-decimals this), (:decimal-groups this), (:shift this), (:rounding-mode this), (:codes this), (:code-separator this), true))
    )

    ;;;
     ; Postfix formatted output with currency code.  This configuration is not relevant for parsing.
     ;;
    #_public
    (ยง method #_"MonetaryFormat" postfixCode []
        (if (not (:code-prefixed this)) this (MonetaryFormat. (:negative-sign this), (:positive-sign this), (:zero-digit this), (:decimal-mark this), (:min-decimals this), (:decimal-groups this), (:shift this), (:rounding-mode this), (:codes this), (:code-separator this), false))
    )

    ;;;
     ; Configure this instance with values from a {@link Locale}.
     ;;
    #_public
    (ยง method #_"MonetaryFormat" withLocale [#_"Locale" __locale]
        (let [#_"DecimalFormatSymbols" __dfs (DecimalFormatSymbols. __locale)
              #_"char" __negativeSign (.. __dfs (getMinusSign))
              #_"char" __zeroDigit (.. __dfs (getZeroDigit))
              #_"char" __decimalMark (.. __dfs (getMonetaryDecimalSeparator))]
            (MonetaryFormat. __negativeSign, (:positive-sign this), __zeroDigit, __decimalMark, (:min-decimals this), (:decimal-groups this), (:shift this), (:rounding-mode this), (:codes this), (:code-separator this), (:code-prefixed this))
        )
    )

    #_public
    (ยง constructor MonetaryFormat []
        ;; defaults
        (ยง assoc this :negative-sign \-)
        (ยง assoc this :positive-sign 0) ;; none
        (ยง assoc this :zero-digit \0)
        (ยง assoc this :decimal-mark \.)
        (ยง assoc this :min-decimals 2)
        (ยง assoc this :decimal-groups nil)
        (ยง assoc this :shift 0)
        (ยง assoc this :rounding-mode RoundingMode/HALF_UP)
        (ยง assoc this :codes (make-array String MonetaryFormat/MAX_DECIMALS))
        (aset (:codes this) 0 MonetaryFormat/CODE_BTC)
        (aset (:codes this) 3 MonetaryFormat/CODE_MBTC)
        (aset (:codes this) 6 MonetaryFormat/CODE_UBTC)
        (ยง assoc this :code-separator \space)
        (ยง assoc this :code-prefixed true)
        this
    )

    #_private
    (ยง constructor- #_"MonetaryFormat" [#_"char" __negativeSign, #_"char" __positiveSign, #_"char" __zeroDigit, #_"char" __decimalMark, #_"int" __minDecimals, #_"List<Integer>" __decimalGroups, #_"int" __shift, #_"RoundingMode" __roundingMode, #_"String[]" __codes, #_"char" __codeSeparator, #_"boolean" __codePrefixed]
        (ยง assoc this :negative-sign __negativeSign)
        (ยง assoc this :positive-sign __positiveSign)
        (ยง assoc this :zero-digit __zeroDigit)
        (ยง assoc this :decimal-mark __decimalMark)
        (ยง assoc this :min-decimals __minDecimals)
        (ยง assoc this :decimal-groups __decimalGroups)
        (ยง assoc this :shift __shift)
        (ยง assoc this :rounding-mode __roundingMode)
        (ยง assoc this :codes __codes)
        (ยง assoc this :code-separator __codeSeparator)
        (ยง assoc this :code-prefixed __codePrefixed)
        this
    )

    ;;;
     ; Format the given monetary value to a human readable form.
     ;;
    #_public
    (ยง method #_"CharSequence" format [#_"Monetary" __monetary]
        ;; preparation
        (let [#_"int" __maxDecimals (:min-decimals this)]
            (when (some? (:decimal-groups this))
                (doseq [#_"int" __group (:decimal-groups this)]
                    (ยง ass __maxDecimals (+ __maxDecimals __group))
                )
            )
            (let [#_"int" __smallestUnitExponent (.. __monetary (smallestUnitExponent))]
                (Preconditions/checkState (<= __maxDecimals __smallestUnitExponent), "The maximum possible number of decimals (%s) cannot exceed %s.", __maxDecimals, __smallestUnitExponent)

                ;; rounding
                (let [#_"long" __satoshis (Math/abs (.. __monetary (getValue)))
                      #_"long" __precisionDivisor (LongMath/checkedPow 10, (- __smallestUnitExponent (:shift this) __maxDecimals))]
                    (ยง ass __satoshis (LongMath/checkedMultiply (LongMath/divide __satoshis, __precisionDivisor, (:rounding-mode this)), __precisionDivisor))

                    ;; shifting
                    (let [#_"long" __shiftDivisor (LongMath/checkedPow 10, (- __smallestUnitExponent (:shift this)))
                          #_"long" __numbers (/ __satoshis __shiftDivisor)
                          #_"long" __decimals (% __satoshis __shiftDivisor)]

                        ;; formatting
                        (let [#_"String" __decimalsStr (String/format Locale/US, (str "%0" (- __smallestUnitExponent (:shift this)) "d"), __decimals)
                              #_"StringBuilder" __sb (StringBuilder. __decimalsStr)]
                            (while (and (< (:min-decimals this) (.. __sb (length))) (== (.. __sb (charAt (dec (.. __sb (length))))) \0))
                                (.. __sb (setLength (dec (.. __sb (length))))) ;; trim trailing zero
                            )
                            (let [#_"int" __i (:min-decimals this)]
                                (when (some? (:decimal-groups this))
                                    (doseq [#_"int" __group (:decimal-groups this)]
                                        (when (and (< __i (.. __sb (length))) (< (.. __sb (length)) (+ __i __group)))
                                            (while (< (.. __sb (length)) (+ __i __group))
                                                (.. __sb (append "0"))
                                            )
                                            (ยง break )
                                        )
                                        (ยง ass __i (+ __i __group))
                                    )
                                )
                                (when (< 0 (.. __sb (length)))
                                    (.. __sb (insert 0, (:decimal-mark this)))
                                )
                                (.. __sb (insert 0, __numbers))
                                (cond
                                    (< (.. __monetary (getValue)) 0) (.. __sb (insert 0, (:negative-sign this)))
                                    (!= (:positive-sign this) 0)    (.. __sb (insert 0, (:positive-sign this)))
                                )
                                (when (some? (:codes this))
                                    (if (:code-prefixed this)
                                        (.. __sb (insert 0, (:code-separator this)) (insert 0, (.. this (code))))
                                        (.. __sb (append (:code-separator this)) (append (.. this (code))))
                                    )
                                )

                                ;; Convert to non-arabic digits.
                                (when (!= (:zero-digit this) \0)
                                    (let [#_"int" __offset (- (:zero-digit this) \0)]
                                        (loop-when-recur [#_"int" __d 0] (< __d (.. __sb (length))) [(inc __d)]
                                            (let [#_"char" __c (.. __sb (charAt __d))]
                                                (when (Character/isDigit __c)
                                                    (.. __sb (setCharAt __d, (char (+ __c __offset))))
                                                )
                                            )
                                        )
                                    )
                                )
                                __sb
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Parse a human readable coin value to a {@link org.bitcoinj.core.Coin} instance.
     ;
     ; @throws NumberFormatException if the string cannot be parsed for some reason.
     ;;
    #_public
    #_throws #_[ "NumberFormatException" ]
    (ยง method #_"Coin" parse [#_"String" __str]
        (Coin/valueOf (.. this (parseValue __str, Coin/SMALLEST_UNIT_EXPONENT)))
    )

    ;;;
     ; Parse a human readable fiat value to a {@link org.bitcoinj.utils.Fiat} instance.
     ;
     ; @throws NumberFormatException if the string cannot be parsed for some reason.
     ;;
    #_public
    #_throws #_[ "NumberFormatException" ]
    (ยง method #_"Fiat" parseFiat [#_"String" __currencyCode, #_"String" __str]
        (Fiat/valueOf __currencyCode, (.. this (parseValue __str, Fiat/SMALLEST_UNIT_EXPONENT)))
    )

    #_private
    (ยง method- #_"long" parseValue [#_"String" __str, #_"int" __smallestUnitExponent]
        (Preconditions/checkState (<= __smallestUnitExponent (.. MonetaryFormat/DECIMALS_PADDING (length))))

        (when (.. __str (isEmpty))
            (throw (NumberFormatException. "empty string"))
        )

        (let [#_"char" __first (.. __str (charAt 0))]
            (when (any == __first (:negative-sign this) (:positive-sign this))
                (ยง ass __str (.. __str (substring 1)))
            )
            (let [#_"String" __numbers
                  #_"String" __decimals
                  #_"int" __decimalMarkIndex (.. __str (indexOf (:decimal-mark this)))]
                (cond (!= __decimalMarkIndex -1)
                    (do
                        (ยง ass __numbers (.. __str (substring 0, __decimalMarkIndex)))
                        (ยง ass __decimals (.. (str __str MonetaryFormat/DECIMALS_PADDING) (substring (inc __decimalMarkIndex))))
                        (when (!= (.. __decimals (indexOf (:decimal-mark this))) -1)
                            (throw (NumberFormatException. "more than one decimal mark"))
                        )
                    )
                    :else
                    (do
                        (ยง ass __numbers __str)
                        (ยง ass __decimals MonetaryFormat/DECIMALS_PADDING)
                    )
                )

                (let [#_"String" __satoshis (+ __numbers (.. __decimals (substring 0, (- __smallestUnitExponent (:shift this)))))]
                    (doseq [#_"char" __c (.. __satoshis (toCharArray))]
                        (when (not (Character/isDigit __c))
                            (throw (NumberFormatException. (str "illegal character: " __c)))
                        )
                    )

                    ;; Non-arabic digits allowed here.
                    (let [#_"long" __value (Long/parseLong __satoshis)]
                        (when (== __first (:negative-sign this))
                            (ยง ass __value (- __value))
                        )
                        __value
                    )
                )
            )
        )
    )

    ;;;
     ; Get currency code that will be used for current shift.
     ;;
    #_public
    (ยง method #_"String" code []
        (when (nil? (:codes this))
            (ยง return nil)
        )
        (when (nil? (aget (:codes this) (:shift this)))
            (throw (NumberFormatException. (str "missing code for shift: " (:shift this))))
        )
        (aget (:codes this) (:shift this))
    )
)

;;;
 ; Various threading related utilities.  Provides a wrapper around explicit lock creation that lets you control whether
 ; bitcoinj performs cycle detection or not.  Cycle detection is useful to detect bugs but comes with a small cost.
 ; Also provides a worker thread that is designed for event listeners to be dispatched on.
 ;;
#_public
(ยง class Threading
    ;;;
     ; An executor with one thread that is intended for running event listeners on.  This ensures all event listener
     ; code runs without any locks being held.  It's intended for the API user to run things on.  Callbacks registered
     ; by bitcoinj internally shouldn't normally run here, although currently there are a few exceptions.
     ;;
    #_public
    #_static
    (ยง def #_"Executor" Threading/USER_THREAD)

    ;;;
     ; A dummy executor that just invokes the runnable immediately.  Use this over
     ; {@link com.google.common.util.concurrent.MoreExecutors#sameThreadExecutor()} because the latter creates
     ; a new object each time in order to implement the more complex {@link ExecutorService} interface, which is
     ; overkill for our needs.
     ;;
    #_public
    #_static
    (ยง def #_"Executor" Threading/SAME_THREAD)

    ;;;
     ; Put a dummy task into the queue and wait for it to be run.  Because it's single threaded, this means all
     ; tasks submitted before this point are now completed.  Usually you won't want to use this method - it's a
     ; convenience primarily used in unit testing.  If you want to wait for an event to be called the right thing
     ; to do is usually to create a {@link com.google.common.util.concurrent.SettableFuture} and then call set
     ; on it.  You can then either block on that future, compose it, add listeners to it and so on.
     ;;
    #_public
    #_static
    (ยง defn #_"void" Threading/waitForUserCode []
        (let [#_"CountDownLatch" __latch (CountDownLatch. 1)]
            (.. Threading/USER_THREAD (execute (Runnable.)
            (ยง anon
                #_override
                #_public
                (ยง method #_"void" run []
                    (.. __latch (countDown))
                    nil
                )
            )))
            (Uninterruptibles/awaitUninterruptibly __latch)
            nil
        )
    )

    ;;;
     ; An exception handler that will be invoked for any exceptions that occur in the user thread, and any unhandled
     ; exceptions that are caught whilst the framework is processing network traffic or doing other background tasks.
     ; The purpose of this is to allow you to report back unanticipated crashes from your users to a central collection
     ; center for analysis and debugging.  You should configure this <b>before</b> any bitcoinj library code is run,
     ; setting it after you started network traffic and other forms of processing may result in the change not taking effect.
     ;;
    #_nilable
    #_public
    #_static
    #_volatile
    (ยง def #_"Thread.UncaughtExceptionHandler" Threading/UNCAUGHT_EXCEPTION_HANDLER)

    #_public
    #_static
    (ยง class Threading.UserThread (ยง extends Thread) (ยง implements Executor)
        #_private
        #_static
        (ยง def- #_"Logger" Threading.UserThread/log (LoggerFactory/getLogger Threading.UserThread))

        ;; 10,000 pending tasks is entirely arbitrary and may or may not be appropriate for the device we're running on.
        #_public
        #_static
        (ยง def #_"int" Threading.UserThread/WARNING_THRESHOLD 10000)

        #_private
        (ยง field- #_"LinkedBlockingQueue<Runnable>" :tasks)

        #_public
        (ยง constructor Threading.UserThread []
            (ยง super "bitcoinj user thread")

            (setDaemon true)
            (ยง assoc this :tasks (LinkedBlockingQueue. #_"<>"))
            (.. this (start))
            this
        )

        #_suppress #_[ "InfiniteLoopStatement" ]
        #_override
        #_public
        (ยง method #_"void" run []
            (loop []
                (let [#_"Runnable" __task (Uninterruptibles/takeUninterruptibly (:tasks this))]
                    (try
                        (.. __task (run))
                        (catch Throwable __t
                            (.. Threading.UserThread/log (warn "Exception in user thread", __t))
                            (let [#_"Thread.UncaughtExceptionHandler" __handler Threading/UNCAUGHT_EXCEPTION_HANDLER]
                                (when (some? __handler)
                                    (.. __handler (uncaughtException this, __t))
                                )
                            )
                        )
                    )
                )
            )
            nil
        )

        #_override
        #_public
        (ยง method #_"void" execute [#_"Runnable" __command]
            (let [#_"int" __size (.. (:tasks this) (size))]
                (when (== __size Threading.UserThread/WARNING_THRESHOLD)
                    (.. Threading.UserThread/log (warn (str "User thread has {} pending tasks, memory exhaustion may occur.\n" "If you see this message, check your memory consumption and see if it's problematic or excessively spikey.\n" "If it is, check for deadlocked or slow event handlers. If it isn't, try adjusting the constant \n" "Threading.UserThread.WARNING_THRESHOLD upwards until it's a suitable level for your app, or Integer.MAX_VALUE to disable."), __size))
                )
                (Uninterruptibles/putUninterruptibly (:tasks this), __command)
                nil
            )
        )
    )

    #_static
    (ยง block
        ;; Default policy goes here.  If you want to change this, use one of the static methods before instantiating
        ;; any bitcoinj objects.  The policy change will take effect only on new objects from that point onwards.
        (Threading/throwOnLockCycles)

        (ยง ass Threading/USER_THREAD (Threading.UserThread.))
        (ยง ass Threading/SAME_THREAD (Executor.
        (ยง anon
            #_override
            #_public
            (ยง method #_"void" execute [#_non-nil #_"Runnable" __runnable]
                (.. __runnable (run))
                nil
            )
        )))
    )

    #_private
    #_static
    (ยง def- #_"CycleDetectingLockFactory.Policy" Threading/POLICY)
    #_public
    #_static
    (ยง def #_"CycleDetectingLockFactory" Threading/FACTORY)

    #_public
    #_static
    (ยง defn #_"ReentrantLock" Threading/lock [#_"String" __name]
        (if (Utils/isAndroidRuntime) (ReentrantLock. true) (.. Threading/FACTORY (newReentrantLock __name)))
    )

    #_public
    #_static
    (ยง defn #_"void" Threading/warnOnLockCycles []
        (Threading/setPolicy CycleDetectingLockFactory.Policies/WARN)
        nil
    )

    #_public
    #_static
    (ยง defn #_"void" Threading/throwOnLockCycles []
        (Threading/setPolicy CycleDetectingLockFactory.Policies/THROW)
        nil
    )

    #_public
    #_static
    (ยง defn #_"void" Threading/ignoreLockCycles []
        (Threading/setPolicy CycleDetectingLockFactory.Policies/DISABLED)
        nil
    )

    #_public
    #_static
    (ยง defn #_"void" Threading/setPolicy [#_"CycleDetectingLockFactory.Policy" __policy]
        (ยง ass Threading/POLICY __policy)
        (ยง ass Threading/FACTORY (CycleDetectingLockFactory/newInstance __policy))
        nil
    )

    #_public
    #_static
    (ยง defn #_"CycleDetectingLockFactory.Policy" Threading/getPolicy []
        Threading/POLICY
    )

    ;;; A caching thread pool that creates daemon threads, which won't keep the JVM alive waiting for more work. ;;
    #_public
    #_static
    (ยง def #_"ListeningExecutorService" Threading/THREAD_POOL (MoreExecutors/listeningDecorator (Executors/newCachedThreadPool (ThreadFactory.)
        (ยง anon
            #_override
            #_public
            (ยง method #_"Thread" newThread [#_"Runnable" __r]
                (let [#_"Thread" __t (Thread. __r)]
                    (.. __t (setName "Threading.THREAD_POOL worker"))
                    (.. __t (setDaemon true))
                    __t
                )
            )
        ))))
)

;;;
 ; Caching counter for the block versions within a moving window.  This class is NOT thread safe
 ; (as if two threads are trying to use it concurrently, there's risk of getting versions out of sequence).
 ;
 ; @see org.bitcoinj.core.NetworkParameters#getMajorityWindow()
 ; @see org.bitcoinj.core.NetworkParameters#getMajorityEnforceBlockUpgrade()
 ; @see org.bitcoinj.core.NetworkParameters#getMajorityRejectBlockOutdated()
 ;;
#_public
(ยง class VersionTally
    ;;;
     ; Cache of version numbers.
     ;;
    #_private
    (ยง field- #_"long[]" :version-window)

    ;;;
     ; Offset within the version window at which the next version will be written.
     ;;
    #_private
    (ยง field- #_"int" :version-write-head 0)

    ;;;
     ; Number of versions written into the tally.  Until this matches the length
     ; of the version window, we do not have sufficient data to return values.
     ;;
    #_private
    (ยง field- #_"int" :versions-stored 0)

    #_public
    (ยง constructor VersionTally [#_"NetworkParameters" __params]
        (ยง assoc this :version-window (long-array (.. __params (getMajorityWindow))))
        this
    )

    ;;;
     ; Add a new block version to the tally, and return the count for that version within the window.
     ;
     ; @param version The block version to add.
     ;;
    #_public
    (ยง method #_"void" add [#_"long" __version]
        (aset (:version-window this) (:version-write-head this) __version)
        (ยง assoc this :version-write-head (inc (:version-write-head this)))
        (when (== (:version-write-head this) (.. (:version-window this) (alength)))
            (ยง assoc this :version-write-head 0)
        )
        (ยง assoc this :versions-stored (inc (:versions-stored this)))
        nil
    )

    ;;;
     ; Get the count of blocks at or above the given version, within the window.
     ;
     ; @param version The block version to query.
     ; @return the count for the block version, or null if the window is not yet full.
     ;;
    #_public
    (ยง method #_"Integer" getCountAtOrAbove [#_"long" __version]
        (when (< (:versions-stored this) (.. (:version-window this) (alength)))
            (ยง return nil)
        )

        (let [#_"int" __count 0]
            (loop-when-recur [#_"int" __versionIdx 0] (< __versionIdx (.. (:version-window this) (alength))) [(inc __versionIdx)]
                (when (<= __version (aget (:version-window this) __versionIdx))
                    (ยง ass __count (inc __count))
                )
            )

            __count
        )
    )

    ;;;
     ; Initialize the version tally from the block store.  Note this does not search backwards past
     ; the start of the block store, so if starting from a checkpoint this may not fill the window.
     ;
     ; @param blockStore Block store to load blocks from.
     ; @param chainHead Current chain tip.
     ;;
    #_public
    #_throws #_[ "BlockStoreException" ]
    (ยง method #_"void" initialize [#_"BlockStore" __blockStore, #_"StoredBlock" __chainHead]
        (let [#_"StoredBlock" __versionBlock __chainHead
              #_"Stack<Long>" __versions (Stack. #_"<>")]

            ;; We don't know how many blocks back we can go, so load what we can first.
            (.. __versions (push (.. __versionBlock (getHeader) (getVersion))))
            (loop-when-recur [#_"int" __headOffset 0] (< __headOffset (.. (:version-window this) (alength))) [(inc __headOffset)]
                (ยง ass __versionBlock (.. __versionBlock (getPrev __blockStore)))
                (when (nil? __versionBlock)
                    (ยง break )
                )
                (.. __versions (push (.. __versionBlock (getHeader) (getVersion))))
            )

            ;; Replay the versions into the tally.
            (while (not (.. __versions (isEmpty)))
                (.. this (add (.. __versions (pop))))
            )
            nil
        )
    )

    ;;;
     ; Get the size of the version window.
     ;;
    #_public
    (ยง method #_"int" size []
        (.. (:version-window this) (alength))
    )
)

#_(ns org.bitcoinj.wallet #_"AllRandomKeysRotating")

#_(ns org.bitcoinj.wallet #_"AllowUnconfirmedCoinSelector"
   (:require [org.bitcoinj.core Transaction]))

#_(ns org.bitcoinj.wallet #_"BasicKeyChain"
    (:import [java.util *]
             [java.util.concurrent CopyOnWriteArrayList Executor]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect ImmutableList Lists]
             [com.google.protobuf ByteString]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core BloomFilter ECKey]
             [org.bitcoinj.crypto *]
             [org.bitcoinj.utils ListenerRegistration Threading]
             [org.bitcoinj.wallet Protos]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

#_(ns org.bitcoinj.wallet #_"CoinSelection"
    (:import [java.util Collection])
   (:require [org.bitcoinj.core Coin TransactionOutput]))

#_(ns org.bitcoinj.wallet #_"CoinSelector"
    (:import [java.util List])
   (:require [org.bitcoinj.core Coin TransactionOutput]))

#_(ns org.bitcoinj.wallet #_"DecryptingKeyBag"
    (:import [java.util ArrayList List])
    (:import [com.google.common.base Preconditions]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core ECKey]))

#_(ns org.bitcoinj.wallet #_"DefaultCoinSelector"
    (:import [java.math BigInteger]
             [java.util *])
    (:import [com.google.common.annotations VisibleForTesting])
   (:require [org.bitcoinj.core Coin NetworkParameters Transaction TransactionConfidence TransactionOutput]))

#_(ns org.bitcoinj.wallet #_"DefaultKeyChainFactory"
   (:require [org.bitcoinj.crypto *]
             [org.bitcoinj.wallet Protos]))

#_(ns org.bitcoinj.wallet #_"DefaultRiskAnalysis"
    (:import [java.util List])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core Coin ECKey]
             [org.bitcoinj.core NetworkParameters Transaction TransactionConfidence TransactionInput TransactionOutput]
             [org.bitcoinj.crypto TransactionSignature]
             [org.bitcoinj.script ScriptChunk]))

#_(ns org.bitcoinj.wallet #_"DeterministicKeyChain"
    (:import [java.math BigInteger]
             [java.security SecureRandom]
             [java.util *]
             [java.util.concurrent Executor]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.base Preconditions Stopwatch]
             [com.google.common.collect ImmutableList Iterators Lists PeekingIterator]
             [com.google.protobuf ByteString]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core BloomFilter ECKey NetworkParameters Utils]
             [org.bitcoinj.crypto *]
             [org.bitcoinj.script Script]
             [org.bitcoinj.utils Threading]
             [org.bitcoinj.wallet Protos]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

#_(ns org.bitcoinj.wallet #_"DeterministicSeed"
    (:import [java.security SecureRandom]
             [java.util List])
    (:import [com.google.common.base Charsets Objects Preconditions Splitter]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core Utils]
             [org.bitcoinj.crypto *]
             [org.bitcoinj.wallet Protos]))

#_(ns org.bitcoinj.wallet #_"DeterministicUpgradeRequiredException")

#_(ns org.bitcoinj.wallet #_"DeterministicUpgradeRequiresPassword")

#_(ns org.bitcoinj.wallet #_"EncryptableKeyChain"
    (:import [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.crypto KeyCrypter KeyCrypterException]))

#_(ns org.bitcoinj.wallet #_"FilteringCoinSelector"
    (:import [java.util HashSet Iterator List])
   (:require [org.bitcoinj.core *]))

#_(ns org.bitcoinj.wallet #_"KeyBag"
   (:require [org.bitcoinj.core ECKey]))

#_(ns org.bitcoinj.wallet #_"KeyChain"
    (:import [java.util List]
             [java.util.concurrent Executor])
   (:require [org.bitcoinj.core BloomFilter ECKey]
             [org.bitcoinj.wallet Protos]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

#_(ns org.bitcoinj.wallet #_"KeyChainFactory"
   (:require [org.bitcoinj.crypto DeterministicKey KeyCrypter]
             [org.bitcoinj.wallet Protos]))

#_(ns org.bitcoinj.wallet #_"KeyChainGroup"
    (:import [java.security *]
             [java.util *]
             [java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect *]
             [com.google.protobuf *]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto.params *])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.crypto *]
             [org.bitcoinj.script *]
             [org.bitcoinj.utils *]
             [org.bitcoinj.wallet Protos]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

#_(ns org.bitcoinj.wallet #_"KeyTimeCoinSelector"
    (:import [java.util LinkedList List])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.script Script]))

#_(ns org.bitcoinj.wallet #_"MarriedKeyChain"
    (:import [java.security SecureRandom]
             [java.util LinkedHashMap List Map])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect ImmutableList Lists]
             [com.google.protobuf ByteString])
   (:require [org.bitcoinj.core BloomFilter ECKey NetworkParameters Utils]
             [org.bitcoinj.crypto DeterministicKey KeyCrypter]
             [org.bitcoinj.script Script ScriptBuilder]
             [org.bitcoinj.wallet Protos]))

#_(ns org.bitcoinj.wallet #_"RedeemData"
    (:import [java.util ArrayList Collections List])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.core ECKey]
             [org.bitcoinj.script Script]))

#_(ns org.bitcoinj.wallet #_"RiskAnalysis"
    (:import [java.util List])
   (:require [org.bitcoinj.core Transaction]))

#_(ns org.bitcoinj.wallet #_"SendRequest"
    (:import [java.math BigInteger]
             [java.util Date])
    (:import [com.google.common.base MoreObjects Preconditions]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core Address Coin Context ECKey NetworkParameters Transaction TransactionOutput]
             [org.bitcoinj.script Script ScriptBuilder]
             [org.bitcoinj.utils ExchangeRate]
             [org.bitcoinj.wallet KeyChain Wallet]))

#_(ns org.bitcoinj.wallet #_"UnreadableWalletException")

#_(ns org.bitcoinj.wallet #_"Wallet"
    (:import [java.io *]
             [java.math BigInteger]
             [java.util *]
             [java.util.concurrent *]
             [java.util.concurrent.atomic *]
             [java.util.concurrent.locks *])
    (:import [com.google.common.annotations *]
             [com.google.common.base *]
             [com.google.common.collect *]
             [com.google.common.primitives *]
             [com.google.common.util.concurrent *]
             [com.google.protobuf *]
             [net.jcip.annotations *]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto.params *])
   (:require [org.bitcoinj.core AbstractBlockChain Address BlockChain BloomFilter Coin Context ECKey FilteredBlock InsufficientMoneyException Message NetworkParameters Peer PeerFilterProvider PeerGroup ScriptException Sha256Hash StoredBlock Transaction TransactionBag TransactionBroadcast TransactionBroadcaster TransactionConfidence TransactionInput TransactionOutPoint TransactionOutput UTXO Utils VarInt VerificationException]
             [org.bitcoinj.core.listeners *]
             [org.bitcoinj.crypto *]
             [org.bitcoinj.script *]
             [org.bitcoinj.signers *]
             [org.bitcoinj.utils *]
             [org.bitcoinj.wallet Protos WalletTransaction]
             [org.bitcoinj.wallet.listeners KeyChainEventListener WalletChangeEventListener WalletCoinsReceivedEventListener WalletCoinsSentEventListener WalletReorganizeEventListener]))

#_(ns org.bitcoinj.wallet #_"WalletFiles"
    (:import [java.io *]
             [java.util Date]
             [java.util.concurrent *]
             [java.util.concurrent.atomic *])
    (:import [com.google.common.base Preconditions Stopwatch]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.utils *]))

#_(ns org.bitcoinj.wallet #_"WalletProtobufSerializer"
    (:import [java.io IOException InputStream OutputStream]
             [java.math BigInteger]
             [java.net InetAddress UnknownHostException]
             [java.util *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [com.google.protobuf ByteString CodedInputStream CodedOutputStream TextFormat WireFormat]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.crypto KeyCrypter KeyCrypterScrypt]
             [org.bitcoinj.script Script]
             [org.bitcoinj.signers LocalTransactionSigner TransactionSigner]
             [org.bitcoinj.utils ExchangeRate Fiat]
             [org.bitcoinj.wallet Protos]))

#_(ns org.bitcoinj.wallet #_"WalletTransaction"
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.core Transaction]))

;;;
 ; Indicates that an attempt was made to upgrade a random wallet to deterministic, but there were no non-rotating
 ; random keys to use as source material for the seed.  Add a non-compromised key first!
 ;;
#_public
(ยง class AllRandomKeysRotating (ยง extends RuntimeException))

;;;
 ; This coin selector will select any transaction at all, regardless of where it came from or whether it was
 ; confirmed yet.  However immature coinbases will not be included (would be a protocol violation).
 ;;
#_public
(ยง class AllowUnconfirmedCoinSelector (ยง extends DefaultCoinSelector)
    #_override
    #_protected
    (ยง method #_"boolean" shouldSelect [#_"Transaction" __tx]
        true
    )

    #_private
    #_static
    (ยง def- #_"AllowUnconfirmedCoinSelector" AllowUnconfirmedCoinSelector/INSTANCE)

    ;;; Returns a global static instance of the selector. ;;
    #_public
    #_static
    (ยง defn #_"AllowUnconfirmedCoinSelector" AllowUnconfirmedCoinSelector/get []
        ;; This doesn't have to be thread safe as the object has no state, so discarded duplicates are harmless.
        (when (nil? AllowUnconfirmedCoinSelector/INSTANCE)
            (ยง ass AllowUnconfirmedCoinSelector/INSTANCE (AllowUnconfirmedCoinSelector.))
        )
        AllowUnconfirmedCoinSelector/INSTANCE
    )
)

;;;
 ; A {@link KeyChain} that implements the simplest model possible: it can have keys imported into it, and just
 ; acts as a dumb bag of keys.  It will, left to its own devices, always return the same key for usage by the wallet,
 ; although it will automatically add one to itself if it's empty or if encryption is requested.
 ;;
#_public
(ยง class BasicKeyChain (ยง implements EncryptableKeyChain)
    #_private
    (ยง field- #_"ReentrantLock" :lock (Threading/lock "BasicKeyChain"))

    ;; Maps used to let us quickly look up a key given data we find in transcations or the block chain.
    #_private
    (ยง field- #_"LinkedHashMap<ByteString, ECKey>" :hash-to-keys)
    #_private
    (ยง field- #_"LinkedHashMap<ByteString, ECKey>" :pubkey-to-keys)
    #_nilable
    #_private
    (ยง field- #_"KeyCrypter" :key-crypter)
    #_private
    (ยง field- #_"boolean" :is-watching)

    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<KeyChainEventListener>>" :listeners)

    #_public
    (ยง constructor BasicKeyChain []
        (ยง this nil)
        this
    )

    #_public
    (ยง constructor BasicKeyChain [#_nilable #_"KeyCrypter" __crypter]
        (ยง assoc this :key-crypter __crypter)
        (ยง assoc this :hash-to-keys (LinkedHashMap. #_"<>"))
        (ยง assoc this :pubkey-to-keys (LinkedHashMap. #_"<>"))
        (ยง assoc this :listeners (CopyOnWriteArrayList. #_"<>"))
        this
    )

    ;;; Returns the {@link KeyCrypter} in use or null if the key chain is not encrypted. ;;
    #_override
    #_nilable
    #_public
    (ยง method #_"KeyCrypter" getKeyCrypter []
        (.. (:lock this) (lock))
        (try
            (:key-crypter this)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_override
    #_public
    (ยง method #_"ECKey" getKey [#_nilable #_"KeyChain.KeyPurpose" __ignored]
        (.. (:lock this) (lock))
        (try
            (when (.. (:hash-to-keys this) (isEmpty))
                ;; We will refuse to encrypt an empty key chain.
                (Preconditions/checkState (nil? (:key-crypter this)))

                (let [#_"ECKey" __key (ECKey.)]
                    (.. this (importKeyLocked __key))
                    (.. this (queueOnKeysAdded (ImmutableList/of __key)))
                )
            )
            (.. (:hash-to-keys this) (values) (iterator) (next))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_override
    #_public
    (ยง method #_"List<ECKey>" getKeys [#_nilable #_"KeyChain.KeyPurpose" __purpose, #_"int" __numberOfKeys]
        (Preconditions/checkArgument (< 0 __numberOfKeys))

        (.. (:lock this) (lock))
        (try
            (when (< (.. (:hash-to-keys this) (size)) __numberOfKeys)
                (Preconditions/checkState (nil? (:key-crypter this)))

                (let [#_"List<ECKey>" __keys (ArrayList. #_"<>")]
                    (loop-when-recur [#_"int" __i 0] (< __i (- __numberOfKeys (.. (:hash-to-keys this) (size)))) [(inc __i)]
                        (.. __keys (add (ECKey.)))
                    )

                    (let [#_"ImmutableList<ECKey>" __immutableKeys (ImmutableList/copyOf __keys)]
                        (.. this (importKeysLocked __immutableKeys))
                        (.. this (queueOnKeysAdded __immutableKeys))
                    )
                )
            )

            (let [#_"List<ECKey>" __keysToReturn (ArrayList. #_"<>")
                  #_"int" __count 0]
                (while (and (.. (:hash-to-keys this) (values) (iterator) (hasNext)) (!= __numberOfKeys __count))
                    (.. __keysToReturn (add (.. (:hash-to-keys this) (values) (iterator) (next))))
                    (ยง ass __count (inc __count))
                )
                (ยง return __keysToReturn)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;; Returns a copy of the list of keys that this chain is managing. ;;
    #_public
    (ยง method #_"List<ECKey>" getKeys []
        (.. (:lock this) (lock))
        (try
            (ArrayList. #_"<>" (.. (:hash-to-keys this) (values)))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_public
    (ยง method #_"int" importKeys [#_"ECKey..." __keys]
        (.. this (importKeys (ImmutableList/copyOf __keys)))
    )

    #_public
    (ยง method #_"int" importKeys [#_"List<? extends ECKey>" __keys]
        (.. (:lock this) (lock))
        (try
            ;; Check that if we're encrypted, the keys are all encrypted, and if we're not, that none are.
            ;; We are NOT checking that the actual password matches here because we don't have access to the
            ;; password at this point: if you screw up and import keys with mismatched passwords, you lose!
            ;; So make sure the password is checked first.
            (doseq [#_"ECKey" __key __keys]
                (.. this (checkKeyEncryptionStateMatches __key))
            )

            (let [#_"List<ECKey>" __actuallyAdded (ArrayList. #_"<>" (.. __keys (size)))]
                (doseq [#_"ECKey" __key __keys]
                    (when (not (.. this (hasKey __key)))
                        (.. __actuallyAdded (add __key))
                        (.. this (importKeyLocked __key))
                    )
                )
                (when (< 0 (.. __actuallyAdded (size)))
                    (.. this (queueOnKeysAdded __actuallyAdded))
                )
                (ยง return (.. __actuallyAdded (size)))
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_private
    (ยง method- #_"void" checkKeyEncryptionStateMatches [#_"ECKey" __key]
        (when (and (nil? (:key-crypter this)) (.. __key (isEncrypted)))
            (throw (KeyCrypterException. "Key is encrypted but chain is not"))
        )
        (when (and (some? (:key-crypter this)) (not (.. __key (isEncrypted))))
            (throw (KeyCrypterException. "Key is not encrypted but chain is"))
        )
        (when (and (some? (:key-crypter this)) (some? (.. __key (getKeyCrypter))) (not (.. __key (getKeyCrypter) (equals (:key-crypter this)))))
            (throw (KeyCrypterException. "Key encrypted under different parameters to chain"))
        )
        nil
    )

    #_private
    (ยง method- #_"void" importKeyLocked [#_"ECKey" __key]
        (cond (.. (:hash-to-keys this) (isEmpty))
            (do
                (ยง assoc this :is-watching (.. __key (isWatching)))
            )
            :else
            (do
                (when (and (.. __key (isWatching)) (not (:is-watching this)))
                    (throw (IllegalArgumentException. "Key is watching but chain is not"))
                )
                (when (and (not (.. __key (isWatching))) (:is-watching this))
                    (throw (IllegalArgumentException. "Key is not watching but chain is"))
                )
            )
        )
        (let [#_"ECKey" __previousKey (.. (:pubkey-to-keys this) (put (ByteString/copyFrom (.. __key (getPubKey))), __key))]
            (.. (:hash-to-keys this) (put (ByteString/copyFrom (.. __key (getPubKeyHash))), __key))
            (Preconditions/checkState (nil? __previousKey))
            nil
        )
    )

    #_private
    (ยง method- #_"void" importKeysLocked [#_"List<ECKey>" __keys]
        (doseq [#_"ECKey" __key __keys]
            (.. this (importKeyLocked __key))
        )
        nil
    )

    ;;;
     ; Imports a key to the key chain.  If key is present in the key chain, ignore it.
     ;;
    #_public
    (ยง method #_"void" importKey [#_"ECKey" __key]
        (.. (:lock this) (lock))
        (try
            (.. this (checkKeyEncryptionStateMatches __key))
            (when (.. this (hasKey __key))
                (ยง return nil)
            )

            (.. this (importKeyLocked __key))
            (.. this (queueOnKeysAdded (ImmutableList/of __key)))
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    #_public
    (ยง method #_"ECKey" findKeyFromPubHash [#_"byte[]" __pubkeyHash]
        (.. (:lock this) (lock))
        (try
            (.. (:hash-to-keys this) (get (ByteString/copyFrom __pubkeyHash)))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_public
    (ยง method #_"ECKey" findKeyFromPubKey [#_"byte[]" __pubkey]
        (.. (:lock this) (lock))
        (try
            (.. (:pubkey-to-keys this) (get (ByteString/copyFrom __pubkey)))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_override
    #_public
    (ยง method #_"boolean" hasKey [#_"ECKey" __key]
        (some? (.. this (findKeyFromPubKey (.. __key (getPubKey)))))
    )

    #_override
    #_public
    (ยง method #_"int" numKeys []
        (.. (:pubkey-to-keys this) (size))
    )

    ;;; Whether this basic key chain is empty, full of regular (usable for signing) keys, or full of watching keys. ;;
    #_public
    (ยง enum BasicKeyChain.State
        (ยง item EMPTY)
        (ยง item WATCHING)
        (ยง item REGULAR)
    )

    ;;;
     ; Returns whether this chain consists of pubkey only (watching) keys, regular keys (usable for signing),
     ; or has no keys in it yet at all (thus we cannot tell).
     ;;
    #_public
    (ยง method #_"BasicKeyChain.State" isWatching []
        (.. (:lock this) (lock))
        (try
            (if (.. (:hash-to-keys this) (isEmpty)) BasicKeyChain.State/EMPTY (if (:is-watching this) BasicKeyChain.State/WATCHING BasicKeyChain.State/REGULAR))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Removes the given key from the keychain.  Be very careful with this - losing a private key
     ; <b>destroys the money associated with it</b>.
     ; @return whether the key was removed or not.
     ;;
    #_public
    (ยง method #_"boolean" removeKey [#_"ECKey" __key]
        (.. (:lock this) (lock))
        (try
            (let [#_"boolean" __a (some? (.. (:hash-to-keys this) (remove (ByteString/copyFrom (.. __key (getPubKeyHash))))))
                  #_"boolean" __b (some? (.. (:pubkey-to-keys this) (remove (ByteString/copyFrom (.. __key (getPubKey))))))]
                (Preconditions/checkState (== __a __b)) ;; Should be in both maps or neither.
                (ยง return __a)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_override
    #_public
    (ยง method #_"long" getEarliestKeyCreationTime []
        (.. (:lock this) (lock))
        (try
            (let [#_"long" __time Long/MAX_VALUE]
                (doseq [#_"ECKey" __key (.. (:hash-to-keys this) (values))]
                    (ยง ass __time (Math/min (.. __key (getCreationTimeSeconds)), __time))
                )
                (ยง return __time)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_public
    (ยง method #_"List<ListenerRegistration<KeyChainEventListener>>" getListeners []
        (ArrayList. #_"<>" (:listeners this))
    )

    (ยง method #_"Map<ECKey, Protos.Key.Builder>" serializeToEditableProtobufs []
        (let [#_"Map<ECKey, Protos.Key.Builder>" __result (LinkedHashMap. #_"<>")]
            (doseq [#_"ECKey" __ecKey (.. (:hash-to-keys this) (values))]
                (let [#_"Protos.Key.Builder" __protoKey (BasicKeyChain/serializeEncryptableItem __ecKey)]
                    (.. __protoKey (setPublicKey (ByteString/copyFrom (.. __ecKey (getPubKey)))))
                    (.. __result (put __ecKey, __protoKey))
                )
            )
            __result
        )
    )

    #_override
    #_public
    (ยง method #_"List<Protos.Key>" serializeToProtobuf []
        (let [#_"Collection<Protos.Key.Builder>" __builders (.. this (serializeToEditableProtobufs) (values))
              #_"List<Protos.Key>" __result (ArrayList. #_"<>" (.. __builders (size)))]
            (doseq [#_"Protos.Key.Builder" __builder __builders]
                (.. __result (add (.. __builder (build))))
            )
            __result
        )
    )

    #_static
    (ยง defn #_"Protos.Key.Builder" BasicKeyChain/serializeEncryptableItem [#_"EncryptableItem" __item]
        (let [#_"Protos.Key.Builder" __proto (Protos.Key/newBuilder)]
            (.. __proto (setCreationTimestamp (* (.. __item (getCreationTimeSeconds)) 1000)))
            (cond (and (.. __item (isEncrypted)) (some? (.. __item (getEncryptedData))))
                (do
                    ;; The encrypted data can be missing for an "encrypted" key in the case of a deterministic wallet
                    ;; for which the leaf keys chain to an encrypted parent and rederive their private keys on the fly.
                    ;; In that case the caller in DeterministicKeyChain will take care of setting the type.
                    (let [#_"EncryptedData" __data (.. __item (getEncryptedData))]
                        (.. __proto (getEncryptedDataBuilder) (setEncryptedPrivateKey (ByteString/copyFrom (:encrypted-bytes __data))) (setInitialisationVector (ByteString/copyFrom (:initialisation-vector __data))))
                        ;; We don't allow mixing of encryption types at the moment.
                        (Preconditions/checkState (== (.. __item (getEncryptionType)) Protos.Wallet.EncryptionType/ENCRYPTED_SCRYPT_AES))
                        (.. __proto (setType Protos.Key.Type/ENCRYPTED_SCRYPT_AES))
                    )
                )
                :else
                (do
                    (let [#_"byte[]" __secret (.. __item (getSecretBytes))]
                        ;; The secret might be missing in the case of a watching wallet, or a key for which the private key
                        ;; is expected to be rederived on the fly from its parent.
                        (when (some? __secret)
                            (.. __proto (setSecretBytes (ByteString/copyFrom __secret)))
                        )
                        (.. __proto (setType Protos.Key.Type/ORIGINAL))
                    )
                )
            )
            __proto
        )
    )

    ;;;
     ; Returns a new BasicKeyChain that contains all basic, ORIGINAL type keys extracted from the list.
     ; Unrecognised key types are ignored.
     ;;
    #_public
    #_static
    #_throws #_[ "UnreadableWalletException" ]
    (ยง defn #_"BasicKeyChain" BasicKeyChain/fromProtobufUnencrypted [#_"List<Protos.Key>" __keys]
        (let [#_"BasicKeyChain" __chain (BasicKeyChain.)]
            (.. __chain (deserializeFromProtobuf __keys))
            __chain
        )
    )

    ;;;
     ; Returns a new BasicKeyChain that contains all basic, ORIGINAL type keys and also any encrypted keys
     ; extracted from the list.  Unrecognised key types are ignored.
     ; @throws org.bitcoinj.wallet.UnreadableWalletException.BadPassword if the password doesn't seem to match.
     ; @throws org.bitcoinj.wallet.UnreadableWalletException if the data structures are corrupted/inconsistent.
     ;;
    #_public
    #_static
    #_throws #_[ "UnreadableWalletException" ]
    (ยง defn #_"BasicKeyChain" BasicKeyChain/fromProtobufEncrypted [#_"List<Protos.Key>" __keys, #_"KeyCrypter" __crypter]
        (let [#_"BasicKeyChain" __chain (BasicKeyChain. (Preconditions/checkNotNull __crypter))]
            (.. __chain (deserializeFromProtobuf __keys))
            __chain
        )
    )

    #_private
    #_throws #_[ "UnreadableWalletException" ]
    (ยง method- #_"void" deserializeFromProtobuf [#_"List<Protos.Key>" __keys]
        (.. (:lock this) (lock))
        (try
            (Preconditions/checkState (.. (:hash-to-keys this) (isEmpty)), "Tried to deserialize into a non-empty chain")
            (doseq [#_"Protos.Key" __key __keys]
                (when (and (!= (.. __key (getType)) Protos.Key.Type/ORIGINAL) (!= (.. __key (getType)) Protos.Key.Type/ENCRYPTED_SCRYPT_AES))
                    (ยง continue )
                )

                (let [#_"boolean" __encrypted (== (.. __key (getType)) Protos.Key.Type/ENCRYPTED_SCRYPT_AES)
                      #_"byte[]" __priv (when (.. __key (hasSecretBytes)) (.. __key (getSecretBytes) (toByteArray)))]
                    (when (not (.. __key (hasPublicKey)))
                        (throw (UnreadableWalletException. "Public key missing"))
                    )

                    (let [#_"byte[]" __pub (.. __key (getPublicKey) (toByteArray))
                          #_"ECKey" __ecKey]
                        (cond __encrypted
                            (do
                                (Preconditions/checkState (some? (:key-crypter this)), "This wallet is encrypted but encrypt() was not called prior to deserialization")
                                (when (not (.. __key (hasEncryptedData)))
                                    (throw (UnreadableWalletException. "Encrypted private key data missing"))
                                )

                                (let [#_"Protos.EncryptedData" __proto (.. __key (getEncryptedData))
                                      #_"EncryptedData" __e (EncryptedData. (.. __proto (getInitialisationVector) (toByteArray)), (.. __proto (getEncryptedPrivateKey) (toByteArray)))]
                                    (ยง ass __ecKey (ECKey/fromEncrypted __e, (:key-crypter this), __pub))
                                )
                            )
                            :else
                            (do
                                (ยง ass __ecKey (if (some? __priv) (ECKey/fromPrivateAndPrecalculatedPublic __priv, __pub) (ECKey/fromPublicOnly __pub)))
                            )
                        )
                        (.. __ecKey (setCreationTimeSeconds (/ (.. __key (getCreationTimestamp)) 1000)))
                        (.. this (importKeyLocked __ecKey))
                    )
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    #_override
    #_public
    (ยง method #_"void" addEventListener [#_"KeyChainEventListener" __listener]
        (.. this (addEventListener __listener, Threading/USER_THREAD))
        nil
    )

    #_override
    #_public
    (ยง method #_"void" addEventListener [#_"KeyChainEventListener" __listener, #_"Executor" __executor]
        (.. (:listeners this) (add (ListenerRegistration. #_"<>" __listener, __executor)))
        nil
    )

    #_override
    #_public
    (ยง method #_"boolean" removeEventListener [#_"KeyChainEventListener" __listener]
        (ListenerRegistration/removeFromList __listener, (:listeners this))
    )

    #_private
    (ยง method- #_"void" queueOnKeysAdded [#_"List<ECKey>" __keys]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))

        (doseq [#_"ListenerRegistration<KeyChainEventListener>" __registration (:listeners this)]
            (.. (:executor __registration) (execute (Runnable.)
            (ยง anon
                #_override
                #_public
                (ยง method #_"void" run []
                    (.. (:listener __registration) (onKeysAdded __keys))
                    nil
                )
            )))
        )
        nil
    )

    ;;;
     ; Convenience wrapper around {@link #toEncrypted(org.bitcoinj.crypto.KeyCrypter, org.spongycastle.crypto.params.KeyParameter)}
     ; which uses the default Scrypt key derivation algorithm and parameters, derives a key from the given password and returns
     ; the created key.
     ;;
    #_override
    #_public
    (ยง method #_"BasicKeyChain" toEncrypted [#_"CharSequence" __password]
        (Preconditions/checkNotNull __password)
        (Preconditions/checkArgument (< 0 (.. __password (length))))

        (let [#_"KeyCrypter" __scrypt (KeyCrypterScrypt.)
              #_"KeyParameter" __derivedKey (.. __scrypt (deriveKey __password))]
            (.. this (toEncrypted __scrypt, __derivedKey))
        )
    )

    ;;;
     ; Encrypt the wallet using the KeyCrypter and the AES key.  A good default KeyCrypter to use is
     ; {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @param keyCrypter The KeyCrypter that specifies how to encrypt/ decrypt a key.
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming
     ;               to create from a password).
     ; @throws KeyCrypterException if the wallet encryption fails.  If so, the wallet state is unchanged.
     ;;
    #_override
    #_public
    (ยง method #_"BasicKeyChain" toEncrypted [#_"KeyCrypter" __keyCrypter, #_"KeyParameter" __aesKey]
        (.. (:lock this) (lock))
        (try
            (Preconditions/checkNotNull __keyCrypter)
            (Preconditions/checkState (nil? (:key-crypter this)), "Key chain is already encrypted")

            (let [#_"BasicKeyChain" __encrypted (BasicKeyChain. __keyCrypter)]
                (doseq [#_"ECKey" __key (.. (:hash-to-keys this) (values))]
                    (let [#_"ECKey" __encryptedKey (.. __key (encrypt __keyCrypter, __aesKey))]
                        ;; Check that the encrypted key can be successfully decrypted.
                        ;; This is done as it is a critical failure if the private key cannot be decrypted successfully
                        ;; (all bitcoin controlled by that private key is lost forever).
                        ;; For a correctly constructed keyCrypter the encryption should always be reversible so it is just
                        ;; being as cautious as possible.
                        (when (not (ECKey/encryptionIsReversible __key, __encryptedKey, __keyCrypter, __aesKey))
                            (throw (KeyCrypterException. (str "The key " __key " cannot be successfully decrypted after encryption so aborting wallet encryption.")))
                        )
                        (.. __encrypted (importKeyLocked __encryptedKey))
                    )
                )
                (ยง return __encrypted)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_override
    #_public
    (ยง method #_"BasicKeyChain" toDecrypted [#_"CharSequence" __password]
        (Preconditions/checkNotNull (:key-crypter this), "Wallet is already decrypted")

        (.. this (toDecrypted (.. (:key-crypter this) (deriveKey __password))))
    )

    #_override
    #_public
    (ยง method #_"BasicKeyChain" toDecrypted [#_"KeyParameter" __aesKey]
        (.. (:lock this) (lock))
        (try
            (Preconditions/checkState (some? (:key-crypter this)), "Wallet is already decrypted")

            ;; Do an up-front check.
            (when (and (< 0 (.. this (numKeys))) (not (.. this (checkAESKey __aesKey))))
                (throw (KeyCrypterException. "Password/key was incorrect."))
            )

            (let [#_"BasicKeyChain" __decrypted (BasicKeyChain.)]
                (doseq [#_"ECKey" __key (.. (:hash-to-keys this) (values))]
                    (.. __decrypted (importKeyLocked (.. __key (decrypt __aesKey))))
                )
                (ยง return __decrypted)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns whether the given password is correct for this key chain.
     ; @throws IllegalStateException if the chain is not encrypted at all.
     ;;
    #_override
    #_public
    (ยง method #_"boolean" checkPassword [#_"CharSequence" __password]
        (Preconditions/checkNotNull __password)
        (Preconditions/checkState (some? (:key-crypter this)), "Key chain not encrypted")

        (.. this (checkAESKey (.. (:key-crypter this) (deriveKey __password))))
    )

    ;;;
     ; Check whether the AES key can decrypt the first encrypted key in the wallet.
     ;
     ; @return true if AES key supplied can decrypt the first encrypted private key in the wallet, false otherwise.
     ;;
    #_override
    #_public
    (ยง method #_"boolean" checkAESKey [#_"KeyParameter" __aesKey]
        (.. (:lock this) (lock))
        (try
            ;; If no keys then cannot decrypt.
            (when (.. (:hash-to-keys this) (isEmpty))
                (ยง return false)
            )

            (Preconditions/checkState (some? (:key-crypter this)), "Key chain is not encrypted")

            ;; Find the first encrypted key in the wallet.
            (let [#_"ECKey" __first nil]
                (doseq [#_"ECKey" __key (.. (:hash-to-keys this) (values))]
                    (when (.. __key (isEncrypted))
                        (ยง ass __first __key)
                        (ยง break )
                    )
                )
                (Preconditions/checkState (some? __first), "No encrypted keys in the wallet")

                (try
                    (let [#_"ECKey" __rebornKey (.. __first (decrypt __aesKey))]
                        (ยง return (Arrays/equals (.. __first (getPubKey)), (.. __rebornKey (getPubKey))))
                    )
                    (catch KeyCrypterException _
                        ;; The AES key supplied is incorrect.
                        (ยง return false)
                    )
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_override
    #_public
    (ยง method #_"BloomFilter" getFilter [#_"int" __size, #_"double" __falsePositiveRate, #_"long" __tweak]
        (.. (:lock this) (lock))
        (try
            (let [#_"BloomFilter" __filter (BloomFilter. __size, __falsePositiveRate, __tweak)]
                (doseq [#_"ECKey" __key (.. (:hash-to-keys this) (values))]
                    (.. __filter (insert __key))
                )
                (ยง return __filter)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_override
    #_public
    (ยง method #_"int" numBloomFilterEntries []
        (* (.. this (numKeys)) 2)
    )

    ;;; Returns the first ECKey created after the given UNIX time, or null if there is none. ;;
    #_nilable
    #_public
    (ยง method #_"ECKey" findOldestKeyAfter [#_"long" __timeSecs]
        (.. (:lock this) (lock))
        (try
            (let [#_"ECKey" __oldest nil]
                (doseq [#_"ECKey" __key (.. (:hash-to-keys this) (values))]
                    (let [#_"long" __keyTime (.. __key (getCreationTimeSeconds))]
                        (when (and (< __timeSecs __keyTime) (or (nil? __oldest) (< __keyTime (.. __oldest (getCreationTimeSeconds)))))
                            (ยง ass __oldest __key)
                        )
                    )
                )
                (ยง return __oldest)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;; Returns a list of all ECKeys created after the given UNIX time. ;;
    #_public
    (ยง method #_"List<ECKey>" findKeysBefore [#_"long" __timeSecs]
        (.. (:lock this) (lock))
        (try
            (let [#_"List<ECKey>" __results (Lists/newLinkedList)]
                (doseq [#_"ECKey" __key (.. (:hash-to-keys this) (values))]
                    (let [#_"long" __keyTime (.. __key (getCreationTimeSeconds))]
                        (when (< __keyTime __timeSecs)
                            (.. __results (add __key))
                        )
                    )
                )
                (ยง return __results)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )
)

;;;
 ; Represents the results of a {@link CoinSelector#select(Coin, java.util.List)} operation.
 ; A coin selection represents a list of spendable transaction outputs that sum together to give valueGathered.
 ; Different coin selections could be produced by different coin selectors from the same input set, according
 ; to their varying policies.
 ;;
#_public
(ยง class CoinSelection
    #_public
    (ยง field #_"Coin" :value-gathered)
    #_public
    (ยง field #_"Collection<TransactionOutput>" :gathered)

    #_public
    (ยง constructor CoinSelection [#_"Coin" __valueGathered, #_"Collection<TransactionOutput>" __gathered]
        (ยง assoc this :value-gathered __valueGathered)
        (ยง assoc this :gathered __gathered)
        this
    )
)

;;;
 ; A CoinSelector is responsible for picking some outputs to spend, from the list of all possible outputs.
 ; It allows you to customize the policies for creation of transactions to suit your needs.  The select operation
 ; may return a {@link CoinSelection} that has a valueGathered lower than the requested target, if there's not
 ; enough money in the wallet.
 ;;
#_public
(ยง interface CoinSelector
    ;;;
     ; Creates a CoinSelection that tries to meet the target amount of value.  The candidates list is given to
     ; this call and can be edited freely.  See the docs for CoinSelection to learn more, or look a the implementation
     ; of {@link DefaultCoinSelector}.
     ;;
    (ยง method #_"CoinSelection" select [#_"Coin" __target, #_"List<TransactionOutput>" __candidates])
)

;;;
 ; A DecryptingKeyBag filters a pre-existing key bag, decrypting keys as they are requested using the provided AES key.
 ; If the keys are encrypted and no AES key provided, {@link org.bitcoinj.core.ECKey.KeyIsEncryptedException} will be thrown.
 ;;
#_public
(ยง class DecryptingKeyBag (ยง implements KeyBag)
    #_protected
    (ยง field #_"KeyBag" :target)
    #_protected
    (ยง field #_"KeyParameter" :aes-key)

    #_public
    (ยง constructor DecryptingKeyBag [#_"KeyBag" __target, #_nilable #_"KeyParameter" __aesKey]
        (ยง assoc this :target (Preconditions/checkNotNull __target))
        (ยง assoc this :aes-key __aesKey)
        this
    )

    #_nilable
    #_private
    (ยง method- #_"ECKey" maybeDecrypt [#_"ECKey" __key]
        (when (nil? __key)
            (ยง return nil)
        )

        (when (.. __key (isEncrypted))
            (when (nil? (:aes-key this))
                (throw (ECKey.KeyIsEncryptedException.))
            )
            (ยง return (.. __key (decrypt (:aes-key this))))
        )

        __key
    )

    #_private
    (ยง method- #_"RedeemData" maybeDecrypt [#_"RedeemData" __redeemData]
        (let [#_"List<ECKey>" __decryptedKeys (ArrayList. #_"<>")]
            (doseq [#_"ECKey" __key (:keys __redeemData)]
                (.. __decryptedKeys (add (.. this (maybeDecrypt __key))))
            )
            (RedeemData/of __decryptedKeys, (:redeem-script __redeemData))
        )
    )

    #_nilable
    #_override
    #_public
    (ยง method #_"ECKey" findKeyFromPubHash [#_"byte[]" __pubkeyHash]
        (.. this (maybeDecrypt (.. (:target this) (findKeyFromPubHash __pubkeyHash))))
    )

    #_nilable
    #_override
    #_public
    (ยง method #_"ECKey" findKeyFromPubKey [#_"byte[]" __pubkey]
        (.. this (maybeDecrypt (.. (:target this) (findKeyFromPubKey __pubkey))))
    )

    #_nilable
    #_override
    #_public
    (ยง method #_"RedeemData" findRedeemDataFromScriptHash [#_"byte[]" __scriptHash]
        (.. this (maybeDecrypt (.. (:target this) (findRedeemDataFromScriptHash __scriptHash))))
    )
)

;;;
 ; This class implements a {@link CoinSelector} which attempts to get the highest priority possible.
 ; This means that the transaction is the most likely to get confirmed.  Note that this means we may end up
 ; "spending" more priority than would be required to get the transaction we are creating confirmed.
 ;;
#_public
(ยง class DefaultCoinSelector (ยง implements CoinSelector)
    #_override
    #_public
    (ยง method #_"CoinSelection" select [#_"Coin" __target, #_"List<TransactionOutput>" __candidates]
        (let [#_"ArrayList<TransactionOutput>" __selected (ArrayList. #_"<>")]
            ;; Sort the inputs by age * value, so we get the highest "coindays" spent.
            ;; TODO: Consider changing the wallets internal format to track just outputs and keep them ordered.
            (let [#_"ArrayList<TransactionOutput>" __sortedOutputs (ArrayList. #_"<>" __candidates)]
                ;; When calculating the wallet balance, we may be asked to select all possible coins, if so, avoid
                ;; sorting them in order to improve performance.
                ;; TODO: Take in network parameters when instanatiated, and then test against the current network.
                ;; Or just have a boolean parameter for "give me everything".
                (when (not (.. __target (equals NetworkParameters/MAX_MONEY)))
                    (DefaultCoinSelector/sortOutputs __sortedOutputs)
                )
                ;; Now iterate over the sorted outputs until we have got as close to the target as possible or
                ;; a little bit over (excessive value will be change).
                (let [#_"long" __total 0]
                    (doseq [#_"TransactionOutput" __output __sortedOutputs]
                        (when (<= (:value __target) __total)
                            (ยง break )
                        )
                        ;; Only pick chain-included transactions, or transactions that are ours and pending.
                        (when (.. this (shouldSelect (.. __output (getParentTransaction))))
                            (.. __selected (add __output))
                            (ยง ass __total (+ __total (:value (.. __output (getValue)))))
                        )
                    )
                    ;; Total may be lower than the target here if the given candidates were insufficient to create
                    ;; the requested transaction.
                    (CoinSelection. (Coin/valueOf __total), __selected)
                )
            )
        )
    )

    #_testing
    #_static
    (ยง defn #_"void" DefaultCoinSelector/sortOutputs [#_"ArrayList<TransactionOutput>" __outputs]
        (Collections/sort __outputs, (Comparator. #_"<TransactionOutput>")
        (ยง anon
            #_override
            #_public
            (ยง method #_"int" compare [#_"TransactionOutput" __a, #_"TransactionOutput" __b]
                (let [#_"int" __depth1 (.. __a (getParentTransactionDepthInBlocks))
                      #_"int" __depth2 (.. __b (getParentTransactionDepthInBlocks))
                      #_"Coin" __aValue (.. __a (getValue))
                      #_"Coin" __bValue (.. __b (getValue))
                      #_"BigInteger" __aCoinDepth (.. (BigInteger/valueOf (:value __aValue)) (multiply (BigInteger/valueOf __depth1)))
                      #_"BigInteger" __bCoinDepth (.. (BigInteger/valueOf (:value __bValue)) (multiply (BigInteger/valueOf __depth2)))
                      #_"int" __c1 (.. __bCoinDepth (compareTo __aCoinDepth))]
                    (when (!= __c1 0)
                        (ยง return __c1)
                    )

                    ;; The "coin * days" destroyed are equal, sort by value alone to get the lowest transaction size.
                    (let [#_"int" __c2 (.. __bValue (compareTo __aValue))]
                        (when (!= __c2 0)
                            (ยง return __c2)
                        )

                        ;; They are entirely equivalent (possibly pending) so sort by hash to ensure a total ordering.
                        (let [#_"BigInteger" __aHash (.. __a (getParentTransactionHash) (toBigInteger))
                              #_"BigInteger" __bHash (.. __b (getParentTransactionHash) (toBigInteger))]
                            (.. __aHash (compareTo __bHash))
                        )
                    )
                )
            )
        ))
        nil
    )

    ;;; Sub-classes can override this to just customize whether transactions are usable, but keep age sorting. ;;
    #_protected
    (ยง method #_"boolean" shouldSelect [#_"Transaction" __tx]
        (if (some? __tx) (DefaultCoinSelector/isSelectable __tx) true)
    )

    #_public
    #_static
    (ยง defn #_"boolean" DefaultCoinSelector/isSelectable [#_"Transaction" __tx]
        ;; Only pick chain-included transactions, or transactions that are ours and pending.
        (let [#_"TransactionConfidence" __confidence (.. __tx (getConfidence))
              #_"TransactionConfidence.ConfidenceType" __type (.. __confidence (getConfidenceType))]
            ;; TODO: The value 1 below dates from a time when transactions we broadcast *to* were counted, set to 0.
            (or (.. __type (equals TransactionConfidence.ConfidenceType/BUILDING)) (and (.. __type (equals TransactionConfidence.ConfidenceType/PENDING)) (.. __confidence (getSource) (equals TransactionConfidence.Source/SELF)) (< 1 (.. __confidence (numBroadcastPeers)))))
        )
    )
)

;;;
 ; Default factory for creating keychains while de-serializing.
 ;;
#_public
(ยง class DefaultKeyChainFactory (ยง implements KeyChainFactory)
    #_override
    #_public
    (ยง method #_"DeterministicKeyChain" makeKeyChain [#_"Protos.Key" __key, #_"Protos.Key" __firstSubKey, #_"DeterministicSeed" __seed, #_"KeyCrypter" __crypter, #_"boolean" __isMarried]
        (if __isMarried (MarriedKeyChain. __seed, __crypter) (DeterministicKeyChain. __seed, __crypter))
    )

    #_override
    #_public
    #_throws #_[ "UnreadableWalletException" ]
    (ยง method #_"DeterministicKeyChain" makeWatchingKeyChain [#_"Protos.Key" __key, #_"Protos.Key" __firstSubKey, #_"DeterministicKey" __accountKey, #_"boolean" __isFollowingKey, #_"boolean" __isMarried]
        (when (not (.. __accountKey (getPath) (equals DeterministicKeyChain/ACCOUNT_ZERO_PATH)))
            (throw (UnreadableWalletException. (str "Expecting account key but found key with path: " (HDUtils/formatPath (.. __accountKey (getPath))))))
        )

        (if __isMarried (MarriedKeyChain. __accountKey) (DeterministicKeyChain. __accountKey, __isFollowingKey))
    )
)

;;;
 ; <p>The default risk analysis.  Currently, it only is concerned with whether a tx/dependency is non-final or not,
 ; and whether a tx/dependency violates the dust rules.  Outside of specialised protocols you should not encounter
 ; non-final transactions.</p>
 ;;
#_public
(ยง class DefaultRiskAnalysis (ยง implements RiskAnalysis)
    #_private
    #_static
    (ยง def- #_"Logger" DefaultRiskAnalysis/log (LoggerFactory/getLogger DefaultRiskAnalysis))

    ;;;
     ; Any standard output smaller than this value (in satoshis) will be considered risky, as it's most likely
     ; be rejected by the network.  This is usually the same as {@link Transaction#MIN_NONDUST_OUTPUT} but can
     ; be different when the fee is about to change in Bitcoin Core.
     ;;
    #_public
    #_static
    (ยง def #_"Coin" DefaultRiskAnalysis/MIN_ANALYSIS_NONDUST_OUTPUT Transaction/MIN_NONDUST_OUTPUT)

    #_protected
    (ยง field #_"Transaction" :tx)
    #_protected
    (ยง field #_"List<Transaction>" :dependencies)
    #_nilable
    #_protected
    (ยง field #_"Wallet" :wallet)

    #_private
    (ยง field- #_"Transaction" :non-standard)
    #_protected
    (ยง field #_"Transaction" :non-final)
    #_protected
    (ยง field #_"boolean" :analyzed)

    #_private
    (ยง constructor- #_"DefaultRiskAnalysis" [#_"Wallet" __wallet, #_"Transaction" __tx, #_"List<Transaction>" __dependencies]
        (ยง assoc this :tx __tx)
        (ยง assoc this :dependencies __dependencies)
        (ยง assoc this :wallet __wallet)
        this
    )

    #_override
    #_public
    (ยง method #_"RiskAnalysis.Result" analyze []
        (Preconditions/checkState (not (:analyzed this)))
        (ยง assoc this :analyzed true)

        (let [#_"RiskAnalysis.Result" __result (.. this (analyzeIsFinal))]
            (when (and (some? __result) (!= __result RiskAnalysis.Result/OK))
                (ยง return __result)
            )

            (.. this (analyzeIsStandard))
        )
    )

    #_nilable
    #_private
    (ยง method- #_"RiskAnalysis.Result" analyzeIsFinal []
        ;; Transactions we create ourselves are, by definition, not at risk of double spending against us.
        (when (== (.. (:tx this) (getConfidence) (getSource)) TransactionConfidence.Source/SELF)
            (ยง return RiskAnalysis.Result/OK)
        )

        ;; We consider transactions that opt into replace-by-fee at risk of double spending.
        (when (.. (:tx this) (isOptInFullRBF))
            (ยง assoc this :non-final (:tx this))
            (ยง return RiskAnalysis.Result/NON_FINAL)
        )

        (when (nil? (:wallet this))
            (ยง return nil)
        )

        (let [#_"int" __height (.. (:wallet this) (getLastBlockSeenHeight))
              #_"long" __time (.. (:wallet this) (getLastBlockSeenTimeSecs))]
            ;; If the transaction has a lock time specified in blocks, we consider that if the tx would become final
            ;; in the next block, it is not risky (as it would confirm normally).
            (let [#_"int" __adjustedHeight (inc __height)]

                (when (not (.. (:tx this) (isFinal __adjustedHeight, __time)))
                    (ยง assoc this :non-final (:tx this))
                    (ยง return RiskAnalysis.Result/NON_FINAL)
                )

                (doseq [#_"Transaction" __dep (:dependencies this)]
                    (when (not (.. __dep (isFinal __adjustedHeight, __time)))
                        (ยง assoc this :non-final __dep)
                        (ยง return RiskAnalysis.Result/NON_FINAL)
                    )
                )

                RiskAnalysis.Result/OK
            )
        )
    )

    ;;;
     ; The reason a transaction is considered non-standard, returned by {@link #isStandard(org.bitcoinj.core.Transaction)}.
     ;;
    #_public
    (ยง enum DefaultRiskAnalysis.RuleViolation
        (ยง item NONE)
        (ยง item VERSION)
        (ยง item DUST)
        (ยง item SHORTEST_POSSIBLE_PUSHDATA)
        (ยง item NONEMPTY_STACK) ;; Not yet implemented (for post 0.12)
        (ยง item SIGNATURE_CANONICAL_ENCODING)
    )

    ;;;
     ; <p>Checks if a transaction is considered "standard" by Bitcoin Core's IsStandardTx and AreInputsStandard functions.</p>
     ;
     ; <p>Note that this method currently only implements a minimum of checks.  More to be added later.</p>
     ;;
    #_public
    #_static
    (ยง defn #_"DefaultRiskAnalysis.RuleViolation" DefaultRiskAnalysis/isStandard [#_"Transaction" __tx]
        ;; TODO: Finish this function off.
        (when (or (< 1 (.. __tx (getVersion))) (< (.. __tx (getVersion)) 1))
            (.. DefaultRiskAnalysis/log (warn "TX considered non-standard due to unknown version number {}", (.. __tx (getVersion))))
            (ยง return DefaultRiskAnalysis.RuleViolation/VERSION)
        )

        (let [#_"List<TransactionOutput>" __outputs (.. __tx (getOutputs))]
            (loop-when-recur [#_"int" __i 0] (< __i (.. __outputs (size))) [(inc __i)]
                (let [#_"TransactionOutput" __output (.. __outputs (get __i))
                      #_"DefaultRiskAnalysis.RuleViolation" __violation (DefaultRiskAnalysis/isOutputStandard __output)]
                    (when (!= __violation DefaultRiskAnalysis.RuleViolation/NONE)
                        (.. DefaultRiskAnalysis/log (warn "TX considered non-standard due to output {} violating rule {}", __i, __violation))
                        (ยง return __violation)
                    )
                )
            )

            (let [#_"List<TransactionInput>" __inputs (.. __tx (getInputs))]
                (loop-when-recur [#_"int" __i 0] (< __i (.. __inputs (size))) [(inc __i)]
                    (let [#_"TransactionInput" __input (.. __inputs (get __i))
                          #_"DefaultRiskAnalysis.RuleViolation" __violation (DefaultRiskAnalysis/isInputStandard __input)]
                        (when (!= __violation DefaultRiskAnalysis.RuleViolation/NONE)
                            (.. DefaultRiskAnalysis/log (warn "TX considered non-standard due to input {} violating rule {}", __i, __violation))
                            (ยง return __violation)
                        )
                    )
                )

                DefaultRiskAnalysis.RuleViolation/NONE
            )
        )
    )

    ;;;
     ; Checks the output to see if the script violates a standardness rule.  Not complete.
     ;;
    #_public
    #_static
    (ยง defn #_"DefaultRiskAnalysis.RuleViolation" DefaultRiskAnalysis/isOutputStandard [#_"TransactionOutput" __output]
        (when (< (.. __output (getValue) (compareTo DefaultRiskAnalysis/MIN_ANALYSIS_NONDUST_OUTPUT)) 0)
            (ยง return DefaultRiskAnalysis.RuleViolation/DUST)
        )

        (doseq [#_"ScriptChunk" __chunk (.. __output (getScriptPubKey) (getChunks))]
            (when (and (.. __chunk (isPushData)) (not (.. __chunk (isShortestPossiblePushData))))
                (ยง return DefaultRiskAnalysis.RuleViolation/SHORTEST_POSSIBLE_PUSHDATA)
            )
        )

        DefaultRiskAnalysis.RuleViolation/NONE
    )

    ;;; Checks if the given input passes some of the AreInputsStandard checks.  Not complete. ;;
    #_public
    #_static
    (ยง defn #_"DefaultRiskAnalysis.RuleViolation" DefaultRiskAnalysis/isInputStandard [#_"TransactionInput" __input]
        (doseq [#_"ScriptChunk" __chunk (.. __input (getScriptSig) (getChunks))]
            (when (and (some? (:data __chunk)) (not (.. __chunk (isShortestPossiblePushData))))
                (ยง return DefaultRiskAnalysis.RuleViolation/SHORTEST_POSSIBLE_PUSHDATA)
            )

            (when (.. __chunk (isPushData))
                (let [#_"ECKey.ECDSASignature" __signature]
                    (try
                        (ยง ass __signature (ECKey.ECDSASignature/decodeFromDER (:data __chunk)))
                        (catch IllegalArgumentException _
                            ;; Doesn't look like a signature.
                            (ยง ass __signature nil)
                        )
                    )
                    (when (some? __signature)
                        (when (not (TransactionSignature/isEncodingCanonical (:data __chunk)))
                            (ยง return DefaultRiskAnalysis.RuleViolation/SIGNATURE_CANONICAL_ENCODING)
                        )
                        (when (not (.. __signature (isCanonical)))
                            (ยง return DefaultRiskAnalysis.RuleViolation/SIGNATURE_CANONICAL_ENCODING)
                        )
                    )
                )
            )
        )
        DefaultRiskAnalysis.RuleViolation/NONE
    )

    #_private
    (ยง method- #_"RiskAnalysis.Result" analyzeIsStandard []
        ;; The IsStandard rules don't apply on testnet, because they're just a safety mechanism and we don't
        ;; want to crush innovation with valueless test coins.
        (when (and (some? (:wallet this)) (not (.. (:wallet this) (getNetworkParameters) (getId) (equals NetworkParameters/ID_MAINNET))))
            (ยง return RiskAnalysis.Result/OK)
        )

        (let [#_"DefaultRiskAnalysis.RuleViolation" __ruleViolation (DefaultRiskAnalysis/isStandard (:tx this))]
            (when (!= __ruleViolation DefaultRiskAnalysis.RuleViolation/NONE)
                (ยง assoc this :non-standard (:tx this))
                (ยง return RiskAnalysis.Result/NON_STANDARD)
            )

            (doseq [#_"Transaction" __dep (:dependencies this)]
                (ยง ass __ruleViolation (DefaultRiskAnalysis/isStandard __dep))
                (when (!= __ruleViolation DefaultRiskAnalysis.RuleViolation/NONE)
                    (ยง assoc this :non-standard __dep)
                    (ยง return RiskAnalysis.Result/NON_STANDARD)
                )
            )

            RiskAnalysis.Result/OK
        )
    )

    ;;; Returns the transaction that was found to be non-standard, or null. ;;
    #_nilable
    #_public
    (ยง method #_"Transaction" getNonStandard []
        (:non-standard this)
    )

    ;;; Returns the transaction that was found to be non-final, or null. ;;
    #_nilable
    #_public
    (ยง method #_"Transaction" getNonFinal []
        (:non-final this)
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (when (not (:analyzed this))
            (ยง return (str "Pending risk analysis for " (.. (:tx this) (getHashAsString))))
        )
        (when (some? (:non-final this))
            (ยง return (str "Risky due to non-finality of " (.. (:non-final this) (getHashAsString))))
        )
        (when (some? (:non-standard this))
            (ยง return (str "Risky due to non-standard tx " (.. (:non-standard this) (getHashAsString))))
        )

        "Non-risky"
    )

    #_public
    #_static
    (ยง class DefaultRiskAnalysis.Analyzer (ยง implements RiskAnalysis.Analyzer)
        #_override
        #_public
        (ยง method #_"DefaultRiskAnalysis" create [#_"Wallet" __wallet, #_"Transaction" __tx, #_"List<Transaction>" __dependencies]
            (DefaultRiskAnalysis. __wallet, __tx, __dependencies)
        )
    )

    #_public
    #_static
    (ยง def #_"DefaultRiskAnalysis.Analyzer" DefaultRiskAnalysis/FACTORY (DefaultRiskAnalysis.Analyzer.))
)

;;;
 ; <p>A deterministic key chain is a {@link KeyChain} that uses the
 ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP 32 standard</a>, as implemented by
 ; {@link org.bitcoinj.crypto.DeterministicHierarchy}, to derive all the keys in the keychain from a master seed.
 ; This type of wallet is extremely convenient and flexible.  Although backing up full wallet files is always a good
 ; idea, to recover money only the root seed needs to be preserved and that is a number small enough that it can be
 ; written down on paper or, when represented using a BIP 39 {@link org.bitcoinj.crypto.MnemonicCode},
 ; dictated over the phone (possibly even memorized).</p>
 ;
 ; <p>Deterministic key chains have other advantages: parts of the key tree can be selectively revealed to allow
 ; for auditing, and new public keys can be generated without access to the private keys, yielding a highly secure
 ; configuration for web servers which can accept payments into a wallet but not spend from them.  This does not work
 ; quite how you would expect due to a quirk of elliptic curve mathematics and the techniques used to deal with it.
 ; A watching wallet is not instantiated using the public part of the master key as you may imagine.  Instead, you
 ; need to take the account key (first child of the master key) and provide the public part of that to the watching
 ; wallet instead.  You can do this by calling {@link #getWatchingKey()} and then serializing it with
 ; {@link org.bitcoinj.crypto.DeterministicKey#serializePubB58(org.bitcoinj.core.NetworkParameters)}.  The resulting
 ; "xpub..." string encodes sufficient information about the account key to create a watching chain via
 ; {@link org.bitcoinj.crypto.DeterministicKey#deserializeB58(org.bitcoinj.crypto.DeterministicKey, String, org.bitcoinj.core.NetworkParameters)}
 ; (with null as the first parameter) and then
 ; {@link DeterministicKeyChain#DeterministicKeyChain(org.bitcoinj.crypto.DeterministicKey)}.</p>
 ;
 ; <p>This class builds on {@link org.bitcoinj.crypto.DeterministicHierarchy} and {@link org.bitcoinj.crypto.DeterministicKey}
 ; by adding support for serialization to and from protobufs, and encryption of parts of the key tree.  Internally it
 ; arranges itself as per the BIP 32 spec, with the seed being used to derive a master key, which is then used to derive
 ; an account key, the account key is used to derive two child keys called the <i>internal</i> and <i>external</i> parent
 ; keys (for change and handing out addresses respectively) and finally the actual leaf keys that users use hanging off
 ; the end.  The leaf keys are special in that they don't internally store the private part at all, instead choosing to
 ; rederive the private key from the parent when needed for signing.  This simplifies the design for encrypted key chains.</p>
 ;
 ; <p>The key chain manages a <i>lookahead zone</i>.  This zone is required because when scanning the chain, you don't
 ; know exactly which keys might receive payments.  The user may have handed out several addresses and received payments
 ; on them, but for latency reasons the block chain is requested from remote peers in bulk, meaning you must
 ; "look ahead" when calculating keys to put in the Bloom filter.  The default lookahead zone is 100 keys, meaning
 ; if the user hands out more than 100 addresses and receives payment on them before the chain is next scanned, some
 ; transactions might be missed.  100 is a reasonable choice for consumer wallets running on CPU constrained devices.
 ; For industrial wallets that are receiving keys all the time, a higher value is more appropriate.  Ideally DKC and
 ; the wallet would know how to adjust this value automatically, but that's not implemented at the moment.</p>
 ;
 ; <p>In fact the real size of the lookahead zone is larger than requested, by default, it's one third larger.  This
 ; is because the act of deriving new keys means recalculating the Bloom filters and this is an expensive operation.
 ; Thus, to ensure we don't have to recalculate on every single new key/address requested or seen we add more buffer
 ; space and only extend the lookahead zone when that buffer is exhausted.  For example with a lookahead zone of 100
 ; keys, you can request 33 keys before more keys will be calculated and the Bloom filter rebuilt and rebroadcast.
 ; But even when you are requesting the 33rd key, you will still be looking 100 keys ahead.</p>
 ;
 ; @author Andreas Schildbach
 ;;
#_suppress #_[ "PublicStaticCollectionField" ]
#_public
(ยง class DeterministicKeyChain (ยง implements EncryptableKeyChain)
    #_private
    #_static
    (ยง def- #_"Logger" DeterministicKeyChain/log (LoggerFactory/getLogger DeterministicKeyChain))
    #_public
    #_static
    (ยง def #_"String" DeterministicKeyChain/DEFAULT_PASSPHRASE_FOR_MNEMONIC "")

    #_protected
    (ยง field #_"ReentrantLock" :lock (Threading/lock "DeterministicKeyChain"))

    #_private
    (ยง field- #_"DeterministicHierarchy" :hierarchy)
    #_nilable
    #_private
    (ยง field- #_"DeterministicKey" :root-key)
    #_nilable
    #_private
    (ยง field- #_"DeterministicSeed" :seed)

    ;; Paths through the key tree.  External keys are ones that are communicated to other parties.  Internal keys are
    ;; keys created for change addresses, coinbases, mixing, etc - anything that isn't communicated.  The distinction
    ;; is somewhat arbitrary but can be useful for audits.  The first number is the "account number" but we don't use
    ;; that feature yet.  In future we might hand out different accounts for cases where we wish to hand payers
    ;; a payment request that can generate lots of addresses independently.
    ;; The account path may be overridden by subclasses.
    #_public
    #_static
    (ยง def #_"ImmutableList<ChildNumber>" DeterministicKeyChain/ACCOUNT_ZERO_PATH (ImmutableList/of ChildNumber/ZERO_HARDENED))
    #_public
    #_static
    (ยง def #_"ImmutableList<ChildNumber>" DeterministicKeyChain/EXTERNAL_SUBPATH (ImmutableList/of ChildNumber/ZERO))
    #_public
    #_static
    (ยง def #_"ImmutableList<ChildNumber>" DeterministicKeyChain/INTERNAL_SUBPATH (ImmutableList/of ChildNumber/ONE))
    #_public
    #_static
    (ยง def #_"ImmutableList<ChildNumber>" DeterministicKeyChain/EXTERNAL_PATH (HDUtils/concat DeterministicKeyChain/ACCOUNT_ZERO_PATH, DeterministicKeyChain/EXTERNAL_SUBPATH))
    #_public
    #_static
    (ยง def #_"ImmutableList<ChildNumber>" DeterministicKeyChain/INTERNAL_PATH (HDUtils/concat DeterministicKeyChain/ACCOUNT_ZERO_PATH, DeterministicKeyChain/INTERNAL_SUBPATH))
    ;; m / 44' / 0' / 0'
    #_public
    #_static
    (ยง def #_"ImmutableList<ChildNumber>" DeterministicKeyChain/BIP44_ACCOUNT_ZERO_PATH (ImmutableList/of (ChildNumber. 44, true), ChildNumber/ZERO_HARDENED, ChildNumber/ZERO_HARDENED))

    ;; We try to ensure we have at least this many keys ready and waiting to be handed out via getKey().  See docs
    ;; for getLookaheadSize() for more info on what this is for.  The -1 value means it hasn't been calculated yet.
    ;; For new chains it's set to whatever the default is, unless overridden by setLookaheadSize.  For deserialized
    ;; chains, it will be calculated on demand from the number of loaded keys.
    #_private
    #_static
    (ยง def- #_"int" DeterministicKeyChain/LAZY_CALCULATE_LOOKAHEAD -1)
    #_protected
    (ยง field #_"int" :lookahead-size 100)
    ;; The lookahead threshold causes us to batch up creation of new keys to minimize the frequency of Bloom filter
    ;; regenerations, which are expensive and will (in future) trigger chain download stalls/retries.  One third is
    ;; an efficiency tradeoff.
    #_protected
    (ยง field #_"int" :lookahead-threshold (.. this (calcDefaultLookaheadThreshold)))

    #_private
    (ยง method- #_"int" calcDefaultLookaheadThreshold []
        (/ (:lookahead-size this) 3)
    )

    ;; The parent keys for external keys (handed out to other people) and internal keys (used for change addresses).
    #_private
    (ยง field- #_"DeterministicKey" :external-parent-key)
    #_private
    (ยง field- #_"DeterministicKey" :internal-parent-key)
    ;; How many keys on each path have actually been used.  This may be fewer than the number that have been
    ;; deserialized or held in memory, because of the lookahead zone.
    #_private
    (ยง field- #_"int" :issued-external-keys)
    #_private
    (ยง field- #_"int" :issued-internal-keys)
    ;; A counter that is incremented each time a key in the lookahead threshold zone is marked as used and lookahead
    ;; is triggered.  The Wallet/KCG reads these counters and combines them so it can tell the Peer whether to throw
    ;; away the current block (and any future blocks in the same download batch) and restart chain sync once a new filter
    ;; has been calculated.  This field isn't persisted to the wallet as it's only relevant within a network session.
    #_private
    (ยง field- #_"int" :key-lookahead-epoch)

    ;; We simplify by wrapping a basic key chain and that way we get some functionality like key lookup and event
    ;; listeners "for free".  All keys in the key tree appear here, even if they aren't meant to be used for
    ;; receiving money.
    #_private
    (ยง field- #_"BasicKeyChain" :basic-key-chain)

    ;; If set this chain is following another chain in a married KeyChainGroup.
    #_private
    (ยง field- #_"boolean" :is-following)

    ;; Holds a number of signatures required to spend.  It's the N from N-of-M CHECKMULTISIG script for P2SH transactions
    ;; and always 1 for other transaction types.
    #_protected
    (ยง field #_"int" :sigs-required-to-spend 1)

    #_public
    #_static
    (ยง class DeterministicKeyChain.Builder #_"<T extends DeterministicKeyChain.Builder<T>>"
        #_protected
        (ยง field #_"SecureRandom" :random)
        #_protected
        (ยง field #_"int" :bits 128)
        #_protected
        (ยง field #_"String" :passphrase)
        #_protected
        (ยง field #_"long" :seed-creation-time-secs)
        #_protected
        (ยง field #_"byte[]" :entropy)
        #_protected
        (ยง field #_"DeterministicSeed" :seed)
        #_protected
        (ยง field #_"DeterministicKey" :watching-key)

        #_protected
        (ยง constructor DeterministicKeyChain.Builder []
            this
        )

        #_suppress #_[ "unchecked" ]
        #_protected
        (ยง method #_"T" self []
            (cast T this)
        )

        ;;;
         ; Creates a deterministic key chain starting from the given entropy.  All keys yielded by this chain will be the
         ; same if the starting entropy is the same.  You should provide the creation time in seconds since the UNIX epoch
         ; for the seed: this lets us know from what part of the chain we can expect to see derived keys appear.
         ;;
        #_public
        (ยง method #_"T" entropy [#_"byte[]" __entropy]
            (ยง assoc this :entropy __entropy)
            (.. this (self))
        )

        ;;;
         ; Creates a deterministic key chain starting from the given seed.  All keys yielded by this chain will be the same
         ; if the starting seed is the same.
         ;;
        #_public
        (ยง method #_"T" seed [#_"DeterministicSeed" __seed]
            (ยง assoc this :seed __seed)
            (.. this (self))
        )

        ;;;
         ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom} object
         ; and of the requested size in bits.  The derived seed is further protected with a user selected passphrase (see BIP 39).
         ; @param random The random number generator - use new SecureRandom().
         ; @param bits The number of bits of entropy to use when generating entropy.  Either 128 (default), 192 or 256.
         ;;
        #_public
        (ยง method #_"T" random [#_"SecureRandom" __random, #_"int" __bits]
            (ยง assoc this :random __random)
            (ยง assoc this :bits __bits)
            (.. this (self))
        )

        ;;;
         ; Generates a new key chain with 128 bits of entropy selected randomly from the given {@link java.security.SecureRandom}
         ; object.  The derived seed is further protected with a user selected passphrase (see BIP 39).
         ; @param random The random number generator - use new SecureRandom().
         ;;
        #_public
        (ยง method #_"T" random [#_"SecureRandom" __random]
            (ยง assoc this :random __random)
            (.. this (self))
        )

        #_public
        (ยง method #_"T" watchingKey [#_"DeterministicKey" __watchingKey]
            (ยง assoc this :watching-key __watchingKey)
            (.. this (self))
        )

        #_public
        (ยง method #_"T" seedCreationTimeSecs [#_"long" __seedCreationTimeSecs]
            (ยง assoc this :seed-creation-time-secs __seedCreationTimeSecs)
            (.. this (self))
        )

        ;;;
         ; The passphrase to use with the generated mnemonic, or null if you would like to use the default empty string.
         ; Currently must be the empty string.
         ;;
        #_public
        (ยง method #_"T" passphrase [#_"String" __passphrase]
            ;; FIXME support non-empty passphrase
            (ยง assoc this :passphrase __passphrase)
            (.. this (self))
        )

        #_public
        (ยง method #_"DeterministicKeyChain" build []
            (Preconditions/checkState (or (some? (:random this)) (some? (:entropy this)) (some? (:seed this)) (some? (:watching-key this))), "Must provide either entropy or random or seed or watchingKey")
            (Preconditions/checkState (or (nil? (:passphrase this)) (nil? (:seed this))), "Passphrase must not be specified with seed")

            ;; Default passphrase to "" if not specified.
            (when (some? (:random this))
                (ยง return (DeterministicKeyChain. (:random this), (:bits this), (.. this (getPassphrase)), (:seed-creation-time-secs this)))
            )

            (when (some? (:entropy this))
                (ยง return (DeterministicKeyChain. (:entropy this), (.. this (getPassphrase)), (:seed-creation-time-secs this)))
            )

            (when (some? (:seed this))
                (.. (:seed this) (setCreationTimeSeconds (:seed-creation-time-secs this)))
                (ยง return (DeterministicKeyChain. (:seed this)))
            )

            (.. (:watching-key this) (setCreationTimeSeconds (:seed-creation-time-secs this)))
            (DeterministicKeyChain. (:watching-key this))
        )

        #_protected
        (ยง method #_"String" getPassphrase []
            (or (:passphrase this) DeterministicKeyChain/DEFAULT_PASSPHRASE_FOR_MNEMONIC)
        )
    )

    #_public
    #_static
    (ยง defn #_"DeterministicKeyChain.Builder<?>" DeterministicKeyChain/builder []
        (DeterministicKeyChain.Builder.)
    )

    ;;;
     ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
     ; object and the default entropy size.
     ;;
    #_public
    (ยง constructor DeterministicKeyChain [#_"SecureRandom" __random]
        (ยง this __random, DeterministicSeed/DEFAULT_SEED_ENTROPY_BITS, DeterministicKeyChain/DEFAULT_PASSPHRASE_FOR_MNEMONIC, (Utils/currentTimeSeconds))
        this
    )

    ;;;
     ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
     ; object and of the requested size in bits.
     ;;
    #_public
    (ยง constructor DeterministicKeyChain [#_"SecureRandom" __random, #_"int" __bits]
        (ยง this __random, __bits, DeterministicKeyChain/DEFAULT_PASSPHRASE_FOR_MNEMONIC, (Utils/currentTimeSeconds))
        this
    )

    ;;;
     ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
     ; object and of the requested size in bits.  The derived seed is further protected with a user selected passphrase
     ; (see BIP 39).
     ;;
    #_public
    (ยง constructor DeterministicKeyChain [#_"SecureRandom" __random, #_"int" __bits, #_"String" __passphrase, #_"long" __seedCreationTimeSecs]
        (ยง this (DeterministicSeed. __random, __bits, __passphrase, __seedCreationTimeSecs))
        this
    )

    ;;;
     ; Creates a deterministic key chain starting from the given entropy.  All keys yielded by this chain will be the
     ; same if the starting seed is the same.  You should provide the creation time in seconds since the UNIX epoch
     ; for the seed: this lets us know from what part of the chain we can expect to see derived keys appear.
     ;;
    #_public
    (ยง constructor DeterministicKeyChain [#_"byte[]" __entropy, #_"String" __passphrase, #_"long" __seedCreationTimeSecs]
        (ยง this (DeterministicSeed. __entropy, __passphrase, __seedCreationTimeSecs))
        this
    )

    ;;;
     ; Creates a deterministic key chain starting from the given seed.  All keys yielded by this chain will be the
     ; same if the starting seed is the same.
     ;;
    #_protected
    (ยง constructor DeterministicKeyChain [#_"DeterministicSeed" __seed]
        (ยง this __seed, nil)
        this
    )

    ;;;
     ; Creates a deterministic key chain that watches the given (public only) root key.  You can use this to calculate
     ; balances and generally follow along, but spending is not possible with such a chain.  Currently you can't use
     ; this method to watch an arbitrary fragment of some other tree, this limitation may be removed in future.
     ;;
    #_public
    (ยง constructor DeterministicKeyChain [#_"DeterministicKey" __watchingKey]
        (Preconditions/checkArgument (.. __watchingKey (isPubKeyOnly)), "Private subtrees not currently supported: if you got this key from DKC.getWatchingKey() then use .dropPrivate().dropParent() on it first.")
        (Preconditions/checkArgument (== (.. __watchingKey (getPath) (size)) (.. this (getAccountPath) (size))), "You can only watch an account key currently")

        (ยง assoc this :basic-key-chain (BasicKeyChain.))
        (ยง assoc this :seed nil)
        (ยง assoc this :root-key nil)
        (.. (:basic-key-chain this) (importKey __watchingKey))
        (ยง assoc this :hierarchy (DeterministicHierarchy. __watchingKey))
        (.. this (initializeHierarchyUnencrypted __watchingKey))
        this
    )

    ;;;
     ; <p>Creates a deterministic key chain with the given watch key.  If <code>isFollowing</code> flag is set then this
     ; keychain follows some other keychain.  In a married wallet following keychain represents "spouse's" keychain.</p>
     ; <p>Watch key has to be an account key.</p>
     ;;
    #_protected
    (ยง constructor DeterministicKeyChain [#_"DeterministicKey" __watchKey, #_"boolean" __isFollowing]
        (ยง this __watchKey)
        (ยง assoc this :is-following __isFollowing)
        this
    )

    ;;;
     ; Creates a deterministic key chain with the given watch key and that follows some other keychain.
     ; In a married wallet following keychain represents "spouse".
     ; Watch key has to be an account key.
     ;;
    #_public
    #_static
    (ยง defn #_"DeterministicKeyChain" DeterministicKeyChain/watchAndFollow [#_"DeterministicKey" __watchKey]
        (DeterministicKeyChain. __watchKey, true)
    )

    ;;;
     ; Creates a key chain that watches the given account key.
     ;;
    #_public
    #_static
    (ยง defn #_"DeterministicKeyChain" DeterministicKeyChain/watch [#_"DeterministicKey" __accountKey]
        (DeterministicKeyChain. __accountKey)
    )

    ;;;
     ; For use in {@link KeyChainFactory} during deserialization.
     ;;
    #_protected
    (ยง constructor DeterministicKeyChain [#_"DeterministicSeed" __seed, #_nilable #_"KeyCrypter" __crypter]
        (ยง assoc this :seed __seed)
        (ยง assoc this :basic-key-chain (BasicKeyChain. __crypter))
        (when (not (.. __seed (isEncrypted)))
            (ยง assoc this :root-key (HDKeyDerivation/createMasterPrivateKey (Preconditions/checkNotNull (.. __seed (getSeedBytes)))))
            (.. (:root-key this) (setCreationTimeSeconds (.. __seed (getCreationTimeSeconds))))
            (.. (:basic-key-chain this) (importKey (:root-key this)))
            (ยง assoc this :hierarchy (DeterministicHierarchy. (:root-key this)))
            (loop-when-recur [#_"int" __i 1] (<= __i (.. this (getAccountPath) (size))) [(inc __i)]
                (.. (:basic-key-chain this) (importKey (.. (:hierarchy this) (get (.. this (getAccountPath) (subList 0, __i)), false, true))))
            )
            (.. this (initializeHierarchyUnencrypted (:root-key this)))
        )
        ;; Else...
        ;; We can't initialize ourselves with just an encrypted seed, so we expected deserialization code
        ;; to do the rest of the setup (loading the root key).
        this
    )

    ;;;
     ; For use in encryption when {@link #toEncrypted(KeyCrypter, KeyParameter)} is called,
     ; so that subclasses can override that method and create an instance of the right class.
     ;
     ; See also {@link #makeKeyChainFromSeed(DeterministicSeed)}.
     ;;
    #_protected
    (ยง constructor DeterministicKeyChain [#_"KeyCrypter" __crypter, #_"KeyParameter" __aesKey, #_"DeterministicKeyChain" __chain]
        ;; Can't encrypt a watching chain.
        (Preconditions/checkNotNull (:root-key __chain))
        (Preconditions/checkNotNull (:seed __chain))

        (Preconditions/checkArgument (not (.. (:root-key __chain) (isEncrypted))), "Chain already encrypted")

        (ยง assoc this :issued-external-keys (:issued-external-keys __chain))
        (ยง assoc this :issued-internal-keys (:issued-internal-keys __chain))

        (ยง assoc this :lookahead-size (:lookahead-size __chain))
        (ยง assoc this :lookahead-threshold (:lookahead-threshold __chain))

        (ยง assoc this :seed (.. (:seed __chain) (encrypt __crypter, __aesKey)))
        (ยง assoc this :basic-key-chain (BasicKeyChain. __crypter))
        ;; The first number is the "account number" but we don't use that feature.
        (ยง assoc this :root-key (.. (:root-key __chain) (encrypt __crypter, __aesKey, nil)))
        (ยง assoc this :hierarchy (DeterministicHierarchy. (:root-key this)))
        (.. (:basic-key-chain this) (importKey (:root-key this)))

        (loop-when-recur [#_"int" __i 1] (< __i (.. this (getAccountPath) (size))) [(inc __i)]
            (.. this (encryptNonLeaf __aesKey, __chain, (:root-key this), (.. this (getAccountPath) (subList 0, __i))))
        )

        (let [#_"DeterministicKey" __account (.. this (encryptNonLeaf __aesKey, __chain, (:root-key this), (.. this (getAccountPath))))]
            (ยง assoc this :external-parent-key (.. this (encryptNonLeaf __aesKey, __chain, __account, (HDUtils/concat (.. this (getAccountPath)), DeterministicKeyChain/EXTERNAL_SUBPATH))))
            (ยง assoc this :internal-parent-key (.. this (encryptNonLeaf __aesKey, __chain, __account, (HDUtils/concat (.. this (getAccountPath)), DeterministicKeyChain/INTERNAL_SUBPATH))))

            ;; Now copy the (pubkey only) leaf keys across to avoid rederiving them.  The private key bytes are missing
            ;; anyway so there's nothing to encrypt.
            (doseq [#_"ECKey" __eckey (.. (:basic-key-chain __chain) (getKeys))]
                (let [#_"DeterministicKey" __key (cast DeterministicKey __eckey)]
                    (when (!= (.. __key (getPath) (size)) (+ (.. this (getAccountPath) (size)) 2))
                        (ยง continue ) ;; Not a leaf key.
                    )

                    (let [#_"DeterministicKey" __parent (.. (:hierarchy this) (get (.. (Preconditions/checkNotNull (.. __key (getParent))) (getPath)), false, false))]
                        ;; Clone the key to the new encrypted hierarchy.
                        (ยง ass __key (DeterministicKey. (.. __key (dropPrivateBytes)), __parent))
                        (.. (:hierarchy this) (putKey __key))
                        (.. (:basic-key-chain this) (importKey __key))
                    )
                )
            )
            this
        )
    )

    ;;; Override in subclasses to use a different account derivation path. ;;
    #_protected
    (ยง method #_"ImmutableList<ChildNumber>" getAccountPath []
        DeterministicKeyChain/ACCOUNT_ZERO_PATH
    )

    #_private
    (ยง method- #_"DeterministicKey" encryptNonLeaf [#_"KeyParameter" __aesKey, #_"DeterministicKeyChain" __chain, #_"DeterministicKey" __parent, #_"ImmutableList<ChildNumber>" __path]
        (let [#_"DeterministicKey" __key (.. (:hierarchy __chain) (get __path, false, false))]
            (ยง ass __key (.. __key (encrypt (Preconditions/checkNotNull (.. (:basic-key-chain this) (getKeyCrypter))), __aesKey, __parent)))
            (.. (:hierarchy this) (putKey __key))
            (.. (:basic-key-chain this) (importKey __key))
            __key
        )
    )

    ;; Derives the account path keys and inserts them into the basic key chain.
    ;; This is important to preserve their order for serialization, amongst other things.
    #_private
    (ยง method- #_"void" initializeHierarchyUnencrypted [#_"DeterministicKey" __baseKey]
        (ยง assoc this :external-parent-key (.. (:hierarchy this) (deriveChild (.. this (getAccountPath)), false, false, ChildNumber/ZERO)))
        (ยง assoc this :internal-parent-key (.. (:hierarchy this) (deriveChild (.. this (getAccountPath)), false, false, ChildNumber/ONE)))
        (.. (:basic-key-chain this) (importKey (:external-parent-key this)))
        (.. (:basic-key-chain this) (importKey (:internal-parent-key this)))
        nil
    )

    ;;; Returns a freshly derived key that has not been returned by this method before. ;;
    #_override
    #_public
    (ยง method #_"DeterministicKey" getKey [#_"KeyChain.KeyPurpose" __purpose]
        (.. this (getKeys __purpose, 1) (get 0))
    )

    ;;; Returns freshly derived key/s that have not been returned by this method before. ;;
    #_override
    #_public
    (ยง method #_"List<DeterministicKey>" getKeys [#_"KeyChain.KeyPurpose" __purpose, #_"int" __numberOfKeys]
        (Preconditions/checkArgument (< 0 __numberOfKeys))
        (.. (:lock this) (lock))
        (try
            ;; Map both REFUND and RECEIVE_KEYS to the same branch for now.  Refunds are a feature of the BIP 70
            ;; payment protocol.  Later we may wish to map it to a different branch (in a new wallet version?).
            ;; This would allow a watching wallet to only be able to see inbound payments, but not change
            ;; (i.e. spends) or refunds.  Might be useful for auditing ...
            (let [[#_"int" __index #_"DeterministicKey" __parentKey]
                    (condp ==? __purpose
                        [RECEIVE_FUNDS REFUND]
                            (do
                                (ยง assoc this :issued-external-keys (+ (:issued-external-keys this) __numberOfKeys))
                                [(:issued-external-keys this) (:external-parent-key this)]
                            )
                        [AUTHENTICATION CHANGE]
                            (do
                                (ยง assoc this :issued-internal-keys (+ (:issued-internal-keys this) __numberOfKeys))
                                [(:issued-internal-keys this) (:internal-parent-key this)]
                            )
                        (throw (UnsupportedOperationException.))
                    )]
                ;; Optimization: potentially do a very quick key generation for just the number of keys we need if we
                ;; didn't already create them, ignoring the configured lookahead size.  This ensures we'll be able to
                ;; retrieve the keys in the following loop, but if we're totally fresh and didn't get a chance to
                ;; calculate the lookahead keys yet, this will not block waiting to calculate 100+ EC point multiplies.
                ;; On slow/crappy Android phones looking ahead 100 keys can take ~5 seconds but the OS will kill us
                ;; if we block for just one second on the UI thread.  Because UI threads may need an address in order
                ;; to render the screen, we need getKeys to be fast even if the wallet is totally brand new and lookahead
                ;; didn't happen yet.
                ;;
                ;; It's safe to do this because when a network thread tries to calculate a Bloom filter, we'll go ahead
                ;; and calculate the full lookahead zone there, so network requests will always use the right amount.
                (let [#_"List<DeterministicKey>" __lookahead (.. this (maybeLookAhead __parentKey, __index, 0, 0))]
                    (.. (:basic-key-chain this) (importKeys __lookahead))
                    (let [#_"List<DeterministicKey>" __keys (ArrayList. #_"<>" __numberOfKeys)]
                        (loop-when-recur [#_"int" __i 0] (< __i __numberOfKeys) [(inc __i)]
                            (let [#_"ImmutableList<ChildNumber>" __path (HDUtils/append (.. __parentKey (getPath)), (ChildNumber. (+ (- __index __numberOfKeys) __i), false))
                                  #_"DeterministicKey" __k (.. (:hierarchy this) (get __path, false, false))]
                                ;; Just a last minute sanity check before we hand the key out to the app for usage.  This isn't
                                ;; inspired by any real problem reports from bitcoinj users, but I've heard of cases via the grapevine
                                ;; of places that lost money due to bitflips causing addresses to not match keys.  Of course in an
                                ;; environment with flaky RAM there's no real way to always win: bitflips could be introduced at any
                                ;; other layer.  But as we're potentially retrieving from long term storage here, check anyway.
                                (.. this (checkForBitFlip __k))
                                (.. __keys (add __k))
                            )
                        )
                        (ยง return __keys)
                    )
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_private
    (ยง method- #_"void" checkForBitFlip [#_"DeterministicKey" __k]
        (let [#_"DeterministicKey" __parent (Preconditions/checkNotNull (.. __k (getParent)))
              #_"byte[]" __rederived (:key-bytes (HDKeyDerivation/deriveChildKeyBytesFromPublic __parent, (.. __k (getChildNumber)), HDKeyDerivation.PublicDeriveMode/WITH_INVERSION))
              #_"byte[]" __actual (.. __k (getPubKey))]
            (when (not (Arrays/equals __rederived, __actual))
                (throw (IllegalStateException. (String/format Locale/US, "Bit-flip check failed: %s vs %s", (Arrays/toString __rederived), (Arrays/toString __actual))))
            )
            nil
        )
    )

    ;;;
     ; Mark the DeterministicKey as used.
     ; Also correct the issued{Internal|External}Keys counter, because all lower children seem to be requested already.
     ; If the counter was updated, we also might trigger lookahead.
     ;;
    #_public
    (ยง method #_"DeterministicKey" markKeyAsUsed [#_"DeterministicKey" __k]
        (let [#_"int" __numChildren (inc (.. __k (getChildNumber) (i)))]

            (cond (== (.. __k (getParent)) (:internal-parent-key this))
                (do
                    (when (< (:issued-internal-keys this) __numChildren)
                        (ยง assoc this :issued-internal-keys __numChildren)
                        (.. this (maybeLookAhead))
                    )
                )
                (== (.. __k (getParent)) (:external-parent-key this))
                (do
                    (when (< (:issued-external-keys this) __numChildren)
                        (ยง assoc this :issued-external-keys __numChildren)
                        (.. this (maybeLookAhead))
                    )
                )
            )
            __k
        )
    )

    #_public
    (ยง method #_"DeterministicKey" findKeyFromPubHash [#_"byte[]" __pubkeyHash]
        (.. (:lock this) (lock))
        (try
            (cast DeterministicKey (.. (:basic-key-chain this) (findKeyFromPubHash __pubkeyHash)))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_public
    (ยง method #_"DeterministicKey" findKeyFromPubKey [#_"byte[]" __pubkey]
        (.. (:lock this) (lock))
        (try
            (cast DeterministicKey (.. (:basic-key-chain this) (findKeyFromPubKey __pubkey)))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkeyHash.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_nilable
    #_public
    (ยง method #_"DeterministicKey" markPubHashAsUsed [#_"byte[]" __pubkeyHash]
        (.. (:lock this) (lock))
        (try
            (let [#_"DeterministicKey" __k (cast DeterministicKey (.. (:basic-key-chain this) (findKeyFromPubHash __pubkeyHash)))]
                (when (some? __k)
                    (.. this (markKeyAsUsed __k))
                )
                (ยง return __k)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkey.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_nilable
    #_public
    (ยง method #_"DeterministicKey" markPubKeyAsUsed [#_"byte[]" __pubkey]
        (.. (:lock this) (lock))
        (try
            (let [#_"DeterministicKey" __k (cast DeterministicKey (.. (:basic-key-chain this) (findKeyFromPubKey __pubkey)))]
                (when (some? __k)
                    (.. this (markKeyAsUsed __k))
                )
                (ยง return __k)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_override
    #_public
    (ยง method #_"boolean" hasKey [#_"ECKey" __key]
        (.. (:lock this) (lock))
        (try
            (.. (:basic-key-chain this) (hasKey __key))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;; Returns the deterministic key for the given absolute path in the hierarchy. ;;
    #_protected
    (ยง method #_"DeterministicKey" getKeyByPath [#_"ChildNumber..." __path]
        (.. this (getKeyByPath (ImmutableList/copyOf __path)))
    )

    ;;; Returns the deterministic key for the given absolute path in the hierarchy. ;;
    #_protected
    (ยง method #_"DeterministicKey" getKeyByPath [#_"List<ChildNumber>" __path]
        (.. this (getKeyByPath __path, false))
    )

    ;;; Returns the deterministic key for the given absolute path in the hierarchy, optionally creating it. ;;
    #_public
    (ยง method #_"DeterministicKey" getKeyByPath [#_"List<ChildNumber>" __path, #_"boolean" __create]
        (.. (:hierarchy this) (get __path, false, __create))
    )

    ;;;
     ; <p>An alias for <code>getKeyByPath(getAccountPath())</code>.</p>
     ;
     ; <p>Use this when you would like to create a watching key chain that follows this one, but can't spend money from it.
     ; The returned key can be serialized and then passed into {@link #watch(org.bitcoinj.crypto.DeterministicKey)}
     ; on another system to watch the hierarchy.</p>
     ;
     ; <p>Note that the returned key is not pubkey only unless this key chain already is: the returned key can still
     ; be used for signing etc if the private key bytes are available.</p>
     ;;
    #_public
    (ยง method #_"DeterministicKey" getWatchingKey []
        (.. this (getKeyByPath (.. this (getAccountPath))))
    )

    ;;; Returns true if this chain is watch only, meaning it has public keys but no private key. ;;
    #_public
    (ยง method #_"boolean" isWatching []
        (.. this (getWatchingKey) (isWatching))
    )

    #_override
    #_public
    (ยง method #_"int" numKeys []
        ;; We need to return here the total number of keys including the lookahead zone, not the number
        ;; of keys we have issued via getKey/freshReceiveKey.
        (.. (:lock this) (lock))
        (try
            (.. this (maybeLookAhead))
            (.. (:basic-key-chain this) (numKeys))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns number of leaf keys used including both internal and external paths.  This may be fewer
     ; than the number that have been deserialized or held in memory, because of the lookahead zone.
     ;;
    #_public
    (ยง method #_"int" numLeafKeysIssued []
        (.. (:lock this) (lock))
        (try
            (+ (:issued-external-keys this) (:issued-internal-keys this))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_override
    #_public
    (ยง method #_"long" getEarliestKeyCreationTime []
        (if (some? (:seed this)) (.. (:seed this) (getCreationTimeSeconds)) (.. this (getWatchingKey) (getCreationTimeSeconds)))
    )

    #_override
    #_public
    (ยง method #_"void" addEventListener [#_"KeyChainEventListener" __listener]
        (.. (:basic-key-chain this) (addEventListener __listener))
        nil
    )

    #_override
    #_public
    (ยง method #_"void" addEventListener [#_"KeyChainEventListener" __listener, #_"Executor" __executor]
        (.. (:basic-key-chain this) (addEventListener __listener, __executor))
        nil
    )

    #_override
    #_public
    (ยง method #_"boolean" removeEventListener [#_"KeyChainEventListener" __listener]
        (.. (:basic-key-chain this) (removeEventListener __listener))
    )

    ;;; Returns a list of words that represent the seed or null if this chain is a watching chain. ;;
    #_nilable
    #_public
    (ยง method #_"List<String>" getMnemonicCode []
        (when (nil? (:seed this))
            (ยง return nil)
        )

        (.. (:lock this) (lock))
        (try
            (.. (:seed this) (getMnemonicCode))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Return true if this keychain is following another keychain.
     ;;
    #_public
    (ยง method #_"boolean" isFollowing []
        (:is-following this)
    )

    #_override
    #_public
    (ยง method #_"List<Protos.Key>" serializeToProtobuf []
        (let [#_"List<Protos.Key>" __result (Lists/newArrayList)]
            (.. (:lock this) (lock))
            (try
                (.. __result (addAll (.. this (serializeMyselfToProtobuf))))
                (finally
                    (.. (:lock this) (unlock))
                )
            )
            __result
        )
    )

    #_protected
    (ยง method #_"List<Protos.Key>" serializeMyselfToProtobuf []
        ;; Most of the serialization work is delegated to the basic key chain, which will serialize the bulk of the
        ;; data (handling encryption along the way), and letting us patch it up with the extra data we care about.
        (let [#_"LinkedList<Protos.Key>" __entries (Lists/newLinkedList)]
            (when (some? (:seed this))
                (let [#_"Protos.Key.Builder" __mnemonicEntry (BasicKeyChain/serializeEncryptableItem (:seed this))]
                    (.. __mnemonicEntry (setType Protos.Key.Type/DETERMINISTIC_MNEMONIC))
                    (DeterministicKeyChain/serializeSeedEncryptableItem (:seed this), __mnemonicEntry)
                    (.. __entries (add (.. __mnemonicEntry (build))))
                )
            )
            (let [#_"Map<ECKey, Protos.Key.Builder>" __keys (.. (:basic-key-chain this) (serializeToEditableProtobufs))]
                (doseq [#_"Map.Entry<ECKey, Protos.Key.Builder>" __entry (.. __keys (entrySet))]
                    (let [#_"DeterministicKey" __key (cast DeterministicKey (.. __entry (getKey)))
                          #_"Protos.Key.Builder" __proto (.. __entry (getValue))]
                        (.. __proto (setType Protos.Key.Type/DETERMINISTIC_KEY))
                        (let [#_"Protos.DeterministicKey.Builder" __detKey (.. __proto (getDeterministicKeyBuilder))]
                            (.. __detKey (setChainCode (ByteString/copyFrom (.. __key (getChainCode)))))
                            (doseq [#_"ChildNumber" __num (.. __key (getPath))]
                                (.. __detKey (addPath (.. __num (i))))
                            )
                            (cond (.. __key (equals (:external-parent-key this)))
                                (do
                                    (.. __detKey (setIssuedSubkeys (:issued-external-keys this)))
                                    (.. __detKey (setLookaheadSize (:lookahead-size this)))
                                    (.. __detKey (setSigsRequiredToSpend (.. this (getSigsRequiredToSpend))))
                                )
                                (.. __key (equals (:internal-parent-key this)))
                                (do
                                    (.. __detKey (setIssuedSubkeys (:issued-internal-keys this)))
                                    (.. __detKey (setLookaheadSize (:lookahead-size this)))
                                    (.. __detKey (setSigsRequiredToSpend (.. this (getSigsRequiredToSpend))))
                                )
                            )
                            ;; Flag the very first key of following keychain.
                            (when (and (.. __entries (isEmpty)) (.. this (isFollowing)))
                                (.. __detKey (setIsFollowing true))
                            )
                            ;; HD keys inherit the timestamp of their parent if they have one, so no need to serialize it.
                            (when (some? (.. __key (getParent)))
                                (.. __proto (clearCreationTimestamp))
                            )
                            (.. __entries (add (.. __proto (build))))
                        )
                    )
                )
                __entries
            )
        )
    )

    #_static
    #_throws #_[ "UnreadableWalletException" ]
    (ยง defn #_"List<DeterministicKeyChain>" DeterministicKeyChain/fromProtobuf [#_"List<Protos.Key>" __keys, #_nilable #_"KeyCrypter" __crypter]
        (DeterministicKeyChain/fromProtobuf __keys, __crypter, (DefaultKeyChainFactory.))
    )

    ;;;
     ; Returns all the key chains found in the given list of keys.  Typically there will only be one,
     ; but in the case of key rotation it can happen that there are multiple chains found.
     ;;
    #_public
    #_static
    #_throws #_[ "UnreadableWalletException" ]
    (ยง defn #_"List<DeterministicKeyChain>" DeterministicKeyChain/fromProtobuf [#_"List<Protos.Key>" __keys, #_nilable #_"KeyCrypter" __crypter, #_"KeyChainFactory" __factory]
        (let [#_"List<DeterministicKeyChain>" __chains (Lists/newLinkedList)
              #_"DeterministicSeed" __seed nil
              #_"DeterministicKeyChain" __chain nil]

            (let [#_"int" __lookaheadSize -1
                  #_"int" __sigsRequiredToSpend 1]

                (let [#_"PeekingIterator<Protos.Key>" __iter (Iterators/peekingIterator (.. __keys (iterator)))]
                    (while (.. __iter (hasNext))
                        (let [#_"Protos.Key" __key (.. __iter (next))
                              #_"Protos.Key.Type" __t (.. __key (getType))]
                            (cond (== __t Protos.Key.Type/DETERMINISTIC_MNEMONIC)
                                (do
                                    (when (some? __chain)
                                        (Preconditions/checkState (<= 0 __lookaheadSize))

                                        (.. __chain (setLookaheadSize __lookaheadSize))
                                        (.. __chain (setSigsRequiredToSpend __sigsRequiredToSpend))
                                        (.. __chain (maybeLookAhead))
                                        (.. __chains (add __chain))
                                        (ยง ass __chain nil)
                                    )
                                    (let [#_"long" __timestamp (/ (.. __key (getCreationTimestamp)) 1000)
                                          #_"String" __passphrase DeterministicKeyChain/DEFAULT_PASSPHRASE_FOR_MNEMONIC] ;; FIXME allow non-empty passphrase
                                        (cond (.. __key (hasSecretBytes))
                                            (do
                                                (when (.. __key (hasEncryptedDeterministicSeed))
                                                    (throw (UnreadableWalletException. (str "Malformed key proto: " __key)))
                                                )

                                                (let [#_"byte[]" __seedBytes nil]
                                                    (when (.. __key (hasDeterministicSeed))
                                                        (ยง ass __seedBytes (.. __key (getDeterministicSeed) (toByteArray)))
                                                    )
                                                    (ยง ass __seed (DeterministicSeed. (.. __key (getSecretBytes) (toStringUtf8)), __seedBytes, __passphrase, __timestamp))
                                                )
                                            )
                                            (.. __key (hasEncryptedData))
                                            (do
                                                (when (.. __key (hasDeterministicSeed))
                                                    (throw (UnreadableWalletException. (str "Malformed key proto: " __key)))
                                                )

                                                (let [#_"EncryptedData" __data (EncryptedData. (.. __key (getEncryptedData) (getInitialisationVector) (toByteArray)), (.. __key (getEncryptedData) (getEncryptedPrivateKey) (toByteArray)))
                                                      #_"EncryptedData" __encryptedSeedBytes nil]
                                                    (when (.. __key (hasEncryptedDeterministicSeed))
                                                        (let [#_"Protos.EncryptedData" __encryptedSeed (.. __key (getEncryptedDeterministicSeed))]
                                                            (ยง ass __encryptedSeedBytes (EncryptedData. (.. __encryptedSeed (getInitialisationVector) (toByteArray)), (.. __encryptedSeed (getEncryptedPrivateKey) (toByteArray))))
                                                        )
                                                    )
                                                    (ยง ass __seed (DeterministicSeed. __data, __encryptedSeedBytes, __timestamp))
                                                )
                                            )
                                            :else
                                            (do
                                                (throw (UnreadableWalletException. (str "Malformed key proto: " __key)))
                                            )
                                        )

                                        (when (.. DeterministicKeyChain/log (isDebugEnabled))
                                            (.. DeterministicKeyChain/log (debug "Deserializing: DETERMINISTIC_MNEMONIC: {}", __seed))
                                        )
                                    )
                                )
                                (== __t Protos.Key.Type/DETERMINISTIC_KEY)
                                (do
                                    (when (not (.. __key (hasDeterministicKey)))
                                        (throw (UnreadableWalletException. (str "Deterministic key missing extra data: " __key)))
                                    )

                                    (let [#_"byte[]" __chainCode (.. __key (getDeterministicKey) (getChainCode) (toByteArray))]
                                        ;; Deserialize the path through the tree.
                                        (let [#_"LinkedList<ChildNumber>" __path (Lists/newLinkedList)]
                                            (doseq [#_"int" __i (.. __key (getDeterministicKey) (getPathList))]
                                                (.. __path (add (ChildNumber. __i)))
                                            )

                                            ;; Deserialize the public key and path.
                                            (let [#_"LazyECPoint" __pubkey (LazyECPoint. (.. ECKey/CURVE (getCurve)), (.. __key (getPublicKey) (toByteArray)))
                                                  #_"ImmutableList<ChildNumber>" __immutablePath (ImmutableList/copyOf __path)]
                                                ;; Possibly create the chain, if we didn't already do so yet.
                                                (let [#_"boolean" __isWatchingAccountKey false
                                                      #_"boolean" __isFollowingKey false]
                                                    ;; Save previous chain if any if the key is marked as following.  Current key and the next ones
                                                    ;; are to be placed in new following key chain.
                                                    (when (.. __key (getDeterministicKey) (getIsFollowing))
                                                        (when (some? __chain)
                                                            (Preconditions/checkState (<= 0 __lookaheadSize))

                                                            (.. __chain (setLookaheadSize __lookaheadSize))
                                                            (.. __chain (setSigsRequiredToSpend __sigsRequiredToSpend))
                                                            (.. __chain (maybeLookAhead))
                                                            (.. __chains (add __chain))
                                                            (ยง ass __chain nil)
                                                            (ยง ass __seed nil)
                                                        )
                                                        (ยง ass __isFollowingKey true)
                                                    )

                                                    (when (nil? __chain)
                                                        ;; If this is not a following chain and previous was, this must be married.
                                                        (let [#_"boolean" __isMarried (and (not __isFollowingKey) (not (.. __chains (isEmpty))) (.. __chains (get (dec (.. __chains (size)))) (isFollowing)))]
                                                            (cond (nil? __seed)
                                                                (do
                                                                    (let [#_"DeterministicKey" __accountKey (DeterministicKey. __immutablePath, __chainCode, __pubkey, nil, nil)]
                                                                        (.. __accountKey (setCreationTimeSeconds (/ (.. __key (getCreationTimestamp)) 1000)))
                                                                        (ยง ass __chain (.. __factory (makeWatchingKeyChain __key, (.. __iter (peek)), __accountKey, __isFollowingKey, __isMarried)))
                                                                        (ยง ass __isWatchingAccountKey true)
                                                                    )
                                                                )
                                                                :else
                                                                (do
                                                                    (ยง ass __chain (.. __factory (makeKeyChain __key, (.. __iter (peek)), __seed, __crypter, __isMarried)))
                                                                    (ยง assoc __chain :lookahead-size DeterministicKeyChain/LAZY_CALCULATE_LOOKAHEAD)
                                                                    ;; If the seed is encrypted, then the chain is incomplete at this point.  However, we will load
                                                                    ;; it up below as we parse in the keys.  We just need to check at the end that we've loaded
                                                                    ;; everything afterwards.
                                                                )
                                                            )
                                                        )
                                                    )
                                                    ;; Find the parent key assuming this is not the root key, and not an account key for a watching chain.
                                                    (let [#_"DeterministicKey" __parent nil]
                                                        (when (and (not (.. __path (isEmpty))) (not __isWatchingAccountKey))
                                                            (let [#_"ChildNumber" __index (.. __path (removeLast))]
                                                                (ยง ass __parent (.. (:hierarchy __chain) (get __path, false, false)))
                                                                (.. __path (add __index))
                                                            )
                                                        )
                                                        (let [#_"DeterministicKey" __detkey]
                                                            (cond (.. __key (hasSecretBytes))
                                                                (do
                                                                    ;; Not encrypted: private key is available.
                                                                    (let [#_"BigInteger" __priv (BigInteger. 1, (.. __key (getSecretBytes) (toByteArray)))]
                                                                        (ยง ass __detkey (DeterministicKey. __immutablePath, __chainCode, __pubkey, __priv, __parent))
                                                                    )
                                                                )
                                                                :else
                                                                (do
                                                                    (cond (.. __key (hasEncryptedData))
                                                                        (do
                                                                            (let [#_"Protos.EncryptedData" __proto (.. __key (getEncryptedData))
                                                                                  #_"EncryptedData" __data (EncryptedData. (.. __proto (getInitialisationVector) (toByteArray)), (.. __proto (getEncryptedPrivateKey) (toByteArray)))]
                                                                                (Preconditions/checkNotNull __crypter, "Encountered an encrypted key but no key crypter provided")
                                                                                (ยง ass __detkey (DeterministicKey. __immutablePath, __chainCode, __crypter, __pubkey, __data, __parent))
                                                                            )
                                                                        )
                                                                        :else
                                                                        (do
                                                                            ;; No secret key bytes and key is not encrypted: either a watching key or private key bytes
                                                                            ;; will be rederived on the fly from the parent.
                                                                            (ยง ass __detkey (DeterministicKey. __immutablePath, __chainCode, __pubkey, nil, __parent))
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                            (when (.. __key (hasCreationTimestamp))
                                                                (.. __detkey (setCreationTimeSeconds (/ (.. __key (getCreationTimestamp)) 1000)))
                                                            )
                                                            (when (.. DeterministicKeyChain/log (isDebugEnabled))
                                                                (.. DeterministicKeyChain/log (debug "Deserializing: DETERMINISTIC_KEY: {}", __detkey))
                                                            )
                                                            (when (not __isWatchingAccountKey)
                                                                ;; If the non-encrypted case, the non-leaf keys (account, internal, external) have already
                                                                ;; been rederived and inserted at this point.  In the encrypted case though, we can't
                                                                ;; rederive and we must reinsert, potentially building the heirarchy object if need be.
                                                                (cond (== (.. __path (size)) 0)
                                                                    (do
                                                                        ;; Master key.
                                                                        (when (nil? (:root-key __chain))
                                                                            (ยง assoc __chain :root-key __detkey)
                                                                            (ยง assoc __chain :hierarchy (DeterministicHierarchy. __detkey))
                                                                        )
                                                                    )
                                                                    (== (.. __path (size)) (inc (.. __chain (getAccountPath) (size))))
                                                                    (do
                                                                        (cond (== (.. __detkey (getChildNumber) (num)) 0)
                                                                            (do
                                                                                (ยง assoc __chain :external-parent-key __detkey)
                                                                                (ยง assoc __chain :issued-external-keys (.. __key (getDeterministicKey) (getIssuedSubkeys)))
                                                                                (ยง ass __lookaheadSize (Math/max __lookaheadSize, (.. __key (getDeterministicKey) (getLookaheadSize))))
                                                                                (ยง ass __sigsRequiredToSpend (.. __key (getDeterministicKey) (getSigsRequiredToSpend)))
                                                                            )
                                                                            (== (.. __detkey (getChildNumber) (num)) 1)
                                                                            (do
                                                                                (ยง assoc __chain :internal-parent-key __detkey)
                                                                                (ยง assoc __chain :issued-internal-keys (.. __key (getDeterministicKey) (getIssuedSubkeys)))
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                            (.. (:hierarchy __chain) (putKey __detkey))
                                                            (.. (:basic-key-chain __chain) (importKey __detkey))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (when (some? __chain)
                        (Preconditions/checkState (>= __lookaheadSize 0))
                        (.. __chain (setLookaheadSize __lookaheadSize))
                        (.. __chain (setSigsRequiredToSpend __sigsRequiredToSpend))
                        (.. __chain (maybeLookAhead))
                        (.. __chains (add __chain))
                    )
                    __chains
                )
            )
        )
    )

    #_override
    #_public
    (ยง method #_"DeterministicKeyChain" toEncrypted [#_"CharSequence" __password]
        (Preconditions/checkNotNull __password)
        (Preconditions/checkArgument (< 0 (.. __password (length))))
        (Preconditions/checkState (some? (:seed this)), "Attempt to encrypt a watching chain.")
        (Preconditions/checkState (not (.. (:seed this) (isEncrypted))))

        (let [#_"KeyCrypter" __scrypt (KeyCrypterScrypt.)
              #_"KeyParameter" __derivedKey (.. __scrypt (deriveKey __password))]
            (.. this (toEncrypted __scrypt, __derivedKey))
        )
    )

    #_override
    #_public
    (ยง method #_"DeterministicKeyChain" toEncrypted [#_"KeyCrypter" __keyCrypter, #_"KeyParameter" __aesKey]
        (DeterministicKeyChain. __keyCrypter, __aesKey, this)
    )

    #_override
    #_public
    (ยง method #_"DeterministicKeyChain" toDecrypted [#_"CharSequence" __password]
        (Preconditions/checkNotNull __password)
        (Preconditions/checkArgument (< 0 (.. __password (length))))

        (let [#_"KeyCrypter" __crypter (.. this (getKeyCrypter))]
            (Preconditions/checkState (some? __crypter), "Chain not encrypted")
            (let [#_"KeyParameter" __derivedKey (.. __crypter (deriveKey __password))]
                (.. this (toDecrypted __derivedKey))
            )
        )
    )

    #_override
    #_public
    (ยง method #_"DeterministicKeyChain" toDecrypted [#_"KeyParameter" __aesKey]
        (Preconditions/checkState (some? (.. this (getKeyCrypter))), "Key chain not encrypted")
        (Preconditions/checkState (some? (:seed this)), "Can't decrypt a watching chain")
        (Preconditions/checkState (.. (:seed this) (isEncrypted)))

        (let [#_"String" __passphrase DeterministicKeyChain/DEFAULT_PASSPHRASE_FOR_MNEMONIC] ;; FIXME allow non-empty passphrase
            (let [#_"DeterministicSeed" __decSeed (.. (:seed this) (decrypt (.. this (getKeyCrypter)), __passphrase, __aesKey))
                  #_"DeterministicKeyChain" __chain (.. this (makeKeyChainFromSeed __decSeed))]
                ;; Now double check that the keys match to catch the case where the key is wrong but padding didn't catch it.
                (when (not (.. __chain (getWatchingKey) (getPubKeyPoint) (equals (.. this (getWatchingKey) (getPubKeyPoint)))))
                    (throw (KeyCrypterException. "Provided AES key is wrong"))
                )

                (ยง assoc __chain :lookahead-size (:lookahead-size this))
                ;; Now copy the (pubkey only) leaf keys across to avoid rederiving them.  The private key bytes are missing
                ;; anyway so there's nothing to decrypt.
                (doseq [#_"ECKey" __eckey (.. (:basic-key-chain this) (getKeys))]
                    (let [#_"DeterministicKey" __key (cast DeterministicKey __eckey)]
                        (when (!= (.. __key (getPath) (size)) (+ (.. this (getAccountPath) (size)) 2))
                            (ยง continue ) ;; Not a leaf key.
                        )

                        (Preconditions/checkState (.. __key (isEncrypted)))
                        (let [#_"DeterministicKey" __parent (.. (:hierarchy __chain) (get (.. (Preconditions/checkNotNull (.. __key (getParent))) (getPath)), false, false))]
                            ;; Clone the key to the new decrypted hierarchy.
                            (ยง ass __key (DeterministicKey. (.. __key (dropPrivateBytes)), __parent))
                            (.. (:hierarchy __chain) (putKey __key))
                            (.. (:basic-key-chain __chain) (importKey __key))
                        )
                    )
                )
                (ยง assoc __chain :issued-external-keys (:issued-external-keys this))
                (ยง assoc __chain :issued-internal-keys (:issued-internal-keys this))
                __chain
            )
        )
    )

    ;;;
     ; Factory method to create a key chain from a seed.
     ; Subclasses should override this to create an instance of the subclass instead of a plain DKC.
     ; This is used in encryption/decryption.
     ;;
    #_protected
    (ยง method #_"DeterministicKeyChain" makeKeyChainFromSeed [#_"DeterministicSeed" __seed]
        (DeterministicKeyChain. __seed)
    )

    #_override
    #_public
    (ยง method #_"boolean" checkPassword [#_"CharSequence" __password]
        (Preconditions/checkNotNull __password)
        (Preconditions/checkState (some? (.. this (getKeyCrypter))), "Key chain not encrypted")

        (.. this (checkAESKey (.. this (getKeyCrypter) (deriveKey __password))))
    )

    #_override
    #_public
    (ยง method #_"boolean" checkAESKey [#_"KeyParameter" __aesKey]
        (Preconditions/checkState (some? (:root-key this)), "Can't check password for a watching chain")
        (Preconditions/checkNotNull __aesKey)
        (Preconditions/checkState (some? (.. this (getKeyCrypter))), "Key chain not encrypted")

        (try
            (ยง return (.. (:root-key this) (decrypt __aesKey) (getPubKeyPoint) (equals (.. (:root-key this) (getPubKeyPoint)))))
            (catch KeyCrypterException _
                (ยง return false)
            )
        )
    )

    #_nilable
    #_override
    #_public
    (ยง method #_"KeyCrypter" getKeyCrypter []
        (.. (:basic-key-chain this) (getKeyCrypter))
    )

    #_override
    #_public
    (ยง method #_"int" numBloomFilterEntries []
        (* (.. this (numKeys)) 2)
    )

    #_override
    #_public
    (ยง method #_"BloomFilter" getFilter [#_"int" __size, #_"double" __falsePositiveRate, #_"long" __tweak]
        (.. (:lock this) (lock))
        (try
            (Preconditions/checkArgument (<= (.. this (numBloomFilterEntries)) __size))
            (.. this (maybeLookAhead))
            (.. (:basic-key-chain this) (getFilter __size, __falsePositiveRate, __tweak))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; <p>The number of public keys we should pre-generate on each path before they are requested by the app.  This is
     ; required so that when scanning through the chain given only a seed, we can give enough keys to the remote node
     ; via the Bloom filter such that we see transactions that are "from the future", for example transactions created
     ; by a different app that's sharing the same seed, or transactions we made before but we're replaying the chain
     ; given just the seed. The default is 100.</p>
     ;;
    #_public
    (ยง method #_"int" getLookaheadSize []
        (.. (:lock this) (lock))
        (try
            (:lookahead-size this)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Sets a new lookahead size.  See {@link #getLookaheadSize()} for details on what this is.  Setting a new size
     ; that's larger than the current size will return immediately and the new size will only take effect next time
     ; a fresh filter is requested (e.g. due to a new peer being connected).  So you should set this before starting
     ; to sync the chain, if you want to modify it.  If you haven't modified the lookahead threshold manually then
     ; it will be automatically set to be a third of the new size.
     ;;
    #_public
    (ยง method #_"void" setLookaheadSize [#_"int" __lookaheadSize]
        (.. (:lock this) (lock))
        (try
            (let [#_"boolean" __readjustThreshold (== (:lookahead-threshold this) (.. this (calcDefaultLookaheadThreshold)))]
                (ยง assoc this :lookahead-size __lookaheadSize)
                (when __readjustThreshold
                    (ยง assoc this :lookahead-threshold (.. this (calcDefaultLookaheadThreshold)))
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Sets the threshold for the key pre-generation.  This is used to avoid adding new keys and thus re-calculating
     ; Bloom filters every time a new key is calculated.  Without a lookahead threshold, every time we received
     ; a relevant transaction, we'd extend the lookahead zone and generate a new filter, which is inefficient.
     ;;
    #_public
    (ยง method #_"void" setLookaheadThreshold [#_"int" __num]
        (.. (:lock this) (lock))
        (try
            (when (<= (:lookahead-size this) __num)
                (throw (IllegalArgumentException. "Threshold larger or equal to the lookaheadSize"))
            )

            (ยง assoc this :lookahead-threshold __num)
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Gets the threshold for the key pre-generation.  See {@link #setLookaheadThreshold(int)} for details on what
     ; this is.  The default is a third of the lookahead size (100 / 3 == 33).  If you don't modify it explicitly,
     ; then this value will always be one third of the lookahead size.
     ;;
    #_public
    (ยง method #_"int" getLookaheadThreshold []
        (.. (:lock this) (lock))
        (try
            (if (< (:lookahead-threshold this) (:lookahead-size this)) (:lookahead-threshold this) 0)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Pre-generate enough keys to reach the lookahead size.  You can call this if you need to explicitly invoke
     ; the lookahead procedure, but it's normally unnecessary as it will be done automatically when needed.
     ;;
    #_public
    (ยง method #_"void" maybeLookAhead []
        (.. (:lock this) (lock))
        (try
            (let [#_"List<DeterministicKey>" __keys (.. this (maybeLookAhead (:external-parent-key this), (:issued-external-keys this)))]
                (.. __keys (addAll (.. this (maybeLookAhead (:internal-parent-key this), (:issued-internal-keys this)))))
                (when (.. __keys (isEmpty))
                    (ยง return nil)
                )

                (ยง assoc this :key-lookahead-epoch (inc (:key-lookahead-epoch this)))
                ;; Batch add all keys at once so there's only one event listener invocation, as this will be listened to
                ;; by the wallet and used to rebuild/broadcast the Bloom filter.  That's expensive so we don't want to do
                ;; it more often than necessary.
                (.. (:basic-key-chain this) (importKeys __keys))
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    #_private
    (ยง method- #_"List<DeterministicKey>" maybeLookAhead [#_"DeterministicKey" __parent, #_"int" __issued]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))

        (.. this (maybeLookAhead __parent, __issued, (.. this (getLookaheadSize)), (.. this (getLookaheadThreshold))))
    )

    ;;;
     ; Pre-generate enough keys to reach the lookahead size, but only if there are more than the lookaheadThreshold
     ; to be generated, so that the Bloom filter does not have to be regenerated that often.
     ;
     ; The returned mutable list of keys must be inserted into the basic key chain.
     ;;
    #_private
    (ยง method- #_"List<DeterministicKey>" maybeLookAhead [#_"DeterministicKey" __parent, #_"int" __issued, #_"int" __lookaheadSize, #_"int" __lookaheadThreshold]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))

        (let [#_"int" __numChildren (.. (:hierarchy this) (getNumChildren (.. __parent (getPath))))
              #_"int" __needed (- (+ __issued __lookaheadSize __lookaheadThreshold) __numChildren)]

            (when (<= __needed __lookaheadThreshold)
                (ยง return (ArrayList. #_"<>"))
            )

            (.. DeterministicKeyChain/log (info "{} keys needed for {} = {} issued + {} lookahead size + {} lookahead threshold - {} num children", __needed, (.. __parent (getPathAsString)), __issued, __lookaheadSize, __lookaheadThreshold, __numChildren))

            (let [#_"List<DeterministicKey>" __result (ArrayList. #_"<>" __needed)
                  #_"Stopwatch" __watch (Stopwatch/createStarted)
                  #_"int" __nextChild __numChildren]
                (loop-when-recur [#_"int" __i 0] (< __i __needed) [(inc __i)]
                    (let [#_"DeterministicKey" __key (HDKeyDerivation/deriveThisOrNextChildKey __parent, __nextChild)]
                        (ยง ass __key (.. __key (dropPrivateBytes)))
                        (.. (:hierarchy this) (putKey __key))
                        (.. __result (add __key))
                        (ยง ass __nextChild (inc (.. __key (getChildNumber) (num))))
                    )
                )
                (.. __watch (stop))
                (.. DeterministicKeyChain/log (info "Took {}", __watch))
                __result
            )
        )
    )

    ;;; Housekeeping call to call when lookahead might be needed.  Normally called automatically by KeychainGroup. ;;
    #_public
    (ยง method #_"void" maybeLookAheadScripts []
        nil
    )

    ;;;
     ; Returns number of keys used on external path.  This may be fewer than the number that have been deserialized
     ; or held in memory, because of the lookahead zone.
     ;;
    #_public
    (ยง method #_"int" getIssuedExternalKeys []
        (.. (:lock this) (lock))
        (try
            (:issued-external-keys this)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns number of keys used on internal path.  This may be fewer than the number that have been deserialized
     ; or held in memory, because of the lookahead zone.
     ;;
    #_public
    (ยง method #_"int" getIssuedInternalKeys []
        (.. (:lock this) (lock))
        (try
            (:issued-internal-keys this)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;; Returns the seed or null if this chain is a watching chain. ;;
    #_nilable
    #_public
    (ยง method #_"DeterministicSeed" getSeed []
        (.. (:lock this) (lock))
        (try
            (:seed this)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;; For internal usage only.
    (ยง method #_"List<ECKey>" getKeys [#_"boolean" __includeLookahead, #_"boolean" __includeParents]
        (let [#_"List<ECKey>" __keys (.. (:basic-key-chain this) (getKeys))]
            (when (not __includeLookahead)
                (let [#_"int" __treeSize (.. (:internal-parent-key this) (getPath) (size))
                      #_"List<ECKey>" __issuedKeys (LinkedList. #_"<>")]
                    (doseq [#_"ECKey" __key __keys]
                        (let [#_"DeterministicKey" __detkey (cast DeterministicKey __key)
                              #_"DeterministicKey" __parent (.. __detkey (getParent))]
                            (when (and (not __includeParents) (nil? __parent))
                                (ยง continue )
                            )
                            (when (and (not __includeParents) (<= (.. __detkey (getPath) (size)) __treeSize))
                                (ยง continue )
                            )
                            (when (and (.. (:internal-parent-key this) (equals __parent)) (<= (:issued-internal-keys this) (.. __detkey (getChildNumber) (i))))
                                (ยง continue )
                            )
                            (when (and (.. (:external-parent-key this) (equals __parent)) (<= (:issued-external-keys this) (.. __detkey (getChildNumber) (i))))
                                (ยง continue )
                            )
                            (.. __issuedKeys (add __detkey))
                        )
                    )
                    (ยง return __issuedKeys)
                )
            )
            __keys
        )
    )

    ;;;
     ; Returns only the external keys that have been issued by this chain, lookahead not included.
     ;;
    #_public
    (ยง method #_"List<ECKey>" getIssuedReceiveKeys []
        (let [#_"List<ECKey>" __keys (ArrayList. #_"<>" (.. this (getKeys false, false)))]
            (loop-when-recur [#_"Iterator<ECKey>" __i (.. __keys (iterator))] (.. __i (hasNext)) []
                (let [#_"DeterministicKey" __parent (.. (cast DeterministicKey (.. __i (next))) (getParent))]
                    (when (or (nil? __parent) (not (.. (:external-parent-key this) (equals __parent))))
                        (.. __i (remove))
                    )
                )
            )
            __keys
        )
    )

    ;;;
     ; Returns leaf keys issued by this chain (including lookahead zone).
     ;;
    #_public
    (ยง method #_"List<DeterministicKey>" getLeafKeys []
        (let [#_"ImmutableList.Builder<DeterministicKey>" __keys (ImmutableList/builder)]
            (doseq [#_"ECKey" __key (.. this (getKeys true, false))]
                (let [#_"DeterministicKey" __dKey (cast DeterministicKey __key)]
                    (when (== (.. __dKey (getPath) (size)) (+ (.. this (getAccountPath) (size)) 2))
                        (.. __keys (add __dKey))
                    )
                )
            )
            (.. __keys (build))
        )
    )

    #_static
    (ยง defn #_"void" DeterministicKeyChain/serializeSeedEncryptableItem [#_"DeterministicSeed" __seed, #_"Protos.Key.Builder" __proto]
        ;; The seed can be missing if we have not derived it yet from the mnemonic.
        ;; This will not normally happen once all the wallets are on the latest code that caches the seed.
        (cond (and (.. __seed (isEncrypted)) (some? (.. __seed (getEncryptedSeedData))))
            (do
                (let [#_"EncryptedData" __data (.. __seed (getEncryptedSeedData))]
                    (.. __proto (getEncryptedDeterministicSeedBuilder) (setEncryptedPrivateKey (ByteString/copyFrom (:encrypted-bytes __data))) (setInitialisationVector (ByteString/copyFrom (:initialisation-vector __data))))
                    ;; We don't allow mixing of encryption types at the moment.
                    (Preconditions/checkState (== (.. __seed (getEncryptionType)) Protos.Wallet.EncryptionType/ENCRYPTED_SCRYPT_AES))
                )
            )
            :else
            (do
                (let [#_"byte[]" __secret (.. __seed (getSeedBytes))]
                    (when (some? __secret)
                        (.. __proto (setDeterministicSeed (ByteString/copyFrom __secret)))
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Returns a counter that is incremented each time new keys are generated due to lookahead.
     ; Used by the network code to learn whether to discard the current block and await calculation
     ; of a new filter.
     ;;
    #_public
    (ยง method #_"int" getKeyLookaheadEpoch []
        (.. (:lock this) (lock))
        (try
            (:key-lookahead-epoch this)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Whether the keychain is married.  A keychain is married when it vends P2SH addresses from
     ; multiple keychains in a multisig relationship.
     ; @see org.bitcoinj.wallet.MarriedKeyChain
     ;;
    #_public
    (ยง method #_"boolean" isMarried []
        false
    )

    ;;; Get redeem data for a key.  Only applicable to married keychains. ;;
    #_public
    (ยง method #_"RedeemData" getRedeemData [#_"DeterministicKey" __followedKey]
        (throw (UnsupportedOperationException.))
    )

    ;;; Create a new key and return the matching output script.  Only applicable to married keychains. ;;
    #_public
    (ยง method #_"Script" freshOutputScript [#_"KeyChain.KeyPurpose" __purpose]
        (throw (UnsupportedOperationException.))
    )

    #_public
    (ยง method #_"String" toString [#_"boolean" __includePrivateKeys, #_"NetworkParameters" __params]
        (let [#_"DeterministicKey" __watchingKey (.. this (getWatchingKey))
              #_"StringBuilder" __sb (StringBuilder.)]
            (cond (some? (:seed this))
                (do
                    (cond (.. (:seed this) (isEncrypted))
                        (do
                            (.. __sb (append "Seed is encrypted\n"))
                        )
                        __includePrivateKeys
                        (do
                            (let [#_"List<String>" __words (.. (:seed this) (getMnemonicCode))]
                                (.. __sb (append "Seed as words: ") (append (.. Utils/SPACE_JOINER (join __words))) (append "\n"))
                                (.. __sb (append "Seed as hex:   ") (append (.. (:seed this) (toHexString))) (append "\n"))
                            )
                        )
                    )
                    (.. __sb (append "Seed birthday: ") (append (.. (:seed this) (getCreationTimeSeconds))) (append "  [") (append (Utils/dateTimeFormat (* (.. (:seed this) (getCreationTimeSeconds)) 1000))) (append "]\n"))
                )
                :else
                (do
                    (.. __sb (append "Key birthday:  ") (append (.. __watchingKey (getCreationTimeSeconds))) (append "  [") (append (Utils/dateTimeFormat (* (.. __watchingKey (getCreationTimeSeconds)) 1000))) (append "]\n"))
                )
            )
            (.. __sb (append "Key to watch:  ") (append (.. __watchingKey (serializePubB58 __params))) (append "\n"))
            (.. this (formatAddresses __includePrivateKeys, __params, __sb))
            (.. __sb (toString))
        )
    )

    #_protected
    (ยง method #_"void" formatAddresses [#_"boolean" __includePrivateKeys, #_"NetworkParameters" __params, #_"StringBuilder" __builder]
        (doseq [#_"ECKey" __key (.. this (getKeys false, true))]
            (.. __key (formatKeyWithAddress __includePrivateKeys, __builder, __params))
        )
        nil
    )

    ;;; The number of signatures required to spend coins received by this keychain. ;;
    #_public
    (ยง method #_"void" setSigsRequiredToSpend [#_"int" __sigsRequiredToSpend]
        (ยง assoc this :sigs-required-to-spend __sigsRequiredToSpend)
        nil
    )

    ;;;
     ; Returns the number of signatures required to spend transactions for this KeyChain.
     ; It's the N from N-of-M CHECKMULTISIG script for P2SH transactions and always 1 for other transaction types.
     ;;
    #_public
    (ยง method #_"int" getSigsRequiredToSpend []
        (:sigs-required-to-spend this)
    )

    ;;; Returns the redeem script by its hash or null if this keychain did not generate the script. ;;
    #_nilable
    #_public
    (ยง method #_"RedeemData" findRedeemDataByScriptHash [#_"ByteString" __bytes]
        nil
    )
)

;;;
 ; Holds the seed bytes for the BIP32 deterministic wallet algorithm, inside a {@link DeterministicKeyChain}.
 ; The purpose of this wrapper is to simplify the encryption code.
 ;;
#_public
(ยง class DeterministicSeed (ยง implements EncryptableItem)
    ;; It would take more than 10^12 years to brute-force a 128 bit seed using $1B worth of computing equipment.
    #_public
    #_static
    (ยง def #_"int" DeterministicSeed/DEFAULT_SEED_ENTROPY_BITS 128)
    #_public
    #_static
    (ยง def #_"int" DeterministicSeed/MAX_SEED_ENTROPY_BITS 512)

    #_nilable
    #_private
    (ยง field- #_"byte[]" :seed)
    #_nilable
    #_private
    (ยง field- #_"List<String>" :mnemonic-code) ;; only one of mnemonicCode/encryptedMnemonicCode will be set
    #_nilable
    #_private
    (ยง field- #_"EncryptedData" :encrypted-mnemonic-code)
    #_nilable
    #_private
    (ยง field- #_"EncryptedData" :encrypted-seed)
    #_private
    (ยง field- #_"long" :creation-time-seconds)

    #_public
    #_throws #_[ "UnreadableWalletException" ]
    (ยง constructor DeterministicSeed [#_"String" __mnemonicCode, #_"byte[]" __seed, #_"String" __passphrase, #_"long" __creationTimeSeconds]
        (ยง this (DeterministicSeed/decodeMnemonicCode __mnemonicCode), __seed, __passphrase, __creationTimeSeconds)
        this
    )

    #_public
    (ยง constructor DeterministicSeed [#_"byte[]" __seed, #_"List<String>" __mnemonic, #_"long" __creationTimeSeconds]
        (ยง assoc this :seed (Preconditions/checkNotNull __seed))
        (ยง assoc this :mnemonic-code (Preconditions/checkNotNull __mnemonic))
        (ยง assoc this :encrypted-mnemonic-code nil)
        (ยง assoc this :creation-time-seconds __creationTimeSeconds)
        this
    )

    #_public
    (ยง constructor DeterministicSeed [#_"EncryptedData" __encryptedMnemonic, #_nilable #_"EncryptedData" __encryptedSeed, #_"long" __creationTimeSeconds]
        (ยง assoc this :seed nil)
        (ยง assoc this :mnemonic-code nil)
        (ยง assoc this :encrypted-mnemonic-code (Preconditions/checkNotNull __encryptedMnemonic))
        (ยง assoc this :encrypted-seed __encryptedSeed)
        (ยง assoc this :creation-time-seconds __creationTimeSeconds)
        this
    )

    ;;;
     ; Constructs a seed from a BIP 39 mnemonic code.
     ; See {@link org.bitcoinj.crypto.MnemonicCode} for more details on this scheme.
     ; @param mnemonicCode A list of words.
     ; @param seed The derived seed, or pass null to derive it from mnemonicCode (slow).
     ; @param passphrase A user supplied passphrase, or an empty string if there is no passphrase.
     ; @param creationTimeSeconds When the seed was originally created, UNIX time.
     ;;
    #_public
    (ยง constructor DeterministicSeed [#_"List<String>" __mnemonicCode, #_nilable #_"byte[]" __seed, #_"String" __passphrase, #_"long" __creationTimeSeconds]
        (ยง this (or __seed (MnemonicCode/toSeed __mnemonicCode, (Preconditions/checkNotNull __passphrase))), __mnemonicCode, __creationTimeSeconds)
        this
    )

    ;;;
     ; Constructs a seed from a BIP 39 mnemonic code.
     ; See {@link org.bitcoinj.crypto.MnemonicCode} for more details on this scheme.
     ; @param random Entropy source.
     ; @param bits Number of bits, must be divisible by 32.
     ; @param passphrase A user supplied passphrase, or an empty string if there is no passphrase.
     ; @param creationTimeSeconds When the seed was originally created, UNIX time.
     ;;
    #_public
    (ยง constructor DeterministicSeed [#_"SecureRandom" __random, #_"int" __bits, #_"String" __passphrase, #_"long" __creationTimeSeconds]
        (ยง this (DeterministicSeed/getEntropy __random, __bits), (Preconditions/checkNotNull __passphrase), __creationTimeSeconds)
        this
    )

    ;;;
     ; Constructs a seed from a BIP 39 mnemonic code.
     ; See {@link org.bitcoinj.crypto.MnemonicCode} for more details on this scheme.
     ; @param entropy Entropy bits, length must be divisible by 32.
     ; @param passphrase A user supplied passphrase, or an empty string if there is no passphrase.
     ; @param creationTimeSeconds When the seed was originally created, UNIX time.
     ;;
    #_public
    (ยง constructor DeterministicSeed [#_"byte[]" __entropy, #_"String" __passphrase, #_"long" __creationTimeSeconds]
        (Preconditions/checkArgument (== (% (.. __entropy (alength)) 4) 0), "entropy size in bits not divisible by 32")
        (Preconditions/checkArgument (<= DeterministicSeed/DEFAULT_SEED_ENTROPY_BITS (* (.. __entropy (alength)) 8)), "entropy size too small")
        (Preconditions/checkNotNull __passphrase)

        (try
            (ยง assoc this :mnemonic-code (.. MnemonicCode/INSTANCE (toMnemonic __entropy)))
            (catch MnemonicException.MnemonicLengthException __e
                (throw (RuntimeException. __e)) ;; Cannot happen.
            )
        )
        (ยง assoc this :seed (MnemonicCode/toSeed (:mnemonic-code this), __passphrase))
        (ยง assoc this :encrypted-mnemonic-code nil)
        (ยง assoc this :creation-time-seconds __creationTimeSeconds)
        this
    )

    #_private
    #_static
    (ยง defn- #_"byte[]" DeterministicSeed/getEntropy [#_"SecureRandom" __random, #_"int" __bits]
        (Preconditions/checkArgument (<= __bits DeterministicSeed/MAX_SEED_ENTROPY_BITS), "requested entropy size too large")

        (let [#_"byte[]" __seed (byte-array (/ __bits 8))]
            (.. __random (nextBytes __seed))
            __seed
        )
    )

    #_override
    #_public
    (ยง method #_"boolean" isEncrypted []
        (Preconditions/checkState (or (some? (:mnemonic-code this)) (some? (:encrypted-mnemonic-code this))))
        (some? (:encrypted-mnemonic-code this))
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (if (.. this (isEncrypted)) "DeterministicSeed [encrypted]" (str "DeterministicSeed " (.. this (toHexString)) " " (.. Utils/SPACE_JOINER (join (:mnemonic-code this)))))
    )

    ;;; Returns the seed as hex or null if encrypted. ;;
    #_nilable
    #_public
    (ยง method #_"String" toHexString []
        (when (some? (:seed this)) (.. Utils/HEX (encode (:seed this))))
    )

    #_nilable
    #_override
    #_public
    (ยง method #_"byte[]" getSecretBytes []
        (.. this (getMnemonicAsBytes))
    )

    #_nilable
    #_public
    (ยง method #_"byte[]" getSeedBytes []
        (:seed this)
    )

    #_nilable
    #_override
    #_public
    (ยง method #_"EncryptedData" getEncryptedData []
        (:encrypted-mnemonic-code this)
    )

    #_override
    #_public
    (ยง method #_"Protos.Wallet.EncryptionType" getEncryptionType []
        Protos.Wallet.EncryptionType/ENCRYPTED_SCRYPT_AES
    )

    #_nilable
    #_public
    (ยง method #_"EncryptedData" getEncryptedSeedData []
        (:encrypted-seed this)
    )

    #_override
    #_public
    (ยง method #_"long" getCreationTimeSeconds []
        (:creation-time-seconds this)
    )

    #_public
    (ยง method #_"void" setCreationTimeSeconds [#_"long" __creationTimeSeconds]
        (ยง assoc this :creation-time-seconds __creationTimeSeconds)
        nil
    )

    #_public
    (ยง method #_"DeterministicSeed" encrypt [#_"KeyCrypter" __keyCrypter, #_"KeyParameter" __aesKey]
        (Preconditions/checkState (nil? (:encrypted-mnemonic-code this)), "Trying to encrypt seed twice")
        (Preconditions/checkState (some? (:mnemonic-code this)), "Mnemonic missing so cannot encrypt")

        (let [#_"EncryptedData" __encryptedMnemonic (.. __keyCrypter (encrypt (.. this (getMnemonicAsBytes)), __aesKey))
              #_"EncryptedData" __encryptedSeed (.. __keyCrypter (encrypt (:seed this), __aesKey))]
            (DeterministicSeed. __encryptedMnemonic, __encryptedSeed, (:creation-time-seconds this))
        )
    )

    #_private
    (ยง method- #_"byte[]" getMnemonicAsBytes []
        (.. Utils/SPACE_JOINER (join (:mnemonic-code this)) (getBytes Charsets/UTF_8))
    )

    #_public
    (ยง method #_"DeterministicSeed" decrypt [#_"KeyCrypter" __crypter, #_"String" __passphrase, #_"KeyParameter" __aesKey]
        (Preconditions/checkState (.. this (isEncrypted)))
        (Preconditions/checkNotNull (:encrypted-mnemonic-code this))

        (let [#_"List<String>" __mnemonic (DeterministicSeed/decodeMnemonicCode (.. __crypter (decrypt (:encrypted-mnemonic-code this), __aesKey)))
              #_"byte[]" __seed (when (some? (:encrypted-seed this)) (.. __crypter (decrypt (:encrypted-seed this), __aesKey)))]
            (DeterministicSeed. __mnemonic, __seed, __passphrase, (:creation-time-seconds this))
        )
    )

    #_override
    #_public
    (ยง method #_"boolean" equals [#_"Object" __o]
        (when (== this __o)
            (ยง return true)
        )
        (when (or (nil? __o) (!= (getClass) (.. __o (getClass))))
            (ยง return false)
        )
        (let [#_"DeterministicSeed" __other (cast DeterministicSeed __o)]
            (and (== (:creation-time-seconds this) (:creation-time-seconds __other)) (Objects/equal (:encrypted-mnemonic-code this), (:encrypted-mnemonic-code __other)) (Objects/equal (:mnemonic-code this), (:mnemonic-code __other)))
        )
    )

    #_override
    #_public
    (ยง method #_"int" hashCode []
        (Objects/hashCode (:creation-time-seconds this), (:encrypted-mnemonic-code this), (:mnemonic-code this))
    )

    ;;;
     ; Check if our mnemonic is a valid mnemonic phrase for our word list.
     ; Does nothing if we are encrypted.
     ;
     ; @throws org.bitcoinj.crypto.MnemonicException if check fails.
     ;;
    #_public
    #_throws #_[ "MnemonicException" ]
    (ยง method #_"void" check []
        (when (some? (:mnemonic-code this))
            (.. MnemonicCode/INSTANCE (check (:mnemonic-code this)))
        )
        nil
    )

    #_throws #_[ "MnemonicException" ]
    (ยง method #_"byte[]" getEntropyBytes []
        (.. MnemonicCode/INSTANCE (toEntropy (:mnemonic-code this)))
    )

    ;;; Get the mnemonic code, or null if unknown. ;;
    #_nilable
    #_public
    (ยง method #_"List<String>" getMnemonicCode []
        (:mnemonic-code this)
    )

    #_private
    #_static
    (ยง defn- #_"List<String>" DeterministicSeed/decodeMnemonicCode [#_"byte[]" __mnemonicCode]
        (DeterministicSeed/decodeMnemonicCode (Utils/toString __mnemonicCode, "UTF-8"))
    )

    #_private
    #_static
    (ยง defn- #_"List<String>" DeterministicSeed/decodeMnemonicCode [#_"String" __mnemonicCode]
        (.. (Splitter/on " ") (splitToList __mnemonicCode))
    )
)

;;;
 ; Indicates that an attempt was made to use HD wallet features on a wallet that was deserialized from an old,
 ; pre-HD random wallet without calling upgradeToDeterministic() beforehand.
 ;;
#_public
(ยง class DeterministicUpgradeRequiredException (ยง extends RuntimeException))

;;;
 ; Indicates that the pre-HD random wallet is encrypted, so you should try the upgrade again after getting the
 ; users password.  This is required because HD wallets are upgraded from random using the private key bytes of
 ; the oldest non-rotating key, in order to make the upgrade process itself deterministic.
 ;;
#_public
(ยง class DeterministicUpgradeRequiresPassword (ยง extends RuntimeException))

;;;
 ; An encryptable key chain is a key-chain that can be encrypted with a user-provided password or AES key.
 ;;
#_public
(ยง interface EncryptableKeyChain (ยง extends KeyChain)
    ;;;
     ; Takes the given password, which should be strong, derives a key from it and then invokes
     ; {@link #toEncrypted(org.bitcoinj.crypto.KeyCrypter, org.spongycastle.crypto.params.KeyParameter)}
     ; with {@link org.bitcoinj.crypto.KeyCrypterScrypt} as the crypter.
     ;
     ; @return the derived key, in case you wish to cache it for future use.
     ;;
    (ยง method #_"EncryptableKeyChain" toEncrypted [#_"CharSequence" __password])

    ;;;
     ; Returns a new keychain holding identical/cloned keys to this chain, but encrypted under the given key.
     ; Old keys and keychains remain valid and so you should ensure you don't accidentally hold references to them.
     ;;
    (ยง method #_"EncryptableKeyChain" toEncrypted [#_"KeyCrypter" __keyCrypter, #_"KeyParameter" __aesKey])

    ;;;
     ; Decrypts the key chain with the given password.
     ; See {@link #toDecrypted(org.spongycastle.crypto.params.KeyParameter)} for details.
     ;;
    (ยง method #_"EncryptableKeyChain" toDecrypted [#_"CharSequence" __password])

    ;;;
     ; Decrypt the key chain with the given AES key and whatever {@link KeyCrypter} is already set.  Note that
     ; if you just want to spend money from an encrypted wallet, don't decrypt the whole thing first.  Instead,
     ; set the {@link org.bitcoinj.wallet.SendRequest#aesKey} field before asking the wallet to build the send.
     ;
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time
     ;               consuming to create from a password).
     ; @throws KeyCrypterException if the wallet decryption fails.  If so, the wallet state is unchanged.
     ;;
    (ยง method #_"EncryptableKeyChain" toDecrypted [#_"KeyParameter" __aesKey])

    (ยง method #_"boolean" checkPassword [#_"CharSequence" __password])
    (ยง method #_"boolean" checkAESKey [#_"KeyParameter" __aesKey])

    ;;; Returns the key crypter used by this key chain, or null if it's not encrypted. ;;
    #_nilable
    (ยง method #_"KeyCrypter" getKeyCrypter [])
)

;;;
 ; A filtering coin selector delegates to another coin selector, but won't select outputs spent by the given transactions.
 ;;
#_public
(ยง class FilteringCoinSelector (ยง implements CoinSelector)
    #_protected
    (ยง field #_"CoinSelector" :delegate)
    #_protected
    (ยง field #_"HashSet<TransactionOutPoint>" :spent (HashSet. #_"<>"))

    #_public
    (ยง constructor FilteringCoinSelector [#_"CoinSelector" __delegate]
        (ยง assoc this :delegate __delegate)
        this
    )

    #_public
    (ยง method #_"void" excludeOutputsSpentBy [#_"Transaction" __tx]
        (doseq [#_"TransactionInput" __input (.. __tx (getInputs))]
            (.. (:spent this) (add (.. __input (getOutpoint))))
        )
        nil
    )

    #_override
    #_public
    (ยง method #_"CoinSelection" select [#_"Coin" __target, #_"List<TransactionOutput>" __candidates]
        (let [#_"Iterator<TransactionOutput>" __iter (.. __candidates (iterator))]
            (while (.. __iter (hasNext))
                (let [#_"TransactionOutput" __output (.. __iter (next))]
                    (when (.. (:spent this) (contains (.. __output (getOutPointFor))))
                        (.. __iter (remove))
                    )
                )
            )
            (.. (:delegate this) (select __target, __candidates))
        )
    )
)

;;;
 ; A KeyBag is simply an object that can map public keys, their 160-bit hashes and script hashes to ECKey
 ; and {@link RedeemData} objects.
 ;;
#_public
(ยง interface KeyBag
    ;;;
     ; Locates a keypair from the keychain given the hash of the public key.  This is needed when finding out
     ; which key we need to use to redeem a transaction output.
     ;
     ; @return ECKey object or null if no such key was found.
     ;;
    #_nilable
    (ยง method #_"ECKey" findKeyFromPubHash [#_"byte[]" __pubkeyHash])

    ;;;
     ; Locates a keypair from the keychain given the raw public key bytes.
     ;
     ; @return ECKey or null if no such key was found.
     ;;
    #_nilable
    (ยง method #_"ECKey" findKeyFromPubKey [#_"byte[]" __pubkey])

    ;;;
     ; Locates a redeem data (redeem script and keys) from the keychain given the hash of the script.
     ; This is needed when finding out which key and script we need to use to locally sign a P2SH transaction input.
     ; It is assumed that wallet should not have more than one private key for a single P2SH tx for security reasons.
     ;
     ; @return RedeemData object or null if no such data was found.
     ;;
    #_nilable
    (ยง method #_"RedeemData" findRedeemDataFromScriptHash [#_"byte[]" __scriptHash])
)

;;;
 ; <p>A KeyChain is a class that stores a collection of keys for a {@link org.bitcoinj.wallet.Wallet}.  Key chains
 ; are expected to be able to look up keys given a hash (i.e. address) or pubkey bytes, and provide keys on request
 ; for a given purpose.  They can inform event listeners about new keys being added.</p>
 ;
 ; <p>However it is important to understand what this interface does <i>not</i> provide.  It cannot encrypt or decrypt
 ; keys, for instance you need an implementor of {@link EncryptableKeyChain}.  It cannot have keys imported into it,
 ; that you to use a method of a specific key chain instance, such as {@link BasicKeyChain}.  The reason for these
 ; restrictions is to support key chains that may be handled by external hardware or software, or which are derived
 ; deterministically from a seed (and thus the notion of importing a key is meaningless).</p>
 ;;
#_public
(ยง interface KeyChain
    ;;; Returns true if the given key is in the chain. ;;
    (ยง method #_"boolean" hasKey [#_"ECKey" __key])

    (ยง enum KeyChain.KeyPurpose
        (ยง item RECEIVE_FUNDS)
        (ยง item CHANGE)
        (ยง item REFUND)
        (ยง item AUTHENTICATION)
    )

    ;;;
     ; Obtains a number of key/s intended for the given purpose.
     ; The chain may create new key/s, derive, or re-use an old one.
     ;;
    (ยง method #_"List<? extends ECKey>" getKeys [#_"KeyChain.KeyPurpose" __purpose, #_"int" __numberOfKeys])

    ;;;
     ; Obtains a key intended for the given purpose.
     ; The chain may create a new key, derive one, or re-use an old one.
     ;;
    (ยง method #_"ECKey" getKey [#_"KeyChain.KeyPurpose" __purpose])

    ;;; Returns a list of keys serialized to the bitcoinj protobuf format. ;;
    (ยง method #_"List<Protos.Key>" serializeToProtobuf [])

    ;;; Adds a listener for events that are run when keys are added, on the user thread. ;;
    (ยง method #_"void" addEventListener [#_"KeyChainEventListener" __listener])

    ;;; Adds a listener for events that are run when keys are added, on the given executor. ;;
    (ยง method #_"void" addEventListener [#_"KeyChainEventListener" __listener, #_"Executor" __executor])

    ;;; Removes a listener for events that are run when keys are added. ;;
    (ยง method #_"boolean" removeEventListener [#_"KeyChainEventListener" __listener])

    ;;; Returns the number of keys this key chain manages. ;;
    (ยง method #_"int" numKeys [])

    ;;;
     ; Returns the number of elements this chain wishes to insert into the Bloom filter.
     ; The size passed to {@link #getFilter(int, double, long)} should be at least this large.
     ;;
    (ยง method #_"int" numBloomFilterEntries [])

    ;;;
     ; Returns the earliest creation time of keys in this chain, in seconds since the epoch.  This can return
     ; zero if at least one key does not have that data (was created before key timestamping was implemented).
     ; If there are no keys in the wallet, {@link Long#MAX_VALUE} is returned.
     ;;
    (ยง method #_"long" getEarliestKeyCreationTime [])

    ;;;
     ; <p>Gets a bloom filter that contains all of the public keys from this chain, and which will provide the given
     ; false-positive rate if it has size elements.  Keep in mind that you will get 2 elements in the bloom filter for
     ; each key in the key chain, for the public key and the hash of the public key (address form).  For this reason
     ; size should be <i>at least</i> 2x the result of {@link #numKeys()}.</p>
     ;
     ; <p>This is used to generate a {@link BloomFilter} which can be {@link BloomFilter#merge(BloomFilter)}d with
     ; another.  It could also be used if you have a specific target for the filter's size.</p>
     ;
     ; <p>See the docs for {@link org.bitcoinj.core.BloomFilter#BloomFilter(int, double, long)} for a brief
     ; explanation of anonymity when using bloom filters, and for the meaning of these parameters.</p>
     ;;
    (ยง method #_"BloomFilter" getFilter [#_"int" __size, #_"double" __falsePositiveRate, #_"long" __tweak])
)

;;;
 ; Factory interface for creation keychains while de-serializing a wallet.
 ;;
#_public
(ยง interface KeyChainFactory
    ;;;
     ; Make a keychain (but not a watching one).
     ;
     ; @param key The protobuf for the root key.
     ; @param firstSubKey The protobuf for the first child key (normally the parent of the external subchain).
     ; @param seed The seed.
     ; @param crypter The encrypted/decrypter.
     ; @param isMarried Whether the keychain is leading in a marriage.
     ;;
    (ยง method #_"DeterministicKeyChain" makeKeyChain [#_"Protos.Key" __key, #_"Protos.Key" __firstSubKey, #_"DeterministicSeed" __seed, #_"KeyCrypter" __crypter, #_"boolean" __isMarried])

    ;;;
     ; Make a watching keychain.
     ;
     ; isMarried and isFollowingKey must not be true at the same time.
     ;
     ; @param key The protobuf for the account key.
     ; @param firstSubKey The protobuf for the first child key (normally the parent of the external subchain).
     ; @param accountKey The account extended public key.
     ; @param isFollowingKey Whether the keychain is following in a marriage.
     ; @param isMarried Whether the keychain is leading in a marriage.
     ;;
    #_throws #_[ "UnreadableWalletException" ]
    (ยง method #_"DeterministicKeyChain" makeWatchingKeyChain [#_"Protos.Key" __key, #_"Protos.Key" __firstSubKey, #_"DeterministicKey" __accountKey, #_"boolean" __isFollowingKey, #_"boolean" __isMarried])
)

;;;
 ; <p>A KeyChainGroup is used by the {@link org.bitcoinj.wallet.Wallet} and manages: a {@link BasicKeyChain} object
 ; (which will normally be empty), and zero or more {@link DeterministicKeyChain}s.  A deterministic key chain will be
 ; created lazily/on demand when a fresh or current key is requested, possibly being initialized from the private key
 ; bytes of the earliest non rotating key in the basic key chain if one is available, or from a fresh random seed if not.</p>
 ;
 ; <p>If a key rotation time is set, it may be necessary to add a new DeterministicKeyChain with a fresh seed and
 ; also preserve the old one, so funds can be swept from the rotating keys.  In this case, there may be more than
 ; one deterministic chain.  The latest chain is called the active chain and is where new keys are served from.</p>
 ;
 ; <p>The wallet delegates most key management tasks to this class.  It is <b>not</b> thread safe and requires external
 ; locking, i.e. by the wallet lock.  The group then in turn delegates most operations to the key chain objects,
 ; combining their responses together when necessary.</p>
 ;
 ; <p>Deterministic key chains have a concept of a lookahead size and threshold.  Please see the discussion in the
 ; class docs for {@link DeterministicKeyChain} for more information on this topic.</p>
 ;;
#_public
(ยง class KeyChainGroup (ยง implements KeyBag)
    #_private
    #_static
    (ยง def- #_"Logger" KeyChainGroup/log (LoggerFactory/getLogger KeyChainGroup))

    #_private
    (ยง field- #_"BasicKeyChain" :basic)
    #_private
    (ยง field- #_"NetworkParameters" :params)
    #_protected
    (ยง field #_"LinkedList<DeterministicKeyChain>" :chains)
    ;; currentKeys is used for normal, non-multisig/married wallets.
    ;; currentAddresses is used when we're handing out P2SH addresses.
    ;; They're mutually exclusive.
    #_private
    (ยง field- #_"EnumMap<KeyChain.KeyPurpose, DeterministicKey>" :current-keys)
    #_private
    (ยง field- #_"EnumMap<KeyChain.KeyPurpose, Address>" :current-addresses)

    #_nilable
    #_private
    (ยง field- #_"KeyCrypter" :key-crypter)
    #_private
    (ยง field- #_"int" :lookahead-size -1)
    #_private
    (ยง field- #_"int" :lookahead-threshold -1)

    ;;; Creates a keychain group with no basic chain, and a single, lazily created HD chain. ;;
    #_public
    (ยง constructor KeyChainGroup [#_"NetworkParameters" __params]
        (ยง this __params, nil, (ArrayList. #_"<DeterministicKeyChain>" 1), nil, nil)
        this
    )

    ;;; Creates a keychain group with no basic chain, and an HD chain initialized from the given seed. ;;
    #_public
    (ยง constructor KeyChainGroup [#_"NetworkParameters" __params, #_"DeterministicSeed" __seed]
        (ยง this __params, nil, (ImmutableList/of (DeterministicKeyChain. __seed)), nil, nil)
        this
    )

    ;;;
     ; Creates a keychain group with no basic chain, and an HD chain that is watching the given watching key.
     ; This HAS to be an account key as returned by {@link DeterministicKeyChain#getWatchingKey()}.
     ;;
    #_public
    (ยง constructor KeyChainGroup [#_"NetworkParameters" __params, #_"DeterministicKey" __watchKey]
        (ยง this __params, nil, (ImmutableList/of (DeterministicKeyChain/watch __watchKey)), nil, nil)
        this
    )

    ;; Used for deserialization.
    #_private
    (ยง constructor- #_"KeyChainGroup" [#_"NetworkParameters" __params, #_nilable #_"BasicKeyChain" __basicKeyChain, #_"List<DeterministicKeyChain>" __chains, #_nilable #_"EnumMap<KeyChain.KeyPurpose, DeterministicKey>" __currentKeys, #_nilable #_"KeyCrypter" __crypter]
        (ยง assoc this :params __params)
        (ยง assoc this :basic (or __basicKeyChain (BasicKeyChain.)))
        (ยง assoc this :chains (LinkedList. #_"<>" (Preconditions/checkNotNull __chains)))
        (ยง assoc this :key-crypter __crypter)
        (ยง assoc this :current-keys (or __currentKeys (EnumMap. #_"<KeyChain.KeyPurpose, DeterministicKey>" KeyChain.KeyPurpose)))
        (ยง assoc this :current-addresses (EnumMap. #_"<>" KeyChain.KeyPurpose))
        (.. this (maybeLookaheadScripts))

        (when (.. this (isMarried))
            (doseq [#_"Map.Entry<KeyChain.KeyPurpose, DeterministicKey>" __entry (.. (:current-keys this) (entrySet))]
                (let [#_"Address" __address (.. this (makeP2SHOutputScript (.. __entry (getValue)), (.. this (getActiveKeyChain))) (getToAddress __params))]
                    (.. (:current-addresses this) (put (.. __entry (getKey)), __address))
                )
            )
        )
        this
    )

    ;; This keeps married redeem data in sync with the number of keys issued.
    #_private
    (ยง method- #_"void" maybeLookaheadScripts []
        (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
            (.. __chain (maybeLookAheadScripts))
        )
        nil
    )

    ;;; Adds a new HD chain to the chains list, and make it the default chain (from which keys are issued). ;;
    #_public
    (ยง method #_"void" createAndActivateNewHDChain []
        ;; We can't do auto upgrade here because we don't know the rotation time, if any.
        (let [#_"DeterministicKeyChain" __chain (DeterministicKeyChain. (SecureRandom.))]
            (.. this (addAndActivateHDChain __chain))
            nil
        )
    )

    ;;;
     ; Adds an HD chain to the chains list, and make it the default chain (from which keys are issued).
     ; Useful for adding a complex pre-configured keychain, such as a married wallet.
     ;;
    #_public
    (ยง method #_"void" addAndActivateHDChain [#_"DeterministicKeyChain" __chain]
        (.. KeyChainGroup/log (info "Creating and activating a new HD chain: {}", __chain))
        (doseq [#_"ListenerRegistration<KeyChainEventListener>" __registration (.. (:basic this) (getListeners))]
            (.. __chain (addEventListener (:listener __registration), (:executor __registration)))
        )
        (when (<= 0 (:lookahead-size this))
            (.. __chain (setLookaheadSize (:lookahead-size this)))
        )
        (when (<= 0 (:lookahead-threshold this))
            (.. __chain (setLookaheadThreshold (:lookahead-threshold this)))
        )
        (.. (:chains this) (add __chain))
        nil
    )

    ;;;
     ; Returns a key that hasn't been seen in a transaction yet, and which is suitable for displaying in a wallet
     ; user interface as "a convenient key to receive funds on" when the purpose parameter is
     ; {@link KeyChain.KeyPurpose#RECEIVE_FUNDS}.  The returned key is stable until it's actually seen in a pending
     ; or confirmed transaction, at which point this method will start returning a different key (for each purpose
     ; independently).
     ;
     ; <p>This method is not supposed to be used for married keychains and will throw UnsupportedOperationException
     ; if the active chain is married.
     ; For married keychains use {@link #currentAddress(KeyChain.KeyPurpose)} to get a proper P2SH address.</p>
     ;;
    #_public
    (ยง method #_"DeterministicKey" currentKey [#_"KeyChain.KeyPurpose" __purpose]
        (let [#_"DeterministicKeyChain" __chain (.. this (getActiveKeyChain))]
            (when (.. __chain (isMarried))
                (throw (UnsupportedOperationException. "Key is not suitable to receive coins for married keychains. Use freshAddress to get P2SH address instead."))
            )

            (let [#_"DeterministicKey" __current (.. (:current-keys this) (get __purpose))]
                (when (nil? __current)
                    (ยง ass __current (.. this (freshKey __purpose)))
                    (.. (:current-keys this) (put __purpose, __current))
                )
                __current
            )
        )
    )

    ;;;
     ; Returns address for a {@link #currentKey(KeyChain.KeyPurpose)}.
     ;;
    #_public
    (ยง method #_"Address" currentAddress [#_"KeyChain.KeyPurpose" __purpose]
        (let [#_"DeterministicKeyChain" __chain (.. this (getActiveKeyChain))]
            (when (.. __chain (isMarried))
                (let [#_"Address" __current (.. (:current-addresses this) (get __purpose))]
                    (when (nil? __current)
                        (ยง ass __current (.. this (freshAddress __purpose)))
                        (.. (:current-addresses this) (put __purpose, __current))
                    )
                    (ยง return __current)
                )
            )

            (.. this (currentKey __purpose) (toAddress (:params this)))
        )
    )

    ;;;
     ; Returns a key that has not been returned by this method before (fresh).  You can think of this as being a newly
     ; created key, although the notion of "create" is not really valid for a {@link DeterministicKeyChain}.  When the
     ; parameter is {@link KeyChain.KeyPurpose#RECEIVE_FUNDS}, the returned key is suitable for being put into a receive
     ; coins wizard type UI.  You should use this when the user is definitely going to hand this key out to someone who
     ; wishes to send money.
     ; <p>This method is not supposed to be used for married keychains and will throw UnsupportedOperationException if
     ; the active chain is married.
     ; For married keychains use {@link #freshAddress(KeyChain.KeyPurpose)} to get a proper P2SH address.</p>
     ;;
    #_public
    (ยง method #_"DeterministicKey" freshKey [#_"KeyChain.KeyPurpose" __purpose]
        (.. this (freshKeys __purpose, 1) (get 0))
    )

    ;;;
     ; Returns a key/s that have not been returned by this method before (fresh).  You can think of this as being newly
     ; created key/s, although the notion of "create" is not really valid for a {@link DeterministicKeyChain}.  When the
     ; parameter is {@link KeyChain.KeyPurpose#RECEIVE_FUNDS}, the returned key is suitable for being put into a receive
     ; coins wizard type UI.  You should use this when the user is definitely going to hand this key out to someone who
     ; wishes to send money.
     ; <p>This method is not supposed to be used for married keychains and will throw UnsupportedOperationException if
     ; the active chain is married.
     ; For married keychains use {@link #freshAddress(KeyChain.KeyPurpose)} to get a proper P2SH address.</p>
     ;;
    #_public
    (ยง method #_"List<DeterministicKey>" freshKeys [#_"KeyChain.KeyPurpose" __purpose, #_"int" __numberOfKeys]
        (let [#_"DeterministicKeyChain" __chain (.. this (getActiveKeyChain))]
            (when (.. __chain (isMarried))
                (throw (UnsupportedOperationException. "Key is not suitable to receive coins for married keychains. Use freshAddress to get P2SH address instead."))
            )

            (.. __chain (getKeys __purpose, __numberOfKeys)) ;; Always returns the next key along the key chain.
        )
    )

    ;;;
     ; Returns address for a {@link #freshKey(KeyChain.KeyPurpose)}.
     ;;
    #_public
    (ยง method #_"Address" freshAddress [#_"KeyChain.KeyPurpose" __purpose]
        (let [#_"DeterministicKeyChain" __chain (.. this (getActiveKeyChain))]
            (when (.. __chain (isMarried))
                (let [#_"Script" __outputScript (.. __chain (freshOutputScript __purpose))]
                    (Preconditions/checkState (.. __outputScript (isPayToScriptHash))) ;; Only handle P2SH for now.
                    (let [#_"Address" __freshAddress (Address/fromP2SHScript (:params this), __outputScript)]
                        (.. this (maybeLookaheadScripts))
                        (.. (:current-addresses this) (put __purpose, __freshAddress))
                        (ยง return __freshAddress)
                    )
                )
            )

            (.. this (freshKey __purpose) (toAddress (:params this)))
        )
    )

    ;;; Returns the key chain that's used for generation of fresh/current keys.  This is always the newest HD chain. ;;
    #_public
    (ยง method #_"DeterministicKeyChain" getActiveKeyChain []
        (when (.. (:chains this) (isEmpty))
            (when (< 0 (.. (:basic this) (numKeys)))
                (.. KeyChainGroup/log (warn "No HD chain present but random keys are: you probably deserialized an old wallet."))
                ;; If called from the wallet (most likely) it'll try to upgrade us, as it knows the rotation time but not the password.
                (throw (DeterministicUpgradeRequiredException.))
            )
            ;; Otherwise we have no HD chains and no random keys: we are a new born!  So a random seed is fine.
            (.. this (createAndActivateNewHDChain))
        )
        (.. (:chains this) (get (dec (.. (:chains this) (size)))))
    )

    ;;;
     ; Sets the lookahead buffer size for ALL deterministic key chains as well as for following key chains if any exist.
     ; See {@link DeterministicKeyChain#setLookaheadSize(int)} for more information.
     ;;
    #_public
    (ยง method #_"void" setLookaheadSize [#_"int" __lookaheadSize]
        (ยง assoc this :lookahead-size __lookaheadSize)
        (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
            (.. __chain (setLookaheadSize __lookaheadSize))
        )
        nil
    )

    ;;;
     ; Gets the current lookahead size being used for ALL deterministic key chains.
     ; See {@link DeterministicKeyChain#setLookaheadSize(int)} for more information.
     ;;
    #_public
    (ยง method #_"int" getLookaheadSize []
        (if (== (:lookahead-size this) -1) (.. this (getActiveKeyChain) (getLookaheadSize)) (:lookahead-size this))
    )

    ;;;
     ; Sets the lookahead buffer threshold for ALL deterministic key chains.
     ; See {@link DeterministicKeyChain#setLookaheadThreshold(int)} for more information.
     ;;
    #_public
    (ยง method #_"void" setLookaheadThreshold [#_"int" __num]
        (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
            (.. __chain (setLookaheadThreshold __num))
        )
        nil
    )

    ;;;
     ; Gets the current lookahead threshold being used for ALL deterministic key chains.
     ; See {@link DeterministicKeyChain#setLookaheadThreshold(int)} for more information.
     ;;
    #_public
    (ยง method #_"int" getLookaheadThreshold []
        (if (== (:lookahead-threshold this) -1) (.. this (getActiveKeyChain) (getLookaheadThreshold)) (:lookahead-threshold this))
    )

    ;;; Imports the given keys into the basic chain, creating it if necessary. ;;
    #_public
    (ยง method #_"int" importKeys [#_"List<ECKey>" __keys]
        (.. (:basic this) (importKeys __keys))
    )

    ;;; Imports the given keys into the basic chain, creating it if necessary. ;;
    #_public
    (ยง method #_"int" importKeys [#_"ECKey..." __keys]
        (.. this (importKeys (ImmutableList/copyOf __keys)))
    )

    #_public
    (ยง method #_"boolean" checkPassword [#_"CharSequence" __password]
        (Preconditions/checkState (some? (:key-crypter this)), "Not encrypted")

        (.. this (checkAESKey (.. (:key-crypter this) (deriveKey __password))))
    )

    #_public
    (ยง method #_"boolean" checkAESKey [#_"KeyParameter" __aesKey]
        (Preconditions/checkState (some? (:key-crypter this)), "Not encrypted")

        (if (< 0 (.. (:basic this) (numKeys))) (.. (:basic this) (checkAESKey __aesKey)) (.. this (getActiveKeyChain) (checkAESKey __aesKey)))
    )

    ;;; Imports the given unencrypted keys into the basic chain, encrypting them along the way with the given key. ;;
    #_public
    (ยง method #_"int" importKeysAndEncrypt [#_"List<ECKey>" __keys, #_"KeyParameter" __aesKey]
        ;; TODO: Firstly check if the aes key can decrypt any of the existing keys successfully.
        (Preconditions/checkState (some? (:key-crypter this)), "Not encrypted")

        (let [#_"LinkedList<ECKey>" __encryptedKeys (Lists/newLinkedList)]
            (doseq [#_"ECKey" __key __keys]
                (when (.. __key (isEncrypted))
                    (throw (IllegalArgumentException. "Cannot provide already encrypted keys"))
                )

                (.. __encryptedKeys (add (.. __key (encrypt (:key-crypter this), __aesKey))))
            )
            (.. this (importKeys __encryptedKeys))
        )
    )

    #_override
    #_nilable
    #_public
    (ยง method #_"RedeemData" findRedeemDataFromScriptHash [#_"byte[]" __scriptHash]
        ;; Iterate in reverse order, since the active keychain is the one most likely to have the hit.
        (loop-when-recur [#_"Iterator<DeterministicKeyChain>" __iter (.. (:chains this) (descendingIterator))] (.. __iter (hasNext)) []
            (let [#_"DeterministicKeyChain" __chain (.. __iter (next))
                  #_"RedeemData" __redeemData (.. __chain (findRedeemDataByScriptHash (ByteString/copyFrom __scriptHash)))]
                (when (some? __redeemData)
                    (ยง return __redeemData)
                )
            )
        )
        nil
    )

    #_public
    (ยง method #_"void" markP2SHAddressAsUsed [#_"Address" __address]
        (Preconditions/checkArgument (.. __address (isP2SHAddress)))

        (let [#_"RedeemData" __data (.. this (findRedeemDataFromScriptHash (.. __address (getHash160))))]
            (when (nil? __data)
                (ยง return nil) ;; Not our P2SH address.
            )

            (doseq [#_"ECKey" __key (:keys __data)]
                (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
                    (let [#_"DeterministicKey" __k (.. __chain (findKeyFromPubKey (.. __key (getPubKey))))]
                        (when (some? __k)
                            (.. __chain (markKeyAsUsed __k))
                            (.. this (maybeMarkCurrentAddressAsUsed __address))
                        )
                    )
                )
            )
            nil
        )
    )

    #_nilable
    #_override
    #_public
    (ยง method #_"ECKey" findKeyFromPubHash [#_"byte[]" __pubkeyHash]
        (let [#_"ECKey" __result (.. (:basic this) (findKeyFromPubHash __pubkeyHash))]
            (when (some? __result)
                (ยง return __result)
            )

            (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
                (ยง ass __result (.. __chain (findKeyFromPubHash __pubkeyHash)))
                (when (some? __result)
                    (ยง return __result)
                )
            )

            nil
        )
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkeyHash.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_public
    (ยง method #_"void" markPubKeyHashAsUsed [#_"byte[]" __pubkeyHash]
        (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
            (let [#_"DeterministicKey" __key (.. __chain (markPubHashAsUsed __pubkeyHash))]
                (when (some? __key)
                    (.. this (maybeMarkCurrentKeyAsUsed __key))
                    (ยง return nil)
                )
            )
        )
        nil
    )

    ;;; If the given P2SH address is "current", advance it to a new one. ;;
    #_private
    (ยง method- #_"void" maybeMarkCurrentAddressAsUsed [#_"Address" __address]
        (Preconditions/checkArgument (.. __address (isP2SHAddress)))

        (doseq [#_"Map.Entry<KeyChain.KeyPurpose, Address>" __entry (.. (:current-addresses this) (entrySet))]
            (when (and (some? (.. __entry (getValue))) (.. __entry (getValue) (equals __address)))
                (.. KeyChainGroup/log (info "Marking P2SH address as used: {}", __address))
                (.. (:current-addresses this) (put (.. __entry (getKey)), (.. this (freshAddress (.. __entry (getKey))))))
                (ยง return nil)
            )
        )
        nil
    )

    ;;; If the given key is "current", advance the current key to a new one. ;;
    #_private
    (ยง method- #_"void" maybeMarkCurrentKeyAsUsed [#_"DeterministicKey" __key]
        ;; It's OK for currentKeys to be empty here: it means we're a married wallet and the key may be a part of a rotating chain.
        (doseq [#_"Map.Entry<KeyChain.KeyPurpose, DeterministicKey>" __entry (.. (:current-keys this) (entrySet))]
            (when (and (some? (.. __entry (getValue))) (.. __entry (getValue) (equals __key)))
                (.. KeyChainGroup/log (info "Marking key as used: {}", __key))
                (.. (:current-keys this) (put (.. __entry (getKey)), (.. this (freshKey (.. __entry (getKey))))))
                (ยง return nil)
            )
        )
        nil
    )

    #_public
    (ยง method #_"boolean" hasKey [#_"ECKey" __key]
        (when (.. (:basic this) (hasKey __key))
            (ยง return true)
        )
        (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
            (when (.. __chain (hasKey __key))
                (ยง return true)
            )
        )
        false
    )

    #_nilable
    #_override
    #_public
    (ยง method #_"ECKey" findKeyFromPubKey [#_"byte[]" __pubkey]
        (let [#_"ECKey" __result (.. (:basic this) (findKeyFromPubKey __pubkey))]
            (when (some? __result)
                (ยง return __result)
            )

            (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
                (ยง ass __result (.. __chain (findKeyFromPubKey __pubkey)))
                (when (some? __result)
                    (ยง return __result)
                )
            )

            nil
        )
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkey.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_public
    (ยง method #_"void" markPubKeyAsUsed [#_"byte[]" __pubkey]
        (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
            (let [#_"DeterministicKey" __key (.. __chain (markPubKeyAsUsed __pubkey))]
                (when (some? __key)
                    (.. this (maybeMarkCurrentKeyAsUsed __key))
                    (ยง return nil)
                )
            )
        )
        nil
    )

    ;;; Returns the number of keys managed by this group, including the lookahead buffers. ;;
    #_public
    (ยง method #_"int" numKeys []
        (let [#_"int" __result (.. (:basic this) (numKeys))]
            (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
                (ยง ass __result (+ __result (.. __chain (numKeys))))
            )
            __result
        )
    )

    ;;;
     ; Removes a key that was imported into the basic key chain.  You cannot remove deterministic keys.
     ; @throws java.lang.IllegalArgumentException if the key is deterministic.
     ;;
    #_public
    (ยง method #_"boolean" removeImportedKey [#_"ECKey" __key]
        (Preconditions/checkNotNull __key)
        (Preconditions/checkArgument (not (instance? DeterministicKey __key)))

        (.. (:basic this) (removeKey __key))
    )

    ;;;
     ; Whether the active keychain is married.  A keychain is married when it vends P2SH addresses
     ; from multiple keychains in a multisig relationship.
     ; @see org.bitcoinj.wallet.MarriedKeyChain
     ;;
    #_public
    (ยง method #_"boolean" isMarried []
        (and (not (.. (:chains this) (isEmpty))) (.. this (getActiveKeyChain) (isMarried)))
    )

    ;;;
     ; Encrypt the keys in the group using the KeyCrypter and the AES key.
     ; A good default KeyCrypter to use is {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @throws org.bitcoinj.crypto.KeyCrypterException if the wallet encryption fails for some reason,
     ;         leaving the group unchanged.
     ; @throws DeterministicUpgradeRequiredException if there are random keys but no HD chain.
     ;;
    #_public
    (ยง method #_"void" encrypt [#_"KeyCrypter" __keyCrypter, #_"KeyParameter" __aesKey]
        (Preconditions/checkNotNull __keyCrypter)
        (Preconditions/checkNotNull __aesKey)

        ;; This code must be exception safe.
        (let [#_"BasicKeyChain" __newBasic (.. (:basic this) (toEncrypted __keyCrypter, __aesKey))
              #_"List<DeterministicKeyChain>" __newChains (ArrayList. #_"<>" (.. (:chains this) (size)))]
            (when (and (.. (:chains this) (isEmpty)) (== (.. (:basic this) (numKeys)) 0))
                ;; No HD chains and no random keys: encrypting an entirely empty keychain group.
                ;; But we can't do that, we must have something to encrypt: so instantiate a new HD chain here.
                (.. this (createAndActivateNewHDChain))
            )
            (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
                (.. __newChains (add (.. __chain (toEncrypted __keyCrypter, __aesKey))))
            )
            (ยง assoc this :key-crypter __keyCrypter)
            (ยง assoc this :basic __newBasic)
            (.. (:chains this) (clear))
            (.. (:chains this) (addAll __newChains))
            nil
        )
    )

    ;;;
     ; Decrypt the keys in the group using the previously given key crypter and the AES key.
     ; A good default KeyCrypter to use is {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @throws org.bitcoinj.crypto.KeyCrypterException if the wallet decryption fails for some reason, leaving the group unchanged.
     ;;
    #_public
    (ยง method #_"void" decrypt [#_"KeyParameter" __aesKey]
        ;; This code must be exception safe.
        (Preconditions/checkNotNull __aesKey)

        (let [#_"BasicKeyChain" __newBasic (.. (:basic this) (toDecrypted __aesKey))
              #_"List<DeterministicKeyChain>" __newChains (ArrayList. #_"<>" (.. (:chains this) (size)))]
            (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
                (.. __newChains (add (.. __chain (toDecrypted __aesKey))))
            )

            (ยง assoc this :key-crypter nil)
            (ยง assoc this :basic __newBasic)
            (.. (:chains this) (clear))
            (.. (:chains this) (addAll __newChains))
            nil
        )
    )

    ;;; Returns true if the group is encrypted. ;;
    #_public
    (ยง method #_"boolean" isEncrypted []
        (some? (:key-crypter this))
    )

    ;;;
     ; Returns whether this chain has only watching keys (unencrypted keys with no private part).
     ; Mixed chains are forbidden.
     ;
     ; @throws IllegalStateException if there are no keys, or if there is a mix between watching and non-watching keys.
     ;;
    #_public
    (ยง method #_"boolean" isWatching []
        (let [#_"BasicKeyChain.State" __activeState BasicKeyChain.State/EMPTY]
            (when (not (.. (:chains this) (isEmpty)))
                (ยง ass __activeState (if (.. this (getActiveKeyChain) (isWatching)) BasicKeyChain.State/WATCHING BasicKeyChain.State/REGULAR))
            )

            (let [#_"BasicKeyChain.State" __basicState (.. (:basic this) (isWatching))]
                (when (== __basicState BasicKeyChain.State/EMPTY)
                    (when (== __activeState BasicKeyChain.State/EMPTY)
                        (throw (IllegalStateException. "Empty key chain group: cannot answer isWatching() query"))
                    )

                    (ยง return (== __activeState BasicKeyChain.State/WATCHING))
                )

                (when (== __activeState BasicKeyChain.State/EMPTY)
                    (ยง return (== __basicState BasicKeyChain.State/WATCHING))
                )

                (when (!= __activeState __basicState)
                    (throw (IllegalStateException. "Mix of watching and non-watching keys in wallet"))
                )

                (== __activeState BasicKeyChain.State/WATCHING)
            )
        )
    )

    ;;; Returns the key crypter or null if the group is not encrypted. ;;
    #_nilable
    #_public
    (ยง method #_"KeyCrypter" getKeyCrypter []
        (:key-crypter this)
    )

    ;;;
     ; Returns a list of the non-deterministic keys that have been imported into the wallet, or the empty list if none.
     ;;
    #_public
    (ยง method #_"List<ECKey>" getImportedKeys []
        (.. (:basic this) (getKeys))
    )

    #_public
    (ยง method #_"long" getEarliestKeyCreationTime []
        (let [#_"long" __time (.. (:basic this) (getEarliestKeyCreationTime))] ;; Long.MAX_VALUE if empty.
            (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
                (ยง ass __time (Math/min __time, (.. __chain (getEarliestKeyCreationTime))))
            )
            __time
        )
    )

    #_public
    (ยง method #_"int" getBloomFilterElementCount []
        (let [#_"int" __result (.. (:basic this) (numBloomFilterEntries))]
            (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
                (ยง ass __result (+ __result (.. __chain (numBloomFilterEntries))))
            )
            __result
        )
    )

    #_public
    (ยง method #_"BloomFilter" getBloomFilter [#_"int" __size, #_"double" __falsePositiveRate, #_"long" __nTweak]
        (let [#_"BloomFilter" __filter (BloomFilter. __size, __falsePositiveRate, __nTweak)]
            (when (< 0 (.. (:basic this) (numKeys)))
                (.. __filter (merge (.. (:basic this) (getFilter __size, __falsePositiveRate, __nTweak))))
            )

            (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
                (.. __filter (merge (.. __chain (getFilter __size, __falsePositiveRate, __nTweak))))
            )
            __filter
        )
    )

    #_private
    (ยง method- #_"Script" makeP2SHOutputScript [#_"DeterministicKey" __followedKey, #_"DeterministicKeyChain" __chain]
        (ScriptBuilder/createP2SHOutputScript (:redeem-script (.. __chain (getRedeemData __followedKey))))
    )

    ;;; Adds a listener for events that are run when keys are added, on the user thread. ;;
    #_public
    (ยง method #_"void" addEventListener [#_"KeyChainEventListener" __listener]
        (.. this (addEventListener __listener, Threading/USER_THREAD))
        nil
    )

    ;;; Adds a listener for events that are run when keys are added, on the given executor. ;;
    #_public
    (ยง method #_"void" addEventListener [#_"KeyChainEventListener" __listener, #_"Executor" __executor]
        (Preconditions/checkNotNull __listener)
        (Preconditions/checkNotNull __executor)

        (.. (:basic this) (addEventListener __listener, __executor))
        (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
            (.. __chain (addEventListener __listener, __executor))
        )
        nil
    )

    ;;; Removes a listener for events that are run when keys are added. ;;
    #_public
    (ยง method #_"boolean" removeEventListener [#_"KeyChainEventListener" __listener]
        (Preconditions/checkNotNull __listener)

        (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
            (.. __chain (removeEventListener __listener))
        )
        (.. (:basic this) (removeEventListener __listener))
    )

    ;;; Returns a list of key protobufs obtained by merging the chains. ;;
    #_public
    (ยง method #_"List<Protos.Key>" serializeToProtobuf []
        (let [#_"List<Protos.Key>" __result (if (some? (:basic this)) (.. (:basic this) (serializeToProtobuf)) (Lists/newArrayList))]

            (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
                (let [#_"List<Protos.Key>" __protos (.. __chain (serializeToProtobuf))]
                    (.. __result (addAll __protos))
                )
            )
            __result
        )
    )

    #_static
    #_throws #_[ "UnreadableWalletException" ]
    (ยง defn #_"KeyChainGroup" KeyChainGroup/fromProtobufUnencrypted [#_"NetworkParameters" __params, #_"List<Protos.Key>" __keys]
        (KeyChainGroup/fromProtobufUnencrypted __params, __keys, (DefaultKeyChainFactory.))
    )

    #_public
    #_static
    #_throws #_[ "UnreadableWalletException" ]
    (ยง defn #_"KeyChainGroup" KeyChainGroup/fromProtobufUnencrypted [#_"NetworkParameters" __params, #_"List<Protos.Key>" __keys, #_"KeyChainFactory" __factory]
        (let [#_"BasicKeyChain" __basicKeyChain (BasicKeyChain/fromProtobufUnencrypted __keys)
              #_"List<DeterministicKeyChain>" __chains (DeterministicKeyChain/fromProtobuf __keys, nil, __factory)
              #_"EnumMap<KeyChain.KeyPurpose, DeterministicKey>" __currentKeys nil]
            (when (not (.. __chains (isEmpty)))
                (ยง ass __currentKeys (KeyChainGroup/createCurrentKeysMap __chains))
            )
            (KeyChainGroup/extractFollowingKeychains __chains)
            (KeyChainGroup. __params, __basicKeyChain, __chains, __currentKeys, nil)
        )
    )

    #_static
    #_throws #_[ "UnreadableWalletException" ]
    (ยง defn #_"KeyChainGroup" KeyChainGroup/fromProtobufEncrypted [#_"NetworkParameters" __params, #_"List<Protos.Key>" __keys, #_"KeyCrypter" __crypter]
        (KeyChainGroup/fromProtobufEncrypted __params, __keys, __crypter, (DefaultKeyChainFactory.))
    )

    #_public
    #_static
    #_throws #_[ "UnreadableWalletException" ]
    (ยง defn #_"KeyChainGroup" KeyChainGroup/fromProtobufEncrypted [#_"NetworkParameters" __params, #_"List<Protos.Key>" __keys, #_"KeyCrypter" __crypter, #_"KeyChainFactory" __factory]
        (Preconditions/checkNotNull __crypter)

        (let [#_"BasicKeyChain" __basicKeyChain (BasicKeyChain/fromProtobufEncrypted __keys, __crypter)
              #_"List<DeterministicKeyChain>" __chains (DeterministicKeyChain/fromProtobuf __keys, __crypter, __factory)
              #_"EnumMap<KeyChain.KeyPurpose, DeterministicKey>" __currentKeys nil]
            (when (not (.. __chains (isEmpty)))
                (ยง ass __currentKeys (KeyChainGroup/createCurrentKeysMap __chains))
            )
            (KeyChainGroup/extractFollowingKeychains __chains)
            (KeyChainGroup. __params, __basicKeyChain, __chains, __currentKeys, __crypter)
        )
    )

    ;;;
     ; If the key chain contains only random keys and no deterministic key chains, this method will create a chain
     ; based on the oldest non-rotating private key (i.e. the seed is derived from the old wallet).
     ;
     ; @param keyRotationTimeSecs If non-zero, UNIX time for which keys created before this are assumed to be
     ;                            compromised or weak, those keys will not be used for deterministic upgrade.
     ; @param aesKey If non-null, the encryption key the keychain is encrypted under.  If the keychain is encrypted
     ;               and this is not supplied, an exception is thrown letting you know you should ask the user for
     ;               their password, turn it into a key, and then try again.
     ; @throws java.lang.IllegalStateException if there is already a deterministic key chain present or if there are
     ;                                         no random keys (i.e. this is not an upgrade scenario), or if aesKey is
     ;                                         provided but the wallet is not encrypted.
     ; @throws java.lang.IllegalArgumentException if the rotation time specified excludes all keys.
     ; @throws DeterministicUpgradeRequiresPassword if the key chain group is encrypted
     ;         and you should provide the users encryption key.
     ; @return the DeterministicKeyChain that was created by the upgrade.
     ;;
    #_public
    #_throws #_[ "DeterministicUpgradeRequiresPassword", "AllRandomKeysRotating" ]
    (ยง method #_"DeterministicKeyChain" upgradeToDeterministic [#_"long" __keyRotationTimeSecs, #_nilable #_"KeyParameter" __aesKey]
        (Preconditions/checkState (< 0 (.. (:basic this) (numKeys))))
        (Preconditions/checkArgument (<= 0 __keyRotationTimeSecs))

        ;; Subtract one because the key rotation time might have been set to the creation time of the first known
        ;; good key, in which case, that's the one we want to find.
        (let [#_"ECKey" __keyToUse (.. (:basic this) (findOldestKeyAfter (dec __keyRotationTimeSecs)))]
            (when (nil? __keyToUse)
                (throw (AllRandomKeysRotating.))
            )

            (cond (.. __keyToUse (isEncrypted))
                (do
                    (when (nil? __aesKey)
                        ;; We can't auto upgrade because we don't know the users password at this point.  We throw an exception
                        ;; so the calling code knows to abort the load and ask the user for their password, they can then try
                        ;; loading the wallet again passing in the AES key.
                        ;;
                        ;; There are a few different approaches we could have used here, but they all suck.  The most obvious
                        ;; is to try and be as lazy as possible, running in the old random-wallet mode until the user enters
                        ;; their password for some other reason and doing the upgrade then.  But this could result in strange
                        ;; and unexpected UI flows for the user, as well as complicating the job of wallet developers who then
                        ;; have to support both "old" and "new" UI modes simultaneously, switching them on the fly.  Given that
                        ;; this is a one-off transition, it seems more reasonable to just ask the user for their password
                        ;; on startup, and then the wallet app can have all the widgets for accessing seed words etc active
                        ;; all the time.
                        (throw (DeterministicUpgradeRequiresPassword.))
                    )
                    (ยง ass __keyToUse (.. __keyToUse (decrypt __aesKey)))
                )
                (some? __aesKey)
                (do
                    (throw (IllegalStateException. "AES Key was provided but wallet is not encrypted."))
                )
            )

            (if (.. (:chains this) (isEmpty))
                (.. KeyChainGroup/log (info "Auto-upgrading pre-HD wallet to HD!"))
                (.. KeyChainGroup/log (info "Wallet with existing HD chain is being re-upgraded due to change in key rotation time."))
            )

            (.. KeyChainGroup/log (info "Instantiating new HD chain using oldest non-rotating private key (address: {})", (.. __keyToUse (toAddress (:params this)))))
            (let [#_"byte[]" __entropy (Preconditions/checkNotNull (.. __keyToUse (getSecretBytes)))]
                ;; Private keys should be at least 128 bits long.
                (Preconditions/checkState (<= (/ DeterministicSeed/DEFAULT_SEED_ENTROPY_BITS 8) (.. __entropy (alength))))
                ;; We reduce the entropy here to 128 bits because people like to write their seeds down on paper,
                ;; and 128 bits should be sufficient forever unless the laws of the universe change or ECC is broken;
                ;; in either case we all have bigger problems.
                (ยง ass __entropy (Arrays/copyOfRange __entropy, 0, (/ DeterministicSeed/DEFAULT_SEED_ENTROPY_BITS 8))) ;; Final argument is exclusive range.
                (Preconditions/checkState (== (.. __entropy (alength)) (/ DeterministicSeed/DEFAULT_SEED_ENTROPY_BITS 8)))
                (let [#_"String" __passphrase ""] ;; FIXME allow non-empty passphrase
                    (let [#_"DeterministicKeyChain" __chain (DeterministicKeyChain. __entropy, __passphrase, (.. __keyToUse (getCreationTimeSeconds)))]
                        (when (some? __aesKey)
                            (ยง ass __chain (.. __chain (toEncrypted (Preconditions/checkNotNull (.. (:basic this) (getKeyCrypter))), __aesKey)))
                        )
                        (.. (:chains this) (add __chain))
                        __chain
                    )
                )
            )
        )
    )

    ;;; Returns true if the group contains random keys but no HD chains. ;;
    #_public
    (ยง method #_"boolean" isDeterministicUpgradeRequired []
        (and (< 0 (.. (:basic this) (numKeys))) (.. (:chains this) (isEmpty)))
    )

    #_private
    #_static
    (ยง defn- #_"EnumMap<KeyChain.KeyPurpose, DeterministicKey>" KeyChainGroup/createCurrentKeysMap [#_"List<DeterministicKeyChain>" __chains]
        (let [#_"DeterministicKeyChain" __activeChain (.. __chains (get (dec (.. __chains (size)))))]

            (let [#_"EnumMap<KeyChain.KeyPurpose, DeterministicKey>" __currentKeys (EnumMap. #_"<>" KeyChain.KeyPurpose)]

                ;; Assuming that only RECEIVE and CHANGE keys are being used at the moment, we will treat the latest issued
                ;; external key as current RECEIVE key and latest issued internal key as CHANGE key.  This should be changed
                ;; as soon as other kinds of KeyPurpose are introduced.
                (when (< 0 (.. __activeChain (getIssuedExternalKeys)))
                    (let [#_"DeterministicKey" __currentExternalKey (.. __activeChain (getKeyByPath (HDUtils/append (HDUtils/concat (.. __activeChain (getAccountPath)), DeterministicKeyChain/EXTERNAL_SUBPATH), (ChildNumber. (dec (.. __activeChain (getIssuedExternalKeys)))))))]
                        (.. __currentKeys (put KeyChain.KeyPurpose/RECEIVE_FUNDS, __currentExternalKey))
                    )
                )

                (when (< 0 (.. __activeChain (getIssuedInternalKeys)))
                    (let [#_"DeterministicKey" __currentInternalKey (.. __activeChain (getKeyByPath (HDUtils/append (HDUtils/concat (.. __activeChain (getAccountPath)), DeterministicKeyChain/INTERNAL_SUBPATH), (ChildNumber. (dec (.. __activeChain (getIssuedInternalKeys)))))))]
                        (.. __currentKeys (put KeyChain.KeyPurpose/CHANGE, __currentInternalKey))
                    )
                )

                __currentKeys
            )
        )
    )

    #_private
    #_static
    (ยง defn- #_"void" KeyChainGroup/extractFollowingKeychains [#_"List<DeterministicKeyChain>" __chains]
        ;; Look for following key chains and map them to the watch keys of followed keychains.
        (let [#_"List<DeterministicKeyChain>" __followingChains (Lists/newArrayList)]
            (loop-when-recur [#_"Iterator<DeterministicKeyChain>" __it (.. __chains (iterator))] (.. __it (hasNext)) []
                (let [#_"DeterministicKeyChain" __chain (.. __it (next))]
                    (cond (.. __chain (isFollowing))
                        (do
                            (.. __followingChains (add __chain))
                            (.. __it (remove))
                        )
                        (not (.. __followingChains (isEmpty)))
                        (do
                            (when (not (instance? MarriedKeyChain __chain))
                                (throw (IllegalStateException.))
                            )

                            (.. (cast MarriedKeyChain __chain) (setFollowingKeyChains __followingChains))
                            (ยง ass __followingChains (Lists/newArrayList))
                        )
                    )
                )
            )
            nil
        )
    )

    #_public
    (ยง method #_"String" toString [#_"boolean" __includePrivateKeys]
        (let [#_"StringBuilder" __sb (StringBuilder.)]
            (when (some? (:basic this))
                (let [#_"List<ECKey>" __keys (.. (:basic this) (getKeys))]
                    (Collections/sort __keys, ECKey/AGE_COMPARATOR)
                    (doseq [#_"ECKey" __key __keys]
                        (.. __key (formatKeyWithAddress __includePrivateKeys, __sb, (:params this)))
                    )
                )
            )
            (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
                (.. __sb (append (.. __chain (toString __includePrivateKeys, (:params this)))) (append "\n"))
            )
            (.. __sb (toString))
        )
    )

    ;;; Returns a copy of the current list of chains. ;;
    #_public
    (ยง method #_"List<DeterministicKeyChain>" getDeterministicKeyChains []
        (ArrayList. #_"<>" (:chains this))
    )

    ;;;
     ; Returns a counter that increases (by an arbitrary amount) each time new keys have been calculated
     ; due to lookahead and thus the Bloom filter that was previously calculated has become stale.
     ;;
    #_public
    (ยง method #_"int" getCombinedKeyLookaheadEpochs []
        (let [#_"int" __epoch 0]
            (doseq [#_"DeterministicKeyChain" __chain (:chains this)]
                (ยง ass __epoch (+ __epoch (.. __chain (getKeyLookaheadEpoch))))
            )
            __epoch
        )
    )
)

;;;
 ; A coin selector that takes all coins assigned to keys created before the given timestamp.
 ; Used as part of the implementation of {@link Wallet#setKeyRotationTime(java.util.Date)}.
 ;;
#_public
(ยง class KeyTimeCoinSelector (ยง implements CoinSelector)
    #_private
    #_static
    (ยง def- #_"Logger" KeyTimeCoinSelector/log (LoggerFactory/getLogger KeyTimeCoinSelector))

    ;;; A number of inputs chosen to avoid hitting {@link org.bitcoinj.core.Transaction#MAX_STANDARD_TX_SIZE}. ;;
    #_public
    #_static
    (ยง def #_"int" KeyTimeCoinSelector/MAX_SIMULTANEOUS_INPUTS 600)

    #_private
    (ยง field- #_"long" :unix-time-seconds)
    #_private
    (ยง field- #_"Wallet" :wallet)
    #_private
    (ยง field- #_"boolean" :ignore-pending)

    #_public
    (ยง constructor KeyTimeCoinSelector [#_"Wallet" __wallet, #_"long" __unixTimeSeconds, #_"boolean" __ignorePending]
        (ยง assoc this :unix-time-seconds __unixTimeSeconds)
        (ยง assoc this :wallet __wallet)
        (ยง assoc this :ignore-pending __ignorePending)
        this
    )

    #_override
    #_public
    (ยง method #_"CoinSelection" select [#_"Coin" __target, #_"List<TransactionOutput>" __candidates]
        (try
            (let [#_"LinkedList<TransactionOutput>" __gathered (Lists/newLinkedList)
                  #_"Coin" __valueGathered Coin/ZERO]
                (doseq [#_"TransactionOutput" __output __candidates]
                    (when (and (:ignore-pending this) (not (.. this (isConfirmed __output))))
                        (ยง continue )
                    )

                    ;; Find the key that controls output, assuming it's a regular pay-to-pubkey or pay-to-address output.
                    ;; We ignore any other kind of exotic output on the assumption we can't spend it ourselves.
                    (let [#_"Script" __scriptPubKey (.. __output (getScriptPubKey))
                          #_"ECKey" __controllingKey]
                        (cond (.. __scriptPubKey (isSentToRawPubKey))
                            (do
                                (ยง ass __controllingKey (.. (:wallet this) (findKeyFromPubKey (.. __scriptPubKey (getPubKey)))))
                            )
                            (.. __scriptPubKey (isSentToAddress))
                            (do
                                (ยง ass __controllingKey (.. (:wallet this) (findKeyFromPubHash (.. __scriptPubKey (getPubKeyHash)))))
                            )
                            :else
                            (do
                                (.. KeyTimeCoinSelector/log (info "Skipping tx output {} because it's not of simple form.", __output))
                                (ยง continue )
                            )
                        )

                        (Preconditions/checkNotNull __controllingKey, "Coin selector given output as candidate for which we lack the key")
                        (when (<= (:unix-time-seconds this) (.. __controllingKey (getCreationTimeSeconds)))
                            (ยง continue )
                        )

                        ;; It's older than the cutoff time so select.
                        (ยง ass __valueGathered (.. __valueGathered (add (.. __output (getValue)))))
                        (.. __gathered (push __output))
                        (when (<= KeyTimeCoinSelector/MAX_SIMULTANEOUS_INPUTS (.. __gathered (size)))
                            (.. KeyTimeCoinSelector/log (warn "Reached {} inputs, going further would yield a tx that is too large, stopping here.", (.. __gathered (size))))
                            (ยง break )
                        )
                    )
                )
                (ยง return (CoinSelection. __valueGathered, __gathered))
            )
            (catch ScriptException __e
                (throw (RuntimeException. __e)) ;; We should never have problems understanding scripts in our wallet.
            )
        )
    )

    #_private
    (ยง method- #_"boolean" isConfirmed [#_"TransactionOutput" __output]
        (.. __output (getParentTransaction) (getConfidence) (getConfidenceType) (equals TransactionConfidence.ConfidenceType/BUILDING))
    )
)

;;;
 ; <p>A multi-signature keychain using synchronized HD keys (a.k.a HDM).</p>
 ;
 ; <p>This keychain keeps track of following keychains that follow the account key of this keychain.  You can get P2SH
 ; addresses to receive coins to from this chain.  The threshold - sigsRequiredToSpend specifies how many signatures
 ; required to spend transactions for this married keychain.  This value should not exceed the total number of keys
 ; involved (one followed key plus number of following keys), otherwise IllegalArgumentException will be thrown.</p>
 ;
 ; <p>IMPORTANT: As of Bitcoin Core 0.9 all multisig transactions which require more than 3 public keys are non-standard and
 ; such spends won't be processed by peers with default settings, essentially making such transactions almost nonspendable.</p>
 ;
 ; <p>This method will throw an IllegalStateException, if the keychain is already married or already has leaf keys issued.</p>
 ;;
#_public
(ยง class MarriedKeyChain (ยง extends DeterministicKeyChain)
    ;; The map holds P2SH redeem script and corresponding ECKeys issued by this KeyChainGroup (including lookahead)
    ;; mapped to redeem script hashes.
    #_private
    (ยง field- #_"LinkedHashMap<ByteString, RedeemData>" :married-keys-redeem-data (LinkedHashMap. #_"<>"))

    #_private
    (ยง field- #_"List<DeterministicKeyChain>" :following-key-chains)

    ;;; Builds a {@link MarriedKeyChain}. ;;
    #_public
    #_static
    (ยง class MarriedKeyChain.Builder #_"<T extends DeterministicKeyChain.Builder<T>>" (ยง extends DeterministicKeyChain.Builder #_"<T>")
        #_private
        (ยง field- #_"List<DeterministicKey>" :following-keys)
        #_private
        (ยง field- #_"int" :threshold)

        #_protected
        (ยง constructor MarriedKeyChain.Builder []
            this
        )

        #_public
        (ยง method #_"T" followingKeys [#_"List<DeterministicKey>" __followingKeys]
            (ยง assoc this :following-keys __followingKeys)
            (.. this (self))
        )

        #_public
        (ยง method #_"T" followingKeys [#_"DeterministicKey" __followingKey, #_"DeterministicKey" __followingKeys ...]
            (ยง assoc this :following-keys (Lists/asList __followingKey, __followingKeys))
            (.. this (self))
        )

        ;;;
         ; Threshold, or <code>((followingKeys.size() + 1) / 2 + 1)</code> (majority) if unspecified.
         ;
         ; IMPORTANT: As of Bitcoin Core 0.9 all multisig transactions which require more than 3 public keys are non-standard and
         ; such spends won't be processed by peers with default settings, essentially making such transactions almost nonspendable.
         ;;
        #_public
        (ยง method #_"T" threshold [#_"int" __threshold]
            (ยง assoc this :threshold __threshold)
            (.. this (self))
        )

        #_override
        #_public
        (ยง method #_"MarriedKeyChain" build []
            (Preconditions/checkState (or (some? (:random this)) (some? (:entropy this)) (some? (:seed this)) (some? (:watching-key this))), "Must provide either entropy or random or seed or watchingKey")
            (Preconditions/checkNotNull (:following-keys this), "followingKeys must be provided")

            (let [#_"MarriedKeyChain" __chain]
                (when (== (:threshold this) 0)
                    (ยง assoc this :threshold (inc (/ (inc (.. (:following-keys this) (size))) 2)))
                )

                (cond (some? (:random this))
                    (do
                        (ยง ass __chain (MarriedKeyChain. (:random this), (:bits this), (.. this (getPassphrase)), (:seed-creation-time-secs this)))
                    )
                    (some? (:entropy this))
                    (do
                        (ยง ass __chain (MarriedKeyChain. (:entropy this), (.. this (getPassphrase)), (:seed-creation-time-secs this)))
                    )
                    (some? (:seed this))
                    (do
                        (.. (:seed this) (setCreationTimeSeconds (:seed-creation-time-secs this)))
                        (ยง ass __chain (MarriedKeyChain. (:seed this)))
                    )
                    :else
                    (do
                        (.. (:watching-key this) (setCreationTimeSeconds (:seed-creation-time-secs this)))
                        (ยง ass __chain (MarriedKeyChain. (:watching-key this)))
                    )
                )

                (.. __chain (addFollowingAccountKeys (:following-keys this), (:threshold this)))
                __chain
            )
        )
    )

    #_public
    #_static
    (ยง defn #_"MarriedKeyChain.Builder<?>" MarriedKeyChain/builder []
        (MarriedKeyChain.Builder.)
    )

    ;; Protobuf deserialization constructors.
    (ยง constructor MarriedKeyChain [#_"DeterministicKey" __accountKey]
        (ยง super __accountKey, false)
        this
    )

    (ยง constructor MarriedKeyChain [#_"DeterministicSeed" __seed, #_"KeyCrypter" __crypter]
        (ยง super __seed, __crypter)
        this
    )

    ;; Builder constructors.
    #_private
    (ยง constructor- #_"MarriedKeyChain" [#_"SecureRandom" __random, #_"int" __bits, #_"String" __passphrase, #_"long" __seedCreationTimeSecs]
        (ยง super __random, __bits, __passphrase, __seedCreationTimeSecs)
        this
    )

    #_private
    (ยง constructor- #_"MarriedKeyChain" [#_"byte[]" __entropy, #_"String" __passphrase, #_"long" __seedCreationTimeSecs]
        (ยง super __entropy, __passphrase, __seedCreationTimeSecs)
        this
    )

    #_private
    (ยง constructor- #_"MarriedKeyChain" [#_"DeterministicSeed" __seed]
        (ยง super __seed)
        this
    )

    (ยง method #_"void" setFollowingKeyChains [#_"List<DeterministicKeyChain>" __followingKeyChains]
        (Preconditions/checkArgument (not (.. __followingKeyChains (isEmpty))))
        (ยง assoc this :following-key-chains __followingKeyChains)
        nil
    )

    #_override
    #_public
    (ยง method #_"boolean" isMarried []
        true
    )

    ;;; Create a new married key and return the matching output script. ;;
    #_override
    #_public
    (ยง method #_"Script" freshOutputScript [#_"KeyChain.KeyPurpose" __purpose]
        (let [#_"DeterministicKey" __followedKey (.. this (getKey __purpose))
              #_"ImmutableList.Builder<ECKey>" __keys (.. (ImmutableList/builder #_"ImmutableList<ECKey>") (add __followedKey))]
            (doseq [#_"DeterministicKeyChain" __keyChain (:following-key-chains this)]
                (let [#_"DeterministicKey" __followingKey (.. __keyChain (getKey __purpose))]
                    (Preconditions/checkState (.. __followedKey (getChildNumber) (equals (.. __followingKey (getChildNumber)))), "Following keychains should be in sync")
                    (.. __keys (add __followingKey))
                )
            )
            (let [#_"List<ECKey>" __marriedKeys (.. __keys (build))
                  #_"Script" __redeemScript (ScriptBuilder/createRedeemScript (:sigs-required-to-spend this), __marriedKeys)]
                (ScriptBuilder/createP2SHOutputScript __redeemScript)
            )
        )
    )

    #_private
    (ยง method- #_"List<ECKey>" getMarriedKeysWithFollowed [#_"DeterministicKey" __followedKey]
        (let [#_"ImmutableList.Builder<ECKey>" __keys (ImmutableList/builder)]
            (doseq [#_"DeterministicKeyChain" __keyChain (:following-key-chains this)]
                (.. __keyChain (maybeLookAhead))
                (.. __keys (add (.. __keyChain (getKeyByPath (.. __followedKey (getPath))))))
            )
            (.. __keys (add __followedKey))
            (.. __keys (build))
        )
    )

    ;;; Get the redeem data for a key in this married chain. ;;
    #_override
    #_public
    (ยง method #_"RedeemData" getRedeemData [#_"DeterministicKey" __followedKey]
        (let [#_"List<ECKey>" __marriedKeys (.. this (getMarriedKeysWithFollowed __followedKey))
              #_"Script" __redeemScript (ScriptBuilder/createRedeemScript (:sigs-required-to-spend this), __marriedKeys)]
            (RedeemData/of __marriedKeys, __redeemScript)
        )
    )

    #_private
    (ยง method- #_"void" addFollowingAccountKeys [#_"List<DeterministicKey>" __followingAccountKeys, #_"int" __sigsRequiredToSpend]
        (Preconditions/checkArgument (<= __sigsRequiredToSpend (inc (.. __followingAccountKeys (size)))), "Multisig threshold can't exceed total number of keys")
        (Preconditions/checkState (== (.. this (numLeafKeysIssued)) 0), "Active keychain already has keys in use")
        (Preconditions/checkState (nil? (:following-key-chains this)))

        (let [#_"List<DeterministicKeyChain>" __followingKeyChains (Lists/newArrayList)]

            (doseq [#_"DeterministicKey" __key __followingAccountKeys]
                (Preconditions/checkArgument (== (.. __key (getPath) (size)) (.. this (getAccountPath) (size))), "Following keys have to be account keys")

                (let [#_"DeterministicKeyChain" __chain (DeterministicKeyChain/watchAndFollow __key)]
                    (when (<= 0 (:lookahead-size this))
                        (.. __chain (setLookaheadSize (:lookahead-size this)))
                    )
                    (when (<= 0 (:lookahead-threshold this))
                        (.. __chain (setLookaheadThreshold (:lookahead-threshold this)))
                    )
                    (.. __followingKeyChains (add __chain))
                )
            )

            (ยง assoc this :sigs-required-to-spend __sigsRequiredToSpend)
            (ยง assoc this :following-key-chains __followingKeyChains)
            nil
        )
    )

    #_override
    #_public
    (ยง method #_"void" setLookaheadSize [#_"int" __lookaheadSize]
        (.. (:lock this) (lock))
        (try
            (.. super (setLookaheadSize __lookaheadSize))

            (when (some? (:following-key-chains this))
                (doseq [#_"DeterministicKeyChain" __followingChain (:following-key-chains this)]
                    (.. __followingChain (setLookaheadSize __lookaheadSize))
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    #_override
    #_public
    (ยง method #_"List<Protos.Key>" serializeToProtobuf []
        (let [#_"List<Protos.Key>" __result (Lists/newArrayList)]
            (.. (:lock this) (lock))
            (try
                (doseq [#_"DeterministicKeyChain" __chain (:following-key-chains this)]
                    (.. __result (addAll (.. __chain (serializeMyselfToProtobuf))))
                )
                (.. __result (addAll (.. this (serializeMyselfToProtobuf))))
                (finally
                    (.. (:lock this) (unlock))
                )
            )
            __result
        )
    )

    #_override
    #_protected
    (ยง method #_"void" formatAddresses [#_"boolean" __includePrivateKeys, #_"NetworkParameters" __params, #_"StringBuilder" __sb]
        (doseq [#_"DeterministicKeyChain" __followingChain (:following-key-chains this)]
            (.. __sb (append "Following chain:  ") (append (.. __followingChain (getWatchingKey) (serializePubB58 __params))) (append "\n"))
        )
        (.. __sb (append "\n"))
        (doseq [#_"RedeemData" __redeemData (.. (:married-keys-redeem-data this) (values))]
            (.. this (formatScript (ScriptBuilder/createP2SHOutputScript (:redeem-script __redeemData)), __sb, __params))
        )
        nil
    )

    #_private
    (ยง method- #_"void" formatScript [#_"Script" __script, #_"StringBuilder" __sb, #_"NetworkParameters" __params]
        (.. __sb (append "  addr:") (append (.. __script (getToAddress __params))))
        (.. __sb (append "  hash160:") (append (.. Utils/HEX (encode (.. __script (getPubKeyHash))))))
        (when (< 0 (.. __script (getCreationTimeSeconds)))
            (.. __sb (append "  creationTimeSeconds:") (append (.. __script (getCreationTimeSeconds))))
        )
        (.. __sb (append "\n"))
        nil
    )

    #_override
    #_public
    (ยง method #_"void" maybeLookAheadScripts []
        (.. super (maybeLookAheadScripts))

        (let [#_"int" __numLeafKeys (.. this (getLeafKeys) (size))]
            (Preconditions/checkState (<= (.. (:married-keys-redeem-data this) (size)) __numLeafKeys), "Number of scripts is greater than number of leaf keys")

            (when (!= (.. (:married-keys-redeem-data this) (size)) __numLeafKeys)
                (.. this (maybeLookAhead))
                (doseq [#_"DeterministicKey" __followedKey (.. this (getLeafKeys))]
                    (let [#_"RedeemData" __redeemData (.. this (getRedeemData __followedKey))
                          #_"Script" __scriptPubKey (ScriptBuilder/createP2SHOutputScript (:redeem-script __redeemData))]
                        (.. (:married-keys-redeem-data this) (put (ByteString/copyFrom (.. __scriptPubKey (getPubKeyHash))), __redeemData))
                    )
                )
            )
            nil
        )
    )

    #_nilable
    #_override
    #_public
    (ยง method #_"RedeemData" findRedeemDataByScriptHash [#_"ByteString" __bytes]
        (.. (:married-keys-redeem-data this) (get __bytes))
    )

    #_override
    #_public
    (ยง method #_"BloomFilter" getFilter [#_"int" __size, #_"double" __falsePositiveRate, #_"long" __tweak]
        (.. (:lock this) (lock))
        (let [#_"BloomFilter" __filter]
            (try
                (ยง ass __filter (BloomFilter. __size, __falsePositiveRate, __tweak))
                (doseq [#_"Map.Entry<ByteString, RedeemData>" __entry (.. (:married-keys-redeem-data this) (entrySet))]
                    (.. __filter (insert (.. __entry (getKey) (toByteArray))))
                    (.. __filter (insert (.. __entry (getValue) :redeem-script (getProgram))))
                )
                (finally
                    (.. (:lock this) (unlock))
                )
            )
            __filter
        )
    )

    #_override
    #_public
    (ยง method #_"int" numBloomFilterEntries []
        (.. this (maybeLookAhead))
        (* (.. this (getLeafKeys) (size)) 2)
    )
)

;;;
 ; This class aggregates data required to spend transaction output.
 ;
 ; For pay-to-address and pay-to-pubkey transactions it will have only a single key and CHECKSIG program as redeemScript.
 ; For multisignature transactions there will be multiple keys one of which will be a full key and the rest are watch only,
 ; redeem script will be a CHECKMULTISIG program.  Keys will be sorted in the same order they appear in
 ; a program (lexicographical order).
 ;;
#_public
(ยง class RedeemData
    #_public
    (ยง field #_"Script" :redeem-script)
    #_public
    (ยง field #_"List<ECKey>" :keys)

    #_private
    (ยง constructor- #_"RedeemData" [#_"List<ECKey>" __keys, #_"Script" __redeemScript]
        (ยง assoc this :redeem-script __redeemScript)
        (let [#_"List<ECKey>" __sortedKeys (ArrayList. #_"<>" __keys)]
            (Collections/sort __sortedKeys, ECKey/PUBKEY_COMPARATOR)
            (ยง assoc this :keys __sortedKeys)
            this
        )
    )

    #_public
    #_static
    (ยง defn #_"RedeemData" RedeemData/of [#_"List<ECKey>" __keys, #_"Script" __redeemScript]
        (RedeemData. __keys, __redeemScript)
    )

    ;;;
     ; Creates RedeemData for pay-to-address or pay-to-pubkey input.  Provided key is a single private key
     ; needed to spend such inputs and provided program should be a proper CHECKSIG program.
     ;;
    #_public
    #_static
    (ยง defn #_"RedeemData" RedeemData/of [#_"ECKey" __key, #_"Script" __program]
        (Preconditions/checkArgument (or (.. __program (isSentToAddress)) (.. __program (isSentToRawPubKey))))

        (when (some? __key) (RedeemData. (Collections/singletonList __key), __program))
    )

    ;;;
     ; Returns the first key that has private bytes.
     ;;
    #_public
    (ยง method #_"ECKey" getFullKey []
        (doseq [#_"ECKey" __key (:keys this)]
            (when (.. __key (hasPrivKey))
                (ยง return __key)
            )
        )
        nil
    )
)

;;;
 ; <p>A RiskAnalysis represents an analysis of how likely it is that a transaction (and its dependencies)
 ; represents a possible double spending attack.  The wallet will create these to decide whether or not to accept
 ; a pending transaction.  Look at {@link DefaultRiskAnalysis} to see what is currently considered risky.</p>
 ;
 ; <p>The intention here is that implementing classes can expose more information and detail about the result,
 ; for app developers.  The core code needs only to know whether it's OK or not.</p>
 ;
 ; <p>A factory interface is provided.  The wallet will use this to analyze new pending transactions.</p>
 ;;
#_public
(ยง interface RiskAnalysis
    (ยง enum RiskAnalysis.Result
        (ยง item OK)
        (ยง item NON_FINAL)
        (ยง item NON_STANDARD)
    )

    (ยง method #_"RiskAnalysis.Result" analyze [])

    (ยง interface RiskAnalysis.Analyzer
        (ยง method #_"RiskAnalysis" create [#_"Wallet" __wallet, #_"Transaction" __tx, #_"List<Transaction>" __dependencies])
    )
)

;;;
 ; A SendRequest gives the wallet information about precisely how to send money to a recipient or set of recipients.
 ; Static methods are provided to help you create SendRequests and there are a few helper methods on the wallet that
 ; just simplify the most common use cases.  You may wish to customize a SendRequest if you want to attach a fee or
 ; modify the change address.
 ;;
#_public
(ยง class SendRequest
    ;;;
     ; <p>A transaction, probably incomplete, that describes the outline of what you want to do.  This typically
     ; will mean it has some outputs to the intended destinations, but no inputs or change address (and therefore
     ; no fees) - the wallet will calculate all that for you and update tx later.</p>
     ;
     ; <p>Be careful when adding outputs that you check the min output value
     ; ({@link TransactionOutput#getMinNonDustValue(Coin)}) to avoid the whole transaction being rejected
     ; because one output is dust.</p>
     ;
     ; <p>If there are already inputs to the transaction, make sure their out point has a connected output,
     ; otherwise their value will be added to fee.  Also ensure they are either signed or are spendable by
     ; a wallet key, otherwise the behavior of {@link Wallet#completeTx(Wallet.SendRequest)} is undefined
     ; (likely RuntimeException).</p>
     ;;
    #_public
    (ยง field #_"Transaction" :tx)

    ;;;
     ; When emptyWallet is set, all coins selected by the coin selector are sent to the first output in tx
     ; (its value is ignored and set to {@link org.bitcoinj.wallet.Wallet#getBalance()} - the fees required
     ; for the transaction).  Any additional outputs are removed.
     ;;
    #_public
    (ยง field #_"boolean" :empty-wallet false)

    ;;;
     ; "Change" means the difference between the value gathered by a transactions inputs (the size of which you
     ; don't really control as it depends on who sent you money), and the value being sent somewhere else.  The
     ; change address should be selected from this wallet, normally.  <b>If null this will be chosen for you.</b>
     ;;
    #_public
    (ยง field #_"Address" :change-address nil)

    ;;;
     ; <p>A transaction can have a fee attached, which is defined as the difference between the input values
     ; and output values.  Any value taken in that is not provided to an output can be claimed by a miner.  This
     ; is how mining is incentivized in later years of the Bitcoin system when inflation drops.  It also provides
     ; a way for people to prioritize their transactions over others and is used as a way to make denial of service
     ; attacks expensive.</p>
     ;
     ; <p>This is a dynamic fee (in satoshis) which will be added to the transaction for each kilobyte in size
     ; including the first.  This is useful as as miners usually sort pending transactions by their fee per unit size
     ; when choosing which transactions to add to a block.  Note that, to keep this equivalent to Bitcoin Core
     ; definition, a kilobyte is defined as 1000 bytes, not 1024.</p>
     ;;
    #_public
    (ยง field #_"Coin" :fee-per-kb (.. (Context/get) (getFeePerKb)))

    ;;;
     ; <p>Requires that there be enough fee for a default Bitcoin Core to at least relay the transaction.
     ; (i.e. ensure the transaction will not be outright rejected by the network).  Defaults to true,
     ; you should only set this to false if you know what you're doing.</p>
     ;
     ; <p>Note that this does not enforce certain fee rules that only apply to transactions which are larger
     ; than 26,000 bytes.  If you get a transaction which is that large, you should set a feePerKb of at least
     ; {@link Transaction#REFERENCE_DEFAULT_MIN_TX_FEE}.</p>
     ;;
    #_public
    (ยง field #_"boolean" :ensure-min-required-fee (.. (Context/get) (isEnsureMinRequiredFee)))

    ;;;
     ; If true (the default), the inputs will be signed.
     ;;
    #_public
    (ยง field #_"boolean" :sign-inputs true)

    ;;;
     ; The AES key to use to decrypt the private keys before signing.
     ; If null then no decryption will be performed and if decryption is required an exception will be thrown.
     ; You can get this from a password by doing wallet.getKeyCrypter().deriveKey(password).
     ;;
    #_public
    (ยง field #_"KeyParameter" :aes-key nil)

    ;;;
     ; If not null, the {@link org.bitcoinj.wallet.CoinSelector} to use instead of the wallets default.
     ; Coin selectors are responsible for choosing which transaction outputs (coins) in a wallet to use given
     ; the desired send value amount.
     ;;
    #_public
    (ยง field #_"CoinSelector" :coin-selector nil)

    ;;;
     ; If true (the default), the outputs will be shuffled during completion to randomize the location
     ; of the change output, if any.  This is normally what you want for privacy reasons but in unit tests
     ; it can be annoying, so it can be disabled here.
     ;;
    #_public
    (ยง field #_"boolean" :shuffle-outputs true)

    ;;;
     ; Specifies what to do with missing signatures left after completing this request.  Default strategy is
     ; to throw an exception on missing signature ({@link MissingSigsMode#THROW}).
     ; @see MissingSigsMode
     ;;
    #_public
    (ยง field #_"Wallet.MissingSigsMode" :missing-sigs-mode Wallet.MissingSigsMode/THROW)

    ;;;
     ; If not null, this exchange rate is recorded with the transaction during completion.
     ;;
    #_public
    (ยง field #_"ExchangeRate" :exchange-rate nil)

    ;;;
     ; If not null, this memo is recorded with the transaction during completion.  It can be used to record
     ; the memo of the payment request that initiated the transaction.
     ;;
    #_public
    (ยง field #_"String" :memo nil)

    ;;;
     ; If false (default value), tx fee is paid by the sender.  If true, tx fee is paid by the recipient/s.
     ; If there is more than one recipient, the tx fee is split equally between them regardless of output
     ; value and size.
     ;;
    #_public
    (ยง field #_"boolean" :recipients-pay-fees false)

    ;; Tracks if this has been passed to wallet.completeTx already: just a safety check.
    (ยง field #_"boolean" :completed)

    #_private
    (ยง constructor- #_"SendRequest" []
        this
    )

    ;;;
     ; <p>Creates a new SendRequest to the given address for the given value.</p>
     ;
     ; <p>Be very careful when value is smaller than {@link Transaction#MIN_NONDUST_OUTPUT} as the transaction
     ; will likely be rejected by the network in this case.</p>
     ;;
    #_public
    #_static
    (ยง defn #_"SendRequest" SendRequest/to [#_"Address" __destination, #_"Coin" __value]
        (let [#_"SendRequest" __req (SendRequest.)
              #_"NetworkParameters" __parameters (.. __destination (getParameters))]

            (Preconditions/checkNotNull __parameters, "Address is for an unknown network")

            (ยง assoc __req :tx (Transaction. __parameters))
            (.. (:tx __req) (addOutput __value, __destination))
            __req
        )
    )

    ;;;
     ; <p>Creates a new SendRequest to the given pubkey for the given value.</p>
     ;
     ; <p>Be careful to check the output's value is reasonable using
     ; {@link TransactionOutput#getMinNonDustValue(Coin)} afterwards or you risk having the transaction
     ; rejected by the network.  Note that using {@link SendRequest#to(Address, Coin)} will result
     ; in a smaller output, and thus the ability to use a smaller output value without rejection.</p>
     ;;
    #_public
    #_static
    (ยง defn #_"SendRequest" SendRequest/to [#_"NetworkParameters" __params, #_"ECKey" __destination, #_"Coin" __value]
        (let [#_"SendRequest" __req (SendRequest.)]
            (ยง assoc __req :tx (Transaction. __params))
            (.. (:tx __req) (addOutput __value, __destination))
            __req
        )
    )

    ;;; Simply wraps a pre-built incomplete transaction provided by you. ;;
    #_public
    #_static
    (ยง defn #_"SendRequest" SendRequest/forTx [#_"Transaction" __tx]
        (let [#_"SendRequest" __req (SendRequest.)]
            (ยง assoc __req :tx __tx)
            __req
        )
    )

    #_public
    #_static
    (ยง defn #_"SendRequest" SendRequest/emptyWallet [#_"Address" __destination]
        (let [#_"SendRequest" __req (SendRequest.)
              #_"NetworkParameters" __parameters (.. __destination (getParameters))]

            (Preconditions/checkNotNull __parameters, "Address is for an unknown network")

            (ยง assoc __req :tx (Transaction. __parameters))
            (.. (:tx __req) (addOutput Coin/ZERO, __destination))
            (ยง assoc __req :empty-wallet true)
            __req
        )
    )

    ;;;
     ; Construct a SendRequest for a CPFP (child-pays-for-parent) transaction.  The resulting transaction is
     ; already completed, so you should directly proceed to signing and broadcasting/committing the transaction.
     ; CPFP is currently only supported by a few miners, so use with care.
     ;;
    #_public
    #_static
    (ยง defn #_"SendRequest" SendRequest/childPaysForParent [#_"Wallet" __wallet, #_"Transaction" __parentTransaction, #_"Coin" __feeRaise]
        (let [#_"TransactionOutput" __outputToSpend nil]
            (doseq [#_"TransactionOutput" __output (.. __parentTransaction (getOutputs))]
                (when (and (.. __output (isMine __wallet)) (.. __output (isAvailableForSpending)) (.. __output (getValue) (isGreaterThan __feeRaise)))
                    (ยง ass __outputToSpend __output)
                    (ยง break )
                )
            )
            ;; TODO: Spend another confirmed output of own wallet if needed.
            (Preconditions/checkNotNull __outputToSpend, "Can't find adequately sized output that spends to us")

            (let [#_"Transaction" __tx (Transaction. (.. __parentTransaction (getParams)))]
                (.. __tx (addInput __outputToSpend))
                (.. __tx (addOutput (.. __outputToSpend (getValue) (subtract __feeRaise)), (.. __wallet (freshAddress KeyChain.KeyPurpose/CHANGE))))
                (.. __tx (setPurpose Transaction.Purpose/RAISE_FEE))
                (let [#_"SendRequest" __req (SendRequest/forTx __tx)]
                    (ยง assoc __req :completed true)
                    __req
                )
            )
        )
    )

    #_public
    #_static
    (ยง defn #_"SendRequest" SendRequest/toCLTVPaymentChannel [#_"NetworkParameters" __params, #_"Date" __releaseTime, #_"ECKey" __from, #_"ECKey" __to, #_"Coin" __value]
        (let [#_"long" __time (/ (.. __releaseTime (getTime)) 1000)]

            (Preconditions/checkArgument (<= Transaction/LOCKTIME_THRESHOLD __time), "Release time was too small")

            (SendRequest/toCLTVPaymentChannel __params, (BigInteger/valueOf __time), __from, __to, __value)
        )
    )

    #_public
    #_static
    (ยง defn #_"SendRequest" SendRequest/toCLTVPaymentChannel [#_"NetworkParameters" __params, #_"int" __releaseBlock, #_"ECKey" __from, #_"ECKey" __to, #_"Coin" __value]
        (Preconditions/checkArgument (< -1 __releaseBlock Transaction/LOCKTIME_THRESHOLD), "Block number was too large")

        (SendRequest/toCLTVPaymentChannel __params, (BigInteger/valueOf __releaseBlock), __from, __to, __value)
    )

    #_public
    #_static
    (ยง defn #_"SendRequest" SendRequest/toCLTVPaymentChannel [#_"NetworkParameters" __params, #_"BigInteger" __time, #_"ECKey" __from, #_"ECKey" __to, #_"Coin" __value]
        (let [#_"SendRequest" __req (SendRequest.)
              #_"Script" __output (ScriptBuilder/createCLTVPaymentChannelOutput __time, __from, __to)]
            (ยง assoc __req :tx (Transaction. __params))
            (.. (:tx __req) (addOutput __value, __output))
            __req
        )
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        ;; Print only the user-settable fields.
        (let [#_"MoreObjects.ToStringHelper" __helper (.. (MoreObjects/toStringHelper this) (omitNullValues))]
            (.. __helper (add "emptyWallet", (:empty-wallet this)))
            (.. __helper (add "changeAddress", (:change-address this)))
            (.. __helper (add "feePerKb", (:fee-per-kb this)))
            (.. __helper (add "ensureMinRequiredFee", (:ensure-min-required-fee this)))
            (.. __helper (add "signInputs", (:sign-inputs this)))
            (.. __helper (add "aesKey", (when (some? (:aes-key this)) "set"))) ;; Careful to not leak the key.
            (.. __helper (add "coinSelector", (:coin-selector this)))
            (.. __helper (add "shuffleOutputs", (:shuffle-outputs this)))
            (.. __helper (add "recipientsPayFees", (:recipients-pay-fees this)))
            (.. __helper (toString))
        )
    )
)

;;;
 ; Thrown by the {@link WalletProtobufSerializer} when the serialized protocol buffer is either corrupted,
 ; internally inconsistent or appears to be from the future.
 ;;
#_public
(ยง class UnreadableWalletException (ยง extends Exception)
    #_public
    (ยง constructor UnreadableWalletException [#_"String" __s]
        (ยง super __s)
        this
    )

    #_public
    (ยง constructor UnreadableWalletException [#_"String" __s, #_"Throwable" __t]
        (ยง super __s, __t)
        this
    )

    #_public
    #_static
    (ยง class UnreadableWalletException.BadPassword (ยง extends UnreadableWalletException)
        #_public
        (ยง constructor UnreadableWalletException.BadPassword []
            (ยง super "Password incorrect")
            this
        )
    )

    #_public
    #_static
    (ยง class UnreadableWalletException.FutureVersion (ยง extends UnreadableWalletException)
        #_public
        (ยง constructor UnreadableWalletException.FutureVersion []
            (ยง super "Unknown wallet version from the future.")
            this
        )
    )

    #_public
    #_static
    (ยง class UnreadableWalletException.WrongNetwork (ยง extends UnreadableWalletException)
        #_public
        (ยง constructor UnreadableWalletException.WrongNetwork []
            (ยง super "Mismatched network ID")
            this
        )
    )
)

;; To do list:
;;
;; - Take all wallet-relevant data out of Transaction and put it into WalletTransaction.  Make Transaction immutable.
;; - Only store relevant transaction outputs, don't bother storing the rest of the data.  Big RAM saving.
;; - Split block chain and tx output tracking into a superclass that doesn't have any key or spending related code.
;; - Simplify how transactions are tracked and stored: in particular, have the wallet maintain positioning information
;;   for transactions independent of the transactions themselves, so the timeline can be walked without having to
;;   process and sort every single transaction.
;; - Split data persistence out into a backend class and make the wallet transactional, so we can store a wallet
;;   in a database not just in RAM.
;; - Make clearing of transactions able to only rewind the wallet a certain distance instead of all blocks.
;; - Make it scale:
;;     - eliminate all the algorithms with quadratic complexity (or worse).
;;     - don't require everything to be held in RAM at once.
;;     - consider allowing eviction of no longer re-orgable transactions or keys that were used up.
;;
;; Finally, find more ways to break the class up and decompose it.  Currently every time we move code out, other code
;; fills up the lines saved!

;;;
 ; <p>A Wallet stores keys and a record of transactions that send and receive value from those keys.  Using these,
 ; it is able to create new transactions that spend the recorded transactions, and this is the fundamental operation
 ; of the Bitcoin protocol.</p>
 ;
 ; <p>To learn more about this class, read <b><a href="https://bitcoinj.github.io/working-with-the-wallet">working with the wallet.</a></b></p>
 ;
 ; <p>To fill up a Wallet with transactions, you need to use it in combination with a {@link BlockChain} and various
 ; other objects, see the <a href="https://bitcoinj.github.io/getting-started">Getting started</a> tutorial
 ; on the website to learn more about how to set everything up.</p>
 ;
 ; <p>Wallets can be serialized using protocol buffers.  You need to save the wallet whenever it changes, there is an
 ; auto-save feature that simplifies this for you although you're still responsible for manually triggering a save when
 ; your app is about to quit because the auto-save feature waits a moment before actually committing to disk to avoid IO
 ; thrashing when the wallet is changing very fast (e.g. due to a block chain sync).  See
 ; {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, org.bitcoinj.wallet.WalletFiles.Listener)}
 ; for more information about this.</p>
 ;;
#_public
(ยง class Wallet (ยง implements NewBestBlockListener, TransactionReceivedInBlockListener, PeerFilterProvider, KeyBag, TransactionBag, ReorganizeListener)
    #_private
    #_static
    (ยง def- #_"Logger" Wallet/log (LoggerFactory/getLogger Wallet))
    #_private
    #_static
    (ยง def- #_"int" Wallet/MINIMUM_BLOOM_DATA_LENGTH 8)

    ;; Ordering: lock > keyChainGroupLock.  KeyChainGroup is protected separately to allow fast querying of current receive
    ;; address even if the wallet itself is busy e.g. saving or processing a big reorg.  Useful for reducing UI latency.
    #_protected
    (ยง field #_"ReentrantLock" :lock (Threading/lock "wallet"))
    #_protected
    (ยง field #_"ReentrantLock" :key-chain-group-lock (Threading/lock "wallet-keychaingroup"))

    ;; The various pools below give quick access to wallet-relevant transactions by the state they're in:
    ;;
    ;; Pending:  Transactions that didn't make it into the best chain yet.  Pending transactions can be killed if a
    ;;           double spend against them appears in the best chain, in which case they move to the dead pool.
    ;;           If a double spend appears in the pending state as well, we update the confidence type
    ;;           of all txns in conflict to IN_CONFLICT and wait for the miners to resolve the race.
    ;; Unspent:  Transactions that appeared in the best chain and have outputs we can spend.  Note that we store the
    ;;           entire transaction in memory even though for spending purposes we only really need the outputs, the
    ;;           reason being that this simplifies handling of re-orgs.  It would be worth fixing this in future.
    ;; Spent:    Transactions that appeared in the best chain but don't have any spendable outputs.  They're stored
    ;;           here for history browsing/auditing reasons only and in future will probably be flushed out to some
    ;;           other kind of cold storage or just removed.
    ;; Dead:     Transactions that we believe will never confirm get moved here, out of pending.  Note that Bitcoin
    ;;           Core has no notion of dead-ness: the assumption is that double spends won't happen so there's no
    ;;           need to notify the user about them.  We take a more pessimistic approach and try to track the fact
    ;;           that transactions have been double spent so applications can do something intelligent (cancel orders,
    ;;           show to the user in the UI, etc).  A transaction can leave dead and move into spent/unspent if there
    ;;           is a re-org to a chain that doesn't include the double spend.

    #_private
    (ยง field- #_"Map<Sha256Hash, Transaction>" :pending)
    #_private
    (ยง field- #_"Map<Sha256Hash, Transaction>" :unspent)
    #_private
    (ยง field- #_"Map<Sha256Hash, Transaction>" :spent)
    #_private
    (ยง field- #_"Map<Sha256Hash, Transaction>" :dead)

    ;; All transactions together.
    #_protected
    (ยง field #_"Map<Sha256Hash, Transaction>" :transactions)

    ;; All the TransactionOutput objects that we could spend (ignoring whether we have the private key or not).
    ;; Used to speed up various calculations.
    #_protected
    (ยง field #_"HashSet<TransactionOutput>" :my-unspents (Sets/newHashSet))

    ;; Transactions that were dropped by the risk analysis system.  These are not in any pools and not serialized
    ;; to disk.  We have to keep them around because if we ignore a tx because we think it will never confirm, but
    ;; then it actually does confirm and does so within the same network session, remote peers will not resend us
    ;; the tx data along with the Bloom filtered block, as they know we already received it once before
    ;; (so it would be wasteful to repeat).  Thus we keep them around here for a while.  If we drop our network
    ;; connections then the remote peers will forget that we were sent the tx data previously and send it again
    ;; when relaying a filtered merkleblock.
    #_private
    (ยง field- #_"LinkedHashMap<Sha256Hash, Transaction>" :risk-dropped (LinkedHashMap. #_"<Sha256Hash, Transaction>"
        (ยง anon
            #_override
            #_protected
            (ยง method #_"boolean" removeEldestEntry [#_"Map.Entry<Sha256Hash, Transaction>" __eldest]
                (< 1000 (.. this (size)))
            )
        )))

    ;; The key chain group is not thread safe, and generally the whole hierarchy of objects should not be mutated
    ;; outside the wallet lock.  So don't expose this object directly via any accessors!
    #_private
    (ยง field- #_"KeyChainGroup" :key-chain-group)

    #_protected
    (ยง field #_"Context" :context)
    #_protected
    (ยง field #_"NetworkParameters" :params)

    #_nilable
    #_private
    (ยง field- #_"Sha256Hash" :last-block-seen-hash)
    #_private
    (ยง field- #_"int" :last-block-seen-height)
    #_private
    (ยง field- #_"long" :last-block-seen-time-secs)

    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<WalletChangeEventListener>>" :change-listeners (CopyOnWriteArrayList. #_"<>"))
    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<WalletCoinsReceivedEventListener>>" :coins-received-listeners (CopyOnWriteArrayList. #_"<>"))
    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<WalletCoinsSentEventListener>>" :coins-sent-listeners (CopyOnWriteArrayList. #_"<>"))
    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<WalletReorganizeEventListener>>" :reorganize-listeners (CopyOnWriteArrayList. #_"<>"))
    #_private
    (ยง field- #_"CopyOnWriteArrayList<ListenerRegistration<TransactionConfidenceEventListener>>" :transaction-confidence-listeners (CopyOnWriteArrayList. #_"<>"))

    ;; A listener that relays confidence changes from the transaction confidence object to the wallet event listener,
    ;; as a convenience to API users so they don't have to register on every transaction themselves.
    #_private
    (ยง field- #_"TransactionConfidence.Listener" :tx-confidence-listener)

    ;; If a TX hash appears in this set then notifyNewBestBlock will ignore it, as its confidence was already set up
    ;; in receive() via Transaction.setBlockAppearance().  As the BlockChain always calls notifyNewBestBlock even if
    ;; it sent transactions to the wallet, without this we'd double count.
    #_private
    (ยง field- #_"HashSet<Sha256Hash>" :ignore-next-new-block)
    ;; Whether or not to ignore pending transactions that are considered risky by the configured risk analyzer.
    #_private
    (ยง field- #_"boolean" :accept-risky-transactions)
    ;; Object that performs risk analysis of pending transactions.  We might reject transactions that seem like
    ;; a high risk of being a double spending attack.
    #_private
    (ยง field- #_"RiskAnalysis.Analyzer" :risk-analyzer DefaultRiskAnalysis/FACTORY)

    ;; Stuff for notifying transaction objects that we changed their confidences.  The purpose of this is to avoid
    ;; spuriously sending lots of repeated notifications to listeners that API users aren't really interested in as
    ;; a side effect of how the code is written (e.g. during re-orgs confidence data gets adjusted multiple times).
    #_private
    (ยง field- #_"int" :on-wallet-changed-suppressions)
    #_private
    (ยง field- #_"boolean" :inside-reorg)
    #_private
    (ยง field- #_"Map<Transaction, TransactionConfidence.Listener.ChangeReason>" :confidence-changed)
    #_protected
    #_volatile
    (ยง field #_"WalletFiles" :v-file-manager)
    ;; Object that is used to send transactions asynchronously when the wallet requires it.
    #_protected
    #_volatile
    (ยง field #_"TransactionBroadcaster" :v-transaction-broadcaster)
    ;; UNIX time in seconds.  Money controlled by keys created before this time will be automatically respent to
    ;; a key that was created after it.  Useful when you believe some keys have been compromised.
    #_private
    #_volatile
    (ยง field- #_"long" :v-key-rotation-timestamp)

    #_protected
    (ยง field #_"CoinSelector" :coin-selector (DefaultCoinSelector.))

    ;; The wallet version.  This is an int that can be used to track breaking changes in the wallet format.
    ;; You can also use it to detect wallets that come from the future (i.e. they contain features you
    ;; do not know how to deal with).
    #_private
    (ยง field- #_"int" :version)
    ;; User-provided description that may help people keep track of what a wallet is for.
    #_private
    (ยง field- #_"String" :description)

    ;; Objects that perform transaction signing.  Applied subsequently one after another.
    #_private
    (ยง field- #_"List<TransactionSigner>" :signers)

    ;;;
     ; Creates a new, empty wallet with a randomly chosen seed and no transactions.  Make sure to provide for
     ; sufficient backup!  Any keys will be derived from the seed.  If you want to restore a wallet from disk
     ; instead, see {@link #loadFromFile}.
     ;;
    #_public
    (ยง constructor Wallet [#_"NetworkParameters" __params]
        (ยง this (Context/getOrCreate __params))
        this
    )

    ;;;
     ; Creates a new, empty wallet with a randomly chosen seed and no transactions.  Make sure to provide for
     ; sufficient backup!  Any keys will be derived from the seed.  If you want to restore a wallet from disk
     ; instead, see {@link #loadFromFile}.
     ;;
    #_public
    (ยง constructor Wallet [#_"Context" __context]
        (ยง this __context, (KeyChainGroup. (.. __context (getParams))))
        this
    )

    #_public
    #_static
    (ยง defn #_"Wallet" Wallet/fromSeed [#_"NetworkParameters" __params, #_"DeterministicSeed" __seed]
        (Wallet. __params, (KeyChainGroup. __params, __seed))
    )

    ;;;
     ; Creates a wallet that tracks payments to and from the HD key hierarchy rooted by the given watching key.
     ; A watching key corresponds to account zero in the recommended BIP32 key hierarchy.
     ;;
    #_public
    #_static
    (ยง defn #_"Wallet" Wallet/fromWatchingKey [#_"NetworkParameters" __params, #_"DeterministicKey" __watchKey]
        (Wallet. __params, (KeyChainGroup. __params, __watchKey))
    )

    ;;;
     ; Creates a wallet that tracks payments to and from the HD key hierarchy rooted by the given watching key.
     ; A watching key corresponds to account zero in the recommended BIP32 key hierarchy.  The key is specified
     ; in base58 notation and the creation time of the key.  If you don't know the creation time, you can pass
     ; {@link DeterministicHierarchy#BIP32_STANDARDISATION_TIME_SECS}.
     ;;
    #_public
    #_static
    (ยง defn #_"Wallet" Wallet/fromWatchingKeyB58 [#_"NetworkParameters" __params, #_"String" __watchKeyB58, #_"long" __creationTimeSeconds]
        (let [#_"DeterministicKey" __watchKey (DeterministicKey/deserializeB58 nil, __watchKeyB58, __params)]
            (.. __watchKey (setCreationTimeSeconds __creationTimeSeconds))
            (Wallet/fromWatchingKey __params, __watchKey)
        )
    )

    ;;;
     ; Creates a wallet containing a given set of keys.  All further keys will be derived from the oldest key.
     ;;
    #_public
    #_static
    (ยง defn #_"Wallet" Wallet/fromKeys [#_"NetworkParameters" __params, #_"List<ECKey>" __keys]
        (doseq [#_"ECKey" __key __keys]
            (Preconditions/checkArgument (not (instance? DeterministicKey __key)))
        )

        (let [#_"KeyChainGroup" __group (KeyChainGroup. __params)]
            (.. __group (importKeys __keys))
            (Wallet. __params, __group)
        )
    )

    #_public
    (ยง constructor Wallet [#_"NetworkParameters" __params, #_"KeyChainGroup" __keyChainGroup]
        (ยง this (Context/getOrCreate __params), __keyChainGroup)
        this
    )

    #_private
    (ยง constructor- #_"Wallet" [#_"Context" __context, #_"KeyChainGroup" __keyChainGroup]
        (ยง assoc this :context __context)
        (ยง assoc this :params (.. __context (getParams)))
        (ยง assoc this :key-chain-group (Preconditions/checkNotNull __keyChainGroup))
        (when (.. (:params this) (getId) (equals NetworkParameters/ID_UNITTESTNET))
            (.. (:key-chain-group this) (setLookaheadSize 5)) ;; Cut down excess computation for unit tests.
        )
        ;; If this keyChainGroup was created fresh just now (new wallet), make HD so a backup can be made immediately
        ;; without having to call current/freshReceiveKey.  If there are already keys in the chain of any kind then
        ;; we're probably being deserialized so leave things alone: the API user can upgrade later.
        (when (== (.. (:key-chain-group this) (numKeys)) 0)
            (.. (:key-chain-group this) (createAndActivateNewHDChain))
        )
        (ยง assoc this :unspent (HashMap. #_"<>"))
        (ยง assoc this :spent (HashMap. #_"<>"))
        (ยง assoc this :pending (HashMap. #_"<>"))
        (ยง assoc this :dead (HashMap. #_"<>"))
        (ยง assoc this :transactions (HashMap. #_"<>"))
        ;; Use a linked hash map to ensure ordering of event listeners is correct.
        (ยง assoc this :confidence-changed (LinkedHashMap. #_"<>"))
        (ยง assoc this :signers (ArrayList. #_"<>"))
        (.. this (addTransactionSigner (LocalTransactionSigner.)))
        (.. this (createTransientState))
        this
    )

    #_private
    (ยง method- #_"void" createTransientState []
        (ยง assoc this :ignore-next-new-block (HashSet. #_"<>"))
        (ยง assoc this :tx-confidence-listener (TransactionConfidence.Listener.
        (ยง anon
            #_override
            #_public
            (ยง method #_"void" onConfidenceChanged [#_"TransactionConfidence" __confidence, #_"TransactionConfidence.Listener.ChangeReason" __reason]
                ;; This will run on the user code thread so we shouldn't do anything too complicated here.
                ;; We only want to queue a wallet changed event and auto-save if the number of peers announcing
                ;; the transaction has changed, as that confidence change is made by the networking code which
                ;; doesn't necessarily know at that point which wallets contain which transactions, so it's up
                ;; to us to listen for that.  Other types of confidence changes (type, etc.) are triggered by us,
                ;; so we'll queue up a wallet change event in other parts of the code.
                (when (== __reason TransactionConfidence.Listener.ChangeReason/SEEN_PEERS)
                    (.. (:lock this) (lock))
                    (try
                        (.. this (checkBalanceFuturesLocked nil))
                        (let [#_"Transaction" __tx (.. this (getTransaction (.. __confidence (getTransactionHash))))]
                            (.. this (queueOnTransactionConfidenceChanged __tx))
                            (.. this (maybeQueueOnWalletChanged))
                        )
                        (finally
                            (.. (:lock this) (unlock))
                        )
                    )
                )
                nil
            )
        )))
        (ยง assoc this :accept-risky-transactions false)
        nil
    )

    #_public
    (ยง method #_"NetworkParameters" getNetworkParameters []
        (:params this)
    )

    ;;;
     ; Gets the active keychain via {@link KeyChainGroup#getActiveKeyChain()}.
     ;;
    #_public
    (ยง method #_"DeterministicKeyChain" getActiveKeyChain []
        (.. (:key-chain-group this) (getActiveKeyChain))
    )

    ;;;
     ; <p>Adds given transaction signer to the list of signers.  It will be added to the end of the signers list,
     ; so if this wallet already has some signers added, given signer will be executed after all of them.</p>
     ; <p>Transaction signer should be fully initialized before adding to the wallet, otherwise
     ; {@link IllegalStateException} will be thrown</p>
     ;;
    #_public
    (ยง method #_"void" addTransactionSigner [#_"TransactionSigner" __signer]
        (.. (:lock this) (lock))
        (try
            (if (.. __signer (isReady))
                (.. (:signers this) (add __signer))
                (throw (IllegalStateException. (str "Signer instance is not ready to be added into Wallet: " (.. __signer (getClass)))))
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    #_public
    (ยง method #_"List<TransactionSigner>" getTransactionSigners []
        (.. (:lock this) (lock))
        (try
            (ImmutableList/copyOf (:signers this))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns a key that hasn't been seen in a transaction yet, and which is suitable for displaying
     ; in a wallet user interface as "a convenient key to receive funds on" when the purpose parameter
     ; is {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS}.  The returned key is stable
     ; until it's actually seen in a pending or confirmed transaction, at which point this method will
     ; start returning a different key (for each purpose independently).
     ;;
    #_public
    (ยง method #_"DeterministicKey" currentKey [#_"KeyChain.KeyPurpose" __purpose]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. this (maybeUpgradeToHD))
            (.. (:key-chain-group this) (currentKey __purpose))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;;
     ; An alias for calling {@link #currentKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
    #_public
    (ยง method #_"DeterministicKey" currentReceiveKey []
        (.. this (currentKey KeyChain.KeyPurpose/RECEIVE_FUNDS))
    )

    ;;;
     ; Returns address for a {@link #currentKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)}.
     ;;
    #_public
    (ยง method #_"Address" currentAddress [#_"KeyChain.KeyPurpose" __purpose]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. this (maybeUpgradeToHD))
            (.. (:key-chain-group this) (currentAddress __purpose))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;;
     ; An alias for calling {@link #currentAddress(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
    #_public
    (ยง method #_"Address" currentReceiveAddress []
        (.. this (currentAddress KeyChain.KeyPurpose/RECEIVE_FUNDS))
    )

    ;;;
     ; Returns a key that has not been returned by this method before (fresh).  You can think of this
     ; as being a newly created key, although the notion of "create" is not really valid for a
     ; {@link org.bitcoinj.wallet.DeterministicKeyChain}.  When the parameter is
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} the returned key is suitable for
     ; being put into a receive coins wizard type UI.  You should use this when the user is definitely
     ; going to hand this key out to someone who wishes to send money.
     ;;
    #_public
    (ยง method #_"DeterministicKey" freshKey [#_"KeyChain.KeyPurpose" __purpose]
        (.. this (freshKeys __purpose, 1) (get 0))
    )

    ;;;
     ; Returns a key/s that has not been returned by this method before (fresh).  You can think of this
     ; as being a newly created key/s, although the notion of "create" is not really valid for a
     ; {@link org.bitcoinj.wallet.DeterministicKeyChain}.  When the parameter is
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} the returned key is suitable for
     ; being put into a receive coins wizard type UI. You should use this when the user is definitely
     ; going to hand this key/s out to someone who wishes to send money.
     ;;
    #_public
    (ยง method #_"List<DeterministicKey>" freshKeys [#_"KeyChain.KeyPurpose" __purpose, #_"int" __numberOfKeys]
        (let [#_"List<DeterministicKey>" __keys]
            (.. (:key-chain-group-lock this) (lock))
            (try
                (.. this (maybeUpgradeToHD))
                (ยง ass __keys (.. (:key-chain-group this) (freshKeys __purpose, __numberOfKeys)))
                (finally
                    (.. (:key-chain-group-lock this) (unlock))
                )
            )
            ;; Do we really need an immediate hard save?  Arguably all this is doing is saving the 'current' key
            ;; and that's not quite so important, so we could coalesce for more performance.
            (.. this (saveNow))
            __keys
        )
    )

    ;;;
     ; An alias for calling {@link #freshKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
    #_public
    (ยง method #_"DeterministicKey" freshReceiveKey []
        (.. this (freshKey KeyChain.KeyPurpose/RECEIVE_FUNDS))
    )

    ;;;
     ; Returns address for a {@link #freshKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)}.
     ;;
    #_public
    (ยง method #_"Address" freshAddress [#_"KeyChain.KeyPurpose" __purpose]
        (let [#_"Address" __key]
            (.. (:key-chain-group-lock this) (lock))
            (try
                (ยง ass __key (.. (:key-chain-group this) (freshAddress __purpose)))
                (finally
                    (.. (:key-chain-group-lock this) (unlock))
                )
            )
            (.. this (saveNow))
            __key
        )
    )

    ;;;
     ; An alias for calling {@link #freshAddress(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
    #_public
    (ยง method #_"Address" freshReceiveAddress []
        (.. this (freshAddress KeyChain.KeyPurpose/RECEIVE_FUNDS))
    )

    ;;;
     ; Returns only the keys that have been issued by {@link #freshReceiveKey()}, {@link #freshReceiveAddress()},
     ; {@link #currentReceiveKey()} or {@link #currentReceiveAddress()}.
     ;;
    #_public
    (ยง method #_"List<ECKey>" getIssuedReceiveKeys []
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (getActiveKeyChain) (getIssuedReceiveKeys))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns only the addresses that have been issued by {@link #freshReceiveKey()}, {@link #freshReceiveAddress()},
     ; {@link #currentReceiveKey()} or {@link #currentReceiveAddress()}.
     ;;
    #_public
    (ยง method #_"List<Address>" getIssuedReceiveAddresses []
        (let [#_"List<ECKey>" __keys (.. this (getIssuedReceiveKeys))
              #_"List<Address>" __addresses (ArrayList. #_"<>" (.. __keys (size)))]
            (doseq [#_"ECKey" __key __keys]
                (.. __addresses (add (.. __key (toAddress (.. this (getParams))))))
            )
            __addresses
        )
    )

    ;;;
     ; Upgrades the wallet to be deterministic (BIP32).  You should call this, possibly providing the users encryption
     ; key, after loading a wallet produced by previous versions of bitcoinj.  If the wallet is encrypted the key
     ; <b>must</b> be provided, due to the way the seed is derived deterministically from private key bytes: failing
     ; to do this will result in an exception being thrown.  For non-encrypted wallets, the upgrade will be done for
     ; you automatically the first time a new key is requested (this happens when spending due to the change address).
     ;;
    #_public
    #_throws #_[ "DeterministicUpgradeRequiresPassword" ]
    (ยง method #_"void" upgradeToDeterministic [#_nilable #_"KeyParameter" __aesKey]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (upgradeToDeterministic (:v-key-rotation-timestamp this), __aesKey))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Returns true if the wallet contains random keys and no HD chains, in which case you should call
     ; {@link #upgradeToDeterministic(org.spongycastle.crypto.params.KeyParameter)} before attempting
     ; to do anything that would require a new address or key.
     ;;
    #_public
    (ยง method #_"boolean" isDeterministicUpgradeRequired []
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (isDeterministicUpgradeRequired))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    #_private
    #_throws #_[ "DeterministicUpgradeRequiresPassword" ]
    (ยง method- #_"void" maybeUpgradeToHD []
        (.. this (maybeUpgradeToHD nil))
        nil
    )

    #_private
    #_throws #_[ "DeterministicUpgradeRequiresPassword" ]
    (ยง method- #_"void" maybeUpgradeToHD [#_nilable #_"KeyParameter" __aesKey]
        (Preconditions/checkState (.. (:key-chain-group-lock this) (isHeldByCurrentThread)))
        (when (.. (:key-chain-group this) (isDeterministicUpgradeRequired))
            (.. Wallet/log (info "Upgrade to HD wallets is required, attempting to do so."))
            (try
                (.. this (upgradeToDeterministic __aesKey))
                (catch DeterministicUpgradeRequiresPassword __e
                    (.. Wallet/log (error "Failed to auto upgrade due to encryption. You should call wallet.upgradeToDeterministic with the users AES key to avoid this error."))
                    (throw __e)
                )
            )
        )
        nil
    )

    ;;;
     ; Removes the given key from the basicKeyChain.  Be very careful with this - losing a private key
     ; <b>destroys the money associated with it</b>.
     ; @return whether the key was removed or not.
     ;;
    #_public
    (ยง method #_"boolean" removeKey [#_"ECKey" __key]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (removeImportedKey __key))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns the number of keys in the key chain group, including lookahead keys.
     ;;
    #_public
    (ยง method #_"int" getKeyChainGroupSize []
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (numKeys))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    #_testing
    #_public
    (ยง method #_"int" getKeyChainGroupCombinedKeyLookaheadEpochs []
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (getCombinedKeyLookaheadEpochs))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns a list of the non-deterministic keys that have been imported into the wallet, or the empty list if none.
     ;;
    #_public
    (ยง method #_"List<ECKey>" getImportedKeys []
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (getImportedKeys))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;; Returns the address used for change outputs.  Note: this will probably go away in future. ;;
    #_public
    (ยง method #_"Address" currentChangeAddress []
        (.. this (currentAddress KeyChain.KeyPurpose/CHANGE))
    )

    ;;;
     ; <p>Imports the given ECKey to the wallet.</p>
     ;
     ; <p>If the wallet is configured to auto save to a file, triggers a save immediately.  Runs the onKeysAdded event
     ; handler.  If the key already exists in the wallet, does nothing and returns false.</p>
     ;;
    #_public
    (ยง method #_"boolean" importKey [#_"ECKey" __key]
        (== (.. this (importKeys (Lists/newArrayList __key))) 1)
    )

    ;;;
     ; Imports the given keys to the wallet.
     ; If {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, org.bitcoinj.wallet.WalletFiles.Listener)}
     ; has been called, triggers an auto save bypassing the normal coalescing delay and event handlers.
     ; Returns the number of keys added, after duplicates are ignored.  The onKeyAdded event will be called
     ; for each key in the list that was not already present.
     ;;
    #_public
    (ยง method #_"int" importKeys [#_"List<ECKey>" __keys]
        ;; API usage check.
        (.. this (checkNoDeterministicKeys __keys))
        (let [#_"int" __result]
            (.. (:key-chain-group-lock this) (lock))
            (try
                (ยง ass __result (.. (:key-chain-group this) (importKeys __keys)))
                (finally
                    (.. (:key-chain-group-lock this) (unlock))
                )
            )
            (.. this (saveNow))
            __result
        )
    )

    #_private
    (ยง method- #_"void" checkNoDeterministicKeys [#_"List<ECKey>" __keys]
        ;; Watch out for someone doing wallet.importKey(wallet.freshReceiveKey()); or equivalent: we never tested this.
        (doseq [#_"ECKey" __key __keys]
            (when (instance? DeterministicKey __key)
                (throw (IllegalArgumentException. "Cannot import HD keys back into the wallet"))
            )
        )
        nil
    )

    ;;; Takes a list of keys and a password, then encrypts and imports them in one step using the current keycrypter. ;;
    #_public
    (ยง method #_"int" importKeysAndEncrypt [#_"List<ECKey>" __keys, #_"CharSequence" __password]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (Preconditions/checkNotNull (.. this (getKeyCrypter)), "Wallet is not encrypted")
            (.. this (importKeysAndEncrypt __keys, (.. this (getKeyCrypter) (deriveKey __password))))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;; Takes a list of keys and an AES key, then encrypts and imports them in one step using the current keycrypter. ;;
    #_public
    (ยง method #_"int" importKeysAndEncrypt [#_"List<ECKey>" __keys, #_"KeyParameter" __aesKey]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. this (checkNoDeterministicKeys __keys))
            (.. (:key-chain-group this) (importKeysAndEncrypt __keys, __aesKey))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;;
     ; Add a pre-configured keychain to the wallet.  Useful for setting up a complex keychain,
     ; such as for a married wallet.  For example:
     ; <pre>
     ; MarriedKeyChain chain = MarriedKeyChain.builder()
     ;     .random(SecureRandom.())
     ;     .followingKeys(followingKeys)
     ;     .threshold(2).build();
     ; wallet.addAndActivateHDChain(chain);
     ; </p>
     ;;
    #_public
    (ยง method #_"void" addAndActivateHDChain [#_"DeterministicKeyChain" __chain]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (addAndActivateHDChain __chain))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
        nil
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadSize(int)} for more info on this. ;;
    #_public
    (ยง method #_"void" setKeyChainGroupLookaheadSize [#_"int" __lookaheadSize]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (setLookaheadSize __lookaheadSize))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
        nil
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadSize(int)} for more info on this. ;;
    #_public
    (ยง method #_"int" getKeyChainGroupLookaheadSize []
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (getLookaheadSize))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadThreshold(int)} for more info on this. ;;
    #_public
    (ยง method #_"void" setKeyChainGroupLookaheadThreshold [#_"int" __num]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. this (maybeUpgradeToHD))
            (.. (:key-chain-group this) (setLookaheadThreshold __num))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
        nil
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadThreshold(int)} for more info on this. ;;
    #_public
    (ยง method #_"int" getKeyChainGroupLookaheadThreshold []
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. this (maybeUpgradeToHD))
            (.. (:key-chain-group this) (getLookaheadThreshold))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns a public-only DeterministicKey that can be used to set up a watching wallet: that is, a wallet that
     ; can import transactions from the block chain just as the normal wallet can, but which cannot spend.  Watching
     ; wallets are very useful for things like web servers that accept payments.  This key corresponds to the account
     ; zero key in the recommended BIP32 hierarchy.
     ;;
    #_public
    (ยง method #_"DeterministicKey" getWatchingKey []
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. this (maybeUpgradeToHD))
            (.. (:key-chain-group this) (getActiveKeyChain) (getWatchingKey))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns whether this wallet consists entirely of watching keys (unencrypted keys with no private part).
     ; Mixed wallets are forbidden.
     ;
     ; @throws IllegalStateException if there are no keys, or if there is a mix between watching and non-watching keys.
     ;;
    #_public
    (ยง method #_"boolean" isWatching []
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. this (maybeUpgradeToHD))
            (.. (:key-chain-group this) (isWatching))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;;
     ; Locates a keypair from the basicKeyChain given the hash of the public key.  This is needed when finding out
     ; which key we need to use to redeem a transaction output.
     ;
     ; @return ECKey object or null if no such key was found.
     ;;
    #_override
    #_nilable
    #_public
    (ยง method #_"ECKey" findKeyFromPubHash [#_"byte[]" __pubkeyHash]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (findKeyFromPubHash __pubkeyHash))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;; Returns true if the given key is in the wallet, false otherwise.  Currently an O(N) operation. ;;
    #_public
    (ยง method #_"boolean" hasKey [#_"ECKey" __key]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (hasKey __key))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (ยง method #_"boolean" isPubKeyHashMine [#_"byte[]" __pubkeyHash]
        (some? (.. this (findKeyFromPubHash __pubkeyHash)))
    )

    ;;;
     ; Locates a keypair from the basicKeyChain given the raw public key bytes.
     ; @return ECKey or null if no such key was found.
     ;;
    #_override
    #_nilable
    #_public
    (ยง method #_"ECKey" findKeyFromPubKey [#_"byte[]" __pubkey]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (findKeyFromPubKey __pubkey))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (ยง method #_"boolean" isPubKeyMine [#_"byte[]" __pubkey]
        (some? (.. this (findKeyFromPubKey __pubkey)))
    )

    ;;;
     ; Locates a redeem data (redeem script and keys) from the keyChainGroup given the hash of the script.
     ; @return RedeemData object or null if no such data was found.
     ;;
    #_nilable
    #_override
    #_public
    (ยง method #_"RedeemData" findRedeemDataFromScriptHash [#_"byte[]" __payToScriptHash]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (findRedeemDataFromScriptHash __payToScriptHash))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (ยง method #_"boolean" isPayToScriptHashMine [#_"byte[]" __payToScriptHash]
        (some? (.. this (findRedeemDataFromScriptHash __payToScriptHash)))
    )

    ;;;
     ; Marks all keys used in the transaction output as used in the wallet.
     ; See {@link org.bitcoinj.wallet.DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_private
    (ยง method- #_"void" markKeysAsUsed [#_"Transaction" __tx]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (doseq [#_"TransactionOutput" __o (.. __tx (getOutputs))]
                (try
                    (let [#_"Script" __script (.. __o (getScriptPubKey))]
                        (cond (.. __script (isSentToRawPubKey))
                            (do
                                (let [#_"byte[]" __pubkey (.. __script (getPubKey))]
                                    (.. (:key-chain-group this) (markPubKeyAsUsed __pubkey))
                                )
                            )
                            (.. __script (isSentToAddress))
                            (do
                                (let [#_"byte[]" __pubkeyHash (.. __script (getPubKeyHash))]
                                    (.. (:key-chain-group this) (markPubKeyHashAsUsed __pubkeyHash))
                                )
                            )
                            (.. __script (isPayToScriptHash))
                            (do
                                (let [#_"Address" __a (Address/fromP2SHScript (.. __tx (getParams)), __script)]
                                    (.. (:key-chain-group this) (markP2SHAddressAsUsed __a))
                                )
                            )
                        )
                    )
                    (catch ScriptException __e
                        ;; Just means we didn't understand the output of this transaction: ignore it.
                        (.. Wallet/log (warn "Could not parse tx output script: {}", (.. __e (toString))))
                    )
                )
            )
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Returns the immutable seed for the current active HD chain.
     ; @throws org.bitcoinj.core.ECKey.MissingPrivateKeyException if the seed is unavailable (watching wallet).
     ;;
    #_public
    (ยง method #_"DeterministicSeed" getKeyChainSeed []
        (.. (:key-chain-group-lock this) (lock))
        (try
            (let [#_"DeterministicSeed" __seed (.. (:key-chain-group this) (getActiveKeyChain) (getSeed))]
                (when (nil? __seed)
                    (throw (ECKey.MissingPrivateKeyException.))
                )
                (ยง return __seed)
            )
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns a key for the given HD path, assuming it's already been derived.  You normally shouldn't use this:
     ; use currentReceiveKey/freshReceiveKey instead.
     ;;
    #_public
    (ยง method #_"DeterministicKey" getKeyByPath [#_"List<ChildNumber>" __path]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. this (maybeUpgradeToHD))
            (.. (:key-chain-group this) (getActiveKeyChain) (getKeyByPath __path, false))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;;
     ; Convenience wrapper around
     ; {@link Wallet#encrypt(org.bitcoinj.crypto.KeyCrypter, org.spongycastle.crypto.params.KeyParameter)}
     ; which uses the default Scrypt key derivation algorithm and parameters to derive a key from the given password.
     ;;
    #_public
    (ยง method #_"void" encrypt [#_"CharSequence" __password]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (let [#_"KeyCrypterScrypt" __scrypt (KeyCrypterScrypt.)]
                (.. (:key-chain-group this) (encrypt __scrypt, (.. __scrypt (deriveKey __password))))
            )
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
        (.. this (saveNow))
        nil
    )

    ;;;
     ; Encrypt the wallet using the KeyCrypter and the AES key.
     ; A good default KeyCrypter to use is {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @param keyCrypter The KeyCrypter that specifies how to encrypt/ decrypt a key.
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming to create from a password).
     ; @throws KeyCrypterException if the wallet encryption fails.  If so, the wallet state is unchanged.
     ;;
    #_public
    (ยง method #_"void" encrypt [#_"KeyCrypter" __keyCrypter, #_"KeyParameter" __aesKey]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (encrypt __keyCrypter, __aesKey))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
        (.. this (saveNow))
        nil
    )

    ;;;
     ; Decrypt the wallet with the wallets keyCrypter and password.
     ; @throws KeyCrypterException if the wallet decryption fails.  If so, the wallet state is unchanged.
     ;;
    #_public
    (ยง method #_"void" decrypt [#_"CharSequence" __password]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (let [#_"KeyCrypter" __crypter (.. (:key-chain-group this) (getKeyCrypter))]
                (Preconditions/checkState (some? __crypter), "Not encrypted")
                (.. (:key-chain-group this) (decrypt (.. __crypter (deriveKey __password))))
            )
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
        (.. this (saveNow))
        nil
    )

    ;;;
     ; Decrypt the wallet with the wallets keyCrypter and AES key.
     ;
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming to create from a password).
     ; @throws KeyCrypterException if the wallet decryption fails. If so, the wallet state is unchanged.
     ;;
    #_public
    (ยง method #_"void" decrypt [#_"KeyParameter" __aesKey]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (decrypt __aesKey))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
        (.. this (saveNow))
        nil
    )

    ;;;
     ;  Check whether the password can decrypt the first key in the wallet.
     ;  This can be used to check the validity of an entered password.
     ;
     ;  @return true if the password supplied can decrypt the first private key in the wallet, false otherwise.
     ;  @throws IllegalStateException if the wallet is not encrypted.
     ;;
    #_public
    (ยง method #_"boolean" checkPassword [#_"CharSequence" __password]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (checkPassword __password))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;;
     ;  Check whether the AES key can decrypt the first encrypted key in the wallet.
     ;
     ;  @return true if AES key supplied can decrypt the first encrypted private key in the wallet, false otherwise.
     ;;
    #_public
    (ยง method #_"boolean" checkAESKey [#_"KeyParameter" __aesKey]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (checkAESKey __aesKey))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;;
     ; Get the wallet's KeyCrypter, or null if the wallet is not encrypted.
     ; (Used in encrypting/decrypting an ECKey).
     ;;
    #_nilable
    #_public
    (ยง method #_"KeyCrypter" getKeyCrypter []
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (getKeyCrypter))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;;
     ; Get the type of encryption used for this wallet.
     ;
     ; (This is a convenience method - the encryption type is actually stored in the keyCrypter).
     ;;
    #_public
    (ยง method #_"Protos.Wallet.EncryptionType" getEncryptionType []
        (.. (:key-chain-group-lock this) (lock))
        (try
            (let [#_"KeyCrypter" __crypter (.. (:key-chain-group this) (getKeyCrypter))]
                (ยง return (if (some? __crypter) (.. __crypter (getUnderstoodEncryptionType)) Protos.Wallet.EncryptionType/UNENCRYPTED))
            )
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;; Returns true if the wallet is encrypted using any scheme, false if not. ;;
    #_public
    (ยง method #_"boolean" isEncrypted []
        (!= (.. this (getEncryptionType)) Protos.Wallet.EncryptionType/UNENCRYPTED)
    )

    ;;; Changes wallet encryption password, this is atomic operation. ;;
    #_public
    (ยง method #_"void" changeEncryptionPassword [#_"CharSequence" __currentPassword, #_"CharSequence" __newPassword]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. this (decrypt __currentPassword))
            (.. this (encrypt __newPassword))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
        nil
    )

    ;;; Changes wallet AES encryption key, this is atomic operation. ;;
    #_public
    (ยง method #_"void" changeEncryptionKey [#_"KeyCrypter" __keyCrypter, #_"KeyParameter" __currentAesKey, #_"KeyParameter" __newAesKey]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. this (decrypt __currentAesKey))
            (.. this (encrypt __keyCrypter, __newAesKey))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
        nil
    )

    ;; TODO: Make this package private once the classes finish moving around.
    ;;; Internal use only. ;;
    #_public
    (ยง method #_"List<Protos.Key>" serializeKeyChainGroupToProtobuf []
        (.. (:key-chain-group-lock this) (lock))
        (try
            (.. (:key-chain-group this) (serializeToProtobuf))
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;; Saves the wallet first to the given temp file, then renames to the dest file. ;;
    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" saveToFile [#_"File" __temp, #_"File" __destFile]
        (let [#_"FileOutputStream" __stream nil]
            (.. (:lock this) (lock))
            (try
                (ยง ass __stream (FileOutputStream. __temp))
                (.. this (saveToFileStream __stream))
                ;; Attempt to force the bits to hit the disk.  In reality the OS or hard disk itself may still decide
                ;; to not write through to physical media for at least a few seconds, but this is the best we can do.
                (.. __stream (flush))
                (.. __stream (getFD) (sync))
                (.. __stream (close))
                (ยง ass __stream nil)
                (cond (Utils/isWindows)
                    (do
                        ;; Work around an issue on Windows whereby you can't rename over existing files.
                        (let [#_"File" __canonical (.. __destFile (getCanonicalFile))]
                            (when (and (.. __canonical (exists)) (not (.. __canonical (delete))))
                                (throw (IOException. "Failed to delete canonical wallet file for replacement with autosave"))
                            )
                            (when (.. __temp (renameTo __canonical))
                                (ยง return nil) ;; else fall through
                            )
                            (throw (IOException. (str "Failed to rename " __temp " to " __canonical)))
                        )
                    )
                    (not (.. __temp (renameTo __destFile)))
                    (do
                        (throw (IOException. (str "Failed to rename " __temp " to " __destFile)))
                    )
                )
                (catch RuntimeException __e
                    (.. Wallet/log (error "Failed whilst saving wallet", __e))
                    (throw __e)
                )
                (finally
                    (.. (:lock this) (unlock))
                    (when (some? __stream)
                        (.. __stream (close))
                    )
                    (when (.. __temp (exists))
                        (.. Wallet/log (warn "Temp file still exists after failed save."))
                    )
                )
            )
            nil
        )
    )

    ;;;
     ; Uses protobuf serialization to save the wallet to the given file.  To learn more about this file format, see
     ; {@link WalletProtobufSerializer}.  Writes out first to a temporary file in the same directory and then renames
     ; once written.
     ;;
    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" saveToFile [#_"File" __f]
        (let [#_"File" __directory (.. __f (getAbsoluteFile) (getParentFile))
              #_"File" __temp (File/createTempFile "wallet", nil, __directory)]
            (.. this (saveToFile __temp, __f))
            nil
        )
    )

    ;;;
     ; <p>Whether or not the wallet will ignore pending transactions that fail the selected {@link RiskAnalysis}.
     ; By default, if a transaction is considered risky then it won't enter the wallet and won't trigger any event
     ; listeners.  If you set this property to true, then all transactions will be allowed in regardless of risk.
     ; For example, the {@link DefaultRiskAnalysis} checks for non-finality of transactions.</p>
     ;
     ; <p>Note that this property is not serialized.  You have to set it each time a Wallet object is constructed,
     ; even if it's loaded from a protocol buffer.</p>
     ;;
    #_public
    (ยง method #_"void" setAcceptRiskyTransactions [#_"boolean" __acceptRiskyTransactions]
        (.. (:lock this) (lock))
        (try
            (ยง assoc this :accept-risky-transactions __acceptRiskyTransactions)
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; See {@link Wallet#setAcceptRiskyTransactions(boolean)} for an explanation of this property.
     ;;
    #_public
    (ยง method #_"boolean" isAcceptRiskyTransactions []
        (.. (:lock this) (lock))
        (try
            (:accept-risky-transactions this)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Sets the {@link RiskAnalysis} implementation to use for deciding whether received pending transactions are
     ; risky or not.  If the analyzer says a transaction is risky, by default it will be dropped. You can customize
     ; this behaviour with {@link #setAcceptRiskyTransactions(boolean)}.
     ;;
    #_public
    (ยง method #_"void" setRiskAnalyzer [#_"RiskAnalysis.Analyzer" __analyzer]
        (.. (:lock this) (lock))
        (try
            (ยง assoc this :risk-analyzer (Preconditions/checkNotNull __analyzer))
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Gets the current {@link RiskAnalysis} implementation.  The default is {@link DefaultRiskAnalysis}.
     ;;
    #_public
    (ยง method #_"RiskAnalysis.Analyzer" getRiskAnalyzer []
        (.. (:lock this) (lock))
        (try
            (:risk-analyzer this)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; <p>Sets up the wallet to auto-save itself to the given file, using temp files with atomic renames to ensure
     ; consistency.  After connecting to a file, you no longer need to save the wallet manually, it will do it
     ; whenever necessary.  Protocol buffer serialization will be used.</p>
     ;
     ; <p>If delayTime is set, a background thread will be created and the wallet will only be saved to disk
     ; every so many time units.  If no changes have occurred for the given time period, nothing will be written.
     ; In this way disk IO can be rate limited.  It's a good idea to set this as otherwise the wallet can change very
     ; frequently, e.g. if there are a lot of transactions in it or during block sync, and there will be a lot of redundant
     ; writes.  Note that when a new key is added, that always results in an immediate save regardless of delayTime.
     ; <b>You should still save the wallet manually when your program is about to shut down as the JVM will not
     ; wait for the background thread.</b></p>
     ;
     ; <p>An event listener can be provided.  If a delay >0 was specified, it will be called on a background thread
     ; with the wallet locked when an auto-save occurs.  If delay is zero or you do something that always triggers
     ; an immediate save, like adding a key, the event listener will be invoked on the calling threads.</p>
     ;
     ; @param f The destination file to save to.
     ; @param delayTime How many time units to wait until saving the wallet on a background thread.
     ; @param timeUnit The unit of measurement for delayTime.
     ; @param eventListener Callback to be informed when the auto-save thread does things, or null.
     ;;
    #_public
    (ยง method #_"WalletFiles" autosaveToFile [#_"File" __f, #_"long" __delayTime, #_"TimeUnit" __timeUnit, #_nilable #_"WalletFiles.Listener" __eventListener]
        (.. (:lock this) (lock))
        (try
            (Preconditions/checkState (nil? (:v-file-manager this)), "Already auto saving this wallet.")
            (let [#_"WalletFiles" __manager (WalletFiles. this, __f, __delayTime, __timeUnit)]
                (when (some? __eventListener)
                    (.. __manager (setListener __eventListener))
                )
                (ยง assoc this :v-file-manager __manager)
                (ยง return __manager)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Disables auto-saving, after it had been enabled with
     ; {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, org.bitcoinj.wallet.WalletFiles.Listener)}
     ; before.  This method blocks until finished.
     ;;
    #_public
    (ยง method #_"void" shutdownAutosaveAndWait []
        (.. (:lock this) (lock))
        (try
            (let [#_"WalletFiles" __files (:v-file-manager this)]
                (ยง assoc this :v-file-manager nil)
                (Preconditions/checkState (some? __files), "Auto saving not enabled.")
                (.. __files (shutdownAndWait))
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;; Requests an asynchronous save on a background thread. ;;
    #_protected
    (ยง method #_"void" saveLater []
        (let [#_"WalletFiles" __files (:v-file-manager this)]
            (when (some? __files)
                (.. __files (saveLater))
            )
            nil
        )
    )

    ;;; If auto saving is enabled, do an immediate sync write to disk ignoring any delays. ;;
    #_protected
    (ยง method #_"void" saveNow []
        (let [#_"WalletFiles" __files (:v-file-manager this)]
            (when (some? __files)
                (try
                    (.. __files (saveNow)) ;; This calls back into saveToFile().
                    (catch IOException __e
                        ;; Can't really do much at this point, just let the API user know.
                        (.. Wallet/log (error "Failed to save wallet to disk!", __e))
                        (let [#_"Thread.UncaughtExceptionHandler" __handler Threading/UNCAUGHT_EXCEPTION_HANDLER]
                            (when (some? __handler)
                                (.. __handler (uncaughtException (Thread/currentThread), __e))
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    ;;;
     ; Uses protobuf serialization to save the wallet to the given file stream.
     ; To learn more about this file format, see {@link WalletProtobufSerializer}.
     ;;
    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" saveToFileStream [#_"OutputStream" __f]
        (.. (:lock this) (lock))
        (try
            (.. (WalletProtobufSerializer.) (writeWallet this, __f))
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;; Returns the parameters this wallet was created with. ;;
    #_public
    (ยง method #_"NetworkParameters" getParams []
        (:params this)
    )

    ;;; Returns the API context that this wallet was created with. ;;
    #_public
    (ยง method #_"Context" getContext []
        (:context this)
    )

    ;;;
     ; Returns a wallet deserialized from the given file.
     ;
     ; @param file The wallet file to be read.
     ;;
    #_public
    #_static
    #_throws #_[ "UnreadableWalletException" ]
    (ยง defn #_"Wallet" Wallet/loadFromFile [#_"File" __file]
        (try
            (let [#_"FileInputStream" __stream nil]
                (try
                    (ยง ass __stream (FileInputStream. __file))
                    (Wallet/loadFromFileStream __stream)
                    (finally
                        (when (some? __stream)
                            (.. __stream (close))
                        )
                    )
                )
            )
            (catch IOException __e
                (throw (UnreadableWalletException. "Could not open file", __e))
            )
        )
    )

    ;;;
     ; Returns if this wallet is structurally consistent, so e.g. no duplicate transactions.
     ; First inconsistency and a dump of the wallet will be logged.
     ;;
    #_public
    (ยง method #_"boolean" isConsistent []
        (try
            (.. this (isConsistentOrThrow))
            (ยง return true)
            (catch IllegalStateException __e1
                (.. Wallet/log (error (.. __e1 (getMessage))))
                (try
                    (.. Wallet/log (error (.. this (toString))))
                    (catch RuntimeException __e2
                        (.. Wallet/log (error "Printing inconsistent wallet failed", __e2))
                    )
                )
                (ยง return false)
            )
        )
    )

    ;;;
     ; Variant of {@link Wallet#isConsistent()} that throws an {@link IllegalStateException} describing
     ; the first inconsistency.
     ;;
    #_public
    #_throws #_[ "IllegalStateException" ]
    (ยง method #_"void" isConsistentOrThrow []
        (.. (:lock this) (lock))
        (try
            (let [#_"Set<Transaction>" __transactions (.. this (getTransactions true))]

                (let [#_"Set<Sha256Hash>" __hashes (HashSet. #_"<>")]
                    (doseq [#_"Transaction" __tx __transactions]
                        (.. __hashes (add (.. __tx (getHash))))
                    )

                    (let [#_"int" __size1 (.. __transactions (size))]
                        (when (!= __size1 (.. __hashes (size)))
                            (throw (IllegalStateException. "Two transactions with same hash"))
                        )

                        (let [#_"int" __size2 (+ (.. (:unspent this) (size)) (.. (:spent this) (size)) (.. (:pending this) (size)) (.. (:dead this) (size)))]
                            (when (!= __size1 __size2)
                                (throw (IllegalStateException. (str "Inconsistent wallet sizes: " __size1 ", " __size2)))
                            )

                            (doseq [#_"Transaction" __tx (.. (:unspent this) (values))]
                                (when (not (.. this (isTxConsistent __tx, false)))
                                    (throw (IllegalStateException. (str "Inconsistent unspent tx: " (.. __tx (getHashAsString)))))
                                )
                            )

                            (doseq [#_"Transaction" __tx (.. (:spent this) (values))]
                                (when (not (.. this (isTxConsistent __tx, true)))
                                    (throw (IllegalStateException. (str "Inconsistent spent tx: " (.. __tx (getHashAsString)))))
                                )
                            )
                        )
                    )
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;; If isSpent, check that all my outputs spent, otherwise check that there at least one unspent.
    #_testing
    (ยง method #_"boolean" isTxConsistent [#_"Transaction" __tx, #_"boolean" __isSpent]
        (let [#_"boolean" __isActuallySpent true]
            (doseq [#_"TransactionOutput" __o (.. __tx (getOutputs))]
                (cond (.. __o (isAvailableForSpending))
                    (do
                        (when (.. __o (isMine this))
                            (ยง ass __isActuallySpent false)
                        )
                        (when (some? (.. __o (getSpentBy)))
                            (.. Wallet/log (error "isAvailableForSpending != spentBy"))
                            (ยง return false)
                        )
                    )
                    :else
                    (do
                        (when (nil? (.. __o (getSpentBy)))
                            (.. Wallet/log (error "isAvailableForSpending != spentBy"))
                            (ยง return false)
                        )
                    )
                )
            )
            (== __isActuallySpent __isSpent)
        )
    )

    ;;; Returns a wallet deserialized from the given input stream. ;;
    #_public
    #_static
    #_throws #_[ "UnreadableWalletException" ]
    (ยง defn #_"Wallet" Wallet/loadFromFileStream [#_"InputStream" __stream]
        (let [#_"Wallet" __wallet (.. (WalletProtobufSerializer.) (readWallet __stream))]
            (when (not (.. __wallet (isConsistent)))
                (.. Wallet/log (error "Loaded an inconsistent wallet"))
            )
            __wallet
        )
    )

    ;;;
     ; Called by the {@link BlockChain} when we receive a new filtered block that contains a transactions previously
     ; received by a call to {@link #receivePending}.
     ;
     ; This is necessary for the internal book-keeping Wallet does.  When a transaction is received that sends us
     ; coins it is added to a pool so we can use it later to create spends.  When a transaction is received that
     ; consumes outputs they are marked as spent so they won't be used in future.
     ;
     ; A transaction that spends our own coins can be received either because a spend we created was accepted by
     ; the network and thus made it into a block, or because our keys are being shared between multiple instances
     ; and some other node spent the coins instead.  We still have to know about that to avoid accidentally trying
     ; to double spend.
     ;
     ; A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.  We must still record these transactions and the blocks they appear in because a future
     ; block might change which chain is best causing a reorganize.  A re-org can totally change our balance!
     ;;
    #_override
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"boolean" notifyTransactionIsInBlock [#_"Sha256Hash" __txHash, #_"StoredBlock" __block, #_"BlockChain.NewBlockType" __blockType, #_"int" __relativityOffset]
        (.. (:lock this) (lock))
        (try
            (let [#_"Transaction" __tx (.. (:transactions this) (get __txHash))]
                (when (nil? __tx)
                    (ยง ass __tx (.. (:risk-dropped this) (get __txHash)))
                    (cond (some? __tx)
                        (do
                            ;; If this happens our risk analysis is probably wrong and should be improved.
                            (.. Wallet/log (info "Risk analysis dropped tx {} but was included in block anyway", (.. __tx (getHash))))
                        )
                        :else
                        (do
                            ;; False positive that was broadcast to us and ignored by us because it was irrelevant to our keys.
                            (ยง return false)
                        )
                    )
                )
                (.. this (receive __tx, __block, __blockType, __relativityOffset))
                (ยง return true)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; <p>Called when we have found a transaction (via network broadcast or otherwise) that is relevant to this wallet
     ; and want to record it.  Note that we <b>cannot verify these transactions at all</b>, they may spend fictional
     ; coins or be otherwise invalid.  They are useful to inform the user about coins they can expect to receive soon,
     ; and if you trust the sender of the transaction you can choose to assume they are in fact valid and will not
     ; be double spent as an optimization.</p>
     ;
     ; <p>This is the same as {@link Wallet#receivePending(Transaction, java.util.List)} but allows you to override the
     ; {@link Wallet#isPendingTransactionRelevant(Transaction)} sanity-check to keep track of transactions that are not
     ; spendable or spend our coins.  This can be useful when you want to keep track of transaction confidence on
     ; arbitrary transactions.  Note that transactions added in this way will still be relayed to peers and appear in
     ; transaction lists like any other pending transaction (even when not relevant).</p>
     ;;
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"void" receivePending [#_"Transaction" __tx, #_nilable #_"List<Transaction>" __dependencies, #_"boolean" __overrideIsRelevant]
        ;; Can run in a peer thread.  This method will only be called if a prior call to isPendingTransactionRelevant
        ;; returned true, so we already know by this point that it sends coins to or from our wallet, or is a double
        ;; spend against one of our other pending transactions.
        (.. (:lock this) (lock))
        (try
            (.. __tx (verify))
            ;; Ignore it if we already know about this transaction.  Receiving a pending transaction never moves it
            ;; between pools.
            (let [#_"EnumSet<WalletTransaction.Pool>" __containingPools (.. this (getContainingPools __tx))]
                (when (not (.. __containingPools (equals (EnumSet/noneOf WalletTransaction.Pool))))
                    (.. Wallet/log (debug (str "Received tx we already saw in a block or created ourselves: " (.. __tx (getHashAsString)))))
                    (ยง return nil)
                )
                ;; Repeat the check of relevancy here, even though the caller may have already done so - this is to avoid
                ;; race conditions where receivePending may be being called in parallel.
                (when (and (not __overrideIsRelevant) (not (.. this (isPendingTransactionRelevant __tx))))
                    (ยง return nil)
                )

                (when (and (.. this (isTransactionRisky __tx, __dependencies)) (not (:accept-risky-transactions this)))
                    ;; isTransactionRisky already logged the reason.
                    (.. (:risk-dropped this) (put (.. __tx (getHash)), __tx))
                    (.. Wallet/log (warn "There are now {} risk dropped transactions being kept in memory", (.. (:risk-dropped this) (size))))
                    (ยง return nil)
                )

                (let [#_"Coin" __valueSentToMe (.. __tx (getValueSentToMe this))
                      #_"Coin" __valueSentFromMe (.. __tx (getValueSentFromMe this))]
                    (when (.. Wallet/log (isInfoEnabled))
                        (.. Wallet/log (info (String/format Locale/US, "Received a pending transaction %s that spends %s from our own wallet, and sends us %s", (.. __tx (getHashAsString)), (.. __valueSentFromMe (toFriendlyString)), (.. __valueSentToMe (toFriendlyString)))))
                    )
                    (when (.. __tx (getConfidence) (getSource) (equals TransactionConfidence.Source/UNKNOWN))
                        (.. Wallet/log (warn "Wallet received transaction with an unknown source. Consider tagging it!"))
                    )
                    ;; If this tx spends any of our unspent outputs, mark them as spent now, then add to the pending pool.  This
                    ;; ensures that if some other client that has our keys broadcasts a spend we stay in sync.  Also updates the
                    ;; timestamp on the transaction and registers/runs event listeners.
                    (.. this (commitTx __tx))
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        ;; maybeRotateKeys() will ignore pending transactions, so we don't bother calling it here (see the comments
        ;; in that function for an explanation of why).
        nil
    )

    ;;;
     ; Given a transaction and an optional list of dependencies (recursive/flattened), returns true if the given
     ; transaction would be rejected by the analyzer, or false otherwise.  The result of this call is independent
     ; of the value of {@link #isAcceptRiskyTransactions()}.  Risky transactions yield a logged warning.  If you
     ; want to know the reason why a transaction is risky, create an instance of the {@link RiskAnalysis} yourself
     ; using the factory returned by {@link #getRiskAnalyzer()} and use it directly.
     ;;
    #_public
    (ยง method #_"boolean" isTransactionRisky [#_"Transaction" __tx, #_nilable #_"List<Transaction>" __dependencies]
        (.. (:lock this) (lock))
        (try
            (when (nil? __dependencies)
                (ยง ass __dependencies (ImmutableList/of))
            )
            (let [#_"RiskAnalysis" __analysis (.. (:risk-analyzer this) (create this, __tx, __dependencies))
                  #_"RiskAnalysis.Result" __result (.. __analysis (analyze))]
                (when (!= __result RiskAnalysis.Result/OK)
                    (.. Wallet/log (warn "Pending transaction was considered risky: {}\n{}", __analysis, __tx))
                    (ยง return true)
                )
                (ยง return false)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; <p>Called when we have found a transaction (via network broadcast or otherwise) that is relevant to this wallet
     ; and want to record it.  Note that we <b>cannot verify these transactions at all</b>, they may spend fictional
     ; coins or be otherwise invalid.  They are useful to inform the user about coins they can expect to receive soon,
     ; and if you trust the sender of the transaction you can choose to assume they are in fact valid and will not
     ; be double spent as an optimization.</p>
     ;
     ; <p>Before this method is called, {@link Wallet#isPendingTransactionRelevant(Transaction)} should have been
     ; called to decide whether the wallet cares about the transaction - if it does, then this method expects the
     ; transaction and any dependencies it has which are still in the memory pool.</p>
     ;;
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"void" receivePending [#_"Transaction" __tx, #_nilable #_"List<Transaction>" __dependencies]
        (.. this (receivePending __tx, __dependencies, false))
        nil
    )

    ;;;
     ; This method is used by a {@link Peer} to find out if a transaction that has been announced is interesting,
     ; that is, whether we should bother downloading its dependencies and exploring the transaction to decide how
     ; risky it is.  If this method returns true then {@link Wallet#receivePending(Transaction, java.util.List)}
     ; will soon be called with the transactions dependencies as well.
     ;;
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"boolean" isPendingTransactionRelevant [#_"Transaction" __tx]
        (.. (:lock this) (lock))
        (try
            ;; Ignore it if we already know about this transaction.  Receiving a pending transaction never moves it
            ;; between pools.
            (let [#_"EnumSet<WalletTransaction.Pool>" __containingPools (.. this (getContainingPools __tx))]
                (when (not (.. __containingPools (equals (EnumSet/noneOf WalletTransaction.Pool))))
                    (.. Wallet/log (debug (str "Received tx we already saw in a block or created ourselves: " (.. __tx (getHashAsString)))))
                    (ยง return false)
                )

                ;; We only care about transactions that:
                ;;   - Send us coins.
                ;;   - Spend our coins.
                ;;   - Double spend a tx in our wallet.
                (when (not (.. this (isTransactionRelevant __tx)))
                    (.. Wallet/log (debug "Received tx that isn't relevant to this wallet, discarding."))
                    (ยง return false)
                )
                (ยง return true)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; <p>Returns true if the given transaction sends coins to any of our keys, or has inputs spending any of our outputs,
     ; and also returns true if tx has inputs that are spending outputs which are
     ; not ours but which are spent by pending transactions.</p>
     ;
     ; <p>Note that if the tx has inputs containing one of our keys, but the connected transaction is not in the wallet,
     ; it will not be considered relevant.</p>
     ;;
    #_public
    #_throws #_[ "ScriptException" ]
    (ยง method #_"boolean" isTransactionRelevant [#_"Transaction" __tx]
        (.. (:lock this) (lock))
        (try
            (or (< 0 (.. __tx (getValueSentFromMe this) (signum))) (< 0 (.. __tx (getValueSentToMe this) (signum))) (not (.. this (findDoubleSpendsAgainst __tx, (:transactions this)) (isEmpty))))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Finds transactions in the specified candidates that double spend "tx".  Not a general check, but it can work even
     ; if the double spent inputs are not ours.
     ; @return the set of transactions that double spend "tx".
     ;;
    #_private
    (ยง method- #_"Set<Transaction>" findDoubleSpendsAgainst [#_"Transaction" __tx, #_"Map<Sha256Hash, Transaction>" __candidates]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))
        (when (.. __tx (isCoinBase))
            (ยง return (Sets/newHashSet))
        )

        ;; Compile a set of outpoints that are spent by tx.
        (let [#_"HashSet<TransactionOutPoint>" __outpoints (HashSet. #_"<>")]
            (doseq [#_"TransactionInput" __input (.. __tx (getInputs))]
                (.. __outpoints (add (.. __input (getOutpoint))))
            )

            ;; Now for each pending transaction, see if it shares any outpoints with this tx.
            (let [#_"Set<Transaction>" __doubleSpendTxns (Sets/newHashSet)]
                (doseq [#_"Transaction" __p (.. __candidates (values))]
                    (when (.. __p (equals __tx))
                        (ยง continue )
                    )

                    (doseq [#_"TransactionInput" __input (.. __p (getInputs))]
                        ;; This relies on the fact that TransactionOutPoint equality is defined at the protocol not object
                        ;; level - outpoints from two different inputs that point to the same output compare the same.
                        (let [#_"TransactionOutPoint" __outpoint (.. __input (getOutpoint))]
                            ;; If does, it's a double spend against the candidates, which makes it relevant.
                            (when (.. __outpoints (contains __outpoint))
                                (.. __doubleSpendTxns (add __p))
                            )
                        )
                    )
                )
                __doubleSpendTxns
            )
        )
    )

    ;;;
     ; Adds to txSet all the txns in txPool spending outputs of txns in txSet,
     ; and all txns spending the outputs of those txns, recursively.
     ;;
    (ยง method #_"void" addTransactionsDependingOn [#_"Set<Transaction>" __txSet, #_"Set<Transaction>" __txPool]
        (let [#_"Map<Sha256Hash, Transaction>" __txQueue (LinkedHashMap. #_"<>")]
            (doseq [#_"Transaction" __tx __txSet]
                (.. __txQueue (put (.. __tx (getHash)), __tx))
            )

            (while (not (.. __txQueue (isEmpty)))
                (let [#_"Transaction" __tx (.. __txQueue (remove (.. __txQueue (keySet) (iterator) (next))))]
                    (doseq [#_"Transaction" __anotherTx __txPool]
                        (when (.. __anotherTx (equals __tx))
                            (ยง continue )
                        )

                        (doseq [#_"TransactionInput" __input (.. __anotherTx (getInputs))]
                            (when (.. __input (getOutpoint) (getHash) (equals (.. __tx (getHash))))
                                (when (nil? (.. __txQueue (get (.. __anotherTx (getHash)))))
                                    (.. __txQueue (put (.. __anotherTx (getHash)), __anotherTx))
                                    (.. __txSet (add __anotherTx))
                                )
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    ;;;
     ; Called by the {@link BlockChain} when we receive a new block that sends coins to one of our addresses or
     ; spends coins from one of our addresses (note that a single transaction can do both).
     ;
     ; This is necessary for the internal book-keeping Wallet does.  When a transaction is received that sends us
     ; coins it is added to a pool so we can use it later to create spends.  When a transaction is received that
     ; consumes outputs they are marked as spent so they won't be used in future.
     ;
     ; A transaction that spends our own coins can be received either because a spend we created was accepted by
     ; the network and thus made it into a block, or because our keys are being shared between multiple instances
     ; and some other node spent the coins instead.  We still have to know about that to avoid accidentally trying
     ; to double spend.
     ;
     ; A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.  We must still record these transactions and the blocks they appear in because a future
     ; block might change which chain is best causing a reorganize.  A re-org can totally change our balance!
     ;;
    #_override
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"void" receiveFromBlock [#_"Transaction" __tx, #_"StoredBlock" __block, #_"BlockChain.NewBlockType" __blockType, #_"int" __relativityOffset]
        (.. (:lock this) (lock))
        (try
            (when (.. this (isTransactionRelevant __tx))
                (.. this (receive __tx, __block, __blockType, __relativityOffset))
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;; Whether to do a saveNow or saveLater when we are notified of the next best block.
    #_private
    (ยง field- #_"boolean" :hard-save-on-next-block false)

    #_private
    #_throws #_[ "VerificationException" ]
    (ยง method- #_"void" receive [#_"Transaction" __tx, #_"StoredBlock" __block, #_"BlockChain.NewBlockType" __blockType, #_"int" __relativityOffset]
        ;; Runs in a peer thread.
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))

        (let [#_"Coin" __prevBalance (.. this (getBalance))
              #_"Sha256Hash" __txHash (.. __tx (getHash))
              #_"boolean" __bestChain (== __blockType BlockChain.NewBlockType/BEST_CHAIN)
              #_"boolean" __sideChain (== __blockType BlockChain.NewBlockType/SIDE_CHAIN)]

            (let [#_"Coin" __valueSentFromMe (.. __tx (getValueSentFromMe this))
                  #_"Coin" __valueSentToMe (.. __tx (getValueSentToMe this))
                  #_"Coin" __valueDifference (.. __valueSentToMe (subtract __valueSentFromMe))]

                (.. Wallet/log (info "Received tx{} for {}: {} [{}] in block {}", (if __sideChain " on a side chain" ""), (.. __valueDifference (toFriendlyString)), (.. __tx (getHashAsString)), __relativityOffset, (if (some? __block) (.. __block (getHeader) (getHash)) "(unit test)")))

                ;; Inform the key chains that the issued keys were observed in a transaction, so they know to
                ;; calculate more keys for the next Bloom filters.
                (.. this (markKeysAsUsed __tx))

                (ยง assoc this :on-wallet-changed-suppressions (inc (:on-wallet-changed-suppressions this)))

                ;; If this transaction is already in the wallet, we may need to move it into a different pool.
                ;; At the very least we need to ensure we're manipulating the canonical object rather than a duplicate.
                (let [#_"Transaction" __tmp (.. (:transactions this) (get (.. __tx (getHash))))]
                    (when (some? __tmp)
                        (ยง ass __tx __tmp)
                    )
                )

                (let [#_"boolean" __wasPending (some? (.. (:pending this) (remove __txHash)))]
                    (when __wasPending
                        (.. Wallet/log (info "  <-pending"))
                    )

                    (cond __bestChain
                        (do
                            (let [#_"boolean" __wasDead (some? (.. (:dead this) (remove __txHash)))]
                                (when __wasDead
                                    (.. Wallet/log (info "  <-dead"))
                                )
                                (when __wasPending
                                    ;; Was pending and is now confirmed.  Disconnect the outputs in case we spent any already:
                                    ;; they will be re-connected by processTxFromBestChain below.
                                    (doseq [#_"TransactionOutput" __output (.. __tx (getOutputs))]
                                        (let [#_"TransactionInput" __spentBy (.. __output (getSpentBy))]
                                            (when (some? __spentBy)
                                                (Preconditions/checkState (.. (:my-unspents this) (add __output)))
                                                (.. __spentBy (disconnect))
                                            )
                                        )
                                    )
                                )
                                (.. this (processTxFromBestChain __tx, (or __wasPending __wasDead)))
                            )
                        )
                        :else
                        (do
                            (Preconditions/checkState __sideChain)
                            ;; Transactions that appear in a side chain will have that appearance recorded below - we assume
                            ;; that some miners are also trying to include the transaction into the current best chain too,
                            ;; so let's treat it as pending, except we don't need to do any risk analysis on it.
                            (cond __wasPending
                                (do
                                    ;; Just put it back in without touching the connections or confidence.
                                    (.. this (addWalletTransaction WalletTransaction.Pool/PENDING, __tx))
                                    (.. Wallet/log (info "  ->pending"))
                                )
                                :else
                                (do
                                    ;; Ignore the case where a tx appears on a side chain at the same time as the best chain
                                    ;; (this is quite normal and expected).
                                    (let [#_"Sha256Hash" __hash (.. __tx (getHash))]
                                        (when (and (not (.. (:unspent this) (containsKey __hash))) (not (.. (:spent this) (containsKey __hash))) (not (.. (:dead this) (containsKey __hash))))
                                            ;; Otherwise put it (possibly back) into pending.
                                            ;; Committing it updates the spent flags and inserts into the pool as well.
                                            (.. this (commitTx __tx))
                                        )
                                    )
                                )
                            )
                        )
                    )

                    (when (some? __block)
                        ;; Mark the tx as appearing in this block so we can find it later after a re-org.  This also tells
                        ;; the tx confidence object about the block and sets its depth appropriately.
                        (.. __tx (setBlockAppearance __block, __bestChain, __relativityOffset))
                        (when __bestChain
                            ;; Don't notify this tx of work done in notifyNewBestBlock which will be called immediately
                            ;; after this method has been called by BlockChain for all relevant transactions.  Otherwise
                            ;; we'd double count.
                            (.. (:ignore-next-new-block this) (add __txHash))

                            ;; When a tx is received from the best chain, if other txns that spend this tx are IN_CONFLICT,
                            ;; change its confidence to PENDING (Unless they are also spending other txns IN_CONFLICT).
                            ;; Consider dependency chains.
                            (let [#_"Set<Transaction>" __currentTxDependencies (Sets/newHashSet __tx)]
                                (.. this (addTransactionsDependingOn __currentTxDependencies, (.. this (getTransactions true))))
                                (.. __currentTxDependencies (remove __tx))
                                (let [#_"List<Transaction>" __currentTxDependenciesSorted (.. this (sortTxnsByDependency __currentTxDependencies))]
                                    (doseq [#_"Transaction" __txDependency __currentTxDependenciesSorted]
                                        (when (.. __txDependency (getConfidence) (getConfidenceType) (equals TransactionConfidence.ConfidenceType/IN_CONFLICT))
                                            (when (.. this (isNotSpendingTxnsInConfidenceType __txDependency, TransactionConfidence.ConfidenceType/IN_CONFLICT))
                                                (.. __txDependency (getConfidence) (setConfidenceType TransactionConfidence.ConfidenceType/PENDING))
                                                (.. (:confidence-changed this) (put __txDependency, TransactionConfidence.Listener.ChangeReason/TYPE))
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )

                    (ยง assoc this :on-wallet-changed-suppressions (dec (:on-wallet-changed-suppressions this)))

                    ;; Side chains don't affect confidence.
                    (cond __bestChain
                        (do
                            ;; notifyNewBestBlock will be invoked next and will then call maybeQueueOnWalletChanged for us.
                            (.. (:confidence-changed this) (put __tx, TransactionConfidence.Listener.ChangeReason/TYPE))
                        )
                        :else
                        (do
                            (.. this (maybeQueueOnWalletChanged))
                        )
                    )

                    ;; Inform anyone interested that we have received or sent coins but only if:
                    ;;  - This is not due to a re-org.
                    ;;  - The coins appeared on the best chain.
                    ;;  - We did in fact receive some new money.
                    ;;  - We have not already informed the user about the coins when we received the tx broadcast,
                    ;;    or for our own spends.  If users want to know when a broadcast tx becomes confirmed,
                    ;;    they need to use tx confidence listeners.
                    (when (and (not (:inside-reorg this)) __bestChain)
                        (let [#_"Coin" __newBalance (.. this (getBalance))] ;; This is slow.
                            (.. Wallet/log (info (str "Balance is now: " (.. __newBalance (toFriendlyString)))))
                            (when (not __wasPending)
                                (let [#_"int" __diff (.. __valueDifference (signum))]
                                    ;; We pick one callback based on the value difference, though a tx can of course both
                                    ;; send and receive coins from the wallet.
                                    (cond
                                        (< 0 __diff) (.. this (queueOnCoinsReceived __tx, __prevBalance, __newBalance))
                                        (< __diff 0) (.. this (queueOnCoinsSent __tx, __prevBalance, __newBalance))
                                    )
                                )
                            )
                            (.. this (checkBalanceFuturesLocked __newBalance))
                        )
                    )

                    (.. this (informConfidenceListenersIfNotReorganizing))
                    (.. this (isConsistentOrThrow))
                    ;; Optimization for the case where a block has tons of relevant transactions.
                    (.. this (saveLater))
                    (ยง assoc this :hard-save-on-next-block true)
                    nil
                )
            )
        )
    )

    ;;; Finds if tx is NOT spending other txns which are in the specified confidence type. ;;
    #_private
    (ยง method- #_"boolean" isNotSpendingTxnsInConfidenceType [#_"Transaction" __tx, #_"TransactionConfidence.ConfidenceType" __confidenceType]
        (doseq [#_"TransactionInput" __txInput (.. __tx (getInputs))]
            (let [#_"Transaction" __connectedTx (.. this (getTransaction (.. __txInput (getOutpoint) (getHash))))]
                (when (and (some? __connectedTx) (.. __connectedTx (getConfidence) (getConfidenceType) (equals __confidenceType)))
                    (ยง return false)
                )
            )
        )
        true
    )

    ;;;
     ; Creates and returns a new List with the same txns as inputSet, but txns are sorted by depencency
     ; (a topological sort).  If tx B spends tx A, then tx A should be before tx B on the returned List.
     ; Several invocations to this method with the same inputSet could result in lists with txns in different
     ; order, as there is no guarantee on the order of the returned txns besides what was already stated.
     ;;
    (ยง method #_"List<Transaction>" sortTxnsByDependency [#_"Set<Transaction>" __inputSet]
        (let [#_"ArrayList<Transaction>" __result (ArrayList. #_"<>" __inputSet)]
            (loop-when-recur [#_"int" __i 0] (< __i (dec (.. __result (size)))) [(inc __i)]
                (let [#_"boolean" __txAtISpendsOtherTxInTheList]
                    (ยง repeat
                        (ยง ass __txAtISpendsOtherTxInTheList false)
                        (loop-when-recur [#_"int" __j (inc __i)] (< __j (.. __result (size))) [(inc __j)]
                            (when (.. this (spends (.. __result (get __i)), (.. __result (get __j))))
                                (let [#_"Transaction" __transactionAtI (.. __result (remove __i))]
                                    (.. __result (add __j, __transactionAtI))
                                    (ยง ass __txAtISpendsOtherTxInTheList true)
                                    (ยง break )
                                )
                            )
                        )
                        (ยง again __txAtISpendsOtherTxInTheList)
                    )
                )
            )
            __result
        )
    )

    ;;; Finds whether txA spends txB. ;;
    (ยง method #_"boolean" spends [#_"Transaction" __txA, #_"Transaction" __txB]
        (doseq [#_"TransactionInput" __txInput (.. __txA (getInputs))]
            (when (.. __txInput (getOutpoint) (getHash) (equals (.. __txB (getHash))))
                (ยง return true)
            )
        )

        false
    )

    #_private
    (ยง method- #_"void" informConfidenceListenersIfNotReorganizing []
        (when (:inside-reorg this)
            (ยง return nil)
        )

        (doseq [#_"Map.Entry<Transaction, TransactionConfidence.Listener.ChangeReason>" __entry (.. (:confidence-changed this) (entrySet))]
            (let [#_"Transaction" __tx (.. __entry (getKey))]
                (.. __tx (getConfidence) (queueListeners (.. __entry (getValue))))
                (.. this (queueOnTransactionConfidenceChanged __tx))
            )
        )
        (.. (:confidence-changed this) (clear))
        nil
    )

    ;;;
     ; Called by the {@link BlockChain} when a new block on the best chain is seen, AFTER relevant wallet
     ; transactions are extracted and sent to us UNLESS the new block caused a re-org, in which case this will
     ; not be called (the {@link Wallet#reorganize(StoredBlock, java.util.List, java.util.List)} method will
     ; call this one in that case).
     ;
     ; Used to update confidence data in each transaction and last seen block hash.  Triggers auto saving.
     ; Invokes the onWalletChanged event listener if there were any affected transactions.
     ;;
    #_override
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"void" notifyNewBestBlock [#_"StoredBlock" __block]
        ;; Check to see if this block has been seen before.
        (let [#_"Sha256Hash" __newBlockHash (.. __block (getHeader) (getHash))]
            (when (.. __newBlockHash (equals (.. this (getLastBlockSeenHash))))
                (ยง return nil)
            )

            (.. (:lock this) (lock))
            (try
                ;; Store the new block hash.
                (.. this (setLastBlockSeenHash __newBlockHash))
                (.. this (setLastBlockSeenHeight (.. __block (getHeight))))
                (.. this (setLastBlockSeenTimeSecs (.. __block (getHeader) (getTimeSeconds))))
                ;; Notify all the BUILDING transactions of the new block.
                ;; This is so that they can update their depth.
                (let [#_"Set<Transaction>" __transactions (.. this (getTransactions true))]
                    (doseq [#_"Transaction" __tx __transactions]
                        (cond (.. (:ignore-next-new-block this) (contains (.. __tx (getHash))))
                            (do
                                ;; tx was already processed in receive() due to it appearing in this block, so we don't want
                                ;; to increment the tx confidence depth twice, it'd result in miscounting.
                                (.. (:ignore-next-new-block this) (remove (.. __tx (getHash))))
                            )
                            :else
                            (do
                                (let [#_"TransactionConfidence" __confidence (.. __tx (getConfidence))]
                                    (when (== (.. __confidence (getConfidenceType)) TransactionConfidence.ConfidenceType/BUILDING)
                                        ;; Erase the set of seen peers once the tx is so deep that it seems unlikely to ever go
                                        ;; pending again.  We could clear this data the moment a tx is seen in the block chain,
                                        ;; but in cases where the chain re-orgs, this would mean that wallets would perceive a
                                        ;; newly pending tx has zero confidence at all, which would not be right: we expect it to
                                        ;; be included once again.  We could have a separate was-in-chain-and-now-isn't confidence
                                        ;; type, but this way is backwards compatible with existing software, and the new state
                                        ;; probably wouldn't mean anything different to just remembering peers anyway.
                                        (when (< (.. (:context this) (getEventHorizon)) (.. __confidence (incrementDepthInBlocks)))
                                            (.. __confidence (clearBroadcastBy))
                                        )
                                        (.. (:confidence-changed this) (put __tx, TransactionConfidence.Listener.ChangeReason/DEPTH))
                                    )
                                )
                            )
                        )
                    )

                    (.. this (informConfidenceListenersIfNotReorganizing))
                    (.. this (maybeQueueOnWalletChanged))

                    (cond (:hard-save-on-next-block this)
                        (do
                            (.. this (saveNow))
                            (ยง assoc this :hard-save-on-next-block false)
                        )
                        :else
                        (do
                            ;; Coalesce writes to avoid throttling on disk access when catching up with the chain.
                            (.. this (saveLater))
                        )
                    )
                )
                (finally
                    (.. (:lock this) (unlock))
                )
            )
            nil
        )
    )

    ;;;
     ; Handle when a transaction becomes newly active on the best chain, either due to receiving a new block or a
     ; re-org.  Places the tx into the right pool, handles coinbase transactions, handles double-spends and so on.
     ;;
    #_private
    #_throws #_[ "VerificationException" ]
    (ยง method- #_"void" processTxFromBestChain [#_"Transaction" __tx, #_"boolean" __forceAddToPool]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))
        (Preconditions/checkState (not (.. (:pending this) (containsKey (.. __tx (getHash))))))

        ;; This TX may spend our existing outputs even though it was not pending.  This can happen in unit tests,
        ;; if keys are moved between wallets, if we're catching up to the chain given only a set of keys,
        ;; or if a dead coinbase transaction has moved back onto the main chain.
        (let [#_"boolean" __isDeadCoinbase (and (.. __tx (isCoinBase)) (.. (:dead this) (containsKey (.. __tx (getHash)))))]
            (when __isDeadCoinbase
                ;; There is a dead coinbase tx being received on the best chain.  A coinbase tx is made dead when it moves
                ;; to a side chain but it can be switched back on a reorg and resurrected back to spent or unspent.
                ;; So take it out of the dead pool.  Note that we don't resurrect dependent transactions here, even though
                ;; we could.  Bitcoin Core nodes on the network have deleted the dependent transactions from their mempools
                ;; entirely by this point.  We could and maybe should rebroadcast them so the network remembers and tries
                ;; to confirm them again.  But this is a deeply unusual edge case that due to the maturity rule should never
                ;; happen in practice, thus for simplicities sake we ignore it here.
                (.. Wallet/log (info "  coinbase tx <-dead: confidence {}", (.. __tx (getHashAsString)), (.. __tx (getConfidence) (getConfidenceType) (name))))
                (.. (:dead this) (remove (.. __tx (getHash))))
            )

            ;; Update tx and other unspent/pending transactions by connecting inputs/outputs.
            (.. this (updateForSpends __tx, true))

            ;; Now make sure it ends up in the right pool.  Also, handle the case where this TX is double-spending
            ;; against our pending transactions.  Note that a tx may double spend our pending transactions and also
            ;; send us money/spend our money.
            (let [#_"boolean" __hasOutputsToMe (< 0 (.. __tx (getValueSentToMe this) (signum)))
                  #_"boolean" __hasOutputsFromMe false]
                (cond __hasOutputsToMe
                    (do
                        ;; Needs to go into either unspent or spent (if the outputs were already spent by a pending tx).
                        (cond (.. __tx (isEveryOwnedOutputSpent this))
                            (do
                                (.. Wallet/log (info "  tx {} ->spent (by pending)", (.. __tx (getHashAsString))))
                                (.. this (addWalletTransaction WalletTransaction.Pool/SPENT, __tx))
                            )
                            :else
                            (do
                                (.. Wallet/log (info "  tx {} ->unspent", (.. __tx (getHashAsString))))
                                (.. this (addWalletTransaction WalletTransaction.Pool/UNSPENT, __tx))
                            )
                        )
                    )
                    (< 0 (.. __tx (getValueSentFromMe this) (signum)))
                    (do
                        (ยง ass __hasOutputsFromMe true)
                        ;; Didn't send us any money, but did spend some.  Keep it around for record keeping purposes.
                        (.. Wallet/log (info "  tx {} ->spent", (.. __tx (getHashAsString))))
                        (.. this (addWalletTransaction WalletTransaction.Pool/SPENT, __tx))
                    )
                    __forceAddToPool
                    (do
                        ;; Was manually added to pending, so we should keep it to notify the user of confidence information.
                        (.. Wallet/log (info "  tx {} ->spent (manually added)", (.. __tx (getHashAsString))))
                        (.. this (addWalletTransaction WalletTransaction.Pool/SPENT, __tx))
                    )
                )

                ;; Kill txns in conflict with this tx.
                (let [#_"Set<Transaction>" __doubleSpendTxns (.. this (findDoubleSpendsAgainst __tx, (:pending this)))]
                    (when (not (.. __doubleSpendTxns (isEmpty)))
                        ;; No need to addTransactionsDependingOn(doubleSpendTxns), because killTxns() already kills dependencies.
                        (.. this (killTxns __doubleSpendTxns, __tx))
                    )
                    (when (and (not __hasOutputsToMe) (not __hasOutputsFromMe) (not __forceAddToPool) (not (.. this (findDoubleSpendsAgainst __tx, (:transactions this)) (isEmpty))))
                        ;; Disconnect irrelevant inputs (otherwise might cause protobuf serialization issue).
                        (doseq [#_"TransactionInput" __input (.. __tx (getInputs))]
                            (let [#_"TransactionOutput" __output (.. __input (getConnectedOutput))]
                                (when (and (some? __output) (not (.. __output (isMine this))))
                                    (.. __input (disconnect))
                                )
                            )
                        )
                    )
                    nil
                )
            )
        )
    )

    ;;;
     ; <p>Updates the wallet by checking if this TX spends any of our outputs, and marking them as spent if so.
     ; If fromChain is true, also checks to see if any pending transaction spends outputs of this transaction and marks
     ; the spent flags appropriately.</p>
     ;
     ; <p>It can be called in two contexts.  One is when we receive a transaction on the best chain but it wasn't pending,
     ; this most commonly happens when we have a set of keys but the wallet transactions were wiped and we are catching
     ; up with the block chain.  It can also happen if a block includes a transaction we never saw at broadcast time.
     ; If this tx double spends, it takes precedence over our pending transactions and the pending tx goes dead.</p>
     ;
     ; <p>The other context it can be called is from {@link Wallet#receivePending(Transaction, java.util.List)},
     ; i.e. we saw a tx be broadcast or one was submitted directly that spends our own coins.  If this tx double spends,
     ; it does NOT take precedence because the winner will be resolved by the miners - we assume that our version will
     ; win, if we are wrong then when a block appears the tx will go dead.</p>
     ;
     ; @param tx The transaction which is being updated.
     ; @param fromChain If true, the tx appeared on the current best chain, if false it was pending.
     ;;
    #_private
    #_throws #_[ "VerificationException" ]
    (ยง method- #_"void" updateForSpends [#_"Transaction" __tx, #_"boolean" __fromChain]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))
        (when __fromChain
            (Preconditions/checkState (not (.. (:pending this) (containsKey (.. __tx (getHash))))))
        )

        (doseq [#_"TransactionInput" __input (.. __tx (getInputs))]
            (let [#_"TransactionInput.ConnectionResult" __result (.. __input (connect (:unspent this), TransactionInput.ConnectMode/ABORT_ON_CONFLICT))]
                (when (== __result TransactionInput.ConnectionResult/NO_SUCH_TX)
                    ;; Not found in the unspent map.  Try again with the spent map.
                    (ยง ass __result (.. __input (connect (:spent this), TransactionInput.ConnectMode/ABORT_ON_CONFLICT)))
                    (when (== __result TransactionInput.ConnectionResult/NO_SUCH_TX)
                        ;; Not found in the unspent and spent maps.  Try again with the pending map.
                        (ยง ass __result (.. __input (connect (:pending this), TransactionInput.ConnectMode/ABORT_ON_CONFLICT)))
                        (when (== __result TransactionInput.ConnectionResult/NO_SUCH_TX)
                            ;; Doesn't spend any of our outputs or is coinbase.
                            (ยง continue )
                        )
                    )
                )

                (let [#_"TransactionOutput" __output (Preconditions/checkNotNull (.. __input (getConnectedOutput)))]
                    (cond (== __result TransactionInput.ConnectionResult/ALREADY_SPENT)
                        (do
                            (cond __fromChain
                                (do
                                    ;; Can be:
                                    ;; (1) We already marked this output as spent when we saw the pending transaction (most likely).
                                    ;;     Now it's being confirmed of course, we cannot mark it as spent again.
                                    ;; (2) A double spend from chain: this will be handled later by findDoubleSpendsAgainst()/killTxns().
                                    ;;
                                    ;; In any case, nothing to do here.
                                )
                                :else
                                (do
                                    ;; We saw two pending transactions that double spend each other.  We don't know which will win.
                                    ;; This can happen in the case of bad network nodes that mutate transactions.  Do a hex dump
                                    ;; so the exact nature of the mutation can be examined.
                                    (.. Wallet/log (warn "Saw two pending transactions double spend each other"))
                                    (.. Wallet/log (warn "  offending input is input {}", (.. __tx (getInputs) (indexOf __input))))
                                    (.. Wallet/log (warn "{}: {}", (.. __tx (getHash)), (.. Utils/HEX (encode (.. __tx (unsafeBitcoinSerialize))))))
                                    (let [#_"Transaction" __other (.. __output (getSpentBy) (getParentTransaction))]
                                        (.. Wallet/log (warn "{}: {}", (.. __other (getHash)), (.. Utils/HEX (encode (.. __other (unsafeBitcoinSerialize))))))
                                    )
                                )
                            )
                        )
                        (== __result TransactionInput.ConnectionResult/SUCCESS)
                        (do
                            ;; Otherwise we saw a transaction spend our coins, but we didn't try and spend them ourselves yet.
                            ;; The outputs are already marked as spent by the connect call above, so check if there are any more for
                            ;; us to use.  Move if not.
                            (let [#_"Transaction" __connected (Preconditions/checkNotNull (.. __input (getConnectedTransaction)))]
                                (.. Wallet/log (info "  marked {} as spent by {}", (.. __input (getOutpoint)), (.. __tx (getHashAsString))))
                                (.. this (maybeMovePool __connected, "prevtx"))
                                ;; Just because it's connected, doesn't mean it's actually ours: sometimes we have total visibility.
                                (when (.. __output (isMine this))
                                    (Preconditions/checkState (.. (:my-unspents this) (remove __output)))
                                )
                            )
                        )
                    )
                )
            )
        )

        ;; Now check each output and see if there is a pending transaction which spends it.  This shouldn't normally
        ;; ever occur because we expect transactions to arrive in temporal order, but this assumption can be violated
        ;; when we receive a pending transaction from the mempool that is relevant to us, which spends coins that we
        ;; didn't see arrive on the best chain yet.  For instance, because of a chain replay or because of our keys were
        ;; used by another wallet somewhere else.  Also, unconfirmed transactions can arrive from the mempool in more
        ;; or less random order.
        (doseq [#_"Transaction" __pendingTx (.. (:pending this) (values))]
            (doseq [#_"TransactionInput" __input (.. __pendingTx (getInputs))]
                (let [#_"TransactionInput.ConnectionResult" __result (.. __input (connect __tx, TransactionInput.ConnectMode/ABORT_ON_CONFLICT))]
                    (when __fromChain
                        ;; This TX is supposed to have just appeared on the best chain, so its outputs should not be marked
                        ;; as spent yet.  If they are, it means something is happening out of order.
                        (Preconditions/checkState (!= __result TransactionInput.ConnectionResult/ALREADY_SPENT))
                    )
                    (when (== __result TransactionInput.ConnectionResult/SUCCESS)
                        (.. Wallet/log (info "Connected pending tx input {}:{}", (.. __pendingTx (getHashAsString)), (.. __pendingTx (getInputs) (indexOf __input))))
                        ;; The unspents map might not have it if we never saw this tx until it was included in the chain
                        ;; and thus becomes spent the moment we become aware of it.
                        (when (.. (:my-unspents this) (remove (.. __input (getConnectedOutput))))
                            (.. Wallet/log (info "Removed from UNSPENTS: {}", (.. __input (getConnectedOutput))))
                        )
                    )
                )
            )
        )
        (cond (not __fromChain)
            (do
                (.. this (maybeMovePool __tx, "pendingtx"))
            )
            :else
            (do
                ;; If the transactions outputs are now all spent, it will be moved into the spent pool by the
                ;; processTxFromBestChain method.
            )
        )
        nil
    )

    ;; Updates the wallet when a double spend occurs.  overridingTx can be null for the case of coinbases.
    #_private
    (ยง method- #_"void" killTxns [#_"Set<Transaction>" __txnsToKill, #_nilable #_"Transaction" __overridingTx]
        (let [#_"LinkedList<Transaction>" __work (LinkedList. #_"<>" __txnsToKill)]
            (while (not (.. __work (isEmpty)))
                (let [#_"Transaction" __tx (.. __work (poll))]
                    (.. Wallet/log (warn "TX {} killed{}", (.. __tx (getHashAsString)), (if (some? __overridingTx) (str " by " (.. __overridingTx (getHashAsString))) "")))
                    (.. Wallet/log (warn "Disconnecting each input and moving connected transactions."))
                    ;; TX could be pending (finney attack), or in unspent/spent (coinbase killed by reorg).
                    (.. (:pending this) (remove (.. __tx (getHash))))
                    (.. (:unspent this) (remove (.. __tx (getHash))))
                    (.. (:spent this) (remove (.. __tx (getHash))))
                    (.. this (addWalletTransaction WalletTransaction.Pool/DEAD, __tx))
                    (doseq [#_"TransactionInput" __deadInput (.. __tx (getInputs))]
                        (let [#_"Transaction" __connected (.. __deadInput (getConnectedTransaction))]
                            (when (nil? __connected)
                                (ยง continue )
                            )
                            (when (and (!= (.. __connected (getConfidence) (getConfidenceType)) TransactionConfidence.ConfidenceType/DEAD) (some? (.. __deadInput (getConnectedOutput) (getSpentBy))) (.. __deadInput (getConnectedOutput) (getSpentBy) (equals __deadInput)))
                                (Preconditions/checkState (.. (:my-unspents this) (add (.. __deadInput (getConnectedOutput)))))
                                (.. Wallet/log (info "Added to UNSPENTS: {} in {}", (.. __deadInput (getConnectedOutput)), (.. __deadInput (getConnectedOutput) (getParentTransaction) (getHash))))
                            )
                            (.. __deadInput (disconnect))
                            (.. this (maybeMovePool __connected, "kill"))
                        )
                    )
                    (.. __tx (getConfidence) (setOverridingTransaction __overridingTx))
                    (.. (:confidence-changed this) (put __tx, TransactionConfidence.Listener.ChangeReason/TYPE))
                    ;; Now kill any transactions we have that depended on this one.
                    (doseq [#_"TransactionOutput" __deadOutput (.. __tx (getOutputs))]
                        (when (.. (:my-unspents this) (remove __deadOutput))
                            (.. Wallet/log (info "XX Removed from UNSPENTS: {}", __deadOutput))
                        )
                        (let [#_"TransactionInput" __connected (.. __deadOutput (getSpentBy))]
                            (when (nil? __connected)
                                (ยง continue )
                            )
                            (let [#_"Transaction" __parentTransaction (.. __connected (getParentTransaction))]
                                (.. Wallet/log (info "This death invalidated dependent tx {}", (.. __parentTransaction (getHash))))
                                (.. __work (push __parentTransaction))
                            )
                        )
                    )
                )
            )
            (when (nil? __overridingTx)
                (ยง return nil)
            )

            (.. Wallet/log (warn "Now attempting to connect the inputs of the overriding transaction."))
            (doseq [#_"TransactionInput" __input (.. __overridingTx (getInputs))]
                (let [#_"TransactionInput.ConnectionResult" __result (.. __input (connect (:unspent this), TransactionInput.ConnectMode/DISCONNECT_ON_CONFLICT))]
                    (cond (== __result TransactionInput.ConnectionResult/SUCCESS)
                        (do
                            (.. this (maybeMovePool (.. __input (getConnectedTransaction)), "kill"))
                            (.. (:my-unspents this) (remove (.. __input (getConnectedOutput))))
                            (.. Wallet/log (info "Removing from UNSPENTS: {}", (.. __input (getConnectedOutput))))
                        )
                        :else
                        (do
                            (ยง ass __result (.. __input (connect (:spent this), TransactionInput.ConnectMode/DISCONNECT_ON_CONFLICT)))
                            (when (== __result TransactionInput.ConnectionResult/SUCCESS)
                                (.. this (maybeMovePool (.. __input (getConnectedTransaction)), "kill"))
                                (.. (:my-unspents this) (remove (.. __input (getConnectedOutput))))
                                (.. Wallet/log (info "Removing from UNSPENTS: {}", (.. __input (getConnectedOutput))))
                            )
                        )
                    )
                )
            )
            nil
        )
    )

    ;;;
     ; If the transactions outputs are all marked as spent, and it's in the unspent map, move it.
     ; If the owned transactions outputs are not all marked as spent, and it's in the spent map, move it.
     ;;
    #_private
    (ยง method- #_"void" maybeMovePool [#_"Transaction" __tx, #_"String" __context]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))

        (cond (.. __tx (isEveryOwnedOutputSpent this))
            (do
                ;; There's nothing left I can spend in this transaction.
                (when (some? (.. (:unspent this) (remove (.. __tx (getHash)))))
                    (when (.. Wallet/log (isInfoEnabled))
                        (.. Wallet/log (info "  {} {} <-unspent ->spent", (.. __tx (getHashAsString)), __context))
                    )
                    (.. (:spent this) (put (.. __tx (getHash)), __tx))
                )
            )
            :else
            (do
                (when (some? (.. (:spent this) (remove (.. __tx (getHash)))))
                    (when (.. Wallet/log (isInfoEnabled))
                        (.. Wallet/log (info "  {} {} <-spent ->unspent", (.. __tx (getHashAsString)), __context))
                    )
                    (.. (:unspent this) (put (.. __tx (getHash)), __tx))
                )
            )
        )
        nil
    )

    ;;;
     ; Calls {@link Wallet#commitTx} if tx is not already in the pending pool.
     ;
     ; @return true if the tx was added to the wallet, or false if it was already in the pending pool.
     ;;
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"boolean" maybeCommitTx [#_"Transaction" __tx]
        (.. __tx (verify))
        (.. (:lock this) (lock))
        (try
            (when (.. (:pending this) (containsKey (.. __tx (getHash))))
                (ยง return false)
            )

            (.. Wallet/log (info "commitTx of {}", (.. __tx (getHashAsString))))
            (let [#_"Coin" __balance (.. this (getBalance))]
                (.. __tx (setUpdateTime (Utils/now)))
                ;; Put any outputs that are sending money back to us into the unspents map, and calculate their total value.
                (let [#_"Coin" __valueSentToMe Coin/ZERO]
                    (doseq [#_"TransactionOutput" __o (.. __tx (getOutputs))]
                        (when (.. __o (isMine this))
                            (ยง ass __valueSentToMe (.. __valueSentToMe (add (.. __o (getValue)))))
                        )
                    )
                    ;; Mark the outputs we're spending as spent so we won't try and use them in future creations.  This will also
                    ;; move any transactions that are now fully spent to the spent map so we can skip them when creating future
                    ;; spends.
                    (.. this (updateForSpends __tx, false))

                    (let [#_"Set<Transaction>" __doubleSpendPendingTxns (.. this (findDoubleSpendsAgainst __tx, (:pending this)))
                          #_"Set<Transaction>" __doubleSpendUnspentTxns (.. this (findDoubleSpendsAgainst __tx, (:unspent this)))
                          #_"Set<Transaction>" __doubleSpendSpentTxns (.. this (findDoubleSpendsAgainst __tx, (:spent this)))]

                        (cond (or (not (.. __doubleSpendUnspentTxns (isEmpty))) (not (.. __doubleSpendSpentTxns (isEmpty))) (not (.. this (isNotSpendingTxnsInConfidenceType __tx, TransactionConfidence.ConfidenceType/DEAD))))
                            (do
                                ;; tx is a double spend against a tx already in the best chain or spends outputs of a DEAD tx.
                                ;; Add tx to the dead pool and schedule confidence listener notifications.
                                (.. Wallet/log (info "->dead: {}", (.. __tx (getHashAsString))))
                                (.. __tx (getConfidence) (setConfidenceType TransactionConfidence.ConfidenceType/DEAD))
                                (.. (:confidence-changed this) (put __tx, TransactionConfidence.Listener.ChangeReason/TYPE))
                                (.. this (addWalletTransaction WalletTransaction.Pool/DEAD, __tx))
                            )
                            (or (not (.. __doubleSpendPendingTxns (isEmpty))) (not (.. this (isNotSpendingTxnsInConfidenceType __tx, TransactionConfidence.ConfidenceType/IN_CONFLICT))))
                            (do
                                ;; tx is a double spend against a pending tx or spends outputs of a tx already IN_CONFLICT.
                                ;; Add tx to the pending pool.  Update the confidence type of tx, the txns in conflict with tx
                                ;; and all their dependencies to IN_CONFLICT and schedule confidence listener notifications.
                                (.. Wallet/log (info "->pending (IN_CONFLICT): {}", (.. __tx (getHashAsString))))
                                (.. this (addWalletTransaction WalletTransaction.Pool/PENDING, __tx))
                                (.. __doubleSpendPendingTxns (add __tx))
                                (.. this (addTransactionsDependingOn __doubleSpendPendingTxns, (.. this (getTransactions true))))
                                (doseq [#_"Transaction" __doubleSpendTx __doubleSpendPendingTxns]
                                    (.. __doubleSpendTx (getConfidence) (setConfidenceType TransactionConfidence.ConfidenceType/IN_CONFLICT))
                                    (.. (:confidence-changed this) (put __doubleSpendTx, TransactionConfidence.Listener.ChangeReason/TYPE))
                                )
                            )
                            :else
                            (do
                                ;; No conflict detected.
                                ;; Add to the pending pool and schedule confidence listener notifications.
                                (.. Wallet/log (info "->pending: {}", (.. __tx (getHashAsString))))
                                (.. __tx (getConfidence) (setConfidenceType TransactionConfidence.ConfidenceType/PENDING))
                                (.. (:confidence-changed this) (put __tx, TransactionConfidence.Listener.ChangeReason/TYPE))
                                (.. this (addWalletTransaction WalletTransaction.Pool/PENDING, __tx))
                            )
                        )
                        (when (.. Wallet/log (isInfoEnabled))
                            (.. Wallet/log (info "Estimated balance is now: {}", (.. this (getBalance Wallet.BalanceType/ESTIMATED) (toFriendlyString))))
                        )

                        ;; Mark any keys used in the outputs as "used", this allows wallet UI's to auto-advance the current key
                        ;; they are showing to the user in qr codes etc.
                        (.. this (markKeysAsUsed __tx))
                        (try
                            (let [#_"Coin" __valueSentFromMe (.. __tx (getValueSentFromMe this))
                                  #_"Coin" __newBalance (.. __balance (add __valueSentToMe) (subtract __valueSentFromMe))]
                                (when (< 0 (.. __valueSentToMe (signum)))
                                    (.. this (checkBalanceFuturesLocked nil))
                                    (.. this (queueOnCoinsReceived __tx, __balance, __newBalance))
                                )
                                (when (< 0 (.. __valueSentFromMe (signum)))
                                    (.. this (queueOnCoinsSent __tx, __balance, __newBalance))
                                )

                                (.. this (maybeQueueOnWalletChanged))
                            )
                            (catch ScriptException __e
                                ;; Cannot happen as we just created this transaction ourselves.
                                (throw (RuntimeException. __e))
                            )
                        )

                        (.. this (isConsistentOrThrow))
                        (.. this (informConfidenceListenersIfNotReorganizing))
                        (.. this (saveNow))
                    )
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        true
    )

    ;;;
     ; <p>Updates the wallet with the given transaction: puts it into the pending pool, sets the spent flags
     ; and runs the onCoinsSent/onCoinsReceived event listener.  Used in two situations:</p>
     ;
     ; <ol>
     ;     <li>When we have just successfully transmitted the tx we created to the network.</li>
     ;     <li>When we receive a pending transaction that didn't appear in the chain yet, and we did not create it.</li>
     ; </ol>
     ;
     ; <p>Triggers an auto save.</p>
     ;;
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"void" commitTx [#_"Transaction" __tx]
        (Preconditions/checkArgument (.. this (maybeCommitTx __tx)), "commitTx called on the same transaction twice")
        nil
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  Runs the listener methods in the user thread.
     ;;
    #_public
    (ยง method #_"void" addChangeEventListener [#_"WalletChangeEventListener" __listener]
        (.. this (addChangeEventListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  The listener is executed by the given executor.
     ;;
    #_public
    (ยง method #_"void" addChangeEventListener [#_"Executor" __executor, #_"WalletChangeEventListener" __listener]
        ;; This is thread safe, so we don't need to take the lock.
        (.. (:change-listeners this) (add (ListenerRegistration. #_"<>" __listener, __executor)))
        nil
    )

    ;;;
     ; Adds an event listener object called when coins are received.
     ; Runs the listener methods in the user thread.
     ;;
    #_public
    (ยง method #_"void" addCoinsReceivedEventListener [#_"WalletCoinsReceivedEventListener" __listener]
        (.. this (addCoinsReceivedEventListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;;
     ; Adds an event listener object called when coins are received.
     ; The listener is executed by the given executor.
     ;;
    #_public
    (ยง method #_"void" addCoinsReceivedEventListener [#_"Executor" __executor, #_"WalletCoinsReceivedEventListener" __listener]
        ;; This is thread safe, so we don't need to take the lock.
        (.. (:coins-received-listeners this) (add (ListenerRegistration. #_"<>" __listener, __executor)))
        nil
    )

    ;;;
     ; Adds an event listener object called when coins are sent.
     ; Runs the listener methods in the user thread.
     ;;
    #_public
    (ยง method #_"void" addCoinsSentEventListener [#_"WalletCoinsSentEventListener" __listener]
        (.. this (addCoinsSentEventListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;;
     ; Adds an event listener object called when coins are sent.
     ; The listener is executed by the given executor.
     ;;
    #_public
    (ยง method #_"void" addCoinsSentEventListener [#_"Executor" __executor, #_"WalletCoinsSentEventListener" __listener]
        ;; This is thread safe, so we don't need to take the lock.
        (.. (:coins-sent-listeners this) (add (ListenerRegistration. #_"<>" __listener, __executor)))
        nil
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when keys are
     ; added.  The listener is executed in the user thread.
     ;;
    #_public
    (ยง method #_"void" addKeyChainEventListener [#_"KeyChainEventListener" __listener]
        (.. (:key-chain-group this) (addEventListener __listener, Threading/USER_THREAD))
        nil
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when keys are
     ; added.  The listener is executed by the given executor.
     ;;
    #_public
    (ยง method #_"void" addKeyChainEventListener [#_"Executor" __executor, #_"KeyChainEventListener" __listener]
        (.. (:key-chain-group this) (addEventListener __listener, __executor))
        nil
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  Runs the listener methods in the user thread.
     ;;
    #_public
    (ยง method #_"void" addReorganizeEventListener [#_"WalletReorganizeEventListener" __listener]
        (.. this (addReorganizeEventListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  The listener is executed by the given executor.
     ;;
    #_public
    (ยง method #_"void" addReorganizeEventListener [#_"Executor" __executor, #_"WalletReorganizeEventListener" __listener]
        ;; This is thread safe, so we don't need to take the lock.
        (.. (:reorganize-listeners this) (add (ListenerRegistration. #_"<>" __listener, __executor)))
        nil
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when confidence
     ; of a transaction changes.  Runs the listener methods in the user thread.
     ;;
    #_public
    (ยง method #_"void" addTransactionConfidenceEventListener [#_"TransactionConfidenceEventListener" __listener]
        (.. this (addTransactionConfidenceEventListener Threading/USER_THREAD, __listener))
        nil
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when confidence
     ; of a transaction changes.  The listener is executed by the given executor.
     ;;
    #_public
    (ยง method #_"void" addTransactionConfidenceEventListener [#_"Executor" __executor, #_"TransactionConfidenceEventListener" __listener]
        ;; This is thread safe, so we don't need to take the lock.
        (.. (:transaction-confidence-listeners this) (add (ListenerRegistration. #_"<>" __listener, __executor)))
        nil
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (ยง method #_"boolean" removeChangeEventListener [#_"WalletChangeEventListener" __listener]
        (ListenerRegistration/removeFromList __listener, (:change-listeners this))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (ยง method #_"boolean" removeCoinsReceivedEventListener [#_"WalletCoinsReceivedEventListener" __listener]
        (ListenerRegistration/removeFromList __listener, (:coins-received-listeners this))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (ยง method #_"boolean" removeCoinsSentEventListener [#_"WalletCoinsSentEventListener" __listener]
        (ListenerRegistration/removeFromList __listener, (:coins-sent-listeners this))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (ยง method #_"boolean" removeKeyChainEventListener [#_"KeyChainEventListener" __listener]
        (.. (:key-chain-group this) (removeEventListener __listener))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (ยง method #_"boolean" removeReorganizeEventListener [#_"WalletReorganizeEventListener" __listener]
        (ListenerRegistration/removeFromList __listener, (:reorganize-listeners this))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (ยง method #_"boolean" removeTransactionConfidenceEventListener [#_"TransactionConfidenceEventListener" __listener]
        (ListenerRegistration/removeFromList __listener, (:transaction-confidence-listeners this))
    )

    #_private
    (ยง method- #_"void" queueOnTransactionConfidenceChanged [#_"Transaction" __tx]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))

        (doseq [#_"ListenerRegistration<TransactionConfidenceEventListener>" __registration (:transaction-confidence-listeners this)]
            (cond (== (:executor __registration) Threading/SAME_THREAD)
                (do
                    (.. (:listener __registration) (onTransactionConfidenceChanged this, __tx))
                )
                :else
                (do
                    (.. (:executor __registration) (execute (Runnable.)
                    (ยง anon
                        #_override
                        #_public
                        (ยง method #_"void" run []
                            (.. (:listener __registration) (onTransactionConfidenceChanged (ยง dhis Wallet), __tx))
                            nil
                        )
                    )))
                )
            )
        )
        nil
    )

    #_protected
    (ยง method #_"void" maybeQueueOnWalletChanged []
        ;; Don't invoke the callback in some circumstances, e.g. whilst we are re-organizing or fiddling
        ;; with transactions due to a new block arriving.  It will be called later instead.
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))
        (Preconditions/checkState (<= 0 (:on-wallet-changed-suppressions this)))

        (when (< 0 (:on-wallet-changed-suppressions this))
            (ยง return nil)
        )

        (doseq [#_"ListenerRegistration<WalletChangeEventListener>" __registration (:change-listeners this)]
            (.. (:executor __registration) (execute (Runnable.)
            (ยง anon
                #_override
                #_public
                (ยง method #_"void" run []
                    (.. (:listener __registration) (onWalletChanged (ยง dhis Wallet)))
                    nil
                )
            )))
        )
        nil
    )

    #_protected
    (ยง method #_"void" queueOnCoinsReceived [#_"Transaction" __tx, #_"Coin" __balance, #_"Coin" __newBalance]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))

        (doseq [#_"ListenerRegistration<WalletCoinsReceivedEventListener>" __registration (:coins-received-listeners this)]
            (.. (:executor __registration) (execute (Runnable.)
            (ยง anon
                #_override
                #_public
                (ยง method #_"void" run []
                    (.. (:listener __registration) (onCoinsReceived (ยง dhis Wallet), __tx, __balance, __newBalance))
                    nil
                )
            )))
        )
        nil
    )

    #_protected
    (ยง method #_"void" queueOnCoinsSent [#_"Transaction" __tx, #_"Coin" __prevBalance, #_"Coin" __newBalance]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))

        (doseq [#_"ListenerRegistration<WalletCoinsSentEventListener>" __registration (:coins-sent-listeners this)]
            (.. (:executor __registration) (execute (Runnable.)
            (ยง anon
                #_override
                #_public
                (ยง method #_"void" run []
                    (.. (:listener __registration) (onCoinsSent (ยง dhis Wallet), __tx, __prevBalance, __newBalance))
                    nil
                )
            )))
        )
        nil
    )

    #_protected
    (ยง method #_"void" queueOnReorganize []
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))
        (Preconditions/checkState (:inside-reorg this))

        (doseq [#_"ListenerRegistration<WalletReorganizeEventListener>" __registration (:reorganize-listeners this)]
            (.. (:executor __registration) (execute (Runnable.)
            (ยง anon
                #_override
                #_public
                (ยง method #_"void" run []
                    (.. (:listener __registration) (onReorganize (ยง dhis Wallet)))
                    nil
                )
            )))
        )
        nil
    )

    ;;;
     ; Returns a set of all transactions in the wallet.
     ; @param includeDead If true, transactions that were overridden by a double spend are included.
     ;;
    #_public
    (ยง method #_"Set<Transaction>" getTransactions [#_"boolean" __includeDead]
        (.. (:lock this) (lock))
        (try
            (let [#_"Set<Transaction>" __all (HashSet. #_"<>")]
                (.. __all (addAll (.. (:unspent this) (values))))
                (.. __all (addAll (.. (:spent this) (values))))
                (.. __all (addAll (.. (:pending this) (values))))
                (when __includeDead
                    (.. __all (addAll (.. (:dead this) (values))))
                )
                (ยง return __all)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns a set of all WalletTransactions in the wallet.
     ;;
    #_public
    (ยง method #_"Iterable<WalletTransaction>" getWalletTransactions []
        (.. (:lock this) (lock))
        (try
            (let [#_"Set<WalletTransaction>" __all (HashSet. #_"<>")]
                (Wallet/addWalletTransactionsToSet __all, WalletTransaction.Pool/UNSPENT, (.. (:unspent this) (values)))
                (Wallet/addWalletTransactionsToSet __all, WalletTransaction.Pool/SPENT, (.. (:spent this) (values)))
                (Wallet/addWalletTransactionsToSet __all, WalletTransaction.Pool/DEAD, (.. (:dead this) (values)))
                (Wallet/addWalletTransactionsToSet __all, WalletTransaction.Pool/PENDING, (.. (:pending this) (values)))
                (ยง return __all)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_private
    #_static
    (ยง defn- #_"void" Wallet/addWalletTransactionsToSet [#_"Set<WalletTransaction>" __txns, #_"WalletTransaction.Pool" __poolType, #_"Collection<Transaction>" __pool]
        (doseq [#_"Transaction" __tx __pool]
            (.. __txns (add (WalletTransaction. __poolType, __tx)))
        )
        nil
    )

    ;;;
     ; Adds a transaction that has been associated with a particular wallet pool.  This is intended for usage by
     ; deserialization code, such as the {@link WalletProtobufSerializer} class.  It isn't normally useful for
     ; applications.  It does not trigger auto saving.
     ;;
    #_public
    (ยง method #_"void" addWalletTransaction [#_"WalletTransaction" __wtx]
        (.. (:lock this) (lock))
        (try
            (.. this (addWalletTransaction (.. __wtx (getPool)), (.. __wtx (getTransaction))))
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Adds the given transaction to the given pools and registers a confidence change listener on it.
     ;;
    #_private
    (ยง method- #_"void" addWalletTransaction [#_"WalletTransaction.Pool" __pool, #_"Transaction" __tx]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))

        (.. (:transactions this) (put (.. __tx (getHash)), __tx))
        (condp == __pool
            UNSPENT (Preconditions/checkState (nil? (.. (:unspent this) (put (.. __tx (getHash)), __tx))))
            SPENT   (Preconditions/checkState (nil? (.. (:spent this) (put (.. __tx (getHash)), __tx))))
            PENDING (Preconditions/checkState (nil? (.. (:pending this) (put (.. __tx (getHash)), __tx))))
            DEAD    (Preconditions/checkState (nil? (.. (:dead this) (put (.. __tx (getHash)), __tx))))
            (throw (RuntimeException. (str "Unknown wallet transaction type " __pool)))
        )

        (when (any == __pool WalletTransaction.Pool/UNSPENT WalletTransaction.Pool/PENDING)
            (doseq [#_"TransactionOutput" __output (.. __tx (getOutputs))]
                (when (and (.. __output (isAvailableForSpending)) (.. __output (isMine this)))
                    (.. (:my-unspents this) (add __output))
                )
            )
        )
        ;; This is safe even if the listener has been added before, as TransactionConfidence ignores duplicate
        ;; registration requests.  That makes the code in the wallet simpler.
        (.. __tx (getConfidence) (addEventListener Threading/SAME_THREAD, (:tx-confidence-listener this)))
        nil
    )

    ;;;
     ; Returns all non-dead, active transactions ordered by recency.
     ;;
    #_public
    (ยง method #_"List<Transaction>" getTransactionsByTime []
        (.. this (getRecentTransactions 0, false))
    )

    ;;;
     ; Returns an list of N transactions, ordered by increasing age.  Transactions on side chains are not included.
     ; Dead transactions (overridden by double spends) are optionally included.
     ;
     ; Note: the current implementation is O(num transactions in wallet).  Regardless of how many transactions are
     ; requested, the cost is always the same.  In future, requesting smaller numbers of transactions may be faster
     ; depending on how the wallet is implemented (e.g. if backed by a database).
     ;;
    #_public
    (ยง method #_"List<Transaction>" getRecentTransactions [#_"int" __numTransactions, #_"boolean" __includeDead]
        (.. (:lock this) (lock))
        (try
            (Preconditions/checkArgument (<= 0 __numTransactions))

            ;; Firstly, put all transactions into an array.
            (let [#_"int" __size (+ (.. (:unspent this) (size)) (.. (:spent this) (size)) (.. (:pending this) (size)))]
                (when (or (< __size __numTransactions) (== __numTransactions 0))
                    (ยง ass __numTransactions __size)
                )

                (let [#_"ArrayList<Transaction>" __all (ArrayList. #_"<>" (.. this (getTransactions __includeDead)))]
                    ;; Order by update time.
                    (Collections/sort __all, Transaction/SORT_TX_BY_UPDATE_TIME)
                    (when (== __numTransactions (.. __all (size)))
                        (ยง return __all)
                    )

                    (.. __all (subList __numTransactions, (.. __all (size))) (clear))
                    (ยง return __all)
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns a transaction object given its hash, if it exists in this wallet, or null otherwise.
     ;;
    #_nilable
    #_public
    (ยง method #_"Transaction" getTransaction [#_"Sha256Hash" __hash]
        (.. (:lock this) (lock))
        (try
            (.. (:transactions this) (get __hash))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (ยง method #_"Map<Sha256Hash, Transaction>" getTransactionPool [#_"WalletTransaction.Pool" __pool]
        (.. (:lock this) (lock))
        (try
            (condp == __pool
                UNSPENT (:unspent this)
                SPENT   (:spent this)
                PENDING (:pending this)
                DEAD    (:dead this)
                (throw (RuntimeException. (str "Unknown wallet transaction type " __pool)))
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Prepares the wallet for a blockchain replay.  Removes all transactions (as they would
     ; get in the way of the replay) and makes the wallet think it has never seen a block.
     ;;
    #_public
    (ยง method #_"void" reset []
        (.. (:lock this) (lock))
        (try
            (.. this (clearTransactions))
            (ยง assoc this :last-block-seen-hash nil)
            (ยง assoc this :last-block-seen-height -1) ;; Magic value for 'never'.
            (ยง assoc this :last-block-seen-time-secs 0)
            (.. this (saveLater))
            (.. this (maybeQueueOnWalletChanged))
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Deletes transactions which appeared above the given block height from the wallet, but does not touch the keys.
     ; This is useful if you have some keys and wish to replay the block chain into the wallet in order to pick them up.
     ; Triggers auto saving.
     ;;
    #_public
    (ยง method #_"void" clearTransactions [#_"int" __fromHeight]
        (.. (:lock this) (lock))
        (try
            (cond (== __fromHeight 0)
                (do
                    (.. this (clearTransactions))
                    (.. this (saveLater))
                )
                :else
                (do
                    (throw (UnsupportedOperationException.))
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    #_private
    (ยง method- #_"void" clearTransactions []
        (.. (:unspent this) (clear))
        (.. (:spent this) (clear))
        (.. (:pending this) (clear))
        (.. (:dead this) (clear))
        (.. (:transactions this) (clear))
        (.. (:my-unspents this) (clear))
        nil
    )

    ;;;
     ; Clean up the wallet.  Currently, it only removes risky pending transaction from the wallet and only
     ; if their outputs have not been spent.
     ;;
    #_public
    (ยง method #_"void" cleanup []
        (.. (:lock this) (lock))
        (try
            (let [#_"boolean" __dirty false]
                (loop-when-recur [#_"Iterator<Transaction>" __i (.. (:pending this) (values) (iterator))] (.. __i (hasNext)) []
                    (let [#_"Transaction" __tx (.. __i (next))]
                        (when (and (.. this (isTransactionRisky __tx, nil)) (not (:accept-risky-transactions this)))
                            (.. Wallet/log (debug "Found risky transaction {} in wallet during cleanup.", (.. __tx (getHashAsString))))
                            (cond (not (.. __tx (isAnyOutputSpent)))
                                (do
                                    ;; Sync myUnspents with the change.
                                    (doseq [#_"TransactionInput" __input (.. __tx (getInputs))]
                                        (let [#_"TransactionOutput" __output (.. __input (getConnectedOutput))]
                                            (when (nil? __output)
                                                (ยง continue )
                                            )
                                            (when (.. __output (isMine this))
                                                (Preconditions/checkState (.. (:my-unspents this) (add __output)))
                                            )
                                            (.. __input (disconnect))
                                        )
                                    )
                                    (doseq [#_"TransactionOutput" __output (.. __tx (getOutputs))]
                                        (.. (:my-unspents this) (remove __output))
                                    )

                                    (.. __i (remove))
                                    (.. (:transactions this) (remove (.. __tx (getHash))))
                                    (ยง ass __dirty true)
                                    (.. Wallet/log (info "Removed transaction {} from pending pool during cleanup.", (.. __tx (getHashAsString))))
                                )
                                :else
                                (do
                                    (.. Wallet/log (info "Cannot remove transaction {} from pending pool during cleanup, as it's already spent partially.", (.. __tx (getHashAsString))))
                                )
                            )
                        )
                    )
                )
                (when __dirty
                    (.. this (isConsistentOrThrow))
                    (.. this (saveLater))
                    (when (.. Wallet/log (isInfoEnabled))
                        (.. Wallet/log (info "Estimated balance is now: {}", (.. this (getBalance Wallet.BalanceType/ESTIMATED) (toFriendlyString))))
                    )
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    (ยง method #_"EnumSet<WalletTransaction.Pool>" getContainingPools [#_"Transaction" __tx]
        (.. (:lock this) (lock))
        (try
            (let [#_"EnumSet<WalletTransaction.Pool>" __result (EnumSet/noneOf WalletTransaction.Pool)
                  #_"Sha256Hash" __txHash (.. __tx (getHash))]
                (when (.. (:unspent this) (containsKey __txHash))
                    (.. __result (add WalletTransaction.Pool/UNSPENT))
                )
                (when (.. (:spent this) (containsKey __txHash))
                    (.. __result (add WalletTransaction.Pool/SPENT))
                )
                (when (.. (:pending this) (containsKey __txHash))
                    (.. __result (add WalletTransaction.Pool/PENDING))
                )
                (when (.. (:dead this) (containsKey __txHash))
                    (.. __result (add WalletTransaction.Pool/DEAD))
                )
                (ยง return __result)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;; Returns a copy of the internal unspent outputs list. ;;
    #_public
    (ยง method #_"List<TransactionOutput>" getUnspents []
        (.. (:lock this) (lock))
        (try
            (ArrayList. #_"<>" (:my-unspents this))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_override
    #_public
    (ยง method #_"String" toString []
        (.. this (toString false, true, nil))
    )

    ;;;
     ; Formats the wallet as a human readable piece of text.  Intended for debugging, the format is
     ; not meant to be stable or human readable.
     ; @param includePrivateKeys Whether raw private key data should be included.
     ; @param includeTransactions Whether to print transaction data.
     ; @param chain If set, will be used to estimate lock times for block timelocked transactions.
     ;;
    #_public
    (ยง method #_"String" toString [#_"boolean" __includePrivateKeys, #_"boolean" __includeTransactions, #_nilable #_"AbstractBlockChain" __chain]
        (.. (:lock this) (lock))
        (.. (:key-chain-group-lock this) (lock))
        (try
            (let [#_"StringBuilder" __sb (StringBuilder.)
                  #_"Coin" __estimatedBalance (.. this (getBalance Wallet.BalanceType/ESTIMATED))
                  #_"Coin" __availableBalance (.. this (getBalance Wallet.BalanceType/AVAILABLE_SPENDABLE))]
                (.. __sb (append "Wallet containing ") (append (.. __estimatedBalance (toFriendlyString))) (append " (spendable: ") (append (.. __availableBalance (toFriendlyString))) (append ") in:\n"))
                (.. __sb (append "  ") (append (.. (:pending this) (size))) (append " pending transactions\n"))
                (.. __sb (append "  ") (append (.. (:unspent this) (size))) (append " unspent transactions\n"))
                (.. __sb (append "  ") (append (.. (:spent this) (size))) (append " spent transactions\n"))
                (.. __sb (append "  ") (append (.. (:dead this) (size))) (append " dead transactions\n"))
                (let [#_"Date" __lastBlockSeenTime (.. this (getLastBlockSeenTime))]
                    (.. __sb (append "Last seen best block: ") (append (.. this (getLastBlockSeenHeight))) (append " (") (append (if (some? __lastBlockSeenTime) (Utils/dateTimeFormat __lastBlockSeenTime) "time unknown")) (append "): ") (append (.. this (getLastBlockSeenHash))) (append "\n"))
                    (let [#_"KeyCrypter" __crypter (.. (:key-chain-group this) (getKeyCrypter))]
                        (when (some? __crypter)
                            (.. __sb (append "Encryption: ") (append __crypter) (append "\n"))
                        )
                        (when (.. this (isWatching))
                            (.. __sb (append "Wallet is watching.\n"))
                        )

                        ;; Do the keys.
                        (.. __sb (append "\nKeys:\n"))
                        (.. __sb (append "Earliest creation time: ") (append (Utils/dateTimeFormat (* (.. this (getEarliestKeyCreationTime)) 1000))) (append "\n"))
                        (let [#_"Date" __keyRotationTime (.. this (getKeyRotationTime))]
                            (when (some? __keyRotationTime)
                                (.. __sb (append "Key rotation time:      ") (append (Utils/dateTimeFormat __keyRotationTime)) (append "\n"))
                            )
                            (.. __sb (append (.. (:key-chain-group this) (toString __includePrivateKeys))))

                            (when __includeTransactions
                                ;; Print the transactions themselves.
                                (when (< 0 (.. (:pending this) (size)))
                                    (.. __sb (append "\n>>> PENDING:\n"))
                                    (.. this (toStringHelper __sb, (:pending this), __chain, Transaction/SORT_TX_BY_UPDATE_TIME))
                                )
                                (when (< 0 (.. (:unspent this) (size)))
                                    (.. __sb (append "\n>>> UNSPENT:\n"))
                                    (.. this (toStringHelper __sb, (:unspent this), __chain, Transaction/SORT_TX_BY_HEIGHT))
                                )
                                (when (< 0 (.. (:spent this) (size)))
                                    (.. __sb (append "\n>>> SPENT:\n"))
                                    (.. this (toStringHelper __sb, (:spent this), __chain, Transaction/SORT_TX_BY_HEIGHT))
                                )
                                (when (< 0 (.. (:dead this) (size)))
                                    (.. __sb (append "\n>>> DEAD:\n"))
                                    (.. this (toStringHelper __sb, (:dead this), __chain, Transaction/SORT_TX_BY_UPDATE_TIME))
                                )
                            )
                            (ยง return (.. __sb (toString)))
                        )
                    )
                )
            )
            (finally
                (.. (:key-chain-group-lock this) (unlock))
                (.. (:lock this) (unlock))
            )
        )
    )

    #_private
    (ยง method- #_"void" toStringHelper [#_"StringBuilder" __sb, #_"Map<Sha256Hash, Transaction>" __transactionMap, #_nilable #_"AbstractBlockChain" __chain, #_nilable #_"Comparator<Transaction>" __sortOrder]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))

        (let [#_"Collection<Transaction>" __txns]
            (cond (some? __sortOrder)
                (do
                    (ยง ass __txns (TreeSet. #_"<>" __sortOrder))
                    (.. __txns (addAll (.. __transactionMap (values))))
                )
                :else
                (do
                    (ยง ass __txns (.. __transactionMap (values)))
                )
            )

            (doseq [#_"Transaction" __tx __txns]
                (try
                    (.. __sb (append (.. __tx (getValue this) (toFriendlyString))))
                    (.. __sb (append " total value (sends "))
                    (.. __sb (append (.. __tx (getValueSentFromMe this) (toFriendlyString))))
                    (.. __sb (append " and receives "))
                    (.. __sb (append (.. __tx (getValueSentToMe this) (toFriendlyString))))
                    (.. __sb (append ")\n"))
                    (catch ScriptException _
                        ;; Ignore and don't print this line.
                    )
                )
                (when (.. __tx (hasConfidence))
                    (.. __sb (append "  confidence: ") (append (.. __tx (getConfidence))) (append "\n"))
                )
                (.. __sb (append (.. __tx (toString __chain))))
            )
            nil
        )
    )

    ;;;
     ; Returns an immutable view of the transactions currently waiting for network confirmations.
     ;;
    #_public
    (ยง method #_"Collection<Transaction>" getPendingTransactions []
        (.. (:lock this) (lock))
        (try
            (Collections/unmodifiableCollection (.. (:pending this) (values)))
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns the earliest creation time of keys or watched scripts in this wallet, in seconds since the epoch,
     ; i.e. the min of {@link org.bitcoinj.core.ECKey#getCreationTimeSeconds()}.  This can return zero if at least
     ; one key does not have that data (was created before key timestamping was implemented).
     ;
     ; This method is most often used in conjunction with {@link PeerGroup#setFastCatchupTimeSecs(long)} in order to
     ; optimize chain download for new users of wallet apps.  Backwards compatibility notice: if you get zero from this
     ; method, you can instead use the time of the first release of your software, as it's guaranteed no users will
     ; have wallets pre-dating this time.
     ;
     ; If there are no keys in the wallet, the current time is returned.
     ;;
    #_override
    #_public
    (ยง method #_"long" getEarliestKeyCreationTime []
        (.. (:key-chain-group-lock this) (lock))
        (try
            (let [#_"long" __earliestTime (.. (:key-chain-group this) (getEarliestKeyCreationTime))]
                (ยง return (if (== __earliestTime Long/MAX_VALUE) (Utils/currentTimeSeconds) __earliestTime))
            )
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    ;;; Returns the hash of the last seen best-chain block, or null if the wallet is too old to store this data. ;;
    #_nilable
    #_public
    (ยง method #_"Sha256Hash" getLastBlockSeenHash []
        (.. (:lock this) (lock))
        (try
            (:last-block-seen-hash this)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_public
    (ยง method #_"void" setLastBlockSeenHash [#_nilable #_"Sha256Hash" __lastBlockSeenHash]
        (.. (:lock this) (lock))
        (try
            (ยง assoc this :last-block-seen-hash __lastBlockSeenHash)
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    #_public
    (ยง method #_"void" setLastBlockSeenHeight [#_"int" __lastBlockSeenHeight]
        (.. (:lock this) (lock))
        (try
            (ยง assoc this :last-block-seen-height __lastBlockSeenHeight)
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    #_public
    (ยง method #_"void" setLastBlockSeenTimeSecs [#_"long" __timeSecs]
        (.. (:lock this) (lock))
        (try
            (ยง assoc this :last-block-seen-time-secs __timeSecs)
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Returns the UNIX time in seconds since the epoch extracted from the last best seen block header.  This timestamp
     ; is <b>not</b> the local time at which the block was first observed by this application but rather what the block
     ; (i.e. miner) self declares.  It is allowed to have some significant drift from the real time at which the block
     ; was found, although most miners do use accurate times.  If this wallet is old and does not have a recorded
     ; time then this method returns zero.
     ;;
    #_public
    (ยง method #_"long" getLastBlockSeenTimeSecs []
        (.. (:lock this) (lock))
        (try
            (:last-block-seen-time-secs this)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns a {@link Date} representing the time extracted from the last best seen block header.  This timestamp
     ; is <b>not</b> the local time at which the block was first observed by this application but rather what the block
     ; (i.e. miner) self declares.  It is allowed to have some significant drift from the real time at which the block
     ; was found, although most miners do use accurate times.  If this wallet is old and does not have a recorded
     ; time then this method returns null.
     ;;
    #_nilable
    #_public
    (ยง method #_"Date" getLastBlockSeenTime []
        (let [#_"long" __secs (.. this (getLastBlockSeenTimeSecs))]
            (if (== __secs 0) nil (Date. (* __secs 1000)))
        )
    )

    ;;;
     ; Returns the height of the last seen best-chain block.  Can be 0 if a wallet is brand new or -1 if the wallet
     ; is old and doesn't have that data.
     ;;
    #_public
    (ยง method #_"int" getLastBlockSeenHeight []
        (.. (:lock this) (lock))
        (try
            (:last-block-seen-height this)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Get the version of the Wallet.
     ; This is an int you can use to indicate which versions of wallets your code understands,
     ; and which come from the future (and hence cannot be safely loaded).
     ;;
    #_public
    (ยง method #_"int" getVersion []
        (:version this)
    )

    ;;;
     ; Set the version number of the wallet.  See {@link Wallet#getVersion()}.
     ;;
    #_public
    (ยง method #_"void" setVersion [#_"int" __version]
        (ยง assoc this :version __version)
        nil
    )

    ;;;
     ; Set the description of the wallet.
     ; This is a Unicode encoding string typically entered by the user as descriptive text for the wallet.
     ;;
    #_public
    (ยง method #_"void" setDescription [#_"String" __description]
        (ยง assoc this :description __description)
        nil
    )

    ;;;
     ; Get the description of the wallet.  See {@link Wallet#setDescription(String)}.
     ;;
    #_public
    (ยง method #_"String" getDescription []
        (:description this)
    )

    ;;;
     ; <p>It's possible to calculate a wallets balance from multiple points of view.  This enum selects which
     ; {@link #getBalance(BalanceType)} should use.</p>
     ;
     ; <p>Consider a real-world example: you buy a snack costing $5 but you only have a $10 bill.  At the start
     ; you have $10 viewed from every possible angle.  After you order the snack you hand over your $10 bill.
     ; From the perspective of your wallet you have zero dollars (AVAILABLE).  But you know in a few seconds the
     ; shopkeeper will give you back $5 change so most people in practice would say they have $5 (ESTIMATED).</p>
     ;
     ; <p>The fact that the wallet can track transactions which are not spendable by itself ("watching wallets")
     ; adds another type of balance to the mix.  Although the wallet won't do this by default, advanced use cases
     ; that override the relevancy checks can end up with a mix of spendable and unspendable transactions.</p>
     ;;
    #_public
    (ยง enum Wallet.BalanceType
        ;;;
         ; Balance calculated assuming all pending transactions are in fact included into the best chain by miners.
         ; This includes the value of immature coinbase transactions.
         ;;
        (ยง item ESTIMATED)

        ;;;
         ; Balance that could be safely used to create new spends, if we had all the needed private keys.  This is
         ; whatever the default coin selector would make available, which by default means transaction outputs with at
         ; least 1 confirmation and pending transactions created by our own wallet which have been propagated across
         ; the network.  Whether we <i>actually</i> have the private keys or not is irrelevant for this balance type.
         ;;
        (ยง item AVAILABLE)

        ;;; Same as ESTIMATED but only for outputs we have the private keys for and can sign ourselves. ;;
        (ยง item ESTIMATED_SPENDABLE)
        ;;; Same as AVAILABLE but only for outputs we have the private keys for and can sign ourselves. ;;
        (ยง item AVAILABLE_SPENDABLE)
    )

    ;;;
     ; Returns the AVAILABLE balance of this wallet.
     ; See {@link BalanceType#AVAILABLE} for details on what this means.
     ;;
    #_public
    (ยง method #_"Coin" getBalance []
        (.. this (getBalance Wallet.BalanceType/AVAILABLE))
    )

    ;;;
     ; Returns the balance of this wallet as calculated by the provided balanceType.
     ;;
    #_public
    (ยง method #_"Coin" getBalance [#_"Wallet.BalanceType" __balanceType]
        (.. (:lock this) (lock))
        (try
            (cond (any == __balanceType Wallet.BalanceType/AVAILABLE Wallet.BalanceType/AVAILABLE_SPENDABLE)
                (do
                    (let [#_"List<TransactionOutput>" __candidates (.. this (calculateAllSpendCandidates true, (== __balanceType Wallet.BalanceType/AVAILABLE_SPENDABLE)))
                          #_"CoinSelection" __selection (.. (:coin-selector this) (select NetworkParameters/MAX_MONEY, __candidates))]
                        (ยง return (:value-gathered __selection))
                    )
                )
                (any == __balanceType Wallet.BalanceType/ESTIMATED Wallet.BalanceType/ESTIMATED_SPENDABLE)
                (do
                    (let [#_"List<TransactionOutput>" __all (.. this (calculateAllSpendCandidates false, (== __balanceType Wallet.BalanceType/ESTIMATED_SPENDABLE)))
                          #_"Coin" __value Coin/ZERO]
                        (doseq [#_"TransactionOutput" __out __all]
                            (ยง ass __value (.. __value (add (.. __out (getValue)))))
                        )
                        (ยง return __value)
                    )
                )
                :else
                (do
                    (throw (AssertionError. "Unknown balance type")) ;; Unreachable.
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns the balance that would be considered spendable by the given coin selector, including watched outputs
     ; (i.e. balance includes outputs we don't have the private keys for).  Just asks it to select as many coins as
     ; possible and returns the total.
     ;;
    #_public
    (ยง method #_"Coin" getBalance [#_"CoinSelector" __selector]
        (.. (:lock this) (lock))
        (try
            (Preconditions/checkNotNull __selector)

            (let [#_"List<TransactionOutput>" __candidates (.. this (calculateAllSpendCandidates true, false))
                  #_"CoinSelection" __selection (.. __selector (select (.. (:params this) (getMaxMoney)), __candidates))]
                (ยง return (:value-gathered __selection))
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    #_private
    #_static
    (ยง class- Wallet.BalanceFutureRequest
        #_public
        (ยง field #_"SettableFuture<Coin>" :future)
        #_public
        (ยง field #_"Coin" :value)
        #_public
        (ยง field #_"Wallet.BalanceType" :type)
    )
    #_private
    (ยง field- #_"List<Wallet.BalanceFutureRequest>" :balance-future-requests (Lists/newLinkedList))

    ;;;
     ; <p>Returns a future that will complete when the balance of the given type has become equal or larger to the
     ; given value.  If the wallet already has a large enough balance the future is returned in a pre-completed state.
     ; Note that this method is not blocking, if you want to actually wait immediately, you have to call .get() on
     ; the result.</p>
     ;
     ; <p>Also note that by the time the future completes, the wallet may have changed yet again if something else
     ; is going on in parallel, so you should treat the returned balance as advisory and be prepared for sending
     ; money to fail!  Finally please be aware that any listeners on the future will run either on the calling thread
     ; if it completes immediately, or eventually on a background thread if the balance is not yet at the right
     ; level.  If you do something that means you know the balance should be sufficient to trigger the future,
     ; you can use {@link org.bitcoinj.utils.Threading#waitForUserCode()} to block until the future had a
     ; chance to be updated.</p>
     ;;
    #_public
    (ยง method #_"ListenableFuture<Coin>" getBalanceFuture [#_"Coin" __value, #_"Wallet.BalanceType" __type]
        (.. (:lock this) (lock))
        (try
            (let [#_"SettableFuture<Coin>" __future (SettableFuture/create)
                  #_"Coin" __current (.. this (getBalance __type))]
                (cond (<= 0 (.. __current (compareTo __value)))
                    (do
                        ;; Already have enough.
                        (.. __future (set __current))
                    )
                    :else
                    (do
                        ;; Will be checked later in checkBalanceFutures.  We don't just add an event listener for ourselves
                        ;; here so that running getBalanceFuture().get() in the user code thread works - generally we must
                        ;; avoid giving the user back futures that require the user code thread to be free.
                        (let [#_"Wallet.BalanceFutureRequest" __req (Wallet.BalanceFutureRequest.)]
                            (ยง assoc __req :future __future)
                            (ยง assoc __req :value __value)
                            (ยง assoc __req :type __type)
                            (.. (:balance-future-requests this) (add __req))
                        )
                    )
                )
                (ยง return __future)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;; Runs any balance futures in the user code thread.
    #_suppress #_[ "FieldAccessNotGuarded" ]
    #_private
    (ยง method- #_"void" checkBalanceFuturesLocked [#_nilable #_"Coin" __avail]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))

        (let [#_"ListIterator<Wallet.BalanceFutureRequest>" __it (.. (:balance-future-requests this) (listIterator))]
            (while (.. __it (hasNext))
                (let [#_"Wallet.BalanceFutureRequest" __req (.. __it (next))
                      #_"Coin" __val (.. this (getBalance (:type __req)))] ;; This could be slow for lots of futures.
                    (when (< (.. __val (compareTo (:value __req))) 0)
                        (ยง continue )
                    )
                    ;; Found one that's finished.
                    (.. __it (remove))
                    (let [#_"Coin" __v __val]
                        ;; Don't run any user-provided future listeners with our lock held.
                        (.. Threading/USER_THREAD (execute (Runnable.)
                        (ยง anon
                            #_override
                            #_public
                            (ยง method #_"void" run []
                                (.. (:future __req) (set __v))
                                nil
                            )
                        )))
                    )
                )
            )
            nil
        )
    )

    ;;;
     ; Returns the amount of bitcoin ever received via output.  <b>This is not the balance!</b>  If an output
     ; spends from a transaction whose inputs are also to our wallet, the input amounts are deducted from the
     ; outputs contribution, with a minimum of zero contribution.  The idea behind this is we avoid double
     ; counting money sent to us.
     ; @return the total amount of satoshis received, regardless of whether it was spent or not.
     ;;
    #_public
    (ยง method #_"Coin" getTotalReceived []
        (let [#_"Coin" __total Coin/ZERO]

            ;; Include outputs to us if they were not just change outputs, i.e. the inputs to us summed to less
            ;; than the outputs to us.
            (doseq [#_"Transaction" __tx (.. (:transactions this) (values))]
                (let [#_"Coin" __txTotal Coin/ZERO]
                    (doseq [#_"TransactionOutput" __output (.. __tx (getOutputs))]
                        (when (.. __output (isMine this))
                            (ยง ass __txTotal (.. __txTotal (add (.. __output (getValue)))))
                        )
                    )
                    (doseq [#_"TransactionInput" __in (.. __tx (getInputs))]
                        (let [#_"TransactionOutput" __prevOut (.. __in (getConnectedOutput))]
                            (when (and (some? __prevOut) (.. __prevOut (isMine this)))
                                (ยง ass __txTotal (.. __txTotal (subtract (.. __prevOut (getValue)))))
                            )
                        )
                    )
                    (when (.. __txTotal (isPositive))
                        (ยง ass __total (.. __total (add __txTotal)))
                    )
                )
            )
            __total
        )
    )

    ;;;
     ; Returns the amount of bitcoin ever sent via output.  If an output is sent to our own wallet, because of
     ; change or rotating keys or whatever, we do not count it.  If the wallet was involved in a shared transaction,
     ; i.e. there is some input to the transaction that we don't have the key for, then we multiply the sum of
     ; the output values by the proportion of satoshi coming in to our inputs.  Essentially we treat inputs as
     ; pooling into the transaction, becoming fungible and being equally distributed to all outputs.
     ; @return the total amount of satoshis sent by us.
     ;;
    #_public
    (ยง method #_"Coin" getTotalSent []
        (let [#_"Coin" __total Coin/ZERO]

            (doseq [#_"Transaction" __tx (.. (:transactions this) (values))]
                ;; Count spent outputs to only if they were not to us.  This means we don't count change outputs.
                (let [#_"Coin" __txOutputTotal Coin/ZERO]
                    (doseq [#_"TransactionOutput" __out (.. __tx (getOutputs))]
                        (when (not (.. __out (isMine this)))
                            (ยง ass __txOutputTotal (.. __txOutputTotal (add (.. __out (getValue)))))
                        )
                    )

                    ;; Count the input values to us
                    (let [#_"Coin" __txOwnedInputsTotal Coin/ZERO]
                        (doseq [#_"TransactionInput" __in (.. __tx (getInputs))]
                            (let [#_"TransactionOutput" __prevOut (.. __in (getConnectedOutput))]
                                (when (and (some? __prevOut) (.. __prevOut (isMine this)))
                                    (ยง ass __txOwnedInputsTotal (.. __txOwnedInputsTotal (add (.. __prevOut (getValue)))))
                                )
                            )
                        )

                        ;; If there is an input that isn't from us, i.e. this is a shared transaction.
                        (let [#_"Coin" __txInputsTotal (.. __tx (getInputSum))]
                            (when (!= __txOwnedInputsTotal __txInputsTotal)
                                ;; Multiply our output total by the appropriate proportion to account for the inputs that we don't own.
                                (let [#_"BigInteger" __txOutputTotalNum (BigInteger. (.. __txOutputTotal (toString)))]
                                    (ยง ass __txOutputTotalNum (.. __txOutputTotalNum (multiply (BigInteger. (.. __txOwnedInputsTotal (toString))))))
                                    (ยง ass __txOutputTotalNum (.. __txOutputTotalNum (divide (BigInteger. (.. __txInputsTotal (toString))))))
                                    (ยง ass __txOutputTotal (Coin/valueOf (.. __txOutputTotalNum (longValue))))
                                )
                            )
                            (ยง ass __total (.. __total (add __txOutputTotal)))
                        )
                    )
                )
            )
            __total
        )
    )

    ;;; A SendResult is returned to you as part of sending coins to a recipient. ;;
    #_public
    #_static
    (ยง class Wallet.SendResult
        ;;; The Bitcoin transaction message that moves the money. ;;
        #_public
        (ยง field #_"Transaction" :tx)
        ;;;
         ; A future that will complete once the tx message has been successfully broadcast to the network.
         ; This is just the result of calling broadcast.future().
         ;;
        #_public
        (ยง field #_"ListenableFuture<Transaction>" :broadcast-complete)
        ;;; The broadcast object returned by the linked TransactionBroadcaster. ;;
        #_public
        (ยง field #_"TransactionBroadcast" :broadcast)
    )

    ;;;
     ; Enumerates possible resolutions for missing signatures.
     ;;
    #_public
    (ยง enum Wallet.MissingSigsMode
        ;;; Input script will have OP_0 instead of missing signatures. ;;
        (ยง item USE_OP_ZERO)
        ;;;
         ; Missing signatures will be replaced by dummy sigs.  This is useful when you'd like to know the
         ; fee for a transaction without knowing the user's password, as fee depends on size.
         ;;
        (ยง item USE_DUMMY_SIG)
        ;;;
         ; If signature is missing, {@link org.bitcoinj.signers.TransactionSigner.MissingSignatureException}
         ; will be thrown for P2SH and {@link ECKey.MissingPrivateKeyException} for other tx types.
         ;;
        (ยง item THROW)
    )

    ;;;
     ; <p>Statelessly creates a transaction that sends the given value to address.  The change is sent to
     ; {@link Wallet#currentChangeAddress()}, so you must have added at least one key.</p>
     ;
     ; <p>If you just want to send money quickly, you probably want
     ; {@link Wallet#sendCoins(TransactionBroadcaster, Address, Coin)} instead.  That will create the sending
     ; transaction, commit to the wallet and broadcast it to the network all in one go.  This method is lower
     ; level and lets you see the proposed transaction before anything is done with it.</p>
     ;
     ; <p>This is a helper method that is equivalent to using {@link SendRequest#to(Address, Coin)}
     ; followed by {@link Wallet#completeTx(Wallet.SendRequest)} and returning the requests transaction object.
     ; Note that this means a fee may be automatically added if required, if you want more control over the process,
     ; just do those two steps yourself.</p>
     ;
     ; <p>IMPORTANT: This method does NOT update the wallet.  If you call createSend again you may get two transactions
     ; that spend the same coins.  You have to call {@link Wallet#commitTx(Transaction)} on the created transaction to
     ; prevent this, but that should only occur once the transaction has been accepted by the network.  This implies
     ; you cannot have more than one outstanding sending tx at once.</p>
     ;
     ; <p>You MUST ensure that the value is not smaller than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction
     ; will almost certainly be rejected by the network as dust.</p>
     ;
     ; @param address The Bitcoin address to send the money to.
     ; @param value How much currency to send.
     ; @return either the created Transaction or null if there are insufficient coins.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    #_throws #_[ "InsufficientMoneyException" ]
    (ยง method #_"Transaction" createSend [#_"Address" __address, #_"Coin" __value]
        (let [#_"SendRequest" __req (SendRequest/to __address, __value)]
            (when (.. (:params this) (getId) (equals NetworkParameters/ID_UNITTESTNET))
                (ยง assoc __req :shuffle-outputs false)
            )
            (.. this (completeTx __req))
            (:tx __req)
        )
    )

    ;;;
     ; Sends coins to the given address but does not broadcast the resulting pending transaction.  It is still
     ; stored in the wallet, so when the wallet is added to a {@link PeerGroup} or {@link Peer} the transaction
     ; will be announced to the network.  The given {@link SendRequest} is completed first using
     ; {@link Wallet#completeTx(Wallet.SendRequest)} to make it valid.
     ;
     ; @return the Transaction that was created.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    #_throws #_[ "InsufficientMoneyException" ]
    (ยง method #_"Transaction" sendCoinsOffline [#_"SendRequest" __request]
        (.. (:lock this) (lock))
        (try
            (.. this (completeTx __request))
            (.. this (commitTx (:tx __request)))
            (:tx __request)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; <p>Sends coins to the given address, via the given {@link PeerGroup}.  Change is returned to
     ; {@link Wallet#currentChangeAddress()}.  Note that a fee may be automatically added if one may be required
     ; for the transaction to be confirmed.</p>
     ;
     ; <p>The returned object provides both the transaction, and a future that can be used to learn when the broadcast
     ; is complete.  Complete means, if the PeerGroup is limited to only one connection, when it was written out to
     ; the socket.  Otherwise when the transaction is written out and we heard it back from a different peer.</p>
     ;
     ; <p>Note that the sending transaction is committed to the wallet immediately, not when the transaction is
     ; successfully broadcast.  This means that even if the network hasn't heard about your transaction you won't be
     ; able to spend those same coins again.</p>
     ;
     ; <p>You MUST ensure that value is not smaller than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction will
     ; almost certainly be rejected by the network as dust.</p>
     ;
     ; @param broadcaster A {@link TransactionBroadcaster} to use to send the transactions out.
     ; @param to Which address to send coins to.
     ; @param value How much value to send.
     ; @return an object containing the transaction that was created, and a future for the broadcast of it.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    #_throws #_[ "InsufficientMoneyException" ]
    (ยง method #_"Wallet.SendResult" sendCoins [#_"TransactionBroadcaster" __broadcaster, #_"Address" __to, #_"Coin" __value]
        (let [#_"SendRequest" __request (SendRequest/to __to, __value)]
            (.. this (sendCoins __broadcaster, __request))
        )
    )

    ;;;
     ; <p>Sends coins according to the given request, via the given {@link TransactionBroadcaster}.</p>
     ;
     ; <p>The returned object provides both the transaction, and a future that can be used to learn when the broadcast
     ; is complete.  Complete means, if the PeerGroup is limited to only one connection, when it was written out to
     ; the socket.  Otherwise when the transaction is written out and we heard it back from a different peer.</p>
     ;
     ; <p>Note that the sending transaction is committed to the wallet immediately, not when the transaction is
     ; successfully broadcast.  This means that even if the network hasn't heard about your transaction you won't be
     ; able to spend those same coins again.</p>
     ;
     ; @param broadcaster The target to use for broadcast.
     ; @param request The SendRequest that describes what to do, get one using static methods on SendRequest itself.
     ; @return an object containing the transaction that was created, and a future for the broadcast of it.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    #_throws #_[ "InsufficientMoneyException" ]
    (ยง method #_"Wallet.SendResult" sendCoins [#_"TransactionBroadcaster" __broadcaster, #_"SendRequest" __request]
        ;; Should not be locked here, as we're going to call into the broadcaster and that might want to hold its
        ;; own lock.  sendCoinsOffline handles everything that needs to be locked.
        (Preconditions/checkState (not (.. (:lock this) (isHeldByCurrentThread))))

        ;; Commit the TX to the wallet immediately so the spent coins won't be reused.
        ;; TODO: We should probably allow the request to specify tx commit only after the network has accepted it.
        (let [#_"Transaction" __tx (.. this (sendCoinsOffline __request))
              #_"Wallet.SendResult" __result (Wallet.SendResult.)]
            (ยง assoc __result :tx __tx)
            ;; The tx has been committed to the pending pool by this point (via sendCoinsOffline -> commitTx), so it has
            ;; a txConfidenceListener registered.  Once the tx is broadcast the peers will update the memory pool with the
            ;; count of seen peers, the memory pool will update the transaction confidence object, that will invoke the
            ;; txConfidenceListener which will in turn invoke the wallets event listener onTransactionConfidenceChanged
            ;; method.
            (ยง assoc __result :broadcast (.. __broadcaster (broadcastTransaction __tx)))
            (ยง assoc __result :broadcast-complete (.. (:broadcast __result) (future)))
            __result
        )
    )

    ;;;
     ; Satisfies the given {@link SendRequest} using the default transaction broadcaster configured either via
     ; {@link PeerGroup#addWallet(Wallet)} or directly with {@link #setTransactionBroadcaster(TransactionBroadcaster)}.
     ;
     ; @param request The SendRequest that describes what to do, get one using static methods on SendRequest itself.
     ; @return an object containing the transaction that was created, and a future for the broadcast of it.
     ; @throws IllegalStateException if no transaction broadcaster has been configured.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    #_throws #_[ "InsufficientMoneyException" ]
    (ยง method #_"Wallet.SendResult" sendCoins [#_"SendRequest" __request]
        (let [#_"TransactionBroadcaster" __broadcaster (:v-transaction-broadcaster this)]
            (Preconditions/checkState (some? __broadcaster), "No transaction broadcaster is configured")
            (.. this (sendCoins __broadcaster, __request))
        )
    )

    ;;;
     ; Sends coins to the given address, via the given {@link Peer}.  Change is returned to {@link Wallet#currentChangeAddress()}.
     ; If an exception is thrown by {@link Peer#sendMessage(Message)} the transaction is still committed, so the pending
     ; transaction must be broadcast <b>by you</b> at some other time.  Note that a fee may be automatically added
     ; if one may be required for the transaction to be confirmed.
     ;
     ; @return the {@link Transaction} that was created or null if there was insufficient balance to send the coins.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    #_throws #_[ "InsufficientMoneyException" ]
    (ยง method #_"Transaction" sendCoins [#_"Peer" __peer, #_"SendRequest" __request]
        (let [#_"Transaction" __tx (.. this (sendCoinsOffline __request))]
            (.. __peer (sendMessage __tx))
            __tx
        )
    )

    ;;;
     ; Class of exceptions thrown in {@link Wallet#completeTx(SendRequest)}.
     ;;
    #_public
    #_static
    (ยง class Wallet.CompletionException (ยง extends RuntimeException))

    ;;;
     ; Thrown if the resultant transaction would violate the dust rules (an output that's too small to be worthwhile).
     ;;
    #_public
    #_static
    (ยง class Wallet.DustySendRequested (ยง extends Wallet.CompletionException))

    ;;;
     ; Thrown if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    #_static
    (ยง class Wallet.MultipleOpReturnRequested (ยง extends Wallet.CompletionException))

    ;;;
     ; Thrown when we were trying to empty the wallet, and the total amount of money we were trying to empty after
     ; being reduced for the fee was smaller than the min payment.
     ; Note that the missing field will be null in this case.
     ;;
    #_public
    #_static
    (ยง class Wallet.CouldNotAdjustDownwards (ยง extends Wallet.CompletionException))

    ;;;
     ; Thrown if the resultant transaction is too big for Bitcoin to process.  Try breaking up the amounts of value.
     ;;
    #_public
    #_static
    (ยง class Wallet.ExceededMaxTransactionSize (ยง extends Wallet.CompletionException))

    ;;;
     ; Given a spend request containing an incomplete transaction, makes it valid by adding outputs and signed inputs
     ; according to the instructions in the request.  The transaction in the request is modified by this method.
     ;
     ; @param req A SendRequest that contains the incomplete transaction and details for how to make it valid.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    #_throws #_[ "InsufficientMoneyException" ]
    (ยง method #_"void" completeTx [#_"SendRequest" __req]
        (.. (:lock this) (lock))
        (try
            (Preconditions/checkArgument (not (:completed __req)), "Given SendRequest has already been completed.")

            ;; Calculate the amount of value we need to import.
            (let [#_"Coin" __value Coin/ZERO]
                (doseq [#_"TransactionOutput" __output (.. (:tx __req) (getOutputs))]
                    (ยง ass __value (.. __value (add (.. __output (getValue)))))
                )

                (.. Wallet/log (info "Completing send tx with {} outputs totalling {} and a fee of {}/kB", (.. (:tx __req) (getOutputs) (size)), (.. __value (toFriendlyString)), (.. (:fee-per-kb __req) (toFriendlyString))))

                ;; If any inputs have already been added, we don't need to get their value from wallet.
                (let [#_"Coin" __totalInput Coin/ZERO]
                    (doseq [#_"TransactionInput" __input (.. (:tx __req) (getInputs))]
                        (if (some? (.. __input (getConnectedOutput)))
                            (ยง ass __totalInput (.. __totalInput (add (.. __input (getConnectedOutput) (getValue)))))
                            (.. Wallet/log (warn "SendRequest transaction already has inputs but we don't know how much they are worth - they will be added to fee."))
                        )
                    )
                    (ยง ass __value (.. __value (subtract __totalInput)))

                    (let [#_"List<TransactionInput>" __originalInputs (ArrayList. #_"<>" (.. (:tx __req) (getInputs)))]

                        ;; Check for dusty sends and the OP_RETURN limit.
                        (when (and (:ensure-min-required-fee __req) (not (:empty-wallet __req))) ;; Min fee checking is handled later for emptyWallet.
                            (let [#_"int" __opReturnCount 0]
                                (doseq [#_"TransactionOutput" __output (.. (:tx __req) (getOutputs))]
                                    (when (.. __output (isDust))
                                        (throw (Wallet.DustySendRequested.))
                                    )
                                    (when (.. __output (getScriptPubKey) (isOpReturn))
                                        (ยง ass __opReturnCount (inc __opReturnCount))
                                    )
                                )
                                (when (< 1 __opReturnCount) ;; Only 1 OP_RETURN per transaction allowed.
                                    (throw (Wallet.MultipleOpReturnRequested.))
                                )
                            )
                        )

                        ;; Calculate a list of ALL potential candidates for spending and then ask a coin selector to provide us
                        ;; with the actual outputs that'll be used to gather the required amount of value.  In this way, users
                        ;; can customize coin selection policies.  The call below will ignore immature coinbases and outputs
                        ;; we don't have the keys for.
                        (let [#_"List<TransactionOutput>" __candidates (.. this (calculateAllSpendCandidates true, (== (:missing-sigs-mode __req) Wallet.MissingSigsMode/THROW)))]

                            (let [#_"CoinSelection" __bestCoinSelection
                                  #_"TransactionOutput" __bestChangeOutput nil
                                  #_"List<Coin>" __updatedOutputValues nil]
                                (cond (not (:empty-wallet __req))
                                    (do
                                        ;; This can throw InsufficientMoneyException.
                                        (let [#_"Wallet.FeeCalculation" __feeCalculation (.. this (calculateFee __req, __value, __originalInputs, (:ensure-min-required-fee __req), __candidates))]
                                            (ยง ass __bestCoinSelection (:best-coin-selection __feeCalculation))
                                            (ยง ass __bestChangeOutput (:best-change-output __feeCalculation))
                                            (ยง ass __updatedOutputValues (:updated-output-values __feeCalculation))
                                        )
                                    )
                                    :else
                                    (do
                                        ;; We're being asked to empty the wallet.  What this means is ensuring "tx" has only a single output
                                        ;; of the total value we can currently spend as determined by the selector, and then subtracting the fee.
                                        (Preconditions/checkState (== (.. (:tx __req) (getOutputs) (size)) 1), "Empty wallet TX must have a single output only.")

                                        (let [#_"CoinSelector" __selector (or (:coin-selector __req) (:coin-selector this))]
                                            (ยง ass __bestCoinSelection (.. __selector (select (.. (:params this) (getMaxMoney)), __candidates)))
                                            (ยง ass __candidates nil) ;; Selector took ownership and might have changed candidates.  Don't access again.
                                            (.. (:tx __req) (getOutput 0) (setValue (:value-gathered __bestCoinSelection)))
                                            (.. Wallet/log (info "  emptying {}", (.. (:value-gathered __bestCoinSelection) (toFriendlyString))))
                                        )
                                    )
                                )

                                (doseq [#_"TransactionOutput" __output (:gathered __bestCoinSelection)]
                                    (.. (:tx __req) (addInput __output))
                                )

                                (when (:empty-wallet __req)
                                    (let [#_"Coin" __feePerKb (or (:fee-per-kb __req) Coin/ZERO)]
                                        (when (not (.. this (adjustOutputDownwardsForFee (:tx __req), __bestCoinSelection, __feePerKb, (:ensure-min-required-fee __req))))
                                            (throw (Wallet.CouldNotAdjustDownwards.))
                                        )
                                    )
                                )

                                (when (some? __updatedOutputValues)
                                    (loop-when-recur [#_"int" __i 0] (< __i (.. __updatedOutputValues (size))) [(inc __i)]
                                        (.. (:tx __req) (getOutput __i) (setValue (.. __updatedOutputValues (get __i))))
                                    )
                                )

                                (when (some? __bestChangeOutput)
                                    (.. (:tx __req) (addOutput __bestChangeOutput))
                                    (.. Wallet/log (info "  with {} change", (.. __bestChangeOutput (getValue) (toFriendlyString))))
                                )

                                ;; Now shuffle the outputs to obfuscate which is the change.
                                (when (:shuffle-outputs __req)
                                    (.. (:tx __req) (shuffleOutputs))
                                )

                                ;; Now sign the inputs, thus proving that we are entitled to redeem the connected outputs.
                                (when (:sign-inputs __req)
                                    (.. this (signTransaction __req))
                                )

                                ;; Check size.
                                (let [#_"int" __size (.. (:tx __req) (unsafeBitcoinSerialize) (alength))]
                                    (when (< Transaction/MAX_STANDARD_TX_SIZE __size)
                                        (throw (Wallet.ExceededMaxTransactionSize.))
                                    )

                                    ;; Label the transaction as being self created.  We can use this later to spend its change output even before
                                    ;; the transaction is confirmed.  We deliberately won't bother notifying listeners here as there's not much
                                    ;; point - the user isn't interested in a confidence transition they made themselves.
                                    (.. (:tx __req) (getConfidence) (setSource TransactionConfidence.Source/SELF))
                                    ;; Label the transaction as being a user requested payment.  This can be used to render GUI wallet
                                    ;; transaction lists more appropriately, especially when the wallet starts to generate transactions itself
                                    ;; for internal purposes.
                                    (.. (:tx __req) (setPurpose Transaction.Purpose/USER_PAYMENT))
                                    ;; Record the exchange rate that was valid when the transaction was completed.
                                    (.. (:tx __req) (setExchangeRate (:exchange-rate __req)))
                                    (.. (:tx __req) (setMemo (:memo __req)))
                                    (ยง assoc __req :completed true)
                                    (.. Wallet/log (info "  completed: {}", (:tx __req)))
                                )
                            )
                        )
                    )
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; <p>Given a send request containing transaction, attempts to sign it's inputs.  This method expects
     ; the transaction to have all necessary inputs connected or they will be ignored.</p>
     ; <p>Actual signing is done by pluggable {@link #signers} and it's not guaranteed that
     ; the transaction will be complete in the end.</p>
     ;;
    #_public
    (ยง method #_"void" signTransaction [#_"SendRequest" __req]
        (.. (:lock this) (lock))
        (try
            (let [#_"Transaction" __tx (:tx __req)
                  #_"List<TransactionInput>" __inputs (.. __tx (getInputs))
                  #_"List<TransactionOutput>" __outputs (.. __tx (getOutputs))]
                (Preconditions/checkState (< 0 (.. __inputs (size))))
                (Preconditions/checkState (< 0 (.. __outputs (size))))

                (let [#_"KeyBag" __maybeDecryptingKeyBag (DecryptingKeyBag. this, (:aes-key __req))]

                    (let [#_"int" __numInputs (.. __tx (getInputs) (size))]
                        (loop-when-recur [#_"int" __i 0] (< __i __numInputs) [(inc __i)]
                            (let [#_"TransactionInput" __txIn (.. __tx (getInput __i))]
                                ;; Missing connected output, assuming already signed.
                                (when (nil? (.. __txIn (getConnectedOutput)))
                                    (ยง continue )
                                )

                                (try
                                    ;; We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                                    ;; we sign missing pieces (to check this would require either assuming any signatures are signing
                                    ;; standard output types or a way to get processed signatures out of script execution).
                                    (.. __txIn (getScriptSig) (correctlySpends __tx, __i, (.. __txIn (getConnectedOutput) (getScriptPubKey))))
                                    (.. Wallet/log (warn "Input {} already correctly spends output, assuming SIGHASH type used will be safe and skipping signing.", __i))
                                    (ยง continue )
                                    (catch ScriptException __e
                                        (.. Wallet/log (debug "Input contained an incorrect signature", __e))
                                        ;; Expected.
                                    )
                                )

                                (let [#_"Script" __scriptPubKey (.. __txIn (getConnectedOutput) (getScriptPubKey))
                                      #_"RedeemData" __redeemData (.. __txIn (getConnectedRedeemData __maybeDecryptingKeyBag))]
                                    (Preconditions/checkNotNull __redeemData, "Transaction exists in wallet that we cannot redeem: %s", (.. __txIn (getOutpoint) (getHash)))
                                    (.. __txIn (setScriptSig (.. __scriptPubKey (createEmptyInputScript (.. (:keys __redeemData) (get 0)), (:redeem-script __redeemData)))))
                                )
                            )
                        )

                        (let [#_"TransactionSigner.ProposedTransaction" __proposal (TransactionSigner.ProposedTransaction. __tx)]
                            (doseq [#_"TransactionSigner" __signer (:signers this)]
                                (when (not (.. __signer (signInputs __proposal, __maybeDecryptingKeyBag)))
                                    (.. Wallet/log (info "{} returned false for the tx", (.. __signer (getClass) (getName))))
                                )
                            )

                            ;; Resolve missing sigs if any.
                            (.. (MissingSigResolutionSigner. (:missing-sigs-mode __req)) (signInputs __proposal, __maybeDecryptingKeyBag))
                        )
                    )
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;; Reduce the value of the first output of a transaction to pay the given feePerKb as appropriate for its size. ;;
    #_private
    (ยง method- #_"boolean" adjustOutputDownwardsForFee [#_"Transaction" __tx, #_"CoinSelection" __coinSelection, #_"Coin" __feePerKb, #_"boolean" __ensureMinRequiredFee]
        (let [#_"int" __size (+ (.. __tx (unsafeBitcoinSerialize) (alength)) (.. this (estimateBytesForSigning __coinSelection)))
              #_"Coin" __fee (.. __feePerKb (multiply __size) (divide 1000))]
            (when (and __ensureMinRequiredFee (< (.. __fee (compareTo Transaction/REFERENCE_DEFAULT_MIN_TX_FEE)) 0))
                (ยง ass __fee Transaction/REFERENCE_DEFAULT_MIN_TX_FEE)
            )
            (let [#_"TransactionOutput" __output (.. __tx (getOutput 0))]
                (.. __output (setValue (.. __output (getValue) (subtract __fee))))
                (not (.. __output (isDust)))
            )
        )
    )

    ;;;
     ; Returns a list of the outputs that can potentially be spent, i.e. that we have the keys for and are unspent
     ; according to our knowledge of the block chain.
     ;;
    #_public
    (ยง method #_"List<TransactionOutput>" calculateAllSpendCandidates []
        (.. this (calculateAllSpendCandidates true, true))
    )

    ;;;
     ; Returns a list of all outputs that are being tracked by this wallet taking into account the flags.
     ;
     ; @param excludeImmatureCoinbases Whether to ignore coinbase outputs that we will be able to spend in future once they mature.
     ; @param excludeUnsignable Whether to ignore outputs that we are tracking but don't have the keys to sign for.
     ;;
    #_public
    (ยง method #_"List<TransactionOutput>" calculateAllSpendCandidates [#_"boolean" __excludeImmatureCoinbases, #_"boolean" __excludeUnsignable]
        (.. (:lock this) (lock))
        (try
            (let [#_"List<TransactionOutput>" __candidates (ArrayList. #_"<>" (.. (:my-unspents this) (size)))]
                (doseq [#_"TransactionOutput" __output (:my-unspents this)]
                    (when (and __excludeUnsignable (not (.. this (canSignFor (.. __output (getScriptPubKey))))))
                        (ยง continue )
                    )
                    (let [#_"Transaction" __transaction (Preconditions/checkNotNull (.. __output (getParentTransaction)))]
                        (when (and __excludeImmatureCoinbases (not (.. __transaction (isMature))))
                            (ยง continue )
                        )
                        (.. __candidates (add __output))
                    )
                )
                (ยง return __candidates)
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; Returns true if this wallet has at least one of the private keys needed to sign for this scriptPubKey.
     ; Returns false if the form of the script is not known or if the script is OP_RETURN.
     ;;
    #_public
    (ยง method #_"boolean" canSignFor [#_"Script" __script]
        (when (.. __script (isSentToRawPubKey))
            (let [#_"byte[]" __pubkey (.. __script (getPubKey))
                  #_"ECKey" __key (.. this (findKeyFromPubKey __pubkey))]
                (ยง return (and (some? __key) (or (.. __key (isEncrypted)) (.. __key (hasPrivKey)))))
            )
        )

        (when (.. __script (isPayToScriptHash))
            (let [#_"RedeemData" __data (.. this (findRedeemDataFromScriptHash (.. __script (getPubKeyHash))))]
                (ยง return (and (some? __data) (.. this (canSignFor (:redeem-script __data)))))
            )
        )

        (when (.. __script (isSentToAddress))
            (let [#_"ECKey" __key (.. this (findKeyFromPubHash (.. __script (getPubKeyHash))))]
                (ยง return (and (some? __key) (or (.. __key (isEncrypted)) (.. __key (hasPrivKey)))))
            )
        )

        (cond (.. __script (isSentToMultiSig))
            (do
                (doseq [#_"ECKey" __pubkey (.. __script (getPubKeys))]
                    (let [#_"ECKey" __key (.. this (findKeyFromPubKey (.. __pubkey (getPubKey))))]
                        (when (and (some? __key) (or (.. __key (isEncrypted)) (.. __key (hasPrivKey))))
                            (ยง return true)
                        )
                    )
                )
            )
            (.. __script (isSentToCLTVPaymentChannel))
            (do
                ;; Any script for which we are the recipient or sender counts.
                (let [#_"byte[]" __sender (.. __script (getCLTVPaymentChannelSenderPubKey))
                      #_"ECKey" __senderKey (.. this (findKeyFromPubKey __sender))]
                    (when (and (some? __senderKey) (or (.. __senderKey (isEncrypted)) (.. __senderKey (hasPrivKey))))
                        (ยง return true)
                    )

                    (let [#_"byte[]" __recipient (.. __script (getCLTVPaymentChannelRecipientPubKey))
                          #_"ECKey" __recipientKey (.. this (findKeyFromPubKey __sender))]
                        (when (and (some? __recipientKey) (or (.. __recipientKey (isEncrypted)) (.. __recipientKey (hasPrivKey))))
                            (ยง return true)
                        )
                    )
                )
            )
        )
        false
    )

    ;;; Returns the {@link CoinSelector} object which controls which outputs can be spent by this wallet. ;;
    #_public
    (ยง method #_"CoinSelector" getCoinSelector []
        (.. (:lock this) (lock))
        (try
            (:coin-selector this)
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )

    ;;;
     ; A coin selector is responsible for choosing which outputs to spend when creating transactions.  The default
     ; selector implements a policy of spending transactions that appeared in the best chain and pending transactions
     ; that were created by this wallet, but not others.  You can override the coin selector for any given send
     ; operation by changing {@link SendRequest#coinSelector}.
     ;;
    #_public
    (ยง method #_"void" setCoinSelector [#_"CoinSelector" __coinSelector]
        (.. (:lock this) (lock))
        (try
            (ยง assoc this :coin-selector (Preconditions/checkNotNull __coinSelector))
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Convenience wrapper for <tt>setCoinSelector(Wallet.AllowUnconfirmedCoinSelector.get())</tt>.  If this method
     ; is called on the wallet then transactions will be used for spending regardless of their confidence.  This can
     ; be dangerous - only use this if you absolutely know what you're doing!
     ;;
    #_public
    (ยง method #_"void" allowSpendingUnconfirmedTransactions []
        (.. this (setCoinSelector (AllowUnconfirmedCoinSelector/get)))
        nil
    )

    ;;;
     ; A custom {@link TransactionOutput} that is free standing.  This contains all the information
     ; required for spending without actually having all the linked data (i.e parent tx).
     ;
     ;;
    #_private
    (ยง class- Wallet.FreeStandingTransactionOutput (ยง extends TransactionOutput)
        #_private
        (ยง field- #_"UTXO" :output)
        #_private
        (ยง field- #_"int" :chain-height)

        ;;;
         ; Construct a free standing Transaction Output.
         ; @param params The network parameters.
         ; @param output The stored output (free standing).
         ;;
        #_public
        (ยง constructor Wallet.FreeStandingTransactionOutput [#_"NetworkParameters" __params, #_"UTXO" __output, #_"int" __chainHeight]
            (ยง super __params, nil, (.. __output (getValue)), (.. __output (getScript) (getProgram)))

            (ยง assoc this :output __output)
            (ยง assoc this :chain-height __chainHeight)
            this
        )

        ;;;
         ; Get the {@link UTXO}.
         ; @return the stored output.
         ;;
        #_public
        (ยง method #_"UTXO" getUTXO []
            (:output this)
        )

        ;;;
         ; Get the depth within the chain of the parent tx, depth is 1 if the output height is the height
         ; of the latest block.
         ; @return the depth.
         ;;
        #_override
        #_public
        (ยง method #_"int" getParentTransactionDepthInBlocks []
            (inc (- (:chain-height this) (.. (:output this) (getHeight))))
        )

        #_override
        #_public
        (ยง method #_"int" getIndex []
            (int (.. (:output this) (getIndex)))
        )

        #_override
        #_public
        (ยง method #_"Sha256Hash" getParentTransactionHash []
            (.. (:output this) (getHash))
        )
    )

    #_private
    #_static
    (ยง class- Wallet.TxOffsetPair (ยง implements Comparable #_"<Wallet.TxOffsetPair>")
        #_public
        (ยง field #_"Transaction" :tx)
        #_public
        (ยง field #_"int" :offset)

        #_public
        (ยง constructor Wallet.TxOffsetPair [#_"Transaction" __tx, #_"int" __offset]
            (ยง assoc this :tx __tx)
            (ยง assoc this :offset __offset)
            this
        )

        #_override
        #_public
        (ยง method #_"int" compareTo [#_"Wallet.TxOffsetPair" __o]
            ;; Note that in this implementation compareTo() is not consistent with equals().
            (Ints/compare (:offset this), (:offset __o))
        )
    )

    ;;;
     ; <p>Don't call this directly.  It's not intended for API users.</p>
     ;
     ; <p>Called by the {@link BlockChain} when the best chain (representing total work done) has changed.
     ; This can cause the number of confirmations of a transaction to go higher, lower, drop to zero and
     ; can even result in a transaction going dead (will never confirm) due to a double spend.</p>
     ;
     ; <p>The oldBlocks/newBlocks lists are ordered height-wise from top first to bottom last.</p>
     ;;
    #_override
    #_public
    #_throws #_[ "VerificationException" ]
    (ยง method #_"void" reorganize [#_"StoredBlock" __splitPoint, #_"List<StoredBlock>" __oldBlocks, #_"List<StoredBlock>" __newBlocks]
        (.. (:lock this) (lock))
        (try
            ;; This runs on any peer thread with the block chain locked.
            ;;
            ;; The reorganize functionality of the wallet is tested in ChainSplitTest.java
            ;;
            ;; receive() has been called on the block that is triggering the re-org before this is called,
            ;; with type of SIDE_CHAIN.
            ;;
            ;; Note that this code assumes blocks are not invalid - if blocks contain duplicated transactions,
            ;; transactions that double spend etc then we can calculate the incorrect result.  This could open up
            ;; obscure DoS attacks if someone successfully mines a throwaway invalid block and feeds it to us, just
            ;; to try and corrupt the internal data structures.  We should try harder to avoid this but it's tricky
            ;; because there are so many ways the block can be invalid.

            ;; Avoid spuriously informing the user of wallet/tx confidence changes whilst we're re-organizing.
            (Preconditions/checkState (== (.. (:confidence-changed this) (size)) 0))
            (Preconditions/checkState (not (:inside-reorg this)))
            (ยง assoc this :inside-reorg true)
            (Preconditions/checkState (== (:on-wallet-changed-suppressions this) 0))
            (ยง assoc this :on-wallet-changed-suppressions (inc (:on-wallet-changed-suppressions this)))

            ;; Map block hash to transactions that appear in it.  We ensure that the map values are sorted according
            ;; to their relative position within those blocks.
            (let [#_"ArrayListMultimap<Sha256Hash, Wallet.TxOffsetPair>" __mapBlockTx (ArrayListMultimap/create)]
                (doseq [#_"Transaction" __tx (.. this (getTransactions true))]
                    (let [#_"Map<Sha256Hash, Integer>" __appearsIn (.. __tx (getAppearsInHashes))]
                        (when (nil? __appearsIn)
                            (ยง continue ) ;; Pending.
                        )
                        (doseq [#_"Map.Entry<Sha256Hash, Integer>" __block (.. __appearsIn (entrySet))]
                            (.. __mapBlockTx (put (.. __block (getKey)), (Wallet.TxOffsetPair. __tx, (.. __block (getValue)))))
                        )
                    )
                )
                (doseq [#_"Sha256Hash" __blockHash (.. __mapBlockTx (keySet))]
                    (Collections/sort (.. __mapBlockTx (get __blockHash)))
                )

                (let [#_"List<Sha256Hash>" __oldBlockHashes (ArrayList. #_"<>" (.. __oldBlocks (size)))]
                    (.. Wallet/log (info "Old part of chain (top to bottom):"))
                    (doseq [#_"StoredBlock" __b __oldBlocks]
                        (.. Wallet/log (info "  {}", (.. __b (getHeader) (getHashAsString))))
                        (.. __oldBlockHashes (add (.. __b (getHeader) (getHash))))
                    )
                    (.. Wallet/log (info "New part of chain (top to bottom):"))
                    (doseq [#_"StoredBlock" __b __newBlocks]
                        (.. Wallet/log (info "  {}", (.. __b (getHeader) (getHashAsString))))
                    )

                    (Collections/reverse __newBlocks) ;; Need bottom-to-top but we get top-to-bottom.

                    ;; For each block in the old chain, disconnect the transactions in reverse order.
                    (let [#_"LinkedList<Transaction>" __oldChainTxns (Lists/newLinkedList)]
                        (doseq [#_"Sha256Hash" __blockHash __oldBlockHashes]
                            (doseq [#_"Wallet.TxOffsetPair" __pair (.. __mapBlockTx (get __blockHash))]
                                (let [#_"Transaction" __tx (:tx __pair)
                                      #_"Sha256Hash" __txHash (.. __tx (getHash))]
                                    (cond (.. __tx (isCoinBase))
                                        (do
                                            ;; All the transactions that we have in our wallet which spent this coinbase are now invalid
                                            ;; and will never confirm.  Hopefully this should never happen - that's the point of the maturity
                                            ;; rule that forbids spending of coinbase transactions for 100 blocks.
                                            ;;
                                            ;; This could be recursive, although of course because we don't have the full transaction
                                            ;; graph we can never reliably kill all transactions we might have that were rooted in
                                            ;; this coinbase tx.  Some can just go pending forever, like the Bitcoin Core.  However we
                                            ;; can do our best.
                                            (.. Wallet/log (warn "Coinbase killed by re-org: {}", (.. __tx (getHashAsString))))
                                            (.. this (killTxns (ImmutableSet/of __tx), nil))
                                        )
                                        :else
                                        (do
                                            (doseq [#_"TransactionOutput" __output (.. __tx (getOutputs))]
                                                (let [#_"TransactionInput" __input (.. __output (getSpentBy))]
                                                    (when (some? __input)
                                                        (when (.. __output (isMine this))
                                                            (Preconditions/checkState (.. (:my-unspents this) (add __output)))
                                                        )
                                                        (.. __input (disconnect))
                                                    )
                                                )
                                            )
                                            (.. __oldChainTxns (add __tx))
                                            (.. (:unspent this) (remove __txHash))
                                            (.. (:spent this) (remove __txHash))
                                            (Preconditions/checkState (not (.. (:pending this) (containsKey __txHash))))
                                            (Preconditions/checkState (not (.. (:dead this) (containsKey __txHash))))
                                        )
                                    )
                                )
                            )
                        )

                        ;; Put all the disconnected transactions back into the pending pool and re-connect them.
                        (doseq [#_"Transaction" __tx __oldChainTxns]
                            ;; Coinbase transactions on the old part of the chain are dead for good and won't come back unless
                            ;; there's another re-org.
                            (when (.. __tx (isCoinBase))
                                (ยง continue )
                            )
                            (.. Wallet/log (info "  ->pending {}", (.. __tx (getHash))))

                            (.. __tx (getConfidence) (setConfidenceType TransactionConfidence.ConfidenceType/PENDING)) ;; Wipe height/depth/work data.
                            (.. (:confidence-changed this) (put __tx, TransactionConfidence.Listener.ChangeReason/TYPE))
                            (.. this (addWalletTransaction WalletTransaction.Pool/PENDING, __tx))
                            (.. this (updateForSpends __tx, false))
                        )

                        ;; Note that dead transactions stay dead.  Consider a chain that Finney attacks T1 and replaces it with
                        ;; T2, so we move T1 into the dead pool.  If there's now a re-org to a chain that doesn't include T2, it
                        ;; doesn't matter - the miners deleted T1 from their mempool, will resurrect T2 and put that into the
                        ;; mempool and so T1 is still seen as a losing double spend.

                        ;; The old blocks have contributed to the depth for all the transactions in the
                        ;; wallet that are in blocks up to and including the chain split block.
                        ;; The total depth is calculated here and then subtracted from the appropriate transactions.
                        (let [#_"int" __depthToSubtract (.. __oldBlocks (size))]
                            (.. Wallet/log (info (str "depthToSubtract = " __depthToSubtract)))
                            ;; Remove depthToSubtract from all transactions in the wallet except for pending.
                            (.. this (subtractDepth __depthToSubtract, (.. (:spent this) (values))))
                            (.. this (subtractDepth __depthToSubtract, (.. (:unspent this) (values))))
                            (.. this (subtractDepth __depthToSubtract, (.. (:dead this) (values))))

                            ;; The effective last seen block is now the split point so set the lastSeenBlockHash.
                            (.. this (setLastBlockSeenHash (.. __splitPoint (getHeader) (getHash))))

                            ;; For each block in the new chain, work forwards calling receive() and notifyNewBestBlock().
                            ;; This will pull them back out of the pending pool, or if the tx didn't appear in the old chain
                            ;; and does appear in the new chain, will treat it as such and possibly kill pending transactions
                            ;; that conflict.
                            (doseq [#_"StoredBlock" __block __newBlocks]
                                (.. Wallet/log (info "Replaying block {}", (.. __block (getHeader) (getHashAsString))))
                                (doseq [#_"Wallet.TxOffsetPair" __pair (.. __mapBlockTx (get (.. __block (getHeader) (getHash))))]
                                    (.. Wallet/log (info "  tx {}", (.. (:tx __pair) (getHash))))
                                    (try
                                        (.. this (receive (:tx __pair), __block, BlockChain.NewBlockType/BEST_CHAIN, (:offset __pair)))
                                        (catch ScriptException __e
                                            (throw (RuntimeException. __e)) ;; Cannot happen as these blocks were already verified.
                                        )
                                    )
                                )
                                (.. this (notifyNewBestBlock __block))
                            )
                            (.. this (isConsistentOrThrow))
                            (let [#_"Coin" __balance (.. this (getBalance))]
                                (.. Wallet/log (info "post-reorg balance is {}", (.. __balance (toFriendlyString))))
                                ;; Inform event listeners that a re-org took place.
                                (.. this (queueOnReorganize))
                                (ยง assoc this :inside-reorg false)
                                (ยง assoc this :on-wallet-changed-suppressions (dec (:on-wallet-changed-suppressions this)))
                                (.. this (maybeQueueOnWalletChanged))
                                (.. this (checkBalanceFuturesLocked __balance))
                                (.. this (informConfidenceListenersIfNotReorganizing))
                                (.. this (saveLater))
                            )
                        )
                    )
                )
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
        nil
    )

    ;;;
     ; Subtract the supplied depth from the given transactions.
     ;;
    #_private
    (ยง method- #_"void" subtractDepth [#_"int" __depthToSubtract, #_"Collection<Transaction>" __transactions]
        (doseq [#_"Transaction" __tx __transactions]
            (when (== (.. __tx (getConfidence) (getConfidenceType)) TransactionConfidence.ConfidenceType/BUILDING)
                (.. __tx (getConfidence) (setDepthInBlocks (- (.. __tx (getConfidence) (getDepthInBlocks)) __depthToSubtract)))
                (.. (:confidence-changed this) (put __tx, TransactionConfidence.Listener.ChangeReason/DEPTH))
            )
        )
        nil
    )

    #_private
    (ยง field- #_"ArrayList<TransactionOutPoint>" :bloom-out-points (Lists/newArrayList))
    ;; Used to track whether we must automatically begin/end a filter calculation and calc outpoints/take the locks.
    #_private
    (ยง field- #_"AtomicInteger" :bloom-filter-guard (AtomicInteger. 0))

    #_override
    #_public
    (ยง method #_"void" beginBloomFilterCalculation []
        (when (< 1 (.. (:bloom-filter-guard this) (incrementAndGet)))
            (ยง return nil)
        )

        (.. (:lock this) (lock))
        (.. (:key-chain-group-lock this) (lock))
        ;; noinspection FieldAccessNotGuarded
        (.. this (calcBloomOutPointsLocked))
        nil
    )

    #_private
    (ยง method- #_"void" calcBloomOutPointsLocked []
        ;; TODO: This could be done once and then kept up to date.
        (.. (:bloom-out-points this) (clear))
        (let [#_"Set<Transaction>" __all (HashSet. #_"<>")]
            (.. __all (addAll (.. (:unspent this) (values))))
            (.. __all (addAll (.. (:spent this) (values))))
            (.. __all (addAll (.. (:pending this) (values))))

            (doseq [#_"Transaction" __tx __all]
                (doseq [#_"TransactionOutput" __out (.. __tx (getOutputs))]
                    (try
                        (when (.. this (isTxOutputBloomFilterable __out))
                            (.. (:bloom-out-points this) (add (.. __out (getOutPointFor))))
                        )
                        (catch ScriptException __e
                            ;; If it is ours, we parsed the script correctly, so this shouldn't happen.
                            (throw (RuntimeException. __e))
                        )
                    )
                )
            )
            nil
        )
    )

    #_override
    #_public
    (ยง method #_"void" endBloomFilterCalculation []
        (when (< 0 (.. (:bloom-filter-guard this) (decrementAndGet)))
            (ยง return nil)
        )

        (.. (:bloom-out-points this) (clear))
        (.. (:key-chain-group-lock this) (unlock))
        (.. (:lock this) (unlock))
        nil
    )

    ;;;
     ; Returns the number of distinct data items (note: NOT keys) that will be inserted into a bloom filter,
     ; when it is constructed.
     ;;
    #_override
    #_public
    (ยง method #_"int" getBloomFilterElementCount []
        (.. this (beginBloomFilterCalculation))
        (try
            (+ (.. (:bloom-out-points this) (size)) (.. (:key-chain-group this) (getBloomFilterElementCount)))
            (finally
                (.. this (endBloomFilterCalculation))
            )
        )
    )

    ;;;
     ; Gets a bloom filter that contains all of the public keys from this wallet, and which will provide the given
     ; false-positive rate.  See the docs for {@link BloomFilter} for a brief explanation of anonymity when using filters.
     ;;
    #_public
    (ยง method #_"BloomFilter" getBloomFilter [#_"double" __falsePositiveRate]
        (.. this (beginBloomFilterCalculation))
        (try
            (.. this (getBloomFilter (.. this (getBloomFilterElementCount)), __falsePositiveRate, (long (* (Math/random) Long/MAX_VALUE))))
            (finally
                (.. this (endBloomFilterCalculation))
            )
        )
    )

    ;;;
     ; <p>Gets a bloom filter that contains all of the public keys from this wallet, and which will provide the given
     ; false-positive rate if it has size elements.  Keep in mind that you will get 2 elements in the bloom filter for
     ; each key in the wallet, for the public key and the hash of the public key (address form).</p>
     ;
     ; <p>This is used to generate a BloomFilter which can be {@link BloomFilter#merge(BloomFilter)}d with another.
     ; It could also be used if you have a specific target for the filter's size.</p>
     ;
     ; <p>See the docs for {@link BloomFilter(int, double)} for a brief explanation of anonymity when using bloom
     ; filters.</p>
     ;;
    #_override
    #_public
    (ยง method #_"BloomFilter" getBloomFilter [#_"int" __size, #_"double" __falsePositiveRate, #_"long" __nTweak]
        (.. this (beginBloomFilterCalculation))
        (try
            (let [#_"BloomFilter" __filter (.. (:key-chain-group this) (getBloomFilter __size, __falsePositiveRate, __nTweak))]
                (doseq [#_"TransactionOutPoint" __point (:bloom-out-points this)]
                    (.. __filter (insert (.. __point (unsafeBitcoinSerialize))))
                )
                (ยง return __filter)
            )
            (finally
                (.. this (endBloomFilterCalculation))
            )
        )
    )

    ;; Returns true if the output is one that won't be selected by a data element matching in the scriptSig.
    #_private
    (ยง method- #_"boolean" isTxOutputBloomFilterable [#_"TransactionOutput" __out]
        (let [#_"Script" __script (.. __out (getScriptPubKey))
              #_"boolean" __isScriptTypeSupported (or (.. __script (isSentToRawPubKey)) (.. __script (isPayToScriptHash)))]
            (and __isScriptTypeSupported (.. (:my-unspents this) (contains __out)))
        )
    )

    ;;;
     ; Used by {@link Peer} to decide whether or not to discard this block and any blocks building upon it, in case
     ; the Bloom filter used to request them may be exhausted, that is, not have sufficient keys in the deterministic
     ; sequence within it to reliably find relevant transactions.
     ;;
    #_public
    (ยง method #_"boolean" checkForFilterExhaustion [#_"FilteredBlock" __block]
        (.. (:key-chain-group-lock this) (lock))
        (try
            (let [#_"int" __epoch (.. (:key-chain-group this) (getCombinedKeyLookaheadEpochs))]
                (doseq [#_"Transaction" __tx (.. __block (getAssociatedTransactions) (values))]
                    (.. this (markKeysAsUsed __tx))
                )
                (let [#_"int" __newEpoch (.. (:key-chain-group this) (getCombinedKeyLookaheadEpochs))]
                    (Preconditions/checkState (<= __epoch __newEpoch))
                    ;; If the key lookahead epoch has advanced, there was a call to importKeys and the PeerGroup already has a
                    ;; pending request to recalculate the filter queued up on another thread.  The calling Peer should abandon
                    ;; block at this point and await a new filter before restarting the download.
                    (ยง return (< __epoch __newEpoch))
                )
            )
            (finally
                (.. (:key-chain-group-lock this) (unlock))
            )
        )
    )

    #_private
    #_static
    (ยง class- Wallet.FeeCalculation
        ;; Selected UTXOs to spend.
        #_public
        (ยง field #_"CoinSelection" :best-coin-selection)
        ;; Change output (may be null if no change).
        #_public
        (ยง field #_"TransactionOutput" :best-change-output)
        ;; List of output values adjusted downwards when recipients pay fees (may be null if no adjustment needed).
        #_public
        (ยง field #_"List<Coin>" :updated-output-values)
    )

    #_private
    #_throws #_[ "InsufficientMoneyException" ]
    (ยง method- #_"Wallet.FeeCalculation" calculateFee [#_"SendRequest" __req, #_"Coin" __value, #_"List<TransactionInput>" __originalInputs, #_"boolean" __needAtLeastReferenceFee, #_"List<TransactionOutput>" __candidates]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))
        (let [#_"Wallet.FeeCalculation" __result
              #_"Coin" __fee Coin/ZERO]
            (loop []
                (ยง ass __result (Wallet.FeeCalculation.))
                (let [#_"Transaction" __tx (Transaction. (:params this))]
                    (.. this (addSuppliedInputs __tx, (.. (:tx __req) (getInputs))))

                    (let [#_"Coin" __valueNeeded __value]
                        (when (not (:recipients-pay-fees __req))
                            (ยง ass __valueNeeded (.. __valueNeeded (add __fee)))
                        )
                        (when (:recipients-pay-fees __req)
                            (ยง assoc __result :updated-output-values (ArrayList. #_"<Coin>"))
                        )

                        (loop-when-recur [#_"int" __i 0] (< __i (.. (:tx __req) (getOutputs) (size))) [(inc __i)]
                            (let [#_"TransactionOutput" __output (TransactionOutput. (:params this), __tx, (.. (:tx __req) (getOutputs) (get __i) (bitcoinSerialize)), 0)]
                                (when (:recipients-pay-fees __req)
                                    ;; Subtract fee equally from each selected recipient.
                                    (.. __output (setValue (.. __output (getValue) (subtract (.. __fee (divide (.. (:tx __req) (getOutputs) (size))))))))
                                    ;; First receiver pays the remainder not divisible by output count.
                                    (when (== __i 0)
                                        ;; Subtract fee equally from each selected recipient.
                                        (.. __output (setValue (.. __output (getValue) (subtract (aget (.. __fee (divideAndRemainder (.. (:tx __req) (getOutputs) (size)))) 1)))))
                                    )
                                    (.. (:updated-output-values __result) (add (.. __output (getValue))))
                                    (when (.. __output (getMinNonDustValue) (isGreaterThan (.. __output (getValue))))
                                        (throw (Wallet.CouldNotAdjustDownwards.))
                                    )
                                )
                                (.. __tx (addOutput __output))
                            )
                        )

                        (let [#_"CoinSelector" __selector (or (:coin-selector __req) (:coin-selector this))]
                            ;; selector is allowed to modify candidates list.
                            (let [#_"CoinSelection" __selection (.. __selector (select __valueNeeded, (LinkedList. #_"<>" __candidates)))]
                                (ยง assoc __result :best-coin-selection __selection)
                                ;; Can we afford this?
                                (when (< (.. (:value-gathered __selection) (compareTo __valueNeeded)) 0)
                                    (let [#_"Coin" __valueMissing (.. __valueNeeded (subtract (:value-gathered __selection)))]
                                        (throw (InsufficientMoneyException. __valueMissing))
                                    )
                                )

                                (let [#_"Coin" __change (.. (:value-gathered __selection) (subtract __valueNeeded))]
                                    (when (.. __change (isGreaterThan Coin/ZERO))
                                        ;; The value of the inputs is greater than what we want to send.  Just like in real life then,
                                        ;; we need to take back some coins ... this is called "change".  Add another output that sends the change
                                        ;; back to us.  The address comes either from the request or currentChangeAddress() as a default.
                                        (let [#_"Address" __changeAddress (:change-address __req)]
                                            (when (nil? __changeAddress)
                                                (ยง ass __changeAddress (.. this (currentChangeAddress)))
                                            )

                                            (let [#_"TransactionOutput" __changeOutput (TransactionOutput. (:params this), __tx, __change, __changeAddress)]
                                                (when (and (:recipients-pay-fees __req) (.. __changeOutput (isDust)))
                                                    ;; We do not move dust-change to fees, because the sender would end up paying more than requested.
                                                    ;; This would be against the purpose of the all-inclusive feature.
                                                    ;; So instead we raise the change and deduct from the first recipient.
                                                    (let [#_"Coin" __missingToNotBeDust (.. __changeOutput (getMinNonDustValue) (subtract (.. __changeOutput (getValue))))]
                                                        (.. __changeOutput (setValue (.. __changeOutput (getValue) (add __missingToNotBeDust))))
                                                        (let [#_"TransactionOutput" __firstOutput (.. __tx (getOutputs) (get 0))]
                                                            (.. __firstOutput (setValue (.. __firstOutput (getValue) (subtract __missingToNotBeDust))))
                                                            (.. (:updated-output-values __result) (set 0, (.. __firstOutput (getValue))))
                                                            (when (.. __firstOutput (isDust))
                                                                (throw (Wallet.CouldNotAdjustDownwards.))
                                                            )
                                                        )
                                                    )
                                                )

                                                (cond (.. __changeOutput (isDust))
                                                    (do
                                                        ;; Never create dust outputs; if we would, just add the dust to the fee.
                                                        ;; Oscar comment: This seems like a way to make the condition below "if (!fee.isLessThan(feeNeeded))" to become true.
                                                        ;; This is a non-easy to understand way to do that.
                                                        ;; Maybe there are other effects I am missing.
                                                        (ยง ass __fee (.. __fee (add (.. __changeOutput (getValue)))))
                                                    )
                                                    :else
                                                    (do
                                                        (.. __tx (addOutput __changeOutput))
                                                        (ยง assoc __result :best-change-output __changeOutput)
                                                    )
                                                )
                                            )
                                        )
                                    )

                                    (doseq [#_"TransactionOutput" __selectedOutput (:gathered __selection)]
                                        (let [#_"TransactionInput" __input (.. __tx (addInput __selectedOutput))]
                                            ;; If the scriptBytes don't default to none, our size calculations will be thrown off.
                                            (Preconditions/checkState (== (.. __input (getScriptBytes) (alength)) 0))
                                        )
                                    )

                                    (let [#_"int" __size (.. __tx (unsafeBitcoinSerialize) (alength))]
                                        (ยง ass __size (+ __size (.. this (estimateBytesForSigning __selection))))

                                        (let [#_"Coin" __feePerKb (:fee-per-kb __req)]
                                            (when (and __needAtLeastReferenceFee (< (.. __feePerKb (compareTo Transaction/REFERENCE_DEFAULT_MIN_TX_FEE)) 0))
                                                (ยง ass __feePerKb Transaction/REFERENCE_DEFAULT_MIN_TX_FEE)
                                            )

                                            (let [#_"Coin" __feeNeeded (.. __feePerKb (multiply __size) (divide 1000))]

                                                (when (not (.. __fee (isLessThan __feeNeeded)))
                                                    ;; Done, enough fee included.
                                                    (ยง break )
                                                )

                                                ;; Include more fee and try again.
                                                (ยง ass __fee __feeNeeded)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            __result
        )
    )

    #_private
    (ยง method- #_"void" addSuppliedInputs [#_"Transaction" __tx, #_"List<TransactionInput>" __originalInputs]
        (doseq [#_"TransactionInput" __input __originalInputs]
            (.. __tx (addInput (TransactionInput. (:params this), __tx, (.. __input (bitcoinSerialize)))))
        )
        nil
    )

    #_private
    (ยง method- #_"int" estimateBytesForSigning [#_"CoinSelection" __selection]
        (let [#_"int" __size 0]
            (doseq [#_"TransactionOutput" __output (:gathered __selection)]
                (try
                    (let [#_"Script" __script (.. __output (getScriptPubKey))
                          #_"ECKey" __key nil
                          #_"Script" __redeemScript nil]
                        (cond (.. __script (isSentToAddress))
                            (do
                                (ยง ass __key (.. this (findKeyFromPubHash (.. __script (getPubKeyHash)))))
                                (Preconditions/checkNotNull __key, "Coin selection includes unspendable outputs")
                            )
                            (.. __script (isPayToScriptHash))
                            (do
                                (ยง ass __redeemScript (.. this (findRedeemDataFromScriptHash (.. __script (getPubKeyHash))) :redeem-script))
                                (Preconditions/checkNotNull __redeemScript, "Coin selection includes unspendable outputs")
                            )
                        )
                        (ยง ass __size (+ __size (.. __script (getNumberOfBytesRequiredToSpend __key, __redeemScript))))
                    )
                    (catch ScriptException __e
                        ;; If this happens it means an output script in a wallet tx could not be understood.  That
                        ;; should never happen, if it does it means the wallet has got into an inconsistent state.
                        (throw (IllegalStateException. __e))
                    )
                )
            )
            __size
        )
    )

    ;; Wallet maintenance transactions.  These transactions may not be directly connected to a payment the user is
    ;; making.  They may be instead key rotation transactions for when old keys are suspected to be compromised,
    ;; de/re-fragmentation transactions for when our output sizes are inappropriate or suboptimal, privacy transactions
    ;; and so on.  Because these transactions may require user intervention in some way (e.g. entering their password)
    ;; the wallet application is expected to poll the Wallet class to get SendRequests.  Ideally security systems like
    ;; hardware wallets or risk analysis providers are programmed to auto-approve transactions that send from our own
    ;; keys back to our own keys.

    ;;;
     ; <p>Specifies that the given {@link TransactionBroadcaster}, typically a {@link PeerGroup}, should be used for
     ; sending transactions to the Bitcoin network by default.  Some sendCoins methods let you specify a broadcaster
     ; explicitly, in that case, they don't use this broadcaster.  If null is specified then the wallet won't attempt
     ; to broadcast transactions itself.</p>
     ;
     ; <p>You don't normally need to call this.  A {@link PeerGroup} will automatically set itself as the wallets
     ; broadcaster when you use {@link PeerGroup#addWallet(Wallet)}.  A wallet can use the broadcaster when you ask
     ; it to send money, but in future also at other times to implement various features that may require asynchronous
     ; re-organisation of the wallet contents on the block chain.  For instance, in future the wallet may choose to
     ; optimise itself to reduce fees or improve privacy.</p>
     ;;
    #_public
    (ยง method #_"void" setTransactionBroadcaster [#_nilable #_"org.bitcoinj.core.TransactionBroadcaster" __broadcaster]
        (let [#_"Transaction[]" __toBroadcast (make-array Transaction 0)]
            (.. (:lock this) (lock))
            (try
                (when (== (:v-transaction-broadcaster this) __broadcaster)
                    (ยง return nil)
                )
                (ยง assoc this :v-transaction-broadcaster __broadcaster)
                (when (nil? __broadcaster)
                    (ยง return nil)
                )
                (ยง ass __toBroadcast (.. (:pending this) (values) (toArray __toBroadcast)))
                (finally
                    (.. (:lock this) (unlock))
                )
            )
            ;; Now use it to upload any pending transactions we have that are marked as not being seen by any peers yet.
            ;; Don't hold the wallet lock whilst doing this, so if the broadcaster accesses the wallet at some point there
            ;; is no inversion.
            (doseq [#_"Transaction" __tx __toBroadcast]
                (let [#_"TransactionConfidence.ConfidenceType" __confidenceType (.. __tx (getConfidence) (getConfidenceType))]
                    (Preconditions/checkState (any == __confidenceType TransactionConfidence.ConfidenceType/PENDING TransactionConfidence.ConfidenceType/IN_CONFLICT), "Expected PENDING or IN_CONFLICT, was %s.", __confidenceType)
                    ;; Re-broadcast even if it's marked as already seen for two reasons:
                    ;; 1. Old wallets may have transactions marked as broadcast by 1 peer when
                    ;;    in reality the network never saw it, due to bugs.
                    ;; 2. It can't really hurt.
                    (.. Wallet/log (info "New broadcaster so uploading waiting tx {}", (.. __tx (getHash))))
                    (.. __broadcaster (broadcastTransaction __tx))
                )
            )
            nil
        )
    )

    ;;;
     ; When a key rotation time is set, and money controlled by keys created before the given timestamp T will be
     ; automatically respent to any key that was created after T.  This can be used to recover from a situation where
     ; a set of keys is believed to be compromised.  Once the time is set transactions will be created and broadcast
     ; immediately.  New coins that come in after calling this method will be automatically respent immediately.
     ; The rotation time is persisted to the wallet. You can stop key rotation by calling this method again with zero
     ; as the argument.
     ;;
    #_public
    (ยง method #_"void" setKeyRotationTime [#_"Date" __time]
        (.. this (setKeyRotationTime (/ (.. __time (getTime)) 1000)))
        nil
    )

    ;;;
     ; Returns the key rotation time, or null if unconfigured.
     ; See {@link #setKeyRotationTime(Date)} for a description of the field.
     ;;
    #_public
    #_nilable
    (ยง method #_"Date" getKeyRotationTime []
        (let [#_"long" __keyRotationTimestamp (:v-key-rotation-timestamp this)]
            (when (!= __keyRotationTimestamp 0) (Date. (* __keyRotationTimestamp 1000)))
        )
    )

    ;;;
     ; <p>When a key rotation time is set, any money controlled by keys created before the given timestamp T will be
     ; automatically respent to any key that was created after T.  This can be used to recover from a situation where
     ; a set of keys is believed to be compromised.  You can stop key rotation by calling this method again with zero
     ; as the argument.  Once set up, calling {@link #doMaintenance(org.spongycastle.crypto.params.KeyParameter, boolean)}
     ; will create and possibly send rotation transactions: but it won't be done automatically (because you might have
     ; to ask for the users password).</p>
     ;
     ; <p>The given time cannot be in the future.</p>
     ;;
    #_public
    (ยง method #_"void" setKeyRotationTime [#_"long" __unixTimeSeconds]
        (Preconditions/checkArgument (<= __unixTimeSeconds (Utils/currentTimeSeconds)), "Given time (%s) cannot be in the future.", (Utils/dateTimeFormat (* __unixTimeSeconds 1000)))
        (ยง assoc this :v-key-rotation-timestamp __unixTimeSeconds)
        (.. this (saveNow))
        nil
    )

    ;;; Returns whether the keys creation time is before the key rotation time, if one was set. ;;
    #_public
    (ยง method #_"boolean" isKeyRotating [#_"ECKey" __key]
        (let [#_"long" __time (:v-key-rotation-timestamp this)]
            (and (!= __time 0) (< (.. __key (getCreationTimeSeconds)) __time))
        )
    )

    ;;;
     ; A wallet app should call this from time to time in order to let the wallet craft and send transactions needed
     ; to re-organise coins internally.  A good time to call this would be after receiving coins for an unencrypted
     ; wallet, or after sending money for an encrypted wallet.  If you have an encrypted wallet and just want to know
     ; if some maintenance needs doing, call this method with andSend set to false and look at the returned list of
     ; transactions.  Maintenance might also include internal changes that involve some processing or work but
     ; which don't require making transactions - these will happen automatically unless the password is required
     ; in which case an exception will be thrown.
     ;
     ; @param aesKey The users password, if any.
     ; @param signAndSend If true, send the transactions via the tx broadcaster and return them, if false just return them.
     ; @return a list of transactions that the wallet just made/will make for internal maintenance.  Might be empty.
     ; @throws org.bitcoinj.wallet.DeterministicUpgradeRequiresPassword if key rotation requires the users password.
     ;;
    #_public
    #_throws #_[ "DeterministicUpgradeRequiresPassword" ]
    (ยง method #_"ListenableFuture<List<Transaction>>" doMaintenance [#_nilable #_"KeyParameter" __aesKey, #_"boolean" __signAndSend]
        (let [#_"List<Transaction>" __txns]
            (.. (:lock this) (lock))
            (.. (:key-chain-group-lock this) (lock))
            (try
                (ยง ass __txns (.. this (maybeRotateKeys __aesKey, __signAndSend)))
                (when (not __signAndSend)
                    (ยง return (Futures/immediateFuture __txns))
                )
                (finally
                    (.. (:key-chain-group-lock this) (unlock))
                    (.. (:lock this) (unlock))
                )
            )
            (Preconditions/checkState (not (.. (:lock this) (isHeldByCurrentThread))))
            (let [#_"ArrayList<ListenableFuture<Transaction>>" __futures (ArrayList. #_"<>" (.. __txns (size)))
                  #_"TransactionBroadcaster" __broadcaster (:v-transaction-broadcaster this)]
                (doseq [#_"Transaction" __tx __txns]
                    (try
                        (let [#_"ListenableFuture<Transaction>" __future (.. __broadcaster (broadcastTransaction __tx) (future))]
                            (.. __futures (add __future))
                            (Futures/addCallback __future, (FutureCallback. #_"<Transaction>")
                            (ยง anon
                                #_override
                                #_public
                                (ยง method #_"void" onSuccess [#_"Transaction" __transaction]
                                    (.. Wallet/log (info "Successfully broadcast key rotation tx: {}", __transaction))
                                    nil
                                )

                                #_override
                                #_public
                                (ยง method #_"void" onFailure [#_"Throwable" __throwable]
                                    (.. Wallet/log (error "Failed to broadcast key rotation tx", __throwable))
                                    nil
                                )
                            ))
                        )
                        (catch Exception __e
                            (.. Wallet/log (error "Failed to broadcast rekey tx", __e))
                        )
                    )
                )
                (Futures/allAsList __futures)
            )
        )
    )

    ;; Checks to see if any coins are controlled by rotating keys and if so, spends them.
    #_private
    #_throws #_[ "DeterministicUpgradeRequiresPassword" ]
    (ยง method- #_"List<Transaction>" maybeRotateKeys [#_nilable #_"KeyParameter" __aesKey, #_"boolean" __sign]
        (Preconditions/checkState (.. (:lock this) (isHeldByCurrentThread)))
        (Preconditions/checkState (.. (:key-chain-group-lock this) (isHeldByCurrentThread)))

        (let [#_"List<Transaction>" __results (Lists/newLinkedList)]
            ;; TODO: Handle chain replays here.
            (let [#_"long" __keyRotationTimestamp (:v-key-rotation-timestamp this)]
                (when (== __keyRotationTimestamp 0)
                    (ยง return __results) ;; Nothing to do.
                )

                ;; We might have to create a new HD hierarchy if the previous ones are now rotating.
                (let [#_"boolean" __allChainsRotating true]
                    (doseq [#_"DeterministicKeyChain" __chain (.. (:key-chain-group this) (getDeterministicKeyChains))]
                        (when (<= __keyRotationTimestamp (.. __chain (getEarliestKeyCreationTime)))
                            (ยง ass __allChainsRotating false)
                            (ยง break )
                        )
                    )
                    (when __allChainsRotating
                        (try
                            (cond (.. (:key-chain-group this) (getImportedKeys) (isEmpty))
                                (do
                                    (.. Wallet/log (info "All HD chains are currently rotating and we have no random keys, creating fresh HD chain ..."))
                                    (.. (:key-chain-group this) (createAndActivateNewHDChain))
                                )
                                :else
                                (do
                                    (.. Wallet/log (info "All HD chains are currently rotating, attempting to create a new one from the next oldest non-rotating key material ..."))
                                    (.. (:key-chain-group this) (upgradeToDeterministic __keyRotationTimestamp, __aesKey))
                                    (.. Wallet/log (info " ... upgraded to HD again, based on next best oldest key."))
                                )
                            )
                            (catch AllRandomKeysRotating _
                                (.. Wallet/log (info " ... no non-rotating random keys available, generating entirely new HD tree: backup required after this."))
                                (.. (:key-chain-group this) (createAndActivateNewHDChain))
                            )
                        )
                        (.. this (saveNow))
                    )

                    ;; Because transactions are size limited, we might not be able to re-key the entire wallet in one go.  So loop
                    ;; around here until we no longer produce transactions with the max number of inputs.  That means we're fully
                    ;; done, at least for now (we may still get more transactions later and this method will be reinvoked).
                    (let [#_"Transaction" __tx]
                        (ยง repeat
                            (ยง ass __tx (.. this (rekeyOneBatch __keyRotationTimestamp, __aesKey, __results, __sign)))
                            (when (some? __tx)
                                (.. __results (add __tx))
                            )
                            (ยง again (and (some? __tx) (== (.. __tx (getInputs) (size)) KeyTimeCoinSelector/MAX_SIMULTANEOUS_INPUTS)))
                        )

                        __results
                    )
                )
            )
        )
    )

    #_nilable
    #_private
    (ยง method- #_"Transaction" rekeyOneBatch [#_"long" __timeSecs, #_nilable #_"KeyParameter" __aesKey, #_"List<Transaction>" __others, #_"boolean" __sign]
        (.. (:lock this) (lock))
        (try
            ;; Build the transaction using some custom logic for our special needs.  Last parameter to
            ;; KeyTimeCoinSelector is whether to ignore pending transactions or not.
            ;;
            ;; We ignore pending outputs because trying to rotate these is basically racing an attacker, and
            ;; we're quite likely to lose and create stuck double spends.  Also, some users who have 0.9 wallets
            ;; have already got stuck double spends in their wallet due to the Bloom-filtering block reordering
            ;; bug that was fixed in 0.10, thus, making a re-key transaction depend on those would cause it to
            ;; never confirm at all.
            (let [#_"CoinSelector" __keyTimeSelector (KeyTimeCoinSelector. this, __timeSecs, true)
                  #_"FilteringCoinSelector" __selector (FilteringCoinSelector. __keyTimeSelector)]
                (doseq [#_"Transaction" __other __others]
                    (.. __selector (excludeOutputsSpentBy __other))
                )
                ;; TODO: Make this use the standard SendRequest.
                (let [#_"CoinSelection" __toMove (.. __selector (select Coin/ZERO, (.. this (calculateAllSpendCandidates))))]
                    (when (.. (:value-gathered __toMove) (equals Coin/ZERO))
                        (ยง return nil) ;; Nothing to do.
                    )

                    (.. this (maybeUpgradeToHD __aesKey))
                    (let [#_"Transaction" __rekeyTx (Transaction. (:params this))]
                        (doseq [#_"TransactionOutput" __output (:gathered __toMove)]
                            (.. __rekeyTx (addInput __output))
                        )
                        ;; When not signing, don't waste addresses.
                        (.. __rekeyTx (addOutput (:value-gathered __toMove), (if __sign (.. this (freshReceiveAddress)) (.. this (currentReceiveAddress)))))
                        (when (not (.. this (adjustOutputDownwardsForFee __rekeyTx, __toMove, Transaction/DEFAULT_TX_FEE, true)))
                            (.. Wallet/log (error "Failed to adjust rekey tx for fees."))
                            (ยง return nil)
                        )

                        (.. __rekeyTx (getConfidence) (setSource TransactionConfidence.Source/SELF))
                        (.. __rekeyTx (setPurpose Transaction.Purpose/KEY_ROTATION))
                        (let [#_"SendRequest" __req (SendRequest/forTx __rekeyTx)]
                            (ยง assoc __req :aes-key __aesKey)
                            (when __sign
                                (.. this (signTransaction __req))
                            )
                            ;; KeyTimeCoinSelector should never select enough inputs to push us oversize.
                            (Preconditions/checkState (< (.. __rekeyTx (unsafeBitcoinSerialize) (alength)) Transaction/MAX_STANDARD_TX_SIZE))
                            (ยง return __rekeyTx)
                        )
                    )
                )
            )
            (catch VerificationException __e
                (throw (RuntimeException. __e)) ;; Cannot happen.
            )
            (finally
                (.. (:lock this) (unlock))
            )
        )
    )
)

;;;
 ; A class that handles atomic and optionally delayed writing of the wallet file to disk.  In future: backups too.
 ; It can be useful to delay writing of a wallet file to disk on slow devices where disk and serialization overhead
 ; can come to dominate the chain processing speed, i.e. on Android phones.  By coalescing writes and doing
 ; serialization and disk IO on a background thread performance can be improved.
 ;;
#_public
(ยง class WalletFiles
    #_private
    #_static
    (ยง def- #_"Logger" WalletFiles/log (LoggerFactory/getLogger WalletFiles))

    #_private
    (ยง field- #_"Wallet" :wallet)
    #_private
    (ยง field- #_"ScheduledThreadPoolExecutor" :executor)
    #_private
    (ยง field- #_"File" :file)
    #_private
    (ยง field- #_"AtomicBoolean" :save-pending)
    #_private
    (ยง field- #_"long" :delay)
    #_private
    (ยง field- #_"TimeUnit" :delay-time-unit)
    #_private
    (ยง field- #_"Callable<Void>" :saver)

    #_private
    #_volatile
    (ยง field- #_"WalletFiles.Listener" :v-listener)

    ;;;
     ; Implementors can do pre/post treatment of the wallet file.  Useful for adjusting permissions and other things.
     ;;
    #_public
    (ยง interface WalletFiles.Listener
        ;;;
         ; Called on the auto-save thread when a new temporary file is created but before the wallet data is saved
         ; to it.  If you want to do something here like adjust permissions, go ahead and do so.
         ;;
        (ยง method #_"void" onBeforeAutoSave [#_"File" __tempFile])

        ;;;
         ; Called on the auto-save thread after the newly created temporary file has been filled with data and renamed.
         ;;
        (ยง method #_"void" onAfterAutoSave [#_"File" __newlySavedFile])
    )

    ;;;
     ; Initialize atomic and optionally delayed writing of the wallet file to disk.  Note the initial wallet state isn't
     ; saved automatically.  The {@link Wallet} calls {@link #saveNow()} or {@link #saveLater()} as wallet state changes,
     ; depending on the urgency of the changes.
     ;;
    #_public
    (ยง constructor WalletFiles [#_"Wallet" __wallet, #_"File" __file, #_"long" __delay, #_"TimeUnit" __delayTimeUnit]
        ;; An executor that starts up threads when needed and shuts them down later.
        (ยง assoc this :executor (ScheduledThreadPoolExecutor. 1, (ContextPropagatingThreadFactory. "Wallet autosave thread", Thread/MIN_PRIORITY)))
        (.. (:executor this) (setKeepAliveTime 5, TimeUnit/SECONDS))
        (.. (:executor this) (allowCoreThreadTimeOut true))
        (.. (:executor this) (setExecuteExistingDelayedTasksAfterShutdownPolicy false))
        (ยง assoc this :wallet (Preconditions/checkNotNull __wallet))
        ;; File must only be accessed from the auto-save executor from now on, to avoid simultaneous access.
        (ยง assoc this :file (Preconditions/checkNotNull __file))
        (ยง assoc this :save-pending (AtomicBoolean.))
        (ยง assoc this :delay __delay)
        (ยง assoc this :delay-time-unit (Preconditions/checkNotNull __delayTimeUnit))

        (ยง assoc this :saver (Callable. #_"<Void>"
        (ยง anon
            #_override
            #_public
            #_throws #_[ "Exception" ]
            (ยง method #_"Void" call []
                ;; Runs in an auto save thread.
                (when (not (.. (:save-pending this) (getAndSet false)))
                    ;; Some other scheduled request already beat us to it.
                    (ยง return nil)
                )
                (let [#_"Date" __lastBlockSeenTime (.. __wallet (getLastBlockSeenTime))]
                    (.. WalletFiles/log (info "Background saving wallet; last seen block is height {}, date {}, hash {}", (.. __wallet (getLastBlockSeenHeight)), (if (some? __lastBlockSeenTime) (Utils/dateTimeFormat __lastBlockSeenTime) "unknown"), (.. __wallet (getLastBlockSeenHash))))
                    (.. this (saveNowInternal))
                    nil
                )
            )
        )))
        this
    )

    ;;;
     ; The given listener will be called on the autosave thread before and after the wallet is saved to disk.
     ;;
    #_public
    (ยง method #_"void" setListener [#_non-nil #_"WalletFiles.Listener" __listener]
        (ยง assoc this :v-listener (Preconditions/checkNotNull __listener))
        nil
    )

    ;;; Actually write the wallet file to disk, using an atomic rename when possible.  Runs on the current thread. ;;
    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" saveNow []
        ;; Can be called by any thread. However the wallet is locked whilst saving, so we can have two saves
        ;; in flight, but they will serialize (using different temp files).
        (let [#_"Date" __lastBlockSeenTime (.. (:wallet this) (getLastBlockSeenTime))]
            (.. WalletFiles/log (info "Saving wallet; last seen block is height {}, date {}, hash {}", (.. (:wallet this) (getLastBlockSeenHeight)), (if (some? __lastBlockSeenTime) (Utils/dateTimeFormat __lastBlockSeenTime) "unknown"), (.. (:wallet this) (getLastBlockSeenHash))))
            (.. this (saveNowInternal))
            nil
        )
    )

    #_private
    #_throws #_[ "IOException" ]
    (ยง method- #_"void" saveNowInternal []
        (let [#_"Stopwatch" __watch (Stopwatch/createStarted)
              #_"File" __directory (.. (:file this) (getAbsoluteFile) (getParentFile))
              #_"File" __temp (File/createTempFile "wallet", nil, __directory)
              #_"WalletFiles.Listener" __listener (:v-listener this)]
            (when (some? __listener)
                (.. __listener (onBeforeAutoSave __temp))
            )
            (.. (:wallet this) (saveToFile __temp, (:file this)))
            (when (some? __listener)
                (.. __listener (onAfterAutoSave (:file this)))
            )
            (.. __watch (stop))
            (.. WalletFiles/log (info "Save completed in {}", __watch))
            nil
        )
    )

    ;;; Queues up a save in the background.  Useful for not very important wallet changes. ;;
    #_public
    (ยง method #_"void" saveLater []
        (when (.. (:save-pending this) (getAndSet true))
            (ยง return nil) ;; Already pending.
        )

        (.. (:executor this) (schedule (:saver this), (:delay this), (:delay-time-unit this)))
        nil
    )

    ;;; Shut down auto-saving. ;;
    #_public
    (ยง method #_"void" shutdownAndWait []
        (.. (:executor this) (shutdown))
        (try
            (.. (:executor this) (awaitTermination Long/MAX_VALUE, TimeUnit/DAYS)) ;; forever
            (catch InterruptedException __e
                (throw (RuntimeException. __e))
            )
        )
        nil
    )
)

;;;
 ; Serialize and de-serialize a wallet to a byte stream containing a
 ; <a href="https://developers.google.com/protocol-buffers/docs/overview">protocol buffer</a>.  Protocol buffers are
 ; a data interchange format developed by Google with an efficient binary representation, a type safe specification
 ; language and compilers that generate code to work with those data structures for many languages.  Protocol buffers
 ; can have their format evolved over time: conceptually they represent data using (tag, length, value) tuples.  The
 ; format is defined by the <tt>wallet.proto</tt> file in the bitcoinj source distribution.
 ;
 ; This class is used through its static methods.  The most common operations are writeWallet and readWallet, which do
 ; the obvious operations on Output/InputStreams.  You can use a {@link java.io.ByteArrayInputStream} and equivalent
 ; {@link java.io.ByteArrayOutputStream} if you'd like byte arrays instead.  The protocol buffer can also be manipulated
 ; in its object form if you'd like to modify the flattened data structure before serialization to binary.
 ;
 ; You can extend the wallet format with additional fields specific to your application if you want, but make sure
 ; to either put the extra data in the provided extension areas, or select tag numbers that are unlikely to be used
 ; by anyone else.
 ;
 ; @author Miron Cuperman
 ; @author Andreas Schildbach
 ;;
#_public
(ยง class WalletProtobufSerializer
    #_private
    #_static
    (ยง def- #_"Logger" WalletProtobufSerializer/log (LoggerFactory/getLogger WalletProtobufSerializer))

    ;;; Current version used for serializing wallets.  A version higher than this is considered from the future. ;;
    #_public
    #_static
    (ยง def #_"int" WalletProtobufSerializer/CURRENT_WALLET_VERSION (.. (Protos.Wallet/getDefaultInstance) (getVersion)))
    ;; 512 MB
    #_private
    #_static
    (ยง def- #_"int" WalletProtobufSerializer/WALLET_SIZE_LIMIT (* 512 1024 1024))
    ;; Used for de-serialization.
    #_protected
    (ยง field #_"Map<ByteString, Transaction>" :tx-map)

    #_private
    (ยง field- #_"int" :wallet-write-buffer-size CodedOutputStream/DEFAULT_BUFFER_SIZE)

    #_public
    (ยง interface WalletProtobufSerializer.WalletFactory
        (ยง method #_"Wallet" create [#_"NetworkParameters" __params, #_"KeyChainGroup" __keyChainGroup])
    )

    #_private
    (ยง field- #_"WalletProtobufSerializer.WalletFactory" :factory)
    #_private
    (ยง field- #_"KeyChainFactory" :key-chain-factory)

    #_public
    (ยง constructor WalletProtobufSerializer []
        (ยง this (WalletProtobufSerializer.WalletFactory.
        (ยง anon
            #_override
            #_public
            (ยง method #_"Wallet" create [#_"NetworkParameters" __params, #_"KeyChainGroup" __keyChainGroup]
                (Wallet. __params, __keyChainGroup)
            )
        )))
        this
    )

    #_public
    (ยง constructor WalletProtobufSerializer [#_"WalletProtobufSerializer.WalletFactory" __factory]
        (ยง assoc this :tx-map (HashMap. #_"<>"))
        (ยง assoc this :factory __factory)
        (ยง assoc this :key-chain-factory (DefaultKeyChainFactory.))
        this
    )

    #_public
    (ยง method #_"void" setKeyChainFactory [#_"KeyChainFactory" __keyChainFactory]
        (ยง assoc this :key-chain-factory __keyChainFactory)
        nil
    )

    ;;;
     ; Change buffer size for writing wallet to output stream.
     ; Default is {@link com.google.protobuf.CodedOutputStream.DEFAULT_BUFFER_SIZE}.
     ; @param walletWriteBufferSize Buffer size in bytes.
     ;;
    #_public
    (ยง method #_"void" setWalletWriteBufferSize [#_"int" __walletWriteBufferSize]
        (ยง assoc this :wallet-write-buffer-size __walletWriteBufferSize)
        nil
    )

    ;;;
     ; Formats the given wallet (transactions and keys) to the given output stream in protocol buffer format.
     ;
     ; Equivalent to <tt>walletToProto(wallet).writeTo(output)</tt>.
     ;;
    #_public
    #_throws #_[ "IOException" ]
    (ยง method #_"void" writeWallet [#_"Wallet" __wallet, #_"OutputStream" __output]
        (let [#_"Protos.Wallet" __walletProto (.. this (walletToProto __wallet))
              #_"CodedOutputStream" __codedOutput (CodedOutputStream/newInstance __output, (:wallet-write-buffer-size this))]
            (.. __walletProto (writeTo __codedOutput))
            (.. __codedOutput (flush))
            nil
        )
    )

    ;;;
     ; Returns the given wallet formatted as text.  The text format is that used by protocol buffers and although
     ; it can also be parsed using {@link TextFormat#merge(CharSequence, com.google.protobuf.Message.Builder)},
     ; it is designed more for debugging than storage.  It is not well specified and wallets are largely binary data
     ; structures anyway, consisting as they do of keys (large random numbers) and {@link Transaction}s which also
     ; mostly contain keys and hashes.
     ;;
    #_public
    (ยง method #_"String" walletToText [#_"Wallet" __wallet]
        (let [#_"Protos.Wallet" __walletProto (.. this (walletToProto __wallet))]
            (TextFormat/printToString __walletProto)
        )
    )

    ;;;
     ; Converts the given wallet to the object representation of the protocol buffers.  This can be modified, or
     ; additional data fields set, before serialization takes place.
     ;;
    #_public
    (ยง method #_"Protos.Wallet" walletToProto [#_"Wallet" __wallet]
        (let [#_"Protos.Wallet.Builder" __walletBuilder (Protos.Wallet/newBuilder)]
            (.. __walletBuilder (setNetworkIdentifier (.. __wallet (getNetworkParameters) (getId))))
            (when (some? (.. __wallet (getDescription)))
                (.. __walletBuilder (setDescription (.. __wallet (getDescription))))
            )

            (doseq [#_"WalletTransaction" __wtx (.. __wallet (getWalletTransactions))]
                (let [#_"Protos.Transaction" __txProto (WalletProtobufSerializer/makeTxProto __wtx)]
                    (.. __walletBuilder (addTransaction __txProto))
                )
            )

            (.. __walletBuilder (addAllKey (.. __wallet (serializeKeyChainGroupToProtobuf))))

            ;; Populate the lastSeenBlockHash field.
            (let [#_"Sha256Hash" __lastSeenBlockHash (.. __wallet (getLastBlockSeenHash))]
                (when (some? __lastSeenBlockHash)
                    (.. __walletBuilder (setLastSeenBlockHash (WalletProtobufSerializer/hashToByteString __lastSeenBlockHash)))
                    (.. __walletBuilder (setLastSeenBlockHeight (.. __wallet (getLastBlockSeenHeight))))
                )
                (when (< 0 (.. __wallet (getLastBlockSeenTimeSecs)))
                    (.. __walletBuilder (setLastSeenBlockTimeSecs (.. __wallet (getLastBlockSeenTimeSecs))))
                )

                ;; Populate the scrypt parameters.
                (let [#_"KeyCrypter" __keyCrypter (.. __wallet (getKeyCrypter))]
                    (cond (nil? __keyCrypter)
                        (do
                            ;; The wallet is unencrypted.
                            (.. __walletBuilder (setEncryptionType Protos.Wallet.EncryptionType/UNENCRYPTED))
                        )
                        :else
                        (do
                            ;; The wallet is encrypted.
                            (.. __walletBuilder (setEncryptionType (.. __keyCrypter (getUnderstoodEncryptionType))))
                            (cond (instance? KeyCrypterScrypt __keyCrypter)
                                (do
                                    (let [#_"KeyCrypterScrypt" __keyCrypterScrypt (cast KeyCrypterScrypt __keyCrypter)]
                                        (.. __walletBuilder (setEncryptionParameters (.. __keyCrypterScrypt (getScryptParameters))))
                                    )
                                )
                                :else
                                (do
                                    ;; Some other form of encryption has been specified that we do not know how to persist.
                                    (throw (RuntimeException. (str "The wallet has encryption of type '" (.. __keyCrypter (getUnderstoodEncryptionType)) "' but this WalletProtobufSerializer does not know how to persist this.")))
                                )
                            )
                        )
                    )

                    (when (some? (.. __wallet (getKeyRotationTime)))
                        (let [#_"long" __timeSecs (/ (.. __wallet (getKeyRotationTime) (getTime)) 1000)]
                            (.. __walletBuilder (setKeyRotationTime __timeSecs))
                        )
                    )

                    (doseq [#_"TransactionSigner" __signer (.. __wallet (getTransactionSigners))]
                        ;; Do not serialize LocalTransactionSigner as it's being added implicitly.
                        (when (instance? LocalTransactionSigner __signer)
                            (ยง continue )
                        )

                        (let [#_"Protos.TransactionSigner.Builder" __protoSigner (Protos.TransactionSigner/newBuilder)]
                            (.. __protoSigner (setClassName (.. __signer (getClass) (getName))))
                            (.. __protoSigner (setData (ByteString/copyFrom (.. __signer (serialize)))))
                            (.. __walletBuilder (addTransactionSigners __protoSigner))
                        )
                    )

                    ;; Populate the wallet version.
                    (.. __walletBuilder (setVersion (.. __wallet (getVersion))))

                    (.. __walletBuilder (build))
                )
            )
        )
    )

    #_private
    #_static
    (ยง defn- #_"Protos.Transaction" WalletProtobufSerializer/makeTxProto [#_"WalletTransaction" __wtx]
        (let [#_"Transaction" __tx (.. __wtx (getTransaction))
              #_"Protos.Transaction.Builder" __txBuilder (Protos.Transaction/newBuilder)]

            (.. __txBuilder (setPool (WalletProtobufSerializer/getProtoPool __wtx)) (setHash (WalletProtobufSerializer/hashToByteString (.. __tx (getHash)))) (setVersion (int (.. __tx (getVersion)))))

            (when (some? (.. __tx (getUpdateTime)))
                (.. __txBuilder (setUpdatedAt (.. __tx (getUpdateTime) (getTime))))
            )

            (when (< 0 (.. __tx (getLockTime)))
                (.. __txBuilder (setLockTime (int (.. __tx (getLockTime)))))
            )

            ;; Handle inputs.
            (doseq [#_"TransactionInput" __input (.. __tx (getInputs))]
                (let [#_"Protos.TransactionInput.Builder" __inputBuilder (.. (Protos.TransactionInput/newBuilder) (setScriptBytes (ByteString/copyFrom (.. __input (getScriptBytes)))) (setTransactionOutPointHash (WalletProtobufSerializer/hashToByteString (.. __input (getOutpoint) (getHash)))) (setTransactionOutPointIndex (int (.. __input (getOutpoint) (getIndex)))))]
                    (when (.. __input (hasSequence))
                        (.. __inputBuilder (setSequence (int (.. __input (getSequenceNumber)))))
                    )
                    (when (some? (.. __input (getValue)))
                        (.. __inputBuilder (setValue (:value (.. __input (getValue)))))
                    )
                    (.. __txBuilder (addTransactionInput __inputBuilder))
                )
            )

            ;; Handle outputs.
            (doseq [#_"TransactionOutput" __output (.. __tx (getOutputs))]
                (let [#_"Protos.TransactionOutput.Builder" __outputBuilder (.. (Protos.TransactionOutput/newBuilder) (setScriptBytes (ByteString/copyFrom (.. __output (getScriptBytes)))) (setValue (:value (.. __output (getValue)))))
                      #_"TransactionInput" __spentBy (.. __output (getSpentBy))]
                    (when (some? __spentBy)
                        (let [#_"Sha256Hash" __spendingHash (.. __spentBy (getParentTransaction) (getHash))
                              #_"int" __spentByTransactionIndex (.. __spentBy (getParentTransaction) (getInputs) (indexOf __spentBy))]
                            (.. __outputBuilder (setSpentByTransactionHash (WalletProtobufSerializer/hashToByteString __spendingHash)) (setSpentByTransactionIndex __spentByTransactionIndex))
                        )
                    )
                    (.. __txBuilder (addTransactionOutput __outputBuilder))
                )
            )

            ;; Handle which blocks tx was seen in.
            (let [#_"Map<Sha256Hash, Integer>" __appearsInHashes (.. __tx (getAppearsInHashes))]
                (when (some? __appearsInHashes)
                    (doseq [#_"Map.Entry<Sha256Hash, Integer>" __entry (.. __appearsInHashes (entrySet))]
                        (.. __txBuilder (addBlockHash (WalletProtobufSerializer/hashToByteString (.. __entry (getKey)))))
                        (.. __txBuilder (addBlockRelativityOffsets (.. __entry (getValue))))
                    )
                )

                (when (.. __tx (hasConfidence))
                    (let [#_"TransactionConfidence" __confidence (.. __tx (getConfidence))
                          #_"Protos.TransactionConfidence.Builder" __confidenceBuilder (Protos.TransactionConfidence/newBuilder)]
                        (WalletProtobufSerializer/writeConfidence __txBuilder, __confidence, __confidenceBuilder)
                    )
                )

                (let [#_"Protos.Transaction.Purpose" __purpose
                        (condp == (.. __tx (getPurpose))
                            UNKNOWN                   Protos.Transaction.Purpose/UNKNOWN
                            USER_PAYMENT              Protos.Transaction.Purpose/USER_PAYMENT
                            KEY_ROTATION              Protos.Transaction.Purpose/KEY_ROTATION
                            ASSURANCE_CONTRACT_CLAIM  Protos.Transaction.Purpose/ASSURANCE_CONTRACT_CLAIM
                            ASSURANCE_CONTRACT_PLEDGE Protos.Transaction.Purpose/ASSURANCE_CONTRACT_PLEDGE
                            ASSURANCE_CONTRACT_STUB   Protos.Transaction.Purpose/ASSURANCE_CONTRACT_STUB
                            RAISE_FEE                 Protos.Transaction.Purpose/RAISE_FEE
                            (throw (RuntimeException. "New tx purpose serialization not implemented."))
                        )]
                    (.. __txBuilder (setPurpose __purpose))

                    (let [#_"ExchangeRate" __exchangeRate (.. __tx (getExchangeRate))]
                        (when (some? __exchangeRate)
                            (let [#_"Protos.ExchangeRate.Builder" __exchangeRateBuilder (.. (Protos.ExchangeRate/newBuilder) (setCoinValue (.. (:coin __exchangeRate) :value)) (setFiatValue (.. (:fiat __exchangeRate) :value)) (setFiatCurrencyCode (.. (:fiat __exchangeRate) :currency-code)))]
                                (.. __txBuilder (setExchangeRate __exchangeRateBuilder))
                            )
                        )

                        (when (some? (.. __tx (getMemo)))
                            (.. __txBuilder (setMemo (.. __tx (getMemo))))
                        )

                        (.. __txBuilder (build))
                    )
                )
            )
        )
    )

    #_private
    #_static
    (ยง defn- #_"Protos.Transaction.Pool" WalletProtobufSerializer/getProtoPool [#_"WalletTransaction" __wtx]
        (condp == (.. __wtx (getPool))
            UNSPENT Protos.Transaction.Pool/UNSPENT
            SPENT   Protos.Transaction.Pool/SPENT
            DEAD    Protos.Transaction.Pool/DEAD
            PENDING Protos.Transaction.Pool/PENDING
            (throw (RuntimeException. "Unreachable"))
        )
    )

    #_private
    #_static
    (ยง defn- #_"void" WalletProtobufSerializer/writeConfidence [#_"Protos.Transaction.Builder" __txBuilder, #_"TransactionConfidence" __confidence, #_"Protos.TransactionConfidence.Builder" __confidenceBuilder]
        (ยง sync __confidence
            (.. __confidenceBuilder (setType (Protos.TransactionConfidence.Type/valueOf (.. __confidence (getConfidenceType) (getValue)))))
            (when (== (.. __confidence (getConfidenceType)) TransactionConfidence.ConfidenceType/BUILDING)
                (.. __confidenceBuilder (setAppearedAtHeight (.. __confidence (getAppearedAtChainHeight))))
                (.. __confidenceBuilder (setDepth (.. __confidence (getDepthInBlocks))))
            )
            (when (== (.. __confidence (getConfidenceType)) TransactionConfidence.ConfidenceType/DEAD)
                ;; Copy in the overriding transaction, if available.
                ;; (A dead coinbase transaction has no overriding transaction).
                (when (some? (.. __confidence (getOverridingTransaction)))
                    (let [#_"Sha256Hash" __overridingHash (.. __confidence (getOverridingTransaction) (getHash))]
                        (.. __confidenceBuilder (setOverridingTransaction (WalletProtobufSerializer/hashToByteString __overridingHash)))
                    )
                )
            )
            (condp == (.. __confidence (getSource))
                SELF        (.. __confidenceBuilder (setSource Protos.TransactionConfidence.Source/SOURCE_SELF))
                NETWORK     (.. __confidenceBuilder (setSource Protos.TransactionConfidence.Source/SOURCE_NETWORK))
                #_"UNKNOWN" (.. __confidenceBuilder (setSource Protos.TransactionConfidence.Source/SOURCE_UNKNOWN))
            )
        )

        (doseq [#_"PeerAddress" __address (.. __confidence (getBroadcastBy))]
            (let [#_"Protos.PeerAddress" __proto (.. (Protos.PeerAddress/newBuilder) (setIpAddress (ByteString/copyFrom (.. __address (getAddr) (getAddress)))) (setPort (.. __address (getPort))) (setServices (.. __address (getServices) (longValue))) (build))]
                (.. __confidenceBuilder (addBroadcastBy __proto))
            )
        )
        (let [#_"Date" __lastBroadcastedAt (.. __confidence (getLastBroadcastedAt))]
            (when (some? __lastBroadcastedAt)
                (.. __confidenceBuilder (setLastBroadcastedAt (.. __lastBroadcastedAt (getTime))))
            )
            (.. __txBuilder (setConfidence __confidenceBuilder))
            nil
        )
    )

    #_public
    #_static
    (ยง defn #_"ByteString" WalletProtobufSerializer/hashToByteString [#_"Sha256Hash" __hash]
        (ByteString/copyFrom (.. __hash (getBytes)))
    )

    #_public
    #_static
    (ยง defn #_"Sha256Hash" WalletProtobufSerializer/byteStringToHash [#_"ByteString" __bs]
        (Sha256Hash/wrap (.. __bs (toByteArray)))
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails the provided Wallet object may be in an indeterminate state and should be thrown away.</p>
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt data,
     ; internally inconsistent data and so on.  You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
    #_public
    #_throws #_[ "UnreadableWalletException" ]
    (ยง method #_"Wallet" readWallet [#_"InputStream" __input]
        (.. this (readWallet __input, false))
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails the provided Wallet object may be in an indeterminate state and should be thrown away.  Do not
     ; simply call this method again on the same Wallet object with {@code forceReset} set {@code true}.
     ; It won't work.</p>
     ;
     ; <p>If {@code forceReset} is {@code true}, then no transactions are loaded from the wallet, and
     ; it is configured to replay transactions from the blockchain (as if the wallet had been loaded and
     ; {@link Wallet.reset} had been called immediately thereafter).
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt data,
     ; internally inconsistent data and so on. You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
    #_public
    #_throws #_[ "UnreadableWalletException" ]
    (ยง method #_"Wallet" readWallet [#_"InputStream" __input, #_"boolean" __forceReset]
        (try
            (let [#_"Protos.Wallet" __walletProto (WalletProtobufSerializer/parseToProto __input)
                  #_"String" __paramsID (.. __walletProto (getNetworkIdentifier))
                  #_"NetworkParameters" __params (NetworkParameters/fromID __paramsID)]
                (when (nil? __params)
                    (throw (UnreadableWalletException. (str "Unknown network parameters ID " __paramsID)))
                )

                (ยง return (.. this (readWallet __params, __walletProto, __forceReset)))
            )
            (catch IOException __e
                (throw (UnreadableWalletException. "Could not parse input stream to protobuf", __e))
            )
            (catch IllegalStateException __e
                (throw (UnreadableWalletException. "Could not parse input stream to protobuf", __e))
            )
            (catch IllegalArgumentException __e
                (throw (UnreadableWalletException. "Could not parse input stream to protobuf", __e))
            )
        )
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails, the provided Wallet object may be in an indeterminate state and should be thrown away.</p>
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt
     ; data, internally inconsistent data and so on.  You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
    #_public
    #_throws #_[ "UnreadableWalletException" ]
    (ยง method #_"Wallet" readWallet [#_"NetworkParameters" __params, #_"Protos.Wallet" __walletProto]
        (.. this (readWallet __params, __walletProto, false))
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails, the provided Wallet object may be in an indeterminate state and should be thrown away.  Do not
     ; simply call this method again on the same Wallet object with {@code forceReset} set {@code true}.
     ; It won't work.</p>
     ;
     ; <p>If {@code forceReset} is {@code true}, then no transactions are loaded from the wallet, and it is
     ; configured to replay transactions from the blockchain (as if the wallet had been loaded and
     ; {@link Wallet.reset} had been called immediately thereafter).
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt data,
     ; internally inconsistent data and so on.  You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
    #_public
    #_throws #_[ "UnreadableWalletException" ]
    (ยง method #_"Wallet" readWallet [#_"NetworkParameters" __params, #_"Protos.Wallet" __walletProto, #_"boolean" __forceReset]
        (when (< WalletProtobufSerializer/CURRENT_WALLET_VERSION (.. __walletProto (getVersion)))
            (throw (UnreadableWalletException.FutureVersion.))
        )
        (when (not (.. __walletProto (getNetworkIdentifier) (equals (.. __params (getId)))))
            (throw (UnreadableWalletException.WrongNetwork.))
        )

        ;; Read the scrypt parameters that specify how encryption and decryption is performed.
        (let [#_"KeyChainGroup" __keyChainGroup]
            (cond (.. __walletProto (hasEncryptionParameters))
                (do
                    (let [#_"Protos.ScryptParameters" __encryptionParameters (.. __walletProto (getEncryptionParameters))
                          #_"KeyCrypterScrypt" __keyCrypter (KeyCrypterScrypt. __encryptionParameters)]
                        (ยง ass __keyChainGroup (KeyChainGroup/fromProtobufEncrypted __params, (.. __walletProto (getKeyList)), __keyCrypter, (:key-chain-factory this)))
                    )
                )
                :else
                (do
                    (ยง ass __keyChainGroup (KeyChainGroup/fromProtobufUnencrypted __params, (.. __walletProto (getKeyList)), (:key-chain-factory this)))
                )
            )

            (let [#_"Wallet" __wallet (.. (:factory this) (create __params, __keyChainGroup))]
                (when (.. __walletProto (hasDescription))
                    (.. __wallet (setDescription (.. __walletProto (getDescription))))
                )

                (cond __forceReset
                    (do
                        ;; Should mirror Wallet.reset().
                        (.. __wallet (setLastBlockSeenHash nil))
                        (.. __wallet (setLastBlockSeenHeight -1))
                        (.. __wallet (setLastBlockSeenTimeSecs 0))
                    )
                    :else
                    (do
                        ;; Read all transactions and insert into the txMap.
                        (doseq [#_"Protos.Transaction" __txProto (.. __walletProto (getTransactionList))]
                            (.. this (readTransaction __txProto, (.. __wallet (getParams))))
                        )

                        ;; Update transaction outputs to point to inputs that spend them.
                        (doseq [#_"Protos.Transaction" __txProto (.. __walletProto (getTransactionList))]
                            (let [#_"WalletTransaction" __wtx (.. this (connectTransactionOutputs __params, __txProto))]
                                (.. __wallet (addWalletTransaction __wtx))
                            )
                        )

                        ;; Update the lastBlockSeenHash.
                        (if (not (.. __walletProto (hasLastSeenBlockHash)))
                            (.. __wallet (setLastBlockSeenHash nil))
                            (.. __wallet (setLastBlockSeenHash (WalletProtobufSerializer/byteStringToHash (.. __walletProto (getLastSeenBlockHash)))))
                        )

                        (if (not (.. __walletProto (hasLastSeenBlockHeight)))
                            (.. __wallet (setLastBlockSeenHeight -1))
                            (.. __wallet (setLastBlockSeenHeight (.. __walletProto (getLastSeenBlockHeight))))
                        )

                        ;; Will default to zero if not present.
                        (.. __wallet (setLastBlockSeenTimeSecs (.. __walletProto (getLastSeenBlockTimeSecs))))

                        (when (.. __walletProto (hasKeyRotationTime))
                            (.. __wallet (setKeyRotationTime (Date. (* (.. __walletProto (getKeyRotationTime)) 1000))))
                        )
                    )
                )

                (doseq [#_"Protos.TransactionSigner" __signerProto (.. __walletProto (getTransactionSignersList))]
                    (try
                        (let [#_"Class" __signerClass (Class/forName (.. __signerProto (getClassName)))
                              #_"TransactionSigner" __signer (cast TransactionSigner (.. __signerClass (newInstance)))]
                            (.. __signer (deserialize (.. __signerProto (getData) (toByteArray))))
                            (.. __wallet (addTransactionSigner __signer))
                        )
                        (catch Exception __e
                            (throw (UnreadableWalletException. (str "Unable to deserialize TransactionSigner instance: " (.. __signerProto (getClassName))), __e))
                        )
                    )
                )

                (when (.. __walletProto (hasVersion))
                    (.. __wallet (setVersion (.. __walletProto (getVersion))))
                )

                ;; Make sure the object can be re-used to read another wallet without corruption.
                (.. (:tx-map this) (clear))

                __wallet
            )
        )
    )

    ;;;
     ; Returns the loaded protocol buffer from the given byte stream.  You normally want
     ; {@link Wallet#loadFromFile(java.io.File)} instead - this method is designed for
     ; low level work involving the wallet file format itself.
     ;;
    #_public
    #_static
    #_throws #_[ "IOException" ]
    (ยง defn #_"Protos.Wallet" WalletProtobufSerializer/parseToProto [#_"InputStream" __input]
        (let [#_"CodedInputStream" __codedInput (CodedInputStream/newInstance __input)]
            (.. __codedInput (setSizeLimit WalletProtobufSerializer/WALLET_SIZE_LIMIT))
            (Protos.Wallet/parseFrom __codedInput)
        )
    )

    #_private
    #_throws #_[ "UnreadableWalletException" ]
    (ยง method- #_"void" readTransaction [#_"Protos.Transaction" __txProto, #_"NetworkParameters" __params]
        (let [#_"Transaction" __tx (Transaction. __params)]

            (.. __tx (setVersion (.. __txProto (getVersion))))

            (when (.. __txProto (hasUpdatedAt))
                (.. __tx (setUpdateTime (Date. (.. __txProto (getUpdatedAt)))))
            )

            (doseq [#_"Protos.TransactionOutput" __outputProto (.. __txProto (getTransactionOutputList))]
                (let [#_"Coin" __value (Coin/valueOf (.. __outputProto (getValue)))
                      #_"byte[]" __scriptBytes (.. __outputProto (getScriptBytes) (toByteArray))
                      #_"TransactionOutput" __output (TransactionOutput. __params, __tx, __value, __scriptBytes)]
                    (.. __tx (addOutput __output))
                )
            )

            (doseq [#_"Protos.TransactionInput" __inputProto (.. __txProto (getTransactionInputList))]
                (let [#_"byte[]" __scriptBytes (.. __inputProto (getScriptBytes) (toByteArray))
                      #_"TransactionOutPoint" __outpoint (TransactionOutPoint. __params, (& 0xffffffff (.. __inputProto (getTransactionOutPointIndex))), (WalletProtobufSerializer/byteStringToHash (.. __inputProto (getTransactionOutPointHash))))
                      #_"Coin" __value (when (.. __inputProto (hasValue)) (Coin/valueOf (.. __inputProto (getValue))))
                      #_"TransactionInput" __input (TransactionInput. __params, __tx, __scriptBytes, __outpoint, __value)]
                    (when (.. __inputProto (hasSequence))
                        (.. __input (setSequenceNumber (& 0xffffffff (.. __inputProto (getSequence)))))
                    )
                    (.. __tx (addInput __input))
                )
            )

            (loop-when-recur [#_"int" __i 0] (< __i (.. __txProto (getBlockHashCount))) [(inc __i)]
                (let [#_"ByteString" __blockHash (.. __txProto (getBlockHash __i))
                      #_"int" __relativityOffset 0]
                    (when (< 0 (.. __txProto (getBlockRelativityOffsetsCount)))
                        (ยง ass __relativityOffset (.. __txProto (getBlockRelativityOffsets __i)))
                    )
                    (.. __tx (addBlockAppearance (WalletProtobufSerializer/byteStringToHash __blockHash), __relativityOffset))
                )
            )

            (when (.. __txProto (hasLockTime))
                (.. __tx (setLockTime (& 0xffffffff (.. __txProto (getLockTime)))))
            )

            (cond (.. __txProto (hasPurpose))
                (do
                    (condp == (.. __txProto (getPurpose))
                        UNKNOWN                   (.. __tx (setPurpose Transaction.Purpose/UNKNOWN))
                        USER_PAYMENT              (.. __tx (setPurpose Transaction.Purpose/USER_PAYMENT))
                        KEY_ROTATION              (.. __tx (setPurpose Transaction.Purpose/KEY_ROTATION))
                        ASSURANCE_CONTRACT_CLAIM  (.. __tx (setPurpose Transaction.Purpose/ASSURANCE_CONTRACT_CLAIM))
                        ASSURANCE_CONTRACT_PLEDGE (.. __tx (setPurpose Transaction.Purpose/ASSURANCE_CONTRACT_PLEDGE))
                        ASSURANCE_CONTRACT_STUB   (.. __tx (setPurpose Transaction.Purpose/ASSURANCE_CONTRACT_STUB))
                        RAISE_FEE                 (.. __tx (setPurpose Transaction.Purpose/RAISE_FEE))
                        (throw (RuntimeException. "New purpose serialization not implemented."))
                    )
                )
                :else
                (do
                    ;; Old wallet: assume a user payment as that's the only reason a new tx would have been created back then.
                    (.. __tx (setPurpose Transaction.Purpose/USER_PAYMENT))
                )
            )

            (when (.. __txProto (hasExchangeRate))
                (let [#_"Protos.ExchangeRate" __exchangeRateProto (.. __txProto (getExchangeRate))]
                    (.. __tx (setExchangeRate (ExchangeRate. (Coin/valueOf (.. __exchangeRateProto (getCoinValue))), (Fiat/valueOf (.. __exchangeRateProto (getFiatCurrencyCode)), (.. __exchangeRateProto (getFiatValue))))))
                )
            )

            (when (.. __txProto (hasMemo))
                (.. __tx (setMemo (.. __txProto (getMemo))))
            )

            ;; Transaction should now be complete.
            (let [#_"Sha256Hash" __protoHash (WalletProtobufSerializer/byteStringToHash (.. __txProto (getHash)))]
                (when (not (.. __tx (getHash) (equals __protoHash)))
                    (throw (UnreadableWalletException. (String/format Locale/US, "Transaction did not deserialize completely: %s vs %s", (.. __tx (getHash)), __protoHash)))
                )
                (when (.. (:tx-map this) (containsKey (.. __txProto (getHash))))
                    (throw (UnreadableWalletException. (str "Wallet contained duplicate transaction " (WalletProtobufSerializer/byteStringToHash (.. __txProto (getHash))))))
                )
                (.. (:tx-map this) (put (.. __txProto (getHash)), __tx))
                nil
            )
        )
    )

    #_private
    #_throws #_[ "UnreadableWalletException" ]
    (ยง method- #_"WalletTransaction" connectTransactionOutputs [#_"NetworkParameters" __params, #_"org.bitcoinj.wallet.Protos.Transaction" __txProto]
        (let [#_"Transaction" __tx (.. (:tx-map this) (get (.. __txProto (getHash))))
              #_"WalletTransaction.Pool" __pool
                (condp ==? (.. __txProto (getPool))
                    DEAD    WalletTransaction.Pool/DEAD
                    PENDING WalletTransaction.Pool/PENDING
                    SPENT   WalletTransaction.Pool/SPENT
                    UNSPENT WalletTransaction.Pool/UNSPENT
                    ;; Upgrade old wallets: inactive pool has been merged with the pending pool.
                    ;; Remove this some time after 0.9 is old and everyone has upgraded.
                    ;; There should not be any spent outputs in this tx as old wallets would not allow them to be spent in this state.
                    [INACTIVE PENDING_INACTIVE] WalletTransaction.Pool/PENDING
                    (throw (UnreadableWalletException. (str "Unknown transaction pool: " (.. __txProto (getPool)))))
                )]

            (loop-when-recur [#_"int" __i 0] (< __i (.. __tx (getOutputs) (size))) [(inc __i)]
                (let [#_"TransactionOutput" __output (.. __tx (getOutputs) (get __i))
                      #_"Protos.TransactionOutput" __transactionOutput (.. __txProto (getTransactionOutput __i))]
                    (when (.. __transactionOutput (hasSpentByTransactionHash))
                        (let [#_"ByteString" __spentByTransactionHash (.. __transactionOutput (getSpentByTransactionHash))
                              #_"Transaction" __spendingTx (.. (:tx-map this) (get __spentByTransactionHash))]
                            (when (nil? __spendingTx)
                                (throw (UnreadableWalletException. (String/format Locale/US, "Could not connect %s to %s", (.. __tx (getHashAsString)), (WalletProtobufSerializer/byteStringToHash __spentByTransactionHash))))
                            )

                            (let [#_"int" __spendingIndex (.. __transactionOutput (getSpentByTransactionIndex))
                                  #_"TransactionInput" __input (Preconditions/checkNotNull (.. __spendingTx (getInput __spendingIndex)))]
                                (.. __input (connect __output))
                            )
                        )
                    )
                )
            )

            (when (.. __txProto (hasConfidence))
                (let [#_"Protos.TransactionConfidence" __confidenceProto (.. __txProto (getConfidence))
                      #_"TransactionConfidence" __confidence (.. __tx (getConfidence))]
                    (.. this (readConfidence __params, __tx, __confidenceProto, __confidence))
                )
            )

            (WalletTransaction. __pool, __tx)
        )
    )

    #_private
    #_throws #_[ "UnreadableWalletException" ]
    (ยง method- #_"void" readConfidence [#_"NetworkParameters" __params, #_"Transaction" __tx, #_"Protos.TransactionConfidence" __confidenceProto, #_"TransactionConfidence" __confidence]
        ;; We are lenient here because tx confidence is not an essential part of the wallet.
        ;; If the tx has an unknown type of confidence, ignore.
        (when (not (.. __confidenceProto (hasType)))
            (.. WalletProtobufSerializer/log (warn "Unknown confidence type for tx {}", (.. __tx (getHashAsString))))
            (ยง return nil)
        )

        (let [#_"TransactionConfidence.ConfidenceType" __confidenceType
                (condp == (.. __confidenceProto (getType))
                    BUILDING          TransactionConfidence.ConfidenceType/BUILDING
                    DEAD              TransactionConfidence.ConfidenceType/DEAD
                    ;; These two are equivalent (must be able to read old wallets).
                    NOT_IN_BEST_CHAIN TransactionConfidence.ConfidenceType/PENDING
                    PENDING           TransactionConfidence.ConfidenceType/PENDING
                    IN_CONFLICT       TransactionConfidence.ConfidenceType/IN_CONFLICT
                    #_"UNKNOWN"       TransactionConfidence.ConfidenceType/UNKNOWN
                )]
            (.. __confidence (setConfidenceType __confidenceType))
            (when (.. __confidenceProto (hasAppearedAtHeight))
                (when (!= (.. __confidence (getConfidenceType)) TransactionConfidence.ConfidenceType/BUILDING)
                    (.. WalletProtobufSerializer/log (warn "Have appearedAtHeight but not BUILDING for tx {}", (.. __tx (getHashAsString))))
                    (ยง return nil)
                )
                (.. __confidence (setAppearedAtChainHeight (.. __confidenceProto (getAppearedAtHeight))))
            )

            (when (.. __confidenceProto (hasDepth))
                (when (!= (.. __confidence (getConfidenceType)) TransactionConfidence.ConfidenceType/BUILDING)
                    (.. WalletProtobufSerializer/log (warn "Have depth but not BUILDING for tx {}", (.. __tx (getHashAsString))))
                    (ยง return nil)
                )
                (.. __confidence (setDepthInBlocks (.. __confidenceProto (getDepth))))
            )

            (when (.. __confidenceProto (hasOverridingTransaction))
                (when (!= (.. __confidence (getConfidenceType)) TransactionConfidence.ConfidenceType/DEAD)
                    (.. WalletProtobufSerializer/log (warn "Have overridingTransaction but not OVERRIDDEN for tx {}", (.. __tx (getHashAsString))))
                    (ยง return nil)
                )
                (let [#_"Transaction" __overridingTransaction (.. (:tx-map this) (get (.. __confidenceProto (getOverridingTransaction))))]
                    (when (nil? __overridingTransaction)
                        (.. WalletProtobufSerializer/log (warn "Have overridingTransaction that is not in wallet for tx {}", (.. __tx (getHashAsString))))
                        (ยง return nil)
                    )
                    (.. __confidence (setOverridingTransaction __overridingTransaction))
                )
            )

            (doseq [#_"Protos.PeerAddress" __proto (.. __confidenceProto (getBroadcastByList))]
                (let [#_"InetAddress" __ip]
                    (try
                        (ยง ass __ip (InetAddress/getByAddress (.. __proto (getIpAddress) (toByteArray))))
                        (catch UnknownHostException __e
                            (throw (UnreadableWalletException. "Peer IP address does not have the right length", __e))
                        )
                    )

                    (let [#_"int" __port (.. __proto (getPort))
                          #_"int" __protocolVersion (.. __params (getProtocolVersionNum NetworkParameters.ProtocolVersion/CURRENT))
                          #_"BigInteger" __services (BigInteger/valueOf (.. __proto (getServices)))
                          #_"PeerAddress" __address (PeerAddress. __params, __ip, __port, __protocolVersion, __services)]
                        (.. __confidence (markBroadcastBy __address))
                    )
                )
            )

            (when (.. __confidenceProto (hasLastBroadcastedAt))
                (.. __confidence (setLastBroadcastedAt (Date. (.. __confidenceProto (getLastBroadcastedAt)))))
            )

            (condp == (.. __confidenceProto (getSource))
                SOURCE_SELF        (.. __confidence (setSource TransactionConfidence.Source/SELF))
                SOURCE_NETWORK     (.. __confidence (setSource TransactionConfidence.Source/NETWORK))
                #_"SOURCE_UNKNOWN" (.. __confidence (setSource TransactionConfidence.Source/UNKNOWN))
            )
            nil
        )
    )

    ;;;
     ; Cheap test to see if input stream is a wallet.  This checks for a magic value at the beginning of the stream.
     ;
     ; @param is Input stream to test.
     ; @return true if input stream is a wallet.
     ;;
    #_public
    #_static
    (ยง defn #_"boolean" WalletProtobufSerializer/isWallet [#_"InputStream" __is]
        (try
            (let [#_"CodedInputStream" __cis (CodedInputStream/newInstance __is)
                  #_"int" __field (WireFormat/getTagFieldNumber (.. __cis (readTag)))]
                (if (== __field 1) ;; network_identifier
                    (ยง return (some? (NetworkParameters/fromID (.. __cis (readString)))))
                    (ยง return false)
                )
            )
            (catch IOException _
                (ยง return false)
            )
        )
    )
)

;;;
 ; Stores data about a transaction that is only relevant to the {@link org.bitcoinj.wallet.Wallet} class.
 ;;
#_public
(ยง class WalletTransaction
    #_public
    (ยง enum WalletTransaction.Pool
        (ยง item UNSPENT) ;; unspent in best chain
        (ยง item SPENT) ;; spent in best chain
        (ยง item DEAD) ;; double-spend in alt chain
        (ยง item PENDING) ;; a pending tx we would like to go into the best chain
    )
    #_private
    (ยง field- #_"Transaction" :transaction)
    #_private
    (ยง field- #_"WalletTransaction.Pool" :pool)

    #_public
    (ยง constructor WalletTransaction [#_"WalletTransaction.Pool" __pool, #_"Transaction" __transaction]
        (ยง assoc this :pool (Preconditions/checkNotNull __pool))
        (ยง assoc this :transaction __transaction)
        this
    )

    #_public
    (ยง method #_"Transaction" getTransaction []
        (:transaction this)
    )

    #_public
    (ยง method #_"WalletTransaction.Pool" getPool []
        (:pool this)
    )
)

#_(ns org.bitcoinj.wallet.listeners #_"KeyChainEventListener"
    (:import [java.util List])
   (:require [org.bitcoinj.core ECKey]
             [org.bitcoinj.wallet KeyChain]))

#_(ns org.bitcoinj.wallet.listeners #_"WalletChangeEventListener"
   (:require [org.bitcoinj.wallet Wallet]))

#_(ns org.bitcoinj.wallet.listeners #_"WalletCoinsReceivedEventListener"
   (:require [org.bitcoinj.core Coin Transaction]
             [org.bitcoinj.wallet Wallet]))

#_(ns org.bitcoinj.wallet.listeners #_"WalletCoinsSentEventListener"
   (:require [org.bitcoinj.core Coin Transaction]
             [org.bitcoinj.wallet Wallet]))

#_(ns org.bitcoinj.wallet.listeners #_"WalletReorganizeEventListener"
   (:require [org.bitcoinj.wallet Wallet]))

#_public
(ยง interface KeyChainEventListener
    ;;;
     ; Called whenever a new key is added to the key chain, whether that be via an explicit addition or due to some
     ; other automatic derivation.  See the documentation for your {@link KeyChain} implementation for details on
     ; what can trigger this event.
     ;;
    (ยง method #_"void" onKeysAdded [#_"List<ECKey>" __keys])
)

;;;
 ; <p>Implementors are called when the contents of the wallet changes, for instance due to receiving/sending money
 ; or a block chain re-organize.</p>
 ;;
#_public
(ยง interface WalletChangeEventListener
    ;;;
     ; <p>Designed for GUI applications to refresh their transaction lists.  This callback is invoked in the following
     ; situations:</p>
     ;
     ; <ol>
     ;     <li>A new block is received (and thus building transactions got more confidence).</li>
     ;     <li>A pending transaction is received.</li>
     ;     <li>A pending transaction changes confidence due to some non-new-block related event,
     ;     such as being announced by more peers or by  a double-spend conflict being observed.</li>
     ;     <li>A re-organize occurs. Call occurs only if the re-org modified any of our transactions.</li>
     ;     <li>A new spend is committed to the wallet.</li>
     ;     <li>The wallet is reset and all transactions removed.<li>
     ; </ol>
     ;
     ; <p>When this is called you can refresh the UI contents from the wallet contents.  It's more efficient to use
     ; this rather than onTransactionConfidenceChanged() + onReorganize() because you only get one callback per block
     ; rather than one per transaction per block.  Note that this is <b>not</b> called when a key is added.</p>
     ;;
    (ยง method #_"void" onWalletChanged [#_"Wallet" __wallet])
)

;;;
 ; <p>Implementors are called when the contents of the wallet changes, for instance due to receiving/sending money
 ; or a block chain re-organize.</p>
 ;;
#_public
(ยง interface WalletCoinsReceivedEventListener
    ;;;
     ; This is called when a transaction is seen that sends coins <b>to</b> this wallet, either because it was
     ; broadcast across the network or because a block was received.  If a transaction is seen when it was broadcast,
     ; onCoinsReceived won't be called again when a block containing it is received.  If you want to know when such
     ; a transaction receives its first confirmation, register a {@link TransactionConfidence} event listener using
     ; the object retrieved via {@link org.bitcoinj.core.Transaction#getConfidence()}.  It's safe to modify the
     ; wallet in this callback, for example, by spending the transaction just received.
     ;
     ; @param wallet The wallet object that received the coins.
     ; @param tx The transaction which sent us the coins.
     ; @param prevBalance Balance before the coins were received.
     ; @param newBalance This is the 'estimated' balance.
     ;;
    (ยง method #_"void" onCoinsReceived [#_"Wallet" __wallet, #_"Transaction" __tx, #_"Coin" __prevBalance, #_"Coin" __newBalance])
)

;;;
 ; <p>Implementors are called when the contents of the wallet changes, for instance due to receiving/sending money
 ; or a block chain re-organize.</p>
 ;;
#_public
(ยง interface WalletCoinsSentEventListener
    ;;;
     ; This is called when a transaction is seen that sends coins <b>from</b> this wallet, either because it
     ; was broadcast across the network or because a block was received.  This may at first glance seem useless,
     ; because in the common case you already know about such transactions because you created them with the
     ; Wallets createSend/sendCoins methods.  However when you have a wallet containing only keys, and you wish
     ; to replay the block chain to fill it with transactions, it's useful to find out when a transaction is
     ; discovered that sends coins from the wallet.
     ;
     ; It's safe to modify the wallet from inside this callback, but if you're replaying the block chain you should
     ; be careful to avoid such modifications.  Otherwise your changes may be overridden by new data from the chain.
     ;
     ; @param wallet The wallet object that this callback relates to (that sent the coins).
     ; @param tx The transaction that sent the coins to someone else.
     ; @param prevBalance The wallets balance before this transaction was seen.
     ; @param newBalance The wallets balance after this transaction was seen.  This is the 'estimated' balance.
     ;;
    (ยง method #_"void" onCoinsSent [#_"Wallet" __wallet, #_"Transaction" __tx, #_"Coin" __prevBalance, #_"Coin" __newBalance])
)

;;;
 ; <p>Implementors are called when the wallet is reorganized.</p>
 ;;
#_public
(ยง interface WalletReorganizeEventListener
    ;; TODO: Finish onReorganize to be more useful.
    ;;;
     ; <p>This is called when a block is received that triggers a block chain re-organization.</p>
     ;
     ; <p>A re-organize means that the consensus (chain) of the network has diverged and now changed from
     ; what we believed it was previously.  Usually this won't matter because the new consensus will include
     ; all our old transactions assuming we are playing by the rules.  However it's theoretically possible
     ; for our balance to change in arbitrary ways, most likely, we could lose some money we thought we had.</p>
     ;
     ; <p>It is safe to use methods of wallet whilst inside this callback.</p>
     ;;
    (ยง method #_"void" onReorganize [#_"Wallet" __wallet])
)
