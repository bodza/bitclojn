(ns bitclojn.core)

(defmacro § [& _])
(defmacro ß [& _])

(defmacro def- [s i] `(def ~(vary-meta s assoc :private true) ~i))

(defmacro when' [y & w]
    (let [[_ & w] (if (= '=> (first w)) (rest w) (cons nil w))]
        `(if ~y (do ~@w) ~_)))
(defmacro let-when [x y & w]
    (let [[_ & w] (if (= '=> (first w)) (rest w) (cons nil w))]
        `(let [~@x] (if ~y (do ~@w) ~_))))

(defn -main [& args]
    )

#_(ns org.bitcoinj.core #_"AbstractBlockChain"
    (:import [java.util *]
             [java.util.concurrent *]
             [java.util.concurrent.locks *])
    (:import [com.google.common.base *]
             [com.google.common.collect *]
             [com.google.common.util.concurrent *]
             [org.slf4j *])
   (:require [org.bitcoinj.core.listeners *]
             [org.bitcoinj.store *]
             [org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>An AbstractBlockChain holds a series of {@link Block} objects, links them together, and knows how to verify that
 ; the chain follows the rules of the {@link NetworkParameters} for this chain.</p>
 ;
 ; <p>It can be connected to a {@link Wallet}, and also {@link TransactionReceivedInBlockListener}s that can receive
 ; transactions and notifications of re-organizations.</p>
 ;
 ; <p>An AbstractBlockChain implementation must be connected to a {@link BlockStore} implementation.  The chain object
 ; by itself doesn't store any data, that's delegated to the store.  Which store you use is a decision best made by
 ; reading the getting started guide, but briefly, fully validating block chains need fully validating stores.  In
 ; the lightweight SPV mode, a {@link org.bitcoinj.store.SPVBlockStore} is the right choice.</p>
 ;
 ; <p>This class implements an abstract class which makes it simple to create a BlockChain that does/doesn't do
 ; full verification.  It verifies headers and is implements most of what is required to implement SPV mode, but
 ; also provides callback hooks which can be used to do full verification.</p>
 ;
 ; <p>There are two subclasses of AbstractBlockChain that are useful: {@link BlockChain}, which is the simplest
 ; class and implements <i>simplified payment verification</i>.  This is a lightweight and efficient mode that
 ; does not verify the contents of blocks, just their headers.  A {@link FullPrunedBlockChain} paired with a
 ; {@link org.bitcoinj.store.H2FullPrunedBlockStore} implements full verification, which is equivalent to
 ; Bitcoin Core.  To learn more about the alternative security models, please consult the articles on the
 ; website.</p>
 ;
 ; <b>Theory</b>
 ;
 ; <p>The 'chain' is actually a tree although in normal operation it operates mostly as a list of {@link Block}s.
 ; When multiple new head blocks are found simultaneously, there are multiple stories of the economy competing to become
 ; the one true consensus.  This can happen naturally when two miners solve a block within a few seconds of each other,
 ; or it can happen when the chain is under attack.</p>
 ;
 ; <p>A reference to the head block of the best known chain is stored.  If you can reach the genesis block by repeatedly
 ; walking through the prevBlock pointers, then we say this is a full chain.  If you cannot reach the genesis block
 ; we say it is an orphan chain.  Orphan chains can occur when blocks are solved and received during the initial block
 ; chain download, or if we connect to a peer that doesn't send us blocks in order.</p>
 ;
 ; <p>A reorganize occurs when the blocks that make up the best known chain changes.  Note that simply adding a
 ; new block to the top of the best chain isn't as reorganize, but that a reorganize is always triggered by adding
 ; a new block that connects to some other (non best head) block.  By "best" we mean the chain representing the largest
 ; amount of work done.</p>
 ;
 ; <p>Every so often the block chain passes a difficulty transition point.  At that time, all the blocks in the last
 ; 2016 blocks are examined and a new difficulty target is calculated from them.</p>
 ;;
#_public
#_abstract
(§ class #_"AbstractBlockChain"
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"AbstractBlockChain"))))

    #_protected
    #_final
    (§ field #_"ReentrantLock" (§ name lock) (§ expr Threading/lock(§ pars "blockchain")))

    ;;; Keeps a map of block hashes to StoredBlocks. ;;
    #_private
    #_final
    (§ field #_"BlockStore" (§ name blockStore))

    ;;;
     ; Tracks the top of the best known chain.
     ;
     ; Following this one down to the genesis block produces the story of the economy from the creation of Bitcoin
     ; until the present day.  The chain head can change if a new set of blocks is received that results in a chain of
     ; greater work than the one obtained by following this one down.  In that case a reorganize is triggered,
     ; potentially invalidating transactions in our wallet.
     ;;
    #_protected
    (§ field #_"StoredBlock" (§ name chainHead))

    ;; TODO: Scrap this and use a proper read/write for all of the block chain objects.
    ;; The chainHead field is read/written synchronized with this object rather than BlockChain.  However writing is
    ;; also guaranteed to happen whilst BlockChain is synchronized (see setChainHead).  The goal of this is to let
    ;; clients quickly access the chain head even whilst the block chain is downloading and thus the BlockChain is
    ;; locked most of the time.
    #_private
    #_final
    (§ field #_"Object" (§ name chainHeadLock) (§ new #_"Object" (§ pars )))

    #_protected
    #_final
    (§ field #_"NetworkParameters" (§ name params))
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<NewBestBlockListener>>" (§ name newBestBlockListeners))
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<ReorganizeListener>>" (§ name reorganizeListeners))
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<TransactionReceivedInBlockListener>>" (§ name transactionReceivedListeners))

    ;; Holds a block header and, optionally, a list of tx hashes or block's transactions.
    (§ class #_"OrphanBlock"
        #_final
        (§ field #_"Block" (§ name block))
        #_final
        (§ field #_"List<Sha256Hash>" (§ name filteredTxHashes))
        #_final
        (§ field #_"Map<Sha256Hash, Transaction>" (§ name filteredTxn))

        (§ constructor #_"OrphanBlock" [#_"Block" (§ name block), #_nilable #_"List<Sha256Hash>" (§ name filteredTxHashes), #_nilable #_"Map<Sha256Hash, Transaction>" (§ name filteredTxn)])
        (§ block
            #_final
            (§ var #_"boolean" (§ name filtered) (§ expr filteredTxHashes != nil && filteredTxn != nil))
            (§ expr Preconditions/checkArgument(§ pars (§ expr block.transactions == nil && filtered) || (§ expr block.transactions != nil && (§ not filtered))))
            (§ ass (§ name this.block) block)
            (§ ass (§ name this.filteredTxHashes) filteredTxHashes)
            (§ ass (§ name this.filteredTxn) filteredTxn)
            (§ void this)
        )
    )
    ;; Holds blocks that we have received but can't plug into the chain yet, e.g. because they were created whilst we
    ;; were downloading the block chain.
    #_private
    #_final
    (§ field #_"LinkedHashMap<Sha256Hash, OrphanBlock>" (§ name orphanBlocks) (§ new #_"LinkedHashMap<>" (§ pars )))

    ;;; False positive estimation uses a double exponential moving average. ;;
    #_public
    #_static
    #_final
    (§ field #_"double" (§ name FP_ESTIMATOR_ALPHA) 0.0001)
    ;;; False positive estimation uses a double exponential moving average. ;;
    #_public
    #_static
    #_final
    (§ field #_"double" (§ name FP_ESTIMATOR_BETA) 0.01)

    #_private
    (§ field #_"double" (§ name falsePositiveRate))
    #_private
    (§ field #_"double" (§ name falsePositiveTrend))
    #_private
    (§ field #_"double" (§ name previousFalsePositiveRate))

    #_private
    #_final
    (§ field #_"VersionTally" (§ name versionTally))

    ;;; See {@link #AbstractBlockChain(Context, List, BlockStore)} ;;
    #_public
    (§ constructor #_"AbstractBlockChain" [#_"NetworkParameters" (§ name params), #_"List<? extends Wallet>" (§ name transactionReceivedListeners), #_"BlockStore" (§ name blockStore)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ this (§ pars Context/getOrCreate(§ pars params), transactionReceivedListeners, blockStore))
        (§ void this)
    )

    ;;;
     ; Constructs a BlockChain connected to the given list of listeners (e.g. wallets) and a store.
     ;;
    #_public
    (§ constructor #_"AbstractBlockChain" [#_"Context" (§ name context), #_"List<? extends Wallet>" (§ name wallets), #_"BlockStore" (§ name blockStore)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ ass (§ name this.blockStore) blockStore)
        (§ ass (§ name chainHead) (§ expr blockStore.getChainHead(§ pars )))
        (§ expr log.info(§ pars "chain head is at height {}:\n{}", chainHead.getHeight(§ pars ), chainHead.getHeader(§ pars )))
        (§ ass (§ name this.params) (§ expr context.getParams(§ pars )))

        (§ ass (§ name this.newBestBlockListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
        (§ ass (§ name this.reorganizeListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
        (§ ass (§ name this.transactionReceivedListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
        (§ for (§ var #_"NewBestBlockListener" (§ name l)) :for wallets)
        (§ block
            (§ expr addNewBestBlockListener(§ pars Threading/SAME_THREAD, l))
        )
        (§ for (§ var #_"ReorganizeListener" (§ name l)) :for wallets)
        (§ block
            (§ expr addReorganizeListener(§ pars Threading/SAME_THREAD, l))
        )
        (§ for (§ var #_"TransactionReceivedInBlockListener" (§ name l)) :for wallets)
        (§ block
            (§ expr addTransactionReceivedListener(§ pars Threading/SAME_THREAD, l))
        )

        (§ ass (§ name this.versionTally) (§ new #_"VersionTally" (§ pars context.getParams(§ pars ))))
        (§ expr this.versionTally.initialize(§ pars blockStore, chainHead))
        (§ void this)
    )

    ;;;
     ; Add a wallet to the BlockChain.  Note that the wallet will be unaffected by any blocks received while it
     ; was not part of this BlockChain.  This method is useful if the wallet has just been created, and its keys
     ; have never been in use, or if the wallet has been loaded along with the BlockChain.  Note that adding
     ; multiple wallets is not well tested!
     ;;
    #_public
    #_final
    (§ method #_"void" (§ fn addWallet) [#_"Wallet" (§ name wallet)])
    (§ block
        (§ expr addNewBestBlockListener(§ pars Threading/SAME_THREAD, wallet))
        (§ expr addReorganizeListener(§ pars Threading/SAME_THREAD, wallet))
        (§ expr addTransactionReceivedListener(§ pars Threading/SAME_THREAD, wallet))

        (§ var #_"int" (§ name walletHeight) (§ expr wallet.getLastBlockSeenHeight(§ pars )))
        (§ var #_"int" (§ name chainHeight) (§ expr getBestChainHeight(§ pars )))
        (§ if (§ expr walletHeight != chainHeight))
        (§ block
            (§ expr log.warn(§ pars "Wallet/chain height mismatch: {} vs {}", walletHeight, chainHeight))
            (§ expr log.warn(§ pars "Hashes: {} vs {}", wallet.getLastBlockSeenHash(§ pars ), getChainHead(§ pars ).getHeader(§ pars ).getHash(§ pars )))

            ;; This special case happens when the VM crashes because of a transaction received.  It causes the updated
            ;; block store to persist, but not the wallet.  In order to fix the issue, we roll back the block store to
            ;; the wallet height to make it look like as if the block has never been received.
            (§ if (§ expr 0 < walletHeight && walletHeight < chainHeight))
            (§ block
                (§ try )
                (§ block
                    (§ expr rollbackBlockStore(§ pars walletHeight))
                    (§ expr log.info(§ pars "Rolled back block store to height {}.", walletHeight))
                )
                (§ catch #_"BlockStoreException" (§ name _))
                (§ block
                    (§ expr log.warn(§ pars "Rollback of block store failed, continuing with mismatched heights. This can happen due to a replay."))
                )
            )
        )
        (§ void nil)
    )

    ;;; Removes a wallet from the chain. ;;
    #_public
    (§ method #_"void" (§ fn removeWallet) [#_"Wallet" (§ name wallet)])
    (§ block
        (§ expr removeNewBestBlockListener(§ pars wallet))
        (§ expr removeReorganizeListener(§ pars wallet))
        (§ expr removeTransactionReceivedListener(§ pars wallet))
        (§ void nil)
    )

    ;;; Replaced with more specific listener methods: use them instead. ;;
    #_deprecated
    #_suppress(§ opt "deprecation")
    #_public
    (§ method #_"void" (§ fn addListener) [#_"BlockChainListener" (§ name listener)])
    (§ block
        (§ expr addListener(§ pars listener, Threading/USER_THREAD))
        (§ void nil)
    )

    ;;; Replaced with more specific listener methods: use them instead. ;;
    #_deprecated
    #_public
    (§ method #_"void" (§ fn addListener) [#_"BlockChainListener" (§ name listener), #_"Executor" (§ name executor)])
    (§ block
        (§ expr addReorganizeListener(§ pars executor, listener))
        (§ expr addNewBestBlockListener(§ pars executor, listener))
        (§ expr addTransactionReceivedListener(§ pars executor, listener))
        (§ void nil)
    )

    #_deprecated
    #_public
    (§ method #_"void" (§ fn removeListener) [#_"BlockChainListener" (§ name listener)])
    (§ block
        (§ expr removeReorganizeListener(§ pars listener))
        (§ expr removeNewBestBlockListener(§ pars listener))
        (§ expr removeTransactionReceivedListener(§ pars listener))
        (§ void nil)
    )

    ;;;
     ; Adds a {@link NewBestBlockListener} listener to the chain.
     ;;
    #_public
    (§ method #_"void" (§ fn addNewBestBlockListener) [#_"NewBestBlockListener" (§ name listener)])
    (§ block
        (§ expr addNewBestBlockListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;;
     ; Adds a {@link NewBestBlockListener} listener to the chain.
     ;;
    #_public
    #_final
    (§ method #_"void" (§ fn addNewBestBlockListener) [#_"Executor" (§ name executor), #_"NewBestBlockListener" (§ name listener)])
    (§ block
        (§ expr newBestBlockListeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars listener, executor))))
        (§ void nil)
    )

    ;;;
     ; Adds a generic {@link ReorganizeListener} listener to the chain.
     ;;
    #_public
    (§ method #_"void" (§ fn addReorganizeListener) [#_"ReorganizeListener" (§ name listener)])
    (§ block
        (§ expr addReorganizeListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;;
     ; Adds a generic {@link ReorganizeListener} listener to the chain.
     ;;
    #_public
    #_final
    (§ method #_"void" (§ fn addReorganizeListener) [#_"Executor" (§ name executor), #_"ReorganizeListener" (§ name listener)])
    (§ block
        (§ expr reorganizeListeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars listener, executor))))
        (§ void nil)
    )

    ;;;
     ; Adds a generic {@link TransactionReceivedInBlockListener} listener to the chain.
     ;;
    #_public
    (§ method #_"void" (§ fn addTransactionReceivedListener) [#_"TransactionReceivedInBlockListener" (§ name listener)])
    (§ block
        (§ expr addTransactionReceivedListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;;
     ; Adds a generic {@link TransactionReceivedInBlockListener} listener to the chain.
     ;;
    #_public
    #_final
    (§ method #_"void" (§ fn addTransactionReceivedListener) [#_"Executor" (§ name executor), #_"TransactionReceivedInBlockListener" (§ name listener)])
    (§ block
        (§ expr transactionReceivedListeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars listener, executor))))
        (§ void nil)
    )

    ;;;
     ; Removes the given {@link NewBestBlockListener} from the chain.
     ;;
    #_public
    (§ method #_"void" (§ fn removeNewBestBlockListener) [#_"NewBestBlockListener" (§ name listener)])
    (§ block
        (§ expr ListenerRegistration/removeFromList(§ pars listener, newBestBlockListeners))
        (§ void nil)
    )

    ;;;
     ; Removes the given {@link ReorganizeListener} from the chain.
     ;;
    #_public
    (§ method #_"void" (§ fn removeReorganizeListener) [#_"ReorganizeListener" (§ name listener)])
    (§ block
        (§ expr ListenerRegistration/removeFromList(§ pars listener, reorganizeListeners))
        (§ void nil)
    )

    ;;;
     ; Removes the given {@link TransactionReceivedInBlockListener} from the chain.
     ;;
    #_public
    (§ method #_"void" (§ fn removeTransactionReceivedListener) [#_"TransactionReceivedInBlockListener" (§ name listener)])
    (§ block
        (§ expr ListenerRegistration/removeFromList(§ pars listener, transactionReceivedListeners))
        (§ void nil)
    )

    ;;;
     ; Returns the {@link BlockStore} the chain was constructed with.  You can use this to iterate over the chain.
     ;;
    #_public
    (§ method #_"BlockStore" (§ fn getBlockStore) [])
    (§ block
        (§ return blockStore)
    )

    ;;;
     ; Adds/updates the given {@link Block} with the block store.
     ; This version is used when the transactions have not been verified.
     ; @param storedPrev The {@link StoredBlock} which immediately precedes block.
     ; @param block The {@link Block} to add/update.
     ; @return the newly created {@link StoredBlock}
     ;;
    #_protected
    #_abstract
    (§ method #_"StoredBlock" (§ fn addToBlockStore) [#_"StoredBlock" (§ name storedPrev), #_"Block" (§ name block)])
        (§ throws #_"BlockStoreException", #_"VerificationException")

    ;;;
     ; Adds/updates the given {@link StoredBlock} with the block store.
     ; This version is used when the transactions have already been verified to properly spend txOutputChanges.
     ; @param storedPrev The {@link StoredBlock} which immediately precedes block.
     ; @param header The {@link StoredBlock} to add/update.
     ; @param txOutputChanges The total sum of all changes made by this block to the set of open transaction outputs
     ;                        (from a call to connectTransactions), if in fully verifying mode (null otherwise).
     ; @return the newly created {@link StoredBlock}
     ;;
    #_protected
    #_abstract
    (§ method #_"StoredBlock" (§ fn addToBlockStore) [#_"StoredBlock" (§ name storedPrev), #_"Block" (§ name header), #_nilable #_"TransactionOutputChanges" (§ name txOutputChanges)])
        (§ throws #_"BlockStoreException", #_"VerificationException")

    ;;;
     ; Rollback the block store to a given height.  This is currently only supported by {@link BlockChain} instances.
     ;
     ; @throws BlockStoreException
     ;             if the operation fails or is unsupported.
     ;;
    #_protected
    #_abstract
    (§ method #_"void" (§ fn rollbackBlockStore) [#_"int" (§ name height)])
        (§ throws #_"BlockStoreException")

    ;;;
     ; Called before setting chain head in memory.
     ; Should write the new head to block store and then commit any database transactions
     ; that were started by disconnectTransactions/connectTransactions.
     ;;
    #_protected
    #_abstract
    (§ method #_"void" (§ fn doSetChainHead) [#_"StoredBlock" (§ name chainHead)])
        (§ throws #_"BlockStoreException")

    ;;;
     ; Called if we (possibly) previously called disconnectTransaction/connectTransactions,
     ; but will not be calling preSetChainHead as a block failed verification.
     ; Can be used to abort database transactions that were started by
     ; disconnectTransactions/connectTransactions.
     ;;
    #_protected
    #_abstract
    (§ method #_"void" (§ fn notSettingChainHead) [])
        (§ throws #_"BlockStoreException")

    ;;;
     ; For a standard BlockChain, this should return blockStore.get(hash),
     ; for a FullPrunedBlockChain blockStore.getOnceUndoableStoredBlock(hash)
     ;;
    #_protected
    #_abstract
    (§ method #_"StoredBlock" (§ fn getStoredBlockInCurrentScope) [#_"Sha256Hash" (§ name hash)])
        (§ throws #_"BlockStoreException")

    ;;;
     ; Processes a received block and tries to add it to the chain.  If there's something wrong with the block an
     ; exception is thrown.  If the block is OK but cannot be connected to the chain at this time, returns false.
     ; If the block can be connected to the chain, returns true.
     ; Accessing block's transactions in another thread while this method runs may result in undefined behavior.
     ;;
    #_public
    (§ method #_"boolean" (§ fn add) [#_"Block" (§ name block)])
        (§ throws #_"VerificationException", #_"PrunedException")
    (§ block
        (§ try )
        (§ block
            (§ return (§ expr add(§ pars block, true, nil, nil)))
        )
        (§ catch #_"BlockStoreException" (§ name e))
        (§ block
            ;; TODO: Figure out a better way to propagate this exception to the user.
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
        (§ catch #_"VerificationException" (§ name e))
        (§ block
            (§ try )
            (§ block
                (§ expr notSettingChainHead(§ pars ))
            )
            (§ catch #_"BlockStoreException" (§ name e1))
            (§ block
                (§ throw (§ new #_"RuntimeException" (§ pars e1)))
            )
            (§ throw (§ new #_"VerificationException" (§ pars "Could not verify block:\n" + block, e)))
        )
    )

    ;;;
     ; Processes a received block and tries to add it to the chain.  If there's something wrong with the block an
     ; exception is thrown.  If the block is OK but cannot be connected to the chain at this time, returns false.
     ; If the block can be connected to the chain, returns true.
     ;;
    #_public
    (§ method #_"boolean" (§ fn add) [#_"FilteredBlock" (§ name block)])
        (§ throws #_"VerificationException", #_"PrunedException")
    (§ block
        (§ try )
        (§ block
            ;; The block has a list of hashes of transactions that matched the Bloom filter, and a list of associated
            ;; Transaction objects.  There may be fewer Transaction objects than hashes, this is expected.  It can happen
            ;; in the case where we were already around to witness the initial broadcast, so we downloaded the
            ;; transaction and sent it to the wallet before this point (the wallet may have thrown it away if it was
            ;; a false positive, as expected in any Bloom filtering scheme).  The filteredTxn list here will usually
            ;; only be full of data when we are catching up to the head of the chain and thus haven't witnessed any
            ;; of the transactions.
            (§ return (§ expr add(§ pars block.getBlockHeader(§ pars ), true, block.getTransactionHashes(§ pars ), block.getAssociatedTransactions(§ pars ))))
        )
        (§ catch #_"BlockStoreException" (§ name e))
        (§ block
            ;; TODO: Figure out a better way to propagate this exception to the user.
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
        (§ catch #_"VerificationException" (§ name e))
        (§ block
            (§ try )
            (§ block
                (§ expr notSettingChainHead(§ pars ))
            )
            (§ catch #_"BlockStoreException" (§ name e1))
            (§ block
                (§ throw (§ new #_"RuntimeException" (§ pars e1)))
            )
            (§ throw (§ new #_"VerificationException" (§ pars "Could not verify block " + block.getHash(§ pars ) + "\n" + block, e)))
        )
    )

    ;;;
     ; Whether or not we are maintaining a set of unspent outputs and are verifying all transactions.
     ; Also indicates that all calls to add() should provide a block containing transactions
     ;;
    #_protected
    #_abstract
    (§ method #_"boolean" (§ fn shouldVerifyTransactions) [])

    ;;;
     ; Connect each transaction in block.transactions, verifying them as we go and removing spent outputs
     ; If an error is encountered in a transaction, no changes should be made to the underlying BlockStore
     ; and a VerificationException should be thrown.
     ; Only called if shouldVerifyTransactions().
     ; @throws VerificationException if an attempt was made to spend an already-spent output, or if a transaction incorrectly solved an output script.
     ; @throws BlockStoreException if the block store had an underlying error.
     ; @return The full set of all changes made to the set of open transaction outputs.
     ;;
    #_protected
    #_abstract
    (§ method #_"TransactionOutputChanges" (§ fn connectTransactions) [#_"int" (§ name height), #_"Block" (§ name block)])
        (§ throws #_"VerificationException", #_"BlockStoreException")

    ;;;
     ; Load newBlock from BlockStore and connect its transactions, returning changes to the set of unspent transactions.
     ; If an error is encountered in a transaction, no changes should be made to the underlying BlockStore.
     ; Only called if shouldVerifyTransactions().
     ; @throws PrunedException if newBlock does not exist as a {@link StoredUndoableBlock} in the block store.
     ; @throws VerificationException if an attempt was made to spend an already-spent output, or if a transaction incorrectly solved an output script.
     ; @throws BlockStoreException if the block store had an underlying error or newBlock does not exist in the block store at all.
     ; @return The full set of all changes made to the set of open transaction outputs.
     ;;
    #_protected
    #_abstract
    (§ method #_"TransactionOutputChanges" (§ fn connectTransactions) [#_"StoredBlock" (§ name newBlock)])
        (§ throws #_"VerificationException", #_"BlockStoreException", #_"PrunedException")

    ;; filteredTxHashList contains all transactions, filteredTxn just a subset
    #_private
    (§ method #_"boolean" (§ fn add) [#_"Block" (§ name block), #_"boolean" (§ name tryConnecting), #_nilable #_"List<Sha256Hash>" (§ name filteredTxHashList), #_nilable #_"Map<Sha256Hash, Transaction>" (§ name filteredTxn)])
        (§ throws #_"BlockStoreException", #_"VerificationException", #_"PrunedException")
    (§ block
        ;; TODO: Use read/write locks to ensure that during chain download properties are still low latency.
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; Quick check for duplicates to avoid an expensive check further down (in findSplit).
            ;; This can happen a lot when connecting orphan transactions due to the dumb brute force algorithm we use.
            (§ if (§ expr block.equals(§ pars getChainHead(§ pars ).getHeader(§ pars ))))
            (§ block
                (§ return true)
            )
            (§ if (§ expr tryConnecting && orphanBlocks.containsKey(§ pars block.getHash(§ pars ))))
            (§ block
                (§ return false)
            )

            ;; If we want to verify transactions (i.e. we are running with full blocks), verify that block has transactions.
            (§ if (§ expr shouldVerifyTransactions(§ pars ) && block.transactions == nil))
            (§ block
                (§ throw (§ new #_"VerificationException" (§ pars "Got a block header while running in full-block mode")))
            )

            ;; Check for already-seen block, but only for full pruned mode, where the DB is
            ;; more likely able to handle these queries quickly.
            (§ if (§ expr shouldVerifyTransactions(§ pars ) && blockStore.get(§ pars block.getHash(§ pars )) != nil))
            (§ block
                (§ return true)
            )

            #_final
            (§ var #_"StoredBlock" (§ name storedPrev))
            #_final
            (§ var #_"int" (§ name height))
            #_final
            (§ var #_"EnumSet<Block.VerifyFlag>" (§ name flags))

            ;; Prove the block is internally valid: hash is lower than target, etc.  This only checks the block contents
            ;; if there is a tx sending or receiving coins using an address in one of our wallets.  And those transactions
            ;; are only lightly verified: presence in a valid connecting block is taken as proof of validity.  See the
            ;; article here for more details: https://bitcoinj.github.io/security-model
            (§ try )
            (§ block
                (§ expr block.verifyHeader(§ pars ))
                (§ ass (§ name storedPrev) (§ expr getStoredBlockInCurrentScope(§ pars block.getPrevBlockHash(§ pars ))))
                (§ if (§ expr storedPrev != nil))
                (§ block
                    (§ ass (§ name height) (§ expr storedPrev.getHeight(§ pars ) + 1))
                )
                (§ else )
                (§ block
                    (§ ass (§ name height) (§ expr Block/BLOCK_HEIGHT_UNKNOWN))
                )
                (§ ass (§ name flags) (§ expr params.getBlockVerificationFlags(§ pars block, versionTally, height)))
                (§ if (§ expr shouldVerifyTransactions(§ pars )))
                (§ block
                    (§ expr block.verifyTransactions(§ pars height, flags))
                )
            )
            (§ catch #_"VerificationException" (§ name e))
            (§ block
                (§ expr log.error(§ pars "Failed to verify block: ", e))
                (§ expr log.error(§ pars block.getHashAsString(§ pars )))
                (§ throw e)
            )

            ;; Try linking it to a place in the currently known blocks.

            (§ if (§ expr storedPrev == nil))
            (§ block
                ;; We can't find the previous block.  Probably we are still in the process of downloading the chain and
                ;; a block was solved whilst we were doing it.  We put it to one side and try to connect it later when we
                ;; have more blocks.
                (§ expr Preconditions/checkState(§ pars tryConnecting, "bug in tryConnectingOrphans"))
                (§ expr log.warn(§ pars "Block does not connect: {} prev {}", block.getHashAsString(§ pars ), block.getPrevBlockHash(§ pars )))
                (§ expr orphanBlocks.put(§ pars block.getHash(§ pars ), new OrphanBlock(§ pars block, filteredTxHashList, filteredTxn)))
                (§ return false)
            )

            (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
            ;; It connects to somewhere on the chain.  Not necessarily the top of the best known chain.
            (§ expr params.checkDifficultyTransitions(§ pars storedPrev, block, blockStore))
            (§ expr connectBlock(§ pars block, storedPrev, shouldVerifyTransactions(§ pars ), filteredTxHashList, filteredTxn))

            (§ if tryConnecting)
            (§ block
                (§ expr tryConnectingOrphans(§ pars ))
            )

            (§ return true)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the hashes of the currently stored orphan blocks and then deletes them from this objects storage.
     ; Used by Peer when a filter exhaustion event has occurred and thus any orphan blocks that have been downloaded
     ; might be inaccurate/incomplete.
     ;;
    #_public
    (§ method #_"Set<Sha256Hash>" (§ fn drainOrphanBlocks) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"Set<Sha256Hash>" (§ name hashes) (§ new #_"HashSet<>" (§ pars orphanBlocks.keySet(§ pars ))))
            (§ expr orphanBlocks.clear(§ pars ))
            (§ return hashes)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;; expensiveChecks enables checks that require looking at blocks further back in the chain
    ;; than the previous one when connecting (e.g. median timestamp check)
    ;; It could be exposed, but for now we just set it to shouldVerifyTransactions()
    #_private
    (§ method #_"void" (§ fn connectBlock) [#_final #_"Block" (§ name block), #_"StoredBlock" (§ name storedPrev), #_"boolean" (§ name expensiveChecks), #_nilable #_final #_"List<Sha256Hash>" (§ name filteredTxHashList), #_nilable #_final #_"Map<Sha256Hash, Transaction>" (§ name filteredTxn)])
        (§ throws #_"BlockStoreException", #_"VerificationException", #_"PrunedException")
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ var #_"boolean" (§ name filtered) (§ expr filteredTxHashList != nil && filteredTxn != nil))
        ;; Check that we aren't connecting a block that fails a checkpoint check.
        (§ if (§ expr (§ not params.passesCheckpoint(§ pars storedPrev.getHeight(§ pars ) + 1, block.getHash(§ pars )))))
        (§ block
            (§ throw (§ new #_"VerificationException" (§ pars "Block failed checkpoint lockin at " + (§ expr storedPrev.getHeight(§ pars ) + 1))))
        )
        (§ if (§ expr shouldVerifyTransactions(§ pars )))
        (§ block
            (§ expr Preconditions/checkNotNull(§ pars block.transactions))
            (§ for (§ var #_"Transaction" (§ name tx)) :for (§ expr block.transactions))
            (§ block
                (§ if (§ expr (§ not tx.isFinal(§ pars storedPrev.getHeight(§ pars ) + 1, block.getTimeSeconds(§ pars )))))
                (§ block
                    (§ throw (§ new #_"VerificationException" (§ pars "Block contains non-final transaction")))
                )
            )
        )

        (§ var #_"StoredBlock" (§ name head) (§ expr getChainHead(§ pars )))
        (§ if (§ expr storedPrev.equals(§ pars head)))
        (§ block
            (§ if (§ expr filtered && 0 < filteredTxn.size(§ pars )))
            (§ block
                (§ expr log.debug(§ pars "Block {} connects to top of best chain with {} transaction(s) of which we were sent {}", block.getHashAsString(§ pars ), filteredTxHashList.size(§ pars ), filteredTxn.size(§ pars )))
                (§ for (§ var #_"Sha256Hash" (§ name hash)) :for filteredTxHashList)
                (§ block
                    (§ expr log.debug(§ pars "  matched tx {}", hash))
                )
            )
            (§ if (§ expr expensiveChecks && block.getTimeSeconds(§ pars ) <= getMedianTimestampOfRecentBlocks(§ pars head, blockStore)))
            (§ block
                (§ throw (§ new #_"VerificationException" (§ pars "Block's timestamp is too early")))
            )

            ;; BIP 66 & 65: Enforce block version 3/4 once they are a supermajority of blocks.
            ;; NOTE: This requires 1,000 blocks since the last checkpoint (on main net, less on test) in order to be applied.
            ;; It is also limited to stopping addition of new v2/3 blocks to the tip of the chain.
            (§ if (§ expr block.getVersion(§ pars ) == Block/BLOCK_VERSION_BIP34 || block.getVersion(§ pars ) == Block/BLOCK_VERSION_BIP66))
            (§ block
                #_final
                (§ var #_"Integer" (§ name count) (§ expr versionTally.getCountAtOrAbove(§ pars block.getVersion(§ pars ) + 1)))
                (§ if (§ expr count != nil && params.getMajorityRejectBlockOutdated(§ pars ) <= count))
                (§ block
                    (§ throw (§ new #_"VerificationException.BlockVersionOutOfDate" (§ pars block.getVersion(§ pars ))))
                )
            )

            ;; This block connects to the best known block, it is a normal continuation of the system.
            (§ var #_"TransactionOutputChanges" (§ name txOutChanges) nil)
            (§ if (§ expr shouldVerifyTransactions(§ pars )))
            (§ block
                (§ ass (§ name txOutChanges) (§ expr connectTransactions(§ pars storedPrev.getHeight(§ pars ) + 1, block)))
            )
            (§ var #_"StoredBlock" (§ name newStoredBlock) (§ expr addToBlockStore(§ pars storedPrev, (§ quest (§ expr block.transactions == nil) ? block :else (§ expr block.cloneAsHeader(§ pars ))), txOutChanges)))
            (§ expr versionTally.add(§ pars block.getVersion(§ pars )))
            (§ expr setChainHead(§ pars newStoredBlock))
            (§ expr log.debug(§ pars "Chain is now {} blocks high, running listeners", newStoredBlock.getHeight(§ pars )))
            (§ expr informListenersForNewBlock(§ pars block, NewBlockType/BEST_CHAIN, filteredTxHashList, filteredTxn, newStoredBlock))
        )
        (§ else )
        (§ block
            ;; This block connects to somewhere other than the top of the best known chain.  We treat these differently.
            ;;
            ;; Note that we send the transactions to the wallet FIRST, even if we're about to re-organize this block
            ;; to become the new best chain head.  This simplifies handling of the re-org in the Wallet class.
            (§ var #_"StoredBlock" (§ name newBlock) (§ expr storedPrev.build(§ pars block)))
            (§ var #_"boolean" (§ name haveNewBestChain) (§ expr newBlock.moreWorkThan(§ pars head)))
            (§ if haveNewBestChain)
            (§ block
                (§ expr log.info(§ pars "Block is causing a re-organize"))
            )
            (§ else )
            (§ block
                (§ var #_"StoredBlock" (§ name splitPoint) (§ expr findSplit(§ pars newBlock, head, blockStore)))
                (§ if (§ expr splitPoint != nil && splitPoint.equals(§ pars newBlock)))
                (§ block
                    ;; newStoredBlock is a part of the same chain, there's no fork.  This happens when we receive a block
                    ;; that we already saw and linked into the chain previously, which isn't the chain head.
                    ;; Re-processing it is confusing for the wallet so just skip.
                    (§ expr log.warn(§ pars "Saw duplicated block in main chain at height {}: {}", newBlock.getHeight(§ pars ), newBlock.getHeader(§ pars ).getHash(§ pars )))
                    (§ return nil)
                )

                (§ if (§ expr splitPoint == nil))
                (§ block
                    ;; This should absolutely never happen.
                    ;; (lets not write the full block to disk to keep any bugs which allow this to happen from writing unreasonable amounts of data to disk)
                    (§ throw (§ new #_"VerificationException" (§ pars "Block forks the chain but splitPoint is nil")))
                )
                (§ else )
                (§ block
                    ;; We aren't actually spending any transactions (yet) because we are on a fork.
                    (§ expr addToBlockStore(§ pars storedPrev, block))
                    (§ var #_"int" (§ name splitPointHeight) (§ expr splitPoint.getHeight(§ pars )))
                    (§ var #_"String" (§ name splitPointHash) (§ expr splitPoint.getHeader(§ pars ).getHashAsString(§ pars )))
                    (§ expr log.info(§ pars "Block forks the chain at height {}/block {}, but it did not cause a reorganize:\n{}", splitPointHeight, splitPointHash, newBlock.getHeader(§ pars ).getHashAsString(§ pars )))
                )
            )

            ;; We may not have any transactions if we received only a header, which can happen during fast catchup.
            ;; If we do, send them to the wallet but state that they are on a side chain so it knows not to try and
            ;; spend them until they become activated.
            (§ if (§ expr block.transactions != nil || filtered))
            (§ block
                (§ expr informListenersForNewBlock(§ pars block, NewBlockType/SIDE_CHAIN, filteredTxHashList, filteredTxn, newBlock))
            )

            (§ if haveNewBestChain)
            (§ block
                (§ expr handleNewBestChain(§ pars storedPrev, newBlock, block, expensiveChecks))
            )
        )
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn informListenersForNewBlock) [#_final #_"Block" (§ name block), #_final #_"NewBlockType" (§ name newBlockType), #_nilable #_final #_"List<Sha256Hash>" (§ name filteredTxHashList), #_nilable #_final #_"Map<Sha256Hash, Transaction>" (§ name filteredTxn), #_final #_"StoredBlock" (§ name newStoredBlock)])
        (§ throws #_"VerificationException")
    (§ block
        ;; Notify the listeners of the new block, so the depth and workDone of stored transactions can be updated
        ;; (in the case of the listener being a wallet).  Wallets need to know how deep each transaction is, so
        ;; coinbases aren't used before maturity.
        (§ var #_"boolean" (§ name first) true)
        (§ var #_"Set<Sha256Hash>" (§ name falsePositives) (§ expr Sets/newHashSet(§ pars )))
        (§ if (§ expr filteredTxHashList != nil))
        (§ block
            (§ expr falsePositives.addAll(§ pars filteredTxHashList))
        )

        (§ for (§ var #_final ListenerRegistration<TransactionReceivedInBlockListener> registration) :for transactionReceivedListeners)
        (§ block
            (§ if (§ expr registration.executor == Threading/SAME_THREAD))
            (§ block
                (§ expr informListenerForNewTransactions(§ pars block, newBlockType, filteredTxHashList, filteredTxn, newStoredBlock, first, registration.listener, falsePositives))
            )
            (§ else )
            (§ block
                ;; Listener wants to be run on some other thread, so marshal it across here.
                #_final
                (§ var #_"boolean" (§ name notFirst) (§ expr (§ not first)))
                (§ expr registration.executor.execute(§ pars (§ new #_"Runnable" (§ pars ))
                (§ anon
                    #_override
                    #_public
                    (§ method #_"void" (§ fn run) [])
                    (§ block
                        (§ try )
                        (§ block
                            ;; We can't do false-positive handling when executing on another thread.
                            (§ var #_"Set<Sha256Hash>" (§ name ignoredFalsePositives) (§ expr Sets/newHashSet(§ pars )))
                            (§ expr informListenerForNewTransactions(§ pars block, newBlockType, filteredTxHashList, filteredTxn, newStoredBlock, notFirst, registration.listener, ignoredFalsePositives))
                        )
                        (§ catch #_"VerificationException" (§ name e))
                        (§ block
                            (§ expr log.error(§ pars "Block chain listener threw exception: ", e))
                            ;; Don't attempt to relay this back to the original peer thread if this was an async listener invocation.
                            ;; TODO: Make exception reporting a global feature and use it here.
                        )
                        (§ void nil)
                    )
                )))
            )
            (§ ass (§ name first) false)
        )

        (§ for (§ var #_final ListenerRegistration<NewBestBlockListener> registration) :for newBestBlockListeners)
        (§ block
            (§ if (§ expr registration.executor == Threading/SAME_THREAD))
            (§ block
                (§ if (§ expr newBlockType == NewBlockType/BEST_CHAIN))
                (§ block
                    (§ expr registration.listener.notifyNewBestBlock(§ pars newStoredBlock))
                )
            )
            (§ else )
            (§ block
                ;; Listener wants to be run on some other thread, so marshal it across here.
                (§ expr registration.executor.execute(§ pars (§ new #_"Runnable" (§ pars ))
                (§ anon
                    #_override
                    #_public
                    (§ method #_"void" (§ fn run) [])
                    (§ block
                        (§ try )
                        (§ block
                            (§ if (§ expr newBlockType == NewBlockType/BEST_CHAIN))
                            (§ block
                                (§ expr registration.listener.notifyNewBestBlock(§ pars newStoredBlock))
                            )
                        )
                        (§ catch #_"VerificationException" (§ name e))
                        (§ block
                            (§ expr log.error(§ pars "Block chain listener threw exception: ", e))
                            ;; Don't attempt to relay this back to the original peer thread if this was an async listener invocation.
                            ;; TODO: Make exception reporting a global feature and use it here.
                        )
                        (§ void nil)
                    )
                )))
            )
            (§ ass (§ name first) false)
        )

        (§ expr trackFalsePositives(§ pars falsePositives.size(§ pars )))
        (§ void nil)
    )

    #_private
    #_static
    (§ method #_"void" (§ fn informListenerForNewTransactions) [#_"Block" (§ name block), #_"NewBlockType" (§ name newBlockType), #_nilable #_"List<Sha256Hash>" (§ name filteredTxHashList), #_nilable #_"Map<Sha256Hash, Transaction>" (§ name filteredTxn), #_"StoredBlock" (§ name newStoredBlock), #_"boolean" (§ name first), #_"TransactionReceivedInBlockListener" (§ name listener), #_"Set<Sha256Hash>" (§ name falsePositives)])
        (§ throws #_"VerificationException")
    (§ block
        (§ if (§ expr block.transactions != nil))
        (§ block
            ;; If this is not the first wallet, ask for the transactions to be duplicated before being given
            ;; to the wallet when relevant.  This ensures that if we have two connected wallets and a tx that
            ;; is relevant to both of them, they don't end up accidentally sharing the same object (which can
            ;; result in temporary in-memory corruption during re-orgs).  See bug 257.  We only duplicate in
            ;; the case of multiple wallets to avoid an unnecessary efficiency hit in the common case.
            (§ expr sendTransactionsToListener(§ pars newStoredBlock, newBlockType, listener, 0, block.transactions, (§ not first), falsePositives))
        )
        (§ elseif (§ expr filteredTxHashList != nil))
        (§ block
            (§ expr Preconditions/checkNotNull(§ pars filteredTxn))
            ;; We must send transactions to listeners in the order they appeared in the block - thus we iterate over the
            ;; set of hashes and call sendTransactionsToListener with individual txn when they have not already been
            ;; seen in loose broadcasts - otherwise notifyTransactionIsInBlock on the hash.
            (§ var #_"int" (§ name relativityOffset) 0)
            (§ for (§ var #_"Sha256Hash" (§ name hash)) :for filteredTxHashList)
            (§ block
                (§ var #_"Transaction" (§ name tx) (§ expr filteredTxn.get(§ pars hash)))
                (§ if (§ expr tx != nil))
                (§ block
                    (§ expr sendTransactionsToListener(§ pars newStoredBlock, newBlockType, listener, relativityOffset, Collections/singletonList(§ pars tx), (§ not first), falsePositives))
                )
                (§ elseif (§ expr listener.notifyTransactionIsInBlock(§ pars hash, newStoredBlock, newBlockType, relativityOffset)))
                (§ block
                    (§ expr falsePositives.remove(§ pars hash))
                )
                (§ ass (§ name relativityOffset) (§ expr relativityOffset + 1))
            )
        )
        (§ void nil)
    )

    ;;;
     ; Gets the median timestamp of the last 11 blocks.
     ;;
    #_private
    #_static
    (§ method #_"long" (§ fn getMedianTimestampOfRecentBlocks) [#_"StoredBlock" (§ name storedBlock), #_"BlockStore" (§ name store)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ var #_"long[]" (§ name timestamps) (§ new #_"long[]" (§ count 11)))
        (§ var #_"int" (§ name unused) 9)
        (§ ass (§ name timestamps[10]) (§ dot storedBlock.getHeader(§ pars ).getTimeSeconds(§ pars )))
        (§ for (§ var ) :for (§ expr 0 <= unused && (§ ass (§ name storedBlock) (§ expr storedBlock.getPrev(§ pars store))) != nil) :for (§ ass (§ name unused) (§ expr unused - 1)))
        (§ block
            (§ ass (§ name timestamps[unused]) (§ dot storedBlock.getHeader(§ pars ).getTimeSeconds(§ pars )))
        )

        (§ expr Arrays/sort(§ pars timestamps, unused + 1, 11))
        (§ return (§ expr timestamps[unused + (§ expr 11 - unused) / 2]))
    )

    ;;;
     ; Disconnect each transaction in the block (after reading it from the block store).
     ; Only called if shouldVerifyTransactions().
     ; @throws PrunedException if block does not exist as a {@link StoredUndoableBlock} in the block store.
     ; @throws BlockStoreException if the block store had an underlying error or block does not exist in the block store at all.
     ;;
    #_protected
    #_abstract
    (§ method #_"void" (§ fn disconnectTransactions) [#_"StoredBlock" (§ name block)])
        (§ throws #_"PrunedException", #_"BlockStoreException")

    ;;;
     ; Called as part of connecting a block when the new block results in a different chain having higher total work.
     ;
     ; if (shouldVerifyTransactions)
     ;     either newChainHead needs to be in the block store as a FullStoredBlock, or (block != null && block.transactions != null)
     ;;
    #_private
    (§ method #_"void" (§ fn handleNewBestChain) [#_"StoredBlock" (§ name storedPrev), #_"StoredBlock" (§ name newChainHead), #_"Block" (§ name block), #_"boolean" (§ name expensiveChecks)])
        (§ throws #_"BlockStoreException", #_"VerificationException", #_"PrunedException")
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        ;; This chain has overtaken the one we currently believe is best.  Reorganize is required.
        ;;
        ;; Firstly, calculate the block at which the chain diverged.  We only need to examine the
        ;; chain from beyond this block to find differences.

        (§ var #_"StoredBlock" (§ name head) (§ expr getChainHead(§ pars )))
        #_final
        (§ var #_"StoredBlock" (§ name splitPoint) (§ expr findSplit(§ pars newChainHead, head, blockStore)))
        (§ expr log.info(§ pars "Re-organize after split at height {}", splitPoint.getHeight(§ pars )))
        (§ expr log.info(§ pars "Old chain head: {}", head.getHeader(§ pars ).getHashAsString(§ pars )))
        (§ expr log.info(§ pars "New chain head: {}", newChainHead.getHeader(§ pars ).getHashAsString(§ pars )))
        (§ expr log.info(§ pars "Split at block: {}", splitPoint.getHeader(§ pars ).getHashAsString(§ pars )))

        ;; Then build a list of all blocks in the old part of the chain and the new part.
        #_final
        (§ var #_"LinkedList<StoredBlock>" (§ name oldBlocks) (§ expr getPartialChain(§ pars head, splitPoint, blockStore)))
        #_final
        (§ var #_"LinkedList<StoredBlock>" (§ name newBlocks) (§ expr getPartialChain(§ pars newChainHead, splitPoint, blockStore)))

        ;; Disconnect each transaction in the previous main chain that is no longer in the new main chain.
        (§ var #_"StoredBlock" (§ name storedNewHead) splitPoint)
        (§ if (§ expr shouldVerifyTransactions(§ pars )))
        (§ block
            (§ for (§ var #_"StoredBlock" (§ name oldBlock)) :for oldBlocks)
            (§ block
                (§ try )
                (§ block
                    (§ expr disconnectTransactions(§ pars oldBlock))
                )
                (§ catch #_"PrunedException" (§ name e))
                (§ block
                    ;; We threw away the data we need to re-org this deep!  We need to go back to a peer with full
                    ;; block contents and ask them for the relevant data then rebuild the indexs.  Or we could just
                    ;; give up and ask the human operator to help get us unstuck (e.g. rescan from the genesis block).
                    ;; TODO: retry adding this block when we get a block with hash e.getHash()
                    (§ throw e)
                )
            )

            (§ var #_"StoredBlock" (§ name cursor))
            ;; Walk in ascending chronological order.
            (§ for (§ var #_"Iterator<StoredBlock>" (§ name it) (§ expr newBlocks.descendingIterator(§ pars ))) :for (§ expr it.hasNext(§ pars )) :for (§ expr ))
            (§ block
                (§ ass (§ name cursor) (§ expr it.next(§ pars )))
                (§ var #_"Block" (§ name cursorBlock) (§ expr cursor.getHeader(§ pars )))
                (§ if (§ expr expensiveChecks && cursorBlock.getTimeSeconds(§ pars ) <= getMedianTimestampOfRecentBlocks(§ pars cursor.getPrev(§ pars blockStore), blockStore)))
                (§ block
                    (§ throw (§ new #_"VerificationException" (§ pars "Block's timestamp is too early during reorg")))
                )
                (§ var #_"TransactionOutputChanges" (§ name txOutChanges))
                (§ if (§ expr cursor != newChainHead || block == nil))
                (§ block
                    (§ ass (§ name txOutChanges) (§ expr connectTransactions(§ pars cursor)))
                )
                (§ else )
                (§ block
                    (§ ass (§ name txOutChanges) (§ expr connectTransactions(§ pars newChainHead.getHeight(§ pars ), block)))
                )
                (§ ass (§ name storedNewHead) (§ expr addToBlockStore(§ pars storedNewHead, cursorBlock.cloneAsHeader(§ pars ), txOutChanges)))
            )
        )
        (§ else )
        (§ block
            ;; (Finally) write block to block store.
            (§ ass (§ name storedNewHead) (§ expr addToBlockStore(§ pars storedPrev, newChainHead.getHeader(§ pars ))))
        )

        ;; Now inform the listeners.  This is necessary so the set of currently active transactions (that we can spend)
        ;; can be updated to take into account the re-organize.  We might also have received new coins we didn't have
        ;; before and our previous spends might have been undone.
        (§ for (§ var #_final ListenerRegistration<ReorganizeListener> registration) :for reorganizeListeners)
        (§ block
            (§ if (§ expr registration.executor == Threading/SAME_THREAD))
            (§ block
                ;; Short circuit the executor so we can propagate any exceptions.
                ;; TODO: Do we really need to do this or should it be irrelevant?
                (§ expr registration.listener.reorganize(§ pars splitPoint, oldBlocks, newBlocks))
            )
            (§ else )
            (§ block
                (§ expr registration.executor.execute(§ pars (§ new #_"Runnable" (§ pars ))
                (§ anon
                    #_override
                    #_public
                    (§ method #_"void" (§ fn run) [])
                    (§ block
                        (§ try )
                        (§ block
                            (§ expr registration.listener.reorganize(§ pars splitPoint, oldBlocks, newBlocks))
                        )
                        (§ catch #_"VerificationException" (§ name e))
                        (§ block
                            (§ expr log.error(§ pars "Block chain listener threw exception during reorg", e))
                        )
                        (§ void nil)
                    )
                )))
            )
        )

        ;; Update the pointer to the best known block.
        (§ expr setChainHead(§ pars storedNewHead))
        (§ void nil)
    )

    ;;;
     ; Returns the set of contiguous blocks between 'higher' and 'lower'.  Higher is included, lower is not.
     ;;
    #_private
    #_static
    (§ method #_"LinkedList<StoredBlock>" (§ fn getPartialChain) [#_"StoredBlock" (§ name higher), #_"StoredBlock" (§ name lower), #_"BlockStore" (§ name store)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr Preconditions/checkArgument(§ pars lower.getHeight(§ pars ) < higher.getHeight(§ pars ), "higher and lower are reversed"))
        (§ var #_"LinkedList<StoredBlock>" (§ name results) (§ new #_"LinkedList<>" (§ pars )))
        (§ var #_"StoredBlock" (§ name cursor) higher)
        (§ while true)
        (§ block
            (§ expr results.add(§ pars cursor))
            (§ ass (§ name cursor) (§ expr Preconditions/checkNotNull(§ pars cursor.getPrev(§ pars store), "Ran off the end of the chain")))
            (§ if (§ expr cursor.equals(§ pars lower)))
            (§ block
                (§ break )
            )
        )
        (§ return results)
    )

    ;;;
     ; Locates the point in the chain at which newStoredBlock and chainHead diverge.  Returns null if no split point was
     ; found (i.e. they are not part of the same chain).  Returns newChainHead or chainHead if they don't actually diverge
     ; but are part of the same chain.
     ;;
    #_private
    #_static
    (§ method #_"StoredBlock" (§ fn findSplit) [#_"StoredBlock" (§ name newChainHead), #_"StoredBlock" (§ name oldChainHead), #_"BlockStore" (§ name store)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ var #_"StoredBlock" (§ name currentChainCursor) oldChainHead)
        (§ var #_"StoredBlock" (§ name newChainCursor) newChainHead)
        ;; Loop until we find the block both chains have in common.  Example:
        ;;
        ;;    A -> B -> C -> D
        ;;         \--> E -> F -> G
        ;;
        ;; findSplit will return block B.  oldChainHead = D and newChainHead = G.
        (§ while (§ expr (§ not currentChainCursor.equals(§ pars newChainCursor))))
        (§ block
            (§ if (§ expr newChainCursor.getHeight(§ pars ) < currentChainCursor.getHeight(§ pars )))
            (§ block
                (§ ass (§ name currentChainCursor) (§ expr currentChainCursor.getPrev(§ pars store)))
                (§ expr Preconditions/checkNotNull(§ pars currentChainCursor, "Attempt to follow an orphan chain"))
            )
            (§ else )
            (§ block
                (§ ass (§ name newChainCursor) (§ expr newChainCursor.getPrev(§ pars store)))
                (§ expr Preconditions/checkNotNull(§ pars newChainCursor, "Attempt to follow an orphan chain"))
            )
        )
        (§ return currentChainCursor)
    )

    ;;;
     ; @return the height of the best known chain, convenience for <tt>getChainHead().getHeight()</tt>
     ;;
    #_public
    #_final
    (§ method #_"int" (§ fn getBestChainHeight) [])
    (§ block
        (§ return (§ expr getChainHead(§ pars ).getHeight(§ pars )))
    )

    #_public
    (§ enum #_"NewBlockType"
        (§ item BEST_CHAIN)
        (§ item SIDE_CHAIN)
    )

    #_private
    #_static
    (§ method #_"void" (§ fn sendTransactionsToListener) [#_"StoredBlock" (§ name block), #_"NewBlockType" (§ name blockType), #_"TransactionReceivedInBlockListener" (§ name listener), #_"int" (§ name relativityOffset), #_"List<Transaction>" (§ name transactions), #_"boolean" (§ name clone), #_"Set<Sha256Hash>" (§ name falsePositives)])
        (§ throws #_"VerificationException")
    (§ block
        (§ for (§ var #_"Transaction" (§ name tx)) :for transactions)
        (§ block
            (§ try )
            (§ block
                (§ expr falsePositives.remove(§ pars tx.getHash(§ pars )))
                (§ if clone)
                (§ block
                    (§ ass (§ name tx) (§ expr tx.params.getDefaultSerializer(§ pars ).makeTransaction(§ pars tx.bitcoinSerialize(§ pars ))))
                )
                (§ expr listener.receiveFromBlock(§ pars tx, block, blockType, relativityOffset))
                (§ ass (§ name relativityOffset) (§ expr relativityOffset + 1))
            )
            (§ catch #_"ScriptException" (§ name e))
            (§ block
                ;; We don't want scripts we don't understand to break the block chain so just note that this tx was
                ;; not scanned here and continue.
                (§ expr log.warn(§ pars "Failed to parse a script: " + e))
            )
            (§ catch #_"ProtocolException" (§ name e))
            (§ block
                ;; Failed to duplicate tx, should never happen.
                (§ throw (§ new #_"RuntimeException" (§ pars e)))
            )
        )
        (§ void nil)
    )

    #_protected
    (§ method #_"void" (§ fn setChainHead) [#_"StoredBlock" (§ name chainHead)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr doSetChainHead(§ pars chainHead))
        (§ sync chainHeadLock)
        (§ block
            (§ ass (§ name this.chainHead) chainHead)
        )
        (§ void nil)
    )

    ;;;
     ; For each block in orphanBlocks, see if we can now fit it on top of the chain and if so, do so.
     ;;
    #_private
    (§ method #_"void" (§ fn tryConnectingOrphans) [])
        (§ throws #_"VerificationException", #_"BlockStoreException", #_"PrunedException")
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        ;; For each block in our orphan list, try and fit it onto the head of the chain.  If we succeed remove it
        ;; from the list and keep going.  If we changed the head of the list at the end of the round try again until
        ;; we can't fit anything else on the top.
        ;;
        ;; This algorithm is kind of crappy, we should do a topo-sort then just connect them in order, but for small
        ;; numbers of orphan blocks it does OK.

        (§ var #_"int" (§ name blocksConnectedThisRound))
        (§ do )
        (§ block
            (§ ass (§ name blocksConnectedThisRound) 0)
            (§ var #_"Iterator<OrphanBlock>" (§ name iter) (§ expr orphanBlocks.values(§ pars ).iterator(§ pars )))
            (§ while (§ expr iter.hasNext(§ pars )))
            (§ block
                (§ var #_"OrphanBlock" (§ name orphanBlock) (§ expr iter.next(§ pars )))
                ;; Look up the blocks previous.
                (§ var #_"StoredBlock" (§ name prev) (§ expr getStoredBlockInCurrentScope(§ pars orphanBlock.block.getPrevBlockHash(§ pars ))))
                (§ if (§ expr prev == nil))
                (§ block
                    ;; This is still an unconnected/orphan block.
                    (§ expr log.debug(§ pars "Orphan block {} is not connectable right now", orphanBlock.block.getHash(§ pars )))
                    (§ continue )
                )
                ;; Otherwise we can connect it now.
                ;; False here ensures we don't recurse infinitely downwards when connecting huge chains.
                (§ expr log.info(§ pars "Connected orphan {}", orphanBlock.block.getHash(§ pars )))
                (§ expr add(§ pars orphanBlock.block, false, orphanBlock.filteredTxHashes, orphanBlock.filteredTxn))
                (§ expr iter.remove(§ pars ))
                (§ ass (§ name blocksConnectedThisRound) (§ expr blocksConnectedThisRound + 1))
            )
            (§ if (§ expr 0 < blocksConnectedThisRound))
            (§ block
                (§ expr log.info(§ pars "Connected {} orphan blocks.", blocksConnectedThisRound))
            )
        )
        (§ again (§ expr 0 < blocksConnectedThisRound))
        (§ void nil)
    )

    ;;;
     ; Returns the block at the head of the current best chain.  This is the block which represents the greatest
     ; amount of cumulative work done.
     ;;
    #_public
    (§ method #_"StoredBlock" (§ fn getChainHead) [])
    (§ block
        (§ sync chainHeadLock)
        (§ block
            (§ return chainHead)
        )
    )

    ;;;
     ; An orphan block is one that does not connect to the chain anywhere (i.e. we can't find its parent, therefore
     ; it's an orphan).  Typically this occurs when we are downloading the chain and didn't reach the head yet, and/or
     ; if a block is solved whilst we are downloading.  It's possible that we see a small amount of orphan blocks which
     ; chain together, this method tries walking backwards through the known orphan blocks to find the bottom-most.
     ;
     ; @return from or one of from's parents, or null if "from" does not identify an orphan block
     ;;
    #_nilable
    #_public
    (§ method #_"Block" (§ fn getOrphanRoot) [#_"Sha256Hash" (§ name from)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"OrphanBlock" (§ name cursor) (§ expr orphanBlocks.get(§ pars from)))
            (§ if (§ expr cursor == nil))
            (§ block
                (§ return nil)
            )
            (§ var #_"OrphanBlock" (§ name tmp))
            (§ while (§ expr (§ ass (§ name tmp) (§ expr orphanBlocks.get(§ pars cursor.block.getPrevBlockHash(§ pars )))) != nil))
            (§ block
                (§ ass (§ name cursor) tmp)
            )
            (§ return (§ expr cursor.block))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;; Returns true if the given block is currently in the orphan blocks list. ;;
    #_public
    (§ method #_"boolean" (§ fn isOrphan) [#_"Sha256Hash" (§ name block)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr orphanBlocks.containsKey(§ pars block)))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns an estimate of when the given block will be reached, assuming a perfect 10 minute average for each
     ; block.  This is useful for turning transaction lock times into human readable times.  Note that a height in
     ; the past will still be estimated, even though the time of solving is actually known (we won't scan backwards
     ; through the chain to obtain the right answer).
     ;;
    #_public
    (§ method #_"Date" (§ fn estimateBlockTime) [#_"int" (§ name height)])
    (§ block
        (§ sync chainHeadLock)
        (§ block
            (§ var #_"long" (§ name offset) (§ expr height - chainHead.getHeight(§ pars )))
            (§ var #_"long" (§ name headTime) (§ expr chainHead.getHeader(§ pars ).getTimeSeconds(§ pars )))
            (§ var #_"long" (§ name estimated) (§ expr (§ expr headTime * 1000) + (§ expr 1000 * 60 * 10 * offset)))
            (§ return (§ new #_"Date" (§ pars estimated)))
        )
    )

    ;;;
     ; Returns a future that completes when the block chain has reached the given height.  Yields the
     ; {@link StoredBlock} of the block that reaches that height first.  The future completes on a peer thread.
     ;;
    #_public
    (§ method #_"ListenableFuture<StoredBlock>" (§ fn getHeightFuture) [#_final #_"int" (§ name height)])
    (§ block
        #_final
        (§ var #_"SettableFuture<StoredBlock>" (§ name result) (§ expr SettableFuture/create(§ pars )))
        (§ expr addNewBestBlockListener(§ pars Threading/SAME_THREAD, new NewBestBlockListener(§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn notifyNewBestBlock) [#_"StoredBlock" (§ name block)])
                (§ throws #_"VerificationException")
            (§ block
                (§ if (§ expr height <= block.getHeight(§ pars )))
                (§ block
                    (§ expr removeNewBestBlockListener(§ pars this))
                    (§ expr result.set(§ pars block))
                )
                (§ void nil)
            )
        )))
        (§ return result)
    )

    ;;;
     ; The false positive rate is the average over all blockchain transactions of:
     ;
     ; - 1.0 if the transaction was false-positive (was irrelevant to all listeners)
     ; - 0.0 if the transaction was relevant or filtered out
     ;;
    #_public
    (§ method #_"double" (§ fn getFalsePositiveRate) [])
    (§ block
        (§ return falsePositiveRate)
    )

    ;;
     ; We completed handling of a filtered block.  Update false-positive estimate based
     ; on the total number of transactions in the original block.
     ;
     ; count includes filtered transactions, transactions that were passed in and were relevant
     ; and transactions that were false positives (i.e. includes all transactions in the block).
     ;;
    #_protected
    (§ method #_"void" (§ fn trackFilteredTransactions) [#_"int" (§ name count)])
    (§ block
        ;; Track non-false-positives in batch.  Each non-false-positive counts as 0.0 towards the estimate.
        ;;
        ;; This is slightly off because we are applying false positive tracking before non-FP tracking,
        ;; which counts FP as if they came at the beginning of the block.  Assuming uniform FP
        ;; spread in a block, this will somewhat underestimate the FP rate (5% for 1000 tx block).
        (§ var #_"double" (§ name alphaDecay) (§ expr Math/pow(§ pars 1 - FP_ESTIMATOR_ALPHA, count)))

        ;; new_rate = alpha_decay * new_rate
        (§ ass (§ name falsePositiveRate) (§ expr alphaDecay * falsePositiveRate))

        (§ var #_"double" (§ name betaDecay) (§ expr Math/pow(§ pars 1 - FP_ESTIMATOR_BETA, count)))

        ;; trend = beta * (new_rate - old_rate) + beta_decay * trend
        (§ ass (§ name falsePositiveTrend) (§ expr FP_ESTIMATOR_BETA * count * (§ expr falsePositiveRate - previousFalsePositiveRate) + betaDecay * falsePositiveTrend))

        ;; new_rate += alpha_decay * trend
        (§ ass (§ name falsePositiveRate) (§ expr falsePositiveRate + (§ expr alphaDecay * falsePositiveTrend)))

        ;; stash new_rate in old_rate
        (§ ass (§ name previousFalsePositiveRate) falsePositiveRate)
        (§ void nil)
    )

    ;;;Irrelevant transactions were received.  Update false-positive estimate. ;;
    (§ method #_"void" (§ fn trackFalsePositives) [#_"int" (§ name count)])
    (§ block
        ;; Track false positives in batch by adding alpha to the false positive estimate once per count.
        ;; Each false positive counts as 1.0 towards the estimate.
        (§ ass (§ name falsePositiveRate) (§ expr falsePositiveRate + (§ expr FP_ESTIMATOR_ALPHA * count)))
        (§ if (§ expr 0 < count))
        (§ block
            (§ expr log.debug(§ pars "{} false positives, current rate = {} trend = {}", count, falsePositiveRate, falsePositiveTrend))
        )
        (§ void nil)
    )

    ;;; Resets estimates of false positives.  Used when the filter is sent to the peer. ;;
    #_public
    (§ method #_"void" (§ fn resetFalsePositiveEstimate) [])
    (§ block
        (§ ass (§ name falsePositiveRate) 0)
        (§ ass (§ name falsePositiveTrend) 0)
        (§ ass (§ name previousFalsePositiveRate) 0)
        (§ void nil)
    )

    #_protected
    (§ method #_"VersionTally" (§ fn getVersionTally) [])
    (§ block
        (§ return versionTally)
    )
)

#_(ns org.bitcoinj.core #_"Address"
    (:import [java.io IOException ObjectInputStream ObjectOutputStream])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.params Networks]
             [org.bitcoinj.script Script]))

;;;
 ; <p>A Bitcoin address looks like 1MsScoe2fTJoq4ZPdQgqyhgWeoNamYPevy and is derived from an elliptic curve public key
 ; plus a set of network parameters.  Not to be confused with a {@link PeerAddress} or {@link AddressMessage}
 ; which are about network (TCP) addresses.</p>
 ;
 ; <p>A standard address is built by taking the RIPE-MD160 hash of the public key bytes, with a version prefix and a
 ; checksum suffix, then encoding it textually as base58.  The version prefix is used to both denote the network for
 ; which the address is valid (see {@link NetworkParameters}, and also to indicate how the bytes inside the address
 ; should be interpreted.  Whilst almost all addresses today are hashes of public keys, another (currently unsupported
 ; type) can contain a hash of a script instead.</p>
 ;;
#_public
(§ class #_"Address" (§ extends #_"VersionedChecksummedBytes")
    ;;;
     ; An address is a RIPEMD160 hash of a public key, therefore is always 160 bits or 20 bytes.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name LENGTH) 20)

    #_private
    #_transient
    (§ field #_"NetworkParameters" (§ name params))

    ;;;
     ; Construct an address from parameters, the address version, and the hash160 form.  Example:
     ;
     ; <pre>new Address(MainNetParams.get(), NetworkParameters.getAddressHeader(), Hex.decode("4a22c3c4cbb31e4d03b15550636762bda0baf85a"));</pre>
     ;;
    #_public
    (§ constructor #_"Address" [#_"NetworkParameters" (§ name params), #_"int" (§ name version), #_"byte[]" (§ name hash160)])
        (§ throws #_"WrongNetworkException")
    (§ block
        (§ super (§ pars version, hash160))

        (§ expr Preconditions/checkNotNull(§ pars params))
        (§ expr Preconditions/checkArgument(§ pars hash160.length == 20, "Addresses are 160-bit hashes, so you must provide 20 bytes"))
        (§ if (§ expr (§ not isAcceptableVersion(§ pars params, version))))
        (§ block
            (§ throw (§ new #_"WrongNetworkException" (§ pars version, params.getAcceptableAddressCodes(§ pars ))))
        )
        (§ ass (§ name this.params) params)
        (§ void this)
    )

    ;;; Returns an Address that represents the given P2SH script hash. ;;
    #_public
    #_static
    (§ method #_"Address" (§ fn fromP2SHHash) [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name hash160)])
    (§ block
        (§ try )
        (§ block
            (§ return (§ new #_"Address" (§ pars params, params.getP2SHHeader(§ pars ), hash160)))
        )
        (§ catch #_"WrongNetworkException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
    )

    ;;; Returns an Address that represents the script hash extracted from the given scriptPubKey. ;;
    #_public
    #_static
    (§ method #_"Address" (§ fn fromP2SHScript) [#_"NetworkParameters" (§ name params), #_"Script" (§ name scriptPubKey)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars scriptPubKey.isPayToScriptHash(§ pars ), "Not a P2SH script"))
        (§ return (§ expr fromP2SHHash(§ pars params, scriptPubKey.getPubKeyHash(§ pars ))))
    )

    ;;;
     ; Construct an address from its Base58 representation.
     ; @param params
     ;            The expected NetworkParameters or null if you don't want validation.
     ; @param base58
     ;            The textual form of the address, such as "17kzeh4N8g49GFvdDzSf8PjaPfyoD1MndL".
     ; @throws AddressFormatException
     ;             if the given base58 doesn't parse or the checksum is invalid
     ; @throws WrongNetworkException
     ;             if the given address is valid but for a different chain (e.g. testnet vs. mainnet)
     ;;
    #_public
    #_static
    (§ method #_"Address" (§ fn fromBase58) [#_nilable #_"NetworkParameters" (§ name params), #_"String" (§ name base58)])
        (§ throws #_"AddressFormatException")
    (§ block
        (§ return (§ new #_"Address" (§ pars params, base58)))
    )

    ;;;
     ; Construct an address from parameters and the hash160 form.  Example:
     ;
     ; <pre>new Address(MainNetParams.get(), Hex.decode("4a22c3c4cbb31e4d03b15550636762bda0baf85a"));</pre>
     ;;
    #_public
    (§ constructor #_"Address" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name hash160)])
    (§ block
        (§ super (§ pars params.getAddressHeader(§ pars ), hash160))

        (§ expr Preconditions/checkArgument(§ pars hash160.length == 20, "Addresses are 160-bit hashes, so you must provide 20 bytes"))
        (§ ass (§ name this.params) params)
        (§ void this)
    )

    ;;; @deprecated Use {@link #fromBase58(NetworkParameters, String)} ;;
    #_deprecated
    #_public
    (§ constructor #_"Address" [#_nilable #_"NetworkParameters" (§ name params), #_"String" (§ name address)])
        (§ throws #_"AddressFormatException")
    (§ block
        (§ super (§ pars address))

        (§ if (§ expr params != nil))
        (§ block
            (§ if (§ expr (§ not isAcceptableVersion(§ pars params, version))))
            (§ block
                (§ throw (§ new #_"WrongNetworkException" (§ pars version, params.getAcceptableAddressCodes(§ pars ))))
            )
            (§ ass (§ name this.params) params)
        )
        (§ else )
        (§ block
            (§ var #_"NetworkParameters" (§ name paramsFound) nil)
            (§ for (§ var #_"NetworkParameters" (§ name p)) :for (§ expr Networks/get(§ pars )))
            (§ block
                (§ if (§ expr isAcceptableVersion(§ pars p, version)))
                (§ block
                    (§ ass (§ name paramsFound) p)
                    (§ break )
                )
            )
            (§ if (§ expr paramsFound == nil))
            (§ block
                (§ throw (§ new #_"AddressFormatException" (§ pars "No network found for " + address)))
            )

            (§ ass (§ name this.params) paramsFound)
        )
        (§ void this)
    )

    ;;; The (big endian) 20 byte hash that is the core of a Bitcoin address. ;;
    #_public
    (§ method #_"byte[]" (§ fn getHash160) [])
    (§ block
        (§ return bytes)
    )

    ;;;
     ; Returns true if this address is a Pay-To-Script-Hash (P2SH) address.
     ; See also https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki: Address Format for pay-to-script-hash
     ;;
    #_public
    (§ method #_"boolean" (§ fn isP2SHAddress) [])
    (§ block
        #_final
        (§ var #_"NetworkParameters" (§ name parameters) (§ expr getParameters(§ pars )))
        (§ return (§ expr parameters != nil && this.version == parameters.p2shHeader))
    )

    ;;;
     ; Examines the version byte of the address and attempts to find a matching NetworkParameters.  If you aren't sure
     ; which network the address is intended for (e.g. it was provided by a user), you can use this to decide if it is
     ; compatible with the current wallet.  You should be able to handle a null response from this method.  Note that
     ; the parameters returned is not necessarily the same as the one the Address was created with.
     ;
     ; @return a NetworkParameters representing the network the address is intended for
     ;;
    #_public
    (§ method #_"NetworkParameters" (§ fn getParameters) [])
    (§ block
        (§ return params)
    )

    ;;;
     ; Given an address, examines the version byte and attempts to find a matching NetworkParameters.  If you aren't sure
     ; which network the address is intended for (e.g. it was provided by a user), you can use this to decide if it is
     ; compatible with the current wallet.
     ; @return a NetworkParameters of the address
     ; @throws AddressFormatException if the string wasn't of a known version
     ;;
    #_public
    #_static
    (§ method #_"NetworkParameters" (§ fn getParametersFromAddress) [#_"String" (§ name address)])
        (§ throws #_"AddressFormatException")
    (§ block
        (§ try )
        (§ block
            (§ return (§ expr Address/fromBase58(§ pars nil, address).getParameters(§ pars )))
        )
        (§ catch #_"WrongNetworkException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
    )

    ;;;
     ; Check if a given address version is valid given the NetworkParameters.
     ;;
    #_private
    #_static
    (§ method #_"boolean" (§ fn isAcceptableVersion) [#_"NetworkParameters" (§ name params), #_"int" (§ name version)])
    (§ block
        (§ for (§ var #_"int" (§ name v)) :for (§ expr params.getAcceptableAddressCodes(§ pars )))
        (§ block
            (§ if (§ expr version == v))
            (§ block
                (§ return true)
            )
        )
        (§ return false)
    )

    ;;;
     ; This implementation narrows the return type to <code>Address</code>.
     ;;
    #_override
    #_public
    (§ method #_"Address" (§ fn clone) [])
        (§ throws #_"CloneNotSupportedException")
    (§ block
        (§ return (§ cast #_"Address" (§ expr super.clone(§ pars ))))
    )

    ;; Java serialization

    #_private
    (§ method #_"void" (§ fn writeObject) [#_"ObjectOutputStream" (§ name out)])
        (§ throws #_"IOException")
    (§ block
        (§ expr out.defaultWriteObject(§ pars ))
        (§ expr out.writeUTF(§ pars params.id))
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn readObject) [#_"ObjectInputStream" (§ name in)])
        (§ throws #_"IOException", #_"ClassNotFoundException")
    (§ block
        (§ expr in.defaultReadObject(§ pars ))
        (§ ass (§ name params) (§ expr NetworkParameters/fromID(§ pars in.readUTF(§ pars ))))
        (§ void nil)
    )
)

#_(ns org.bitcoinj.core #_"AddressFormatException")

#_public
(§ class #_"AddressFormatException" (§ extends #_"IllegalArgumentException")
    #_public
    (§ constructor #_"AddressFormatException" [])
    (§ block
        (§ super (§ pars ))
        (§ void this)
    )

    #_public
    (§ constructor #_"AddressFormatException" [#_"String" (§ name message)])
    (§ block
        (§ super (§ pars message))
        (§ void this)
    )
)

#_(ns org.bitcoinj.core #_"AddressMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Collections List]))

;;;
 ; <p>Represents an "addr" message on the P2P network, which contains broadcast IP addresses of other peers.  This is
 ; one of the ways peers can find each other without using the DNS or IRC discovery mechanisms.  However storing and
 ; using addr messages is not presently implemented.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"AddressMessage" (§ extends #_"Message")
    #_private
    #_static
    #_final
    (§ field #_"long" (§ name MAX_ADDRESSES) 1024)

    #_private
    (§ field #_"List<PeerAddress>" (§ name addresses))

    ;;;
     ; Contruct a new 'addr' message.
     ; @param params NetworkParameters object.
     ; @param offset The location of the first payload byte within the array.
     ; @param parseRetain Whether to retain the backing byte array for quick reserialization.
     ; If true and the backing byte array is invalidated due to modification of a field, then
     ; the cached bytes may be repopulated and retained if the message is serialized again in the future.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    (§ constructor #_"AddressMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"int" (§ name offset), #_"MessageSerializer" (§ name setSerializer), #_"int" (§ name length)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, offset, setSerializer, length))
        (§ void this)
    )

    ;;;
     ; Contruct a new 'addr' message.
     ; @param params NetworkParameters object.
     ; @param serializer The serializer to use for this block.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    (§ constructor #_"AddressMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"MessageSerializer" (§ name serializer), #_"int" (§ name length)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, 0, serializer, length))
        (§ void this)
    )

    (§ constructor #_"AddressMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"int" (§ name offset)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, offset, params.getDefaultSerializer(§ pars ), UNKNOWN_LENGTH))
        (§ void this)
    )

    (§ constructor #_"AddressMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, 0, params.getDefaultSerializer(§ pars ), UNKNOWN_LENGTH))
        (§ void this)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ var #_"long" (§ name numAddresses) (§ expr readVarInt(§ pars )))
        ;; Guard against ultra large messages that will crash us.
        (§ if (§ expr MAX_ADDRESSES < numAddresses))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars "Address message too large.")))
        )
        (§ ass (§ name addresses) (§ new #_"ArrayList<>" (§ pars (§ cast #_"int" numAddresses))))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numAddresses) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ var #_"PeerAddress" (§ name addr) (§ new #_"PeerAddress" (§ pars params, payload, cursor, protocolVersion, this, serializer)))
            (§ expr addresses.add(§ pars addr))
            (§ ass (§ name cursor) (§ expr cursor + addr.getMessageSize(§ pars )))
        )
        (§ ass (§ name length) (§ expr (§ new #_"VarInt" (§ pars addresses.size(§ pars ))).getSizeInBytes(§ pars )))
        ;; The 4 byte difference is the uint32 timestamp that was introduced in version 31402.
        (§ ass (§ name length) (§ expr length + (§ expr (§ expr addresses.size(§ pars )) * (§ quest (§ expr 31402 < protocolVersion) ? (§ expr PeerAddress/MESSAGE_SIZE) :else (§ expr PeerAddress/MESSAGE_SIZE - 4)))))
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ if (§ expr addresses != nil))
        (§ block
            (§ expr stream.write(§ pars (§ new #_"VarInt" (§ pars addresses.size(§ pars ))).encode(§ pars )))
            (§ for (§ var #_"PeerAddress" (§ name addr)) :for addresses)
            (§ block
                (§ expr addr.bitcoinSerialize(§ pars stream))
            )
        )
        (§ void nil)
    )

    ;;;
     ; @return An unmodifiableList view of the backing List of addresses.  Addresses contained within the list may be safely modified.
     ;;
    #_public
    (§ method #_"List<PeerAddress>" (§ fn getAddresses) [])
    (§ block
        (§ return (§ expr Collections/unmodifiableList(§ pars addresses)))
    )

    #_public
    (§ method #_"void" (§ fn addAddress) [#_"PeerAddress" (§ name address)])
    (§ block
        (§ expr unCache(§ pars ))
        (§ expr address.setParent(§ pars this))
        (§ expr addresses.add(§ pars address))
        (§ if (§ expr length == UNKNOWN_LENGTH))
        (§ block
            (§ expr getMessageSize(§ pars ))
        )
        (§ else )
        (§ block
            (§ ass (§ name length) (§ expr length + address.getMessageSize(§ pars )))
        )
        (§ void nil)
    )

    #_public
    (§ method #_"void" (§ fn removeAddress) [#_"int" (§ name index)])
    (§ block
        (§ expr unCache(§ pars ))
        (§ var #_"PeerAddress" (§ name address) (§ expr addresses.remove(§ pars index)))
        (§ expr address.setParent(§ pars nil))
        (§ if (§ expr length == UNKNOWN_LENGTH))
        (§ block
            (§ expr getMessageSize(§ pars ))
        )
        (§ else )
        (§ block
            (§ ass (§ name length) (§ expr length - address.getMessageSize(§ pars )))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr "addr: " + Utils/SPACE_JOINER.join(§ pars addresses)))
    )
)

#_(ns org.bitcoinj.core #_"AlertMessage"
    (:import [java.util Date HashSet Set]))

;;;
 ; Alerts are signed messages that are broadcast on the peer-to-peer network if they match a hard-coded signing key.
 ; The private keys are held by a small group of core Bitcoin developers, and alerts may be broadcast in the event of
 ; an available upgrade or a serious network problem.  Alerts have an expiration time, data that specifies what
 ; set of software versions it matches and the ability to cancel them by broadcasting another type of alert.
 ;
 ; The right course of action on receiving an alert is usually to either ensure a human will see it (display on screen,
 ; log, email), or if you decide to use alerts for notifications that are specific to your app in some way, to parse it.
 ; For example, you could treat it as an upgrade notification specific to your app.  Satoshi designed alerts to ensure
 ; that software upgrades could be distributed independently of a hard-coded website, in order to allow everything to
 ; be purely peer-to-peer.  You don't have to use this of course, and indeed it often makes more sense not to.
 ;
 ; <p>Before doing anything with an alert, you should check {@link AlertMessage#isSignatureValid()}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"AlertMessage" (§ extends #_"Message")
    #_private
    (§ field #_"byte[]" (§ name content))
    #_private
    (§ field #_"byte[]" (§ name signature))

    ;; See the getters for documentation of what each field means.
    #_private
    (§ field #_"long" (§ name version) 1)
    #_private
    (§ field #_"Date" (§ name relayUntil))
    #_private
    (§ field #_"Date" (§ name expiration))
    #_private
    (§ field #_"long" (§ name id))
    #_private
    (§ field #_"long" (§ name cancel))
    #_private
    (§ field #_"long" (§ name minVer))
    #_private
    (§ field #_"long" (§ name maxVer))
    #_private
    (§ field #_"long" (§ name priority))
    #_private
    (§ field #_"String" (§ name comment))
    #_private
    (§ field #_"String" (§ name statusBar))
    #_private
    (§ field #_"String" (§ name reserved))

    ;; Chosen arbitrarily to avoid memory blowups.
    #_private
    #_static
    #_final
    (§ field #_"long" (§ name MAX_SET_SIZE) 100)

    #_public
    (§ constructor #_"AlertMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payloadBytes)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payloadBytes, 0))
        (§ void this)
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr "ALERT: " + getStatusBar(§ pars )))
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        ;; Alerts are formatted in two levels.  The top level contains two byte arrays: a signature, and a serialized
        ;; data structure containing the actual alert data.
        (§ var #_"int" (§ name startPos) cursor)
        (§ ass (§ name content) (§ expr readByteArray(§ pars )))
        (§ ass (§ name signature) (§ expr readByteArray(§ pars )))
        ;; Now we need to parse out the contents of the embedded structure.  Rewind back to the start of the message.
        (§ ass (§ name cursor) startPos)
        (§ expr readVarInt(§ pars )) ;; Skip the length field on the content array.
        ;; We're inside the embedded structure.
        (§ ass (§ name version) (§ expr readUint32(§ pars )))
        ;; Read the timestamps.  Bitcoin uses seconds since the epoch.
        (§ ass (§ name relayUntil) (§ new #_"Date" (§ pars readUint64(§ pars ).longValue(§ pars ) * 1000)))
        (§ ass (§ name expiration) (§ new #_"Date" (§ pars readUint64(§ pars ).longValue(§ pars ) * 1000)))
        (§ ass (§ name id) (§ expr readUint32(§ pars )))
        (§ ass (§ name cancel) (§ expr readUint32(§ pars )))
        ;; Sets are serialized as <len><item><item><item>....
        (§ var #_"long" (§ name cancelSetSize) (§ expr readVarInt(§ pars )))
        (§ if (§ expr cancelSetSize < 0 || MAX_SET_SIZE < cancelSetSize))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars "Bad cancel set size: " + cancelSetSize)))
        )
        ;; Using a hashset here is very inefficient given that this will normally be only one item.  But Java doesn't
        ;; make it easy to do better.  What we really want is just an array-backed set.
        (§ var #_"Set<Long>" (§ name cancelSet) (§ new #_"HashSet<>" (§ pars (§ cast #_"int" cancelSetSize))))
        (§ for (§ var #_"long" (§ name i) 0) :for (§ expr i < cancelSetSize) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ expr cancelSet.add(§ pars readUint32(§ pars )))
        )
        (§ ass (§ name minVer) (§ expr readUint32(§ pars )))
        (§ ass (§ name maxVer) (§ expr readUint32(§ pars )))
        ;; Read the subver matching set.
        (§ var #_"long" (§ name subverSetSize) (§ expr readVarInt(§ pars )))
        (§ if (§ expr subverSetSize < 0 || MAX_SET_SIZE < subverSetSize))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars "Bad subver set size: " + subverSetSize)))
        )
        (§ var #_"Set<String>" (§ name matchingSubVers) (§ new #_"HashSet<>" (§ pars (§ cast #_"int" subverSetSize))))
        (§ for (§ var #_"long" (§ name i) 0) :for (§ expr i < subverSetSize) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ expr matchingSubVers.add(§ pars readStr(§ pars )))
        )
        (§ ass (§ name priority) (§ expr readUint32(§ pars )))
        (§ ass (§ name comment) (§ expr readStr(§ pars )))
        (§ ass (§ name statusBar) (§ expr readStr(§ pars )))
        (§ ass (§ name reserved) (§ expr readStr(§ pars )))

        (§ ass (§ name length) (§ expr cursor - offset))
        (§ void nil)
    )

    ;;;
     ; Returns true if the digital signature attached to the message verifies.  Don't do anything with the alert if it
     ; doesn't verify, because that would allow arbitrary attackers to spam your users.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isSignatureValid) [])
    (§ block
        (§ return (§ expr ECKey/verify(§ pars Sha256Hash/hashTwice(§ pars content), signature, params.getAlertSigningKey(§ pars ))))
    )

    ;;;
     ; The time at which the alert should stop being broadcast across the network.  Note that you can still receive
     ; the alert after this time from other nodes if the alert still applies to them or to you.
     ;;
    #_public
    (§ method #_"Date" (§ fn getRelayUntil) [])
    (§ block
        (§ return relayUntil)
    )

    #_public
    (§ method #_"void" (§ fn setRelayUntil) [#_"Date" (§ name relayUntil)])
    (§ block
        (§ ass (§ name this.relayUntil) relayUntil)
        (§ void nil)
    )

    ;;;
     ; The time at which the alert ceases to be relevant.  It should not be presented to the user or app administrator
     ; after this time.
     ;;
    #_public
    (§ method #_"Date" (§ fn getExpiration) [])
    (§ block
        (§ return expiration)
    )

    #_public
    (§ method #_"void" (§ fn setExpiration) [#_"Date" (§ name expiration)])
    (§ block
        (§ ass (§ name this.expiration) expiration)
        (§ void nil)
    )

    ;;;
     ; The numeric identifier of this alert.  Each alert should have a unique ID, but the signer can choose any number.
     ; If an alert is broadcast with a cancel field higher than this ID, this alert is considered cancelled.
     ; @return uint32
     ;;
    #_public
    (§ method #_"long" (§ fn getId) [])
    (§ block
        (§ return id)
    )

    #_public
    (§ method #_"void" (§ fn setId) [#_"long" (§ name id)])
    (§ block
        (§ ass (§ name this.id) id)
        (§ void nil)
    )

    ;;;
     ; A marker that results in any alerts with an ID lower than this value to be considered cancelled.
     ; @return uint32
     ;;
    #_public
    (§ method #_"long" (§ fn getCancel) [])
    (§ block
        (§ return cancel)
    )

    #_public
    (§ method #_"void" (§ fn setCancel) [#_"long" (§ name cancel)])
    (§ block
        (§ ass (§ name this.cancel) cancel)
        (§ void nil)
    )

    ;;;
     ; The inclusive lower bound on software versions that are considered for the purposes of this alert.  Bitcoin Core
     ; compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     ; alerts could use any version numbers.
     ; @return uint32
     ;;
    #_public
    (§ method #_"long" (§ fn getMinVer) [])
    (§ block
        (§ return minVer)
    )

    #_public
    (§ method #_"void" (§ fn setMinVer) [#_"long" (§ name minVer)])
    (§ block
        (§ ass (§ name this.minVer) minVer)
        (§ void nil)
    )

    ;;;
     ; The inclusive upper bound on software versions considered for the purposes of this alert.  Bitcoin Core
     ; compares this against a protocol version field, but as long as the subVer field is used to restrict it your
     ; alerts could use any version numbers.
     ;;
    #_public
    (§ method #_"long" (§ fn getMaxVer) [])
    (§ block
        (§ return maxVer)
    )

    #_public
    (§ method #_"void" (§ fn setMaxVer) [#_"long" (§ name maxVer)])
    (§ block
        (§ ass (§ name this.maxVer) maxVer)
        (§ void nil)
    )

    ;;;
     ; Provides an integer ordering amongst simultaneously active alerts.
     ; @return uint32
     ;;
    #_public
    (§ method #_"long" (§ fn getPriority) [])
    (§ block
        (§ return priority)
    )

    #_public
    (§ method #_"void" (§ fn setPriority) [#_"long" (§ name priority)])
    (§ block
        (§ ass (§ name this.priority) priority)
        (§ void nil)
    )

    ;;;
     ; This field is unused.  It is presumably intended for the author of the alert to provide a justification for it
     ; visible to protocol developers but not users.
     ;;
    #_public
    (§ method #_"String" (§ fn getComment) [])
    (§ block
        (§ return comment)
    )

    #_public
    (§ method #_"void" (§ fn setComment) [#_"String" (§ name comment)])
    (§ block
        (§ ass (§ name this.comment) comment)
        (§ void nil)
    )

    ;;;
     ; A string that is intended to display in the status bar of Bitcoin Core's GUI client.  It contains the user-visible
     ; message.  English only.
     ;;
    #_public
    (§ method #_"String" (§ fn getStatusBar) [])
    (§ block
        (§ return statusBar)
    )

    #_public
    (§ method #_"void" (§ fn setStatusBar) [#_"String" (§ name statusBar)])
    (§ block
        (§ ass (§ name this.statusBar) statusBar)
        (§ void nil)
    )

    ;;;
     ; This field is never used.
     ;;
    #_public
    (§ method #_"String" (§ fn getReserved) [])
    (§ block
        (§ return reserved)
    )

    #_public
    (§ method #_"void" (§ fn setReserved) [#_"String" (§ name reserved)])
    (§ block
        (§ ass (§ name this.reserved) reserved)
        (§ void nil)
    )

    #_public
    (§ method #_"long" (§ fn getVersion) [])
    (§ block
        (§ return version)
    )
)

#_(ns org.bitcoinj.core #_"Base58"
    (:import [java.math BigInteger]
             [java.util Arrays]))

;;;
 ; Base58 is a way to encode Bitcoin addresses (or arbitrary data) as alphanumeric strings.
 ;
 ; Note that this is not the same base58 as used by Flickr, which you may find referenced around the Internet.
 ;
 ; You may want to consider working with {@link VersionedChecksummedBytes} instead, which
 ; adds support for testing the prefix and suffix bytes commonly found in addresses.
 ;
 ; Satoshi explains: why base-58 instead of standard base-64 encoding?
 ; <ul>
 ; <li>Don't want 0OIl characters that look the same in some fonts and
 ;     could be used to create visually identical looking account numbers.</li>
 ; <li>A string with non-alphanumeric characters is not as easily accepted as an account number.</li>
 ; <li>E-mail usually won't line-break if there's no punctuation to break at.</li>
 ; <li>Doubleclicking selects the whole number as one word if it's all alphanumeric.</li>
 ; </ul>
 ;
 ; However, note that the encoding/decoding runs in O(n&sup2;) time, so it is not useful for large data.
 ;
 ; The basic idea of the encoding is to treat the data bytes as a large number represented using
 ; base-256 digits, convert the number to be represented using base-58 digits, preserve the exact
 ; number of leading zeros (which are otherwise lost during the mathematical operations on the
 ; numbers), and finally represent the resulting base-58 digits as alphanumeric ASCII characters.
 ;;
#_public
(§ class #_"Base58"
    #_public
    #_static
    #_final
    (§ field #_"char[]" (§ name ALPHABET) (§ expr "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz".toCharArray(§ pars )))
    #_private
    #_static
    #_final
    (§ field #_"char" (§ name ENCODED_ZERO) (§ expr ALPHABET[0]))
    #_private
    #_static
    #_final
    (§ field #_"int[]" (§ name INDEXES) (§ new #_"int[]" (§ count 128)))
    #_static
    (§ block
        (§ expr Arrays/fill(§ pars INDEXES, -1))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < ALPHABET.length) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ ass (§ name INDEXES[ALPHABET[i]]) i)
        )
    )

    ;;;
     ; Encodes the given bytes as a base58 string (no checksum is appended).
     ;
     ; @param input the bytes to encode
     ; @return the base58-encoded string
     ;;
    #_public
    #_static
    (§ method #_"String" (§ fn encode) [#_"byte[]" (§ name input)])
    (§ block
        (§ if (§ expr input.length == 0))
        (§ block
            (§ return (§ expr ""))
        )

        ;; Count leading zeros.
        (§ var #_"int" (§ name zeros) 0)
        (§ while (§ expr zeros < input.length && input[zeros] == 0))
        (§ block
            (§ ass (§ name zeros) (§ expr zeros + 1))
        )

        ;; Convert base-256 digits to base-58 digits (plus conversion to ASCII characters).
        (§ ass (§ name input) (§ expr Arrays/copyOf(§ pars input, input.length))) ;; since we modify it in-place
        (§ var #_"char[]" (§ name encoded) (§ new #_"char[]" (§ count input.length * 2))) ;; upper bound
        (§ var #_"int" (§ name outputStart) (§ expr encoded.length))
        (§ for (§ var #_"int" (§ name inputStart) zeros) :for (§ expr inputStart < input.length) :for (§ expr ))
        (§ block
            (§ ass (§ name outputStart) (§ expr outputStart - 1))
            (§ ass (§ name encoded[outputStart]) (§ expr ALPHABET[divmod(§ pars input, inputStart, 256, 58)]))
            (§ if (§ expr input[inputStart] == 0))
            (§ block
                (§ ass (§ name inputStart) (§ expr inputStart + 1)) ;; optimization - skip leading zeros
            )
        )
        ;; Preserve exactly as many leading encoded zeros in output as there were leading zeros in input.
        (§ while (§ expr outputStart < encoded.length && encoded[outputStart] == ENCODED_ZERO))
        (§ block
            (§ ass (§ name outputStart) (§ expr outputStart + 1))
        )
        (§ for (§ var ) :for (§ expr 0 < zeros) :for (§ ass (§ name zeros) (§ expr zeros - 1)))
        (§ block
            (§ ass (§ name outputStart) (§ expr outputStart - 1))
            (§ ass (§ name encoded[outputStart]) (§ expr ENCODED_ZERO))
        )

        ;; Return encoded string (including encoded leading zeros).
        (§ return (§ new #_"String" (§ pars encoded, outputStart, encoded.length - outputStart)))
    )

    ;;;
     ; Decodes the given base58 string into the original data bytes.
     ;
     ; @param input the base58-encoded string to decode
     ; @return the decoded data bytes
     ; @throws AddressFormatException if the given string is not a valid base58 string
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn decode) [#_"String" (§ name input)])
        (§ throws #_"AddressFormatException")
    (§ block
        (§ if (§ expr input.length(§ pars ) == 0))
        (§ block
            (§ return (§ new #_"byte[]" (§ count 0)))
        )

        ;; Convert the base58-encoded ASCII chars to a base58 byte sequence (base58 digits).
        (§ var #_"byte[]" (§ name input58) (§ new #_"byte[]" (§ count input.length(§ pars ))))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < input.length(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ var #_"char" (§ name c) (§ expr input.charAt(§ pars i)))
            (§ var #_"int" (§ name digit) (§ quest (§ expr c < 128) ? (§ expr INDEXES[c]) :else -1))
            (§ if (§ expr digit < 0))
            (§ block
                (§ throw (§ new #_"AddressFormatException" (§ pars "Illegal character " + c + " at position " + i)))
            )
            (§ ass (§ name input58[i]) (§ cast #_"byte" digit))
        )
        ;; Count leading zeros.
        (§ var #_"int" (§ name zeros) 0)
        (§ while (§ expr zeros < input58.length && input58[zeros] == 0))
        (§ block
            (§ ass (§ name zeros) (§ expr zeros + 1))
        )
        ;; Convert base-58 digits to base-256 digits.
        (§ var #_"byte[]" (§ name decoded) (§ new #_"byte[]" (§ count input.length(§ pars ))))
        (§ var #_"int" (§ name outputStart) (§ expr decoded.length))
        (§ for (§ var #_"int" (§ name inputStart) zeros) :for (§ expr inputStart < input58.length) :for (§ expr ))
        (§ block
            (§ ass (§ name outputStart) (§ expr outputStart - 1))
            (§ ass (§ name decoded[outputStart]) (§ expr divmod(§ pars input58, inputStart, 58, 256)))
            (§ if (§ expr input58[inputStart] == 0))
            (§ block
                (§ ass (§ name inputStart) (§ expr inputStart + 1)) ;; optimization - skip leading zeros
            )
        )
        ;; Ignore extra leading zeroes that were added during the calculation.
        (§ while (§ expr outputStart < decoded.length && decoded[outputStart] == 0))
        (§ block
            (§ ass (§ name outputStart) (§ expr outputStart + 1))
        )

        ;; Return decoded data (including original number of leading zeros).
        (§ return (§ expr Arrays/copyOfRange(§ pars decoded, outputStart - zeros, decoded.length)))
    )

    #_public
    #_static
    (§ method #_"BigInteger" (§ fn decodeToBigInteger) [#_"String" (§ name input)])
        (§ throws #_"AddressFormatException")
    (§ block
        (§ return (§ new #_"BigInteger" (§ pars 1, decode(§ pars input))))
    )

    ;;;
     ; Decodes the given base58 string into the original data bytes, using the checksum in the
     ; last 4 bytes of the decoded data to verify that the rest are correct.  The checksum is
     ; removed from the returned data.
     ;
     ; @param input the base58-encoded string to decode (which should include the checksum)
     ; @throws AddressFormatException if the input is not base 58 or the checksum does not validate
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn decodeChecked) [#_"String" (§ name input)])
        (§ throws #_"AddressFormatException")
    (§ block
        (§ var #_"byte[]" (§ name decoded) (§ expr decode(§ pars input)))
        (§ if (§ expr decoded.length < 4))
        (§ block
            (§ throw (§ new #_"AddressFormatException" (§ pars "Input too short")))
        )
        (§ var #_"byte[]" (§ name data) (§ expr Arrays/copyOfRange(§ pars decoded, 0, decoded.length - 4)))
        (§ var #_"byte[]" (§ name checksum) (§ expr Arrays/copyOfRange(§ pars decoded, decoded.length - 4, decoded.length)))
        (§ var #_"byte[]" (§ name actualChecksum) (§ expr Arrays/copyOfRange(§ pars Sha256Hash/hashTwice(§ pars data), 0, 4)))
        (§ if (§ expr (§ not Arrays/equals(§ pars checksum, actualChecksum))))
        (§ block
            (§ throw (§ new #_"AddressFormatException" (§ pars "Checksum does not validate")))
        )
        (§ return data)
    )

    ;;;
     ; Divides a number, represented as an array of bytes each containing a single digit
     ; in the specified base, by the given divisor.  The given number is modified in-place
     ; to contain the quotient, and the return value is the remainder.
     ;
     ; @param number the number to divide
     ; @param firstDigit the index within the array of the first non-zero digit
     ;        (this is used for optimization by skipping the leading zeros)
     ; @param base the base in which the number's digits are represented (up to 256)
     ; @param divisor the number to divide by (up to 256)
     ; @return the remainder of the division operation
     ;;
    #_private
    #_static
    (§ method #_"byte" (§ fn divmod) [#_"byte[]" (§ name number), #_"int" (§ name firstDigit), #_"int" (§ name base), #_"int" (§ name divisor)])
    (§ block
        ;; This is just long division which accounts for the base of the input digits.
        (§ var #_"int" (§ name remainder) 0)
        (§ for (§ var #_"int" (§ name i) firstDigit) :for (§ expr i < number.length) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ var #_"int" (§ name digit) (§ expr (§ cast #_"int" number[i]) & 0xff))
            (§ var #_"int" (§ name temp) (§ expr remainder * base + digit))
            (§ ass (§ name number[i]) (§ cast #_"byte" (§ expr temp / divisor)))
            (§ ass (§ name remainder) (§ expr temp % divisor))
        )
        (§ return (§ cast #_"byte" remainder))
    )
)

#_(ns org.bitcoinj.core #_"BitcoinSerializer"
    (:import [java.io IOException OutputStream]
             [java.nio BufferUnderflowException ByteBuffer]
             [java.util HashMap Map])
    (:import [org.slf4j Logger LoggerFactory])
    (:import #_static [org.bitcoinj.core.Utils *]))

;;;
 ; <p>Methods to serialize and de-serialize messages to the Bitcoin network format as defined in
 ; <a href="https://en.bitcoin.it/wiki/Protocol_specification">the protocol specification</a>.</p>
 ;
 ; <p>To be able to serialize and deserialize new Message subclasses the following criteria needs to be met.</p>
 ;
 ; <ul>
 ; <li>The proper Class instance needs to be mapped to its message name in the names variable below.</li>
 ; <li>There needs to be a constructor matching: NetworkParameters params, byte[] payload.</li>
 ; <li>Message.bitcoinSerializeToStream() needs to be properly subclassed.</li>
 ; </ul>
 ;;
#_public
(§ class #_"BitcoinSerializer" (§ extends #_"MessageSerializer")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"BitcoinSerializer"))))
    #_private
    #_static
    #_final
    (§ field #_"int" (§ name COMMAND_LEN) 12)

    #_private
    #_static
    #_final
    (§ field #_"Map<Class<? extends Message>, String>" (§ name names) (§ new #_"HashMap<>" (§ pars )))
    #_static
    (§ block
        (§ expr names.put(§ pars (§ klass #_"VersionMessage"), "version"))
        (§ expr names.put(§ pars (§ klass #_"InventoryMessage"), "inv"))
        (§ expr names.put(§ pars (§ klass #_"Block"), "block"))
        (§ expr names.put(§ pars (§ klass #_"GetDataMessage"), "getdata"))
        (§ expr names.put(§ pars (§ klass #_"Transaction"), "tx"))
        (§ expr names.put(§ pars (§ klass #_"AddressMessage"), "addr"))
        (§ expr names.put(§ pars (§ klass #_"Ping"), "ping"))
        (§ expr names.put(§ pars (§ klass #_"Pong"), "pong"))
        (§ expr names.put(§ pars (§ klass #_"VersionAck"), "verack"))
        (§ expr names.put(§ pars (§ klass #_"GetBlocksMessage"), "getblocks"))
        (§ expr names.put(§ pars (§ klass #_"GetHeadersMessage"), "getheaders"))
        (§ expr names.put(§ pars (§ klass #_"GetAddrMessage"), "getaddr"))
        (§ expr names.put(§ pars (§ klass #_"HeadersMessage"), "headers"))
        (§ expr names.put(§ pars (§ klass #_"BloomFilter"), "filterload"))
        (§ expr names.put(§ pars (§ klass #_"FilteredBlock"), "merkleblock"))
        (§ expr names.put(§ pars (§ klass #_"NotFoundMessage"), "notfound"))
        (§ expr names.put(§ pars (§ klass #_"MemoryPoolMessage"), "mempool"))
        (§ expr names.put(§ pars (§ klass #_"RejectMessage"), "reject"))
    )

    #_private
    #_final
    (§ field #_"NetworkParameters" (§ name params))
    #_private
    #_final
    (§ field #_"boolean" (§ name parseRetain))

    ;;;
     ; Constructs a BitcoinSerializer with the given behavior.
     ;
     ; @param params           networkParams used to create Messages instances and termining packetMagic
     ; @param parseRetain      retain the backing byte array of a message for fast reserialization
     ;;
    #_public
    (§ constructor #_"BitcoinSerializer" [#_"NetworkParameters" (§ name params), #_"boolean" (§ name parseRetain)])
    (§ block
        (§ ass (§ name this.params) params)
        (§ ass (§ name this.parseRetain) parseRetain)
        (§ void this)
    )

    ;;;
     ; Writes message to to the output stream.
     ;;
    #_override
    #_public
    (§ method #_"void" (§ fn serialize) [#_"String" (§ name name), #_"byte[]" (§ name message), #_"OutputStream" (§ name out)])
        (§ throws #_"IOException")
    (§ block
        (§ var #_"byte[]" (§ name header) (§ new #_"byte[]" (§ count 4 + COMMAND_LEN + 4 + 4))) ;; checksum
        (§ expr uint32ToByteArrayBE(§ pars params.getPacketMagic(§ pars ), header, 0))

        ;; The header array is initialized to zero by Java so we don't have to worry
        ;; about NULL terminating the string here.
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < name.length(§ pars ) && i < COMMAND_LEN) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ ass (§ name header[4 + i]) (§ cast #_"byte" (§ expr name.codePointAt(§ pars i) & 0xff)))
        )

        (§ expr Utils/uint32ToByteArrayLE(§ pars message.length, header, 4 + COMMAND_LEN))

        (§ var #_"byte[]" (§ name hash) (§ expr Sha256Hash/hashTwice(§ pars message)))
        (§ expr System/arraycopy(§ pars hash, 0, header, 4 + COMMAND_LEN + 4, 4))
        (§ expr out.write(§ pars header))
        (§ expr out.write(§ pars message))

        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ expr log.debug(§ pars "Sending {} message: {}", name, HEX.encode(§ pars header) + HEX.encode(§ pars message)))
        )
        (§ void nil)
    )

    ;;;
     ; Writes message to to the output stream.
     ;;
    #_override
    #_public
    (§ method #_"void" (§ fn serialize) [#_"Message" (§ name message), #_"OutputStream" (§ name out)])
        (§ throws #_"IOException")
    (§ block
        (§ var #_"String" (§ name name) (§ expr names.get(§ pars message.getClass(§ pars ))))
        (§ if (§ expr name == nil))
        (§ block
            (§ throw (§ new #_"Error" (§ pars "BitcoinSerializer doesn't currently know how to serialize " + message.getClass(§ pars ))))
        )

        (§ expr serialize(§ pars name, message.bitcoinSerialize(§ pars ), out))
        (§ void nil)
    )

    ;;;
     ; Reads a message from the given ByteBuffer and returns it.
     ;;
    #_override
    #_public
    (§ method #_"Message" (§ fn deserialize) [#_"ByteBuffer" (§ name in)])
        (§ throws #_"ProtocolException", #_"IOException")
    (§ block
        ;; A Bitcoin protocol message has the following format:
        ;;
        ;;   - 4 byte magic number: 0xfabfb5da for the testnet or
        ;;                          0xf9beb4d9 for production
        ;;   - 12 byte command in ASCII
        ;;   - 4 byte payload size
        ;;   - 4 byte checksum
        ;;   - Payload data
        ;;
        ;; The checksum is the first 4 bytes of a SHA256 hash of the message payload. It isn't
        ;; present for all messages, notably, the first one on a connection.
        ;;
        ;; Bitcoin Core ignores garbage before the magic header bytes. We have to do the same because
        ;; sometimes it sends us stuff that isn't part of any message.
        (§ expr seekPastMagicBytes(§ pars in))
        (§ var #_"BitcoinPacketHeader" (§ name header) (§ new #_"BitcoinPacketHeader" (§ pars in)))
        ;; Now try to read the whole message.
        (§ return (§ expr deserializePayload(§ pars header, in)))
    )

    ;;;
     ; Deserializes only the header in case packet meta data is needed before decoding
     ; the payload.  This method assumes you have already called seekPastMagicBytes().
     ;;
    #_override
    #_public
    (§ method #_"BitcoinPacketHeader" (§ fn deserializeHeader) [#_"ByteBuffer" (§ name in)])
        (§ throws #_"ProtocolException", #_"IOException")
    (§ block
        (§ return (§ new #_"BitcoinPacketHeader" (§ pars in)))
    )

    ;;;
     ; Deserialize payload only.  You must provide a header, typically obtained by calling
     ; {@link BitcoinSerializer#deserializeHeader}.
     ;;
    #_override
    #_public
    (§ method #_"Message" (§ fn deserializePayload) [#_"BitcoinPacketHeader" (§ name header), #_"ByteBuffer" (§ name in)])
        (§ throws #_"ProtocolException", #_"BufferUnderflowException")
    (§ block
        (§ var #_"byte[]" (§ name payloadBytes) (§ new #_"byte[]" (§ count header.size)))
        (§ expr in.get(§ pars payloadBytes, 0, header.size))

        ;; Verify the checksum.
        (§ var #_"byte[]" (§ name hash))
        (§ ass (§ name hash) (§ expr Sha256Hash/hashTwice(§ pars payloadBytes)))
        (§ if (§ expr header.checksum[0] != hash[0] || header.checksum[1] != hash[1] || header.checksum[2] != hash[2] || header.checksum[3] != hash[3]))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars "Checksum failed to verify, actual " + HEX.encode(§ pars hash) + " vs " + HEX.encode(§ pars header.checksum))))
        )

        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ expr log.debug(§ pars "Received {} byte '{}' message: {}", header.size, header.command, HEX.encode(§ pars payloadBytes)))
        )

        (§ try )
        (§ block
            (§ return (§ expr makeMessage(§ pars header.command, header.size, payloadBytes, hash, header.checksum)))
        )
        (§ catch #_"Exception" (§ name e))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars "Error deserializing message " + HEX.encode(§ pars payloadBytes) + "\n", e)))
        )
    )

    #_private
    (§ method #_"Message" (§ fn makeMessage) [#_"String" (§ name command), #_"int" (§ name length), #_"byte[]" (§ name payloadBytes), #_"byte[]" (§ name hash), #_"byte[]" (§ name checksum)])
        (§ throws #_"ProtocolException")
    (§ block
        ;; We use an if ladder rather than reflection because reflection is very slow on Android.
        (§ if (§ expr command.equals(§ pars "version")))
        (§ block
            (§ return (§ new #_"VersionMessage" (§ pars params, payloadBytes)))
        )
        (§ if (§ expr command.equals(§ pars "inv")))
        (§ block
            (§ return (§ expr makeInventoryMessage(§ pars payloadBytes, length)))
        )
        (§ if (§ expr command.equals(§ pars "block")))
        (§ block
            (§ return (§ expr makeBlock(§ pars payloadBytes, length)))
        )
        (§ if (§ expr command.equals(§ pars "merkleblock")))
        (§ block
            (§ return (§ expr makeFilteredBlock(§ pars payloadBytes)))
        )
        (§ if (§ expr command.equals(§ pars "getdata")))
        (§ block
            (§ return (§ new #_"GetDataMessage" (§ pars params, payloadBytes, this, length)))
        )
        (§ if (§ expr command.equals(§ pars "getblocks")))
        (§ block
            (§ return (§ new #_"GetBlocksMessage" (§ pars params, payloadBytes)))
        )
        (§ if (§ expr command.equals(§ pars "getheaders")))
        (§ block
            (§ return (§ new #_"GetHeadersMessage" (§ pars params, payloadBytes)))
        )
        (§ if (§ expr command.equals(§ pars "tx")))
        (§ block
            (§ return (§ expr makeTransaction(§ pars payloadBytes, 0, length, hash)))
        )
        (§ if (§ expr command.equals(§ pars "addr")))
        (§ block
            (§ return (§ expr makeAddressMessage(§ pars payloadBytes, length)))
        )
        (§ if (§ expr command.equals(§ pars "ping")))
        (§ block
            (§ return (§ new #_"Ping" (§ pars params, payloadBytes)))
        )
        (§ if (§ expr command.equals(§ pars "pong")))
        (§ block
            (§ return (§ new #_"Pong" (§ pars params, payloadBytes)))
        )
        (§ if (§ expr command.equals(§ pars "verack")))
        (§ block
            (§ return (§ new #_"VersionAck" (§ pars params, payloadBytes)))
        )
        (§ if (§ expr command.equals(§ pars "headers")))
        (§ block
            (§ return (§ new #_"HeadersMessage" (§ pars params, payloadBytes)))
        )
        (§ if (§ expr command.equals(§ pars "alert")))
        (§ block
            (§ return (§ expr makeAlertMessage(§ pars payloadBytes)))
        )
        (§ if (§ expr command.equals(§ pars "filterload")))
        (§ block
            (§ return (§ expr makeBloomFilter(§ pars payloadBytes)))
        )
        (§ if (§ expr command.equals(§ pars "notfound")))
        (§ block
            (§ return (§ new #_"NotFoundMessage" (§ pars params, payloadBytes)))
        )
        (§ if (§ expr command.equals(§ pars "mempool")))
        (§ block
            (§ return (§ new #_"MemoryPoolMessage" (§ pars )))
        )
        (§ if (§ expr command.equals(§ pars "reject")))
        (§ block
            (§ return (§ new #_"RejectMessage" (§ pars params, payloadBytes)))
        )
        (§ expr log.warn(§ pars "No support for deserializing message with name {}", command))
        (§ return (§ new #_"UnknownMessage" (§ pars params, command, payloadBytes)))
    )

    ;;;
     ; Get the network parameters for this serializer.
     ;;
    #_public
    (§ method #_"NetworkParameters" (§ fn getParameters) [])
    (§ block
        (§ return params)
    )

    ;;;
     ; Make an address message from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method #_"AddressMessage" (§ fn makeAddressMessage) [#_"byte[]" (§ name payloadBytes), #_"int" (§ name length)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ return (§ new #_"AddressMessage" (§ pars params, payloadBytes, this, length)))
    )

    ;;;
     ; Make an alert message from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method #_"Message" (§ fn makeAlertMessage) [#_"byte[]" (§ name payloadBytes)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ return (§ new #_"AlertMessage" (§ pars params, payloadBytes)))
    )

    ;;;
     ; Make a block from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method #_"Block" (§ fn makeBlock) [#_final #_"byte[]" (§ name payloadBytes), #_final #_"int" (§ name offset), #_final #_"int" (§ name length)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ return (§ new #_"Block" (§ pars params, payloadBytes, offset, this, length)))
    )

    ;;;
     ; Make an filter message from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method #_"Message" (§ fn makeBloomFilter) [#_"byte[]" (§ name payloadBytes)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ return (§ new #_"BloomFilter" (§ pars params, payloadBytes)))
    )

    ;;;
     ; Make a filtered block from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method #_"FilteredBlock" (§ fn makeFilteredBlock) [#_"byte[]" (§ name payloadBytes)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ return (§ new #_"FilteredBlock" (§ pars params, payloadBytes)))
    )

    ;;;
     ; Make an inventory message from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method #_"InventoryMessage" (§ fn makeInventoryMessage) [#_"byte[]" (§ name payloadBytes), #_"int" (§ name length)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ return (§ new #_"InventoryMessage" (§ pars params, payloadBytes, this, length)))
    )

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative serialization format support.
     ;;
    #_override
    #_public
    (§ method #_"Transaction" (§ fn makeTransaction) [#_"byte[]" (§ name payloadBytes), #_"int" (§ name offset), #_"int" (§ name length), #_"byte[]" (§ name hash)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ var #_"Transaction" (§ name tx) (§ new #_"Transaction" (§ pars params, payloadBytes, offset, nil, this, length)))
        (§ if (§ expr hash != nil))
        (§ block
            (§ expr tx.setHash(§ pars Sha256Hash/wrapReversed(§ pars hash)))
        )
        (§ return tx)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn seekPastMagicBytes) [#_"ByteBuffer" (§ name in)])
        (§ throws #_"BufferUnderflowException")
    (§ block
        (§ var #_"int" (§ name magicCursor) 3) ;; Which byte of the magic we're looking for currently.
        (§ while true)
        (§ block
            (§ var #_"byte" (§ name b) (§ expr in.get(§ pars )))
            ;; We're looking for a run of bytes that is the same as the packet magic but we want to ignore partial
            ;; magics that aren't complete.  So we keep track of where we're up to with magicCursor.
            (§ var #_"byte" (§ name expectedByte) (§ expr (§ cast #_"byte" (§ expr 0xff & params.getPacketMagic(§ pars ) >>> (§ expr magicCursor << 3)))))
            (§ if (§ expr b == expectedByte))
            (§ block
                (§ ass (§ name magicCursor) (§ expr magicCursor - 1))
                (§ if (§ expr magicCursor < 0))
                (§ block
                    (§ return nil) ;; We found the magic sequence.
                )
            )
            (§ else )
            (§ block
                (§ ass (§ name magicCursor) 3)
            )
        )
        (§ void nil)
    )

    ;;;
     ; Whether the serializer will produce cached mode Messages.
     ;;
    #_override
    #_public
    (§ method #_"boolean" (§ fn isParseRetainMode) [])
    (§ block
        (§ return parseRetain)
    )

    #_public
    #_static
    (§ class #_"BitcoinPacketHeader"
        ;;; The largest number of bytes that a header can represent. ;;
        #_public
        #_static
        #_final
        (§ field #_"int" (§ name HEADER_LENGTH) (§ expr COMMAND_LEN + 4 + 4))

        #_public
        #_final
        (§ field #_"byte[]" (§ name header))
        #_public
        #_final
        (§ field #_"String" (§ name command))
        #_public
        #_final
        (§ field #_"int" (§ name size))
        #_public
        #_final
        (§ field #_"byte[]" (§ name checksum))

        #_public
        (§ constructor #_"BitcoinPacketHeader" [#_"ByteBuffer" (§ name in)])
            (§ throws #_"ProtocolException", #_"BufferUnderflowException")
        (§ block
            (§ ass (§ name header) (§ new #_"byte[]" (§ count HEADER_LENGTH)))
            (§ expr in.get(§ pars header, 0, header.length))

            (§ var #_"int" (§ name cursor) 0)

            ;; The command is a NULL terminated string, unless the command fills all twelve bytes
            ;; in which case the termination is implicit.
            (§ while (§ expr header[cursor] != 0 && cursor < COMMAND_LEN))
            (§ block
                (§ ass (§ name cursor) (§ expr cursor + 1))
            )
            (§ var #_"byte[]" (§ name commandBytes) (§ new #_"byte[]" (§ count cursor)))
            (§ expr System/arraycopy(§ pars header, 0, commandBytes, 0, cursor))
            (§ ass (§ name command) (§ expr Utils/toString(§ pars commandBytes, "US-ASCII")))
            (§ ass (§ name cursor) (§ expr COMMAND_LEN))

            (§ ass (§ name size) (§ cast #_"int" (§ expr readUint32(§ pars header, cursor))))
            (§ ass (§ name cursor) (§ expr cursor + 4))

            (§ if (§ expr Message/MAX_SIZE < size || size < 0))
            (§ block
                (§ throw (§ new #_"ProtocolException" (§ pars "Message size too large: " + size)))
            )

            ;; Old clients don't send the checksum.
            (§ ass (§ name checksum) (§ new #_"byte[]" (§ count 4)))
            ;; Note that the size read above includes the checksum bytes.
            (§ expr System/arraycopy(§ pars header, cursor, checksum, 0, 4))
            (§ ass (§ name cursor) (§ expr cursor + 4))
            (§ void this)
        )
    )
)

#_(ns org.bitcoinj.core #_"Block"
    (:import [java.io *]
             [java.math *]
             [java.util *])
    (:import [com.google.common.annotations *]
             [com.google.common.base *]
             [com.google.common.collect *]
             [org.slf4j *])
   (:require [org.bitcoinj.script *]
             #_static [org.bitcoinj.core.Coin *]
             #_static [org.bitcoinj.core.Sha256Hash *]))

;;;
 ; <p>A block is a group of transactions, and is one of the fundamental data structures of the Bitcoin system.
 ; It records a set of {@link Transaction}s together with some data that links it into a place in the global block chain,
 ; and proves that a difficult calculation was done over its contents.
 ; See <a href="http://www.bitcoin.org/bitcoin.pdf">the Bitcoin technical paper</a> for more detail on blocks.
 ;
 ; <p>To get a block, you can either build one from the raw bytes you can get from another implementation, or request one
 ; specifically using {@link Peer#getBlock(Sha256Hash)}, or grab one from a downloaded {@link BlockChain}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"Block" (§ extends #_"Message")
    ;;;
     ; Flags used to control which elements of block validation are done on received blocks.
     ;;
    #_public
    (§ enum #_"VerifyFlag"
        ;;; Check that block height is in coinbase transaction (BIP 34). ;;
        (§ item HEIGHT_IN_COINBASE)
    )

    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"Block"))))

    ;;; How many bytes are required to represent a block header WITHOUT the trailing 00 length byte. ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name HEADER_SIZE) 80)

    #_static
    #_final
    (§ field #_"long" (§ name ALLOWED_TIME_DRIFT) (§ expr 2 * 60 * 60)) ;; Same value as Bitcoin Core.

    ;;;
     ; A constant shared by the entire network: how large in bytes a block is allowed to be.  One day we may have to
     ; upgrade everyone to change this, so Bitcoin can continue to grow.  For now it exists as an anti-DoS measure to
     ; avoid somebody creating a titanically huge but valid block and forcing everyone to download/store it forever.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name MAX_BLOCK_SIZE) (§ expr 1 * 1000 * 1000))
    ;;;
     ; A "sigop" is a signature verification operation.  Because they're expensive, we also impose a separate limit on
     ; the number in a block to prevent somebody mining a huge block that has way more sigops than normal, so is very
     ; expensive/slow to verify.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name MAX_BLOCK_SIGOPS) (§ expr MAX_BLOCK_SIZE / 50))

    ;;; A value for difficultyTarget (nBits) that allows half of all possible hash solutions.  Used in unit testing. ;;
    #_public
    #_static
    #_final
    (§ field #_"long" (§ name EASIEST_DIFFICULTY_TARGET) (§ expr 0x207fffff))

    ;;; Value to use if the block height is unknown. ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name BLOCK_HEIGHT_UNKNOWN) -1)
    ;;; Height of the first block. ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name BLOCK_HEIGHT_GENESIS) 0)

    #_public
    #_static
    #_final
    (§ field #_"long" (§ name BLOCK_VERSION_GENESIS) 1)
    ;;; Block version introduced in BIP 34: Height in coinbase. ;;
    #_public
    #_static
    #_final
    (§ field #_"long" (§ name BLOCK_VERSION_BIP34) 2)
    ;;; Block version introduced in BIP 66: Strict DER signatures. ;;
    #_public
    #_static
    #_final
    (§ field #_"long" (§ name BLOCK_VERSION_BIP66) 3)
    ;;; Block version introduced in BIP 65: OP_CHECKLOCKTIMEVERIFY ;;
    #_public
    #_static
    #_final
    (§ field #_"long" (§ name BLOCK_VERSION_BIP65) 4)

    ;; Fields defined as part of the protocol format.
    #_private
    (§ field #_"long" (§ name version))
    #_private
    (§ field #_"Sha256Hash" (§ name prevBlockHash))
    #_private
    (§ field #_"Sha256Hash" (§ name merkleRoot))
    #_private
    (§ field #_"long" (§ name time))
    #_private
    (§ field #_"long" (§ name difficultyTarget)) ;; "nBits"
    #_private
    (§ field #_"long" (§ name nonce))

    ;; TODO: Get rid of all the direct accesses to this field.  It's a long-since unnecessary holdover from the Dalvik days.
    ;;; If null, it means this object holds only the headers. ;;
    #_nilable
    (§ field #_"List<Transaction>" (§ name transactions))

    ;;; Stores the hash of the block.  If null, getHash() will recalculate it. ;;
    #_private
    (§ field #_"Sha256Hash" (§ name hash))

    #_protected
    (§ field #_"boolean" (§ name headerBytesValid))
    #_protected
    (§ field #_"boolean" (§ name transactionBytesValid))

    ;; Blocks can be encoded in a way that will use more bytes than is optimal (due to VarInts having multiple encodings).
    ;; MAX_BLOCK_SIZE must be compared to the optimal encoding, not the actual encoding, so when parsing, we keep track
    ;; of the size of the ideal encoding in addition to the actual message size (which Message needs).
    #_protected
    (§ field #_"int" (§ name optimalEncodingMessageSize))

    ;;; Special case constructor, used for the genesis node, cloneAsHeader and unit tests. ;;
    (§ constructor #_"Block" [#_"NetworkParameters" (§ name params), #_"long" (§ name setVersion)])
    (§ block
        (§ super (§ pars params))

        ;; Set up a few basic things.  We are not complete after this though.
        (§ ass (§ name version) setVersion)
        (§ ass (§ name difficultyTarget) (§ expr 0x1d07fff8))
        (§ ass (§ name time) (§ expr System/currentTimeMillis(§ pars ) / 1000))
        (§ ass (§ name prevBlockHash) (§ expr Sha256Hash/ZERO_HASH))

        (§ ass (§ name length) (§ expr HEADER_SIZE))
        (§ void this)
    )

    ;;;
     ; Constructs a block object from the Bitcoin wire format.
     ; @deprecated Use {@link BitcoinSerializer#makeBlock(byte[])} instead.
     ;;
    #_deprecated
    #_public
    (§ constructor #_"Block" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payloadBytes)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payloadBytes, 0, params.getDefaultSerializer(§ pars ), payloadBytes.length))
        (§ void this)
    )

    ;;;
     ; Construct a block object from the Bitcoin wire format.
     ; @param params NetworkParameters object.
     ; @param payloadBytes The payload to extract the block from.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor #_"Block" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payloadBytes), #_"MessageSerializer" (§ name serializer), #_"int" (§ name length)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payloadBytes, 0, serializer, length))
        (§ void this)
    )

    ;;;
     ; Construct a block object from the Bitcoin wire format.
     ; @param params NetworkParameters object.
     ; @param payloadBytes The payload to extract the block from.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor #_"Block" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payloadBytes), #_"int" (§ name offset), #_"MessageSerializer" (§ name serializer), #_"int" (§ name length)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payloadBytes, offset, serializer, length))
        (§ void this)
    )

    ;;;
     ; Construct a block object from the Bitcoin wire format.  Used in the case of a block
     ; contained within another message (i.e. for AuxPoW header).
     ;
     ; @param params NetworkParameters object.
     ; @param payloadBytes Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param parent The message element which contains this block, maybe null for no parent.
     ; @param serializer The serializer to use for this block.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor #_"Block" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payloadBytes), #_"int" (§ name offset), #_nilable #_"Message" (§ name parent), #_"MessageSerializer" (§ name serializer), #_"int" (§ name length)])
        (§ throws #_"ProtocolException")
    (§ block
        ;; TODO: Keep the parent.
        (§ super (§ pars params, payloadBytes, offset, serializer, length))
        (§ void this)
    )

    ;;;
     ; Construct a block initialized with all the given fields.
     ; @param params Which network the block is for.
     ; @param version This should usually be set to 1 or 2, depending on if the height is in the coinbase input.
     ; @param prevBlockHash Reference to previous block in the chain or {@link Sha256Hash#ZERO_HASH} if genesis.
     ; @param merkleRoot The root of the merkle tree formed by the transactions.
     ; @param time UNIX time when the block was mined.
     ; @param difficultyTarget Number which this block hashes lower than.
     ; @param nonce Arbitrary number to make the block hash lower than the target.
     ; @param transactions List of transactions including the coinbase.
     ;;
    #_public
    (§ constructor #_"Block" [#_"NetworkParameters" (§ name params), #_"long" (§ name version), #_"Sha256Hash" (§ name prevBlockHash), #_"Sha256Hash" (§ name merkleRoot), #_"long" (§ name time), #_"long" (§ name difficultyTarget), #_"long" (§ name nonce), #_"List<Transaction>" (§ name transactions)])
    (§ block
        (§ super (§ pars params))

        (§ ass (§ name this.version) version)
        (§ ass (§ name this.prevBlockHash) prevBlockHash)
        (§ ass (§ name this.merkleRoot) merkleRoot)
        (§ ass (§ name this.time) time)
        (§ ass (§ name this.difficultyTarget) difficultyTarget)
        (§ ass (§ name this.nonce) nonce)
        (§ ass (§ name this.transactions) (§ new #_"LinkedList<>" (§ pars )))
        (§ expr this.transactions.addAll(§ pars transactions))
        (§ void this)
    )

    ;;;
     ; <p>A utility method that calculates how much new Bitcoin would be created by the block at the given height.
     ; The inflation of Bitcoin is predictable and drops roughly every 4 years (210,000 blocks).  At the dawn of
     ; the system it was 50 coins per block, in late 2012 it went to 25 coins per block, and so on.  The size of
     ; a coinbase transaction is inflation plus fees.</p>
     ;
     ; The half-life is controlled by {@link org.bitcoinj.core.NetworkParameters#getSubsidyDecreaseBlockCount()}.
     ;;
    #_public
    (§ method #_"Coin" (§ fn getBlockInflation) [#_"int" (§ name height)])
    (§ block
        (§ return (§ expr FIFTY_COINS.shiftRight(§ pars height / params.getSubsidyDecreaseBlockCount(§ pars ))))
    )

    ;;;
     ; Parse transactions from the block.
     ;
     ; @param transactionsOffset Offset of the transactions within the block.
     ; Useful for non-Bitcoin chains where the block header may not be a fixed size.
     ;;
    #_protected
    (§ method #_"void" (§ fn parseTransactions) [#_final #_"int" (§ name transactionsOffset)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ ass (§ name cursor) transactionsOffset)
        (§ ass (§ name optimalEncodingMessageSize) (§ expr HEADER_SIZE))
        (§ if (§ expr payload.length == cursor))
        (§ block
            ;; This message is just a header, it has no transactions.
            (§ ass (§ name transactionBytesValid) false)
            (§ return nil)
        )

        (§ var #_"int" (§ name numTransactions) (§ expr (§ cast #_"int" (§ expr readVarInt(§ pars )))))
        (§ ass (§ name optimalEncodingMessageSize) (§ expr optimalEncodingMessageSize + VarInt/sizeOf(§ pars numTransactions)))
        (§ ass (§ name transactions) (§ new #_"ArrayList<>" (§ pars numTransactions)))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numTransactions) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ var #_"Transaction" (§ name tx) (§ new #_"Transaction" (§ pars params, payload, cursor, this, serializer, UNKNOWN_LENGTH)))
            ;; Label the transaction as coming from the P2P network, so code that cares where we first saw it knows.
            (§ expr tx.getConfidence(§ pars ).setSource(§ pars TransactionConfidence/Source/NETWORK))
            (§ expr transactions.add(§ pars tx))
            (§ ass (§ name cursor) (§ expr cursor + tx.getMessageSize(§ pars )))
            (§ ass (§ name optimalEncodingMessageSize) (§ expr optimalEncodingMessageSize + tx.getOptimalEncodingMessageSize(§ pars )))
        )
        (§ ass (§ name transactionBytesValid) (§ expr serializer.isParseRetainMode(§ pars )))
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        ;; header
        (§ ass (§ name cursor) offset)
        (§ ass (§ name version) (§ expr readUint32(§ pars )))
        (§ ass (§ name prevBlockHash) (§ expr readHash(§ pars )))
        (§ ass (§ name merkleRoot) (§ expr readHash(§ pars )))
        (§ ass (§ name time) (§ expr readUint32(§ pars )))
        (§ ass (§ name difficultyTarget) (§ expr readUint32(§ pars )))
        (§ ass (§ name nonce) (§ expr readUint32(§ pars )))
        (§ ass (§ name hash) (§ expr Sha256Hash/wrapReversed(§ pars Sha256Hash/hashTwice(§ pars payload, offset, cursor - offset))))
        (§ ass (§ name headerBytesValid) (§ expr serializer.isParseRetainMode(§ pars )))

        ;; transactions
        (§ expr parseTransactions(§ pars offset + HEADER_SIZE))
        (§ ass (§ name length) (§ expr cursor - offset))
        (§ void nil)
    )

    #_public
    (§ method #_"int" (§ fn getOptimalEncodingMessageSize) [])
    (§ block
        (§ if (§ expr optimalEncodingMessageSize != 0))
        (§ block
            (§ return optimalEncodingMessageSize)
        )
        (§ ass (§ name optimalEncodingMessageSize) (§ expr bitcoinSerialize(§ pars ).length))
        (§ return optimalEncodingMessageSize)
    )

    ;; default for testing
    (§ method #_"void" (§ fn writeHeader) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        ;; try for cached write first
        (§ if (§ expr headerBytesValid && payload != nil && offset + HEADER_SIZE <= payload.length))
        (§ block
            (§ expr stream.write(§ pars payload, offset, HEADER_SIZE))
            (§ return nil)
        )

        ;; fall back to manual write
        (§ expr Utils/uint32ToByteStreamLE(§ pars version, stream))
        (§ expr stream.write(§ pars prevBlockHash.getReversedBytes(§ pars )))
        (§ expr stream.write(§ pars getMerkleRoot(§ pars ).getReversedBytes(§ pars )))
        (§ expr Utils/uint32ToByteStreamLE(§ pars time, stream))
        (§ expr Utils/uint32ToByteStreamLE(§ pars difficultyTarget, stream))
        (§ expr Utils/uint32ToByteStreamLE(§ pars nonce, stream))
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn writeTransactions) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        ;; check for no transaction conditions first
        (§ if (§ expr transactions == nil))
        (§ block
            (§ return nil)
        )

        ;; confirmed we must have transactions either cached or as objects
        (§ if (§ expr transactionBytesValid && payload != nil && offset + length <= payload.length))
        (§ block
            (§ expr stream.write(§ pars payload, offset + HEADER_SIZE, length - HEADER_SIZE))
            (§ return nil)
        )

        (§ if (§ expr transactions != nil))
        (§ block
            (§ expr stream.write(§ pars (§ new #_"VarInt" (§ pars transactions.size(§ pars ))).encode(§ pars )))
            (§ for (§ var #_"Transaction" (§ name tx)) :for transactions)
            (§ block
                (§ expr tx.bitcoinSerialize(§ pars stream))
            )
        )
        (§ void nil)
    )

    ;;;
     ; Special handling to check if we have a valid byte array for both header and transactions.
     ;
     ; @throws IOException
     ;;
    #_override
    #_public
    (§ method #_"byte[]" (§ fn bitcoinSerialize) [])
    (§ block
        ;; we have completely cached byte array
        (§ if (§ expr headerBytesValid && transactionBytesValid))
        (§ block
            (§ expr Preconditions/checkNotNull(§ pars payload, "Bytes should never be nil if headerBytesValid && transactionBytesValid"))
            (§ if (§ expr length == payload.length))
            (§ block
                (§ return payload)
            )

            ;; byte array is offset, so copy out the correct range
            (§ var #_"byte[]" (§ name buf) (§ new #_"byte[]" (§ count length)))
            (§ expr System/arraycopy(§ pars payload, offset, buf, 0, length))
            (§ return buf)
        )

        ;; At least one of the two cacheable components is invalid, so fall back to stream write since we can't be sure of the length.
        (§ var #_"ByteArrayOutputStream" (§ name stream) (§ new #_"UnsafeByteArrayOutputStream" (§ pars (§ quest (§ expr length == UNKNOWN_LENGTH) ? (§ expr HEADER_SIZE + guessTransactionsLength(§ pars )) :else length))))
        (§ try )
        (§ block
            (§ expr writeHeader(§ pars stream))
            (§ expr writeTransactions(§ pars stream))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            ;; Cannot happen, we are serializing to a memory stream.
        )
        (§ return (§ expr stream.toByteArray(§ pars )))
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ expr writeHeader(§ pars stream))
        ;; We may only have enough data to write the header.
        (§ expr writeTransactions(§ pars stream))
        (§ void nil)
    )

    ;;;
     ; Provides a reasonable guess at the byte length of the transactions part of the block.
     ; The returned value will be accurate in 99% of cases and in those cases where not will probably slightly oversize.
     ;
     ; This is used to preallocate the underlying byte array for a ByteArrayOutputStream.  If the size is under the
     ; real value the only penalty is resizing of the underlying byte array.
     ;;
    #_private
    (§ method #_"int" (§ fn guessTransactionsLength) [])
    (§ block
        (§ if transactionBytesValid)
        (§ block
            (§ return (§ expr payload.length - HEADER_SIZE))
        )
        (§ if (§ expr transactions == nil))
        (§ block
            (§ return 0)
        )
        (§ var #_"int" (§ name len) (§ expr VarInt/sizeOf(§ pars transactions.size(§ pars ))))
        (§ for (§ var #_"Transaction" (§ name tx)) :for transactions)
        (§ block
            ;; 255 is just a guess at an average tx length
            (§ ass (§ name len) (§ expr len + (§ quest (§ expr tx.length == UNKNOWN_LENGTH) ? 255 :else (§ expr tx.length))))
        )
        (§ return len)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn unCache) [])
    (§ block
        ;; Since we have alternate uncache methods to use internally, this will only ever be called by a child
        ;; transaction, so we only need to invalidate that part of the cache.
        (§ expr unCacheTransactions(§ pars ))
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn unCacheHeader) [])
    (§ block
        (§ ass (§ name headerBytesValid) false)
        (§ if (§ expr (§ not transactionBytesValid)))
        (§ block
            (§ ass (§ name payload) nil)
        )
        (§ ass (§ name hash) nil)
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn unCacheTransactions) [])
    (§ block
        (§ ass (§ name transactionBytesValid) false)
        (§ if (§ expr (§ not headerBytesValid)))
        (§ block
            (§ ass (§ name payload) nil)
        )
        ;; Current implementation has to uncache headers as well as any change to a tx will alter the merkle root.
        ;; In future, we can go more granular and cache merkle root separately so rest of the header does not need to be rewritten.
        (§ expr unCacheHeader(§ pars ))
        ;; Clear merkleRoot last as it may end up being parsed during unCacheHeader().
        (§ ass (§ name merkleRoot) nil)
        (§ void nil)
    )

    ;;;
     ; Calculates the block hash by serializing the block and hashing the resulting bytes.
     ;;
    #_private
    (§ method #_"Sha256Hash" (§ fn calculateHash) [])
    (§ block
        (§ try )
        (§ block
            (§ var #_"ByteArrayOutputStream" (§ name bos) (§ new #_"UnsafeByteArrayOutputStream" (§ pars HEADER_SIZE)))
            (§ expr writeHeader(§ pars bos))
            (§ return (§ expr Sha256Hash/wrapReversed(§ pars Sha256Hash/hashTwice(§ pars bos.toByteArray(§ pars )))))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
    )

    ;;;
     ; Returns the hash of the block (which for a valid, solved block should be below the target) in the form seen on
     ; the block explorer.  If you call this on block 1 in the mainnet chain,
     ; you will get "00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048".
     ;;
    #_public
    (§ method #_"String" (§ fn getHashAsString) [])
    (§ block
        (§ return (§ expr getHash(§ pars ).toString(§ pars )))
    )

    ;;;
     ; Returns the hash of the block (which for a valid, solved block should be
     ; below the target).  Big endian.
     ;;
    #_override
    #_public
    (§ method #_"Sha256Hash" (§ fn getHash) [])
    (§ block
        (§ if (§ expr hash == nil))
        (§ block
            (§ ass (§ name hash) (§ expr calculateHash(§ pars )))
        )
        (§ return hash)
    )

    ;;;
     ; The number that is one greater than the largest representable SHA-256 hash.
     ;;
    #_private
    #_static
    (§ field #_"BigInteger" (§ name LARGEST_HASH) (§ expr BigInteger/ONE.shiftLeft(§ pars 256)))

    ;;;
     ; Returns the work represented by this block.
     ;
     ; Work is defined as the number of tries needed to solve a block in the
     ; average case.  Consider a difficulty target that covers 5% of all possible
     ; hash values.  Then the work of the block will be 20.  As the target gets
     ; lower, the amount of work goes up.
     ;;
    #_public
    (§ method #_"BigInteger" (§ fn getWork) [])
        (§ throws #_"VerificationException")
    (§ block
        (§ var #_"BigInteger" (§ name target) (§ expr getDifficultyTargetAsInteger(§ pars )))
        (§ return (§ expr LARGEST_HASH.divide(§ pars target.add(§ pars BigInteger/ONE))))
    )

    ;;; Returns a copy of the block, but without any transactions. ;;
    #_public
    (§ method #_"Block" (§ fn cloneAsHeader) [])
    (§ block
        (§ var #_"Block" (§ name block) (§ new #_"Block" (§ pars params, BLOCK_VERSION_GENESIS)))
        (§ expr copyBitcoinHeaderTo(§ pars block))
        (§ return block)
    )

    ;;; Copy the block without transactions into the provided empty block. ;;
    #_protected
    #_final
    (§ method #_"void" (§ fn copyBitcoinHeaderTo) [#_final #_"Block" (§ name block)])
    (§ block
        (§ ass (§ name block.nonce) nonce)
        (§ ass (§ name block.prevBlockHash) prevBlockHash)
        (§ ass (§ name block.merkleRoot) (§ expr getMerkleRoot(§ pars )))
        (§ ass (§ name block.version) version)
        (§ ass (§ name block.time) time)
        (§ ass (§ name block.difficultyTarget) difficultyTarget)
        (§ ass (§ name block.transactions) nil)
        (§ ass (§ name block.hash) (§ expr getHash(§ pars )))
        (§ void nil)
    )

    ;;;
     ; Returns a multi-line string containing a description of the contents of the block.
     ; Use for debugging purposes only.
     ;;
    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ var #_"StringBuilder" (§ name sb) (§ new #_"StringBuilder" (§ pars )))
        (§ expr sb.append(§ pars " block: \n"))
        (§ expr sb.append(§ pars "   hash: ").append(§ pars getHashAsString(§ pars )).append(§ pars "\n"))
        (§ expr sb.append(§ pars "   version: ").append(§ pars version))
        (§ var #_"String" (§ name bips) (§ dot Joiner/on(§ pars ", ").skipNulls(§ pars ).join(§ pars (§ quest (§ expr isBIP34(§ pars )) ? (§ expr "BIP34") :else nil), (§ quest (§ expr isBIP66(§ pars )) ? (§ expr "BIP66") :else nil), (§ quest (§ expr isBIP65(§ pars )) ? (§ expr "BIP65") :else nil))))
        (§ if (§ expr (§ not bips.isEmpty(§ pars ))))
        (§ block
            (§ expr sb.append(§ pars " (").append(§ pars bips).append(§ pars ")"))
        )
        (§ expr sb.append(§ pars "\n"))
        (§ expr sb.append(§ pars "   previous block: ").append(§ pars getPrevBlockHash(§ pars )).append(§ pars "\n"))
        (§ expr sb.append(§ pars "   merkle root: ").append(§ pars getMerkleRoot(§ pars )).append(§ pars "\n"))
        (§ expr sb.append(§ pars "   time: ").append(§ pars time).append(§ pars " (").append(§ pars Utils/dateTimeFormat(§ pars time * 1000)).append(§ pars ")\n"))
        (§ expr sb.append(§ pars "   difficulty target (nBits): ").append(§ pars difficultyTarget).append(§ pars "\n"))
        (§ expr sb.append(§ pars "   nonce: ").append(§ pars nonce).append(§ pars "\n"))
        (§ if (§ expr transactions != nil && 0 < transactions.size(§ pars )))
        (§ block
            (§ expr sb.append(§ pars "   with ").append(§ pars transactions.size(§ pars )).append(§ pars " transaction(s):\n"))
            (§ for (§ var #_"Transaction" (§ name tx)) :for transactions)
            (§ block
                (§ expr sb.append(§ pars tx))
            )
        )
        (§ return (§ expr sb.toString(§ pars )))
    )

    ;;;
     ; <p>Finds a value of nonce that makes the blocks hash lower than the difficulty target.  This is called mining,
     ; but solve() is far too slow to do real mining with.  It exists only for unit testing purposes.
     ;
     ; <p>This can loop forever if a solution cannot be found solely by incrementing nonce.  It doesn't change
     ; extraNonce.</p>
     ;;
    #_public
    (§ method #_"void" (§ fn solve) [])
    (§ block
        (§ while true)
        (§ block
            (§ try )
            (§ block
                ;; Is our proof of work valid yet?
                (§ if (§ expr checkProofOfWork(§ pars false)))
                (§ block
                    (§ return nil)
                )
                ;; No, so increment the nonce and try again.
                (§ expr setNonce(§ pars getNonce(§ pars ) + 1))
            )
            (§ catch #_"VerificationException" (§ name e))
            (§ block
                (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
            )
        )
        (§ void nil)
    )

    ;;;
     ; Returns the difficulty target as a 256 bit value that can be compared to a SHA-256 hash.  Inside a block the
     ; target is represented using a compact form.  If this form decodes to a value that is out of bounds, an exception
     ; is thrown.
     ;;
    #_public
    (§ method #_"BigInteger" (§ fn getDifficultyTargetAsInteger) [])
        (§ throws #_"VerificationException")
    (§ block
        (§ var #_"BigInteger" (§ name target) (§ expr Utils/decodeCompactBits(§ pars difficultyTarget)))
        (§ if (§ expr target.signum(§ pars ) <= 0 || 0 < target.compareTo(§ pars params.maxTarget)))
        (§ block
            (§ throw (§ new #_"VerificationException" (§ pars "Difficulty target is bad: " + target)))
        )
        (§ return target)
    )

    ;;; Returns true if the hash of the block is OK (lower than difficulty target). ;;
    #_protected
    (§ method #_"boolean" (§ fn checkProofOfWork) [#_"boolean" (§ name throwException)])
        (§ throws #_"VerificationException")
    (§ block
        ;; This part is key - it is what proves the block was as difficult to make as it claims
        ;; to be.  Note however that in the context of this function, the block can claim to be
        ;; as difficult as it wants to be .... if somebody was able to take control of our network
        ;; connection and fork us onto a different chain, they could send us valid blocks with
        ;; ridiculously easy difficulty and this function would accept them.
        ;;
        ;; To prevent this attack from being possible, elsewhere we check that the difficultyTarget
        ;; field is of the right value.  This requires us to have the preceeding blocks.
        (§ var #_"BigInteger" (§ name target) (§ expr getDifficultyTargetAsInteger(§ pars )))

        (§ var #_"BigInteger" (§ name h) (§ expr getHash(§ pars ).toBigInteger(§ pars )))
        (§ if (§ expr 0 < h.compareTo(§ pars target)))
        (§ block
            ;; Proof of work check failed!
            (§ if throwException)
            (§ block
                (§ throw (§ new #_"VerificationException" (§ pars "Hash is higher than target: " + getHashAsString(§ pars ) + " vs " + target.toString(§ pars 16))))
            )
            (§ else )
            (§ block
                (§ return false)
            )
        )
        (§ return true)
    )

    #_private
    (§ method #_"void" (§ fn checkTimestamp) [])
        (§ throws #_"VerificationException")
    (§ block
        #_final
        (§ var #_"long" (§ name allowedTime) (§ expr Utils/currentTimeSeconds(§ pars ) + ALLOWED_TIME_DRIFT))
        (§ if (§ expr allowedTime < time))
        (§ block
            (§ throw (§ new #_"VerificationException" (§ pars String/format(§ pars Locale/US, "Block too far in future: %s (%d) vs allowed %s (%d)", Utils/dateTimeFormat(§ pars time * 1000), time, Utils/dateTimeFormat(§ pars allowedTime * 1000), allowedTime))))
        )
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn checkSigOps) [])
        (§ throws #_"VerificationException")
    (§ block
        ;; Check there aren't too many signature verifications in the block.  This is an anti-DoS measure, see the
        ;; comments for MAX_BLOCK_SIGOPS.
        (§ var #_"int" (§ name sigOps) 0)
        (§ for (§ var #_"Transaction" (§ name tx)) :for transactions)
        (§ block
            (§ ass (§ name sigOps) (§ expr sigOps + tx.getSigOpCount(§ pars )))
        )

        (§ if (§ expr MAX_BLOCK_SIGOPS < sigOps))
        (§ block
            (§ throw (§ new #_"VerificationException" (§ pars "Block had too many Signature Operations")))
        )
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn checkMerkleRoot) [])
        (§ throws #_"VerificationException")
    (§ block
        (§ var #_"Sha256Hash" (§ name calculatedRoot) (§ expr calculateMerkleRoot(§ pars )))
        (§ if (§ expr (§ not calculatedRoot.equals(§ pars merkleRoot))))
        (§ block
            (§ expr log.error(§ pars "Merkle tree did not verify"))
            (§ throw (§ new #_"VerificationException" (§ pars "Merkle hashes do not match: " + calculatedRoot + " vs " + merkleRoot)))
        )
        (§ void nil)
    )

    #_private
    (§ method #_"Sha256Hash" (§ fn calculateMerkleRoot) [])
    (§ block
        (§ var #_"List<byte[]>" (§ name tree) (§ expr buildMerkleTree(§ pars )))
        (§ return (§ expr Sha256Hash/wrap(§ pars tree.get(§ pars tree.size(§ pars ) - 1))))
    )

    #_private
    (§ method #_"List<byte[]>" (§ fn buildMerkleTree) [])
    (§ block
        ;; The Merkle root is based on a tree of hashes calculated from the transactions:
        ;;
        ;;     root
        ;;     /  \
        ;;   A      B
        ;;  / \    / \
        ;; t1 t2  t3 t4
        ;;
        ;; The tree is represented as a list: (t1 t2 t3 t4 A B root), where each entry is a hash.
        ;;
        ;; The hashing algorithm is double SHA-256.  The leaves are a hash of the serialized contents of the transaction.
        ;; The interior nodes are hashes of the concenation of the two child hashes.
        ;;
        ;; This structure allows the creation of proof that a transaction was included into a block without having to
        ;; provide the full block contents.  Instead, you can provide only a Merkle branch.  For example to prove tx2 was
        ;; in a block you can just provide tx2, the hash(tx1) and B.  Now the other party has everything they need to
        ;; derive the root, which can be checked against the block header.  These proofs aren't used right now but
        ;; will be helpful later when we want to download partial block contents.
        ;;
        ;; Note that if the number of transactions is not even, the last tx is repeated to make it so (see tx3 above).
        ;; A tree with 5 transactions would look like this:
        ;;
        ;;          root
        ;;        /      \
        ;;      1          5
        ;;    /   \       / \
        ;;   2     3     4   4
        ;;  / \   / \   / \
        ;; t1 t2 t3 t4 t5 t5
        (§ var #_"ArrayList<byte[]>" (§ name tree) (§ new #_"ArrayList<>" (§ pars )))
        ;; Start by adding all the hashes of the transactions as leaves of the tree.
        (§ for (§ var #_"Transaction" (§ name t)) :for transactions)
        (§ block
            (§ expr tree.add(§ pars t.getHash(§ pars ).getBytes(§ pars )))
        )

        ;; Offset in the list where the currently processed level starts.
        (§ var #_"int" (§ name levelOffset) 0)
        ;; Step through each level, stopping when we reach the root (levelSize == 1).
        (§ for (§ var #_"int" (§ name levelSize) (§ expr transactions.size(§ pars ))) :for (§ expr 1 < levelSize) :for (§ ass (§ name levelSize) (§ expr (§ expr levelSize + 1) / 2)))
        (§ block
            ;; For each pair of nodes on that level:
            (§ for (§ var #_"int" (§ name left) 0) :for (§ expr left < levelSize) :for (§ ass (§ name left) (§ expr left + 2)))
            (§ block
                ;; The right hand node can be the same as the left hand, in the case where we don't have enough transactions.
                (§ var #_"int" (§ name right) (§ expr Math/min(§ pars left + 1, levelSize - 1)))
                (§ var #_"byte[]" (§ name leftBytes) (§ expr Utils/reverseBytes(§ pars tree.get(§ pars levelOffset + left))))
                (§ var #_"byte[]" (§ name rightBytes) (§ expr Utils/reverseBytes(§ pars tree.get(§ pars levelOffset + right))))
                (§ expr tree.add(§ pars Utils/reverseBytes(§ pars hashTwice(§ pars leftBytes, 0, 32, rightBytes, 0, 32))))
            )
            ;; Move to the next level.
            (§ ass (§ name levelOffset) (§ expr levelOffset + levelSize))
        )
        (§ return tree)
    )

    ;;;
     ; Verify the transactions on a block.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;               If provided, used to validate the coinbase input script of v2 and above blocks.
     ; @throws VerificationException if there was an error verifying the block.
     ;;
    #_private
    (§ method #_"void" (§ fn checkTransactions) [#_final #_"int" (§ name height), #_final #_"EnumSet<VerifyFlag>" (§ name flags)])
        (§ throws #_"VerificationException")
    (§ block
        ;; The first transaction in a block must always be a coinbase transaction.
        (§ if (§ not (§ dot transactions.get(§ pars 0).isCoinBase(§ pars ))))
        (§ block
            (§ throw (§ new #_"VerificationException" (§ pars "First tx is not coinbase")))
        )

        (§ if (§ expr flags.contains(§ pars Block/VerifyFlag/HEIGHT_IN_COINBASE) && BLOCK_HEIGHT_GENESIS <= height))
        (§ block
            (§ expr transactions.get(§ pars 0).checkCoinBaseHeight(§ pars height))
        )

        ;; The rest must not be.
        (§ for (§ var #_"int" (§ name i) 1) :for (§ expr i < transactions.size(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ if (§ expr transactions.get(§ pars i).isCoinBase(§ pars )))
            (§ block
                (§ throw (§ new #_"VerificationException" (§ pars "TX " + i + " is coinbase when it should not be.")))
            )
        )
        (§ void nil)
    )

    ;;;
     ; Checks the block data to ensure it follows the rules laid out in the network parameters.  Specifically,
     ; throws an exception if the proof of work is invalid, or if the timestamp is too far from what it should be.
     ; This is <b>not</b> everything that is required for a block to be valid, only what is checkable independent
     ; of the chain and without a transaction index.
     ;
     ; @throws VerificationException
     ;;
    #_public
    (§ method #_"void" (§ fn verifyHeader) [])
        (§ throws #_"VerificationException")
    (§ block
        ;; Prove that this block is OK.  It might seem that we can just ignore most of these checks given that the
        ;; network is also verifying the blocks, but we cannot as it'd open us to a variety of obscure attacks.
        ;;
        ;; Firstly we need to ensure this block does in fact represent real work done.  If the difficulty is high
        ;; enough, it's probably been done by the network.
        (§ expr checkProofOfWork(§ pars true))
        (§ expr checkTimestamp(§ pars ))
        (§ void nil)
    )

    ;;;
     ; Checks the block contents.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;               If valid, used to validate the coinbase input script of v2 and above blocks.
     ; @param flags Flags to indicate which tests should be applied (i.e. whether to test for height in the coinbase transaction).
     ; @throws VerificationException if there was an error verifying the block.
     ;;
    #_public
    (§ method #_"void" (§ fn verifyTransactions) [#_final #_"int" (§ name height), #_final #_"EnumSet<VerifyFlag>" (§ name flags)])
        (§ throws #_"VerificationException")
    (§ block
        ;; Now we need to check that the body of the block actually matches the headers.  The network won't generate
        ;; an invalid block, but if we didn't validate this then an untrusted man-in-the-middle could obtain the next
        ;; valid block from the network and simply replace the transactions in it with their own fictional
        ;; transactions that reference spent or non-existant inputs.
        (§ if (§ expr transactions.isEmpty(§ pars )))
        (§ block
            (§ throw (§ new #_"VerificationException" (§ pars "Block had no transactions")))
        )
        (§ if (§ expr MAX_BLOCK_SIZE < this.getOptimalEncodingMessageSize(§ pars )))
        (§ block
            (§ throw (§ new #_"VerificationException" (§ pars "Block larger than MAX_BLOCK_SIZE")))
        )
        (§ expr checkTransactions(§ pars height, flags))
        (§ expr checkMerkleRoot(§ pars ))
        (§ expr checkSigOps(§ pars ))
        (§ for (§ var #_"Transaction" (§ name transaction)) :for transactions)
        (§ block
            (§ expr transaction.verify(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Verifies both the header and that the transactions hash to the merkle root.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ; @param flags Flags to indicate which tests should be applied (i.e. whether to test for height in the coinbase transaction).
     ; @throws VerificationException if there was an error verifying the block.
     ;;
    #_public
    (§ method #_"void" (§ fn verify) [#_final #_"int" (§ name height), #_final #_"EnumSet<VerifyFlag>" (§ name flags)])
        (§ throws #_"VerificationException")
    (§ block
        (§ expr verifyHeader(§ pars ))
        (§ expr verifyTransactions(§ pars height, flags))
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return (§ expr getHash(§ pars ).equals(§ pars (§ expr (§ cast #_"Block" o)).getHash(§ pars ))))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr getHash(§ pars ).hashCode(§ pars )))
    )

    ;;;
     ; Returns the merkle root in big endian form, calculating it from transactions if necessary.
     ;;
    #_public
    (§ method #_"Sha256Hash" (§ fn getMerkleRoot) [])
    (§ block
        (§ if (§ expr merkleRoot == nil))
        (§ block
            ;; TODO: Check if this is really necessary.
            (§ expr unCacheHeader(§ pars ))
            (§ ass (§ name merkleRoot) (§ expr calculateMerkleRoot(§ pars )))
        )
        (§ return merkleRoot)
    )

    ;;; Exists only for unit testing. ;;
    (§ method #_"void" (§ fn setMerkleRoot) [#_"Sha256Hash" (§ name value)])
    (§ block
        (§ expr unCacheHeader(§ pars ))
        (§ ass (§ name merkleRoot) value)
        (§ ass (§ name hash) nil)
        (§ void nil)
    )

    ;;; Adds a transaction to this block.  The nonce and merkle root are invalid after this. ;;
    #_public
    (§ method #_"void" (§ fn addTransaction) [#_"Transaction" (§ name t)])
    (§ block
        (§ expr addTransaction(§ pars t, true))
        (§ void nil)
    )

    ;;; Adds a transaction to this block, with or without checking the sanity of doing so. ;;
    (§ method #_"void" (§ fn addTransaction) [#_"Transaction" (§ name t), #_"boolean" (§ name runSanityChecks)])
    (§ block
        (§ expr unCacheTransactions(§ pars ))
        (§ if (§ expr transactions == nil))
        (§ block
            (§ ass (§ name transactions) (§ new #_"ArrayList<>" (§ pars )))
        )
        (§ expr t.setParent(§ pars this))
        (§ if (§ expr runSanityChecks && transactions.size(§ pars ) == 0 && (§ not t.isCoinBase(§ pars ))))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars "Attempted to add a non-coinbase transaction as the first transaction: " + t)))
        )
        (§ if (§ expr runSanityChecks && 0 < transactions.size(§ pars ) && t.isCoinBase(§ pars )))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars "Attempted to add a coinbase transaction when there already is one: " + t)))
        )
        (§ expr transactions.add(§ pars t))
        (§ expr adjustLength(§ pars transactions.size(§ pars ), t.length))
        ;; Force a recalculation next time the values are needed.
        (§ ass (§ name merkleRoot) nil)
        (§ ass (§ name hash) nil)
        (§ void nil)
    )

    ;;;
     ; Returns the version of the block data structure as defined by the Bitcoin protocol.
     ;;
    #_public
    (§ method #_"long" (§ fn getVersion) [])
    (§ block
        (§ return version)
    )

    ;;;
     ; Returns the hash of the previous block in the chain, as defined by the block header.
     ;;
    #_public
    (§ method #_"Sha256Hash" (§ fn getPrevBlockHash) [])
    (§ block
        (§ return prevBlockHash)
    )

    (§ method #_"void" (§ fn setPrevBlockHash) [#_"Sha256Hash" (§ name prevBlockHash)])
    (§ block
        (§ expr unCacheHeader(§ pars ))
        (§ ass (§ name this.prevBlockHash) prevBlockHash)
        (§ ass (§ name this.hash) nil)
        (§ void nil)
    )

    ;;;
     ; Returns the time at which the block was solved and broadcast, according to the clock of the solving node.
     ; This is measured in seconds since the UNIX epoch (midnight Jan 1st 1970).
     ;;
    #_public
    (§ method #_"long" (§ fn getTimeSeconds) [])
    (§ block
        (§ return time)
    )

    ;;;
     ; Returns the time at which the block was solved and broadcast, according to the clock of the solving node.
     ;;
    #_public
    (§ method #_"Date" (§ fn getTime) [])
    (§ block
        (§ return (§ new #_"Date" (§ pars getTimeSeconds(§ pars ) * 1000)))
    )

    #_public
    (§ method #_"void" (§ fn setTime) [#_"long" (§ name time)])
    (§ block
        (§ expr unCacheHeader(§ pars ))
        (§ ass (§ name this.time) time)
        (§ ass (§ name this.hash) nil)
        (§ void nil)
    )

    ;;;
     ; Returns the difficulty of the proof of work that this block should meet encoded <b>in compact form</b>.
     ; The {@link BlockChain} verifies that this is not too easy by looking at the length of the chain when the block is added.
     ; To find the actual value the hash should be compared against, use {@link org.bitcoinj.core.Block#getDifficultyTargetAsInteger()}.
     ; Note that this is <b>not</b> the same as the difficulty value reported by the Bitcoin "getdifficulty" RPC that you may see on various block explorers.
     ; That number is the result of applying a formula to the underlying difficulty to normalize the minimum to 1.
     ; Calculating the difficulty that way is currently unsupported.
     ;;
    #_public
    (§ method #_"long" (§ fn getDifficultyTarget) [])
    (§ block
        (§ return difficultyTarget)
    )

    ;;; Sets the difficulty target in compact form. ;;
    #_public
    (§ method #_"void" (§ fn setDifficultyTarget) [#_"long" (§ name compactForm)])
    (§ block
        (§ expr unCacheHeader(§ pars ))
        (§ ass (§ name this.difficultyTarget) compactForm)
        (§ ass (§ name this.hash) nil)
        (§ void nil)
    )

    ;;;
     ; Returns the nonce, an arbitrary value that exists only to make the hash of the block header fall below the difficulty target.
     ;;
    #_public
    (§ method #_"long" (§ fn getNonce) [])
    (§ block
        (§ return nonce)
    )

    ;;;
     ; Sets the nonce and clears any cached data.
     ;;
    #_public
    (§ method #_"void" (§ fn setNonce) [#_"long" (§ name nonce)])
    (§ block
        (§ expr unCacheHeader(§ pars ))
        (§ ass (§ name this.nonce) nonce)
        (§ ass (§ name this.hash) nil)
        (§ void nil)
    )

    ;;; Returns an immutable list of transactions held in this block, or null if this object represents just a header. ;;
    #_nilable
    #_public
    (§ method #_"List<Transaction>" (§ fn getTransactions) [])
    (§ block
        (§ return (§ quest (§ expr transactions == nil) ? nil :else (§ expr ImmutableList/copyOf(§ pars transactions))))
    )

    ;; Used to make transactions unique.
    #_private
    #_static
    (§ field #_"int" (§ name txCounter))

    ;;; Adds a coinbase transaction to the block.  This exists for unit tests.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;;
    #_testing
    (§ method #_"void" (§ fn addCoinbaseTransaction) [#_"byte[]" (§ name pubKeyTo), #_"Coin" (§ name value), #_final #_"int" (§ name height)])
    (§ block
        (§ expr unCacheTransactions(§ pars ))
        (§ ass (§ name transactions) (§ new #_"ArrayList<>" (§ pars )))
        (§ var #_"Transaction" (§ name coinbase) (§ new #_"Transaction" (§ pars params)))
        #_final
        (§ var #_"ScriptBuilder" (§ name inputBuilder) (§ new #_"ScriptBuilder" (§ pars )))

        (§ if (§ expr Block/BLOCK_HEIGHT_GENESIS <= height))
        (§ block
            (§ expr inputBuilder.number(§ pars height))
        )
        (§ expr inputBuilder.data(§ pars (§ new #_"byte[]" (§ coll (§ cast #_"byte" txCounter), (§ cast #_"byte" (§ expr txCounter >> 8)) ))))
        (§ ass (§ name txCounter) (§ expr txCounter + 1))

        ;; A real coinbase transaction has some stuff in the scriptSig like the extraNonce and difficulty.
        ;; The transactions are distinguished by every TX output going to a different key.
        ;;
        ;; Here we will do things a bit differently so a new address isn't needed every time.
        ;; We'll put a simple counter in the scriptSig, so every transaction has a different hash.
        (§ expr coinbase.addInput(§ pars (§ new #_"TransactionInput" (§ pars params, coinbase, inputBuilder.build(§ pars ).getProgram(§ pars )))))
        (§ expr coinbase.addOutput(§ pars (§ new #_"TransactionOutput" (§ pars params, coinbase, value, ScriptBuilder/createOutputScript(§ pars ECKey/fromPublicOnly(§ pars pubKeyTo)).getProgram(§ pars )))))
        (§ expr transactions.add(§ pars coinbase))
        (§ expr coinbase.setParent(§ pars this))
        (§ ass (§ name coinbase.length) (§ expr coinbase.unsafeBitcoinSerialize(§ pars ).length))
        (§ expr adjustLength(§ pars transactions.size(§ pars ), coinbase.length))
        (§ void nil)
    )

    #_static
    #_final
    (§ field #_"byte[]" (§ name EMPTY_BYTES) (§ new #_"byte[]" (§ count 32)))

    ;; It's pretty weak to have this around at runtime: fix later.
    #_private
    #_static
    #_final
    (§ field #_"byte[]" (§ name pubkeyForTesting) (§ expr (§ new #_"ECKey" (§ pars )).getPubKey(§ pars )))

    ;;;
     ; Returns a solved block that builds on top of this one.  This exists for unit tests.
     ;;
    #_testing
    #_public
    (§ method #_"Block" (§ fn createNextBlock) [#_"Address" (§ name to), #_"long" (§ name version), #_"long" (§ name time), #_"int" (§ name blockHeight)])
    (§ block
        (§ return (§ expr createNextBlock(§ pars to, version, nil, time, pubkeyForTesting, FIFTY_COINS, blockHeight)))
    )

    ;;;
     ; Returns a solved block that builds on top of this one.  This exists for unit tests.
     ; In this variant you can specify a public key (pubkey) for use in generating coinbase blocks.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;;
    (§ method #_"Block" (§ fn createNextBlock) [#_nilable #_final #_"Address" (§ name to), #_final #_"long" (§ name version), #_nilable #_"TransactionOutPoint" (§ name prevOut), #_final #_"long" (§ name time), #_final #_"byte[]" (§ name pubKey), #_final #_"Coin" (§ name coinbaseValue), #_final #_"int" (§ name height)])
    (§ block
        (§ var #_"Block" (§ name b) (§ new #_"Block" (§ pars params, version)))
        (§ expr b.setDifficultyTarget(§ pars difficultyTarget))
        (§ expr b.addCoinbaseTransaction(§ pars pubKey, coinbaseValue, height))

        (§ if (§ expr to != nil))
        (§ block
            ;; Add a transaction paying 50 coins to the "to" address.
            (§ var #_"Transaction" (§ name t) (§ new #_"Transaction" (§ pars params)))
            (§ expr t.addOutput(§ pars (§ new #_"TransactionOutput" (§ pars params, t, FIFTY_COINS, to))))
            ;; The input does not really need to be a valid signature, as long as it has the right general form.
            (§ var #_"TransactionInput" (§ name input))
            (§ if (§ expr prevOut == nil))
            (§ block
                (§ ass (§ name input) (§ new #_"TransactionInput" (§ pars params, t, Script/createInputScript(§ pars EMPTY_BYTES, EMPTY_BYTES))))
                ;; Importantly, the outpoint hash cannot be zero as that's how we detect a coinbase transaction in isolation,
                ;; but it must be unique to avoid 'different' transactions looking the same.
                (§ var #_"byte[]" (§ name counter) (§ new #_"byte[]" (§ count 32)))
                (§ ass (§ name counter[0]) (§ cast #_"byte" txCounter))
                (§ ass (§ name counter[1]) (§ cast #_"byte" (§ expr txCounter >> 8)))
                (§ ass (§ name txCounter) (§ expr txCounter + 1))
                (§ expr input.getOutpoint(§ pars ).setHash(§ pars Sha256Hash/wrap(§ pars counter)))
            )
            (§ else )
            (§ block
                (§ ass (§ name input) (§ new #_"TransactionInput" (§ pars params, t, Script/createInputScript(§ pars EMPTY_BYTES, EMPTY_BYTES), prevOut)))
            )
            (§ expr t.addInput(§ pars input))
            (§ expr b.addTransaction(§ pars t))
        )

        (§ expr b.setPrevBlockHash(§ pars getHash(§ pars )))
        ;; Don't let timestamp go backwards.
        (§ if (§ expr time <= getTimeSeconds(§ pars )))
        (§ block
            (§ expr b.setTime(§ pars getTimeSeconds(§ pars ) + 1))
        )
        (§ else )
        (§ block
            (§ expr b.setTime(§ pars time))
        )
        (§ expr b.solve(§ pars ))
        (§ try )
        (§ block
            (§ expr b.verifyHeader(§ pars ))
        )
        (§ catch #_"VerificationException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
        (§ if (§ expr b.getVersion(§ pars ) != version))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars )))
        )
        (§ return b)
    )

    #_testing
    #_public
    (§ method #_"Block" (§ fn createNextBlock) [#_nilable #_"Address" (§ name to), #_"TransactionOutPoint" (§ name prevOut)])
    (§ block
        (§ return (§ expr createNextBlock(§ pars to, BLOCK_VERSION_GENESIS, prevOut, getTimeSeconds(§ pars ) + 5, pubkeyForTesting, FIFTY_COINS, BLOCK_HEIGHT_UNKNOWN)))
    )

    #_testing
    #_public
    (§ method #_"Block" (§ fn createNextBlock) [#_nilable #_"Address" (§ name to), #_"Coin" (§ name value)])
    (§ block
        (§ return (§ expr createNextBlock(§ pars to, BLOCK_VERSION_GENESIS, nil, getTimeSeconds(§ pars ) + 5, pubkeyForTesting, value, BLOCK_HEIGHT_UNKNOWN)))
    )

    #_testing
    #_public
    (§ method #_"Block" (§ fn createNextBlock) [#_nilable #_"Address" (§ name to)])
    (§ block
        (§ return (§ expr createNextBlock(§ pars to, FIFTY_COINS)))
    )

    #_testing
    #_public
    (§ method #_"Block" (§ fn createNextBlockWithCoinbase) [#_"long" (§ name version), #_"byte[]" (§ name pubKey), #_"Coin" (§ name coinbaseValue), #_final #_"int" (§ name height)])
    (§ block
        (§ return (§ expr createNextBlock(§ pars nil, version, (§ cast #_"TransactionOutPoint" nil), Utils/currentTimeSeconds(§ pars ), pubKey, coinbaseValue, height)))
    )

    ;;;
     ; Create a block sending 50BTC as a coinbase transaction to the public key specified.
     ; This method is intended for test use only.
     ;;
    #_testing
    (§ method #_"Block" (§ fn createNextBlockWithCoinbase) [#_"long" (§ name version), #_"byte[]" (§ name pubKey), #_final #_"int" (§ name height)])
    (§ block
        (§ return (§ expr createNextBlock(§ pars nil, version, (§ cast #_"TransactionOutPoint" nil), Utils/currentTimeSeconds(§ pars ), pubKey, FIFTY_COINS, height)))
    )

    #_testing
    (§ method #_"boolean" (§ fn isHeaderBytesValid) [])
    (§ block
        (§ return headerBytesValid)
    )

    #_testing
    (§ method #_"boolean" (§ fn isTransactionBytesValid) [])
    (§ block
        (§ return transactionBytesValid)
    )

    ;;;
     ; Return whether this block contains any transactions.
     ;
     ; @return true if the block contains transactions, false otherwise (is purely a header).
     ;;
    #_public
    (§ method #_"boolean" (§ fn hasTransactions) [])
    (§ block
        (§ return (§ expr (§ not this.transactions.isEmpty(§ pars ))))
    )

    ;;;
     ; Returns whether this block conforms to
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki">BIP34: Height in Coinbase</a>.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isBIP34) [])
    (§ block
        (§ return (§ expr BLOCK_VERSION_BIP34 <= version))
    )

    ;;;
     ; Returns whether this block conforms to
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki">BIP66: Strict DER signatures</a>.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isBIP66) [])
    (§ block
        (§ return (§ expr BLOCK_VERSION_BIP66 <= version))
    )

    ;;;
     ; Returns whether this block conforms to
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki">BIP65: OP_CHECKLOCKTIMEVERIFY</a>.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isBIP65) [])
    (§ block
        (§ return (§ expr BLOCK_VERSION_BIP65 <= version))
    )
)

#_(ns org.bitcoinj.core #_"BlockChain"
    (:import [java.util ArrayList List])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.store BlockStore BlockStoreException]
             [org.bitcoinj.wallet Wallet]))

;; TODO: Rename this class to SPVBlockChain at some point.

;;;
 ; A BlockChain implements the <i>simplified payment verification</i> mode of the Bitcoin protocol.  It is the right
 ; choice to use for programs that have limited resources as it won't verify transactions signatures or attempt to store
 ; all of the block chain.  Really, this class should be called SPVBlockChain but for backwards compatibility it is not.
 ;;
#_public
(§ class #_"BlockChain" (§ extends #_"AbstractBlockChain")
    ;;; Keeps a map of block hashes to StoredBlocks. ;;
    #_protected
    #_final
    (§ field #_"BlockStore" (§ name blockStore))

    ;;;
     ; <p>Constructs a BlockChain connected to the given wallet and store.  To obtain a {@link Wallet} you can construct
     ; one from scratch, or you can deserialize a saved wallet from disk using {@link Wallet#loadFromFile(java.io.File)}.</p>
     ;
     ; <p>For the store, you should use {@link org.bitcoinj.store.SPVBlockStore} or you could also try a
     ; {@link org.bitcoinj.store.MemoryBlockStore} if you want to hold all headers in RAM and don't care about
     ; disk serialization (this is rare).</p>
     ;;
    #_public
    (§ constructor #_"BlockChain" [#_"Context" (§ name context), #_"Wallet" (§ name wallet), #_"BlockStore" (§ name blockStore)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ this (§ pars context, new ArrayList<Wallet>(§ pars ), blockStore))
        (§ expr addWallet(§ pars wallet))
        (§ void this)
    )

    ;;; See {@link #BlockChain(Context, Wallet, BlockStore)}}. ;;
    #_public
    (§ constructor #_"BlockChain" [#_"NetworkParameters" (§ name params), #_"Wallet" (§ name wallet), #_"BlockStore" (§ name blockStore)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ this (§ pars Context/getOrCreate(§ pars params), wallet, blockStore))
        (§ void this)
    )

    ;;;
     ; Constructs a BlockChain that has no wallet at all.  This is helpful when you don't actually care about sending
     ; and receiving coins but rather, just want to explore the network data structures.
     ;;
    #_public
    (§ constructor #_"BlockChain" [#_"Context" (§ name context), #_"BlockStore" (§ name blockStore)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ this (§ pars context, new ArrayList<Wallet>(§ pars ), blockStore))
        (§ void this)
    )

    ;;; See {@link #BlockChain(Context, BlockStore)}. ;;
    #_public
    (§ constructor #_"BlockChain" [#_"NetworkParameters" (§ name params), #_"BlockStore" (§ name blockStore)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ this (§ pars params, new ArrayList<Wallet>(§ pars ), blockStore))
        (§ void this)
    )

    ;;;
     ; Constructs a BlockChain connected to the given list of listeners and a store.
     ;;
    #_public
    (§ constructor #_"BlockChain" [#_"Context" (§ name params), #_"List<? extends Wallet>" (§ name wallets), #_"BlockStore" (§ name blockStore)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ super (§ pars params, wallets, blockStore))
        (§ ass (§ name this.blockStore) blockStore)
        (§ void this)
    )

    ;;; See {@link #BlockChain(Context, List, BlockStore)}. ;;
    #_public
    (§ constructor #_"BlockChain" [#_"NetworkParameters" (§ name params), #_"List<? extends Wallet>" (§ name wallets), #_"BlockStore" (§ name blockStore)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ this (§ pars Context/getOrCreate(§ pars params), wallets, blockStore))
        (§ void this)
    )

    #_override
    #_protected
    (§ method #_"StoredBlock" (§ fn addToBlockStore) [#_"StoredBlock" (§ name storedPrev), #_"Block" (§ name blockHeader), #_"TransactionOutputChanges" (§ name txOutChanges)])
        (§ throws #_"BlockStoreException", #_"VerificationException")
    (§ block
        (§ var #_"StoredBlock" (§ name newBlock) (§ expr storedPrev.build(§ pars blockHeader)))
        (§ expr blockStore.put(§ pars newBlock))
        (§ return newBlock)
    )

    #_override
    #_protected
    (§ method #_"StoredBlock" (§ fn addToBlockStore) [#_"StoredBlock" (§ name storedPrev), #_"Block" (§ name blockHeader)])
        (§ throws #_"BlockStoreException", #_"VerificationException")
    (§ block
        (§ var #_"StoredBlock" (§ name newBlock) (§ expr storedPrev.build(§ pars blockHeader)))
        (§ expr blockStore.put(§ pars newBlock))
        (§ return newBlock)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn rollbackBlockStore) [#_"int" (§ name height)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"int" (§ name currentHeight) (§ expr getBestChainHeight(§ pars )))
            (§ expr Preconditions/checkArgument(§ pars 0 <= height && height <= currentHeight, "Bad height: %s", height))
            (§ if (§ expr height == currentHeight))
            (§ block
                (§ return nil) ;; nothing to do
            )

            ;; Look for the block we want to be the new chain head.
            (§ var #_"StoredBlock" (§ name newChainHead) (§ expr blockStore.getChainHead(§ pars )))
            (§ while (§ expr height < newChainHead.getHeight(§ pars )))
            (§ block
                (§ ass (§ name newChainHead) (§ expr newChainHead.getPrev(§ pars blockStore)))
                (§ if (§ expr newChainHead == nil))
                (§ block
                    (§ throw (§ new #_"BlockStoreException" (§ pars "Unreachable height")))
                )
            )

            ;; Modify store directly.
            (§ expr blockStore.put(§ pars newChainHead))
            (§ expr this.setChainHead(§ pars newChainHead))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"boolean" (§ fn shouldVerifyTransactions) [])
    (§ block
        (§ return false)
    )

    #_override
    #_protected
    (§ method #_"TransactionOutputChanges" (§ fn connectTransactions) [#_"int" (§ name height), #_"Block" (§ name block)])
    (§ block
        ;; Don't have to do anything as this is only called if shouldVerifyTransactions().
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars )))
    )

    #_override
    #_protected
    (§ method #_"TransactionOutputChanges" (§ fn connectTransactions) [#_"StoredBlock" (§ name newBlock)])
    (§ block
        ;; Don't have to do anything as this is only called if shouldVerifyTransactions().
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars )))
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn disconnectTransactions) [#_"StoredBlock" (§ name block)])
    (§ block
        ;; Don't have to do anything as this is only called if shouldVerifyTransactions().
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars )))
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn doSetChainHead) [#_"StoredBlock" (§ name chainHead)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr blockStore.setChainHead(§ pars chainHead))
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn notSettingChainHead) [])
        (§ throws #_"BlockStoreException")
    (§ block
        ;; We don't use DB transactions here, so we don't need to do anything.
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"StoredBlock" (§ fn getStoredBlockInCurrentScope) [#_"Sha256Hash" (§ name hash)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ return (§ expr blockStore.get(§ pars hash)))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn add) [#_"FilteredBlock" (§ name block)])
        (§ throws #_"VerificationException", #_"PrunedException")
    (§ block
        (§ var #_"boolean" (§ name success) (§ expr super.add(§ pars block)))
        (§ if success)
        (§ block
            (§ expr trackFilteredTransactions(§ pars block.getTransactionCount(§ pars )))
        )
        (§ return success)
    )
)

#_(ns org.bitcoinj.core #_"BloomFilter"
    (:import [java.io IOException OutputStream]
             #_static [java.lang.Math *]
             [java.util ArrayList Arrays List])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.collect Lists])
   (:require [org.bitcoinj.script Script ScriptChunk]))

;;;
 ; <p>A Bloom filter is a probabilistic data structure which can be sent to another client so that it can avoid
 ; sending us transactions that aren't relevant to our set of keys.  This allows for significantly more efficient
 ; use of available network bandwidth and CPU time.</p>
 ;
 ; <p>Because a Bloom filter is probabilistic, it has a configurable false positive rate.  So the filter will sometimes
 ; match transactions that weren't inserted into it, but it will never fail to match transactions that were.  This is
 ; a useful privacy feature - if you have spare bandwidth the false positive rate can be increased so the remote peer
 ; gets a noisy picture of what transactions are relevant to your wallet.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"BloomFilter" (§ extends #_"Message")
    ;;;
     ; The BLOOM_UPDATE_* constants control when the bloom filter is auto-updated by the peer using
     ; it as a filter, either never, for all outputs or only for pay-2-pubkey outputs (default).
     ;;
    #_public
    (§ enum #_"BloomUpdate"
        (§ item UPDATE_NONE) ;; 0
        (§ item UPDATE_ALL) ;; 1
        ;;; Only adds outpoints to the filter if the output is a pay-to-pubkey/pay-to-multisig script. ;;
        (§ item UPDATE_P2PUBKEY_ONLY) ;; 2
    )

    #_private
    (§ field #_"byte[]" (§ name data))
    #_private
    (§ field #_"long" (§ name hashFuncs))
    #_private
    (§ field #_"long" (§ name nTweak))
    #_private
    (§ field #_"byte" (§ name nFlags))

    ;; Same value as of Bitcoin Core.
    ;; A filter of 20,000 items and a false positive rate of 0.1% or one of 10,000 items and 0.0001% is just under 36,000 bytes.
    #_private
    #_static
    #_final
    (§ field #_"long" (§ name MAX_FILTER_SIZE) 36000)
    ;; There is little reason to ever have more hash functions than 50 given a limit of 36,000 bytes.
    #_private
    #_static
    #_final
    (§ field #_"int" (§ name MAX_HASH_FUNCS) 50)

    ;;;
     ; Construct a BloomFilter by deserializing payloadBytes.
     ;;
    #_public
    (§ constructor #_"BloomFilter" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payloadBytes)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payloadBytes, 0))
        (§ void this)
    )

    ;;;
     ; Constructs a filter with the given parameters which is updated on pay2pubkey outputs only.
     ;;
    #_public
    (§ constructor #_"BloomFilter" [#_"int" (§ name elements), #_"double" (§ name falsePositiveRate), #_"long" (§ name randomNonce)])
    (§ block
        (§ this (§ pars elements, falsePositiveRate, randomNonce, BloomUpdate/UPDATE_P2PUBKEY_ONLY))
        (§ void this)
    )

    ;;;
     ; <p>Constructs a new Bloom Filter which will provide approximately the given false positive rate when the given
     ; number of elements have been inserted.  If the filter would otherwise be larger than the maximum allowed size,
     ; it will be automatically downsized to the maximum size.</p>
     ;
     ; <p>To check the theoretical false positive rate of a given filter, use {@link BloomFilter#getFalsePositiveRate(int)}.</p>
     ;
     ; <p>The anonymity of which coins are yours to any peer which you send a BloomFilter to is controlled by the
     ; false positive rate.  For reference, as of block 187,000, the total number of addresses used in the chain was
     ; roughly 4.5 million.  Thus, if you use a false positive rate of 0.001 (0.1%), there will be, on average, 4,500
     ; distinct public keys/addresses which will be thought to be yours by nodes which have your bloom filter, but
     ; which are not actually yours.  Keep in mind that a remote node can do a pretty good job estimating the order of
     ; magnitude of the false positive rate of a given filter you provide it when considering the anonymity of a given
     ; filter.</p>
     ;
     ; <p>In order for filtered block download to function efficiently, the number of matched transactions in any given
     ; block should be less than (with some headroom) the maximum size of the MemoryPool used by the Peer
     ; doing the downloading (default is {@link TxConfidenceTable#MAX_SIZE}).  See the comment in processBlock(FilteredBlock)
     ; for more information on this restriction.</p>
     ;
     ; <p>randomNonce is a tweak for the hash function used to prevent some theoretical DoS attacks.
     ; It should be a random value, however secureness of the random value is of no great consequence.</p>
     ;
     ; <p>updateFlag is used to control filter behaviour on the server (remote node) side when it encounters a hit.
     ; See {@link org.bitcoinj.core.BloomFilter.BloomUpdate} for a brief description of each mode.  The purpose
     ; of this flag is to reduce network round-tripping and avoid over-dirtying the filter for the most common
     ; wallet configurations.</p>
     ;;
    #_public
    (§ constructor #_"BloomFilter" [#_"int" (§ name elements), #_"double" (§ name falsePositiveRate), #_"long" (§ name randomNonce), #_"BloomUpdate" (§ name updateFlag)])
    (§ block
        ;; The following formulas were stolen from Wikipedia's page on Bloom Filters (with the addition of min(..., MAX_...)).
        ;; Size required for a given number of elements and false-positive rate.
        (§ var #_"int" (§ name size) (§ expr (§ cast #_"int" (§ expr -1 / pow(§ pars log(§ pars 2), 2) * elements * log(§ pars falsePositiveRate)))))
        (§ ass (§ name size) (§ expr max(§ pars 1, min(§ pars size, (§ cast #_"int" MAX_FILTER_SIZE) * 8) / 8)))
        (§ ass (§ name data) (§ new #_"byte[]" (§ count size)))
        ;; Optimal number of hash functions for a given filter size and element count.
        (§ ass (§ name hashFuncs) (§ cast #_"int" (§ expr data.length * 8 / (§ cast #_"double" elements) * log(§ pars 2))))
        (§ ass (§ name hashFuncs) (§ expr max(§ pars 1, min(§ pars hashFuncs, MAX_HASH_FUNCS))))
        (§ ass (§ name this.nTweak) randomNonce)
        (§ ass (§ name this.nFlags) (§ cast #_"byte" (§ expr 0xff & updateFlag.ordinal(§ pars ))))
        (§ void this)
    )

    ;;;
     ; Returns the theoretical false positive rate of this filter if were to contain the given number of elements.
     ;;
    #_public
    (§ method #_"double" (§ fn getFalsePositiveRate) [#_"int" (§ name elements)])
    (§ block
        (§ return (§ expr pow(§ pars 1 - pow(§ pars E, -1.0 * (§ expr hashFuncs * elements) / (§ expr data.length * 8)), hashFuncs)))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr "Bloom Filter of size " + data.length + " with " + hashFuncs + " hash functions."))
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ ass (§ name data) (§ expr readByteArray(§ pars )))
        (§ if (§ expr MAX_FILTER_SIZE < data.length))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars "Bloom filter out of size range.")))
        )
        (§ ass (§ name hashFuncs) (§ expr readUint32(§ pars )))
        (§ if (§ expr MAX_HASH_FUNCS < hashFuncs))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars "Bloom filter hash function count out of range")))
        )
        (§ ass (§ name nTweak) (§ expr readUint32(§ pars )))
        (§ ass (§ name nFlags) (§ expr readBytes(§ pars 1)[0]))
        (§ ass (§ name length) (§ expr cursor - offset))
        (§ void nil)
    )

    ;;;
     ; Serializes this message to the provided stream.  If you just want the raw bytes use bitcoinSerialize().
     ;;
    #_override
    #_protected
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ expr stream.write(§ pars (§ new #_"VarInt" (§ pars data.length)).encode(§ pars )))
        (§ expr stream.write(§ pars data))
        (§ expr Utils/uint32ToByteStreamLE(§ pars hashFuncs, stream))
        (§ expr Utils/uint32ToByteStreamLE(§ pars nTweak, stream))
        (§ expr stream.write(§ pars nFlags))
        (§ void nil)
    )

    #_private
    #_static
    (§ method #_"int" (§ fn rotateLeft32) [#_"int" (§ name x), #_"int" (§ name r)])
    (§ block
        (§ return (§ expr (§ expr x << r) | (§ expr x >>> (§ expr 32 - r))))
    )

    ;;;
     ; Applies the MurmurHash3 (x86_32) algorithm to the given data.
     ; See <a href="https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp">this C++ code</a> for the original.
     ;;
    #_public
    #_static
    (§ method #_"int" (§ fn murmurHash3) [#_"byte[]" (§ name data), #_"long" (§ name nTweak), #_"int" (§ name hashNum), #_"byte[]" (§ name object)])
    (§ block
        (§ var #_"int" (§ name h1) (§ expr (§ cast #_"int" (§ expr hashNum * 0xfba4c795 + nTweak))))
        #_final
        (§ var #_"int" (§ name c1) (§ expr 0xcc9e2d51))
        #_final
        (§ var #_"int" (§ name c2) (§ expr 0x1b873593))

        (§ var #_"int" (§ name numBlocks) (§ expr (§ expr object.length / 4) * 4))

        ;; body
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numBlocks) :for (§ ass (§ name i) (§ expr i + 4)))
        (§ block
            (§ var #_"int" (§ name k1) (§ expr (§ expr object[i] & 0xff) | (§ expr (§ expr object[i + 1] & 0xff) << 8) | (§ expr (§ expr object[i + 2] & 0xff) << 16) | (§ expr (§ expr object[i + 3] & 0xff) << 24)))

            (§ ass (§ name k1) (§ expr k1 * c1))
            (§ ass (§ name k1) (§ expr rotateLeft32(§ pars k1, 15)))
            (§ ass (§ name k1) (§ expr k1 * c2))

            (§ ass (§ name h1) (§ expr h1 :xor k1))
            (§ ass (§ name h1) (§ expr rotateLeft32(§ pars h1, 13)))
            (§ ass (§ name h1) (§ expr h1 * 5 + 0xe6546b64))
        )

        (§ var #_"int" (§ name k1) 0)
        (§ switch (§ expr object.length & 3))
        (§ block
            (§ case 3)
            (§ block
                (§ ass (§ name k1) (§ expr k1 :xor (§ expr (§ expr object[numBlocks + 2] & 0xff) << 16)))
                ;; Fall through.
            )
            (§ case 2)
            (§ block
                (§ ass (§ name k1) (§ expr k1 :xor (§ expr (§ expr object[numBlocks + 1] & 0xff) << 8)))
                ;; Fall through.
            )
            (§ case 1)
            (§ block
                (§ ass (§ name k1) (§ expr k1 :xor (§ expr object[numBlocks] & 0xff)))
                (§ ass (§ name k1) (§ expr k1 * c1))
                (§ ass (§ name k1) (§ expr rotateLeft32(§ pars k1, 15)))
                (§ ass (§ name k1) (§ expr k1 * c2))
                (§ ass (§ name h1) (§ expr h1 :xor k1))
                ;; Fall through.
            )
            (§ default )
            (§ block
                ;; Do nothing.
                (§ break )
            )
        )

        ;; finalization
        (§ ass (§ name h1) (§ expr h1 :xor object.length))
        (§ ass (§ name h1) (§ expr h1 :xor (§ expr h1 >>> 16)))
        (§ ass (§ name h1) (§ expr h1 * 0x85ebca6b))
        (§ ass (§ name h1) (§ expr h1 :xor (§ expr h1 >>> 13)))
        (§ ass (§ name h1) (§ expr h1 * 0xc2b2ae35))
        (§ ass (§ name h1) (§ expr h1 :xor (§ expr h1 >>> 16)))

        (§ return (§ cast #_"int" (§ expr (§ expr h1 & 0xffffffff) % (§ expr data.length * 8))))
    )

    ;;;
     ; Returns true if the given object matches the filter either because it was inserted, or because we have a false-positive.
     ;;
    #_public
    #_synchronized
    (§ method #_"boolean" (§ fn contains) [#_"byte[]" (§ name object)])
    (§ block
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < hashFuncs) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ if (§ expr (§ not Utils/checkBitLE(§ pars data, murmurHash3(§ pars data, nTweak, i, object)))))
            (§ block
                (§ return false)
            )
        )

        (§ return true)
    )

    ;;; Insert the given arbitrary data into the filter. ;;
    #_public
    #_synchronized
    (§ method #_"void" (§ fn insert) [#_"byte[]" (§ name object)])
    (§ block
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < hashFuncs) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ expr Utils/setBitLE(§ pars data, murmurHash3(§ pars data, nTweak, i, object)))
        )
        (§ void nil)
    )

    ;;; Inserts the given key and equivalent hashed form (for the address). ;;
    #_public
    #_synchronized
    (§ method #_"void" (§ fn insert) [#_"ECKey" (§ name key)])
    (§ block
        (§ expr insert(§ pars key.getPubKey(§ pars )))
        (§ expr insert(§ pars key.getPubKeyHash(§ pars )))
        (§ void nil)
    )

    ;;;
     ; Sets this filter to match all objects.  A Bloom filter which matches everything may seem pointless, however,
     ; it is useful in order to reduce steady state bandwidth usage when you want full blocks.  Instead of receiving
     ; all transaction data twice, you will receive the vast majority of all transactions just once, at broadcast time.
     ; Solved blocks will then be send just as Merkle trees of tx hashes, meaning a constant 32 bytes of data for each
     ; transaction instead of 100-300 bytes as per usual.
     ;;
    #_public
    #_synchronized
    (§ method #_"void" (§ fn setMatchAll) [])
    (§ block
        (§ ass (§ name data) (§ new #_"byte[]" (§ coll (§ cast #_"byte" 0xff) )))
        (§ void nil)
    )

    ;;;
     ; Copies filter into this.  Filter must have the same size, hash function count and nTweak or an
     ; IllegalArgumentException will be thrown.
     ;;
    #_public
    #_synchronized
    (§ method #_"void" (§ fn merge) [#_"BloomFilter" (§ name filter)])
    (§ block
        (§ if (§ expr (§ not this.matchesAll(§ pars )) && (§ not filter.matchesAll(§ pars ))))
        (§ block
            (§ expr Preconditions/checkArgument(§ pars filter.data.length == this.data.length && filter.hashFuncs == this.hashFuncs && filter.nTweak == this.nTweak))

            (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < data.length) :for (§ ass (§ name i) (§ expr i + 1)))
            (§ block
                (§ ass (§ name this.data[i]) (§ expr this.data[i] | filter.data[i]))
            )
        )
        (§ else )
        (§ block
            (§ ass (§ name this.data) (§ new #_"byte[]" (§ coll (§ cast #_"byte" 0xff) )))
        )
        (§ void nil)
    )

    ;;;
     ; Returns true if this filter will match anything.  See {@link org.bitcoinj.core.BloomFilter#setMatchAll()}
     ; for when this can be a useful thing to do.
     ;;
    #_public
    #_synchronized
    (§ method #_"boolean" (§ fn matchesAll) [])
    (§ block
        (§ for (§ var #_"byte" (§ name b)) :for data)
        (§ block
            (§ if (§ expr b != (§ cast #_"byte" 0xff)))
            (§ block
                (§ return false)
            )
        )
        (§ return true)
    )

    ;;;
     ; The update flag controls how application of the filter to a block modifies the filter.  See the enum javadocs
     ; for information on what occurs and when.
     ;;
    #_public
    #_synchronized
    (§ method #_"BloomUpdate" (§ fn getUpdateFlag) [])
    (§ block
        (§ if (§ expr nFlags == 0))
        (§ block
            (§ return (§ expr BloomUpdate/UPDATE_NONE))
        )
        (§ if (§ expr nFlags == 1))
        (§ block
            (§ return (§ expr BloomUpdate/UPDATE_ALL))
        )
        (§ if (§ expr nFlags == 2))
        (§ block
            (§ return (§ expr BloomUpdate/UPDATE_P2PUBKEY_ONLY))
        )

        (§ throw (§ new #_"IllegalStateException" (§ pars "Unknown flag combination")))
    )

    ;;;
     ; Creates a new FilteredBlock from the given Block, using this filter to select transactions.  Matches can cause the
     ; filter to be updated with the matched element, this ensures that when a filter is applied to a block, spends of
     ; matched transactions are also matched.  However it means this filter can be mutated by the operation.  The returned
     ; filtered block already has the matched transactions associated with it.
     ;;
    #_public
    #_synchronized
    (§ method #_"FilteredBlock" (§ fn applyAndUpdate) [#_"Block" (§ name block)])
    (§ block
        (§ var #_"List<Transaction>" (§ name txns) (§ expr block.getTransactions(§ pars )))
        (§ var #_"List<Sha256Hash>" (§ name txHashes) (§ new #_"ArrayList<>" (§ pars txns.size(§ pars ))))
        (§ var #_"List<Transaction>" (§ name matched) (§ expr Lists/newArrayList(§ pars )))
        (§ var #_"byte[]" (§ name bits) (§ new #_"byte[]" (§ count (§ cast #_"int" (§ expr Math/ceil(§ pars txns.size(§ pars ) / 8.0))))))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < txns.size(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ var #_"Transaction" (§ name tx) (§ expr txns.get(§ pars i)))
            (§ expr txHashes.add(§ pars tx.getHash(§ pars )))
            (§ if (§ expr applyAndUpdate(§ pars tx)))
            (§ block
                (§ expr Utils/setBitLE(§ pars bits, i))
                (§ expr matched.add(§ pars tx))
            )
        )
        (§ var #_"PartialMerkleTree" (§ name pmt) (§ expr PartialMerkleTree/buildFromLeaves(§ pars block.getParams(§ pars ), bits, txHashes)))
        (§ var #_"FilteredBlock" (§ name filteredBlock) (§ new #_"FilteredBlock" (§ pars block.getParams(§ pars ), block.cloneAsHeader(§ pars ), pmt)))
        (§ for (§ var #_"Transaction" (§ name transaction)) :for matched)
        (§ block
            (§ expr filteredBlock.provideTransaction(§ pars transaction))
        )
        (§ return filteredBlock)
    )

    #_public
    #_synchronized
    (§ method #_"boolean" (§ fn applyAndUpdate) [#_"Transaction" (§ name tx)])
    (§ block
        (§ if (§ expr contains(§ pars tx.getHash(§ pars ).getBytes(§ pars ))))
        (§ block
            (§ return true)
        )
        (§ var #_"boolean" (§ name found) false)
        (§ var #_"BloomUpdate" (§ name flag) (§ expr getUpdateFlag(§ pars )))
        (§ for (§ var #_"TransactionOutput" (§ name output)) :for (§ expr tx.getOutputs(§ pars )))
        (§ block
            (§ var #_"Script" (§ name script) (§ expr output.getScriptPubKey(§ pars )))
            (§ for (§ var #_"ScriptChunk" (§ name chunk)) :for (§ expr script.getChunks(§ pars )))
            (§ block
                (§ if (§ expr chunk.isPushData(§ pars ) && contains(§ pars chunk.data)))
                (§ block
                    (§ var #_"boolean" (§ name isSendingToPubKeys) (§ expr script.isSentToRawPubKey(§ pars ) || script.isSentToMultiSig(§ pars )))
                    (§ if (§ expr flag == BloomUpdate/UPDATE_ALL || (§ expr flag == BloomUpdate/UPDATE_P2PUBKEY_ONLY && isSendingToPubKeys)))
                    (§ block
                        (§ expr insert(§ pars output.getOutPointFor(§ pars ).unsafeBitcoinSerialize(§ pars )))
                    )
                    (§ ass (§ name found) true)
                )
            )
        )
        (§ if found)
        (§ block
            (§ return true)
        )
        (§ for (§ var #_"TransactionInput" (§ name input)) :for (§ expr tx.getInputs(§ pars )))
        (§ block
            (§ if (§ expr contains(§ pars input.getOutpoint(§ pars ).unsafeBitcoinSerialize(§ pars ))))
            (§ block
                (§ return true)
            )

            (§ for (§ var #_"ScriptChunk" (§ name chunk)) :for (§ expr input.getScriptSig(§ pars ).getChunks(§ pars )))
            (§ block
                (§ if (§ expr chunk.isPushData(§ pars ) && contains(§ pars chunk.data)))
                (§ block
                    (§ return true)
                )
            )
        )
        (§ return false)
    )

    #_override
    #_public
    #_synchronized
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"BloomFilter" (§ name other) (§ expr (§ cast #_"BloomFilter" o)))
        (§ return (§ expr hashFuncs == other.hashFuncs && nTweak == other.nTweak && Arrays/equals(§ pars data, other.data)))
    )

    #_override
    #_public
    #_synchronized
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars hashFuncs, nTweak, Arrays/hashCode(§ pars data))))
    )
)

#_(ns org.bitcoinj.core #_"CheckpointManager"
    (:import [java.io BufferedInputStream BufferedReader DataInputStream IOException InputStream InputStreamReader]
             [java.nio ByteBuffer ByteOrder]
             [java.security DigestInputStream MessageDigest]
             [java.util Arrays Map TreeMap])
    (:import [com.google.common.base Charsets Preconditions]
             [com.google.common.hash HashCode Hasher Hashing]
             [com.google.common.io BaseEncoding]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.store BlockStore BlockStoreException FullPrunedBlockStore]))

;;;
 ; <p>Vends hard-coded {@link StoredBlock}s for blocks throughout the chain.  Checkpoints serve two purposes:</p>
 ; <ol>
 ;    <li>They act as a safety mechanism against huge re-orgs that could rewrite large chunks of history, thus
 ;    constraining the block chain to be a consensus mechanism only for recent parts of the timeline.</li>
 ;    <li>They allow synchronization to the head of the chain for new wallets/users much faster than syncing all
 ;    headers from the genesis block.</li>
 ; </ol>
 ;
 ; <p>Checkpoints are used by the SPV {@link BlockChain} to initialize fresh {@link org.bitcoinj.store.SPVBlockStore}s.
 ; They are not used by fully validating mode, which instead has a different concept of checkpoints that are used
 ; to hard-code the validity of blocks that violate BIP30 (duplicate coinbase transactions).
 ; Those "checkpoints" can be found in NetworkParameters.</p>
 ;
 ; <p>The file format consists of the string "CHECKPOINTS 1", followed by a uint32 containing the number of signatures
 ; to read.  The value may not be larger than 256 (so it could have been a byte but isn't for historical reasons).
 ; If the number of signatures is larger than zero, each 65 byte ECDSA secp256k1 signature then follows.  The signatures
 ; sign the hash of all bytes that follow the last signature.</p>
 ;
 ; <p>After the signatures come an int32 containing the number of checkpoints in the file.  Then each checkpoint follows
 ; one after the other.  A checkpoint is 12 bytes for the total work done field, 4 bytes for the height, 80 bytes
 ; for the block header and then 1 zero byte at the end (i.e. number of transactions in the block: always zero).</p>
 ;;
#_public
(§ class #_"CheckpointManager"
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"CheckpointManager"))))

    #_private
    #_static
    #_final
    (§ field #_"String" (§ name BINARY_MAGIC) (§ expr "CHECKPOINTS 1"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name TEXTUAL_MAGIC) (§ expr "TXT CHECKPOINTS 1"))
    #_private
    #_static
    #_final
    (§ field #_"int" (§ name MAX_SIGNATURES) 256)

    ;; Map of block header time to data.
    #_protected
    #_final
    (§ field #_"TreeMap<Long, StoredBlock>" (§ name checkpoints) (§ new #_"TreeMap<>" (§ pars )))

    #_protected
    #_final
    (§ field #_"NetworkParameters" (§ name params))
    #_protected
    #_final
    (§ field #_"Sha256Hash" (§ name dataHash))

    #_public
    #_static
    #_final
    (§ field #_"BaseEncoding" (§ name BASE64) (§ expr BaseEncoding/base64(§ pars ).omitPadding(§ pars )))

    ;;; Loads the default checkpoints bundled with bitcoinj. ;;
    #_public
    (§ constructor #_"CheckpointManager" [#_"Context" (§ name context)])
        (§ throws #_"IOException")
    (§ block
        (§ this (§ pars context.getParams(§ pars ), nil))
        (§ void this)
    )

    ;;; Loads the checkpoints from the given stream. ;;
    #_public
    (§ constructor #_"CheckpointManager" [#_"NetworkParameters" (§ name params), #_nilable #_"InputStream" (§ name inputStream)])
        (§ throws #_"IOException")
    (§ block
        (§ ass (§ name this.params) (§ expr Preconditions/checkNotNull(§ pars params)))
        (§ if (§ expr inputStream == nil))
        (§ block
            (§ ass (§ name inputStream) (§ expr openStream(§ pars params)))
        )
        (§ expr Preconditions/checkNotNull(§ pars inputStream))
        (§ ass (§ name inputStream) (§ new #_"BufferedInputStream" (§ pars inputStream)))
        (§ expr inputStream.mark(§ pars 1))
        (§ var #_"int" (§ name first) (§ expr inputStream.read(§ pars )))
        (§ expr inputStream.reset(§ pars ))
        (§ if (§ expr first == BINARY_MAGIC.charAt(§ pars 0)))
        (§ block
            (§ ass (§ name dataHash) (§ expr readBinary(§ pars inputStream)))
        )
        (§ elseif (§ expr first == TEXTUAL_MAGIC.charAt(§ pars 0)))
        (§ block
            (§ ass (§ name dataHash) (§ expr readTextual(§ pars inputStream)))
        )
        (§ else )
        (§ block
            (§ throw (§ new #_"IOException" (§ pars "Unsupported format.")))
        )
        (§ void this)
    )

    ;;; Returns a checkpoints stream pointing to inside the bitcoinj JAR. ;;
    #_public
    #_static
    (§ method #_"InputStream" (§ fn openStream) [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ return (§ dot (§ klass #_"CheckpointManager").getResourceAsStream(§ pars "/" + params.getId(§ pars ) + ".checkpoints.txt")))
    )

    #_private
    (§ method #_"Sha256Hash" (§ fn readBinary) [#_"InputStream" (§ name inputStream)])
        (§ throws #_"IOException")
    (§ block
        (§ var #_"DataInputStream" (§ name dis) nil)
        (§ try )
        (§ block
            (§ var #_"MessageDigest" (§ name digest) (§ expr Sha256Hash/newDigest(§ pars )))
            (§ var #_"DigestInputStream" (§ name digestInputStream) (§ new #_"DigestInputStream" (§ pars inputStream, digest)))
            (§ ass (§ name dis) (§ new #_"DataInputStream" (§ pars digestInputStream)))
            (§ expr digestInputStream.on(§ pars false))
            (§ var #_"byte[]" (§ name header) (§ new #_"byte[]" (§ count BINARY_MAGIC.length(§ pars ))))
            (§ expr dis.readFully(§ pars header))
            (§ if (§ expr (§ not Arrays/equals(§ pars header, BINARY_MAGIC.getBytes(§ pars "US-ASCII")))))
            (§ block
                (§ throw (§ new #_"IOException" (§ pars "Header bytes did not match expected version")))
            )
            (§ var #_"int" (§ name numSignatures) (§ expr checkPositionIndex(§ pars dis.readInt(§ pars ), MAX_SIGNATURES, "Num signatures out of range")))
            (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numSignatures) :for (§ ass (§ name i) (§ expr i + 1)))
            (§ block
                (§ var #_"byte[]" (§ name sig) (§ new #_"byte[]" (§ count 65)))
                (§ expr dis.readFully(§ pars sig))
                ;; TODO: Do something with the signature here.
            )
            (§ expr digestInputStream.on(§ pars true))
            (§ var #_"int" (§ name numCheckpoints) (§ expr dis.readInt(§ pars )))
            (§ expr Preconditions/checkState(§ pars 0 < numCheckpoints))
            #_final
            (§ var #_"int" (§ name size) (§ expr StoredBlock/COMPACT_SERIALIZED_SIZE))
            (§ var #_"ByteBuffer" (§ name buffer) (§ expr ByteBuffer/allocate(§ pars size)))
            (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numCheckpoints) :for (§ ass (§ name i) (§ expr i + 1)))
            (§ block
                (§ if (§ expr dis.read(§ pars buffer.array(§ pars ), 0, size) < size))
                (§ block
                    (§ throw (§ new #_"IOException" (§ pars "Incomplete read whilst loading checkpoints.")))
                )
                (§ var #_"StoredBlock" (§ name block) (§ expr StoredBlock/deserializeCompact(§ pars params, buffer)))
                (§ expr buffer.position(§ pars 0))
                (§ expr checkpoints.put(§ pars block.getHeader(§ pars ).getTimeSeconds(§ pars ), block))
            )
            (§ var #_"Sha256Hash" (§ name dataHash) (§ expr Sha256Hash/wrap(§ pars digest.digest(§ pars ))))
            (§ expr log.info(§ pars "Read {} checkpoints, hash is {}", checkpoints.size(§ pars ), dataHash))
            (§ return dataHash)
        )
        (§ catch #_"ProtocolException" (§ name e))
        (§ block
            (§ throw (§ new #_"IOException" (§ pars e)))
        )
        (§ finally )
        (§ block
            (§ if (§ expr dis != nil))
            (§ block
                (§ expr dis.close(§ pars ))
            )
            (§ expr inputStream.close(§ pars ))
        )
    )

    #_private
    (§ method #_"Sha256Hash" (§ fn readTextual) [#_"InputStream" (§ name inputStream)])
        (§ throws #_"IOException")
    (§ block
        (§ var #_"Hasher" (§ name hasher) (§ expr Hashing/sha256(§ pars ).newHasher(§ pars )))
        (§ var #_"BufferedReader" (§ name reader) nil)
        (§ try )
        (§ block
            (§ ass (§ name reader) (§ new #_"BufferedReader" (§ pars (§ new #_"InputStreamReader" (§ pars inputStream, Charsets/US_ASCII)))))
            (§ var #_"String" (§ name magic) (§ expr reader.readLine(§ pars )))
            (§ if (§ expr (§ not TEXTUAL_MAGIC.equals(§ pars magic))))
            (§ block
                (§ throw (§ new #_"IOException" (§ pars "unexpected magic: " + magic)))
            )
            (§ var #_"int" (§ name numSigs) (§ expr Integer/parseInt(§ pars reader.readLine(§ pars ))))
            (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numSigs) :for (§ ass (§ name i) (§ expr i + 1)))
            (§ block
                (§ expr reader.readLine(§ pars )) ;; Skip sigs for now.
            )
            (§ var #_"int" (§ name numCheckpoints) (§ expr Integer/parseInt(§ pars reader.readLine(§ pars ))))
            (§ expr Preconditions/checkState(§ pars 0 < numCheckpoints))
            ;; Hash numCheckpoints in a way compatible to the binary format.
            (§ expr hasher.putBytes(§ pars ByteBuffer/allocate(§ pars 4).order(§ pars ByteOrder/BIG_ENDIAN).putInt(§ pars numCheckpoints).array(§ pars )))
            #_final
            (§ var #_"int" (§ name size) (§ expr StoredBlock/COMPACT_SERIALIZED_SIZE))
            (§ var #_"ByteBuffer" (§ name buffer) (§ expr ByteBuffer/allocate(§ pars size)))
            (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numCheckpoints) :for (§ ass (§ name i) (§ expr i + 1)))
            (§ block
                (§ var #_"byte[]" (§ name bytes) (§ expr BASE64.decode(§ pars reader.readLine(§ pars ))))
                (§ expr hasher.putBytes(§ pars bytes))
                (§ expr buffer.position(§ pars 0))
                (§ expr buffer.put(§ pars bytes))
                (§ expr buffer.position(§ pars 0))
                (§ var #_"StoredBlock" (§ name block) (§ expr StoredBlock/deserializeCompact(§ pars params, buffer)))
                (§ expr checkpoints.put(§ pars block.getHeader(§ pars ).getTimeSeconds(§ pars ), block))
            )
            (§ var #_"HashCode" (§ name hash) (§ expr hasher.hash(§ pars )))
            (§ expr log.info(§ pars "Read {} checkpoints, hash is {}", checkpoints.size(§ pars ), hash))
            (§ return (§ expr Sha256Hash/wrap(§ pars hash.asBytes(§ pars ))))
        )
        (§ finally )
        (§ block
            (§ if (§ expr reader != nil))
            (§ block
                (§ expr reader.close(§ pars ))
            )
        )
    )

    ;;;
     ; Returns a {@link StoredBlock} representing the last checkpoint before the given time, for example, normally
     ; you would want to know the checkpoint before the earliest wallet birthday.
     ;;
    #_public
    (§ method #_"StoredBlock" (§ fn getCheckpointBefore) [#_"long" (§ name time)])
    (§ block
        (§ try )
        (§ block
            (§ expr Preconditions/checkArgument(§ pars params.getGenesisBlock(§ pars ).getTimeSeconds(§ pars ) < time))
            ;; This is thread safe because the map never changes after creation.
            (§ var #_"Map.Entry<Long, StoredBlock>" (§ name entry) (§ expr checkpoints.floorEntry(§ pars time)))
            (§ if (§ expr entry != nil))
            (§ block
                (§ return (§ expr entry.getValue(§ pars )))
            )
            (§ var #_"Block" (§ name genesis) (§ expr params.getGenesisBlock(§ pars ).cloneAsHeader(§ pars )))
            (§ return (§ new #_"StoredBlock" (§ pars genesis, genesis.getWork(§ pars ), 0)))
        )
        (§ catch #_"VerificationException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
    )

    ;;; Returns the number of checkpoints that were loaded. ;;
    #_public
    (§ method #_"int" (§ fn numCheckpoints) [])
    (§ block
        (§ return (§ expr checkpoints.size(§ pars )))
    )

    ;;; Returns a hash of the concatenated checkpoint data. ;;
    #_public
    (§ method #_"Sha256Hash" (§ fn getDataHash) [])
    (§ block
        (§ return dataHash)
    )

    ;;;
     ; <p>Convenience method that creates a CheckpointManager, loads the given data, gets the checkpoint for the given
     ; time, then inserts it into the store and sets that to be the chain head.  Useful when you have just created
     ; a new store from scratch and want to use configure it all in one go.</p>
     ;
     ; <p>Note that time is adjusted backwards by a week to account for possible clock drift in the block headers.</p>
     ;;
    #_public
    #_static
    (§ method #_"void" (§ fn checkpoint) [#_"NetworkParameters" (§ name params), #_"InputStream" (§ name checkpoints), #_"BlockStore" (§ name store), #_"long" (§ name time)])
        (§ throws #_"IOException", #_"BlockStoreException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars params))
        (§ expr Preconditions/checkNotNull(§ pars store))
        (§ expr Preconditions/checkArgument(§ pars (§ not (§ insta store #_"FullPrunedBlockStore")), "You cannot use checkpointing with a full store."))

        (§ ass (§ name time) (§ expr time - (§ expr 86400 * 7)))

        (§ expr Preconditions/checkArgument(§ pars 0 < time))
        (§ expr log.info(§ pars "Attempting to initialize a new block store with a checkpoint for time {} ({})", time, Utils/dateTimeFormat(§ pars time * 1000)))

        (§ var #_"BufferedInputStream" (§ name stream) (§ new #_"BufferedInputStream" (§ pars checkpoints)))
        (§ var #_"CheckpointManager" (§ name manager) (§ new #_"CheckpointManager" (§ pars params, stream)))
        (§ var #_"StoredBlock" (§ name checkpoint) (§ expr manager.getCheckpointBefore(§ pars time)))
        (§ expr store.put(§ pars checkpoint))
        (§ expr store.setChainHead(§ pars checkpoint))
        (§ void nil)
    )
)

#_(ns org.bitcoinj.core #_"ChildMessage")

;;;
 ; <p>Represents a Message type that can be contained within another Message.  ChildMessages that have a cached
 ; backing byte array need to invalidate their parent's caches as well as their own if they are modified.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
(§ class #_"ChildMessage" (§ extends #_"Message")
    #_nilable
    #_protected
    (§ field #_"Message" (§ name parent))

    #_public
    (§ constructor #_"ChildMessage" [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ super (§ pars params))
        (§ void this)
    )

    #_public
    (§ constructor #_"ChildMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"int" (§ name offset), #_"int" (§ name protocolVersion)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, offset, protocolVersion))
        (§ void this)
    )

    #_public
    (§ constructor #_"ChildMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"int" (§ name offset), #_"int" (§ name protocolVersion), #_"Message" (§ name parent), #_"MessageSerializer" (§ name setSerializer), #_"int" (§ name length)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, offset, protocolVersion, setSerializer, length))
        (§ ass (§ name this.parent) parent)
        (§ void this)
    )

    #_public
    (§ constructor #_"ChildMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"int" (§ name offset)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, offset))
        (§ void this)
    )

    #_public
    (§ constructor #_"ChildMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"int" (§ name offset), #_nilable #_"Message" (§ name parent), #_"MessageSerializer" (§ name setSerializer), #_"int" (§ name length)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, offset, setSerializer, length))
        (§ ass (§ name this.parent) parent)
        (§ void this)
    )

    #_public
    #_final
    (§ method #_"void" (§ fn setParent) [#_nilable #_"Message" (§ name parent)])
    (§ block
        (§ if (§ expr this.parent != nil && this.parent != parent && parent != nil))
        (§ block
            ;; After old parent is unlinked it won't be able to receive notice if this ChildMessage changes internally.
            ;; To be safe we invalidate the parent cache to ensure it rebuilds manually on serialization.
            (§ expr this.parent.unCache(§ pars ))
        )
        (§ ass (§ name this.parent) parent)
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn unCache) [])
    (§ block
        (§ expr super.unCache(§ pars ))
        (§ if (§ expr parent != nil))
        (§ block
            (§ expr parent.unCache(§ pars ))
        )
        (§ void nil)
    )

    #_protected
    (§ method #_"void" (§ fn adjustLength) [#_"int" (§ name adjustment)])
    (§ block
        (§ expr adjustLength(§ pars 0, adjustment))
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn adjustLength) [#_"int" (§ name newArraySize), #_"int" (§ name adjustment)])
    (§ block
        (§ expr super.adjustLength(§ pars newArraySize, adjustment))
        (§ if (§ expr parent != nil))
        (§ block
            (§ expr parent.adjustLength(§ pars newArraySize, adjustment))
        )
        (§ void nil)
    )
)

#_(ns org.bitcoinj.core #_"Coin"
    (:import [java.io Serializable]
             [java.math BigDecimal])
    (:import [com.google.common.base Preconditions]
             [com.google.common.math LongMath]
             [com.google.common.primitives Longs])
   (:require [org.bitcoinj.utils MonetaryFormat]))

;;;
 ; Represents a monetary Bitcoin value.  This class is immutable.
 ;;
#_public
#_final
(§ class #_"Coin" (§ implements #_"Monetary", #_"Comparable<Coin>", #_"Serializable")
    ;;;
     ; Number of decimals for one Bitcoin.  This constant is useful for quick adapting to other coins because a lot of
     ; constants derive from it.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name SMALLEST_UNIT_EXPONENT) 8)

    ;;;
     ; The number of satoshis equal to one bitcoin.
     ;;
    #_private
    #_static
    #_final
    (§ field #_"long" (§ name COIN_VALUE) (§ expr LongMath/pow(§ pars 10, SMALLEST_UNIT_EXPONENT)))

    ;;;
     ; Zero Bitcoins.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"Coin" (§ name ZERO) (§ expr Coin/valueOf(§ pars 0)))

    ;;;
     ; One Bitcoin.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"Coin" (§ name COIN) (§ expr Coin/valueOf(§ pars COIN_VALUE)))

    ;;;
     ; 0.01 Bitcoins.  This unit is not really used much.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"Coin" (§ name CENT) (§ expr COIN.divide(§ pars 100)))

    ;;;
     ; 0.001 Bitcoins, also known as 1 mBTC.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"Coin" (§ name MILLICOIN) (§ expr COIN.divide(§ pars 1000)))

    ;;;
     ; 0.000001 Bitcoins, also known as 1 µBTC or 1 uBTC.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"Coin" (§ name MICROCOIN) (§ expr MILLICOIN.divide(§ pars 1000)))

    ;;;
     ; A satoshi is the smallest unit that can be transferred.  100 million of them fit into a Bitcoin.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"Coin" (§ name SATOSHI) (§ expr Coin/valueOf(§ pars 1)))

    #_public
    #_static
    #_final
    (§ field #_"Coin" (§ name FIFTY_COINS) (§ expr COIN.multiply(§ pars 50)))

    ;;;
     ; Represents a monetary value of minus one satoshi.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"Coin" (§ name NEGATIVE_SATOSHI) (§ expr Coin/valueOf(§ pars -1)))

    ;;;
     ; The number of satoshis of this monetary value.
     ;;
    #_public
    #_final
    (§ field #_"long" (§ name value))

    #_private
    (§ constructor #_"Coin" [#_final #_"long" (§ name satoshis)])
    (§ block
        (§ ass (§ name this.value) satoshis)
        (§ void this)
    )

    #_public
    #_static
    (§ method #_"Coin" (§ fn valueOf) [#_final #_"long" (§ name satoshis)])
    (§ block
        (§ return (§ new #_"Coin" (§ pars satoshis)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn smallestUnitExponent) [])
    (§ block
        (§ return (§ expr SMALLEST_UNIT_EXPONENT))
    )

    ;;;
     ; Returns the number of satoshis of this monetary value.
     ;;
    #_override
    #_public
    (§ method #_"long" (§ fn getValue) [])
    (§ block
        (§ return value)
    )

    ;;;
     ; Convert an amount expressed in the way humans are used to into satoshis.
     ;;
    #_public
    #_static
    (§ method #_"Coin" (§ fn valueOf) [#_final #_"int" (§ name coins), #_final #_"int" (§ name cents)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars 0 <= coins && 0 <= cents && cents < 100))

        (§ return (§ expr COIN.multiply(§ pars coins).add(§ pars CENT.multiply(§ pars cents))))
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify fractional satoshis, or a value out of range.
     ;;
    #_public
    #_static
    (§ method #_"Coin" (§ fn parseCoin) [#_final #_"String" (§ name str)])
    (§ block
        (§ try )
        (§ block
            (§ var #_"long" (§ name satoshis) (§ expr (§ new #_"BigDecimal" (§ pars str)).movePointRight(§ pars SMALLEST_UNIT_EXPONENT).longValueExact(§ pars )))
            (§ return (§ expr Coin/valueOf(§ pars satoshis)))
        )
        (§ catch #_"ArithmeticException" (§ name e))
        (§ block
            (§ throw (§ new #_"IllegalArgumentException" (§ pars e))) ;; Repackage exception to honor method contract.
        )
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.  The amount is cut to satoshi precision.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify a value out of range.
     ;;
    #_public
    #_static
    (§ method #_"Coin" (§ fn parseCoinInexact) [#_final #_"String" (§ name str)])
    (§ block
        (§ try )
        (§ block
            (§ var #_"long" (§ name satoshis) (§ expr (§ new #_"BigDecimal" (§ pars str)).movePointRight(§ pars SMALLEST_UNIT_EXPONENT).longValue(§ pars )))
            (§ return (§ expr Coin/valueOf(§ pars satoshis)))
        )
        (§ catch #_"ArithmeticException" (§ name e))
        (§ block
            (§ throw (§ new #_"IllegalArgumentException" (§ pars e))) ;; Repackage exception to honor method contract.
        )
    )

    #_public
    (§ method #_"Coin" (§ fn add) [#_final #_"Coin" (§ name value)])
    (§ block
        (§ return (§ new #_"Coin" (§ pars LongMath/checkedAdd(§ pars this.value, value.value))))
    )

    ;;; Alias for add. ;;
    #_public
    (§ method #_"Coin" (§ fn plus) [#_final #_"Coin" (§ name value)])
    (§ block
        (§ return (§ expr add(§ pars value)))
    )

    #_public
    (§ method #_"Coin" (§ fn subtract) [#_final #_"Coin" (§ name value)])
    (§ block
        (§ return (§ new #_"Coin" (§ pars LongMath/checkedSubtract(§ pars this.value, value.value))))
    )

    ;;; Alias for subtract. ;;
    #_public
    (§ method #_"Coin" (§ fn minus) [#_final #_"Coin" (§ name value)])
    (§ block
        (§ return (§ expr subtract(§ pars value)))
    )

    #_public
    (§ method #_"Coin" (§ fn multiply) [#_final #_"long" (§ name factor)])
    (§ block
        (§ return (§ new #_"Coin" (§ pars LongMath/checkedMultiply(§ pars this.value, factor))))
    )

    ;;; Alias for multiply. ;;
    #_public
    (§ method #_"Coin" (§ fn times) [#_final #_"long" (§ name factor)])
    (§ block
        (§ return (§ expr multiply(§ pars factor)))
    )

    ;;; Alias for multiply. ;;
    #_public
    (§ method #_"Coin" (§ fn times) [#_final #_"int" (§ name factor)])
    (§ block
        (§ return (§ expr multiply(§ pars factor)))
    )

    #_public
    (§ method #_"Coin" (§ fn divide) [#_final #_"long" (§ name divisor)])
    (§ block
        (§ return (§ new #_"Coin" (§ pars this.value / divisor)))
    )

    ;;; Alias for divide. ;;
    #_public
    (§ method #_"Coin" (§ fn div) [#_final #_"long" (§ name divisor)])
    (§ block
        (§ return (§ expr divide(§ pars divisor)))
    )

    ;;; Alias for divide. ;;
    #_public
    (§ method #_"Coin" (§ fn div) [#_final #_"int" (§ name divisor)])
    (§ block
        (§ return (§ expr divide(§ pars divisor)))
    )

    #_public
    (§ method #_"Coin[]" (§ fn divideAndRemainder) [#_final #_"long" (§ name divisor)])
    (§ block
        (§ return (§ new #_"Coin[]" (§ coll (§ new #_"Coin" (§ pars this.value / divisor)), (§ new #_"Coin" (§ pars this.value % divisor)) )))
    )

    #_public
    (§ method #_"long" (§ fn divide) [#_final #_"Coin" (§ name divisor)])
    (§ block
        (§ return (§ expr this.value / divisor.value))
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value greater than zero,
     ; otherwise false.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isPositive) [])
    (§ block
        (§ return (§ expr signum(§ pars ) == 1))
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value less than zero,
     ; otherwise false.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isNegative) [])
    (§ block
        (§ return (§ expr signum(§ pars ) == -1))
    )

    ;;;
     ; Returns true if and only if this instance represents zero monetary value,
     ; otherwise false.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isZero) [])
    (§ block
        (§ return (§ expr signum(§ pars ) == 0))
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is greater than that
     ; of the given other Coin, otherwise false.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isGreaterThan) [#_"Coin" (§ name other)])
    (§ block
        (§ return (§ expr 0 < compareTo(§ pars other)))
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is less than that
     ; of the given other Coin, otherwise false.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isLessThan) [#_"Coin" (§ name other)])
    (§ block
        (§ return (§ expr compareTo(§ pars other) < 0))
    )

    #_public
    (§ method #_"Coin" (§ fn shiftLeft) [#_final #_"int" (§ name n)])
    (§ block
        (§ return (§ new #_"Coin" (§ pars this.value << n)))
    )

    #_public
    (§ method #_"Coin" (§ fn shiftRight) [#_final #_"int" (§ name n)])
    (§ block
        (§ return (§ new #_"Coin" (§ pars this.value >> n)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn signum) [])
    (§ block
        (§ if (§ expr this.value == 0))
        (§ block
            (§ return 0)
        )
        (§ return (§ quest (§ expr this.value < 0) ? -1 :else 1))
    )

    #_public
    (§ method #_"Coin" (§ fn negate) [])
    (§ block
        (§ return (§ new #_"Coin" (§ pars (§ neg this.value))))
    )

    ;;;
     ; Returns the number of satoshis of this monetary value.  It's deprecated in favour of accessing {@link #value} directly.
     ;;
    #_public
    (§ method #_"long" (§ fn longValue) [])
    (§ block
        (§ return (§ expr this.value))
    )

    #_private
    #_static
    #_final
    (§ field #_"MonetaryFormat" (§ name FRIENDLY_FORMAT) (§ expr MonetaryFormat/BTC.minDecimals(§ pars 2).repeatOptionalDecimals(§ pars 1, 6).postfixCode(§ pars )))

    ;;;
     ; Returns the value as a 0.12 type string.  More digits after the decimal place will be used
     ; if necessary, but two will always be present.
     ;;
    #_public
    (§ method #_"String" (§ fn toFriendlyString) [])
    (§ block
        (§ return (§ expr FRIENDLY_FORMAT.format(§ pars this).toString(§ pars )))
    )

    #_private
    #_static
    #_final
    (§ field #_"MonetaryFormat" (§ name PLAIN_FORMAT) (§ expr MonetaryFormat/BTC.minDecimals(§ pars 0).repeatOptionalDecimals(§ pars 1, 8).noCode(§ pars )))

    ;;;
     ; Returns the value as a plain string denominated in BTC.
     ; The result is unformatted with no trailing zeroes.
     ; For instance, a value of 150000 satoshis gives an output string of "0.0015" BTC.
     ;;
    #_public
    (§ method #_"String" (§ fn toPlainString) [])
    (§ block
        (§ return (§ expr PLAIN_FORMAT.format(§ pars this).toString(§ pars )))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr Long/toString(§ pars value)))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_final #_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return (§ expr this.value == (§ expr (§ cast #_"Coin" o)).value))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ cast #_"int" this.value))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn compareTo) [#_final #_"Coin" (§ name other)])
    (§ block
        (§ return (§ expr Longs/compare(§ pars this.value, other.value)))
    )
)

#_(ns org.bitcoinj.core #_"Context"
    (:import [com.google.common.base Preconditions]
             [org.slf4j *]))

;; TODO: Finish adding Context c'tors to all the different objects so we can start deprecating the versions that take NetworkParameters.
;; TODO: Add a working directory notion to Context and make various subsystems that want to use files default to that directory (e.g. Orchid, block stores, wallet, etc).
;; TODO: Auto-register the block chain object here, and then use it in the (newly deprecated) TransactionConfidence.getDepthInBlocks() method:
;;       the new version should take an AbstractBlockChain specifically.
;;       Also use the block chain object reference from the context in PeerGroup and remove the other constructors, as it's easy to forget to wire things up.
;; TODO: Move Threading.USER_THREAD to here and leave behind just a source code stub.  Allow different instantiations of the library to use different user threads.
;; TODO: Keep a URI to where library internal data files can be found, to abstract over the lack of JAR files on Android.
;; TODO: Stash anything else that resembles global library configuration in here and use it to clean up the rest of the API without breaking people.
;; TODO: Move the TorClient into Context, so different parts of the library can read data over Tor without having to request it directly. (or maybe a general socket factory??)

;;;
 ; <p>The Context object holds various objects and pieces of configuration that are scoped to a specific instantiation of
 ; bitcoinj for a specific network.  You can get an instance of this class through calling {@link #get()}.</p>
 ;
 ; <p>Context is new in 0.13 and the library is currently in a transitional period: you should create a Context that
 ; wraps your chosen network parameters before using the rest of the library.  However if you don't, things will still
 ; work as a Context will be created for you and stashed in thread local storage.  The context is then propagated between
 ; library created threads as needed.  This automagical propagation and creation is a temporary mechanism: one day it
 ; will be removed to avoid confusing edge cases that could occur if the developer does not fully understand it e.g.
 ; in the case where multiple instances of the library are in use simultaneously.</p>
 ;;
#_public
(§ class #_"Context"
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"Context"))))

    #_public
    #_static
    #_final
    (§ field #_"int" (§ name DEFAULT_EVENT_HORIZON) 100)

    #_final
    #_private
    (§ field #_"TxConfidenceTable" (§ name confidenceTable))
    #_final
    #_private
    (§ field #_"NetworkParameters" (§ name params))
    #_final
    #_private
    (§ field #_"int" (§ name eventHorizon))
    #_final
    #_private
    (§ field #_"boolean" (§ name ensureMinRequiredFee))
    #_final
    #_private
    (§ field #_"Coin" (§ name feePerKb))

    ;;;
     ; Creates a new context object.  For now, this will be done for you by the framework.  Eventually you will be
     ; expected to do this yourself in the same manner as fetching a NetworkParameters object (at the start of your app).
     ;
     ; @param params The network parameters that will be associated with this context.
     ;;
    #_public
    (§ constructor #_"Context" [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ this (§ pars params, DEFAULT_EVENT_HORIZON, Transaction/DEFAULT_TX_FEE, true))
        (§ void this)
    )

    ;;;
     ; Creates a new custom context object.  This is mainly meant for unit tests for now.
     ;
     ; @param params The network parameters that will be associated with this context.
     ; @param eventHorizon Number of blocks after which the library will delete data and be unable to always process reorgs (see {@link #getEventHorizon()}).
     ; @param feePerKb The default fee per 1000 bytes of transaction data to pay when completing transactions.  For details, see {@link SendRequest#feePerKb}.
     ; @param ensureMinRequiredFee Whether to ensure the minimum required fee by default when completing transactions.  For details, see {@link SendRequest#ensureMinRequiredFee}.
     ;;
    #_public
    (§ constructor #_"Context" [#_"NetworkParameters" (§ name params), #_"int" (§ name eventHorizon), #_"Coin" (§ name feePerKb), #_"boolean" (§ name ensureMinRequiredFee)])
    (§ block
        (§ expr log.info(§ pars "Creating bitcoinj {} context.", VersionMessage/BITCOINJ_VERSION))
        (§ ass (§ name this.confidenceTable) (§ new #_"TxConfidenceTable" (§ pars )))
        (§ ass (§ name this.params) params)
        (§ ass (§ name this.eventHorizon) eventHorizon)
        (§ ass (§ name this.ensureMinRequiredFee) ensureMinRequiredFee)
        (§ ass (§ name this.feePerKb) feePerKb)
        (§ ass (§ name lastConstructed) this)
        (§ expr slot.set(§ pars this))
        (§ void this)
    )

    #_private
    #_static
    #_volatile
    (§ field #_"Context" (§ name lastConstructed))
    #_private
    #_static
    (§ field #_"boolean" (§ name isStrictMode))
    #_private
    #_static
    #_final
    (§ field #_"ThreadLocal<Context>" (§ name slot) (§ new #_"ThreadLocal<>" (§ pars )))

    ;;;
     ; Returns the current context that is associated with the <b>calling thread</b>.  BitcoinJ is an API that has thread
     ; affinity: much like OpenGL it expects each thread that accesses it to have been configured with a global Context
     ; object.  This method returns that.  Note that to help you develop, this method will <i>also</i> propagate whichever
     ; context was created last onto the current thread, if it's missing.  However it will print an error when doing so
     ; because propagation of contexts is meant to be done manually: this is so two libraries or subsystems that
     ; independently use bitcoinj (or possibly alt coin forks of it) can operate correctly.
     ;
     ; @throws java.lang.IllegalStateException if no context exists at all or if we are in strict mode and there is no context.
     ;;
    #_public
    #_static
    (§ method #_"Context" (§ fn get) [])
    (§ block
        (§ var #_"Context" (§ name tls) (§ expr slot.get(§ pars )))
        (§ if (§ expr tls == nil))
        (§ block
            (§ if isStrictMode)
            (§ block
                (§ expr log.error(§ pars "Thread is missing a bitcoinj context."))
                (§ expr log.error(§ pars "You should use Context/propagate() or a ContextPropagatingThreadFactory."))
                (§ throw (§ new #_"IllegalStateException" (§ pars "missing context")))
            )
            (§ if (§ expr lastConstructed == nil))
            (§ block
                (§ throw (§ new #_"IllegalStateException" (§ pars "You must construct a Context object before using bitcoinj!")))
            )
            (§ expr slot.set(§ pars lastConstructed))
            (§ expr log.error(§ pars "Performing thread fixup: you are accessing bitcoinj via a thread that has not had any context set on it."))
            (§ expr log.error(§ pars "This error has been corrected for, but doing this makes your app less robust."))
            (§ expr log.error(§ pars "You should use Context/propagate() or a ContextPropagatingThreadFactory."))
            (§ expr log.error(§ pars "Please refer to the user guide for more information about this."))
            (§ expr log.error(§ pars "Thread name is {}.", Thread/currentThread(§ pars ).getName(§ pars )))
            ;; TODO: Actually write the user guide section about this.
            (§ return lastConstructed)
        )

        (§ return tls)
    )

    ;;;
     ; Require that new threads use {@link #propagate(Context)} or {@link org.bitcoinj.utils.ContextPropagatingThreadFactory},
     ; rather than using a heuristic for the desired context.
     ;;
    #_public
    #_static
    (§ method #_"void" (§ fn enableStrictMode) [])
    (§ block
        (§ ass (§ name isStrictMode) true)
        (§ void nil)
    )

    ;; A temporary internal shim designed to help us migrate internally in a way that doesn't wreck source compatibility.
    #_public
    #_static
    (§ method #_"Context" (§ fn getOrCreate) [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ var #_"Context" (§ name context))
        (§ try )
        (§ block
            (§ ass (§ name context) (§ expr get(§ pars )))
        )
        (§ catch #_"IllegalStateException" (§ name e))
        (§ block
            (§ expr log.warn(§ pars "Implicitly creating context. This is a migration step and this message will eventually go away."))
            (§ ass (§ name context) (§ new #_"Context" (§ pars params)))
            (§ return context)
        )
        (§ if (§ expr context.getParams(§ pars ) != params))
        (§ block
            (§ throw (§ new #_"IllegalStateException" (§ pars "Context does not match implicit network params: " + context.getParams(§ pars ) + " vs " + params)))
        )
        (§ return context)
    )

    ;;;
     ; Sets the given context as the current thread context.  You should use this if you create your own threads that
     ; want to create core BitcoinJ objects.  Generally, if a class can accept a Context in its constructor and might
     ; be used (even indirectly) by a thread, you will want to call this first.  Your task may be simplified by using
     ; a {@link org.bitcoinj.utils.ContextPropagatingThreadFactory}.
     ;;
    #_public
    #_static
    (§ method #_"void" (§ fn propagate) [#_"Context" (§ name context)])
    (§ block
        (§ expr slot.set(§ pars Preconditions/checkNotNull(§ pars context)))
        (§ void nil)
    )

    ;;;
     ; Returns the {@link TxConfidenceTable} created by this context.  The pool tracks advertised
     ; and downloaded transactions so their confidence can be measured as a proportion of how many peers announced it.
     ; With an un-tampered with internet connection, the more peers announce a transaction the more confidence you can
     ; have that it's really valid.
     ;;
    #_public
    (§ method #_"TxConfidenceTable" (§ fn getConfidenceTable) [])
    (§ block
        (§ return confidenceTable)
    )

    ;;;
     ; Returns the {@link org.bitcoinj.core.NetworkParameters} specified when this context was (auto) created.  The
     ; network parameters defines various hard coded constants for a specific instance of a Bitcoin network, such as
     ; main net, testnet, etc.
     ;;
    #_public
    (§ method #_"NetworkParameters" (§ fn getParams) [])
    (§ block
        (§ return params)
    )

    ;;;
     ; The event horizon is the number of blocks after which various bits of the library consider a transaction to be
     ; so confirmed that it's safe to delete data.  Re-orgs larger than the event horizon will not be correctly
     ; processed, so the default value is high (100).
     ;;
    #_public
    (§ method #_"int" (§ fn getEventHorizon) [])
    (§ block
        (§ return eventHorizon)
    )

    ;;;
     ; The default fee per 1000 bytes of transaction data to pay when completing transactions.  For details, see {@link SendRequest#feePerKb}.
     ;;
    #_public
    (§ method #_"Coin" (§ fn getFeePerKb) [])
    (§ block
        (§ return feePerKb)
    )

    ;;;
     ; Whether to ensure the minimum required fee by default when completing transactions.  For details, see {@link SendRequest#ensureMinRequiredFee}.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isEnsureMinRequiredFee) [])
    (§ block
        (§ return ensureMinRequiredFee)
    )
)

#_(ns org.bitcoinj.core #_"DummySerializer"
    (:import [java.io IOException OutputStream]
             [java.nio BufferUnderflowException ByteBuffer]))

;;;
 ; Dummy serializer used ONLY for objects which do not have network parameters set.
 ;;
(§ class #_"DummySerializer" (§ extends #_"MessageSerializer")
    #_public
    #_static
    #_final
    (§ field #_"DummySerializer" (§ name DEFAULT) (§ new #_"DummySerializer" (§ pars )))

    #_private
    #_static
    #_final
    (§ field #_"String" (§ name DEFAULT_EXCEPTION_MESSAGE) (§ expr "Dummy serializer cannot serialize/deserialize objects as it does not know which network they belong to."))

    #_public
    (§ constructor #_"DummySerializer" [])
    (§ block
        (§ void this)
    )

    #_override
    #_public
    (§ method #_"Message" (§ fn deserialize) [#_"ByteBuffer" (§ name in)])
        (§ throws #_"UnsupportedOperationException")
    (§ block
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method #_"BitcoinSerializer.BitcoinPacketHeader" (§ fn deserializeHeader) [#_"ByteBuffer" (§ name in)])
        (§ throws #_"UnsupportedOperationException")
    (§ block
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method #_"Message" (§ fn deserializePayload) [#_"BitcoinSerializer.BitcoinPacketHeader" (§ name header), #_"ByteBuffer" (§ name in)])
        (§ throws #_"UnsupportedOperationException")
    (§ block
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn isParseRetainMode) [])
    (§ block
        (§ return false)
    )

    #_override
    #_public
    (§ method #_"AddressMessage" (§ fn makeAddressMessage) [#_"byte[]" (§ name payloadBytes), #_"int" (§ name length)])
        (§ throws #_"UnsupportedOperationException")
    (§ block
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method #_"Message" (§ fn makeAlertMessage) [#_"byte[]" (§ name payloadBytes)])
        (§ throws #_"UnsupportedOperationException")
    (§ block
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method #_"Block" (§ fn makeBlock) [#_"byte[]" (§ name payloadBytes), #_"int" (§ name offset), #_"int" (§ name length)])
        (§ throws #_"UnsupportedOperationException")
    (§ block
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method #_"Message" (§ fn makeBloomFilter) [#_"byte[]" (§ name payloadBytes)])
        (§ throws #_"UnsupportedOperationException")
    (§ block
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method #_"FilteredBlock" (§ fn makeFilteredBlock) [#_"byte[]" (§ name payloadBytes)])
        (§ throws #_"UnsupportedOperationException")
    (§ block
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method #_"InventoryMessage" (§ fn makeInventoryMessage) [#_"byte[]" (§ name payloadBytes), #_"int" (§ name length)])
        (§ throws #_"UnsupportedOperationException")
    (§ block
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method #_"Transaction" (§ fn makeTransaction) [#_"byte[]" (§ name payloadBytes), #_"int" (§ name offset), #_"int" (§ name length), #_"byte[]" (§ name hash)])
        (§ throws #_"UnsupportedOperationException")
    (§ block
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars DEFAULT_EXCEPTION_MESSAGE)))
    )

    #_override
    #_public
    (§ method #_"void" (§ fn seekPastMagicBytes) [#_"ByteBuffer" (§ name in)])
        (§ throws #_"BufferUnderflowException")
    (§ block
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars DEFAULT_EXCEPTION_MESSAGE)))
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn serialize) [#_"String" (§ name name), #_"byte[]" (§ name message), #_"OutputStream" (§ name out)])
        (§ throws #_"IOException")
    (§ block
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars DEFAULT_EXCEPTION_MESSAGE)))
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn serialize) [#_"Message" (§ name message), #_"OutputStream" (§ name out)])
        (§ throws #_"IOException")
    (§ block
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars DEFAULT_EXCEPTION_MESSAGE)))
        (§ void nil)
    )
)

#_(ns org.bitcoinj.core #_"ECKey"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.math BigInteger]
             [java.nio.charset Charset]
             [java.security SecureRandom SignatureException]
             [java.util Arrays Comparator])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base MoreObjects Objects Preconditions]
             [com.google.common.primitives Ints UnsignedBytes]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.asn1 *]
             [org.spongycastle.asn1.x9 X9ECParameters X9IntegerConverter]
             [org.spongycastle.crypto AsymmetricCipherKeyPair]
             [org.spongycastle.crypto.digests SHA256Digest]
             [org.spongycastle.crypto.ec CustomNamedCurves]
             [org.spongycastle.crypto.generators ECKeyPairGenerator]
             [org.spongycastle.crypto.params *]
             [org.spongycastle.crypto.signers ECDSASigner HMacDSAKCalculator]
             [org.spongycastle.math.ec ECAlgorithms ECPoint FixedPointCombMultiplier FixedPointUtil]
             [org.spongycastle.math.ec.custom.sec SecP256K1Curve]
             [org.spongycastle.util.encoders Base64])
   (:require [org.bitcoinj.crypto *]
             [org.bitcoinj.wallet Protos Wallet]))

;; TODO: Move this class to tracking compression state itself.
;; The Bouncy Castle guys are deprecating their own tracking of the compression state.

;;;
 ; <p>Represents an elliptic curve public and (optionally) private key, usable for digital signatures but not encryption.
 ; Creating a new ECKey with the empty constructor will generate a new random keypair.  Other static methods can be used
 ; when you already have the public or private parts.  If you create a key with only the public part, you can check
 ; signatures but not create them.</p>
 ;
 ; <p>ECKey also provides access to Bitcoin Core compatible text message signing, as accessible via the UI or JSON-RPC.
 ; This is slightly different to signing raw bytes - if you want to sign your own data and it won't be exposed as
 ; text to people, you don't want to use this.  If in doubt, ask on the mailing list.</p>
 ;
 ; <p>The ECDSA algorithm supports <i>key recovery</i> in which a signature plus a couple of discriminator bits can
 ; be reversed to find the public key used to calculate it.  This can be convenient when you have a message and a
 ; signature and want to find out who signed it, rather than requiring the user to provide the expected identity.</p>
 ;
 ; <p>This class supports a variety of serialization forms.  The methods that accept/return byte arrays serialize
 ; private keys as raw byte arrays and public keys using the SEC standard byte encoding for public keys.  Signatures
 ; are encoded using ASN.1/DER inside the Bitcoin protocol.</p>
 ;
 ; <p>A key can be <i>compressed</i> or <i>uncompressed</i>.  This refers to whether the public key is represented
 ; when encoded into bytes as an (x, y) coordinate on the elliptic curve, or whether it's represented as just an X
 ; co-ordinate and an extra byte that carries a sign bit.  With the latter form the Y coordinate can be calculated
 ; dynamically, however, <b>because the binary serialization is different the address of a key changes if its
 ; compression status is changed</b>.  If you deviate from the defaults it's important to understand this: money sent
 ; to a compressed version of the key will have a different address to the same key in uncompressed form.  Whether
 ; a public key is compressed or not is recorded in the SEC binary serialisation format, and preserved in a flag in
 ; this class so round-tripping preserves state.  Unless you're working with old software or doing unusual things, you
 ; can usually ignore the compressed/uncompressed distinction.</p>
 ;;
#_public
(§ class #_"ECKey" (§ implements #_"EncryptableItem")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"ECKey"))))

    ;;; Sorts oldest keys first, newest last. ;;
    #_public
    #_static
    #_final
    (§ field #_"Comparator<ECKey>" (§ name AGE_COMPARATOR) (§ new #_"Comparator<ECKey>" (§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"int" (§ fn compare) [#_"ECKey" (§ name k1), #_"ECKey" (§ name k2)])
            (§ block
                (§ if (§ expr k1.creationTimeSeconds == k2.creationTimeSeconds))
                (§ block
                    (§ return 0)
                )

                (§ return (§ quest (§ expr k1.creationTimeSeconds < k2.creationTimeSeconds) ? -1 :else 1))
            )
        )))

    ;;; Compares pub key bytes using {@link com.google.common.primitives.UnsignedBytes#lexicographicalComparator()}. ;;
    #_public
    #_static
    #_final
    (§ field #_"Comparator<ECKey>" (§ name PUBKEY_COMPARATOR) (§ new #_"Comparator<ECKey>" (§ pars )
        (§ anon
            #_private
            (§ field #_"Comparator<byte[]>" (§ name comparator) (§ expr UnsignedBytes/lexicographicalComparator(§ pars )))

            #_override
            #_public
            (§ method #_"int" (§ fn compare) [#_"ECKey" (§ name k1), #_"ECKey" (§ name k2)])
            (§ block
                (§ return (§ expr comparator.compare(§ pars k1.getPubKey(§ pars ), k2.getPubKey(§ pars ))))
            )
        )))

    ;; The parameters of the secp256k1 curve that Bitcoin uses.
    #_private
    #_static
    #_final
    (§ field #_"X9ECParameters" (§ name CURVE_PARAMS) (§ expr CustomNamedCurves/getByName(§ pars "secp256k1")))

    ;;; The parameters of the secp256k1 curve that Bitcoin uses. ;;
    #_public
    #_static
    #_final
    (§ field #_"ECDomainParameters" (§ name CURVE))

    ;;;
     ; Equal to CURVE.getN().shiftRight(1), used for canonicalising the S value of a signature.
     ; If you aren't sure what this is about, you can ignore it.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"BigInteger" (§ name HALF_CURVE_ORDER))

    #_private
    #_static
    #_final
    (§ field #_"SecureRandom" (§ name secureRandom))

    #_static
    (§ block
        ;; Init proper random number generator, as some old Android installations have bugs that make it unsecure.
        (§ if (§ expr Utils/isAndroidRuntime(§ pars )))
        (§ block
            (§ expr (§ new #_"LinuxSecureRandom" (§ pars )))
        )

        ;; Tell Bouncy Castle to precompute data that's needed during secp256k1 calculations.  Increasing the width
        ;; number makes calculations faster, but at a cost of extra memory usage and with decreasing returns.  12 was
        ;; picked after consulting with the BC team.
        (§ expr FixedPointUtil/precompute(§ pars CURVE_PARAMS.getG(§ pars ), 12))
        (§ ass (§ name CURVE) (§ new #_"ECDomainParameters" (§ pars CURVE_PARAMS.getCurve(§ pars ), CURVE_PARAMS.getG(§ pars ), CURVE_PARAMS.getN(§ pars ), CURVE_PARAMS.getH(§ pars ))))
        (§ ass (§ name HALF_CURVE_ORDER) (§ dot CURVE_PARAMS.getN(§ pars ).shiftRight(§ pars 1)))
        (§ ass (§ name secureRandom) (§ new #_"SecureRandom" (§ pars )))
    )

    ;; The two parts of the key.  If "priv" is set, "pub" can always be calculated.  If "pub" is set but not "priv", we
    ;; can only verify signatures not make them.
    #_protected
    #_final
    (§ field #_"BigInteger" (§ name priv)) ;; A field element.
    #_protected
    #_final
    (§ field #_"LazyECPoint" (§ name pub))

    ;; Creation time of the key in seconds since the epoch, or zero if the key was deserialized from a version that did
    ;; not have this field.
    #_protected
    (§ field #_"long" (§ name creationTimeSeconds))

    #_protected
    (§ field #_"KeyCrypter" (§ name keyCrypter))
    #_protected
    (§ field #_"EncryptedData" (§ name encryptedPrivateKey))

    #_private
    (§ field #_"byte[]" (§ name pubKeyHash))

    ;;;
     ; Generates an entirely new keypair.  Point compression is used so the resulting public key will be 33 bytes
     ; (32 for the co-ordinate and 1 byte to represent the y bit).
     ;;
    #_public
    (§ constructor #_"ECKey" [])
    (§ block
        (§ this (§ pars secureRandom))
        (§ void this)
    )

    ;;;
     ; Generates an entirely new keypair with the given {@link SecureRandom} object.  Point compression is used so the
     ; resulting public key will be 33 bytes (32 for the co-ordinate and 1 byte to represent the y bit).
     ;;
    #_public
    (§ constructor #_"ECKey" [#_"SecureRandom" (§ name secureRandom)])
    (§ block
        (§ var #_"ECKeyPairGenerator" (§ name generator) (§ new #_"ECKeyPairGenerator" (§ pars )))
        (§ var #_"ECKeyGenerationParameters" (§ name keygenParams) (§ new #_"ECKeyGenerationParameters" (§ pars CURVE, secureRandom)))
        (§ expr generator.init(§ pars keygenParams))
        (§ var #_"AsymmetricCipherKeyPair" (§ name keypair) (§ expr generator.generateKeyPair(§ pars )))
        (§ var #_"ECPrivateKeyParameters" (§ name privParams) (§ expr (§ cast #_"ECPrivateKeyParameters" (§ expr keypair.getPrivate(§ pars )))))
        (§ var #_"ECPublicKeyParameters" (§ name pubParams) (§ expr (§ cast #_"ECPublicKeyParameters" (§ expr keypair.getPublic(§ pars )))))
        (§ ass (§ name priv) (§ expr privParams.getD(§ pars )))
        (§ ass (§ name pub) (§ new #_"LazyECPoint" (§ pars CURVE.getCurve(§ pars ), pubParams.getQ(§ pars ).getEncoded(§ pars true))))
        (§ ass (§ name creationTimeSeconds) (§ expr Utils/currentTimeSeconds(§ pars )))
        (§ void this)
    )

    #_protected
    (§ constructor #_"ECKey" [#_nilable #_"BigInteger" (§ name priv), #_"ECPoint" (§ name pub)])
    (§ block
        (§ this (§ pars priv, new LazyECPoint(§ pars Preconditions/checkNotNull(§ pars pub))))
        (§ void this)
    )

    #_protected
    (§ constructor #_"ECKey" [#_nilable #_"BigInteger" (§ name priv), #_"LazyECPoint" (§ name pub)])
    (§ block
        (§ if (§ expr priv != nil))
        (§ block
            (§ expr Preconditions/checkArgument(§ pars priv.bitLength(§ pars ) <= (§ expr 32 << 3), "private key exceeds 32 bytes: {} bits", priv.bitLength(§ pars )))
            ;; Try and catch buggy callers or bad key imports, etc.  Zero and one are special because these are often
            ;; used as sentinel values and because scripting languages have a habit of auto-casting true and false to
            ;; 1 and 0 or vice-versa.  Type confusion bugs could therefore result in private keys with these values.
            (§ expr Preconditions/checkArgument(§ pars (§ not priv.equals(§ pars BigInteger/ZERO))))
            (§ expr Preconditions/checkArgument(§ pars (§ not priv.equals(§ pars BigInteger/ONE))))
        )
        (§ ass (§ name this.priv) priv)
        (§ ass (§ name this.pub) (§ expr Preconditions/checkNotNull(§ pars pub)))
        (§ void this)
    )

    ;;;
     ; Utility for compressing an elliptic curve point.  Returns the same point if it's already compressed.
     ; See the ECKey class docs for a discussion of point compression.
     ;;
    #_public
    #_static
    (§ method #_"ECPoint" (§ fn compressPoint) [#_"ECPoint" (§ name point)])
    (§ block
        (§ return (§ expr getPointWithCompression(§ pars point, true)))
    )

    #_public
    #_static
    (§ method #_"LazyECPoint" (§ fn compressPoint) [#_"LazyECPoint" (§ name point)])
    (§ block
        (§ return (§ quest (§ expr point.isCompressed(§ pars )) ? point :else (§ new #_"LazyECPoint" (§ pars compressPoint(§ pars point.get(§ pars ))))))
    )

    ;;;
     ; Utility for decompressing an elliptic curve point.  Returns the same point if it's already compressed.
     ; See the ECKey class docs for a discussion of point compression.
     ;;
    #_public
    #_static
    (§ method #_"ECPoint" (§ fn decompressPoint) [#_"ECPoint" (§ name point)])
    (§ block
        (§ return (§ expr getPointWithCompression(§ pars point, false)))
    )

    #_public
    #_static
    (§ method #_"LazyECPoint" (§ fn decompressPoint) [#_"LazyECPoint" (§ name point)])
    (§ block
        (§ return (§ quest (§ not (§ expr point.isCompressed(§ pars ))) ? point :else (§ new #_"LazyECPoint" (§ pars decompressPoint(§ pars point.get(§ pars ))))))
    )

    #_private
    #_static
    (§ method #_"ECPoint" (§ fn getPointWithCompression) [#_"ECPoint" (§ name point), #_"boolean" (§ name compressed)])
    (§ block
        (§ if (§ expr point.isCompressed(§ pars ) == compressed))
        (§ block
            (§ return point)
        )

        (§ ass (§ name point) (§ expr point.normalize(§ pars )))
        (§ var #_"BigInteger" (§ name x) (§ expr point.getAffineXCoord(§ pars ).toBigInteger(§ pars )))
        (§ var #_"BigInteger" (§ name y) (§ expr point.getAffineYCoord(§ pars ).toBigInteger(§ pars )))
        (§ return (§ expr CURVE.getCurve(§ pars ).createPoint(§ pars x, y, compressed)))
    )

    ;;;
     ; Construct an ECKey from an ASN.1 encoded private key.  These are produced by OpenSSL and stored by Bitcoin
     ; Core in its wallet.  Note that this is slow because it requires an EC point multiply.
     ;;
    #_public
    #_static
    (§ method #_"ECKey" (§ fn fromASN1) [#_"byte[]" (§ name asn1privkey)])
    (§ block
        (§ return (§ expr extractKeyFromASN1(§ pars asn1privkey)))
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow).  The resulting
     ; public key is compressed.
     ;;
    #_public
    #_static
    (§ method #_"ECKey" (§ fn fromPrivate) [#_"BigInteger" (§ name privKey)])
    (§ block
        (§ return (§ expr fromPrivate(§ pars privKey, true)))
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow), either
     ; compressed or not.
     ;;
    #_public
    #_static
    (§ method #_"ECKey" (§ fn fromPrivate) [#_"BigInteger" (§ name privKey), #_"boolean" (§ name compressed)])
    (§ block
        (§ var #_"ECPoint" (§ name point) (§ expr publicPointFromPrivate(§ pars privKey)))
        (§ return (§ new #_"ECKey" (§ pars privKey, getPointWithCompression(§ pars point, compressed))))
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow).  The resulting
     ; public key is compressed.
     ;;
    #_public
    #_static
    (§ method #_"ECKey" (§ fn fromPrivate) [#_"byte[]" (§ name privKeyBytes)])
    (§ block
        (§ return (§ expr fromPrivate(§ pars (§ new #_"BigInteger" (§ pars 1, privKeyBytes)))))
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow), either
     ; compressed or not.
     ;;
    #_public
    #_static
    (§ method #_"ECKey" (§ fn fromPrivate) [#_"byte[]" (§ name privKeyBytes), #_"boolean" (§ name compressed)])
    (§ block
        (§ return (§ expr fromPrivate(§ pars (§ new #_"BigInteger" (§ pars 1, privKeyBytes)), compressed)))
    )

    ;;;
     ; Creates an ECKey that simply trusts the caller to ensure that point is really the result of multiplying the
     ; generator point by the private key.  This is used to speed things up when you know you have the right values
     ; already.  The compression state of pub will be preserved.
     ;;
    #_public
    #_static
    (§ method #_"ECKey" (§ fn fromPrivateAndPrecalculatedPublic) [#_"BigInteger" (§ name priv), #_"ECPoint" (§ name pub)])
    (§ block
        (§ return (§ new #_"ECKey" (§ pars priv, pub)))
    )

    ;;;
     ; Creates an ECKey that simply trusts the caller to ensure that point is really the result of multiplying the
     ; generator point by the private key.  This is used to speed things up when you know you have the right values
     ; already.  The compression state of the point will be preserved.
     ;;
    #_public
    #_static
    (§ method #_"ECKey" (§ fn fromPrivateAndPrecalculatedPublic) [#_"byte[]" (§ name priv), #_"byte[]" (§ name pub)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars priv))
        (§ expr Preconditions/checkNotNull(§ pars pub))
        (§ return (§ new #_"ECKey" (§ pars (§ new #_"BigInteger" (§ pars 1, priv)), CURVE.getCurve(§ pars ).decodePoint(§ pars pub))))
    )

    ;;;
     ; Creates an ECKey that cannot be used for signing, only verifying signatures, from the given point.
     ; The compression state of pub will be preserved.
     ;;
    #_public
    #_static
    (§ method #_"ECKey" (§ fn fromPublicOnly) [#_"ECPoint" (§ name pub)])
    (§ block
        (§ return (§ new #_"ECKey" (§ pars nil, pub)))
    )

    ;;;
     ; Creates an ECKey that cannot be used for signing, only verifying signatures, from the given encoded point.
     ; The compression state of pub will be preserved.
     ;;
    #_public
    #_static
    (§ method #_"ECKey" (§ fn fromPublicOnly) [#_"byte[]" (§ name pub)])
    (§ block
        (§ return (§ new #_"ECKey" (§ pars nil, CURVE.getCurve(§ pars ).decodePoint(§ pars pub))))
    )

    ;;;
     ; Returns a copy of this key, but with the public point represented in uncompressed form.  Normally you would
     ; never need this: it's for specialised scenarios or when backwards compatibility in encoded form is necessary.
     ;;
    #_public
    (§ method #_"ECKey" (§ fn decompress) [])
    (§ block
        (§ return (§ quest (§ expr pub.isCompressed(§ pars )) ? (§ new #_"ECKey" (§ pars priv, decompressPoint(§ pars pub.get(§ pars )))) :else this))
    )

    ;;;
     ; Creates an ECKey given only the private key bytes.  This is the same as using the BigInteger constructor, but
     ; is more convenient if you are importing a key from elsewhere.  The public key will be automatically derived
     ; from the private key.
     ;;
    #_deprecated
    #_public
    (§ constructor #_"ECKey" [#_nilable #_"byte[]" (§ name privKeyBytes), #_nilable #_"byte[]" (§ name pubKey)])
    (§ block
        (§ this (§ pars (§ quest (§ expr privKeyBytes != nil) ? (§ new #_"BigInteger" (§ pars 1, privKeyBytes)) :else nil), pubKey))
        (§ void this)
    )

    ;;;
     ; Create a new ECKey with an encrypted private key, a public key and a KeyCrypter.
     ;
     ; @param encryptedPrivateKey The encrypted private key.
     ; @param pubKey The public key.
     ; @param keyCrypter The KeyCrypter that will be used, with an AES key, to encrypt and decrypt the private key.
     ;;
    #_deprecated
    #_public
    (§ constructor #_"ECKey" [#_"EncryptedData" (§ name encryptedPrivateKey), #_"byte[]" (§ name pubKey), #_"KeyCrypter" (§ name keyCrypter)])
    (§ block
        (§ this (§ pars (§ cast #_"byte[]" nil), pubKey))

        (§ ass (§ name this.keyCrypter) (§ expr Preconditions/checkNotNull(§ pars keyCrypter)))
        (§ ass (§ name this.encryptedPrivateKey) encryptedPrivateKey)
        (§ void this)
    )

    ;;;
     ; Constructs a key that has an encrypted private component.  The given object wraps encrypted bytes and an
     ; initialization vector.  Note that the key will not be decrypted during this call: the returned ECKey is
     ; unusable for signing unless a decryption key is supplied.
     ;;
    #_public
    #_static
    (§ method #_"ECKey" (§ fn fromEncrypted) [#_"EncryptedData" (§ name encryptedPrivateKey), #_"KeyCrypter" (§ name crypter), #_"byte[]" (§ name pubKey)])
    (§ block
        (§ var #_"ECKey" (§ name key) (§ expr fromPublicOnly(§ pars pubKey)))
        (§ ass (§ name key.encryptedPrivateKey) (§ expr Preconditions/checkNotNull(§ pars encryptedPrivateKey)))
        (§ ass (§ name key.keyCrypter) (§ expr Preconditions/checkNotNull(§ pars crypter)))
        (§ return key)
    )

    ;;;
     ; Creates an ECKey given either the private key only, the public key only, or both.  If only the private key
     ; is supplied, the public key will be calculated from it (this is slow).  If both are supplied, it's assumed
     ; the public key already correctly matches the private key.  If only the public key is supplied, this ECKey
     ; cannot be used for signing.
     ; @param compressed If set to true and pubKey is null, the derived public key will be in compressed form.
     ;;
    #_deprecated
    #_public
    (§ constructor #_"ECKey" [#_nilable #_"BigInteger" (§ name privKey), #_nilable #_"byte[]" (§ name pubKey), #_"boolean" (§ name compressed)])
    (§ block
        (§ if (§ expr privKey == nil && pubKey == nil))
        (§ block
            (§ throw (§ new #_"IllegalArgumentException" (§ pars "ECKey requires at least private or public key")))
        )
        (§ ass (§ name this.priv) privKey)
        (§ if (§ expr pubKey == nil))
        (§ block
            ;; Derive public from private.
            (§ var #_"ECPoint" (§ name point) (§ expr publicPointFromPrivate(§ pars privKey)))
            (§ ass (§ name point) (§ expr getPointWithCompression(§ pars point, compressed)))
            (§ ass (§ name this.pub) (§ new #_"LazyECPoint" (§ pars point)))
        )
        (§ else )
        (§ block
            ;; We expect the pubkey to be in regular encoded form, just as a BigInteger.
            ;; Therefore the first byte is a special marker byte.
            ;; TODO: This is probably not a useful API and may be confusing.
            (§ ass (§ name this.pub) (§ new #_"LazyECPoint" (§ pars CURVE.getCurve(§ pars ), pubKey)))
        )
        (§ void this)
    )

    ;;;
     ; Creates an ECKey given either the private key only, the public key only, or both.  If only the private key
     ; is supplied, the public key will be calculated from it (this is slow).  If both are supplied, it's assumed
     ; the public key already correctly matches the public key.  If only the public key is supplied, this ECKey cannot
     ; be used for signing.
     ;;
    #_deprecated
    #_private
    (§ constructor #_"ECKey" [#_nilable #_"BigInteger" (§ name privKey), #_nilable #_"byte[]" (§ name pubKey)])
    (§ block
        (§ this (§ pars privKey, pubKey, false))
        (§ void this)
    )

    ;;;
     ; Returns true if this key doesn't have unencrypted access to private key bytes.  This may be because
     ; it was never given any private key bytes to begin with (a watching key), or because the key is encrypted.
     ; You can use {@link #isEncrypted()} to tell the cases apart.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isPubKeyOnly) [])
    (§ block
        (§ return (§ expr priv == nil))
    )

    ;;;
     ; Returns true if this key has unencrypted access to private key bytes.
     ; Does the opposite of {@link #isPubKeyOnly()}.
     ;;
    #_public
    (§ method #_"boolean" (§ fn hasPrivKey) [])
    (§ block
        (§ return (§ expr priv != nil))
    )

    ;;; Returns true if this key is watch only, meaning it has a public key but no private key. ;;
    #_public
    (§ method #_"boolean" (§ fn isWatching) [])
    (§ block
        (§ return (§ expr isPubKeyOnly(§ pars ) && (§ not isEncrypted(§ pars ))))
    )

    ;;;
     ; Output this ECKey as an ASN.1 encoded private key, as understood by OpenSSL or used by Bitcoin Core
     ; in its wallet storage format.
     ; @throws org.bitcoinj.core.ECKey.MissingPrivateKeyException if the private key is missing or encrypted.
     ;;
    #_public
    (§ method #_"byte[]" (§ fn toASN1) [])
    (§ block
        (§ try )
        (§ block
            (§ var #_"byte[]" (§ name privKeyBytes) (§ expr getPrivKeyBytes(§ pars )))
            (§ var #_"ByteArrayOutputStream" (§ name baos) (§ new #_"ByteArrayOutputStream" (§ pars 400)))

            ;; ASN1_SEQUENCE(EC_PRIVATEKEY) = {
            ;;   ASN1_SIMPLE(EC_PRIVATEKEY, version, LONG),
            ;;   ASN1_SIMPLE(EC_PRIVATEKEY, privateKey, ASN1_OCTET_STRING),
            ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, parameters, ECPKPARAMETERS, 0),
            ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, publicKey, ASN1_BIT_STRING, 1)
            ;; } ASN1_SEQUENCE_END(EC_PRIVATEKEY)
            (§ var #_"DERSequenceGenerator" (§ name seq) (§ new #_"DERSequenceGenerator" (§ pars baos)))
            (§ expr seq.addObject(§ pars (§ new #_"ASN1Integer" (§ pars 1)))) ;; version
            (§ expr seq.addObject(§ pars (§ new #_"DEROctetString" (§ pars privKeyBytes))))
            (§ expr seq.addObject(§ pars (§ new #_"DERTaggedObject" (§ pars 0, CURVE_PARAMS.toASN1Primitive(§ pars )))))
            (§ expr seq.addObject(§ pars (§ new #_"DERTaggedObject" (§ pars 1, new DERBitString(§ pars getPubKey(§ pars ))))))
            (§ expr seq.close(§ pars ))
            (§ return (§ expr baos.toByteArray(§ pars )))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen, writing to memory stream.
        )
    )

    ;;;
     ; Returns public key bytes from the given private key.  To convert a byte array into a BigInteger, use <tt>new BigInteger(1, bytes)</tt>.
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn publicKeyFromPrivate) [#_"BigInteger" (§ name privKey), #_"boolean" (§ name compressed)])
    (§ block
        (§ return (§ expr publicPointFromPrivate(§ pars privKey).getEncoded(§ pars compressed)))
    )

    ;;;
     ; Returns public key point from the given private key.  To convert a byte array into a BigInteger, use <tt>new BigInteger(1, bytes)</tt>.
     ;;
    #_public
    #_static
    (§ method #_"ECPoint" (§ fn publicPointFromPrivate) [#_"BigInteger" (§ name privKey)])
    (§ block
        ;;
         ; TODO: FixedPointCombMultiplier currently doesn't support scalars longer than the group order,
         ; but that could change in future versions.
         ;;
        (§ if (§ expr CURVE.getN(§ pars ).bitLength(§ pars ) < privKey.bitLength(§ pars )))
        (§ block
            (§ ass (§ name privKey) (§ expr privKey.mod(§ pars CURVE.getN(§ pars ))))
        )

        (§ return (§ new #_"FixedPointCombMultiplier" (§ pars )).multiply(§ pars CURVE.getG(§ pars ), privKey))
    )

    ;;; Gets the hash160 form of the public key (as seen in addresses). ;;
    #_public
    (§ method #_"byte[]" (§ fn getPubKeyHash) [])
    (§ block
        (§ if (§ expr pubKeyHash == nil))
        (§ block
            (§ ass (§ name pubKeyHash) (§ expr Utils/sha256hash160(§ pars this.pub.getEncoded(§ pars ))))
        )

        (§ return pubKeyHash)
    )

    ;;;
     ; Gets the raw public key value.  This appears in transaction scriptSigs.  Note that this is <b>not</b> the same
     ; as the pubKeyHash/address.
     ;;
    #_public
    (§ method #_"byte[]" (§ fn getPubKey) [])
    (§ block
        (§ return (§ expr pub.getEncoded(§ pars )))
    )

    ;;; Gets the public key in the form of an elliptic curve point object from Bouncy Castle. ;;
    #_public
    (§ method #_"ECPoint" (§ fn getPubKeyPoint) [])
    (§ block
        (§ return (§ expr pub.get(§ pars )))
    )

    ;;;
     ; Gets the private key in the form of an integer field element.  The public key is derived by performing EC
     ; point addition this number of times (i.e. point multiplying).
     ;
     ; @throws java.lang.IllegalStateException if the private key bytes are not available.
     ;;
    #_public
    (§ method #_"BigInteger" (§ fn getPrivKey) [])
    (§ block
        (§ if (§ expr priv == nil))
        (§ block
            (§ throw (§ new #_"MissingPrivateKeyException" (§ pars )))
        )

        (§ return priv)
    )

    ;;;
     ; Returns whether this key is using the compressed form or not.  Compressed pubkeys are only 33 bytes, not 64.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isCompressed) [])
    (§ block
        (§ return (§ expr pub.isCompressed(§ pars )))
    )

    ;;;
     ; Returns the address that corresponds to the public part of this ECKey.  Note that an address is derived from
     ; the RIPEMD-160 hash of the public key and is not the public key itself (which is too large to be convenient).
     ;;
    #_public
    (§ method #_"Address" (§ fn toAddress) [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ return (§ new #_"Address" (§ pars params, getPubKeyHash(§ pars ))))
    )

    ;;;
     ; Groups the two components that make up a signature, and provides a way to encode to DER form, which is
     ; how ECDSA signatures are represented when embedded in other data structures in the Bitcoin protocol.
     ; The raw components can be useful for doing further EC maths on them.
     ;;
    #_public
    #_static
    (§ class #_"ECDSASignature"
        ;;; The two components of the signature. ;;
        #_public
        #_final
        (§ field #_"BigInteger" (§ name r))
        #_public
        #_final
        (§ field #_"BigInteger" (§ name s))

        ;;;
         ; Constructs a signature with the given components.  Does NOT automatically canonicalise the signature.
         ;;
        #_public
        (§ constructor #_"ECDSASignature" [#_"BigInteger" (§ name r), #_"BigInteger" (§ name s)])
        (§ block
            (§ ass (§ name this.r) r)
            (§ ass (§ name this.s) s)
            (§ void this)
        )

        ;;;
         ; Returns true if the S component is "low", that means it is below {@link ECKey#HALF_CURVE_ORDER}.  See
         ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki#Low_S_values_in_signatures">BIP62</a>.
         ;;
        #_public
        (§ method #_"boolean" (§ fn isCanonical) [])
        (§ block
            (§ return (§ expr s.compareTo(§ pars HALF_CURVE_ORDER) <= 0))
        )

        ;;;
         ; Will automatically adjust the S component to be less than or equal to half the curve order, if necessary.
         ; This is required because for every signature (r,s) the signature (r, -s (mod N)) is a valid signature of
         ; the same message.  However, we dislike the ability to modify the bits of a Bitcoin transaction after it's
         ; been signed, as that violates various assumed invariants.  Thus in future only one of those forms will be
         ; considered legal and the other will be banned.
         ;;
        #_public
        (§ method #_"ECDSASignature" (§ fn toCanonicalised) [])
        (§ block
            (§ if (§ expr (§ not isCanonical(§ pars ))))
            (§ block
                ;; The order of the curve is the number of valid points that exist on that curve.  If S is in the upper
                ;; half of the number of valid points, then bring it back to the lower half.  Otherwise, imagine that
                ;;    N = 10
                ;;    s = 8, so (-8 % 10 == 2) thus both (r, 8) and (r, 2) are valid solutions.
                ;;    10 - 8 == 2, giving us always the latter solution, which is canonical.
                (§ return (§ new #_"ECDSASignature" (§ pars r, CURVE.getN(§ pars ).subtract(§ pars s))))
            )

            (§ return this)
        )

        ;;;
         ; DER is an international standard for serializing data structures which is widely used in cryptography.
         ; It's somewhat like protocol buffers but less convenient.  This method returns a standard DER encoding
         ; of the signature, as recognized by OpenSSL and other libraries.
         ;;
        #_public
        (§ method #_"byte[]" (§ fn encodeToDER) [])
        (§ block
            (§ try )
            (§ block
                (§ return (§ expr derByteStream(§ pars ).toByteArray(§ pars )))
            )
            (§ catch #_"IOException" (§ name e))
            (§ block
                (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
            )
        )

        #_public
        #_static
        (§ method #_"ECDSASignature" (§ fn decodeFromDER) [#_"byte[]" (§ name bytes)])
            (§ throws #_"IllegalArgumentException")
        (§ block
            (§ var #_"ASN1InputStream" (§ name decoder) nil)
            (§ try )
            (§ block
                (§ ass (§ name decoder) (§ new #_"ASN1InputStream" (§ pars bytes)))
                (§ var #_"DLSequence" (§ name seq) (§ expr (§ cast #_"DLSequence" (§ expr decoder.readObject(§ pars )))))
                (§ if (§ expr seq == nil))
                (§ block
                    (§ throw (§ new #_"IllegalArgumentException" (§ pars "Reached past end of ASN.1 stream.")))
                )

                (§ var #_"ASN1Integer" (§ name r))
                (§ var #_"ASN1Integer" (§ name s))
                (§ try )
                (§ block
                    (§ ass (§ name r) (§ cast #_"ASN1Integer" (§ expr seq.getObjectAt(§ pars 0))))
                    (§ ass (§ name s) (§ cast #_"ASN1Integer" (§ expr seq.getObjectAt(§ pars 1))))
                )
                (§ catch #_"ClassCastException" (§ name e))
                (§ block
                    (§ throw (§ new #_"IllegalArgumentException" (§ pars e)))
                )
                ;; OpenSSL deviates from the DER spec by interpreting these values as unsigned, though they should not be.
                ;; Thus, we always use the positive versions.  See http://r6.ca/blog/20111119T211504Z.html
                (§ return (§ new #_"ECDSASignature" (§ pars r.getPositiveValue(§ pars ), s.getPositiveValue(§ pars ))))
            )
            (§ catch #_"IOException" (§ name e))
            (§ block
                (§ throw (§ new #_"IllegalArgumentException" (§ pars e)))
            )
            (§ finally )
            (§ block
                (§ if (§ expr decoder != nil))
                (§ block
                    (§ try )
                    (§ block
                        (§ expr decoder.close(§ pars ))
                    )
                    (§ catch #_"IOException" (§ name _))
                    (§ block
                    )
                )
            )
        )

        #_protected
        (§ method #_"ByteArrayOutputStream" (§ fn derByteStream) [])
            (§ throws #_"IOException")
        (§ block
            ;; Usually 70-72 bytes.
            (§ var #_"ByteArrayOutputStream" (§ name bos) (§ new #_"ByteArrayOutputStream" (§ pars 72)))
            (§ var #_"DERSequenceGenerator" (§ name seq) (§ new #_"DERSequenceGenerator" (§ pars bos)))
            (§ expr seq.addObject(§ pars (§ new #_"ASN1Integer" (§ pars r))))
            (§ expr seq.addObject(§ pars (§ new #_"ASN1Integer" (§ pars s))))
            (§ expr seq.close(§ pars ))
            (§ return bos)
        )

        #_override
        #_public
        (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
        (§ block
            (§ if (§ expr this == o))
            (§ block
                (§ return true)
            )
            (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
            (§ block
                (§ return false)
            )
            (§ var #_"ECDSASignature" (§ name other) (§ expr (§ cast #_"ECDSASignature" o)))
            (§ return (§ expr r.equals(§ pars other.r) && s.equals(§ pars other.s)))
        )

        #_override
        #_public
        (§ method #_"int" (§ fn hashCode) [])
        (§ block
            (§ return (§ expr Objects/hashCode(§ pars r, s)))
        )
    )

    ;;;
     ; Signs the given hash and returns the R and S components as BigIntegers.  In the Bitcoin protocol, they are
     ; usually encoded using ASN.1 format, so you want {@link org.bitcoinj.core.ECKey.ECDSASignature#toASN1()}
     ; instead.  However sometimes the independent components can be useful, for instance, if you're going to do
     ; further EC maths on them.
     ; @throws KeyCrypterException if this ECKey doesn't have a private part.
     ;;
    #_public
    (§ method #_"ECDSASignature" (§ fn sign) [#_"Sha256Hash" (§ name input)])
        (§ throws #_"KeyCrypterException")
    (§ block
        (§ return (§ expr sign(§ pars input, nil)))
    )

    ;;;
     ; If this global variable is set to true, sign() creates a dummy signature and verify() always returns true.
     ; This is intended to help accelerate unit tests that do a lot of signing/verifying, which in the debugger
     ; can be painfully slow.
     ;;
    #_testing
    #_public
    #_static
    (§ field #_"boolean" (§ name FAKE_SIGNATURES) false)

    ;;;
     ; Signs the given hash and returns the R and S components as BigIntegers.  In the Bitcoin protocol, they are
     ; usually encoded using DER format, so you want {@link org.bitcoinj.core.ECKey.ECDSASignature#encodeToDER()}
     ; instead.  However sometimes the independent components can be useful, for instance, if you're doing to do further
     ; EC maths on them.
     ;
     ; @param aesKey The AES key to use for decryption of the private key.  If null, then no decryption is required.
     ; @throws KeyCrypterException if there's something wrong with aesKey.
     ; @throws ECKey.MissingPrivateKeyException if this key cannot sign because it's pubkey only.
     ;;
    #_public
    (§ method #_"ECDSASignature" (§ fn sign) [#_"Sha256Hash" (§ name input), #_nilable #_"KeyParameter" (§ name aesKey)])
        (§ throws #_"KeyCrypterException")
    (§ block
        (§ var #_"KeyCrypter" (§ name crypter) (§ expr getKeyCrypter(§ pars )))
        (§ if (§ expr crypter != nil))
        (§ block
            (§ if (§ expr aesKey == nil))
            (§ block
                (§ throw (§ new #_"KeyIsEncryptedException" (§ pars )))
            )
            (§ return (§ expr decrypt(§ pars aesKey).sign(§ pars input)))
        )
        (§ else )
        (§ block
            ;; No decryption of private key required.
            (§ if (§ expr priv == nil))
            (§ block
                (§ throw (§ new #_"MissingPrivateKeyException" (§ pars )))
            )
        )
        (§ return (§ expr doSign(§ pars input, priv)))
    )

    #_protected
    (§ method #_"ECDSASignature" (§ fn doSign) [#_"Sha256Hash" (§ name input), #_"BigInteger" (§ name privateKeyForSigning)])
    (§ block
        (§ if (§ expr FAKE_SIGNATURES))
        (§ block
            (§ return (§ expr TransactionSignature/dummy(§ pars )))
        )

        (§ expr Preconditions/checkNotNull(§ pars privateKeyForSigning))

        (§ var #_"ECDSASigner" (§ name signer) (§ new #_"ECDSASigner" (§ pars (§ new #_"HMacDSAKCalculator" (§ pars (§ new #_"SHA256Digest" (§ pars )))))))
        (§ var #_"ECPrivateKeyParameters" (§ name privKey) (§ new #_"ECPrivateKeyParameters" (§ pars privateKeyForSigning, CURVE)))
        (§ expr signer.init(§ pars true, privKey))
        (§ var #_"BigInteger[]" (§ name components) (§ expr signer.generateSignature(§ pars input.getBytes(§ pars ))))
        (§ return (§ new #_"ECDSASignature" (§ pars components[0], components[1])).toCanonicalised(§ pars ))
    )

    ;;;
     ; <p>Verifies the given ECDSA signature against the message bytes using the public key bytes.</p>
     ;
     ; <p>When using native ECDSA verification, data must be 32 bytes, and no element may be
     ; larger than 520 bytes.</p>
     ;
     ; @param data      Hash of the data to verify.
     ; @param signature ASN.1 encoded signature.
     ; @param pub       The public key bytes to use.
     ;;
    #_public
    #_static
    (§ method #_"boolean" (§ fn verify) [#_"byte[]" (§ name data), #_"ECDSASignature" (§ name signature), #_"byte[]" (§ name pub)])
    (§ block
        (§ if (§ expr FAKE_SIGNATURES))
        (§ block
            (§ return true)
        )

        (§ var #_"ECDSASigner" (§ name signer) (§ new #_"ECDSASigner" (§ pars )))
        (§ var #_"ECPublicKeyParameters" (§ name params) (§ new #_"ECPublicKeyParameters" (§ pars CURVE.getCurve(§ pars ).decodePoint(§ pars pub), CURVE)))
        (§ expr signer.init(§ pars false, params))
        (§ try )
        (§ block
            (§ return (§ expr signer.verifySignature(§ pars data, signature.r, signature.s)))
        )
        (§ catch #_"NullPointerException" (§ name e))
        (§ block
            ;; Bouncy Castle contains a bug that can cause NPEs given specially crafted signatures.  Those signatures
            ;; are inherently invalid/attack sigs so we just fail them here rather than crash the thread.
            (§ expr log.error(§ pars "Caught NPE inside bouncy castle", e))
            (§ return false)
        )
    )

    ;;;
     ; Verifies the given ASN.1 encoded ECDSA signature against a hash using the public key.
     ;
     ; @param data      Hash of the data to verify.
     ; @param signature ASN.1 encoded signature.
     ; @param pub       The public key bytes to use.
     ;;
    #_public
    #_static
    (§ method #_"boolean" (§ fn verify) [#_"byte[]" (§ name data), #_"byte[]" (§ name signature), #_"byte[]" (§ name pub)])
    (§ block
        (§ return (§ expr verify(§ pars data, ECDSASignature/decodeFromDER(§ pars signature), pub)))
    )

    ;;;
     ; Verifies the given ASN.1 encoded ECDSA signature against a hash using the public key.
     ;
     ; @param hash      Hash of the data to verify.
     ; @param signature ASN.1 encoded signature.
     ;;
    #_public
    (§ method #_"boolean" (§ fn verify) [#_"byte[]" (§ name hash), #_"byte[]" (§ name signature)])
    (§ block
        (§ return (§ expr ECKey/verify(§ pars hash, signature, getPubKey(§ pars ))))
    )

    ;;;
     ; Verifies the given R/S pair (signature) against a hash using the public key.
     ;;
    #_public
    (§ method #_"boolean" (§ fn verify) [#_"Sha256Hash" (§ name sigHash), #_"ECDSASignature" (§ name signature)])
    (§ block
        (§ return (§ expr ECKey/verify(§ pars sigHash.getBytes(§ pars ), signature, getPubKey(§ pars ))))
    )

    ;;;
     ; Verifies the given ASN.1 encoded ECDSA signature against a hash using the public key, and throws an exception
     ; if the signature doesn't match.
     ; @throws java.security.SignatureException if the signature does not match.
     ;;
    #_public
    (§ method #_"void" (§ fn verifyOrThrow) [#_"byte[]" (§ name hash), #_"byte[]" (§ name signature)])
        (§ throws #_"SignatureException")
    (§ block
        (§ if (§ expr (§ not verify(§ pars hash, signature))))
        (§ block
            (§ throw (§ new #_"SignatureException" (§ pars )))
        )
        (§ void nil)
    )

    ;;;
     ; Verifies the given R/S pair (signature) against a hash using the public key, and throws an exception
     ; if the signature doesn't match.
     ; @throws java.security.SignatureException if the signature does not match.
     ;;
    #_public
    (§ method #_"void" (§ fn verifyOrThrow) [#_"Sha256Hash" (§ name sigHash), #_"ECDSASignature" (§ name signature)])
        (§ throws #_"SignatureException")
    (§ block
        (§ if (§ expr (§ not ECKey/verify(§ pars sigHash.getBytes(§ pars ), signature, getPubKey(§ pars )))))
        (§ block
            (§ throw (§ new #_"SignatureException" (§ pars )))
        )
        (§ void nil)
    )

    ;;;
     ; Returns true if the given pubkey is canonical, i.e. the correct length taking into account compression.
     ;;
    #_public
    #_static
    (§ method #_"boolean" (§ fn isPubKeyCanonical) [#_"byte[]" (§ name pubkey)])
    (§ block
        (§ if (§ expr pubkey.length < 33))
        (§ block
            (§ return false)
        )
        ;; Uncompressed pubkey.
        (§ if (§ expr pubkey[0] == 0x04))
        (§ block
            (§ return (§ expr pubkey.length == 65))
        )
        ;; Compressed pubkey.
        (§ if (§ expr pubkey[0] == 0x02 || pubkey[0] == 0x03))
        (§ block
            (§ return (§ expr pubkey.length == 33))
        )
        (§ return false)
    )

    #_private
    #_static
    (§ method #_"ECKey" (§ fn extractKeyFromASN1) [#_"byte[]" (§ name asn1privkey)])
    (§ block
        ;; To understand this code, see the definition of the ASN.1 format for EC private keys in the OpenSSL source
        ;; code in ec_asn1.c:
        ;;
        ;; ASN1_SEQUENCE(EC_PRIVATEKEY) = {
        ;;   ASN1_SIMPLE(EC_PRIVATEKEY, version, LONG),
        ;;   ASN1_SIMPLE(EC_PRIVATEKEY, privateKey, ASN1_OCTET_STRING),
        ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, parameters, ECPKPARAMETERS, 0),
        ;;   ASN1_EXP_OPT(EC_PRIVATEKEY, publicKey, ASN1_BIT_STRING, 1)
        ;; } ASN1_SEQUENCE_END(EC_PRIVATEKEY)
        (§ try )
        (§ block
            (§ var #_"ASN1InputStream" (§ name decoder) (§ new #_"ASN1InputStream" (§ pars asn1privkey)))
            (§ var #_"DLSequence" (§ name seq) (§ expr (§ cast #_"DLSequence" (§ expr decoder.readObject(§ pars )))))
            (§ expr Preconditions/checkArgument(§ pars decoder.readObject(§ pars ) == nil, "Input contains extra bytes"))
            (§ expr decoder.close(§ pars ))

            (§ expr Preconditions/checkArgument(§ pars seq.size(§ pars ) == 4, "Input does not appear to be an ASN.1 OpenSSL EC private key"))

            (§ expr Preconditions/checkArgument(§ pars (§ expr (§ cast #_"ASN1Integer" (§ expr seq.getObjectAt(§ pars 0)))).getValue(§ pars ).equals(§ pars BigInteger/ONE), "Input is of wrong version"))

            (§ var #_"byte[]" (§ name privbits) (§ expr (§ expr (§ cast #_"ASN1OctetString" (§ expr seq.getObjectAt(§ pars 1)))).getOctets(§ pars )))
            (§ var #_"BigInteger" (§ name privkey) (§ new #_"BigInteger" (§ pars 1, privbits)))

            (§ var #_"ASN1TaggedObject" (§ name pubkey) (§ expr (§ cast #_"ASN1TaggedObject" (§ expr seq.getObjectAt(§ pars 3)))))
            (§ expr Preconditions/checkArgument(§ pars pubkey.getTagNo(§ pars ) == 1, "Input has 'publicKey' with bad tag number"))
            (§ var #_"byte[]" (§ name pubbits) (§ expr (§ expr (§ cast #_"DERBitString" (§ expr pubkey.getObject(§ pars )))).getBytes(§ pars )))
            (§ expr Preconditions/checkArgument(§ pars pubbits.length == 33 || pubbits.length == 65, "Input has 'publicKey' with invalid length"))
            (§ var #_"int" (§ name encoding) (§ expr pubbits[0] & 0xff))
            ;; Only allow compressed(2,3) and uncompressed(4), not infinity(0) or hybrid(6,7).
            (§ expr Preconditions/checkArgument(§ pars 2 <= encoding && encoding <= 4, "Input has 'publicKey' with invalid encoding"))

            ;; Now sanity check to ensure the pubkey bytes match the privkey.
            (§ var #_"boolean" (§ name compressed) (§ expr pubbits.length == 33))
            (§ var #_"ECKey" (§ name key) (§ new #_"ECKey" (§ pars privkey, nil, compressed)))
            (§ if (§ expr (§ not Arrays/equals(§ pars key.getPubKey(§ pars ), pubbits))))
            (§ block
                (§ throw (§ new #_"IllegalArgumentException" (§ pars "Public key in ASN.1 structure does not match private key.")))
            )
            (§ return key)
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen, reading from memory stream.
        )
    )

    ;;;
     ; Signs a text message using the standard Bitcoin messaging signing format and returns the signature as a base64
     ; encoded string.
     ;
     ; @throws IllegalStateException if this ECKey does not have the private part.
     ; @throws KeyCrypterException if this ECKey is encrypted and no AESKey is provided or it does not decrypt the ECKey.
     ;;
    #_public
    (§ method #_"String" (§ fn signMessage) [#_"String" (§ name message)])
        (§ throws #_"KeyCrypterException")
    (§ block
        (§ return (§ expr signMessage(§ pars message, nil)))
    )

    ;;;
     ; Signs a text message using the standard Bitcoin messaging signing format and returns the signature as a base64
     ; encoded string.
     ;
     ; @throws IllegalStateException if this ECKey does not have the private part.
     ; @throws KeyCrypterException if this ECKey is encrypted and no AESKey is provided or it does not decrypt the ECKey.
     ;;
    #_public
    (§ method #_"String" (§ fn signMessage) [#_"String" (§ name message), #_nilable #_"KeyParameter" (§ name aesKey)])
        (§ throws #_"KeyCrypterException")
    (§ block
        (§ var #_"byte[]" (§ name data) (§ expr Utils/formatMessageForSigning(§ pars message)))
        (§ var #_"Sha256Hash" (§ name hash) (§ expr Sha256Hash/twiceOf(§ pars data)))
        (§ var #_"ECDSASignature" (§ name sig) (§ expr sign(§ pars hash, aesKey)))
        ;; Now we have to work backwards to figure out the recId needed to recover the signature.
        (§ var #_"int" (§ name recId) -1)
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < 4) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ var #_"ECKey" (§ name k) (§ expr ECKey/recoverFromSignature(§ pars i, sig, hash, isCompressed(§ pars ))))
            (§ if (§ expr k != nil && k.pub.equals(§ pars pub)))
            (§ block
                (§ ass (§ name recId) i)
                (§ break )
            )
        )
        (§ if (§ expr recId == -1))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars "Could not construct a recoverable key. This should never happen.")))
        )
        (§ var #_"int" (§ name headerByte) (§ expr recId + 27 + (§ quest (§ expr isCompressed(§ pars )) ? 4 :else 0)))
        (§ var #_"byte[]" (§ name sigData) (§ new #_"byte[]" (§ count 65))) ;; 1 header + 32 bytes for R + 32 bytes for S
        (§ ass (§ name sigData[0]) (§ cast #_"byte" headerByte))
        (§ expr System/arraycopy(§ pars Utils/bigIntegerToBytes(§ pars sig.r, 32), 0, sigData, 1, 32))
        (§ expr System/arraycopy(§ pars Utils/bigIntegerToBytes(§ pars sig.s, 32), 0, sigData, 33, 32))
        (§ return (§ new #_"String" (§ pars Base64/encode(§ pars sigData), Charset/forName(§ pars "UTF-8"))))
    )

    ;;;
     ; Given an arbitrary piece of text and a Bitcoin-format message signature encoded in base64, returns an ECKey
     ; containing the public key that was used to sign it.  This can then be compared to the expected public key to
     ; determine if the signature was correct.  These sorts of signatures are compatible with the Bitcoin-Qt/bitcoind
     ; format generated by signmessage/verifymessage RPCs and GUI menu options.  They are intended for humans to verify
     ; their communications with each other, hence the base64 format and the fact that the input is text.
     ;
     ; @param message Some piece of human readable text.
     ; @param signatureBase64 The Bitcoin-format message signature in base64.
     ; @throws SignatureException if the public key could not be recovered or if there was a signature format error.
     ;;
    #_public
    #_static
    (§ method #_"ECKey" (§ fn signedMessageToKey) [#_"String" (§ name message), #_"String" (§ name signatureBase64)])
        (§ throws #_"SignatureException")
    (§ block
        (§ var #_"byte[]" (§ name signatureEncoded))
        (§ try )
        (§ block
            (§ ass (§ name signatureEncoded) (§ expr Base64/decode(§ pars signatureBase64)))
        )
        (§ catch #_"RuntimeException" (§ name e))
        (§ block
            ;; This is what you get back from Bouncy Castle if base64 doesn't decode :( ;; )
            (§ throw (§ new #_"SignatureException" (§ pars "Could not decode base64", e)))
        )
        ;; Parse the signature bytes into r/s and the selector value.
        (§ if (§ expr signatureEncoded.length < 65))
        (§ block
            (§ throw (§ new #_"SignatureException" (§ pars "Signature truncated, expected 65 bytes and got " + signatureEncoded.length)))
        )

        (§ var #_"int" (§ name header) (§ expr signatureEncoded[0] & 0xff))
        ;; The header byte: 0x1B = first key with even y, 0x1C = first key with odd y,
        ;;                  0x1D = second key with even y, 0x1E = second key with odd y.
        (§ if (§ expr header < 27 || 34 < header))
        (§ block
            (§ throw (§ new #_"SignatureException" (§ pars "Header byte out of range: " + header)))
        )
        (§ var #_"BigInteger" (§ name r) (§ new #_"BigInteger" (§ pars 1, Arrays/copyOfRange(§ pars signatureEncoded, 1, 33))))
        (§ var #_"BigInteger" (§ name s) (§ new #_"BigInteger" (§ pars 1, Arrays/copyOfRange(§ pars signatureEncoded, 33, 65))))
        (§ var #_"ECDSASignature" (§ name sig) (§ new #_"ECDSASignature" (§ pars r, s)))
        (§ var #_"byte[]" (§ name messageBytes) (§ expr Utils/formatMessageForSigning(§ pars message)))
        ;; Note that the C++ code doesn't actually seem to specify any character encoding.
        ;; Presumably it's whatever JSON-SPIRIT hands back.  Assume UTF-8 for now.
        (§ var #_"Sha256Hash" (§ name messageHash) (§ expr Sha256Hash/twiceOf(§ pars messageBytes)))
        (§ var #_"boolean" (§ name compressed) false)
        (§ if (§ expr 31 <= header))
        (§ block
            (§ ass (§ name compressed) true)
            (§ ass (§ name header) (§ expr header - 4))
        )
        (§ var #_"int" (§ name recId) (§ expr header - 27))
        (§ var #_"ECKey" (§ name key) (§ expr ECKey/recoverFromSignature(§ pars recId, sig, messageHash, compressed)))
        (§ if (§ expr key == nil))
        (§ block
            (§ throw (§ new #_"SignatureException" (§ pars "Could not recover public key from signature")))
        )
        (§ return key)
    )

    ;;;
     ; Convenience wrapper around {@link ECKey#signedMessageToKey(String, String)}.
     ; If the key derived from the signature is not the same as this one, throws a SignatureException.
     ;;
    #_public
    (§ method #_"void" (§ fn verifyMessage) [#_"String" (§ name message), #_"String" (§ name signatureBase64)])
        (§ throws #_"SignatureException")
    (§ block
        (§ var #_"ECKey" (§ name key) (§ expr ECKey/signedMessageToKey(§ pars message, signatureBase64)))
        (§ if (§ expr (§ not key.pub.equals(§ pars pub))))
        (§ block
            (§ throw (§ new #_"SignatureException" (§ pars "Signature did not match for message")))
        )
        (§ void nil)
    )

    ;;;
     ; <p>Given the components of a signature and a selector value, recover and return the public key
     ; that generated the signature according to the algorithm in SEC1v2 section 4.1.6.</p>
     ;
     ; <p>The recId is an index from 0 to 3 which indicates which of the 4 possible keys is the correct one.  Because
     ; the key recovery operation yields multiple potential keys, the correct key must either be stored alongside the
     ; signature, or you must be willing to try each recId in turn until you find one that outputs the key you are
     ; expecting.</p>
     ;
     ; <p>If this method returns null it means recovery was not possible and recId should be iterated.</p>
     ;
     ; <p>Given the above two points, a correct usage of this method is inside a for loop from 0 to 3, and if the
     ; output is null OR a key that is not the one you expect, you try again with the next recId.</p>
     ;
     ; @param recId Which possible key to recover.
     ; @param sig The R and S components of the signature, wrapped.
     ; @param message Hash of the data that was signed.
     ; @param compressed Whether or not the original pubkey was compressed.
     ; @return An ECKey containing only the public part, or null if recovery wasn't possible.
     ;;
    #_nilable
    #_public
    #_static
    (§ method #_"ECKey" (§ fn recoverFromSignature) [#_"int" (§ name recId), #_"ECDSASignature" (§ name sig), #_"Sha256Hash" (§ name message), #_"boolean" (§ name compressed)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars 0 <= recId, "recId must be positive"))
        (§ expr Preconditions/checkArgument(§ pars 0 <= sig.r.signum(§ pars ), "r must be positive"))
        (§ expr Preconditions/checkArgument(§ pars 0 <= sig.s.signum(§ pars ), "s must be positive"))
        (§ expr Preconditions/checkNotNull(§ pars message))

        ;; 1.0 For j from 0 to h   (h == recId here and the loop is outside this function)
        ;;   1.1 Let x = r + jn
        (§ var #_"BigInteger" (§ name n) (§ expr CURVE.getN(§ pars ))) ;; Curve order.
        (§ var #_"BigInteger" (§ name i) (§ expr BigInteger/valueOf(§ pars (§ cast #_"long" recId) / 2)))
        (§ var #_"BigInteger" (§ name x) (§ expr sig.r.add(§ pars i.multiply(§ pars n))))
        ;;   1.2. Convert the integer x to an octet string X of length mlen using the conversion routine
        ;;        specified in Section 2.3.7, where mlen = ⌈(log2 p)/8⌉ or mlen = ⌈m/8⌉.
        ;;   1.3. Convert the octet string (16 set binary digits)||X to an elliptic curve point R using the
        ;;        conversion routine specified in Section 2.3.4. If this conversion routine outputs “invalid”,
        ;;        then do another iteration of Step 1.
        ;;
        ;; More concisely, what these points mean is to use X as a compressed public key.
        (§ var #_"BigInteger" (§ name prime) (§ expr SecP256K1Curve.q))
        ;; Cannot have point co-ordinates larger than this as everything takes place modulo Q.
        (§ if (§ expr 0 <= x.compareTo(§ pars prime)))
        (§ block
            (§ return nil)
        )

        ;; Compressed keys require you to know an extra bit of data about the y-coord as there are two possibilities.
        ;; So it's encoded in the recId.
        (§ var #_"ECPoint" (§ name R) (§ expr decompressKey(§ pars x, (§ expr recId & 1) == 1)))
        ;;   1.4. If nR != point at infinity, then do another iteration of Step 1 (callers responsibility).
        (§ if (§ not (§ dot R.multiply(§ pars n).isInfinity(§ pars ))))
        (§ block
            (§ return nil)
        )

        ;;   1.5. Compute e from M using Steps 2 and 3 of ECDSA signature verification.
        (§ var #_"BigInteger" (§ name e) (§ expr message.toBigInteger(§ pars )))
        ;;   1.6. For k from 1 to 2 do the following.   (loop is outside this function via iterating recId)
        ;;   1.6.1. Compute a candidate public key as:
        ;;               Q = mi(r) * (sR - eG)
        ;;
        ;; Where mi(x) is the modular multiplicative inverse. We transform this into the following:
        ;;               Q = (mi(r) * s ** R) + (mi(r) * -e ** G)
        ;; Where -e is the modular additive inverse of e, that is z such that z + e = 0 (mod n). In the above equation
        ;; ** is point multiplication and + is point addition (the EC group operator).
        ;;
        ;; We can find the additive inverse by subtracting e from zero then taking the mod. For example the additive
        ;; inverse of 3 modulo 11 is 8 because 3 + 8 mod 11 = 0, and -3 mod 11 = 8.
        (§ var #_"BigInteger" (§ name eInv) (§ expr BigInteger/ZERO.subtract(§ pars e).mod(§ pars n)))
        (§ var #_"BigInteger" (§ name rInv) (§ expr sig.r.modInverse(§ pars n)))
        (§ var #_"BigInteger" (§ name srInv) (§ expr rInv.multiply(§ pars sig.s).mod(§ pars n)))
        (§ var #_"BigInteger" (§ name eInvrInv) (§ expr rInv.multiply(§ pars eInv).mod(§ pars n)))
        (§ var #_"ECPoint" (§ name q) (§ expr ECAlgorithms/sumOfTwoMultiplies(§ pars CURVE.getG(§ pars ), eInvrInv, R, srInv)))
        (§ return (§ expr ECKey/fromPublicOnly(§ pars q.getEncoded(§ pars compressed))))
    )

    ;;; Decompress a compressed public key (x co-ord and low-bit of y-coord). ;;
    #_private
    #_static
    (§ method #_"ECPoint" (§ fn decompressKey) [#_"BigInteger" (§ name xBN), #_"boolean" (§ name yBit)])
    (§ block
        (§ var #_"X9IntegerConverter" (§ name x9) (§ new #_"X9IntegerConverter" (§ pars )))
        (§ var #_"byte[]" (§ name compEnc) (§ expr x9.integerToBytes(§ pars xBN, 1 + x9.getByteLength(§ pars CURVE.getCurve(§ pars )))))
        (§ ass (§ name compEnc[0]) (§ cast #_"byte" (§ quest yBit ? 0x03 :else 0x02)))
        (§ return (§ expr CURVE.getCurve(§ pars ).decodePoint(§ pars compEnc)))
    )

    ;;;
     ; Returns a 32 byte array containing the private key.
     ; @throws org.bitcoinj.core.ECKey.MissingPrivateKeyException if the private key bytes are missing/encrypted.
     ;;
    #_public
    (§ method #_"byte[]" (§ fn getPrivKeyBytes) [])
    (§ block
        (§ return (§ expr Utils/bigIntegerToBytes(§ pars getPrivKey(§ pars ), 32)))
    )

    ;;;
     ; Returns the creation time of this key or zero if the key was deserialized from a version that did not store
     ; that data.
     ;;
    #_override
    #_public
    (§ method #_"long" (§ fn getCreationTimeSeconds) [])
    (§ block
        (§ return creationTimeSeconds)
    )

    ;;;
     ; Sets the creation time of this key.  Zero is a convention to mean "unavailable".  This method can be useful when
     ; you have a raw key you are importing from somewhere else.
     ;;
    #_public
    (§ method #_"void" (§ fn setCreationTimeSeconds) [#_"long" (§ name newCreationTimeSeconds)])
    (§ block
        (§ if (§ expr newCreationTimeSeconds < 0))
        (§ block
            (§ throw (§ new #_"IllegalArgumentException" (§ pars "Cannot set creation time to negative value: " + newCreationTimeSeconds)))
        )
        (§ ass (§ name creationTimeSeconds) newCreationTimeSeconds)
        (§ void nil)
    )

    ;;;
     ; Create an encrypted private key with the keyCrypter and the AES key supplied.
     ; This method returns a new encrypted key and leaves the original unchanged.
     ;
     ; @param keyCrypter The keyCrypter that specifies exactly how the encrypted bytes are created.
     ; @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached as it is slow to create).
     ; @return encryptedKey
     ;;
    #_public
    (§ method #_"ECKey" (§ fn encrypt) [#_"KeyCrypter" (§ name keyCrypter), #_"KeyParameter" (§ name aesKey)])
        (§ throws #_"KeyCrypterException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars keyCrypter))

        #_final
        (§ var #_"byte[]" (§ name privKeyBytes) (§ expr getPrivKeyBytes(§ pars )))
        (§ var #_"EncryptedData" (§ name encryptedPrivateKey) (§ expr keyCrypter.encrypt(§ pars privKeyBytes, aesKey)))
        (§ var #_"ECKey" (§ name result) (§ expr ECKey/fromEncrypted(§ pars encryptedPrivateKey, keyCrypter, getPubKey(§ pars ))))
        (§ expr result.setCreationTimeSeconds(§ pars creationTimeSeconds))
        (§ return result)
    )

    ;;;
     ; Create a decrypted private key with the keyCrypter and AES key supplied.  Note that if the aesKey is wrong, this
     ; has some chance of throwing KeyCrypterException due to the corrupted padding that will result, but it can also
     ; just yield a garbage key.
     ;
     ; @param keyCrypter The keyCrypter that specifies exactly how the decrypted bytes are created.
     ; @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached).
     ;;
    #_public
    (§ method #_"ECKey" (§ fn decrypt) [#_"KeyCrypter" (§ name keyCrypter), #_"KeyParameter" (§ name aesKey)])
        (§ throws #_"KeyCrypterException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars keyCrypter))

        ;; Check that the keyCrypter matches the one used to encrypt the keys, if set.
        (§ if (§ expr this.keyCrypter != nil && (§ not this.keyCrypter.equals(§ pars keyCrypter))))
        (§ block
            (§ throw (§ new #_"KeyCrypterException" (§ pars "The keyCrypter being used to decrypt the key is different to the one that was used to encrypt it")))
        )

        (§ expr Preconditions/checkState(§ pars encryptedPrivateKey != nil, "This key is not encrypted"))

        (§ var #_"byte[]" (§ name unencryptedPrivateKey) (§ expr keyCrypter.decrypt(§ pars encryptedPrivateKey, aesKey)))
        (§ var #_"ECKey" (§ name key) (§ expr ECKey/fromPrivate(§ pars unencryptedPrivateKey)))
        (§ if (§ expr (§ not isCompressed(§ pars ))))
        (§ block
            (§ ass (§ name key) (§ expr key.decompress(§ pars )))
        )
        (§ if (§ expr (§ not Arrays/equals(§ pars key.getPubKey(§ pars ), getPubKey(§ pars )))))
        (§ block
            (§ throw (§ new #_"KeyCrypterException" (§ pars "Provided AES key is wrong")))
        )

        (§ expr key.setCreationTimeSeconds(§ pars creationTimeSeconds))
        (§ return key)
    )

    ;;;
     ; Create a decrypted private key with AES key.  Note that if the AES key is wrong, this
     ; has some chance of throwing KeyCrypterException due to the corrupted padding that will result, but it can also
     ; just yield a garbage key.
     ;
     ; @param aesKey The KeyParameter with the AES encryption key (usually constructed with keyCrypter#deriveKey and cached).
     ;;
    #_public
    (§ method #_"ECKey" (§ fn decrypt) [#_"KeyParameter" (§ name aesKey)])
        (§ throws #_"KeyCrypterException")
    (§ block
        #_final
        (§ var #_"KeyCrypter" (§ name crypter) (§ expr getKeyCrypter(§ pars )))
        (§ if (§ expr crypter == nil))
        (§ block
            (§ throw (§ new #_"KeyCrypterException" (§ pars "No key crypter available")))
        )

        (§ return (§ expr decrypt(§ pars crypter, aesKey)))
    )

    ;;;
     ; Creates decrypted private key if needed.
     ;;
    #_public
    (§ method #_"ECKey" (§ fn maybeDecrypt) [#_nilable #_"KeyParameter" (§ name aesKey)])
        (§ throws #_"KeyCrypterException")
    (§ block
        (§ return (§ quest (§ expr isEncrypted(§ pars ) && aesKey != nil) ? (§ expr decrypt(§ pars aesKey)) :else this))
    )

    ;;;
     ; <p>Check that it is possible to decrypt the key with the keyCrypter and that the original key is returned.</p>
     ;
     ; <p>Because it is a critical failure if the private keys cannot be decrypted successfully (resulting of loss of
     ; all bitcoins controlled by the private key) you can use this method to check when you *encrypt* a wallet that
     ; it can definitely be decrypted successfully.</p>
     ;
     ; <p>See {@link Wallet#encrypt(KeyCrypter keyCrypter, KeyParameter aesKey)} for example usage.</p>
     ;
     ; @return true if the encrypted key can be decrypted back to the original key successfully.
     ;;
    #_public
    #_static
    (§ method #_"boolean" (§ fn encryptionIsReversible) [#_"ECKey" (§ name originalKey), #_"ECKey" (§ name encryptedKey), #_"KeyCrypter" (§ name keyCrypter), #_"KeyParameter" (§ name aesKey)])
    (§ block
        (§ try )
        (§ block
            (§ var #_"ECKey" (§ name rebornUnencryptedKey) (§ expr encryptedKey.decrypt(§ pars keyCrypter, aesKey)))
            (§ var #_"byte[]" (§ name originalPrivateKeyBytes) (§ expr originalKey.getPrivKeyBytes(§ pars )))
            (§ var #_"byte[]" (§ name rebornKeyBytes) (§ expr rebornUnencryptedKey.getPrivKeyBytes(§ pars )))
            (§ if (§ expr (§ not Arrays/equals(§ pars originalPrivateKeyBytes, rebornKeyBytes))))
            (§ block
                (§ expr log.error(§ pars "The check that encryption could be reversed failed for {}", originalKey))
                (§ return false)
            )
            (§ return true)
        )
        (§ catch #_"KeyCrypterException" (§ name kce))
        (§ block
            (§ expr log.error(§ pars kce.getMessage(§ pars )))
            (§ return false)
        )
    )

    ;;;
     ; Indicates whether the private key is encrypted (true) or not (false).
     ; A private key is deemed to be encrypted when there is both a KeyCrypter and the encryptedPrivateKey is non-zero.
     ;;
    #_override
    #_public
    (§ method #_"boolean" (§ fn isEncrypted) [])
    (§ block
        (§ return (§ expr keyCrypter != nil && encryptedPrivateKey != nil && 0 < encryptedPrivateKey.encryptedBytes.length))
    )

    #_nilable
    #_override
    #_public
    (§ method #_"Protos.Wallet.EncryptionType" (§ fn getEncryptionType) [])
    (§ block
        (§ return (§ quest (§ expr keyCrypter != nil) ? (§ expr keyCrypter.getUnderstoodEncryptionType(§ pars )) :else (§ expr Protos/Wallet/EncryptionType/UNENCRYPTED)))
    )

    ;;;
     ; A wrapper for {@link #getPrivKeyBytes()} that returns null if the private key bytes are missing or would have
     ; to be derived (for the HD key case).
     ;;
    #_override
    #_nilable
    #_public
    (§ method #_"byte[]" (§ fn getSecretBytes) [])
    (§ block
        (§ if (§ expr hasPrivKey(§ pars )))
        (§ block
            (§ return (§ expr getPrivKeyBytes(§ pars )))
        )

        (§ return nil)
    )

    ;;; An alias for {@link #getEncryptedPrivateKey()}. ;;
    #_nilable
    #_override
    #_public
    (§ method #_"EncryptedData" (§ fn getEncryptedData) [])
    (§ block
        (§ return (§ expr getEncryptedPrivateKey(§ pars )))
    )

    ;;;
     ; Returns the the encrypted private key bytes and initialisation vector for this ECKey, or null if the ECKey
     ; is not encrypted.
     ;;
    #_nilable
    #_public
    (§ method #_"EncryptedData" (§ fn getEncryptedPrivateKey) [])
    (§ block
        (§ return encryptedPrivateKey)
    )

    ;;;
     ; Returns the KeyCrypter that was used to encrypt to encrypt this ECKey.  You need this to decrypt the ECKey.
     ;;
    #_nilable
    #_public
    (§ method #_"KeyCrypter" (§ fn getKeyCrypter) [])
    (§ block
        (§ return keyCrypter)
    )

    #_public
    #_static
    (§ class #_"MissingPrivateKeyException" (§ extends #_"RuntimeException")
    )

    #_public
    #_static
    (§ class #_"KeyIsEncryptedException" (§ extends #_"MissingPrivateKeyException")
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || (§ not (§ insta o #_"ECKey"))))
        (§ block
            (§ return false)
        )
        (§ var #_"ECKey" (§ name other) (§ expr (§ cast #_"ECKey" o)))
        (§ return (§ expr Objects/equal(§ pars this.priv, other.priv) && Objects/equal(§ pars this.pub, other.pub) && Objects/equal(§ pars this.creationTimeSeconds, other.creationTimeSeconds) && Objects/equal(§ pars this.keyCrypter, other.keyCrypter) && Objects/equal(§ pars this.encryptedPrivateKey, other.encryptedPrivateKey)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr pub.hashCode(§ pars )))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr toString(§ pars false, nil)))
    )

    ;;;
     ; Produce a string rendering of the ECKey INCLUDING the private key.
     ; Unless you absolutely need the private key it is better for security reasons to just use {@link #toString()}.
     ;;
    #_public
    (§ method #_"String" (§ fn toStringWithPrivate) [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ return (§ expr toString(§ pars true, params)))
    )

    #_public
    (§ method #_"String" (§ fn getPrivateKeyAsHex) [])
    (§ block
        (§ return (§ expr Utils/HEX.encode(§ pars getPrivKeyBytes(§ pars ))))
    )

    #_public
    (§ method #_"String" (§ fn getPublicKeyAsHex) [])
    (§ block
        (§ return (§ expr Utils/HEX.encode(§ pars pub.getEncoded(§ pars ))))
    )

    #_private
    (§ method #_"String" (§ fn toString) [#_"boolean" (§ name includePrivate), #_"NetworkParameters" (§ name params)])
    (§ block
        #_final
        (§ var #_"MoreObjects.ToStringHelper" (§ name helper) (§ expr MoreObjects/toStringHelper(§ pars this).omitNullValues(§ pars )))
        (§ expr helper.add(§ pars "pub HEX", getPublicKeyAsHex(§ pars )))
        (§ if includePrivate)
        (§ block
            (§ try )
            (§ block
                (§ expr helper.add(§ pars "priv HEX", getPrivateKeyAsHex(§ pars )))
            )
            (§ catch #_"IllegalStateException" (§ name _))
            (§ block
                ;; TODO: Make hasPrivKey() work for deterministic keys and fix this.
            )
            (§ catch #_"Exception" (§ name e))
            (§ block
                #_final
                (§ var #_"String" (§ name message) (§ expr e.getMessage(§ pars )))
                (§ expr helper.add(§ pars "priv EXCEPTION", e.getClass(§ pars ).getName(§ pars ) + (§ quest (§ expr message != nil) ? (§ str ": " + message) :else (§ expr ""))))
            )
        )
        (§ if (§ expr 0 < creationTimeSeconds))
        (§ block
            (§ expr helper.add(§ pars "creationTimeSeconds", creationTimeSeconds))
        )
        (§ expr helper.add(§ pars "keyCrypter", keyCrypter))
        (§ if includePrivate)
        (§ block
            (§ expr helper.add(§ pars "encryptedPrivateKey", encryptedPrivateKey))
        )
        (§ expr helper.add(§ pars "isEncrypted", isEncrypted(§ pars )))
        (§ expr helper.add(§ pars "isPubKeyOnly", isPubKeyOnly(§ pars )))
        (§ return (§ expr helper.toString(§ pars )))
    )

    #_public
    (§ method #_"void" (§ fn formatKeyWithAddress) [#_"boolean" (§ name includePrivateKeys), #_"StringBuilder" (§ name sb), #_"NetworkParameters" (§ name params)])
    (§ block
        #_final
        (§ var #_"Address" (§ name address) (§ expr toAddress(§ pars params)))
        (§ expr sb.append(§ pars "  addr:"))
        (§ expr sb.append(§ pars address.toString(§ pars )))
        (§ expr sb.append(§ pars "  hash160:"))
        (§ expr sb.append(§ pars Utils/HEX.encode(§ pars getPubKeyHash(§ pars ))))
        (§ if (§ expr 0 < creationTimeSeconds))
        (§ block
            (§ expr sb.append(§ pars "  creationTimeSeconds:").append(§ pars creationTimeSeconds))
        )
        (§ expr sb.append(§ pars "\n"))
        (§ if includePrivateKeys)
        (§ block
            (§ expr sb.append(§ pars "  "))
            (§ expr sb.append(§ pars toStringWithPrivate(§ pars params)))
            (§ expr sb.append(§ pars "\n"))
        )
        (§ void nil)
    )
)

#_(ns org.bitcoinj.core #_"EmptyMessage"
    (:import [java.io IOException OutputStream]))

;;;
 ; <p>Parent class for header only messages that don't have a payload.
 ; Currently this includes getaddr, verack and special bitcoinj class UnknownMessage.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
(§ class #_"EmptyMessage" (§ extends #_"Message")
    #_public
    (§ constructor #_"EmptyMessage" [])
    (§ block
        (§ ass (§ name length) 0)
        (§ void this)
    )

    #_public
    (§ constructor #_"EmptyMessage" [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ super (§ pars params))
        (§ ass (§ name length) 0)
        (§ void this)
    )

    #_public
    (§ constructor #_"EmptyMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"int" (§ name offset)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, offset))
        (§ ass (§ name length) 0)
        (§ void this)
    )

    #_override
    #_protected
    #_final
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"byte[]" (§ fn bitcoinSerialize) [])
    (§ block
        (§ return (§ new #_"byte[]" (§ count 0)))
    )
)

#_(ns org.bitcoinj.core #_"FilteredBlock"
    (:import [java.io IOException OutputStream]
             [java.util *])
    (:import [com.google.common.base Objects]))

;;;
 ; <p>A FilteredBlock is used to relay a block with its transactions filtered using a {@link BloomFilter}.  It consists
 ; of the block header and a {@link PartialMerkleTree} which contains the transactions which matched the filter.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"FilteredBlock" (§ extends #_"Message")
    #_private
    (§ field #_"Block" (§ name header))

    #_private
    (§ field #_"PartialMerkleTree" (§ name merkleTree))
    #_private
    (§ field #_"List<Sha256Hash>" (§ name cachedTransactionHashes))

    ;; A set of transactions whose hashes are a subset of getTransactionHashes().
    ;; These were relayed as a part of the filteredblock getdata, i.e. likely weren't previously received as loose transactions.
    #_private
    (§ field #_"Map<Sha256Hash, Transaction>" (§ name associatedTransactions) (§ new #_"HashMap<>" (§ pars )))

    #_public
    (§ constructor #_"FilteredBlock" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payloadBytes)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payloadBytes, 0))
        (§ void this)
    )

    #_public
    (§ constructor #_"FilteredBlock" [#_"NetworkParameters" (§ name params), #_"Block" (§ name header), #_"PartialMerkleTree" (§ name pmt)])
    (§ block
        (§ super (§ pars params))
        (§ ass (§ name this.header) header)
        (§ ass (§ name this.merkleTree) pmt)
        (§ void this)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ if (§ expr header.transactions == nil))
        (§ block
            (§ expr header.bitcoinSerializeToStream(§ pars stream))
        )
        (§ else )
        (§ block
            (§ expr header.cloneAsHeader(§ pars ).bitcoinSerializeToStream(§ pars stream))
        )
        (§ expr merkleTree.bitcoinSerializeToStream(§ pars stream))
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ var #_"byte[]" (§ name headerBytes) (§ new #_"byte[]" (§ count Block/HEADER_SIZE)))
        (§ expr System/arraycopy(§ pars payload, 0, headerBytes, 0, Block/HEADER_SIZE))
        (§ ass (§ name header) (§ expr params.getDefaultSerializer(§ pars ).makeBlock(§ pars headerBytes)))

        (§ ass (§ name merkleTree) (§ new #_"PartialMerkleTree" (§ pars params, payload, Block/HEADER_SIZE)))

        (§ ass (§ name length) (§ expr Block/HEADER_SIZE + merkleTree.getMessageSize(§ pars )))
        (§ void nil)
    )

    ;;;
     ; Gets a list of leaf hashes which are contained in the partial merkle tree in this filtered block.
     ;
     ; @throws ProtocolException if the partial merkle block is invalid or the merkle root of the partial merkle block doesnt match the block header.
     ;;
    #_public
    (§ method #_"List<Sha256Hash>" (§ fn getTransactionHashes) [])
        (§ throws #_"VerificationException")
    (§ block
        (§ if (§ expr cachedTransactionHashes != nil))
        (§ block
            (§ return (§ expr Collections/unmodifiableList(§ pars cachedTransactionHashes)))
        )

        (§ var #_"List<Sha256Hash>" (§ name hashesMatched) (§ new #_"LinkedList<>" (§ pars )))
        (§ if (§ expr header.getMerkleRoot(§ pars ).equals(§ pars merkleTree.getTxnHashAndMerkleRoot(§ pars hashesMatched))))
        (§ block
            (§ ass (§ name cachedTransactionHashes) hashesMatched)
            (§ return (§ expr Collections/unmodifiableList(§ pars cachedTransactionHashes)))
        )

        (§ throw (§ new #_"VerificationException" (§ pars "Merkle root of block header does not match merkle root of partial merkle tree.")))
    )

    ;;;
     ; Gets a copy of the block header.
     ;;
    #_public
    (§ method #_"Block" (§ fn getBlockHeader) [])
    (§ block
        (§ return (§ expr header.cloneAsHeader(§ pars )))
    )

    ;;; Gets the hash of the block represented in this FilteredBlock. ;;
    #_override
    #_public
    (§ method #_"Sha256Hash" (§ fn getHash) [])
    (§ block
        (§ return (§ expr header.getHash(§ pars )))
    )

    ;;;
     ; Provide this FilteredBlock with a transaction which is in its Merkle tree.
     ; @return false if the tx is not relevant to this FilteredBlock.
     ;;
    #_public
    (§ method #_"boolean" (§ fn provideTransaction) [#_"Transaction" (§ name tx)])
        (§ throws #_"VerificationException")
    (§ block
        (§ var #_"Sha256Hash" (§ name hash) (§ expr tx.getHash(§ pars )))
        (§ if (§ expr getTransactionHashes(§ pars ).contains(§ pars hash)))
        (§ block
            (§ expr associatedTransactions.put(§ pars hash, tx))
            (§ return true)
        )
        (§ return false)
    )

    ;;; Returns the {@link PartialMerkleTree} object that provides the mathematical proof of transaction inclusion in the block. ;;
    #_public
    (§ method #_"PartialMerkleTree" (§ fn getPartialMerkleTree) [])
    (§ block
        (§ return merkleTree)
    )

    ;;; Gets the set of transactions which were provided using provideTransaction() which match in getTransactionHashes(). ;;
    #_public
    (§ method #_"Map<Sha256Hash, Transaction>" (§ fn getAssociatedTransactions) [])
    (§ block
        (§ return (§ expr Collections/unmodifiableMap(§ pars associatedTransactions)))
    )

    ;;; Number of transactions in this block, before it was filtered. ;;
    #_public
    (§ method #_"int" (§ fn getTransactionCount) [])
    (§ block
        (§ return (§ expr merkleTree.getTransactionCount(§ pars )))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"FilteredBlock" (§ name other) (§ expr (§ cast #_"FilteredBlock" o)))
        (§ return (§ expr associatedTransactions.equals(§ pars other.associatedTransactions) && header.equals(§ pars other.header) && merkleTree.equals(§ pars other.merkleTree)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars associatedTransactions, header, merkleTree)))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr "FilteredBlock{merkleTree=" + merkleTree + ", header=" + header + "}"))
    )
)

#_(ns org.bitcoinj.core #_"FullPrunedBlockChain"
    (:import [java.util ArrayList LinkedList List ListIterator Set]
             [java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.script Script]
             [org.bitcoinj.script.Script VerifyFlag]
             [org.bitcoinj.store BlockStoreException FullPrunedBlockStore]
             [org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>A FullPrunedBlockChain works in conjunction with a {@link FullPrunedBlockStore} to verify all the rules of the
 ; Bitcoin system, with the downside being a large cost in system resources.  Fully verifying means all unspent
 ; transaction outputs are stored.  Once a transaction output is spent and that spend is buried deep enough, the data
 ; related to it is deleted to ensure disk space usage doesn't grow forever.  For this reason a pruning node cannot
 ; serve the full block chain to other clients, but it nevertheless provides the same security guarantees as Bitcoin
 ; Core does.</p>
 ;;
#_public
(§ class #_"FullPrunedBlockChain" (§ extends #_"AbstractBlockChain")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"FullPrunedBlockChain"))))

    ;;;
     ; Keeps a map of block hashes to StoredBlocks.
     ;;
    #_protected
    #_final
    (§ field #_"FullPrunedBlockStore" (§ name blockStore))

    ;; Whether or not to execute scriptPubKeys before accepting a transaction (i.e. check signatures).
    #_private
    (§ field #_"boolean" (§ name runScripts) true)

    ;;;
     ; Constructs a block chain connected to the given wallet and store.  To obtain a {@link Wallet} you can construct
     ; one from scratch, or you can deserialize a saved wallet from disk using {@link Wallet#loadFromFile(java.io.File)}.
     ;;
    #_public
    (§ constructor #_"FullPrunedBlockChain" [#_"Context" (§ name context), #_"Wallet" (§ name wallet), #_"FullPrunedBlockStore" (§ name blockStore)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ this (§ pars context, new ArrayList<Wallet>(§ pars ), blockStore))
        (§ expr addWallet(§ pars wallet))
        (§ void this)
    )

    ;;;
     ; Constructs a block chain connected to the given wallet and store.  To obtain a {@link Wallet} you can construct
     ; one from scratch, or you can deserialize a saved wallet from disk using {@link Wallet#loadFromFile(java.io.File)}.
     ;;
    #_public
    (§ constructor #_"FullPrunedBlockChain" [#_"NetworkParameters" (§ name params), #_"Wallet" (§ name wallet), #_"FullPrunedBlockStore" (§ name blockStore)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ this (§ pars Context/getOrCreate(§ pars params), wallet, blockStore))
        (§ void this)
    )

    ;;;
     ; Constructs a block chain connected to the given store.
     ;;
    #_public
    (§ constructor #_"FullPrunedBlockChain" [#_"Context" (§ name context), #_"FullPrunedBlockStore" (§ name blockStore)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ this (§ pars context, new ArrayList<Wallet>(§ pars ), blockStore))
        (§ void this)
    )

    ;;;
     ; See {@link #FullPrunedBlockChain(Context, Wallet, FullPrunedBlockStore)}.
     ;;
    #_public
    (§ constructor #_"FullPrunedBlockChain" [#_"NetworkParameters" (§ name params), #_"FullPrunedBlockStore" (§ name blockStore)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ this (§ pars Context/getOrCreate(§ pars params), blockStore))
        (§ void this)
    )

    ;;;
     ; Constructs a block chain connected to the given list of wallets and a store.
     ;;
    #_public
    (§ constructor #_"FullPrunedBlockChain" [#_"Context" (§ name context), #_"List<Wallet>" (§ name listeners), #_"FullPrunedBlockStore" (§ name blockStore)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ super (§ pars context, listeners, blockStore))
        (§ ass (§ name this.blockStore) blockStore)
        ;; Ignore upgrading for now.
        (§ ass (§ name this.chainHead) (§ expr blockStore.getVerifiedChainHead(§ pars )))
        (§ void this)
    )

    ;;;
     ; See {@link #FullPrunedBlockChain(Context, List, FullPrunedBlockStore)}.
     ;;
    #_public
    (§ constructor #_"FullPrunedBlockChain" [#_"NetworkParameters" (§ name params), #_"List<Wallet>" (§ name listeners), #_"FullPrunedBlockStore" (§ name blockStore)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ this (§ pars Context/getOrCreate(§ pars params), listeners, blockStore))
        (§ void this)
    )

    #_override
    #_protected
    (§ method #_"StoredBlock" (§ fn addToBlockStore) [#_"StoredBlock" (§ name storedPrev), #_"Block" (§ name header), #_"TransactionOutputChanges" (§ name txOutChanges)])
        (§ throws #_"BlockStoreException", #_"VerificationException")
    (§ block
        (§ var #_"StoredBlock" (§ name newBlock) (§ expr storedPrev.build(§ pars header)))
        (§ expr blockStore.put(§ pars newBlock, new StoredUndoableBlock(§ pars newBlock.getHeader(§ pars ).getHash(§ pars ), txOutChanges)))
        (§ return newBlock)
    )

    #_override
    #_protected
    (§ method #_"StoredBlock" (§ fn addToBlockStore) [#_"StoredBlock" (§ name storedPrev), #_"Block" (§ name block)])
        (§ throws #_"BlockStoreException", #_"VerificationException")
    (§ block
        (§ var #_"StoredBlock" (§ name newBlock) (§ expr storedPrev.build(§ pars block)))
        (§ expr blockStore.put(§ pars newBlock, new StoredUndoableBlock(§ pars newBlock.getHeader(§ pars ).getHash(§ pars ), block.transactions)))
        (§ return newBlock)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn rollbackBlockStore) [#_"int" (§ name height)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ throw (§ new #_"BlockStoreException" (§ pars "Unsupported")))
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"boolean" (§ fn shouldVerifyTransactions) [])
    (§ block
        (§ return true)
    )

    ;;;
     ; Whether or not to run scripts whilst accepting blocks (i.e. checking signatures, for most transactions).
     ; If you're accepting data from an untrusted node, such as one found via the P2P network, this should be set
     ; to true (which is the default).  If you're downloading a chain from a node you control, script execution
     ; is redundant because you know the connected node won't relay bad data to you.  In that case it's safe to set
     ; this to false and obtain a significant speedup.
     ;;
    #_public
    (§ method #_"void" (§ fn setRunScripts) [#_"boolean" (§ name value)])
    (§ block
        (§ ass (§ name this.runScripts) value)
        (§ void nil)
    )

    ;; TODO: Remove lots of duplicated code in the two connectTransactions.

    ;; TODO: Execute in order of largest transaction (by input count) first.
    (§ field #_"ExecutorService" (§ name scriptVerificationExecutor) (§ expr Executors/newFixedThreadPool(§ pars Runtime/getRuntime(§ pars ).availableProcessors(§ pars ), new ContextPropagatingThreadFactory(§ pars "Script verification"))))

    ;;;
     ; A job submitted to the executor which verifies signatures.
     ;;
    #_private
    #_static
    (§ class #_"Verifier" (§ implements #_"Callable<VerificationException>")
        #_final
        (§ field #_"Transaction" (§ name tx))
        #_final
        (§ field #_"List<Script>" (§ name prevOutScripts))
        #_final
        (§ field #_"Set<VerifyFlag>" (§ name verifyFlags))

        #_public
        (§ constructor #_"Verifier" [#_final #_"Transaction" (§ name tx), #_final #_"List<Script>" (§ name prevOutScripts), #_final #_"Set<VerifyFlag>" (§ name verifyFlags)])
        (§ block
            (§ ass (§ name this.tx) tx)
            (§ ass (§ name this.prevOutScripts) prevOutScripts)
            (§ ass (§ name this.verifyFlags) verifyFlags)
            (§ void this)
        )

        #_nilable
        #_override
        #_public
        (§ method #_"VerificationException" (§ fn call) [])
            (§ throws #_"Exception")
        (§ block
            (§ try )
            (§ block
                (§ var #_"ListIterator<Script>" (§ name prevOutIt) (§ expr prevOutScripts.listIterator(§ pars )))
                (§ for (§ var #_"int" (§ name index) 0) :for (§ expr index < tx.getInputs(§ pars ).size(§ pars )) :for (§ ass (§ name index) (§ expr index + 1)))
                (§ block
                    (§ expr tx.getInputs(§ pars ).get(§ pars index).getScriptSig(§ pars ).correctlySpends(§ pars tx, index, prevOutIt.next(§ pars ), verifyFlags))
                )
                (§ return nil)
            )
            (§ catch #_"VerificationException" (§ name e))
            (§ block
                (§ return e)
            )
        )
    )

    ;;;
     ; Get the {@link Script} from the script bytes or return Script of empty byte array.
     ;;
    #_private
    (§ method #_"Script" (§ fn getScript) [#_"byte[]" (§ name scriptBytes)])
    (§ block
        (§ try )
        (§ block
            (§ return (§ new #_"Script" (§ pars scriptBytes)))
        )
        (§ catch #_"Exception" (§ name _))
        (§ block
            (§ return (§ new #_"Script" (§ pars (§ new #_"byte[]" (§ count 0)))))
        )
    )

    ;;;
     ; Get the address from the {@link Script} if it exists, otherwise return empty string "".
     ;
     ; @param script The script.
     ; @return The address.
     ;;
    #_private
    (§ method #_"String" (§ fn getScriptAddress) [#_nilable #_"Script" (§ name script)])
    (§ block
        (§ var #_"String" (§ name address) (§ expr ""))
        (§ try )
        (§ block
            (§ if (§ expr script != nil))
            (§ block
                (§ ass (§ name address) (§ expr script.getToAddress(§ pars params, true).toString(§ pars )))
            )
        )
        (§ catch #_"Exception" (§ name _))
        (§ block
        )
        (§ return address)
    )

    #_override
    #_protected
    (§ method #_"TransactionOutputChanges" (§ fn connectTransactions) [#_"int" (§ name height), #_"Block" (§ name block)])
        (§ throws #_"VerificationException", #_"BlockStoreException")
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ if (§ expr block.transactions == nil))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars "connectTransactions called with Block that didn't have transactions!")))
        )
        (§ if (§ expr (§ not params.passesCheckpoint(§ pars height, block.getHash(§ pars )))))
        (§ block
            (§ throw (§ new #_"VerificationException" (§ pars "Block failed checkpoint lockin at " + height)))
        )

        (§ expr blockStore.beginDatabaseBatchWrite(§ pars ))

        (§ var #_"LinkedList<UTXO>" (§ name txOutsSpent) (§ new #_"LinkedList<>" (§ pars )))
        (§ var #_"LinkedList<UTXO>" (§ name txOutsCreated) (§ new #_"LinkedList<>" (§ pars )))
        (§ var #_"long" (§ name sigOps) 0)

        (§ if (§ expr scriptVerificationExecutor.isShutdown(§ pars )))
        (§ block
            (§ ass (§ name scriptVerificationExecutor) (§ expr Executors/newFixedThreadPool(§ pars Runtime/getRuntime(§ pars ).availableProcessors(§ pars ))))
        )

        (§ var #_"List<Future<VerificationException>>" (§ name listScriptVerificationResults) (§ new #_"ArrayList<>" (§ pars block.transactions.size(§ pars ))))
        (§ try )
        (§ block
            (§ if (§ expr (§ not params.isCheckpoint(§ pars height))))
            (§ block
                ;; BIP30 violator blocks are ones that contain a duplicated transaction.  They are all in the checkpoints list
                ;; and we therefore only check non-checkpoints for duplicated transactions here.  See the BIP30 document
                ;; for more details on this: https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki
                (§ for (§ var #_"Transaction" (§ name tx)) :for (§ expr block.transactions))
                (§ block
                    #_final
                    (§ var #_"Set<VerifyFlag>" (§ name verifyFlags) (§ expr params.getTransactionVerificationFlags(§ pars block, tx, getVersionTally(§ pars ), height)))
                    (§ var #_"Sha256Hash" (§ name hash) (§ expr tx.getHash(§ pars )))
                    ;; If we already have unspent outputs for this hash, we saw the tx already.
                    ;; Either the block is being added twice (bug) or the block is a BIP30 violator.
                    (§ if (§ expr blockStore.hasUnspentOutputs(§ pars hash, tx.getOutputs(§ pars ).size(§ pars ))))
                    (§ block
                        (§ throw (§ new #_"VerificationException" (§ pars "Block failed BIP30 test!")))
                    )
                    ;; We already check non-BIP16 sigops in Block.verifyTransactions(true).
                    (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag/P2SH)))
                    (§ block
                        (§ ass (§ name sigOps) (§ expr sigOps + tx.getSigOpCount(§ pars )))
                    )
                )
            )
            (§ var #_"Coin" (§ name totalFees) (§ expr Coin/ZERO))
            (§ var #_"Coin" (§ name coinbaseValue) nil)
            (§ for (§ var #_final Transaction tx) :for (§ expr block.transactions))
            (§ block
                (§ var #_"boolean" (§ name isCoinBase) (§ expr tx.isCoinBase(§ pars )))
                (§ var #_"Coin" (§ name valueIn) (§ expr Coin/ZERO))
                (§ var #_"Coin" (§ name valueOut) (§ expr Coin/ZERO))
                #_final
                (§ var #_"List<Script>" (§ name prevOutScripts) (§ new #_"LinkedList<>" (§ pars )))
                #_final
                (§ var #_"Set<VerifyFlag>" (§ name verifyFlags) (§ expr params.getTransactionVerificationFlags(§ pars block, tx, getVersionTally(§ pars ), height)))
                (§ if (§ expr (§ not isCoinBase)))
                (§ block
                    ;; For each input of the transaction remove the corresponding output from the set of unspent outputs.
                    (§ for (§ var #_"int" (§ name index) 0) :for (§ expr index < tx.getInputs(§ pars ).size(§ pars )) :for (§ ass (§ name index) (§ expr index + 1)))
                    (§ block
                        (§ var #_"TransactionInput" (§ name in) (§ expr tx.getInputs(§ pars ).get(§ pars index)))
                        (§ var #_"UTXO" (§ name prevOut) (§ expr blockStore.getTransactionOutput(§ pars in.getOutpoint(§ pars ).getHash(§ pars ), in.getOutpoint(§ pars ).getIndex(§ pars ))))
                        (§ if (§ expr prevOut == nil))
                        (§ block
                            (§ throw (§ new #_"VerificationException" (§ pars "Attempted to spend a non-existent or already spent output!")))
                        )
                        ;; Coinbases can't be spent until they mature, to avoid re-orgs destroying entire transaction chains.
                        ;; The assumption is there will ~never be re-orgs deeper than the spendable coinbase chain depth.
                        (§ if (§ expr prevOut.isCoinbase(§ pars )))
                        (§ block
                            (§ if (§ expr height - prevOut.getHeight(§ pars ) < params.getSpendableCoinbaseDepth(§ pars )))
                            (§ block
                                (§ throw (§ new #_"VerificationException" (§ pars "Tried to spend coinbase at depth " + (§ expr height - prevOut.getHeight(§ pars )))))
                            )
                        )
                        ;; TODO: Check we're not spending the genesis transaction here. Bitcoin Core won't allow it.
                        (§ ass (§ name valueIn) (§ expr valueIn.add(§ pars prevOut.getValue(§ pars ))))
                        (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag/P2SH)))
                        (§ block
                            (§ if (§ expr prevOut.getScript(§ pars ).isPayToScriptHash(§ pars )))
                            (§ block
                                (§ ass (§ name sigOps) (§ expr sigOps + Script/getP2SHSigOpCount(§ pars in.getScriptBytes(§ pars ))))
                            )
                            (§ if (§ expr Block/MAX_BLOCK_SIGOPS < sigOps))
                            (§ block
                                (§ throw (§ new #_"VerificationException" (§ pars "Too many P2SH SigOps in block")))
                            )
                        )

                        (§ expr prevOutScripts.add(§ pars prevOut.getScript(§ pars )))
                        (§ expr blockStore.removeUnspentTransactionOutput(§ pars prevOut))
                        (§ expr txOutsSpent.add(§ pars prevOut))
                    )
                )
                (§ var #_"Sha256Hash" (§ name hash) (§ expr tx.getHash(§ pars )))
                (§ for (§ var #_"TransactionOutput" (§ name out)) :for (§ expr tx.getOutputs(§ pars )))
                (§ block
                    (§ ass (§ name valueOut) (§ expr valueOut.add(§ pars out.getValue(§ pars ))))
                    ;; For each output, add it to the set of unspent outputs so it can be consumed in future.
                    (§ var #_"Script" (§ name script) (§ expr getScript(§ pars out.getScriptBytes(§ pars ))))
                    (§ var #_"UTXO" (§ name newOut) (§ new #_"UTXO" (§ pars hash, out.getIndex(§ pars ), out.getValue(§ pars ), height, isCoinBase, script, getScriptAddress(§ pars script))))
                    (§ expr blockStore.addUnspentTransactionOutput(§ pars newOut))
                    (§ expr txOutsCreated.add(§ pars newOut))
                )
                ;; All values were already checked for being non-negative (as it is verified in Transaction.verify()),
                ;; but we check again here just for defence in depth.  Transactions with zero output value are OK.
                (§ if (§ expr valueOut.signum(§ pars ) < 0 || 0 < valueOut.compareTo(§ pars params.getMaxMoney(§ pars ))))
                (§ block
                    (§ throw (§ new #_"VerificationException" (§ pars "Transaction output value out of range")))
                )

                (§ if isCoinBase)
                (§ block
                    (§ ass (§ name coinbaseValue) valueOut)
                )
                (§ else )
                (§ block
                    (§ if (§ expr valueIn.compareTo(§ pars valueOut) < 0 || 0 < valueIn.compareTo(§ pars params.getMaxMoney(§ pars ))))
                    (§ block
                        (§ throw (§ new #_"VerificationException" (§ pars "Transaction input value out of range")))
                    )
                    (§ ass (§ name totalFees) (§ expr totalFees.add(§ pars valueIn.subtract(§ pars valueOut))))
                )

                (§ if (§ expr (§ not isCoinBase) && runScripts))
                (§ block
                    ;; Because correctlySpends modifies transactions, this must come after we are done with tx.
                    (§ var #_"FutureTask<VerificationException>" (§ name future) (§ new #_"FutureTask<>" (§ pars (§ new #_"Verifier" (§ pars tx, prevOutScripts, verifyFlags)))))
                    (§ expr scriptVerificationExecutor.execute(§ pars future))
                    (§ expr listScriptVerificationResults.add(§ pars future))
                )
            )
            (§ if (§ expr 0 < totalFees.compareTo(§ pars params.getMaxMoney(§ pars )) || block.getBlockInflation(§ pars height).add(§ pars totalFees).compareTo(§ pars coinbaseValue) < 0))
            (§ block
                (§ throw (§ new #_"VerificationException" (§ pars "Transaction fees out of range")))
            )

            (§ for (§ var #_"Future<VerificationException>" (§ name future)) :for listScriptVerificationResults)
            (§ block
                (§ var #_"VerificationException" (§ name e))
                (§ try )
                (§ block
                    (§ ass (§ name e) (§ expr future.get(§ pars )))
                )
                (§ catch #_"InterruptedException" (§ name ie))
                (§ block
                    (§ throw (§ new #_"RuntimeException" (§ pars ie))) ;; Shouldn't happen.
                )
                (§ catch #_"ExecutionException" (§ name ee))
                (§ block
                    (§ expr log.error(§ pars "Script.correctlySpends threw a non-normal exception: " + ee.getCause(§ pars )))
                    (§ throw (§ new #_"VerificationException" (§ pars "Bug in Script.correctlySpends, likely script malformed in some new and interesting way.", ee)))
                )
                (§ if (§ expr e != nil))
                (§ block
                    (§ throw e)
                )
            )
        )
        (§ catch #_"VerificationException" (§ name e))
        (§ block
            (§ expr scriptVerificationExecutor.shutdownNow(§ pars ))
            (§ expr blockStore.abortDatabaseBatchWrite(§ pars ))
            (§ throw e)
        )
        (§ catch #_"BlockStoreException" (§ name e))
        (§ block
            (§ expr scriptVerificationExecutor.shutdownNow(§ pars ))
            (§ expr blockStore.abortDatabaseBatchWrite(§ pars ))
            (§ throw e)
        )

        (§ return (§ new #_"TransactionOutputChanges" (§ pars txOutsCreated, txOutsSpent)))
    )

    #_override
    ;;;
     ; Used during reorgs to connect a block previously on a fork.
     ;;
    #_protected
    #_synchronized
    (§ method #_"TransactionOutputChanges" (§ fn connectTransactions) [#_"StoredBlock" (§ name newBlock)])
        (§ throws #_"VerificationException", #_"BlockStoreException", #_"PrunedException")
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ if (§ expr (§ not params.passesCheckpoint(§ pars newBlock.getHeight(§ pars ), newBlock.getHeader(§ pars ).getHash(§ pars )))))
        (§ block
            (§ throw (§ new #_"VerificationException" (§ pars "Block failed checkpoint lockin at " + newBlock.getHeight(§ pars ))))
        )

        (§ expr blockStore.beginDatabaseBatchWrite(§ pars ))
        (§ var #_"StoredUndoableBlock" (§ name block) (§ expr blockStore.getUndoBlock(§ pars newBlock.getHeader(§ pars ).getHash(§ pars ))))
        (§ if (§ expr block == nil))
        (§ block
            ;; We're trying to re-org too deep and the data needed has been deleted.
            (§ expr blockStore.abortDatabaseBatchWrite(§ pars ))
            (§ throw (§ new #_"PrunedException" (§ pars newBlock.getHeader(§ pars ).getHash(§ pars ))))
        )

        (§ var #_"TransactionOutputChanges" (§ name txOutChanges))
        (§ try )
        (§ block
            (§ var #_"List<Transaction>" (§ name transactions) (§ expr block.getTransactions(§ pars )))
            (§ if (§ expr transactions != nil))
            (§ block
                (§ var #_"LinkedList<UTXO>" (§ name txOutsSpent) (§ new #_"LinkedList<>" (§ pars )))
                (§ var #_"LinkedList<UTXO>" (§ name txOutsCreated) (§ new #_"LinkedList<>" (§ pars )))
                (§ var #_"long" (§ name sigOps) 0)

                (§ if (§ expr (§ not params.isCheckpoint(§ pars newBlock.getHeight(§ pars )))))
                (§ block
                    (§ for (§ var #_"Transaction" (§ name tx)) :for transactions)
                    (§ block
                        (§ var #_"Sha256Hash" (§ name hash) (§ expr tx.getHash(§ pars )))
                        (§ if (§ expr blockStore.hasUnspentOutputs(§ pars hash, tx.getOutputs(§ pars ).size(§ pars ))))
                        (§ block
                            (§ throw (§ new #_"VerificationException" (§ pars "Block failed BIP30 test!")))
                        )
                    )
                )

                (§ var #_"Coin" (§ name totalFees) (§ expr Coin/ZERO))
                (§ var #_"Coin" (§ name coinbaseValue) nil)

                (§ if (§ expr scriptVerificationExecutor.isShutdown(§ pars )))
                (§ block
                    (§ ass (§ name scriptVerificationExecutor) (§ expr Executors/newFixedThreadPool(§ pars Runtime/getRuntime(§ pars ).availableProcessors(§ pars ))))
                )

                (§ var #_"List<Future<VerificationException>>" (§ name listScriptVerificationResults) (§ new #_"ArrayList<>" (§ pars transactions.size(§ pars ))))
                (§ for (§ var #_final Transaction tx) :for transactions)
                (§ block
                    #_final
                    (§ var #_"Set<VerifyFlag>" (§ name verifyFlags) (§ expr params.getTransactionVerificationFlags(§ pars newBlock.getHeader(§ pars ), tx, getVersionTally(§ pars ), Integer/SIZE)))
                    (§ var #_"boolean" (§ name isCoinBase) (§ expr tx.isCoinBase(§ pars )))
                    (§ var #_"Coin" (§ name valueIn) (§ expr Coin/ZERO))
                    (§ var #_"Coin" (§ name valueOut) (§ expr Coin/ZERO))
                    #_final
                    (§ var #_"List<Script>" (§ name prevOutScripts) (§ new #_"LinkedList<>" (§ pars )))

                    (§ if (§ expr (§ not isCoinBase)))
                    (§ block
                        (§ for (§ var #_"int" (§ name index) 0) :for (§ expr index < tx.getInputs(§ pars ).size(§ pars )) :for (§ ass (§ name index) (§ expr index + 1)))
                        (§ block
                            #_final
                            (§ var #_"TransactionInput" (§ name in) (§ expr tx.getInputs(§ pars ).get(§ pars index)))
                            #_final
                            (§ var #_"UTXO" (§ name prevOut) (§ expr blockStore.getTransactionOutput(§ pars in.getOutpoint(§ pars ).getHash(§ pars ), in.getOutpoint(§ pars ).getIndex(§ pars ))))
                            (§ if (§ expr prevOut == nil))
                            (§ block
                                (§ throw (§ new #_"VerificationException" (§ pars "Attempted spend of a non-existent or already spent output!")))
                            )
                            (§ if (§ expr prevOut.isCoinbase(§ pars ) && newBlock.getHeight(§ pars ) - prevOut.getHeight(§ pars ) < params.getSpendableCoinbaseDepth(§ pars )))
                            (§ block
                                (§ throw (§ new #_"VerificationException" (§ pars "Tried to spend coinbase at depth " + (§ expr newBlock.getHeight(§ pars ) - prevOut.getHeight(§ pars )))))
                            )
                            (§ ass (§ name valueIn) (§ expr valueIn.add(§ pars prevOut.getValue(§ pars ))))
                            (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag/P2SH)))
                            (§ block
                                (§ if (§ expr prevOut.getScript(§ pars ).isPayToScriptHash(§ pars )))
                                (§ block
                                    (§ ass (§ name sigOps) (§ expr sigOps + Script/getP2SHSigOpCount(§ pars in.getScriptBytes(§ pars ))))
                                )
                                (§ if (§ expr sigOps > Block/MAX_BLOCK_SIGOPS))
                                (§ block
                                    (§ throw (§ new #_"VerificationException" (§ pars "Too many P2SH SigOps in block")))
                                )
                            )

                            ;; TODO: Enforce DER signature format.

                            (§ expr prevOutScripts.add(§ pars prevOut.getScript(§ pars )))

                            (§ expr blockStore.removeUnspentTransactionOutput(§ pars prevOut))
                            (§ expr txOutsSpent.add(§ pars prevOut))
                        )
                    )
                    (§ var #_"Sha256Hash" (§ name hash) (§ expr tx.getHash(§ pars )))
                    (§ for (§ var #_"TransactionOutput" (§ name out)) :for (§ expr tx.getOutputs(§ pars )))
                    (§ block
                        (§ ass (§ name valueOut) (§ expr valueOut.add(§ pars out.getValue(§ pars ))))
                        (§ var #_"Script" (§ name script) (§ expr getScript(§ pars out.getScriptBytes(§ pars ))))
                        (§ var #_"UTXO" (§ name newOut) (§ new #_"UTXO" (§ pars hash, out.getIndex(§ pars ), out.getValue(§ pars ), newBlock.getHeight(§ pars ), isCoinBase, script, getScriptAddress(§ pars script))))
                        (§ expr blockStore.addUnspentTransactionOutput(§ pars newOut))
                        (§ expr txOutsCreated.add(§ pars newOut))
                    )
                    ;; All values were already checked for being non-negative (as it is verified in Transaction.verify())
                    ;; but we check again here just for defence in depth.  Transactions with zero output value are OK.
                    (§ if (§ expr valueOut.signum(§ pars ) < 0 || 0 < valueOut.compareTo(§ pars params.getMaxMoney(§ pars ))))
                    (§ block
                        (§ throw (§ new #_"VerificationException" (§ pars "Transaction output value out of range")))
                    )

                    (§ if isCoinBase)
                    (§ block
                        (§ ass (§ name coinbaseValue) valueOut)
                    )
                    (§ else )
                    (§ block
                        (§ if (§ expr valueIn.compareTo(§ pars valueOut) < 0 || 0 < valueIn.compareTo(§ pars params.getMaxMoney(§ pars ))))
                        (§ block
                            (§ throw (§ new #_"VerificationException" (§ pars "Transaction input value out of range")))
                        )
                        (§ ass (§ name totalFees) (§ expr totalFees.add(§ pars valueIn.subtract(§ pars valueOut))))
                    )

                    (§ if (§ expr (§ not isCoinBase)))
                    (§ block
                        ;; Because correctlySpends modifies transactions, this must come after we are done with tx.
                        (§ var #_"FutureTask<VerificationException>" (§ name future) (§ new #_"FutureTask<>" (§ pars (§ new #_"Verifier" (§ pars tx, prevOutScripts, verifyFlags)))))
                        (§ expr scriptVerificationExecutor.execute(§ pars future))
                        (§ expr listScriptVerificationResults.add(§ pars future))
                    )
                )
                (§ if (§ expr 0 < totalFees.compareTo(§ pars params.getMaxMoney(§ pars )) || newBlock.getHeader(§ pars ).getBlockInflation(§ pars newBlock.getHeight(§ pars )).add(§ pars totalFees).compareTo(§ pars coinbaseValue) < 0))
                (§ block
                    (§ throw (§ new #_"VerificationException" (§ pars "Transaction fees out of range")))
                )

                (§ ass (§ name txOutChanges) (§ new #_"TransactionOutputChanges" (§ pars txOutsCreated, txOutsSpent)))
                (§ for (§ var #_"Future<VerificationException>" (§ name future)) :for listScriptVerificationResults)
                (§ block
                    (§ var #_"VerificationException" (§ name e))
                    (§ try )
                    (§ block
                        (§ ass (§ name e) (§ expr future.get(§ pars )))
                    )
                    (§ catch #_"InterruptedException" (§ name ie))
                    (§ block
                        (§ throw (§ new #_"RuntimeException" (§ pars ie))) ;; Shouldn't happen.
                    )
                    (§ catch #_"ExecutionException" (§ name ee))
                    (§ block
                        (§ expr log.error(§ pars "Script.correctlySpends threw a non-normal exception: " + ee.getCause(§ pars )))
                        (§ throw (§ new #_"VerificationException" (§ pars "Bug in Script.correctlySpends, likely script malformed in some new and interesting way.", ee)))
                    )
                    (§ if (§ expr e != nil))
                    (§ block
                        (§ throw e)
                    )
                )
            )
            (§ else )
            (§ block
                (§ ass (§ name txOutChanges) (§ expr block.getTxOutChanges(§ pars )))
                (§ if (§ expr (§ not params.isCheckpoint(§ pars newBlock.getHeight(§ pars )))))
                (§ block
                    (§ for (§ var #_"UTXO" (§ name out)) :for (§ expr txOutChanges.txOutsCreated))
                    (§ block
                        (§ var #_"Sha256Hash" (§ name hash) (§ expr out.getHash(§ pars )))
                        (§ if (§ expr blockStore.getTransactionOutput(§ pars hash, out.getIndex(§ pars )) != nil))
                        (§ block
                            (§ throw (§ new #_"VerificationException" (§ pars "Block failed BIP30 test!")))
                        )
                    )
                )
                (§ for (§ var #_"UTXO" (§ name out)) :for (§ expr txOutChanges.txOutsCreated))
                (§ block
                    (§ expr blockStore.addUnspentTransactionOutput(§ pars out))
                )
                (§ for (§ var #_"UTXO" (§ name out)) :for (§ expr txOutChanges.txOutsSpent))
                (§ block
                    (§ expr blockStore.removeUnspentTransactionOutput(§ pars out))
                )
            )
        )
        (§ catch #_"VerificationException" (§ name e))
        (§ block
            (§ expr scriptVerificationExecutor.shutdownNow(§ pars ))
            (§ expr blockStore.abortDatabaseBatchWrite(§ pars ))
            (§ throw e)
        )
        (§ catch #_"BlockStoreException" (§ name e))
        (§ block
            (§ expr scriptVerificationExecutor.shutdownNow(§ pars ))
            (§ expr blockStore.abortDatabaseBatchWrite(§ pars ))
            (§ throw e)
        )
        (§ return txOutChanges)
    )

    ;;;
     ; This is broken for blocks that do not pass BIP30, so all BIP30-failing blocks which are allowed to fail BIP30
     ; must be checkpointed.
     ;;
    #_override
    #_protected
    (§ method #_"void" (§ fn disconnectTransactions) [#_"StoredBlock" (§ name oldBlock)])
        (§ throws #_"PrunedException", #_"BlockStoreException")
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ expr blockStore.beginDatabaseBatchWrite(§ pars ))
        (§ try )
        (§ block
            (§ var #_"StoredUndoableBlock" (§ name undoBlock) (§ expr blockStore.getUndoBlock(§ pars oldBlock.getHeader(§ pars ).getHash(§ pars ))))
            (§ if (§ expr undoBlock == nil))
            (§ block
                (§ throw (§ new #_"PrunedException" (§ pars oldBlock.getHeader(§ pars ).getHash(§ pars ))))
            )

            (§ var #_"TransactionOutputChanges" (§ name txOutChanges) (§ expr undoBlock.getTxOutChanges(§ pars )))
            (§ for (§ var #_"UTXO" (§ name out)) :for (§ expr txOutChanges.txOutsSpent))
            (§ block
                (§ expr blockStore.addUnspentTransactionOutput(§ pars out))
            )
            (§ for (§ var #_"UTXO" (§ name out)) :for (§ expr txOutChanges.txOutsCreated))
            (§ block
                (§ expr blockStore.removeUnspentTransactionOutput(§ pars out))
            )
        )
        (§ catch #_"PrunedException" (§ name e))
        (§ block
            (§ expr blockStore.abortDatabaseBatchWrite(§ pars ))
            (§ throw e)
        )
        (§ catch #_"BlockStoreException" (§ name e))
        (§ block
            (§ expr blockStore.abortDatabaseBatchWrite(§ pars ))
            (§ throw e)
        )
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn doSetChainHead) [#_"StoredBlock" (§ name chainHead)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ expr blockStore.setVerifiedChainHead(§ pars chainHead))
        (§ expr blockStore.commitDatabaseBatchWrite(§ pars ))
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn notSettingChainHead) [])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr blockStore.abortDatabaseBatchWrite(§ pars ))
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"StoredBlock" (§ fn getStoredBlockInCurrentScope) [#_"Sha256Hash" (§ name hash)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ return (§ expr blockStore.getOnceUndoableStoredBlock(§ pars hash)))
    )
)

#_(ns org.bitcoinj.core #_"GetAddrMessage")

;;;
 ; <p>Represents the "getaddr" P2P protocol message, which requests network {@link AddressMessage}s from a peer.
 ; Not to be confused with {@link Address} which is sort of like an account number.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"GetAddrMessage" (§ extends #_"EmptyMessage")
    #_public
    (§ constructor #_"GetAddrMessage" [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ super (§ pars params))
        (§ void this)
    )
)

#_(ns org.bitcoinj.core #_"GetBlocksMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList List]))

;;;
 ; <p>Represents the "getblocks" P2P network message, which requests the hashes of the parts of the block chain we're missing.
 ; Those blocks can then be downloaded with a {@link GetDataMessage}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"GetBlocksMessage" (§ extends #_"Message")
    #_protected
    (§ field #_"long" (§ name version))
    #_protected
    (§ field #_"List<Sha256Hash>" (§ name locator))
    #_protected
    (§ field #_"Sha256Hash" (§ name stopHash))

    #_public
    (§ constructor #_"GetBlocksMessage" [#_"NetworkParameters" (§ name params), #_"List<Sha256Hash>" (§ name locator), #_"Sha256Hash" (§ name stopHash)])
    (§ block
        (§ super (§ pars params))

        (§ ass (§ name this.version) protocolVersion)
        (§ ass (§ name this.locator) locator)
        (§ ass (§ name this.stopHash) stopHash)
        (§ void this)
    )

    #_public
    (§ constructor #_"GetBlocksMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, 0))
        (§ void this)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ ass (§ name cursor) offset)
        (§ ass (§ name version) (§ expr readUint32(§ pars )))
        (§ var #_"int" (§ name startCount) (§ expr (§ cast #_"int" (§ expr readVarInt(§ pars )))))
        (§ if (§ expr 500 < startCount))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars "Number of locators cannot be > 500, received: " + startCount)))
        )

        (§ ass (§ name length) (§ expr cursor - offset + (§ expr (§ expr startCount + 1) * 32)))
        (§ ass (§ name locator) (§ new #_"ArrayList<>" (§ pars startCount)))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < startCount) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ expr locator.add(§ pars readHash(§ pars )))
        )
        (§ ass (§ name stopHash) (§ expr readHash(§ pars )))
        (§ void nil)
    )

    #_public
    (§ method #_"List<Sha256Hash>" (§ fn getLocator) [])
    (§ block
        (§ return locator)
    )

    #_public
    (§ method #_"Sha256Hash" (§ fn getStopHash) [])
    (§ block
        (§ return stopHash)
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr "getblocks: " + Utils/SPACE_JOINER.join(§ pars locator)))
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        ;; Version, for some reason.
        (§ expr Utils/uint32ToByteStreamLE(§ pars params.getProtocolVersionNum(§ pars NetworkParameters/ProtocolVersion/CURRENT), stream))
        ;; Then a vector of block hashes.  This is actually a "block locator", a set of block
        ;; identifiers that spans the entire chain with exponentially increasing gaps between
        ;; them, until we end up at the genesis block.  See CBlockLocator::Set().
        (§ expr stream.write(§ pars (§ new #_"VarInt" (§ pars locator.size(§ pars ))).encode(§ pars )))
        (§ for (§ var #_"Sha256Hash" (§ name hash)) :for locator)
        (§ block
            ;; Have to reverse as wire format is little endian.
            (§ expr stream.write(§ pars hash.getReversedBytes(§ pars )))
        )
        ;; Next, a block ID to stop at.
        (§ expr stream.write(§ pars stopHash.getReversedBytes(§ pars )))
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"GetBlocksMessage" (§ name other) (§ expr (§ cast #_"GetBlocksMessage" o)))
        (§ return (§ expr version == other.version && stopHash.equals(§ pars other.stopHash) && locator.size(§ pars ) == other.locator.size(§ pars ) && locator.containsAll(§ pars other.locator))) ;; ignores locator ordering
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ var #_"int" (§ name hashCode) (§ expr (§ cast #_"int" version) :xor "getblocks".hashCode(§ pars ) :xor stopHash.hashCode(§ pars )))
        (§ for (§ var #_"Sha256Hash" (§ name l)) :for locator)
        (§ block
            (§ ass (§ name hashCode) (§ expr hashCode :xor l.hashCode(§ pars ))) ;; ignores locator ordering
        )
        (§ return hashCode)
    )
)

#_(ns org.bitcoinj.core #_"GetDataMessage")

;;;
 ; <p>Represents the "getdata" P2P network message, which requests the contents of blocks or transactions given their hashes.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"GetDataMessage" (§ extends #_"ListMessage")
    #_public
    (§ constructor #_"GetDataMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payloadBytes)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payloadBytes))
        (§ void this)
    )

    ;;;
     ; Deserializes a 'getdata' message.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor #_"GetDataMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"MessageSerializer" (§ name serializer), #_"int" (§ name length)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, serializer, length))
        (§ void this)
    )

    #_public
    (§ constructor #_"GetDataMessage" [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ super (§ pars params))
        (§ void this)
    )

    #_public
    (§ method #_"void" (§ fn addTransaction) [#_"Sha256Hash" (§ name hash)])
    (§ block
        (§ expr addItem(§ pars (§ new #_"InventoryItem" (§ pars InventoryItem/Type/Transaction, hash))))
        (§ void nil)
    )

    #_public
    (§ method #_"void" (§ fn addBlock) [#_"Sha256Hash" (§ name hash)])
    (§ block
        (§ expr addItem(§ pars (§ new #_"InventoryItem" (§ pars InventoryItem/Type/Block, hash))))
        (§ void nil)
    )

    #_public
    (§ method #_"void" (§ fn addFilteredBlock) [#_"Sha256Hash" (§ name hash)])
    (§ block
        (§ expr addItem(§ pars (§ new #_"InventoryItem" (§ pars InventoryItem/Type/FilteredBlock, hash))))
        (§ void nil)
    )

    #_public
    (§ method #_"Sha256Hash" (§ fn getHashOf) [#_"int" (§ name i)])
    (§ block
        (§ return (§ expr getItems(§ pars ).get(§ pars i).hash))
    )
)

#_(ns org.bitcoinj.core #_"GetHeadersMessage"
    (:import [java.util List]))

;;;
 ; <p>The "getheaders" command is structurally identical to "getblocks", but has different meaning.  On receiving this
 ; message a Bitcoin node returns matching blocks up to the limit, but without the bodies.  It is useful as an
 ; optimization: when your wallet does not contain any keys created before a particular time, you don't have to download
 ; the bodies for those blocks because you know there are no relevant transactions.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"GetHeadersMessage" (§ extends #_"GetBlocksMessage")
    #_public
    (§ constructor #_"GetHeadersMessage" [#_"NetworkParameters" (§ name params), #_"List<Sha256Hash>" (§ name locator), #_"Sha256Hash" (§ name stopHash)])
    (§ block
        (§ super (§ pars params, locator, stopHash))
        (§ void this)
    )

    #_public
    (§ constructor #_"GetHeadersMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload))
        (§ void this)
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr "getheaders: " + Utils/SPACE_JOINER.join(§ pars locator)))
    )

    ;;;
     ; Compares two getheaders messages.  Note that even though they are structurally identical a GetHeadersMessage
     ; will not compare equal to a GetBlocksMessage containing the same data.
     ;;
    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"GetHeadersMessage" (§ name other) (§ expr (§ cast #_"GetHeadersMessage" o)))
        (§ return (§ expr version == other.version && stopHash.equals(§ pars other.stopHash) && locator.size(§ pars ) == other.locator.size(§ pars ) && locator.containsAll(§ pars other.locator))) ;; ignores locator ordering
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ var #_"int" (§ name hashCode) (§ expr (§ cast #_"int" version) :xor "getheaders".hashCode(§ pars ) :xor stopHash.hashCode(§ pars )))
        (§ for (§ var #_"Sha256Hash" (§ name l)) :for locator)
        (§ block
            (§ ass (§ name hashCode) (§ expr hashCode :xor l.hashCode(§ pars ))) ;; ignores locator ordering
        )
        (§ return hashCode)
    )
)

#_(ns org.bitcoinj.core #_"HeadersMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Arrays List])
    (:import [org.slf4j Logger LoggerFactory]))

;;;
 ; <p>A protocol message that contains a repeated series of block headers, sent in response to the "getheaders" command.
 ; This is useful when you want to traverse the chain but know you don't care about the block contents, for example,
 ; because you have a freshly created wallet with no keys.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"HeadersMessage" (§ extends #_"Message")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"HeadersMessage"))))

    ;; The main client will never send us more than this number of headers.
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name MAX_HEADERS) 2000)

    #_private
    (§ field #_"List<Block>" (§ name blockHeaders))

    #_public
    (§ constructor #_"HeadersMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, 0))
        (§ void this)
    )

    #_public
    (§ constructor #_"HeadersMessage" [#_"NetworkParameters" (§ name params), #_"Block..." (§ name headers)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params))
        (§ ass (§ name blockHeaders) (§ expr Arrays/asList(§ pars headers)))
        (§ void this)
    )

    #_public
    (§ constructor #_"HeadersMessage" [#_"NetworkParameters" (§ name params), #_"List<Block>" (§ name headers)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params))
        (§ ass (§ name blockHeaders) headers)
        (§ void this)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ expr stream.write(§ pars (§ new #_"VarInt" (§ pars blockHeaders.size(§ pars ))).encode(§ pars )))
        (§ for (§ var #_"Block" (§ name header)) :for blockHeaders)
        (§ block
            (§ expr header.cloneAsHeader(§ pars ).bitcoinSerializeToStream(§ pars stream))
            (§ expr stream.write(§ pars 0))
        )
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ var #_"long" (§ name numHeaders) (§ expr readVarInt(§ pars )))
        (§ if (§ expr MAX_HEADERS < numHeaders))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars "Too many headers: got " + numHeaders + " which is larger than " + MAX_HEADERS)))
        )

        (§ ass (§ name blockHeaders) (§ new #_"ArrayList<>" (§ pars )))
        #_final
        (§ var #_"BitcoinSerializer" (§ name serializer) (§ expr this.params.getSerializer(§ pars true)))

        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numHeaders) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            #_final
            (§ var #_"Block" (§ name newBlockHeader) (§ expr serializer.makeBlock(§ pars payload, cursor, UNKNOWN_LENGTH)))
            (§ if (§ expr newBlockHeader.hasTransactions(§ pars )))
            (§ block
                (§ throw (§ new #_"ProtocolException" (§ pars "Block header does not end with a nil byte")))
            )

            (§ ass (§ name cursor) (§ expr cursor + newBlockHeader.optimalEncodingMessageSize))
            (§ expr blockHeaders.add(§ pars newBlockHeader))
        )

        (§ if (§ expr length == UNKNOWN_LENGTH))
        (§ block
            (§ ass (§ name length) (§ expr cursor - offset))
        )

        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numHeaders) :for (§ ass (§ name i) (§ expr i + 1)))
            (§ block
                (§ expr log.debug(§ pars this.blockHeaders.get(§ pars i).toString(§ pars )))
            )
        )
        (§ void nil)
    )

    #_public
    (§ method #_"List<Block>" (§ fn getBlockHeaders) [])
    (§ block
        (§ return blockHeaders)
    )
)

#_(ns org.bitcoinj.core #_"InsufficientMoneyException"
    (:import [com.google.common.base Preconditions]))

;;;
 ; Thrown to indicate that you don't have enough money available to perform the requested operation.
 ;;
#_public
(§ class #_"InsufficientMoneyException" (§ extends #_"Exception")
    ;;; Contains the number of satoshis that would have been required to complete the operation. ;;
    #_nilable
    #_public
    #_final
    (§ field #_"Coin" (§ name missing))

    #_protected
    (§ constructor #_"InsufficientMoneyException" [])
    (§ block
        (§ ass (§ name this.missing) nil)
        (§ void this)
    )

    #_public
    (§ constructor #_"InsufficientMoneyException" [#_"Coin" (§ name missing)])
    (§ block
        (§ this (§ pars missing, "Insufficient money,  missing " + missing.toFriendlyString(§ pars )))
        (§ void this)
    )

    #_public
    (§ constructor #_"InsufficientMoneyException" [#_"Coin" (§ name missing), #_"String" (§ name message)])
    (§ block
        (§ super (§ pars message))
        (§ ass (§ name this.missing) (§ expr Preconditions/checkNotNull(§ pars missing)))
        (§ void this)
    )
)

#_(ns org.bitcoinj.core #_"InventoryItem"
    (:import [com.google.common.base Objects]))

#_public
(§ class #_"InventoryItem"
    ;;;
     ; 4 byte uint32 type field + 32 byte hash
     ;;
    #_static
    #_final
    (§ field #_"int" (§ name MESSAGE_LENGTH) 36)

    #_public
    (§ enum #_"Type"
        (§ item Error)
        (§ item Transaction)
        (§ item Block)
        (§ item FilteredBlock)
    )

    #_public
    #_final
    (§ field #_"Type" (§ name type))
    #_public
    #_final
    (§ field #_"Sha256Hash" (§ name hash))

    #_public
    (§ constructor #_"InventoryItem" [#_"Type" (§ name type), #_"Sha256Hash" (§ name hash)])
    (§ block
        (§ ass (§ name this.type) type)
        (§ ass (§ name this.hash) hash)
        (§ void this)
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr type + ": " + hash))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"InventoryItem" (§ name other) (§ expr (§ cast #_"InventoryItem" o)))
        (§ return (§ expr type == other.type && hash.equals(§ pars other.hash)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars type, hash)))
    )
)

#_(ns org.bitcoinj.core #_"InventoryMessage"
    (:import [com.google.common.base Preconditions]))

;;;
 ; <p>Represents the "inv" P2P network message.  An inv contains a list of hashes of either blocks or transactions.
 ; It's a bandwidth optimization - on receiving some data, a (fully validating) peer sends every connected peer an inv
 ; containing the hash of what it saw.  It'll only transmit the full thing if a peer asks for it with a
 ; {@link GetDataMessage}.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"InventoryMessage" (§ extends #_"ListMessage")
    ;;; A hard coded constant in the protocol. ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name MAX_INV_SIZE) 50000)

    #_public
    (§ constructor #_"InventoryMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name bytes)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, bytes))
        (§ void this)
    )

    ;;;
     ; Deserializes an 'inv' message.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor #_"InventoryMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"MessageSerializer" (§ name serializer), #_"int" (§ name length)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, serializer, length))
        (§ void this)
    )

    #_public
    (§ constructor #_"InventoryMessage" [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ super (§ pars params))
        (§ void this)
    )

    #_public
    (§ method #_"void" (§ fn addBlock) [#_"Block" (§ name block)])
    (§ block
        (§ expr addItem(§ pars (§ new #_"InventoryItem" (§ pars InventoryItem/Type/Block, block.getHash(§ pars )))))
        (§ void nil)
    )

    #_public
    (§ method #_"void" (§ fn addTransaction) [#_"Transaction" (§ name tx)])
    (§ block
        (§ expr addItem(§ pars (§ new #_"InventoryItem" (§ pars InventoryItem/Type/Transaction, tx.getHash(§ pars )))))
        (§ void nil)
    )

    ;;; Creates a new inv message for the given transactions. ;;
    #_public
    #_static
    (§ method #_"InventoryMessage" (§ fn with) [#_"Transaction..." (§ name txs)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars 0 < txs.length))
        (§ var #_"InventoryMessage" (§ name result) (§ new #_"InventoryMessage" (§ pars txs[0].getParams(§ pars ))))
        (§ for (§ var #_"Transaction" (§ name tx)) :for txs)
        (§ block
            (§ expr result.addTransaction(§ pars tx))
        )
        (§ return result)
    )
)

#_(ns org.bitcoinj.core #_"ListMessage"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Collections List]))

;;;
 ; <p>Abstract superclass of classes with list based payload, i.e. InventoryMessage and GetDataMessage.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
(§ class #_"ListMessage" (§ extends #_"Message")
    #_public
    #_static
    #_final
    (§ field #_"long" (§ name MAX_INVENTORY_ITEMS) 50000)

    #_private
    (§ field #_"long" (§ name arrayLen))
    ;; For some reason the compiler complains if this is inside InventoryItem.
    #_protected
    (§ field #_"List<InventoryItem>" (§ name items))

    #_public
    (§ constructor #_"ListMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name bytes)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, bytes, 0))
        (§ void this)
    )

    #_public
    (§ constructor #_"ListMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"MessageSerializer" (§ name serializer), #_"int" (§ name length)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, 0, serializer, length))
        (§ void this)
    )

    #_public
    (§ constructor #_"ListMessage" [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ super (§ pars params))

        (§ ass (§ name items) (§ new #_"ArrayList<>" (§ pars )))
        (§ ass (§ name length) 1) ;; length of 0 varint
        (§ void this)
    )

    #_public
    (§ method #_"List<InventoryItem>" (§ fn getItems) [])
    (§ block
        (§ return (§ expr Collections/unmodifiableList(§ pars items)))
    )

    #_public
    (§ method #_"void" (§ fn addItem) [#_"InventoryItem" (§ name item)])
    (§ block
        (§ expr unCache(§ pars ))
        (§ ass (§ name length) (§ expr length - VarInt/sizeOf(§ pars items.size(§ pars ))))
        (§ expr items.add(§ pars item))
        (§ ass (§ name length) (§ expr length + VarInt/sizeOf(§ pars items.size(§ pars )) + InventoryItem/MESSAGE_LENGTH))
        (§ void nil)
    )

    #_public
    (§ method #_"void" (§ fn removeItem) [#_"int" (§ name index)])
    (§ block
        (§ expr unCache(§ pars ))
        (§ ass (§ name length) (§ expr length - VarInt/sizeOf(§ pars items.size(§ pars ))))
        (§ expr items.remove(§ pars index))
        (§ ass (§ name length) (§ expr length + VarInt/sizeOf(§ pars items.size(§ pars )) - InventoryItem/MESSAGE_LENGTH))
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ ass (§ name arrayLen) (§ expr readVarInt(§ pars )))
        (§ if (§ expr MAX_INVENTORY_ITEMS < arrayLen))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars "Too many items in INV message: " + arrayLen)))
        )
        (§ ass (§ name length) (§ cast #_"int" (§ expr cursor - offset + (§ expr arrayLen * InventoryItem/MESSAGE_LENGTH))))

        ;; An inv is vector<CInv> where CInv is int+hash.  The int is either 1 or 2 for tx or block.
        (§ ass (§ name items) (§ new #_"ArrayList<>" (§ pars (§ cast #_"int" arrayLen))))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < arrayLen) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ if (§ expr payload.length < cursor + InventoryItem/MESSAGE_LENGTH))
            (§ block
                (§ throw (§ new #_"ProtocolException" (§ pars "Ran off the end of the INV")))
            )

            (§ var #_"int" (§ name typeCode) (§ expr (§ cast #_"int" (§ expr readUint32(§ pars )))))
            (§ var #_"InventoryItem.Type" (§ name type))
            ;; see ppszTypeName in net.h
            (§ switch typeCode)
            (§ block
                (§ case 0)
                (§ block
                    (§ ass (§ name type) (§ expr InventoryItem/Type/Error))
                    (§ break )
                )
                (§ case 1)
                (§ block
                    (§ ass (§ name type) (§ expr InventoryItem/Type/Transaction))
                    (§ break )
                )
                (§ case 2)
                (§ block
                    (§ ass (§ name type) (§ expr InventoryItem/Type/Block))
                    (§ break )
                )
                (§ case 3)
                (§ block
                    (§ ass (§ name type) (§ expr InventoryItem/Type/FilteredBlock))
                    (§ break )
                )
                (§ default )
                (§ block
                    (§ throw (§ new #_"ProtocolException" (§ pars "Unknown CInv type: " + typeCode)))
                )
            )
            (§ expr items.add(§ pars (§ new #_"InventoryItem" (§ pars type, readHash(§ pars )))))
        )
        (§ ass (§ name payload) nil)
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ expr stream.write(§ pars (§ new #_"VarInt" (§ pars items.size(§ pars ))).encode(§ pars )))
        (§ for (§ var #_"InventoryItem" (§ name i)) :for items)
        (§ block
            ;; Write out the type code.
            (§ expr Utils/uint32ToByteStreamLE(§ pars i.type.ordinal(§ pars ), stream))
            ;; And now the hash.
            (§ expr stream.write(§ pars i.hash.getReversedBytes(§ pars )))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return (§ expr items.equals(§ pars (§ expr (§ cast #_"ListMessage" o)).items)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr items.hashCode(§ pars )))
    )
)

#_(ns org.bitcoinj.core #_"MemoryPoolMessage"
    (:import [java.io IOException OutputStream]))

;;;
 ; <p>The "mempool" message asks a remote peer to announce all transactions in its memory pool, possibly restricted by
 ; any Bloom filter set on the connection.  The list of transaction hashes comes back in an inv message.  Note that
 ; this is different to the {@link TxConfidenceTable} object which doesn't try to keep track of all pending transactions,
 ; it's just a holding area for transactions that a part of the app may find interesting.  The mempool message has
 ; no fields.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"MemoryPoolMessage" (§ extends #_"Message")
    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ void nil)
    )
)

#_(ns org.bitcoinj.core #_"Message"
    (:import [java.io *]
             [java.math BigInteger]
             [java.util Arrays])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory]))

;;;
 ; <p>A Message is a data structure that can be serialized/deserialized using the Bitcoin serialization format.
 ; Specific types of messages that are used both in the block chain, and on the wire, are derived from this class.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
#_abstract
(§ class #_"Message"
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"Message"))))

    #_public
    #_static
    #_final
    (§ field #_"int" (§ name MAX_SIZE) (§ expr 0x02000000)) ;; 32MB

    #_public
    #_static
    #_final
    (§ field #_"int" (§ name UNKNOWN_LENGTH) (§ expr Integer/MIN_VALUE))

    ;; Useful to ensure serialize/deserialize are consistent with each other.
    #_private
    #_static
    #_final
    (§ field #_"boolean" (§ name SELF_CHECK) false)

    ;; The offset is how many bytes into the provided byte array this message payload starts at.
    #_protected
    (§ field #_"int" (§ name offset))
    ;; The cursor keeps track of where we are in the byte array as we parse it.
    ;; Note that it's relative to the start of the array NOT the start of the message payload.
    #_protected
    (§ field #_"int" (§ name cursor))

    #_protected
    (§ field #_"int" (§ name length) (§ expr UNKNOWN_LENGTH))

    ;; The raw message payload bytes themselves.
    #_protected
    (§ field #_"byte[]" (§ name payload))

    #_protected
    (§ field #_"boolean" (§ name recached) false)
    #_protected
    (§ field #_"MessageSerializer" (§ name serializer))

    #_protected
    (§ field #_"int" (§ name protocolVersion))

    #_protected
    (§ field #_"NetworkParameters" (§ name params))

    #_protected
    (§ constructor #_"Message" [])
    (§ block
        (§ ass (§ name serializer) (§ expr DummySerializer/DEFAULT))
        (§ void this)
    )

    #_protected
    (§ constructor #_"Message" [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ ass (§ name this.params) params)
        (§ ass (§ name serializer) (§ expr params.getDefaultSerializer(§ pars )))
        (§ void this)
    )

    #_protected
    (§ constructor #_"Message" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"int" (§ name offset), #_"int" (§ name protocolVersion)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ this (§ pars params, payload, offset, protocolVersion, params.getDefaultSerializer(§ pars ), UNKNOWN_LENGTH))
        (§ void this)
    )

    ;;;
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param protocolVersion Bitcoin protocol version.
     ; @param serializer The serializer to use for this message.
     ; @param length The length of message payload if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_protected
    (§ constructor #_"Message" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"int" (§ name offset), #_"int" (§ name protocolVersion), #_"MessageSerializer" (§ name serializer), #_"int" (§ name length)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ ass (§ name this.serializer) serializer)
        (§ ass (§ name this.protocolVersion) protocolVersion)
        (§ ass (§ name this.params) params)
        (§ ass (§ name this.payload) payload)
        (§ ass (§ name this.cursor) (§ ass (§ name this.offset) offset))
        (§ ass (§ name this.length) length)

        (§ expr parse(§ pars ))

        (§ if (§ expr this.length == UNKNOWN_LENGTH))
        (§ block
            (§ expr Preconditions/checkState(§ pars false, "Length field has not been set in constructor for %s after parse.", getClass(§ pars ).getSimpleName(§ pars )))
        )

        (§ if (§ expr SELF_CHECK))
        (§ block
            (§ expr selfCheck(§ pars payload, offset))
        )

        (§ if (§ expr (§ not serializer.isParseRetainMode(§ pars ))))
        (§ block
            (§ ass (§ name this.payload) nil)
        )
        (§ void this)
    )

    #_private
    (§ method #_"void" (§ fn selfCheck) [#_"byte[]" (§ name payload), #_"int" (§ name offset)])
    (§ block
        (§ if (§ expr (§ not (§ insta this #_"VersionMessage"))))
        (§ block
            (§ var #_"byte[]" (§ name payloadBytes) (§ new #_"byte[]" (§ count cursor - offset)))
            (§ expr System/arraycopy(§ pars payload, offset, payloadBytes, 0, cursor - offset))
            (§ var #_"byte[]" (§ name reserialized) (§ expr bitcoinSerialize(§ pars )))
            (§ if (§ expr (§ not Arrays/equals(§ pars reserialized, payloadBytes))))
            (§ block
                (§ throw (§ new #_"RuntimeException" (§ pars "Serialization is wrong: \n" + Utils/HEX.encode(§ pars reserialized) + " vs \n" + Utils/HEX.encode(§ pars payloadBytes))))
            )
        )
        (§ void nil)
    )

    #_protected
    (§ constructor #_"Message" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"int" (§ name offset)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ this (§ pars params, payload, offset, params.getProtocolVersionNum(§ pars NetworkParameters/ProtocolVersion/CURRENT), params.getDefaultSerializer(§ pars ), UNKNOWN_LENGTH))
        (§ void this)
    )

    #_protected
    (§ constructor #_"Message" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"int" (§ name offset), #_"MessageSerializer" (§ name serializer), #_"int" (§ name length)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ this (§ pars params, payload, offset, params.getProtocolVersionNum(§ pars NetworkParameters/ProtocolVersion/CURRENT), serializer, length))
        (§ void this)
    )

    ;; These methods handle the serialization/deserialization using the custom Bitcoin protocol.

    #_protected
    #_abstract
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")

    ;;;
     ; <p>To be called before any change of internal values including any setters.  This ensures any cached byte array is
     ; removed.<p/>
     ; <p>Child messages of this object (e.g. Transactions belonging to a Block) will not have their internal byte caches
     ; invalidated unless they are also modified internally.</p>
     ;;
    #_protected
    (§ method #_"void" (§ fn unCache) [])
    (§ block
        (§ ass (§ name payload) nil)
        (§ ass (§ name recached) false)
        (§ void nil)
    )

    #_protected
    (§ method #_"void" (§ fn adjustLength) [#_"int" (§ name newArraySize), #_"int" (§ name adjustment)])
    (§ block
        (§ if (§ expr length == UNKNOWN_LENGTH))
        (§ block
            (§ return nil)
        )
        ;; Our own length is now unknown if we have an unknown length adjustment.
        (§ if (§ expr adjustment == UNKNOWN_LENGTH))
        (§ block
            (§ ass (§ name length) (§ expr UNKNOWN_LENGTH))
            (§ return nil)
        )
        (§ ass (§ name length) (§ expr length + adjustment))
        ;; Check if we will need more bytes to encode the length prefix.
        (§ if (§ expr newArraySize == 1))
        (§ block
            (§ ass (§ name length) (§ expr length + 1)) ;; The assumption here is we never call adjustLength with the same arraySize as before.
        )
        (§ elseif (§ expr newArraySize != 0))
        (§ block
            (§ ass (§ name length) (§ expr length + VarInt/sizeOf(§ pars newArraySize) - VarInt/sizeOf(§ pars newArraySize - 1)))
        )
        (§ void nil)
    )

    ;;;
     ; used for unit testing
     ;;
    #_public
    (§ method #_"boolean" (§ fn isCached) [])
    (§ block
        (§ return (§ expr payload != nil))
    )

    #_public
    (§ method #_"boolean" (§ fn isRecached) [])
    (§ block
        (§ return recached)
    )

    ;;;
     ; Returns a copy of the array returned by {@link Message#unsafeBitcoinSerialize()}, which is safe to mutate.
     ; If you need extra performance and can guarantee you won't write to the array, you can use the unsafe version.
     ;
     ; @return a freshly allocated serialized byte array.
     ;;
    #_public
    (§ method #_"byte[]" (§ fn bitcoinSerialize) [])
    (§ block
        (§ var #_"byte[]" (§ name bytes) (§ expr unsafeBitcoinSerialize(§ pars )))
        (§ var #_"byte[]" (§ name copy) (§ new #_"byte[]" (§ count bytes.length)))
        (§ expr System/arraycopy(§ pars bytes, 0, copy, 0, bytes.length))
        (§ return copy)
    )

    ;;;
     ; Serialize this message to a byte array that conforms to the bitcoin wire protocol.
     ; <br/>
     ; This method may return the original byte array used to construct this message if the
     ; following conditions are met:
     ; <ol>
     ; <li>1. The message was parsed from a byte array with parseRetain = true.</li>
     ; <li>2. The message has not been modified.</li>
     ; <li>3. The array had an offset of 0 and no surplus bytes.</li>
     ; </ol>
     ;
     ; If condition 3 is not met then an copy of the relevant portion of the array will be returned.
     ; Otherwise a full serialize will occur.  For this reason you should only use this API
     ; if you can guarantee you will treat the resulting array as read only.
     ;
     ; @return a byte array owned by this object, do NOT mutate it.
     ;;
    #_public
    (§ method #_"byte[]" (§ fn unsafeBitcoinSerialize) [])
    (§ block
        ;; 1st attempt to use a cached array.
        (§ if (§ expr payload != nil))
        (§ block
            ;; Cached byte array is the entire message with no extras so we can return as is and avoid an array copy.
            (§ if (§ expr offset == 0 && length == payload.length))
            (§ block
                (§ return payload)
            )

            (§ var #_"byte[]" (§ name buf) (§ new #_"byte[]" (§ count length)))
            (§ expr System/arraycopy(§ pars payload, offset, buf, 0, length))
            (§ return buf)
        )

        ;; No cached array available so serialize parts by stream.
        (§ var #_"ByteArrayOutputStream" (§ name stream) (§ new #_"UnsafeByteArrayOutputStream" (§ pars (§ quest (§ expr length < 32) ? 32 :else (§ expr length + 32)))))
        (§ try )
        (§ block
            (§ expr bitcoinSerializeToStream(§ pars stream))
        )
        (§ catch #_"IOException" (§ name _))
        (§ block
            ;; Cannot happen, we are serializing to a memory stream.
        )

        (§ if (§ expr serializer.isParseRetainMode(§ pars )))
        (§ block
            ;; A free set of steak knives!
            ;; If there happens to be a call to this method we gain an opportunity to recache
            ;; the byte array and in this case it contains no bytes from parent messages.
            ;; This give a dual benefit.  Releasing references to the larger byte array so that it
            ;; it is more likely to be GC'd.  And preventing double serializations.  E.g. calculating
            ;; merkle root calls this method.  It is will frequently happen prior to serializing the block
            ;; which means another call to bitcoinSerialize is coming.  If we didn't recache then internal
            ;; serialization would occur a 2nd time and every subsequent time the message is serialized.
            (§ ass (§ name payload) (§ expr stream.toByteArray(§ pars )))
            (§ ass (§ name cursor) (§ expr cursor - offset))
            (§ ass (§ name offset) 0)
            (§ ass (§ name recached) true)
            (§ ass (§ name length) (§ expr payload.length))
            (§ return payload)
        )
        ;; Record length.  If this Message wasn't parsed from a byte stream it won't have length field
        ;; set (except for static length message types).  Setting it makes future streaming more efficient
        ;; because we can preallocate the ByteArrayOutputStream buffer and avoid resizing.
        (§ var #_"byte[]" (§ name buf) (§ expr stream.toByteArray(§ pars )))
        (§ ass (§ name length) (§ expr buf.length))
        (§ return buf)
    )

    ;;;
     ; Serialize this message to the provided OutputStream using the bitcoin wire format.
     ;
     ; @param stream
     ; @throws IOException
     ;;
    #_public
    #_final
    (§ method #_"void" (§ fn bitcoinSerialize) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        ;; 1st check for cached bytes.
        (§ if (§ expr payload != nil && length != UNKNOWN_LENGTH))
        (§ block
            (§ expr stream.write(§ pars payload, offset, length))
            (§ return nil)
        )

        (§ expr bitcoinSerializeToStream(§ pars stream))
        (§ void nil)
    )

    ;;;
     ; Serializes this message to the provided stream.  If you just want the raw bytes use bitcoinSerialize().
     ;;
    #_protected
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ expr log.error(§ pars "Error: {} class has not implemented bitcoinSerializeToStream method.  Generating message with no payload", getClass(§ pars )))
        (§ void nil)
    )

    ;;;
     ; This method is a NOP for all classes except Block and Transaction.  It is only declared in Message
     ; so BitcoinSerializer can avoid 2 instanceof checks + a casting.
     ;;
    #_public
    (§ method #_"Sha256Hash" (§ fn getHash) [])
    (§ block
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars )))
    )

    ;;;
     ; This returns a correct value by parsing the message.
     ;;
    #_public
    #_final
    (§ method #_"int" (§ fn getMessageSize) [])
    (§ block
        (§ if (§ expr length == UNKNOWN_LENGTH))
        (§ block
            (§ expr Preconditions/checkState(§ pars false, "Length field has not been set in %s.", getClass(§ pars ).getSimpleName(§ pars )))
        )
        (§ return length)
    )

    #_protected
    (§ method #_"long" (§ fn readUint32) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ try )
        (§ block
            (§ var #_"long" (§ name u) (§ expr Utils/readUint32(§ pars payload, cursor)))
            (§ ass (§ name cursor) (§ expr cursor + 4))
            (§ return u)
        )
        (§ catch #_"ArrayIndexOutOfBoundsException" (§ name e))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars e)))
        )
    )

    #_protected
    (§ method #_"long" (§ fn readInt64) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ try )
        (§ block
            (§ var #_"long" (§ name u) (§ expr Utils/readInt64(§ pars payload, cursor)))
            (§ ass (§ name cursor) (§ expr cursor + 8))
            (§ return u)
        )
        (§ catch #_"ArrayIndexOutOfBoundsException" (§ name e))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars e)))
        )
    )

    #_protected
    (§ method #_"BigInteger" (§ fn readUint64) [])
        (§ throws #_"ProtocolException")
    (§ block
        ;; Java does not have an unsigned 64 bit type. So scrape it off the wire then flip.
        (§ return (§ new #_"BigInteger" (§ pars Utils/reverseBytes(§ pars readBytes(§ pars 8)))))
    )

    #_protected
    (§ method #_"long" (§ fn readVarInt) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ return (§ expr readVarInt(§ pars 0)))
    )

    #_protected
    (§ method #_"long" (§ fn readVarInt) [#_"int" (§ name offset)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ try )
        (§ block
            (§ var #_"VarInt" (§ name varint) (§ new #_"VarInt" (§ pars payload, cursor + offset)))
            (§ ass (§ name cursor) (§ expr cursor + offset + varint.getOriginalSizeInBytes(§ pars )))
            (§ return (§ expr varint.value))
        )
        (§ catch #_"ArrayIndexOutOfBoundsException" (§ name e))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars e)))
        )
    )

    #_protected
    (§ method #_"byte[]" (§ fn readBytes) [#_"int" (§ name length)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ if (§ expr MAX_SIZE < length))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars "Claimed value length too large: " + length)))
        )

        (§ try )
        (§ block
            (§ var #_"byte[]" (§ name b) (§ new #_"byte[]" (§ count length)))
            (§ expr System/arraycopy(§ pars payload, cursor, b, 0, length))
            (§ ass (§ name cursor) (§ expr cursor + length))
            (§ return b)
        )
        (§ catch #_"IndexOutOfBoundsException" (§ name e))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars e)))
        )
    )

    #_protected
    (§ method #_"byte[]" (§ fn readByteArray) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ var #_"long" (§ name len) (§ expr readVarInt(§ pars )))
        (§ return (§ expr readBytes(§ pars (§ cast #_"int" len))))
    )

    #_protected
    (§ method #_"String" (§ fn readStr) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ var #_"long" (§ name length) (§ expr readVarInt(§ pars )))
        (§ return (§ quest (§ expr length == 0) ? (§ expr "") :else (§ expr Utils/toString(§ pars readBytes(§ pars (§ cast #_"int" length)), "UTF-8")))) ;; optimization for empty strings
    )

    #_protected
    (§ method #_"Sha256Hash" (§ fn readHash) [])
        (§ throws #_"ProtocolException")
    (§ block
        ;; We have to flip it around, as it's been read off the wire in little endian.
        ;; Not the most efficient way to do this but the clearest.
        (§ return (§ expr Sha256Hash/wrapReversed(§ pars readBytes(§ pars 32))))
    )

    #_protected
    (§ method #_"boolean" (§ fn hasMoreBytes) [])
    (§ block
        (§ return (§ expr cursor < payload.length))
    )

    ;;; Network parameters this message was created with. ;;
    #_public
    (§ method #_"NetworkParameters" (§ fn getParams) [])
    (§ block
        (§ return params)
    )

    ;;;
     ; Set the serializer for this message when deserialized by Java.
     ;;
    #_private
    (§ method #_"void" (§ fn readObject) [#_"java.io.ObjectInputStream" (§ name in)])
        (§ throws #_"IOException", #_"ClassNotFoundException")
    (§ block
        (§ expr in.defaultReadObject(§ pars ))
        (§ if (§ expr params != nil))
        (§ block
            (§ ass (§ name this.serializer) (§ expr params.getDefaultSerializer(§ pars )))
        )
        (§ void nil)
    )
)

#_(ns org.bitcoinj.core #_"MessageSerializer"
    (:import [java.io IOException OutputStream]
             [java.nio BufferUnderflowException ByteBuffer]))

;;;
 ; Generic interface for classes which serialize/deserialize messages.
 ; Implementing classes should be immutable.
 ;;
#_public
#_abstract
(§ class #_"MessageSerializer"
    ;;;
     ; Reads a message from the given ByteBuffer and returns it.
     ;;
    #_public
    #_abstract
    (§ method #_"Message" (§ fn deserialize) [#_"ByteBuffer" (§ name in)])
        (§ throws #_"ProtocolException", #_"IOException", #_"UnsupportedOperationException")

    ;;;
     ; Deserializes only the header in case packet meta data is needed before decoding
     ; the payload.  This method assumes you have already called seekPastMagicBytes().
     ;;
    #_public
    #_abstract
    (§ method #_"BitcoinSerializer.BitcoinPacketHeader" (§ fn deserializeHeader) [#_"ByteBuffer" (§ name in)])
        (§ throws #_"ProtocolException", #_"IOException", #_"UnsupportedOperationException")

    ;;;
     ; Deserialize payload only.  You must provide a header, typically obtained by calling
     ; {@link BitcoinSerializer#deserializeHeader}.
     ;;
    #_public
    #_abstract
    (§ method #_"Message" (§ fn deserializePayload) [#_"BitcoinSerializer.BitcoinPacketHeader" (§ name header), #_"ByteBuffer" (§ name in)])
        (§ throws #_"ProtocolException", #_"BufferUnderflowException", #_"UnsupportedOperationException")

    ;;;
     ; Whether the serializer will produce cached mode Messages.
     ;;
    #_public
    #_abstract
    (§ method #_"boolean" (§ fn isParseRetainMode) [])

    ;;;
     ; Make an address message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    (§ method #_"AddressMessage" (§ fn makeAddressMessage) [#_"byte[]" (§ name payloadBytes), #_"int" (§ name length)])
        (§ throws #_"ProtocolException", #_"UnsupportedOperationException")

    ;;;
     ; Make an alert message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    (§ method #_"Message" (§ fn makeAlertMessage) [#_"byte[]" (§ name payloadBytes)])
        (§ throws #_"ProtocolException", #_"UnsupportedOperationException")

    ;;;
     ; Make a block from the payload, using an offset of zero and the payload
     ; length as block length.
     ;;
    #_public
    #_final
    (§ method #_"Block" (§ fn makeBlock) [#_"byte[]" (§ name payloadBytes)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ return (§ expr makeBlock(§ pars payloadBytes, 0, payloadBytes.length)))
    )

    ;;;
     ; Make a block from the payload, using an offset of zero and the provided
     ; length as block length.
     ;;
    #_public
    #_final
    (§ method #_"Block" (§ fn makeBlock) [#_"byte[]" (§ name payloadBytes), #_"int" (§ name length)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ return (§ expr makeBlock(§ pars payloadBytes, 0, length)))
    )

    ;;;
     ; Make a block from the payload, using an offset of zero and the provided
     ; length as block length.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    (§ method #_"Block" (§ fn makeBlock) [#_final #_"byte[]" (§ name payloadBytes), #_final #_"int" (§ name offset), #_final #_"int" (§ name length)])
        (§ throws #_"ProtocolException", #_"UnsupportedOperationException")

    ;;;
     ; Make an filter message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    (§ method #_"Message" (§ fn makeBloomFilter) [#_"byte[]" (§ name payloadBytes)])
        (§ throws #_"ProtocolException", #_"UnsupportedOperationException")

    ;;;
     ; Make a filtered block from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    (§ method #_"FilteredBlock" (§ fn makeFilteredBlock) [#_"byte[]" (§ name payloadBytes)])
        (§ throws #_"ProtocolException", #_"UnsupportedOperationException")

    ;;;
     ; Make an inventory message from the payload.  Extension point for alternative
     ; serialization format support.
     ;;
    #_public
    #_abstract
    (§ method #_"InventoryMessage" (§ fn makeInventoryMessage) [#_"byte[]" (§ name payloadBytes), #_"int" (§ name length)])
        (§ throws #_"ProtocolException", #_"UnsupportedOperationException")

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative
     ; serialization format support.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support deserialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support deserializing transactions.
     ;;
    #_public
    #_abstract
    (§ method #_"Transaction" (§ fn makeTransaction) [#_"byte[]" (§ name payloadBytes), #_"int" (§ name offset), #_"int" (§ name length), #_"byte[]" (§ name hash)])
        (§ throws #_"ProtocolException", #_"UnsupportedOperationException")

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative
     ; serialization format support.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support deserialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support deserializing transactions.
     ;;
    #_public
    #_final
    (§ method #_"Transaction" (§ fn makeTransaction) [#_"byte[]" (§ name payloadBytes)])
        (§ throws #_"ProtocolException", #_"UnsupportedOperationException")
    (§ block
        (§ return (§ expr makeTransaction(§ pars payloadBytes, 0)))
    )

    ;;;
     ; Make a transaction from the payload.  Extension point for alternative
     ; serialization format support.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support deserialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support deserializing transactions.
     ;;
    #_public
    #_final
    (§ method #_"Transaction" (§ fn makeTransaction) [#_"byte[]" (§ name payloadBytes), #_"int" (§ name offset)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ return (§ expr makeTransaction(§ pars payloadBytes, offset, payloadBytes.length, nil)))
    )

    #_public
    #_abstract
    (§ method #_"void" (§ fn seekPastMagicBytes) [#_"ByteBuffer" (§ name in)])
        (§ throws #_"BufferUnderflowException")

    ;;;
     ; Writes message to to the output stream.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support serialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support serializing the given message.
     ;;
    #_public
    #_abstract
    (§ method #_"void" (§ fn serialize) [#_"String" (§ name name), #_"byte[]" (§ name message), #_"OutputStream" (§ name out)])
        (§ throws #_"IOException", #_"UnsupportedOperationException")

    ;;;
     ; Writes message to to the output stream.
     ;
     ; @throws UnsupportedOperationException if this serializer/deserializer
     ; does not support serialization.  This can occur either because it's a dummy
     ; serializer (i.e. for messages with no network parameters), or because
     ; it does not support serializing the given message.
     ;;
    #_public
    #_abstract
    (§ method #_"void" (§ fn serialize) [#_"Message" (§ name message), #_"OutputStream" (§ name out)])
        (§ throws #_"IOException", #_"UnsupportedOperationException")
)

#_(ns org.bitcoinj.core #_"Monetary"
    (:import [java.io Serializable]))

;;;
 ; Classes implementing this interface represent a monetary value, such as a Bitcoin or fiat amount.
 ;;
#_public
(§ interface #_"Monetary" (§ extends #_"Serializable")
    ;;;
     ; Returns the absolute value of exponent of the value of a "smallest unit" in scientific notation.
     ; For Bitcoin, a satoshi is worth 1E-8 so this would be 8.
     ;;
    (§ method #_"int" (§ fn smallestUnitExponent) [])

    ;;;
     ; Returns the number of "smallest units" of this monetary value.
     ; For Bitcoin, this would be the number of satoshis.
     ;;
    (§ method #_"long" (§ fn getValue) [])

    (§ method #_"int" (§ fn signum) [])
)

#_(ns org.bitcoinj.core #_"NetworkParameters"
    (:import [java.io *]
             [java.math *]
             [java.util *])
    (:import [com.google.common.base Objects])
   (:require [org.bitcoinj.core Block]
             #_static [org.bitcoinj.core.Coin *]
             [org.bitcoinj.core StoredBlock VerificationException]
             [org.bitcoinj.net.discovery *]
             [org.bitcoinj.params *]
             [org.bitcoinj.script *]
             [org.bitcoinj.store BlockStore BlockStoreException]
             [org.bitcoinj.utils MonetaryFormat VersionTally]))

;;;
 ; <p>NetworkParameters contains the data needed for working with an instantiation of a Bitcoin chain.</p>
 ;
 ; <p>This is an abstract class, concrete instantiations can be found in the params package.  There are four:
 ; one for the main network ({@link MainNetParams}), one for the public test network, and two others that are
 ; intended for unit testing and local app development purposes.  Although this class contains some aliases for
 ; them, you are encouraged to call the static get() methods on each specific params class directly.</p>
 ;;
#_public
#_abstract
(§ class #_"NetworkParameters"
    ;;;
     ; The alert signing key originally owned by Satoshi, and now passed on to Gavin along with a few others.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"byte[]" (§ name SATOSHI_KEY) (§ expr Utils/HEX.decode(§ pars "04fc9702847840aaf195de8442ebecedf5b095cdbb9bc716bda9110971b28a49e0ead8564ff0db22209e0374782c093bb899692d524e9d6a6956e7c5ecbcd68284")))

    ;;; The string returned by getId() for the main, production network where people trade things. ;;
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name ID_MAINNET) (§ expr "org.bitcoin.production"))
    ;;; The string returned by getId() for the testnet. ;;
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name ID_TESTNET) (§ expr "org.bitcoin.test"))
    ;;; Unit test network. ;;
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name ID_UNITTESTNET) (§ expr "org.bitcoinj.unittest"))

    ;;; The string used by the payment protocol to represent the main net. ;;
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name PAYMENT_PROTOCOL_ID_MAINNET) (§ expr "main"))
    ;;; The string used by the payment protocol to represent the test net. ;;
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name PAYMENT_PROTOCOL_ID_TESTNET) (§ expr "test"))
    ;;; The string used by the payment protocol to represent unit testing (note that this is non-standard). ;;
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name PAYMENT_PROTOCOL_ID_UNIT_TESTS) (§ expr "unittest"))

    ;; TODO: Seed nodes should be here as well.

    #_protected
    (§ field #_"Block" (§ name genesisBlock))
    #_protected
    (§ field #_"BigInteger" (§ name maxTarget))
    #_protected
    (§ field #_"int" (§ name port))
    #_protected
    (§ field #_"long" (§ name packetMagic)) ;; Indicates message origin network and is used to seek to the next message when stream state is unknown.
    #_protected
    (§ field #_"int" (§ name addressHeader))
    #_protected
    (§ field #_"int" (§ name p2shHeader))
    #_protected
    (§ field #_"int" (§ name interval))
    #_protected
    (§ field #_"int" (§ name targetTimespan))
    #_protected
    (§ field #_"byte[]" (§ name alertSigningKey))
    #_protected
    (§ field #_"int" (§ name bip32HeaderPub))
    #_protected
    (§ field #_"int" (§ name bip32HeaderPriv))

    ;;; Used to check majorities for block version upgrade. ;;
    #_protected
    (§ field #_"int" (§ name majorityEnforceBlockUpgrade))
    #_protected
    (§ field #_"int" (§ name majorityRejectBlockOutdated))
    #_protected
    (§ field #_"int" (§ name majorityWindow))

    ;;;
     ; See getId().  This may be null for old deserialized wallets.  In that case we derive it heuristically
     ; by looking at the port number.
     ;;
    #_protected
    (§ field #_"String" (§ name id))

    ;;;
     ; The depth of blocks required for a coinbase transaction to be spendable.
     ;;
    #_protected
    (§ field #_"int" (§ name spendableCoinbaseDepth))
    #_protected
    (§ field #_"int" (§ name subsidyDecreaseBlockCount))

    #_protected
    (§ field #_"int[]" (§ name acceptableAddressCodes))
    #_protected
    (§ field #_"String[]" (§ name dnsSeeds))
    #_protected
    (§ field #_"int[]" (§ name addrSeeds))
    #_protected
    (§ field #_"Map<Integer, Sha256Hash>" (§ name checkpoints) (§ new #_"HashMap<>" (§ pars )))
    #_protected
    #_transient
    (§ field #_"MessageSerializer" (§ name defaultSerializer))

    #_protected
    (§ constructor #_"NetworkParameters" [])
    (§ block
        (§ ass (§ name alertSigningKey) (§ expr SATOSHI_KEY))
        (§ ass (§ name genesisBlock) (§ expr createGenesis(§ pars this)))
        (§ void this)
    )

    #_private
    #_static
    (§ method #_"Block" (§ fn createGenesis) [#_"NetworkParameters" (§ name n)])
    (§ block
        (§ var #_"Block" (§ name genesisBlock) (§ new #_"Block" (§ pars n, Block/BLOCK_VERSION_GENESIS)))
        (§ var #_"Transaction" (§ name t) (§ new #_"Transaction" (§ pars n)))
        (§ try )
        (§ block
            ;; A script containing the difficulty bits and the following message: "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks".
            (§ var #_"byte[]" (§ name bytes) (§ expr Utils/HEX.decode(§ pars "04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73")))
            (§ expr t.addInput(§ pars (§ new #_"TransactionInput" (§ pars n, t, bytes))))
            (§ var #_"ByteArrayOutputStream" (§ name scriptPubKeyBytes) (§ new #_"ByteArrayOutputStream" (§ pars )))
            (§ expr Script/writeBytes(§ pars scriptPubKeyBytes, Utils/HEX.decode(§ pars "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f")))
            (§ expr scriptPubKeyBytes.write(§ pars ScriptOpCodes/OP_CHECKSIG))
            (§ expr t.addOutput(§ pars (§ new #_"TransactionOutput" (§ pars n, t, FIFTY_COINS, scriptPubKeyBytes.toByteArray(§ pars )))))
        )
        (§ catch #_"Exception" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
        (§ expr genesisBlock.addTransaction(§ pars t))
        (§ return genesisBlock)
    )

    #_public
    #_static
    #_final
    (§ field #_"int" (§ name TARGET_TIMESPAN) (§ expr 14 * 24 * 60 * 60)) ;; 2 weeks per difficulty cycle, on average.
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name TARGET_SPACING) (§ expr 10 * 60)) ;; 10 minutes per block.
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name INTERVAL) (§ expr TARGET_TIMESPAN / TARGET_SPACING))

    ;;;
     ; Blocks with a timestamp after this should enforce BIP 16, aka "Pay to script hash".  This BIP changed
     ; the network rules in a soft-forking manner, that is, blocks that don't follow the rules are accepted
     ; but not mined upon and thus will be quickly re-orged out as long as the majority are enforcing the rule.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name BIP16_ENFORCE_TIME) 1333238400)

    ;;;
     ; The maximum number of coins to be generated.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"long" (§ name MAX_COINS) 21000000)

    ;;;
     ; The maximum money to be generated.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"Coin" (§ name MAX_MONEY) (§ expr COIN.multiply(§ pars MAX_COINS)))

    ;;;
     ; A Java package style string acting as unique ID for these parameters.
     ;;
    #_public
    (§ method #_"String" (§ fn getId) [])
    (§ block
        (§ return id)
    )

    #_public
    #_abstract
    (§ method #_"String" (§ fn getPaymentProtocolId) [])

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return (§ expr getId(§ pars ).equals(§ pars (§ expr (§ cast #_"NetworkParameters" o)).getId(§ pars ))))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars getId(§ pars ))))
    )

    ;;; Returns the network parameters for the given string ID or NULL if not recognized. ;;
    #_nilable
    #_public
    #_static
    (§ method #_"NetworkParameters" (§ fn fromID) [#_"String" (§ name id)])
    (§ block
        (§ if (§ expr id.equals(§ pars ID_MAINNET)))
        (§ block
            (§ return (§ expr MainNetParams/get(§ pars )))
        )
        (§ if (§ expr id.equals(§ pars ID_TESTNET)))
        (§ block
            (§ return (§ expr TestNet3Params/get(§ pars )))
        )
        (§ if (§ expr id.equals(§ pars ID_UNITTESTNET)))
        (§ block
            (§ return (§ expr UnitTestParams/get(§ pars )))
        )
        (§ return nil)
    )

    ;;; Returns the network parameters for the given string paymentProtocolID or NULL if not recognized. ;;
    #_nilable
    #_public
    #_static
    (§ method #_"NetworkParameters" (§ fn fromPmtProtocolID) [#_"String" (§ name pmtProtocolId)])
    (§ block
        (§ if (§ expr pmtProtocolId.equals(§ pars PAYMENT_PROTOCOL_ID_MAINNET)))
        (§ block
            (§ return (§ expr MainNetParams/get(§ pars )))
        )
        (§ if (§ expr pmtProtocolId.equals(§ pars PAYMENT_PROTOCOL_ID_TESTNET)))
        (§ block
            (§ return (§ expr TestNet3Params/get(§ pars )))
        )
        (§ if (§ expr pmtProtocolId.equals(§ pars PAYMENT_PROTOCOL_ID_UNIT_TESTS)))
        (§ block
            (§ return (§ expr UnitTestParams/get(§ pars )))
        )
        (§ return nil)
    )

    #_public
    (§ method #_"int" (§ fn getSpendableCoinbaseDepth) [])
    (§ block
        (§ return spendableCoinbaseDepth)
    )

    ;;;
     ; Throws an exception if the block's difficulty is not correct.
     ;
     ; @throws VerificationException if the block's difficulty is not correct.
     ;;
    #_public
    #_abstract
    (§ method #_"void" (§ fn checkDifficultyTransitions) [#_"StoredBlock" (§ name storedPrev), #_"Block" (§ name next), #_final #_"BlockStore" (§ name blockStore)])
        (§ throws #_"VerificationException", #_"BlockStoreException")

    ;;;
     ; Returns true if the block height is either not a checkpoint, or is a checkpoint and the hash matches.
     ;;
    #_public
    (§ method #_"boolean" (§ fn passesCheckpoint) [#_"int" (§ name height), #_"Sha256Hash" (§ name hash)])
    (§ block
        (§ var #_"Sha256Hash" (§ name checkpointHash) (§ expr checkpoints.get(§ pars height)))
        (§ return (§ expr checkpointHash == nil || checkpointHash.equals(§ pars hash)))
    )

    ;;;
     ; Returns true if the given height has a recorded checkpoint.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isCheckpoint) [#_"int" (§ name height)])
    (§ block
        (§ var #_"Sha256Hash" (§ name checkpointHash) (§ expr checkpoints.get(§ pars height)))
        (§ return (§ expr checkpointHash != nil))
    )

    #_public
    (§ method #_"int" (§ fn getSubsidyDecreaseBlockCount) [])
    (§ block
        (§ return subsidyDecreaseBlockCount)
    )

    ;;; Returns DNS names that when resolved, give IP addresses of active peers. ;;
    #_public
    (§ method #_"String[]" (§ fn getDnsSeeds) [])
    (§ block
        (§ return dnsSeeds)
    )

    ;;; Returns IP address of active peers. ;;
    #_public
    (§ method #_"int[]" (§ fn getAddrSeeds) [])
    (§ block
        (§ return addrSeeds)
    )

    ;;;
     ; <p>Genesis block for this chain.</p>
     ;
     ; <p>The first block in every chain is a well known constant shared between all Bitcoin implemenetations.
     ; For a block to be valid, it must be eventually possible to work backwards to the genesis block by following
     ; the prevBlockHash pointers in the block headers.</p>
     ;
     ; <p>The genesis blocks for both test and main networks contain the timestamp of when they were created,
     ; and a message in the coinbase transaction.  It says,
     ; <i>"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"</i>.</p>
     ;;
    #_public
    (§ method #_"Block" (§ fn getGenesisBlock) [])
    (§ block
        (§ return genesisBlock)
    )

    ;;; Default TCP port on which to connect to nodes. ;;
    #_public
    (§ method #_"int" (§ fn getPort) [])
    (§ block
        (§ return port)
    )

    ;;; The header bytes that identify the start of a packet on this network. ;;
    #_public
    (§ method #_"long" (§ fn getPacketMagic) [])
    (§ block
        (§ return packetMagic)
    )

    ;;;
     ; First byte of a base58 encoded address.  See {@link org.bitcoinj.core.Address}.
     ; This is the same as acceptableAddressCodes[0] and is the one used for "normal" addresses.
     ; Other types of address may be encountered with version codes found in the acceptableAddressCodes array.
     ;;
    #_public
    (§ method #_"int" (§ fn getAddressHeader) [])
    (§ block
        (§ return addressHeader)
    )

    ;;;
     ; First byte of a base58 encoded P2SH address.  P2SH addresses are defined as part of BIP0013.
     ;;
    #_public
    (§ method #_"int" (§ fn getP2SHHeader) [])
    (§ block
        (§ return p2shHeader)
    )

    ;;;
     ; How much time in seconds is supposed to pass between "interval" blocks.  If the actual elapsed time is
     ; significantly different from this value, the network difficulty formula will produce a different value.
     ; Both test and main Bitcoin networks use 2 weeks (1209600 seconds).
     ;;
    #_public
    (§ method #_"int" (§ fn getTargetTimespan) [])
    (§ block
        (§ return targetTimespan)
    )

    ;;;
     ; The version codes that prefix addresses which are acceptable on this network.  Although Satoshi intended these
     ; to be used for "versioning", in fact they are today used to discriminate what kind of data is contained in the
     ; address and to prevent accidentally sending coins across chains which would destroy them.
     ;;
    #_public
    (§ method #_"int[]" (§ fn getAcceptableAddressCodes) [])
    (§ block
        (§ return acceptableAddressCodes)
    )

    ;;;
     ; If we are running in testnet-in-a-box mode, we allow connections to nodes with 0 non-genesis blocks.
     ;;
    #_public
    (§ method #_"boolean" (§ fn allowEmptyPeerChain) [])
    (§ block
        (§ return true)
    )

    ;;; How many blocks pass between difficulty adjustment periods.  Bitcoin standardises this to be 2016. ;;
    #_public
    (§ method #_"int" (§ fn getInterval) [])
    (§ block
        (§ return interval)
    )

    ;;; Maximum target represents the easiest allowable proof of work. ;;
    #_public
    (§ method #_"BigInteger" (§ fn getMaxTarget) [])
    (§ block
        (§ return maxTarget)
    )

    ;;;
     ; The key used to sign {@link org.bitcoinj.core.AlertMessage}s.
     ; You can use {@link org.bitcoinj.core.ECKey#verify(byte[], byte[], byte[])} to verify signatures using it.
     ;;
    #_public
    (§ method #_"byte[]" (§ fn getAlertSigningKey) [])
    (§ block
        (§ return alertSigningKey)
    )

    ;;; Returns the 4 byte header for BIP32 (HD) wallet - public key part. ;;
    #_public
    (§ method #_"int" (§ fn getBip32HeaderPub) [])
    (§ block
        (§ return bip32HeaderPub)
    )

    ;;; Returns the 4 byte header for BIP32 (HD) wallet - private key part. ;;
    #_public
    (§ method #_"int" (§ fn getBip32HeaderPriv) [])
    (§ block
        (§ return bip32HeaderPriv)
    )

    ;;;
     ; Returns the number of coins that will be produced in total, on this network.
     ; Where not applicable, a very large number of coins is returned
     ; instead (i.e. the main coin issue for Dogecoin).
     ;;
    #_public
    #_abstract
    (§ method #_"Coin" (§ fn getMaxMoney) [])

    ;;;
     ; Any standard (i.e. pay-to-address) output smaller than this value will
     ; most likely be rejected by the network.
     ;;
    #_public
    #_abstract
    (§ method #_"Coin" (§ fn getMinNonDustOutput) [])

    ;;;
     ; The monetary object for this currency.
     ;;
    #_public
    #_abstract
    (§ method #_"MonetaryFormat" (§ fn getMonetaryFormat) [])

    ;;;
     ; Scheme part for URIs, for example "bitcoin".
     ;;
    #_public
    #_abstract
    (§ method #_"String" (§ fn getUriScheme) [])

    ;;;
     ; Returns whether this network has a maximum number of coins (finite supply) or not.
     ; Always returns true for Bitcoin, but exists to be overriden for other networks.
     ;;
    #_public
    #_abstract
    (§ method #_"boolean" (§ fn hasMaxMoney) [])

    ;;;
     ; Return the default serializer for this network.  This is a shared serializer.
     ;;
    #_public
    #_final
    (§ method #_"MessageSerializer" (§ fn getDefaultSerializer) [])
    (§ block
        ;; Construct a default serializer if we don't have one.
        (§ if (§ expr this.defaultSerializer == nil))
        (§ block
            ;; Don't grab a lock unless we absolutely need it.
            (§ sync this)
            (§ block
                ;; Now we have a lock, double check there's still no serializer and create one if so.
                (§ if (§ expr this.defaultSerializer == nil))
                (§ block
                    ;; As the serializers are intended to be immutable, creating
                    ;; two due to a race condition should not be a problem, however
                    ;; to be safe we ensure only one exists for each network.
                    (§ ass (§ name this.defaultSerializer) (§ expr getSerializer(§ pars false)))
                )
            )
        )
        (§ return defaultSerializer)
    )

    ;;;
     ; Construct and return a custom serializer.
     ;;
    #_public
    #_abstract
    (§ method #_"BitcoinSerializer" (§ fn getSerializer) [#_"boolean" (§ name parseRetain)])

    ;;;
     ; The number of blocks in the last {@link getMajorityWindow()} blocks
     ; at which to trigger a notice to the user to upgrade their client, where
     ; the client does not understand those blocks.
     ;;
    #_public
    (§ method #_"int" (§ fn getMajorityEnforceBlockUpgrade) [])
    (§ block
        (§ return majorityEnforceBlockUpgrade)
    )

    ;;;
     ; The number of blocks in the last {@link getMajorityWindow()} blocks
     ; at which to enforce the requirement that all new blocks are of the
     ; newer type (i.e. outdated blocks are rejected).
     ;;
    #_public
    (§ method #_"int" (§ fn getMajorityRejectBlockOutdated) [])
    (§ block
        (§ return majorityRejectBlockOutdated)
    )

    ;;;
     ; The sampling window from which the version numbers of blocks are taken
     ; in order to determine if a new block version is now the majority.
     ;;
    #_public
    (§ method #_"int" (§ fn getMajorityWindow) [])
    (§ block
        (§ return majorityWindow)
    )

    ;;;
     ; The flags indicating which block validation tests should be applied to
     ; the given block.  Enables support for alternative blockchains which enable
     ; tests based on different criteria.
     ;
     ; @param block Block to determine flags for.
     ; @param height Height of the block, if known, null otherwise.  Returned
     ; tests should be a safe subset if block height is unknown.
     ;;
    #_public
    (§ method #_"EnumSet<Block.VerifyFlag>" (§ fn getBlockVerificationFlags) [#_final #_"Block" (§ name block), #_final #_"VersionTally" (§ name tally), #_final #_"Integer" (§ name height)])
    (§ block
        #_final
        (§ var #_"EnumSet<Block.VerifyFlag>" (§ name flags) (§ expr EnumSet/noneOf(§ pars (§ klass #_"Block.VerifyFlag"))))

        (§ if (§ expr block.isBIP34(§ pars )))
        (§ block
            #_final
            (§ var #_"Integer" (§ name count) (§ expr tally.getCountAtOrAbove(§ pars Block/BLOCK_VERSION_BIP34)))
            (§ if (§ expr count != nil && getMajorityEnforceBlockUpgrade(§ pars ) <= count))
            (§ block
                (§ expr flags.add(§ pars Block/VerifyFlag/HEIGHT_IN_COINBASE))
            )
        )

        (§ return flags)
    )

    ;;;
     ; The flags indicating which script validation tests should be applied to
     ; the given transaction.  Enables support for alternative blockchains which enable
     ; tests based on different criteria.
     ;
     ; @param block Block the transaction belongs to.
     ; @param transaction to determine flags for.
     ; @param height Height of the block, if known, null otherwise.  Returned
     ; tests should be a safe subset if block height is unknown.
     ;;
    #_public
    (§ method #_"EnumSet<Script.VerifyFlag>" (§ fn getTransactionVerificationFlags) [#_final #_"Block" (§ name block), #_final #_"Transaction" (§ name transaction), #_final #_"VersionTally" (§ name tally), #_final #_"Integer" (§ name height)])
    (§ block
        #_final
        (§ var #_"EnumSet<Script.VerifyFlag>" (§ name verifyFlags) (§ expr EnumSet/noneOf(§ pars (§ klass #_"Script.VerifyFlag"))))
        (§ if (§ expr NetworkParameters/BIP16_ENFORCE_TIME <= block.getTimeSeconds(§ pars )))
        (§ block
            (§ expr verifyFlags.add(§ pars Script/VerifyFlag/P2SH))
        )

        ;; Start enforcing CHECKLOCKTIMEVERIFY (BIP65) for block.nVersion=4 blocks,
        ;; when 75% of the network has been upgraded:
        (§ if (§ expr Block/BLOCK_VERSION_BIP65 <= block.getVersion(§ pars ) && this.getMajorityEnforceBlockUpgrade(§ pars ) < tally.getCountAtOrAbove(§ pars Block/BLOCK_VERSION_BIP65)))
        (§ block
            (§ expr verifyFlags.add(§ pars Script/VerifyFlag/CHECKLOCKTIMEVERIFY))
        )

        (§ return verifyFlags)
    )

    #_public
    #_abstract
    (§ method #_"int" (§ fn getProtocolVersionNum) [#_final #_"ProtocolVersion" (§ name version)])

    #_public
    #_static
    (§ enum #_"ProtocolVersion"
        (§ item MINIMUM(§ pars 70000))
        (§ item PONG(§ pars 60001))
        (§ item BLOOM_FILTER(§ pars 70000))
        (§ item CURRENT(§ pars 70001))

        #_private
        #_final
        (§ field #_"int" (§ name bitcoinProtocol))

        (§ constructor #_"ProtocolVersion" [#_final #_"int" (§ name bitcoinProtocol)])
        (§ block
            (§ ass (§ name this.bitcoinProtocol) bitcoinProtocol)
            (§ void this)
        )

        #_public
        (§ method #_"int" (§ fn getBitcoinProtocolVersion) [])
        (§ block
            (§ return bitcoinProtocol)
        )
    )
)

#_(ns org.bitcoinj.core #_"NotFoundMessage"
    (:import [java.util ArrayList List]))

;;;
 ; <p>Sent by a peer when a getdata request doesn't find the requested data in the mempool.  It has the same format
 ; as an inventory message and lists the hashes of the missing items.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"NotFoundMessage" (§ extends #_"InventoryMessage")
    #_public
    #_static
    (§ field #_"int" (§ name MIN_PROTOCOL_VERSION) 70001)

    #_public
    (§ constructor #_"NotFoundMessage" [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ super (§ pars params))
        (§ void this)
    )

    #_public
    (§ constructor #_"NotFoundMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payloadBytes)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payloadBytes))
        (§ void this)
    )

    #_public
    (§ constructor #_"NotFoundMessage" [#_"NetworkParameters" (§ name params), #_"List<InventoryItem>" (§ name items)])
    (§ block
        (§ super (§ pars params))
        (§ ass (§ name this.items) (§ new #_"ArrayList<>" (§ pars items)))
        (§ void this)
    )
)

#_(ns org.bitcoinj.core #_"PartialMerkleTree"
    (:import [java.io IOException OutputStream]
             [java.util ArrayList Arrays List])
    (:import [com.google.common.base Objects])
    (:import #_static [org.bitcoinj.core.Utils *]))

;;;
 ; <p>A data structure that contains proofs of block inclusion for one or more transactions, in an efficient manner.</p>
 ;
 ; <p>The encoding works as follows: we traverse the tree in depth-first order, storing a bit for each traversed node,
 ; signifying whether the node is the parent of at least one matched leaf txid (or a matched txid itself).  In case we
 ; are at the leaf level, or this bit is 0, its merkle node hash is stored, and its children are not explored further.
 ; Otherwise, no hash is stored, but we recurse into both (or the only) child branch.  During decoding, the same
 ; depth-first traversal is performed, consuming bits and hashes as they were written during encoding.</p>
 ;
 ; <p>The serialization is fixed and provides a hard guarantee about the encoded size,
 ; <tt>SIZE &lt;= 10 + ceil(32.25 * N)</tt> where N represents the number of leaf nodes of the partial tree.
 ; N itself is bounded by:</p>
 ;
 ; N &lt;= total_transactions<br>
 ; N &lt;= 1 + matched_transactions * tree_height
 ;
 ; <p><pre>The serialization format:
 ;  - uint32     total_transactions (4 bytes)
 ;  - varint     number of hashes (1-3 bytes)
 ;  - uint256[]  hashes in depth-first order (&lt;= 32*N bytes)
 ;  - varint     number of bytes of flag bits (1-3 bytes)
 ;  - byte[]     flag bits, packed per 8 in a byte, least significant bit first (&lt;= 2*N-1 bits)
 ; The size constraints follow from this.</pre></p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"PartialMerkleTree" (§ extends #_"Message")
    ;; the total number of transactions in the block
    #_private
    (§ field #_"int" (§ name transactionCount))

    ;; node-is-parent-of-matched-txid bits
    #_private
    (§ field #_"byte[]" (§ name matchedChildBits))

    ;; txids and internal hashes
    #_private
    (§ field #_"List<Sha256Hash>" (§ name hashes))

    #_public
    (§ constructor #_"PartialMerkleTree" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payloadBytes), #_"int" (§ name offset)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payloadBytes, offset))
        (§ void this)
    )

    ;;;
     ; Constructs a new PMT with the given bit set (little endian) and the raw list of hashes including internal hashes,
     ; taking ownership of the list.
     ;;
    #_public
    (§ constructor #_"PartialMerkleTree" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name bits), #_"List<Sha256Hash>" (§ name hashes), #_"int" (§ name origTxCount)])
    (§ block
        (§ super (§ pars params))

        (§ ass (§ name this.matchedChildBits) bits)
        (§ ass (§ name this.hashes) hashes)
        (§ ass (§ name this.transactionCount) origTxCount)
        (§ void this)
    )

    ;;;
     ; Calculates a PMT given the list of leaf hashes and which leaves need to be included.  The relevant interior hashes
     ; are calculated and a new PMT returned.
     ;;
    #_public
    #_static
    (§ method #_"PartialMerkleTree" (§ fn buildFromLeaves) [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name includeBits), #_"List<Sha256Hash>" (§ name allLeafHashes)])
    (§ block
        ;; Calculate height of the tree.
        (§ var #_"int" (§ name height) 0)
        (§ while (§ expr 1 < getTreeWidth(§ pars allLeafHashes.size(§ pars ), height)))
        (§ block
            (§ ass (§ name height) (§ expr height + 1))
        )
        (§ var #_"List<Boolean>" (§ name bitList) (§ new #_"ArrayList<>" (§ pars )))
        (§ var #_"List<Sha256Hash>" (§ name hashes) (§ new #_"ArrayList<>" (§ pars )))
        (§ expr traverseAndBuild(§ pars height, 0, allLeafHashes, includeBits, bitList, hashes))
        (§ var #_"byte[]" (§ name bits) (§ new #_"byte[]" (§ count (§ cast #_"int" (§ expr Math/ceil(§ pars bitList.size(§ pars ) / 8.0))))))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < bitList.size(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ if (§ expr bitList.get(§ pars i)))
            (§ block
                (§ expr Utils/setBitLE(§ pars bits, i))
            )
        )
        (§ return (§ new #_"PartialMerkleTree" (§ pars params, bits, hashes, allLeafHashes.size(§ pars ))))
    )

    #_override
    #_public
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ expr uint32ToByteStreamLE(§ pars transactionCount, stream))

        (§ expr stream.write(§ pars (§ new #_"VarInt" (§ pars hashes.size(§ pars ))).encode(§ pars )))
        (§ for (§ var #_"Sha256Hash" (§ name hash)) :for hashes)
        (§ block
            (§ expr stream.write(§ pars hash.getReversedBytes(§ pars )))
        )

        (§ expr stream.write(§ pars (§ new #_"VarInt" (§ pars matchedChildBits.length)).encode(§ pars )))
        (§ expr stream.write(§ pars matchedChildBits))
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ ass (§ name transactionCount) (§ cast #_"int" (§ expr readUint32(§ pars ))))

        (§ var #_"int" (§ name nHashes) (§ expr (§ cast #_"int" (§ expr readVarInt(§ pars )))))
        (§ ass (§ name hashes) (§ new #_"ArrayList<>" (§ pars nHashes)))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < nHashes) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ expr hashes.add(§ pars readHash(§ pars )))
        )

        (§ var #_"int" (§ name nFlagBytes) (§ expr (§ cast #_"int" (§ expr readVarInt(§ pars )))))
        (§ ass (§ name matchedChildBits) (§ expr readBytes(§ pars nFlagBytes)))

        (§ ass (§ name length) (§ expr cursor - offset))
        (§ void nil)
    )

    ;; Based on CPartialMerkleTree::TraverseAndBuild in Bitcoin Core.
    #_private
    #_static
    (§ method #_"void" (§ fn traverseAndBuild) [#_"int" (§ name height), #_"int" (§ name pos), #_"List<Sha256Hash>" (§ name allLeafHashes), #_"byte[]" (§ name includeBits), #_"List<Boolean>" (§ name matchedChildBits), #_"List<Sha256Hash>" (§ name resultHashes)])
    (§ block
        (§ var #_"boolean" (§ name parentOfMatch) false)
        ;; Is this node a parent of at least one matched hash?
        (§ for (§ var #_"int" (§ name p) (§ expr pos << height)) :for (§ expr p < (§ expr pos + 1) << height && p < allLeafHashes.size(§ pars )) :for (§ ass (§ name p) (§ expr p + 1)))
        (§ block
            (§ if (§ expr Utils/checkBitLE(§ pars includeBits, p)))
            (§ block
                (§ ass (§ name parentOfMatch) true)
                (§ break )
            )
        )
        ;; Store as a flag bit.
        (§ expr matchedChildBits.add(§ pars parentOfMatch))
        (§ if (§ expr height == 0 || (§ not parentOfMatch)))
        (§ block
            ;; If at height 0, or nothing interesting below, store hash and stop.
            (§ expr resultHashes.add(§ pars calcHash(§ pars height, pos, allLeafHashes)))
        )
        (§ else )
        (§ block
            ;; Otherwise descend into the subtrees.
            (§ var #_"int" (§ name h) (§ expr height - 1))
            (§ var #_"int" (§ name p) (§ expr pos * 2))
            (§ expr traverseAndBuild(§ pars h, p, allLeafHashes, includeBits, matchedChildBits, resultHashes))
            (§ if (§ expr p + 1 < getTreeWidth(§ pars allLeafHashes.size(§ pars ), h)))
            (§ block
                (§ expr traverseAndBuild(§ pars h, p + 1, allLeafHashes, includeBits, matchedChildBits, resultHashes))
            )
        )
        (§ void nil)
    )

    #_private
    #_static
    (§ method #_"Sha256Hash" (§ fn calcHash) [#_"int" (§ name height), #_"int" (§ name pos), #_"List<Sha256Hash>" (§ name hashes)])
    (§ block
        ;; Hash at height 0 is just the regular tx hash itself.
        (§ if (§ expr height == 0))
        (§ block
            (§ return (§ expr hashes.get(§ pars pos)))
        )

        (§ var #_"int" (§ name h) (§ expr height - 1))
        (§ var #_"int" (§ name p) (§ expr pos * 2))
        (§ var #_"Sha256Hash" (§ name left) (§ expr calcHash(§ pars h, p, hashes)))
        ;; Calculate right hash if not beyond the end of the array - copy left hash otherwise.
        (§ var #_"Sha256Hash" (§ name right) (§ quest (§ expr p + 1 < getTreeWidth(§ pars hashes.size(§ pars ), h)) ? (§ expr calcHash(§ pars h, p + 1, hashes)) :else left))

        (§ return (§ expr combineLeftRight(§ pars left.getBytes(§ pars ), right.getBytes(§ pars ))))
    )

    ;; Helper function to efficiently calculate the number of nodes at given height in the merkle tree.
    #_private
    #_static
    (§ method #_"int" (§ fn getTreeWidth) [#_"int" (§ name transactionCount), #_"int" (§ name height)])
    (§ block
        (§ return (§ expr transactionCount + (§ expr 1 << height) - 1) >> height)
    )

    #_private
    #_static
    (§ class #_"ValuesUsed"
        #_public
        (§ field #_"int" (§ name bitsUsed) 0)
        (§ field #_"int" (§ name hashesUsed) 0)
    )

    ;; Recursive function that traverses tree nodes, consuming the bits and hashes produced by TraverseAndBuild.
    ;; It returns the hash of the respective node.
    #_private
    (§ method #_"Sha256Hash" (§ fn recursiveExtractHashes) [#_"int" (§ name height), #_"int" (§ name pos), #_"ValuesUsed" (§ name used), #_"List<Sha256Hash>" (§ name matchedHashes)])
        (§ throws #_"VerificationException")
    (§ block
        ;; overflowed bits array - failure
        (§ if (§ expr matchedChildBits.length * 8 <= used.bitsUsed))
        (§ block
            (§ throw (§ new #_"VerificationException" (§ pars "PartialMerkleTree overflowed its bits array")))
        )

        (§ var #_"boolean" (§ name parentOfMatch) (§ expr checkBitLE(§ pars matchedChildBits, used.bitsUsed)))
        (§ ass (§ name used.bitsUsed) (§ expr used.bitsUsed + 1))

        ;; if at height 0, or nothing interesting below, use stored hash and do not descend
        (§ if (§ expr height == 0 || (§ not parentOfMatch)))
        (§ block
            ;; overflowed hash array - failure
            (§ if (§ expr hashes.size(§ pars ) <= used.hashesUsed))
            (§ block
                (§ throw (§ new #_"VerificationException" (§ pars "PartialMerkleTree overflowed its hash array")))
            )

            (§ var #_"Sha256Hash" (§ name hash) (§ expr hashes.get(§ pars used.hashesUsed)))
            (§ ass (§ name used.hashesUsed) (§ expr used.hashesUsed + 1))
            ;; in case of height 0, we have a matched txid
            (§ if (§ expr height == 0 && parentOfMatch))
            (§ block
                (§ expr matchedHashes.add(§ pars hash))
            )

            (§ return hash)
        )
        (§ else )
        (§ block
            ;; otherwise, descend into the subtrees to extract matched txids and hashes
            (§ var #_"byte[]" (§ name left) (§ expr recursiveExtractHashes(§ pars height - 1, pos * 2, used, matchedHashes).getBytes(§ pars ), right))
            (§ if (§ expr pos * 2 + 1 < getTreeWidth(§ pars transactionCount, height - 1)))
            (§ block
                (§ ass (§ name right) (§ expr recursiveExtractHashes(§ pars height - 1, pos * 2 + 1, used, matchedHashes).getBytes(§ pars )))
                (§ if (§ expr Arrays/equals(§ pars right, left)))
                (§ block
                    (§ throw (§ new #_"VerificationException" (§ pars "Invalid merkle tree with duplicated left/right branches")))
                )
            )
            (§ else )
            (§ block
                (§ ass (§ name right) left)
            )
            ;; and combine them before returning
            (§ return (§ expr combineLeftRight(§ pars left, right)))
        )
    )

    #_private
    #_static
    (§ method #_"Sha256Hash" (§ fn combineLeftRight) [#_"byte[]" (§ name left), #_"byte[]" (§ name right)])
    (§ block
        (§ return (§ expr Sha256Hash/wrapReversed(§ pars Sha256Hash/hashTwice(§ pars reverseBytes(§ pars left), 0, 32, reverseBytes(§ pars right), 0, 32))))
    )

    ;;;
     ; Extracts tx hashes that are in this merkle tree and returns the merkle root of this tree.
     ;
     ; The returned root should be checked against the merkle root contained in the block header for security.
     ;
     ; @param matchedHashesOut A list which will contain the matched txn (will be cleared).
     ; @return the merkle root of this merkle tree.
     ; @throws ProtocolException if this partial merkle tree is invalid.
     ;;
    #_public
    (§ method #_"Sha256Hash" (§ fn getTxnHashAndMerkleRoot) [#_"List<Sha256Hash>" (§ name matchedHashesOut)])
        (§ throws #_"VerificationException")
    (§ block
        (§ expr matchedHashesOut.clear(§ pars ))

        ;; an empty set will not work
        (§ if (§ expr transactionCount == 0))
        (§ block
            (§ throw (§ new #_"VerificationException" (§ pars "Got a CPartialMerkleTree with 0 transactions")))
        )
        ;; check for excessively high numbers of transactions
        (§ if (§ expr Block/MAX_BLOCK_SIZE / 60 < transactionCount)) ;; 60 is the lower bound for the size of a serialized CTransaction
        (§ block
            (§ throw (§ new #_"VerificationException" (§ pars "Got a CPartialMerkleTree with more transactions than is possible")))
        )
        ;; there can never be more hashes provided than one for every txid
        (§ if (§ expr transactionCount < hashes.size(§ pars )))
        (§ block
            (§ throw (§ new #_"VerificationException" (§ pars "Got a CPartialMerkleTree with more hashes than transactions")))
        )
        ;; there must be at least one bit per node in the partial tree, and at least one node per hash
        (§ if (§ expr matchedChildBits.length * 8 < hashes.size(§ pars )))
        (§ block
            (§ throw (§ new #_"VerificationException" (§ pars "Got a CPartialMerkleTree with fewer matched bits than hashes")))
        )

        ;; calculate height of tree
        (§ var #_"int" (§ name height) 0)
        (§ while (§ expr 1 < getTreeWidth(§ pars transactionCount, height)))
        (§ block
            (§ ass (§ name height) (§ expr height + 1))
        )
        ;; traverse the partial tree
        (§ var #_"ValuesUsed" (§ name used) (§ new #_"ValuesUsed" (§ pars )))
        (§ var #_"Sha256Hash" (§ name merkleRoot) (§ expr recursiveExtractHashes(§ pars height, 0, used, matchedHashesOut)))
        ;; verify that all bits were consumed (except for the padding caused by serializing it as a byte sequence)
        ;; verify that all hashes were consumed
        (§ if (§ expr (§ expr used.bitsUsed + 7) / 8 != matchedChildBits.length || used.hashesUsed != hashes.size(§ pars )))
        (§ block
            (§ throw (§ new #_"VerificationException" (§ pars "Got a CPartialMerkleTree that didn't need all the data it provided")))
        )

        (§ return merkleRoot)
    )

    #_public
    (§ method #_"int" (§ fn getTransactionCount) [])
    (§ block
        (§ return transactionCount)
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"PartialMerkleTree" (§ name other) (§ expr (§ cast #_"PartialMerkleTree" o)))
        (§ return (§ expr transactionCount == other.transactionCount && hashes.equals(§ pars other.hashes) && Arrays/equals(§ pars matchedChildBits, other.matchedChildBits)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars transactionCount, hashes, Arrays/hashCode(§ pars matchedChildBits))))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr "PartialMerkleTree{" + "transactionCount=" + transactionCount + ", matchedChildBits=" + Arrays/toString(§ pars matchedChildBits) + ", hashes=" + hashes + "}"))
    )
)

#_(ns org.bitcoinj.core #_"Peer"
    (:import [java.util *]
             [java.util.concurrent CopyOnWriteArrayList CopyOnWriteArraySet Executor]
             [java.util.concurrent.atomic AtomicInteger]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.base * Objects]
             [com.google.common.collect Lists]
             [com.google.common.util.concurrent FutureCallback Futures ListenableFuture SettableFuture]
             [net.jcip.annotations GuardedBy]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core.listeners *]
             [org.bitcoinj.net StreamConnection]
             [org.bitcoinj.store BlockStore BlockStoreException]
             [org.bitcoinj.utils ListenerRegistration Threading]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>A Peer handles the high level communication with a Bitcoin node, extending a {@link PeerSocketHandler} which
 ; handles low-level message (de)serialization.</p>
 ;
 ; <p>Note that timeouts are handled by the extended
 ; {@link org.bitcoinj.net.AbstractTimeoutHandler} and timeout is automatically disabled (using
 ; {@link org.bitcoinj.net.AbstractTimeoutHandler#setTimeoutEnabled(boolean)}) once the version
 ; handshake completes.</p>
 ;;
#_public
(§ class #_"Peer" (§ extends #_"PeerSocketHandler")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"Peer"))))

    #_protected
    #_final
    (§ field #_"ReentrantLock" (§ name lock) (§ expr Threading/lock(§ pars "peer")))

    #_private
    #_final
    (§ field #_"NetworkParameters" (§ name params))
    #_private
    #_final
    (§ field #_"AbstractBlockChain" (§ name blockChain))
    #_private
    #_final
    (§ field #_"Context" (§ name context))

    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<BlocksDownloadedEventListener>>" (§ name blocksDownloadedEventListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<ChainDownloadStartedEventListener>>" (§ name chainDownloadStartedEventListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<PeerConnectedEventListener>>" (§ name connectedEventListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<PeerDisconnectedEventListener>>" (§ name disconnectedEventListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<GetDataEventListener>>" (§ name getDataEventListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<PreMessageReceivedEventListener>>" (§ name preMessageReceivedEventListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<OnTransactionBroadcastListener>>" (§ name onTransactionEventListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))

    ;; Whether to try and download blocks and transactions from this peer.  Set to false by PeerGroup if not the
    ;; primary peer.  This is to avoid redundant work and concurrency problems with downloading the same chain
    ;; in parallel.
    #_private
    #_volatile
    (§ field #_"boolean" (§ name vDownloadData))
    ;; The version data to announce to the other side of the connections we make: useful for setting our "user agent"
    ;; equivalent and other things.
    #_private
    #_final
    (§ field #_"VersionMessage" (§ name versionMessage))
    ;; Maximum depth up to which pending transaction dependencies are downloaded, or 0 for disabled.
    #_private
    #_volatile
    (§ field #_"int" (§ name vDownloadTxDependencyDepth))
    ;; How many block messages the peer has announced to us.  Peers only announce blocks that attach to their best chain
    ;; so we can use this to calculate the height of the peers chain, by adding it to the initial height in the version
    ;; message.  This method can go wrong if the peer re-orgs onto a shorter (but harder) chain, however, this is rare.
    #_private
    #_final
    (§ field #_"AtomicInteger" (§ name blocksAnnounced) (§ new #_"AtomicInteger" (§ pars )))
    ;; Each wallet added to the peer will be notified of downloaded transaction data.
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<Wallet>" (§ name wallets))
    ;; A time before which we only download block headers, after that point we download block bodies.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"long" (§ name fastCatchupTimeSecs))
    ;; Whether we are currently downloading headers only or block bodies.  Starts at true.  If the fast catchup time is
    ;; set AND our best block is before that date, switch to false until block headers beyond that point have been
    ;; received at which point it gets set to true again.  This isn't relevant unless vDownloadData is true.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"boolean" (§ name downloadBlockBodies) true)
    ;; Whether to request filtered blocks instead of full blocks if the protocol version allows for them.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"boolean" (§ name useFilteredBlocks) false)
    ;; The current Bloom filter set on the connection, used to tell the remote peer what transactions to send us.
    #_private
    #_volatile
    (§ field #_"BloomFilter" (§ name vBloomFilter))
    ;; The last filtered block we received, we're waiting to fill it out with transactions.
    #_private
    (§ field #_"FilteredBlock" (§ name currentFilteredBlock) nil)
    ;; How many filtered blocks have been received during the lifetime of this connection.  Used to decide when to
    ;; refresh the server-side side filter by sending a new one (it degrades over time as false positives are added
    ;; on the remote side, see BIP 37 for a discussion of this).
    ;; TODO: Is this still needed?  It should not be since the auto FP tracking logic was added.
    #_private
    (§ field #_"int" (§ name filteredBlocksReceived))
    ;; If non-null, we should discard incoming filtered blocks because we ran out of keys and are awaiting a new filter
    ;; to be calculated by the PeerGroup.  The discarded block hashes should be added here so we can re-request them
    ;; once we've recalculated and resent a new filter.
    #_guarded-by(§ opt "lock")
    #_nilable
    #_private
    (§ field #_"List<Sha256Hash>" (§ name awaitingFreshFilter))
    ;; How frequently to refresh the filter.  This should become dynamic in future and calculated depending on the
    ;; actual false positive rate.  For now a good value was determined empirically around January 2013.
    #_private
    #_static
    #_final
    (§ field #_"int" (§ name RESEND_BLOOM_FILTER_BLOCK_COUNT) 25000)
    ;; Keeps track of things we requested internally with getdata but didn't receive yet, so we can avoid re-requests.
    ;; It's not quite the same as getDataFutures, as this is used only for getdatas done as part of downloading
    ;; the chain and so is lighter weight (we just keep a bunch of hashes not futures).
    ;;
    ;; It is important to avoid a nasty edge case where we can end up with parallel chain downloads proceeding
    ;; simultaneously if we were to receive a newly solved block whilst parts of the chain are streaming to us.
    #_private
    #_final
    (§ field #_"HashSet<Sha256Hash>" (§ name pendingBlockDownloads) (§ new #_"HashSet<>" (§ pars )))
    ;; Keep references to TransactionConfidence objects for transactions that were announced by a remote peer, but
    ;; which we haven't downloaded yet.  These objects are de-duplicated by the TxConfidenceTable class.
    ;; Once the tx is downloaded (by some peer), the Transaction object that is created will have a reference to
    ;; the confidence object held inside it, and it's then up to the event listeners that receive the Transaction
    ;; to keep it pinned to the root set if they care about this data.
    #_suppress(§ opt "MismatchedQueryAndUpdateOfCollection")
    #_private
    #_final
    (§ field #_"HashSet<TransactionConfidence>" (§ name pendingTxDownloads) (§ new #_"HashSet<>" (§ pars )))
    ;; The lowest version number we're willing to accept.  Lower than this will result in an immediate disconnect.
    #_private
    #_volatile
    (§ field #_"int" (§ name vMinProtocolVersion))
    ;; When an API user explicitly requests a block or transaction from a peer, the InventoryItem is put here
    ;; whilst waiting for the response.  Is not used for downloads Peer generates itself.
    #_private
    #_static
    (§ class #_"GetDataRequest"
        #_final
        (§ field #_"Sha256Hash" (§ name hash))
        #_final
        (§ field #_"SettableFuture" (§ name future))

        #_public
        (§ constructor #_"GetDataRequest" [#_"Sha256Hash" (§ name hash), #_"SettableFuture" (§ name future)])
        (§ block
            (§ ass (§ name this.hash) hash)
            (§ ass (§ name this.future) future)
            (§ void this)
        )
    )
    ;; TODO: The types/locking should be rationalised a bit.
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<GetDataRequest>" (§ name getDataFutures))
    #_guarded-by(§ opt "getAddrFutures")
    #_private
    #_final
    (§ field #_"LinkedList<SettableFuture<AddressMessage>>" (§ name getAddrFutures))

    #_private
    #_static
    #_final
    (§ field #_"int" (§ name PING_MOVING_AVERAGE_WINDOW) 20)

    ;; Outstanding pings against this peer and how long the last one took to complete.
    #_private
    #_final
    (§ field #_"ReentrantLock" (§ name lastPingTimesLock) (§ new #_"ReentrantLock" (§ pars )))
    #_guarded-by(§ opt "lastPingTimesLock")
    #_private
    (§ field #_"long[]" (§ name lastPingTimes))
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<PendingPing>" (§ name pendingPings))

    #_private
    #_volatile
    (§ field #_"VersionMessage" (§ name vPeerVersionMessage))

    ;; A settable future which completes (with this) when the connection is open.
    #_private
    #_final
    (§ field #_"SettableFuture<Peer>" (§ name connectionOpenFuture) (§ expr SettableFuture/create(§ pars )))
    #_private
    #_final
    (§ field #_"SettableFuture<Peer>" (§ name outgoingVersionHandshakeFuture) (§ expr SettableFuture/create(§ pars )))
    #_private
    #_final
    (§ field #_"SettableFuture<Peer>" (§ name incomingVersionHandshakeFuture) (§ expr SettableFuture/create(§ pars )))
    #_private
    #_final
    (§ field #_"ListenableFuture<Peer>" (§ name versionHandshakeFuture) (§ expr Futures/transform(§ pars Futures/allAsList(§ pars outgoingVersionHandshakeFuture, incomingVersionHandshakeFuture), new Function<List<Peer>, Peer>(§ pars )
        (§ anon
            #_override
            #_nilable
            #_public
            (§ method #_"Peer" (§ fn apply) [#_nilable #_"List<Peer>" (§ name peers)])
            (§ block
                (§ expr Preconditions/checkNotNull(§ pars peers))
                (§ expr Preconditions/checkState(§ pars peers.size(§ pars ) == 2 && peers.get(§ pars 0) == peers.get(§ pars 1)))
                (§ return (§ expr peers.get(§ pars 0)))
            )
        ))))

    ;;;
     ; <p>Construct a peer that reads/writes from the given block chain.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection.  If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
    #_public
    (§ constructor #_"Peer" [#_"NetworkParameters" (§ name params), #_"VersionMessage" (§ name ver), #_nilable #_"AbstractBlockChain" (§ name chain), #_"PeerAddress" (§ name remoteAddress)])
    (§ block
        (§ this (§ pars params, ver, remoteAddress, chain))
        (§ void this)
    )

    ;;;
     ; <p>Construct a peer that reads/writes from the given block chain.  Transactions stored in a {@link org.bitcoinj.core.TxConfidenceTable}
     ; will have their confidence levels updated when a peer announces it, to reflect the greater likelyhood that
     ; the transaction is valid.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection.  If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
    #_public
    (§ constructor #_"Peer" [#_"NetworkParameters" (§ name params), #_"VersionMessage" (§ name ver), #_"PeerAddress" (§ name remoteAddress), #_nilable #_"AbstractBlockChain" (§ name chain)])
    (§ block
        (§ this (§ pars params, ver, remoteAddress, chain, Integer/MAX_VALUE))
        (§ void this)
    )

    ;;;
     ; <p>Construct a peer that reads/writes from the given block chain.  Transactions stored in a {@link org.bitcoinj.core.TxConfidenceTable}
     ; will have their confidence levels updated when a peer announces it, to reflect the greater likelyhood that
     ; the transaction is valid.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection.  If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
    #_public
    (§ constructor #_"Peer" [#_"NetworkParameters" (§ name params), #_"VersionMessage" (§ name ver), #_"PeerAddress" (§ name remoteAddress), #_nilable #_"AbstractBlockChain" (§ name chain), #_"int" (§ name downloadTxDependencyDepth)])
    (§ block
        (§ super (§ pars params, remoteAddress))

        (§ ass (§ name this.params) (§ expr Preconditions/checkNotNull(§ pars params)))
        (§ ass (§ name this.versionMessage) (§ expr Preconditions/checkNotNull(§ pars ver)))
        (§ ass (§ name this.vDownloadTxDependencyDepth) (§ quest (§ expr chain != nil) ? downloadTxDependencyDepth :else 0))
        (§ ass (§ name this.blockChain) chain) ;; Allowed to be nil.
        (§ ass (§ name this.vDownloadData) (§ expr chain != nil))
        (§ ass (§ name this.getDataFutures) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
        (§ ass (§ name this.getAddrFutures) (§ new #_"LinkedList<>" (§ pars )))
        (§ ass (§ name this.fastCatchupTimeSecs) (§ expr params.getGenesisBlock(§ pars ).getTimeSeconds(§ pars )))
        (§ ass (§ name this.pendingPings) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
        (§ ass (§ name this.vMinProtocolVersion) (§ expr params.getProtocolVersionNum(§ pars NetworkParameters/ProtocolVersion/PONG)))
        (§ ass (§ name this.wallets) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
        (§ ass (§ name this.context) (§ expr Context/get(§ pars )))

        (§ expr this.versionHandshakeFuture.addListener(§ pars (§ new #_"Runnable" (§ pars ))
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn run) [])
            (§ block
                (§ expr versionHandshakeComplete(§ pars ))
                (§ void nil)
            )
        ), Threading.SAME_THREAD))
        (§ void this)
    )

    ;;;
     ; <p>Construct a peer that reads/writes from the given chain.  Automatically creates a VersionMessage for you from
     ; the given software name/version strings, which should be something like "MySimpleTool", "1.0" and which will tell
     ; the remote node to relay transaction inv messages before it has received a filter.</p>
     ;
     ; <p>Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection. If you want to create a one-off connection, create a Peer and pass it to
     ; {@link org.bitcoinj.net.NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link org.bitcoinj.net.NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.</p>
     ;
     ; <p>The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.</p>
     ;;
    #_public
    (§ constructor #_"Peer" [#_"NetworkParameters" (§ name params), #_"AbstractBlockChain" (§ name blockChain), #_"PeerAddress" (§ name peerAddress), #_"String" (§ name thisSoftwareName), #_"String" (§ name thisSoftwareVersion)])
    (§ block
        (§ this (§ pars params, new VersionMessage(§ pars params, blockChain.getBestChainHeight(§ pars )), blockChain, peerAddress))
        (§ expr this.versionMessage.appendToSubVer(§ pars thisSoftwareName, thisSoftwareVersion, nil))
        (§ void this)
    )

    ;;; Registers a listener that is invoked when new blocks are downloaded. ;;
    #_public
    (§ method #_"void" (§ fn addBlocksDownloadedEventListener) [#_"BlocksDownloadedEventListener" (§ name listener)])
    (§ block
        (§ expr addBlocksDownloadedEventListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;; Registers a listener that is invoked when new blocks are downloaded. ;;
    #_public
    (§ method #_"void" (§ fn addBlocksDownloadedEventListener) [#_"Executor" (§ name executor), #_"BlocksDownloadedEventListener" (§ name listener)])
    (§ block
        (§ expr blocksDownloadedEventListeners.add(§ pars (§ new #_"ListenerRegistration" (§ pars listener, executor))))
        (§ void nil)
    )

    ;;; Registers a listener that is invoked when a blockchain downloaded starts. ;;
    #_public
    (§ method #_"void" (§ fn addChainDownloadStartedEventListener) [#_"ChainDownloadStartedEventListener" (§ name listener)])
    (§ block
        (§ expr addChainDownloadStartedEventListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;; Registers a listener that is invoked when a blockchain downloaded starts. ;;
    #_public
    (§ method #_"void" (§ fn addChainDownloadStartedEventListener) [#_"Executor" (§ name executor), #_"ChainDownloadStartedEventListener" (§ name listener)])
    (§ block
        (§ expr chainDownloadStartedEventListeners.add(§ pars (§ new #_"ListenerRegistration" (§ pars listener, executor))))
        (§ void nil)
    )

    ;;; Registers a listener that is invoked when a peer is connected. ;;
    #_public
    (§ method #_"void" (§ fn addConnectedEventListener) [#_"PeerConnectedEventListener" (§ name listener)])
    (§ block
        (§ expr addConnectedEventListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;; Registers a listener that is invoked when a peer is connected. ;;
    #_public
    (§ method #_"void" (§ fn addConnectedEventListener) [#_"Executor" (§ name executor), #_"PeerConnectedEventListener" (§ name listener)])
    (§ block
        (§ expr connectedEventListeners.add(§ pars (§ new #_"ListenerRegistration" (§ pars listener, executor))))
        (§ void nil)
    )

    ;;; Registers a listener that is invoked when a peer is disconnected. ;;
    #_public
    (§ method #_"void" (§ fn addDisconnectedEventListener) [#_"PeerDisconnectedEventListener" (§ name listener)])
    (§ block
        (§ expr addDisconnectedEventListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;; Registers a listener that is invoked when a peer is disconnected. ;;
    #_public
    (§ method #_"void" (§ fn addDisconnectedEventListener) [#_"Executor" (§ name executor), #_"PeerDisconnectedEventListener" (§ name listener)])
    (§ block
        (§ expr disconnectedEventListeners.add(§ pars (§ new #_"ListenerRegistration" (§ pars listener, executor))))
        (§ void nil)
    )

    ;;; Registers a listener that is called when messages are received. ;;
    #_public
    (§ method #_"void" (§ fn addGetDataEventListener) [#_"GetDataEventListener" (§ name listener)])
    (§ block
        (§ expr addGetDataEventListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;; Registers a listener that is called when messages are received. ;;
    #_public
    (§ method #_"void" (§ fn addGetDataEventListener) [#_"Executor" (§ name executor), #_"GetDataEventListener" (§ name listener)])
    (§ block
        (§ expr getDataEventListeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars listener, executor))))
        (§ void nil)
    )

    ;;; Registers a listener that is called when a transaction is broadcast across the network. ;;
    #_public
    (§ method #_"void" (§ fn addOnTransactionBroadcastListener) [#_"OnTransactionBroadcastListener" (§ name listener)])
    (§ block
        (§ expr addOnTransactionBroadcastListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;; Registers a listener that is called when a transaction is broadcast across the network. ;;
    #_public
    (§ method #_"void" (§ fn addOnTransactionBroadcastListener) [#_"Executor" (§ name executor), #_"OnTransactionBroadcastListener" (§ name listener)])
    (§ block
        (§ expr onTransactionEventListeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars listener, executor))))
        (§ void nil)
    )

    ;;; Registers a listener that is called immediately before a message is received. ;;
    #_public
    (§ method #_"void" (§ fn addPreMessageReceivedEventListener) [#_"PreMessageReceivedEventListener" (§ name listener)])
    (§ block
        (§ expr addPreMessageReceivedEventListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;; Registers a listener that is called immediately before a message is received. ;;
    #_public
    (§ method #_"void" (§ fn addPreMessageReceivedEventListener) [#_"Executor" (§ name executor), #_"PreMessageReceivedEventListener" (§ name listener)])
    (§ block
        (§ expr preMessageReceivedEventListeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars listener, executor))))
        (§ void nil)
    )

    #_public
    (§ method #_"boolean" (§ fn removeBlocksDownloadedEventListener) [#_"BlocksDownloadedEventListener" (§ name listener)])
    (§ block
        (§ return (§ expr ListenerRegistration/removeFromList(§ pars listener, blocksDownloadedEventListeners)))
    )

    #_public
    (§ method #_"boolean" (§ fn removeChainDownloadStartedEventListener) [#_"ChainDownloadStartedEventListener" (§ name listener)])
    (§ block
        (§ return (§ expr ListenerRegistration/removeFromList(§ pars listener, chainDownloadStartedEventListeners)))
    )

    #_public
    (§ method #_"boolean" (§ fn removeConnectedEventListener) [#_"PeerConnectedEventListener" (§ name listener)])
    (§ block
        (§ return (§ expr ListenerRegistration/removeFromList(§ pars listener, connectedEventListeners)))
    )

    #_public
    (§ method #_"boolean" (§ fn removeDisconnectedEventListener) [#_"PeerDisconnectedEventListener" (§ name listener)])
    (§ block
        (§ return (§ expr ListenerRegistration/removeFromList(§ pars listener, disconnectedEventListeners)))
    )

    #_public
    (§ method #_"boolean" (§ fn removeGetDataEventListener) [#_"GetDataEventListener" (§ name listener)])
    (§ block
        (§ return (§ expr ListenerRegistration/removeFromList(§ pars listener, getDataEventListeners)))
    )

    #_public
    (§ method #_"boolean" (§ fn removeOnTransactionBroadcastListener) [#_"OnTransactionBroadcastListener" (§ name listener)])
    (§ block
        (§ return (§ expr ListenerRegistration/removeFromList(§ pars listener, onTransactionEventListeners)))
    )

    #_public
    (§ method #_"boolean" (§ fn removePreMessageReceivedEventListener) [#_"PreMessageReceivedEventListener" (§ name listener)])
    (§ block
        (§ return (§ expr ListenerRegistration/removeFromList(§ pars listener, preMessageReceivedEventListeners)))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ var #_"PeerAddress" (§ name addr) (§ expr getAddress(§ pars )))
        ;; if null, it's a user-provided NetworkConnection object
        (§ return (§ quest (§ expr addr == nil) ? (§ expr "Peer()") :else (§ expr addr.toString(§ pars ))))
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn timeoutOccurred) [])
    (§ block
        (§ expr super.timeoutOccurred(§ pars ))

        (§ if (§ expr (§ not connectionOpenFuture.isDone(§ pars ))))
        (§ block
            ;; Invoke the event handlers to tell listeners e.g. PeerGroup that we never managed to connect.
            (§ expr connectionClosed(§ pars ))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn connectionClosed) [])
    (§ block
        (§ for (§ var #_final ListenerRegistration<PeerDisconnectedEventListener> registration) :for disconnectedEventListeners)
        (§ block
            (§ expr registration.executor.execute(§ pars (§ new #_"Runnable" (§ pars ))
            (§ anon
                #_override
                #_public
                (§ method #_"void" (§ fn run) [])
                (§ block
                    (§ expr registration.listener.onPeerDisconnected(§ pars (§ dhis Peer), 0))
                    (§ void nil)
                )
            )))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn connectionOpened) [])
    (§ block
        ;; Announce ourselves.  This has to come first to connect to clients beyond v0.3.20.2 which wait to hear
        ;; from us until they send their version message back.
        (§ var #_"PeerAddress" (§ name address) (§ expr getAddress(§ pars )))
        (§ expr log.info(§ pars "Announcing to {} as: {}", (§ quest (§ expr address != nil) ? (§ expr address.toSocketAddress(§ pars )) :else (§ expr "Peer")), versionMessage.subVer))
        (§ expr sendMessage(§ pars versionMessage))
        (§ expr connectionOpenFuture.set(§ pars this))
        ;; When connecting, the remote peer sends us a version message with various bits of
        ;; useful data in it.  We need to know the peer protocol version before we can talk to it.
        (§ void nil)
    )

    ;;;
     ; Provides a ListenableFuture that can be used to wait for the socket to connect.  A socket connection does not
     ; mean that protocol handshake has occurred.
     ;;
    #_public
    (§ method #_"ListenableFuture<Peer>" (§ fn getConnectionOpenFuture) [])
    (§ block
        (§ return connectionOpenFuture)
    )

    #_public
    (§ method #_"ListenableFuture<Peer>" (§ fn getVersionHandshakeFuture) [])
    (§ block
        (§ return versionHandshakeFuture)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn processMessage) [#_"Message" (§ name m)])
        (§ throws #_"Exception")
    (§ block
        ;; Allow event listeners to filter the message stream.  Listeners are allowed to drop messages by returning null.
        (§ for (§ var #_"ListenerRegistration<PreMessageReceivedEventListener>" (§ name registration)) :for preMessageReceivedEventListeners)
        (§ block
            ;; Skip any listeners that are supposed to run in another thread as we don't want to block waiting for it,
            ;; which might cause circular deadlock.
            (§ if (§ expr registration.executor == Threading/SAME_THREAD))
            (§ block
                (§ ass (§ name m) (§ expr registration.listener.onPreMessageReceived(§ pars this, m)))
                (§ if (§ expr m == nil))
                (§ block
                    (§ break )
                )
            )
        )
        (§ if (§ expr m == nil))
        (§ block
            (§ return nil)
        )

        ;; If we are in the middle of receiving transactions as part of a filtered block push from the remote node,
        ;; and we receive something that's not a transaction, then we're done.
        (§ if (§ expr currentFilteredBlock != nil && (§ not (§ insta m #_"Transaction"))))
        (§ block
            (§ expr endFilteredBlock(§ pars currentFilteredBlock))
            (§ ass (§ name currentFilteredBlock) nil)
        )

        ;; No further communication is possible until version handshake is complete.
        (§ if (§ expr (§ not (§ expr (§ insta m #_"VersionMessage") || (§ insta m #_"VersionAck") || (§ expr versionHandshakeFuture.isDone(§ pars ) && (§ not versionHandshakeFuture.isCancelled(§ pars )))))))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars "Received " + m.getClass(§ pars ).getSimpleName(§ pars ) + " before version handshake is complete.")))
        )

        (§ if (§ insta m #_"Ping"))
        (§ block
            (§ expr processPing(§ pars (§ cast #_"Ping" m)))
        )
        (§ elseif (§ insta m #_"Pong"))
        (§ block
            (§ expr processPong(§ pars (§ cast #_"Pong" m)))
        )
        (§ elseif (§ insta m #_"NotFoundMessage"))
        (§ block
            ;; This is sent to us when we did a getdata on some transactions that aren't in the peers memory pool.
            ;; Because NotFoundMessage is a subclass of InventoryMessage, the test for it must come before the next.
            (§ expr processNotFoundMessage(§ pars (§ cast #_"NotFoundMessage" m)))
        )
        (§ elseif (§ insta m #_"InventoryMessage"))
        (§ block
            (§ expr processInv(§ pars (§ cast #_"InventoryMessage" m)))
        )
        (§ elseif (§ insta m #_"Block"))
        (§ block
            (§ expr processBlock(§ pars (§ cast #_"Block" m)))
        )
        (§ elseif (§ insta m #_"FilteredBlock"))
        (§ block
            (§ expr startFilteredBlock(§ pars (§ cast #_"FilteredBlock" m)))
        )
        (§ elseif (§ insta m #_"Transaction"))
        (§ block
            (§ expr processTransaction(§ pars (§ cast #_"Transaction" m)))
        )
        (§ elseif (§ insta m #_"GetDataMessage"))
        (§ block
            (§ expr processGetData(§ pars (§ cast #_"GetDataMessage" m)))
        )
        (§ elseif (§ insta m #_"AddressMessage"))
        (§ block
            ;; We don't care about addresses of the network right now.  But in future,
            ;; we should save them in the wallet so we don't put too much load on the seed nodes and can
            ;; properly explore the network.
            (§ expr processAddressMessage(§ pars (§ cast #_"AddressMessage" m)))
        )
        (§ elseif (§ insta m #_"HeadersMessage"))
        (§ block
            (§ expr processHeaders(§ pars (§ cast #_"HeadersMessage" m)))
        )
        (§ elseif (§ insta m #_"AlertMessage"))
        (§ block
            (§ expr processAlert(§ pars (§ cast #_"AlertMessage" m)))
        )
        (§ elseif (§ insta m #_"VersionMessage"))
        (§ block
            (§ expr processVersionMessage(§ pars (§ cast #_"VersionMessage" m)))
        )
        (§ elseif (§ insta m #_"VersionAck"))
        (§ block
            (§ expr processVersionAck(§ pars (§ cast #_"VersionAck" m)))
        )
        (§ elseif (§ insta m #_"RejectMessage"))
        (§ block
            (§ expr log.error(§ pars "{} {}: Received {}", this, getPeerVersionMessage(§ pars ).subVer, m))
        )
        (§ else )
        (§ block
            (§ expr log.warn(§ pars "{}: Received unhandled message: {}", this, m))
        )
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn processAddressMessage) [#_"AddressMessage" (§ name m)])
    (§ block
        (§ var #_"SettableFuture<AddressMessage>" (§ name future))
        (§ sync getAddrFutures)
        (§ block
            (§ ass (§ name future) (§ expr getAddrFutures.poll(§ pars )))
            (§ if (§ expr future == nil)) ;; Not an addr message we are waiting for.
            (§ block
                (§ return nil)
            )
        )
        (§ expr future.set(§ pars m))
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn processVersionMessage) [#_"VersionMessage" (§ name m)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ if (§ expr vPeerVersionMessage != nil))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars "Got two version messages from peer")))
        )

        (§ ass (§ name vPeerVersionMessage) m)
        ;; Switch to the new protocol version.
        (§ var #_"long" (§ name peerTime) (§ expr vPeerVersionMessage.time * 1000))
        (§ expr log.info(§ pars "{}: Got version={}, subVer='{}', services=0x{}, time={}, blocks={}", this, vPeerVersionMessage.clientVersion, vPeerVersionMessage.subVer, vPeerVersionMessage.localServices, String/format(§ pars Locale/US, "%tF %tT", peerTime, peerTime), vPeerVersionMessage.bestHeight))
        ;; bitcoinj is a client mode implementation.  That means there's not much point in us talking to other client
        ;; mode nodes because we can't download the data from them we need to find/verify transactions.  Some bogus
        ;; implementations claim to have a block chain in their services field but then report a height of zero, filter
        ;; them out here.
        (§ if (§ expr (§ not vPeerVersionMessage.hasBlockChain(§ pars )) || (§ expr (§ not params.allowEmptyPeerChain(§ pars )) && vPeerVersionMessage.bestHeight == 0)))
        (§ block
            ;; Shut down the channel gracefully.
            (§ expr log.info(§ pars "{}: Peer does not have a copy of the block chain.", this))
            (§ expr close(§ pars ))
            (§ return nil)
        )

        (§ if (§ expr vPeerVersionMessage.bestHeight < 0))
        (§ block
            ;; In this case, it's a protocol violation.
            (§ throw (§ new #_"ProtocolException" (§ pars "Peer reports invalid best height: " + vPeerVersionMessage.bestHeight)))
        )
        ;; Now it's our turn ...
        ;; Send an ACK message stating we accept the peers protocol version.
        (§ expr sendMessage(§ pars (§ new #_"VersionAck" (§ pars ))))
        (§ expr log.debug(§ pars "{}: Incoming version handshake complete.", this))
        (§ expr incomingVersionHandshakeFuture.set(§ pars this))
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn processVersionAck) [#_"VersionAck" (§ name m)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ if (§ expr vPeerVersionMessage == nil))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars "got a version ack before version")))
        )

        (§ if (§ expr outgoingVersionHandshakeFuture.isDone(§ pars )))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars "got more than one version ack")))
        )

        (§ expr log.debug(§ pars "{}: Outgoing version handshake complete.", this))
        (§ expr outgoingVersionHandshakeFuture.set(§ pars this))
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn versionHandshakeComplete) [])
    (§ block
        (§ expr log.debug(§ pars "{}: Handshake complete.", this))
        (§ expr setTimeoutEnabled(§ pars false))
        (§ for (§ var #_final ListenerRegistration<PeerConnectedEventListener> registration) :for connectedEventListeners)
        (§ block
            (§ expr registration.executor.execute(§ pars (§ new #_"Runnable" (§ pars ))
            (§ anon
                #_override
                #_public
                (§ method #_"void" (§ fn run) [])
                (§ block
                    (§ expr registration.listener.onPeerConnected(§ pars (§ dhis Peer), 1))
                    (§ void nil)
                )
            )))
        )
        ;; We check min version after onPeerConnected as channel.close() will
        ;; call onPeerDisconnected, and we should probably call onPeerConnected first.
        #_final
        (§ var #_"int" (§ name version) vMinProtocolVersion)
        (§ if (§ expr vPeerVersionMessage.clientVersion < version))
        (§ block
            (§ expr log.warn(§ pars "Connected to a peer speaking protocol version {} but need {}, closing", vPeerVersionMessage.clientVersion, version))
            (§ expr close(§ pars ))
        )
        (§ void nil)
    )

    #_protected
    (§ method #_"void" (§ fn startFilteredBlock) [#_"FilteredBlock" (§ name m)])
    (§ block
        ;; Filtered blocks come before the data that they refer to, so stash it here and then fill it out as
        ;; messages stream in.  We'll call endFilteredBlock when a non-tx message arrives (e.g. another
        ;; FilteredBlock) or when a tx that isn't needed by that block is found.  A ping message is sent after
        ;; a getblocks, to force the non-tx message path.
        (§ ass (§ name currentFilteredBlock) m)
        ;; Potentially refresh the server side filter.  Because the remote node adds hits back into the filter
        ;; to save round-tripping back through us, the filter degrades over time as false positives get added,
        ;; triggering yet more false positives.  We refresh it every so often to get the FP rate back down.
        (§ ass (§ name filteredBlocksReceived) (§ expr filteredBlocksReceived + 1))
        (§ if (§ expr filteredBlocksReceived % RESEND_BLOOM_FILTER_BLOCK_COUNT == RESEND_BLOOM_FILTER_BLOCK_COUNT - 1))
        (§ block
            (§ expr sendMessage(§ pars vBloomFilter))
        )
        (§ void nil)
    )

    #_protected
    (§ method #_"void" (§ fn processNotFoundMessage) [#_"NotFoundMessage" (§ name m)])
    (§ block
        ;; This is received when we previously did a getdata but the peer couldn't find what we requested in it's
        ;; memory pool.  Typically, because we are downloading dependencies of a relevant transaction and reached
        ;; the bottom of the dependency tree (where the unconfirmed transactions connect to transactions that are
        ;; in the chain).
        ;;
        ;; We go through and cancel the pending getdata futures for the items we were told weren't found.
        (§ for (§ var #_"GetDataRequest" (§ name req)) :for getDataFutures)
        (§ block
            (§ for (§ var #_"InventoryItem" (§ name item)) :for (§ expr m.getItems(§ pars )))
            (§ block
                (§ if (§ expr item.hash.equals(§ pars req.hash)))
                (§ block
                    (§ expr log.info(§ pars "{}: Bottomed out dep tree at {}", this, req.hash))
                    (§ expr req.future.cancel(§ pars true))
                    (§ expr getDataFutures.remove(§ pars req))
                    (§ break )
                )
            )
        )
        (§ void nil)
    )

    #_protected
    (§ method #_"void" (§ fn processAlert) [#_"AlertMessage" (§ name m)])
    (§ block
        (§ try )
        (§ block
            (§ if (§ expr m.isSignatureValid(§ pars )))
            (§ block
                (§ expr log.info(§ pars "Received alert from peer {}: {}", this, m.getStatusBar(§ pars )))
            )
            (§ else )
            (§ block
                (§ expr log.warn(§ pars "Received alert with invalid signature from peer {}: {}", this, m.getStatusBar(§ pars )))
            )
        )
        (§ catch #_"Throwable" (§ name t))
        (§ block
            ;; Signature checking can FAIL on Android platforms before Gingerbread apparently due to bugs in their
            ;; BigInteger implementations!  See https://github.com/bitcoinj/bitcoinj/issues/526 for discussion.
            ;; As alerts are just optional and not that useful, we just swallow the error here.
            (§ expr log.error(§ pars "Failed to check signature: bug in platform libraries?", t))
        )
        (§ void nil)
    )

    #_protected
    (§ method #_"void" (§ fn processHeaders) [#_"HeadersMessage" (§ name m)])
        (§ throws #_"ProtocolException")
    (§ block
        ;; Runs in network loop thread for this peer.
        ;;
        ;; This method can run if a peer just randomly sends us a "headers" message (should never happen), or more
        ;; likely when we've requested them as part of chain download using fast catchup.  We need to add each block to
        ;; the chain if it pre-dates the fast catchup time.  If we go past it, we can stop processing the headers and
        ;; request the full blocks from that point on instead.
        (§ var #_"boolean" (§ name downloadBlockBodies))
        (§ var #_"long" (§ name fastCatchupTimeSecs))

        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr blockChain == nil))
            (§ block
                ;; Can happen if we are receiving unrequested data, or due to programmer error.
                (§ expr log.warn(§ pars "Received headers when Peer is not configured with a chain."))
                (§ return nil)
            )
            (§ ass (§ name fastCatchupTimeSecs) (§ expr this.fastCatchupTimeSecs))
            (§ ass (§ name downloadBlockBodies) (§ expr this.downloadBlockBodies))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )

        (§ try )
        (§ block
            (§ expr Preconditions/checkState(§ pars (§ not downloadBlockBodies), toString(§ pars )))

            (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < m.getBlockHeaders(§ pars ).size(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
            (§ block
                (§ var #_"Block" (§ name header) (§ expr m.getBlockHeaders(§ pars ).get(§ pars i)))
                ;; Process headers until we pass the fast catchup time, or are about to catch up with the head
                ;; of the chain - always process the last block as a full/filtered block to kick us out of the
                ;; fast catchup mode (in which we ignore new blocks).
                (§ var #_"boolean" (§ name passedTime) (§ expr fastCatchupTimeSecs <= header.getTimeSeconds(§ pars )))
                (§ var #_"boolean" (§ name reachedTop) (§ expr vPeerVersionMessage.bestHeight <= blockChain.getBestChainHeight(§ pars )))
                (§ if (§ expr (§ not passedTime) && (§ not reachedTop)))
                (§ block
                    (§ if (§ expr (§ not vDownloadData)))
                    (§ block
                        ;; Not download peer anymore, some other peer probably became better.
                        (§ expr log.info(§ pars "Lost download peer status, throwing away downloaded headers."))
                        (§ return nil)
                    )
                    (§ if (§ expr blockChain.add(§ pars header)))
                    (§ block
                        ;; The block was successfully linked into the chain. Notify the user of our progress.
                        (§ expr invokeOnBlocksDownloaded(§ pars header, nil))
                    )
                    (§ else )
                    (§ block
                        ;; This block is unconnected - we don't know how to get from it back to the genesis block yet.
                        ;; That must mean that the peer is buggy or malicious because we specifically requested for
                        ;; headers that are part of the best chain.
                        (§ throw (§ new #_"ProtocolException" (§ pars "Got unconnected header from peer: " + header.getHashAsString(§ pars ))))
                    )
                )
                (§ else )
                (§ block
                    (§ expr lock.lock(§ pars ))
                    (§ try )
                    (§ block
                        (§ expr log.info(§ pars "Passed the fast catchup time ({}) at height {}, discarding {} headers and requesting full blocks", Utils/dateTimeFormat(§ pars fastCatchupTimeSecs * 1000), blockChain.getBestChainHeight(§ pars ) + 1, m.getBlockHeaders(§ pars ).size(§ pars ) - i))
                        (§ ass (§ name this.downloadBlockBodies) true)
                        ;; Prevent this request being seen as a duplicate.
                        (§ ass (§ name this.lastGetBlocksBegin) (§ expr Sha256Hash/ZERO_HASH))
                        (§ expr blockChainDownloadLocked(§ pars Sha256Hash/ZERO_HASH))
                    )
                    (§ finally )
                    (§ block
                        (§ expr lock.unlock(§ pars ))
                    )
                    (§ return nil)
                )
            )
            ;; We added all headers in the message to the chain.
            ;; Request some more if we got up to the limit, otherwise we are at the end of the chain.
            (§ if (§ expr HeadersMessage/MAX_HEADERS <= m.getBlockHeaders(§ pars ).size(§ pars )))
            (§ block
                (§ expr lock.lock(§ pars ))
                (§ try )
                (§ block
                    (§ expr blockChainDownloadLocked(§ pars Sha256Hash/ZERO_HASH))
                )
                (§ finally )
                (§ block
                    (§ expr lock.unlock(§ pars ))
                )
            )
        )
        (§ catch #_"VerificationException" (§ name e))
        (§ block
            (§ expr log.warn(§ pars "Block header verification failed", e))
        )
        (§ catch #_"PrunedException" (§ name e))
        (§ block
            ;; Unreachable when in SPV mode.
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
        (§ void nil)
    )

    #_protected
    (§ method #_"void" (§ fn processGetData) [#_"GetDataMessage" (§ name getdata)])
    (§ block
        (§ expr log.info(§ pars "{}: Received getdata message: {}", getAddress(§ pars ), getdata.toString(§ pars )))
        (§ var #_"ArrayList<Message>" (§ name items) (§ new #_"ArrayList<>" (§ pars )))
        (§ for (§ var #_"ListenerRegistration<GetDataEventListener>" (§ name registration)) :for getDataEventListeners)
        (§ block
            (§ if (§ expr registration.executor != Threading/SAME_THREAD))
            (§ block
                (§ continue )
            )
            (§ var #_"List<Message>" (§ name listenerItems) (§ expr registration.listener.getData(§ pars this, getdata)))
            (§ if (§ expr listenerItems == nil))
            (§ block
                (§ continue )
            )
            (§ expr items.addAll(§ pars listenerItems))
        )
        (§ if (§ expr (§ not items.isEmpty(§ pars ))))
        (§ block
            (§ expr log.info(§ pars "{}: Sending {} items gathered from listeners to peer", getAddress(§ pars ), items.size(§ pars )))
            (§ for (§ var #_"Message" (§ name item)) :for items)
            (§ block
                (§ expr sendMessage(§ pars item))
            )
        )
        (§ void nil)
    )

    #_protected
    (§ method #_"void" (§ fn processTransaction) [#_final #_"Transaction" (§ name tx)])
        (§ throws #_"VerificationException")
    (§ block
        ;; Check a few basic syntax issues to ensure the received TX isn't nonsense.
        (§ expr tx.verify(§ pars ))
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr log.debug(§ pars "{}: Received tx {}", getAddress(§ pars ), tx.getHashAsString(§ pars )))
            ;; Label the transaction as coming in from the P2P network (as opposed to being created by us, direct import,
            ;; etc).  This helps the wallet decide how to risk analyze it later.
            ;;
            ;; Additionally, by invoking tx.getConfidence(), this tx now pins the confidence data into the heap, meaning
            ;; we can stop holding a reference to the confidence object ourselves.  It's up to event listeners on the
            ;; Peer to stash the tx object somewhere if they want to keep receiving updates about network propagation
            ;; and so on.
            (§ var #_"TransactionConfidence" (§ name confidence) (§ expr tx.getConfidence(§ pars )))
            (§ expr confidence.setSource(§ pars TransactionConfidence/Source/NETWORK))
            (§ expr pendingTxDownloads.remove(§ pars confidence))
            (§ if (§ expr maybeHandleRequestedData(§ pars tx)))
            (§ block
                (§ return nil)
            )

            (§ if (§ expr currentFilteredBlock != nil))
            (§ block
                (§ if (§ expr (§ not currentFilteredBlock.provideTransaction(§ pars tx))))
                (§ block
                    ;; Got a tx that didn't fit into the filtered block, so we must have received everything.
                    (§ expr endFilteredBlock(§ pars currentFilteredBlock))
                    (§ ass (§ name currentFilteredBlock) nil)
                )
                ;; Don't tell wallets or listeners about this tx as they'll learn about it when the filtered block is
                ;; fully downloaded instead.
                (§ return nil)
            )

            ;; It's a broadcast transaction.  Tell all wallets about this tx so they can check if it's relevant or not.
            (§ for (§ var #_final Wallet wallet) :for wallets)
            (§ block
                (§ try )
                (§ block
                    (§ if (§ expr wallet.isPendingTransactionRelevant(§ pars tx)))
                    (§ block
                        (§ if (§ expr 0 < vDownloadTxDependencyDepth))
                        (§ block
                            ;; This transaction seems interesting to us, so let's download its dependencies.  This has
                            ;; several purposes: we can check that the sender isn't attacking us by engaging in protocol
                            ;; abuse games, like depending on a time-locked transaction that will never confirm, or
                            ;; building huge chains of unconfirmed transactions (again - so they don't confirm and the
                            ;; money can be taken back with a Finney attack).  Knowing the dependencies also lets us
                            ;; store them in a serialized wallet so we always have enough data to re-announce to the
                            ;; network and get the payment into the chain, in case the sender goes away and the network
                            ;; starts to forget.
                            ;;
                            ;; TODO: Not all the above things are implemented.
                            ;;
                            ;; Note that downloading of dependencies can end up walking around 15 minutes back even
                            ;; through transactions that have confirmed, as getdata on the remote peer also checks
                            ;; relay memory not only the mempool.  Unfortunately we have no way to know that here.
                            ;; In practice it should not matter much.
                            (§ expr Futures/addCallback(§ pars downloadDependencies(§ pars tx), new FutureCallback<List<Transaction>>(§ pars )
                            (§ anon
                                #_override
                                #_public
                                (§ method #_"void" (§ fn onSuccess) [#_"List<Transaction>" (§ name dependencies)])
                                (§ block
                                    (§ try )
                                    (§ block
                                        (§ expr log.info(§ pars "{}: Dependency download complete!", getAddress(§ pars )))
                                        (§ expr wallet.receivePending(§ pars tx, dependencies))
                                    )
                                    (§ catch #_"VerificationException" (§ name e))
                                    (§ block
                                        (§ expr log.error(§ pars "{}: Wallet failed to process pending transaction {}", getAddress(§ pars ), tx.getHash(§ pars )))
                                        (§ expr log.error(§ pars "Error was: ", e))
                                        ;; Not much more we can do at this point.
                                    )
                                    (§ void nil)
                                )

                                #_override
                                #_public
                                (§ method #_"void" (§ fn onFailure) [#_"Throwable" (§ name throwable)])
                                (§ block
                                    (§ expr log.error(§ pars "Could not download dependencies of tx {}", tx.getHashAsString(§ pars )))
                                    (§ expr log.error(§ pars "Error was: ", throwable))
                                    ;; Not much more we can do at this point.
                                    (§ void nil)
                                )
                            )))
                        )
                        (§ else )
                        (§ block
                            (§ expr wallet.receivePending(§ pars tx, nil))
                        )
                    )
                )
                (§ catch #_"VerificationException" (§ name e))
                (§ block
                    (§ expr log.error(§ pars "Wallet failed to verify tx", e))
                    ;; Carry on, listeners may still want to know.
                )
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        ;; Tell all listeners about this tx so they can decide whether to keep it or not.  If no listener keeps a
        ;; reference around then the memory pool will forget about it after a while too because it uses weak references.
        (§ for (§ var #_final ListenerRegistration<OnTransactionBroadcastListener> registration) :for onTransactionEventListeners)
        (§ block
            (§ expr registration.executor.execute(§ pars (§ new #_"Runnable" (§ pars ))
            (§ anon
                #_override
                #_public
                (§ method #_"void" (§ fn run) [])
                (§ block
                    (§ expr registration.listener.onTransaction(§ pars (§ dhis Peer), tx))
                    (§ void nil)
                )
            )))
        )
        (§ void nil)
    )

    ;;;
     ; <p>Returns a future that wraps a list of all transactions that the given transaction depends on, recursively.
     ; Only transactions in peers memory pools are included; the recursion stops at transactions that are in the
     ; current best chain.  So it doesn't make much sense to provide a tx that was already in the best chain and
     ; a precondition checks this.</p>
     ;
     ; <p>For example, if tx has 2 inputs that connect to transactions A and B, and transaction B is unconfirmed and
     ; has one input connecting to transaction C that is unconfirmed, and transaction C connects to transaction D
     ; that is in the chain, then this method will return either {B, C} or {C, B}.  No ordering is guaranteed.</p>
     ;
     ; <p>This method is useful for apps that want to learn about how long an unconfirmed transaction might take
     ; to confirm, by checking for unexpectedly time locked transactions, unusually deep dependency trees or fee-paying
     ; transactions that depend on unconfirmed free transactions.</p>
     ;
     ; <p>Note that dependencies downloaded this way will not trigger the onTransaction method of event listeners.</p>
     ;;
    #_public
    (§ method #_"ListenableFuture<List<Transaction>>" (§ fn downloadDependencies) [#_"Transaction" (§ name tx)])
    (§ block
        (§ var #_"TransactionConfidence.ConfidenceType" (§ name txConfidence) (§ expr tx.getConfidence(§ pars ).getConfidenceType(§ pars )))
        (§ expr Preconditions/checkArgument(§ pars txConfidence != TransactionConfidence/ConfidenceType/BUILDING))
        (§ expr log.info(§ pars "{}: Downloading dependencies of {}", getAddress(§ pars ), tx.getHashAsString(§ pars )))
        #_final
        (§ var #_"LinkedList<Transaction>" (§ name results) (§ new #_"LinkedList<>" (§ pars )))
        ;; future will be invoked when the entire dependency tree has been walked and the results compiled.
        #_final
        (§ var #_"ListenableFuture<Object>" (§ name future) (§ expr downloadDependenciesInternal(§ pars vDownloadTxDependencyDepth, 0, tx, new Object(§ pars ), results)))
        #_final
        (§ var #_"SettableFuture<List<Transaction>>" (§ name resultFuture) (§ expr SettableFuture/create(§ pars )))
        (§ expr Futures/addCallback(§ pars future, new FutureCallback<Object>(§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn onSuccess) [#_"Object" (§ name ignored)])
            (§ block
                (§ expr resultFuture.set(§ pars results))
                (§ void nil)
            )

            #_override
            #_public
            (§ method #_"void" (§ fn onFailure) [#_"Throwable" (§ name throwable)])
            (§ block
                (§ expr resultFuture.setException(§ pars throwable))
                (§ void nil)
            )
        )))
        (§ return resultFuture)
    )

    ;; The marker object in the future returned is the same as the parameter.  It is arbitrary and can be anything.
    #_protected
    (§ method #_"ListenableFuture<Object>" (§ fn downloadDependenciesInternal) [#_final #_"int" (§ name maxDepth), #_final #_"int" (§ name depth), #_final #_"Transaction" (§ name tx), #_final #_"Object" (§ name marker), #_final #_"List<Transaction>" (§ name results)])
    (§ block
        #_final
        (§ var #_"SettableFuture<Object>" (§ name resultFuture) (§ expr SettableFuture/create(§ pars )))
        #_final
        (§ var #_"Sha256Hash" (§ name rootTxHash) (§ expr tx.getHash(§ pars )))
        ;; We want to recursively grab its dependencies.  This is so listeners can learn important information like
        ;; whether a transaction is dependent on a timelocked transaction or has an unexpectedly deep dependency tree
        ;; or depends on a no-fee transaction.

        ;; We may end up requesting transactions that we've already downloaded and thrown away here.
        (§ var #_"Set<Sha256Hash>" (§ name needToRequest) (§ new #_"CopyOnWriteArraySet<>" (§ pars )))
        (§ for (§ var #_"TransactionInput" (§ name input)) :for (§ expr tx.getInputs(§ pars )))
        (§ block
            ;; There may be multiple inputs that connect to the same transaction.
            (§ expr needToRequest.add(§ pars input.getOutpoint(§ pars ).getHash(§ pars )))
        )

        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; Build the request for the missing dependencies.
            (§ var #_"List<ListenableFuture<Transaction>>" (§ name futures) (§ expr Lists/newArrayList(§ pars )))
            (§ var #_"GetDataMessage" (§ name getdata) (§ new #_"GetDataMessage" (§ pars params)))

            (§ if (§ expr 1 < needToRequest.size(§ pars )))
            (§ block
                (§ expr log.info(§ pars "{}: Requesting {} transactions for depth {} dep resolution", getAddress(§ pars ), needToRequest.size(§ pars ), depth + 1))
            )

            (§ for (§ var #_"Sha256Hash" (§ name hash)) :for needToRequest)
            (§ block
                (§ expr getdata.addTransaction(§ pars hash))
                (§ var #_"GetDataRequest" (§ name req) (§ new #_"GetDataRequest" (§ pars hash, SettableFuture/create(§ pars ))))
                (§ expr futures.add(§ pars req.future))
                (§ expr getDataFutures.add(§ pars req))
            )

            (§ var #_"ListenableFuture<List<Transaction>>" (§ name successful) (§ expr Futures/successfulAsList(§ pars futures)))
            (§ expr Futures/addCallback(§ pars successful, new FutureCallback<List<Transaction>>(§ pars )
            (§ anon
                #_override
                #_public
                (§ method #_"void" (§ fn onSuccess) [#_"List<Transaction>" (§ name transactions)])
                (§ block
                    ;; Once all transactions either were received, or we know there are no more to come, ...
                    ;; Note that transactions will contain "null" for any positions that weren't successful.
                    (§ var #_"List<ListenableFuture<Object>>" (§ name childFutures) (§ expr Lists/newLinkedList(§ pars )))
                    (§ for (§ var #_"Transaction" (§ name tx)) :for transactions)
                    (§ block
                        (§ if (§ expr tx == nil))
                        (§ block
                            (§ continue )
                        )
                        (§ expr log.info(§ pars "{}: Downloaded dependency of {}: {}", getAddress(§ pars ), rootTxHash, tx.getHashAsString(§ pars )))
                        (§ expr results.add(§ pars tx))
                        ;; Now recurse into the dependencies of this transaction too.
                        (§ if (§ expr depth + 1 < maxDepth))
                        (§ block
                            (§ expr childFutures.add(§ pars downloadDependenciesInternal(§ pars maxDepth, depth + 1, tx, marker, results)))
                        )
                    )
                    (§ if (§ expr childFutures.size(§ pars ) == 0))
                    (§ block
                        ;; Short-circuit: we're at the bottom of this part of the tree.
                        (§ expr resultFuture.set(§ pars marker))
                    )
                    (§ else )
                    (§ block
                        ;; There are some children to download.  Wait until it's done (and their children, and their
                        ;; children, ...) to inform the caller that we're finished.
                        (§ expr Futures/addCallback(§ pars Futures/successfulAsList(§ pars childFutures), new FutureCallback<List<Object>>(§ pars )
                        (§ anon
                            #_override
                            #_public
                            (§ method #_"void" (§ fn onSuccess) [#_"List<Object>" (§ name objects)])
                            (§ block
                                (§ expr resultFuture.set(§ pars marker))
                                (§ void nil)
                            )

                            #_override
                            #_public
                            (§ method #_"void" (§ fn onFailure) [#_"Throwable" (§ name throwable)])
                            (§ block
                                (§ expr resultFuture.setException(§ pars throwable))
                                (§ void nil)
                            )
                        )))
                    )
                    (§ void nil)
                )

                #_override
                #_public
                (§ method #_"void" (§ fn onFailure) [#_"Throwable" (§ name throwable)])
                (§ block
                    (§ expr resultFuture.setException(§ pars throwable))
                    (§ void nil)
                )
            )))

            ;; Start the operation.
            (§ expr sendMessage(§ pars getdata))
        )
        (§ catch #_"Exception" (§ name e))
        (§ block
            (§ expr log.error(§ pars "{}: Couldn't send getdata in downloadDependencies({})", this, tx.getHash(§ pars ), e))
            (§ expr resultFuture.setException(§ pars e))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )

        (§ return resultFuture)
    )

    #_protected
    (§ method #_"void" (§ fn processBlock) [#_"Block" (§ name m)])
    (§ block
        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ expr log.debug(§ pars "{}: Received broadcast block {}", getAddress(§ pars ), m.getHashAsString(§ pars )))
        )

        ;; Was this block requested by getBlock()?
        (§ if (§ expr maybeHandleRequestedData(§ pars m)))
        (§ block
            (§ return nil)
        )

        (§ if (§ expr blockChain == nil))
        (§ block
            (§ expr log.debug(§ pars "Received block but was not configured with an AbstractBlockChain"))
            (§ return nil)
        )

        ;; Did we lose download peer status after requesting block data?
        (§ if (§ expr (§ not vDownloadData)))
        (§ block
            (§ expr log.debug(§ pars "{}: Received block we did not ask for: {}", getAddress(§ pars ), m.getHashAsString(§ pars )))
            (§ return nil)
        )

        (§ expr pendingBlockDownloads.remove(§ pars m.getHash(§ pars )))

        (§ try )
        (§ block
            ;; Otherwise it's a block sent to us because the peer thought we needed it, so add it to the block chain.
            (§ if (§ expr blockChain.add(§ pars m)))
            (§ block
                ;; The block was successfully linked into the chain.  Notify the user of our progress.
                (§ expr invokeOnBlocksDownloaded(§ pars m, nil))
            )
            (§ else )
            (§ block
                ;; This block is an orphan - we don't know how to get from it back to the genesis block yet.  That
                ;; must mean that there are blocks we are missing, so do another getblocks with a new block locator
                ;; to ask the peer to send them to us.  This can happen during the initial block chain download where
                ;; the peer will only send us 500 at a time and then sends us the head block expecting us to request
                ;; the others.
                ;;
                ;; We must do two things here:
                ;; (1) Request from current top of chain to the oldest ancestor of the received block in the orphan set.
                ;; (2) Filter out duplicate getblock requests (done in blockChainDownloadLocked).
                ;;
                ;; The reason for (1) is that otherwise if new blocks were solved during the middle of chain download
                ;; we'd do a blockChainDownloadLocked() on the new best chain head, which would cause us to try and grab the
                ;; chain twice (or more!) on the same connection!  The block chain would filter out the duplicates but
                ;; only at a huge speed penalty.  By finding the orphan root we ensure every getblocks looks the same
                ;; no matter how many blocks are solved, and therefore that the (2) duplicate filtering can work.
                ;;
                ;; We only do this if we are not currently downloading headers.  If we are then we don't want to kick
                ;; off a request for lots more headers in parallel.
                (§ expr lock.lock(§ pars ))
                (§ try )
                (§ block
                    (§ if downloadBlockBodies)
                    (§ block
                        #_final
                        (§ var #_"Block" (§ name orphanRoot) (§ expr Preconditions/checkNotNull(§ pars blockChain.getOrphanRoot(§ pars m.getHash(§ pars )))))
                        (§ expr blockChainDownloadLocked(§ pars orphanRoot.getHash(§ pars )))
                    )
                    (§ else )
                    (§ block
                        (§ expr log.info(§ pars "Did not start chain download on solved block due to in-flight header download."))
                    )
                )
                (§ finally )
                (§ block
                    (§ expr lock.unlock(§ pars ))
                )
            )
        )
        (§ catch #_"VerificationException" (§ name e))
        (§ block
            ;; We don't want verification failures to kill the thread.
            (§ expr log.warn(§ pars "{}: Block verification failed", getAddress(§ pars ), e))
        )
        (§ catch #_"PrunedException" (§ name e))
        (§ block
            ;; Unreachable when in SPV mode.
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
        (§ void nil)
    )

    ;; TODO: Fix this duplication.
    #_protected
    (§ method #_"void" (§ fn endFilteredBlock) [#_"FilteredBlock" (§ name m)])
    (§ block
        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ expr log.debug(§ pars "{}: Received broadcast filtered block {}", getAddress(§ pars ), m.getHash(§ pars ).toString(§ pars )))
        )

        (§ if (§ expr (§ not vDownloadData)))
        (§ block
            (§ expr log.debug(§ pars "{}: Received block we did not ask for: {}", getAddress(§ pars ), m.getHash(§ pars ).toString(§ pars )))
            (§ return nil)
        )

        (§ if (§ expr blockChain == nil))
        (§ block
            (§ expr log.debug(§ pars "Received filtered block but was not configured with an AbstractBlockChain"))
            (§ return nil)
        )

        ;; Note that we currently do nothing about peers which maliciously do not include transactions which
        ;; actually match our filter or which simply do not send us all the transactions we need: it can be fixed
        ;; by cross-checking peers against each other.
        (§ expr pendingBlockDownloads.remove(§ pars m.getBlockHeader(§ pars ).getHash(§ pars )))

        (§ try )
        (§ block
            ;; It's a block sent to us because the peer thought we needed it, so maybe add it to the block chain.
            ;; The FilteredBlock m here contains a list of hashes, and may contain Transaction objects for a subset
            ;; of the hashes (those that were sent to us by the remote peer).  Any hashes that haven't had a tx
            ;; provided in processTransaction are ones that were announced to us previously via an 'inv' so the
            ;; assumption is we have already downloaded them and either put them in the wallet, or threw them away
            ;; for being false positives.
            ;;
            ;; TODO: Fix the following protocol race.
            ;; It is possible for this code to go wrong such that we miss a confirmation.  If the remote peer announces
            ;; a relevant transaction via an 'inv' and then it immediately announces the block that confirms
            ;; the tx before we had a chance to download it+its dependencies and provide them to the wallet, then we
            ;; will add the block to the chain here without the tx being in the wallet and thus it will miss its
            ;; confirmation and become stuck forever.  The fix is to notice that there's a pending getdata for a tx
            ;; that appeared in this block and delay processing until it arrived ... it's complicated by the fact that
            ;; the data may be requested by a different peer to this one.

            ;; Ask each wallet attached to the peer/blockchain if this block exhausts the list of data items
            ;; (keys/addresses) that were used to calculate the previous filter.  If so, then it's possible this block
            ;; is only partial.  Check for discarding first so we don't check for exhaustion on blocks we already know
            ;; we're going to discard, otherwise redundant filters might end up being queued and calculated.
            (§ expr lock.lock(§ pars ))
            (§ try )
            (§ block
                (§ if (§ expr awaitingFreshFilter != nil))
                (§ block
                    (§ expr log.info(§ pars "Discarding block {} because we're still waiting for a fresh filter", m.getHash(§ pars )))
                    ;; We must record the hashes of blocks we discard because you cannot do getblocks twice on the same
                    ;; range of blocks and get an inv both times, due to the codepath in Bitcoin Core hitting
                    ;; CPeer::PushInventory() which checks CPeer::setInventoryKnown and thus deduplicates.
                    (§ expr awaitingFreshFilter.add(§ pars m.getHash(§ pars )))
                    (§ return nil) ;; Chain download process is restarted via a call to setBloomFilter.
                )

                (§ if (§ expr checkForFilterExhaustion(§ pars m)))
                (§ block
                    ;; Yes, so we must abandon the attempt to process this block and any further blocks we receive,
                    ;; then wait for the Bloom filter to be recalculated, sent to this peer and for the peer to acknowledge
                    ;; that the new filter is now in use (which we have to simulate with a ping/pong), and then we can
                    ;; safely restart the chain download with the new filter that contains a new set of lookahead keys.
                    (§ expr log.info(§ pars "Bloom filter exhausted whilst processing block {}, discarding", m.getHash(§ pars )))
                    (§ ass (§ name awaitingFreshFilter) (§ new #_"LinkedList<>" (§ pars )))
                    (§ expr awaitingFreshFilter.add(§ pars m.getHash(§ pars )))
                    (§ expr awaitingFreshFilter.addAll(§ pars blockChain.drainOrphanBlocks(§ pars )))
                    (§ return nil) ;; Chain download process is restarted via a call to setBloomFilter.
                )
            )
            (§ finally )
            (§ block
                (§ expr lock.unlock(§ pars ))
            )

            (§ if (§ expr blockChain.add(§ pars m)))
            (§ block
                ;; The block was successfully linked into the chain.  Notify the user of our progress.
                (§ expr invokeOnBlocksDownloaded(§ pars m.getBlockHeader(§ pars ), m))
            )
            (§ else )
            (§ block
                ;; This block is an orphan - we don't know how to get from it back to the genesis block yet.  That
                ;; must mean that there are blocks we are missing, so do another getblocks with a new block locator
                ;; to ask the peer to send them to us.  This can happen during the initial block chain download where
                ;; the peer will only send us 500 at a time and then sends us the head block expecting us to request
                ;; the others.
                ;;
                ;; We must do two things here:
                ;; (1) Request from current top of chain to the oldest ancestor of the received block in the orphan set.
                ;; (2) Filter out duplicate getblock requests (done in blockChainDownloadLocked).
                ;;
                ;; The reason for (1) is that otherwise if new blocks were solved during the middle of chain download
                ;; we'd do a blockChainDownloadLocked() on the new best chain head, which would cause us to try and grab the
                ;; chain twice (or more!) on the same connection!  The block chain would filter out the duplicates but
                ;; only at a huge speed penalty.  By finding the orphan root we ensure every getblocks looks the same
                ;; no matter how many blocks are solved, and therefore that the (2) duplicate filtering can work.
                (§ expr lock.lock(§ pars ))
                (§ try )
                (§ block
                    #_final
                    (§ var #_"Block" (§ name orphanRoot) (§ expr Preconditions/checkNotNull(§ pars blockChain.getOrphanRoot(§ pars m.getHash(§ pars )))))
                    (§ expr blockChainDownloadLocked(§ pars orphanRoot.getHash(§ pars )))
                )
                (§ finally )
                (§ block
                    (§ expr lock.unlock(§ pars ))
                )
            )
        )
        (§ catch #_"VerificationException" (§ name e))
        (§ block
            ;; We don't want verification failures to kill the thread.
            (§ expr log.warn(§ pars "{}: FilteredBlock verification failed", getAddress(§ pars ), e))
        )
        (§ catch #_"PrunedException" (§ name e))
        (§ block
            ;; We pruned away some of the data we need to properly handle this block.  We need to request the needed
            ;; data from the remote peer and fix things.  Or just give up.
            ;; TODO: Request e.getHash() and submit it to the block store before any other blocks.
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
        (§ void nil)
    )

    #_private
    (§ method #_"boolean" (§ fn checkForFilterExhaustion) [#_"FilteredBlock" (§ name m)])
    (§ block
        (§ var #_"boolean" (§ name exhausted) false)
        (§ for (§ var #_"Wallet" (§ name wallet)) :for wallets)
        (§ block
            (§ ass (§ name exhausted) (§ expr exhausted | wallet.checkForFilterExhaustion(§ pars m)))
        )
        (§ return exhausted)
    )

    #_private
    (§ method #_"boolean" (§ fn maybeHandleRequestedData) [#_"Message" (§ name m)])
    (§ block
        (§ var #_"boolean" (§ name found) false)
        (§ var #_"Sha256Hash" (§ name hash) (§ expr m.getHash(§ pars )))
        (§ for (§ var #_"GetDataRequest" (§ name req)) :for getDataFutures)
        (§ block
            (§ if (§ expr hash.equals(§ pars req.hash)))
            (§ block
                (§ expr req.future.set(§ pars m))
                (§ expr getDataFutures.remove(§ pars req))
                (§ ass (§ name found) true)
                ;; Keep going in case there are more.
            )
        )
        (§ return found)
    )

    #_private
    (§ method #_"void" (§ fn invokeOnBlocksDownloaded) [#_final #_"Block" (§ name block), #_nilable #_final #_"FilteredBlock" (§ name fb)])
    (§ block
        ;; It is possible for the peer block height difference to be negative when blocks have been solved and broadcast
        ;; since the time we first connected to the peer.  However, it's weird and unexpected to receive a callback
        ;; with negative "blocks left" in this case, so we clamp to zero so the API user doesn't have to think about it.
        #_final
        (§ var #_"int" (§ name blocksLeft) (§ expr Math/max(§ pars 0, (§ cast #_"int" vPeerVersionMessage.bestHeight) - Preconditions/checkNotNull(§ pars blockChain).getBestChainHeight(§ pars ))))
        (§ for (§ var #_final ListenerRegistration<BlocksDownloadedEventListener> registration) :for blocksDownloadedEventListeners)
        (§ block
            (§ expr registration.executor.execute(§ pars (§ new #_"Runnable" (§ pars ))
            (§ anon
                #_override
                #_public
                (§ method #_"void" (§ fn run) [])
                (§ block
                    (§ expr registration.listener.onBlocksDownloaded(§ pars (§ dhis Peer), block, fb, blocksLeft))
                    (§ void nil)
                )
            )))
        )
        (§ void nil)
    )

    #_protected
    (§ method #_"void" (§ fn processInv) [#_"InventoryMessage" (§ name inv)])
    (§ block
        (§ var #_"List<InventoryItem>" (§ name items) (§ expr inv.getItems(§ pars )))

        ;; Separate out the blocks and transactions, we'll handle them differently.
        (§ var #_"List<InventoryItem>" (§ name transactions) (§ new #_"LinkedList<>" (§ pars )))
        (§ var #_"List<InventoryItem>" (§ name blocks) (§ new #_"LinkedList<>" (§ pars )))

        (§ for (§ var #_"InventoryItem" (§ name item)) :for items)
        (§ block
            (§ switch (§ expr item.type))
            (§ block
                (§ case Transaction)
                (§ block
                    (§ expr transactions.add(§ pars item))
                    (§ break )
                )
                (§ case Block)
                (§ block
                    (§ expr blocks.add(§ pars item))
                    (§ break )
                )
                (§ default )
                (§ block
                    (§ throw (§ new #_"IllegalStateException" (§ pars "Not implemented: " + item.type)))
                )
            )
        )

        #_final
        (§ var #_"boolean" (§ name downloadData) (§ expr this.vDownloadData))

        (§ if (§ expr transactions.size(§ pars ) == 0 && blocks.size(§ pars ) == 1))
        (§ block
            ;; Single block announcement.  If we're downloading the chain this is just a tickle to make us continue
            ;; (the block chain download protocol is very implicit and not well thought out).  If we're not downloading
            ;; the chain then this probably means a new block was solved and the peer believes it connects to the best
            ;; chain, so count it.  This way getBestChainHeight() can be accurate.
            (§ if (§ expr downloadData && blockChain != nil))
            (§ block
                (§ if (§ expr (§ not blockChain.isOrphan(§ pars blocks.get(§ pars 0).hash))))
                (§ block
                    (§ expr blocksAnnounced.incrementAndGet(§ pars ))
                )
            )
            (§ else )
            (§ block
                (§ expr blocksAnnounced.incrementAndGet(§ pars ))
            )
        )

        (§ var #_"GetDataMessage" (§ name getdata) (§ new #_"GetDataMessage" (§ pars params)))

        (§ var #_"Iterator<InventoryItem>" (§ name it) (§ expr transactions.iterator(§ pars )))
        (§ while (§ expr it.hasNext(§ pars )))
        (§ block
            (§ var #_"InventoryItem" (§ name item) (§ expr it.next(§ pars )))
            ;; Only download the transaction if we are the first peer that saw it be advertised.  Other peers will also
            ;; see it be advertised in inv packets asynchronously, they co-ordinate via the memory pool.  We could
            ;; potentially download transactions faster by always asking every peer for a tx when advertised, as remote
            ;; peers run at different speeds.  However to conserve bandwidth on mobile devices we try to only download a
            ;; transaction once.  This means we can miss broadcasts if the peer disconnects between sending us an inv and
            ;; sending us the transaction: currently we'll never try to re-fetch after a timeout.
            ;;
            ;; The line below can trigger confidence listeners.
            (§ var #_"TransactionConfidence" (§ name conf) (§ expr context.getConfidenceTable(§ pars ).seen(§ pars item.hash, this.getAddress(§ pars ))))
            (§ if (§ expr 1 < conf.numBroadcastPeers(§ pars )))
            (§ block
                ;; Some other peer already announced this so don't download.
                (§ expr it.remove(§ pars ))
            )
            (§ elseif (§ expr conf.getSource(§ pars ).equals(§ pars TransactionConfidence/Source/SELF)))
            (§ block
                ;; We created this transaction ourselves, so don't download.
                (§ expr it.remove(§ pars ))
            )
            (§ else )
            (§ block
                (§ expr log.debug(§ pars "{}: getdata on tx {}", getAddress(§ pars ), item.hash))
                (§ expr getdata.addItem(§ pars item))
                ;; Register with the garbage collector that we care about the confidence data for a while.
                (§ expr pendingTxDownloads.add(§ pars conf))
            )
        )

        ;; If we are requesting filteredblocks, we have to send a ping after the getdata so that we have a clear
        ;; end to the final FilteredBlock's transactions (in the form of a pong) sent to us.
        (§ var #_"boolean" (§ name pingAfterGetData) false)

        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr 0 < blocks.size(§ pars ) && downloadData && blockChain != nil))
            (§ block
                ;; Ideally, we'd only ask for the data here if we actually needed it.  However that can imply a lot of
                ;; disk IO to figure out what we've got.  Normally peers will not send us inv for things we already have
                ;; so we just re-request it here, and if we get duplicates the block chain / wallet will filter them out.
                (§ for (§ var #_"InventoryItem" (§ name item)) :for blocks)
                (§ block
                    (§ if (§ expr blockChain.isOrphan(§ pars item.hash) && downloadBlockBodies))
                    (§ block
                        ;; If an orphan was re-advertised, ask for more blocks unless we are not currently downloading
                        ;; full block data because we have a getheaders outstanding.
                        #_final
                        (§ var #_"Block" (§ name orphanRoot) (§ expr Preconditions/checkNotNull(§ pars blockChain.getOrphanRoot(§ pars item.hash))))
                        (§ expr blockChainDownloadLocked(§ pars orphanRoot.getHash(§ pars )))
                    )
                    (§ else )
                    (§ block
                        ;; Don't re-request blocks we already requested.  Normally this should not happen.  However there is
                        ;; an edge case: if a block is solved and we complete the inv<->getdata<->block<->getblocks cycle
                        ;; whilst other parts of the chain are streaming in, then the new getblocks request won't match the
                        ;; previous one: whilst the stopHash is the same (because we use the orphan root), the start hash
                        ;; will be different and so the getblocks req won't be dropped as a duplicate.  We'll end up
                        ;; requesting a subset of what we already requested, which can lead to parallel chain downloads
                        ;; and other nastyness.  So we just do a quick removal of redundant getdatas here too.
                        ;;
                        ;; Note that as of June 2012 Bitcoin Core won't actually ever interleave blocks pushed as
                        ;; part of chain download with newly announced blocks, so it should always be taken care of by
                        ;; the duplicate check in blockChainDownloadLocked().  But Bitcoin Core may change in future so
                        ;; it's better to be safe here.
                        (§ if (§ expr (§ not pendingBlockDownloads.contains(§ pars item.hash))))
                        (§ block
                            (§ if (§ expr vPeerVersionMessage.isBloomFilteringSupported(§ pars ) && useFilteredBlocks))
                            (§ block
                                (§ expr getdata.addFilteredBlock(§ pars item.hash))
                                (§ ass (§ name pingAfterGetData) true)
                            )
                            (§ else )
                            (§ block
                                (§ expr getdata.addItem(§ pars item))
                            )
                            (§ expr pendingBlockDownloads.add(§ pars item.hash))
                        )
                    )
                )
                ;; If we're downloading the chain, doing a getdata on the last block we were told about will cause the
                ;; peer to advertize the head block to us in a single-item inv.  When we download THAT, it will be an
                ;; orphan block, meaning we'll re-enter blockChainDownloadLocked() to trigger another getblocks between the
                ;; current best block we have and the orphan block.  If more blocks arrive in the meantime they'll also
                ;; become orphan.
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )

        (§ if (§ not (§ dot getdata.getItems(§ pars ).isEmpty(§ pars ))))
        (§ block
            ;; This will cause us to receive a bunch of block or tx messages.
            (§ expr sendMessage(§ pars getdata))
        )

        (§ if pingAfterGetData)
        (§ block
            (§ expr sendMessage(§ pars (§ new #_"Ping" (§ pars (§ cast #_"long" (§ expr Math/random(§ pars ) * Long/MAX_VALUE))))))
        )
        (§ void nil)
    )

    ;;;
     ; Asks the connected peer for the block of the given hash, and returns a future representing the answer.
     ; If you want the block right away and don't mind waiting for it, just call .get() on the result.  Your thread
     ; will block until the peer answers.
     ;;
    #_suppress(§ opt "unchecked")
    ;; The 'unchecked conversion' warning being suppressed here comes from the sendSingleGetData() formally returning
    ;; ListenableFuture instead of ListenableFuture<Block>.  This is okay as sendSingleGetData() actually returns
    ;; ListenableFuture<Block> in this context.  Note that sendSingleGetData() is also used for Transactions.
    #_public
    (§ method #_"ListenableFuture<Block>" (§ fn getBlock) [#_"Sha256Hash" (§ name blockHash)])
    (§ block
        ;; This does not need to be locked.
        (§ expr log.info(§ pars "Request to fetch block {}", blockHash))
        (§ var #_"GetDataMessage" (§ name getdata) (§ new #_"GetDataMessage" (§ pars params)))
        (§ expr getdata.addBlock(§ pars blockHash))
        (§ return (§ expr sendSingleGetData(§ pars getdata)))
    )

    ;;;
     ; Asks the connected peer for the given transaction from its memory pool.  Transactions in the chain cannot be
     ; retrieved this way because peers don't have a transaction ID to transaction-pos-on-disk index, and besides,
     ; in future many peers will delete old transaction data they don't need.
     ;;
    #_suppress(§ opt "unchecked")
    ;; The 'unchecked conversion' warning being suppressed here comes from the sendSingleGetData() formally returning
    ;; ListenableFuture instead of ListenableFuture<Transaction>.  This is okay as sendSingleGetData() actually returns
    ;; ListenableFuture<Transaction> in this context.  Note that sendSingleGetData() is also used for Blocks.
    #_public
    (§ method #_"ListenableFuture<Transaction>" (§ fn getPeerMempoolTransaction) [#_"Sha256Hash" (§ name hash)])
    (§ block
        ;; This does not need to be locked.
        (§ expr log.info(§ pars "Request to fetch peer mempool tx  {}", hash))
        (§ var #_"GetDataMessage" (§ name getdata) (§ new #_"GetDataMessage" (§ pars params)))
        (§ expr getdata.addTransaction(§ pars hash))
        (§ return (§ expr sendSingleGetData(§ pars getdata)))
    )

    ;;; Sends a getdata with a single item in it. ;;
    #_private
    (§ method #_"ListenableFuture" (§ fn sendSingleGetData) [#_"GetDataMessage" (§ name getdata)])
    (§ block
        ;; This does not need to be locked.
        (§ expr Preconditions/checkArgument(§ pars getdata.getItems(§ pars ).size(§ pars ) == 1))
        (§ var #_"GetDataRequest" (§ name req) (§ new #_"GetDataRequest" (§ pars getdata.getItems(§ pars ).get(§ pars 0).hash, SettableFuture/create(§ pars ))))
        (§ expr getDataFutures.add(§ pars req))
        (§ expr sendMessage(§ pars getdata))
        (§ return (§ expr req.future))
    )

    ;;; Sends a getaddr request to the peer and returns a future that completes with the answer once the peer has replied. ;;
    #_public
    (§ method #_"ListenableFuture<AddressMessage>" (§ fn getAddr) [])
    (§ block
        (§ var #_"SettableFuture<AddressMessage>" (§ name future) (§ expr SettableFuture/create(§ pars )))
        (§ sync getAddrFutures)
        (§ block
            (§ expr getAddrFutures.add(§ pars future))
        )
        (§ expr sendMessage(§ pars (§ new #_"GetAddrMessage" (§ pars params))))
        (§ return future)
    )

    ;;;
     ; When downloading the block chain, the bodies will be skipped for blocks created before the given date.
     ; Any transactions relevant to the wallet will therefore not be found, but if you know your wallet has no such
     ; transactions it doesn't matter and can save a lot of bandwidth and processing time.  Note that the times of blocks
     ; isn't known until their headers are available and they are requested in chunks, so some headers may be downloaded
     ; twice using this scheme, but this optimization can still be a large win for newly created wallets.
     ;
     ; @param secondsSinceEpoch Time in seconds since the epoch or 0 to reset to always downloading block bodies.
     ;;
    #_public
    (§ method #_"void" (§ fn setDownloadParameters) [#_"long" (§ name secondsSinceEpoch), #_"boolean" (§ name useFilteredBlocks)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr secondsSinceEpoch == 0))
            (§ block
                (§ ass (§ name fastCatchupTimeSecs) (§ expr params.getGenesisBlock(§ pars ).getTimeSeconds(§ pars )))
                (§ ass (§ name downloadBlockBodies) true)
            )
            (§ else )
            (§ block
                (§ ass (§ name fastCatchupTimeSecs) secondsSinceEpoch)
                ;; If the given time is before the current chains head block time, then this has no effect (we already
                ;; downloaded everything we need).
                (§ if (§ expr blockChain != nil && blockChain.getChainHead(§ pars ).getHeader(§ pars ).getTimeSeconds(§ pars ) < fastCatchupTimeSecs))
                (§ block
                    (§ ass (§ name downloadBlockBodies) false)
                )
            )
            (§ ass (§ name this.useFilteredBlocks) useFilteredBlocks)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Links the given wallet to this peer.  If you have multiple peers, you should use a {@link PeerGroup} to manage
     ; them and use the {@link PeerGroup#addWallet(Wallet)} method instead of registering the wallet with each peer
     ; independently, otherwise the wallet will receive duplicate notifications.
     ;;
    #_public
    (§ method #_"void" (§ fn addWallet) [#_"Wallet" (§ name wallet)])
    (§ block
        (§ expr wallets.add(§ pars wallet))
        (§ void nil)
    )

    ;;; Unlinks the given wallet from peer.  See {@link Peer#addWallet(Wallet)}. ;;
    #_public
    (§ method #_"void" (§ fn removeWallet) [#_"Wallet" (§ name wallet)])
    (§ block
        (§ expr wallets.remove(§ pars wallet))
        (§ void nil)
    )

    ;; Keep track of the last request we made to the peer in blockChainDownloadLocked so we can avoid redundant and harmful
    ;; getblocks requests.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"Sha256Hash" (§ name lastGetBlocksBegin))
    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"Sha256Hash" (§ name lastGetBlocksEnd))

    #_guarded-by(§ opt "lock")
    #_private
    (§ method #_"void" (§ fn blockChainDownloadLocked) [#_"Sha256Hash" (§ name toHash)])
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        ;; The block chain download process is a bit complicated.  Basically, we start with one or more blocks in a
        ;; chain that we have from a previous session.  We want to catch up to the head of the chain BUT we don't know
        ;; where that chain is up to or even if the top block we have is even still in the chain - we
        ;; might have got ourselves onto a fork that was later resolved by the network.
        ;;
        ;; To solve this, we send the peer a block locator which is just a list of block hashes.  It contains the
        ;; blocks we know about, but not all of them, just enough of them so the peer can figure out if we did end up
        ;; on a fork and if so, what the earliest still valid block we know about is likely to be.
        ;;
        ;; Once it has decided which blocks we need, it will send us an inv with up to 500 block messages.  We may
        ;; have some of them already if we already have a block chain and just need to catch up.  Once we request the
        ;; last block, if there are still more to come it sends us an "inv" containing only the hash of the head
        ;; block.
        ;;
        ;; That causes us to download the head block but then we find (in processBlock) that we can't connect
        ;; it to the chain yet because we don't have the intermediate blocks.  So we rerun this function building a
        ;; new block locator describing where we're up to.
        ;;
        ;; The getblocks with the new locator gets us another inv with another bunch of blocks.  We download them once
        ;; again.  This time when the peer sends us an inv with the head block, we already have it so we won't download
        ;; it again - but we recognize this case as special and call back into blockChainDownloadLocked to continue the
        ;; process.
        ;;
        ;; So this is a complicated process but it has the advantage that we can download a chain of enormous length
        ;; in a relatively stateless manner and with constant memory usage.
        ;;
        ;; All this is made more complicated by the desire to skip downloading the bodies of blocks that pre-date the
        ;; 'fast catchup time', which is usually set to the creation date of the earliest key in the wallet.  Because
        ;; we know there are no transactions using our keys before that date, we need only the headers.  To do that we
        ;; use the "getheaders" command.  Once we find we've gone past the target date, we throw away the downloaded
        ;; headers and then request the blocks from that point onwards.  "getheaders" does not send us an inv, it just
        ;; sends us the data we requested in a "headers" message.

        ;; TODO: Block locators should be abstracted out rather than special cased here.
        (§ var #_"List<Sha256Hash>" (§ name blockLocator) (§ new #_"ArrayList<>" (§ pars 51)))

        ;; For now, we don't do the exponential thinning as suggested here:
        ;;
        ;;   https://en.bitcoin.it/wiki/Protocol_specification#getblocks
        ;;
        ;; This is because it requires scanning all the block chain headers, which is very slow.  Instead we add the
        ;; top 100 block headers.  If there is a re-org deeper than that, we'll end up downloading the entire chain.
        ;; We must always put the genesis block as the first entry.

        (§ var #_"BlockStore" (§ name store) (§ expr Preconditions/checkNotNull(§ pars blockChain).getBlockStore(§ pars )))
        (§ var #_"StoredBlock" (§ name chainHead) (§ expr blockChain.getChainHead(§ pars )))
        (§ var #_"Sha256Hash" (§ name chainHeadHash) (§ expr chainHead.getHeader(§ pars ).getHash(§ pars )))

        ;; Did we already make this request?  If so, don't do it again.
        (§ if (§ expr Objects/equal(§ pars lastGetBlocksBegin, chainHeadHash) && Objects/equal(§ pars lastGetBlocksEnd, toHash)))
        (§ block
            (§ expr log.info(§ pars "blockChainDownloadLocked({}): ignoring duplicated request: {}", toHash, chainHeadHash))
            (§ for (§ var #_"Sha256Hash" (§ name hash)) :for pendingBlockDownloads)
            (§ block
                (§ expr log.info(§ pars "Pending block download: {}", hash))
            )
            (§ expr log.info(§ pars Throwables/getStackTraceAsString(§ pars (§ new #_"Throwable" (§ pars )))))
            (§ return nil)
        )

        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ expr log.debug(§ pars "{}: blockChainDownloadLocked({}) current head = {}", this, toHash, chainHead.getHeader(§ pars ).getHashAsString(§ pars )))
        )

        (§ var #_"StoredBlock" (§ name cursor) chainHead)
        (§ for (§ var #_"int" (§ name i) 100) :for (§ expr cursor != nil && 0 < i) :for (§ ass (§ name i) (§ expr i - 1)))
        (§ block
            (§ expr blockLocator.add(§ pars cursor.getHeader(§ pars ).getHash(§ pars )))
            (§ try )
            (§ block
                (§ ass (§ name cursor) (§ expr cursor.getPrev(§ pars store)))
            )
            (§ catch #_"BlockStoreException" (§ name e))
            (§ block
                (§ expr log.error(§ pars "Failed to walk the block chain whilst constructing a locator"))
                (§ throw (§ new #_"RuntimeException" (§ pars e)))
            )
        )

        ;; Only add the locator if we didn't already do so.  If the chain is < 50 blocks we already reached it.
        (§ if (§ expr cursor != nil))
        (§ block
            (§ expr blockLocator.add(§ pars params.getGenesisBlock(§ pars ).getHash(§ pars )))
        )

        ;; Record that we requested this range of blocks so we can filter out duplicate requests in the event
        ;; of a block being solved during chain download.
        (§ ass (§ name lastGetBlocksBegin) chainHeadHash)
        (§ ass (§ name lastGetBlocksEnd) toHash)

        (§ if downloadBlockBodies)
        (§ block
            (§ var #_"GetBlocksMessage" (§ name message) (§ new #_"GetBlocksMessage" (§ pars params, blockLocator, toHash)))
            (§ expr sendMessage(§ pars message))
        )
        (§ else )
        (§ block
            ;; Downloading headers for a while instead of full blocks.
            (§ var #_"GetHeadersMessage" (§ name message) (§ new #_"GetHeadersMessage" (§ pars params, blockLocator, toHash)))
            (§ expr sendMessage(§ pars message))
        )
        (§ void nil)
    )

    ;;;
     ; Starts an asynchronous download of the block chain.  The chain download is deemed to be complete once we've
     ; downloaded the same number of blocks that the peer advertised having in its version handshake message.
     ;;
    #_public
    (§ method #_"void" (§ fn startBlockChainDownload) [])
    (§ block
        (§ expr setDownloadData(§ pars true))
        ;; TODO: Peer might still have blocks that we don't have, and even have a heavier
        ;; chain even if the chain block count is lower.
        #_final
        (§ var #_"int" (§ name blocksLeft) (§ expr getPeerBlockHeightDifference(§ pars )))
        (§ if (§ expr 0 <= blocksLeft))
        (§ block
            (§ for (§ var #_final ListenerRegistration<ChainDownloadStartedEventListener> registration) :for chainDownloadStartedEventListeners)
            (§ block
                (§ expr registration.executor.execute(§ pars (§ new #_"Runnable" (§ pars ))
                (§ anon
                    #_override
                    #_public
                    (§ method #_"void" (§ fn run) [])
                    (§ block
                        (§ expr registration.listener.onChainDownloadStarted(§ pars (§ dhis Peer), blocksLeft))
                        (§ void nil)
                    )
                )))
            )
            ;; When we just want as many blocks as possible, we can set the target hash to zero.
            (§ expr lock.lock(§ pars ))
            (§ try )
            (§ block
                (§ expr blockChainDownloadLocked(§ pars Sha256Hash/ZERO_HASH))
            )
            (§ finally )
            (§ block
                (§ expr lock.unlock(§ pars ))
            )
        )
        (§ void nil)
    )

    #_private
    (§ class #_"PendingPing"
        ;; The future that will be invoked when the pong is heard back.
        #_public
        (§ field #_"SettableFuture<Long>" (§ name future))
        ;; The random nonce that lets us tell apart overlapping pings/pongs.
        #_public
        #_final
        (§ field #_"long" (§ name nonce))
        ;; Measurement of the time elapsed.
        #_public
        #_final
        (§ field #_"long" (§ name startTimeMsec))

        #_public
        (§ constructor #_"PendingPing" [#_"long" (§ name nonce)])
        (§ block
            (§ ass (§ name future) (§ expr SettableFuture/create(§ pars )))
            (§ ass (§ name this.nonce) nonce)
            (§ ass (§ name startTimeMsec) (§ expr Utils/currentTimeMillis(§ pars )))
            (§ void this)
        )

        #_public
        (§ method #_"void" (§ fn complete) [])
        (§ block
            (§ if (§ expr (§ not future.isDone(§ pars ))))
            (§ block
                (§ var #_"Long" (§ name elapsed) (§ expr Utils/currentTimeMillis(§ pars ) - startTimeMsec))
                (§ expr Peer.this.addPingTimeData(§ pars elapsed))
                (§ expr log.debug(§ pars "{}: ping time is {} msec", Peer.this.toString(§ pars ), elapsed))
                (§ expr future.set(§ pars elapsed))
            )
            (§ void nil)
        )
    )

    ;;; Adds a ping time sample to the averaging window. ;;
    #_private
    (§ method #_"void" (§ fn addPingTimeData) [#_"long" (§ name sample)])
    (§ block
        (§ expr lastPingTimesLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr lastPingTimes == nil))
            (§ block
                (§ ass (§ name lastPingTimes) (§ new #_"long[]" (§ count PING_MOVING_AVERAGE_WINDOW)))
                ;; Initialize the averaging window to the first sample.
                (§ expr Arrays/fill(§ pars lastPingTimes, sample))
            )
            (§ else )
            (§ block
                ;; Shift all elements backwards by one.
                (§ expr System/arraycopy(§ pars lastPingTimes, 1, lastPingTimes, 0, lastPingTimes.length - 1))
                ;; And append the new sample to the end.
                (§ ass (§ name lastPingTimes[lastPingTimes.length - 1]) sample)
            )
        )
        (§ finally )
        (§ block
            (§ expr lastPingTimesLock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Sends the peer a ping message and returns a future that will be invoked when the pong is received back.
     ; The future provides a number which is the number of milliseconds elapsed between the ping and the pong.
     ; Once the pong is received the value returned by {@link org.bitcoinj.core.Peer#getLastPingTime()} is
     ; updated.
     ; @throws ProtocolException if the peer version is too low to support measurable pings.
     ;;
    #_public
    (§ method #_"ListenableFuture<Long>" (§ fn ping) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ return (§ expr ping(§ pars (§ cast #_"long" (§ expr Math/random(§ pars ) * Long/MAX_VALUE)))))
    )

    #_protected
    (§ method #_"ListenableFuture<Long>" (§ fn ping) [#_"long" (§ name nonce)])
        (§ throws #_"ProtocolException")
    (§ block
        #_final
        (§ var #_"VersionMessage" (§ name ver) vPeerVersionMessage)
        (§ if (§ expr (§ not ver.isPingPongSupported(§ pars ))))
        (§ block
            (§ throw (§ new #_"ProtocolException" (§ pars "Peer version is too low for measurable pings: " + ver)))
        )

        (§ var #_"PendingPing" (§ name pendingPing) (§ new #_"PendingPing" (§ pars nonce)))
        (§ expr pendingPings.add(§ pars pendingPing))
        (§ expr sendMessage(§ pars (§ new #_"Ping" (§ pars pendingPing.nonce))))

        (§ return (§ expr pendingPing.future))
    )

    ;;;
     ; Returns the elapsed time of the last ping/pong cycle.  If {@link org.bitcoinj.core.Peer#ping()} has
     ; never been called or we did not hear back the "pong" message yet, returns {@link Long#MAX_VALUE}.
     ;;
    #_public
    (§ method #_"long" (§ fn getLastPingTime) [])
    (§ block
        (§ expr lastPingTimesLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ quest (§ expr lastPingTimes != nil) ? (§ expr lastPingTimes[lastPingTimes.length - 1]) :else (§ expr Long/MAX_VALUE)))
        )
        (§ finally )
        (§ block
            (§ expr lastPingTimesLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a moving average of the last N ping/pong cycles.  If {@link org.bitcoinj.core.Peer#ping()} has never
     ; been called or we did not hear back the "pong" message yet, returns {@link Long#MAX_VALUE}.  The moving average
     ; window is 5 buckets.
     ;;
    #_public
    (§ method #_"long" (§ fn getPingTime) [])
    (§ block
        (§ expr lastPingTimesLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr lastPingTimes == nil))
            (§ block
                (§ return (§ expr Long/MAX_VALUE))
            )
            (§ var #_"long" (§ name sum) 0)
            (§ for (§ var #_"long" (§ name i)) :for lastPingTimes)
            (§ block
                (§ ass (§ name sum) (§ expr sum + i))
            )
            (§ return (§ cast #_"long" (§ expr (§ cast #_"double" sum) / lastPingTimes.length)))
        )
        (§ finally )
        (§ block
            (§ expr lastPingTimesLock.unlock(§ pars ))
        )
    )

    #_private
    (§ method #_"void" (§ fn processPing) [#_"Ping" (§ name m)])
    (§ block
        (§ if (§ expr m.hasNonce(§ pars )))
        (§ block
            (§ expr sendMessage(§ pars (§ new #_"Pong" (§ pars m.getNonce(§ pars )))))
        )
        (§ void nil)
    )

    #_protected
    (§ method #_"void" (§ fn processPong) [#_"Pong" (§ name m)])
    (§ block
        ;; Iterates over a snapshot of the list, so we can run unlocked here.
        (§ for (§ var #_"PendingPing" (§ name ping)) :for pendingPings)
        (§ block
            (§ if (§ expr m.getNonce(§ pars ) == ping.nonce))
            (§ block
                (§ expr pendingPings.remove(§ pars ping))
                ;; This line may trigger an event listener that re-runs ping().
                (§ expr ping.complete(§ pars ))
                (§ return nil)
            )
        )
        (§ void nil)
    )

    ;;;
     ; Returns the difference between our best chain height and the peers, which can either be positive if we are
     ; behind the peer, or negative if the peer is ahead of us.
     ;;
    #_public
    (§ method #_"int" (§ fn getPeerBlockHeightDifference) [])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars blockChain, "No block chain configured"))

        ;; Chain will overflow signed int blocks in ~41,000 years.
        (§ var #_"int" (§ name chainHeight) (§ expr (§ cast #_"int" (§ expr getBestHeight(§ pars )))))
        ;; chainHeight should not be zero/negative because we shouldn't have given the user a Peer that is to another
        ;; client-mode node, nor should it be unconnected.  If that happens it means the user overrode us somewhere or
        ;; there is a bug in the peer management code.
        (§ expr Preconditions/checkState(§ pars params.allowEmptyPeerChain(§ pars ) || 0 < chainHeight, "Connected to peer with zero/negative chain height", chainHeight))
        (§ return (§ expr chainHeight - blockChain.getBestChainHeight(§ pars )))
    )

    #_private
    (§ method #_"boolean" (§ fn isNotFoundMessageSupported) [])
    (§ block
        (§ return (§ expr NotFoundMessage/MIN_PROTOCOL_VERSION <= vPeerVersionMessage.clientVersion))
    )

    ;;;
     ; Returns true if this peer will try and download things it is sent in "inv" messages.
     ; Normally you only need one peer to be downloading data.  Defaults to true.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isDownloadData) [])
    (§ block
        (§ return vDownloadData)
    )

    ;;;
     ; If set to false, the peer won't try and fetch blocks and transactions it hears about.  Normally, only one
     ; peer should download missing blocks.  Defaults to true.  Changing this value from false to true may trigger
     ; a request to the remote peer for the contents of its memory pool, if Bloom filtering is active.
     ;;
    #_public
    (§ method #_"void" (§ fn setDownloadData) [#_"boolean" (§ name downloadData)])
    (§ block
        (§ ass (§ name this.vDownloadData) downloadData)
        (§ void nil)
    )

    ;;; Returns version data announced by the remote peer. ;;
    #_public
    (§ method #_"VersionMessage" (§ fn getPeerVersionMessage) [])
    (§ block
        (§ return vPeerVersionMessage)
    )

    ;;; Returns version data we announce to our remote peers. ;;
    #_public
    (§ method #_"VersionMessage" (§ fn getVersionMessage) [])
    (§ block
        (§ return versionMessage)
    )

    ;;;
     ; @return the height of the best chain as claimed by peer: sum of its ver announcement and blocks announced since.
     ;;
    #_public
    (§ method #_"long" (§ fn getBestHeight) [])
    (§ block
        (§ return (§ expr vPeerVersionMessage.bestHeight + blocksAnnounced.get(§ pars )))
    )

    ;;;
     ; The minimum P2P protocol version that is accepted.  If the peer speaks a protocol version lower than this, it
     ; will be disconnected.
     ; @return true if the peer was disconnected as a result.
     ;;
    #_public
    (§ method #_"boolean" (§ fn setMinProtocolVersion) [#_"int" (§ name minProtocolVersion)])
    (§ block
        (§ ass (§ name this.vMinProtocolVersion) minProtocolVersion)

        (§ var #_"VersionMessage" (§ name ver) (§ expr getPeerVersionMessage(§ pars )))
        (§ if (§ expr ver != nil && ver.clientVersion < minProtocolVersion))
        (§ block
            (§ expr log.warn(§ pars "{}: Disconnecting due to new min protocol version {}, got: {}", this, minProtocolVersion, ver.clientVersion))
            (§ expr close(§ pars ))
            (§ return true)
        )

        (§ return false)
    )

    ;;;
     ; <p>Sets a Bloom filter on this connection.  This will cause the given {@link BloomFilter} object to be sent
     ; to the remote peer and if either a memory pool has been set using the constructor or the
     ; vDownloadData property is true, a {@link MemoryPoolMessage} is sent as well to trigger downloading of any
     ; pending transactions that may be relevant.</p>
     ;
     ; <p>The Peer does not automatically request filters from any wallets added using {@link Peer#addWallet(Wallet)}.
     ; This is to allow callers to avoid redundantly recalculating the same filter repeatedly when using multiple peers
     ; and multiple wallets together.</p>
     ;
     ; <p>Therefore, you should not use this method if your app uses a {@link PeerGroup}.  It is called for you.</p>
     ;
     ; <p>If the remote peer doesn't support Bloom filtering, then this call is ignored.  Once set you presently cannot
     ; unset a filter, though the underlying p2p protocol does support it.</p>
     ;;
    #_public
    (§ method #_"void" (§ fn setBloomFilter) [#_"BloomFilter" (§ name filter)])
    (§ block
        (§ expr setBloomFilter(§ pars filter, true))
        (§ void nil)
    )

    ;;;
     ; <p>Sets a Bloom filter on this connection.  This will cause the given {@link BloomFilter} object to be sent
     ; to the remote peer and if requested, a {@link MemoryPoolMessage} is sent as well to trigger downloading of any
     ; pending transactions that may be relevant.</p>
     ;
     ; <p>The Peer does not automatically request filters from any wallets added using {@link Peer#addWallet(Wallet)}.
     ; This is to allow callers to avoid redundantly recalculating the same filter repeatedly when using multiple peers
     ; and multiple wallets together.</p>
     ;
     ; <p>Therefore, you should not use this method if your app uses a {@link PeerGroup}.  It is called for you.</p>
     ;
     ; <p>If the remote peer doesn't support Bloom filtering, then this call is ignored.  Once set you presently cannot
     ; unset a filter, though the underlying p2p protocol does support it.</p>
     ;;
    #_public
    (§ method #_"void" (§ fn setBloomFilter) [#_"BloomFilter" (§ name filter), #_"boolean" (§ name andQueryMemPool)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars filter, "Clearing filters is not currently supported"))

        #_final
        (§ var #_"VersionMessage" (§ name ver) vPeerVersionMessage)
        (§ if (§ expr ver != nil && ver.isBloomFilteringSupported(§ pars )))
        (§ block
            (§ ass (§ name vBloomFilter) filter)
            (§ expr log.debug(§ pars "{}: Sending Bloom filter{}", this, (§ quest andQueryMemPool ? (§ expr " and querying mempool") :else (§ expr ""))))
            (§ expr sendMessage(§ pars filter))
            (§ if andQueryMemPool)
            (§ block
                (§ expr sendMessage(§ pars (§ new #_"MemoryPoolMessage" (§ pars ))))
            )
            (§ expr maybeRestartChainDownload(§ pars ))
        )
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn maybeRestartChainDownload) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr awaitingFreshFilter == nil))
            (§ block
                (§ return nil)
            )

            (§ if (§ expr (§ not vDownloadData)))
            (§ block
                ;; This branch should be harmless but I want to know how often it happens in reality.
                (§ expr log.warn(§ pars "Lost download peer status whilst awaiting fresh filter."))
                (§ return nil)
            )

            ;; Ping/pong to wait for blocks that are still being streamed to us to finish being downloaded and discarded.
            (§ expr ping(§ pars ).addListener(§ pars (§ new #_"Runnable" (§ pars ))
            (§ anon
                #_override
                #_public
                (§ method #_"void" (§ fn run) [])
                (§ block
                    (§ expr lock.lock(§ pars ))
                    (§ expr Preconditions/checkNotNull(§ pars awaitingFreshFilter))
                    (§ var #_"GetDataMessage" (§ name getdata) (§ new #_"GetDataMessage" (§ pars params)))
                    (§ for (§ var #_"Sha256Hash" (§ name hash)) :for awaitingFreshFilter)
                    (§ block
                        (§ expr getdata.addFilteredBlock(§ pars hash))
                    )
                    (§ ass (§ name awaitingFreshFilter) nil)
                    (§ expr lock.unlock(§ pars ))

                    (§ expr log.info(§ pars "Restarting chain download"))
                    (§ expr sendMessage(§ pars getdata))
                    ;; TODO: This bizarre ping-after-getdata hack probably isn't necessary.
                    ;; It's to ensure we know when the end of a filtered block stream of txns is, but we should just be
                    ;; able to match txns with the merkleblock.  Ask Matt why it's written this way.
                    (§ expr sendMessage(§ pars (§ new #_"Ping" (§ pars (§ cast #_"long" (§ expr Math/random(§ pars ) * Long/MAX_VALUE))))))
                    (§ void nil)
                )
            ), Threading.SAME_THREAD))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Returns the last {@link BloomFilter} set by {@link Peer#setBloomFilter(BloomFilter)}.  Bloom filters tell
     ; the remote node what transactions to send us, in a compact manner.
     ;;
    #_public
    (§ method #_"BloomFilter" (§ fn getBloomFilter) [])
    (§ block
        (§ return vBloomFilter)
    )

    ;;;
     ; Returns true if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     ; before handing the transaction off to the wallet.  The wallet can do risk analysis on pending/recent transactions
     ; to try and discover if a pending tx might be at risk of double spending.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isDownloadTxDependencies) [])
    (§ block
        (§ return (§ expr 0 < vDownloadTxDependencyDepth))
    )

    ;;;
     ; Sets if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     ; before handing the transaction off to the wallet.  The wallet can do risk analysis on pending/recent transactions
     ; to try and discover if a pending tx might be at risk of double spending.
     ;;
    #_public
    (§ method #_"void" (§ fn setDownloadTxDependencies) [#_"boolean" (§ name enable)])
    (§ block
        (§ ass (§ name vDownloadTxDependencyDepth) (§ quest enable ? (§ expr Integer/MAX_VALUE) :else 0))
        (§ void nil)
    )

    ;;;
     ; Sets if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     ; before handing the transaction off to the wallet.  The wallet can do risk analysis on pending/recent transactions
     ; to try and discover if a pending tx might be at risk of double spending.
     ;;
    #_public
    (§ method #_"void" (§ fn setDownloadTxDependencies) [#_"int" (§ name depth)])
    (§ block
        (§ ass (§ name vDownloadTxDependencyDepth) depth)
        (§ void nil)
    )
)

#_(ns org.bitcoinj.core #_"PeerAddress"
    (:import [java.io IOException OutputStream]
             [java.math BigInteger]
             [java.net InetAddress InetSocketAddress UnknownHostException])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.net InetAddresses])
    (:import #_static [org.bitcoinj.core.Utils uint32ToByteStreamLE]
             #_static [org.bitcoinj.core.Utils uint64ToByteStreamLE]
             [org.bitcoinj.params MainNetParams]))

;;;
 ; <p>A PeerAddress holds an IP address and port number representing the network location of
 ; a peer in the Bitcoin P2P network.  It exists primarily for serialization purposes.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"PeerAddress" (§ extends #_"ChildMessage")
    #_static
    #_final
    (§ field #_"int" (§ name MESSAGE_SIZE) 30)

    #_private
    (§ field #_"InetAddress" (§ name addr))
    #_private
    (§ field #_"String" (§ name hostname)) ;; Used for .onion addresses.
    #_private
    (§ field #_"int" (§ name port))
    #_private
    (§ field #_"BigInteger" (§ name services))
    #_private
    (§ field #_"long" (§ name time))

    ;;;
     ; Construct a peer address from a serialized payload.
     ;;
    #_public
    (§ constructor #_"PeerAddress" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"int" (§ name offset), #_"int" (§ name protocolVersion)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, offset, protocolVersion))
        (§ void this)
    )

    ;;;
     ; Construct a peer address from a serialized payload.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param protocolVersion Bitcoin protocol version.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor #_"PeerAddress" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"int" (§ name offset), #_"int" (§ name protocolVersion), #_"Message" (§ name parent), #_"MessageSerializer" (§ name serializer)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, offset, protocolVersion, parent, serializer, UNKNOWN_LENGTH))
        (§ void this)
    )

    ;;;
     ; Construct a peer address from a memorized or hardcoded address.
     ;;
    #_public
    (§ constructor #_"PeerAddress" [#_"NetworkParameters" (§ name params), #_"InetAddress" (§ name addr), #_"int" (§ name port), #_"int" (§ name protocolVersion), #_"BigInteger" (§ name services)])
    (§ block
        (§ super (§ pars params))

        (§ ass (§ name this.addr) (§ expr Preconditions/checkNotNull(§ pars addr)))
        (§ ass (§ name this.port) port)
        (§ ass (§ name this.protocolVersion) protocolVersion)
        (§ ass (§ name this.services) services)

        (§ ass (§ name length) (§ quest (§ expr 31402 < protocolVersion) ? (§ expr MESSAGE_SIZE) :else (§ expr MESSAGE_SIZE - 4)))
        (§ void this)
    )

    ;;;
     ; Constructs a peer address from the given IP address and port.  Version number is default for the given parameters.
     ;;
    #_public
    (§ constructor #_"PeerAddress" [#_"NetworkParameters" (§ name params), #_"InetAddress" (§ name addr), #_"int" (§ name port)])
    (§ block
        (§ this (§ pars params, addr, port, params.getProtocolVersionNum(§ pars NetworkParameters/ProtocolVersion/CURRENT), BigInteger/ZERO))
        (§ void this)
    )

    ;;;
     ; Constructs a peer address from the given IP address.  Port and version number are default for the given parameters.
     ;;
    #_public
    (§ constructor #_"PeerAddress" [#_"NetworkParameters" (§ name params), #_"InetAddress" (§ name addr)])
    (§ block
        (§ this (§ pars params, addr, params.getPort(§ pars )))
        (§ void this)
    )

    ;;;
     ; Constructs a peer address from an {@link InetSocketAddress}.  An InetSocketAddress can take in as parameters an
     ; InetAddress or a String hostname.  If you want to connect to a .onion, set the hostname to the .onion address.
     ;;
    #_public
    (§ constructor #_"PeerAddress" [#_"NetworkParameters" (§ name params), #_"InetSocketAddress" (§ name addr)])
    (§ block
        (§ this (§ pars params, addr.getAddress(§ pars ), addr.getPort(§ pars )))
        (§ void this)
    )

    ;;;
     ; Constructs a peer address from a stringified hostname+port.  Use this if you want to connect to a Tor .onion address.
     ;;
    #_public
    (§ constructor #_"PeerAddress" [#_"NetworkParameters" (§ name params), #_"String" (§ name hostname), #_"int" (§ name port)])
    (§ block
        (§ super (§ pars params))

        (§ ass (§ name this.hostname) hostname)
        (§ ass (§ name this.port) port)
        (§ ass (§ name this.protocolVersion) (§ expr params.getProtocolVersionNum(§ pars NetworkParameters/ProtocolVersion/CURRENT)))
        (§ ass (§ name this.services) (§ expr BigInteger/ZERO))
        (§ void this)
    )

    #_public
    #_static
    (§ method #_"PeerAddress" (§ fn localhost) [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ return (§ new #_"PeerAddress" (§ pars params, InetAddresses/forString(§ pars "127.0.0.1"), params.getPort(§ pars ))))
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ if (§ expr 31402 <= protocolVersion))
        (§ block
            ;; TODO: This appears to be dynamic because the client only ever sends out it's own address
            ;; so assumes itself to be up.  For a fuller implementation this needs to be dynamic only if
            ;; the address refers to this client.
            (§ var #_"int" (§ name secs) (§ expr (§ cast #_"int" (§ expr Utils/currentTimeSeconds(§ pars )))))
            (§ expr uint32ToByteStreamLE(§ pars secs, stream))
        )
        (§ expr uint64ToByteStreamLE(§ pars services, stream)) ;; nServices.
        ;; Java does not provide any utility to map an IPv4 address into IPv6 space, so we have to do it by hand.
        (§ var #_"byte[]" (§ name ipBytes) (§ expr addr.getAddress(§ pars )))
        (§ if (§ expr ipBytes.length == 4))
        (§ block
            (§ var #_"byte[]" (§ name v6addr) (§ new #_"byte[]" (§ count 16)))
            (§ expr System/arraycopy(§ pars ipBytes, 0, v6addr, 12, 4))
            (§ ass (§ name v6addr[10]) (§ cast #_"byte" 0xff))
            (§ ass (§ name v6addr[11]) (§ cast #_"byte" 0xff))
            (§ ass (§ name ipBytes) v6addr)
        )
        (§ expr stream.write(§ pars ipBytes))
        ;; And write out the port.  Unlike the rest of the protocol, address and port is in big endian byte order.
        (§ expr stream.write(§ pars (§ cast #_"byte" (§ expr 0xff & port >> 8))))
        (§ expr stream.write(§ pars (§ cast #_"byte" (§ expr 0xff & port))))
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        ;; Format of a serialized address:
        ;;   uint32 timestamp
        ;;   uint64 services (flags determining what the node can do)
        ;;   16 bytes ip address
        ;;   2 bytes port num
        (§ ass (§ name time) (§ quest (§ expr 31402 < protocolVersion) ? (§ expr readUint32(§ pars )) :else -1))
        (§ ass (§ name services) (§ expr readUint64(§ pars )))
        (§ var #_"byte[]" (§ name addrBytes) (§ expr readBytes(§ pars 16)))
        (§ try )
        (§ block
            (§ ass (§ name addr) (§ expr InetAddress/getByAddress(§ pars addrBytes)))
        )
        (§ catch #_"UnknownHostException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
        (§ ass (§ name port) (§ expr (§ expr (§ expr payload[cursor] & 0xff) << 8) | (§ expr payload[cursor + 1] & 0xff)))
        (§ ass (§ name cursor) (§ expr cursor + 2))
        ;; The 4 byte difference is the uint32 timestamp that was introduced in version 31402.
        (§ ass (§ name length) (§ quest (§ expr 31402 < protocolVersion) ? (§ expr MESSAGE_SIZE) :else (§ expr MESSAGE_SIZE - 4)))
        (§ void nil)
    )

    #_public
    (§ method #_"String" (§ fn getHostname) [])
    (§ block
        (§ return hostname)
    )

    #_public
    (§ method #_"InetAddress" (§ fn getAddr) [])
    (§ block
        (§ return addr)
    )

    #_public
    (§ method #_"InetSocketAddress" (§ fn getSocketAddress) [])
    (§ block
        (§ return (§ new #_"InetSocketAddress" (§ pars getAddr(§ pars ), getPort(§ pars ))))
    )

    #_public
    (§ method #_"int" (§ fn getPort) [])
    (§ block
        (§ return port)
    )

    #_public
    (§ method #_"BigInteger" (§ fn getServices) [])
    (§ block
        (§ return services)
    )

    #_public
    (§ method #_"long" (§ fn getTime) [])
    (§ block
        (§ return time)
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ quest (§ expr hostname != nil) ? (§ str "[" + hostname + "]:" + port) :else (§ str "[" + (§ expr addr.getHostAddress(§ pars )) + "]:" + port)))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"PeerAddress" (§ name other) (§ expr (§ cast #_"PeerAddress" o)))
        (§ return (§ expr other.addr.equals(§ pars addr) && other.port == port && other.time == time && other.services.equals(§ pars services)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars addr, port, time, services)))
    )

    #_public
    (§ method #_"InetSocketAddress" (§ fn toSocketAddress) [])
    (§ block
        ;; Reconstruct the InetSocketAddress properly.
        (§ return (§ quest (§ expr hostname != nil) ? (§ expr InetSocketAddress/createUnresolved(§ pars hostname, port)) :else (§ new #_"InetSocketAddress" (§ pars addr, port))))
    )
)

#_(ns org.bitcoinj.core #_"PeerException")

;;;
 ; Thrown when a problem occurs in communicating with a peer, and we should retry.
 ;;
#_public
(§ class #_"PeerException" (§ extends #_"Exception")
    #_public
    (§ constructor #_"PeerException" [#_"String" (§ name msg)])
    (§ block
        (§ super (§ pars msg))
        (§ void this)
    )

    #_public
    (§ constructor #_"PeerException" [#_"Exception" (§ name e)])
    (§ block
        (§ super (§ pars e))
        (§ void this)
    )

    #_public
    (§ constructor #_"PeerException" [#_"String" (§ name msg), #_"Exception" (§ name e)])
    (§ block
        (§ super (§ pars msg, e))
        (§ void this)
    )
)

#_(ns org.bitcoinj.core #_"PeerFilterProvider")

;;;
 ; An interface which provides the information required to properly filter data downloaded from Peers.
 ; Note that an implementer is responsible for calling {@link PeerGroup#recalculateFastCatchupAndFilter(org.bitcoinj.core.PeerGroup.FilterRecalculateMode)}
 ; whenever a change occurs which effects the data provided via this interface.
 ;;
#_public
(§ interface #_"PeerFilterProvider"
    ;;;
     ; Returns the earliest timestamp (seconds since epoch) for which full/bloom-filtered blocks must be downloaded.
     ; Blocks with timestamps before this time will only have headers downloaded.  0 requires that all blocks be
     ; downloaded, and thus this should default to {@link System#currentTimeMillis()}/1000.
     ;;
    (§ method #_"long" (§ fn getEarliestKeyCreationTime) [])

    ;;;
     ; Called on all registered filter providers before getBloomFilterElementCount and getBloomFilter are called.
     ; Once called, the provider should ensure that the items it will want to insert into the filter don't change.
     ; The reason is that all providers will have their element counts queried, and then a filter big enough for
     ; all of them will be specified.  So the provider must use consistent state.  There is guaranteed to be
     ; a matching call to endBloomFilterCalculation that can be used to e.g. unlock a lock.
     ;;
    (§ method #_"void" (§ fn beginBloomFilterCalculation) [])

    ;;;
     ; Gets the number of elements that will be added to a bloom filter returned by
     ; {@link PeerFilterProvider#getBloomFilter(int, double, long)}.
     ;;
    (§ method #_"int" (§ fn getBloomFilterElementCount) [])

    ;;;
     ; Gets a bloom filter that contains all the necessary elements for the listener to receive relevant transactions.
     ; Default value should be an empty bloom filter with the given size, falsePositiveRate, and nTweak.
     ;;
    (§ method #_"BloomFilter" (§ fn getBloomFilter) [#_"int" (§ name size), #_"double" (§ name falsePositiveRate), #_"long" (§ name nTweak)])

    (§ method #_"void" (§ fn endBloomFilterCalculation) [])
)

#_(ns org.bitcoinj.core #_"PeerGroup"
    (:import [java.io *]
             [java.net *]
             [java.util *]
             [java.util.concurrent *]
             [java.util.concurrent.locks *])
    (:import [com.google.common.annotations *]
             [com.google.common.base *]
             [com.google.common.collect *]
             [com.google.common.net *]
             [com.google.common.primitives *]
             [com.google.common.util.concurrent *]
             [net.jcip.annotations *]
             [org.slf4j *])
   (:require [org.bitcoinj.core.listeners *]
             [org.bitcoinj.net *]
             [org.bitcoinj.net.discovery *]
             [org.bitcoinj.script *]
             [org.bitcoinj.utils * Threading]
             [org.bitcoinj.wallet Wallet]
             [org.bitcoinj.wallet.listeners KeyChainEventListener WalletCoinsReceivedEventListener]))

;;;
 ; <p>Runs a set of connections to the P2P network, brings up connections to replace disconnected nodes and manages
 ; the interaction between them all.  Most applications will want to use one of these.</p>
 ;
 ; <p>PeerGroup tries to maintain a constant number of connections to a set of distinct peers.
 ; Each peer runs a network listener in its own thread.  When a connection is lost, a new peer
 ; will be tried after a delay as long as the number of connections less than the maximum.</p>
 ;
 ; <p>Connections are made to addresses from a provided list.  When that list is exhausted,
 ; we start again from the head of the list.</p>
 ;
 ; <p>The PeerGroup can broadcast a transaction to the currently connected set of peers.  It can
 ; also handle download of the blockchain from peers, restarting the process when peers die.</p>
 ;
 ; <p>A PeerGroup won't do anything until you call the {@link PeerGroup#start()} method
 ; which will block until peer discovery is completed and some outbound connections
 ; have been initiated (it will return before handshaking is done, however).
 ; You should call {@link PeerGroup#stop()} when finished.  Note that not all methods
 ; of PeerGroup are safe to call from a UI thread as some may do network IO,
 ; but starting and stopping the service should be fine.</p>
 ;;
#_public
(§ class #_"PeerGroup" (§ implements #_"TransactionBroadcaster")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"PeerGroup"))))

    ;; All members in this class should be marked with final, volatile, @GuardedBy or a mix as appropriate to define
    ;; their thread safety semantics.  Volatile requires a Hungarian-style v prefix.

    ;; By default we don't require any services because any peer will do.
    #_private
    (§ field #_"long" (§ name requiredServices) 0)

    ;;;
     ; The default number of connections to the p2p network the library will try to build.  This is set to 12 empirically.
     ; It used to be 4, but because we divide the connection pool in two for broadcasting transactions, that meant we
     ; were only sending transactions to two peers and sometimes this wasn't reliable enough: transactions wouldn't
     ; get through.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name DEFAULT_CONNECTIONS) 12)
    #_private
    #_volatile
    (§ field #_"int" (§ name vMaxPeersToDiscoverCount) 100)
    #_private
    #_static
    #_final
    (§ field #_"long" (§ name DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS) 5000)
    #_private
    #_volatile
    (§ field #_"long" (§ name vPeerDiscoveryTimeoutMillis) (§ expr DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS))

    #_protected
    #_final
    (§ field #_"ReentrantLock" (§ name lock) (§ expr Threading/lock(§ pars "peergroup")))

    #_protected
    #_final
    (§ field #_"NetworkParameters" (§ name params))
    #_nilable
    #_protected
    #_final
    (§ field #_"AbstractBlockChain" (§ name chain))

    ;; This executor is used to queue up jobs: it's used when we don't want to use locks for mutual exclusion,
    ;; typically because the job might call in to user provided code that needs/wants the freedom to use the API
    ;; however it wants, or because a job needs to be ordered relative to other jobs like that.
    #_protected
    #_final
    (§ field #_"ListeningScheduledExecutorService" (§ name executor))

    ;; Whether the peer group is currently running.  Once shut down it cannot be restarted.
    #_private
    #_volatile
    (§ field #_"boolean" (§ name vRunning))
    ;; Whether the peer group has been started or not.  An unstarted PG does not try to access the network.
    #_private
    #_volatile
    (§ field #_"boolean" (§ name vUsedUp))

    ;; Addresses to try to connect to, excluding active peers.
    #_guarded-by(§ opt "lock")
    #_private
    #_final
    (§ field #_"PriorityQueue<PeerAddress>" (§ name inactives))
    #_guarded-by(§ opt "lock")
    #_private
    #_final
    (§ field #_"Map<PeerAddress, ExponentialBackoff>" (§ name backoffMap))

    ;; Currently active peers.  This is an ordered list rather than a set to make unit tests predictable.
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<Peer>" (§ name peers))
    ;; Currently connecting peers.
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<Peer>" (§ name pendingPeers))
    #_private
    #_final
    (§ field #_"ClientConnectionManager" (§ name channels))

    ;; The peer that has been selected for the purposes of downloading announced data.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"Peer" (§ name downloadPeer))
    ;; Callback for events related to chain download.
    #_nilable
    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"PeerDataEventListener" (§ name downloadListener))

    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<BlocksDownloadedEventListener>>" (§ name peersBlocksDownloadedEventListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<ChainDownloadStartedEventListener>>" (§ name peersChainDownloadStartedEventListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
    ;;; Callbacks for events related to peers connecting. ;;
    #_protected
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<PeerConnectedEventListener>>" (§ name peerConnectedEventListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
    ;;; Callbacks for events related to peer connection/disconnection. ;;
    #_protected
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<PeerDiscoveredEventListener>>" (§ name peerDiscoveredEventListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
    ;;; Callbacks for events related to peers disconnecting. ;;
    #_protected
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<PeerDisconnectedEventListener>>" (§ name peerDisconnectedEventListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
    ;;; Callbacks for events related to peer data being received. ;;
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<GetDataEventListener>>" (§ name peerGetDataEventListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<PreMessageReceivedEventListener>>" (§ name peersPreMessageReceivedEventListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
    #_protected
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<OnTransactionBroadcastListener>>" (§ name peersTransactionBroadastEventListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))

    ;; Peer discovery sources, will be polled occasionally if there aren't enough inactives.
    #_private
    #_final
    (§ field #_"CopyOnWriteArraySet<PeerDiscovery>" (§ name peerDiscoverers))
    ;; The version message to use for new connections.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"VersionMessage" (§ name versionMessage))
    ;; Maximum depth up to which pending transaction dependencies are downloaded, or 0 for disabled.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"int" (§ name downloadTxDependencyDepth))
    ;; How many connections we want to have open at the current time.  If we lose connections, we'll try opening more
    ;; until we reach this count.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"int" (§ name maxConnections))
    ;; Minimum protocol version we will allow ourselves to connect to: require Bloom filtering.
    #_private
    #_volatile
    (§ field #_"int" (§ name vMinRequiredProtocolVersion))

    ;;; How many milliseconds to wait after receiving a pong before sending another ping. ;;
    #_public
    #_static
    #_final
    (§ field #_"long" (§ name DEFAULT_PING_INTERVAL_MSEC) 2000)
    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"long" (§ name pingIntervalMsec) (§ expr DEFAULT_PING_INTERVAL_MSEC))

    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"boolean" (§ name useLocalhostPeerWhenPossible) true)
    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"boolean" (§ name ipv6Unreachable) false)

    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"long" (§ name fastCatchupTimeSecs))
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<Wallet>" (§ name wallets))
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<PeerFilterProvider>" (§ name peerFilterProviders))

    ;; This event listener is added to every peer.  It's here so when we announce transactions via an "inv",
    ;; every peer can fetch them.
    #_private
    #_final
    (§ field #_"PeerListener" (§ name peerListener) (§ new #_"PeerListener" (§ pars )))

    #_private
    (§ field #_"int" (§ name minBroadcastConnections) 0)

    #_private
    #_final
    (§ field #_"KeyChainEventListener" (§ name walletKeyEventListener) (§ new #_"KeyChainEventListener" (§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn onKeysAdded) [#_"List<ECKey>" (§ name keys)])
            (§ block
                (§ expr recalculateFastCatchupAndFilter(§ pars FilterRecalculateMode/SEND_IF_CHANGED))
                (§ void nil)
            )
        )))

    #_private
    #_final
    (§ field #_"WalletCoinsReceivedEventListener" (§ name walletCoinsReceivedEventListener) (§ new #_"WalletCoinsReceivedEventListener" (§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn onCoinsReceived) [#_"Wallet" (§ name wallet), #_"Transaction" (§ name tx), #_"Coin" (§ name prevBalance), #_"Coin" (§ name newBalance)])
            (§ block
                ;; We received a relevant transaction.  We MAY need to recalculate and resend the Bloom filter, but only
                ;; if we have received a transaction that includes a relevant pay-to-pubkey output.
                ;;
                ;; The reason is that pay-to-pubkey outputs, when spent, will not repeat any data we can predict in their
                ;; inputs.  So a remote peer will update the Bloom filter for us when such an output is seen matching the
                ;; existing filter, so that it includes the tx hash in which the pay-to-pubkey output was observed.  Thus
                ;; the spending transaction will always match (due to the outpoint structure).
                ;;
                ;; Unfortunately, whilst this is required for correct sync of the chain in blocks, there are two edge cases.
                ;;
                ;; (1) If a wallet receives a relevant, confirmed p2pubkey output that was not broadcast across the network,
                ;; for example in a coinbase transaction, then the node that's serving us the chain will update its filter
                ;; but the rest will not.  If another transaction then spends it, the other nodes won't match/relay it.
                ;;
                ;; (2) If we receive a p2pubkey output broadcast across the network, all currently connected nodes will see
                ;; it and update their filter themselves, but any newly connected nodes will receive the last filter we
                ;; calculated, which would not include this transaction.
                ;;
                ;; For this reason we check if the transaction contained any relevant pay to pubkeys and force a recalc
                ;; and possibly retransmit if so.  The recalculation process will end up including the tx hash into the
                ;; filter.  In case (1), we need to retransmit the filter to the connected peers.  In case (2), we don't
                ;; and shouldn't, we should just recalculate and cache the new filter for next time.

                (§ for (§ var #_"TransactionOutput" (§ name output)) :for (§ expr tx.getOutputs(§ pars )))
                (§ block
                    (§ if (§ expr output.getScriptPubKey(§ pars ).isSentToRawPubKey(§ pars ) && output.isMine(§ pars wallet)))
                    (§ block
                        (§ if (§ expr tx.getConfidence(§ pars ).getConfidenceType(§ pars ) == TransactionConfidence/ConfidenceType/BUILDING))
                        (§ block
                            (§ expr recalculateFastCatchupAndFilter(§ pars FilterRecalculateMode/SEND_IF_CHANGED))
                        )
                        (§ else )
                        (§ block
                            (§ expr recalculateFastCatchupAndFilter(§ pars FilterRecalculateMode/DONT_SEND))
                        )
                        (§ return nil)
                    )
                )
                (§ void nil)
            )
        )))

    ;; Exponential backoff for peers starts at 1 second and maxes at 10 minutes.
    #_private
    #_final
    (§ field #_"ExponentialBackoff.Params" (§ name peerBackoffParams) (§ new #_"ExponentialBackoff.Params" (§ pars 1000, 1.5, 10 * 60 * 1000)))
    ;; Tracks failures globally in case of a network failure.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"ExponentialBackoff" (§ name groupBackoff) (§ new #_"ExponentialBackoff" (§ pars (§ new #_"ExponentialBackoff.Params" (§ pars 1000, 1.5, 10 * 1000)))))

    ;; This is a synchronized set, so it locks on itself.  We use it to prevent TransactionBroadcast objects from
    ;; being garbage collected if nothing in the apps code holds on to them transitively.  See the discussion
    ;; in broadcastTransaction.
    #_private
    #_final
    (§ field #_"Set<TransactionBroadcast>" (§ name runningBroadcasts))

    #_private
    (§ class #_"PeerListener" (§ implements #_"GetDataEventListener", #_"BlocksDownloadedEventListener")
        #_public
        (§ constructor #_"PeerListener" [])
        (§ block
            (§ void this)
        )

        #_override
        #_public
        (§ method #_"List<Message>" (§ fn getData) [#_"Peer" (§ name peer), #_"GetDataMessage" (§ name m)])
        (§ block
            (§ return (§ expr handleGetData(§ pars m)))
        )

        #_override
        #_public
        (§ method #_"void" (§ fn onBlocksDownloaded) [#_"Peer" (§ name peer), #_"Block" (§ name block), #_nilable #_"FilteredBlock" (§ name filteredBlock), #_"int" (§ name blocksLeft)])
        (§ block
            (§ if (§ expr chain != nil))
            (§ block
                #_final
                (§ var #_"double" (§ name rate) (§ expr chain.getFalsePositiveRate(§ pars )))
                #_final
                (§ var #_"double" (§ name target) (§ expr bloomFilterMerger.getBloomFilterFPRate(§ pars ) * MAX_FP_RATE_INCREASE))
                (§ if (§ expr target < rate))
                (§ block
                    ;; TODO: Avoid hitting this path if the remote peer didn't acknowledge applying a new filter yet.
                    (§ if (§ expr log.isDebugEnabled(§ pars )))
                    (§ block
                        (§ expr log.debug(§ pars "Force update Bloom filter due to high false positive rate ({} vs {})", rate, target))
                    )

                    (§ expr recalculateFastCatchupAndFilter(§ pars FilterRecalculateMode/FORCE_SEND_FOR_REFRESH))
                )
            )
            (§ void nil)
        )
    )

    #_private
    (§ class #_"PeerStartupListener" (§ implements #_"PeerConnectedEventListener", #_"PeerDisconnectedEventListener")
        #_override
        #_public
        (§ method #_"void" (§ fn onPeerConnected) [#_"Peer" (§ name peer), #_"int" (§ name peerCount)])
        (§ block
            (§ expr handleNewPeer(§ pars peer))
            (§ void nil)
        )

        #_override
        #_public
        (§ method #_"void" (§ fn onPeerDisconnected) [#_"Peer" (§ name peer), #_"int" (§ name peerCount)])
        (§ block
            ;; The channel will be automatically removed from channels.
            (§ expr handlePeerDeath(§ pars peer, nil))
            (§ void nil)
        )
    )

    #_private
    #_final
    (§ field #_"PeerStartupListener" (§ name startupListener) (§ new #_"PeerStartupListener" (§ pars )))

    ;;;
     ; The default Bloom filter false positive rate, which is selected to be extremely low such that you hardly ever
     ; download false positives.  This provides maximum performance.  Although this default can be overridden to push
     ; the FP rate higher, due to <a href="https://groups.google.com/forum/#!msg/bitcoinj/Ys13qkTwcNg/9qxnhwnkeoIJ">
     ; various complexities</a> there are still ways a remote peer can deanonymize the users wallet.  This is why the
     ; FP rate is chosen for performance rather than privacy.  If a future version of bitcoinj fixes the known
     ; de-anonymization attacks this FP rate may rise again (or more likely, become expressed as a bandwidth allowance).
     ;;
    #_public
    #_static
    #_final
    (§ field #_"double" (§ name DEFAULT_BLOOM_FILTER_FP_RATE) 0.00001)
    ;;; Maximum increase in FP rate before forced refresh of the bloom filter. ;;
    #_public
    #_static
    #_final
    (§ field #_"double" (§ name MAX_FP_RATE_INCREASE) 10.0)
    ;; An object that calculates bloom filters given a list of filter providers, whilst tracking some state useful
    ;; for privacy purposes.
    #_private
    #_final
    (§ field #_"FilterMerger" (§ name bloomFilterMerger))

    ;;; The default timeout between when a connection attempt begins and version message exchange completes. ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name DEFAULT_CONNECT_TIMEOUT_MILLIS) 5000)
    #_private
    #_volatile
    (§ field #_"int" (§ name vConnectTimeoutMillis) (§ expr DEFAULT_CONNECT_TIMEOUT_MILLIS))

    ;;; Whether bloom filter support is enabled when using a non FullPrunedBlockchain. ;;
    #_private
    #_volatile
    (§ field #_"boolean" (§ name vBloomFilteringEnabled) true)

    ;;; See {@link #PeerGroup(Context)}. ;;
    #_public
    (§ constructor #_"PeerGroup" [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ this (§ pars params, nil))
        (§ void this)
    )

    ;;;
     ; Creates a PeerGroup with the given context.  No chain is provided so this node will report its chain height
     ; as zero to other peers.  This constructor is useful if you just want to explore the network but aren't interested
     ; in downloading block data.
     ;;
    #_public
    (§ constructor #_"PeerGroup" [#_"Context" (§ name context)])
    (§ block
        (§ this (§ pars context, nil))
        (§ void this)
    )

    ;;; See {@link #PeerGroup(Context, AbstractBlockChain)}. ;;
    #_public
    (§ constructor #_"PeerGroup" [#_"NetworkParameters" (§ name params), #_nilable #_"AbstractBlockChain" (§ name chain)])
    (§ block
        (§ this (§ pars Context/getOrCreate(§ pars params), chain, new NioClientManager(§ pars )))
        (§ void this)
    )

    ;;;
     ; Creates a PeerGroup for the given context and chain.  Blocks will be passed to the chain as they are broadcast
     ; and downloaded.  This is probably the constructor you want to use.
     ;;
    #_public
    (§ constructor #_"PeerGroup" [#_"Context" (§ name context), #_nilable #_"AbstractBlockChain" (§ name chain)])
    (§ block
        (§ this (§ pars context, chain, new NioClientManager(§ pars )))
        (§ void this)
    )

    ;;; See {@link #PeerGroup(Context, AbstractBlockChain, ClientConnectionManager)}. ;;
    #_public
    (§ constructor #_"PeerGroup" [#_"NetworkParameters" (§ name params), #_nilable #_"AbstractBlockChain" (§ name chain), #_"ClientConnectionManager" (§ name connectionManager)])
    (§ block
        (§ this (§ pars Context/getOrCreate(§ pars params), chain, connectionManager))
        (§ void this)
    )

    ;;;
     ; Creates a new PeerGroup allowing you to specify the {@link ClientConnectionManager} which is used to create new
     ; connections and keep track of existing ones.
     ;;
    #_private
    (§ constructor #_"PeerGroup" [#_"Context" (§ name context), #_nilable #_"AbstractBlockChain" (§ name chain), #_"ClientConnectionManager" (§ name connectionManager)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars context))

        (§ ass (§ name this.params) (§ expr context.getParams(§ pars )))
        (§ ass (§ name this.chain) chain)
        (§ ass (§ name fastCatchupTimeSecs) (§ expr params.getGenesisBlock(§ pars ).getTimeSeconds(§ pars )))
        (§ ass (§ name wallets) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
        (§ ass (§ name peerFilterProviders) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))

        (§ ass (§ name executor) (§ expr createPrivateExecutor(§ pars )))

        ;; This default sentinel value will be overridden by one of two actions:
        ;;   - adding a peer discovery source sets it to the default.
        ;;   - using connectTo() will increment it by one.
        (§ ass (§ name maxConnections) 0)

        (§ var #_"int" (§ name height) (§ quest (§ expr chain != nil) ? (§ expr chain.getBestChainHeight(§ pars )) :else 0))
        (§ ass (§ name versionMessage) (§ new #_"VersionMessage" (§ pars params, height)))
        ;; We never request that the remote node wait for a bloom filter yet, as we have no wallets.
        (§ ass (§ name versionMessage.relayTxesBeforeFilter) true)

        (§ ass (§ name downloadTxDependencyDepth) (§ expr Integer/MAX_VALUE))

        (§ ass (§ name inactives) (§ new #_"PriorityQueue<>" (§ pars 1, new Comparator<PeerAddress>(§ pars )
        (§ anon
            #_suppress(§ opt "FieldAccessNotGuarded") ;; Only called when inactives is accessed, and lock is held then.
            #_override
            #_public
            (§ method #_"int" (§ fn compare) [#_"PeerAddress" (§ name a), #_"PeerAddress" (§ name b)])
            (§ block
                (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

                (§ var #_"int" (§ name result) (§ expr backoffMap.get(§ pars a).compareTo(§ pars backoffMap.get(§ pars b))))
                ;; Sort by port if otherwise equals - for testing.
                (§ if (§ expr result == 0))
                (§ block
                    (§ ass (§ name result) (§ expr Ints/compare(§ pars a.getPort(§ pars ), b.getPort(§ pars ))))
                )
                (§ return result)
            )
        ))))
        (§ ass (§ name backoffMap) (§ new #_"HashMap<>" (§ pars )))
        (§ ass (§ name peers) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
        (§ ass (§ name pendingPeers) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
        (§ ass (§ name channels) connectionManager)
        (§ ass (§ name peerDiscoverers) (§ new #_"CopyOnWriteArraySet<>" (§ pars )))
        (§ ass (§ name runningBroadcasts) (§ expr Collections/synchronizedSet(§ pars (§ new #_"HashSet<TransactionBroadcast>" (§ pars )))))
        (§ ass (§ name bloomFilterMerger) (§ new #_"FilterMerger" (§ pars DEFAULT_BLOOM_FILTER_FP_RATE)))
        (§ ass (§ name vMinRequiredProtocolVersion) (§ expr params.getProtocolVersionNum(§ pars NetworkParameters/ProtocolVersion/BLOOM_FILTER)))
        (§ void this)
    )

    #_private
    (§ field #_"CountDownLatch" (§ name executorStartupLatch) (§ new #_"CountDownLatch" (§ pars 1)))

    #_protected
    (§ method #_"ListeningScheduledExecutorService" (§ fn createPrivateExecutor) [])
    (§ block
        (§ var #_"ListeningScheduledExecutorService" (§ name result) (§ expr MoreExecutors/listeningDecorator(§ pars (§ new #_"ScheduledThreadPoolExecutor" (§ pars 1, new ContextPropagatingThreadFactory(§ pars "PeerGroup Thread"))))))
        ;; Hack: jam the executor so jobs just queue up until the user calls start() on us.  For example, adding a wallet
        ;; results in a bloom filter recalc being queued, but we don't want to do that until we're actually started.
        (§ expr result.execute(§ pars (§ new #_"Runnable" (§ pars ))
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn run) [])
            (§ block
                (§ expr Uninterruptibles/awaitUninterruptibly(§ pars executorStartupLatch))
                (§ void nil)
            )
        )))
        (§ return result)
    )

    ;;;
     ; This is how many milliseconds we wait for peer discoveries to return their results.
     ;;
    #_public
    (§ method #_"void" (§ fn setPeerDiscoveryTimeoutMillis) [#_"long" (§ name peerDiscoveryTimeoutMillis)])
    (§ block
        (§ ass (§ name this.vPeerDiscoveryTimeoutMillis) peerDiscoveryTimeoutMillis)
        (§ void nil)
    )

    ;;;
     ; Adjusts the desired number of connections that we will create to peers.  Note that if there are already peers
     ; open and the new value is lower than the current number of peers, those connections will be terminated.
     ; Likewise if there aren't enough current connections to meet the new requested max size, some will be added.
     ;;
    #_public
    (§ method #_"void" (§ fn setMaxConnections) [#_"int" (§ name maxConnections)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name this.maxConnections) maxConnections)
            (§ if (§ expr (§ not isRunning(§ pars ))))
            (§ block
                (§ return nil)
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )

        ;; We may now have too many or too few open connections.  Add more or drop some to get to the right amount.
        (§ var #_"int" (§ name adjustment) (§ expr maxConnections - channels.getConnectedClientCount(§ pars )))
        (§ if (§ expr 0 < adjustment))
        (§ block
            (§ expr triggerConnections(§ pars ))
        )

        (§ if (§ expr adjustment < 0))
        (§ block
            (§ expr channels.closeConnections(§ pars (§ neg adjustment)))
        )
        (§ void nil)
    )

    ;;;
     ; Configure download of pending transaction dependencies.  A change of values only takes effect for newly connected peers.
     ;;
    #_public
    (§ method #_"void" (§ fn setDownloadTxDependencies) [#_"int" (§ name depth)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name this.downloadTxDependencyDepth) depth)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    #_private
    (§ field #_"Runnable" (§ name triggerConnectionsJob) (§ new #_"Runnable" (§ pars )
        (§ anon
            #_private
            (§ field #_"boolean" (§ name firstRun) true)
            #_private
            #_final
            #_static
            (§ field #_"long" (§ name MIN_PEER_DISCOVERY_INTERVAL) 1000)

            #_override
            #_public
            (§ method #_"void" (§ fn run) [])
            (§ block
                (§ try )
                (§ block
                    (§ expr go(§ pars ))
                )
                (§ catch #_"Throwable" (§ name e))
                (§ block
                    (§ expr log.error(§ pars "Exception when trying to build connections", e)) ;; The executor swallows exceptions :( ;; )
                )
                (§ void nil)
            )

            #_public
            (§ method #_"void" (§ fn go) [])
            (§ block
                (§ if (§ expr (§ not vRunning)))
                (§ block
                    (§ return nil)
                )

                (§ var #_"boolean" (§ name doDiscovery) false)
                (§ var #_"long" (§ name now) (§ expr Utils/currentTimeMillis(§ pars )))
                (§ expr lock.lock(§ pars ))
                (§ try )
                (§ block
                    ;; First run: try and use a local node if there is one, for the additional security it can provide.
                    ;; But, not on Android as there are none for this platform: it could only be a malicious app trying
                    ;; to hijack our traffic.
                    (§ if (§ expr (§ not Utils/isAndroidRuntime(§ pars )) && useLocalhostPeerWhenPossible && maybeCheckForLocalhostPeer(§ pars ) && firstRun))
                    (§ block
                        (§ expr log.info(§ pars "Localhost peer detected, trying to use it instead of P2P discovery"))
                        (§ ass (§ name maxConnections) 0)
                        (§ expr connectToLocalHost(§ pars ))
                        (§ return nil)
                    )

                    (§ var #_"boolean" (§ name havePeerWeCanTry) (§ expr (§ not inactives.isEmpty(§ pars )) && backoffMap.get(§ pars inactives.peek(§ pars )).getRetryTime(§ pars ) <= now))
                    (§ ass (§ name doDiscovery) (§ expr (§ not havePeerWeCanTry)))
                )
                (§ finally )
                (§ block
                    (§ ass (§ name firstRun) false)
                    (§ expr lock.unlock(§ pars ))
                )

                ;; Don't hold the lock across discovery as this process can be very slow.
                (§ var #_"boolean" (§ name discoverySuccess) false)
                (§ if doDiscovery)
                (§ block
                    (§ try )
                    (§ block
                        (§ ass (§ name discoverySuccess) (§ expr 0 < discoverPeers(§ pars )))
                    )
                    (§ catch #_"PeerDiscoveryException" (§ name e))
                    (§ block
                        (§ expr log.error(§ pars "Peer discovery failure", e))
                    )
                )

                (§ var #_"long" (§ name retryTime))
                (§ var #_"PeerAddress" (§ name addrToTry))
                (§ expr lock.lock(§ pars ))
                (§ try )
                (§ block
                    (§ if doDiscovery)
                    (§ block
                        ;; Require that we have enough connections, to consider this a success,
                        ;; or we just constantly test for new peers.
                        (§ if (§ expr discoverySuccess && getMaxConnections(§ pars ) <= countConnectedAndPendingPeers(§ pars )))
                        (§ block
                            (§ expr groupBackoff.trackSuccess(§ pars ))
                        )
                        (§ else )
                        (§ block
                            (§ expr groupBackoff.trackFailure(§ pars ))
                        )
                    )
                    ;; Inactives is sorted by backoffMap time.
                    (§ if (§ expr inactives.isEmpty(§ pars )))
                    (§ block
                        (§ if (§ expr countConnectedAndPendingPeers(§ pars ) < getMaxConnections(§ pars )))
                        (§ block
                            (§ var #_"long" (§ name interval) (§ expr Math/max(§ pars groupBackoff.getRetryTime(§ pars ) - now, MIN_PEER_DISCOVERY_INTERVAL)))
                            (§ expr log.info(§ pars "Peer discovery didn't provide us any more peers, will try again in " + interval + "ms."))
                            (§ expr executor.schedule(§ pars this, interval, TimeUnit/MILLISECONDS))
                        )
                        (§ else )
                        (§ block
                            ;; We have enough peers and discovery provided no more, so just settle down.
                            ;; Most likely we were given a fixed set of addresses in some test scenario.
                        )
                        (§ return nil)
                    )
                    (§ else )
                    (§ block
                        (§ do )
                        (§ block
                            (§ ass (§ name addrToTry) (§ expr inactives.poll(§ pars )))
                        )
                        (§ again (§ expr ipv6Unreachable && (§ insta (§ dot addrToTry.getAddr(§ pars )) #_"Inet6Address")))
                        (§ ass (§ name retryTime) (§ expr backoffMap.get(§ pars addrToTry).getRetryTime(§ pars )))
                    )
                    (§ ass (§ name retryTime) (§ expr Math/max(§ pars retryTime, groupBackoff.getRetryTime(§ pars ))))
                    (§ if (§ expr now < retryTime))
                    (§ block
                        (§ var #_"long" (§ name delay) (§ expr retryTime - now))
                        (§ expr log.info(§ pars "Waiting {} msec before next connect attempt {}", delay, (§ quest (§ expr addrToTry != nil) ? (§ str "to " + addrToTry) :else (§ expr ""))))
                        (§ expr inactives.add(§ pars addrToTry))
                        (§ expr executor.schedule(§ pars this, delay, TimeUnit/MILLISECONDS))
                        (§ return nil)
                    )
                    (§ expr connectTo(§ pars addrToTry, false, vConnectTimeoutMillis))
                )
                (§ finally )
                (§ block
                    (§ expr lock.unlock(§ pars ))
                )
                (§ if (§ expr countConnectedAndPendingPeers(§ pars ) < getMaxConnections(§ pars )))
                (§ block
                    (§ expr executor.execute(§ pars this)) ;; Try next peer immediately.
                )
                (§ void nil)
            )
        )))

    #_private
    (§ method #_"void" (§ fn triggerConnections) [])
    (§ block
        ;; Run on a background thread due to the need to potentially retry and back off in the background.
        (§ if (§ expr (§ not executor.isShutdown(§ pars ))))
        (§ block
            (§ expr executor.execute(§ pars triggerConnectionsJob))
        )
        (§ void nil)
    )

    ;;; The maximum number of connections that we will create to peers. ;;
    #_public
    (§ method #_"int" (§ fn getMaxConnections) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return maxConnections)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_private
    (§ method #_"List<Message>" (§ fn handleGetData) [#_"GetDataMessage" (§ name m)])
    (§ block
        ;; Scans the wallets and memory pool for transactions in the getdata message and returns them.
        ;; Runs on peer threads.
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"LinkedList<Message>" (§ name transactions) (§ new #_"LinkedList<>" (§ pars )))
            (§ var #_"LinkedList<InventoryItem>" (§ name items) (§ new #_"LinkedList<>" (§ pars m.getItems(§ pars ))))
            (§ var #_"Iterator<InventoryItem>" (§ name it) (§ expr items.iterator(§ pars )))
            (§ while (§ expr it.hasNext(§ pars )))
            (§ block
                (§ var #_"InventoryItem" (§ name item) (§ expr it.next(§ pars )))
                ;; Check the wallets.
                (§ for (§ var #_"Wallet" (§ name w)) :for wallets)
                (§ block
                    (§ var #_"Transaction" (§ name tx) (§ expr w.getTransaction(§ pars item.hash)))
                    (§ if (§ expr tx != nil))
                    (§ block
                        (§ expr transactions.add(§ pars tx))
                        (§ expr it.remove(§ pars ))
                        (§ break )
                    )
                )
            )
            (§ return transactions)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Sets the {@link VersionMessage} that will be announced on newly created connections.  A version message is
     ; primarily interesting because it lets you customize the "subVer" field which is used a bit like the User-Agent
     ; field from HTTP.  It means your client tells the other side what it is, see
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki">BIP 14</a>.
     ;
     ; The VersionMessage you provide is copied and the best chain height/time filled in for each new connection,
     ; therefore you don't have to worry about setting that.  The provided object is really more of a template.
     ;;
    #_public
    (§ method #_"void" (§ fn setVersionMessage) [#_"VersionMessage" (§ name ver)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name versionMessage) ver)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Returns the version message provided by setVersionMessage or a default if none was given.
     ;;
    #_public
    (§ method #_"VersionMessage" (§ fn getVersionMessage) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return versionMessage)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Sets information that identifies this software to remote nodes.  This is a convenience wrapper for creating
     ; a new {@link VersionMessage}, calling {@link VersionMessage#appendToSubVer(String, String, String)} on it,
     ; and then calling {@link PeerGroup#setVersionMessage(VersionMessage)} on the result of that.  See the docs for
     ; {@link VersionMessage#appendToSubVer(String, String, String)} for information on what the fields should contain.
     ;;
    #_public
    (§ method #_"void" (§ fn setUserAgent) [#_"String" (§ name name), #_"String" (§ name version), #_nilable #_"String" (§ name comments)])
    (§ block
        ;; TODO: Check that height is needed here (it wasnt, but it should be, no?)
        (§ var #_"int" (§ name height) (§ quest (§ expr chain != nil) ? (§ expr chain.getBestChainHeight(§ pars )) :else 0))
        (§ var #_"VersionMessage" (§ name ver) (§ new #_"VersionMessage" (§ pars params, height)))
        (§ ass (§ name ver.relayTxesBeforeFilter) false)
        (§ expr updateVersionMessageRelayTxesBeforeFilter(§ pars ver))
        (§ expr ver.appendToSubVer(§ pars name, version, comments))
        (§ expr setVersionMessage(§ pars ver))
        (§ void nil)
    )

    ;; Updates the relayTxesBeforeFilter flag of ver.
    #_private
    (§ method #_"void" (§ fn updateVersionMessageRelayTxesBeforeFilter) [#_"VersionMessage" (§ name ver)])
    (§ block
        ;; We will provide the remote node with a bloom filter (i.e. they shouldn't relay yet)
        ;; if chain == null || !chain.shouldVerifyTransactions() and a wallet is added and bloom filters are enabled.
        ;; Note that the default here means that no tx invs will be received if no wallet is ever added.
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"boolean" (§ name spvMode) (§ expr chain != nil && (§ not chain.shouldVerifyTransactions(§ pars ))))
            (§ var #_"boolean" (§ name willSendFilter) (§ expr spvMode && 0 < peerFilterProviders.size(§ pars ) && vBloomFilteringEnabled))
            (§ ass (§ name ver.relayTxesBeforeFilter) (§ expr (§ not willSendFilter)))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Sets information that identifies this software to remote nodes.  This is a convenience wrapper for creating
     ; a new {@link VersionMessage}, calling {@link VersionMessage#appendToSubVer(String, String, String)} on it,
     ; and then calling {@link PeerGroup#setVersionMessage(VersionMessage)} on the result of that.  See the docs for
     ; {@link VersionMessage#appendToSubVer(String, String, String)} for information on what the fields should contain.
     ;;
    #_public
    (§ method #_"void" (§ fn setUserAgent) [#_"String" (§ name name), #_"String" (§ name version)])
    (§ block
        (§ expr setUserAgent(§ pars name, version, nil))
        (§ void nil)
    )

    ;;; See {@link Peer#addBlocksDownloadedEventListener(BlocksDownloadedEventListener)}. ;;
    #_public
    (§ method #_"void" (§ fn addBlocksDownloadedEventListener) [#_"BlocksDownloadedEventListener" (§ name listener)])
    (§ block
        (§ expr addBlocksDownloadedEventListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; blocks are downloaded by the download peer.</p>
     ; @see Peer#addBlocksDownloadedEventListener(Executor, BlocksDownloadedEventListener)
     ;;
    #_public
    (§ method #_"void" (§ fn addBlocksDownloadedEventListener) [#_"Executor" (§ name executor), #_"BlocksDownloadedEventListener" (§ name listener)])
    (§ block
        (§ expr peersBlocksDownloadedEventListeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars Preconditions/checkNotNull(§ pars listener), executor))))
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ expr peer.addBlocksDownloadedEventListener(§ pars executor, listener))
        )
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ expr peer.addBlocksDownloadedEventListener(§ pars executor, listener))
        )
        (§ void nil)
    )

    ;;; See {@link Peer#addBlocksDownloadedEventListener(BlocksDownloadedEventListener)}. ;;
    #_public
    (§ method #_"void" (§ fn addChainDownloadStartedEventListener) [#_"ChainDownloadStartedEventListener" (§ name listener)])
    (§ block
        (§ expr addChainDownloadStartedEventListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; chain download starts.</p>
     ;;
    #_public
    (§ method #_"void" (§ fn addChainDownloadStartedEventListener) [#_"Executor" (§ name executor), #_"ChainDownloadStartedEventListener" (§ name listener)])
    (§ block
        (§ expr peersChainDownloadStartedEventListeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars Preconditions/checkNotNull(§ pars listener), executor))))
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ expr peer.addChainDownloadStartedEventListener(§ pars executor, listener))
        )
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ expr peer.addChainDownloadStartedEventListener(§ pars executor, listener))
        )
        (§ void nil)
    )

    ;;; See {@link Peer#addConnectedEventListener(PeerConnectedEventListener)}. ;;
    #_public
    (§ method #_"void" (§ fn addConnectedEventListener) [#_"PeerConnectedEventListener" (§ name listener)])
    (§ block
        (§ expr addConnectedEventListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; new peers are connected to.</p>
     ;;
    #_public
    (§ method #_"void" (§ fn addConnectedEventListener) [#_"Executor" (§ name executor), #_"PeerConnectedEventListener" (§ name listener)])
    (§ block
        (§ expr peerConnectedEventListeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars Preconditions/checkNotNull(§ pars listener), executor))))
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ expr peer.addConnectedEventListener(§ pars executor, listener))
        )
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ expr peer.addConnectedEventListener(§ pars executor, listener))
        )
        (§ void nil)
    )

    ;;; See {@link Peer#addDisconnectedEventListener(PeerDisconnectedEventListener)}. ;;
    #_public
    (§ method #_"void" (§ fn addDisconnectedEventListener) [#_"PeerDisconnectedEventListener" (§ name listener)])
    (§ block
        (§ expr addDisconnectedEventListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when
     ; peers are disconnected from.</p>
     ;;
    #_public
    (§ method #_"void" (§ fn addDisconnectedEventListener) [#_"Executor" (§ name executor), #_"PeerDisconnectedEventListener" (§ name listener)])
    (§ block
        (§ expr peerDisconnectedEventListeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars Preconditions/checkNotNull(§ pars listener), executor))))
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ expr peer.addDisconnectedEventListener(§ pars executor, listener))
        )
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ expr peer.addDisconnectedEventListener(§ pars executor, listener))
        )
        (§ void nil)
    )

    ;;; See {@link Peer#addDiscoveredEventListener(PeerDiscoveredEventListener)}. ;;
    #_public
    (§ method #_"void" (§ fn addDiscoveredEventListener) [#_"PeerDiscoveredEventListener" (§ name listener)])
    (§ block
        (§ expr addDiscoveredEventListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;;
     ; <p>Adds a listener that will be notified on the given executor when new
     ; peers are discovered.</p>
     ;;
    #_public
    (§ method #_"void" (§ fn addDiscoveredEventListener) [#_"Executor" (§ name executor), #_"PeerDiscoveredEventListener" (§ name listener)])
    (§ block
        (§ expr peerDiscoveredEventListeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars Preconditions/checkNotNull(§ pars listener), executor))))
        (§ void nil)
    )

    ;;; See {@link Peer#addGetDataEventListener(GetDataEventListener)}. ;;
    #_public
    (§ method #_"void" (§ fn addGetDataEventListener) [#_"GetDataEventListener" (§ name listener)])
    (§ block
        (§ expr addGetDataEventListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;; See {@link Peer#addGetDataEventListener(Executor, GetDataEventListener)}. ;;
    #_public
    (§ method #_"void" (§ fn addGetDataEventListener) [#_final #_"Executor" (§ name executor), #_final #_"GetDataEventListener" (§ name listener)])
    (§ block
        (§ expr peerGetDataEventListeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars Preconditions/checkNotNull(§ pars listener), executor))))
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ expr peer.addGetDataEventListener(§ pars executor, listener))
        )
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ expr peer.addGetDataEventListener(§ pars executor, listener))
        )
        (§ void nil)
    )

    ;;; See {@link Peer#addOnTransactionBroadcastListener(OnTransactionBroadcastListener)}. ;;
    #_public
    (§ method #_"void" (§ fn addOnTransactionBroadcastListener) [#_"OnTransactionBroadcastListener" (§ name listener)])
    (§ block
        (§ expr addOnTransactionBroadcastListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;; See {@link Peer#addOnTransactionBroadcastListener(OnTransactionBroadcastListener)}. ;;
    #_public
    (§ method #_"void" (§ fn addOnTransactionBroadcastListener) [#_"Executor" (§ name executor), #_"OnTransactionBroadcastListener" (§ name listener)])
    (§ block
        (§ expr peersTransactionBroadastEventListeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars Preconditions/checkNotNull(§ pars listener), executor))))
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ expr peer.addOnTransactionBroadcastListener(§ pars executor, listener))
        )
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ expr peer.addOnTransactionBroadcastListener(§ pars executor, listener))
        )
        (§ void nil)
    )

    ;;; See {@link Peer#addPreMessageReceivedEventListener(PreMessageReceivedEventListener)}. ;;
    #_public
    (§ method #_"void" (§ fn addPreMessageReceivedEventListener) [#_"PreMessageReceivedEventListener" (§ name listener)])
    (§ block
        (§ expr addPreMessageReceivedEventListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;; See {@link Peer#addPreMessageReceivedEventListener(Executor, PreMessageReceivedEventListener)}. ;;
    #_public
    (§ method #_"void" (§ fn addPreMessageReceivedEventListener) [#_"Executor" (§ name executor), #_"PreMessageReceivedEventListener" (§ name listener)])
    (§ block
        (§ expr peersPreMessageReceivedEventListeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars Preconditions/checkNotNull(§ pars listener), executor))))
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ expr peer.addPreMessageReceivedEventListener(§ pars executor, listener))
        )
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ expr peer.addPreMessageReceivedEventListener(§ pars executor, listener))
        )
        (§ void nil)
    )

    #_public
    (§ method #_"boolean" (§ fn removeBlocksDownloadedEventListener) [#_"BlocksDownloadedEventListener" (§ name listener)])
    (§ block
        (§ var #_"boolean" (§ name result) (§ expr ListenerRegistration/removeFromList(§ pars listener, peersBlocksDownloadedEventListeners)))
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ expr peer.removeBlocksDownloadedEventListener(§ pars listener))
        )
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ expr peer.removeBlocksDownloadedEventListener(§ pars listener))
        )
        (§ return result)
    )

    #_public
    (§ method #_"boolean" (§ fn removeChainDownloadStartedEventListener) [#_"ChainDownloadStartedEventListener" (§ name listener)])
    (§ block
        (§ var #_"boolean" (§ name result) (§ expr ListenerRegistration/removeFromList(§ pars listener, peersChainDownloadStartedEventListeners)))
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ expr peer.removeChainDownloadStartedEventListener(§ pars listener))
        )
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ expr peer.removeChainDownloadStartedEventListener(§ pars listener))
        )
        (§ return result)
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (§ method #_"boolean" (§ fn removeConnectedEventListener) [#_"PeerConnectedEventListener" (§ name listener)])
    (§ block
        (§ var #_"boolean" (§ name result) (§ expr ListenerRegistration/removeFromList(§ pars listener, peerConnectedEventListeners)))
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ expr peer.removeConnectedEventListener(§ pars listener))
        )
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ expr peer.removeConnectedEventListener(§ pars listener))
        )
        (§ return result)
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (§ method #_"boolean" (§ fn removeDisconnectedEventListener) [#_"PeerDisconnectedEventListener" (§ name listener)])
    (§ block
        (§ var #_"boolean" (§ name result) (§ expr ListenerRegistration/removeFromList(§ pars listener, peerDisconnectedEventListeners)))
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ expr peer.removeDisconnectedEventListener(§ pars listener))
        )
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ expr peer.removeDisconnectedEventListener(§ pars listener))
        )
        (§ return result)
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (§ method #_"boolean" (§ fn removeDiscoveredEventListener) [#_"PeerDiscoveredEventListener" (§ name listener)])
    (§ block
        (§ var #_"boolean" (§ name result) (§ expr ListenerRegistration/removeFromList(§ pars listener, peerDiscoveredEventListeners)))
        (§ return result)
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (§ method #_"boolean" (§ fn removeGetDataEventListener) [#_"GetDataEventListener" (§ name listener)])
    (§ block
        (§ var #_"boolean" (§ name result) (§ expr ListenerRegistration/removeFromList(§ pars listener, peerGetDataEventListeners)))
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ expr peer.removeGetDataEventListener(§ pars listener))
        )
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ expr peer.removeGetDataEventListener(§ pars listener))
        )
        (§ return result)
    )

    ;;; The given event listener will no longer be called with events. ;;
    #_public
    (§ method #_"boolean" (§ fn removeOnTransactionBroadcastListener) [#_"OnTransactionBroadcastListener" (§ name listener)])
    (§ block
        (§ var #_"boolean" (§ name result) (§ expr ListenerRegistration/removeFromList(§ pars listener, peersTransactionBroadastEventListeners)))
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ expr peer.removeOnTransactionBroadcastListener(§ pars listener))
        )
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ expr peer.removeOnTransactionBroadcastListener(§ pars listener))
        )
        (§ return result)
    )

    #_public
    (§ method #_"boolean" (§ fn removePreMessageReceivedEventListener) [#_"PreMessageReceivedEventListener" (§ name listener)])
    (§ block
        (§ var #_"boolean" (§ name result) (§ expr ListenerRegistration/removeFromList(§ pars listener, peersPreMessageReceivedEventListeners)))
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getConnectedPeers(§ pars )))
        (§ block
            (§ expr peer.removePreMessageReceivedEventListener(§ pars listener))
        )
        (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getPendingPeers(§ pars )))
        (§ block
            (§ expr peer.removePreMessageReceivedEventListener(§ pars listener))
        )
        (§ return result)
    )

    ;;;
     ; Returns a newly allocated list containing the currently connected peers.
     ; If all you care about is the count, use numConnectedPeers().
     ;;
    #_public
    (§ method #_"List<Peer>" (§ fn getConnectedPeers) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ new #_"ArrayList<>" (§ pars peers)))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a list containing Peers that did not complete connection yet.
     ;;
    #_public
    (§ method #_"List<Peer>" (§ fn getPendingPeers) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ new #_"ArrayList<>" (§ pars pendingPeers)))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Add an address to the list of potential peers to connect to.  It won't necessarily be used unless there's a need
     ; to build new connections to reach the max connection count.
     ;
     ; @param peerAddress IP/port to use.
     ;;
    #_public
    (§ method #_"void" (§ fn addAddress) [#_"PeerAddress" (§ name peerAddress)])
    (§ block
        (§ var #_"int" (§ name newMax))
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr addInactive(§ pars peerAddress))
            (§ ass (§ name newMax) (§ expr getMaxConnections(§ pars ) + 1))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ expr setMaxConnections(§ pars newMax))
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn addInactive) [#_"PeerAddress" (§ name peerAddress)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; Deduplicate.
            (§ if (§ expr backoffMap.containsKey(§ pars peerAddress)))
            (§ block
                (§ return nil)
            )
            (§ expr backoffMap.put(§ pars peerAddress, new ExponentialBackoff(§ pars peerBackoffParams)))
            (§ expr inactives.offer(§ pars peerAddress))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Convenience for connecting only to peers that can serve specific services.
     ; It will configure suitable peer discoveries.
     ; @param requiredServices Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     ;;
    #_public
    (§ method #_"void" (§ fn setRequiredServices) [#_"long" (§ name requiredServices)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name this.requiredServices) requiredServices)
            (§ expr peerDiscoverers.clear(§ pars ))
            (§ expr addPeerDiscovery(§ pars MultiplexingDiscovery/forServices(§ pars params, requiredServices)))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;; Convenience method for addAddress(new PeerAddress(address, params.port)). ;;
    #_public
    (§ method #_"void" (§ fn addAddress) [#_"InetAddress" (§ name address)])
    (§ block
        (§ expr addAddress(§ pars (§ new #_"PeerAddress" (§ pars params, address, params.getPort(§ pars )))))
        (§ void nil)
    )

    ;;;
     ; Add addresses from a discovery source to the list of potential peers to connect to.
     ; If max connections has not been configured, or set to zero, then it's set to the default at this point.
     ;;
    #_public
    (§ method #_"void" (§ fn addPeerDiscovery) [#_"PeerDiscovery" (§ name peerDiscovery)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr getMaxConnections(§ pars ) == 0))
            (§ block
                (§ expr setMaxConnections(§ pars DEFAULT_CONNECTIONS))
            )
            (§ expr peerDiscoverers.add(§ pars peerDiscovery))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;; Returns number of discovered peers. ;;
    #_protected
    (§ method #_"int" (§ fn discoverPeers) [])
        (§ throws #_"PeerDiscoveryException")
    (§ block
        ;; Don't hold the lock whilst doing peer discovery: it can take a long time and cause high API latency.
        (§ expr Preconditions/checkState(§ pars (§ not lock.isHeldByCurrentThread(§ pars ))))

        (§ var #_"int" (§ name maxPeersToDiscoverCount) (§ expr this.vMaxPeersToDiscoverCount))
        (§ var #_"long" (§ name peerDiscoveryTimeoutMillis) (§ expr this.vPeerDiscoveryTimeoutMillis))
        #_final
        (§ var #_"Stopwatch" (§ name watch) (§ expr Stopwatch/createStarted(§ pars )))
        #_final
        (§ var #_"List<PeerAddress>" (§ name addressList) (§ expr Lists/newLinkedList(§ pars )))

        (§ for (§ var #_"PeerDiscovery" (§ name peerDiscovery)) :for peerDiscoverers) ;; COW
        (§ block
            (§ var #_"InetSocketAddress[]" (§ name addresses) (§ expr peerDiscovery.getPeers(§ pars requiredServices, peerDiscoveryTimeoutMillis, TimeUnit/MILLISECONDS)))
            (§ for (§ var #_"InetSocketAddress" (§ name address)) :for addresses)
            (§ block
                (§ expr addressList.add(§ pars (§ new #_"PeerAddress" (§ pars params, address))))
            )
            (§ if (§ expr maxPeersToDiscoverCount <= addressList.size(§ pars )))
            (§ block
                (§ break )
            )
        )

        (§ if (§ expr (§ not addressList.isEmpty(§ pars ))))
        (§ block
            (§ for (§ var #_"PeerAddress" (§ name address)) :for addressList)
            (§ block
                (§ expr addInactive(§ pars address))
            )

            #_final
            (§ var #_"ImmutableSet<PeerAddress>" (§ name peersDiscoveredSet) (§ expr ImmutableSet/copyOf(§ pars addressList)))
            (§ for (§ var #_final ListenerRegistration<PeerDiscoveredEventListener> registration) :for peerDiscoveredEventListeners) ;; COW
            (§ block
                (§ expr registration.executor.execute(§ pars (§ new #_"Runnable" (§ pars ))
                (§ anon
                    #_override
                    #_public
                    (§ method #_"void" (§ fn run) [])
                    (§ block
                        (§ expr registration.listener.onPeersDiscovered(§ pars peersDiscoveredSet))
                        (§ void nil)
                    )
                )))
            )
        )
        (§ expr watch.stop(§ pars ))
        (§ expr log.info(§ pars "Peer discovery took {} and returned {} items", watch, addressList.size(§ pars )))
        (§ return (§ expr addressList.size(§ pars )))
    )

    #_testing
    (§ method #_"void" (§ fn waitForJobQueue) [])
    (§ block
        (§ expr Futures/getUnchecked(§ pars executor.submit(§ pars Runnables/doNothing(§ pars ))))
        (§ void nil)
    )

    #_private
    (§ method #_"int" (§ fn countConnectedAndPendingPeers) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr peers.size(§ pars ) + pendingPeers.size(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_private
    (§ enum #_"LocalhostCheckState"
        (§ item NOT_TRIED)
        (§ item FOUND)
        (§ item FOUND_AND_CONNECTED)
        (§ item NOT_THERE)
    )
    #_private
    (§ field #_"LocalhostCheckState" (§ name localhostCheckState) (§ expr LocalhostCheckState/NOT_TRIED))

    #_private
    (§ method #_"boolean" (§ fn maybeCheckForLocalhostPeer) [])
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ if (§ expr localhostCheckState == LocalhostCheckState/NOT_TRIED))
        (§ block
            ;; Do a fast blocking connect to see if anything is listening.
            (§ var #_"Socket" (§ name socket) nil)
            (§ try )
            (§ block
                (§ ass (§ name socket) (§ new #_"Socket" (§ pars )))
                (§ expr socket.connect(§ pars (§ new #_"InetSocketAddress" (§ pars InetAddresses/forString(§ pars "127.0.0.1"), params.getPort(§ pars ))), vConnectTimeoutMillis))
                (§ ass (§ name localhostCheckState) (§ expr LocalhostCheckState/FOUND))
                (§ return true)
            )
            (§ catch #_"IOException" (§ name e))
            (§ block
                (§ expr log.info(§ pars "Localhost peer not detected."))
                (§ ass (§ name localhostCheckState) (§ expr LocalhostCheckState/NOT_THERE))
            )
            (§ finally )
            (§ block
                (§ if (§ expr socket != nil))
                (§ block
                    (§ try )
                    (§ block
                        (§ expr socket.close(§ pars ))
                    )
                    (§ catch #_"IOException" (§ name _))
                    (§ block
                        ;; Ignore.
                    )
                )
            )
        )
        (§ return false)
    )

    ;;;
     ; Starts the PeerGroup and begins network activity.
     ; @return A future that completes when first connection activity has been triggered (note: not first connection made).
     ;;
    #_public
    (§ method #_"ListenableFuture" (§ fn startAsync) [])
    (§ block
        ;; This is run in a background thread by the Service implementation.
        (§ if (§ expr chain == nil))
        (§ block
            ;; Just try to help catch what might be a programming error.
            (§ expr log.warn(§ pars "Starting up with no attached block chain. Did you forget to pass one to the constructor?"))
        )
        (§ expr Preconditions/checkState(§ pars (§ not vUsedUp), "Cannot start a peer group twice"))

        (§ ass (§ name vRunning) true)
        (§ ass (§ name vUsedUp) true)
        (§ expr executorStartupLatch.countDown(§ pars ))

        ;; We do blocking waits during startup, so run on the executor thread.
        (§ return (§ expr executor.submit(§ pars (§ new #_"Runnable" (§ pars ))
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn run) [])
            (§ block
                (§ try )
                (§ block
                    (§ expr log.info(§ pars "Starting ..."))
                    (§ expr channels.startAsync(§ pars ))
                    (§ expr channels.awaitRunning(§ pars ))
                    (§ expr triggerConnections(§ pars ))
                    (§ expr setupPinging(§ pars ))
                )
                (§ catch #_"Throwable" (§ name e))
                (§ block
                    (§ expr log.error(§ pars "Exception when starting up", e)) ;; The executor swallows exceptions :( ;; )
                )
                (§ void nil)
            )
        ))))
    )

    ;;; Does a blocking startup. ;;
    #_public
    (§ method #_"void" (§ fn start) [])
    (§ block
        (§ expr Futures/getUnchecked(§ pars startAsync(§ pars )))
        (§ void nil)
    )

    ;;; Can just use start() for a blocking start here instead of startAsync/awaitRunning: PeerGroup is no longer a Guava service. ;;
    #_deprecated
    #_public
    (§ method #_"void" (§ fn awaitRunning) [])
    (§ block
        (§ expr waitForJobQueue(§ pars ))
        (§ void nil)
    )

    #_public
    (§ method #_"ListenableFuture" (§ fn stopAsync) [])
    (§ block
        (§ expr Preconditions/checkState(§ pars vRunning))
        (§ ass (§ name vRunning) false)
        (§ var #_"ListenableFuture" (§ name future) (§ expr executor.submit(§ pars (§ new #_"Runnable" (§ pars ))
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn run) [])
            (§ block
                (§ try )
                (§ block
                    (§ expr log.info(§ pars "Stopping ..."))
                    ;; Blocking close of all sockets.
                    (§ expr channels.stopAsync(§ pars ))
                    (§ expr channels.awaitTerminated(§ pars ))
                    (§ for (§ var #_"PeerDiscovery" (§ name peerDiscovery)) :for peerDiscoverers)
                    (§ block
                        (§ expr peerDiscovery.shutdown(§ pars ))
                    )
                    (§ ass (§ name vRunning) false)
                    (§ expr log.info(§ pars "Stopped."))
                )
                (§ catch #_"Throwable" (§ name e))
                (§ block
                    (§ expr log.error(§ pars "Exception when shutting down", e)) ;; The executor swallows exceptions :( ;; )
                )
                (§ void nil)
            )
        ))))
        (§ expr executor.shutdown(§ pars ))
        (§ return future)
    )

    ;;; Does a blocking stop. ;;
    #_public
    (§ method #_"void" (§ fn stop) [])
    (§ block
        (§ try )
        (§ block
            (§ expr stopAsync(§ pars ))
            (§ expr log.info(§ pars "Awaiting PeerGroup shutdown ..."))
            (§ expr executor.awaitTermination(§ pars Long/MAX_VALUE, TimeUnit/SECONDS))
        )
        (§ catch #_"InterruptedException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
        (§ void nil)
    )

    ;;; Can just use stop() here instead of stopAsync/awaitTerminated: PeerGroup is no longer a Guava service. ;;
    #_deprecated
    #_public
    (§ method #_"void" (§ fn awaitTerminated) [])
    (§ block
        (§ try )
        (§ block
            (§ expr executor.awaitTermination(§ pars Long/MAX_VALUE, TimeUnit/SECONDS))
        )
        (§ catch #_"InterruptedException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
        (§ void nil)
    )

    ;;;
     ; <p>Link the given wallet to this PeerGroup.  This is used for three purposes:</p>
     ;
     ; <ol>
     ;   <li>So the wallet receives broadcast transactions.</li>
     ;   <li>Announcing pending transactions that didn't get into the chain yet to our peers.</li>
     ;   <li>Set the fast catchup time using {@link PeerGroup#setFastCatchupTimeSecs(long)} to optimize chain download.</li>
     ; </ol>
     ;
     ; <p>Note that this should be done before chain download commences because if you add a wallet with keys earlier
     ; than the current chain head, the relevant parts of the chain won't be redownloaded for you.</p>
     ;
     ; <p>The Wallet will have an event listener registered on it, so to avoid leaks remember to use
     ; {@link PeerGroup#removeWallet(Wallet)} on it if you wish to keep the Wallet but lose the PeerGroup.</p>
     ;;
    #_public
    (§ method #_"void" (§ fn addWallet) [#_"Wallet" (§ name wallet)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr Preconditions/checkNotNull(§ pars wallet))
            (§ expr Preconditions/checkState(§ pars (§ not wallets.contains(§ pars wallet))))
            (§ expr wallets.add(§ pars wallet))
            (§ expr wallet.setTransactionBroadcaster(§ pars this))
            (§ expr wallet.addCoinsReceivedEventListener(§ pars Threading/SAME_THREAD, walletCoinsReceivedEventListener))
            (§ expr wallet.addKeyChainEventListener(§ pars Threading/SAME_THREAD, walletKeyEventListener))
            (§ expr addPeerFilterProvider(§ pars wallet))
            (§ for (§ var #_"Peer" (§ name peer)) :for peers)
            (§ block
                (§ expr peer.addWallet(§ pars wallet))
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; <p>Link the given PeerFilterProvider to this PeerGroup.
     ; DO NOT use this for Wallets, use {@link PeerGroup#addWallet(Wallet)} instead.</p>
     ;
     ; <p>Note that this should be done before chain download commences because if you add a listener with keys earlier
     ; than the current chain head, the relevant parts of the chain won't be redownloaded for you.</p>
     ;
     ; <p>This method invokes {@link PeerGroup#recalculateFastCatchupAndFilter(FilterRecalculateMode)}.
     ; The return value of this method is the <code>ListenableFuture</code> returned by that invocation.</p>
     ;
     ; @return a future that completes once each <code>Peer</code> in this group has had its <code>BloomFilter</code> (re)set.
     ;;
    #_public
    (§ method #_"ListenableFuture<BloomFilter>" (§ fn addPeerFilterProvider) [#_"PeerFilterProvider" (§ name provider)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr Preconditions/checkNotNull(§ pars provider))
            (§ expr Preconditions/checkState(§ pars (§ not peerFilterProviders.contains(§ pars provider))))
            ;; Insert provider at the start.  This avoids various concurrency problems that could occur because we need
            ;; all providers to be in a consistent, unchanging state whilst the filter is built.  Providers can give
            ;; this guarantee by taking a lock in their begin method, but if we add to the end of the list here, it
            ;; means we establish a lock ordering a > b > c if that's the order the providers were added in.  Given that
            ;; the main wallet will usually be first, this establishes an ordering wallet > other-provider, which means
            ;; other-provider can then not call into the wallet itself.  Other providers installed by the API user should
            ;; come first so the expected ordering is preserved.  This can also manifest itself in providers that use
            ;; synchronous RPCs into an actor instead of locking, but the same issue applies.
            (§ expr peerFilterProviders.add(§ pars 0, provider))

            ;; Don't bother downloading block bodies before the oldest keys in all our wallets.  Make sure we recalculate
            ;; if a key is added.  Of course, by then we may have downloaded the chain already.  Ideally adding keys would
            ;; automatically rewind the block chain and redownload the blocks to find transactions relevant to those keys,
            ;; all transparently and in the background.  But we are a long way from that yet.
            (§ var #_"ListenableFuture<BloomFilter>" (§ name future) (§ expr recalculateFastCatchupAndFilter(§ pars FilterRecalculateMode/SEND_IF_CHANGED)))
            (§ expr updateVersionMessageRelayTxesBeforeFilter(§ pars getVersionMessage(§ pars )))
            (§ return future)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Opposite of {@link #addPeerFilterProvider(PeerFilterProvider)}.  Again, don't use this for wallets.  Does not
     ; trigger recalculation of the filter.
     ;;
    #_public
    (§ method #_"void" (§ fn removePeerFilterProvider) [#_"PeerFilterProvider" (§ name provider)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr Preconditions/checkNotNull(§ pars provider))
            (§ expr Preconditions/checkArgument(§ pars peerFilterProviders.remove(§ pars provider)))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Unlinks the given wallet so it no longer receives broadcast transactions or has its transactions announced.
     ;;
    #_public
    (§ method #_"void" (§ fn removeWallet) [#_"Wallet" (§ name wallet)])
    (§ block
        (§ expr wallets.remove(§ pars Preconditions/checkNotNull(§ pars wallet)))
        (§ expr peerFilterProviders.remove(§ pars wallet))
        (§ expr wallet.removeCoinsReceivedEventListener(§ pars walletCoinsReceivedEventListener))
        (§ expr wallet.removeKeyChainEventListener(§ pars walletKeyEventListener))
        (§ expr wallet.setTransactionBroadcaster(§ pars nil))
        (§ for (§ var #_"Peer" (§ name peer)) :for peers)
        (§ block
            (§ expr peer.removeWallet(§ pars wallet))
        )
        (§ void nil)
    )

    #_public
    (§ enum #_"FilterRecalculateMode"
        (§ item SEND_IF_CHANGED)
        (§ item FORCE_SEND_FOR_REFRESH)
        (§ item DONT_SEND)
    )

    #_private
    #_final
    (§ field #_"Map<FilterRecalculateMode, SettableFuture<BloomFilter>>" (§ name inFlightRecalculations) (§ expr Maps/newHashMap(§ pars )))

    ;;;
     ; Recalculates the bloom filter given to peers as well as the timestamp after which full blocks are downloaded
     ; (instead of only headers).  Note that calls made one after another may return the same future, if the request
     ; wasn't processed yet (i.e. calls are deduplicated).
     ;
     ; @param mode In what situations to send the filter to connected peers.
     ; @return A future that completes once the filter has been calculated (note: this does not mean acknowledged by remote peers).
     ;;
    #_public
    (§ method #_"ListenableFuture<BloomFilter>" (§ fn recalculateFastCatchupAndFilter) [#_final #_"FilterRecalculateMode" (§ name mode)])
    (§ block
        #_final
        (§ var #_"SettableFuture<BloomFilter>" (§ name future) (§ expr SettableFuture/create(§ pars )))
        (§ sync inFlightRecalculations)
        (§ block
            (§ if (§ expr inFlightRecalculations.get(§ pars mode) != nil))
            (§ block
                (§ return (§ expr inFlightRecalculations.get(§ pars mode)))
            )

            (§ expr inFlightRecalculations.put(§ pars mode, future))
        )
        (§ var #_"Runnable" (§ name command) (§ new #_"Runnable" (§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn run) [])
            (§ block
                (§ try )
                (§ block
                    (§ expr go(§ pars ))
                )
                (§ catch #_"Throwable" (§ name e))
                (§ block
                    (§ expr log.error(§ pars "Exception when trying to recalculate Bloom filter", e)) ;; The executor swallows exceptions :( ;; )
                )
                (§ void nil)
            )

            #_public
            (§ method #_"void" (§ fn go) [])
            (§ block
                (§ expr Preconditions/checkState(§ pars (§ not lock.isHeldByCurrentThread(§ pars ))))
                ;; Fully verifying mode doesn't use this optimization (it can't as it needs to see all transactions).
                (§ if (§ expr (§ expr chain != nil && chain.shouldVerifyTransactions(§ pars )) || (§ not vBloomFilteringEnabled)))
                (§ block
                    (§ return nil)
                )

                ;; We only ever call bloomFilterMerger.calculate on jobQueue, so we cannot be calculating two filters at once.
                (§ var #_"FilterMerger.Result" (§ name result) (§ expr bloomFilterMerger.calculate(§ pars ImmutableList/copyOf(§ pars peerFilterProviders)))) ;; COW
                (§ var #_"boolean" (§ name send))
                (§ switch mode)
                (§ block
                    (§ case SEND_IF_CHANGED)
                    (§ block
                        (§ ass (§ name send) (§ expr result.changed))
                        (§ break )
                    )
                    (§ case DONT_SEND)
                    (§ block
                        (§ ass (§ name send) false)
                        (§ break )
                    )
                    (§ case FORCE_SEND_FOR_REFRESH)
                    (§ block
                        (§ ass (§ name send) true)
                        (§ break )
                    )
                    (§ default )
                    (§ block
                        (§ throw (§ new #_"UnsupportedOperationException" (§ pars )))
                    )
                )
                (§ if send)
                (§ block
                    (§ for (§ var #_"Peer" (§ name peer)) :for peers) ;; COW
                    (§ block
                        ;; Only query the mempool if this recalculation request is not in order to lower the observed FP
                        ;; rate.  There's no point querying the mempool when doing this because the FP rate can only go
                        ;; down, and we will have seen all the relevant txns before: it's pointless to ask for them again.
                        (§ expr peer.setBloomFilter(§ pars result.filter, mode != FilterRecalculateMode/FORCE_SEND_FOR_REFRESH))
                    )
                    ;; Reset the false positive estimate so that we don't send a flood of filter updates
                    ;; if the estimate temporarily overshoots our threshold.
                    (§ if (§ expr chain != nil))
                    (§ block
                        (§ expr chain.resetFalsePositiveEstimate(§ pars ))
                    )
                )
                ;; Do this last so that bloomFilter is already set when it gets called.
                (§ expr setFastCatchupTimeSecs(§ pars result.earliestKeyTimeSecs))
                (§ sync inFlightRecalculations)
                (§ block
                    (§ expr inFlightRecalculations.put(§ pars mode, nil))
                )
                (§ expr future.set(§ pars result.filter))
                (§ void nil)
            )
        )))
        (§ try )
        (§ block
            (§ expr executor.execute(§ pars command))
        )
        (§ catch #_"RejectedExecutionException" (§ name _))
        (§ block
            ;; Can happen during shutdown.
        )
        (§ return future)
    )

    ;;;
     ; <p>Sets the false positive rate of bloom filters given to peers.  The default is {@link #DEFAULT_BLOOM_FILTER_FP_RATE}.</p>
     ;
     ; <p>Be careful regenerating the bloom filter too often, as it decreases anonymity because remote nodes can
     ; compare transactions against both the new and old filters to significantly decrease the false positive rate.</p>
     ;
     ; <p>See the docs for {@link BloomFilter#BloomFilter(int, double, long, BloomFilter.BloomUpdate)} for a brief
     ; explanation of anonymity when using bloom filters.</p>
     ;;
    #_public
    (§ method #_"void" (§ fn setBloomFilterFalsePositiveRate) [#_"double" (§ name bloomFilterFPRate)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr bloomFilterMerger.setBloomFilterFPRate(§ pars bloomFilterFPRate))
            (§ expr recalculateFastCatchupAndFilter(§ pars FilterRecalculateMode/SEND_IF_CHANGED))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Returns the number of currently connected peers.  To be informed when this count changes, register a
     ; {@link org.bitcoinj.core.listeners.PeerConnectedEventListener}/{@link org.bitcoinj.core.listeners.PeerDisconnectedEventListener}
     ; and use the onPeerConnected/onPeerDisconnected methods.
     ;;
    #_public
    (§ method #_"int" (§ fn numConnectedPeers) [])
    (§ block
        (§ return (§ expr peers.size(§ pars )))
    )

    ;;;
     ; Connect to a peer by creating a channel to the destination address.  This should not be
     ; used normally - let the PeerGroup manage connections through {@link #start()}.
     ;
     ; @param address Destination IP and port.
     ; @return The newly created Peer object or null if the peer could not be connected.
     ;         Use {@link org.bitcoinj.core.Peer#getConnectionOpenFuture()} if you
     ;         want a future which completes when the connection is open.
     ;;
    #_nilable
    #_public
    (§ method #_"Peer" (§ fn connectTo) [#_"InetSocketAddress" (§ name address)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"PeerAddress" (§ name peerAddress) (§ new #_"PeerAddress" (§ pars params, address)))
            (§ expr backoffMap.put(§ pars peerAddress, new ExponentialBackoff(§ pars peerBackoffParams)))
            (§ return (§ expr connectTo(§ pars peerAddress, true, vConnectTimeoutMillis)))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Helper for forcing a connection to localhost.  Useful when using test mode.  Returns the peer object.
     ;;
    #_nilable
    #_public
    (§ method #_"Peer" (§ fn connectToLocalHost) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            #_final
            (§ var #_"PeerAddress" (§ name localhost) (§ expr PeerAddress/localhost(§ pars params)))
            (§ expr backoffMap.put(§ pars localhost, new ExponentialBackoff(§ pars peerBackoffParams)))
            (§ return (§ expr connectTo(§ pars localhost, true, vConnectTimeoutMillis)))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Creates a version message to send, constructs a Peer object and attempts to connect it.
     ; Returns the peer on success or null on failure.
     ; @param address Remote network address.
     ; @param incrementMaxConnections Whether to consider this connection an attempt to fill our quota, or something explicitly requested.
     ; @return Peer or null.
     ;;
    #_nilable
    #_guarded-by(§ opt "lock")
    #_protected
    (§ method #_"Peer" (§ fn connectTo) [#_"PeerAddress" (§ name address), #_"boolean" (§ name incrementMaxConnections), #_"int" (§ name connectTimeoutMillis)])
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ var #_"VersionMessage" (§ name ver) (§ expr getVersionMessage(§ pars ).duplicate(§ pars )))
        (§ ass (§ name ver.bestHeight) (§ quest (§ expr chain != nil) ? (§ expr chain.getBestChainHeight(§ pars )) :else 0))
        (§ ass (§ name ver.time) (§ expr Utils/currentTimeSeconds(§ pars )))

        (§ var #_"Peer" (§ name peer) (§ expr createPeer(§ pars address, ver)))
        (§ expr peer.addConnectedEventListener(§ pars Threading/SAME_THREAD, startupListener))
        (§ expr peer.addDisconnectedEventListener(§ pars Threading/SAME_THREAD, startupListener))
        (§ expr peer.setMinProtocolVersion(§ pars vMinRequiredProtocolVersion))
        (§ expr pendingPeers.add(§ pars peer))

        (§ try )
        (§ block
            (§ expr log.info(§ pars "Attempting connection to {}     ({} connected, {} pending, {} max)", address, peers.size(§ pars ), pendingPeers.size(§ pars ), maxConnections))
            (§ var #_"ListenableFuture<SocketAddress>" (§ name future) (§ expr channels.openConnection(§ pars address.toSocketAddress(§ pars ), peer)))
            (§ if (§ expr future.isDone(§ pars )))
            (§ block
                (§ expr Uninterruptibles/getUninterruptibly(§ pars future))
            )
        )
        (§ catch #_"ExecutionException" (§ name e))
        (§ block
            (§ var #_"Throwable" (§ name cause) (§ expr Throwables/getRootCause(§ pars e)))
            (§ expr log.warn(§ pars "Failed to connect to " + address + ": " + cause.getMessage(§ pars )))
            (§ expr handlePeerDeath(§ pars peer, cause))
            (§ return nil)
        )
        (§ expr peer.setSocketTimeout(§ pars connectTimeoutMillis))
        ;; When the channel has connected and version negotiated successfully, handleNewPeer will end up being called
        ;; on a worker thread.
        (§ if incrementMaxConnections)
        (§ block
            ;; We don't use setMaxConnections here as that would trigger a recursive attempt to establish a new
            ;; outbound connection.
            (§ ass (§ name maxConnections) (§ expr maxConnections + 1))
        )
        (§ return peer)
    )

    ;;; You can override this to customise the creation of {@link Peer} objects. ;;
    #_guarded-by(§ opt "lock")
    #_protected
    (§ method #_"Peer" (§ fn createPeer) [#_"PeerAddress" (§ name address), #_"VersionMessage" (§ name ver)])
    (§ block
        (§ return (§ new #_"Peer" (§ pars params, ver, address, chain, downloadTxDependencyDepth)))
    )

    ;;;
     ; Sets the timeout between when a connection attempt to a peer begins and when the version message exchange completes.
     ; This does not apply to currently pending peers.
     ;;
    #_public
    (§ method #_"void" (§ fn setConnectTimeoutMillis) [#_"int" (§ name connectTimeoutMillis)])
    (§ block
        (§ ass (§ name this.vConnectTimeoutMillis) connectTimeoutMillis)
        (§ void nil)
    )

    ;;;
     ; <p>Start downloading the blockchain from the first available peer.</p>
     ;
     ; <p>If no peers are currently connected, the download will be started once a peer starts.  If the peer dies,
     ; the download will resume with another peer.</p>
     ;
     ; @param listener A listener for chain download events, may not be null.
     ;;
    #_public
    (§ method #_"void" (§ fn startBlockChainDownload) [#_"PeerDataEventListener" (§ name listener)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr downloadPeer != nil))
            (§ block
                (§ if (§ expr this.downloadListener != nil))
                (§ block
                    (§ expr removeDataEventListenerFromPeer(§ pars downloadPeer, this.downloadListener))
                )
                (§ if (§ expr listener != nil))
                (§ block
                    (§ expr addDataEventListenerToPeer(§ pars Threading/USER_THREAD, downloadPeer, listener))
                )
            )
            (§ ass (§ name this.downloadListener) listener)
            ;; TODO: Be more nuanced about which peer to download from.  We can also try
            ;; downloading from multiple peers and handle the case when a new peer comes along
            ;; with a longer chain after we thought we were done.
            (§ if (§ expr (§ not peers.isEmpty(§ pars ))))
            (§ block
                (§ expr startBlockChainDownloadFromPeer(§ pars peers.iterator(§ pars ).next(§ pars ))) ;; Will add the new download listener.
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Register a data event listener against a single peer (i.e. for blockchain download).
     ; Handling registration/deregistration on peer death/add is outside the scope of these methods.
     ;;
    #_private
    #_static
    (§ method #_"void" (§ fn addDataEventListenerToPeer) [#_"Executor" (§ name executor), #_"Peer" (§ name peer), #_"PeerDataEventListener" (§ name downloadListener)])
    (§ block
        (§ expr peer.addBlocksDownloadedEventListener(§ pars executor, downloadListener))
        (§ expr peer.addChainDownloadStartedEventListener(§ pars executor, downloadListener))
        (§ expr peer.addGetDataEventListener(§ pars executor, downloadListener))
        (§ expr peer.addPreMessageReceivedEventListener(§ pars executor, downloadListener))
        (§ void nil)
    )

    ;;;
     ; Remove a registered data event listener against a single peer (i.e. for blockchain download).
     ; Handling registration/deregistration on peer death/add is outside the scope of these methods.
     ;;
    #_private
    #_static
    (§ method #_"void" (§ fn removeDataEventListenerFromPeer) [#_"Peer" (§ name peer), #_"PeerDataEventListener" (§ name listener)])
    (§ block
        (§ expr peer.removeBlocksDownloadedEventListener(§ pars listener))
        (§ expr peer.removeChainDownloadStartedEventListener(§ pars listener))
        (§ expr peer.removeGetDataEventListener(§ pars listener))
        (§ expr peer.removePreMessageReceivedEventListener(§ pars listener))
        (§ void nil)
    )

    ;;;
     ; Download the blockchain from peers.  Convenience that uses a {@link DownloadProgressTracker} for you.
     ;
     ; This method waits until the download is complete.  "Complete" is defined as downloading
     ; from at least one peer all the blocks that are in that peer's inventory.
     ;;
    #_public
    (§ method #_"void" (§ fn downloadBlockChain) [])
    (§ block
        (§ var #_"DownloadProgressTracker" (§ name listener) (§ new #_"DownloadProgressTracker" (§ pars )))
        (§ expr startBlockChainDownload(§ pars listener))
        (§ try )
        (§ block
            (§ expr listener.await(§ pars ))
        )
        (§ catch #_"InterruptedException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
        (§ void nil)
    )

    #_protected
    (§ method #_"void" (§ fn handleNewPeer) [#_final #_"Peer" (§ name peer)])
    (§ block
        (§ var #_"int" (§ name newSize) -1)
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr groupBackoff.trackSuccess(§ pars ))
            (§ expr backoffMap.get(§ pars peer.getAddress(§ pars )).trackSuccess(§ pars ))

            ;; Sets up the newly connected peer so it can do everything it needs to.
            (§ expr pendingPeers.remove(§ pars peer))
            (§ expr peers.add(§ pars peer))
            (§ ass (§ name newSize) (§ expr peers.size(§ pars )))
            (§ expr log.info(§ pars "{}: New peer      ({} connected, {} pending, {} max)", peer, newSize, pendingPeers.size(§ pars ), maxConnections))
            ;; Give the peer a filter that can be used to probabilistically drop transactions that
            ;; aren't relevant to our wallet.  We may still receive some false positives, which is
            ;; OK because it helps improve wallet privacy.  Old nodes will just ignore the message.
            (§ if (§ expr bloomFilterMerger.getLastFilter(§ pars ) != nil))
            (§ block
                (§ expr peer.setBloomFilter(§ pars bloomFilterMerger.getLastFilter(§ pars )))
            )
            (§ expr peer.setDownloadData(§ pars false))
            ;; TODO: The peer should calculate the fast catchup time from the added wallets here.
            (§ for (§ var #_"Wallet" (§ name wallet)) :for wallets)
            (§ block
                (§ expr peer.addWallet(§ pars wallet))
            )
            (§ if (§ expr downloadPeer == nil))
            (§ block
                ;; Kick off chain download if we aren't already doing it.
                (§ expr setDownloadPeer(§ pars selectDownloadPeer(§ pars peers)))
                (§ var #_"boolean" (§ name shouldDownloadChain) (§ expr downloadListener != nil && chain != nil))
                (§ if shouldDownloadChain)
                (§ block
                    (§ expr startBlockChainDownloadFromPeer(§ pars downloadPeer))
                )
            )
            ;; Make sure the peer knows how to upload transactions that are requested from us.
            (§ expr peer.addBlocksDownloadedEventListener(§ pars Threading/SAME_THREAD, peerListener))
            (§ expr peer.addGetDataEventListener(§ pars Threading/SAME_THREAD, peerListener))

            ;; And set up event listeners for clients.  This will allow them to find out about new transactions and blocks.
            (§ for (§ var #_"ListenerRegistration<BlocksDownloadedEventListener>" (§ name registration)) :for peersBlocksDownloadedEventListeners)
            (§ block
                (§ expr peer.addBlocksDownloadedEventListener(§ pars registration.executor, registration.listener))
            )
            (§ for (§ var #_"ListenerRegistration<ChainDownloadStartedEventListener>" (§ name registration)) :for peersChainDownloadStartedEventListeners)
            (§ block
                (§ expr peer.addChainDownloadStartedEventListener(§ pars registration.executor, registration.listener))
            )
            (§ for (§ var #_"ListenerRegistration<PeerConnectedEventListener>" (§ name registration)) :for peerConnectedEventListeners)
            (§ block
                (§ expr peer.addConnectedEventListener(§ pars registration.executor, registration.listener))
            )

            ;; We intentionally do not add disconnect listeners to peers.
            (§ for (§ var #_"ListenerRegistration<GetDataEventListener>" (§ name registration)) :for peerGetDataEventListeners)
            (§ block
                (§ expr peer.addGetDataEventListener(§ pars registration.executor, registration.listener))
            )
            (§ for (§ var #_"ListenerRegistration<OnTransactionBroadcastListener>" (§ name registration)) :for peersTransactionBroadastEventListeners)
            (§ block
                (§ expr peer.addOnTransactionBroadcastListener(§ pars registration.executor, registration.listener))
            )
            (§ for (§ var #_"ListenerRegistration<PreMessageReceivedEventListener>" (§ name registration)) :for peersPreMessageReceivedEventListeners)
            (§ block
                (§ expr peer.addPreMessageReceivedEventListener(§ pars registration.executor, registration.listener))
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )

        #_final
        (§ var #_"int" (§ name fNewSize) newSize)
        (§ for (§ var #_final ListenerRegistration<PeerConnectedEventListener> registration) :for peerConnectedEventListeners)
        (§ block
            (§ expr registration.executor.execute(§ pars (§ new #_"Runnable" (§ pars ))
            (§ anon
                #_override
                #_public
                (§ method #_"void" (§ fn run) [])
                (§ block
                    (§ expr registration.listener.onPeerConnected(§ pars peer, fNewSize))
                    (§ void nil)
                )
            )))
        )
        (§ void nil)
    )

    #_nilable
    #_private
    #_volatile
    (§ field #_"ListenableScheduledFuture<?>" (§ name vPingTask))

    #_suppress(§ opt "NonAtomicOperationOnVolatileField")
    #_private
    (§ method #_"void" (§ fn setupPinging) [])
    (§ block
        (§ if (§ expr getPingIntervalMsec(§ pars ) <= 0))
        (§ block
            (§ return nil) ;; Disabled.
        )

        (§ ass (§ name vPingTask) (§ expr executor.scheduleAtFixedRate(§ pars (§ new #_"Runnable" (§ pars ))
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn run) [])
            (§ block
                (§ try )
                (§ block
                    (§ if (§ expr getPingIntervalMsec(§ pars ) <= 0))
                    (§ block
                        (§ var #_"ListenableScheduledFuture<?>" (§ name task) vPingTask)
                        (§ if (§ expr task != nil))
                        (§ block
                            (§ expr task.cancel(§ pars false))
                            (§ ass (§ name vPingTask) nil)
                        )
                        (§ return nil) ;; Disabled.
                    )
                    (§ for (§ var #_"Peer" (§ name peer)) :for (§ expr getConnectedPeers(§ pars )))
                    (§ block
                        (§ if (§ expr peer.getPeerVersionMessage(§ pars ).clientVersion < params.getProtocolVersionNum(§ pars NetworkParameters/ProtocolVersion/PONG)))
                        (§ block
                            (§ continue )
                        )
                        (§ expr peer.ping(§ pars ))
                    )
                )
                (§ catch #_"Throwable" (§ name e))
                (§ block
                    (§ expr log.error(§ pars "Exception in ping loop", e)) ;; The executor swallows exceptions :( ;; )
                )
                (§ void nil)
            )
        ), getPingIntervalMsec(§ pars ), getPingIntervalMsec(§ pars ), TimeUnit/MILLISECONDS)))
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn setDownloadPeer) [#_nilable #_"Peer" (§ name peer)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr downloadPeer == peer))
            (§ block
                (§ return nil)
            )
            (§ if (§ expr downloadPeer != nil))
            (§ block
                (§ expr log.info(§ pars "Unsetting download peer: {}", downloadPeer))
                (§ if (§ expr downloadListener != nil))
                (§ block
                    (§ expr removeDataEventListenerFromPeer(§ pars downloadPeer, downloadListener))
                )
                (§ expr downloadPeer.setDownloadData(§ pars false))
            )
            (§ ass (§ name downloadPeer) peer)
            (§ if (§ expr downloadPeer != nil))
            (§ block
                (§ expr log.info(§ pars "Setting download peer: {}", downloadPeer))
                (§ if (§ expr downloadListener != nil))
                (§ block
                    (§ expr addDataEventListenerToPeer(§ pars Threading/SAME_THREAD, peer, downloadListener))
                )
                (§ expr downloadPeer.setDownloadData(§ pars true))
                (§ if (§ expr chain != nil))
                (§ block
                    (§ expr downloadPeer.setDownloadParameters(§ pars fastCatchupTimeSecs, bloomFilterMerger.getLastFilter(§ pars ) != nil))
                )
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Tells the PeerGroup to download only block headers before a certain time and bodies after that.
     ; Call this before starting block chain download.
     ; Do not use a time > NOW - 1 block, as it will break some block download logic.
     ;;
    #_public
    (§ method #_"void" (§ fn setFastCatchupTimeSecs) [#_"long" (§ name secondsSinceEpoch)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr Preconditions/checkState(§ pars chain == nil || (§ not chain.shouldVerifyTransactions(§ pars )), "Fast catchup is incompatible with fully verifying"))

            (§ ass (§ name fastCatchupTimeSecs) secondsSinceEpoch)
            (§ if (§ expr downloadPeer != nil))
            (§ block
                (§ expr downloadPeer.setDownloadParameters(§ pars secondsSinceEpoch, bloomFilterMerger.getLastFilter(§ pars ) != nil))
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Returns the current fast catchup time.  The contents of blocks before this time won't be downloaded as they
     ; cannot contain any interesting transactions.  If you use {@link PeerGroup#addWallet(Wallet)} this just returns
     ; the min of the wallets earliest key times.
     ; @return a time in seconds since the epoch.
     ;;
    #_public
    (§ method #_"long" (§ fn getFastCatchupTimeSecs) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return fastCatchupTimeSecs)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_protected
    (§ method #_"void" (§ fn handlePeerDeath) [#_final #_"Peer" (§ name peer), #_nilable #_"Throwable" (§ name exception)])
    (§ block
        ;; Peer deaths can occur during startup if a connect attempt after peer discovery aborts immediately.
        (§ if (§ expr (§ not isRunning(§ pars ))))
        (§ block
            (§ return nil)
        )

        (§ var #_"int" (§ name numPeers))
        (§ var #_"int" (§ name numConnectedPeers) 0)
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr pendingPeers.remove(§ pars peer))
            (§ expr peers.remove(§ pars peer))

            (§ var #_"PeerAddress" (§ name address) (§ expr peer.getAddress(§ pars )))

            (§ expr log.info(§ pars "{}: Peer died      ({} connected, {} pending, {} max)", address, peers.size(§ pars ), pendingPeers.size(§ pars ), maxConnections))
            (§ if (§ expr peer == downloadPeer))
            (§ block
                (§ expr log.info(§ pars "Download peer died. Picking a new one."))
                (§ expr setDownloadPeer(§ pars nil))
                ;; Pick a new one and possibly tell it to download the chain.
                #_final
                (§ var #_"Peer" (§ name newDownloadPeer) (§ expr selectDownloadPeer(§ pars peers)))
                (§ if (§ expr newDownloadPeer != nil))
                (§ block
                    (§ expr setDownloadPeer(§ pars newDownloadPeer))
                    (§ if (§ expr downloadListener != nil))
                    (§ block
                        (§ expr startBlockChainDownloadFromPeer(§ pars newDownloadPeer))
                    )
                )
            )
            (§ ass (§ name numPeers) (§ expr peers.size(§ pars ) + pendingPeers.size(§ pars )))
            (§ ass (§ name numConnectedPeers) (§ expr peers.size(§ pars )))

            (§ expr groupBackoff.trackFailure(§ pars ))

            (§ if (§ insta exception #_"NoRouteToHostException"))
            (§ block
                (§ if (§ expr (§ insta (§ dot address.getAddr(§ pars )) #_"Inet6Address") && (§ not ipv6Unreachable)))
                (§ block
                    (§ ass (§ name ipv6Unreachable) true)
                    (§ expr log.warn(§ pars "IPv6 peer connect failed due to routing failure, ignoring IPv6 addresses from now on"))
                )
            )
            (§ else )
            (§ block
                (§ expr backoffMap.get(§ pars address).trackFailure(§ pars ))
                ;; Put back on inactive list.
                (§ expr inactives.offer(§ pars address))
            )

            (§ if (§ expr numPeers < getMaxConnections(§ pars )))
            (§ block
                (§ expr triggerConnections(§ pars ))
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )

        (§ expr peer.removeBlocksDownloadedEventListener(§ pars peerListener))
        (§ expr peer.removeGetDataEventListener(§ pars peerListener))
        (§ for (§ var #_"Wallet" (§ name wallet)) :for wallets)
        (§ block
            (§ expr peer.removeWallet(§ pars wallet))
        )

        #_final
        (§ var #_"int" (§ name fNumConnectedPeers) numConnectedPeers)

        (§ for (§ var #_"ListenerRegistration<BlocksDownloadedEventListener>" (§ name registration)) :for peersBlocksDownloadedEventListeners)
        (§ block
            (§ expr peer.removeBlocksDownloadedEventListener(§ pars registration.listener))
        )
        (§ for (§ var #_"ListenerRegistration<ChainDownloadStartedEventListener>" (§ name registration)) :for peersChainDownloadStartedEventListeners)
        (§ block
            (§ expr peer.removeChainDownloadStartedEventListener(§ pars registration.listener))
        )
        (§ for (§ var #_"ListenerRegistration<GetDataEventListener>" (§ name registration)) :for peerGetDataEventListeners)
        (§ block
            (§ expr peer.removeGetDataEventListener(§ pars registration.listener))
        )
        (§ for (§ var #_"ListenerRegistration<PreMessageReceivedEventListener>" (§ name registration)) :for peersPreMessageReceivedEventListeners)
        (§ block
            (§ expr peer.removePreMessageReceivedEventListener(§ pars registration.listener))
        )
        (§ for (§ var #_"ListenerRegistration<OnTransactionBroadcastListener>" (§ name registration)) :for peersTransactionBroadastEventListeners)
        (§ block
            (§ expr peer.removeOnTransactionBroadcastListener(§ pars registration.listener))
        )

        (§ for (§ var #_final ListenerRegistration<PeerDisconnectedEventListener> registration) :for peerDisconnectedEventListeners)
        (§ block
            (§ expr registration.executor.execute(§ pars (§ new #_"Runnable" (§ pars ))
            (§ anon
                #_override
                #_public
                (§ method #_"void" (§ fn run) [])
                (§ block
                    (§ expr registration.listener.onPeerDisconnected(§ pars peer, fNumConnectedPeers))
                    (§ void nil)
                )
            )))
            (§ expr peer.removeDisconnectedEventListener(§ pars registration.listener))
        )
        (§ void nil)
    )

    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"int" (§ name stallPeriodSeconds) 10)
    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"int" (§ name stallMinSpeedBytesSec) (§ expr Block/HEADER_SIZE * 20))

    ;;;
     ; Configures the stall speed: the speed at which a peer is considered to be serving us the block chain
     ; unacceptably slowly.  Once a peer has served us data slower than the given data rate for the given
     ; number of seconds, it is considered stalled and will be disconnected, forcing the chain download to continue
     ; from a different peer.  The defaults are chosen conservatively, but if you are running on a platform that is
     ; CPU constrained or on a very slow network e.g. EDGE, the default settings may need adjustment to
     ; avoid false stalls.
     ;
     ; @param periodSecs How many seconds the download speed must be below blocksPerSec, defaults to 10.
     ; @param bytesPerSecond Download speed (only blocks/txns count) must be consistently below this for a stall, defaults to the bandwidth required for 20 block headers per second.
     ;;
    #_public
    (§ method #_"void" (§ fn setStallThreshold) [#_"int" (§ name periodSecs), #_"int" (§ name bytesPerSecond)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name stallPeriodSeconds) periodSecs)
            (§ ass (§ name stallMinSpeedBytesSec) bytesPerSecond)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    #_private
    (§ class #_"ChainDownloadSpeedCalculator" (§ implements #_"BlocksDownloadedEventListener", #_"Runnable")
        #_private
        (§ field #_"int" (§ name blocksInLastSecond))
        #_private
        (§ field #_"int" (§ name txnsInLastSecond))
        #_private
        (§ field #_"int" (§ name origTxnsInLastSecond))
        #_private
        (§ field #_"long" (§ name bytesInLastSecond))

        ;; If we take more stalls than this, we assume we're on some kind of terminally slow network and the
        ;; stall threshold just isn't set properly.  We give up on stall disconnects after that.
        #_private
        (§ field #_"int" (§ name maxStalls) 3)

        ;; How many seconds the peer has until we start measuring its speed.
        #_private
        (§ field #_"int" (§ name warmupSeconds) -1)

        ;; Used to calculate a moving average.
        #_private
        (§ field #_"long[]" (§ name samples))
        #_private
        (§ field #_"int" (§ name cursor))

        #_private
        (§ field #_"boolean" (§ name syncDone))

        #_override
        #_public
        #_synchronized
        (§ method #_"void" (§ fn onBlocksDownloaded) [#_"Peer" (§ name peer), #_"Block" (§ name block), #_nilable #_"FilteredBlock" (§ name filteredBlock), #_"int" (§ name blocksLeft)])
        (§ block
            (§ ass (§ name blocksInLastSecond) (§ expr blocksInLastSecond + 1))
            (§ ass (§ name bytesInLastSecond) (§ expr bytesInLastSecond + Block/HEADER_SIZE))
            (§ var #_"List<Transaction>" (§ name blockTransactions) (§ expr block.getTransactions(§ pars )))
            ;; This whole area of the type hierarchy is a mess.
            (§ var #_"int" (§ name txCount) (§ expr (§ quest (§ expr blockTransactions != nil) ? (§ expr countAndMeasureSize(§ pars blockTransactions)) :else 0) + (§ quest (§ expr filteredBlock != nil) ? (§ expr countAndMeasureSize(§ pars filteredBlock.getAssociatedTransactions(§ pars ).values(§ pars ))) :else 0)))
            (§ ass (§ name txnsInLastSecond) (§ expr txnsInLastSecond + txCount))
            (§ if (§ expr filteredBlock != nil))
            (§ block
                (§ ass (§ name origTxnsInLastSecond) (§ expr origTxnsInLastSecond + filteredBlock.getTransactionCount(§ pars )))
            )
            (§ void nil)
        )

        #_private
        (§ method #_"int" (§ fn countAndMeasureSize) [#_"Collection<Transaction>" (§ name transactions)])
        (§ block
            (§ for (§ var #_"Transaction" (§ name transaction)) :for transactions)
            (§ block
                (§ ass (§ name bytesInLastSecond) (§ expr bytesInLastSecond + transaction.getMessageSize(§ pars )))
            )
            (§ return (§ expr transactions.size(§ pars )))
        )

        #_override
        #_public
        (§ method #_"void" (§ fn run) [])
        (§ block
            (§ try )
            (§ block
                (§ expr calculate(§ pars ))
            )
            (§ catch #_"Throwable" (§ name e))
            (§ block
                (§ expr log.error(§ pars "Error in speed calculator", e))
            )
            (§ void nil)
        )

        #_private
        (§ method #_"void" (§ fn calculate) [])
        (§ block
            (§ var #_"int" (§ name minSpeedBytesPerSec))
            (§ var #_"int" (§ name period))

            (§ expr lock.lock(§ pars ))
            (§ try )
            (§ block
                (§ ass (§ name minSpeedBytesPerSec) stallMinSpeedBytesSec)
                (§ ass (§ name period) stallPeriodSeconds)
            )
            (§ finally )
            (§ block
                (§ expr lock.unlock(§ pars ))
            )

            (§ sync this)
            (§ block
                (§ if (§ expr samples == nil || samples.length != period))
                (§ block
                    (§ ass (§ name samples) (§ new #_"long[]" (§ count period)))
                    ;; *2 because otherwise a single low sample could cause an immediate disconnect which is too harsh.
                    (§ expr Arrays/fill(§ pars samples, minSpeedBytesPerSec * 2))
                    (§ ass (§ name warmupSeconds) 15)
                )

                (§ var #_"boolean" (§ name behindPeers) (§ expr chain != nil && chain.getBestChainHeight(§ pars ) < getMostCommonChainHeight(§ pars )))
                (§ if (§ expr (§ not behindPeers)))
                (§ block
                    (§ ass (§ name syncDone) true)
                )
                (§ if (§ expr (§ not syncDone)))
                (§ block
                    (§ if (§ expr warmupSeconds < 0))
                    (§ block
                        ;; Calculate the moving average.
                        (§ ass (§ name samples[cursor]) bytesInLastSecond)
                        (§ ass (§ name cursor) (§ expr cursor + 1))
                        (§ if (§ expr cursor == samples.length))
                        (§ block
                            (§ ass (§ name cursor) 0)
                        )
                        (§ var #_"long" (§ name average) 0)
                        (§ for (§ var #_"long" (§ name sample)) :for samples)
                        (§ block
                            (§ ass (§ name average) (§ expr average + sample))
                        )
                        (§ ass (§ name average) (§ expr average / samples.length))

                        (§ expr log.info(§ pars String/format(§ pars Locale/US, "%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, avg/last %.2f/%.2f kilobytes per sec (stall threshold <%.2f KB/sec for %d seconds)", blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond, average / 1024.0, bytesInLastSecond / 1024.0, minSpeedBytesPerSec / 1024.0, samples.length)))

                        (§ if (§ expr average < minSpeedBytesPerSec && 0 < maxStalls))
                        (§ block
                            (§ ass (§ name maxStalls) (§ expr maxStalls - 1))
                            (§ if (§ expr maxStalls == 0))
                            (§ block
                                ;; We could consider starting to drop the Bloom filtering FP rate at this point, because
                                ;; we tried a bunch of peers and no matter what we don't seem to be able to go any faster.
                                ;; This implies we're bandwidth bottlenecked and might want to start using bandwidth
                                ;; more effectively.  Of course if there's a MITM that is deliberately throttling us,
                                ;; this is a good way to make us take away all the FPs from our Bloom filters ... but
                                ;; as they don't give us a whole lot of privacy either way that's not inherently a big
                                ;; deal.
                                (§ expr log.warn(§ pars "This network seems to be slower than the requested stall threshold - won't do stall disconnects any more."))
                            )
                            (§ else )
                            (§ block
                                (§ var #_"Peer" (§ name peer) (§ expr getDownloadPeer(§ pars )))
                                (§ expr log.warn(§ pars String/format(§ pars Locale/US, "Chain download stalled: received %.2f KB/sec for %d seconds, require average of %.2f KB/sec, disconnecting %s", average / 1024.0, samples.length, minSpeedBytesPerSec / 1024.0, peer)))
                                (§ expr peer.close(§ pars ))
                                ;; Reset the sample buffer and give the next peer time to get going.
                                (§ ass (§ name samples) nil)
                                (§ ass (§ name warmupSeconds) period)
                            )
                        )
                    )
                    (§ else )
                    (§ block
                        (§ ass (§ name warmupSeconds) (§ expr warmupSeconds - 1))
                        (§ if (§ expr 0 < bytesInLastSecond))
                        (§ block
                            (§ expr log.info(§ pars String/format(§ pars Locale/US, "%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, last %.2f kilobytes per sec", blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond, bytesInLastSecond / 1024.0)))
                        )
                    )
                )
                (§ ass (§ name blocksInLastSecond) 0)
                (§ ass (§ name txnsInLastSecond) 0)
                (§ ass (§ name origTxnsInLastSecond) 0)
                (§ ass (§ name bytesInLastSecond) 0)
            )
            (§ void nil)
        )
    )
    #_nilable
    #_private
    (§ field #_"ChainDownloadSpeedCalculator" (§ name chainDownloadSpeedCalculator))

    #_private
    (§ method #_"void" (§ fn startBlockChainDownloadFromPeer) [#_"Peer" (§ name peer)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr setDownloadPeer(§ pars peer))

            (§ if (§ expr chainDownloadSpeedCalculator == nil))
            (§ block
                ;; Every second, run the calculator which will log how fast we are downloading the chain.
                (§ ass (§ name chainDownloadSpeedCalculator) (§ new #_"ChainDownloadSpeedCalculator" (§ pars )))
                (§ expr executor.scheduleAtFixedRate(§ pars chainDownloadSpeedCalculator, 1, 1, TimeUnit/SECONDS))
            )
            (§ expr peer.addBlocksDownloadedEventListener(§ pars Threading/SAME_THREAD, chainDownloadSpeedCalculator))

            ;; startBlockChainDownload will setDownloadData(true) on itself automatically.
            (§ expr peer.startBlockChainDownload(§ pars ))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Returns a future that is triggered when the number of connected peers is equal to the given number of peers.
     ; By using this with {@link org.bitcoinj.core.PeerGroup#getMaxConnections()} you can wait until the
     ; network is fully online.  To block immediately, just call get() on the result.  Just calls
     ; {@link #waitForPeersOfVersion(int, long)} with zero as the protocol version.
     ;
     ; @param numPeers How many peers to wait for.
     ; @return a future that will be triggered when the number of connected peers >= numPeers.
     ;;
    #_public
    (§ method #_"ListenableFuture<List<Peer>>" (§ fn waitForPeers) [#_final #_"int" (§ name numPeers)])
    (§ block
        (§ return (§ expr waitForPeersOfVersion(§ pars numPeers, 0)))
    )

    ;;;
     ; Returns a future that is triggered when there are at least the requested number of connected peers that support
     ; the given protocol version or higher.  To block immediately, just call get() on the result.
     ;
     ; @param numPeers How many peers to wait for.
     ; @param protocolVersion The protocol version the awaited peers must implement (or better).
     ; @return a future that will be triggered when the number of connected peers implementing protocolVersion or higher >= numPeers.
     ;;
    #_public
    (§ method #_"ListenableFuture<List<Peer>>" (§ fn waitForPeersOfVersion) [#_final #_"int" (§ name numPeers), #_final #_"long" (§ name protocolVersion)])
    (§ block
        (§ var #_"List<Peer>" (§ name foundPeers) (§ expr findPeersOfAtLeastVersion(§ pars protocolVersion)))
        (§ if (§ expr numPeers <= foundPeers.size(§ pars )))
        (§ block
            (§ return (§ expr Futures/immediateFuture(§ pars foundPeers)))
        )

        #_final
        (§ var #_"SettableFuture<List<Peer>>" (§ name future) (§ expr SettableFuture/create(§ pars )))
        (§ expr addConnectedEventListener(§ pars (§ new #_"PeerConnectedEventListener" (§ pars ))
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn onPeerConnected) [#_"Peer" (§ name peer), #_"int" (§ name peerCount)])
            (§ block
                #_final
                (§ var #_"List<Peer>" (§ name peers) (§ expr findPeersOfAtLeastVersion(§ pars protocolVersion)))
                (§ if (§ expr numPeers <= peers.size(§ pars )))
                (§ block
                    (§ expr future.set(§ pars peers))
                    (§ expr removeConnectedEventListener(§ pars this))
                )
                (§ void nil)
            )
        )))
        (§ return future)
    )

    ;;;
     ; Returns an array list of peers that implement the given protocol version or better.
     ;;
    #_public
    (§ method #_"List<Peer>" (§ fn findPeersOfAtLeastVersion) [#_"long" (§ name protocolVersion)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"ArrayList<Peer>" (§ name results) (§ new #_"ArrayList<Peer>" (§ pars peers.size(§ pars ))))
            (§ for (§ var #_"Peer" (§ name peer)) :for peers)
            (§ block
                (§ if (§ expr peer.getPeerVersionMessage(§ pars ).clientVersion >= protocolVersion))
                (§ block
                    (§ expr results.add(§ pars peer))
                )
            )
            (§ return results)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a future that is triggered when there are at least the requested number of connected peers that support
     ; the given protocol version or higher.  To block immediately, just call get() on the result.
     ;
     ; @param numPeers How many peers to wait for.
     ; @param mask An integer representing a bit mask that will be ANDed with the peers advertised service masks.
     ; @return a future that will be triggered when the number of connected peers implementing protocolVersion or higher >= numPeers.
     ;;
    #_public
    (§ method #_"ListenableFuture<List<Peer>>" (§ fn waitForPeersWithServiceMask) [#_final #_"int" (§ name numPeers), #_final #_"int" (§ name mask)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"List<Peer>" (§ name foundPeers) (§ expr findPeersWithServiceMask(§ pars mask)))
            (§ if (§ expr numPeers <= foundPeers.size(§ pars )))
            (§ block
                (§ return (§ expr Futures/immediateFuture(§ pars foundPeers)))
            )

            #_final
            (§ var #_"SettableFuture<List<Peer>>" (§ name future) (§ expr SettableFuture/create(§ pars )))
            (§ expr addConnectedEventListener(§ pars (§ new #_"PeerConnectedEventListener" (§ pars ))
            (§ anon
                #_override
                #_public
                (§ method #_"void" (§ fn onPeerConnected) [#_"Peer" (§ name peer), #_"int" (§ name peerCount)])
                (§ block
                    #_final
                    (§ var #_"List<Peer>" (§ name peers) (§ expr findPeersWithServiceMask(§ pars mask)))
                    (§ if (§ expr numPeers <= peers.size(§ pars )))
                    (§ block
                        (§ expr future.set(§ pars peers))
                        (§ expr removeConnectedEventListener(§ pars this))
                    )
                    (§ void nil)
                )
            )))
            (§ return future)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns an array list of peers that match the requested service bit mask.
     ;;
    #_public
    (§ method #_"List<Peer>" (§ fn findPeersWithServiceMask) [#_"int" (§ name mask)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"ArrayList<Peer>" (§ name results) (§ new #_"ArrayList<Peer>" (§ pars peers.size(§ pars ))))
            (§ for (§ var #_"Peer" (§ name peer)) :for peers)
            (§ block
                (§ if (§ expr (§ expr peer.getPeerVersionMessage(§ pars ).localServices & mask) == mask))
                (§ block
                    (§ expr results.add(§ pars peer))
                )
            )
            (§ return results)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the number of connections that are required before transactions will be broadcast.  If there aren't
     ; enough, {@link PeerGroup#broadcastTransaction(Transaction)} will wait until the minimum number is reached so
     ; propagation across the network can be observed.  If no value has been set using
     ; {@link PeerGroup#setMinBroadcastConnections(int)} a default of 80% of whatever
     ; {@link org.bitcoinj.core.PeerGroup#getMaxConnections()} returns is used.
     ;;
    #_public
    (§ method #_"int" (§ fn getMinBroadcastConnections) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr minBroadcastConnections == 0))
            (§ block
                (§ var #_"int" (§ name max) (§ expr getMaxConnections(§ pars )))
                (§ if (§ expr max <= 1))
                (§ block
                    (§ return max)
                )
                (§ else )
                (§ block
                    (§ return (§ cast #_"int" (§ expr Math/round(§ pars getMaxConnections(§ pars ) * 0.8))))
                )
            )
            (§ return minBroadcastConnections)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; See {@link org.bitcoinj.core.PeerGroup#getMinBroadcastConnections()}.
     ;;
    #_public
    (§ method #_"void" (§ fn setMinBroadcastConnections) [#_"int" (§ name value)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name minBroadcastConnections) value)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Calls {@link PeerGroup#broadcastTransaction(Transaction, int)} with getMinBroadcastConnections() as the number
     ; of connections to wait for before commencing broadcast.
     ;;
    #_override
    #_public
    (§ method #_"TransactionBroadcast" (§ fn broadcastTransaction) [#_final #_"Transaction" (§ name tx)])
    (§ block
        (§ return (§ expr broadcastTransaction(§ pars tx, Math/max(§ pars 1, getMinBroadcastConnections(§ pars )))))
    )

    ;;;
     ; <p>Given a transaction, sends it un-announced to one peer and then waits for it to be received back from
     ; other peers.  Once all connected peers have announced the transaction, the future available via the
     ; {@link org.bitcoinj.core.TransactionBroadcast#future()} method will be completed.  If anything goes
     ; wrong the exception will be thrown when get() is called, or you can receive it via a callback on the
     ; {@link ListenableFuture}.  This method returns immediately, so if you want it to block just call get() on the
     ; result.</p>
     ;
     ; <p>Note that if the PeerGroup is limited to only one connection (discovery is not activated) then the future
     ; will complete as soon as the transaction was successfully written to that peer.</p>
     ;
     ; <p>The transaction won't be sent until there are at least minConnections active connections available.
     ; A good choice for proportion would be between 0.5 and 0.8 but if you want faster transmission during initial
     ; bringup of the peer group you can lower it.</p>
     ;
     ; <p>The returned {@link org.bitcoinj.core.TransactionBroadcast} object can be used to get progress feedback,
     ; which is calculated by watching the transaction propagate across the network and be announced by peers.</p>
     ;;
    #_public
    (§ method #_"TransactionBroadcast" (§ fn broadcastTransaction) [#_final #_"Transaction" (§ name tx), #_final #_"int" (§ name minConnections)])
    (§ block
        ;; If we don't have a record of where this tx came from already, set it to be ourselves so Peer doesn't end up
        ;; redownloading it from the network redundantly.
        (§ if (§ expr tx.getConfidence(§ pars ).getSource(§ pars ).equals(§ pars TransactionConfidence/Source/UNKNOWN)))
        (§ block
            (§ expr log.info(§ pars "Transaction source unknown, setting to SELF: {}", tx.getHashAsString(§ pars )))
            (§ expr tx.getConfidence(§ pars ).setSource(§ pars TransactionConfidence/Source/SELF))
        )
        #_final
        (§ var #_"TransactionBroadcast" (§ name broadcast) (§ new #_"TransactionBroadcast" (§ pars this, tx)))
        (§ expr broadcast.setMinConnections(§ pars minConnections))
        ;; Send the TX to the wallet once we have a successful broadcast.
        (§ expr Futures/addCallback(§ pars broadcast.future(§ pars ), new FutureCallback<Transaction>(§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn onSuccess) [#_"Transaction" (§ name transaction)])
            (§ block
                (§ expr runningBroadcasts.remove(§ pars broadcast))
                ;; OK, now tell the wallet about the transaction.  If the wallet created the transaction,
                ;; then it already knows and will ignore this.  If it's a transaction we received from
                ;; somebody else via a side channel and are now broadcasting, this will put it into the
                ;; wallet now we know it's valid.
                (§ for (§ var #_"Wallet" (§ name wallet)) :for wallets)
                (§ block
                    ;; Assumption here is there are no dependencies of the created transaction.
                    ;;
                    ;; We may end up with two threads trying to do this in parallel - the wallet will
                    ;; ignore whichever one loses the race.
                    (§ try )
                    (§ block
                        (§ expr wallet.receivePending(§ pars transaction, nil))
                    )
                    (§ catch #_"VerificationException" (§ name e))
                    (§ block
                        (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot fail to verify a tx we created ourselves.
                    )
                )
                (§ void nil)
            )

            #_override
            #_public
            (§ method #_"void" (§ fn onFailure) [#_"Throwable" (§ name throwable)])
            (§ block
                ;; This can happen if we get a reject message from a peer.
                (§ expr runningBroadcasts.remove(§ pars broadcast))
                (§ void nil)
            )
        )))
        ;; Keep a reference to the TransactionBroadcast object.  This is important because otherwise, the entire tree
        ;; of objects we just created would become garbage if the user doesn't hold on to the returned future, and
        ;; eventually be collected.  This in turn could result in the transaction not being committed to the wallet
        ;; at all.
        (§ expr runningBroadcasts.add(§ pars broadcast))
        (§ expr broadcast.broadcast(§ pars ))
        (§ return broadcast)
    )

    ;;;
     ; Returns the period between pings for an individual peer.  Setting this lower means more accurate and timely
     ; ping times are available via {@link org.bitcoinj.core.Peer#getLastPingTime()} but it increases load on the
     ; remote node.  It defaults to {@link PeerGroup#DEFAULT_PING_INTERVAL_MSEC}.
     ;;
    #_public
    (§ method #_"long" (§ fn getPingIntervalMsec) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return pingIntervalMsec)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Sets the period between pings for an individual peer.  Setting this lower means more accurate and timely
     ; ping times are available via {@link org.bitcoinj.core.Peer#getLastPingTime()} but it increases load on the
     ; remote node.  It defaults to {@link PeerGroup#DEFAULT_PING_INTERVAL_MSEC}.
     ; Setting the value to be <= 0 disables pinging entirely, although you can still request one yourself
     ; using {@link org.bitcoinj.core.Peer#ping()}.
     ;;
    #_public
    (§ method #_"void" (§ fn setPingIntervalMsec) [#_"long" (§ name pingIntervalMsec)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name this.pingIntervalMsec) pingIntervalMsec)
            (§ var #_"ListenableScheduledFuture<?>" (§ name task) vPingTask)
            (§ if (§ expr task != nil))
            (§ block
                (§ expr task.cancel(§ pars false))
            )
            (§ expr setupPinging(§ pars ))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; If a peer is connected to that claims to speak a protocol version lower than the given version, it will
     ; be disconnected and another one will be tried instead.
     ;;
    #_public
    (§ method #_"void" (§ fn setMinRequiredProtocolVersion) [#_"int" (§ name minRequiredProtocolVersion)])
    (§ block
        (§ ass (§ name this.vMinRequiredProtocolVersion) minRequiredProtocolVersion)
        (§ void nil)
    )

    ;;; The minimum protocol version required: defaults to the version required for Bloom filtering. ;;
    #_public
    (§ method #_"int" (§ fn getMinRequiredProtocolVersion) [])
    (§ block
        (§ return vMinRequiredProtocolVersion)
    )

    ;;;
     ; Returns our peers most commonly reported chain height.  If multiple heights are tied, the highest is returned.
     ; If no peers are connected, returns zero.
     ;;
    #_public
    (§ method #_"int" (§ fn getMostCommonChainHeight) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr getMostCommonChainHeight(§ pars this.peers)))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns most commonly reported chain height from the given list of {@link Peer}s.
     ; If multiple heights are tied, the highest is returned.  If no peers are connected, returns zero.
     ;;
    #_public
    #_static
    (§ method #_"int" (§ fn getMostCommonChainHeight) [#_final #_"List<Peer>" (§ name peers)])
    (§ block
        (§ if (§ expr peers.isEmpty(§ pars )))
        (§ block
            (§ return 0)
        )

        (§ var #_"List<Integer>" (§ name heights) (§ new #_"ArrayList<>" (§ pars peers.size(§ pars ))))
        (§ for (§ var #_"Peer" (§ name peer)) :for peers)
        (§ block
            (§ expr heights.add(§ pars (§ cast #_"int" (§ expr peer.getBestHeight(§ pars )))))
        )
        (§ return (§ expr Utils/maxOfMostFreq(§ pars heights)))
    )

    ;;;
     ; Given a list of Peers, return a Peer to be used as the download peer.  If you don't want PeerGroup to manage
     ; download peer statuses for you, just override this and always return null.
     ;;
    #_nilable
    #_protected
    (§ method #_"Peer" (§ fn selectDownloadPeer) [#_"List<Peer>" (§ name peers)])
    (§ block
        ;; Characteristics to select for in order of importance:
        ;;  - Chain height is reasonable (majority of nodes).
        ;;  - High enough protocol version for the features we want (but we'll settle for less).
        ;;  - Randomly, to try and spread the load.
        (§ if (§ expr peers.isEmpty(§ pars )))
        (§ block
            (§ return nil)
        )

        ;; Make sure we don't select a peer that is behind/synchronizing itself.
        (§ var #_"int" (§ name mostCommonChainHeight) (§ expr getMostCommonChainHeight(§ pars peers)))
        (§ var #_"List<Peer>" (§ name candidates) (§ new #_"ArrayList<>" (§ pars )))
        (§ for (§ var #_"Peer" (§ name peer)) :for peers)
        (§ block
            (§ if (§ expr peer.getBestHeight(§ pars ) == mostCommonChainHeight))
            (§ block
                (§ expr candidates.add(§ pars peer))
            )
        )

        ;; Of the candidates, find the peers that meet the minimum protocol version we want to target.  We could select
        ;; the highest version we've seen on the assumption that newer versions are always better but we don't want to
        ;; zap peers if they upgrade early.  If we can't find any peers that have our preferred protocol version or
        ;; better then we'll settle for the highest we found instead.
        (§ var #_"int" (§ name highestVersion) 0)
        (§ var #_"int" (§ name preferredVersion) 0)

        ;; if/when PREFERRED_VERSION is not equal to vMinRequiredProtocolVersion, reenable the last test in PeerGroupTest.downloadPeerSelection
        #_final
        (§ var #_"int" (§ name PREFERRED_VERSION) (§ expr params.getProtocolVersionNum(§ pars NetworkParameters/ProtocolVersion/BLOOM_FILTER)))
        (§ for (§ var #_"Peer" (§ name peer)) :for candidates)
        (§ block
            (§ ass (§ name highestVersion) (§ expr Math/max(§ pars peer.getPeerVersionMessage(§ pars ).clientVersion, highestVersion)))
            (§ ass (§ name preferredVersion) (§ expr Math/min(§ pars highestVersion, PREFERRED_VERSION)))
        )
        (§ var #_"ArrayList<Peer>" (§ name candidates2) (§ new #_"ArrayList<>" (§ pars candidates.size(§ pars ))))
        (§ for (§ var #_"Peer" (§ name peer)) :for candidates)
        (§ block
            (§ if (§ expr preferredVersion <= peer.getPeerVersionMessage(§ pars ).clientVersion))
            (§ block
                (§ expr candidates2.add(§ pars peer))
            )
        )
        (§ var #_"int" (§ name index) (§ expr (§ cast #_"int" (§ expr Math/random(§ pars ) * candidates2.size(§ pars )))))
        (§ return (§ expr candidates2.get(§ pars index)))
    )

    ;;;
     ; Returns the currently selected download peer.  Bear in mind that it may have changed as soon as this method
     ; returns.  Can return null if no peer was selected.
     ;;
    #_public
    (§ method #_"Peer" (§ fn getDownloadPeer) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return downloadPeer)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the maximum number of {@link Peer}s to discover.  This maximum is checked after
     ; each {@link PeerDiscovery} so this max number can be surpassed.
     ; @return the maximum number of peers to discover.
     ;;
    #_public
    (§ method #_"int" (§ fn getMaxPeersToDiscoverCount) [])
    (§ block
        (§ return vMaxPeersToDiscoverCount)
    )

    ;;;
     ; Sets the maximum number of {@link Peer}s to discover.  This maximum is checked after
     ; each {@link PeerDiscovery} so this max number can be surpassed.
     ; @param maxPeersToDiscoverCount the maximum number of peers to discover.
     ;;
    #_public
    (§ method #_"void" (§ fn setMaxPeersToDiscoverCount) [#_"int" (§ name maxPeersToDiscoverCount)])
    (§ block
        (§ ass (§ name this.vMaxPeersToDiscoverCount) maxPeersToDiscoverCount)
        (§ void nil)
    )

    ;;; See {@link #setUseLocalhostPeerWhenPossible(boolean)}. ;;
    #_public
    (§ method #_"boolean" (§ fn getUseLocalhostPeerWhenPossible) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return useLocalhostPeerWhenPossible)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; When true (the default), PeerGroup will attempt to connect to a Bitcoin node running on localhost before
     ; attempting to use the P2P network.  If successful, only localhost will be used.  This makes for a simple
     ; and easy way for a user to upgrade a bitcoinj based app running in SPV mode to fully validating security.
     ;;
    #_public
    (§ method #_"void" (§ fn setUseLocalhostPeerWhenPossible) [#_"boolean" (§ name useLocalhostPeerWhenPossible)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name this.useLocalhostPeerWhenPossible) useLocalhostPeerWhenPossible)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    #_public
    (§ method #_"boolean" (§ fn isRunning) [])
    (§ block
        (§ return vRunning)
    )

    ;;;
     ; Can be used to disable Bloom filtering entirely, even in SPV mode.  You are very unlikely to need this, it is
     ; an optimisation for rare cases when full validation is not required but it's still more efficient to download
     ; full blocks than filtered blocks.
     ;;
    #_public
    (§ method #_"void" (§ fn setBloomFilteringEnabled) [#_"boolean" (§ name bloomFilteringEnabled)])
    (§ block
        (§ ass (§ name this.vBloomFilteringEnabled) bloomFilteringEnabled)
        (§ void nil)
    )

    ;;; Returns whether the Bloom filtering protocol optimisation is in use: defaults to true. ;;
    #_public
    (§ method #_"boolean" (§ fn isBloomFilteringEnabled) [])
    (§ block
        (§ return vBloomFilteringEnabled)
    )
)

#_(ns org.bitcoinj.core #_"PeerSocketHandler"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.net ConnectException InetSocketAddress]
             [java.nio BufferUnderflowException ByteBuffer]
             [java.nio.channels NotYetConnectedException]
             [java.util.concurrent.locks Lock])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.net AbstractTimeoutHandler MessageWriteTarget StreamConnection]
             [org.bitcoinj.utils Threading]))

;;;
 ; Handles high-level message (de)serialization for peers, acting as the bridge between the
 ; {@link org.bitcoinj.net} classes and {@link Peer}.
 ;;
#_public
#_abstract
(§ class #_"PeerSocketHandler" (§ extends #_"AbstractTimeoutHandler") (§ implements #_"StreamConnection")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"PeerSocketHandler"))))

    #_private
    #_final
    (§ field #_"MessageSerializer" (§ name serializer))
    #_protected
    (§ field #_"PeerAddress" (§ name peerAddress))
    ;; If we close() before we know our writeTarget, set this to true to call writeTarget.closeConnection() right away.
    #_private
    (§ field #_"boolean" (§ name closePending))
    ;; writeTarget will be thread-safe, and may call into PeerGroup, which calls us, so we should call it unlocked.
    #_testing
    #_protected
    (§ field #_"MessageWriteTarget" (§ name writeTarget))

    ;; The ByteBuffers passed to us from the writeTarget are static in size, and usually smaller than some messages we
    ;; will receive.  For SPV clients, this should be rare (i.e. we're mostly dealing with small transactions), but for
    ;; messages which are larger than the read buffer, we have to keep a temporary buffer with its bytes.
    #_private
    (§ field #_"byte[]" (§ name largeReadBuffer))
    #_private
    (§ field #_"int" (§ name largeReadBufferPos))
    #_private
    (§ field #_"BitcoinSerializer.BitcoinPacketHeader" (§ name header))

    #_private
    (§ field #_"Lock" (§ name lock) (§ expr Threading/lock(§ pars "PeerSocketHandler")))

    #_public
    (§ constructor #_"PeerSocketHandler" [#_"NetworkParameters" (§ name params), #_"InetSocketAddress" (§ name remoteIp)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars params))
        (§ ass (§ name serializer) (§ expr params.getDefaultSerializer(§ pars )))
        (§ ass (§ name this.peerAddress) (§ new #_"PeerAddress" (§ pars params, remoteIp)))
        (§ void this)
    )

    #_public
    (§ constructor #_"PeerSocketHandler" [#_"NetworkParameters" (§ name params), #_"PeerAddress" (§ name peerAddress)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars params))
        (§ ass (§ name serializer) (§ expr params.getDefaultSerializer(§ pars )))
        (§ ass (§ name this.peerAddress) (§ expr Preconditions/checkNotNull(§ pars peerAddress)))
        (§ void this)
    )

    ;;;
     ; Sends the given message to the peer.  Due to the asynchronousness of network programming, there is no guarantee
     ; the peer will have received it.  Throws NotYetConnectedException if we are not yet connected to the remote peer.
     ; TODO: Maybe use something other than the unchecked NotYetConnectedException here.
     ;;
    #_public
    (§ method #_"void" (§ fn sendMessage) [#_"Message" (§ name message)])
        (§ throws #_"NotYetConnectedException")
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr writeTarget == nil))
            (§ block
                (§ throw (§ new #_"NotYetConnectedException" (§ pars )))
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        ;; TODO: Some round-tripping could be avoided here.
        (§ var #_"ByteArrayOutputStream" (§ name out) (§ new #_"ByteArrayOutputStream" (§ pars )))
        (§ try )
        (§ block
            (§ expr serializer.serialize(§ pars message, out))
            (§ expr writeTarget.writeBytes(§ pars out.toByteArray(§ pars )))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ expr exceptionCaught(§ pars e))
        )
        (§ void nil)
    )

    ;;;
     ; Closes the connection to the peer if one exists, or immediately closes the connection as soon as it opens.
     ;;
    #_public
    (§ method #_"void" (§ fn close) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr writeTarget == nil))
            (§ block
                (§ ass (§ name closePending) true)
                (§ return nil)
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ expr writeTarget.closeConnection(§ pars ))
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn timeoutOccurred) [])
    (§ block
        (§ expr log.info(§ pars "{}: Timed out", getAddress(§ pars )))
        (§ expr close(§ pars ))
        (§ void nil)
    )

    ;;;
     ; Called every time a message is received from the network.
     ;;
    #_protected
    #_abstract
    (§ method #_"void" (§ fn processMessage) [#_"Message" (§ name m)])
        (§ throws #_"Exception")

    #_override
    #_public
    (§ method #_"int" (§ fn receiveBytes) [#_"ByteBuffer" (§ name buff)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars buff.position(§ pars ) == 0 && BitcoinSerializer/BitcoinPacketHeader/HEADER_LENGTH + 4 <= buff.capacity(§ pars )))
        (§ try )
        (§ block
            ;; Repeatedly try to deserialize messages until we hit a BufferUnderflowException.
            (§ var #_"boolean" (§ name firstMessage) true)
            (§ while true)
            (§ block
                ;; If we are in the middle of reading a message, try to fill that one first, before we expect another.
                (§ if (§ expr largeReadBuffer != nil))
                (§ block
                    ;; This can only happen in the first iteration.
                    (§ expr Preconditions/checkState(§ pars firstMessage))
                    ;; Read new bytes into the largeReadBuffer.
                    (§ var #_"int" (§ name bytesToGet) (§ expr Math/min(§ pars buff.remaining(§ pars ), largeReadBuffer.length - largeReadBufferPos)))
                    (§ expr buff.get(§ pars largeReadBuffer, largeReadBufferPos, bytesToGet))
                    (§ ass (§ name largeReadBufferPos) (§ expr largeReadBufferPos + bytesToGet))
                    ;; Check the largeReadBuffer's status.
                    (§ if (§ expr largeReadBufferPos == largeReadBuffer.length))
                    (§ block
                        ;; ...processing a message if one is available.
                        (§ expr processMessage(§ pars serializer.deserializePayload(§ pars header, ByteBuffer/wrap(§ pars largeReadBuffer))))
                        (§ ass (§ name largeReadBuffer) nil)
                        (§ ass (§ name header) nil)
                        (§ ass (§ name firstMessage) false)
                    )
                    (§ else ) ;; ...or just returning if we don't have enough bytes yet.
                    (§ block
                        (§ return (§ expr buff.position(§ pars )))
                    )
                )
                ;; Now try to deserialize any messages left in buff.
                (§ var #_"Message" (§ name message))
                (§ var #_"int" (§ name preSerializePosition) (§ expr buff.position(§ pars )))
                (§ try )
                (§ block
                    (§ ass (§ name message) (§ expr serializer.deserialize(§ pars buff)))
                )
                (§ catch #_"BufferUnderflowException" (§ name e))
                (§ block
                    ;; If we went through the whole buffer without a full message, we need to use the largeReadBuffer.
                    (§ if (§ expr firstMessage && buff.limit(§ pars ) == buff.capacity(§ pars )))
                    (§ block
                        ;; ...so reposition the buffer to 0 and read the next message header.
                        (§ expr buff.position(§ pars 0))
                        (§ try )
                        (§ block
                            (§ expr serializer.seekPastMagicBytes(§ pars buff))
                            (§ ass (§ name header) (§ expr serializer.deserializeHeader(§ pars buff)))
                            ;; Initialize the largeReadBuffer with the next message's size and fill it with any bytes left in buff.
                            (§ ass (§ name largeReadBuffer) (§ new #_"byte[]" (§ count header.size)))
                            (§ ass (§ name largeReadBufferPos) (§ expr buff.remaining(§ pars )))
                            (§ expr buff.get(§ pars largeReadBuffer, 0, largeReadBufferPos))
                        )
                        (§ catch #_"BufferUnderflowException" (§ name e1))
                        (§ block
                            ;; If we went through a whole buffer's worth of bytes without getting a header, give up.
                            ;; In cases where the buff is just really small, we could create a second largeReadBuffer
                            ;; that we use to deserialize the magic+header, but that is rather complicated when the buff
                            ;; should probably be at least that big anyway (for efficiency).
                            (§ throw (§ new #_"ProtocolException" (§ pars "No magic bytes+header after reading " + buff.capacity(§ pars ) + " bytes")))
                        )
                    )
                    (§ else )
                    (§ block
                        ;; Reposition the buffer to its original position, which saves us from skipping messages by
                        ;; seeking past part of the magic bytes before all of them are in the buffer.
                        (§ expr buff.position(§ pars preSerializePosition))
                    )
                    (§ return (§ expr buff.position(§ pars )))
                )
                ;; Process our freshly deserialized message.
                (§ expr processMessage(§ pars message))
                (§ ass (§ name firstMessage) false)
            )
        )
        (§ catch #_"Exception" (§ name e))
        (§ block
            (§ expr exceptionCaught(§ pars e))
            ;; Returning -1 also throws an IllegalStateException upstream and kills the connection.
            (§ return -1)
        )
    )

    ;;;
     ; Sets the {@link MessageWriteTarget} used to write messages to the peer.  This should almost never be called,
     ; it is called automatically by {@link org.bitcoinj.net.NioClient} or
     ; {@link org.bitcoinj.net.NioClientManager} once the socket finishes initialization.
     ;;
    #_override
    #_public
    (§ method #_"void" (§ fn setWriteTarget) [#_"MessageWriteTarget" (§ name writeTarget)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars writeTarget != nil))

        (§ expr lock.lock(§ pars ))
        (§ var #_"boolean" (§ name closeNow) false)
        (§ try )
        (§ block
            (§ expr Preconditions/checkArgument(§ pars this.writeTarget == nil))

            (§ ass (§ name closeNow) closePending)
            (§ ass (§ name this.writeTarget) writeTarget)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ if closeNow)
        (§ block
            (§ expr writeTarget.closeConnection(§ pars ))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"int" (§ fn getMaxMessageSize) [])
    (§ block
        (§ return (§ expr Message/MAX_SIZE))
    )

    ;;;
     ; @return the IP address and port of peer.
     ;;
    #_public
    (§ method #_"PeerAddress" (§ fn getAddress) [])
    (§ block
        (§ return peerAddress)
    )

    ;;; Catch any exceptions, logging them and then closing the channel. ;;
    #_private
    (§ method #_"void" (§ fn exceptionCaught) [#_"Exception" (§ name e)])
    (§ block
        (§ var #_"PeerAddress" (§ name addr) (§ expr getAddress(§ pars )))
        (§ var #_"String" (§ name s) (§ quest (§ expr addr == nil) ? (§ expr "?") :else (§ expr addr.toString(§ pars ))))
        (§ if (§ expr (§ insta e #_"ConnectException") || (§ insta e #_"IOException")))
        (§ block
            ;; Short message for network errors
            (§ expr log.info(§ pars s + " - " + e.getMessage(§ pars )))
        )
        (§ else )
        (§ block
            (§ expr log.warn(§ pars s + " - ", e))
            (§ var #_"Thread.UncaughtExceptionHandler" (§ name handler) (§ expr Threading.uncaughtExceptionHandler))
            (§ if (§ expr handler != nil))
            (§ block
                (§ expr handler.uncaughtException(§ pars Thread/currentThread(§ pars ), e))
            )
        )

        (§ expr close(§ pars ))
        (§ void nil)
    )
)

#_(ns org.bitcoinj.core #_"Ping"
    (:import [java.io IOException OutputStream]))

;;;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"Ping" (§ extends #_"Message")
    #_private
    (§ field #_"long" (§ name nonce))
    #_private
    (§ field #_"boolean" (§ name hasNonce))

    #_public
    (§ constructor #_"Ping" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payloadBytes)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payloadBytes, 0))
        (§ void this)
    )

    ;;;
     ; Create a Ping with a nonce value.
     ; Only use this if the remote node has a protocol version > 60000.
     ;;
    #_public
    (§ constructor #_"Ping" [#_"long" (§ name nonce)])
    (§ block
        (§ ass (§ name this.nonce) nonce)
        (§ ass (§ name this.hasNonce) true)
        (§ void this)
    )

    ;;;
     ; Create a Ping without a nonce value.
     ; Only use this if the remote node has a protocol version <= 60000.
     ;;
    #_public
    (§ constructor #_"Ping" [])
    (§ block
        (§ ass (§ name this.hasNonce) false)
        (§ void this)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ if hasNonce)
        (§ block
            (§ expr Utils/int64ToByteStreamLE(§ pars nonce, stream))
        )
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ try )
        (§ block
            (§ ass (§ name nonce) (§ expr readInt64(§ pars )))
            (§ ass (§ name hasNonce) true)
        )
        (§ catch #_"ProtocolException" (§ name e))
        (§ block
            (§ ass (§ name hasNonce) false)
        )
        (§ ass (§ name length) (§ quest hasNonce ? 8 :else 0))
        (§ void nil)
    )

    #_public
    (§ method #_"boolean" (§ fn hasNonce) [])
    (§ block
        (§ return hasNonce)
    )

    #_public
    (§ method #_"long" (§ fn getNonce) [])
    (§ block
        (§ return nonce)
    )
)

#_(ns org.bitcoinj.core #_"Pong"
    (:import [java.io IOException OutputStream]))

;;;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"Pong" (§ extends #_"Message")
    #_private
    (§ field #_"long" (§ name nonce))

    #_public
    (§ constructor #_"Pong" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payloadBytes)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payloadBytes, 0))
        (§ void this)
    )

    ;;;
     ; Create a Pong with a nonce value.
     ; Only use this if the remote node has a protocol version > 60000.
     ;;
    #_public
    (§ constructor #_"Pong" [#_"long" (§ name nonce)])
    (§ block
        (§ ass (§ name this.nonce) nonce)
        (§ void this)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ ass (§ name nonce) (§ expr readInt64(§ pars )))
        (§ ass (§ name length) 8)
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ expr Utils/int64ToByteStreamLE(§ pars nonce, stream))
        (§ void nil)
    )

    ;;; Returns the nonce sent by the remote peer. ;;
    #_public
    (§ method #_"long" (§ fn getNonce) [])
    (§ block
        (§ return nonce)
    )
)

#_(ns org.bitcoinj.core #_"ProtocolException")

#_public
(§ class #_"ProtocolException" (§ extends #_"VerificationException")
    #_public
    (§ constructor #_"ProtocolException" [#_"String" (§ name msg)])
    (§ block
        (§ super (§ pars msg))
        (§ void this)
    )

    #_public
    (§ constructor #_"ProtocolException" [#_"Exception" (§ name e)])
    (§ block
        (§ super (§ pars e))
        (§ void this)
    )

    #_public
    (§ constructor #_"ProtocolException" [#_"String" (§ name msg), #_"Exception" (§ name e)])
    (§ block
        (§ super (§ pars msg, e))
        (§ void this)
    )
)

#_(ns org.bitcoinj.core #_"PrunedException")

;; TODO: Rename PrunedException to something like RequiredDataWasPrunedException.

;;;
 ; PrunedException is thrown in cases where a fully verifying node has deleted (pruned) old block data that turned
 ; out to be necessary for handling a re-org.  Normally this should never happen unless you're playing with the testnet
 ; as the pruning parameters should be set very conservatively, such that an absolutely enormous re-org would be
 ; required to trigger it.
 ;;
#_public
(§ class #_"PrunedException" (§ extends #_"Exception")
    #_private
    (§ field #_"Sha256Hash" (§ name hash))

    #_public
    (§ constructor #_"PrunedException" [#_"Sha256Hash" (§ name hash)])
    (§ block
        (§ super (§ pars hash.toString(§ pars )))

        (§ ass (§ name this.hash) hash)
        (§ void this)
    )

    #_public
    (§ method #_"Sha256Hash" (§ fn getHash) [])
    (§ block
        (§ return hash)
    )
)

#_(ns org.bitcoinj.core #_"RejectMessage"
    (:import [java.io IOException OutputStream]
             [java.util Locale])
    (:import [com.google.common.base Objects]))

;;;
 ; <p>A message sent by nodes when a message we sent was rejected (i.e. a transaction had too little fee/was invalid/etc).</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"RejectMessage" (§ extends #_"Message")
    #_private
    (§ field #_"String" (§ name message))
    #_private
    (§ field #_"String" (§ name reason))

    #_public
    (§ enum #_"RejectCode"
        ;;; The message was not able to be parsed. ;;
        (§ item MALFORMED(§ pars (§ cast #_"byte" 0x01)))
        ;;; The message described an invalid object. ;;
        (§ item INVALID(§ pars (§ cast #_"byte" 0x10)))
        ;;; The message was obsolete or described an object which is obsolete (e.g. unsupported, old version, v1 block). ;;
        (§ item OBSOLETE(§ pars (§ cast #_"byte" 0x11)))
        ;;;
         ; The message was relayed multiple times or described an object which is in conflict with another.
         ; This message can describe errors in protocol implementation or the presence of an attempt to DOUBLE SPEND.
         ;;
        (§ item DUPLICATE(§ pars (§ cast #_"byte" 0x12)))
        ;;;
         ; The message described an object was not standard and was thus not accepted.
         ; Bitcoin Core has a concept of standard transaction forms, which describe scripts and encodings which
         ; it is willing to relay further.  Other transactions are neither relayed nor mined, though they are considered
         ; valid if they appear in a block.
         ;;
        (§ item NONSTANDARD(§ pars (§ cast #_"byte" 0x40)))
        ;;;
         ; This refers to a specific form of NONSTANDARD transactions, which have an output smaller than some constant
         ; defining them as dust (this is no longer used).
         ;;
        (§ item DUST(§ pars (§ cast #_"byte" 0x41)))
        ;;; The messages described an object which did not have sufficient fee to be relayed further. ;;
        (§ item INSUFFICIENTFEE(§ pars (§ cast #_"byte" 0x42)))
        ;;; The message described a block which was invalid according to hard-coded checkpoint blocks. ;;
        (§ item CHECKPOINT(§ pars (§ cast #_"byte" 0x43)))
        (§ item OTHER(§ pars (§ cast #_"byte" 0xff)))

        (§ var #_"byte" (§ name code))

        (§ constructor #_"RejectCode" [#_"byte" (§ name code)])
        (§ block
            (§ ass (§ name this.code) code)
            (§ void this)
        )

        #_static
        (§ method #_"RejectCode" (§ fn fromCode) [#_"byte" (§ name code)])
        (§ block
            (§ for (§ var #_"RejectCode" (§ name rejectCode)) :for (§ expr RejectCode/values(§ pars )))
            (§ block
                (§ if (§ expr rejectCode.code == code))
                (§ block
                    (§ return rejectCode)
                )
            )

            (§ return (§ expr OTHER))
        )
    )

    #_private
    (§ field #_"RejectCode" (§ name code))
    #_private
    (§ field #_"Sha256Hash" (§ name messageHash))

    #_public
    (§ constructor #_"RejectMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, 0))
        (§ void this)
    )

    ;;; Constructs a reject message that fingers the object with the given hash as rejected for the given reason. ;;
    #_public
    (§ constructor #_"RejectMessage" [#_"NetworkParameters" (§ name params), #_"RejectCode" (§ name code), #_"Sha256Hash" (§ name hash), #_"String" (§ name message), #_"String" (§ name reason)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params))

        (§ ass (§ name this.code) code)
        (§ ass (§ name this.messageHash) hash)
        (§ ass (§ name this.message) message)
        (§ ass (§ name this.reason) reason)
        (§ void this)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ ass (§ name message) (§ expr readStr(§ pars )))
        (§ ass (§ name code) (§ expr RejectCode/fromCode(§ pars readBytes(§ pars 1)[0])))
        (§ ass (§ name reason) (§ expr readStr(§ pars )))
        (§ if (§ expr message.equals(§ pars "block") || message.equals(§ pars "tx")))
        (§ block
            (§ ass (§ name messageHash) (§ expr readHash(§ pars )))
        )
        (§ ass (§ name length) (§ expr cursor - offset))
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ var #_"byte[]" (§ name messageBytes) (§ expr message.getBytes(§ pars "UTF-8")))
        (§ expr stream.write(§ pars (§ new #_"VarInt" (§ pars messageBytes.length)).encode(§ pars )))
        (§ expr stream.write(§ pars messageBytes))
        (§ expr stream.write(§ pars code.code))
        (§ var #_"byte[]" (§ name reasonBytes) (§ expr reason.getBytes(§ pars "UTF-8")))
        (§ expr stream.write(§ pars (§ new #_"VarInt" (§ pars reasonBytes.length)).encode(§ pars )))
        (§ expr stream.write(§ pars reasonBytes))
        (§ if (§ expr "block".equals(§ pars message) || "tx".equals(§ pars message)))
        (§ block
            (§ expr stream.write(§ pars messageHash.getReversedBytes(§ pars )))
        )
        (§ void nil)
    )

    ;;;
     ; Provides the type of message which was rejected by the peer.
     ; Note that this is ENTIRELY UNTRUSTED and should be sanity-checked before it is printed or processed.
     ;;
    #_public
    (§ method #_"String" (§ fn getRejectedMessage) [])
    (§ block
        (§ return message)
    )

    ;;;
     ; Provides the hash of the rejected object (if getRejectedMessage() is either "tx" or "block"), otherwise null.
     ;;
    #_public
    (§ method #_"Sha256Hash" (§ fn getRejectedObjectHash) [])
    (§ block
        (§ return messageHash)
    )

    ;;;
     ; The reason code given for why the peer rejected the message.
     ;;
    #_public
    (§ method #_"RejectCode" (§ fn getReasonCode) [])
    (§ block
        (§ return code)
    )

    ;;;
     ; The reason message given for rejection.
     ; Note that this is ENTIRELY UNTRUSTED and should be sanity-checked before it is printed or processed.
     ;;
    #_public
    (§ method #_"String" (§ fn getReasonString) [])
    (§ block
        (§ return reason)
    )

    ;;;
     ; A String representation of the relevant details of this reject message.
     ; Be aware that the value returned by this method includes the value returned by
     ; {@link #getReasonString() getReasonString}, which is taken from the reject message unchecked.
     ; Through malice or otherwise, it might contain control characters or other harmful content.
     ;;
    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ var #_"Sha256Hash" (§ name hash) (§ expr getRejectedObjectHash(§ pars )))
        (§ return (§ expr String/format(§ pars Locale/US, "Reject: %s %s for reason '%s' (%d)", getRejectedMessage(§ pars ), (§ expr hash != nil) ? hash) :for (§ expr "", getReasonString(§ pars ), getReasonCode(§ pars ).code)))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"RejectMessage" (§ name other) (§ expr (§ cast #_"RejectMessage" o)))
        (§ return (§ expr message.equals(§ pars other.message) && code.equals(§ pars other.code) && reason.equals(§ pars other.reason) && messageHash.equals(§ pars other.messageHash)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars message, code, reason, messageHash)))
    )
)

#_(ns org.bitcoinj.core #_"RejectedTransactionException")

;;;
 ; This exception is used by the TransactionBroadcast class to indicate that a broadcast
 ; Transaction has been rejected by the network, for example because it violates a
 ; protocol rule.  Note that not all invalid transactions generate a reject message, and
 ; some peers may never do so.
 ;;
#_public
(§ class #_"RejectedTransactionException" (§ extends #_"Exception")
    #_private
    (§ field #_"Transaction" (§ name tx))
    #_private
    (§ field #_"RejectMessage" (§ name rejectMessage))

    #_public
    (§ constructor #_"RejectedTransactionException" [#_"Transaction" (§ name tx), #_"RejectMessage" (§ name rejectMessage)])
    (§ block
        (§ super (§ pars rejectMessage.toString(§ pars )))

        (§ ass (§ name this.tx) tx)
        (§ ass (§ name this.rejectMessage) rejectMessage)
        (§ void this)
    )

    ;;; Return the original Transaction object whose broadcast was rejected. ;;
    #_public
    (§ method #_"Transaction" (§ fn getTransaction) [])
    (§ block
        (§ return tx)
    )

    ;;; Return the RejectMessage object representing the broadcast rejection. ;;
    #_public
    (§ method #_"RejectMessage" (§ fn getRejectMessage) [])
    (§ block
        (§ return rejectMessage)
    )
)

#_(ns org.bitcoinj.core #_"ScriptException"
   (:require [org.bitcoinj.script ScriptError]))

#_public
(§ class #_"ScriptException" (§ extends #_"VerificationException")
    #_private
    #_final
    (§ field #_"ScriptError" (§ name err))

    #_public
    (§ constructor #_"ScriptException" [#_"ScriptError" (§ name err), #_"String" (§ name msg)])
    (§ block
        (§ super (§ pars msg))
        (§ ass (§ name this.err) err)
        (§ void this)
    )

    #_public
    (§ constructor #_"ScriptException" [#_"ScriptError" (§ name err), #_"String" (§ name msg), #_"Exception" (§ name e)])
    (§ block
        (§ super (§ pars msg, e))
        (§ ass (§ name this.err) err)
        (§ void this)
    )

    #_public
    (§ method #_"ScriptError" (§ fn getError) [])
    (§ block
        (§ return err)
    )
)

#_(ns org.bitcoinj.core #_"Sha256Hash"
    (:import [java.io File FileInputStream IOException Serializable]
             [java.math BigInteger]
             [java.security MessageDigest NoSuchAlgorithmException]
             [java.util Arrays])
    (:import [com.google.common.base Preconditions]
             [com.google.common.io ByteStreams]
             [com.google.common.primitives *]))

;;;
 ; A Sha256Hash just wraps a byte[] so that equals and hashcode work correctly,
 ; allowing it to be used as keys in a map.
 ; It also checks that the length is correct and provides a bit more type safety.
 ;;
#_public
(§ class #_"Sha256Hash" (§ implements #_"Serializable", #_"Comparable<Sha256Hash>")
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name LENGTH) 32) ;; bytes
    #_public
    #_static
    #_final
    (§ field #_"Sha256Hash" (§ name ZERO_HASH) (§ expr wrap(§ pars (§ new #_"byte[]" (§ count LENGTH)))))

    #_private
    #_final
    (§ field #_"byte[]" (§ name bytes))

    ;;;
     ; Use {@link #wrap(byte[])} instead.
     ;;
    #_protected
    (§ constructor #_"Sha256Hash" [#_"byte[]" (§ name rawHashBytes)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars rawHashBytes.length == LENGTH))
        (§ ass (§ name this.bytes) rawHashBytes)
        (§ void this)
    )

    ;;;
     ; Creates a new instance that wraps the given hash value.
     ;
     ; @param rawHashBytes The raw hash bytes to wrap.
     ; @return a new instance.
     ; @throws IllegalArgumentException if the given array length is not exactly 32.
     ;;
    #_public
    #_static
    (§ method #_"Sha256Hash" (§ fn wrap) [#_"byte[]" (§ name rawHashBytes)])
    (§ block
        (§ return (§ new #_"Sha256Hash" (§ pars rawHashBytes)))
    )

    ;;;
     ; Creates a new instance that wraps the given hash value (represented as a hex string).
     ;
     ; @param hexString A hash value represented as a hex string.
     ; @return a new instance.
     ; @throws IllegalArgumentException if the given string is not a valid hex string, or if it does not represent exactly 32 bytes.
     ;;
    #_public
    #_static
    (§ method #_"Sha256Hash" (§ fn wrap) [#_"String" (§ name hexString)])
    (§ block
        (§ return (§ expr wrap(§ pars Utils/HEX.decode(§ pars hexString))))
    )

    ;;;
     ; Creates a new instance that wraps the given hash value, but with byte order reversed.
     ;
     ; @param rawHashBytes The raw hash bytes to wrap.
     ; @return a new instance.
     ; @throws IllegalArgumentException if the given array length is not exactly 32.
     ;;
    #_public
    #_static
    (§ method #_"Sha256Hash" (§ fn wrapReversed) [#_"byte[]" (§ name rawHashBytes)])
    (§ block
        (§ return (§ expr wrap(§ pars Utils/reverseBytes(§ pars rawHashBytes))))
    )

    ;;;
     ; Creates a new instance containing the calculated (one-time) hash of the given bytes.
     ;
     ; @param contents The bytes on which the hash value is calculated.
     ; @return a new instance containing the calculated (one-time) hash.
     ;;
    #_public
    #_static
    (§ method #_"Sha256Hash" (§ fn of) [#_"byte[]" (§ name contents)])
    (§ block
        (§ return (§ expr wrap(§ pars hash(§ pars contents))))
    )

    ;;;
     ; Creates a new instance containing the hash of the calculated hash of the given bytes.
     ;
     ; @param contents The bytes on which the hash value is calculated.
     ; @return a new instance containing the calculated (two-time) hash.
     ;;
    #_public
    #_static
    (§ method #_"Sha256Hash" (§ fn twiceOf) [#_"byte[]" (§ name contents)])
    (§ block
        (§ return (§ expr wrap(§ pars hashTwice(§ pars contents))))
    )

    ;;;
     ; Creates a new instance containing the calculated (one-time) hash of the given file's contents.
     ;
     ; The file contents are read fully into memory, so this method should only be used with small files.
     ;
     ; @param file The file on which the hash value is calculated.
     ; @return a new instance containing the calculated (one-time) hash.
     ; @throws IOException if an error occurs while reading the file.
     ;;
    #_public
    #_static
    (§ method #_"Sha256Hash" (§ fn of) [#_"File" (§ name file)])
        (§ throws #_"IOException")
    (§ block
        (§ var #_"FileInputStream" (§ name in) (§ new #_"FileInputStream" (§ pars file)))
        (§ try )
        (§ block
            (§ return (§ expr of(§ pars ByteStreams/toByteArray(§ pars in))))
        )
        (§ finally )
        (§ block
            (§ expr in.close(§ pars ))
        )
    )

    ;;;
     ; Returns a new SHA-256 MessageDigest instance.
     ;
     ; This is a convenience method which wraps the checked
     ; exception that can never occur with a RuntimeException.
     ;
     ; @return a new SHA-256 MessageDigest instance.
     ;;
    #_public
    #_static
    (§ method #_"MessageDigest" (§ fn newDigest) [])
    (§ block
        (§ try )
        (§ block
            (§ return (§ expr MessageDigest/getInstance(§ pars "SHA-256")))
        )
        (§ catch #_"NoSuchAlgorithmException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Can't happen.
        )
    )

    ;;;
     ; Calculates the SHA-256 hash of the given bytes.
     ;
     ; @param input The bytes to hash.
     ; @return the hash (in big-endian order).
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn hash) [#_"byte[]" (§ name input)])
    (§ block
        (§ return (§ expr hash(§ pars input, 0, input.length)))
    )

    ;;;
     ; Calculates the SHA-256 hash of the given byte range.
     ;
     ; @param input The array containing the bytes to hash.
     ; @param offset The offset within the array of the bytes to hash.
     ; @param length The number of bytes to hash.
     ; @return the hash (in big-endian order).
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn hash) [#_"byte[]" (§ name input), #_"int" (§ name offset), #_"int" (§ name length)])
    (§ block
        (§ var #_"MessageDigest" (§ name digest) (§ expr newDigest(§ pars )))
        (§ expr digest.update(§ pars input, offset, length))
        (§ return (§ expr digest.digest(§ pars )))
    )

    ;;;
     ; Calculates the SHA-256 hash of the given bytes,
     ; and then hashes the resulting hash again.
     ;
     ; @param input The bytes to hash.
     ; @return the double-hash (in big-endian order).
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn hashTwice) [#_"byte[]" (§ name input)])
    (§ block
        (§ return (§ expr hashTwice(§ pars input, 0, input.length)))
    )

    ;;;
     ; Calculates the SHA-256 hash of the given byte range,
     ; and then hashes the resulting hash again.
     ;
     ; @param input The array containing the bytes to hash.
     ; @param offset The offset within the array of the bytes to hash.
     ; @param length The number of bytes to hash.
     ; @return the double-hash (in big-endian order).
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn hashTwice) [#_"byte[]" (§ name input), #_"int" (§ name offset), #_"int" (§ name length)])
    (§ block
        (§ var #_"MessageDigest" (§ name digest) (§ expr newDigest(§ pars )))
        (§ expr digest.update(§ pars input, offset, length))
        (§ return (§ expr digest.digest(§ pars digest.digest(§ pars ))))
    )

    ;;;
     ; Calculates the hash of hash on the given byte ranges.  This is equivalent to
     ; concatenating the two ranges and then passing the result to {@link #hashTwice(byte[])}.
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn hashTwice) [#_"byte[]" (§ name input1), #_"int" (§ name offset1), #_"int" (§ name length1), #_"byte[]" (§ name input2), #_"int" (§ name offset2), #_"int" (§ name length2)])
    (§ block
        (§ var #_"MessageDigest" (§ name digest) (§ expr newDigest(§ pars )))
        (§ expr digest.update(§ pars input1, offset1, length1))
        (§ expr digest.update(§ pars input2, offset2, length2))
        (§ return (§ expr digest.digest(§ pars digest.digest(§ pars ))))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return (§ expr Arrays/equals(§ pars bytes, (§ expr (§ cast #_"Sha256Hash" o)).bytes)))
    )

    ;;;
     ; Returns the last four bytes of the wrapped hash.  This should be unique enough to be a suitable hash code
     ; even for blocks, where the goal is to try and get the first bytes to be zeros (i.e. the value as a big integer
     ; lower than the target value).
     ;;
    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        ;; Use the last 4 bytes, not the first 4 which are often zeros in Bitcoin.
        (§ return (§ expr Ints/fromBytes(§ pars bytes[LENGTH - 4], bytes[LENGTH - 3], bytes[LENGTH - 2], bytes[LENGTH - 1])))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr Utils/HEX.encode(§ pars bytes)))
    )

    ;;;
     ; Returns the bytes interpreted as a positive integer.
     ;;
    #_public
    (§ method #_"BigInteger" (§ fn toBigInteger) [])
    (§ block
        (§ return (§ new #_"BigInteger" (§ pars 1, bytes)))
    )

    ;;;
     ; Returns the internal byte array, without defensively copying.  Therefore do NOT modify the returned array.
     ;;
    #_public
    (§ method #_"byte[]" (§ fn getBytes) [])
    (§ block
        (§ return bytes)
    )

    ;;;
     ; Returns a reversed copy of the internal byte array.
     ;;
    #_public
    (§ method #_"byte[]" (§ fn getReversedBytes) [])
    (§ block
        (§ return (§ expr Utils/reverseBytes(§ pars bytes)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn compareTo) [#_final #_"Sha256Hash" (§ name other)])
    (§ block
        (§ for (§ var #_"int" (§ name i) (§ expr LENGTH - 1)) :for (§ expr 0 <= i) :for (§ ass (§ name i) (§ expr i - 1)))
        (§ block
            #_final
            (§ var #_"int" (§ name thisByte) (§ expr this.bytes[i] & 0xff))
            #_final
            (§ var #_"int" (§ name otherByte) (§ expr other.bytes[i] & 0xff))
            (§ if (§ expr thisByte > otherByte))
            (§ block
                (§ return 1)
            )
            (§ if (§ expr thisByte < otherByte))
            (§ block
                (§ return -1)
            )
        )
        (§ return 0)
    )
)

#_(ns org.bitcoinj.core #_"StoredBlock"
    (:import [java.math BigInteger]
             [java.nio ByteBuffer]
             [java.util Locale])
    (:import [com.google.common.base Objects Preconditions])
   (:require [org.bitcoinj.store BlockStore BlockStoreException]))

;;;
 ; Wraps a {@link Block} object with extra data that can be derived from the block chain but is slow or inconvenient
 ; to calculate.  By storing it alongside the block header we reduce the amount of work required significantly.
 ; Recalculation is slow because the fields are cumulative - to find the chainWork you have to iterate over every
 ; block in the chain back to the genesis block, which involves lots of seeking/loading etc.  So we just keep a
 ; running total: it's a disk space vs cpu/io tradeoff.
 ;
 ; StoredBlocks are put inside a {@link BlockStore} which saves them to memory or disk.
 ;;
#_public
(§ class #_"StoredBlock"
    ;; A BigInteger representing the total amount of work done so far on this chain.  As of May 2011 it takes
    ;; 8 bytes to represent this field, so 12 bytes should be plenty for now.
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name CHAIN_WORK_BYTES) 12)
    #_public
    #_static
    #_final
    (§ field #_"byte[]" (§ name EMPTY_BYTES) (§ new #_"byte[]" (§ count CHAIN_WORK_BYTES)))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name COMPACT_SERIALIZED_SIZE) (§ expr Block/HEADER_SIZE + CHAIN_WORK_BYTES + 4)) ;; for height

    #_private
    (§ field #_"Block" (§ name header))
    #_private
    (§ field #_"BigInteger" (§ name chainWork))
    #_private
    (§ field #_"int" (§ name height))

    #_public
    (§ constructor #_"StoredBlock" [#_"Block" (§ name header), #_"BigInteger" (§ name chainWork), #_"int" (§ name height)])
    (§ block
        (§ ass (§ name this.header) header)
        (§ ass (§ name this.chainWork) chainWork)
        (§ ass (§ name this.height) height)
        (§ void this)
    )

    ;;;
     ; The block header this object wraps.  The referenced block object must not have any transactions in it.
     ;;
    #_public
    (§ method #_"Block" (§ fn getHeader) [])
    (§ block
        (§ return header)
    )

    ;;;
     ; The total sum of work done in this block, and all the blocks below it in the chain.  Work is a measure of
     ; how many tries are needed to solve a block.  If the target is set to cover 10% of the total hash value space,
     ; then the work represented by a block is 10.
     ;;
    #_public
    (§ method #_"BigInteger" (§ fn getChainWork) [])
    (§ block
        (§ return chainWork)
    )

    ;;;
     ; Position in the chain for this block.  The genesis block has a height of zero.
     ;;
    #_public
    (§ method #_"int" (§ fn getHeight) [])
    (§ block
        (§ return height)
    )

    ;;; Returns true if this objects chainWork is higher than the others. ;;
    #_public
    (§ method #_"boolean" (§ fn moreWorkThan) [#_"StoredBlock" (§ name other)])
    (§ block
        (§ return (§ expr 0 < chainWork.compareTo(§ pars other.chainWork)))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"StoredBlock" (§ name other) (§ expr (§ cast #_"StoredBlock" o)))
        (§ return (§ expr header.equals(§ pars other.header) && chainWork.equals(§ pars other.chainWork) && height == other.height))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars header, chainWork, height)))
    )

    ;;;
     ; Creates a new StoredBlock, calculating the additional fields by adding to the values in this block.
     ;;
    #_public
    (§ method #_"StoredBlock" (§ fn build) [#_"Block" (§ name block)])
        (§ throws #_"VerificationException")
    (§ block
        ;; Stored blocks track total work done in this chain, because the canonical chain is the one that represents
        ;; the largest amount of work done not the tallest.
        (§ var #_"BigInteger" (§ name chainWork) (§ expr this.chainWork.add(§ pars block.getWork(§ pars ))))
        (§ var #_"int" (§ name height) (§ expr this.height + 1))
        (§ return (§ new #_"StoredBlock" (§ pars block, chainWork, height)))
    )

    ;;;
     ; Given a block store, looks up the previous block in this chain.  Convenience method for doing
     ; <tt>store.get(this.getHeader().getPrevBlockHash())</tt>.
     ;
     ; @return the previous block in the chain or null if it was not found in the store.
     ;;
    #_public
    (§ method #_"StoredBlock" (§ fn getPrev) [#_"BlockStore" (§ name store)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ return (§ expr store.get(§ pars getHeader(§ pars ).getPrevBlockHash(§ pars ))))
    )

    ;;; Serializes the stored block to a custom packed format.  Used by {@link CheckpointManager}. ;;
    #_public
    (§ method #_"void" (§ fn serializeCompact) [#_"ByteBuffer" (§ name buffer)])
    (§ block
        (§ var #_"byte[]" (§ name chainWorkBytes) (§ expr getChainWork(§ pars ).toByteArray(§ pars )))
        (§ expr Preconditions/checkState(§ pars chainWorkBytes.length <= CHAIN_WORK_BYTES, "Ran out of space to store chain work!"))
        (§ if (§ expr chainWorkBytes.length < CHAIN_WORK_BYTES))
        (§ block
            ;; Pad to the right size.
            (§ expr buffer.put(§ pars EMPTY_BYTES, 0, CHAIN_WORK_BYTES - chainWorkBytes.length))
        )
        (§ expr buffer.put(§ pars chainWorkBytes))
        (§ expr buffer.putInt(§ pars getHeight(§ pars )))
        ;; Using unsafeBitcoinSerialize here can give us direct access to the same bytes we read off the wire,
        ;; avoiding serialization round-trips.
        (§ var #_"byte[]" (§ name bytes) (§ expr getHeader(§ pars ).unsafeBitcoinSerialize(§ pars )))
        (§ expr buffer.put(§ pars bytes, 0, Block/HEADER_SIZE)) ;; Trim the trailing 00 byte (zero transactions).
        (§ void nil)
    )

    ;;; De-serializes the stored block from a custom packed format.  Used by {@link CheckpointManager}. ;;
    #_public
    #_static
    (§ method #_"StoredBlock" (§ fn deserializeCompact) [#_"NetworkParameters" (§ name params), #_"ByteBuffer" (§ name buffer)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ var #_"byte[]" (§ name chainWorkBytes) (§ new #_"byte[]" (§ count StoredBlock/CHAIN_WORK_BYTES)))
        (§ expr buffer.get(§ pars chainWorkBytes))
        (§ var #_"BigInteger" (§ name chainWork) (§ new #_"BigInteger" (§ pars 1, chainWorkBytes)))
        (§ var #_"int" (§ name height) (§ expr buffer.getInt(§ pars ))) ;; +4 bytes
        (§ var #_"byte[]" (§ name header) (§ new #_"byte[]" (§ count Block/HEADER_SIZE + 1))) ;; Extra byte for the 00 transactions length.
        (§ expr buffer.get(§ pars header, 0, Block/HEADER_SIZE))
        (§ return (§ new #_"StoredBlock" (§ pars params.getDefaultSerializer(§ pars ).makeBlock(§ pars header), chainWork, height)))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr String/format(§ pars Locale/US, "Block %s at height %d: %s", getHeader(§ pars ).getHashAsString(§ pars ), getHeight(§ pars ), getHeader(§ pars ).toString(§ pars ))))
    )
)

#_(ns org.bitcoinj.core #_"StoredUndoableBlock"
    (:import [java.util List]))

;;;
 ; Contains minimal data neccessary to disconnect/connect the transactions
 ; in the stored block at will.  Can either store the full set of
 ; transactions (if the inputs for the block have not been tested to work)
 ; or the set of transaction outputs created/destroyed when the block is
 ; connected.
 ;;
#_public
(§ class #_"StoredUndoableBlock"
    (§ field #_"Sha256Hash" (§ name blockHash))

    ;; Only one of either txOutChanges or transactions will be set.
    #_private
    (§ field #_"TransactionOutputChanges" (§ name txOutChanges))
    #_private
    (§ field #_"List<Transaction>" (§ name transactions))

    #_public
    (§ constructor #_"StoredUndoableBlock" [#_"Sha256Hash" (§ name hash), #_"TransactionOutputChanges" (§ name txOutChanges)])
    (§ block
        (§ ass (§ name this.blockHash) hash)
        (§ ass (§ name this.transactions) nil)
        (§ ass (§ name this.txOutChanges) txOutChanges)
        (§ void this)
    )

    #_public
    (§ constructor #_"StoredUndoableBlock" [#_"Sha256Hash" (§ name hash), #_"List<Transaction>" (§ name transactions)])
    (§ block
        (§ ass (§ name this.blockHash) hash)
        (§ ass (§ name this.txOutChanges) nil)
        (§ ass (§ name this.transactions) transactions)
        (§ void this)
    )

    ;;;
     ; Get the transaction output changes if they have been calculated, otherwise null.
     ; Only one of this and getTransactions() will return a non-null value.
     ;;
    #_public
    (§ method #_"TransactionOutputChanges" (§ fn getTxOutChanges) [])
    (§ block
        (§ return txOutChanges)
    )

    ;;;
     ; Get the full list of transactions if it is stored, otherwise null.
     ; Only one of this and getTxOutChanges() will return a non-null value.
     ;;
    #_public
    (§ method #_"List<Transaction>" (§ fn getTransactions) [])
    (§ block
        (§ return transactions)
    )

    ;;;
     ; Get the hash of the represented block.
     ;;
    #_public
    (§ method #_"Sha256Hash" (§ fn getHash) [])
    (§ block
        (§ return blockHash)
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr blockHash.hashCode(§ pars )))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return (§ expr getHash(§ pars ).equals(§ pars (§ expr (§ cast #_"StoredUndoableBlock" o)).getHash(§ pars ))))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr "Undoable Block " + blockHash))
    )
)

#_(ns org.bitcoinj.core #_"Transaction"
    (:import [java.io *]
             [java.math BigInteger]
             [java.util *])
    (:import [com.google.common.base Preconditions Strings]
             [com.google.common.collect ImmutableMap]
             [com.google.common.primitives Ints Longs]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core.TransactionConfidence ConfidenceType]
             #_static [org.bitcoinj.core.Utils *]
             [org.bitcoinj.crypto TransactionSignature]
             [org.bitcoinj.script Script ScriptBuilder ScriptError ScriptOpCodes]
             [org.bitcoinj.signers TransactionSigner]
             [org.bitcoinj.utils ExchangeRate]
             [org.bitcoinj.wallet Wallet]
             [org.bitcoinj.wallet.WalletTransaction Pool]))

;;;
 ; <p>A transaction represents the movement of coins from some addresses to some other addresses.  It can also represent
 ; the minting of new coins.  A Transaction object corresponds to the equivalent in the Bitcoin C++ implementation.</p>
 ;
 ; <p>Transactions are the fundamental atoms of Bitcoin and have many powerful features.  Read
 ; <a href="https://bitcoinj.github.io/working-with-transactions">"Working with transactions"</a> in the
 ; documentation to learn more about how to use this class.</p>
 ;
 ; <p>All Bitcoin transactions are at risk of being reversed, though the risk is much less than with traditional payment
 ; systems.  Transactions have <i>confidence levels</i>, which help you decide whether to trust a transaction or not.
 ; Whether to trust a transaction is something that needs to be decided on a case by case basis - a rule that makes
 ; sense for selling MP3s might not make sense for selling cars, or accepting payments from a family member.  If you
 ; are building a wallet, how to present confidence to your users is something to consider carefully.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"Transaction" (§ extends #_"ChildMessage")
    ;;;
     ; A comparator that can be used to sort transactions by their updateTime field.
     ; The ordering goes from most recent into the past.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"Comparator<Transaction>" (§ name SORT_TX_BY_UPDATE_TIME) (§ new #_"Comparator<Transaction>" (§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"int" (§ fn compare) [#_final #_"Transaction" (§ name tx1), #_final #_"Transaction" (§ name tx2)])
            (§ block
                #_final
                (§ var #_"long" (§ name time1) (§ expr tx1.getUpdateTime(§ pars ).getTime(§ pars )))
                #_final
                (§ var #_"long" (§ name time2) (§ expr tx2.getUpdateTime(§ pars ).getTime(§ pars )))
                #_final
                (§ var #_"int" (§ name updateTimeComparison) (§ expr (§ neg Longs/compare(§ pars time1, time2))))
                ;; If time1 == time2, compare by tx hash to make comparator consistent with equals.
                (§ return (§ quest (§ expr updateTimeComparison != 0) ? updateTimeComparison :else (§ dot tx1.getHash(§ pars ).compareTo(§ pars tx2.getHash(§ pars )))))
            )
        )))

    ;;; A comparator that can be used to sort transactions by their chain height. ;;
    #_public
    #_static
    #_final
    (§ field #_"Comparator<Transaction>" (§ name SORT_TX_BY_HEIGHT) (§ new #_"Comparator<Transaction>" (§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"int" (§ fn compare) [#_final #_"Transaction" (§ name tx1), #_final #_"Transaction" (§ name tx2)])
            (§ block
                #_final
                (§ var #_"TransactionConfidence" (§ name confidence1) (§ expr tx1.getConfidence(§ pars )))
                #_final
                (§ var #_"int" (§ name height1) (§ quest (§ expr confidence1.getConfidenceType(§ pars ) == ConfidenceType/BUILDING) ? (§ expr confidence1.getAppearedAtChainHeight(§ pars )) :else (§ expr Block/BLOCK_HEIGHT_UNKNOWN)))
                #_final
                (§ var #_"TransactionConfidence" (§ name confidence2) (§ expr tx2.getConfidence(§ pars )))
                #_final
                (§ var #_"int" (§ name height2) (§ quest (§ expr confidence2.getConfidenceType(§ pars ) == ConfidenceType/BUILDING) ? (§ expr confidence2.getAppearedAtChainHeight(§ pars )) :else (§ expr Block/BLOCK_HEIGHT_UNKNOWN)))
                #_final
                (§ var #_"int" (§ name heightComparison) (§ expr (§ neg Ints/compare(§ pars height1, height2))))
                ;; If height1 == height2, compare by tx hash to make comparator consistent with equals.
                (§ return (§ quest (§ expr heightComparison != 0) ? heightComparison :else (§ dot tx1.getHash(§ pars ).compareTo(§ pars tx2.getHash(§ pars )))))
            )
        )))

    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"Transaction"))))

    ;;; Threshold for lockTime: below this value it is interpreted as block number, otherwise as timestamp. ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name LOCKTIME_THRESHOLD) 500000000) ;; Tue Nov  5 00:53:20 1985 UTC
    ;;; Same, but as a BigInteger for CHECKLOCKTIMEVERIFY. ;;
    #_public
    #_static
    #_final
    (§ field #_"BigInteger" (§ name LOCKTIME_THRESHOLD_BIG) (§ expr BigInteger/valueOf(§ pars LOCKTIME_THRESHOLD)))

    ;;; How many bytes a transaction can be before it won't be relayed anymore.  Currently 100kb. ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name MAX_STANDARD_TX_SIZE) 100000)

    ;;;
     ; If feePerKb is lower than this, Bitcoin Core will treat it as if there were no fee.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"Coin" (§ name REFERENCE_DEFAULT_MIN_TX_FEE) (§ expr Coin/valueOf(§ pars 5000))) ;; 0.05 mBTC

    ;;;
     ; If using this feePerKb, transactions will get confirmed within the next couple of blocks.
     ; This should be adjusted from time to time.  Last adjustment: February 2017.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"Coin" (§ name DEFAULT_TX_FEE) (§ expr Coin/valueOf(§ pars 100000))) ;; 1 mBTC

    ;;;
     ; Any standard (i.e. pay-to-address) output smaller than this value (in satoshis) will most likely be rejected by the network.
     ; This is calculated by assuming a standard output will be 34 bytes, and then using the formula used in
     ; {@link TransactionOutput#getMinNonDustValue(Coin)}.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"Coin" (§ name MIN_NONDUST_OUTPUT) (§ expr Coin/valueOf(§ pars 2730))) ;; satoshis

    ;; These are bitcoin serialized.
    #_private
    (§ field #_"long" (§ name version))
    #_private
    (§ field #_"ArrayList<TransactionInput>" (§ name inputs))
    #_private
    (§ field #_"ArrayList<TransactionOutput>" (§ name outputs))

    #_private
    (§ field #_"long" (§ name lockTime))

    ;; This is either the time the transaction was broadcast as measured from the local clock, or the time from the
    ;; block in which it was included.  Note that this can be changed by re-orgs so the wallet may update this field.
    ;; Old serialized transactions don't have this field, thus null is valid.  It is used for returning an ordered
    ;; list of transactions from a wallet, which is helpful for presenting to users.
    #_private
    (§ field #_"Date" (§ name updatedAt))

    ;; This is an in memory helper only.
    #_private
    (§ field #_"Sha256Hash" (§ name hash))

    ;; Data about how confirmed this tx is.  Serialized, may be null.
    #_nilable
    #_private
    (§ field #_"TransactionConfidence" (§ name confidence))

    ;; Records a map of which blocks the transaction has appeared in (keys) to an index within that block (values).
    ;; The "index" is not a real index, instead the values are only meaningful relative to each other.  For example,
    ;; consider two transactions that appear in the same block, t1 and t2, where t2 spends an output of t1.  Both
    ;; will have the same block hash as a key in their appearsInHashes, but the counter would be 1 and 2 respectively
    ;; regardless of where they actually appeared in the block.
    ;;
    ;; If this transaction is not stored in the wallet, appearsInHashes is null.
    #_private
    (§ field #_"Map<Sha256Hash, Integer>" (§ name appearsInHashes))

    ;; Transactions can be encoded in a way that will use more bytes than is optimal
    ;; (due to VarInts having multiple encodings).
    ;; MAX_BLOCK_SIZE must be compared to the optimal encoding, not the actual encoding, so when parsing, we keep track
    ;; of the size of the ideal encoding in addition to the actual message size (which Message needs) so that Blocks
    ;; can properly keep track of optimal encoded size.
    #_private
    (§ field #_"int" (§ name optimalEncodingMessageSize))

    ;;;
     ; This enum describes the underlying reason the transaction was created.  It's useful for rendering wallet GUIs
     ; more appropriately.
     ;;
    #_public
    (§ enum #_"Purpose"
        ;;; Used when the purpose of a transaction is genuinely unknown. ;;
        (§ item UNKNOWN)
        ;;; Transaction created to satisfy a user payment request. ;;
        (§ item USER_PAYMENT)
        ;;; Transaction automatically created and broadcast in order to reallocate money from old to new keys. ;;
        (§ item KEY_ROTATION)
        ;;; Transaction that uses up pledges to an assurance contract. ;;
        (§ item ASSURANCE_CONTRACT_CLAIM)
        ;;; Transaction that makes a pledge to an assurance contract. ;;
        (§ item ASSURANCE_CONTRACT_PLEDGE)
        ;;; Send-to-self transaction that exists just to create an output of the right size we can pledge. ;;
        (§ item ASSURANCE_CONTRACT_STUB)
        ;;; Raise fee, e.g. child-pays-for-parent. ;;
        (§ item RAISE_FEE)
        ;; In future: de/refragmentation, privacy boosting/mixing, etc.
        ;; When adding a value, it also needs to be added to wallet.proto, WalletProtobufSerialize.makeTxProto()
        ;; and WalletProtobufSerializer.readTransaction()!
    )

    #_private
    (§ field #_"Purpose" (§ name purpose) (§ expr Purpose/UNKNOWN))

    ;;;
     ; This field can be used by applications to record the exchange rate that was valid when the transaction happened.
     ; It's optional.
     ;;
    #_nilable
    #_private
    (§ field #_"ExchangeRate" (§ name exchangeRate))

    ;;;
     ; This field can be used to record the memo of the payment request that initiated the transaction.
     ; It's optional.
     ;;
    #_nilable
    #_private
    (§ field #_"String" (§ name memo))

    ;; Below flags apply in the context of BIP 68.
     ; If this flag set, CTxIn::nSequence is NOT interpreted as a relative lock-time.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"long" (§ name SEQUENCE_LOCKTIME_DISABLE_FLAG) (§ expr 1 << 31))

    ;; If CTxIn::nSequence encodes a relative lock-time and this flag
     ; is set, the relative lock-time has units of 512 seconds,
     ; otherwise it specifies blocks with a granularity of 1.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"long" (§ name SEQUENCE_LOCKTIME_TYPE_FLAG) (§ expr 1 << 22))

    ;; If CTxIn::nSequence encodes a relative lock-time, this mask is
     ; applied to extract that lock-time from the sequence field.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"long" (§ name SEQUENCE_LOCKTIME_MASK) (§ expr 0x0000ffff))

    #_public
    (§ constructor #_"Transaction" [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ super (§ pars params))

        (§ ass (§ name version) 1)
        (§ ass (§ name inputs) (§ new #_"ArrayList<>" (§ pars )))
        (§ ass (§ name outputs) (§ new #_"ArrayList<>" (§ pars )))
        ;; We don't initialize appearsIn deliberately as it's only useful for transactions stored in the wallet.
        (§ ass (§ name length) 8) ;; 8 for std fields
        (§ void this)
    )

    ;;;
     ; Creates a transaction from the given serialized bytes, e.g. from a block or a tx network message.
     ;;
    #_public
    (§ constructor #_"Transaction" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payloadBytes)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payloadBytes, 0))
        (§ void this)
    )

    ;;;
     ; Creates a transaction by reading payload starting from offset bytes in.  Length of a transaction is fixed.
     ;;
    #_public
    (§ constructor #_"Transaction" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"int" (§ name offset)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, offset))
        ;; inputs/outputs will be created in parse()
        (§ void this)
    )

    ;;;
     ; Creates a transaction by reading payload starting from offset bytes in.  Length of a transaction is fixed.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param parseRetain Whether to retain the backing byte array for quick reserialization.
     ; If true and the backing byte array is invalidated due to modification of a field, then
     ; the cached bytes may be repopulated and retained if the message is serialized again in the future.
     ; @param length The length of message if known.  Usually this is provided when deserializing of the wire
     ; as the length will be provided as part of the header.  Set to Message.UNKNOWN_LENGTH, if not known.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor #_"Transaction" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"int" (§ name offset), #_nilable #_"Message" (§ name parent), #_"MessageSerializer" (§ name setSerializer), #_"int" (§ name length)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, offset, parent, setSerializer, length))
        (§ void this)
    )

    ;;;
     ; Creates a transaction by reading payload.  Length of a transaction is fixed.
     ;;
    #_public
    (§ constructor #_"Transaction" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_nilable #_"Message" (§ name parent), #_"MessageSerializer" (§ name setSerializer), #_"int" (§ name length)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, 0, parent, setSerializer, length))
        (§ void this)
    )

    ;;;
     ; Returns the transaction hash as you see them in the block explorer.
     ;;
    #_override
    #_public
    (§ method #_"Sha256Hash" (§ fn getHash) [])
    (§ block
        (§ if (§ expr hash == nil))
        (§ block
            (§ ass (§ name hash) (§ expr Sha256Hash/wrapReversed(§ pars Sha256Hash/hashTwice(§ pars unsafeBitcoinSerialize(§ pars )))))
        )
        (§ return hash)
    )

    ;;;
     ; Used by BitcoinSerializer.  The serializer has to calculate a hash for checksumming so to
     ; avoid wasting the considerable effort a set method is provided so the serializer can set it.
     ;
     ; No verification is performed on this hash.
     ;;
    (§ method #_"void" (§ fn setHash) [#_"Sha256Hash" (§ name hash)])
    (§ block
        (§ ass (§ name this.hash) hash)
        (§ void nil)
    )

    #_public
    (§ method #_"String" (§ fn getHashAsString) [])
    (§ block
        (§ return (§ expr getHash(§ pars ).toString(§ pars )))
    )

    ;;;
     ; Gets the sum of the inputs, regardless of who owns them.
     ;;
    #_public
    (§ method #_"Coin" (§ fn getInputSum) [])
    (§ block
        (§ var #_"Coin" (§ name inputTotal) (§ expr Coin/ZERO))

        (§ for (§ var #_"TransactionInput" (§ name input)) :for inputs)
        (§ block
            (§ var #_"Coin" (§ name inputValue) (§ expr input.getValue(§ pars )))
            (§ if (§ expr inputValue != nil))
            (§ block
                (§ ass (§ name inputTotal) (§ expr inputTotal.add(§ pars inputValue)))
            )
        )

        (§ return inputTotal)
    )

    ;;;
     ; Calculates the sum of the outputs that are sending coins to a key in the wallet.
     ;;
    #_public
    (§ method #_"Coin" (§ fn getValueSentToMe) [#_"TransactionBag" (§ name transactionBag)])
    (§ block
        ;; This is tested in WalletTest.
        (§ var #_"Coin" (§ name v) (§ expr Coin/ZERO))
        (§ for (§ var #_"TransactionOutput" (§ name o)) :for outputs)
        (§ block
            (§ if (§ expr o.isMine(§ pars transactionBag)))
            (§ block
                (§ ass (§ name v) (§ expr v.add(§ pars o.getValue(§ pars ))))
            )
        )
        (§ return v)
    )

    ;;;
     ; Returns a map of block [hashes] which contain the transaction mapped to relativity counters, or null if this
     ; transaction doesn't have that data because it's not stored in the wallet or because it has never appeared in a
     ; block.
     ;;
    #_nilable
    #_public
    (§ method #_"Map<Sha256Hash, Integer>" (§ fn getAppearsInHashes) [])
    (§ block
        (§ return (§ quest (§ expr appearsInHashes != nil) ? (§ expr ImmutableMap/copyOf(§ pars appearsInHashes)) :else nil))
    )

    ;;;
     ; Convenience wrapper around getConfidence().getConfidenceType().
     ; @return true if this transaction hasn't been seen in any block yet.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isPending) [])
    (§ block
        (§ return (§ expr getConfidence(§ pars ).getConfidenceType(§ pars ) == TransactionConfidence/ConfidenceType/PENDING))
    )

    ;;;
     ; <p>Puts the given block in the internal set of blocks in which this transaction appears.  This is
     ; used by the wallet to ensure transactions that appear on side chains are recorded properly even though
     ; the block stores do not save the transaction data at all.</p>
     ;
     ; <p>If there is a re-org this will be called once for each block that was previously seen, to update which block
     ; is the best chain.  The best chain block is guaranteed to be called last. So this must be idempotent.</p>
     ;
     ; <p>Sets updatedAt to be the earliest valid block time where this tx was seen.</p>
     ;
     ; @param block     The {@link StoredBlock} in which the transaction has appeared.
     ; @param bestChain Whether to set the updatedAt timestamp from the block header (only if not already set).
     ; @param relativityOffset A number that disambiguates the order of transactions within a block.
     ;;
    #_public
    (§ method #_"void" (§ fn setBlockAppearance) [#_"StoredBlock" (§ name block), #_"boolean" (§ name bestChain), #_"int" (§ name relativityOffset)])
    (§ block
        (§ var #_"long" (§ name blockTime) (§ expr block.getHeader(§ pars ).getTimeSeconds(§ pars ) * 1000))
        (§ if (§ expr bestChain && (§ expr updatedAt == nil || updatedAt.getTime(§ pars ) == 0 || blockTime < updatedAt.getTime(§ pars ))))
        (§ block
            (§ ass (§ name updatedAt) (§ new #_"Date" (§ pars blockTime)))
        )

        (§ expr addBlockAppearance(§ pars block.getHeader(§ pars ).getHash(§ pars ), relativityOffset))

        (§ if bestChain)
        (§ block
            (§ var #_"TransactionConfidence" (§ name transactionConfidence) (§ expr getConfidence(§ pars )))
            ;; This sets type to BUILDING and depth to one.
            (§ expr transactionConfidence.setAppearedAtChainHeight(§ pars block.getHeight(§ pars )))
        )
        (§ void nil)
    )

    #_public
    (§ method #_"void" (§ fn addBlockAppearance) [#_final #_"Sha256Hash" (§ name blockHash), #_"int" (§ name relativityOffset)])
    (§ block
        ;; TODO: This could be a lot more memory efficient as we'll typically only store one element.
        (§ if (§ expr appearsInHashes == nil))
        (§ block
            (§ ass (§ name appearsInHashes) (§ new #_"TreeMap<>" (§ pars )))
        )

        (§ expr appearsInHashes.put(§ pars blockHash, relativityOffset))
        (§ void nil)
    )

    ;;;
     ; Calculates the sum of the inputs that are spending coins with keys in the wallet.  This requires the
     ; transactions sending coins to those keys to be in the wallet.  This method will not attempt to download
     ; the blocks containing the input transactions if the key is in the wallet but the transactions are not.
     ;
     ; @return sum of the inputs that are spending coins with keys in the wallet.
     ;;
    #_public
    (§ method #_"Coin" (§ fn getValueSentFromMe) [#_"TransactionBag" (§ name wallet)])
        (§ throws #_"ScriptException")
    (§ block
        ;; This is tested in WalletTest.
        (§ var #_"Coin" (§ name v) (§ expr Coin/ZERO))
        (§ for (§ var #_"TransactionInput" (§ name input)) :for inputs)
        (§ block
            ;; This input is taking value from a transaction in our wallet.  To discover the value,
            ;; we must find the connected transaction.
            (§ var #_"TransactionOutput" (§ name connected) (§ expr input.getConnectedOutput(§ pars wallet.getTransactionPool(§ pars Pool/UNSPENT))))
            (§ if (§ expr connected == nil))
            (§ block
                (§ ass (§ name connected) (§ expr input.getConnectedOutput(§ pars wallet.getTransactionPool(§ pars Pool/SPENT))))
            )
            (§ if (§ expr connected == nil))
            (§ block
                (§ ass (§ name connected) (§ expr input.getConnectedOutput(§ pars wallet.getTransactionPool(§ pars Pool/PENDING))))
            )

            ;; The connected output may be the change to the sender of a previous input sent to this wallet.
            ;; In this case we ignore it.
            (§ if (§ expr connected != nil && connected.isMine(§ pars wallet)))
            (§ block
                (§ ass (§ name v) (§ expr v.add(§ pars connected.getValue(§ pars ))))
            )
        )
        (§ return v)
    )

    ;;;
     ; Gets the sum of the outputs of the transaction.  If the outputs are less than the inputs, it does not count the fee.
     ; @return the sum of the outputs regardless of who owns them.
     ;;
    #_public
    (§ method #_"Coin" (§ fn getOutputSum) [])
    (§ block
        (§ var #_"Coin" (§ name totalOut) (§ expr Coin/ZERO))

        (§ for (§ var #_"TransactionOutput" (§ name output)) :for outputs)
        (§ block
            (§ ass (§ name totalOut) (§ expr totalOut.add(§ pars output.getValue(§ pars ))))
        )

        (§ return totalOut)
    )

    #_nilable
    #_private
    (§ field #_"Coin" (§ name cachedValue))
    #_nilable
    #_private
    (§ field #_"TransactionBag" (§ name cachedForBag))

    ;;;
     ; Returns the difference of {@link Transaction#getValueSentToMe(TransactionBag)} and {@link Transaction#getValueSentFromMe(TransactionBag)}.
     ;;
    #_public
    (§ method #_"Coin" (§ fn getValue) [#_"TransactionBag" (§ name wallet)])
        (§ throws #_"ScriptException")
    (§ block
        ;; FIXME: TEMP PERF HACK FOR ANDROID - this crap can go away once we have a real payments API.
        (§ var #_"boolean" (§ name isAndroid) (§ expr Utils/isAndroidRuntime(§ pars )))
        (§ if (§ expr isAndroid && cachedValue != nil && cachedForBag == wallet))
        (§ block
            (§ return cachedValue)
        )

        (§ var #_"Coin" (§ name result) (§ expr getValueSentToMe(§ pars wallet).subtract(§ pars getValueSentFromMe(§ pars wallet))))
        (§ if isAndroid)
        (§ block
            (§ ass (§ name cachedValue) result)
            (§ ass (§ name cachedForBag) wallet)
        )
        (§ return result)
    )

    ;;;
     ; The transaction fee is the difference of the value of all inputs and the value of all outputs.
     ; Currently, the fee can only be determined for transactions created by us.
     ;
     ; @return fee, or null if it cannot be determined.
     ;;
    #_public
    (§ method #_"Coin" (§ fn getFee) [])
    (§ block
        (§ var #_"Coin" (§ name fee) (§ expr Coin/ZERO))
        (§ if (§ expr inputs.isEmpty(§ pars ) || outputs.isEmpty(§ pars ))) ;; Incomplete transaction.
        (§ block
            (§ return nil)
        )

        (§ for (§ var #_"TransactionInput" (§ name input)) :for inputs)
        (§ block
            (§ if (§ expr input.getValue(§ pars ) == nil))
            (§ block
                (§ return nil)
            )
            (§ ass (§ name fee) (§ expr fee.add(§ pars input.getValue(§ pars ))))
        )
        (§ for (§ var #_"TransactionOutput" (§ name output)) :for outputs)
        (§ block
            (§ ass (§ name fee) (§ expr fee.subtract(§ pars output.getValue(§ pars ))))
        )
        (§ return fee)
    )

    ;;;
     ; Returns true if any of the outputs is marked as spent.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isAnyOutputSpent) [])
    (§ block
        (§ for (§ var #_"TransactionOutput" (§ name output)) :for outputs)
        (§ block
            (§ if (§ expr (§ not output.isAvailableForSpending(§ pars ))))
            (§ block
                (§ return true)
            )
        )

        (§ return false)
    )

    ;;;
     ; Returns false if this transaction has at least one output that is owned by the given wallet and unspent,
     ; true otherwise.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isEveryOwnedOutputSpent) [#_"TransactionBag" (§ name transactionBag)])
    (§ block
        (§ for (§ var #_"TransactionOutput" (§ name output)) :for outputs)
        (§ block
            (§ if (§ expr output.isAvailableForSpending(§ pars ) && output.isMine(§ pars transactionBag)))
            (§ block
                (§ return false)
            )
        )

        (§ return true)
    )

    ;;;
     ; Returns the earliest time at which the transaction was seen (broadcast or included into the chain),
     ; or the epoch if that information isn't available.
     ;;
    #_public
    (§ method #_"Date" (§ fn getUpdateTime) [])
    (§ block
        ;; Older wallets did not store this field.  Set to the epoch.
        (§ if (§ expr updatedAt == nil))
        (§ block
            (§ ass (§ name updatedAt) (§ new #_"Date" (§ pars 0)))
        )
        (§ return updatedAt)
    )

    #_public
    (§ method #_"void" (§ fn setUpdateTime) [#_"Date" (§ name updatedAt)])
    (§ block
        (§ ass (§ name this.updatedAt) updatedAt)
        (§ void nil)
    )

    ;;;
     ; These constants are a part of a scriptSig signature on the inputs.  They define the details of how a
     ; transaction can be redeemed, specifically, they control how the hash of the transaction is calculated.
     ;;
    #_public
    (§ enum #_"SigHash"
        (§ item ALL(§ pars 1))
        (§ item NONE(§ pars 2))
        (§ item SINGLE(§ pars 3))
        (§ item ANYONECANPAY(§ pars 0x80)) ;; Caution: Using this type in isolation is non-standard.  Treated similar to ANYONECANPAY_ALL.
        (§ item ANYONECANPAY_ALL(§ pars 0x81))
        (§ item ANYONECANPAY_NONE(§ pars 0x82))
        (§ item ANYONECANPAY_SINGLE(§ pars 0x83))
        (§ item UNSET(§ pars 0)) ;; Caution: Using this type in isolation is non-standard.  Treated similar to ALL.

        #_public
        #_final
        (§ field #_"int" (§ name value))

        ;;;
         ; @param value
         ;;
        #_private
        (§ constructor #_"SigHash" [#_final #_"int" (§ name value)])
        (§ block
            (§ ass (§ name this.value) value)
            (§ void this)
        )

        ;;;
         ; @return the value as a byte.
         ;;
        #_public
        (§ method #_"byte" (§ fn byteValue) [])
        (§ block
            (§ return (§ cast #_"byte" this.value))
        )
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn unCache) [])
    (§ block
        (§ expr super.unCache(§ pars ))
        (§ ass (§ name hash) nil)
        (§ void nil)
    )

    #_protected
    #_static
    (§ method #_"int" (§ fn calcLength) [#_"byte[]" (§ name buf), #_"int" (§ name offset)])
    (§ block
        ;; jump past version (uint32)
        (§ var #_"int" (§ name cursor) (§ expr offset + 4))

        (§ var #_"VarInt" (§ name varint) (§ new #_"VarInt" (§ pars buf, cursor)))
        (§ var #_"long" (§ name txInCount) (§ expr varint.value))
        (§ ass (§ name cursor) (§ expr cursor + varint.getOriginalSizeInBytes(§ pars )))

        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < txInCount) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            ;; 36 = length of previous_outpoint
            (§ ass (§ name cursor) (§ expr cursor + 36))
            (§ ass (§ name varint) (§ new #_"VarInt" (§ pars buf, cursor)))
            (§ var #_"long" (§ name scriptLen) (§ expr varint.value))
            ;; 4 = length of sequence field (unint32)
            (§ ass (§ name cursor) (§ expr cursor + scriptLen + 4 + varint.getOriginalSizeInBytes(§ pars )))
        )

        (§ ass (§ name varint) (§ new #_"VarInt" (§ pars buf, cursor)))
        (§ var #_"long" (§ name txOutCount) (§ expr varint.value))
        (§ ass (§ name cursor) (§ expr cursor + varint.getOriginalSizeInBytes(§ pars )))

        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < txOutCount) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            ;; 8 = length of tx value field (uint64)
            (§ ass (§ name cursor) (§ expr cursor + 8))
            (§ ass (§ name varint) (§ new #_"VarInt" (§ pars buf, cursor)))
            (§ var #_"long" (§ name scriptLen) (§ expr varint.value))
            (§ ass (§ name cursor) (§ expr cursor + scriptLen + varint.getOriginalSizeInBytes(§ pars )))
        )
        ;; 4 = length of lock_time field (uint32)
        (§ return (§ expr cursor - offset + 4))
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ ass (§ name cursor) offset)

        (§ ass (§ name version) (§ expr readUint32(§ pars )))
        (§ ass (§ name optimalEncodingMessageSize) 4)

        ;; First come the inputs.
        (§ var #_"long" (§ name numInputs) (§ expr readVarInt(§ pars )))
        (§ ass (§ name optimalEncodingMessageSize) (§ expr optimalEncodingMessageSize + VarInt/sizeOf(§ pars numInputs)))
        (§ ass (§ name inputs) (§ new #_"ArrayList<>" (§ pars (§ cast #_"int" numInputs))))
        (§ for (§ var #_"long" (§ name i) 0) :for (§ expr i < numInputs) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ var #_"TransactionInput" (§ name input) (§ new #_"TransactionInput" (§ pars params, this, payload, cursor, serializer)))
            (§ expr inputs.add(§ pars input))
            (§ var #_"long" (§ name scriptLen) (§ expr readVarInt(§ pars TransactionOutPoint/MESSAGE_LENGTH)))
            (§ ass (§ name optimalEncodingMessageSize) (§ expr optimalEncodingMessageSize + TransactionOutPoint/MESSAGE_LENGTH + VarInt/sizeOf(§ pars scriptLen) + scriptLen + 4))
            (§ ass (§ name cursor) (§ expr cursor + scriptLen + 4))
        )
        ;; Now the outputs.
        (§ var #_"long" (§ name numOutputs) (§ expr readVarInt(§ pars )))
        (§ ass (§ name optimalEncodingMessageSize) (§ expr optimalEncodingMessageSize + VarInt/sizeOf(§ pars numOutputs)))
        (§ ass (§ name outputs) (§ new #_"ArrayList<>" (§ pars (§ cast #_"int" numOutputs))))
        (§ for (§ var #_"long" (§ name i) 0) :for (§ expr i < numOutputs) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ var #_"TransactionOutput" (§ name output) (§ new #_"TransactionOutput" (§ pars params, this, payload, cursor, serializer)))
            (§ expr outputs.add(§ pars output))
            (§ var #_"long" (§ name scriptLen) (§ expr readVarInt(§ pars 8)))
            (§ ass (§ name optimalEncodingMessageSize) (§ expr optimalEncodingMessageSize + 8 + VarInt/sizeOf(§ pars scriptLen) + scriptLen))
            (§ ass (§ name cursor) (§ expr cursor + scriptLen))
        )
        (§ ass (§ name lockTime) (§ expr readUint32(§ pars )))
        (§ ass (§ name optimalEncodingMessageSize) (§ expr optimalEncodingMessageSize + 4))
        (§ ass (§ name length) (§ expr cursor - offset))
        (§ void nil)
    )

    #_public
    (§ method #_"int" (§ fn getOptimalEncodingMessageSize) [])
    (§ block
        (§ if (§ expr optimalEncodingMessageSize != 0))
        (§ block
            (§ return optimalEncodingMessageSize)
        )

        (§ ass (§ name optimalEncodingMessageSize) (§ expr getMessageSize(§ pars )))
        (§ return optimalEncodingMessageSize)
    )

    ;;;
     ; The priority (coin age) calculation doesn't use the regular message size, but rather one adjusted downwards
     ; for the number of inputs.  The goal is to incentivise cleaning up the UTXO set with free transactions, if one
     ; can do so.
     ;;
    #_public
    (§ method #_"int" (§ fn getMessageSizeForPriorityCalc) [])
    (§ block
        (§ var #_"int" (§ name size) (§ expr getMessageSize(§ pars )))
        (§ for (§ var #_"TransactionInput" (§ name input)) :for inputs)
        (§ block
            ;; 41: min size of an input
            ;; 110: enough to cover a compressed pubkey p2sh redemption (somewhat arbitrary)
            (§ var #_"int" (§ name benefit) (§ expr 41 + Math/min(§ pars 110, input.getScriptSig(§ pars ).getProgram(§ pars ).length)))
            (§ if (§ expr benefit < size))
            (§ block
                (§ ass (§ name size) (§ expr size - benefit))
            )
        )
        (§ return size)
    )

    ;;;
     ; A coinbase transaction is one that creates a new coin.  They are the first transaction in each block and their
     ; value is determined by a formula that all implementations of Bitcoin share.  In 2011 the value of a coinbase
     ; transaction is 50 coins, but in future it will be less.  A coinbase transaction is defined not only by its
     ; position in a block but by the data in the inputs.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isCoinBase) [])
    (§ block
        (§ return (§ expr inputs.size(§ pars ) == 1 && inputs.get(§ pars 0).isCoinBase(§ pars )))
    )

    ;;;
     ; A transaction is mature if it is either a building coinbase tx that is as deep or deeper than the required coinbase depth, or a non-coinbase tx.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isMature) [])
    (§ block
        (§ if (§ expr (§ not isCoinBase(§ pars ))))
        (§ block
            (§ return true)
        )

        (§ if (§ expr getConfidence(§ pars ).getConfidenceType(§ pars ) != ConfidenceType/BUILDING))
        (§ block
            (§ return false)
        )

        (§ return (§ expr params.getSpendableCoinbaseDepth(§ pars ) <= getConfidence(§ pars ).getDepthInBlocks(§ pars )))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr toString(§ pars nil)))
    )

    ;;;
     ; A human readable version of the transaction useful for debugging.  The format is not guaranteed to be stable.
     ; @param chain If provided, will be used to estimate lock times (if set).  Can be null.
     ;;
    #_public
    (§ method #_"String" (§ fn toString) [#_nilable #_"AbstractBlockChain" (§ name chain)])
    (§ block
        (§ var #_"StringBuilder" (§ name sb) (§ new #_"StringBuilder" (§ pars )))
        (§ expr sb.append(§ pars "  ").append(§ pars getHashAsString(§ pars )).append(§ pars "\n"))
        (§ if (§ expr updatedAt != nil))
        (§ block
            (§ expr sb.append(§ pars "  updated: ").append(§ pars Utils/dateTimeFormat(§ pars updatedAt)).append(§ pars "\n"))
        )
        (§ if (§ expr version != 1))
        (§ block
            (§ expr sb.append(§ pars "  version ").append(§ pars version).append(§ pars "\n"))
        )
        (§ if (§ expr isTimeLocked(§ pars )))
        (§ block
            (§ expr sb.append(§ pars "  time locked until "))
            (§ if (§ expr lockTime < LOCKTIME_THRESHOLD))
            (§ block
                (§ expr sb.append(§ pars "block ").append(§ pars lockTime))
                (§ if (§ expr chain != nil))
                (§ block
                    (§ expr sb.append(§ pars " (estimated to be reached at ").append(§ pars Utils/dateTimeFormat(§ pars chain.estimateBlockTime(§ pars (§ cast #_"int" lockTime)))).append(§ pars ")"))
                )
            )
            (§ else )
            (§ block
                (§ expr sb.append(§ pars Utils/dateTimeFormat(§ pars lockTime * 1000)))
            )
            (§ expr sb.append(§ pars "\n"))
        )
        (§ if (§ expr isOptInFullRBF(§ pars )))
        (§ block
            (§ expr sb.append(§ pars "  opts into full replace-by-fee\n"))
        )
        (§ if (§ expr isCoinBase(§ pars )))
        (§ block
            (§ var #_"String" (§ name script))
            (§ var #_"String" (§ name script2))
            (§ try )
            (§ block
                (§ ass (§ name script) (§ expr inputs.get(§ pars 0).getScriptSig(§ pars ).toString(§ pars )))
                (§ ass (§ name script2) (§ expr outputs.get(§ pars 0).getScriptPubKey(§ pars ).toString(§ pars )))
            )
            (§ catch #_"ScriptException" (§ name _))
            (§ block
                (§ ass (§ name script) (§ expr "???"))
                (§ ass (§ name script2) (§ expr "???"))
            )
            (§ expr sb.append(§ pars "     == COINBASE TXN (scriptSig ").append(§ pars script).append(§ pars ")  (scriptPubKey ").append(§ pars script2).append(§ pars ")\n"))
            (§ return (§ expr sb.toString(§ pars )))
        )

        (§ if (§ expr (§ not inputs.isEmpty(§ pars ))))
        (§ block
            (§ for (§ var #_"TransactionInput" (§ name in)) :for inputs)
            (§ block
                (§ expr sb.append(§ pars "     in   "))

                (§ try )
                (§ block
                    (§ var #_"String" (§ name scriptSigStr) (§ expr in.getScriptSig(§ pars ).toString(§ pars )))
                    (§ expr sb.append(§ pars (§ quest (§ not Strings/isNullOrEmpty(§ pars scriptSigStr)) ? scriptSigStr :else (§ expr "<no scriptSig>"))))
                    #_final
                    (§ var #_"Coin" (§ name value) (§ expr in.getValue(§ pars )))
                    (§ if (§ expr value != nil))
                    (§ block
                        (§ expr sb.append(§ pars " ").append(§ pars value.toFriendlyString(§ pars )))
                    )
                    (§ expr sb.append(§ pars "\n          outpoint:"))
                    #_final
                    (§ var #_"TransactionOutPoint" (§ name outpoint) (§ expr in.getOutpoint(§ pars )))
                    (§ expr sb.append(§ pars outpoint.toString(§ pars )))
                    #_final
                    (§ var #_"TransactionOutput" (§ name connectedOutput) (§ expr outpoint.getConnectedOutput(§ pars )))
                    (§ if (§ expr connectedOutput != nil))
                    (§ block
                        (§ var #_"Script" (§ name scriptPubKey) (§ expr connectedOutput.getScriptPubKey(§ pars )))
                        (§ if (§ expr scriptPubKey.isSentToAddress(§ pars ) || scriptPubKey.isPayToScriptHash(§ pars )))
                        (§ block
                            (§ expr sb.append(§ pars " hash160:").append(§ pars Utils/HEX.encode(§ pars scriptPubKey.getPubKeyHash(§ pars ))))
                        )
                    )
                    (§ if (§ expr in.hasSequence(§ pars )))
                    (§ block
                        (§ expr sb.append(§ pars "\n          sequence:").append(§ pars Long/toHexString(§ pars in.getSequenceNumber(§ pars ))))
                        (§ if (§ expr in.isOptInFullRBF(§ pars )))
                        (§ block
                            (§ expr sb.append(§ pars ", opts into full RBF"))
                        )
                    )
                )
                (§ catch #_"Exception" (§ name e))
                (§ block
                    (§ expr sb.append(§ pars "[exception: ").append(§ pars e.getMessage(§ pars )).append(§ pars "]"))
                )
                (§ expr sb.append(§ pars "\n"))
            )
        )
        (§ else )
        (§ block
            (§ expr sb.append(§ pars "     INCOMPLETE: No inputs!\n"))
        )

        (§ for (§ var #_"TransactionOutput" (§ name out)) :for outputs)
        (§ block
            (§ expr sb.append(§ pars "     out  "))
            (§ try )
            (§ block
                (§ var #_"String" (§ name scriptPubKeyStr) (§ expr out.getScriptPubKey(§ pars ).toString(§ pars )))
                (§ dot sb.append(§ pars (§ quest (§ not Strings/isNullOrEmpty(§ pars scriptPubKeyStr)) ? scriptPubKeyStr :else (§ expr "<no scriptPubKey>"))).append(§ pars " ").append(§ pars out.getValue(§ pars ).toFriendlyString(§ pars )))
                (§ if (§ expr (§ not out.isAvailableForSpending(§ pars ))))
                (§ block
                    (§ expr sb.append(§ pars " Spent"))
                )
                #_final
                (§ var #_"TransactionInput" (§ name spentBy) (§ expr out.getSpentBy(§ pars )))
                (§ if (§ expr spentBy != nil))
                (§ block
                    (§ expr sb.append(§ pars " by ").append(§ pars spentBy.getParentTransaction(§ pars ).getHashAsString(§ pars )))
                )
            )
            (§ catch #_"Exception" (§ name e))
            (§ block
                (§ expr sb.append(§ pars "[exception: ").append(§ pars e.getMessage(§ pars )).append(§ pars "]"))
            )
            (§ expr sb.append(§ pars "\n"))
        )

        #_final
        (§ var #_"Coin" (§ name fee) (§ expr getFee(§ pars )))
        (§ if (§ expr fee != nil))
        (§ block
            #_final
            (§ var #_"int" (§ name size) (§ expr unsafeBitcoinSerialize(§ pars ).length))
            (§ expr sb.append(§ pars "     fee  ").append(§ pars fee.multiply(§ pars 1000).divide(§ pars size).toFriendlyString(§ pars )).append(§ pars "/kB, ").append(§ pars fee.toFriendlyString(§ pars )).append(§ pars " for ").append(§ pars size).append(§ pars " bytes\n"))
        )
        (§ if (§ expr purpose != nil))
        (§ block
            (§ expr sb.append(§ pars "     prps ").append(§ pars purpose).append(§ pars "\n"))
        )
        (§ return (§ expr sb.toString(§ pars )))
    )

    ;;;
     ; Removes all the inputs from this transaction.
     ; Note that this also invalidates the length attribute.
     ;;
    #_public
    (§ method #_"void" (§ fn clearInputs) [])
    (§ block
        (§ expr unCache(§ pars ))
        (§ for (§ var #_"TransactionInput" (§ name input)) :for inputs)
        (§ block
            (§ expr input.setParent(§ pars nil))
        )
        (§ expr inputs.clear(§ pars ))
        ;; You wanted to reserialize, right?
        (§ ass (§ name this.length) (§ expr this.unsafeBitcoinSerialize(§ pars ).length))
        (§ void nil)
    )

    ;;;
     ; Adds an input to this transaction that imports value from the given output.  Note that this input is <i>not</i>
     ; complete and after every input is added with {@link #addInput()} and every output is added with {@link #addOutput()},
     ; a {@link TransactionSigner} must be used to finalize the transaction and finish the inputs off.
     ; Otherwise it won't be accepted by the network.
     ; @return the newly created input.
     ;;
    #_public
    (§ method #_"TransactionInput" (§ fn addInput) [#_"TransactionOutput" (§ name from)])
    (§ block
        (§ return (§ expr addInput(§ pars (§ new #_"TransactionInput" (§ pars params, this, from)))))
    )

    ;;;
     ; Adds an input directly, with no checking that it's valid.
     ; @return the new input.
     ;;
    #_public
    (§ method #_"TransactionInput" (§ fn addInput) [#_"TransactionInput" (§ name input)])
    (§ block
        (§ expr unCache(§ pars ))
        (§ expr input.setParent(§ pars this))
        (§ expr inputs.add(§ pars input))
        (§ expr adjustLength(§ pars inputs.size(§ pars ), input.length))
        (§ return input)
    )

    ;;;
     ; Creates and adds an input to this transaction, with no checking that it's valid.
     ; @return the newly created input.
     ;;
    #_public
    (§ method #_"TransactionInput" (§ fn addInput) [#_"Sha256Hash" (§ name spendTxHash), #_"long" (§ name outputIndex), #_"Script" (§ name script)])
    (§ block
        (§ return (§ expr addInput(§ pars (§ new #_"TransactionInput" (§ pars params, this, script.getProgram(§ pars ), new TransactionOutPoint(§ pars params, outputIndex, spendTxHash))))))
    )

    ;;;
     ; Adds a new and fully signed input for the given parameters.  Note that this method is <b>not</b> thread safe
     ; and requires external synchronization.  Please refer to general documentation on Bitcoin scripting and contracts
     ; to understand the values of sigHash and anyoneCanPay: otherwise you can use the other form of this method
     ; that sets them to typical defaults.
     ;
     ; @throws ScriptException if the scriptPubKey is not a pay to address or pay to pubkey script.
     ;;
    #_public
    (§ method #_"TransactionInput" (§ fn addSignedInput) [#_"TransactionOutPoint" (§ name prevOut), #_"Script" (§ name scriptPubKey), #_"ECKey" (§ name sigKey), #_"SigHash" (§ name sigHash), #_"boolean" (§ name anyoneCanPay)])
        (§ throws #_"ScriptException")
    (§ block
        ;; Verify the API user didn't try to do operations out of order.
        (§ expr Preconditions/checkState(§ pars (§ not outputs.isEmpty(§ pars )), "Attempting to sign tx without outputs."))

        (§ var #_"TransactionInput" (§ name input) (§ new #_"TransactionInput" (§ pars params, this, new byte[] (§ coll ), prevOut)))
        (§ expr addInput(§ pars input))
        (§ var #_"Sha256Hash" (§ name hash) (§ expr hashForSignature(§ pars inputs.size(§ pars ) - 1, scriptPubKey, sigHash, anyoneCanPay)))
        (§ var #_"ECKey.ECDSASignature" (§ name ecSig) (§ expr sigKey.sign(§ pars hash)))
        (§ var #_"TransactionSignature" (§ name txSig) (§ new #_"TransactionSignature" (§ pars ecSig, sigHash, anyoneCanPay)))
        (§ if (§ expr scriptPubKey.isSentToRawPubKey(§ pars )))
        (§ block
            (§ expr input.setScriptSig(§ pars ScriptBuilder/createInputScript(§ pars txSig)))
        )
        (§ elseif (§ expr scriptPubKey.isSentToAddress(§ pars )))
        (§ block
            (§ expr input.setScriptSig(§ pars ScriptBuilder/createInputScript(§ pars txSig, sigKey)))
        )
        (§ else )
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Don't know how to sign for this kind of scriptPubKey: " + scriptPubKey)))
        )
        (§ return input)
    )

    ;;;
     ; Same as {@link #addSignedInput(TransactionOutPoint, org.bitcoinj.script.Script, ECKey, org.bitcoinj.core.Transaction.SigHash, boolean)},
     ; but defaults to {@link SigHash#ALL} and "false" for the anyoneCanPay flag.  This is normally what you want.
     ;;
    #_public
    (§ method #_"TransactionInput" (§ fn addSignedInput) [#_"TransactionOutPoint" (§ name prevOut), #_"Script" (§ name scriptPubKey), #_"ECKey" (§ name sigKey)])
        (§ throws #_"ScriptException")
    (§ block
        (§ return (§ expr addSignedInput(§ pars prevOut, scriptPubKey, sigKey, SigHash/ALL, false)))
    )

    ;;;
     ; Adds an input that points to the given output and contains a valid signature for it, calculated using the
     ; signing key.
     ;;
    #_public
    (§ method #_"TransactionInput" (§ fn addSignedInput) [#_"TransactionOutput" (§ name output), #_"ECKey" (§ name signingKey)])
    (§ block
        (§ return (§ expr addSignedInput(§ pars output.getOutPointFor(§ pars ), output.getScriptPubKey(§ pars ), signingKey)))
    )

    ;;;
     ; Adds an input that points to the given output and contains a valid signature for it, calculated using the
     ; signing key.
     ;;
    #_public
    (§ method #_"TransactionInput" (§ fn addSignedInput) [#_"TransactionOutput" (§ name output), #_"ECKey" (§ name signingKey), #_"SigHash" (§ name sigHash), #_"boolean" (§ name anyoneCanPay)])
    (§ block
        (§ return (§ expr addSignedInput(§ pars output.getOutPointFor(§ pars ), output.getScriptPubKey(§ pars ), signingKey, sigHash, anyoneCanPay)))
    )

    ;;;
     ; Removes all the outputs from this transaction.
     ; Note that this also invalidates the length attribute.
     ;;
    #_public
    (§ method #_"void" (§ fn clearOutputs) [])
    (§ block
        (§ expr unCache(§ pars ))
        (§ for (§ var #_"TransactionOutput" (§ name output)) :for outputs)
        (§ block
            (§ expr output.setParent(§ pars nil))
        )
        (§ expr outputs.clear(§ pars ))
        ;; You wanted to reserialize, right?
        (§ ass (§ name this.length) (§ expr this.unsafeBitcoinSerialize(§ pars ).length))
        (§ void nil)
    )

    ;;;
     ; Adds the given output to this transaction.  The output must be completely initialized.  Returns the given output.
     ;;
    #_public
    (§ method #_"TransactionOutput" (§ fn addOutput) [#_"TransactionOutput" (§ name to)])
    (§ block
        (§ expr unCache(§ pars ))
        (§ expr to.setParent(§ pars this))
        (§ expr outputs.add(§ pars to))
        (§ expr adjustLength(§ pars outputs.size(§ pars ), to.length))
        (§ return to)
    )

    ;;;
     ; Creates an output based on the given address and value, adds it to this transaction, and returns the new output.
     ;;
    #_public
    (§ method #_"TransactionOutput" (§ fn addOutput) [#_"Coin" (§ name value), #_"Address" (§ name address)])
    (§ block
        (§ return (§ expr addOutput(§ pars (§ new #_"TransactionOutput" (§ pars params, this, value, address)))))
    )

    ;;;
     ; Creates an output that pays to the given pubkey directly (no address) with the given value, adds it to this
     ; transaction, and returns the new output.
     ;;
    #_public
    (§ method #_"TransactionOutput" (§ fn addOutput) [#_"Coin" (§ name value), #_"ECKey" (§ name pubkey)])
    (§ block
        (§ return (§ expr addOutput(§ pars (§ new #_"TransactionOutput" (§ pars params, this, value, pubkey)))))
    )

    ;;;
     ; Creates an output that pays to the given script.  The address and key forms are specialisations of this method,
     ; you won't normally need to use it unless you're doing unusual things.
     ;;
    #_public
    (§ method #_"TransactionOutput" (§ fn addOutput) [#_"Coin" (§ name value), #_"Script" (§ name script)])
    (§ block
        (§ return (§ expr addOutput(§ pars (§ new #_"TransactionOutput" (§ pars params, this, value, script.getProgram(§ pars ))))))
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.  The key
     ; must be usable for signing as-is: if the key is encrypted it must be decrypted first external to this method.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param redeemScript Byte-exact contents of the scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
    #_public
    (§ method #_"TransactionSignature" (§ fn calculateSignature) [#_"int" (§ name inputIndex), #_"ECKey" (§ name key), #_"byte[]" (§ name redeemScript), #_"SigHash" (§ name hashType), #_"boolean" (§ name anyoneCanPay)])
    (§ block
        (§ var #_"Sha256Hash" (§ name hash) (§ expr hashForSignature(§ pars inputIndex, redeemScript, hashType, anyoneCanPay)))
        (§ return (§ new #_"TransactionSignature" (§ pars key.sign(§ pars hash), hashType, anyoneCanPay)))
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param redeemScript The scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
    #_public
    (§ method #_"TransactionSignature" (§ fn calculateSignature) [#_"int" (§ name inputIndex), #_"ECKey" (§ name key), #_"Script" (§ name redeemScript), #_"SigHash" (§ name hashType), #_"boolean" (§ name anyoneCanPay)])
    (§ block
        (§ var #_"Sha256Hash" (§ name hash) (§ expr hashForSignature(§ pars inputIndex, redeemScript.getProgram(§ pars ), hashType, anyoneCanPay)))
        (§ return (§ new #_"TransactionSignature" (§ pars key.sign(§ pars hash), hashType, anyoneCanPay)))
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.  The key
     ; must be usable for signing as-is: if the key is encrypted it must be decrypted first external to this method.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param aesKey The AES key to use for decryption of the private key.  If null then no decryption is required.
     ; @param redeemScript Byte-exact contents of the scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
    #_public
    (§ method #_"TransactionSignature" (§ fn calculateSignature) [#_"int" (§ name inputIndex), #_"ECKey" (§ name key), #_nilable #_"KeyParameter" (§ name aesKey), #_"byte[]" (§ name redeemScript), #_"SigHash" (§ name hashType), #_"boolean" (§ name anyoneCanPay)])
    (§ block
        (§ var #_"Sha256Hash" (§ name hash) (§ expr hashForSignature(§ pars inputIndex, redeemScript, hashType, anyoneCanPay)))
        (§ return (§ new #_"TransactionSignature" (§ pars key.sign(§ pars hash, aesKey), hashType, anyoneCanPay)))
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], org.bitcoinj.core.Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param aesKey The AES key to use for decryption of the private key.  If null then no decryption is required.
     ; @param redeemScript The scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
    #_public
    (§ method #_"TransactionSignature" (§ fn calculateSignature) [#_"int" (§ name inputIndex), #_"ECKey" (§ name key), #_nilable #_"KeyParameter" (§ name aesKey), #_"Script" (§ name redeemScript), #_"SigHash" (§ name hashType), #_"boolean" (§ name anyoneCanPay)])
    (§ block
        (§ var #_"Sha256Hash" (§ name hash) (§ expr hashForSignature(§ pars inputIndex, redeemScript.getProgram(§ pars ), hashType, anyoneCanPay)))
        (§ return (§ new #_"TransactionSignature" (§ pars key.sign(§ pars hash, aesKey), hashType, anyoneCanPay)))
    )

    ;;;
     ; <p>Calculates a signature hash, that is, a hash of a simplified form of the transaction.  How exactly the transaction
     ; is simplified is specified by the type and anyoneCanPay parameters.</p>
     ;
     ; <p>This is a low level API and when using the regular {@link Wallet} class you don't have to call this yourself.
     ; When working with more complex transaction types and contracts, it can be necessary.  When signing a P2SH output
     ; the redeemScript should be the script encoded into the scriptSig field, for normal transactions, it's the
     ; scriptPubKey of the output you're signing for.</p>
     ;
     ; @param inputIndex Input the signature is being calculated for.  Tx signatures are always relative to an input.
     ; @param redeemScript The bytes that should be in the given input during signing.
     ; @param type Should be SigHash.ALL.
     ; @param anyoneCanPay Should be false.
     ;;
    #_public
    (§ method #_"Sha256Hash" (§ fn hashForSignature) [#_"int" (§ name inputIndex), #_"byte[]" (§ name redeemScript), #_"SigHash" (§ name type), #_"boolean" (§ name anyoneCanPay)])
    (§ block
        (§ var #_"byte" (§ name sigHashType) (§ expr (§ cast #_"byte" (§ expr TransactionSignature/calcSigHashValue(§ pars type, anyoneCanPay)))))
        (§ return (§ expr hashForSignature(§ pars inputIndex, redeemScript, sigHashType)))
    )

    ;;;
     ; <p>Calculates a signature hash, that is, a hash of a simplified form of the transaction.  How exactly the transaction
     ; is simplified is specified by the type and anyoneCanPay parameters.</p>
     ;
     ; <p>This is a low level API and when using the regular {@link Wallet} class you don't have to call this yourself.
     ; When working with more complex transaction types and contracts, it can be necessary.  When signing a P2SH output
     ; the redeemScript should be the script encoded into the scriptSig field, for normal transactions, it's the
     ; scriptPubKey of the output you're signing for.</p>
     ;
     ; @param inputIndex Input the signature is being calculated for.  Tx signatures are always relative to an input.
     ; @param redeemScript The script that should be in the given input during signing.
     ; @param type Should be SigHash.ALL.
     ; @param anyoneCanPay Should be false.
     ;;
    #_public
    (§ method #_"Sha256Hash" (§ fn hashForSignature) [#_"int" (§ name inputIndex), #_"Script" (§ name redeemScript), #_"SigHash" (§ name type), #_"boolean" (§ name anyoneCanPay)])
    (§ block
        (§ var #_"int" (§ name sigHash) (§ expr TransactionSignature/calcSigHashValue(§ pars type, anyoneCanPay)))
        (§ return (§ expr hashForSignature(§ pars inputIndex, redeemScript.getProgram(§ pars ), (§ cast #_"byte" sigHash))))
    )

    ;;;
     ; This is required for signatures which use a sigHashType which cannot be represented using SigHash and anyoneCanPay.
     ; See transaction c99c49da4c38af669dea436d3e73780dfdb6c1ecf9958baa52960e8baee30e73, which has sigHashType 0.
     ;;
    #_public
    (§ method #_"Sha256Hash" (§ fn hashForSignature) [#_"int" (§ name inputIndex), #_"byte[]" (§ name connectedScript), #_"byte" (§ name sigHashType)])
    (§ block
        ;; The SIGHASH flags are used in the design of contracts, please see this page for a further understanding of
        ;; the purposes of the code in this method:
        ;;
        ;;   https://en.bitcoin.it/wiki/Contracts

        (§ try )
        (§ block
            ;; Create a copy of this transaction to operate upon because we need make changes to the inputs and outputs.
            ;; It would not be thread-safe to change the attributes of the transaction object itself.
            (§ var #_"Transaction" (§ name tx) (§ expr this.params.getDefaultSerializer(§ pars ).makeTransaction(§ pars this.bitcoinSerialize(§ pars ))))

            ;; Clear input scripts in preparation for signing.  If we're signing a fresh transaction that step isn't very
            ;; helpful, but it doesn't add much cost relative to the actual EC math so we'll do it anyway.
            (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < tx.inputs.size(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
            (§ block
                (§ expr tx.inputs.get(§ pars i).clearScriptBytes(§ pars ))
            )

            ;; This step has no purpose beyond being synchronized with Bitcoin Core's bugs.  OP_CODESEPARATOR
            ;; is a legacy holdover from a previous, broken design of executing scripts that shipped in Bitcoin 0.1.
            ;; It was seriously flawed and would have let anyone take anyone elses money.  Later versions switched to
            ;; the design we use today where scripts are executed independently but share a stack.  This left the
            ;; OP_CODESEPARATOR instruction having no purpose as it was only meant to be used internally, not actually
            ;; ever put into scripts.  Deleting OP_CODESEPARATOR is a step that should never be required but if we don't
            ;; do it, we could split off the main chain.
            (§ ass (§ name connectedScript) (§ expr Script/removeAllInstancesOfOp(§ pars connectedScript, ScriptOpCodes/OP_CODESEPARATOR)))

            ;; Set the input to the script of its output.  Bitcoin Core does this but the step has no obvious purpose as
            ;; the signature covers the hash of the prevout transaction which obviously includes the output script
            ;; already.  Perhaps it felt safer to him in some way, or is another leftover from how the code was written.
            (§ var #_"TransactionInput" (§ name input) (§ expr tx.inputs.get(§ pars inputIndex)))
            (§ expr input.setScriptBytes(§ pars connectedScript))

            (§ if (§ expr (§ expr sigHashType & 0x1f) == SigHash/NONE.value))
            (§ block
                ;; SIGHASH_NONE means no outputs are signed at all - the signature is effectively for a "blank cheque".
                (§ ass (§ name tx.outputs) (§ new #_"ArrayList<>" (§ pars 0)))
                ;; The signature isn't broken by new versions of the transaction issued by other parties.
                (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < tx.inputs.size(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
                (§ block
                    (§ if (§ expr i != inputIndex))
                    (§ block
                        (§ expr tx.inputs.get(§ pars i).setSequenceNumber(§ pars 0))
                    )
                )
            )
            (§ elseif (§ expr (§ expr sigHashType & 0x1f) == SigHash/SINGLE.value))
            (§ block
                ;; SIGHASH_SINGLE means only sign the output at the same index as the input (i.e. my output).
                (§ if (§ expr tx.outputs.size(§ pars ) <= inputIndex))
                (§ block
                    ;; The input index is beyond the number of outputs, it's a buggy signature made by a broken
                    ;; Bitcoin implementation.  Bitcoin Core also contains a bug in handling this case:
                    ;; any transaction output that is signed in this case will result in both the signed output
                    ;; and any future outputs to this public key being steal-able by anyone who has
                    ;; the resulting signature and the public key (both of which are part of the signed tx input).

                    ;; Bitcoin Core's bug is that SignatureHash was supposed to return a hash and on this codepath it
                    ;; actually returns the constant "1" to indicate an error, which is never checked for.  Oops.
                    (§ return (§ expr Sha256Hash/wrap(§ pars "0100000000000000000000000000000000000000000000000000000000000000")))
                )
                ;; In SIGHASH_SINGLE the outputs after the matching input index are deleted, and the outputs before
                ;; that position are "nulled out".  Unintuitively, the value in a "null" transaction is set to -1.
                (§ ass (§ name tx.outputs) (§ new #_"ArrayList<>" (§ pars tx.outputs.subList(§ pars 0, inputIndex + 1))))
                (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < inputIndex) :for (§ ass (§ name i) (§ expr i + 1)))
                (§ block
                    (§ expr tx.outputs.set(§ pars i, new TransactionOutput(§ pars tx.params, tx, Coin/NEGATIVE_SATOSHI, new byte[] (§ coll ))))
                )
                ;; The signature isn't broken by new versions of the transaction issued by other parties.
                (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < tx.inputs.size(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
                (§ block
                    (§ if (§ expr i != inputIndex))
                    (§ block
                        (§ expr tx.inputs.get(§ pars i).setSequenceNumber(§ pars 0))
                    )
                )
            )

            (§ if (§ expr (§ expr sigHashType & SigHash/ANYONECANPAY.value) == SigHash/ANYONECANPAY.value))
            (§ block
                ;; SIGHASH_ANYONECANPAY means the signature in the input is not broken by changes/additions/removals
                ;; of other inputs.  For example, this is useful for building assurance contracts.
                (§ ass (§ name tx.inputs) (§ new #_"ArrayList<TransactionInput>" (§ pars )))
                (§ expr tx.inputs.add(§ pars input))
            )

            (§ var #_"ByteArrayOutputStream" (§ name bos) (§ new #_"UnsafeByteArrayOutputStream" (§ pars (§ quest (§ expr tx.length == UNKNOWN_LENGTH) ? 256 :else (§ expr tx.length + 4)))))
            (§ expr tx.bitcoinSerialize(§ pars bos))
            ;; We also have to write a hash type (sigHashType is actually an unsigned char).
            (§ expr uint32ToByteStreamLE(§ pars 0x000000ff & sigHashType, bos))
            ;; Note that this is NOT reversed to ensure it will be signed correctly.  If it were to be printed out
            ;; however then we would expect that it is IS reversed.
            (§ var #_"Sha256Hash" (§ name hash) (§ expr Sha256Hash/twiceOf(§ pars bos.toByteArray(§ pars ))))
            (§ expr bos.close(§ pars ))

            (§ return hash)
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ expr uint32ToByteStreamLE(§ pars version, stream))
        (§ expr stream.write(§ pars (§ new #_"VarInt" (§ pars inputs.size(§ pars ))).encode(§ pars )))
        (§ for (§ var #_"TransactionInput" (§ name in)) :for inputs)
        (§ block
            (§ expr in.bitcoinSerialize(§ pars stream))
        )
        (§ expr stream.write(§ pars (§ new #_"VarInt" (§ pars outputs.size(§ pars ))).encode(§ pars )))
        (§ for (§ var #_"TransactionOutput" (§ name out)) :for outputs)
        (§ block
            (§ expr out.bitcoinSerialize(§ pars stream))
        )
        (§ expr uint32ToByteStreamLE(§ pars lockTime, stream))
        (§ void nil)
    )

    ;;;
     ; Transactions can have an associated lock time, specified either as a block height or in seconds since the
     ; UNIX epoch.  A transaction is not allowed to be confirmed by miners until the lock time is reached, and
     ; since Bitcoin 0.8+ a transaction that did not end its lock period (non final) is considered to be non
     ; standard and won't be relayed or included in the memory pool either.
     ;;
    #_public
    (§ method #_"long" (§ fn getLockTime) [])
    (§ block
        (§ return lockTime)
    )

    ;;;
     ; Transactions can have an associated lock time, specified either as a block height or in seconds since the
     ; UNIX epoch.  A transaction is not allowed to be confirmed by miners until the lock time is reached, and
     ; since Bitcoin 0.8+ a transaction that did not end its lock period (non final) is considered to be non
     ; standard and won't be relayed or included in the memory pool either.
     ;;
    #_public
    (§ method #_"void" (§ fn setLockTime) [#_"long" (§ name lockTime)])
    (§ block
        (§ expr unCache(§ pars ))
        (§ var #_"boolean" (§ name seqNumSet) false)
        (§ for (§ var #_"TransactionInput" (§ name input)) :for inputs)
        (§ block
            (§ if (§ expr input.getSequenceNumber(§ pars ) != TransactionInput/NO_SEQUENCE))
            (§ block
                (§ ass (§ name seqNumSet) true)
                (§ break )
            )
        )
        (§ if (§ expr lockTime != 0 && (§ expr (§ not seqNumSet) || inputs.isEmpty(§ pars ))))
        (§ block
            ;; At least one input must have a non-default sequence number for lock times to have any effect.
            ;; For instance one of them can be set to zero to make this feature work.
            (§ expr log.warn(§ pars "You are setting the lock time on a transaction but none of the inputs have non-default sequence numbers. This will not do what you expect!"))
        )
        (§ ass (§ name this.lockTime) lockTime)
        (§ void nil)
    )

    #_public
    (§ method #_"long" (§ fn getVersion) [])
    (§ block
        (§ return version)
    )

    #_public
    (§ method #_"void" (§ fn setVersion) [#_"int" (§ name version)])
    (§ block
        (§ ass (§ name this.version) version)
        (§ expr unCache(§ pars ))
        (§ void nil)
    )

    ;;; Returns an unmodifiable view of all inputs. ;;
    #_public
    (§ method #_"List<TransactionInput>" (§ fn getInputs) [])
    (§ block
        (§ return (§ expr Collections/unmodifiableList(§ pars inputs)))
    )

    ;;; Returns an unmodifiable view of all outputs. ;;
    #_public
    (§ method #_"List<TransactionOutput>" (§ fn getOutputs) [])
    (§ block
        (§ return (§ expr Collections/unmodifiableList(§ pars outputs)))
    )

    ;;;
     ; <p>Returns the list of transacion outputs, whether spent or unspent, that match a wallet by address or that are
     ; watched by a wallet, i.e. transaction outputs whose script's address is controlled by the wallet and transaction
     ; outputs whose script is watched by the wallet.</p>
     ;
     ; @param transactionBag The wallet that controls addresses and watches scripts.
     ; @return linked list of outputs relevant to the wallet in this transaction.
     ;;
    #_public
    (§ method #_"List<TransactionOutput>" (§ fn getWalletOutputs) [#_"TransactionBag" (§ name transactionBag)])
    (§ block
        (§ var #_"List<TransactionOutput>" (§ name walletOutputs) (§ new #_"LinkedList<>" (§ pars )))

        (§ for (§ var #_"TransactionOutput" (§ name o)) :for outputs)
        (§ block
            (§ if (§ expr o.isMine(§ pars transactionBag)))
            (§ block
                (§ expr walletOutputs.add(§ pars o))
            )
        )

        (§ return walletOutputs)
    )

    ;;; Randomly re-orders the transaction outputs: good for privacy. ;;
    #_public
    (§ method #_"void" (§ fn shuffleOutputs) [])
    (§ block
        (§ expr Collections/shuffle(§ pars outputs))
        (§ void nil)
    )

    ;;; Same as getInputs().get(index). ;;
    #_public
    (§ method #_"TransactionInput" (§ fn getInput) [#_"long" (§ name index)])
    (§ block
        (§ return (§ expr inputs.get(§ pars (§ cast #_"int" index))))
    )

    ;;; Same as getOutputs().get(index). ;;
    #_public
    (§ method #_"TransactionOutput" (§ fn getOutput) [#_"long" (§ name index)])
    (§ block
        (§ return (§ expr outputs.get(§ pars (§ cast #_"int" index))))
    )

    ;;;
     ; Returns the confidence object for this transaction from the {@link org.bitcoinj.core.TxConfidenceTable}
     ; referenced by the implicit {@link Context}.
     ;;
    #_public
    (§ method #_"TransactionConfidence" (§ fn getConfidence) [])
    (§ block
        (§ return (§ expr getConfidence(§ pars Context/get(§ pars ))))
    )

    ;;;
     ; Returns the confidence object for this transaction from the {@link org.bitcoinj.core.TxConfidenceTable}
     ; referenced by the given {@link Context}.
     ;;
    #_public
    (§ method #_"TransactionConfidence" (§ fn getConfidence) [#_"Context" (§ name context)])
    (§ block
        (§ return (§ expr getConfidence(§ pars context.getConfidenceTable(§ pars ))))
    )

    ;;;
     ; Returns the confidence object for this transaction from the {@link org.bitcoinj.core.TxConfidenceTable}.
     ;;
    #_public
    (§ method #_"TransactionConfidence" (§ fn getConfidence) [#_"TxConfidenceTable" (§ name table)])
    (§ block
        (§ if (§ expr confidence == nil))
        (§ block
            (§ ass (§ name confidence) (§ expr table.getOrCreate(§ pars getHash(§ pars ))))
        )
        (§ return confidence)
    )

    ;;; Check if the transaction has a known confidence. ;;
    #_public
    (§ method #_"boolean" (§ fn hasConfidence) [])
    (§ block
        (§ return (§ expr getConfidence(§ pars ).getConfidenceType(§ pars ) != TransactionConfidence/ConfidenceType/UNKNOWN))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return (§ expr getHash(§ pars ).equals(§ pars (§ expr (§ cast #_"Transaction" o)).getHash(§ pars ))))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr getHash(§ pars ).hashCode(§ pars )))
    )

    ;;;
     ; Gets the count of regular SigOps in this transactions.
     ;;
    #_public
    (§ method #_"int" (§ fn getSigOpCount) [])
        (§ throws #_"ScriptException")
    (§ block
        (§ var #_"int" (§ name sigOps) 0)
        (§ for (§ var #_"TransactionInput" (§ name input)) :for inputs)
        (§ block
            (§ ass (§ name sigOps) (§ expr sigOps + Script/getSigOpCount(§ pars input.getScriptBytes(§ pars ))))
        )
        (§ for (§ var #_"TransactionOutput" (§ name output)) :for outputs)
        (§ block
            (§ ass (§ name sigOps) (§ expr sigOps + Script/getSigOpCount(§ pars output.getScriptBytes(§ pars ))))
        )
        (§ return sigOps)
    )

    ;;;
     ; Check block height is in coinbase input script, for use after BIP 34
     ; enforcement is enabled.
     ;;
    #_public
    (§ method #_"void" (§ fn checkCoinBaseHeight) [#_final #_"int" (§ name height)])
        (§ throws #_"VerificationException")
    (§ block
        (§ expr Preconditions/checkArgument(§ pars Block/BLOCK_HEIGHT_GENESIS <= height))
        (§ expr Preconditions/checkState(§ pars isCoinBase(§ pars )))

        ;; Check block height is in coinbase input script.
        #_final
        (§ var #_"TransactionInput" (§ name in) (§ expr this.getInputs(§ pars ).get(§ pars 0)))
        #_final
        (§ var #_"ScriptBuilder" (§ name builder) (§ new #_"ScriptBuilder" (§ pars )))
        (§ expr builder.number(§ pars height))
        #_final
        (§ var #_"byte[]" (§ name expected) (§ expr builder.build(§ pars ).getProgram(§ pars )))
        #_final
        (§ var #_"byte[]" (§ name actual) (§ expr in.getScriptBytes(§ pars )))
        (§ if (§ expr actual.length < expected.length))
        (§ block
            (§ throw (§ new #_"VerificationException.CoinbaseHeightMismatch" (§ pars "Block height mismatch in coinbase.")))
        )

        (§ for (§ var #_"int" (§ name scriptIdx) 0) :for (§ expr scriptIdx < expected.length) :for (§ ass (§ name scriptIdx) (§ expr scriptIdx + 1)))
        (§ block
            (§ if (§ expr actual[scriptIdx] != expected[scriptIdx]))
            (§ block
                (§ throw (§ new #_"VerificationException.CoinbaseHeightMismatch" (§ pars "Block height mismatch in coinbase.")))
            )
        )
        (§ void nil)
    )

    ;;;
     ; <p>Checks the transaction contents for sanity, in ways that can be done in a standalone manner.
     ; Does <b>not</b> perform all checks on a transaction such as whether the inputs are already spent.
     ; Specifically this method verifies:</p>
     ;
     ; <ul>
     ;     <li>That there is at least one input and output.</li>
     ;     <li>That the serialized size is not larger than the max block size.</li>
     ;     <li>That no outputs have negative value.</li>
     ;     <li>That the outputs do not sum to larger than the max allowed quantity of coin in the system.</li>
     ;     <li>If the tx is a coinbase tx, the coinbase scriptSig size is within range.  Otherwise that
     ;     there are no coinbase inputs in the tx.</li>
     ; </ul>
     ;
     ; @throws VerificationException
     ;;
    #_public
    (§ method #_"void" (§ fn verify) [])
        (§ throws #_"VerificationException")
    (§ block
        (§ if (§ expr inputs.size(§ pars ) == 0 || outputs.size(§ pars ) == 0))
        (§ block
            (§ throw (§ new #_"VerificationException.EmptyInputsOrOutputs" (§ pars )))
        )
        (§ if (§ expr Block/MAX_BLOCK_SIZE < this.getMessageSize(§ pars )))
        (§ block
            (§ throw (§ new #_"VerificationException.LargerThanMaxBlockSize" (§ pars )))
        )

        (§ var #_"Coin" (§ name valueOut) (§ expr Coin/ZERO))
        (§ var #_"HashSet<TransactionOutPoint>" (§ name outpoints) (§ new #_"HashSet<>" (§ pars )))
        (§ for (§ var #_"TransactionInput" (§ name input)) :for inputs)
        (§ block
            (§ if (§ expr outpoints.contains(§ pars input.getOutpoint(§ pars ))))
            (§ block
                (§ throw (§ new #_"VerificationException.DuplicatedOutPoint" (§ pars )))
            )
            (§ expr outpoints.add(§ pars input.getOutpoint(§ pars )))
        )
        (§ try )
        (§ block
            (§ for (§ var #_"TransactionOutput" (§ name output)) :for outputs)
            (§ block
                (§ if (§ expr output.getValue(§ pars ).signum(§ pars ) < 0)) ;; getValue() can throw IllegalStateException
                (§ block
                    (§ throw (§ new #_"VerificationException.NegativeValueOutput" (§ pars )))
                )

                (§ ass (§ name valueOut) (§ expr valueOut.add(§ pars output.getValue(§ pars ))))
                (§ if (§ expr params.hasMaxMoney(§ pars ) && 0 < valueOut.compareTo(§ pars params.getMaxMoney(§ pars ))))
                (§ block
                    (§ throw (§ new #_"IllegalArgumentException" (§ pars )))
                )
            )
        )
        (§ catch #_"IllegalStateException" (§ name _))
        (§ block
            (§ throw (§ new #_"VerificationException.ExcessiveValue" (§ pars )))
        )
        (§ catch #_"IllegalArgumentException" (§ name _))
        (§ block
            (§ throw (§ new #_"VerificationException.ExcessiveValue" (§ pars )))
        )

        (§ if (§ expr isCoinBase(§ pars )))
        (§ block
            (§ var #_"int" (§ name n) (§ expr inputs.get(§ pars 0).getScriptBytes(§ pars ).length))
            (§ if (§ expr n < 2 || 100 < n))
            (§ block
                (§ throw (§ new #_"VerificationException.CoinbaseScriptSizeOutOfRange" (§ pars )))
            )
        )
        (§ else )
        (§ block
            (§ for (§ var #_"TransactionInput" (§ name input)) :for inputs)
            (§ block
                (§ if (§ expr input.isCoinBase(§ pars )))
                (§ block
                    (§ throw (§ new #_"VerificationException.UnexpectedCoinbaseInput" (§ pars )))
                )
            )
        )
        (§ void nil)
    )

    ;;;
     ; <p>A transaction is time locked if at least one of its inputs is non-final and it has a lock time.</p>
     ;
     ; <p>To check if this transaction is final at a given height and time, see {@link Transaction#isFinal(int, long)}.</p>
     ;;
    #_public
    (§ method #_"boolean" (§ fn isTimeLocked) [])
    (§ block
        (§ if (§ expr getLockTime(§ pars ) == 0))
        (§ block
            (§ return false)
        )
        (§ for (§ var #_"TransactionInput" (§ name input)) :for (§ expr getInputs(§ pars )))
        (§ block
            (§ if (§ expr input.hasSequence(§ pars )))
            (§ block
                (§ return true)
            )
        )
        (§ return false)
    )

    ;;;
     ; Returns whether this transaction will opt into the
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki">full replace-by-fee</a> semantics.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isOptInFullRBF) [])
    (§ block
        (§ for (§ var #_"TransactionInput" (§ name input)) :for (§ expr getInputs(§ pars )))
        (§ block
            (§ if (§ expr input.isOptInFullRBF(§ pars )))
            (§ block
                (§ return true)
            )
        )
        (§ return false)
    )

    ;;;
     ; <p>Returns true if this transaction is considered finalized and can be placed in a block.  Non-finalized
     ; transactions won't be included by miners and can be replaced with newer versions using sequence numbers.
     ; This is useful in certain types of <a href="http://en.bitcoin.it/wiki/Contracts">contracts</a>, such as
     ; micropayment channels.</p>
     ;
     ; <p>Note that currently the replacement feature is disabled in Bitcoin Core and will need to be
     ; re-activated before this functionality is useful.</p>
     ;;
    #_public
    (§ method #_"boolean" (§ fn isFinal) [#_"int" (§ name height), #_"long" (§ name blockTimeSeconds)])
    (§ block
        (§ var #_"long" (§ name time) (§ expr getLockTime(§ pars )))
        (§ return (§ expr time < (§ quest (§ expr time < LOCKTIME_THRESHOLD) ? height :else blockTimeSeconds) || (§ not isTimeLocked(§ pars ))))
    )

    ;;;
     ; Returns either the lock time as a date, if it was specified in seconds, or an estimate based on the time in
     ; the current head block if it was specified as a block time.
     ;;
    #_public
    (§ method #_"Date" (§ fn estimateLockTime) [#_"AbstractBlockChain" (§ name chain)])
    (§ block
        (§ return (§ quest (§ expr lockTime < LOCKTIME_THRESHOLD) ? (§ expr chain.estimateBlockTime(§ pars (§ cast #_"int" (§ expr getLockTime(§ pars ))))) :else (§ new #_"Date" (§ pars getLockTime(§ pars ) * 1000))))
    )

    ;;;
     ; Returns the purpose for which this transaction was created.  See the javadoc for {@link Purpose} for more
     ; information on the point of this field and what it can be.
     ;;
    #_public
    (§ method #_"Purpose" (§ fn getPurpose) [])
    (§ block
        (§ return purpose)
    )

    ;;;
     ; Marks the transaction as being created for the given purpose.  See the javadoc for {@link Purpose} for more
     ; information on the point of this field and what it can be.
     ;;
    #_public
    (§ method #_"void" (§ fn setPurpose) [#_"Purpose" (§ name purpose)])
    (§ block
        (§ ass (§ name this.purpose) purpose)
        (§ void nil)
    )

    ;;;
     ; Getter for {@link #exchangeRate}.
     ;;
    #_nilable
    #_public
    (§ method #_"ExchangeRate" (§ fn getExchangeRate) [])
    (§ block
        (§ return exchangeRate)
    )

    ;;;
     ; Setter for {@link #exchangeRate}.
     ;;
    #_public
    (§ method #_"void" (§ fn setExchangeRate) [#_"ExchangeRate" (§ name exchangeRate)])
    (§ block
        (§ ass (§ name this.exchangeRate) exchangeRate)
        (§ void nil)
    )

    ;;;
     ; Returns the transaction {@link #memo}.
     ;;
    #_public
    (§ method #_"String" (§ fn getMemo) [])
    (§ block
        (§ return memo)
    )

    ;;;
     ; Set the transaction {@link #memo}.  It can be used to record the memo of the payment request that initiated the
     ; transaction.
     ;;
    #_public
    (§ method #_"void" (§ fn setMemo) [#_"String" (§ name memo)])
    (§ block
        (§ ass (§ name this.memo) memo)
        (§ void nil)
    )
)

#_(ns org.bitcoinj.core #_"TransactionBag"
    (:import [java.util Map])
   (:require [org.bitcoinj.script Script]
             [org.bitcoinj.wallet WalletTransaction]))

;;;
 ; This interface is used to abstract the {@link org.bitcoinj.wallet.Wallet} and the {@link org.bitcoinj.core.Transaction}.
 ;;
#_public
(§ interface #_"TransactionBag"
    ;;; Returns true if this wallet contains a public key which hashes to the given hash. ;;
    (§ method #_"boolean" (§ fn isPubKeyHashMine) [#_"byte[]" (§ name pubkeyHash)])

    ;;; Returns true if this wallet contains a keypair with the given public key. ;;
    (§ method #_"boolean" (§ fn isPubKeyMine) [#_"byte[]" (§ name pubkey)])

    ;;; Returns true if this wallet knows the script corresponding to the given hash. ;;
    (§ method #_"boolean" (§ fn isPayToScriptHashMine) [#_"byte[]" (§ name payToScriptHash)])

    ;;; Returns transactions from a specific pool. ;;
    (§ method #_"Map<Sha256Hash, Transaction>" (§ fn getTransactionPool) [#_"WalletTransaction.Pool" (§ name pool)])
)

#_(ns org.bitcoinj.core #_"TransactionBroadcast"
    (:import [java.util *]
             [java.util.concurrent *])
    (:import [com.google.common.annotations *]
             [com.google.common.base *]
             [com.google.common.util.concurrent *]
             [org.slf4j *])
   (:require [org.bitcoinj.core.listeners PreMessageReceivedEventListener]
             [org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; Represents a single transaction broadcast that we are performing.  A broadcast occurs after a new transaction is created
 ; (typically by a {@link Wallet}) and needs to be sent to the network.  A broadcast can succeed or fail.  A success is
 ; defined as seeing the transaction be announced by peers via inv messages, thus indicating their acceptance.  A failure
 ; is defined as not reaching acceptance within a timeout period, or getting an explicit reject message from a peer
 ; indicating that the transaction was not acceptable.
 ;;
#_public
(§ class #_"TransactionBroadcast"
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"TransactionBroadcast"))))

    #_private
    #_final
    (§ field #_"SettableFuture<Transaction>" (§ name future) (§ expr SettableFuture/create(§ pars )))
    #_private
    #_final
    (§ field #_"PeerGroup" (§ name peerGroup))
    #_private
    #_final
    (§ field #_"Transaction" (§ name tx))
    #_private
    (§ field #_"int" (§ name minConnections))
    #_private
    (§ field #_"int" (§ name numWaitingFor))

    ;;; Used for shuffling the peers before broadcast: unit tests can replace this to make themselves deterministic. ;;
    #_testing
    #_public
    #_static
    (§ field #_"Random" (§ name random) (§ new #_"Random" (§ pars )))

    ;; Tracks which nodes sent us a reject message about this broadcast, if any.  Useful for debugging.
    #_private
    (§ field #_"Map<Peer, RejectMessage>" (§ name rejects) (§ expr Collections/synchronizedMap(§ pars (§ new #_"HashMap<Peer, RejectMessage>" (§ pars )))))

    (§ constructor #_"TransactionBroadcast" [#_"PeerGroup" (§ name peerGroup), #_"Transaction" (§ name tx)])
    (§ block
        (§ ass (§ name this.peerGroup) peerGroup)
        (§ ass (§ name this.tx) tx)
        (§ ass (§ name this.minConnections) (§ expr Math/max(§ pars 1, peerGroup.getMinBroadcastConnections(§ pars ))))
        (§ void this)
    )

    ;; Only for mock broadcasts.
    #_private
    (§ constructor #_"TransactionBroadcast" [#_"Transaction" (§ name tx)])
    (§ block
        (§ ass (§ name this.peerGroup) nil)
        (§ ass (§ name this.tx) tx)
        (§ void this)
    )

    #_testing
    #_public
    #_static
    (§ method #_"TransactionBroadcast" (§ fn createMockBroadcast) [#_"Transaction" (§ name tx), #_final #_"SettableFuture<Transaction>" (§ name future)])
    (§ block
        (§ return (§ new #_"TransactionBroadcast" (§ pars tx))
        (§ anon
            #_override
            #_public
            (§ method #_"ListenableFuture<Transaction>" (§ fn broadcast) [])
            (§ block
                (§ return future)
            )

            #_override
            #_public
            (§ method #_"ListenableFuture<Transaction>" (§ fn future) [])
            (§ block
                (§ return future)
            )
        ))
    )

    #_public
    (§ method #_"ListenableFuture<Transaction>" (§ fn future) [])
    (§ block
        (§ return future)
    )

    #_public
    (§ method #_"void" (§ fn setMinConnections) [#_"int" (§ name minConnections)])
    (§ block
        (§ ass (§ name this.minConnections) minConnections)
        (§ void nil)
    )

    #_private
    (§ field #_"PreMessageReceivedEventListener" (§ name rejectionListener) (§ new #_"PreMessageReceivedEventListener" (§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"Message" (§ fn onPreMessageReceived) [#_"Peer" (§ name peer), #_"Message" (§ name m)])
            (§ block
                (§ if (§ insta m #_"RejectMessage"))
                (§ block
                    (§ var #_"RejectMessage" (§ name rejectMessage) (§ expr (§ cast #_"RejectMessage" m)))
                    (§ if (§ expr tx.getHash(§ pars ).equals(§ pars rejectMessage.getRejectedObjectHash(§ pars ))))
                    (§ block
                        (§ expr rejects.put(§ pars peer, rejectMessage))
                        (§ var #_"int" (§ name size) (§ expr rejects.size(§ pars )))
                        (§ var #_"long" (§ name threshold) (§ expr Math/round(§ pars numWaitingFor / 2.0)))
                        (§ if (§ expr threshold < size))
                        (§ block
                            (§ expr log.warn(§ pars "Threshold for considering broadcast rejected has been reached ({}/{})", size, threshold))
                            (§ expr future.setException(§ pars (§ new #_"RejectedTransactionException" (§ pars tx, rejectMessage))))
                            (§ expr peerGroup.removePreMessageReceivedEventListener(§ pars this))
                        )
                    )
                )
                (§ return m)
            )
        )))

    #_public
    (§ method #_"ListenableFuture<Transaction>" (§ fn broadcast) [])
    (§ block
        (§ expr peerGroup.addPreMessageReceivedEventListener(§ pars Threading/SAME_THREAD, rejectionListener))
        (§ expr log.info(§ pars "Waiting for {} peers required for broadcast, we have {} ...", minConnections, peerGroup.getConnectedPeers(§ pars ).size(§ pars )))
        (§ expr peerGroup.waitForPeers(§ pars minConnections).addListener(§ pars (§ new #_"EnoughAvailablePeers" (§ pars )), Threading/SAME_THREAD))
        (§ return future)
    )

    #_private
    (§ class #_"EnoughAvailablePeers" (§ implements #_"Runnable")
        #_override
        #_public
        (§ method #_"void" (§ fn run) [])
        (§ block
            ;; We now have enough connected peers to send the transaction.
            ;; This can be called immediately if we already have enough.  Otherwise it'll be called from a peer thread.

            ;; We will send the tx simultaneously to half the connected peers and wait to hear back from at least half
            ;; of the other half, i.e. with 4 peers connected we will send the tx to 2 randomly chosen peers, and then
            ;; wait for it to show up on one of the other two.  This will be taken as sign of network acceptance.  As can
            ;; be seen, 4 peers is probably too little - it doesn't taken many broken peers for tx propagation to have
            ;; a big effect.
            (§ var #_"List<Peer>" (§ name peers) (§ expr peerGroup.getConnectedPeers(§ pars ))) ;; snapshots
            ;; Prepare to send the transaction by adding a listener that'll be called when confidence changes.
            ;; Only bother with this if we might actually hear back:
            (§ if (§ expr 1 < minConnections))
            (§ block
                (§ expr tx.getConfidence(§ pars ).addEventListener(§ pars (§ new #_"ConfidenceChange" (§ pars ))))
            )
            ;; Bitcoin Core sends an inv in this case and then lets the peer request the tx data.  We just
            ;; blast out the TX here for a couple of reasons.  Firstly it's simpler: in the case where we have
            ;; just a single connection we don't have to wait for getdata to be received and handled before
            ;; completing the future in the code immediately below.  Secondly, it's faster.  The reason the
            ;; Bitcoin Core sends an inv is privacy - it means you can't tell if the peer originated the
            ;; transaction or not.  However, we are not a fully validating node and this is advertised in
            ;; our version message, as SPV nodes cannot relay it doesn't give away any additional information
            ;; to skip the inv here - we wouldn't send invs anyway.
            (§ var #_"int" (§ name numConnected) (§ expr peers.size(§ pars )))
            (§ var #_"int" (§ name numToBroadcastTo) (§ expr (§ cast #_"int" (§ expr Math/max(§ pars 1, Math/round(§ pars Math/ceil(§ pars peers.size(§ pars ) / 2.0)))))))
            (§ ass (§ name numWaitingFor) (§ cast #_"int" (§ expr Math/ceil(§ pars (§ expr peers.size(§ pars ) - numToBroadcastTo) / 2.0))))
            (§ expr Collections/shuffle(§ pars peers, random))
            (§ ass (§ name peers) (§ expr peers.subList(§ pars 0, numToBroadcastTo)))
            (§ expr log.info(§ pars "broadcastTransaction: We have {} peers, adding {} to the memory pool", numConnected, tx.getHashAsString(§ pars )))
            (§ expr log.info(§ pars "Sending to {} peers, will wait for {}, sending to: {}", numToBroadcastTo, numWaitingFor, Joiner/on(§ pars ",").join(§ pars peers)))
            (§ for (§ var #_"Peer" (§ name peer)) :for peers)
            (§ block
                (§ try )
                (§ block
                    (§ expr peer.sendMessage(§ pars tx))
                    ;; We don't record the peer as having seen the tx in the memory pool because we want to track only
                    ;; how many peers announced to us.
                )
                (§ catch #_"Exception" (§ name e))
                (§ block
                    (§ expr log.error(§ pars "Caught exception sending to {}", peer, e))
                )
            )
            ;; If we've been limited to talk to only one peer, we can't wait to hear back because the
            ;; remote peer won't tell us about transactions we just announced to it for obvious reasons.
            ;; So we just have to assume we're done, at that point.  This happens when we're not given
            ;; any peer discovery source and the user just calls connectTo() once.
            (§ if (§ expr minConnections == 1))
            (§ block
                (§ expr peerGroup.removePreMessageReceivedEventListener(§ pars rejectionListener))
                (§ expr future.set(§ pars tx))
            )
            (§ void nil)
        )
    )

    #_private
    (§ field #_"int" (§ name numSeemPeers))
    #_private
    (§ field #_"boolean" (§ name mined))

    #_private
    (§ class #_"ConfidenceChange" (§ implements #_"TransactionConfidence.Listener")
        #_override
        #_public
        (§ method #_"void" (§ fn onConfidenceChanged) [#_"TransactionConfidence" (§ name conf), #_"ChangeReason" (§ name reason)])
        (§ block
            ;; The number of peers that announced this tx has gone up.
            (§ var #_"int" (§ name numSeenPeers) (§ expr conf.numBroadcastPeers(§ pars ) + rejects.size(§ pars )))
            (§ var #_"boolean" (§ name mined) (§ expr tx.getAppearsInHashes(§ pars ) != nil))
            (§ expr log.info(§ pars "broadcastTransaction: {}:  TX {} seen by {} peers{}", reason, tx.getHashAsString(§ pars ), numSeenPeers, (§ quest mined ? (§ expr " and mined") :else (§ expr ""))))

            ;; Progress callback on the requested thread.
            (§ expr invokeAndRecord(§ pars numSeenPeers, mined))

            (§ if (§ expr numWaitingFor <= numSeenPeers || mined))
            (§ block
                ;; We've seen the min required number of peers announce the transaction, or it was included
                ;; in a block.  Normally we'd expect to see it fully propagate before it gets mined, but
                ;; it can be that a block is solved very soon after broadcast, and it's also possible that
                ;; due to version skew and changes in the relay rules our transaction is not going to
                ;; fully propagate yet can get mined anyway.
                ;;
                ;; Note that we can't wait for the current number of connected peers right now because we
                ;; could have added more peers after the broadcast took place, which means they won't
                ;; have seen the transaction.  In future when peers sync up their memory pools after they
                ;; connect we could come back and change this.
                ;;
                ;; We're done!  It's important that the PeerGroup lock is not held (by this thread) at this
                ;; point to avoid triggering inversions when the Future completes.
                (§ expr log.info(§ pars "broadcastTransaction: {} complete", tx.getHash(§ pars )))
                (§ expr peerGroup.removePreMessageReceivedEventListener(§ pars rejectionListener))
                (§ expr conf.removeEventListener(§ pars this))
                (§ expr future.set(§ pars tx)) ;; RE-ENTRANCY POINT
            )
            (§ void nil)
        )
    )

    #_private
    (§ method #_"void" (§ fn invokeAndRecord) [#_"int" (§ name numSeenPeers), #_"boolean" (§ name mined)])
    (§ block
        (§ sync this)
        (§ block
            (§ ass (§ name this.numSeemPeers) numSeenPeers)
            (§ ass (§ name this.mined) mined)
        )
        (§ expr invokeProgressCallback(§ pars numSeenPeers, mined))
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn invokeProgressCallback) [#_"int" (§ name numSeenPeers), #_"boolean" (§ name mined)])
    (§ block
        #_final
        (§ var #_"ProgressCallback" (§ name callback))
        (§ var #_"Executor" (§ name executor))
        (§ sync this)
        (§ block
            (§ ass (§ name callback) (§ expr this.callback))
            (§ ass (§ name executor) (§ expr this.progressCallbackExecutor))
        )
        (§ if (§ expr callback != nil))
        (§ block
            #_final
            (§ var #_"double" (§ name progress) (§ expr Math/min(§ pars 1.0, (§ quest mined ? 1.0 :else (§ expr numSeenPeers / (§ cast #_"double" numWaitingFor))))))
            (§ expr Preconditions/checkState(§ pars 0.0 <= progress && progress <= 1.0, progress))
            (§ try )
            (§ block
                (§ if (§ expr executor == nil))
                (§ block
                    (§ expr callback.onBroadcastProgress(§ pars progress))
                )
                (§ else )
                (§ block
                    (§ expr executor.execute(§ pars (§ new #_"Runnable" (§ pars ))
                    (§ anon
                        #_override
                        #_public
                        (§ method #_"void" (§ fn run) [])
                        (§ block
                            (§ expr callback.onBroadcastProgress(§ pars progress))
                            (§ void nil)
                        )
                    )))
                )
            )
            (§ catch #_"Throwable" (§ name e))
            (§ block
                (§ expr log.error(§ pars "Exception during progress callback", e))
            )
        )
        (§ void nil)
    )

    ;;; An interface for receiving progress information on the propagation of the tx, from 0.0 to 1.0 ;;
    #_public
    (§ interface #_"ProgressCallback"
        ;;;
         ; onBroadcastProgress will be invoked on the provided executor when the progress of the transaction
         ; broadcast has changed, because the transaction has been announced by another peer or because the transaction
         ; was found inside a mined block (in this case progress will go to 1.0 immediately).  Any exceptions thrown
         ; by this callback will be logged and ignored.
         ;;
        (§ method #_"void" (§ fn onBroadcastProgress) [#_"double" (§ name progress)])
    )

    #_nilable
    #_private
    (§ field #_"ProgressCallback" (§ name callback))
    #_nilable
    #_private
    (§ field #_"Executor" (§ name progressCallbackExecutor))

    ;;;
     ; Sets the given callback for receiving progress values, which will run on the user thread.
     ; See {@link org.bitcoinj.utils.Threading} for details.  If the broadcast has already started then the callback will
     ; be invoked immediately with the current progress.
     ;;
    #_public
    (§ method #_"void" (§ fn setProgressCallback) [#_"ProgressCallback" (§ name callback)])
    (§ block
        (§ expr setProgressCallback(§ pars callback, Threading/USER_THREAD))
        (§ void nil)
    )

    ;;;
     ; Sets the given callback for receiving progress values, which will run on the given executor.  If the executor
     ; is null, then the callback will run on a network thread and may be invoked multiple times in parallel.  You
     ; probably want to provide your UI thread or Threading.USER_THREAD for the second parameter.  If the broadcast
     ; has already started, then the callback will be invoked immediately with the current progress.
     ;;
    #_public
    (§ method #_"void" (§ fn setProgressCallback) [#_"ProgressCallback" (§ name callback), #_nilable #_"Executor" (§ name executor)])
    (§ block
        (§ var #_"boolean" (§ name shouldInvoke))
        (§ var #_"int" (§ name num))
        (§ var #_"boolean" (§ name mined))
        (§ sync this)
        (§ block
            (§ ass (§ name this.callback) callback)
            (§ ass (§ name this.progressCallbackExecutor) executor)
            (§ ass (§ name num) (§ expr this.numSeemPeers))
            (§ ass (§ name mined) (§ expr this.mined))
            (§ ass (§ name shouldInvoke) (§ expr 0 < numWaitingFor))
        )
        (§ if shouldInvoke)
        (§ block
            (§ expr invokeProgressCallback(§ pars num, mined))
        )
        (§ void nil)
    )
)

#_(ns org.bitcoinj.core #_"TransactionBroadcaster")

;;;
 ; A general interface which declares the ability to broadcast transactions.
 ; This is implemented by {@link org.bitcoinj.core.PeerGroup}.
 ;;
#_public
(§ interface #_"TransactionBroadcaster"
    ;;; Broadcast the given transaction on the network. ;;
    (§ method #_"TransactionBroadcast" (§ fn broadcastTransaction) [#_final #_"Transaction" (§ name tx)])
)

#_(ns org.bitcoinj.core #_"TransactionConfidence"
    (:import [java.util *]
             [java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect *]
             [com.google.common.util.concurrent *])
   (:require [org.bitcoinj.utils *]
             [org.bitcoinj.wallet Wallet]))

;; TODO: Modify the getDepthInBlocks method to require the chain height to be specified, in preparation for ceasing to touch every tx on every block.

;;;
 ; <p>A TransactionConfidence object tracks data you can use to make a confidence decision about a transaction.
 ; It also contains some pre-canned rules for common scenarios: if you aren't really sure what level of confidence
 ; you need, these should prove useful.  You can get a confidence object using {@link Transaction#getConfidence()}.
 ; They cannot be constructed directly.</p>
 ;
 ; <p>Confidence in a transaction can come in multiple ways:</p>
 ;
 ; <ul>
 ; <li>Because you created it yourself and only you have the necessary keys.</li>
 ; <li>Receiving it from a fully validating peer you know is trustworthy, for instance, because it's run by yourself.</li>
 ; <li>Receiving it from a peer on the network you randomly chose.  If your network connection is not being
 ;     intercepted, you have a pretty good chance of connecting to a node that is following the rules.</li>
 ; <li>Receiving it from multiple peers on the network.  If your network connection is not being intercepted,
 ;     hearing about a transaction from multiple peers indicates the network has accepted the transaction and
 ;     thus miners likely have too (miners have the final say in whether a transaction becomes valid or not).</li>
 ; <li>Seeing the transaction appear appear in a block on the main chain.  Your confidence increases as the transaction
 ;     becomes further buried under work.  Work can be measured either in blocks (roughly, units of time), or
 ;     amount of work done.</li>
 ; </ul>
 ;
 ; <p>Alternatively, you may know that the transaction is "dead", that is, one or more of its inputs have
 ; been double spent and will never confirm unless there is another re-org.</p>
 ;
 ; <p>TransactionConfidence is updated via the {@link org.bitcoinj.core.TransactionConfidence#incrementDepthInBlocks()}
 ; method to ensure the block depth is up to date.</p>
 ; To make a copy that won't be changed, use {@link org.bitcoinj.core.TransactionConfidence#duplicate()}.
 ;;
#_public
(§ class #_"TransactionConfidence"
    ;;;
     ; The peers that have announced the transaction to us.  Network nodes don't have stable identities, so we use
     ; IP address as an approximation.  It's obviously vulnerable to being gamed if we allow arbitrary people to connect
     ; to us, so only peers we explicitly connected to should go here.
     ;;
    #_private
    (§ field #_"CopyOnWriteArrayList<PeerAddress>" (§ name broadcastBy))
    ;;; The time the transaction was last announced to us. ;;
    #_private
    (§ field #_"Date" (§ name lastBroadcastedAt))
    ;;; The Transaction that this confidence object is associated with. ;;
    #_private
    #_final
    (§ field #_"Sha256Hash" (§ name hash))
    ;; Lazily created listeners array.
    #_private
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<Listener>>" (§ name listeners))

    ;; The depth of the transaction on the best chain in blocks.  An unconfirmed block has depth 0.
    #_private
    (§ field #_"int" (§ name depth))

    ;;; Describes the state of the transaction in general terms.  Properties can be read to learn specifics. ;;
    #_public
    (§ enum #_"ConfidenceType"
        ;;; If BUILDING, then the transaction is included in the best chain and your confidence in it is increasing. ;;
        (§ item BUILDING(§ pars 1))

        ;;;
         ; If PENDING, then the transaction is unconfirmed and should be included shortly, as long as it is being
         ; announced and is considered valid by the network.  A pending transaction will be announced if the containing
         ; wallet has been attached to a live {@link PeerGroup} using {@link PeerGroup#addWallet(Wallet)}.
         ; You can estimate how likely the transaction is to be included by connecting to a bunch of nodes then measuring
         ; how many announce it, using {@link org.bitcoinj.core.TransactionConfidence#numBroadcastPeers()}.
         ; Or if you saw it from a trusted peer, you can assume it's valid and will get mined sooner or later as well.
         ;;
        (§ item PENDING(§ pars 2))

        ;;;
         ; If DEAD, then it means the transaction won't confirm unless there is another re-org,
         ; because some other transaction is spending one of its inputs.  Such transactions should be alerted to the user
         ; so they can take action, e.g. suspending shipment of goods if they are a merchant.
         ; It can also mean that a coinbase transaction has been made dead from it being moved onto a side chain.
         ;;
        (§ item DEAD(§ pars 4))

        ;;;
         ; If IN_CONFLICT, then it means there is another transaction (or several other transactions) spending one
         ; (or several) of its inputs but nor this transaction nor the other/s transaction/s are included in the best chain.
         ; The other/s transaction/s should be IN_CONFLICT too.
         ; IN_CONFLICT can be thought as an intermediary state between a. PENDING and BUILDING or b. PENDING and DEAD.
         ; Another common name for this situation is "double spend".
         ;;
        (§ item IN_CONFLICT(§ pars 5))

        ;;;
         ; If a transaction hasn't been broadcast yet, or there's no record of it, its confidence is UNKNOWN.
         ;;
        (§ item UNKNOWN(§ pars 0))

        #_private
        (§ field #_"int" (§ name value))

        (§ constructor #_"ConfidenceType" [#_"int" (§ name value)])
        (§ block
            (§ ass (§ name this.value) value)
            (§ void this)
        )

        #_public
        (§ method #_"int" (§ fn getValue) [])
        (§ block
            (§ return value)
        )
    )

    #_private
    (§ field #_"ConfidenceType" (§ name confidenceType) (§ expr ConfidenceType/UNKNOWN))
    #_private
    (§ field #_"int" (§ name appearedAtChainHeight) -1)
    ;; The transaction that double spent this one, if any.
    #_private
    (§ field #_"Transaction" (§ name overridingTransaction))

    ;;;
     ; Information about where the transaction was first seen (network, sent direct from peer, created by ourselves).
     ; Useful for risk analyzing pending transactions.  Probably not that useful after a tx is included in the chain,
     ; unless re-org double spends start happening frequently.
     ;;
    #_public
    (§ enum #_"Source"
        ;;; We don't know where the transaction came from. ;;
        (§ item UNKNOWN)
        ;;; We got this transaction from a network peer. ;;
        (§ item NETWORK)
        ;;; This transaction was created by our own wallet, so we know it's not a double spend. ;;
        (§ item SELF)
    )
    #_private
    (§ field #_"Source" (§ name source) (§ expr Source/UNKNOWN))

    #_public
    (§ constructor #_"TransactionConfidence" [#_"Sha256Hash" (§ name hash)])
    (§ block
        ;; Assume a default number of peers for our set.
        (§ ass (§ name broadcastBy) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
        (§ ass (§ name listeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
        (§ ass (§ name this.hash) hash)
        (§ void this)
    )

    ;;;
     ; <p>A confidence listener is informed when the level of {@link TransactionConfidence} is updated by something, like
     ; for example a {@link Wallet}.  You can add listeners to update your user interface or manage your order tracking
     ; system when confidence levels pass a certain threshold.  <b>Note that confidence can go down as well as up.</b>
     ; For example, this can happen if somebody is doing a double-spend attack against you.  Whilst it's unlikely, your
     ; code should be able to handle that in order to be correct.</p>
     ;
     ; <p>During listener execution, it's safe to remove the current listener but not others.</p>
     ;;
    #_public
    (§ interface #_"Listener"
        ;;; An enum that describes why a transaction confidence listener is being invoked (i.e. the class of change). ;;
        (§ enum #_"ChangeReason"
            ;;;
             ; Occurs when the type returned by {@link org.bitcoinj.core.TransactionConfidence#getConfidenceType()}
             ; has changed.  For example, if a PENDING transaction changes to BUILDING or DEAD, then this reason will
             ; be given.  It's a high level summary.
             ;;
            (§ item TYPE)

            ;;;
             ; Occurs when a transaction that is in the best known block chain gets buried by another block.  If you're
             ; waiting for a certain number of confirmations, this is the reason to watch out for.
             ;;
            (§ item DEPTH)

            ;;;
             ; Occurs when a pending transaction (not in the chain) was announced by another connected peers.  By
             ; watching the number of peers that announced a transaction go up, you can see whether it's being
             ; accepted by the network or not.  If all your peers announce, it's a pretty good bet the transaction
             ; is considered relayable and has thus reached the miners.
             ;;
            (§ item SEEN_PEERS)
        )

        (§ method #_"void" (§ fn onConfidenceChanged) [#_"TransactionConfidence" (§ name confidence), #_"ChangeReason" (§ name reason)])
    )

    ;; This is used to ensure that confidence objects which aren't referenced from anywhere but which have an event
    ;; listener set on them don't become eligible for garbage collection.  Otherwise the TxConfidenceTable, which only
    ;; has weak references to these objects, would not be enough to keep the event listeners working as transactions
    ;; propagate around the network - it cannot know directly if the API user is interested in the object, so it uses
    ;; heap reachability as a proxy for interest.
    ;;
    ;; We add ourselves to this set when a listener is added and remove ourselves when the listener list is empty.
    #_private
    #_static
    #_final
    (§ field #_"Set<TransactionConfidence>" (§ name pinnedConfidenceObjects) (§ expr Collections/synchronizedSet(§ pars (§ new #_"HashSet<TransactionConfidence>" (§ pars )))))

    ;;;
     ; <p>Adds an event listener that will be run when this confidence object is updated.  The listener will be locked
     ; and is likely to be invoked on a peer thread.</p>
     ;
     ; <p>Note that this is NOT called when every block arrives.  Instead it is called when the transaction
     ; transitions between confidence states, i.e. from not being seen in the chain to being seen (not necessarily in
     ; the best chain).  If you want to know when the transaction gets buried under another block, consider using
     ; a future from {@link #getDepthFuture(int)}.</p>
     ;;
    #_public
    (§ method #_"void" (§ fn addEventListener) [#_"Executor" (§ name executor), #_"Listener" (§ name listener)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars listener))

        (§ expr listeners.addIfAbsent(§ pars (§ new #_"ListenerRegistration<>" (§ pars listener, executor))))
        (§ expr pinnedConfidenceObjects.add(§ pars this))
        (§ void nil)
    )

    ;;;
     ; <p>Adds an event listener that will be run when this confidence object is updated.  The listener will be locked
     ; and is likely to be invoked on a peer thread.</p>
     ;
     ; <p>Note that this is NOT called when every block arrives.  Instead it is called when the transaction
     ; transitions between confidence states, i.e. from not being seen in the chain to being seen (not necessarily in
     ; the best chain).  If you want to know when the transaction gets buried under another block, implement a
     ; {@link BlockChainListener}, attach it to a {@link BlockChain} and then use the getters on the
     ; confidence object to determine the new depth.</p>
     ;;
    #_public
    (§ method #_"void" (§ fn addEventListener) [#_"Listener" (§ name listener)])
    (§ block
        (§ expr addEventListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    #_public
    (§ method #_"boolean" (§ fn removeEventListener) [#_"Listener" (§ name listener)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars listener))

        (§ var #_"boolean" (§ name removed) (§ expr ListenerRegistration/removeFromList(§ pars listener, listeners)))
        (§ if (§ expr listeners.isEmpty(§ pars )))
        (§ block
            (§ expr pinnedConfidenceObjects.remove(§ pars this))
        )
        (§ return removed)
    )

    ;;;
     ; Returns the chain height at which the transaction appeared if confidence type is BUILDING.
     ; @throws IllegalStateException if the confidence type is not BUILDING.
     ;;
    #_public
    #_synchronized
    (§ method #_"int" (§ fn getAppearedAtChainHeight) [])
    (§ block
        (§ if (§ expr getConfidenceType(§ pars ) != ConfidenceType/BUILDING))
        (§ block
            (§ throw (§ new #_"IllegalStateException" (§ pars "Confidence type is " + getConfidenceType(§ pars ) + ", not BUILDING")))
        )
        (§ return appearedAtChainHeight)
    )

    ;;;
     ; The chain height at which the transaction appeared, if it has been seen in the best chain.
     ; Automatically sets the current type to {@link ConfidenceType#BUILDING} and depth to one.
     ;;
    #_public
    #_synchronized
    (§ method #_"void" (§ fn setAppearedAtChainHeight) [#_"int" (§ name appearedAtChainHeight)])
    (§ block
        (§ if (§ expr appearedAtChainHeight < 0))
        (§ block
            (§ throw (§ new #_"IllegalArgumentException" (§ pars "appearedAtChainHeight out of range")))
        )

        (§ ass (§ name this.appearedAtChainHeight) appearedAtChainHeight)
        (§ ass (§ name this.depth) 1)
        (§ expr setConfidenceType(§ pars ConfidenceType/BUILDING))
        (§ void nil)
    )

    ;;;
     ; Returns a general statement of the level of confidence you can have in this transaction.
     ;;
    #_public
    #_synchronized
    (§ method #_"ConfidenceType" (§ fn getConfidenceType) [])
    (§ block
        (§ return confidenceType)
    )

    ;;;
     ; Called by other objects in the system, like a {@link Wallet}, when new information about the confidence
     ; of a transaction becomes available.
     ;;
    #_public
    #_synchronized
    (§ method #_"void" (§ fn setConfidenceType) [#_"ConfidenceType" (§ name confidenceType)])
    (§ block
        (§ if (§ expr confidenceType == this.confidenceType))
        (§ block
            (§ return nil)
        )

        (§ ass (§ name this.confidenceType) confidenceType)
        (§ if (§ expr confidenceType != ConfidenceType/DEAD))
        (§ block
            (§ ass (§ name overridingTransaction) nil)
        )
        (§ if (§ expr confidenceType == ConfidenceType/PENDING || confidenceType == ConfidenceType/IN_CONFLICT))
        (§ block
            (§ ass (§ name depth) 0)
            (§ ass (§ name appearedAtChainHeight) -1)
        )
        (§ void nil)
    )

    ;;;
     ; Called by a {@link Peer} when a transaction is pending and announced by a peer.  The more peers announce
     ; the transaction, the more peers have validated it (assuming your internet connection is not being intercepted).
     ; If confidence is currently unknown, sets it to {@link ConfidenceType#PENDING}.  Does not run listeners.
     ;
     ; @param address IP address of the peer, used as a proxy for identity.
     ; @return true if marked, false if this address was already seen.
     ;;
    #_public
    (§ method #_"boolean" (§ fn markBroadcastBy) [#_"PeerAddress" (§ name address)])
    (§ block
        (§ ass (§ name lastBroadcastedAt) (§ expr Utils/now(§ pars )))
        (§ if (§ expr (§ not broadcastBy.addIfAbsent(§ pars address))))
        (§ block
            (§ return false) ;; Duplicate.
        )

        (§ sync this)
        (§ block
            (§ if (§ expr getConfidenceType(§ pars ) == ConfidenceType/UNKNOWN))
            (§ block
                (§ ass (§ name this.confidenceType) (§ expr ConfidenceType/PENDING))
            )
        )
        (§ return true)
    )

    ;;;
     ; Returns how many peers have been passed to {@link TransactionConfidence#markBroadcastBy}.
     ;;
    #_public
    (§ method #_"int" (§ fn numBroadcastPeers) [])
    (§ block
        (§ return (§ expr broadcastBy.size(§ pars )))
    )

    ;;;
     ; Returns a snapshot of {@link PeerAddress}es that announced the transaction.
     ;;
    #_public
    (§ method #_"Set<PeerAddress>" (§ fn getBroadcastBy) [])
    (§ block
        (§ var #_"ListIterator<PeerAddress>" (§ name iterator) (§ expr broadcastBy.listIterator(§ pars )))
        (§ return (§ expr Sets/newHashSet(§ pars iterator)))
    )

    ;;; Returns true if the given address has been seen via markBroadcastBy(). ;;
    #_public
    (§ method #_"boolean" (§ fn wasBroadcastBy) [#_"PeerAddress" (§ name address)])
    (§ block
        (§ return (§ expr broadcastBy.contains(§ pars address)))
    )

    ;;; Return the time the transaction was last announced to us. ;;
    #_public
    (§ method #_"Date" (§ fn getLastBroadcastedAt) [])
    (§ block
        (§ return lastBroadcastedAt)
    )

    ;;; Set the time the transaction was last announced to us. ;;
    #_public
    (§ method #_"void" (§ fn setLastBroadcastedAt) [#_"Date" (§ name lastBroadcastedAt)])
    (§ block
        (§ ass (§ name this.lastBroadcastedAt) lastBroadcastedAt)
        (§ void nil)
    )

    #_override
    #_public
    #_synchronized
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ var #_"StringBuilder" (§ name sb) (§ new #_"StringBuilder" (§ pars )))
        (§ var #_"int" (§ name peers) (§ expr numBroadcastPeers(§ pars )))
        (§ if (§ expr 0 < peers))
        (§ block
            (§ expr sb.append(§ pars "Seen by ").append(§ pars peers).append(§ pars (§ quest (§ expr 1 < peers) ? (§ expr " peers") :else (§ expr " peer"))))
            (§ if (§ expr lastBroadcastedAt != nil))
            (§ block
                (§ expr sb.append(§ pars " (most recently: ").append(§ pars Utils/dateTimeFormat(§ pars lastBroadcastedAt)).append(§ pars ")"))
            )
            (§ expr sb.append(§ pars ". "))
        )
        (§ switch (§ expr getConfidenceType(§ pars )))
        (§ block
            (§ case UNKNOWN)
            (§ block
                (§ expr sb.append(§ pars "Unknown confidence level."))
                (§ break )
            )
            (§ case DEAD)
            (§ block
                (§ expr sb.append(§ pars "Dead: overridden by double spend and will not confirm."))
                (§ break )
            )
            (§ case PENDING)
            (§ block
                (§ expr sb.append(§ pars "Pending/unconfirmed."))
                (§ break )
            )
            (§ case IN_CONFLICT)
            (§ block
                (§ expr sb.append(§ pars "In conflict."))
                (§ break )
            )
            (§ case BUILDING)
            (§ block
                (§ expr sb.append(§ pars String/format(§ pars Locale/US, "Appeared in best chain at height %d, depth %d.", getAppearedAtChainHeight(§ pars ), getDepthInBlocks(§ pars ))))
                (§ break )
            )
        )
        (§ if (§ expr source != Source/UNKNOWN))
        (§ block
            (§ expr sb.append(§ pars " Source: ").append(§ pars source))
        )
        (§ return (§ expr sb.toString(§ pars )))
    )

    ;;;
     ; Called by the wallet when the tx appears on the best chain and a new block is added to the top.
     ; Updates the internal counter that tracks how deeply buried the block is.
     ;
     ; @return the new depth
     ;;
    #_public
    #_synchronized
    (§ method #_"int" (§ fn incrementDepthInBlocks) [])
    (§ block
        (§ ass (§ name this.depth) (§ expr this.depth + 1))
        (§ return (§ expr this.depth))
    )

    ;;;
     ; <p>Depth in the chain is an approximation of how much time has elapsed since the transaction has been confirmed.
     ; On average there is supposed to be a new block every 10 minutes, but the actual rate may vary.  Bitcoin Core
     ; considers a transaction impractical to reverse after 6 blocks, but as of EOY 2011 network
     ; security is high enough that often only one block is considered enough even for high value transactions.
     ; For low value transactions like songs, or other cheap items, no blocks at all may be necessary.</p>
     ;
     ; <p>If the transaction appears in the top block, the depth is one.  If it's anything else (pending, dead, unknown)
     ; the depth is zero.</p>
     ;;
    #_public
    #_synchronized
    (§ method #_"int" (§ fn getDepthInBlocks) [])
    (§ block
        (§ return depth)
    )

    ;;
     ; Set the depth in blocks.  Having one block confirmation is a depth of one.
     ;;
    #_public
    #_synchronized
    (§ method #_"void" (§ fn setDepthInBlocks) [#_"int" (§ name depth)])
    (§ block
        (§ ass (§ name this.depth) depth)
        (§ void nil)
    )

    ;;;
     ; Erases the set of broadcast/seen peers.  This cannot be called whilst the confidence is PENDING.  It is useful
     ; for saving memory and wallet space once a tx is buried so deep it doesn't seem likely to go pending again.
     ;;
    #_public
    (§ method #_"void" (§ fn clearBroadcastBy) [])
    (§ block
        (§ expr Preconditions/checkState(§ pars getConfidenceType(§ pars ) != ConfidenceType/PENDING))
        (§ expr broadcastBy.clear(§ pars ))
        (§ ass (§ name lastBroadcastedAt) nil)
        (§ void nil)
    )

    ;;;
     ; If this transaction has been overridden by a double spend (is dead), this call returns the overriding transaction.
     ; Note that this call <b>can return null</b> if you have migrated an old wallet, as pre-Jan 2012 wallets did not
     ; store this information.
     ;
     ; @return the transaction that double spent this one.
     ; @throws IllegalStateException if confidence type is not DEAD.
     ;;
    #_public
    #_synchronized
    (§ method #_"Transaction" (§ fn getOverridingTransaction) [])
    (§ block
        (§ if (§ expr getConfidenceType(§ pars ) != ConfidenceType/DEAD))
        (§ block
            (§ throw (§ new #_"IllegalStateException" (§ pars "Confidence type is " + getConfidenceType(§ pars ) + ", not DEAD")))
        )
        (§ return overridingTransaction)
    )

    ;;;
     ; Called when the transaction becomes newly dead, that is, we learn that one of its inputs has already been spent
     ; in such a way that the double-spending transaction takes precedence over this one.  It will not become valid now
     ; unless there is a re-org.  Automatically sets the confidence type to DEAD.  The overriding transaction may not
     ; directly double spend this one, but could also have double spent a dependency of this tx.
     ;;
    #_public
    #_synchronized
    (§ method #_"void" (§ fn setOverridingTransaction) [#_nilable #_"Transaction" (§ name overridingTransaction)])
    (§ block
        (§ ass (§ name this.overridingTransaction) overridingTransaction)
        (§ expr setConfidenceType(§ pars ConfidenceType/DEAD))
        (§ void nil)
    )

    ;;; Returns a copy of this object.  Event listeners are not duplicated. ;;
    #_public
    (§ method #_"TransactionConfidence" (§ fn duplicate) [])
    (§ block
        (§ var #_"TransactionConfidence" (§ name c) (§ new #_"TransactionConfidence" (§ pars hash)))
        (§ expr c.broadcastBy.addAll(§ pars broadcastBy))
        (§ ass (§ name c.lastBroadcastedAt) lastBroadcastedAt)
        (§ sync this)
        (§ block
            (§ ass (§ name c.confidenceType) confidenceType)
            (§ ass (§ name c.overridingTransaction) overridingTransaction)
            (§ ass (§ name c.appearedAtChainHeight) appearedAtChainHeight)
        )
        (§ return c)
    )

    ;;;
     ; Call this after adjusting the confidence, for cases where listeners should be notified.  This has to be done
     ; explicitly rather than being done automatically because sometimes complex changes to transaction states can
     ; result in a series of confidence changes that are not really useful to see separately.  By invoking listeners
     ; explicitly, more precise control is available.  Note that this will run the listeners on the user code thread.
     ;;
    #_public
    (§ method #_"void" (§ fn queueListeners) [#_final #_"Listener.ChangeReason" (§ name reason)])
    (§ block
        (§ for (§ var #_final ListenerRegistration<Listener> registration) :for listeners)
        (§ block
            (§ expr registration.executor.execute(§ pars (§ new #_"Runnable" (§ pars ))
            (§ anon
                #_override
                #_public
                (§ method #_"void" (§ fn run) [])
                (§ block
                    (§ expr registration.listener.onConfidenceChanged(§ pars (§ dhis TransactionConfidence), reason))
                    (§ void nil)
                )
            )))
        )
        (§ void nil)
    )

    ;;;
     ; The source of a transaction tries to identify where it came from originally.  For instance, did we download it
     ; from the peer to peer network, or make it ourselves, or receive it via Bluetooth, or import it from another app,
     ; and so on.  This information is useful for {@link org.bitcoinj.wallet.CoinSelector} implementations to risk analyze
     ; transactions and decide when to spend them.
     ;;
    #_public
    #_synchronized
    (§ method #_"Source" (§ fn getSource) [])
    (§ block
        (§ return source)
    )

    ;;;
     ; The source of a transaction tries to identify where it came from originally.  For instance, did we download it
     ; from the peer to peer network, or make it ourselves, or receive it via Bluetooth, or import it from another app,
     ; and so on.  This information is useful for {@link org.bitcoinj.wallet.CoinSelector} implementations to risk analyze
     ; transactions and decide when to spend them.
     ;;
    #_public
    #_synchronized
    (§ method #_"void" (§ fn setSource) [#_"Source" (§ name source)])
    (§ block
        (§ ass (§ name this.source) source)
        (§ void nil)
    )

    ;;;
     ; Returns a future that completes when the transaction has been confirmed by "depth" blocks.  For instance setting
     ; depth to one will wait until it appears in a block on the best chain, and zero will wait until it has been seen
     ; on the network.
     ;;
    #_public
    #_synchronized
    (§ method #_"ListenableFuture<TransactionConfidence>" (§ fn getDepthFuture) [#_final #_"int" (§ name depth), #_"Executor" (§ name executor)])
    (§ block
        #_final
        (§ var #_"SettableFuture<TransactionConfidence>" (§ name result) (§ expr SettableFuture/create(§ pars )))
        (§ if (§ expr depth <= getDepthInBlocks(§ pars )))
        (§ block
            (§ expr result.set(§ pars this))
        )

        (§ expr addEventListener(§ pars executor, new Listener(§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn onConfidenceChanged) [#_"TransactionConfidence" (§ name confidence), #_"ChangeReason" (§ name reason)])
            (§ block
                (§ if (§ expr depth <= getDepthInBlocks(§ pars )))
                (§ block
                    (§ expr removeEventListener(§ pars this))
                    (§ expr result.set(§ pars confidence))
                )
                (§ void nil)
            )
        )))
        (§ return result)
    )

    #_public
    #_synchronized
    (§ method #_"ListenableFuture<TransactionConfidence>" (§ fn getDepthFuture) [#_final #_"int" (§ name depth)])
    (§ block
        (§ return (§ expr getDepthFuture(§ pars depth, Threading/USER_THREAD)))
    )

    #_public
    (§ method #_"Sha256Hash" (§ fn getTransactionHash) [])
    (§ block
        (§ return hash)
    )
)

#_(ns org.bitcoinj.core #_"TransactionInput"
    (:import [java.io IOException OutputStream]
             [java.lang.ref WeakReference]
             [java.util Arrays Map])
    (:import [com.google.common.base Joiner Objects Preconditions])
   (:require [org.bitcoinj.script Script ScriptError]
             [org.bitcoinj.wallet DefaultRiskAnalysis KeyBag RedeemData]))

;;;
 ; <p>A transfer of coins from one address to another creates a transaction in which the outputs
 ; can be claimed by the recipient in the input of another transaction.  You can imagine a
 ; transaction as being a module which is wired up to others, the inputs of one have to be wired
 ; to the outputs of another.  The exceptions are coinbase transactions, which create new coins.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"TransactionInput" (§ extends #_"ChildMessage")
    ;;; Magic sequence number that indicates there is no sequence number. ;;
    #_public
    #_static
    #_final
    (§ field #_"long" (§ name NO_SEQUENCE) (§ expr 0xffffffff))
    #_private
    #_static
    #_final
    (§ field #_"byte[]" (§ name EMPTY_ARRAY) (§ new #_"byte[]" (§ count 0)))
    ;; Magic outpoint index that indicates the input is in fact unconnected.
    #_private
    #_static
    #_final
    (§ field #_"long" (§ name UNCONNECTED) (§ expr 0xffffffff))

    ;; Allows for altering transactions after they were broadcast.  Values below NO_SEQUENCE-1 mean it can be altered.
    #_private
    (§ field #_"long" (§ name sequence))
    ;; Data needed to connect to the output of the transaction we're gathering coins from.
    #_private
    (§ field #_"TransactionOutPoint" (§ name outpoint))
    ;; The "script bytes" might not actually be a script.  In coinbase transactions where new coins are minted there
    ;; is no input transaction, so instead the scriptBytes contains some extra stuff (like a rollover nonce) that we
    ;; don't care about much.  The bytes are turned into a Script object (cached below) on demand via a getter.
    #_private
    (§ field #_"byte[]" (§ name scriptBytes))
    ;; The Script object obtained from parsing scriptBytes.  Only filled in on demand and if the transaction is not
    ;; coinbase.
    #_private
    (§ field #_"WeakReference<Script>" (§ name scriptSig))
    ;;; Value of the output connected to the input, if known.  This field does not participate in equals()/hashCode(). ;;
    #_nilable
    #_private
    (§ field #_"Coin" (§ name value))

    ;;;
     ; Creates an input that connects to nothing - used only in creation of coinbase transactions.
     ;;
    #_public
    (§ constructor #_"TransactionInput" [#_"NetworkParameters" (§ name params), #_nilable #_"Transaction" (§ name parentTransaction), #_"byte[]" (§ name scriptBytes)])
    (§ block
        (§ this (§ pars params, parentTransaction, scriptBytes, new TransactionOutPoint(§ pars params, UNCONNECTED, (§ cast #_"Transaction" nil))))
        (§ void this)
    )

    #_public
    (§ constructor #_"TransactionInput" [#_"NetworkParameters" (§ name params), #_nilable #_"Transaction" (§ name parentTransaction), #_"byte[]" (§ name scriptBytes), #_"TransactionOutPoint" (§ name outpoint)])
    (§ block
        (§ this (§ pars params, parentTransaction, scriptBytes, outpoint, nil))
        (§ void this)
    )

    #_public
    (§ constructor #_"TransactionInput" [#_"NetworkParameters" (§ name params), #_nilable #_"Transaction" (§ name parentTransaction), #_"byte[]" (§ name scriptBytes), #_"TransactionOutPoint" (§ name outpoint), #_nilable #_"Coin" (§ name value)])
    (§ block
        (§ super (§ pars params))

        (§ ass (§ name this.scriptBytes) scriptBytes)
        (§ ass (§ name this.outpoint) outpoint)
        (§ ass (§ name this.sequence) (§ expr NO_SEQUENCE))
        (§ ass (§ name this.value) value)
        (§ expr setParent(§ pars parentTransaction))
        (§ ass (§ name length) (§ expr 40 + (§ quest (§ expr scriptBytes != nil) ? (§ expr VarInt/sizeOf(§ pars scriptBytes.length) + scriptBytes.length) :else 1)))
        (§ void this)
    )

    ;;;
     ; Creates an UNSIGNED input that links to the given output.
     ;;
    (§ constructor #_"TransactionInput" [#_"NetworkParameters" (§ name params), #_"Transaction" (§ name parentTransaction), #_"TransactionOutput" (§ name output)])
    (§ block
        (§ super (§ pars params))

        (§ var #_"long" (§ name outputIndex) (§ expr output.getIndex(§ pars )))
        (§ if (§ expr output.getParentTransaction(§ pars ) != nil ))
        (§ block
            (§ ass (§ name outpoint) (§ new #_"TransactionOutPoint" (§ pars params, outputIndex, output.getParentTransaction(§ pars ))))
        )
        (§ else )
        (§ block
            (§ ass (§ name outpoint) (§ new #_"TransactionOutPoint" (§ pars params, output)))
        )
        (§ ass (§ name scriptBytes) (§ expr EMPTY_ARRAY))
        (§ ass (§ name sequence) (§ expr NO_SEQUENCE))
        (§ expr setParent(§ pars parentTransaction))
        (§ ass (§ name this.value) (§ expr output.getValue(§ pars )))
        (§ ass (§ name length) 41)
        (§ void this)
    )

    ;;;
     ; Deserializes an input message.  This is usually part of a transaction message.
     ;;
    #_public
    (§ constructor #_"TransactionInput" [#_"NetworkParameters" (§ name params), #_nilable #_"Transaction" (§ name parentTransaction), #_"byte[]" (§ name payload), #_"int" (§ name offset)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, offset))

        (§ expr setParent(§ pars parentTransaction))
        (§ ass (§ name this.value) nil)
        (§ void this)
    )

    ;;;
     ; Deserializes an input message.  This is usually part of a transaction message.
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor #_"TransactionInput" [#_"NetworkParameters" (§ name params), #_"Transaction" (§ name parentTransaction), #_"byte[]" (§ name payload), #_"int" (§ name offset), #_"MessageSerializer" (§ name serializer)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, offset, parentTransaction, serializer, UNKNOWN_LENGTH))

        (§ ass (§ name this.value) nil)
        (§ void this)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ ass (§ name outpoint) (§ new #_"TransactionOutPoint" (§ pars params, payload, cursor, this, serializer)))
        (§ ass (§ name cursor) (§ expr cursor + outpoint.getMessageSize(§ pars )))
        (§ var #_"int" (§ name scriptLen) (§ expr (§ cast #_"int" (§ expr readVarInt(§ pars )))))
        (§ ass (§ name length) (§ expr cursor - offset + scriptLen + 4))
        (§ ass (§ name scriptBytes) (§ expr readBytes(§ pars scriptLen)))
        (§ ass (§ name sequence) (§ expr readUint32(§ pars )))
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ expr outpoint.bitcoinSerialize(§ pars stream))
        (§ expr stream.write(§ pars (§ new #_"VarInt" (§ pars scriptBytes.length)).encode(§ pars )))
        (§ expr stream.write(§ pars scriptBytes))
        (§ expr Utils/uint32ToByteStreamLE(§ pars sequence, stream))
        (§ void nil)
    )

    ;;;
     ; Coinbase transactions have special inputs with hashes of zero.  If this is such an input, returns true.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isCoinBase) [])
    (§ block
        (§ return (§ expr outpoint.getHash(§ pars ).equals(§ pars Sha256Hash/ZERO_HASH) && (§ expr outpoint.getIndex(§ pars ) & 0xffffffff) == 0xffffffff)) ;; -1 but all is serialized to the wire as unsigned int.
    )

    ;;;
     ; Returns the script that is fed to the referenced output (scriptPubKey) script in order to satisfy it: usually
     ; contains signatures and maybe keys, but can contain arbitrary data if the output script accepts it.
     ;;
    #_public
    (§ method #_"Script" (§ fn getScriptSig) [])
        (§ throws #_"ScriptException")
    (§ block
        ;; Transactions that generate new coins don't actually have a script.
        ;; Instead this parameter is overloaded to be something totally different.
        (§ var #_"Script" (§ name script) (§ quest (§ expr scriptSig != nil) ? (§ expr scriptSig.get(§ pars )) :else nil))
        (§ if (§ expr script == nil))
        (§ block
            (§ ass (§ name script) (§ new #_"Script" (§ pars scriptBytes)))
            (§ ass (§ name scriptSig) (§ new #_"WeakReference<>" (§ pars script)))
        )
        (§ return script)
    )

    ;;; Set the given program as the scriptSig that is supposed to satisfy the connected output script. ;;
    #_public
    (§ method #_"void" (§ fn setScriptSig) [#_"Script" (§ name scriptSig)])
    (§ block
        (§ ass (§ name this.scriptSig) (§ new #_"WeakReference<>" (§ pars Preconditions/checkNotNull(§ pars scriptSig))))
        ;; TODO: This should all be cleaned up so we have a consistent internal representation.
        (§ expr setScriptBytes(§ pars scriptSig.getProgram(§ pars )))
        (§ void nil)
    )

    ;;;
     ; Convenience method that returns the from address of this input by parsing the scriptSig.  The concept of
     ; a "from address" is not well defined in Bitcoin and you should not assume that senders of a transaction can
     ; actually receive coins on the same address they used to sign (e.g. this is not true for shared wallets).
     ;;
    #_deprecated
    #_public
    (§ method #_"Address" (§ fn getFromAddress) [])
        (§ throws #_"ScriptException")
    (§ block
        (§ if (§ expr isCoinBase(§ pars )))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "This is a coinbase transaction which generates new coins. It does not have a from address.")))
        )

        (§ return (§ expr getScriptSig(§ pars ).getFromAddress(§ pars params)))
    )

    ;;;
     ; Sequence numbers allow participants in a multi-party transaction signing protocol to create new versions of the
     ; transaction independently of each other.  Newer versions of a transaction can replace an existing version that's
     ; in nodes memory pools if the existing version is time locked.  See the Contracts page on the Bitcoin wiki for
     ; examples of how you can use this feature to build contract protocols.
     ;;
    #_public
    (§ method #_"long" (§ fn getSequenceNumber) [])
    (§ block
        (§ return sequence)
    )

    ;;;
     ; Sequence numbers allow participants in a multi-party transaction signing protocol to create new versions of the
     ; transaction independently of each other.  Newer versions of a transaction can replace an existing version that's
     ; in nodes memory pools if the existing version is time locked.  See the Contracts page on the Bitcoin wiki for
     ; examples of how you can use this feature to build contract protocols.
     ;;
    #_public
    (§ method #_"void" (§ fn setSequenceNumber) [#_"long" (§ name sequence)])
    (§ block
        (§ expr unCache(§ pars ))
        (§ ass (§ name this.sequence) sequence)
        (§ void nil)
    )

    ;;;
     ; @return The previous output transaction reference, as an OutPoint structure.  This contains the
     ; data needed to connect to the output of the transaction we're gathering coins from.
     ;;
    #_public
    (§ method #_"TransactionOutPoint" (§ fn getOutpoint) [])
    (§ block
        (§ return outpoint)
    )

    ;;;
     ; The "script bytes" might not actually be a script.  In coinbase transactions where new coins are minted there
     ; is no input transaction, so instead the scriptBytes contains some extra stuff (like a rollover nonce) that we
     ; don't care about much.  The bytes are turned into a Script object (cached below) on demand via a getter.
     ; @return the scriptBytes
     ;;
    #_public
    (§ method #_"byte[]" (§ fn getScriptBytes) [])
    (§ block
        (§ return scriptBytes)
    )

    ;;; Clear input scripts, e.g. in preparation for signing. ;;
    #_public
    (§ method #_"void" (§ fn clearScriptBytes) [])
    (§ block
        (§ expr setScriptBytes(§ pars TransactionInput/EMPTY_ARRAY))
        (§ void nil)
    )

    ;;;
     ; @param scriptBytes The scriptBytes to set.
     ;;
    (§ method #_"void" (§ fn setScriptBytes) [#_"byte[]" (§ name scriptBytes)])
    (§ block
        (§ expr unCache(§ pars ))
        (§ ass (§ name this.scriptSig) nil)
        (§ var #_"int" (§ name oldLength) length)
        (§ ass (§ name this.scriptBytes) scriptBytes)
        ;; 40 = previous_outpoint (36) + sequence (4)
        (§ var #_"int" (§ name newLength) (§ expr 40 + (§ quest (§ expr scriptBytes != nil) ? (§ expr VarInt/sizeOf(§ pars scriptBytes.length) + scriptBytes.length) :else 1)))
        (§ expr adjustLength(§ pars newLength - oldLength))
        (§ void nil)
    )

    ;;;
     ; @return the Transaction that owns this input.
     ;;
    #_public
    (§ method #_"Transaction" (§ fn getParentTransaction) [])
    (§ block
        (§ return (§ cast #_"Transaction" parent))
    )

    ;;;
     ; @return the value of the output connected to this input.
     ;;
    #_nilable
    #_public
    (§ method #_"Coin" (§ fn getValue) [])
    (§ block
        (§ return value)
    )

    #_public
    (§ enum #_"ConnectionResult"
        (§ item NO_SUCH_TX)
        (§ item ALREADY_SPENT)
        (§ item SUCCESS)
    )

    ;; TODO: Clean all this up once TransactionOutPoint disappears.

    ;;;
     ; Locates the referenced output from the given pool of transactions.
     ;
     ; @return the TransactionOutput (or null) if the transaction's map doesn't contain the referenced tx.
     ;;
    #_nilable
    (§ method #_"TransactionOutput" (§ fn getConnectedOutput) [#_"Map<Sha256Hash, Transaction>" (§ name transactions)])
    (§ block
        (§ var #_"Transaction" (§ name tx) (§ expr transactions.get(§ pars outpoint.getHash(§ pars ))))
        (§ return (§ quest (§ expr tx != nil) ? (§ dot tx.getOutputs(§ pars ).get(§ pars (§ cast #_"int" (§ expr outpoint.getIndex(§ pars ))))) :else nil))
    )

    ;;;
     ; Alias for getOutpoint().getConnectedRedeemData(keyBag).
     ; @see TransactionOutPoint#getConnectedRedeemData(org.bitcoinj.wallet.KeyBag)
     ;;
    #_nilable
    #_public
    (§ method #_"RedeemData" (§ fn getConnectedRedeemData) [#_"KeyBag" (§ name keyBag)])
        (§ throws #_"ScriptException")
    (§ block
        (§ return (§ expr getOutpoint(§ pars ).getConnectedRedeemData(§ pars keyBag)))
    )

    #_public
    (§ enum #_"ConnectMode"
        (§ item DISCONNECT_ON_CONFLICT)
        (§ item ABORT_ON_CONFLICT)
    )

    ;;;
     ; Connects this input to the relevant output of the referenced transaction if it's in the given map.
     ; Connecting means updating the internal pointers and spent flags.  If the mode is to ABORT_ON_CONFLICT,
     ; then the spent output won't be changed, but the outpoint.fromTx pointer will still be updated.
     ;
     ; @param transactions Map of txhash->transaction.
     ; @param mode Whether to abort if there's a pre-existing connection or not.
     ; @return NO_SUCH_TX if the prevtx wasn't found, ALREADY_SPENT if there was a conflict, SUCCESS if not.
     ;;
    #_public
    (§ method #_"ConnectionResult" (§ fn connect) [#_"Map<Sha256Hash, Transaction>" (§ name transactions), #_"ConnectMode" (§ name mode)])
    (§ block
        (§ var #_"Transaction" (§ name tx) (§ expr transactions.get(§ pars outpoint.getHash(§ pars ))))
        (§ return (§ quest (§ expr tx != nil) ? (§ expr connect(§ pars tx, mode)) :else (§ expr TransactionInput/ConnectionResult/NO_SUCH_TX)))
    )

    ;;;
     ; Connects this input to the relevant output of the referenced transaction.
     ; Connecting means updating the internal pointers and spent flags.  If the mode is to ABORT_ON_CONFLICT,
     ; then the spent output won't be changed, but the outpoint.fromTx pointer will still be updated.
     ;
     ; @param transaction The transaction to try.
     ; @param mode Whether to abort if there's a pre-existing connection or not.
     ; @return NO_SUCH_TX if transaction is not the prevtx, ALREADY_SPENT if there was a conflict, SUCCESS if not.
     ;;
    #_public
    (§ method #_"ConnectionResult" (§ fn connect) [#_"Transaction" (§ name transaction), #_"ConnectMode" (§ name mode)])
    (§ block
        (§ if (§ not (§ dot transaction.getHash(§ pars ).equals(§ pars outpoint.getHash(§ pars )))))
        (§ block
            (§ return (§ expr ConnectionResult/NO_SUCH_TX))
        )

        (§ expr Preconditions/checkElementIndex(§ pars (§ cast #_"int" (§ expr outpoint.getIndex(§ pars ))), transaction.getOutputs(§ pars ).size(§ pars ), "Corrupt transaction"))

        (§ var #_"TransactionOutput" (§ name out) (§ expr transaction.getOutput(§ pars (§ cast #_"int" (§ expr outpoint.getIndex(§ pars ))))))
        (§ if (§ expr (§ not out.isAvailableForSpending(§ pars ))))
        (§ block
            (§ if (§ expr getParentTransaction(§ pars ).equals(§ pars outpoint.fromTx)))
            (§ block
                ;; Already connected.
                (§ return (§ expr ConnectionResult/SUCCESS))
            )
            (§ elseif (§ expr mode == ConnectMode/DISCONNECT_ON_CONFLICT))
            (§ block
                (§ expr out.markAsUnspent(§ pars ))
            )
            (§ elseif (§ expr mode == ConnectMode/ABORT_ON_CONFLICT))
            (§ block
                (§ ass (§ name outpoint.fromTx) (§ expr out.getParentTransaction(§ pars )))
                (§ return (§ expr TransactionInput/ConnectionResult/ALREADY_SPENT))
            )
        )
        (§ expr connect(§ pars out))
        (§ return (§ expr TransactionInput/ConnectionResult/SUCCESS))
    )

    ;;; Internal use only: connects this TransactionInput to the given output (updates pointers and spent flags). ;;
    #_public
    (§ method #_"void" (§ fn connect) [#_"TransactionOutput" (§ name out)])
    (§ block
        (§ ass (§ name outpoint.fromTx) (§ expr out.getParentTransaction(§ pars )))
        (§ expr out.markAsSpent(§ pars this))
        (§ ass (§ name value) (§ expr out.getValue(§ pars )))
        (§ void nil)
    )

    ;;;
     ; If this input is connected, check the output is connected back to this input and release it if so, making
     ; it spendable once again.
     ;
     ; @return true if the disconnection took place, false if it was not connected.
     ;;
    #_public
    (§ method #_"boolean" (§ fn disconnect) [])
    (§ block
        (§ var #_"TransactionOutput" (§ name connectedOutput))
        (§ if (§ expr outpoint.fromTx != nil))
        (§ block
            ;; The outpoint is connected using a "standard" wallet, disconnect it.
            (§ ass (§ name connectedOutput) (§ expr outpoint.fromTx.getOutput(§ pars (§ cast #_"int" (§ expr outpoint.getIndex(§ pars ))))))
            (§ ass (§ name outpoint.fromTx) nil)
        )
        (§ elseif (§ expr outpoint.connectedOutput != nil))
        (§ block
            ;; The outpoint is connected using a UTXO based wallet, disconnect it.
            (§ ass (§ name connectedOutput) (§ expr outpoint.connectedOutput))
            (§ ass (§ name outpoint.connectedOutput) nil)
        )
        (§ else )
        (§ block
            ;; The outpoint is not connected, do nothing.
            (§ return false)
        )

        (§ if (§ expr connectedOutput != nil && connectedOutput.getSpentBy(§ pars ) == this))
        (§ block
            ;; The outpoint was connected to an output, disconnect the output.
            (§ expr connectedOutput.markAsUnspent(§ pars ))
            (§ return true)
        )

        (§ return false)
    )

    ;;;
     ; @return true if this transaction's sequence number is set (i.e. it may be a part of a time-locked transaction).
     ;;
    #_public
    (§ method #_"boolean" (§ fn hasSequence) [])
    (§ block
        (§ return (§ expr sequence != NO_SEQUENCE))
    )

    ;;;
     ; Returns whether this input will cause a transaction to opt into the
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki">full replace-by-fee</a> semantics.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isOptInFullRBF) [])
    (§ block
        (§ return (§ expr sequence < NO_SEQUENCE - 1))
    )

    ;;;
     ; For a connected transaction, runs the script against the connected pubkey and verifies they are correct.
     ; @throws ScriptException if the script did not verify.
     ; @throws VerificationException if the outpoint doesn't match the given output.
     ;;
    #_public
    (§ method #_"void" (§ fn verify) [])
        (§ throws #_"VerificationException")
    (§ block
        #_final
        (§ var #_"Transaction" (§ name fromTx) (§ expr getOutpoint(§ pars ).fromTx))
        (§ var #_"long" (§ name spendingIndex) (§ expr getOutpoint(§ pars ).getIndex(§ pars )))

        (§ expr Preconditions/checkNotNull(§ pars fromTx, "Not connected"))

        #_final
        (§ var #_"TransactionOutput" (§ name output) (§ expr fromTx.getOutput(§ pars (§ cast #_"int" spendingIndex))))
        (§ expr verify(§ pars output))
        (§ void nil)
    )

    ;;;
     ; Verifies that this input can spend the given output.  Note that this input must be a part of a transaction.
     ; Also note that the consistency of the outpoint will be checked, even if this input has not been connected.
     ;
     ; @param output The output that this input is supposed to spend.
     ; @throws ScriptException if the script doesn't verify.
     ; @throws VerificationException if the outpoint doesn't match the given output.
     ;;
    #_public
    (§ method #_"void" (§ fn verify) [#_"TransactionOutput" (§ name output)])
        (§ throws #_"VerificationException")
    (§ block
        (§ if (§ expr output.parent != nil))
        (§ block
            (§ if (§ not (§ dot getOutpoint(§ pars ).getHash(§ pars ).equals(§ pars output.getParentTransaction(§ pars ).getHash(§ pars )))))
            (§ block
                (§ throw (§ new #_"VerificationException" (§ pars "This input does not refer to the tx containing the output.")))
            )
            (§ if (§ expr getOutpoint(§ pars ).getIndex(§ pars ) != output.getIndex(§ pars )))
            (§ block
                (§ throw (§ new #_"VerificationException" (§ pars "This input refers to a different output on the given tx.")))
            )
        )
        (§ var #_"Script" (§ name pubKey) (§ expr output.getScriptPubKey(§ pars )))
        (§ var #_"int" (§ name myIndex) (§ expr getParentTransaction(§ pars ).getInputs(§ pars ).indexOf(§ pars this)))
        (§ expr getScriptSig(§ pars ).correctlySpends(§ pars getParentTransaction(§ pars ), myIndex, pubKey))
        (§ void nil)
    )

    ;;;
     ; Returns the connected output, assuming the input was connected with
     ; {@link TransactionInput#connect(TransactionOutput)} or variants at some point.
     ; If it wasn't connected, then this method returns null.
     ;;
    #_nilable
    #_public
    (§ method #_"TransactionOutput" (§ fn getConnectedOutput) [])
    (§ block
        (§ return (§ expr getOutpoint(§ pars ).getConnectedOutput(§ pars )))
    )

    ;;;
     ; Returns the connected transaction, assuming the input was connected with
     ; {@link TransactionInput#connect(TransactionOutput)} or variants at some point.
     ; If it wasn't connected, then this method returns null.
     ;;
    #_nilable
    #_public
    (§ method #_"Transaction" (§ fn getConnectedTransaction) [])
    (§ block
        (§ return (§ expr getOutpoint(§ pars ).fromTx))
    )

    ;;; Returns a copy of the input detached from its containing transaction, if need be. ;;
    #_public
    (§ method #_"TransactionInput" (§ fn duplicateDetached) [])
    (§ block
        (§ return (§ new #_"TransactionInput" (§ pars params, nil, bitcoinSerialize(§ pars ), 0)))
    )

    ;;;
     ; <p>Returns either RuleViolation.NONE if the input is standard, or which rule makes it non-standard if so.
     ; The "IsStandard" rules control whether the default Bitcoin Core client blocks relay of a tx / refuses to mine it,
     ; however, non-standard transactions can still be included in blocks and will be accepted as valid if so.</p>
     ;
     ; <p>This method simply calls <tt>DefaultRiskAnalysis.isInputStandard(this)</tt>.</p>
     ;;
    #_public
    (§ method #_"DefaultRiskAnalysis.RuleViolation" (§ fn isStandard) [])
    (§ block
        (§ return (§ expr DefaultRiskAnalysis/isInputStandard(§ pars this)))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"TransactionInput" (§ name other) (§ expr (§ cast #_"TransactionInput" o)))
        (§ return (§ expr sequence == other.sequence && parent == other.parent && outpoint.equals(§ pars other.outpoint) && Arrays/equals(§ pars scriptBytes, other.scriptBytes)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars sequence, outpoint, Arrays/hashCode(§ pars scriptBytes))))
    )

    ;;;
     ; Returns a human readable debug string.
     ;;
    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ try )
        (§ block
            (§ var #_"StringBuilder" (§ name sb) (§ new #_"StringBuilder" (§ pars "TxIn")))
            (§ if (§ expr isCoinBase(§ pars )))
            (§ block
                (§ expr sb.append(§ pars ": COINBASE"))
            )
            (§ else )
            (§ block
                (§ expr sb.append(§ pars " for [").append(§ pars outpoint).append(§ pars "]: ").append(§ pars getScriptSig(§ pars )))
                (§ var #_"String" (§ name flags) (§ dot Joiner/on(§ pars ", ").skipNulls(§ pars ).join(§ pars (§ quest (§ expr hasSequence(§ pars )) ? (§ expr "sequence: " + Long/toHexString(§ pars sequence)) :else nil), (§ quest (§ expr isOptInFullRBF(§ pars )) ? (§ expr "opts into full RBF") :else nil))))
                (§ if (§ expr (§ not flags.isEmpty(§ pars ))))
                (§ block
                    (§ expr sb.append(§ pars " (").append(§ pars flags).append(§ pars ")"))
                )
            )
            (§ return (§ expr sb.toString(§ pars )))
        )
        (§ catch #_"ScriptException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
    )
)

#_(ns org.bitcoinj.core #_"TransactionOutPoint"
    (:import [java.io *])
    (:import [com.google.common.base Objects Preconditions])
   (:require [org.bitcoinj.script *]
             [org.bitcoinj.wallet *]))

;;;
 ; <p>This message is a reference or pointer to an output of a different transaction.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"TransactionOutPoint" (§ extends #_"ChildMessage")
    #_static
    #_final
    (§ field #_"int" (§ name MESSAGE_LENGTH) 36)

    ;;; Hash of the transaction to which we refer. ;;
    #_private
    (§ field #_"Sha256Hash" (§ name hash))
    ;;; Which output of that transaction we are talking about. ;;
    #_private
    (§ field #_"long" (§ name index))

    ;; This is not part of bitcoin serialization.  It points to the connected transaction.
    (§ field #_"Transaction" (§ name fromTx))

    ;; The connected output.
    (§ field #_"TransactionOutput" (§ name connectedOutput))

    #_public
    (§ constructor #_"TransactionOutPoint" [#_"NetworkParameters" (§ name params), #_"long" (§ name index), #_nilable #_"Transaction" (§ name fromTx)])
    (§ block
        (§ super (§ pars params))

        (§ ass (§ name this.index) index)
        (§ if (§ expr fromTx != nil))
        (§ block
            (§ ass (§ name this.hash) (§ expr fromTx.getHash(§ pars )))
            (§ ass (§ name this.fromTx) fromTx)
        )
        (§ else )
        (§ block
            ;; This happens when constructing the genesis block.
            (§ ass (§ name hash) (§ expr Sha256Hash/ZERO_HASH))
        )
        (§ ass (§ name length) (§ expr MESSAGE_LENGTH))
        (§ void this)
    )

    #_public
    (§ constructor #_"TransactionOutPoint" [#_"NetworkParameters" (§ name params), #_"long" (§ name index), #_"Sha256Hash" (§ name hash)])
    (§ block
        (§ super (§ pars params))

        (§ ass (§ name this.index) index)
        (§ ass (§ name this.hash) hash)
        (§ ass (§ name length) (§ expr MESSAGE_LENGTH))
        (§ void this)
    )

    #_public
    (§ constructor #_"TransactionOutPoint" [#_"NetworkParameters" (§ name params), #_"TransactionOutput" (§ name connectedOutput)])
    (§ block
        (§ this (§ pars params, connectedOutput.getIndex(§ pars ), connectedOutput.getParentTransactionHash(§ pars )))
        (§ ass (§ name this.connectedOutput) connectedOutput)
        (§ void this)
    )

    ;;;
     ; Deserializes the message.  This is usually part of a transaction message.
     ;;
    #_public
    (§ constructor #_"TransactionOutPoint" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"int" (§ name offset)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, offset))
        (§ void this)
    )

    ;;;
     ; Deserializes the message.  This is usually part of a transaction message.
     ; @param params NetworkParameters object.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor #_"TransactionOutPoint" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload), #_"int" (§ name offset), #_"Message" (§ name parent), #_"MessageSerializer" (§ name serializer)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, offset, parent, serializer, MESSAGE_LENGTH))
        (§ void this)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ ass (§ name length) (§ expr MESSAGE_LENGTH))
        (§ ass (§ name hash) (§ expr readHash(§ pars )))
        (§ ass (§ name index) (§ expr readUint32(§ pars )))
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ expr stream.write(§ pars hash.getReversedBytes(§ pars )))
        (§ expr Utils/uint32ToByteStreamLE(§ pars index, stream))
        (§ void nil)
    )

    ;;;
     ; An outpoint is a part of a transaction input that points to the output of another transaction.  If we have both
     ; sides in memory, and they have been linked together, this returns a pointer to the connected output, or null
     ; if there is no such connection.
     ;;
    #_nilable
    #_public
    (§ method #_"TransactionOutput" (§ fn getConnectedOutput) [])
    (§ block
        (§ if (§ expr fromTx != nil))
        (§ block
            (§ return (§ expr fromTx.getOutputs(§ pars ).get(§ pars (§ cast #_"int" index))))
        )
        (§ if (§ expr connectedOutput != nil))
        (§ block
            (§ return connectedOutput)
        )
        (§ return nil)
    )

    ;;;
     ; Returns the pubkey script from the connected output.
     ; @throws java.lang.NullPointerException if there is no connected output.
     ;;
    #_public
    (§ method #_"byte[]" (§ fn getConnectedPubKeyScript) [])
    (§ block
        (§ var #_"byte[]" (§ name result) (§ expr Preconditions/checkNotNull(§ pars getConnectedOutput(§ pars )).getScriptBytes(§ pars )))
        (§ expr Preconditions/checkState(§ pars 0 < result.length))
        (§ return result)
    )

    ;;;
     ; Returns the ECKey identified in the connected output, for either pay-to-address scripts or pay-to-key scripts.
     ; For P2SH scripts you can use {@link #getConnectedRedeemData(org.bitcoinj.wallet.KeyBag)} and then get the
     ; key from RedeemData.
     ; If the script form cannot be understood, throws ScriptException.
     ;
     ; @return an ECKey or null if the connected key cannot be found in the wallet.
     ;;
    #_nilable
    #_public
    (§ method #_"ECKey" (§ fn getConnectedKey) [#_"KeyBag" (§ name keyBag)])
        (§ throws #_"ScriptException")
    (§ block
        (§ var #_"TransactionOutput" (§ name connectedOutput) (§ expr getConnectedOutput(§ pars )))
        (§ expr Preconditions/checkNotNull(§ pars connectedOutput, "Input is not connected so cannot retrieve key"))
        (§ var #_"Script" (§ name connectedScript) (§ expr connectedOutput.getScriptPubKey(§ pars )))

        (§ if (§ expr connectedScript.isSentToAddress(§ pars )))
        (§ block
            (§ var #_"byte[]" (§ name addressBytes) (§ expr connectedScript.getPubKeyHash(§ pars )))
            (§ return (§ expr keyBag.findKeyFromPubHash(§ pars addressBytes)))
        )

        (§ if (§ expr connectedScript.isSentToRawPubKey(§ pars )))
        (§ block
            (§ var #_"byte[]" (§ name pubkeyBytes) (§ expr connectedScript.getPubKey(§ pars )))
            (§ return (§ expr keyBag.findKeyFromPubKey(§ pars pubkeyBytes)))
        )

        (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Could not understand form of connected output script: " + connectedScript)))
    )

    ;;;
     ; Returns the RedeemData identified in the connected output, for either pay-to-address scripts, pay-to-key
     ; or P2SH scripts.
     ; If the script forms cannot be understood, throws ScriptException.
     ;
     ; @return a RedeemData or null if the connected data cannot be found in the wallet.
     ;;
    #_nilable
    #_public
    (§ method #_"RedeemData" (§ fn getConnectedRedeemData) [#_"KeyBag" (§ name keyBag)])
        (§ throws #_"ScriptException")
    (§ block
        (§ var #_"TransactionOutput" (§ name connectedOutput) (§ expr getConnectedOutput(§ pars )))
        (§ expr Preconditions/checkNotNull(§ pars connectedOutput, "Input is not connected so cannot retrieve key"))
        (§ var #_"Script" (§ name connectedScript) (§ expr connectedOutput.getScriptPubKey(§ pars )))

        (§ if (§ expr connectedScript.isSentToAddress(§ pars )))
        (§ block
            (§ var #_"byte[]" (§ name addressBytes) (§ expr connectedScript.getPubKeyHash(§ pars )))
            (§ return (§ expr RedeemData/of(§ pars keyBag.findKeyFromPubHash(§ pars addressBytes), connectedScript)))
        )

        (§ if (§ expr connectedScript.isSentToRawPubKey(§ pars )))
        (§ block
            (§ var #_"byte[]" (§ name pubkeyBytes) (§ expr connectedScript.getPubKey(§ pars )))
            (§ return (§ expr RedeemData/of(§ pars keyBag.findKeyFromPubKey(§ pars pubkeyBytes), connectedScript)))
        )

        (§ if (§ expr connectedScript.isPayToScriptHash(§ pars )))
        (§ block
            (§ var #_"byte[]" (§ name scriptHash) (§ expr connectedScript.getPubKeyHash(§ pars )))
            (§ return (§ expr keyBag.findRedeemDataFromScriptHash(§ pars scriptHash)))
        )

        (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Could not understand form of connected output script: " + connectedScript)))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr hash + ":" + index))
    )

    ;;;
     ; Returns the hash of the transaction this outpoint references/spends/is connected to.
     ;;
    #_override
    #_public
    (§ method #_"Sha256Hash" (§ fn getHash) [])
    (§ block
        (§ return hash)
    )

    (§ method #_"void" (§ fn setHash) [#_"Sha256Hash" (§ name hash)])
    (§ block
        (§ ass (§ name this.hash) hash)
        (§ void nil)
    )

    #_public
    (§ method #_"long" (§ fn getIndex) [])
    (§ block
        (§ return index)
    )

    #_public
    (§ method #_"void" (§ fn setIndex) [#_"long" (§ name index)])
    (§ block
        (§ ass (§ name this.index) index)
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"TransactionOutPoint" (§ name other) (§ expr (§ cast #_"TransactionOutPoint" o)))
        (§ return (§ expr getIndex(§ pars ) == other.getIndex(§ pars ) && getHash(§ pars ).equals(§ pars other.getHash(§ pars ))))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars getIndex(§ pars ), getHash(§ pars ))))
    )
)

#_(ns org.bitcoinj.core #_"TransactionOutput"
    (:import [java.io *]
             [java.util *])
    (:import [com.google.common.base Objects Preconditions]
             [org.slf4j *])
   (:require [org.bitcoinj.script *]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>A TransactionOutput message contains a scriptPubKey that controls who is able to spend its value.
 ; It is a sub-part of the Transaction message.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"TransactionOutput" (§ extends #_"ChildMessage")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"TransactionOutput"))))

    ;; The output's value is kept as a native type in order to save class instances.
    #_private
    (§ field #_"long" (§ name value))

    ;; A transaction output has a script used for authenticating that the redeemer is allowed to spend
    ;; this output.
    #_private
    (§ field #_"byte[]" (§ name scriptBytes))

    ;; The script bytes are parsed and turned into a Script on demand.
    #_private
    (§ field #_"Script" (§ name scriptPubKey))

    ;; These fields are not Bitcoin serialized.  They are used for tracking purposes in our wallet only.
    ;; If set to true, this output is counted towards our balance.  If false and spentBy is null the tx output
    ;; was owned by us and was sent to somebody else.  If false and spentBy is set it means this output was owned
    ;; by us and used in one of our own transactions (e.g. because it is a change output).
    #_private
    (§ field #_"boolean" (§ name availableForSpending))
    #_nilable
    #_private
    (§ field #_"TransactionInput" (§ name spentBy))

    #_private
    (§ field #_"int" (§ name scriptLen))

    ;;;
     ; Deserializes a transaction output message.  This is usually part of a transaction message.
     ;;
    #_public
    (§ constructor #_"TransactionOutput" [#_"NetworkParameters" (§ name params), #_nilable #_"Transaction" (§ name parent), #_"byte[]" (§ name payload), #_"int" (§ name offset)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, offset))

        (§ expr setParent(§ pars parent))
        (§ ass (§ name availableForSpending) true)
        (§ void this)
    )

    ;;;
     ; Deserializes a transaction output message.  This is usually part of a transaction message.
     ;
     ; @param params NetworkParameters object.
     ; @param payload Bitcoin protocol formatted byte array containing message content.
     ; @param offset The location of the first payload byte within the array.
     ; @param serializer The serializer to use for this message.
     ; @throws ProtocolException
     ;;
    #_public
    (§ constructor #_"TransactionOutput" [#_"NetworkParameters" (§ name params), #_nilable #_"Transaction" (§ name parent), #_"byte[]" (§ name payload), #_"int" (§ name offset), #_"MessageSerializer" (§ name serializer)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, offset, parent, serializer, UNKNOWN_LENGTH))

        (§ ass (§ name availableForSpending) true)
        (§ void this)
    )

    ;;;
     ; Creates an output that sends 'value' to the given address (public key hash).  The amount should be
     ; created with something like {@link Coin#valueOf(int, int)}.  Typically you would use
     ; {@link Transaction#addOutput(Coin, Address)} instead of creating a TransactionOutput directly.
     ;;
    #_public
    (§ constructor #_"TransactionOutput" [#_"NetworkParameters" (§ name params), #_nilable #_"Transaction" (§ name parent), #_"Coin" (§ name value), #_"Address" (§ name to)])
    (§ block
        (§ this (§ pars params, parent, value, ScriptBuilder/createOutputScript(§ pars to).getProgram(§ pars )))
        (§ void this)
    )

    ;;;
     ; Creates an output that sends 'value' to the given public key using a simple CHECKSIG script (no addresses).
     ; The amount should be created with something like {@link Coin#valueOf(int, int)}.  Typically you would use
     ; {@link Transaction#addOutput(Coin, ECKey)} instead of creating an output directly.
     ;;
    #_public
    (§ constructor #_"TransactionOutput" [#_"NetworkParameters" (§ name params), #_nilable #_"Transaction" (§ name parent), #_"Coin" (§ name value), #_"ECKey" (§ name to)])
    (§ block
        (§ this (§ pars params, parent, value, ScriptBuilder/createOutputScript(§ pars to).getProgram(§ pars )))
        (§ void this)
    )

    #_public
    (§ constructor #_"TransactionOutput" [#_"NetworkParameters" (§ name params), #_nilable #_"Transaction" (§ name parent), #_"Coin" (§ name value), #_"byte[]" (§ name scriptBytes)])
    (§ block
        (§ super (§ pars params))

        ;; Negative values obviously make no sense, except for -1 which is used as a sentinel value when calculating
        ;; SIGHASH_SINGLE signatures, so unfortunately we have to allow that here.
        (§ expr Preconditions/checkArgument(§ pars 0 <= value.signum(§ pars ) || value.equals(§ pars Coin/NEGATIVE_SATOSHI), "Negative values not allowed"))
        (§ expr Preconditions/checkArgument(§ pars (§ not params.hasMaxMoney(§ pars )) || value.compareTo(§ pars params.getMaxMoney(§ pars )) <= 0, "Values larger than MAX_MONEY not allowed"))

        (§ ass (§ name this.value) (§ expr value.value))
        (§ ass (§ name this.scriptBytes) scriptBytes)
        (§ expr setParent(§ pars parent))
        (§ ass (§ name availableForSpending) true)
        (§ ass (§ name length) (§ expr 8 + VarInt/sizeOf(§ pars scriptBytes.length) + scriptBytes.length))
        (§ void this)
    )

    #_public
    (§ method #_"Script" (§ fn getScriptPubKey) [])
        (§ throws #_"ScriptException")
    (§ block
        (§ if (§ expr scriptPubKey == nil))
        (§ block
            (§ ass (§ name scriptPubKey) (§ new #_"Script" (§ pars scriptBytes)))
        )
        (§ return scriptPubKey)
    )

    ;;;
     ; <p>If the output script pays to an address as in <a href="https://bitcoin.org/en/developer-guide#term-p2pkh">P2PKH</a>,
     ; return the address of the receiver, i.e. a base58 encoded hash of the public key in the script.</p>
     ;
     ; @param networkParameters Needed to specify an address.
     ; @return null, if the output script is not the form <i>OP_DUP OP_HASH160 <PubkeyHash> OP_EQUALVERIFY OP_CHECKSIG</i>,
     ; i.e. not P2PKH.
     ; @return an address made out of the public key hash.
     ;;
    #_nilable
    #_public
    (§ method #_"Address" (§ fn getAddressFromP2PKHScript) [#_"NetworkParameters" (§ name networkParameters)])
        (§ throws #_"ScriptException")
    (§ block
        (§ return (§ quest (§ dot getScriptPubKey(§ pars ).isSentToAddress(§ pars )) ? (§ dot getScriptPubKey(§ pars ).getToAddress(§ pars networkParameters)) :else nil))
    )

    ;;;
     ; <p>If the output script pays to a redeem script, return the address of the redeem script as described by,
     ; i.e. a base58 encoding of [one-byte version][20-byte hash][4-byte checksum], where the 20-byte hash refers to
     ; the redeem script.</p>
     ;
     ; <p>P2SH is described by <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP 16</a> and
     ; <a href="https://bitcoin.org/en/developer-guide#p2sh-scripts">documented in the Bitcoin Developer Guide</a>.</p>
     ;
     ; @param networkParameters Needed to specify an address.
     ; @return null if the output script does not pay to a script hash.
     ; @return an address that belongs to the redeem script.
     ;;
    #_nilable
    #_public
    (§ method #_"Address" (§ fn getAddressFromP2SH) [#_"NetworkParameters" (§ name networkParameters)])
        (§ throws #_"ScriptException")
    (§ block
        (§ return (§ quest (§ dot getScriptPubKey(§ pars ).isPayToScriptHash(§ pars )) ? (§ dot getScriptPubKey(§ pars ).getToAddress(§ pars networkParameters)) :else nil))
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ ass (§ name value) (§ expr readInt64(§ pars )))
        (§ ass (§ name scriptLen) (§ cast #_"int" (§ expr readVarInt(§ pars ))))
        (§ ass (§ name length) (§ expr cursor - offset + scriptLen))
        (§ ass (§ name scriptBytes) (§ expr readBytes(§ pars scriptLen)))
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars scriptBytes))

        (§ expr Utils/int64ToByteStreamLE(§ pars value, stream))
        ;; TODO: Move script serialization into the Script class, where it belongs.
        (§ expr stream.write(§ pars (§ new #_"VarInt" (§ pars scriptBytes.length)).encode(§ pars )))
        (§ expr stream.write(§ pars scriptBytes))
        (§ void nil)
    )

    ;;;
     ; Returns the value of this output.
     ; This is the amount of currency that the destination address receives.
     ;;
    #_public
    (§ method #_"Coin" (§ fn getValue) [])
    (§ block
        (§ try )
        (§ block
            (§ return (§ expr Coin/valueOf(§ pars value)))
        )
        (§ catch #_"IllegalArgumentException" (§ name e))
        (§ block
            (§ throw (§ new #_"IllegalStateException" (§ pars e.getMessage(§ pars ), e)))
        )
    )

    ;;;
     ; Sets the value of this output.
     ;;
    #_public
    (§ method #_"void" (§ fn setValue) [#_"Coin" (§ name value)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars value))

        (§ expr unCache(§ pars ))
        (§ ass (§ name this.value) (§ expr value.value))
        (§ void nil)
    )

    ;;;
     ; Gets the index of this output in the parent transaction, or throws if this output is free standing.
     ; Iterates over the parents list to discover this.
     ;;
    #_public
    (§ method #_"int" (§ fn getIndex) [])
    (§ block
        (§ var #_"List<TransactionOutput>" (§ name outputs) (§ expr getParentTransaction(§ pars ).getOutputs(§ pars )))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < outputs.size(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ if (§ expr outputs.get(§ pars i) == this))
            (§ block
                (§ return i)
            )
        )

        (§ throw (§ new #_"IllegalStateException" (§ pars "Output linked to wrong parent transaction?")))
    )

    ;;;
     ; Will this transaction be relayable and mined by default miners?
     ;;
    #_public
    (§ method #_"boolean" (§ fn isDust) [])
    (§ block
        ;; Transactions that are OP_RETURN can't be dust regardless of their value.
        (§ return (§ quest (§ dot getScriptPubKey(§ pars ).isOpReturn(§ pars )) ? false :else (§ dot getValue(§ pars ).isLessThan(§ pars getMinNonDustValue(§ pars )))))
    )

    ;;;
     ; <p>Gets the minimum value for a txout of this size to be considered non-dust by Bitcoin Core
     ; (and thus relayed).  See CTxOut::IsDust() in Bitcoin Core.  The assumption is that any output that would
     ; consume more than a third of its value in fees is not something the Bitcoin system wants to deal with right now,
     ; so we call them "dust outputs" and they're made non standard.  The choice of one third is somewhat arbitrary and
     ; may change in future.</p>
     ;
     ; <p>You probably should use {@link org.bitcoinj.core.TransactionOutput#getMinNonDustValue()} which uses
     ; a safe fee-per-kb by default.</p>
     ;
     ; @param feePerKb The fee required per kilobyte.  Note that this is the same as Bitcoin Core's -minrelaytxfee * 3.
     ;;
    #_public
    (§ method #_"Coin" (§ fn getMinNonDustValue) [#_"Coin" (§ name feePerKb)])
    (§ block
        ;; A typical output is 33 bytes (pubkey hash + opcodes) and requires an input of 148 bytes to spend so we add
        ;; that together to find out the total amount of data used to transfer this amount of value.  Note that this
        ;; formula is wrong for anything that's not a pay-to-address output, unfortunately, we must follow Bitcoin Core's
        ;; wrongness in order to ensure we're considered standard.  A better formula would either estimate the
        ;; size of data needed to satisfy all different script types, or just hard code 33 below.
        #_final
        (§ var #_"long" (§ name size) (§ expr this.unsafeBitcoinSerialize(§ pars ).length + 148))
        (§ return (§ expr feePerKb.multiply(§ pars size).divide(§ pars 1000)))
    )

    ;;;
     ; Returns the minimum value for this output to be considered "not dust", i.e. the transaction will be relayable
     ; and mined by default miners.  For normal pay to address outputs, this is 2730 satoshis, the same as
     ; {@link Transaction#MIN_NONDUST_OUTPUT}.
     ;;
    #_public
    (§ method #_"Coin" (§ fn getMinNonDustValue) [])
    (§ block
        (§ return (§ expr getMinNonDustValue(§ pars Transaction/REFERENCE_DEFAULT_MIN_TX_FEE.multiply(§ pars 3))))
    )

    ;;;
     ; Sets this objects availableForSpending flag to false and the spentBy pointer to the given input.
     ; If the input is null, it means this output was signed over to somebody else rather than one of our own keys.
     ; @throws IllegalStateException if the transaction was already marked as spent.
     ;;
    #_public
    (§ method #_"void" (§ fn markAsSpent) [#_"TransactionInput" (§ name input)])
    (§ block
        (§ expr Preconditions/checkState(§ pars availableForSpending))

        (§ ass (§ name availableForSpending) false)
        (§ ass (§ name spentBy) input)

        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ if (§ expr parent != nil))
            (§ block
                (§ expr log.debug(§ pars "Marked {}:{} as spent by {}", getParentTransactionHash(§ pars ), getIndex(§ pars ), input))
            )
            (§ else )
            (§ block
                (§ expr log.debug(§ pars "Marked floating output as spent by {}", input))
            )
        )
        (§ void nil)
    )

    ;;;
     ; Resets the spent pointer / availableForSpending flag to null.
     ;;
    #_public
    (§ method #_"void" (§ fn markAsUnspent) [])
    (§ block
        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ if (§ expr parent != nil))
            (§ block
                (§ expr log.debug(§ pars "Un-marked {}:{} as spent by {}", getParentTransactionHash(§ pars ), getIndex(§ pars ), spentBy))
            )
            (§ else )
            (§ block
                (§ expr log.debug(§ pars "Un-marked floating output as spent by {}", spentBy))
            )
        )

        (§ ass (§ name availableForSpending) true)
        (§ ass (§ name spentBy) nil)
        (§ void nil)
    )

    ;;;
     ; Returns whether {@link TransactionOutput#markAsSpent(TransactionInput)} has been called on this class.
     ; A {@link Wallet} will mark a transaction output as spent once it sees a transaction input that is connected to it.
     ; Note that this flag can be false when an output has in fact been spent according to the rest of the network if
     ; the spending transaction wasn't downloaded yet, and it can be marked as spent when in reality the rest of the
     ; network believes it to be unspent if the signature or script connecting to it was not actually valid.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isAvailableForSpending) [])
    (§ block
        (§ return availableForSpending)
    )

    ;;;
     ; The backing script bytes which can be turned into a Script object.
     ; @return the scriptBytes
    ;;
    #_public
    (§ method #_"byte[]" (§ fn getScriptBytes) [])
    (§ block
        (§ return scriptBytes)
    )

    ;;;
     ; Returns true if this output is to a key, or an address we have the keys for, in the wallet.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isMine) [#_"TransactionBag" (§ name transactionBag)])
    (§ block
        (§ try )
        (§ block
            (§ var #_"Script" (§ name script) (§ expr getScriptPubKey(§ pars )))
            (§ if (§ expr script.isSentToRawPubKey(§ pars )))
            (§ block
                (§ return (§ expr transactionBag.isPubKeyMine(§ pars script.getPubKey(§ pars ))))
            )
            (§ if (§ expr script.isPayToScriptHash(§ pars )))
            (§ block
                (§ return (§ expr transactionBag.isPayToScriptHashMine(§ pars script.getPubKeyHash(§ pars ))))
            )
            (§ return (§ expr transactionBag.isPubKeyHashMine(§ pars script.getPubKeyHash(§ pars ))))
        )
        (§ catch #_"ScriptException" (§ name e))
        (§ block
            ;; Just means we didn't understand the output of this transaction: ignore it.
            (§ expr log.debug(§ pars "Could not parse tx {} output script: {}", (§ quest (§ expr parent != nil) ? (§ expr parent.getHash(§ pars )) :else (§ expr "(no parent)")), e.toString(§ pars )))
            (§ return false)
        )
    )

    ;;;
     ; Returns a human readable debug string.
     ;;
    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ try )
        (§ block
            (§ var #_"Script" (§ name script) (§ expr getScriptPubKey(§ pars )))
            (§ var #_"StringBuilder" (§ name sb) (§ new #_"StringBuilder" (§ pars "TxOut of ")))
            (§ expr sb.append(§ pars Coin/valueOf(§ pars value).toFriendlyString(§ pars )))
            (§ if (§ expr script.isSentToAddress(§ pars ) || script.isPayToScriptHash(§ pars )))
            (§ block
                (§ expr sb.append(§ pars " to ").append(§ pars script.getToAddress(§ pars params)))
            )
            (§ elseif (§ expr script.isSentToRawPubKey(§ pars )))
            (§ block
                (§ expr sb.append(§ pars " to pubkey ").append(§ pars Utils/HEX.encode(§ pars script.getPubKey(§ pars ))))
            )
            (§ elseif (§ expr script.isSentToMultiSig(§ pars )))
            (§ block
                (§ expr sb.append(§ pars " to multisig"))
            )
            (§ else )
            (§ block
                (§ expr sb.append(§ pars " (unknown type)"))
            )
            (§ expr sb.append(§ pars " script:").append(§ pars script))
            (§ return (§ expr sb.toString(§ pars )))
        )
        (§ catch #_"ScriptException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
    )

    ;;;
     ; Returns the connected input.
     ;;
    #_nilable
    #_public
    (§ method #_"TransactionInput" (§ fn getSpentBy) [])
    (§ block
        (§ return spentBy)
    )

    ;;;
     ; Returns the transaction that owns this output.
     ;;
    #_nilable
    #_public
    (§ method #_"Transaction" (§ fn getParentTransaction) [])
    (§ block
        (§ return (§ cast #_"Transaction" parent))
    )

    ;;;
     ; Returns the transaction hash that owns this output.
     ;;
    #_nilable
    #_public
    (§ method #_"Sha256Hash" (§ fn getParentTransactionHash) [])
    (§ block
        (§ return (§ quest (§ expr parent != nil) ? (§ expr parent.getHash(§ pars )) :else nil))
    )

    ;;;
     ; Returns the depth in blocks of the parent tx.
     ;
     ; <p>If the transaction appears in the top block, the depth is one.
     ; If it's anything else (pending, dead, unknown), then -1.</p>
     ; @return the tx depth or -1.
     ;;
    #_public
    (§ method #_"int" (§ fn getParentTransactionDepthInBlocks) [])
    (§ block
        (§ if (§ expr getParentTransaction(§ pars ) != nil))
        (§ block
            (§ var #_"TransactionConfidence" (§ name confidence) (§ expr getParentTransaction(§ pars ).getConfidence(§ pars )))
            (§ if (§ expr confidence.getConfidenceType(§ pars ) == TransactionConfidence/ConfidenceType/BUILDING))
            (§ block
                (§ return (§ expr confidence.getDepthInBlocks(§ pars )))
            )
        )
        (§ return -1)
    )

    ;;;
     ; Returns a new {@link TransactionOutPoint}, which is essentially a structure pointing to this output.
     ; Requires that this output is not detached.
     ;;
    #_public
    (§ method #_"TransactionOutPoint" (§ fn getOutPointFor) [])
    (§ block
        (§ return (§ new #_"TransactionOutPoint" (§ pars params, getIndex(§ pars ), getParentTransaction(§ pars ))))
    )

    ;;; Returns a copy of the output detached from its containing transaction, if need be. ;;
    #_public
    (§ method #_"TransactionOutput" (§ fn duplicateDetached) [])
    (§ block
        (§ return (§ new #_"TransactionOutput" (§ pars params, nil, Coin/valueOf(§ pars value), org.spongycastle.util.Arrays.clone(§ pars scriptBytes))))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"TransactionOutput" (§ name other) (§ expr (§ cast #_"TransactionOutput" o)))
        (§ return (§ expr value == other.value && (§ expr parent == nil || (§ expr parent == other.parent && getIndex(§ pars ) == other.getIndex(§ pars ))) && Arrays/equals(§ pars scriptBytes, other.scriptBytes)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars value, parent, Arrays/hashCode(§ pars scriptBytes))))
    )
)

#_(ns org.bitcoinj.core #_"TransactionOutputChanges"
    (:import [java.io IOException InputStream OutputStream]
             [java.util LinkedList List]))

;;;
 ; <p>TransactionOutputChanges represents a delta to the set of unspent outputs.  It used as a return value for
 ; {@link AbstractBlockChain#connectTransactions(int, Block)}.  It contains the full list of transaction outputs created
 ; and spent in a block.  It DOES contain outputs created that were spent later in the block, as those are needed for
 ; BIP30 (no duplicate txid creation if the previous one was not fully spent prior to this block) verification.</p>
 ;;
#_public
(§ class #_"TransactionOutputChanges"
    #_public
    #_final
    (§ field #_"List<UTXO>" (§ name txOutsCreated))
    #_public
    #_final
    (§ field #_"List<UTXO>" (§ name txOutsSpent))

    #_public
    (§ constructor #_"TransactionOutputChanges" [#_"List<UTXO>" (§ name txOutsCreated), #_"List<UTXO>" (§ name txOutsSpent)])
    (§ block
        (§ ass (§ name this.txOutsCreated) txOutsCreated)
        (§ ass (§ name this.txOutsSpent) txOutsSpent)
        (§ void this)
    )

    #_private
    #_static
    #_final
    (§ method #_"int" (§ fn read4x8le) [#_"InputStream" (§ name is)])
        (§ throws #_"IOException")
    (§ block
        (§ return (§ expr (§ expr is.read(§ pars ) & 0xff) | (§ expr (§ expr is.read(§ pars ) & 0xff) << 8) | (§ expr (§ expr is.read(§ pars ) & 0xff) << 16) | (§ expr (§ expr is.read(§ pars ) & 0xff) << 24)))
    )

    #_public
    (§ constructor #_"TransactionOutputChanges" [#_"InputStream" (§ name is)])
        (§ throws #_"IOException")
    (§ block
        (§ var #_"int" (§ name nCreated) (§ expr read4x8le(§ pars is)))
        (§ ass (§ name txOutsCreated) (§ new #_"LinkedList<>" (§ pars )))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < nCreated) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ expr txOutsCreated.add(§ pars (§ new #_"UTXO" (§ pars is))))
        )

        (§ var #_"int" (§ name nSpent) (§ expr read4x8le(§ pars is)))
        (§ ass (§ name txOutsSpent) (§ new #_"LinkedList<>" (§ pars )))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < nSpent) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ expr txOutsSpent.add(§ pars (§ new #_"UTXO" (§ pars is))))
        )
        (§ void this)
    )

    #_private
    #_static
    #_final
    (§ method #_"void" (§ fn write4x8le) [#_"OutputStream" (§ name os), #_"int" (§ name n)])
        (§ throws #_"IOException")
    (§ block
        (§ expr os.write(§ pars 0xff & n))
        (§ expr os.write(§ pars 0xff & (§ expr n >> 8)))
        (§ expr os.write(§ pars 0xff & (§ expr n >> 16)))
        (§ expr os.write(§ pars 0xff & (§ expr n >> 24)))
        (§ void nil)
    )

    #_public
    (§ method #_"void" (§ fn serializeToStream) [#_"OutputStream" (§ name os)])
        (§ throws #_"IOException")
    (§ block
        (§ expr write4x8le(§ pars os, txOutsCreated.size(§ pars )))
        (§ for (§ var #_"UTXO" (§ name output)) :for txOutsCreated)
        (§ block
            (§ expr output.serializeToStream(§ pars os))
        )

        (§ expr write4x8le(§ pars os, txOutsSpent.size(§ pars )))
        (§ for (§ var #_"UTXO" (§ name output)) :for txOutsSpent)
        (§ block
            (§ expr output.serializeToStream(§ pars os))
        )
        (§ void nil)
    )
)

#_(ns org.bitcoinj.core #_"TxConfidenceTable"
    (:import [java.lang.ref *]
             [java.util *]
             [java.util.concurrent.locks *])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.utils *]))

;;;
 ; <p>Tracks transactions that are being announced across the network.  Typically one is created for you by a
 ; {@link PeerGroup} and then given to each Peer to update.  The current purpose is to let Peers update the confidence
 ; (number of peers broadcasting).  It helps address an attack scenario in which a malicious remote peer (or several)
 ; feeds you invalid transactions, e.g. ones that spend coins which don't exist.  If you don't see most of the peers
 ; announce the transaction within a reasonable time, it may be that the TX is not valid.  Alternatively, an attacker
 ; may control your entire internet connection: in this scenario counting broadcasting peers does not help you.</p>
 ;
 ; <p>It is <b>not</b> at this time directly equivalent to the Bitcoin Core memory pool, which tracks
 ; all transactions not currently included in the best chain - it's simply a cache.</p>
 ;;
#_public
(§ class #_"TxConfidenceTable"
    #_protected
    (§ field #_"ReentrantLock" (§ name lock) (§ expr Threading/lock(§ pars "txconfidencetable")))

    #_private
    #_static
    (§ class #_"WeakConfidenceReference" (§ extends #_"WeakReference<TransactionConfidence>")
        #_public
        (§ field #_"Sha256Hash" (§ name hash))

        #_public
        (§ constructor #_"WeakConfidenceReference" [#_"TransactionConfidence" (§ name confidence), #_"ReferenceQueue<TransactionConfidence>" (§ name queue)])
        (§ block
            (§ super (§ pars confidence, queue))

            (§ ass (§ name hash) (§ expr confidence.getTransactionHash(§ pars )))
            (§ void this)
        )
    )
    #_private
    (§ field #_"LinkedHashMap<Sha256Hash, WeakConfidenceReference>" (§ name table))

    ;; This ReferenceQueue gets entries added to it when they are only weakly reachable, i.e. the TxConfidenceTable is
    ;; the only thing that is tracking the confidence data anymore.  We check it from time to time and delete table entries
    ;; corresponding to expired transactions.  In this way memory usage of the system is in line with however many
    ;; transactions you actually care to track the confidence of.  We can still end up with lots of hashes being stored
    ;; if our peers flood us with invs but the MAX_SIZE param caps this.
    #_private
    (§ field #_"ReferenceQueue<TransactionConfidence>" (§ name referenceQueue))

    ;;; The max size of a table created with the no-args constructor. ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name MAX_SIZE) 1000)

    ;;;
     ; Creates a table that will track at most the given number of transactions (allowing you to bound memory usage).
     ; @param size Max number of transactions to track.  The table will fill up to this size then stop growing.
     ;;
    #_public
    (§ constructor #_"TxConfidenceTable" [#_final #_"int" (§ name size)])
    (§ block
        (§ ass (§ name table) (§ new #_"LinkedHashMap<Sha256Hash, WeakConfidenceReference>" (§ pars )
        (§ anon
            #_override
            #_protected
            (§ method #_"boolean" (§ fn removeEldestEntry) [#_"Map.Entry<Sha256Hash, WeakConfidenceReference>" (§ name entry)])
            (§ block
                ;; An arbitrary choice to stop the memory used by tracked transactions getting too huge in the event
                ;; of some kind of DoS attack.
                (§ return (§ expr size < size(§ pars )))
            )
        )))
        (§ ass (§ name referenceQueue) (§ new #_"ReferenceQueue<>" (§ pars )))
        (§ void this)
    )

    ;;;
     ; Creates a table that will track at most {@link TxConfidenceTable#MAX_SIZE} entries.
     ; You should normally use this constructor.
     ;;
    #_public
    (§ constructor #_"TxConfidenceTable" [])
    (§ block
        (§ this (§ pars MAX_SIZE))
        (§ void this)
    )

    ;;;
     ; If any transactions have expired due to being only weakly reachable through us, go ahead and delete their
     ; table entries - it means we downloaded the transaction and sent it to various event listeners, none of
     ; which bothered to keep a reference.  Typically, this is because the transaction does not involve any keys
     ; that are relevant to any of our wallets.
     ;;
    #_private
    (§ method #_"void" (§ fn cleanTable) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"Reference<? extends TransactionConfidence>" (§ name ref))
            (§ while (§ expr (§ ass (§ name ref) (§ expr referenceQueue.poll(§ pars ))) != nil))
            (§ block
                ;; Find which transaction got deleted by the GC.
                (§ var #_"WeakConfidenceReference" (§ name txRef) (§ expr (§ cast #_"WeakConfidenceReference" ref)))
                ;; And remove the associated map entry, so the other bits of memory can also be reclaimed.
                (§ expr table.remove(§ pars txRef.hash))
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Returns the number of peers that have seen the given hash recently.
     ;;
    #_public
    (§ method #_"int" (§ fn numBroadcastPeers) [#_"Sha256Hash" (§ name txHash)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr cleanTable(§ pars ))
            (§ var #_"WeakConfidenceReference" (§ name entry) (§ expr table.get(§ pars txHash)))
            (§ if (§ expr entry == nil))
            (§ block
                (§ return 0) ;; No such TX known.
            )

            (§ var #_"TransactionConfidence" (§ name confidence) (§ expr entry.get(§ pars )))
            (§ if (§ expr confidence == nil))
            (§ block
                ;; Such a TX hash was seen, but nothing seemed to care, so we ended up throwing away the data.
                (§ expr table.remove(§ pars txHash))
                (§ return 0)
            )

            (§ return (§ expr confidence.numBroadcastPeers(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Called by peers when they see a transaction advertised in an "inv" message.  It passes the data on to the relevant
     ; {@link org.bitcoinj.core.TransactionConfidence} object, creating it if needed.
     ;
     ; @return the number of peers that have now announced this hash (including the caller).
     ;;
    #_public
    (§ method #_"TransactionConfidence" (§ fn seen) [#_"Sha256Hash" (§ name hash), #_"PeerAddress" (§ name byPeer)])
    (§ block
        (§ var #_"TransactionConfidence" (§ name confidence))
        (§ var #_"boolean" (§ name fresh) false)
        (§ expr lock.lock(§ pars ))
        (§ block
            (§ expr cleanTable(§ pars ))
            (§ ass (§ name confidence) (§ expr getOrCreate(§ pars hash)))
            (§ ass (§ name fresh) (§ expr confidence.markBroadcastBy(§ pars byPeer)))
        )
        (§ expr lock.unlock(§ pars ))
        (§ if fresh)
        (§ block
            (§ expr confidence.queueListeners(§ pars TransactionConfidence/Listener/ChangeReason/SEEN_PEERS))
        )
        (§ return confidence)
    )

    ;;;
     ; Returns the {@link TransactionConfidence} for the given hash if we have downloaded it, or null if that tx hash
     ; is unknown to the system at this time.
     ;;
    #_public
    (§ method #_"TransactionConfidence" (§ fn getOrCreate) [#_"Sha256Hash" (§ name hash)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars hash))

        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"WeakConfidenceReference" (§ name reference) (§ expr table.get(§ pars hash)))
            (§ if (§ expr reference != nil))
            (§ block
                (§ var #_"TransactionConfidence" (§ name confidence) (§ expr reference.get(§ pars )))
                (§ if (§ expr confidence != nil))
                (§ block
                    (§ return confidence)
                )
            )
            (§ var #_"TransactionConfidence" (§ name newConfidence) (§ new #_"TransactionConfidence" (§ pars hash)))
            (§ expr table.put(§ pars hash, new WeakConfidenceReference(§ pars newConfidence, referenceQueue)))
            (§ return newConfidence)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the {@link TransactionConfidence} for the given hash if we have downloaded it, or null if that tx hash
     ; is unknown to the system at this time.
     ;;
    #_nilable
    #_public
    (§ method #_"TransactionConfidence" (§ fn get) [#_"Sha256Hash" (§ name hash)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"WeakConfidenceReference" (§ name ref) (§ expr table.get(§ pars hash)))
            (§ return (§ quest (§ expr ref != nil) ? (§ expr ref.get(§ pars )) :else nil))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )
)

#_(ns org.bitcoinj.core #_"UTXO"
    (:import [java.io *]
             [java.math *]
             [java.util Locale])
    (:import [com.google.common.base Objects])
   (:require [org.bitcoinj.script *]))

;; TODO: Fix this class: should not talk about addresses, height should be optional/support mempool height etc.

;;;
 ; A UTXO message contains the information necessary to check a spending transaction.
 ; It avoids having to store the entire parentTransaction just to get the hash and index.
 ; Useful when working with free standing outputs.
 ;;
#_public
(§ class #_"UTXO" (§ implements #_"Serializable")
    #_private
    (§ field #_"Coin" (§ name value))
    #_private
    (§ field #_"Script" (§ name script))
    #_private
    (§ field #_"Sha256Hash" (§ name hash))
    #_private
    (§ field #_"long" (§ name index))
    #_private
    (§ field #_"int" (§ name height))
    #_private
    (§ field #_"boolean" (§ name coinbase))
    #_private
    (§ field #_"String" (§ name address))

    ;;;
     ; Creates a stored transaction output.
     ;
     ; @param hash     The hash of the containing transaction.
     ; @param index    The outpoint.
     ; @param value    The value available.
     ; @param height   The height this output was created in.
     ; @param coinbase The coinbase flag.
     ;;
    #_public
    (§ constructor #_"UTXO" [#_"Sha256Hash" (§ name hash), #_"long" (§ name index), #_"Coin" (§ name value), #_"int" (§ name height), #_"boolean" (§ name coinbase), #_"Script" (§ name script)])
    (§ block
        (§ ass (§ name this.hash) hash)
        (§ ass (§ name this.index) index)
        (§ ass (§ name this.value) value)
        (§ ass (§ name this.height) height)
        (§ ass (§ name this.script) script)
        (§ ass (§ name this.coinbase) coinbase)
        (§ ass (§ name this.address) (§ expr ""))
        (§ void this)
    )

    ;;;
     ; Creates a stored transaction output.
     ;
     ; @param hash     The hash of the containing transaction.
     ; @param index    The outpoint.
     ; @param value    The value available.
     ; @param height   The height this output was created in.
     ; @param coinbase The coinbase flag.
     ; @param address  The address.
     ;;
    #_public
    (§ constructor #_"UTXO" [#_"Sha256Hash" (§ name hash), #_"long" (§ name index), #_"Coin" (§ name value), #_"int" (§ name height), #_"boolean" (§ name coinbase), #_"Script" (§ name script), #_"String" (§ name address)])
    (§ block
        (§ this (§ pars hash, index, value, height, coinbase, script))
        (§ ass (§ name this.address) address)
        (§ void this)
    )

    #_public
    (§ constructor #_"UTXO" [#_"InputStream" (§ name in)])
        (§ throws #_"IOException")
    (§ block
        (§ expr deserializeFromStream(§ pars in))
        (§ void this)
    )

    ;;; The value which this Transaction output holds. ;;
    #_public
    (§ method #_"Coin" (§ fn getValue) [])
    (§ block
        (§ return value)
    )

    ;;; The Script object which you can use to get address, script bytes or script type. ;;
    #_public
    (§ method #_"Script" (§ fn getScript) [])
    (§ block
        (§ return script)
    )

    ;;; The hash of the transaction which holds this output. ;;
    #_public
    (§ method #_"Sha256Hash" (§ fn getHash) [])
    (§ block
        (§ return hash)
    )

    ;;; The index of this output in the transaction which holds it. ;;
    #_public
    (§ method #_"long" (§ fn getIndex) [])
    (§ block
        (§ return index)
    )

    ;;; Gets the height of the block that created this output. ;;
    #_public
    (§ method #_"int" (§ fn getHeight) [])
    (§ block
        (§ return height)
    )

    ;;; Gets the flag of whether this was created by a coinbase tx. ;;
    #_public
    (§ method #_"boolean" (§ fn isCoinbase) [])
    (§ block
        (§ return coinbase)
    )

    ;;; The address of this output, can be the empty string if none was provided at construction time or was deserialized. ;;
    #_public
    (§ method #_"String" (§ fn getAddress) [])
    (§ block
        (§ return address)
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr String/format(§ pars Locale/US, "Stored TxOut of %s (%s:%d)", value.toFriendlyString(§ pars ), hash, index)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars getIndex(§ pars ), getHash(§ pars ))))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"UTXO" (§ name other) (§ expr (§ cast #_"UTXO" o)))
        (§ return (§ expr getIndex(§ pars ) == other.getIndex(§ pars ) && getHash(§ pars ).equals(§ pars other.getHash(§ pars ))))
    )

    #_private
    #_static
    #_final
    (§ method #_"void" (§ fn write4x8le) [#_"OutputStream" (§ name os), #_"int" (§ name n)])
        (§ throws #_"IOException")
    (§ block
        (§ expr os.write(§ pars 0xff & n))
        (§ expr os.write(§ pars 0xff & (§ expr n >> 8)))
        (§ expr os.write(§ pars 0xff & (§ expr n >> 16)))
        (§ expr os.write(§ pars 0xff & (§ expr n >> 24)))
        (§ void nil)
    )

    #_public
    (§ method #_"void" (§ fn serializeToStream) [#_"OutputStream" (§ name os)])
        (§ throws #_"IOException")
    (§ block
        (§ expr Utils/uint64ToByteStreamLE(§ pars BigInteger/valueOf(§ pars value.value), os))

        (§ var #_"byte[]" (§ name scriptBytes) (§ expr script.getProgram(§ pars )))
        (§ expr write4x8le(§ pars os, scriptBytes.length))
        (§ expr os.write(§ pars scriptBytes))

        (§ expr os.write(§ pars hash.getBytes(§ pars )))
        (§ expr Utils/uint32ToByteStreamLE(§ pars index, os))

        (§ expr write4x8le(§ pars os, height))
        (§ expr os.write(§ pars (§ new #_"byte[]" (§ coll (§ cast #_"byte" (§ quest coinbase ? 1 :else 0)) ))))
        (§ void nil)
    )

    #_private
    #_static
    #_final
    (§ method #_"int" (§ fn read4x8le) [#_"InputStream" (§ name is)])
        (§ throws #_"IOException")
    (§ block
        (§ return (§ expr (§ expr is.read(§ pars ) & 0xff) | (§ expr (§ expr is.read(§ pars ) & 0xff) << 8) | (§ expr (§ expr is.read(§ pars ) & 0xff) << 16) | (§ expr (§ expr is.read(§ pars ) & 0xff) << 24)))
    )

    #_public
    (§ method #_"void" (§ fn deserializeFromStream) [#_"InputStream" (§ name is)])
        (§ throws #_"IOException")
    (§ block
        (§ var #_"byte[]" (§ name valueBytes) (§ new #_"byte[]" (§ count 8)))
        (§ if (§ expr is.read(§ pars valueBytes, 0, 8) != 8))
        (§ block
            (§ throw (§ new #_"EOFException" (§ pars )))
        )
        (§ ass (§ name value) (§ expr Coin/valueOf(§ pars Utils/readInt64(§ pars valueBytes, 0))))

        (§ var #_"int" (§ name scriptBytesLength) (§ expr read4x8le(§ pars is)))
        (§ var #_"byte[]" (§ name scriptBytes) (§ new #_"byte[]" (§ count scriptBytesLength)))
        (§ if (§ expr is.read(§ pars scriptBytes) != scriptBytesLength))
        (§ block
            (§ throw (§ new #_"EOFException" (§ pars )))
        )
        (§ ass (§ name script) (§ new #_"Script" (§ pars scriptBytes)))

        (§ var #_"byte[]" (§ name hashBytes) (§ new #_"byte[]" (§ count 32)))
        (§ if (§ expr is.read(§ pars hashBytes) != 32))
        (§ block
            (§ throw (§ new #_"EOFException" (§ pars )))
        )
        (§ ass (§ name hash) (§ expr Sha256Hash/wrap(§ pars hashBytes)))

        (§ var #_"byte[]" (§ name indexBytes) (§ new #_"byte[]" (§ count 4)))
        (§ if (§ expr is.read(§ pars indexBytes) != 4))
        (§ block
            (§ throw (§ new #_"EOFException" (§ pars )))
        )
        (§ ass (§ name index) (§ expr Utils/readUint32(§ pars indexBytes, 0)))

        (§ ass (§ name height) (§ expr read4x8le(§ pars is)))

        (§ var #_"byte[]" (§ name coinbaseByte) (§ new #_"byte[]" (§ count 1)))
        (§ expr is.read(§ pars coinbaseByte))
        (§ ass (§ name coinbase) (§ expr coinbaseByte[0] == 1))
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn writeObject) [#_"ObjectOutputStream" (§ name o)])
        (§ throws #_"IOException")
    (§ block
        (§ expr serializeToStream(§ pars o))
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn readObject) [#_"ObjectInputStream" (§ name o)])
        (§ throws #_"IOException", #_"ClassNotFoundException")
    (§ block
        (§ expr deserializeFromStream(§ pars o))
        (§ void nil)
    )
)

#_(ns org.bitcoinj.core #_"UnknownMessage")

;;;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"UnknownMessage" (§ extends #_"EmptyMessage")
    #_private
    (§ field #_"String" (§ name name))

    #_public
    (§ constructor #_"UnknownMessage" [#_"NetworkParameters" (§ name params), #_"String" (§ name name), #_"byte[]" (§ name payloadBytes)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payloadBytes, 0))

        (§ ass (§ name this.name) name)
        (§ void this)
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ str "Unknown message [" + name + "]: " + (§ quest (§ expr payload != nil) ? (§ expr Utils/HEX.encode(§ pars payload)) :else (§ expr ""))))
    )
)

#_(ns org.bitcoinj.core #_"UnsafeByteArrayOutputStream"
    (:import [java.io ByteArrayOutputStream IOException OutputStream]))

;;;
 ; An unsynchronized implementation of ByteArrayOutputStream that will return the backing byte array
 ; if its length == size().  This avoids unneeded array copy where the BOS is simply being used to
 ; extract a byte array of known length from a 'serialized to stream' method.
 ;
 ; Unless the final length can be accurately predicted the only performance this will yield is due
 ; to unsynchronized methods.
 ;
 ; @author git
 ;;
#_public
(§ class #_"UnsafeByteArrayOutputStream" (§ extends #_"ByteArrayOutputStream")
    #_public
    (§ constructor #_"UnsafeByteArrayOutputStream" [])
    (§ block
        (§ super (§ pars 32))
        (§ void this)
    )

    #_public
    (§ constructor #_"UnsafeByteArrayOutputStream" [#_"int" (§ name size)])
    (§ block
        (§ super (§ pars size))
        (§ void this)
    )

    ;;;
     ; Writes the specified byte to this byte array output stream.
     ;
     ; @param b The byte to be written.
     ;;
    #_override
    #_public
    (§ method #_"void" (§ fn write) [#_"int" (§ name b)])
    (§ block
        (§ var #_"int" (§ name n) (§ expr count + 1))
        (§ if (§ expr buf.length < n))
        (§ block
            (§ ass (§ name buf) (§ expr Utils/copyOf(§ pars buf, Math/max(§ pars buf.length << 1, n))))
        )
        (§ ass (§ name buf[count]) (§ cast #_"byte" b))
        (§ ass (§ name count) n)
        (§ void nil)
    )

    ;;;
     ; Writes <code>len</code> bytes from the specified byte array
     ; starting at offset <code>off</code> to this byte array output stream.
     ;
     ; @param b   The data.
     ; @param off The start offset in the data.
     ; @param len The number of bytes to write.
     ;;
    #_override
    #_public
    (§ method #_"void" (§ fn write) [#_"byte[]" (§ name b), #_"int" (§ name off), #_"int" (§ name len)])
    (§ block
        (§ if (§ expr off < 0 || b.length < off || len < 0 || b.length < off + len || off + len < 0))
        (§ block
            (§ throw (§ new #_"IndexOutOfBoundsException" (§ pars )))
        )

        (§ if (§ expr len != 0))
        (§ block
            (§ var #_"int" (§ name n) (§ expr count + len))
            (§ if (§ expr buf.length < n))
            (§ block
                (§ ass (§ name buf) (§ expr Utils/copyOf(§ pars buf, Math/max(§ pars buf.length << 1, n))))
            )
            (§ expr System/arraycopy(§ pars b, off, buf, count, len))
            (§ ass (§ name count) n)
        )
        (§ void nil)
    )

    ;;;
     ; Writes the complete contents of this byte array output stream to
     ; the specified output stream argument, as if by calling the output
     ; stream's write method using <code>out.write(buf, 0, count)</code>.
     ;
     ; @param out The output stream to which to write the data.
     ; @throws IOException if an I/O error occurs.
     ;;
    #_override
    #_public
    (§ method #_"void" (§ fn writeTo) [#_"OutputStream" (§ name out)])
        (§ throws #_"IOException")
    (§ block
        (§ expr out.write(§ pars buf, 0, count))
        (§ void nil)
    )

    ;;;
     ; Resets the <code>count</code> field of this byte array output
     ; stream to zero, so that all currently accumulated output in the
     ; output stream is discarded.  The output stream can be used again,
     ; reusing the already allocated buffer space.
     ;
     ; @see java.io.ByteArrayInputStream#count
     ;;
    #_override
    #_public
    (§ method #_"void" (§ fn reset) [])
    (§ block
        (§ ass (§ name count) 0)
        (§ void nil)
    )

    ;;;
     ; Creates a newly allocated byte array.  Its size is the current
     ; size of this output stream and the valid contents of the buffer
     ; have been copied into it.
     ;
     ; @return the current contents of this output stream, as a byte array.
     ; @see java.io.ByteArrayOutputStream#size()
     ;;
    #_override
    #_public
    (§ method #_"byte[]" (§ fn toByteArray) [])
    (§ block
        (§ return (§ quest (§ expr count == buf.length) ? buf :else (§ expr Utils/copyOf(§ pars buf, count))))
    )

    ;;;
     ; Returns the current size of the buffer.
     ;
     ; @return the value of the <code>count</code> field, which is the number
     ;         of valid bytes in this output stream.
     ; @see java.io.ByteArrayOutputStream#count
     ;;
    #_override
    #_public
    (§ method #_"int" (§ fn size) [])
    (§ block
        (§ return count)
    )
)

#_(ns org.bitcoinj.core #_"Utils"
    (:import [java.io ByteArrayOutputStream IOException InputStream OutputStream UnsupportedEncodingException]
             [java.math BigInteger]
             [java.net URL]
             [java.text DateFormat SimpleDateFormat]
             [java.util *]
             [java.util.concurrent ArrayBlockingQueue BlockingQueue TimeUnit])
    (:import [com.google.common.base Charsets Joiner Preconditions]
             [com.google.common.collect Lists Ordering]
             [com.google.common.io BaseEncoding Resources]
             [com.google.common.primitives Ints UnsignedLongs]
             #_static [com.google.common.util.concurrent.Uninterruptibles sleepUninterruptibly]
             [org.spongycastle.crypto.digests RIPEMD160Digest]))

;;;
 ; A collection of various utility methods that are helpful for working with the Bitcoin protocol.
 ; To enable debug logging from the library, run with -Dbitcoinj.logging=true on your command line.
 ;;
#_public
(§ class #_"Utils"
    ;;; The string that prefixes all text messages signed using Bitcoin keys. ;;
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name BITCOIN_SIGNED_MESSAGE_HEADER) (§ expr "Bitcoin Signed Message:\n"))
    #_public
    #_static
    #_final
    (§ field #_"byte[]" (§ name BITCOIN_SIGNED_MESSAGE_HEADER_BYTES) (§ expr BITCOIN_SIGNED_MESSAGE_HEADER.getBytes(§ pars Charsets/UTF_8)))

    #_public
    #_static
    #_final
    (§ field #_"Joiner" (§ name SPACE_JOINER) (§ expr Joiner/on(§ pars " ")))

    #_private
    #_static
    (§ field #_"BlockingQueue<Boolean>" (§ name mockSleepQueue))

    ;;;
     ; The regular {@link java.math.BigInteger#toByteArray()} includes the sign bit of the number and
     ; might result in an extra byte addition.  This method removes this extra byte.
     ;
     ; Assuming only positive numbers, it's possible to discriminate if an extra byte
     ; is added by checking if the first element of the array is 0 (0000_0000).
     ; Due to the minimal representation provided by BigInteger, it means that the bit sign
     ; is the least significant bit 0000_000<b>0</b>.  Otherwise the representation is not minimal.
     ; For example, if the sign bit is 0000_00<b>0</b>0, then the representation is not minimal due to the rightmost zero.
     ;
     ; @param b The integer to format into a byte array.
     ; @param numBytes The desired size of the resulting byte array.
     ; @return numBytes byte long array.
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn bigIntegerToBytes) [#_"BigInteger" (§ name b), #_"int" (§ name numBytes)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars 0 <= b.signum(§ pars ), "b must be positive or zero"))
        (§ expr Preconditions/checkArgument(§ pars 0 < numBytes, "numBytes must be positive"))

        (§ var #_"byte[]" (§ name src) (§ expr b.toByteArray(§ pars )))
        (§ var #_"byte[]" (§ name dest) (§ new #_"byte[]" (§ count numBytes)))
        (§ var #_"boolean" (§ name isFirstByteOnlyForSign) (§ expr src[0] == 0))
        (§ var #_"int" (§ name length) (§ quest isFirstByteOnlyForSign ? (§ expr src.length - 1) :else (§ expr src.length)))

        (§ expr Preconditions/checkArgument(§ pars length <= numBytes, "The given number does not fit in " + numBytes))

        (§ var #_"int" (§ name srcPos) (§ quest isFirstByteOnlyForSign ? 1 :else 0))
        (§ var #_"int" (§ name destPos) (§ expr numBytes - length))
        (§ expr System/arraycopy(§ pars src, srcPos, dest, destPos, length))
        (§ return dest)
    )

    #_public
    #_static
    (§ method #_"void" (§ fn uint32ToByteArrayBE) [#_"long" (§ name val), #_"byte[]" (§ name out), #_"int" (§ name offset)])
    (§ block
        (§ ass (§ name out[offset]) (§ cast #_"byte" (§ expr 0xff & (§ expr val >> 24))))
        (§ ass (§ name out[offset + 1]) (§ cast #_"byte" (§ expr 0xff & (§ expr val >> 16))))
        (§ ass (§ name out[offset + 2]) (§ cast #_"byte" (§ expr 0xff & (§ expr val >> 8))))
        (§ ass (§ name out[offset + 3]) (§ cast #_"byte" (§ expr 0xff & val)))
        (§ void nil)
    )

    #_public
    #_static
    (§ method #_"void" (§ fn uint32ToByteArrayLE) [#_"long" (§ name val), #_"byte[]" (§ name out), #_"int" (§ name offset)])
    (§ block
        (§ ass (§ name out[offset]) (§ cast #_"byte" (§ expr 0xff & val)))
        (§ ass (§ name out[offset + 1]) (§ cast #_"byte" (§ expr 0xff & (§ expr val >> 8))))
        (§ ass (§ name out[offset + 2]) (§ cast #_"byte" (§ expr 0xff & (§ expr val >> 16))))
        (§ ass (§ name out[offset + 3]) (§ cast #_"byte" (§ expr 0xff & (§ expr val >> 24))))
        (§ void nil)
    )

    #_public
    #_static
    (§ method #_"void" (§ fn uint64ToByteArrayLE) [#_"long" (§ name val), #_"byte[]" (§ name out), #_"int" (§ name offset)])
    (§ block
        (§ ass (§ name out[offset]) (§ cast #_"byte" (§ expr 0xff & val)))
        (§ ass (§ name out[offset + 1]) (§ cast #_"byte" (§ expr 0xff & (§ expr val >> 8))))
        (§ ass (§ name out[offset + 2]) (§ cast #_"byte" (§ expr 0xff & (§ expr val >> 16))))
        (§ ass (§ name out[offset + 3]) (§ cast #_"byte" (§ expr 0xff & (§ expr val >> 24))))
        (§ ass (§ name out[offset + 4]) (§ cast #_"byte" (§ expr 0xff & (§ expr val >> 32))))
        (§ ass (§ name out[offset + 5]) (§ cast #_"byte" (§ expr 0xff & (§ expr val >> 40))))
        (§ ass (§ name out[offset + 6]) (§ cast #_"byte" (§ expr 0xff & (§ expr val >> 48))))
        (§ ass (§ name out[offset + 7]) (§ cast #_"byte" (§ expr 0xff & (§ expr val >> 56))))
        (§ void nil)
    )

    #_public
    #_static
    (§ method #_"void" (§ fn uint32ToByteStreamLE) [#_"long" (§ name val), #_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ expr stream.write(§ pars (§ cast #_"int" (§ expr 0xff & val))))
        (§ expr stream.write(§ pars (§ cast #_"int" (§ expr 0xff & (§ expr val >> 8)))))
        (§ expr stream.write(§ pars (§ cast #_"int" (§ expr 0xff & (§ expr val >> 16)))))
        (§ expr stream.write(§ pars (§ cast #_"int" (§ expr 0xff & (§ expr val >> 24)))))
        (§ void nil)
    )

    #_public
    #_static
    (§ method #_"void" (§ fn int64ToByteStreamLE) [#_"long" (§ name val), #_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ expr stream.write(§ pars (§ cast #_"int" (§ expr 0xff & val))))
        (§ expr stream.write(§ pars (§ cast #_"int" (§ expr 0xff & (§ expr val >> 8)))))
        (§ expr stream.write(§ pars (§ cast #_"int" (§ expr 0xff & (§ expr val >> 16)))))
        (§ expr stream.write(§ pars (§ cast #_"int" (§ expr 0xff & (§ expr val >> 24)))))
        (§ expr stream.write(§ pars (§ cast #_"int" (§ expr 0xff & (§ expr val >> 32)))))
        (§ expr stream.write(§ pars (§ cast #_"int" (§ expr 0xff & (§ expr val >> 40)))))
        (§ expr stream.write(§ pars (§ cast #_"int" (§ expr 0xff & (§ expr val >> 48)))))
        (§ expr stream.write(§ pars (§ cast #_"int" (§ expr 0xff & (§ expr val >> 56)))))
        (§ void nil)
    )

    #_public
    #_static
    (§ method #_"void" (§ fn uint64ToByteStreamLE) [#_"BigInteger" (§ name val), #_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ var #_"byte[]" (§ name bytes) (§ expr val.toByteArray(§ pars )))
        (§ if (§ expr 8 < bytes.length))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars "Input too large to encode into a uint64")))
        )

        (§ ass (§ name bytes) (§ expr reverseBytes(§ pars bytes)))
        (§ expr stream.write(§ pars bytes))
        (§ if (§ expr bytes.length < 8))
        (§ block
            (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < 8 - bytes.length) :for (§ ass (§ name i) (§ expr i + 1)))
            (§ block
                (§ expr stream.write(§ pars 0))
            )
        )
        (§ void nil)
    )

    ;;;
     ; Work around lack of unsigned types in Java.
     ;;
    #_public
    #_static
    (§ method #_"boolean" (§ fn isLessThanUnsigned) [#_"long" (§ name n1), #_"long" (§ name n2)])
    (§ block
        (§ return (§ expr UnsignedLongs/compare(§ pars n1, n2) < 0))
    )

    ;;;
     ; Work around lack of unsigned types in Java.
     ;;
    #_public
    #_static
    (§ method #_"boolean" (§ fn isLessThanOrEqualToUnsigned) [#_"long" (§ name n1), #_"long" (§ name n2)])
    (§ block
        (§ return (§ expr UnsignedLongs/compare(§ pars n1, n2) <= 0))
    )

    ;;;
     ; Hex encoding used throughout the framework.  Use with HEX.encode(byte[]) or HEX.decode(CharSequence).
     ;;
    #_public
    #_static
    #_final
    (§ field #_"BaseEncoding" (§ name HEX) (§ expr BaseEncoding/base16(§ pars ).lowerCase(§ pars )))

    ;;;
     ; Returns a copy of the given byte array in reverse order.
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn reverseBytes) [#_"byte[]" (§ name bytes)])
    (§ block
        ;; We could use the XOR trick here, but it's easier to understand if we don't.
        ;; If we find this is really a performance issue, the matter can be revisited.
        (§ var #_"byte[]" (§ name buf) (§ new #_"byte[]" (§ count bytes.length)))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < bytes.length) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ ass (§ name buf[i]) (§ expr bytes[bytes.length - 1 - i]))
        )
        (§ return buf)
    )

    ;;;
     ; Returns a copy of the given byte array with the bytes of each double-word (4 bytes) reversed.
     ;
     ; @param bytes Length must be divisible by 4.
     ; @param trimLength Trim output to this length.  If positive, must be divisible by 4.
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn reverseDwordBytes) [#_"byte[]" (§ name bytes), #_"int" (§ name trimLength)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars bytes.length % 4 == 0))
        (§ expr Preconditions/checkArgument(§ pars trimLength < 0 || trimLength % 4 == 0))

        (§ var #_"byte[]" (§ name rev) (§ new #_"byte[]" (§ count (§ quest (§ expr 0 <= trimLength && trimLength < bytes.length) ? trimLength :else (§ expr bytes.length)))))

        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < rev.length) :for (§ ass (§ name i) (§ expr i + 4)))
        (§ block
            (§ expr System/arraycopy(§ pars bytes, i, rev, i , 4))
            (§ for (§ var #_"int" (§ name j) 0) :for (§ expr j < 4) :for (§ ass (§ name j) (§ expr j + 1)))
            (§ block
                (§ ass (§ name rev[i + j]) (§ expr bytes[i + 3 - j]))
            )
        )
        (§ return rev)
    )

    ;;; Parse 4 bytes from the byte array (starting at the offset) as unsigned 32-bit integer in little endian format. ;;
    #_public
    #_static
    (§ method #_"long" (§ fn readUint32) [#_"byte[]" (§ name bytes), #_"int" (§ name offset)])
    (§ block
        (§ return (§ expr (§ expr bytes[offset] & 0xff) | (§ expr (§ expr bytes[offset + 1] & 0xff) << 8) | (§ expr (§ expr bytes[offset + 2] & 0xff) << 16) | (§ expr (§ expr bytes[offset + 3] & 0xff) << 24)))
    )

    ;;; Parse 8 bytes from the byte array (starting at the offset) as signed 64-bit integer in little endian format. ;;
    #_public
    #_static
    (§ method #_"long" (§ fn readInt64) [#_"byte[]" (§ name bytes), #_"int" (§ name offset)])
    (§ block
        (§ return (§ expr (§ expr bytes[offset] & 0xff) | (§ expr (§ expr bytes[offset + 1] & 0xff) << 8) | (§ expr (§ expr bytes[offset + 2] & 0xff) << 16) | (§ expr (§ expr bytes[offset + 3] & 0xff) << 24) | (§ expr (§ expr bytes[offset + 4] & 0xff) << 32) | (§ expr (§ expr bytes[offset + 5] & 0xff) << 40) | (§ expr (§ expr bytes[offset + 6] & 0xff) << 48) | (§ expr (§ expr bytes[offset + 7] & 0xff) << 56)))
    )

    ;;; Parse 4 bytes from the byte array (starting at the offset) as unsigned 32-bit integer in big endian format. ;;
    #_public
    #_static
    (§ method #_"long" (§ fn readUint32BE) [#_"byte[]" (§ name bytes), #_"int" (§ name offset)])
    (§ block
        (§ return (§ expr (§ expr (§ expr bytes[offset] & 0xff) << 24) |  (§ expr (§ expr bytes[offset + 1] & 0xff) << 16) |  (§ expr (§ expr bytes[offset + 2] & 0xff) << 8) |   (§ expr bytes[offset + 3] & 0xff)))
    )

    ;;; Parse 2 bytes from the byte array (starting at the offset) as unsigned 16-bit integer in big endian format. ;;
    #_public
    #_static
    (§ method #_"int" (§ fn readUint16BE) [#_"byte[]" (§ name bytes), #_"int" (§ name offset)])
    (§ block
        (§ return (§ expr (§ expr (§ expr bytes[offset] & 0xff) << 8) |   (§ expr bytes[offset + 1] & 0xff)))
    )

    ;;;
     ; Calculates RIPEMD160(SHA256(input)).  This is used in Address calculations.
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn sha256hash160) [#_"byte[]" (§ name input)])
    (§ block
        (§ var #_"byte[]" (§ name sha256) (§ expr Sha256Hash/hash(§ pars input)))
        (§ var #_"RIPEMD160Digest" (§ name digest) (§ new #_"RIPEMD160Digest" (§ pars )))
        (§ expr digest.update(§ pars sha256, 0, sha256.length))
        (§ var #_"byte[]" (§ name out) (§ new #_"byte[]" (§ count 20)))
        (§ expr digest.doFinal(§ pars out, 0))
        (§ return out)
    )

    ;;;
     ; MPI encoded numbers are produced by the OpenSSL BN_bn2mpi function.  They consist of
     ; a 4 byte big endian length field, followed by the stated number of bytes representing
     ; the number in big endian format (with a sign bit).
     ; @param hasLength can be set to false if the given array is missing the 4 byte length field.
     ;;
    #_public
    #_static
    (§ method #_"BigInteger" (§ fn decodeMPI) [#_"byte[]" (§ name mpi), #_"boolean" (§ name hasLength)])
    (§ block
        (§ var #_"byte[]" (§ name buf))
        (§ if hasLength)
        (§ block
            (§ var #_"int" (§ name length) (§ expr (§ cast #_"int" (§ expr readUint32BE(§ pars mpi, 0)))))
            (§ ass (§ name buf) (§ new #_"byte[]" (§ count length)))
            (§ expr System/arraycopy(§ pars mpi, 4, buf, 0, length))
        )
        (§ else )
        (§ block
            (§ ass (§ name buf) mpi)
        )
        (§ if (§ expr buf.length == 0))
        (§ block
            (§ return (§ expr BigInteger/ZERO))
        )

        (§ var #_"boolean" (§ name isNegative) (§ expr (§ expr buf[0] & 0x80) == 0x80))
        (§ if isNegative)
        (§ block
            (§ ass (§ name buf[0]) (§ expr buf[0] & 0x7f))
        )
        (§ var #_"BigInteger" (§ name result) (§ new #_"BigInteger" (§ pars buf)))
        (§ return (§ quest isNegative ? (§ expr result.negate(§ pars )) :else result))
    )

    ;;;
     ; MPI encoded numbers are produced by the OpenSSL BN_bn2mpi function.  They consist of
     ; a 4 byte big endian length field, followed by the stated number of bytes representing
     ; the number in big endian format (with a sign bit).
     ; @param includeLength indicates whether the 4 byte length field should be included.
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn encodeMPI) [#_"BigInteger" (§ name value), #_"boolean" (§ name includeLength)])
    (§ block
        (§ if (§ expr value.equals(§ pars BigInteger/ZERO)))
        (§ block
            (§ return (§ quest includeLength ? (§ new #_"byte[]" (§ coll 0x00, 0x00, 0x00, 0x00 )) :else (§ new #_"byte[]" (§ coll ))))
        )

        (§ var #_"boolean" (§ name isNegative) (§ expr value.signum(§ pars ) < 0))
        (§ if isNegative)
        (§ block
            (§ ass (§ name value) (§ expr value.negate(§ pars )))
        )
        (§ var #_"byte[]" (§ name array) (§ expr value.toByteArray(§ pars )))
        (§ var #_"int" (§ name length) (§ expr array.length))
        (§ if (§ expr (§ expr array[0] & 0x80) == 0x80))
        (§ block
            (§ ass (§ name length) (§ expr length + 1))
        )

        (§ if includeLength)
        (§ block
            (§ var #_"byte[]" (§ name result) (§ new #_"byte[]" (§ count length + 4)))
            (§ expr System/arraycopy(§ pars array, 0, result, length - array.length + 3, array.length))
            (§ expr uint32ToByteArrayBE(§ pars length, result, 0))
            (§ if isNegative)
            (§ block
                (§ ass (§ name result[4]) (§ expr result[4] | 0x80))
            )
            (§ return result)
        )
        (§ else )
        (§ block
            (§ var #_"byte[]" (§ name result))
            (§ if (§ expr length != array.length))
            (§ block
                (§ ass (§ name result) (§ new #_"byte[]" (§ count length)))
                (§ expr System/arraycopy(§ pars array, 0, result, 1, array.length))
            )
            (§ else )
            (§ block
                (§ ass (§ name result) array)
            )
            (§ if isNegative)
            (§ block
                (§ ass (§ name result[0]) (§ expr result[0] | 0x80))
            )
            (§ return result)
        )
    )

    ;;;
     ; <p>The "compact" format is a representation of a whole number N using an unsigned 32 bit number similar to
     ; a floating point format.  The most significant 8 bits are the unsigned exponent of base 256.  This exponent
     ; can be thought of as "number of bytes of N".  The lower 23 bits are the mantissa.  Bit number 24 (0x800000)
     ; represents the sign of N.  Therefore, N = (-1^sign) * mantissa * 256^(exponent-3).</p>
     ;
     ; <p>Satoshi's original implementation used BN_bn2mpi() and BN_mpi2bn().  MPI uses the most significant bit of
     ; the first byte as sign.  Thus 0x1234560000 is compact 0x05123456 and 0xc0de000000 is compact 0x0600c0de.
     ; Compact 0x05c0de00 would be -0x40de000000.</p>
     ;
     ; <p>Bitcoin only uses this "compact" format for encoding difficulty targets, which are unsigned 256bit quantities.
     ; Thus, all the complexities of the sign bit and using base 256 are probably an implementation accident.</p>
     ;;
    #_public
    #_static
    (§ method #_"BigInteger" (§ fn decodeCompactBits) [#_"long" (§ name compact)])
    (§ block
        (§ var #_"int" (§ name size) (§ expr (§ expr (§ cast #_"int" (§ expr compact >> 24))) & 0xff))
        (§ var #_"byte[]" (§ name bytes) (§ new #_"byte[]" (§ count 4 + size)))
        (§ ass (§ name bytes[3]) (§ cast #_"byte" size))
        (§ if (§ expr 1 <= size))
        (§ block
            (§ ass (§ name bytes[4]) (§ cast #_"byte" (§ expr (§ expr compact >> 16) & 0xff)))
        )
        (§ if (§ expr 2 <= size))
        (§ block
            (§ ass (§ name bytes[5]) (§ cast #_"byte" (§ expr (§ expr compact >> 8) & 0xff)))
        )
        (§ if (§ expr 3 <= size))
        (§ block
            (§ ass (§ name bytes[6]) (§ cast #_"byte" (§ expr compact & 0xff)))
        )
        (§ return (§ expr decodeMPI(§ pars bytes, true)))
    )

    ;;;
     ; @see Utils#decodeCompactBits(long)
     ;;
    #_public
    #_static
    (§ method #_"long" (§ fn encodeCompactBits) [#_"BigInteger" (§ name value)])
    (§ block
        (§ var #_"long" (§ name result))
        (§ var #_"int" (§ name size) (§ expr value.toByteArray(§ pars ).length))
        (§ if (§ expr size <= 3))
        (§ block
            (§ ass (§ name result) (§ expr value.longValue(§ pars ) << 8 * (§ expr 3 - size)))
        )
        (§ else )
        (§ block
            (§ ass (§ name result) (§ expr value.shiftRight(§ pars 8 * (§ expr size - 3)).longValue(§ pars )))
        )
        ;; The 0x00800000 bit denotes the sign.
        ;; Thus, if it is already set, divide the mantissa by 256 and increase the exponent.
        (§ if (§ expr (§ expr result & 0x00800000) != 0))
        (§ block
            (§ ass (§ name result) (§ expr result >> 8))
            (§ ass (§ name size) (§ expr size + 1))
        )
        (§ ass (§ name result) (§ expr result | (§ expr size << 24)))
        (§ ass (§ name result) (§ expr result | (§ quest (§ expr (§ expr value.signum(§ pars )) == -1) ? 0x00800000 :else 0)))
        (§ return result)
    )

    ;;;
     ; If non-null, overrides the return value of now().
     ;;
    #_public
    #_static
    #_volatile
    (§ field #_"Date" (§ name mockTime))

    ;;;
     ; Advances (or rewinds) the mock clock by the given number of seconds.
     ;;
    #_public
    #_static
    (§ method #_"Date" (§ fn rollMockClock) [#_"int" (§ name seconds)])
    (§ block
        (§ return (§ expr rollMockClockMillis(§ pars seconds * 1000)))
    )

    ;;;
     ; Advances (or rewinds) the mock clock by the given number of milliseconds.
     ;;
    #_public
    #_static
    (§ method #_"Date" (§ fn rollMockClockMillis) [#_"long" (§ name millis)])
    (§ block
        (§ if (§ expr mockTime == nil))
        (§ block
            (§ throw (§ new #_"IllegalStateException" (§ pars "You need to use setMockClock() first.")))
        )

        (§ ass (§ name mockTime) (§ new #_"Date" (§ pars mockTime.getTime(§ pars ) + millis)))
        (§ return mockTime)
    )

    ;;;
     ; Sets the mock clock to the current time.
     ;;
    #_public
    #_static
    (§ method #_"void" (§ fn setMockClock) [])
    (§ block
        (§ ass (§ name mockTime) (§ new #_"Date" (§ pars )))
        (§ void nil)
    )

    ;;;
     ; Sets the mock clock to the given time (in seconds).
     ;;
    #_public
    #_static
    (§ method #_"void" (§ fn setMockClock) [#_"long" (§ name mockClockSeconds)])
    (§ block
        (§ ass (§ name mockTime) (§ new #_"Date" (§ pars mockClockSeconds * 1000)))
        (§ void nil)
    )

    ;;;
     ; Returns the current time, or a mocked out equivalent.
     ;;
    #_public
    #_static
    (§ method #_"Date" (§ fn now) [])
    (§ block
        (§ return (§ quest (§ expr mockTime != nil) ? mockTime :else (§ new #_"Date" (§ pars ))))
    )

    ;; TODO: Replace usages of this where the result is / 1000 with currentTimeSeconds.
    ;;; Returns the current time in milliseconds since the epoch, or a mocked out equivalent. ;;
    #_public
    #_static
    (§ method #_"long" (§ fn currentTimeMillis) [])
    (§ block
        (§ return (§ quest (§ expr mockTime != nil) ? (§ expr mockTime.getTime(§ pars )) :else (§ expr System/currentTimeMillis(§ pars ))))
    )

    #_public
    #_static
    (§ method #_"long" (§ fn currentTimeSeconds) [])
    (§ block
        (§ return (§ expr currentTimeMillis(§ pars ) / 1000))
    )

    #_private
    #_static
    #_final
    (§ field #_"TimeZone" (§ name UTC) (§ expr TimeZone/getTimeZone(§ pars "UTC")))

    ;;;
     ; Formats a given date+time value to an ISO 8601 string.
     ; @param dateTime value to format, as a Date
     ;;
    #_public
    #_static
    (§ method #_"String" (§ fn dateTimeFormat) [#_"Date" (§ name dateTime)])
    (§ block
        (§ var #_"DateFormat" (§ name iso8601) (§ new #_"SimpleDateFormat" (§ pars "yyyy-MM-dd'T'HH:mm:ss'Z'", Locale/US)))
        (§ expr iso8601.setTimeZone(§ pars UTC))
        (§ return (§ expr iso8601.format(§ pars dateTime)))
    )

    ;;;
     ; Formats a given date+time value to an ISO 8601 string.
     ; @param dateTime value to format, unix time (ms)
     ;;
    #_public
    #_static
    (§ method #_"String" (§ fn dateTimeFormat) [#_"long" (§ name dateTime)])
    (§ block
        (§ var #_"DateFormat" (§ name iso8601) (§ new #_"SimpleDateFormat" (§ pars "yyyy-MM-dd'T'HH:mm:ss'Z'", Locale/US)))
        (§ expr iso8601.setTimeZone(§ pars UTC))
        (§ return (§ expr iso8601.format(§ pars dateTime)))
    )

    #_public
    #_static
    (§ method #_"byte[]" (§ fn copyOf) [#_"byte[]" (§ name in), #_"int" (§ name length)])
    (§ block
        (§ var #_"byte[]" (§ name out) (§ new #_"byte[]" (§ count length)))
        (§ expr System/arraycopy(§ pars in, 0, out, 0, Math/min(§ pars length, in.length)))
        (§ return out)
    )

    ;;;
     ; Creates a copy of bytes and appends b to the end of it.
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn appendByte) [#_"byte[]" (§ name bytes), #_"byte" (§ name b)])
    (§ block
        (§ var #_"byte[]" (§ name result) (§ expr Arrays/copyOf(§ pars bytes, bytes.length + 1)))
        (§ ass (§ name result[result.length - 1]) b)
        (§ return result)
    )

    ;;;
     ; Constructs a new String by decoding the given bytes using the specified charset.
     ;
     ; This is a convenience method which wraps the checked exception with a RuntimeException.
     ; The exception can never occur given the charsets
     ; US-ASCII, ISO-8859-1, UTF-8, UTF-16, UTF-16LE or UTF-16BE.
     ;
     ; @param bytes The bytes to be decoded into characters.
     ; @param charsetName The name of a supported {@linkplain java.nio.charset.Charset charset}.
     ; @return the decoded String.
     ;;
    #_public
    #_static
    (§ method #_"String" (§ fn toString) [#_"byte[]" (§ name bytes), #_"String" (§ name charsetName)])
    (§ block
        (§ try )
        (§ block
            (§ return (§ new #_"String" (§ pars bytes, charsetName)))
        )
        (§ catch #_"UnsupportedEncodingException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
    )

    ;;;
     ; Encodes the given string into a sequence of bytes using the named charset.
     ;
     ; This is a convenience method which wraps the checked exception with a RuntimeException.
     ; The exception can never occur given the charsets
     ; US-ASCII, ISO-8859-1, UTF-8, UTF-16, UTF-16LE or UTF-16BE.
     ;
     ; @param str The string to encode into bytes.
     ; @param charsetName The name of a supported {@linkplain java.nio.charset.Charset charset}.
     ; @return the encoded bytes.
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn toBytes) [#_"CharSequence" (§ name str), #_"String" (§ name charsetName)])
    (§ block
        (§ try )
        (§ block
            (§ return (§ expr str.toString(§ pars ).getBytes(§ pars charsetName)))
        )
        (§ catch #_"UnsupportedEncodingException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
    )

    ;;;
     ; Attempts to parse the given string as arbitrary-length hex or base58 and then return the results,
     ; or null if neither parse was successful.
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn parseAsHexOrBase58) [#_"String" (§ name data)])
    (§ block
        (§ try )
        (§ block
            (§ return (§ expr HEX.decode(§ pars data)))
        )
        (§ catch #_"Exception" (§ name _))
        (§ block
            ;; Didn't decode as hex, try base58.
            (§ try )
            (§ block
                (§ return (§ expr Base58/decodeChecked(§ pars data)))
            )
            (§ catch #_"AddressFormatException" (§ name __))
            (§ block
                (§ return nil)
            )
        )
    )

    #_public
    #_static
    (§ method #_"boolean" (§ fn isWindows) [])
    (§ block
        (§ return (§ expr System/getProperty(§ pars "os.name").toLowerCase(§ pars ).contains(§ pars "win")))
    )

    ;;;
     ; <p>Given a textual message, returns a byte buffer formatted as follows:</p>
     ;
     ; <p><tt>[24] "Bitcoin Signed Message:\n" [message.length as a varint] message</tt>.</p>
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn formatMessageForSigning) [#_"String" (§ name message)])
    (§ block
        (§ try )
        (§ block
            (§ var #_"ByteArrayOutputStream" (§ name bos) (§ new #_"ByteArrayOutputStream" (§ pars )))
            (§ expr bos.write(§ pars BITCOIN_SIGNED_MESSAGE_HEADER_BYTES.length))
            (§ expr bos.write(§ pars BITCOIN_SIGNED_MESSAGE_HEADER_BYTES))
            (§ var #_"byte[]" (§ name messageBytes) (§ expr message.getBytes(§ pars Charsets/UTF_8)))
            (§ var #_"VarInt" (§ name size) (§ new #_"VarInt" (§ pars messageBytes.length)))
            (§ expr bos.write(§ pars size.encode(§ pars )))
            (§ expr bos.write(§ pars messageBytes))
            (§ return (§ expr bos.toByteArray(§ pars )))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
    )

    ;; 00000001, 00000010, 00000100, 00001000, ...
    #_private
    #_static
    #_final
    (§ field #_"int[]" (§ name bitMask) (§ coll 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 ))

    ;;; Checks if the given bit is set in data, using little endian (not the same as Java native big endian). ;;
    #_public
    #_static
    (§ method #_"boolean" (§ fn checkBitLE) [#_"byte[]" (§ name data), #_"int" (§ name index)])
    (§ block
        (§ return (§ expr (§ expr data[index >>> 3] & bitMask[7 & index]) != 0))
    )

    ;;; Sets the given bit in data to one, using little endian (not the same as Java native big endian). ;;
    #_public
    #_static
    (§ method #_"void" (§ fn setBitLE) [#_"byte[]" (§ name data), #_"int" (§ name index)])
    (§ block
        (§ ass (§ name data[index >>> 3]) (§ expr data[index >>> 3] | bitMask[7 & index]))
        (§ void nil)
    )

    ;;; Sleep for a span of time, or mock sleep if enabled. ;;
    #_public
    #_static
    (§ method #_"void" (§ fn sleep) [#_"long" (§ name millis)])
    (§ block
        (§ if (§ expr mockSleepQueue == nil))
        (§ block
            (§ expr sleepUninterruptibly(§ pars millis, TimeUnit/MILLISECONDS))
        )
        (§ else )
        (§ block
            (§ try )
            (§ block
                (§ var #_"boolean" (§ name isMultiPass) (§ expr mockSleepQueue.take(§ pars )))
                (§ expr rollMockClockMillis(§ pars millis))
                (§ if isMultiPass)
                (§ block
                    (§ expr mockSleepQueue.offer(§ pars true))
                )
            )
            (§ catch #_"InterruptedException" (§ name _))
            (§ block
                ;; Ignored.
            )
        )
        (§ void nil)
    )

    ;;; Enable or disable mock sleep.  If enabled, set mock time to current time. ;;
    #_public
    #_static
    (§ method #_"void" (§ fn setMockSleep) [#_"boolean" (§ name isEnable)])
    (§ block
        (§ if isEnable)
        (§ block
            (§ ass (§ name mockSleepQueue) (§ new #_"ArrayBlockingQueue<>" (§ pars 1)))
            (§ ass (§ name mockTime) (§ new #_"Date" (§ pars System/currentTimeMillis(§ pars ))))
        )
        (§ else )
        (§ block
            (§ ass (§ name mockSleepQueue) nil)
        )
        (§ void nil)
    )

    ;;; Let sleeping thread pass the synchronization point. ;;
    #_public
    #_static
    (§ method #_"void" (§ fn passMockSleep) [])
    (§ block
        (§ expr mockSleepQueue.offer(§ pars false))
        (§ void nil)
    )

    ;;; Let the sleeping thread pass the synchronization point any number of times. ;;
    #_public
    #_static
    (§ method #_"void" (§ fn finishMockSleep) [])
    (§ block
        (§ if (§ expr mockSleepQueue != nil))
        (§ block
            (§ expr mockSleepQueue.offer(§ pars true))
        )
        (§ void nil)
    )

    #_private
    #_static
    (§ field #_"int" (§ name isAndroid) -1)
    #_public
    #_static
    (§ method #_"boolean" (§ fn isAndroidRuntime) [])
    (§ block
        (§ if (§ expr isAndroid == -1))
        (§ block
            #_final
            (§ var #_"String" (§ name runtime) (§ expr System/getProperty(§ pars "java.runtime.name")))
            (§ ass (§ name isAndroid) (§ quest (§ expr runtime != nil && runtime.equals(§ pars "Android Runtime")) ? 1 :else 0))
        )
        (§ return (§ expr isAndroid == 1))
    )

    #_private
    #_static
    (§ class #_"Pair" (§ implements #_"Comparable<Pair>")
        (§ var #_"int" (§ name item))
        (§ var #_"int" (§ name count))

        #_public
        (§ constructor #_"Pair" [#_"int" (§ name item), #_"int" (§ name count)])
        (§ block
            (§ ass (§ name this.count) count)
            (§ ass (§ name this.item) item)
            (§ void this)
        )

        ;; Note that in this implementation compareTo() is not consistent with equals().
        #_override
        #_public
        (§ method #_"int" (§ fn compareTo) [#_"Pair" (§ name o)])
        (§ block
            (§ return (§ expr (§ neg Ints/compare(§ pars count, o.count))))
        )
    )

    #_public
    #_static
    (§ method #_"int" (§ fn maxOfMostFreq) [#_"int..." (§ name items)])
    (§ block
        ;; Java 6 sucks.
        (§ var #_"ArrayList<Integer>" (§ name list) (§ new #_"ArrayList<>" (§ pars items.length)))
        (§ for (§ var #_"int" (§ name item)) :for items)
        (§ block
            (§ expr list.add(§ pars item))
        )
        (§ return (§ expr maxOfMostFreq(§ pars list)))
    )

    #_public
    #_static
    (§ method #_"int" (§ fn maxOfMostFreq) [#_"List<Integer>" (§ name items)])
    (§ block
        (§ if (§ expr items.isEmpty(§ pars )))
        (§ block
            (§ return 0)
        )

        ;; This would be much easier in a functional language (or in Java 8).
        (§ ass (§ name items) (§ expr Ordering/natural(§ pars ).reverse(§ pars ).sortedCopy(§ pars items)))
        (§ var #_"LinkedList<Pair>" (§ name pairs) (§ expr Lists/newLinkedList(§ pars )))
        (§ expr pairs.add(§ pars (§ new #_"Pair" (§ pars items.get(§ pars 0), 0))))
        (§ for (§ var #_"int" (§ name item)) :for items)
        (§ block
            (§ var #_"Pair" (§ name pair) (§ expr pairs.getLast(§ pars )))
            (§ if (§ expr pair.item != item))
            (§ block
                (§ expr pairs.add(§ pars (§ ass (§ name pair) (§ new #_"Pair" (§ pars item, 0)))))
            )
            (§ ass (§ name pair.count) (§ expr pair.count + 1))
        )
        ;; pairs now contains a uniqified list of the sorted inputs, with counts for how often that item appeared.
        ;; Now sort by how frequently they occur, and pick the max of the most frequent.
        (§ expr Collections/sort(§ pars pairs))
        (§ var #_"int" (§ name maxCount) (§ expr pairs.getFirst(§ pars ).count))
        (§ var #_"int" (§ name maxItem) (§ expr pairs.getFirst(§ pars ).item))
        (§ for (§ var #_"Pair" (§ name pair)) :for pairs)
        (§ block
            (§ if (§ expr pair.count != maxCount))
            (§ block
                (§ break )
            )
            (§ ass (§ name maxItem) (§ expr Math/max(§ pars maxItem, pair.item)))
        )
        (§ return maxItem)
    )

    ;;;
     ; Reads and joins together with LF char (\n) all the lines from given file.
     ; It's assumed that file is in UTF-8.
     ;;
    #_public
    #_static
    (§ method #_"String" (§ fn getResourceAsString) [#_"URL" (§ name url)])
        (§ throws #_"IOException")
    (§ block
        (§ var #_"List<String>" (§ name lines) (§ expr Resources/readLines(§ pars url, Charsets/UTF_8)))
        (§ return (§ expr Joiner/on(§ pars "\n").join(§ pars lines)))
    )

    ;; Can't use Closeable here because it's Java 7 only and Android devices only got that with KitKat.
    #_public
    #_static
    (§ method #_"InputStream" (§ fn closeUnchecked) [#_"InputStream" (§ name stream)])
    (§ block
        (§ try )
        (§ block
            (§ expr stream.close(§ pars ))
            (§ return stream)
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
    )

    #_public
    #_static
    (§ method #_"OutputStream" (§ fn closeUnchecked) [#_"OutputStream" (§ name stream)])
    (§ block
        (§ try )
        (§ block
            (§ expr stream.close(§ pars ))
            (§ return stream)
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
    )
)

#_(ns org.bitcoinj.core #_"VarInt")

;;;
 ; A variable-length encoded unsigned integer using Satoshi's encoding (a.k.a. "CompactSize").
 ;;
#_public
(§ class #_"VarInt"
    #_public
    #_final
    (§ field #_"long" (§ name value))
    #_private
    #_final
    (§ field #_"int" (§ name originallyEncodedSize))

    ;;;
     ; Constructs a new VarInt with the given unsigned long value.
     ;
     ; @param value the unsigned long value (beware widening conversion of negatives!)
     ;;
    #_public
    (§ constructor #_"VarInt" [#_"long" (§ name value)])
    (§ block
        (§ ass (§ name this.value) value)
        (§ ass (§ name originallyEncodedSize) (§ expr getSizeInBytes(§ pars )))
        (§ void this)
    )

    ;;;
     ; Constructs a new VarInt with the value parsed from the specified offset of the given buffer.
     ;
     ; @param buf The buffer containing the value.
     ; @param offset The offset of the value.
     ;;
    #_public
    (§ constructor #_"VarInt" [#_"byte[]" (§ name buf), #_"int" (§ name offset)])
    (§ block
        (§ var #_"int" (§ name first) (§ expr 0xff & buf[offset]))
        (§ if (§ expr first < 253))
        (§ block
            (§ ass (§ name value) first)
            (§ ass (§ name originallyEncodedSize) 1) ;; 1 data byte (8 bits)
        )
        (§ elseif (§ expr first == 253))
        (§ block
            (§ ass (§ name value) (§ expr (§ expr 0xff & buf[offset + 1]) | (§ expr (§ expr 0xff & buf[offset + 2]) << 8)))
            (§ ass (§ name originallyEncodedSize) 3) ;; 1 marker + 2 data bytes (16 bits)
        )
        (§ elseif (§ expr first == 254))
        (§ block
            (§ ass (§ name value) (§ expr Utils/readUint32(§ pars buf, offset + 1)))
            (§ ass (§ name originallyEncodedSize) 5) ;; 1 marker + 4 data bytes (32 bits)
        )
        (§ else )
        (§ block
            (§ ass (§ name value) (§ expr Utils/readInt64(§ pars buf, offset + 1)))
            (§ ass (§ name originallyEncodedSize) 9) ;; 1 marker + 8 data bytes (64 bits)
        )
        (§ void this)
    )

    ;;;
     ; Returns the original number of bytes used to encode the value if it was
     ; deserialized from a byte array, or the minimum encoded size if it was not.
     ;;
    #_public
    (§ method #_"int" (§ fn getOriginalSizeInBytes) [])
    (§ block
        (§ return originallyEncodedSize)
    )

    ;;;
     ; Returns the minimum encoded size of the value.
     ;;
    #_public
    #_final
    (§ method #_"int" (§ fn getSizeInBytes) [])
    (§ block
        (§ return (§ expr sizeOf(§ pars value)))
    )

    ;;;
     ; Returns the minimum encoded size of the given unsigned long value.
     ;
     ; @param value the unsigned long value (beware widening conversion of negatives!)
     ;;
    #_public
    #_static
    (§ method #_"int" (§ fn sizeOf) [#_"long" (§ name value)])
    (§ block
        ;; if negative, it's actually a very large unsigned long value
        (§ if (§ expr value < 0))
        (§ block
            (§ return 9) ;; 1 marker + 8 data bytes
        )
        (§ if (§ expr value < 253))
        (§ block
            (§ return 1) ;; 1 data byte
        )
        (§ if (§ expr value <= 0xffff))
        (§ block
            (§ return 3) ;; 1 marker + 2 data bytes
        )
        (§ if (§ expr value <= 0xffffffff))
        (§ block
            (§ return 5) ;; 1 marker + 4 data bytes
        )
        (§ return 9) ;; 1 marker + 8 data bytes
    )

    ;;;
     ; Encodes the value into its minimal representation.
     ;
     ; @return the minimal encoded bytes of the value.
     ;;
    #_public
    (§ method #_"byte[]" (§ fn encode) [])
    (§ block
        (§ var #_"byte[]" (§ name bytes))
        (§ switch (§ expr sizeOf(§ pars value)))
        (§ block
            (§ case 1)
            (§ block
                (§ return (§ new #_"byte[]" (§ coll (§ cast #_"byte" value) )))
            )
            (§ case 3)
            (§ block
                (§ return (§ new #_"byte[]" (§ coll (§ cast #_"byte" 253), (§ cast #_"byte" value), (§ cast #_"byte" (§ expr value >> 8)) )))
            )
            (§ case 5)
            (§ block
                (§ ass (§ name bytes) (§ new #_"byte[]" (§ count 5)))
                (§ ass (§ name bytes[0]) (§ cast #_"byte" 254))
                (§ expr Utils/uint32ToByteArrayLE(§ pars value, bytes, 1))
                (§ return bytes)
            )
            (§ default )
            (§ block
                (§ ass (§ name bytes) (§ new #_"byte[]" (§ count 9)))
                (§ ass (§ name bytes[0]) (§ cast #_"byte" 255))
                (§ expr Utils/uint64ToByteArrayLE(§ pars value, bytes, 1))
                (§ return bytes)
            )
        )
    )
)

#_(ns org.bitcoinj.core #_"VerificationException")

#_public
(§ class #_"VerificationException" (§ extends #_"RuntimeException")
    #_public
    (§ constructor #_"VerificationException" [#_"String" (§ name msg)])
    (§ block
        (§ super (§ pars msg))
        (§ void this)
    )

    #_public
    (§ constructor #_"VerificationException" [#_"Exception" (§ name e)])
    (§ block
        (§ super (§ pars e))
        (§ void this)
    )

    #_public
    (§ constructor #_"VerificationException" [#_"String" (§ name msg), #_"Throwable" (§ name t)])
    (§ block
        (§ super (§ pars msg, t))
        (§ void this)
    )

    #_public
    #_static
    (§ class #_"EmptyInputsOrOutputs" (§ extends #_"VerificationException")
        #_public
        (§ constructor #_"EmptyInputsOrOutputs" [])
        (§ block
            (§ super (§ pars "Transaction had no inputs or no outputs."))
            (§ void this)
        )
    )

    #_public
    #_static
    (§ class #_"LargerThanMaxBlockSize" (§ extends #_"VerificationException")
        #_public
        (§ constructor #_"LargerThanMaxBlockSize" [])
        (§ block
            (§ super (§ pars "Transaction larger than MAX_BLOCK_SIZE"))
            (§ void this)
        )
    )

    #_public
    #_static
    (§ class #_"DuplicatedOutPoint" (§ extends #_"VerificationException")
        #_public
        (§ constructor #_"DuplicatedOutPoint" [])
        (§ block
            (§ super (§ pars "Duplicated outpoint"))
            (§ void this)
        )
    )

    #_public
    #_static
    (§ class #_"NegativeValueOutput" (§ extends #_"VerificationException")
        #_public
        (§ constructor #_"NegativeValueOutput" [])
        (§ block
            (§ super (§ pars "Transaction output negative"))
            (§ void this)
        )
    )

    #_public
    #_static
    (§ class #_"ExcessiveValue" (§ extends #_"VerificationException")
        #_public
        (§ constructor #_"ExcessiveValue" [])
        (§ block
            (§ super (§ pars "Total transaction output value greater than possible"))
            (§ void this)
        )
    )

    #_public
    #_static
    (§ class #_"CoinbaseScriptSizeOutOfRange" (§ extends #_"VerificationException")
        #_public
        (§ constructor #_"CoinbaseScriptSizeOutOfRange" [])
        (§ block
            (§ super (§ pars "Coinbase script size out of range"))
            (§ void this)
        )
    )

    #_public
    #_static
    (§ class #_"BlockVersionOutOfDate" (§ extends #_"VerificationException")
        #_public
        (§ constructor #_"BlockVersionOutOfDate" [#_final #_"long" (§ name version)])
        (§ block
            (§ super (§ pars "Block version #" + version + " is outdated."))
            (§ void this)
        )
    )

    #_public
    #_static
    (§ class #_"UnexpectedCoinbaseInput" (§ extends #_"VerificationException")
        #_public
        (§ constructor #_"UnexpectedCoinbaseInput" [])
        (§ block
            (§ super (§ pars "Coinbase input as input in non-coinbase transaction"))
            (§ void this)
        )
    )

    #_public
    #_static
    (§ class #_"CoinbaseHeightMismatch" (§ extends #_"VerificationException")
        #_public
        (§ constructor #_"CoinbaseHeightMismatch" [#_final #_"String" (§ name message)])
        (§ block
            (§ super (§ pars message))
            (§ void this)
        )
    )
)

#_(ns org.bitcoinj.core #_"VersionAck")

;;;
 ; <p>The verack message, sent by a client accepting the version message they
 ; received from their peer.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"VersionAck" (§ extends #_"EmptyMessage")
    #_public
    (§ constructor #_"VersionAck" [])
    (§ block
        (§ void this)
    )

    ;; this is needed by the BitcoinSerializer
    #_public
    (§ constructor #_"VersionAck" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload)])
    (§ block
        (§ void this)
    )
)

#_(ns org.bitcoinj.core #_"VersionMessage"
    (:import [java.io IOException OutputStream]
             [java.math BigInteger]
             [java.net InetAddress UnknownHostException]
             [java.util Locale])
    (:import [com.google.common.base Objects]
             [com.google.common.net InetAddresses]))

;;;
 ; <p>A VersionMessage holds information exchanged during connection setup with another peer.  Most of the fields are
 ; not particularly interesting.  The subVer field, since BIP 14, acts as a User-Agent string would.  You can and should
 ; append to or change the subVer for your own software so other implementations can identify it, and you can look at
 ; the subVer field received from other nodes to see what they are running.</p>
 ;
 ; <p>After creating yourself a VersionMessage, you can pass it to {@link PeerGroup#setVersionMessage(VersionMessage)}
 ; to ensure it will be used for each new connection.</p>
 ;
 ; <p>Instances of this class are not safe for use by multiple threads.</p>
 ;;
#_public
(§ class #_"VersionMessage" (§ extends #_"Message")
    ;;; The version of this library release, as a string. ;;
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name BITCOINJ_VERSION) (§ expr "0.15-SNAPSHOT"))
    ;;; The value that is prepended to the subVer field of this application. ;;
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name LIBRARY_SUBVER) (§ expr "/bitcoinj:" + BITCOINJ_VERSION + "/"))

    ;;; A services flag that denotes whether the peer has a copy of the block chain or not. ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name NODE_NETWORK) 1)

    ;;;
     ; The version number of the protocol spoken.
     ;;
    #_public
    (§ field #_"int" (§ name clientVersion))
    ;;;
     ; Flags defining what optional services are supported.
     ;;
    #_public
    (§ field #_"long" (§ name localServices))
    ;;;
     ; What the other side believes the current time to be, in seconds.
     ;;
    #_public
    (§ field #_"long" (§ name time))
    ;;;
     ; What the other side believes the address of this program is.  Not used.
     ;;
    #_public
    (§ field #_"PeerAddress" (§ name myAddr))
    ;;;
     ; What the other side believes their own address is.  Not used.
     ;;
    #_public
    (§ field #_"PeerAddress" (§ name theirAddr))
    ;;;
     ; User-Agent as defined in <a href="https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki">BIP 14</a>.
     ; Bitcoin Core sets it to something like "/Satoshi:0.9.1/".
     ;;
    #_public
    (§ field #_"String" (§ name subVer))
    ;;;
     ; How many blocks are in the chain, according to the other side.
     ;;
    #_public
    (§ field #_"long" (§ name bestHeight))
    ;;;
     ; Whether or not to relay tx invs before a filter is received.
     ; See <a href="https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki#extensions-to-existing-messages">BIP 37</a>.
     ;;
    #_public
    (§ field #_"boolean" (§ name relayTxesBeforeFilter))

    #_public
    (§ constructor #_"VersionMessage" [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name payload)])
        (§ throws #_"ProtocolException")
    (§ block
        (§ super (§ pars params, payload, 0))
        (§ void this)
    )

    ;; It doesn't really make sense to ever lazily parse a version message or to retain the backing bytes.
    ;; If you're receiving this on the wire you need to check the protocol version and it will never need
    ;; to be sent back down the wire.

    #_public
    (§ constructor #_"VersionMessage" [#_"NetworkParameters" (§ name params), #_"int" (§ name newBestHeight)])
    (§ block
        (§ super (§ pars params))

        (§ ass (§ name clientVersion) (§ expr params.getProtocolVersionNum(§ pars NetworkParameters/ProtocolVersion/CURRENT)))
        (§ ass (§ name localServices) 0)
        (§ ass (§ name time) (§ expr System/currentTimeMillis(§ pars ) / 1000))
        ;; Note that the Bitcoin Core doesn't do anything with these, and finding out your own external IP address
        ;; is kind of tricky anyway, so we just put nonsense here for now.
        (§ var #_"InetAddress" (§ name localhost) (§ expr InetAddresses/forString(§ pars "127.0.0.1")))
        (§ ass (§ name myAddr) (§ new #_"PeerAddress" (§ pars params, localhost, params.getPort(§ pars ), 0, BigInteger/ZERO)))
        (§ ass (§ name theirAddr) (§ new #_"PeerAddress" (§ pars params, localhost, params.getPort(§ pars ), 0, BigInteger/ZERO)))
        (§ ass (§ name subVer) (§ expr LIBRARY_SUBVER))
        (§ ass (§ name bestHeight) newBestHeight)
        (§ ass (§ name relayTxesBeforeFilter) true)

        (§ ass (§ name length) 85)
        (§ if (§ expr 31402 < protocolVersion))
        (§ block
            (§ ass (§ name length) (§ expr length + 8))
        )
        (§ ass (§ name length) (§ expr length + VarInt/sizeOf(§ pars subVer.length(§ pars )) + subVer.length(§ pars )))
        (§ void this)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn parse) [])
        (§ throws #_"ProtocolException")
    (§ block
        (§ ass (§ name clientVersion) (§ cast #_"int" (§ expr readUint32(§ pars ))))
        (§ ass (§ name localServices) (§ expr readUint64(§ pars ).longValue(§ pars )))
        (§ ass (§ name time) (§ expr readUint64(§ pars ).longValue(§ pars )))
        (§ ass (§ name myAddr) (§ new #_"PeerAddress" (§ pars params, payload, cursor, 0)))
        (§ ass (§ name cursor) (§ expr cursor + myAddr.getMessageSize(§ pars )))
        (§ ass (§ name theirAddr) (§ new #_"PeerAddress" (§ pars params, payload, cursor, 0)))
        (§ ass (§ name cursor) (§ expr cursor + theirAddr.getMessageSize(§ pars )))
        ;; uint64 localHostNonce (random data)
        ;; We don't care about the localhost nonce.  It's used to detect connecting back to yourself in cases where
        ;; there are NATs and proxies in the way.  However we don't listen for inbound connections so it's irrelevant.
        (§ expr readUint64(§ pars ))
        (§ try )
        (§ block
            ;; Initialize default values for flags which may not be sent by old nodes.
            (§ ass (§ name subVer) (§ expr ""))
            (§ ass (§ name bestHeight) 0)
            (§ ass (§ name relayTxesBeforeFilter) true)
            (§ if (§ expr (§ not hasMoreBytes(§ pars ))))
            (§ block
                (§ return nil)
            )

            ;; string subVer (currently "")
            (§ ass (§ name subVer) (§ expr readStr(§ pars )))
            (§ if (§ expr (§ not hasMoreBytes(§ pars ))))
            (§ block
                (§ return nil)
            )

            ;; int bestHeight (size of known block chain)
            (§ ass (§ name bestHeight) (§ expr readUint32(§ pars )))
            (§ if (§ expr (§ not hasMoreBytes(§ pars ))))
            (§ block
                (§ return nil)
            )

            (§ ass (§ name relayTxesBeforeFilter) (§ expr readBytes(§ pars 1)[0] != 0))
        )
        (§ finally )
        (§ block
            (§ ass (§ name length) (§ expr cursor - offset))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn bitcoinSerializeToStream) [#_"OutputStream" (§ name buf)])
        (§ throws #_"IOException")
    (§ block
        (§ expr Utils/uint32ToByteStreamLE(§ pars clientVersion, buf))
        (§ expr Utils/uint32ToByteStreamLE(§ pars localServices, buf))
        (§ expr Utils/uint32ToByteStreamLE(§ pars localServices >> 32, buf))
        (§ expr Utils/uint32ToByteStreamLE(§ pars time, buf))
        (§ expr Utils/uint32ToByteStreamLE(§ pars time >> 32, buf))
        (§ try )
        (§ block
            ;; My address.
            (§ expr myAddr.bitcoinSerialize(§ pars buf))
            ;; Their address.
            (§ expr theirAddr.bitcoinSerialize(§ pars buf))
        )
        (§ catch #_"UnknownHostException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Can't happen.
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Can't happen.
        )
        ;; Next up is the "local host nonce", this is to detect the case of connecting back to yourself.
        ;; We don't care about this as we won't be accepting inbound connections.
        (§ expr Utils/uint32ToByteStreamLE(§ pars 0, buf))
        (§ expr Utils/uint32ToByteStreamLE(§ pars 0, buf))
        ;; Now comes subVer.
        (§ var #_"byte[]" (§ name subVerBytes) (§ expr subVer.getBytes(§ pars "UTF-8")))
        (§ expr buf.write(§ pars (§ new #_"VarInt" (§ pars subVerBytes.length)).encode(§ pars )))
        (§ expr buf.write(§ pars subVerBytes))
        ;; Size of known block chain.
        (§ expr Utils/uint32ToByteStreamLE(§ pars bestHeight, buf))
        (§ expr buf.write(§ pars (§ quest relayTxesBeforeFilter ? 1 :else 0)))
        (§ void nil)
    )

    ;;;
     ; Returns true if the version message indicates the sender has a full copy of the block chain,
     ; or if it's running in client mode (only has the headers).
     ;;
    #_public
    (§ method #_"boolean" (§ fn hasBlockChain) [])
    (§ block
        (§ return (§ expr (§ expr localServices & NODE_NETWORK) == NODE_NETWORK))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"VersionMessage" (§ name other) (§ expr (§ cast #_"VersionMessage" o)))
        (§ return (§ expr other.bestHeight == bestHeight && other.clientVersion == clientVersion && other.localServices == localServices && other.time == time && other.subVer.equals(§ pars subVer) && other.myAddr.equals(§ pars myAddr) && other.theirAddr.equals(§ pars theirAddr) && other.relayTxesBeforeFilter == relayTxesBeforeFilter))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars bestHeight, clientVersion, localServices, time, subVer, myAddr, theirAddr, relayTxesBeforeFilter)))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ var #_"StringBuilder" (§ name sb) (§ new #_"StringBuilder" (§ pars )))
        (§ expr sb.append(§ pars "\n"))
        (§ expr sb.append(§ pars "client version: ").append(§ pars clientVersion).append(§ pars "\n"))
        (§ expr sb.append(§ pars "local services: ").append(§ pars localServices).append(§ pars "\n"))
        (§ expr sb.append(§ pars "time:           ").append(§ pars time).append(§ pars "\n"))
        (§ expr sb.append(§ pars "my addr:        ").append(§ pars myAddr).append(§ pars "\n"))
        (§ expr sb.append(§ pars "their addr:     ").append(§ pars theirAddr).append(§ pars "\n"))
        (§ expr sb.append(§ pars "sub version:    ").append(§ pars subVer).append(§ pars "\n"))
        (§ expr sb.append(§ pars "best height:    ").append(§ pars bestHeight).append(§ pars "\n"))
        (§ expr sb.append(§ pars "delay tx relay: ").append(§ pars (§ not relayTxesBeforeFilter)).append(§ pars "\n"))
        (§ return (§ expr sb.toString(§ pars )))
    )

    #_public
    (§ method #_"VersionMessage" (§ fn duplicate) [])
    (§ block
        (§ var #_"VersionMessage" (§ name v) (§ new #_"VersionMessage" (§ pars params, (§ cast #_"int" bestHeight))))
        (§ ass (§ name v.clientVersion) clientVersion)
        (§ ass (§ name v.localServices) localServices)
        (§ ass (§ name v.time) time)
        (§ ass (§ name v.myAddr) myAddr)
        (§ ass (§ name v.theirAddr) theirAddr)
        (§ ass (§ name v.subVer) subVer)
        (§ ass (§ name v.relayTxesBeforeFilter) relayTxesBeforeFilter)
        (§ return v)
    )

    ;;;
     ; Appends the given user-agent information to the subVer field.  The subVer is composed of a series of
     ; name:version pairs separated by slashes in the form of a path.  For example a typical subVer field for bitcoinj
     ; users might look like "/bitcoinj:0.13/MultiBit:1.2/" where libraries come further to the left.
     ;
     ; There can be as many components as you feel a need for, and the version string can be anything, but it is
     ; recommended to use A.B.C where A = major, B = minor and C = revision for software releases, and dates for
     ; auto-generated source repository snapshots.  A valid subVer begins and ends with a slash, therefore name
     ; and version are not allowed to contain such characters.
     ;
     ; Anything put in the "comments" field will appear in brackets and may be used for platform info, or anything
     ; else.  For example, calling <tt>appendToSubVer("MultiBit", "1.0", "Windows")</tt> will result in a subVer being
     ; set of "/bitcoinj:1.0/MultiBit:1.0(Windows)/".  Therefore the / ( and ) characters are reserved in all these
     ; components.  If you don't want to add a comment (recommended), pass null.
     ;
     ; See <a href="https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki">BIP 14</a> for more information.
     ;
     ; @param comments Optional (can be null) platform or other node specific information.
     ; @throws IllegalArgumentException if name, version or comments contains invalid characters.
     ;;
    #_public
    (§ method #_"void" (§ fn appendToSubVer) [#_"String" (§ name name), #_"String" (§ name version), #_nilable #_"String" (§ name comments)])
    (§ block
        (§ expr checkSubVerComponent(§ pars name))
        (§ expr checkSubVerComponent(§ pars version))

        (§ if (§ expr comments != nil))
        (§ block
            (§ expr checkSubVerComponent(§ pars comments))
            (§ ass (§ name subVer) (§ expr subVer.concat(§ pars String/format(§ pars Locale/US, "%s:%s(%s)/", name, version, comments))))
        )
        (§ else )
        (§ block
            (§ ass (§ name subVer) (§ expr subVer.concat(§ pars String/format(§ pars Locale/US, "%s:%s/", name, version))))
        )
        (§ void nil)
    )

    #_private
    #_static
    (§ method #_"void" (§ fn checkSubVerComponent) [#_"String" (§ name component)])
    (§ block
        (§ if (§ expr component.contains(§ pars "/") || component.contains(§ pars "(") || component.contains(§ pars ")")))
        (§ block
            (§ throw (§ new #_"IllegalArgumentException" (§ pars "name contains invalid characters")))
        )
        (§ void nil)
    )

    ;;;
     ; Returns true if the clientVersion field is >= Pong.MIN_PROTOCOL_VERSION.  If it is then ping() is usable.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isPingPongSupported) [])
    (§ block
        (§ return (§ expr params.getProtocolVersionNum(§ pars NetworkParameters/ProtocolVersion/PONG) <= clientVersion))
    )

    ;;;
     ; Returns true if the clientVersion field is >= FilteredBlock.MIN_PROTOCOL_VERSION.  If it is then Bloom filtering
     ; is available and the memory pool of the remote peer will be queried when the downloadData property is true.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isBloomFilteringSupported) [])
    (§ block
        (§ return (§ expr params.getProtocolVersionNum(§ pars NetworkParameters/ProtocolVersion/BLOOM_FILTER) <= clientVersion))
    )
)

#_(ns org.bitcoinj.core #_"VersionedChecksummedBytes"
    (:import [java.io Serializable]
             [java.util Arrays])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.primitives Ints UnsignedBytes]))

;;;
 ; <p>In Bitcoin the following format is often used to represent some type of key:</p>
 ;
 ; <pre>[one version byte] [data bytes] [4 checksum bytes]</pre>
 ;
 ; <p>and the result is then Base58 encoded.
 ; This format is used for addresses, and private keys exported using the dumpprivkey command.</p>
 ;;
#_public
(§ class #_"VersionedChecksummedBytes" (§ implements #_"Serializable", #_"Cloneable", #_"Comparable<VersionedChecksummedBytes>")
    #_protected
    #_final
    (§ field #_"int" (§ name version))
    #_protected
    (§ field #_"byte[]" (§ name bytes))

    #_protected
    (§ constructor #_"VersionedChecksummedBytes" [#_"String" (§ name encoded)])
        (§ throws #_"AddressFormatException")
    (§ block
        (§ var #_"byte[]" (§ name versionAndDataBytes) (§ expr Base58/decodeChecked(§ pars encoded)))
        (§ var #_"byte" (§ name versionByte) (§ expr versionAndDataBytes[0]))
        (§ ass (§ name version) (§ expr versionByte & 0xff))
        (§ ass (§ name bytes) (§ new #_"byte[]" (§ count versionAndDataBytes.length - 1)))
        (§ expr System/arraycopy(§ pars versionAndDataBytes, 1, bytes, 0, versionAndDataBytes.length - 1))
        (§ void this)
    )

    #_protected
    (§ constructor #_"VersionedChecksummedBytes" [#_"int" (§ name version), #_"byte[]" (§ name bytes)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars 0 <= version && version < 256))

        (§ ass (§ name this.version) version)
        (§ ass (§ name this.bytes) bytes)
        (§ void this)
    )

    ;;;
     ; Returns the base-58 encoded String representation of this object,
     ; including version and checksum bytes.
     ;;
    #_public
    #_final
    (§ method #_"String" (§ fn toBase58) [])
    (§ block
        ;; A stringified buffer is: 1 byte version + data bytes + 4 bytes check code (a truncated hash).
        (§ var #_"byte[]" (§ name addressBytes) (§ new #_"byte[]" (§ count 1 + bytes.length + 4)))
        (§ ass (§ name addressBytes[0]) (§ cast #_"byte" version))
        (§ expr System/arraycopy(§ pars bytes, 0, addressBytes, 1, bytes.length))
        (§ var #_"byte[]" (§ name checksum) (§ expr Sha256Hash/hashTwice(§ pars addressBytes, 0, bytes.length + 1)))
        (§ expr System/arraycopy(§ pars checksum, 0, addressBytes, bytes.length + 1, 4))
        (§ return (§ expr Base58/encode(§ pars addressBytes)))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr toBase58(§ pars )))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars version, Arrays/hashCode(§ pars bytes))))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"VersionedChecksummedBytes" (§ name other) (§ expr (§ cast #_"VersionedChecksummedBytes" o)))
        (§ return (§ expr this.version == other.version && Arrays/equals(§ pars this.bytes, other.bytes)))
    )

    ;;;
     ; {@inheritDoc}
     ;
     ; This implementation narrows the return type to <code>VersionedChecksummedBytes</code>
     ; and allows subclasses to throw <code>CloneNotSupportedException</code> even though it
     ; is never thrown by this implementation.
     ;;
    #_override
    #_public
    (§ method #_"VersionedChecksummedBytes" (§ fn clone) [])
        (§ throws #_"CloneNotSupportedException")
    (§ block
        (§ return (§ cast #_"VersionedChecksummedBytes" (§ expr super.clone(§ pars ))))
    )

    ;;;
     ; {@inheritDoc}
     ;
     ; This implementation uses an optimized Google Guava method to compare <code>bytes</code>.
     ;;
    #_override
    #_public
    (§ method #_"int" (§ fn compareTo) [#_"VersionedChecksummedBytes" (§ name o)])
    (§ block
        (§ var #_"int" (§ name result) (§ expr Ints/compare(§ pars this.version, o.version)))
        (§ return (§ quest (§ expr result != 0) ? result :else (§ dot UnsignedBytes/lexicographicalComparator(§ pars ).compare(§ pars this.bytes, o.bytes))))
    )

    ;;;
     ; Returns the "version" or "header" byte: the first byte of the data.  This is used to disambiguate what
     ; the contents apply to, for example, which network the key or address is valid on.
     ;
     ; @return a positive number between 0 and 255.
     ;;
    #_public
    (§ method #_"int" (§ fn getVersion) [])
    (§ block
        (§ return version)
    )
)

#_(ns org.bitcoinj.core #_"WrongNetworkException"
    (:import [java.util Arrays]))

;;;
 ; This exception is thrown by the Address class when you try and decode an address with a version code that isn't
 ; used by that network.  You shouldn't allow the user to proceed in this case as they are trying to send money across
 ; different chains, an operation that is guaranteed to destroy the money.
 ;;
#_public
(§ class #_"WrongNetworkException" (§ extends #_"AddressFormatException")
    ;;; The version code that was provided in the address. ;;
    #_public
    (§ field #_"int" (§ name verCode))
    ;;; The list of acceptable versions that were expected given the addresses network parameters. ;;
    #_public
    (§ field #_"int[]" (§ name acceptableVersions))

    #_public
    (§ constructor #_"WrongNetworkException" [#_"int" (§ name verCode), #_"int[]" (§ name acceptableVersions)])
    (§ block
        (§ super (§ pars "Version code of address did not match acceptable versions for network: " + verCode + " not in " + Arrays/toString(§ pars acceptableVersions)))

        (§ ass (§ name this.verCode) verCode)
        (§ ass (§ name this.acceptableVersions) acceptableVersions)
        (§ void this)
    )
)

#_(ns org.bitcoinj.core.listeners #_"AbstractPeerDataEventListener"
    (:import [java.util *])
   (:require [org.bitcoinj.core *]))

;;;
 ; Deprecated: implement the more specific event listener interfaces instead to fill out only what you need.
 ;;
#_deprecated
#_public
#_abstract
(§ class #_"AbstractPeerDataEventListener" (§ implements #_"PeerDataEventListener")
    #_override
    #_public
    (§ method #_"void" (§ fn onBlocksDownloaded) [#_"Peer" (§ name peer), #_"Block" (§ name block), #_nilable #_"FilteredBlock" (§ name filteredBlock), #_"int" (§ name blocksLeft)])
    (§ block
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn onChainDownloadStarted) [#_"Peer" (§ name peer), #_"int" (§ name blocksLeft)])
    (§ block
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"Message" (§ fn onPreMessageReceived) [#_"Peer" (§ name peer), #_"Message" (§ name m)])
    (§ block
        ;; Just pass the message right through for further processing.
        (§ return m)
    )

    #_override
    #_public
    (§ method #_"List<Message>" (§ fn getData) [#_"Peer" (§ name peer), #_"GetDataMessage" (§ name m)])
    (§ block
        (§ return nil)
    )
)

#_(ns org.bitcoinj.core.listeners #_"BlockChainListener")

;;;
 ; Old interface for backwards compatibility. Implement the more specific interfaces instead.
 ;;
#_deprecated
#_public
(§ interface #_"BlockChainListener" (§ extends #_"NewBestBlockListener", #_"TransactionReceivedInBlockListener", #_"ReorganizeListener"))

#_(ns org.bitcoinj.core.listeners #_"BlocksDownloadedEventListener"
   (:require [org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(§ interface #_"BlocksDownloadedEventListener"
    ;; TODO: Fix the Block/FilteredBlock type hierarchy so we can avoid the stupid typeless API here.
    ;;;
     ; <p>Called on a Peer thread when a block is received.</p>
     ;
     ; <p>The block may be a Block object that contains transactions, a Block object that is only a header when
     ; fast catchup is being used.  If set, filteredBlock can be used to retrieve the list of associated transactions.</p>
     ;
     ; @param peer The peer receiving the block.
     ; @param block The downloaded block.
     ; @param filteredBlock If non-null, the object that wraps the block header passed as the block param.
     ; @param blocksLeft The number of blocks left to download.
     ;;
    (§ method #_"void" (§ fn onBlocksDownloaded) [#_"Peer" (§ name peer), #_"Block" (§ name block), #_nilable #_"FilteredBlock" (§ name filteredBlock), #_"int" (§ name blocksLeft)])
)

#_(ns org.bitcoinj.core.listeners #_"ChainDownloadStartedEventListener"
   (:require [org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(§ interface #_"ChainDownloadStartedEventListener"
    ;;;
     ; Called when a download is started with the initial number of blocks to be downloaded.
     ;
     ; @param peer The peer receiving the block.
     ; @param blocksLeft The number of blocks left to download.
     ;;
    (§ method #_"void" (§ fn onChainDownloadStarted) [#_"Peer" (§ name peer), #_"int" (§ name blocksLeft)])
)

#_(ns org.bitcoinj.core.listeners #_"DownloadProgressTracker"
    (:import [java.util Date Locale]
             [java.util.concurrent ExecutionException])
    (:import [com.google.common.util.concurrent ListenableFuture SettableFuture]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core Block FilteredBlock Peer Utils]))

;;;
 ; <p>An implementation of {@link AbstractPeerDataEventListener} that listens to chain download events and tracks
 ; progress as a percentage.  The default implementation prints progress to stdout, but you can subclass it and
 ; override the progress method to update a GUI instead.</p>
 ;;
#_public
(§ class #_"DownloadProgressTracker" (§ extends #_"AbstractPeerDataEventListener")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"DownloadProgressTracker"))))

    #_private
    (§ field #_"int" (§ name originalBlocksLeft) -1)
    #_private
    (§ field #_"int" (§ name lastPercent) 0)
    #_private
    (§ field #_"SettableFuture<Long>" (§ name future) (§ expr SettableFuture/create(§ pars )))
    #_private
    (§ field #_"boolean" (§ name caughtUp) false)

    #_override
    #_public
    (§ method #_"void" (§ fn onChainDownloadStarted) [#_"Peer" (§ name peer), #_"int" (§ name blocksLeft)])
    (§ block
        (§ if (§ expr 0 < blocksLeft && originalBlocksLeft == -1))
        (§ block
            (§ expr startDownload(§ pars blocksLeft))
        )
        ;; Only mark this the first time, because this method can be called more than once during a chain download
        ;; if we switch peers during it.
        (§ if (§ expr originalBlocksLeft == -1))
        (§ block
            (§ ass (§ name originalBlocksLeft) blocksLeft)
        )
        (§ else )
        (§ block
            (§ expr log.info(§ pars "Chain download switched to {}", peer))
        )
        (§ if (§ expr blocksLeft == 0))
        (§ block
            (§ expr doneDownload(§ pars ))
            (§ expr future.set(§ pars peer.getBestHeight(§ pars )))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn onBlocksDownloaded) [#_"Peer" (§ name peer), #_"Block" (§ name block), #_nilable #_"FilteredBlock" (§ name filteredBlock), #_"int" (§ name blocksLeft)])
    (§ block
        (§ if caughtUp)
        (§ block
            (§ return nil)
        )

        (§ if (§ expr blocksLeft == 0))
        (§ block
            (§ ass (§ name caughtUp) true)
            (§ expr doneDownload(§ pars ))
            (§ expr future.set(§ pars peer.getBestHeight(§ pars )))
        )

        (§ if (§ expr blocksLeft < 0 || originalBlocksLeft <= 0))
        (§ block
            (§ return nil)
        )

        (§ var #_"double" (§ name pct) (§ expr 100.0 - (§ expr 100.0 * (§ expr blocksLeft / (§ cast #_"double" originalBlocksLeft)))))
        (§ if (§ expr (§ cast #_"int" pct) != lastPercent))
        (§ block
            (§ expr progress(§ pars pct, blocksLeft, new Date(§ pars block.getTimeSeconds(§ pars ) * 1000)))
            (§ ass (§ name lastPercent) (§ cast #_"int" pct))
        )
        (§ void nil)
    )

    ;;;
     ; Called when download progress is made.
     ;
     ; @param pct The percentage of chain downloaded, estimated.
     ; @param date The date of the last block downloaded.
     ;;
    #_protected
    (§ method #_"void" (§ fn progress) [#_"double" (§ name pct), #_"int" (§ name blocksSoFar), #_"Date" (§ name date)])
    (§ block
        (§ expr log.info(§ pars String/format(§ pars Locale/US, "Chain download %d%% done with %d blocks to go, block date %s", (§ cast #_"int" pct), blocksSoFar, Utils/dateTimeFormat(§ pars date))))
        (§ void nil)
    )

    ;;;
     ; Called when download is initiated.
     ;
     ; @param blocks The number of blocks to download, estimated.
     ;;
    #_protected
    (§ method #_"void" (§ fn startDownload) [#_"int" (§ name blocks)])
    (§ block
        (§ expr log.info(§ pars "Downloading block chain of size " + blocks + ". " + (§ quest (§ expr 1000 < blocks) ? (§ expr "This may take a while.") :else (§ expr ""))))
        (§ void nil)
    )

    ;;;
     ; Called when we are done downloading the block chain.
     ;;
    #_protected
    (§ method #_"void" (§ fn doneDownload) [])
    (§ block
        (§ void nil)
    )

    ;;;
     ; Wait for the chain to be downloaded.
     ;;
    #_public
    (§ method #_"void" (§ fn await) [])
        (§ throws #_"InterruptedException")
    (§ block
        (§ try )
        (§ block
            (§ expr future.get(§ pars ))
        )
        (§ catch #_"ExecutionException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
        (§ void nil)
    )

    ;;;
     ; Returns a listenable future that completes with the height of the best chain (as reported by the peer) once chain
     ; download seems to be finished.
     ;;
    #_public
    (§ method #_"ListenableFuture<Long>" (§ fn getFuture) [])
    (§ block
        (§ return future)
    )
)

#_(ns org.bitcoinj.core.listeners #_"GetDataEventListener"
    (:import [java.util *])
   (:require [org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(§ interface #_"GetDataEventListener"
    ;;;
     ; <p>Called when a peer receives a getdata message, usually in response to an "inv" being broadcast.  Return as many
     ; items as possible which appear in the {@link GetDataMessage}, or null if you're not interested in responding.</p>
     ;
     ; <p>Note that this will never be called if registered with any executor other than
     ; {@link org.bitcoinj.utils.Threading#SAME_THREAD}</p>
     ;;
    #_nilable
    (§ method #_"List<Message>" (§ fn getData) [#_"Peer" (§ name peer), #_"GetDataMessage" (§ name m)])
)

#_(ns org.bitcoinj.core.listeners #_"NewBestBlockListener"
   (:require [org.bitcoinj.core StoredBlock VerificationException]))

;;;
 ; Listener interface for when a new block on the best chain is seen.
 ;;
#_public
(§ interface #_"NewBestBlockListener"
    ;;;
     ; Called when a new block on the best chain is seen, after relevant transactions are extracted and sent to us via either
     ; {@link TransactionReceivedInBlockListener#receiveFromBlock(org.bitcoinj.core.Transaction, org.bitcoinj.core.StoredBlock, org.bitcoinj.core.BlockChain.NewBlockType, int relativityOffset)}
     ; or {@link TransactionReceivedInBlockListener#notifyTransactionIsInBlock(org.bitcoinj.core.Sha256Hash, org.bitcoinj.core.StoredBlock, org.bitcoinj.core.BlockChain.NewBlockType, int)}.
     ;
     ; If this block is causing a re-organise to a new chain, this method is NOT
     ; called even though the block may be the new best block: your reorganize
     ; implementation is expected to do whatever would normally be done do for a
     ; new best block in this case.
     ;;
    (§ method #_"void" (§ fn notifyNewBestBlock) [#_final #_"StoredBlock" (§ name block)])
        (§ throws #_"VerificationException")
)

#_(ns org.bitcoinj.core.listeners #_"OnTransactionBroadcastListener"
   (:require [org.bitcoinj.core *]))

;;;
 ; Called when a new transaction is broadcast over the network.
 ;;
#_public
(§ interface #_"OnTransactionBroadcastListener"
    ;;;
     ; Called when a new transaction is broadcast over the network.
     ;;
    (§ method #_"void" (§ fn onTransaction) [#_"Peer" (§ name peer), #_"Transaction" (§ name t)])
)

#_(ns org.bitcoinj.core.listeners #_"PeerConnectedEventListener"
   (:require [org.bitcoinj.core Peer]))

;;;
 ; <p>Implementors can listen to events indicating a new peer connecting.</p>
 ;;
#_public
(§ interface #_"PeerConnectedEventListener"
    ;;;
     ; Called when a peer is connected.  If this listener is registered to a {@link Peer} instead of a {@link PeerGroup},
     ; peerCount will always be 1.
     ;
     ; @param peer
     ; @param peerCount The total number of connected peers.
     ;;
    (§ method #_"void" (§ fn onPeerConnected) [#_"Peer" (§ name peer), #_"int" (§ name peerCount)])
)

#_(ns org.bitcoinj.core.listeners #_"PeerDataEventListener"
   (:require [org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are processed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(§ interface #_"PeerDataEventListener" (§ extends #_"BlocksDownloadedEventListener", #_"ChainDownloadStartedEventListener", #_"GetDataEventListener", #_"PreMessageReceivedEventListener"))

#_(ns org.bitcoinj.core.listeners #_"PeerDisconnectedEventListener"
   (:require [org.bitcoinj.core Peer]))

;;;
 ; <p>Implementors can listen to events indicating a peer disconnecting.</p>
 ;;
#_public
(§ interface #_"PeerDisconnectedEventListener"
    ;;;
     ; Called when a peer is disconnected.  Note that this won't be called if the listener is registered on
     ; a {@link PeerGroup} and the group is in the process of shutting down.  If this listener is registered to
     ; a {@link Peer} instead of a {@link PeerGroup}, peerCount will always be 0.  This handler can be called
     ; without a corresponding invocation of onPeerConnected if the initial connection is never successful.
     ;
     ; @param peer
     ; @param peerCount The total number of connected peers.
     ;;
    (§ method #_"void" (§ fn onPeerDisconnected) [#_"Peer" (§ name peer), #_"int" (§ name peerCount)])
)

#_(ns org.bitcoinj.core.listeners #_"PeerDiscoveredEventListener"
    (:import [java.util Set])
   (:require [org.bitcoinj.core Peer PeerAddress]))

;;;
 ; <p>Implementors can listen to events for peers being discovered.</p>
 ;;
#_public
(§ interface #_"PeerDiscoveredEventListener"
    ;;;
     ; <p>Called when peers are discovered, this happens at startup of {@link PeerGroup}
     ; or if we run out of suitable {@link Peer}s to connect to.</p>
     ;
     ; @param peerAddresses The set of discovered {@link PeerAddress}es.
     ;;
    (§ method #_"void" (§ fn onPeersDiscovered) [#_"Set<PeerAddress>" (§ name peerAddresses)])
)

#_(ns org.bitcoinj.core.listeners #_"PreMessageReceivedEventListener"
   (:require [org.bitcoinj.core *]))

;;;
 ; <p>Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.</p>
 ;;
#_public
(§ interface #_"PreMessageReceivedEventListener"
    ;;;
     ; <p>Called when a message is received by a peer, before the message is processed.  The returned message is
     ; processed instead.  Returning null will cause the message to be ignored by the Peer returning the same message
     ; object allows you to see the messages received but not change them.  The result from one event listeners
     ; callback is passed as "m" to the next, forming a chain.</p>
     ;
     ; <p>Note that this will never be called if registered with any executor other than
     ; {@link org.bitcoinj.utils.Threading#SAME_THREAD}.</p>
     ;;
    (§ method #_"Message" (§ fn onPreMessageReceived) [#_"Peer" (§ name peer), #_"Message" (§ name m)])
)

#_(ns org.bitcoinj.core.listeners #_"ReorganizeListener"
    (:import [java.util List])
   (:require [org.bitcoinj.core StoredBlock VerificationException]))

;;;
 ; Listener interface for when the best chain has changed.
 ;;
#_public
(§ interface #_"ReorganizeListener"
    ;;;
     ; Called by the {@link org.bitcoinj.core.BlockChain} when the best chain (representing total work done)
     ; has changed.  In this case, we need to go through our transactions and find out if any have become invalid.
     ; It's possible for our balance to go down in this case: money we thought we had can suddenly vanish
     ; if the rest of the network agrees it should be so.
     ;
     ; The oldBlocks/newBlocks lists are ordered height-wise from top first to bottom last (i.e. newest blocks first).
     ;;
    (§ method #_"void" (§ fn reorganize) [#_"StoredBlock" (§ name splitPoint), #_"List<StoredBlock>" (§ name oldBlocks), #_"List<StoredBlock>" (§ name newBlocks)])
        (§ throws #_"VerificationException")
)

#_(ns org.bitcoinj.core.listeners #_"TransactionConfidenceEventListener"
   (:require [org.bitcoinj.core Transaction]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when confidence of a transaction changes.</p>
 ;;
#_public
(§ interface #_"TransactionConfidenceEventListener"
    ;;;
     ; <p>Called when a transaction changes its confidence level.  You can also attach event listeners to
     ; the individual transactions, if you don't care about all of them.  Usually you would save the wallet to disk
     ; after receiving this callback unless you already set up autosaving.</p>
     ;
     ; <p>You should pay attention to this callback in case a transaction becomes <i>dead</i>, that is, a transaction
     ; you believed to be active (send or receive) becomes overridden by the network.  This can happen if</p>
     ;
     ; <ol>
     ;     <li>You are sharing keys between wallets and accidentally create/broadcast a double spend.</li>
     ;     <li>Somebody is attacking the network and reversing transactions, i.e. the user is a victim of fraud.</li>
     ;     <li>A bug: for example you create a transaction, broadcast it but fail to commit it.
     ;     The {@link Wallet} will then re-use the same outputs when creating the next spend.</li>
     ; </ol>
     ;
     ; <p>To find if the transaction is dead, you can use <tt>tx.getConfidence().getConfidenceType() ==
     ; TransactionConfidence.ConfidenceType.DEAD</tt>.  If it is, you should notify the user in some way
     ; so they know the thing they bought may not arrive/the thing they sold should not be dispatched.</p>
     ;
     ; <p>Note that this callback will be invoked for every transaction in the wallet, for every new block that is
     ; received (because the depth has changed).  <b>If you want to update a UI view from the contents of the wallet
     ; it is more efficient to use onWalletChanged instead.</b></p>
     ;;
    (§ method #_"void" (§ fn onTransactionConfidenceChanged) [#_"Wallet" (§ name wallet), #_"Transaction" (§ name tx)])
)

#_(ns org.bitcoinj.core.listeners #_"TransactionReceivedInBlockListener"
   (:require [org.bitcoinj.core BlockChain Sha256Hash StoredBlock Transaction VerificationException]))

;;;
 ; Listener interface for when we receive a new block that contains a relevant transaction.
 ;;
#_public
(§ interface #_"TransactionReceivedInBlockListener"
    ;;;
     ; <p>Called by the {@link BlockChain} when we receive a new block that contains a relevant transaction.</p>
     ;
     ; <p>A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.</p>
     ;
     ; <p>The relativityOffset parameter is an arbitrary number used to establish an ordering between transactions
     ; within the same block.  In the case where full blocks are being downloaded, it is simply the index of the
     ; transaction within that block.  When Bloom filtering is in use, we don't find out the exact offset into a block
     ; that a transaction occurred at, so the relativity count is not reflective of anything in an absolute sense but
     ; rather exists only to order the transaction relative to the others.</p>
     ;;
    (§ method #_"void" (§ fn receiveFromBlock) [#_"Transaction" (§ name tx), #_"StoredBlock" (§ name block), #_"BlockChain.NewBlockType" (§ name blockType), #_"int" (§ name relativityOffset)])
        (§ throws #_"VerificationException")

    ;;;
     ; <p>Called by the {@link BlockChain} when we receive a new {@link FilteredBlock} that contains the given
     ; transaction hash in its merkle tree.</p>
     ;
     ; <p>A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.</p>
     ;
     ; <p>The relativityOffset parameter in this case is an arbitrary (meaningless) number, that is useful only when
     ; compared to the relativity count of another transaction received inside the same block.  It is used to establish
     ; an ordering of transactions relative to one another.</p>
     ;
     ; <p>This method should return false if the given tx hash isn't known about, e.g. because the the transaction was
     ; a Bloom false positive.  If it was known about and stored, it should return true.  The caller may need to know
     ; this to calculate the effective FP rate.</p>
     ;
     ; @return whether the transaction is known about i.e. was considered relevant previously.
     ;;
    (§ method #_"boolean" (§ fn notifyTransactionIsInBlock) [#_"Sha256Hash" (§ name txHash), #_"StoredBlock" (§ name block), #_"BlockChain.NewBlockType" (§ name blockType), #_"int" (§ name relativityOffset)])
        (§ throws #_"VerificationException")
)

#_(ns org.bitcoinj.crypto #_"ChildNumber"
    (:import [java.util Locale])
    (:import [com.google.common.primitives Ints]))

;;;
 ; <p>This is just a wrapper for the i (child number) as per BIP 32 with a boolean getter for the most significant bit
 ; and a getter for the actual 0-based child number.  A {@link java.util.List} of these forms a <i>path</i> through a
 ; {@link DeterministicHierarchy}.  This class is immutable.
 ;;
#_public
(§ class #_"ChildNumber" (§ implements #_"Comparable<ChildNumber>")
    ;;;
     ; The bit that's set in the child number to indicate whether this key is "hardened".  Given a hardened key, it is
     ; not possible to derive a child public key if you know only the hardened public key.  With a non-hardened key this
     ; is possible, so you can derive trees of public keys given only a public parent, but the downside is that it's
     ; possible to leak private keys if you disclose a parent public key and a child private key (elliptic curve maths
     ; allows you to work upwards).
     ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name HARDENED_BIT) (§ expr 0x80000000))

    #_public
    #_static
    #_final
    (§ field #_"ChildNumber" (§ name ZERO) (§ new #_"ChildNumber" (§ pars 0)))
    #_public
    #_static
    #_final
    (§ field #_"ChildNumber" (§ name ONE) (§ new #_"ChildNumber" (§ pars 1)))
    #_public
    #_static
    #_final
    (§ field #_"ChildNumber" (§ name ZERO_HARDENED) (§ new #_"ChildNumber" (§ pars 0, true)))

    ;;; Integer i as per BIP 32 spec, including the MSB denoting derivation type (0 = public, 1 = private). ;;
    #_private
    #_final
    (§ field #_"int" (§ name i))

    #_public
    (§ constructor #_"ChildNumber" [#_"int" (§ name childNumber), #_"boolean" (§ name isHardened)])
    (§ block
        (§ if (§ expr hasHardenedBit(§ pars childNumber)))
        (§ block
            (§ throw (§ new #_"IllegalArgumentException" (§ pars "Most significant bit is reserved and shouldn't be set: " + childNumber)))
        )

        (§ ass (§ name i) (§ quest isHardened ? (§ expr childNumber | HARDENED_BIT) :else childNumber))
        (§ void this)
    )

    #_public
    (§ constructor #_"ChildNumber" [#_"int" (§ name i)])
    (§ block
        (§ ass (§ name this.i) i)
        (§ void this)
    )

    ;;; Returns the uint32 encoded form of the path element, including the most significant bit. ;;
    #_public
    (§ method #_"int" (§ fn getI) [])
    (§ block
        (§ return i)
    )

    ;;; Returns the uint32 encoded form of the path element, including the most significant bit. ;;
    #_public
    (§ method #_"int" (§ fn i) [])
    (§ block
        (§ return i)
    )

    #_public
    (§ method #_"boolean" (§ fn isHardened) [])
    (§ block
        (§ return (§ expr hasHardenedBit(§ pars i)))
    )

    #_private
    #_static
    (§ method #_"boolean" (§ fn hasHardenedBit) [#_"int" (§ name a)])
    (§ block
        (§ return (§ expr (§ expr a & HARDENED_BIT) != 0))
    )

    ;;; Returns the child number without the hardening bit set (i.e. index in that part of the tree). ;;
    #_public
    (§ method #_"int" (§ fn num) [])
    (§ block
        (§ return (§ expr i & (§ flip HARDENED_BIT)))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr String/format(§ pars Locale/US, "%d%s", num(§ pars ), (§ quest (§ expr isHardened(§ pars )) ? (§ expr "H") :else (§ expr "")))))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return (§ expr i == (§ expr (§ cast #_"ChildNumber" o)).i))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return i)
    )

    #_override
    #_public
    (§ method #_"int" (§ fn compareTo) [#_"ChildNumber" (§ name other)])
    (§ block
        ;; Note that in this implementation compareTo() is not consistent with equals().
        (§ return (§ expr Ints/compare(§ pars this.num(§ pars ), other.num(§ pars ))))
    )
)

#_(ns org.bitcoinj.crypto #_"DeterministicHierarchy"
    (:import [java.util List Locale Map])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect ImmutableList Maps]))

;; TODO: This whole API feels a bit object heavy.  Do we really need ChildNumber and so many maps, etc?
;; TODO: Should we be representing this using an actual tree arrangement in memory instead of a bunch of hashmaps?

;;;
 ; <p>A DeterministicHierarchy calculates and keeps a whole tree (hierarchy) of keys originating from a single
 ; root key.  This implements part of the BIP 32 specification.  A deterministic key tree is useful because
 ; Bitcoin's privacy system require new keys to be created for each transaction, but managing all these
 ; keys quickly becomes unwieldy.  In particular it becomes hard to back up and distribute them.  By having
 ; a way to derive random-looking but deterministic keys we can make wallet backup simpler and gain the
 ; ability to hand out {@link DeterministicKey}s to other people who can then create new addresses
 ; on the fly, without having to contact us.</p>
 ;
 ; <p>The hierarchy is started from a single root key, and a location in the tree is given by a path which
 ; is a list of {@link ChildNumber}s.</p>
 ;;
#_public
(§ class #_"DeterministicHierarchy"
    #_private
    #_final
    (§ field #_"Map<ImmutableList<ChildNumber>, DeterministicKey>" (§ name keys) (§ expr Maps/newHashMap(§ pars )))
    #_private
    #_final
    (§ field #_"ImmutableList<ChildNumber>" (§ name rootPath))
    ;; Keep track of how many child keys each node has.  This is kind of weak.
    #_private
    #_final
    (§ field #_"Map<ImmutableList<ChildNumber>, ChildNumber>" (§ name lastChildNumbers) (§ expr Maps/newHashMap(§ pars )))

    #_public
    #_static
    #_final
    (§ field #_"int" (§ name BIP32_STANDARDISATION_TIME_SECS) 1369267200)

    ;;;
     ; Constructs a new hierarchy rooted at the given key.  Note that this does not have to be the top of the tree.
     ; You can construct a DeterministicHierarchy for a subtree of a larger tree that you may not own.
     ;;
    #_public
    (§ constructor #_"DeterministicHierarchy" [#_"DeterministicKey" (§ name rootKey)])
    (§ block
        (§ expr putKey(§ pars rootKey))
        (§ ass (§ name rootPath) (§ expr rootKey.getPath(§ pars )))
        (§ void this)
    )

    ;;;
     ; Inserts a key into the heirarchy.  Used during deserialization: you normally don't need this.  Keys must be
     ; inserted in order.
     ;;
    #_public
    #_final
    (§ method #_"void" (§ fn putKey) [#_"DeterministicKey" (§ name key)])
    (§ block
        (§ var #_"ImmutableList<ChildNumber>" (§ name path) (§ expr key.getPath(§ pars )))
        ;; Update our tracking of what the next child in each branch of the tree should be.  Just assume that keys
        ;; are inserted in order here.
        #_final
        (§ var #_"DeterministicKey" (§ name parent) (§ expr key.getParent(§ pars )))
        (§ if (§ expr parent != nil))
        (§ block
            (§ expr lastChildNumbers.put(§ pars parent.getPath(§ pars ), key.getChildNumber(§ pars )))
        )
        (§ expr keys.put(§ pars path, key))
        (§ void nil)
    )

    ;;;
     ; Returns a key for the given path, optionally creating it.
     ;
     ; @param path The path to the key.
     ; @param relativePath Whether the path is relative to the root path.
     ; @param create Whether the key corresponding to path should be created (with any necessary ancestors) if it doesn't exist already.
     ; @return next newly created key using the child derivation function.
     ; @throws IllegalArgumentException if create is false and the path was not found.
     ;;
    #_public
    (§ method #_"DeterministicKey" (§ fn get) [#_"List<ChildNumber>" (§ name path), #_"boolean" (§ name relativePath), #_"boolean" (§ name create)])
    (§ block
        (§ var #_"ImmutableList<ChildNumber>" (§ name absolutePath) (§ quest relativePath ? (§ dot ImmutableList.<ChildNumber>builder(§ pars ).addAll(§ pars rootPath).addAll(§ pars path).build(§ pars )) :else (§ expr ImmutableList/copyOf(§ pars path))))
        (§ if (§ expr (§ not keys.containsKey(§ pars absolutePath))))
        (§ block
            (§ if (§ expr (§ not create)))
            (§ block
                (§ throw (§ new #_"IllegalArgumentException" (§ pars String/format(§ pars Locale/US, "No key found for %s path %s.", relativePath ? "relative") :for (§ expr "absolute", HDUtils/formatPath(§ pars path)))))
            )
            (§ expr Preconditions/checkArgument(§ pars 0 < absolutePath.size(§ pars ), "Can't derive the master key: nothing to derive from."))
            (§ var #_"DeterministicKey" (§ name parent) (§ expr get(§ pars absolutePath.subList(§ pars 0, absolutePath.size(§ pars ) - 1), false, true)))
            (§ expr putKey(§ pars HDKeyDerivation/deriveChildKey(§ pars parent, absolutePath.get(§ pars absolutePath.size(§ pars ) - 1))))
        )
        (§ return (§ expr keys.get(§ pars absolutePath)))
    )

    ;;;
     ; Extends the tree by calculating the next key that hangs off the given parent path.  For example, if you pass
     ; a path of 1/2 here and there are already keys 1/2/1 and 1/2/2 then it will derive 1/2/3.
     ;
     ; @param parentPath The path to the parent.
     ; @param relative Whether the path is relative to the root path.
     ; @param createParent Whether the parent corresponding to path should be created (with any necessary ancestors) if it doesn't exist already.
     ; @param privateDerivation Whether to use private or public derivation.
     ; @return next newly created key using the child derivation funtcion.
     ; @throws IllegalArgumentException if the parent doesn't exist and createParent is false.
     ;;
    #_public
    (§ method #_"DeterministicKey" (§ fn deriveNextChild) [#_"ImmutableList<ChildNumber>" (§ name parentPath), #_"boolean" (§ name relative), #_"boolean" (§ name createParent), #_"boolean" (§ name privateDerivation)])
    (§ block
        (§ var #_"DeterministicKey" (§ name parent) (§ expr get(§ pars parentPath, relative, createParent)))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < HDKeyDerivation/MAX_CHILD_DERIVATION_ATTEMPTS) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ try )
            (§ block
                (§ var #_"ChildNumber" (§ name createChildNumber) (§ expr getNextChildNumberToDerive(§ pars parent.getPath(§ pars ), privateDerivation)))
                (§ return (§ expr deriveChild(§ pars parent, createChildNumber)))
            )
            (§ catch #_"HDDerivationException" (§ name _))
            (§ block
            )
        )
        (§ throw (§ new #_"HDDerivationException" (§ pars "Maximum number of child derivation attempts reached, this is probably an indication of a bug.")))
    )

    #_private
    (§ method #_"ChildNumber" (§ fn getNextChildNumberToDerive) [#_"ImmutableList<ChildNumber>" (§ name path), #_"boolean" (§ name privateDerivation)])
    (§ block
        (§ var #_"ChildNumber" (§ name lastChildNumber) (§ expr lastChildNumbers.get(§ pars path)))
        (§ var #_"ChildNumber" (§ name nextChildNumber) (§ new #_"ChildNumber" (§ pars (§ quest (§ expr lastChildNumber != nil) ? (§ expr lastChildNumber.num(§ pars ) + 1) :else 0), privateDerivation)))
        (§ expr lastChildNumbers.put(§ pars path, nextChildNumber))
        (§ return nextChildNumber)
    )

    #_public
    (§ method #_"int" (§ fn getNumChildren) [#_"ImmutableList<ChildNumber>" (§ name path)])
    (§ block
        #_final
        (§ var #_"ChildNumber" (§ name cn) (§ expr lastChildNumbers.get(§ pars path)))
        ;; Children start with zero based childnumbers.
        (§ return (§ quest (§ expr cn != nil) ? (§ expr 1 + cn.num(§ pars )) :else 0))
    )

    ;;;
     ; Extends the tree by calculating the requested child for the given path.  For example, to get the key at position
     ; 1/2/3 you would pass 1/2 as the parent path and 3 as the child number.
     ;
     ; @param parentPath The path to the parent.
     ; @param relative Whether the path is relative to the root path.
     ; @param createParent Whether the parent corresponding to path should be created (with any necessary ancestors) if it doesn't exist already.
     ; @return the requested key.
     ; @throws IllegalArgumentException if the parent doesn't exist and createParent is false.
     ;;
    #_public
    (§ method #_"DeterministicKey" (§ fn deriveChild) [#_"List<ChildNumber>" (§ name parentPath), #_"boolean" (§ name relative), #_"boolean" (§ name createParent), #_"ChildNumber" (§ name createChildNumber)])
    (§ block
        (§ return (§ expr deriveChild(§ pars get(§ pars parentPath, relative, createParent), createChildNumber)))
    )

    #_private
    (§ method #_"DeterministicKey" (§ fn deriveChild) [#_"DeterministicKey" (§ name parent), #_"ChildNumber" (§ name createChildNumber)])
    (§ block
        (§ var #_"DeterministicKey" (§ name childKey) (§ expr HDKeyDerivation/deriveChildKey(§ pars parent, createChildNumber)))
        (§ expr putKey(§ pars childKey))
        (§ return childKey)
    )

    ;;;
     ; Returns the root key that the {@link DeterministicHierarchy} was created with.
     ;;
    #_public
    (§ method #_"DeterministicKey" (§ fn getRootKey) [])
    (§ block
        (§ return (§ expr get(§ pars rootPath, false, false)))
    )
)

#_(ns org.bitcoinj.crypto #_"DeterministicKey"
    (:import [java.math BigInteger]
             [java.nio ByteBuffer]
             [java.util Arrays Comparator])
    (:import [com.google.common.base MoreObjects Objects Preconditions]
             [com.google.common.collect ImmutableList]
             [org.spongycastle.crypto.params KeyParameter]
             [org.spongycastle.math.ec ECPoint])
   (:require [org.bitcoinj.core *]
             #_static [org.bitcoinj.core.Utils HEX]))

;;;
 ; A deterministic key is a node in a {@link DeterministicHierarchy}.  As per
 ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">the BIP 32 specification</a> it is a pair
 ; (key, chaincode).  If you know its path in the tree and its chain code you can derive more keys from this.
 ; To obtain one of these, you can call {@link HDKeyDerivation#createMasterPrivateKey(byte[])}.
 ;;
#_public
(§ class #_"DeterministicKey" (§ extends #_"ECKey")
    ;;; Sorts deterministic keys in the order of their child number.  That's <i>usually</i> the order used to derive them. ;;
    #_public
    #_static
    #_final
    (§ field #_"Comparator<ECKey>" (§ name CHILDNUM_ORDER) (§ new #_"Comparator<ECKey>" (§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"int" (§ fn compare) [#_"ECKey" (§ name k1), #_"ECKey" (§ name k2)])
            (§ block
                (§ var #_"ChildNumber" (§ name cn1) (§ expr (§ expr (§ cast #_"DeterministicKey" k1)).getChildNumber(§ pars )))
                (§ var #_"ChildNumber" (§ name cn2) (§ expr (§ expr (§ cast #_"DeterministicKey" k2)).getChildNumber(§ pars )))
                (§ return (§ expr cn1.compareTo(§ pars cn2)))
            )
        )))

    #_private
    #_final
    (§ field #_"DeterministicKey" (§ name parent))
    #_private
    #_final
    (§ field #_"ImmutableList<ChildNumber>" (§ name childNumberPath))
    #_private
    #_final
    (§ field #_"int" (§ name depth))
    #_private
    (§ field #_"int" (§ name parentFingerprint)) ;; 0 if this key is root node of key hierarchy

    ;;; 32 bytes ;;
    #_private
    #_final
    (§ field #_"byte[]" (§ name chainCode))

    ;;; Constructs a key from its components.  This is not normally something you should use. ;;
    #_public
    (§ constructor #_"DeterministicKey" [#_"ImmutableList<ChildNumber>" (§ name childNumberPath), #_"byte[]" (§ name chainCode), #_"LazyECPoint" (§ name publicAsPoint), #_nilable #_"BigInteger" (§ name priv), #_nilable #_"DeterministicKey" (§ name parent)])
    (§ block
        (§ super (§ pars priv, compressPoint(§ pars Preconditions/checkNotNull(§ pars publicAsPoint))))

        (§ expr Preconditions/checkArgument(§ pars chainCode.length == 32))

        (§ ass (§ name this.parent) parent)
        (§ ass (§ name this.childNumberPath) (§ expr Preconditions/checkNotNull(§ pars childNumberPath)))
        (§ ass (§ name this.chainCode) (§ expr Arrays/copyOf(§ pars chainCode, chainCode.length)))
        (§ ass (§ name this.depth) (§ quest (§ expr parent != nil) ? (§ expr parent.depth + 1) :else 0))
        (§ ass (§ name this.parentFingerprint) (§ quest (§ expr parent != nil) ? (§ expr parent.getFingerprint(§ pars )) :else 0))
        (§ void this)
    )

    #_public
    (§ constructor #_"DeterministicKey" [#_"ImmutableList<ChildNumber>" (§ name childNumberPath), #_"byte[]" (§ name chainCode), #_"ECPoint" (§ name publicAsPoint), #_nilable #_"BigInteger" (§ name priv), #_nilable #_"DeterministicKey" (§ name parent)])
    (§ block
        (§ this (§ pars childNumberPath, chainCode, new LazyECPoint(§ pars publicAsPoint), priv, parent))
        (§ void this)
    )

    ;;; Constructs a key from its components.  This is not normally something you should use. ;;
    #_public
    (§ constructor #_"DeterministicKey" [#_"ImmutableList<ChildNumber>" (§ name childNumberPath), #_"byte[]" (§ name chainCode), #_"BigInteger" (§ name priv), #_nilable #_"DeterministicKey" (§ name parent)])
    (§ block
        (§ super (§ pars priv, compressPoint(§ pars ECKey/publicPointFromPrivate(§ pars priv))))

        (§ expr Preconditions/checkArgument(§ pars chainCode.length == 32))

        (§ ass (§ name this.parent) parent)
        (§ ass (§ name this.childNumberPath) (§ expr Preconditions/checkNotNull(§ pars childNumberPath)))
        (§ ass (§ name this.chainCode) (§ expr Arrays/copyOf(§ pars chainCode, chainCode.length)))
        (§ ass (§ name this.depth) (§ quest (§ expr parent != nil) ? (§ expr parent.depth + 1) :else 0))
        (§ ass (§ name this.parentFingerprint) (§ quest (§ expr parent != nil) ? (§ expr parent.getFingerprint(§ pars )) :else 0))
        (§ void this)
    )

    ;;; Constructs a key from its components.  This is not normally something you should use. ;;
    #_public
    (§ constructor #_"DeterministicKey" [#_"ImmutableList<ChildNumber>" (§ name childNumberPath), #_"byte[]" (§ name chainCode), #_"KeyCrypter" (§ name crypter), #_"LazyECPoint" (§ name pub), #_"EncryptedData" (§ name priv), #_nilable #_"DeterministicKey" (§ name parent)])
    (§ block
        (§ this (§ pars childNumberPath, chainCode, pub, nil, parent))
        (§ ass (§ name this.encryptedPrivateKey) (§ expr Preconditions/checkNotNull(§ pars priv)))
        (§ ass (§ name this.keyCrypter) (§ expr Preconditions/checkNotNull(§ pars crypter)))
        (§ void this)
    )

    ;;;
     ; Return the fingerprint of this key's parent as an int value, or zero if this key is the
     ; root node of the key hierarchy.  Raise an exception if the arguments are inconsistent.
     ; This method exists to avoid code repetition in the constructors.
     ;;
    #_private
    (§ method #_"int" (§ fn ascertainParentFingerprint) [#_"DeterministicKey" (§ name parentKey), #_"int" (§ name parentFingerprint)])
        (§ throws #_"IllegalArgumentException")
    (§ block
        (§ if (§ expr parentFingerprint != 0))
        (§ block
            (§ if (§ expr parent != nil))
            (§ block
                (§ expr Preconditions/checkArgument(§ pars parent.getFingerprint(§ pars ) == parentFingerprint, "parent fingerprint mismatch", Integer/toHexString(§ pars parent.getFingerprint(§ pars )), Integer/toHexString(§ pars parentFingerprint)))
            )
            (§ return parentFingerprint)
        )

        (§ return 0)
    )

    ;;;
     ; Constructs a key from its components, including its public key data and possibly-redundant
     ; information about its parent key.  Invoked when deserializing, but otherwise not something
     ; that you normally should use.
     ;;
    #_public
    (§ constructor #_"DeterministicKey" [#_"ImmutableList<ChildNumber>" (§ name childNumberPath), #_"byte[]" (§ name chainCode), #_"LazyECPoint" (§ name publicAsPoint), #_nilable #_"DeterministicKey" (§ name parent), #_"int" (§ name depth), #_"int" (§ name parentFingerprint)])
    (§ block
        (§ super (§ pars nil, compressPoint(§ pars Preconditions/checkNotNull(§ pars publicAsPoint))))

        (§ expr Preconditions/checkArgument(§ pars chainCode.length == 32))

        (§ ass (§ name this.parent) parent)
        (§ ass (§ name this.childNumberPath) (§ expr Preconditions/checkNotNull(§ pars childNumberPath)))
        (§ ass (§ name this.chainCode) (§ expr Arrays/copyOf(§ pars chainCode, chainCode.length)))
        (§ ass (§ name this.depth) depth)
        (§ ass (§ name this.parentFingerprint) (§ expr ascertainParentFingerprint(§ pars parent, parentFingerprint)))
        (§ void this)
    )

    ;;;
     ; Constructs a key from its components, including its private key data and possibly-redundant
     ; information about its parent key.  Invoked when deserializing, but otherwise not something that
     ; you normally should use.
     ;;
    #_public
    (§ constructor #_"DeterministicKey" [#_"ImmutableList<ChildNumber>" (§ name childNumberPath), #_"byte[]" (§ name chainCode), #_"BigInteger" (§ name priv), #_nilable #_"DeterministicKey" (§ name parent), #_"int" (§ name depth), #_"int" (§ name parentFingerprint)])
    (§ block
        (§ super (§ pars priv, compressPoint(§ pars ECKey/publicPointFromPrivate(§ pars priv))))

        (§ expr Preconditions/checkArgument(§ pars chainCode.length == 32))

        (§ ass (§ name this.parent) parent)
        (§ ass (§ name this.childNumberPath) (§ expr Preconditions/checkNotNull(§ pars childNumberPath)))
        (§ ass (§ name this.chainCode) (§ expr Arrays/copyOf(§ pars chainCode, chainCode.length)))
        (§ ass (§ name this.depth) depth)
        (§ ass (§ name this.parentFingerprint) (§ expr ascertainParentFingerprint(§ pars parent, parentFingerprint)))
        (§ void this)
    )

    ;;; Clones the key. ;;
    #_public
    (§ constructor #_"DeterministicKey" [#_"DeterministicKey" (§ name keyToClone), #_"DeterministicKey" (§ name newParent)])
    (§ block
        (§ super (§ pars keyToClone.priv, keyToClone.pub.get(§ pars )))

        (§ ass (§ name this.parent) newParent)
        (§ ass (§ name this.childNumberPath) (§ expr keyToClone.childNumberPath))
        (§ ass (§ name this.chainCode) (§ expr keyToClone.chainCode))
        (§ ass (§ name this.encryptedPrivateKey) (§ expr keyToClone.encryptedPrivateKey))
        (§ ass (§ name this.depth) (§ expr this.childNumberPath.size(§ pars )))
        (§ ass (§ name this.parentFingerprint) (§ expr this.parent.getFingerprint(§ pars )))
        (§ void this)
    )

    ;;;
     ; Returns the path through some {@link DeterministicHierarchy} which reaches this keys position in the tree.
     ; A path can be written as 1/2/1 which means the first child of the root, the second child of that node, then
     ; the first child of that node.
     ;;
    #_public
    (§ method #_"ImmutableList<ChildNumber>" (§ fn getPath) [])
    (§ block
        (§ return childNumberPath)
    )

    ;;;
     ; Returns the path of this key as a human readable string starting with M to indicate the master key.
     ;;
    #_public
    (§ method #_"String" (§ fn getPathAsString) [])
    (§ block
        (§ return (§ expr HDUtils/formatPath(§ pars getPath(§ pars ))))
    )

    ;;;
     ; Return this key's depth in the hierarchy, where the root node is at depth zero.
     ; This may be different than the number of segments in the path if this key was
     ; deserialized without access to its parent.
     ;;
    #_public
    (§ method #_"int" (§ fn getDepth) [])
    (§ block
        (§ return depth)
    )

    ;;; Returns the last element of the path returned by {@link DeterministicKey#getPath()}. ;;
    #_public
    (§ method #_"ChildNumber" (§ fn getChildNumber) [])
    (§ block
        (§ return (§ quest (§ expr childNumberPath.size(§ pars ) == 0) ? (§ expr ChildNumber/ZERO) :else (§ expr childNumberPath.get(§ pars childNumberPath.size(§ pars ) - 1))))
    )

    ;;;
     ; Returns the chain code associated with this key.  See the specification to learn more about chain codes.
     ;;
    #_public
    (§ method #_"byte[]" (§ fn getChainCode) [])
    (§ block
        (§ return chainCode)
    )

    ;;;
     ; Returns RIPE-MD160(SHA256(pub key bytes)).
     ;;
    #_public
    (§ method #_"byte[]" (§ fn getIdentifier) [])
    (§ block
        (§ return (§ expr Utils/sha256hash160(§ pars getPubKey(§ pars ))))
    )

    ;;; Returns the first 32 bits of the result of {@link #getIdentifier()}. ;;
    #_public
    (§ method #_"int" (§ fn getFingerprint) [])
    (§ block
        ;; TODO: Why is this different than armory's fingerprint?  BIP 32: "The first 32 bits of the identifier are called the fingerprint."
        (§ return (§ expr ByteBuffer/wrap(§ pars Arrays/copyOfRange(§ pars getIdentifier(§ pars ), 0, 4)).getInt(§ pars )))
    )

    #_nilable
    #_public
    (§ method #_"DeterministicKey" (§ fn getParent) [])
    (§ block
        (§ return parent)
    )

    ;;;
     ; Return the fingerprint of the key from which this key was derived, if this is
     ; a child key, or else an array of four zero-value bytes.
     ;;
    #_public
    (§ method #_"int" (§ fn getParentFingerprint) [])
    (§ block
        (§ return parentFingerprint)
    )

    ;;;
     ; Returns private key bytes, padded with zeros to 33 bytes.
     ; @throws java.lang.IllegalStateException if the private key bytes are missing.
     ;;
    #_public
    (§ method #_"byte[]" (§ fn getPrivKeyBytes33) [])
    (§ block
        (§ var #_"byte[]" (§ name bytes33) (§ new #_"byte[]" (§ count 33)))
        (§ var #_"byte[]" (§ name priv) (§ expr getPrivKeyBytes(§ pars )))
        (§ expr System/arraycopy(§ pars priv, 0, bytes33, 33 - priv.length, priv.length))
        (§ return bytes33)
    )

    ;;;
     ; Returns the same key with the private bytes removed.  May return the same instance.  The purpose of this is to
     ; save memory: the private key can always be very efficiently rederived from a parent that a private key, so storing
     ; all the private keys in RAM is a poor tradeoff especially on constrained devices.  This means that the returned
     ; key may still be usable for signing and so on, so don't expect it to be a true pubkey-only object!  If you want
     ; that then you should follow this call with a call to {@link #dropParent()}.
     ;;
    #_public
    (§ method #_"DeterministicKey" (§ fn dropPrivateBytes) [])
    (§ block
        (§ return (§ quest (§ expr isPubKeyOnly(§ pars )) ? this :else (§ new #_"DeterministicKey" (§ pars getPath(§ pars ), getChainCode(§ pars ), pub, nil, parent))))
    )

    ;;;
     ; <p>Returns the same key with the parent pointer removed (it still knows its own path and the parent fingerprint).</p>
     ;
     ; <p>If this key doesn't have private key bytes stored/cached itself, but could rederive them from the parent, then
     ; the new key returned by this method won't be able to do that.  Thus, using dropPrivateBytes().dropParent() on a
     ; regular DeterministicKey will yield a new DeterministicKey that cannot sign or do other things involving the
     ; private key at all.</p>
     ;;
    #_public
    (§ method #_"DeterministicKey" (§ fn dropParent) [])
    (§ block
        (§ var #_"DeterministicKey" (§ name key) (§ new #_"DeterministicKey" (§ pars getPath(§ pars ), getChainCode(§ pars ), pub, priv, nil)))
        (§ ass (§ name key.parentFingerprint) parentFingerprint)
        (§ return key)
    )

    #_static
    (§ method #_"byte[]" (§ fn addChecksum) [#_"byte[]" (§ name input)])
    (§ block
        (§ var #_"int" (§ name inputLength) (§ expr input.length))
        (§ var #_"byte[]" (§ name checksummed) (§ new #_"byte[]" (§ count inputLength + 4)))
        (§ expr System/arraycopy(§ pars input, 0, checksummed, 0, inputLength))
        (§ var #_"byte[]" (§ name checksum) (§ expr Sha256Hash/hashTwice(§ pars input)))
        (§ expr System/arraycopy(§ pars checksum, 0, checksummed, inputLength, 4))
        (§ return checksummed)
    )

    #_override
    #_public
    (§ method #_"DeterministicKey" (§ fn encrypt) [#_"KeyCrypter" (§ name keyCrypter), #_"KeyParameter" (§ name aesKey)])
        (§ throws #_"KeyCrypterException")
    (§ block
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars "Must supply a new parent for encryption")))
    )

    #_public
    (§ method #_"DeterministicKey" (§ fn encrypt) [#_"KeyCrypter" (§ name keyCrypter), #_"KeyParameter" (§ name aesKey), #_nilable #_"DeterministicKey" (§ name newParent)])
        (§ throws #_"KeyCrypterException")
    (§ block
        ;; Same as the parent code, except we construct a DeterministicKey instead of an ECKey.
        (§ expr Preconditions/checkNotNull(§ pars keyCrypter))
        (§ if (§ expr newParent != nil))
        (§ block
            (§ expr Preconditions/checkArgument(§ pars newParent.isEncrypted(§ pars )))
        )

        #_final
        (§ var #_"byte[]" (§ name privKeyBytes) (§ expr getPrivKeyBytes(§ pars )))
        (§ expr Preconditions/checkState(§ pars privKeyBytes != nil, "Private key is not available"))

        (§ var #_"EncryptedData" (§ name encryptedPrivateKey) (§ expr keyCrypter.encrypt(§ pars privKeyBytes, aesKey)))
        (§ var #_"DeterministicKey" (§ name key) (§ new #_"DeterministicKey" (§ pars childNumberPath, chainCode, keyCrypter, pub, encryptedPrivateKey, newParent)))
        (§ if (§ expr newParent == nil))
        (§ block
            (§ expr key.setCreationTimeSeconds(§ pars getCreationTimeSeconds(§ pars )))
        )
        (§ return key)
    )

    ;;;
     ; A deterministic key is considered to be 'public key only' if it hasn't got a private key part and it cannot be
     ; rederived.  If the hierarchy is encrypted this returns true.
     ;;
    #_override
    #_public
    (§ method #_"boolean" (§ fn isPubKeyOnly) [])
    (§ block
        (§ return (§ expr super.isPubKeyOnly(§ pars ) && (§ expr parent == nil || parent.isPubKeyOnly(§ pars ))))
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (§ method #_"boolean" (§ fn hasPrivKey) [])
    (§ block
        (§ return (§ expr findParentWithPrivKey(§ pars ) != nil))
    )

    #_nilable
    #_override
    #_public
    (§ method #_"byte[]" (§ fn getSecretBytes) [])
    (§ block
        (§ return (§ quest (§ expr priv != nil) ? (§ expr getPrivKeyBytes(§ pars )) :else nil))
    )

    ;;;
     ; A deterministic key is considered to be encrypted if it has access to encrypted private key bytes, OR if its
     ; parent does.  The reason is because the parent would be encrypted under the same key and this key knows how to
     ; rederive its own private key bytes from the parent, if needed.
     ;;
    #_override
    #_public
    (§ method #_"boolean" (§ fn isEncrypted) [])
    (§ block
        (§ return (§ expr priv == nil && (§ expr super.isEncrypted(§ pars ) || (§ expr parent != nil && parent.isEncrypted(§ pars )))))
    )

    ;;;
     ; Returns this keys {@link org.bitcoinj.crypto.KeyCrypter} <b>or</b> the keycrypter of its parent key.
     ;;
    #_override
    #_nilable
    #_public
    (§ method #_"KeyCrypter" (§ fn getKeyCrypter) [])
    (§ block
        (§ if (§ expr keyCrypter != nil))
        (§ block
            (§ return keyCrypter)
        )
        (§ if (§ expr parent != nil))
        (§ block
            (§ return (§ expr parent.getKeyCrypter(§ pars )))
        )

        (§ return nil)
    )

    #_override
    #_public
    (§ method #_"ECDSASignature" (§ fn sign) [#_"Sha256Hash" (§ name input), #_nilable #_"KeyParameter" (§ name aesKey)])
        (§ throws #_"KeyCrypterException")
    (§ block
        (§ if (§ expr isEncrypted(§ pars )))
        (§ block
            ;; If the key is encrypted, ECKey.sign will decrypt it first before rerunning sign.  Decryption walks
            ;; the key heirarchy to find the private key (see below), so, we can just run the inherited method.
            (§ return (§ expr super.sign(§ pars input, aesKey)))
        )
        (§ else )
        (§ block
            ;; If it's not encrypted, derive the private via the parents.
            #_final
            (§ var #_"BigInteger" (§ name privateKey) (§ expr findOrDerivePrivateKey(§ pars )))
            ;; This key is a part of a public-key only heirarchy and cannot be used for signing.
            (§ if (§ expr privateKey == nil))
            (§ block
                (§ throw (§ new #_"MissingPrivateKeyException" (§ pars )))
            )

            (§ return (§ expr super.doSign(§ pars input, privateKey)))
        )
    )

    #_override
    #_public
    (§ method #_"DeterministicKey" (§ fn decrypt) [#_"KeyCrypter" (§ name keyCrypter), #_"KeyParameter" (§ name aesKey)])
        (§ throws #_"KeyCrypterException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars keyCrypter))
        ;; Check that the keyCrypter matches the one used to encrypt the keys, if set.
        (§ if (§ expr this.keyCrypter != nil && (§ not this.keyCrypter.equals(§ pars keyCrypter))))
        (§ block
            (§ throw (§ new #_"KeyCrypterException" (§ pars "The keyCrypter being used to decrypt the key is different to the one that was used to encrypt it")))
        )

        (§ var #_"BigInteger" (§ name privKey) (§ expr findOrDeriveEncryptedPrivateKey(§ pars keyCrypter, aesKey)))
        (§ var #_"DeterministicKey" (§ name key) (§ new #_"DeterministicKey" (§ pars childNumberPath, chainCode, privKey, parent)))
        (§ if (§ expr (§ not Arrays/equals(§ pars key.getPubKey(§ pars ), getPubKey(§ pars )))))
        (§ block
            (§ throw (§ new #_"KeyCrypterException" (§ pars "Provided AES key is wrong")))
        )

        (§ if (§ expr parent == nil))
        (§ block
            (§ expr key.setCreationTimeSeconds(§ pars getCreationTimeSeconds(§ pars )))
        )
        (§ return key)
    )

    #_override
    #_public
    (§ method #_"DeterministicKey" (§ fn decrypt) [#_"KeyParameter" (§ name aesKey)])
        (§ throws #_"KeyCrypterException")
    (§ block
        (§ return (§ cast #_"DeterministicKey" (§ expr super.decrypt(§ pars aesKey))))
    )

    ;; For when a key is encrypted, either decrypt our encrypted private key bytes, or work up the tree asking parents
    ;; to decrypt and re-derive.
    #_private
    (§ method #_"BigInteger" (§ fn findOrDeriveEncryptedPrivateKey) [#_"KeyCrypter" (§ name keyCrypter), #_"KeyParameter" (§ name aesKey)])
    (§ block
        (§ if (§ expr encryptedPrivateKey != nil))
        (§ block
            (§ return (§ new #_"BigInteger" (§ pars 1, keyCrypter.decrypt(§ pars encryptedPrivateKey, aesKey))))
        )

        ;; Otherwise we don't have it, but maybe we can figure it out from our parents.  Walk up the tree looking for
        ;; the first key that has some encrypted private key data.
        (§ var #_"DeterministicKey" (§ name cursor) parent)
        (§ while (§ expr cursor != nil))
        (§ block
            (§ if (§ expr cursor.encryptedPrivateKey != nil))
            (§ block
                (§ break )
            )
            (§ ass (§ name cursor) (§ expr cursor.parent))
        )
        (§ if (§ expr cursor == nil))
        (§ block
            (§ throw (§ new #_"KeyCrypterException" (§ pars "Neither this key nor its parents have an encrypted private key")))
        )

        (§ var #_"byte[]" (§ name parentalPrivateKeyBytes) (§ expr keyCrypter.decrypt(§ pars cursor.encryptedPrivateKey, aesKey)))
        (§ return (§ expr derivePrivateKeyDownwards(§ pars cursor, parentalPrivateKeyBytes)))
    )

    #_private
    (§ method #_"DeterministicKey" (§ fn findParentWithPrivKey) [])
    (§ block
        (§ var #_"DeterministicKey" (§ name cursor) this)
        (§ while (§ expr cursor != nil))
        (§ block
            (§ if (§ expr cursor.priv != nil))
            (§ block
                (§ break )
            )
            (§ ass (§ name cursor) (§ expr cursor.parent))
        )
        (§ return cursor)
    )

    #_nilable
    #_private
    (§ method #_"BigInteger" (§ fn findOrDerivePrivateKey) [])
    (§ block
        (§ var #_"DeterministicKey" (§ name cursor) (§ expr findParentWithPrivKey(§ pars )))
        (§ if (§ expr cursor == nil))
        (§ block
            (§ return nil)
        )

        (§ return (§ expr derivePrivateKeyDownwards(§ pars cursor, cursor.priv.toByteArray(§ pars ))))
    )

    #_private
    (§ method #_"BigInteger" (§ fn derivePrivateKeyDownwards) [#_"DeterministicKey" (§ name cursor), #_"byte[]" (§ name parentalPrivateKeyBytes)])
    (§ block
        (§ var #_"DeterministicKey" (§ name downCursor) (§ new #_"DeterministicKey" (§ pars cursor.childNumberPath, cursor.chainCode, cursor.pub, new BigInteger(§ pars 1, parentalPrivateKeyBytes), cursor.parent)))
        ;; Now we have to rederive the keys along the path back to ourselves.  That path can be found by just truncating
        ;; our path with the length of the parents path.
        (§ var #_"ImmutableList<ChildNumber>" (§ name path) (§ expr childNumberPath.subList(§ pars cursor.getPath(§ pars ).size(§ pars ), childNumberPath.size(§ pars ))))
        (§ for (§ var #_"ChildNumber" (§ name num)) :for path)
        (§ block
            (§ ass (§ name downCursor) (§ expr HDKeyDerivation/deriveChildKey(§ pars downCursor, num)))
        )
        ;; downCursor is now the same key as us, but with private key bytes.
        ;; If it's not, it means we tried decrypting with an invalid password and earlier checks e.g. for padding didn't
        ;; catch it.
        (§ if (§ expr (§ not downCursor.pub.equals(§ pars pub))))
        (§ block
            (§ throw (§ new #_"KeyCrypterException" (§ pars "Could not decrypt bytes")))
        )

        (§ return (§ expr Preconditions/checkNotNull(§ pars downCursor.priv)))
    )

    ;;;
     ; Derives a child at the given index using hardened derivation.  Note: <code>index</code>
     ; is not the "i" value.  If you want the softened derivation, then use instead
     ; <code>HDKeyDerivation.deriveChildKey(this, new ChildNumber(child, false))</code>.
     ;;
    #_public
    (§ method #_"DeterministicKey" (§ fn derive) [#_"int" (§ name child)])
    (§ block
        (§ return (§ expr HDKeyDerivation/deriveChildKey(§ pars this, new ChildNumber(§ pars child, true))))
    )

    ;;;
     ; Returns the private key of this deterministic key.  Even if this object isn't storing the private key,
     ; it can be re-derived by walking up to the parents if necessary and this is what will happen.
     ; @throws java.lang.IllegalStateException if the parents are encrypted or a watching chain.
     ;;
    #_override
    #_public
    (§ method #_"BigInteger" (§ fn getPrivKey) [])
    (§ block
        #_final
        (§ var #_"BigInteger" (§ name key) (§ expr findOrDerivePrivateKey(§ pars )))
        (§ expr Preconditions/checkState(§ pars key != nil, "Private key bytes not available"))
        (§ return key)
    )

    #_public
    (§ method #_"byte[]" (§ fn serializePublic) [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ return (§ expr serialize(§ pars params, true)))
    )

    #_public
    (§ method #_"byte[]" (§ fn serializePrivate) [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ return (§ expr serialize(§ pars params, false)))
    )

    #_private
    (§ method #_"byte[]" (§ fn serialize) [#_"NetworkParameters" (§ name params), #_"boolean" (§ name pub)])
    (§ block
        (§ var #_"ByteBuffer" (§ name ser) (§ expr ByteBuffer/allocate(§ pars 78)))
        (§ expr ser.putInt(§ pars (§ quest pub ? (§ expr params.getBip32HeaderPub(§ pars )) :else (§ expr params.getBip32HeaderPriv(§ pars )))))
        (§ expr ser.put(§ pars (§ cast #_"byte" (§ expr getDepth(§ pars )))))
        (§ expr ser.putInt(§ pars getParentFingerprint(§ pars )))
        (§ expr ser.putInt(§ pars getChildNumber(§ pars ).i(§ pars )))
        (§ expr ser.put(§ pars getChainCode(§ pars )))
        (§ expr ser.put(§ pars (§ quest pub ? (§ expr getPubKey(§ pars )) :else (§ expr getPrivKeyBytes33(§ pars )))))
        (§ expr Preconditions/checkState(§ pars ser.position(§ pars ) == 78))
        (§ return (§ expr ser.array(§ pars )))
    )

    #_public
    (§ method #_"String" (§ fn serializePubB58) [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ return (§ expr toBase58(§ pars serialize(§ pars params, true))))
    )

    #_public
    (§ method #_"String" (§ fn serializePrivB58) [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ return (§ expr toBase58(§ pars serialize(§ pars params, false))))
    )

    #_static
    (§ method #_"String" (§ fn toBase58) [#_"byte[]" (§ name ser)])
    (§ block
        (§ return (§ expr Base58/encode(§ pars addChecksum(§ pars ser))))
    )

    ;;; Deserialize a base-58-encoded HD Key with no parent. ;;
    #_public
    #_static
    (§ method #_"DeterministicKey" (§ fn deserializeB58) [#_"String" (§ name base58), #_"NetworkParameters" (§ name params)])
    (§ block
        (§ return (§ expr deserializeB58(§ pars nil, base58, params)))
    )

    ;;;
     ; Deserialize a base-58-encoded HD Key.
     ; @param parent The parent node in the given key's deterministic hierarchy.
     ; @throws IllegalArgumentException if the base58 encoded key could not be parsed.
     ;;
    #_public
    #_static
    (§ method #_"DeterministicKey" (§ fn deserializeB58) [#_nilable #_"DeterministicKey" (§ name parent), #_"String" (§ name base58), #_"NetworkParameters" (§ name params)])
    (§ block
        (§ return (§ expr deserialize(§ pars params, Base58/decodeChecked(§ pars base58), parent)))
    )

    ;;;
     ; Deserialize an HD Key with no parent.
     ;;
    #_public
    #_static
    (§ method #_"DeterministicKey" (§ fn deserialize) [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name serializedKey)])
    (§ block
        (§ return (§ expr deserialize(§ pars params, serializedKey, nil)))
    )

    ;;;
     ; Deserialize an HD Key.
     ; @param parent The parent node in the given key's deterministic hierarchy.
     ;;
    #_public
    #_static
    (§ method #_"DeterministicKey" (§ fn deserialize) [#_"NetworkParameters" (§ name params), #_"byte[]" (§ name serializedKey), #_nilable #_"DeterministicKey" (§ name parent)])
    (§ block
        (§ var #_"ByteBuffer" (§ name buffer) (§ expr ByteBuffer/wrap(§ pars serializedKey)))
        (§ var #_"int" (§ name header) (§ expr buffer.getInt(§ pars )))
        (§ if (§ expr header != params.getBip32HeaderPriv(§ pars ) && header != params.getBip32HeaderPub(§ pars )))
        (§ block
            (§ throw (§ new #_"IllegalArgumentException" (§ pars "Unknown header bytes: " + toBase58(§ pars serializedKey).substring(§ pars 0, 4))))
        )

        (§ var #_"boolean" (§ name pub) (§ expr header == params.getBip32HeaderPub(§ pars )))
        (§ var #_"int" (§ name depth) (§ expr buffer.get(§ pars ) & 0xff)) ;; convert signed byte to positive int since depth cannot be negative
        #_final
        (§ var #_"int" (§ name parentFingerprint) (§ expr buffer.getInt(§ pars )))
        #_final
        (§ var #_"int" (§ name i) (§ expr buffer.getInt(§ pars )))
        #_final
        (§ var #_"ChildNumber" (§ name childNumber) (§ new #_"ChildNumber" (§ pars i)))
        (§ var #_"ImmutableList<ChildNumber>" (§ name path))
        (§ if (§ expr parent != nil))
        (§ block
            (§ if (§ expr parentFingerprint == 0))
            (§ block
                (§ throw (§ new #_"IllegalArgumentException" (§ pars "Parent was provided but this key doesn't have one")))
            )
            (§ if (§ expr parent.getFingerprint(§ pars ) != parentFingerprint))
            (§ block
                (§ throw (§ new #_"IllegalArgumentException" (§ pars "Parent fingerprints don't match")))
            )
            (§ ass (§ name path) (§ expr HDUtils/append(§ pars parent.getPath(§ pars ), childNumber)))
            (§ if (§ expr path.size(§ pars ) != depth))
            (§ block
                (§ throw (§ new #_"IllegalArgumentException" (§ pars "Depth does not match")))
            )
        )
        (§ else )
        (§ block
            ;; We have been given a key that is not a root key, yet we lack the object representing the parent.
            ;; This can happen when deserializing an account key for a watching wallet.  In this case, we assume that
            ;; the client wants to conceal the key's position in the hierarchy.  The path is truncated at the
            ;; parent's node.
            (§ if (§ expr 1 <= depth))
            (§ block
                (§ ass (§ name path) (§ expr ImmutableList/of(§ pars childNumber)))
            )
            (§ else )
            (§ block
                (§ ass (§ name path) (§ expr ImmutableList/of(§ pars )))
            )
        )
        (§ var #_"byte[]" (§ name chainCode) (§ new #_"byte[]" (§ count 32)))
        (§ expr buffer.get(§ pars chainCode))
        (§ var #_"byte[]" (§ name data) (§ new #_"byte[]" (§ count 33)))
        (§ expr buffer.get(§ pars data))
        (§ expr Preconditions/checkArgument(§ pars (§ not buffer.hasRemaining(§ pars )), "Found unexpected data in key"))
        (§ if pub)
        (§ block
            (§ return (§ new #_"DeterministicKey" (§ pars path, chainCode, new LazyECPoint(§ pars ECKey/CURVE.getCurve(§ pars ), data), parent, depth, parentFingerprint)))
        )
        (§ else )
        (§ block
            (§ return (§ new #_"DeterministicKey" (§ pars path, chainCode, new BigInteger(§ pars 1, data), parent, depth, parentFingerprint)))
        )
    )

    ;;;
     ; The creation time of a deterministic key is equal to that of its parent, unless this key is the root of a tree
     ; in which case the time is stored alongside the key as per normal, see {@link org.bitcoinj.core.ECKey#getCreationTimeSeconds()}.
     ;;
    #_override
    #_public
    (§ method #_"long" (§ fn getCreationTimeSeconds) [])
    (§ block
        (§ if (§ expr parent != nil))
        (§ block
            (§ return (§ expr parent.getCreationTimeSeconds(§ pars )))
        )
        (§ else )
        (§ block
            (§ return (§ expr super.getCreationTimeSeconds(§ pars )))
        )
    )

    ;;;
     ; The creation time of a deterministic key is equal to that of its parent, unless this key is the root of a tree.
     ; Thus, setting the creation time on a leaf is forbidden.
     ;;
    #_override
    #_public
    (§ method #_"void" (§ fn setCreationTimeSeconds) [#_"long" (§ name newCreationTimeSeconds)])
    (§ block
        (§ if (§ expr parent != nil))
        (§ block
            (§ throw (§ new #_"IllegalStateException" (§ pars "Creation time can only be set on root keys.")))
        )
        (§ else )
        (§ block
            (§ expr super.setCreationTimeSeconds(§ pars newCreationTimeSeconds))
        )
        (§ void nil)
    )

    ;;;
     ; Verifies equality of all fields but NOT the parent pointer (thus the same key derived in two separate heirarchy
     ; objects will equal each other.
     ;;
    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"DeterministicKey" (§ name other) (§ expr (§ cast #_"DeterministicKey" o)))
        (§ return (§ expr super.equals(§ pars other) && Arrays/equals(§ pars this.chainCode, other.chainCode) && Objects/equal(§ pars this.childNumberPath, other.childNumberPath)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars super.hashCode(§ pars ), Arrays/hashCode(§ pars chainCode), childNumberPath)))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        #_final
        (§ var #_"MoreObjects.ToStringHelper" (§ name helper) (§ expr MoreObjects/toStringHelper(§ pars this).omitNullValues(§ pars )))
        (§ expr helper.add(§ pars "pub", Utils/HEX.encode(§ pars pub.getEncoded(§ pars ))))
        (§ expr helper.add(§ pars "chainCode", HEX.encode(§ pars chainCode)))
        (§ expr helper.add(§ pars "path", getPathAsString(§ pars )))
        (§ if (§ expr 0 < creationTimeSeconds))
        (§ block
            (§ expr helper.add(§ pars "creationTimeSeconds", creationTimeSeconds))
        )
        (§ expr helper.add(§ pars "isEncrypted", isEncrypted(§ pars )))
        (§ expr helper.add(§ pars "isPubKeyOnly", isPubKeyOnly(§ pars )))
        (§ return (§ expr helper.toString(§ pars )))
    )

    #_override
    #_public
    (§ method #_"void" (§ fn formatKeyWithAddress) [#_"boolean" (§ name includePrivateKeys), #_"StringBuilder" (§ name sb), #_"NetworkParameters" (§ name params)])
    (§ block
        #_final
        (§ var #_"Address" (§ name address) (§ expr toAddress(§ pars params)))
        (§ expr sb.append(§ pars "  addr:").append(§ pars address))
        (§ expr sb.append(§ pars "  hash160:").append(§ pars Utils/HEX.encode(§ pars getPubKeyHash(§ pars ))))
        (§ expr sb.append(§ pars "  (").append(§ pars getPathAsString(§ pars )).append(§ pars ")\n"))
        (§ if includePrivateKeys)
        (§ block
            (§ expr sb.append(§ pars "  ").append(§ pars toStringWithPrivate(§ pars params)).append(§ pars "\n"))
        )
        (§ void nil)
    )
)

#_(ns org.bitcoinj.crypto #_"EncryptableItem"
   (:require [org.bitcoinj.wallet Protos]))

;;;
 ; Provides a uniform way to access something that can be optionally encrypted with a
 ; {@link org.bitcoinj.crypto.KeyCrypter}, yielding an {@link org.bitcoinj.crypto.EncryptedData},
 ; and which can have a creation time associated with it.
 ;;
#_public
(§ interface #_"EncryptableItem"
    ;;; Returns whether the item is encrypted or not.  If it is, then {@link #getSecretBytes()} will return null. ;;
    (§ method #_"boolean" (§ fn isEncrypted) [])

    ;;; Returns the raw bytes of the item, if not encrypted, or null if encrypted or the secret is missing. ;;
    #_nilable
    (§ method #_"byte[]" (§ fn getSecretBytes) [])

    ;;; Returns the initialization vector and encrypted secret bytes, or null if not encrypted. ;;
    #_nilable
    (§ method #_"EncryptedData" (§ fn getEncryptedData) [])

    ;;; Returns an enum constant describing what algorithm was used to encrypt the key or UNENCRYPTED. ;;
    (§ method #_"Protos.Wallet.EncryptionType" (§ fn getEncryptionType) [])

    ;;; Returns the time in seconds since the UNIX epoch at which this encryptable item was first created/derived. ;;
    (§ method #_"long" (§ fn getCreationTimeSeconds) [])
)

#_(ns org.bitcoinj.crypto #_"EncryptedData"
    (:import [java.util Arrays])
    (:import [com.google.common.base Objects]))

;;;
 ; <p>An instance of EncryptedData is a holder for an initialization vector and encrypted bytes.
 ; It is typically used to hold encrypted private key bytes.</p>
 ;
 ; <p>The initialisation vector is random data that is used to initialise the AES block cipher when
 ; the private key bytes were encrypted.  You need these for decryption.</p>
 ;;
#_public
#_final
(§ class #_"EncryptedData"
    #_public
    #_final
    (§ field #_"byte[]" (§ name initialisationVector))
    #_public
    #_final
    (§ field #_"byte[]" (§ name encryptedBytes))

    #_public
    (§ constructor #_"EncryptedData" [#_"byte[]" (§ name initialisationVector), #_"byte[]" (§ name encryptedBytes)])
    (§ block
        (§ ass (§ name this.initialisationVector) (§ expr Arrays/copyOf(§ pars initialisationVector, initialisationVector.length)))
        (§ ass (§ name this.encryptedBytes) (§ expr Arrays/copyOf(§ pars encryptedBytes, encryptedBytes.length)))
        (§ void this)
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"EncryptedData" (§ name other) (§ expr (§ cast #_"EncryptedData" o)))
        (§ return (§ expr Arrays/equals(§ pars encryptedBytes, other.encryptedBytes) && Arrays/equals(§ pars initialisationVector, other.initialisationVector)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars Arrays/hashCode(§ pars encryptedBytes), Arrays/hashCode(§ pars initialisationVector))))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr "EncryptedData [initialisationVector=" + Arrays/toString(§ pars initialisationVector) + ", encryptedPrivateKey=" + Arrays/toString(§ pars encryptedBytes) + "]"))
    )
)

#_(ns org.bitcoinj.crypto #_"HDDerivationException")

#_public
(§ class #_"HDDerivationException" (§ extends #_"RuntimeException")
    #_public
    (§ constructor #_"HDDerivationException" [#_"String" (§ name message)])
    (§ block
        (§ super (§ pars message))
        (§ void this)
    )
)

#_(ns org.bitcoinj.crypto #_"HDKeyDerivation"
    (:import [java.math *]
             [java.nio *]
             [java.security *]
             [java.util *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect *]
             [org.spongycastle.math.ec *])
   (:require [org.bitcoinj.core *]))

;;;
 ; Implementation of the <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP 32</a>
 ; deterministic wallet child key generation algorithm.
 ;;
#_public
#_final
(§ class #_"HDKeyDerivation"
    #_static
    (§ block
        ;; Init proper random number generator, as some old Android installations have bugs that make it unsecure.
        (§ if (§ expr Utils/isAndroidRuntime(§ pars )))
        (§ block
            (§ expr (§ new #_"LinuxSecureRandom" (§ pars )))
        )

        (§ ass (§ name RAND_INT) (§ new #_"BigInteger" (§ pars 256, new SecureRandom(§ pars ))))
    )

    ;; Some arbitrary random number.  Doesn't matter what it is.
    #_private
    #_static
    #_final
    (§ field #_"BigInteger" (§ name RAND_INT))

    #_private
    (§ constructor #_"HDKeyDerivation" [])
    (§ block
        (§ void this)
    )

    ;;;
     ; Child derivation may fail (although with extremely low probability); in such case it is re-attempted.
     ; This is the maximum number of re-attempts (to avoid an infinite loop in case of bugs etc.)
     ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name MAX_CHILD_DERIVATION_ATTEMPTS) 100)

    ;;;
     ; Generates a new deterministic key from the given seed, which can be any arbitrary byte array.
     ; However resist the temptation to use a string as the seed - any key derived from a password
     ; is likely to be weak and easily broken by attackers (this is not theoretical, people have had
     ; money stolen that way).  This method checks that the given seed is at least 64 bits long.
     ;
     ; @throws HDDerivationException if generated master key is invalid (private key 0 or >= n).
     ; @throws IllegalArgumentException if the seed is less than 8 bytes and could be brute forced.
     ;;
    #_public
    #_static
    (§ method #_"DeterministicKey" (§ fn createMasterPrivateKey) [#_"byte[]" (§ name seed)])
        (§ throws #_"HDDerivationException")
    (§ block
        (§ expr Preconditions/checkArgument(§ pars 8 < seed.length, "Seed is too short and could be brute forced"))

        ;; Calculate I = HMAC-SHA512(key="Bitcoin seed", msg=S).
        (§ var #_"byte[]" (§ name i) (§ expr HDUtils/hmacSha512(§ pars HDUtils/createHmacSha512Digest(§ pars "Bitcoin seed".getBytes(§ pars )), seed)))
        ;; Split I into two 32-byte sequences, Il and Ir.
        ;; Use Il as master secret key, and Ir as master chain code.
        (§ expr Preconditions/checkState(§ pars i.length == 64, i.length))

        (§ var #_"byte[]" (§ name il) (§ expr Arrays/copyOfRange(§ pars i, 0, 32)))
        (§ var #_"byte[]" (§ name ir) (§ expr Arrays/copyOfRange(§ pars i, 32, 64)))
        (§ expr Arrays/fill(§ pars i, (§ cast #_"byte" 0)))
        (§ var #_"DeterministicKey" (§ name masterPrivKey) (§ expr createMasterPrivKeyFromBytes(§ pars il, ir)))
        (§ expr Arrays/fill(§ pars il, (§ cast #_"byte" 0)))
        (§ expr Arrays/fill(§ pars ir, (§ cast #_"byte" 0)))

        ;; Child deterministic keys will chain up to their parents to find the keys.
        (§ expr masterPrivKey.setCreationTimeSeconds(§ pars Utils/currentTimeSeconds(§ pars )))
        (§ return masterPrivKey)
    )

    ;;;
     ; @throws HDDerivationException if privKeyBytes is invalid (0 or >= n).
     ;;
    #_public
    #_static
    (§ method #_"DeterministicKey" (§ fn createMasterPrivKeyFromBytes) [#_"byte[]" (§ name privKeyBytes), #_"byte[]" (§ name chainCode)])
        (§ throws #_"HDDerivationException")
    (§ block
        (§ var #_"BigInteger" (§ name priv) (§ new #_"BigInteger" (§ pars 1, privKeyBytes)))
        (§ expr assertNonZero(§ pars priv, "Generated master key is invalid."))
        (§ expr assertLessThanN(§ pars priv, "Generated master key is invalid."))
        (§ return (§ new #_"DeterministicKey" (§ pars ImmutableList.<ChildNumber>of(§ pars ), chainCode, priv, nil)))
    )

    #_public
    #_static
    (§ method #_"DeterministicKey" (§ fn createMasterPubKeyFromBytes) [#_"byte[]" (§ name pubKeyBytes), #_"byte[]" (§ name chainCode)])
    (§ block
        (§ return (§ new #_"DeterministicKey" (§ pars ImmutableList.<ChildNumber>of(§ pars ), chainCode, new LazyECPoint(§ pars ECKey/CURVE.getCurve(§ pars ), pubKeyBytes), nil, nil)))
    )

    ;;;
     ; Derives a key given the "extended" child number, i.e. the 0x80000000 bit of the value that you
     ; pass for <code>childNumber</code> will determine whether to use hardened derivation or not.
     ; Consider whether your code would benefit from the clarity of the equivalent, but explicit, form
     ; of this method that takes a <code>ChildNumber</code> rather than an <code>int</code>, for example:
     ; <code>deriveChildKey(parent, new ChildNumber(childNumber, true))</code>
     ; where the value of the hardened bit of <code>childNumber</code> is zero.
     ;;
    #_public
    #_static
    (§ method #_"DeterministicKey" (§ fn deriveChildKey) [#_"DeterministicKey" (§ name parent), #_"int" (§ name childNumber)])
    (§ block
        (§ return (§ expr deriveChildKey(§ pars parent, new ChildNumber(§ pars childNumber))))
    )

    ;;;
     ; Derives a key of the "extended" child number, i.e. with the 0x80000000 bit specifying whether
     ; to use hardened derivation or not.  If derivation fails, tries a next child.
     ;;
    #_public
    #_static
    (§ method #_"DeterministicKey" (§ fn deriveThisOrNextChildKey) [#_"DeterministicKey" (§ name parent), #_"int" (§ name childNumber)])
    (§ block
        (§ var #_"ChildNumber" (§ name child) (§ new #_"ChildNumber" (§ pars childNumber)))
        (§ var #_"boolean" (§ name isHardened) (§ expr child.isHardened(§ pars )))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < MAX_CHILD_DERIVATION_ATTEMPTS) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ try )
            (§ block
                (§ ass (§ name child) (§ new #_"ChildNumber" (§ pars child.num(§ pars ) + i, isHardened)))
                (§ return (§ expr deriveChildKey(§ pars parent, child)))
            )
            (§ catch #_"HDDerivationException" (§ name _))
            (§ block
            )
        )
        (§ throw (§ new #_"HDDerivationException" (§ pars "Maximum number of child derivation attempts reached, this is probably an indication of a bug.")))
    )

    ;;;
     ; @throws HDDerivationException if private derivation is attempted for a public-only parent key, or
     ; if the resulting derived key is invalid (e.g. private key == 0).
     ;;
    #_public
    #_static
    (§ method #_"DeterministicKey" (§ fn deriveChildKey) [#_"DeterministicKey" (§ name parent), #_"ChildNumber" (§ name childNumber)])
        (§ throws #_"HDDerivationException")
    (§ block
        (§ if (§ expr (§ not parent.hasPrivKey(§ pars ))))
        (§ block
            (§ var #_"RawKeyBytes" (§ name rawKey) (§ expr deriveChildKeyBytesFromPublic(§ pars parent, childNumber, PublicDeriveMode/NORMAL)))
            (§ return (§ new #_"DeterministicKey" (§ pars HDUtils/append(§ pars parent.getPath(§ pars ), childNumber), rawKey.chainCode, new LazyECPoint(§ pars ECKey/CURVE.getCurve(§ pars ), rawKey.keyBytes), nil, parent)))
        )
        (§ else )
        (§ block
            (§ var #_"RawKeyBytes" (§ name rawKey) (§ expr deriveChildKeyBytesFromPrivate(§ pars parent, childNumber)))
            (§ return (§ new #_"DeterministicKey" (§ pars HDUtils/append(§ pars parent.getPath(§ pars ), childNumber), rawKey.chainCode, new BigInteger(§ pars 1, rawKey.keyBytes), parent)))
        )
    )

    #_public
    #_static
    (§ method #_"RawKeyBytes" (§ fn deriveChildKeyBytesFromPrivate) [#_"DeterministicKey" (§ name parent), #_"ChildNumber" (§ name childNumber)])
        (§ throws #_"HDDerivationException")
    (§ block
        (§ expr Preconditions/checkArgument(§ pars parent.hasPrivKey(§ pars ), "Parent key must have private key bytes for this method."))

        (§ var #_"byte[]" (§ name parentPublicKey) (§ expr parent.getPubKeyPoint(§ pars ).getEncoded(§ pars true)))
        (§ expr Preconditions/checkState(§ pars parentPublicKey.length == 33, "Parent pubkey must be 33 bytes, but is " + parentPublicKey.length))

        (§ var #_"ByteBuffer" (§ name data) (§ expr ByteBuffer/allocate(§ pars 37)))
        (§ expr data.put(§ pars (§ quest (§ expr childNumber.isHardened(§ pars )) ? (§ expr parent.getPrivKeyBytes33(§ pars )) :else parentPublicKey)))
        (§ expr data.putInt(§ pars childNumber.i(§ pars )))

        (§ var #_"byte[]" (§ name i) (§ expr HDUtils/hmacSha512(§ pars parent.getChainCode(§ pars ), data.array(§ pars ))))
        (§ expr Preconditions/checkState(§ pars i.length == 64, i.length))

        (§ var #_"byte[]" (§ name il) (§ expr Arrays/copyOfRange(§ pars i, 0, 32)))
        (§ var #_"byte[]" (§ name chainCode) (§ expr Arrays/copyOfRange(§ pars i, 32, 64)))
        (§ var #_"BigInteger" (§ name ilInt) (§ new #_"BigInteger" (§ pars 1, il)))
        (§ expr assertLessThanN(§ pars ilInt, "Illegal derived key: I_L >= n"))

        #_final
        (§ var #_"BigInteger" (§ name priv) (§ expr parent.getPrivKey(§ pars )))
        (§ var #_"BigInteger" (§ name ki) (§ expr priv.add(§ pars ilInt).mod(§ pars ECKey/CURVE.getN(§ pars ))))
        (§ expr assertNonZero(§ pars ki, "Illegal derived key: derived private key equals 0."))

        (§ return (§ new #_"RawKeyBytes" (§ pars ki.toByteArray(§ pars ), chainCode)))
    )

    #_public
    (§ enum #_"PublicDeriveMode"
        (§ item NORMAL)
        (§ item WITH_INVERSION)
    )

    #_public
    #_static
    (§ method #_"RawKeyBytes" (§ fn deriveChildKeyBytesFromPublic) [#_"DeterministicKey" (§ name parent), #_"ChildNumber" (§ name childNumber), #_"PublicDeriveMode" (§ name mode)])
        (§ throws #_"HDDerivationException")
    (§ block
        (§ expr Preconditions/checkArgument(§ pars (§ not childNumber.isHardened(§ pars )), "Can't use private derivation with public keys only."))

        (§ var #_"byte[]" (§ name parentPublicKey) (§ expr parent.getPubKeyPoint(§ pars ).getEncoded(§ pars true)))
        (§ expr Preconditions/checkState(§ pars parentPublicKey.length == 33, "Parent pubkey must be 33 bytes, but is " + parentPublicKey.length))

        (§ var #_"ByteBuffer" (§ name data) (§ expr ByteBuffer/allocate(§ pars 37)))
        (§ expr data.put(§ pars parentPublicKey))
        (§ expr data.putInt(§ pars childNumber.i(§ pars )))

        (§ var #_"byte[]" (§ name i) (§ expr HDUtils/hmacSha512(§ pars parent.getChainCode(§ pars ), data.array(§ pars ))))
        (§ expr Preconditions/checkState(§ pars i.length == 64, i.length))

        (§ var #_"byte[]" (§ name il) (§ expr Arrays/copyOfRange(§ pars i, 0, 32)))
        (§ var #_"byte[]" (§ name chainCode) (§ expr Arrays/copyOfRange(§ pars i, 32, 64)))
        (§ var #_"BigInteger" (§ name ilInt) (§ new #_"BigInteger" (§ pars 1, il)))
        (§ expr assertLessThanN(§ pars ilInt, "Illegal derived key: I_L >= n"))

        #_final
        (§ var #_"BigInteger" (§ name N) (§ expr ECKey/CURVE.getN(§ pars )))
        (§ var #_"ECPoint" (§ name Ki))
        (§ switch mode)
        (§ block
            (§ case NORMAL)
            (§ block
                (§ ass (§ name Ki) (§ dot ECKey/publicPointFromPrivate(§ pars ilInt).add(§ pars parent.getPubKeyPoint(§ pars ))))
                (§ break )
            )
            (§ case WITH_INVERSION)
            (§ block
                ;; This trick comes from Gregory Maxwell.  Check the homomorphic properties of our curve hold.  The
                ;; below calculations should be redundant and give the same result as NORMAL but if the precalculated
                ;; tables have taken a bit flip will yield a different answer.  This mode is used when vending a key
                ;; to perform a last-ditch sanity check trying to catch bad RAM.
                (§ ass (§ name Ki) (§ expr ECKey/publicPointFromPrivate(§ pars ilInt.add(§ pars RAND_INT).mod(§ pars N))))
                (§ var #_"BigInteger" (§ name additiveInverse) (§ expr RAND_INT.negate(§ pars ).mod(§ pars N)))
                (§ ass (§ name Ki) (§ expr Ki/add(§ pars ECKey/publicPointFromPrivate(§ pars additiveInverse))))
                (§ ass (§ name Ki) (§ expr Ki/add(§ pars parent.getPubKeyPoint(§ pars ))))
                (§ break )
            )
            (§ default )
            (§ block
                (§ throw (§ new #_"AssertionError" (§ pars )))
            )
        )

        (§ expr assertNonInfinity(§ pars Ki, "Illegal derived key: derived public key equals infinity."))
        (§ return (§ new #_"RawKeyBytes" (§ pars Ki/getEncoded(§ pars true), chainCode)))
    )

    #_private
    #_static
    (§ method #_"void" (§ fn assertNonZero) [#_"BigInteger" (§ name integer), #_"String" (§ name errorMessage)])
    (§ block
        (§ if (§ expr integer.equals(§ pars BigInteger/ZERO)))
        (§ block
            (§ throw (§ new #_"HDDerivationException" (§ pars errorMessage)))
        )
        (§ void nil)
    )

    #_private
    #_static
    (§ method #_"void" (§ fn assertNonInfinity) [#_"ECPoint" (§ name point), #_"String" (§ name errorMessage)])
    (§ block
        (§ if (§ expr point.equals(§ pars ECKey/CURVE.getCurve(§ pars ).getInfinity(§ pars ))))
        (§ block
            (§ throw (§ new #_"HDDerivationException" (§ pars errorMessage)))
        )
        (§ void nil)
    )

    #_private
    #_static
    (§ method #_"void" (§ fn assertLessThanN) [#_"BigInteger" (§ name integer), #_"String" (§ name errorMessage)])
    (§ block
        (§ if (§ expr integer.compareTo(§ pars ECKey/CURVE.getN(§ pars )) > 0))
        (§ block
            (§ throw (§ new #_"HDDerivationException" (§ pars errorMessage)))
        )
        (§ void nil)
    )

    #_public
    #_static
    (§ class #_"RawKeyBytes"
        #_public
        #_final
        (§ field #_"byte[]" (§ name keyBytes))
        #_public
        #_final
        (§ field #_"byte[]" (§ name chainCode))

        #_public
        (§ constructor #_"RawKeyBytes" [#_"byte[]" (§ name keyBytes), #_"byte[]" (§ name chainCode)])
        (§ block
            (§ ass (§ name this.keyBytes) keyBytes)
            (§ ass (§ name this.chainCode) chainCode)
            (§ void this)
        )
    )
)

#_(ns org.bitcoinj.crypto #_"HDUtils"
    (:import [java.nio ByteBuffer]
             [java.util ArrayList Arrays Collections List])
    (:import [com.google.common.base Joiner]
             [com.google.common.collect ImmutableList Iterables]
             [org.spongycastle.crypto.digests SHA512Digest]
             [org.spongycastle.crypto.macs HMac]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core ECKey]))

;;;
 ; Static utilities used in BIP 32 Hierarchical Deterministic Wallets (HDW).
 ;;
#_public
#_final
(§ class #_"HDUtils"
    #_private
    #_static
    #_final
    (§ field #_"Joiner" (§ name PATH_JOINER) (§ expr Joiner/on(§ pars "/")))

    #_static
    (§ method #_"HMac" (§ fn createHmacSha512Digest) [#_"byte[]" (§ name key)])
    (§ block
        (§ var #_"SHA512Digest" (§ name digest) (§ new #_"SHA512Digest" (§ pars )))
        (§ var #_"HMac" (§ name hMac) (§ new #_"HMac" (§ pars digest)))
        (§ expr hMac.init(§ pars (§ new #_"KeyParameter" (§ pars key))))
        (§ return hMac)
    )

    #_static
    (§ method #_"byte[]" (§ fn hmacSha512) [#_"HMac" (§ name hmacSha512), #_"byte[]" (§ name input)])
    (§ block
        (§ expr hmacSha512.reset(§ pars ))
        (§ expr hmacSha512.update(§ pars input, 0, input.length))
        (§ var #_"byte[]" (§ name out) (§ new #_"byte[]" (§ count 64)))
        (§ expr hmacSha512.doFinal(§ pars out, 0))
        (§ return out)
    )

    #_public
    #_static
    (§ method #_"byte[]" (§ fn hmacSha512) [#_"byte[]" (§ name key), #_"byte[]" (§ name data)])
    (§ block
        (§ return (§ expr hmacSha512(§ pars createHmacSha512Digest(§ pars key), data)))
    )

    #_static
    (§ method #_"byte[]" (§ fn toCompressed) [#_"byte[]" (§ name uncompressedPoint)])
    (§ block
        (§ return (§ expr ECKey/CURVE.getCurve(§ pars ).decodePoint(§ pars uncompressedPoint).getEncoded(§ pars true)))
    )

    #_static
    (§ method #_"byte[]" (§ fn longTo4ByteArray) [#_"long" (§ name n)])
    (§ block
        (§ var #_"byte[]" (§ name bytes) (§ expr Arrays/copyOfRange(§ pars ByteBuffer/allocate(§ pars 8).putLong(§ pars n).array(§ pars ), 4, 8)))
        (§ assert (§ expr bytes.length == 4) :assert bytes.length)
        (§ return bytes)
    )

    ;;; Append a derivation level to an existing path. ;;
    #_public
    #_static
    (§ method #_"ImmutableList<ChildNumber>" (§ fn append) [#_"List<ChildNumber>" (§ name path), #_"ChildNumber" (§ name childNumber)])
    (§ block
        (§ return (§ expr ImmutableList.<ChildNumber>builder(§ pars ).addAll(§ pars path).add(§ pars childNumber).build(§ pars )))
    )

    ;;; Concatenate two derivation paths. ;;
    #_public
    #_static
    (§ method #_"ImmutableList<ChildNumber>" (§ fn concat) [#_"List<ChildNumber>" (§ name path), #_"List<ChildNumber>" (§ name path2)])
    (§ block
        (§ return (§ expr ImmutableList.<ChildNumber>builder(§ pars ).addAll(§ pars path).addAll(§ pars path2).build(§ pars )))
    )

    ;;; Convert to a string path, starting with "M/". ;;
    #_public
    #_static
    (§ method #_"String" (§ fn formatPath) [#_"List<ChildNumber>" (§ name path)])
    (§ block
        (§ return (§ expr PATH_JOINER.join(§ pars Iterables/concat(§ pars Collections/singleton(§ pars "M"), path))))
    )

    ;;;
     ; The path is a human-friendly representation of the deterministic path.  For example:
     ;
     ; "44H / 0H / 0H / 1 / 1"
     ;
     ; Where a letter "H" means hardened key.  Spaces are ignored.
     ;;
    #_public
    #_static
    (§ method #_"List<ChildNumber>" (§ fn parsePath) [#_non-nil #_"String" (§ name path)])
    (§ block
        (§ var #_"String[]" (§ name parsedNodes) (§ expr path.replace(§ pars "M", "").split(§ pars "/")))
        (§ var #_"List<ChildNumber>" (§ name nodes) (§ new #_"ArrayList<>" (§ pars )))

        (§ for (§ var #_"String" (§ name n)) :for parsedNodes)
        (§ block
            (§ ass (§ name n) (§ expr n.replaceAll(§ pars " ", "")))
            (§ if (§ expr n.length(§ pars ) != 0))
            (§ block
                (§ var #_"boolean" (§ name isHard) (§ expr n.endsWith(§ pars "H")))
                (§ if isHard)
                (§ block
                    (§ ass (§ name n) (§ expr n.substring(§ pars 0, n.length(§ pars ) - 1)))
                )
                (§ var #_"int" (§ name nodeNumber) (§ expr Integer/parseInt(§ pars n)))
                (§ expr nodes.add(§ pars (§ new #_"ChildNumber" (§ pars nodeNumber, isHard))))
            )
        )

        (§ return nodes)
    )
)

#_(ns org.bitcoinj.crypto #_"KeyCrypter"
    (:import [java.io Serializable])
    (:import [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.wallet.Protos.Wallet EncryptionType]))

;;;
 ; <p>A KeyCrypter can be used to encrypt and decrypt a message.  The sequence of events to encrypt and then decrypt
 ; a message are as follows:</p>
 ;
 ; <p>(1) Ask the user for a password.  deriveKey() is then called to create an KeyParameter.  This contains the AES
 ; key that will be used for encryption.</p>
 ; <p>(2) Encrypt the message using encrypt(), providing the message bytes and the KeyParameter from (1).  This returns
 ; an EncryptedData which contains the encryptedPrivateKey bytes and an initialisation vector.</p>
 ; <p>(3) To decrypt an EncryptedData, repeat step (1) to get a KeyParameter, then call decrypt().</p>
 ;
 ; <p>There can be different algorithms used for encryption/ decryption so the getUnderstoodEncryptionType is used
 ; to determine whether any given KeyCrypter can understand the type of encrypted data you have.</p>
 ;;
#_public
(§ interface #_"KeyCrypter" (§ extends #_"Serializable")
    ;;;
     ; Return the EncryptionType enum value which denotes the type of encryption/ decryption that this KeyCrypter
     ; can understand.
     ;;
    (§ method #_"EncryptionType" (§ fn getUnderstoodEncryptionType) [])

    ;;;
     ; Create a KeyParameter (which typically contains an AES key).
     ; @param password
     ; @return the KeyParameter which typically contains the AES key to use for encrypting and decrypting.
     ; @throws KeyCrypterException
     ;;
    (§ method #_"KeyParameter" (§ fn deriveKey) [#_"CharSequence" (§ name password)])
        (§ throws #_"KeyCrypterException")

    ;;;
     ; Decrypt the provided encrypted bytes, converting them into unencrypted bytes.
     ;
     ; @throws KeyCrypterException if decryption was unsuccessful.
     ;;
    (§ method #_"byte[]" (§ fn decrypt) [#_"EncryptedData" (§ name encryptedBytesToDecode), #_"KeyParameter" (§ name aesKey)])
        (§ throws #_"KeyCrypterException")

    ;;;
     ; Encrypt the supplied bytes, converting them into ciphertext.
     ;
     ; @return an encryptedPrivateKey containing the encrypted bytes and an initialisation vector.
     ; @throws KeyCrypterException if encryption was unsuccessful.
     ;;
    (§ method #_"EncryptedData" (§ fn encrypt) [#_"byte[]" (§ name plainBytes), #_"KeyParameter" (§ name aesKey)])
        (§ throws #_"KeyCrypterException")
)

#_(ns org.bitcoinj.crypto #_"KeyCrypterException")

;;;
 ; <p>Exception to provide the following:</p>
 ; <ul>
 ; <li>Provision of encryption / decryption exception.</li>
 ; </ul>
 ; <p>This base exception acts as a general failure mode not attributable to a specific cause (other than
 ; that reported in the exception message).  Since this is in English, it may not be worth reporting directly
 ; to the user other than as part of a "general failure to parse" response.</p>
 ;;
#_public
(§ class #_"KeyCrypterException" (§ extends #_"RuntimeException")
    #_public
    (§ constructor #_"KeyCrypterException" [#_"String" (§ name s)])
    (§ block
        (§ super (§ pars s))
        (§ void this)
    )

    #_public
    (§ constructor #_"KeyCrypterException" [#_"String" (§ name s), #_"Throwable" (§ name throwable)])
    (§ block
        (§ super (§ pars s, throwable))
        (§ void this)
    )
)

#_(ns org.bitcoinj.crypto #_"KeyCrypterScrypt"
    (:import [java.security SecureRandom]
             [java.util Arrays])
    (:import [com.google.common.base Objects Preconditions Stopwatch]
             [com.google.protobuf ByteString]
             [com.lambdaworks.crypto SCrypt]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto BufferedBlockCipher]
             [org.spongycastle.crypto.engines AESFastEngine]
             [org.spongycastle.crypto.modes CBCBlockCipher]
             [org.spongycastle.crypto.paddings PaddedBufferedBlockCipher]
             [org.spongycastle.crypto.params KeyParameter ParametersWithIV])
   (:require [org.bitcoinj.core Utils]
             [org.bitcoinj.wallet Protos]
             [org.bitcoinj.wallet.Protos ScryptParameters]
             [org.bitcoinj.wallet.Protos.Wallet EncryptionType]))

;;;
 ; <p>This class encrypts and decrypts byte arrays and strings using scrypt as the
 ; key derivation function and AES for the encryption.</p>
 ;
 ; <p>You can use this class to:</p>
 ;
 ; <p>1. Using a user password, create an AES key that can encrypt and decrypt your private keys.
 ; To convert the password to the AES key, scrypt is used.  This is an algorithm resistant
 ; to brute force attacks.  You can use the ScryptParameters to tune how difficult you
 ; want this to be generation to be.</p>
 ;
 ; <p>2. Using the AES Key generated above, you then can encrypt and decrypt any bytes using
 ; the AES symmetric cipher.  Eight bytes of salt is used to prevent dictionary attacks.</p>
 ;;
#_public
(§ class #_"KeyCrypterScrypt" (§ implements #_"KeyCrypter")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"KeyCrypterScrypt"))))

    ;;;
     ; Key length in bytes.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name KEY_LENGTH) 32) ;; = 256 bits.

    ;;;
     ; The size of an AES block in bytes.
     ; This is also the length of the initialisation vector.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name BLOCK_LENGTH) 16) ;; = 128 bits.

    ;;;
     ; The length of the salt used.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name SALT_LENGTH) 8)

    #_static
    (§ block
        ;; Init proper random number generator, as some old Android installations have bugs that make it unsecure.
        (§ if (§ expr Utils/isAndroidRuntime(§ pars )))
        (§ block
            (§ expr (§ new #_"LinuxSecureRandom" (§ pars )))
        )

        (§ ass (§ name secureRandom) (§ new #_"SecureRandom" (§ pars )))
    )

    #_private
    #_static
    #_final
    (§ field #_"SecureRandom" (§ name secureRandom))

    ;;; Returns SALT_LENGTH (8) bytes of random data. ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn randomSalt) [])
    (§ block
        (§ var #_"byte[]" (§ name salt) (§ new #_"byte[]" (§ count SALT_LENGTH)))
        (§ expr secureRandom.nextBytes(§ pars salt))
        (§ return salt)
    )

    ;; Scrypt parameters.
    #_private
    #_final
    (§ field #_"ScryptParameters" (§ name scryptParameters))

    ;;;
     ; Encryption/Decryption using default parameters and a random salt.
     ;;
    #_public
    (§ constructor #_"KeyCrypterScrypt" [])
    (§ block
        (§ var #_"Protos.ScryptParameters.Builder" (§ name builder) (§ expr Protos/ScryptParameters.newBuilder(§ pars ).setSalt(§ pars ByteString/copyFrom(§ pars randomSalt(§ pars )))))
        (§ ass (§ name this.scryptParameters) (§ expr builder.build(§ pars )))
        (§ void this)
    )

    ;;;
     ; Encryption/Decryption using custom number of iterations parameters and a random salt.
     ; As of August 2016, a useful value for mobile devices is 4096 (derivation takes about 1 second).
     ;
     ; @param iterations Number of scrypt iterations.
     ;;
    #_public
    (§ constructor #_"KeyCrypterScrypt" [#_"int" (§ name iterations)])
    (§ block
        (§ var #_"Protos.ScryptParameters.Builder" (§ name builder) (§ expr Protos/ScryptParameters.newBuilder(§ pars ).setSalt(§ pars ByteString/copyFrom(§ pars randomSalt(§ pars ))).setN(§ pars iterations)))
        (§ ass (§ name this.scryptParameters) (§ expr builder.build(§ pars )))
        (§ void this)
    )

    ;;;
     ; Encryption/ Decryption using specified Scrypt parameters.
     ;
     ; @param scryptParameters ScryptParameters to use.
     ; @throws NullPointerException if the scryptParameters or any of its N, R or P is null.
     ;;
    #_public
    (§ constructor #_"KeyCrypterScrypt" [#_"ScryptParameters" (§ name scryptParameters)])
    (§ block
        (§ ass (§ name this.scryptParameters) (§ expr Preconditions/checkNotNull(§ pars scryptParameters)))

        ;; Check there is a non-empty salt.  Some early MultiBit wallets has a missing salt, so it is not a hard fail.
        (§ if (§ expr scryptParameters.getSalt(§ pars ) == nil || scryptParameters.getSalt(§ pars ).toByteArray(§ pars ) == nil || scryptParameters.getSalt(§ pars ).toByteArray(§ pars ).length == 0))
        (§ block
            (§ expr log.warn(§ pars "You are using a ScryptParameters with no salt. Your encryption may be vulnerable to a dictionary attack."))
        )
        (§ void this)
    )

    ;;;
     ; Generate AES key.
     ;
     ; This is a very slow operation compared to encrypt/ decrypt so it is normally worth caching the result.
     ;
     ; @param password The password to use in key generation.
     ; @return the KeyParameter containing the created AES key.
     ; @throws KeyCrypterException
     ;;
    #_override
    #_public
    (§ method #_"KeyParameter" (§ fn deriveKey) [#_"CharSequence" (§ name password)])
        (§ throws #_"KeyCrypterException")
    (§ block
        (§ var #_"byte[]" (§ name passwordBytes) nil)
        (§ try )
        (§ block
            (§ ass (§ name passwordBytes) (§ expr convertToByteArray(§ pars password)))
            (§ var #_"byte[]" (§ name salt) (§ new #_"byte[]" (§ count 0)))
            (§ if (§ expr scryptParameters.getSalt(§ pars ) != nil))
            (§ block
                (§ ass (§ name salt) (§ expr scryptParameters.getSalt(§ pars ).toByteArray(§ pars )))
            )
            (§ else )
            (§ block
                ;; Warn the user that they are not using a salt.  Some early MultiBit wallets had a blank salt.
                (§ expr log.warn(§ pars "You are using a ScryptParameters with no salt. Your encryption may be vulnerable to a dictionary attack."))
            )

            #_final
            (§ var #_"Stopwatch" (§ name watch) (§ expr Stopwatch/createStarted(§ pars )))
            (§ var #_"byte[]" (§ name keyBytes) (§ expr SCrypt/scrypt(§ pars passwordBytes, salt, (§ cast #_"int" (§ expr scryptParameters.getN(§ pars ))), scryptParameters.getR(§ pars ), scryptParameters.getP(§ pars ), KEY_LENGTH)))
            (§ expr watch.stop(§ pars ))
            (§ expr log.info(§ pars "Deriving key took {} for {} scrypt iterations.", watch, scryptParameters.getN(§ pars )))
            (§ return (§ new #_"KeyParameter" (§ pars keyBytes)))
        )
        (§ catch #_"Exception" (§ name e))
        (§ block
            (§ throw (§ new #_"KeyCrypterException" (§ pars "Could not generate key from password and salt.", e)))
        )
        (§ finally )
        (§ block
            ;; Zero the password bytes.
            (§ if (§ expr passwordBytes != nil))
            (§ block
                (§ expr java.util.Arrays.fill(§ pars passwordBytes, (§ cast #_"byte" 0)))
            )
        )
    )

    ;;;
     ; Password based encryption using AES - CBC 256 bits.
     ;;
    #_override
    #_public
    (§ method #_"EncryptedData" (§ fn encrypt) [#_"byte[]" (§ name plainBytes), #_"KeyParameter" (§ name aesKey)])
        (§ throws #_"KeyCrypterException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars plainBytes))
        (§ expr Preconditions/checkNotNull(§ pars aesKey))

        (§ try )
        (§ block
            ;; Generate iv - each encryption call has a different iv.
            (§ var #_"byte[]" (§ name iv) (§ new #_"byte[]" (§ count BLOCK_LENGTH)))
            (§ expr secureRandom.nextBytes(§ pars iv))

            (§ var #_"ParametersWithIV" (§ name keyWithIv) (§ new #_"ParametersWithIV" (§ pars aesKey, iv)))

            ;; Encrypt using AES.
            (§ var #_"BufferedBlockCipher" (§ name cipher) (§ new #_"PaddedBufferedBlockCipher" (§ pars (§ new #_"CBCBlockCipher" (§ pars (§ new #_"AESFastEngine" (§ pars )))))))
            (§ expr cipher.init(§ pars true, keyWithIv))
            (§ var #_"byte[]" (§ name encryptedBytes) (§ new #_"byte[]" (§ count cipher.getOutputSize(§ pars plainBytes.length))))
            #_final
            (§ var #_"int" (§ name length1) (§ expr cipher.processBytes(§ pars plainBytes, 0, plainBytes.length, encryptedBytes, 0)))
            #_final
            (§ var #_"int" (§ name length2) (§ expr cipher.doFinal(§ pars encryptedBytes, length1)))

            (§ return (§ new #_"EncryptedData" (§ pars iv, Arrays/copyOf(§ pars encryptedBytes, length1 + length2))))
        )
        (§ catch #_"Exception" (§ name e))
        (§ block
            (§ throw (§ new #_"KeyCrypterException" (§ pars "Could not encrypt bytes.", e)))
        )
    )

    ;;;
     ; Decrypt bytes previously encrypted with this class.
     ;
     ; @param dataToDecrypt The data to decrypt.
     ; @param aesKey The AES key to use for decryption.
     ; @return the decrypted bytes.
     ; @throws KeyCrypterException if bytes could not be decrypted.
     ;;
    #_override
    #_public
    (§ method #_"byte[]" (§ fn decrypt) [#_"EncryptedData" (§ name dataToDecrypt), #_"KeyParameter" (§ name aesKey)])
        (§ throws #_"KeyCrypterException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars dataToDecrypt))
        (§ expr Preconditions/checkNotNull(§ pars aesKey))

        (§ try )
        (§ block
            (§ var #_"ParametersWithIV" (§ name keyWithIv) (§ new #_"ParametersWithIV" (§ pars (§ new #_"KeyParameter" (§ pars aesKey.getKey(§ pars ))), dataToDecrypt.initialisationVector)))

            ;; Decrypt the message.
            (§ var #_"BufferedBlockCipher" (§ name cipher) (§ new #_"PaddedBufferedBlockCipher" (§ pars (§ new #_"CBCBlockCipher" (§ pars (§ new #_"AESFastEngine" (§ pars )))))))
            (§ expr cipher.init(§ pars false, keyWithIv))

            (§ var #_"byte[]" (§ name cipherBytes) (§ expr dataToDecrypt.encryptedBytes))
            (§ var #_"byte[]" (§ name decryptedBytes) (§ new #_"byte[]" (§ count cipher.getOutputSize(§ pars cipherBytes.length))))
            #_final
            (§ var #_"int" (§ name length1) (§ expr cipher.processBytes(§ pars cipherBytes, 0, cipherBytes.length, decryptedBytes, 0)))
            #_final
            (§ var #_"int" (§ name length2) (§ expr cipher.doFinal(§ pars decryptedBytes, length1)))

            (§ return (§ expr Arrays/copyOf(§ pars decryptedBytes, length1 + length2)))
        )
        (§ catch #_"Exception" (§ name e))
        (§ block
            (§ throw (§ new #_"KeyCrypterException" (§ pars "Could not decrypt bytes", e)))
        )
    )

    ;;;
     ; Convert a CharSequence (which are UTF16) into a byte array.
     ;
     ; Note: a String.getBytes() is not used to avoid creating a String of the password in the JVM.
     ;;
    #_private
    #_static
    (§ method #_"byte[]" (§ fn convertToByteArray) [#_"CharSequence" (§ name charSequence)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars charSequence))

        (§ var #_"byte[]" (§ name byteArray) (§ new #_"byte[]" (§ count charSequence.length(§ pars ) << 1)))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < charSequence.length(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ var #_"int" (§ name bytePosition) (§ expr i << 1))
            (§ ass (§ name byteArray[bytePosition]) (§ cast #_"byte" (§ expr (§ expr charSequence.charAt(§ pars i) & 0xff00) >> 8)))
            (§ ass (§ name byteArray[bytePosition + 1]) (§ cast #_"byte" (§ expr charSequence.charAt(§ pars i) & 0x00ff)))
        )
        (§ return byteArray)
    )

    #_public
    (§ method #_"ScryptParameters" (§ fn getScryptParameters) [])
    (§ block
        (§ return scryptParameters)
    )

    ;;;
     ; Return the EncryptionType enum value which denotes the type of encryption/ decryption that this KeyCrypter
     ; can understand.
     ;;
    #_override
    #_public
    (§ method #_"EncryptionType" (§ fn getUnderstoodEncryptionType) [])
    (§ block
        (§ return (§ expr EncryptionType/ENCRYPTED_SCRYPT_AES))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr "AES-" + KEY_LENGTH * 8 + "-CBC, Scrypt (N: " + scryptParameters.getN(§ pars ) + ")"))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars scryptParameters)))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return (§ expr Objects/equal(§ pars scryptParameters, (§ expr (§ cast #_"KeyCrypterScrypt" o)).scryptParameters)))
    )
)

#_(ns org.bitcoinj.crypto #_"LazyECPoint"
    (:import [java.math BigInteger]
             [java.util Arrays])
    (:import [com.google.common.base Preconditions]
             [org.spongycastle.math.ec ECCurve ECFieldElement ECPoint]))

;;;
 ; A wrapper around ECPoint that delays decoding of the point for as long as possible.  This is useful because point
 ; encode/decode in Bouncy Castle is quite slow especially on Dalvik, as it often involves decompression/recompression.
 ;;
#_public
(§ class #_"LazyECPoint"
    ;; If curve is set, bits is also set.  If curve is unset, point is set and bits is unset.  Point can be set along
    ;; with curve and bits when the cached form has been accessed and thus must have been converted.
    #_private
    #_final
    (§ field #_"ECCurve" (§ name curve))
    #_private
    #_final
    (§ field #_"byte[]" (§ name bits))

    ;; This field is effectively final - once set it won't change again.  However it can be set after construction.
    #_nilable
    #_private
    (§ field #_"ECPoint" (§ name point))

    #_public
    (§ constructor #_"LazyECPoint" [#_"ECCurve" (§ name curve), #_"byte[]" (§ name bits)])
    (§ block
        (§ ass (§ name this.curve) curve)
        (§ ass (§ name this.bits) bits)
        (§ void this)
    )

    #_public
    (§ constructor #_"LazyECPoint" [#_"ECPoint" (§ name point)])
    (§ block
        (§ ass (§ name this.point) (§ expr Preconditions/checkNotNull(§ pars point)))
        (§ ass (§ name this.curve) nil)
        (§ ass (§ name this.bits) nil)
        (§ void this)
    )

    #_public
    (§ method #_"ECPoint" (§ fn get) [])
    (§ block
        (§ if (§ expr point == nil))
        (§ block
            (§ ass (§ name point) (§ expr curve.decodePoint(§ pars bits)))
        )
        (§ return point)
    )

    ;; Delegated methods.

    #_public
    (§ method #_"ECPoint" (§ fn getDetachedPoint) [])
    (§ block
        (§ return (§ expr get(§ pars ).getDetachedPoint(§ pars )))
    )

    #_public
    (§ method #_"byte[]" (§ fn getEncoded) [])
    (§ block
        (§ if (§ expr bits != nil))
        (§ block
            (§ return (§ expr Arrays/copyOf(§ pars bits, bits.length)))
        )
        (§ else )
        (§ block
            (§ return (§ expr get(§ pars ).getEncoded(§ pars )))
        )
    )

    #_public
    (§ method #_"boolean" (§ fn isInfinity) [])
    (§ block
        (§ return (§ expr get(§ pars ).isInfinity(§ pars )))
    )

    #_public
    (§ method #_"ECPoint" (§ fn timesPow2) [#_"int" (§ name e)])
    (§ block
        (§ return (§ expr get(§ pars ).timesPow2(§ pars e)))
    )

    #_public
    (§ method #_"ECFieldElement" (§ fn getYCoord) [])
    (§ block
        (§ return (§ expr get(§ pars ).getYCoord(§ pars )))
    )

    #_public
    (§ method #_"ECFieldElement[]" (§ fn getZCoords) [])
    (§ block
        (§ return (§ expr get(§ pars ).getZCoords(§ pars )))
    )

    #_public
    (§ method #_"boolean" (§ fn isNormalized) [])
    (§ block
        (§ return (§ expr get(§ pars ).isNormalized(§ pars )))
    )

    #_public
    (§ method #_"boolean" (§ fn isCompressed) [])
    (§ block
        (§ if (§ expr bits != nil))
        (§ block
            (§ return (§ expr bits[0] == 2 || bits[0] == 3))
        )
        (§ else )
        (§ block
            (§ return (§ expr get(§ pars ).isCompressed(§ pars )))
        )
    )

    #_public
    (§ method #_"ECPoint" (§ fn multiply) [#_"BigInteger" (§ name k)])
    (§ block
        (§ return (§ expr get(§ pars ).multiply(§ pars k)))
    )

    #_public
    (§ method #_"ECPoint" (§ fn subtract) [#_"ECPoint" (§ name b)])
    (§ block
        (§ return (§ expr get(§ pars ).subtract(§ pars b)))
    )

    #_public
    (§ method #_"boolean" (§ fn isValid) [])
    (§ block
        (§ return (§ expr get(§ pars ).isValid(§ pars )))
    )

    #_public
    (§ method #_"ECPoint" (§ fn scaleY) [#_"ECFieldElement" (§ name scale)])
    (§ block
        (§ return (§ expr get(§ pars ).scaleY(§ pars scale)))
    )

    #_public
    (§ method #_"ECFieldElement" (§ fn getXCoord) [])
    (§ block
        (§ return (§ expr get(§ pars ).getXCoord(§ pars )))
    )

    #_public
    (§ method #_"ECPoint" (§ fn scaleX) [#_"ECFieldElement" (§ name scale)])
    (§ block
        (§ return (§ expr get(§ pars ).scaleX(§ pars scale)))
    )

    #_public
    (§ method #_"boolean" (§ fn equals) [#_"ECPoint" (§ name other)])
    (§ block
        (§ return (§ expr get(§ pars ).equals(§ pars other)))
    )

    #_public
    (§ method #_"ECPoint" (§ fn negate) [])
    (§ block
        (§ return (§ expr get(§ pars ).negate(§ pars )))
    )

    #_public
    (§ method #_"ECPoint" (§ fn threeTimes) [])
    (§ block
        (§ return (§ expr get(§ pars ).threeTimes(§ pars )))
    )

    #_public
    (§ method #_"ECFieldElement" (§ fn getZCoord) [#_"int" (§ name index)])
    (§ block
        (§ return (§ expr get(§ pars ).getZCoord(§ pars index)))
    )

    #_public
    (§ method #_"byte[]" (§ fn getEncoded) [#_"boolean" (§ name compressed)])
    (§ block
        (§ if (§ expr compressed == isCompressed(§ pars ) && bits != nil))
        (§ block
            (§ return (§ expr Arrays/copyOf(§ pars bits, bits.length)))
        )
        (§ else )
        (§ block
            (§ return (§ expr get(§ pars ).getEncoded(§ pars compressed)))
        )
    )

    #_public
    (§ method #_"ECPoint" (§ fn add) [#_"ECPoint" (§ name b)])
    (§ block
        (§ return (§ expr get(§ pars ).add(§ pars b)))
    )

    #_public
    (§ method #_"ECPoint" (§ fn twicePlus) [#_"ECPoint" (§ name b)])
    (§ block
        (§ return (§ expr get(§ pars ).twicePlus(§ pars b)))
    )

    #_public
    (§ method #_"ECCurve" (§ fn getCurve) [])
    (§ block
        (§ return (§ expr get(§ pars ).getCurve(§ pars )))
    )

    #_public
    (§ method #_"ECPoint" (§ fn normalize) [])
    (§ block
        (§ return (§ expr get(§ pars ).normalize(§ pars )))
    )

    #_public
    (§ method #_"ECFieldElement" (§ fn getY) [])
    (§ block
        (§ return (§ expr this.normalize(§ pars ).getYCoord(§ pars )))
    )

    #_public
    (§ method #_"ECPoint" (§ fn twice) [])
    (§ block
        (§ return (§ expr get(§ pars ).twice(§ pars )))
    )

    #_public
    (§ method #_"ECFieldElement" (§ fn getAffineYCoord) [])
    (§ block
        (§ return (§ expr get(§ pars ).getAffineYCoord(§ pars )))
    )

    #_public
    (§ method #_"ECFieldElement" (§ fn getAffineXCoord) [])
    (§ block
        (§ return (§ expr get(§ pars ).getAffineXCoord(§ pars )))
    )

    #_public
    (§ method #_"ECFieldElement" (§ fn getX) [])
    (§ block
        (§ return (§ expr this.normalize(§ pars ).getXCoord(§ pars )))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return (§ expr Arrays/equals(§ pars getCanonicalEncoding(§ pars ), (§ expr (§ cast #_"LazyECPoint" o)).getCanonicalEncoding(§ pars ))))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Arrays/hashCode(§ pars getCanonicalEncoding(§ pars ))))
    )

    #_private
    (§ method #_"byte[]" (§ fn getCanonicalEncoding) [])
    (§ block
        (§ return (§ expr getEncoded(§ pars true)))
    )
)

#_(ns org.bitcoinj.crypto #_"LinuxSecureRandom"
    (:import [java.io *]
             [java.security *])
    (:import [org.slf4j *]))

;;;
 ; A SecureRandom implementation that is able to override the standard JVM provided implementation, and which simply
 ; serves random numbers by reading /dev/urandom.  That is, it delegates to the kernel on UNIX systems and is unusable
 ; on other platforms.  Attempts to manually set the seed are ignored.  There is no difference between seed bytes and
 ; non-seed bytes, they are all from the same source.
 ;;
#_public
(§ class #_"LinuxSecureRandom" (§ extends #_"SecureRandomSpi")
    #_private
    #_static
    #_final
    (§ field #_"FileInputStream" (§ name urandom))

    #_private
    #_static
    (§ class #_"LinuxSecureRandomProvider" (§ extends #_"Provider")
        #_public
        (§ constructor #_"LinuxSecureRandomProvider" [])
        (§ block
            (§ super (§ pars "LinuxSecureRandom", 1.0, "A Linux specific random number provider that uses /dev/urandom"))

            (§ expr put(§ pars "SecureRandom.LinuxSecureRandom", (§ klass #_"LinuxSecureRandom").getName(§ pars )))
            (§ void this)
        )
    )

    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"LinuxSecureRandom"))))

    #_static
    (§ block
        (§ try )
        (§ block
            (§ var #_"File" (§ name file) (§ new #_"File" (§ pars "/dev/urandom")))
            ;; This stream is deliberately leaked.
            (§ ass (§ name urandom) (§ new #_"FileInputStream" (§ pars file)))
            (§ if (§ expr urandom.read(§ pars ) == -1))
            (§ block
                (§ throw (§ new #_"RuntimeException" (§ pars "/dev/urandom not readable?")))
            )

            ;; Now override the default SecureRandom implementation with this one.
            (§ var #_"int" (§ name position) (§ expr Security/insertProviderAt(§ pars (§ new #_"LinuxSecureRandomProvider" (§ pars )), 1)))

            (§ if (§ expr position != -1))
            (§ block
                (§ expr log.info(§ pars "Secure randomness will be read from {} only.", file))
            )
            (§ else )
            (§ block
                (§ expr log.info(§ pars "Randomness is already secure."))
            )
        )
        (§ catch #_"FileNotFoundException" (§ name e))
        (§ block
            ;; Should never happen.
            (§ expr log.error(§ pars "/dev/urandom does not appear to exist or is not openable"))
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ expr log.error(§ pars "/dev/urandom does not appear to be readable"))
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
    )

    #_private
    #_final
    (§ field #_"DataInputStream" (§ name dis))

    #_public
    (§ constructor #_"LinuxSecureRandom" [])
    (§ block
        ;; DataInputStream is not thread safe, so each random object has its own.
        (§ ass (§ name dis) (§ new #_"DataInputStream" (§ pars urandom)))
        (§ void this)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn engineSetSeed) [#_"byte[]" (§ name bytes)])
    (§ block
        ;; Ignore.
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn engineNextBytes) [#_"byte[]" (§ name bytes)])
    (§ block
        (§ try )
        (§ block
            (§ expr dis.readFully(§ pars bytes)) ;; This will block until all the bytes can be read.
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Fatal error.  Do not attempt to recover from this.
        )
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"byte[]" (§ fn engineGenerateSeed) [#_"int" (§ name i)])
    (§ block
        (§ var #_"byte[]" (§ name bits) (§ new #_"byte[]" (§ count i)))
        (§ expr engineNextBytes(§ pars bits))
        (§ return bits)
    )
)

#_(ns org.bitcoinj.crypto #_"MnemonicCode"
    (:import [java.io BufferedReader FileNotFoundException IOException InputStream InputStreamReader]
             [java.security MessageDigest]
             [java.util ArrayList Collections List])
    (:import [com.google.common.base Stopwatch]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core Sha256Hash Utils]
             #_static [org.bitcoinj.core.Utils HEX]))

;;;
 ; A MnemonicCode object may be used to convert between binary seed values and lists of words per
 ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">the BIP 39 specification</a>.
 ;;

#_public
(§ class #_"MnemonicCode"
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"MnemonicCode"))))

    #_private
    (§ field #_"ArrayList<String>" (§ name wordList))

    #_private
    #_static
    #_final
    (§ field #_"String" (§ name BIP39_ENGLISH_RESOURCE_NAME) (§ expr "mnemonic/wordlist/english.txt"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name BIP39_ENGLISH_SHA256) (§ expr "ad90bf3beb7b0eb7e5acd74727dc0da96e0a280a258354e7293fb7e211ac03db"))

    ;;; UNIX time for when the BIP39 standard was finalised.  This can be used as a default seed birthday. ;;
    #_public
    #_static
    (§ field #_"long" (§ name BIP39_STANDARDISATION_TIME_SECS) 1381276800)

    #_private
    #_static
    #_final
    (§ field #_"int" (§ name PBKDF2_ROUNDS) 2048)

    #_public
    #_static
    (§ field #_"MnemonicCode" (§ name INSTANCE))

    #_static
    (§ block
        (§ try )
        (§ block
            (§ ass (§ name INSTANCE) (§ new #_"MnemonicCode" (§ pars )))
        )
        (§ catch #_"FileNotFoundException" (§ name e))
        (§ block
            ;; We expect failure on Android.  The developer has to set INSTANCE themselves.
            (§ if (§ expr (§ not Utils/isAndroidRuntime(§ pars ))))
            (§ block
                (§ expr log.error(§ pars "Could not find word list", e))
            )
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ expr log.error(§ pars "Failed to load word list", e))
        )
    )

    ;;; Initialise from the included word list.  Won't work on Android. ;;
    #_public
    (§ constructor #_"MnemonicCode" [])
        (§ throws #_"IOException")
    (§ block
        (§ this (§ pars openDefaultWords(§ pars ), BIP39_ENGLISH_SHA256))
        (§ void this)
    )

    #_private
    #_static
    (§ method #_"InputStream" (§ fn openDefaultWords) [])
        (§ throws #_"IOException")
    (§ block
        (§ var #_"InputStream" (§ name stream) (§ dot (§ klass #_"MnemonicCode").getResourceAsStream(§ pars BIP39_ENGLISH_RESOURCE_NAME)))
        (§ if (§ expr stream == nil))
        (§ block
            (§ throw (§ new #_"FileNotFoundException" (§ pars BIP39_ENGLISH_RESOURCE_NAME)))
        )
        (§ return stream)
    )

    ;;;
     ; Creates an MnemonicCode object, initializing with words read from the supplied input stream.
     ; If a wordListDigest is supplied, the digest of the words will be checked.
     ;;
    #_public
    (§ constructor #_"MnemonicCode" [#_"InputStream" (§ name wordstream), #_"String" (§ name wordListDigest)])
        (§ throws #_"IOException", #_"IllegalArgumentException")
    (§ block
        (§ var #_"BufferedReader" (§ name br) (§ new #_"BufferedReader" (§ pars (§ new #_"InputStreamReader" (§ pars wordstream, "UTF-8")))))
        (§ ass (§ name this.wordList) (§ new #_"ArrayList<>" (§ pars 2048)))
        (§ var #_"MessageDigest" (§ name md) (§ expr Sha256Hash/newDigest(§ pars )))
        (§ var #_"String" (§ name word))
        (§ while (§ expr (§ ass (§ name word) (§ expr br.readLine(§ pars ))) != nil))
        (§ block
            (§ expr md.update(§ pars word.getBytes(§ pars )))
            (§ expr this.wordList.add(§ pars word))
        )
        (§ expr br.close(§ pars ))

        (§ if (§ expr this.wordList.size(§ pars ) != 2048))
        (§ block
            (§ throw (§ new #_"IllegalArgumentException" (§ pars "input stream did not contain 2048 words")))
        )

        ;; If a wordListDigest is supplied, check to make sure it matches.
        (§ if (§ expr wordListDigest != nil))
        (§ block
            (§ var #_"byte[]" (§ name digest) (§ expr md.digest(§ pars )))
            (§ var #_"String" (§ name hexdigest) (§ expr HEX.encode(§ pars digest)))
            (§ if (§ expr (§ not hexdigest.equals(§ pars wordListDigest))))
            (§ block
                (§ throw (§ new #_"IllegalArgumentException" (§ pars "wordlist digest mismatch")))
            )
        )
        (§ void this)
    )

    ;;;
     ; Gets the word list this code uses.
     ;;
    #_public
    (§ method #_"List<String>" (§ fn getWordList) [])
    (§ block
        (§ return wordList)
    )

    ;;;
     ; Convert mnemonic word list to seed.
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn toSeed) [#_"List<String>" (§ name words), #_"String" (§ name passphrase)])
    (§ block
        ;; To create binary seed from mnemonic, we use PBKDF2 function with mnemonic sentence (in UTF-8) used as a password
        ;; and string "mnemonic" + passphrase (again in UTF-8) used as a salt.  Iteration count is set to 4096 and HMAC-SHA512
        ;; is used as a pseudo-random function.  Desired length of the derived key is 512 bits (= 64 bytes).

        (§ var #_"String" (§ name pass) (§ expr Utils/SPACE_JOINER.join(§ pars words)))
        (§ var #_"String" (§ name salt) (§ expr "mnemonic" + passphrase))

        #_final
        (§ var #_"Stopwatch" (§ name watch) (§ expr Stopwatch/createStarted(§ pars )))
        (§ var #_"byte[]" (§ name seed) (§ expr PBKDF2SHA512/derive(§ pars pass, salt, PBKDF2_ROUNDS, 64)))
        (§ expr watch.stop(§ pars ))
        (§ expr log.info(§ pars "PBKDF2 took {}", watch))
        (§ return seed)
    )

    ;;;
     ; Convert mnemonic word list to original entropy value.
     ;;
    #_public
    (§ method #_"byte[]" (§ fn toEntropy) [#_"List<String>" (§ name words)])
        (§ throws #_"MnemonicException.MnemonicLengthException", #_"MnemonicException.MnemonicWordException", #_"MnemonicException.MnemonicChecksumException")
    (§ block
        (§ if (§ expr 0 < words.size(§ pars ) % 3))
        (§ block
            (§ throw (§ new #_"MnemonicException.MnemonicLengthException" (§ pars "Word list size must be multiple of three words.")))
        )

        (§ if (§ expr words.size(§ pars ) == 0))
        (§ block
            (§ throw (§ new #_"MnemonicException.MnemonicLengthException" (§ pars "Word list is empty.")))
        )

        ;; Look up all the words in the list and construct the concatenation of the original entropy and the checksum.

        (§ var #_"int" (§ name concatLenBits) (§ expr words.size(§ pars ) * 11))
        (§ var #_"boolean[]" (§ name concatBits) (§ new #_"boolean[]" (§ count concatLenBits)))
        (§ var #_"int" (§ name wordindex) 0)
        (§ for (§ var #_"String" (§ name word)) :for words)
        (§ block
            ;; Find the words index in the wordlist.
            (§ var #_"int" (§ name ndx) (§ expr Collections/binarySearch(§ pars this.wordList, word)))
            (§ if (§ expr ndx < 0))
            (§ block
                (§ throw (§ new #_"MnemonicException.MnemonicWordException" (§ pars word)))
            )

            ;; Set the next 11 bits to the value of the index.
            (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < 11) :for (§ ass (§ name i) (§ expr i + 1)))
            (§ block
                (§ ass (§ name concatBits[(§ expr wordindex * 11) + i]) (§ expr (§ expr ndx & (§ expr 1 << (§ expr 10 - i))) != 0))
            )
            (§ ass (§ name wordindex) (§ expr wordindex + 1))
        )

        (§ var #_"int" (§ name checksumLengthBits) (§ expr concatLenBits / 33))
        (§ var #_"int" (§ name entropyLengthBits) (§ expr concatLenBits - checksumLengthBits))

        ;; Extract original entropy as bytes.
        (§ var #_"byte[]" (§ name entropy) (§ new #_"byte[]" (§ count entropyLengthBits / 8)))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < entropy.length) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ for (§ var #_"int" (§ name j) 0) :for (§ expr j < 8) :for (§ ass (§ name j) (§ expr j + 1)))
            (§ block
                (§ if (§ expr concatBits[(§ expr i * 8) + j]))
                (§ block
                    (§ ass (§ name entropy[i]) (§ expr entropy[i] | (§ expr 1 << (§ expr 7 - j))))
                )
            )
        )

        ;; Take the digest of the entropy.
        (§ var #_"byte[]" (§ name hash) (§ expr Sha256Hash/hash(§ pars entropy)))
        (§ var #_"boolean[]" (§ name hashBits) (§ expr bytesToBits(§ pars hash)))

        ;; Check all the checksum bits.
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < checksumLengthBits) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ if (§ expr concatBits[entropyLengthBits + i] != hashBits[i]))
            (§ block
                (§ throw (§ new #_"MnemonicException.MnemonicChecksumException" (§ pars )))
            )
        )

        (§ return entropy)
    )

    ;;;
     ; Convert entropy data to mnemonic word list.
     ;;
    #_public
    (§ method #_"List<String>" (§ fn toMnemonic) [#_"byte[]" (§ name entropy)])
        (§ throws #_"MnemonicException.MnemonicLengthException")
    (§ block
        (§ if (§ expr 0 < entropy.length % 4))
        (§ block
            (§ throw (§ new #_"MnemonicException.MnemonicLengthException" (§ pars "Entropy length not multiple of 32 bits.")))
        )

        (§ if (§ expr entropy.length == 0))
        (§ block
            (§ throw (§ new #_"MnemonicException.MnemonicLengthException" (§ pars "Entropy is empty.")))
        )

        ;; We take initial entropy of ENT bits and compute its checksum by taking first ENT / 32 bits of its SHA256 hash.

        (§ var #_"byte[]" (§ name hash) (§ expr Sha256Hash/hash(§ pars entropy)))
        (§ var #_"boolean[]" (§ name hashBits) (§ expr bytesToBits(§ pars hash)))

        (§ var #_"boolean[]" (§ name entropyBits) (§ expr bytesToBits(§ pars entropy)))
        (§ var #_"int" (§ name checksumLengthBits) (§ expr entropyBits.length / 32))

        ;; We append these bits to the end of the initial entropy.
        (§ var #_"boolean[]" (§ name concatBits) (§ new #_"boolean[]" (§ count entropyBits.length + checksumLengthBits)))
        (§ expr System/arraycopy(§ pars entropyBits, 0, concatBits, 0, entropyBits.length))
        (§ expr System/arraycopy(§ pars hashBits, 0, concatBits, entropyBits.length, checksumLengthBits))

        ;; Next we take these concatenated bits and split them into groups of 11 bits.  Each group encodes number from 0-2047
        ;; which is a position in a wordlist.  We convert numbers into words and use joined words as mnemonic sentence.

        (§ var #_"ArrayList<String>" (§ name words) (§ new #_"ArrayList<>" (§ pars )))
        (§ var #_"int" (§ name nwords) (§ expr concatBits.length / 11))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < nwords) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ var #_"int" (§ name index) 0)
            (§ for (§ var #_"int" (§ name j) 0) :for (§ expr j < 11) :for (§ ass (§ name j) (§ expr j + 1)))
            (§ block
                (§ ass (§ name index) (§ expr index << 1))
                (§ if (§ expr concatBits[(§ expr i * 11) + j]))
                (§ block
                    (§ ass (§ name index) (§ expr index | 0x1))
                )
            )
            (§ expr words.add(§ pars this.wordList.get(§ pars index)))
        )

        (§ return words)
    )

    ;;;
     ; Check to see if a mnemonic word list is valid.
     ;;
    #_public
    (§ method #_"void" (§ fn check) [#_"List<String>" (§ name words)])
        (§ throws #_"MnemonicException")
    (§ block
        (§ expr toEntropy(§ pars words))
        (§ void nil)
    )

    #_private
    #_static
    (§ method #_"boolean[]" (§ fn bytesToBits) [#_"byte[]" (§ name data)])
    (§ block
        (§ var #_"boolean[]" (§ name bits) (§ new #_"boolean[]" (§ count data.length * 8)))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < data.length) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ for (§ var #_"int" (§ name j) 0) :for (§ expr j < 8) :for (§ ass (§ name j) (§ expr j + 1)))
            (§ block
                (§ ass (§ name bits[(§ expr i * 8) + j]) (§ expr (§ expr data[i] & (§ expr 1 << (§ expr 7 - j))) != 0))
            )
        )
        (§ return bits)
    )
)

#_(ns org.bitcoinj.crypto #_"MnemonicException")

;;;
 ; Exceptions thrown by the MnemonicCode module.
 ;;
#_public
(§ class #_"MnemonicException" (§ extends #_"Exception")
    #_public
    (§ constructor #_"MnemonicException" [])
    (§ block
        (§ super (§ pars ))
        (§ void this)
    )

    #_public
    (§ constructor #_"MnemonicException" [#_"String" (§ name msg)])
    (§ block
        (§ super (§ pars msg))
        (§ void this)
    )

    ;;;
     ; Thrown when an argument to MnemonicCode is the wrong length.
     ;;
    #_public
    #_static
    (§ class #_"MnemonicLengthException" (§ extends #_"MnemonicException")
        #_public
        (§ constructor #_"MnemonicLengthException" [#_"String" (§ name msg)])
        (§ block
            (§ super (§ pars msg))
            (§ void this)
        )
    )

    ;;;
     ; Thrown when a list of MnemonicCode words fails the checksum check.
     ;;
    #_public
    #_static
    (§ class #_"MnemonicChecksumException" (§ extends #_"MnemonicException")
        #_public
        (§ constructor #_"MnemonicChecksumException" [])
        (§ block
            (§ super (§ pars ))
            (§ void this)
        )
    )

    ;;;
     ; Thrown when a word is encountered which is not in the MnemonicCode's word list.
     ;;
    #_public
    #_static
    (§ class #_"MnemonicWordException" (§ extends #_"MnemonicException")
        ;;; Contains the word that was not found in the word list. ;;
        #_public
        #_final
        (§ field #_"String" (§ name badWord))

        #_public
        (§ constructor #_"MnemonicWordException" [#_"String" (§ name badWord)])
        (§ block
            (§ super (§ pars ))
            (§ ass (§ name this.badWord) badWord)
            (§ void this)
        )
    )
)

#_(ns org.bitcoinj.crypto #_"PBKDF2SHA512"
    (:import [java.io ByteArrayOutputStream]
             [java.nio ByteBuffer ByteOrder]
             [javax.crypto Mac]
             [javax.crypto.spec SecretKeySpec]))

;;;
 ; <p>This is a clean-room implementation of PBKDF2 using RFC 2898 as a reference.</p>
 ;
 ; <p>RFC 2898: http://tools.ietf.org/html/rfc2898#section-5.2</p>
 ;
 ; <p>This code passes all RFC 6070 test vectors: http://tools.ietf.org/html/rfc6070</p>
 ;
 ; <p>http://cryptofreek.org/2012/11/29/pbkdf2-pure-java-implementation/<br>
 ; Modified to use SHA-512 - Ken Sedgwick ken@bonsai.com</p>
 ;;
#_public
(§ class #_"PBKDF2SHA512"
    #_public
    #_static
    (§ method #_"byte[]" (§ fn derive) [#_"String" (§ name P), #_"String" (§ name S), #_"int" (§ name c), #_"int" (§ name dkLen)])
    (§ block
        (§ var #_"ByteArrayOutputStream" (§ name baos) (§ new #_"ByteArrayOutputStream" (§ pars )))

        (§ try )
        (§ block
            (§ var #_"int" (§ name hLen) 20)

            (§ if (§ expr (§ expr (§ expr Math/pow(§ pars 2, 32)) - 1) * hLen < dkLen))
            (§ block
                (§ throw (§ new #_"IllegalArgumentException" (§ pars "derived key too long")))
            )

            (§ var #_"int" (§ name l) (§ expr (§ cast #_"int" (§ expr Math/ceil(§ pars (§ cast #_"double" dkLen) / (§ cast #_"double" hLen))))))
         ;; int r = dkLen - (l - 1) * hLen;

            (§ for (§ var #_"int" (§ name i) 1) :for (§ expr i <= l) :for (§ ass (§ name i) (§ expr i + 1)))
            (§ block
                (§ var #_"byte[]" (§ name T) (§ expr F(§ pars P, S, c, i)))
                (§ expr baos.write(§ pars T))
            )
        )
        (§ catch #_"Exception" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )

        (§ var #_"byte[]" (§ name baDerived) (§ new #_"byte[]" (§ count dkLen)))
        (§ expr System/arraycopy(§ pars baos.toByteArray(§ pars ), 0, baDerived, 0, baDerived.length))

        (§ return baDerived)
    )

    #_private
    #_static
    (§ method #_"byte[]" (§ fn F) [#_"String" (§ name P), #_"String" (§ name S), #_"int" (§ name c), #_"int" (§ name i)])
        (§ throws #_"Exception")
    (§ block
        (§ var #_"byte[]" (§ name U_LAST) nil)
        (§ var #_"byte[]" (§ name U_XOR) nil)

        (§ var #_"SecretKeySpec" (§ name key) (§ new #_"SecretKeySpec" (§ pars P.getBytes(§ pars "UTF-8"), "HmacSHA512")))
        (§ var #_"Mac" (§ name mac) (§ expr Mac/getInstance(§ pars key.getAlgorithm(§ pars ))))
        (§ expr mac.init(§ pars key))

        (§ for (§ var #_"int" (§ name j) 0) :for (§ expr j < c) :for (§ ass (§ name j) (§ expr j + 1)))
        (§ block
            (§ if (§ expr j == 0))
            (§ block
                (§ var #_"byte[]" (§ name baS) (§ expr S.getBytes(§ pars "UTF-8")))
                (§ var #_"byte[]" (§ name baI) (§ expr INT(§ pars i)))
                (§ var #_"byte[]" (§ name baU) (§ new #_"byte[]" (§ count baS.length + baI.length)))

                (§ expr System/arraycopy(§ pars baS, 0, baU, 0, baS.length))
                (§ expr System/arraycopy(§ pars baI, 0, baU, baS.length, baI.length))

                (§ ass (§ name U_XOR) (§ expr mac.doFinal(§ pars baU)))
                (§ ass (§ name U_LAST) (§ expr U_XOR))
                (§ expr mac.reset(§ pars ))
            )
            (§ else )
            (§ block
                (§ var #_"byte[]" (§ name baU) (§ expr mac.doFinal(§ pars U_LAST)))
                (§ expr mac.reset(§ pars ))

                (§ for (§ var #_"int" (§ name k) 0) :for (§ expr k < U_XOR.length) :for (§ ass (§ name k) (§ expr k + 1)))
                (§ block
                    (§ ass (§ name U_XOR[k]) (§ cast #_"byte" (§ expr U_XOR[k] :xor baU[k])))
                )

                (§ ass (§ name U_LAST) baU)
            )
        )

        (§ return (§ expr U_XOR))
    )

    #_private
    #_static
    (§ method #_"byte[]" (§ fn INT) [#_"int" (§ name i)])
    (§ block
        (§ var #_"ByteBuffer" (§ name bb) (§ expr ByteBuffer/allocate(§ pars 4)))
        (§ expr bb.order(§ pars ByteOrder/BIG_ENDIAN))
        (§ expr bb.putInt(§ pars i))

        (§ return (§ expr bb.array(§ pars )))
    )
)

#_(ns org.bitcoinj.crypto #_"TransactionSignature"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.math BigInteger])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.core ECKey Transaction VerificationException]
             [org.bitcoinj.core.Transaction SigHash]))

;;;
 ; A TransactionSignature wraps an {@link org.bitcoinj.core.ECKey.ECDSASignature} and adds methods for handling
 ; the additional SIGHASH mode byte that is used.
 ;;
#_public
(§ class #_"TransactionSignature" (§ extends #_"ECKey.ECDSASignature")
    ;;;
     ; A byte that controls which parts of a transaction are signed.  This is exposed because signatures
     ; parsed off the wire may have sighash flags that aren't "normal" serializations of the enum values.
     ; Because Bitcoin Core works via bit testing, we must not lose the exact value when round-tripping
     ; otherwise we'll fail to verify signature hashes.
     ;;
    #_public
    #_final
    (§ field #_"int" (§ name sighashFlags))

    ;;; Constructs a signature with the given components and SIGHASH_ALL. ;;
    #_public
    (§ constructor #_"TransactionSignature" [#_"BigInteger" (§ name r), #_"BigInteger" (§ name s)])
    (§ block
        (§ this (§ pars r, s, Transaction/SigHash/ALL.value))
        (§ void this)
    )

    ;;; Constructs a signature with the given components and raw sighash flag bytes (needed for rule compatibility). ;;
    #_public
    (§ constructor #_"TransactionSignature" [#_"BigInteger" (§ name r), #_"BigInteger" (§ name s), #_"int" (§ name sighashFlags)])
    (§ block
        (§ super (§ pars r, s))
        (§ ass (§ name this.sighashFlags) sighashFlags)
        (§ void this)
    )

    ;;; Constructs a transaction signature based on the ECDSA signature. ;;
    #_public
    (§ constructor #_"TransactionSignature" [#_"ECKey.ECDSASignature" (§ name signature), #_"Transaction.SigHash" (§ name mode), #_"boolean" (§ name anyoneCanPay)])
    (§ block
        (§ super (§ pars signature.r, signature.s))
        (§ ass (§ name sighashFlags) (§ expr calcSigHashValue(§ pars mode, anyoneCanPay)))
        (§ void this)
    )

    ;;;
     ; Returns a dummy invalid signature whose R/S values are set such that they will take up the same number of
     ; encoded bytes as a real signature.  This can be useful when you want to fill out a transaction to be of
     ; the right size (e.g. for fee calculations) but don't have the requisite signing key yet and will fill out
     ; the real signature later.
     ;;
    #_public
    #_static
    (§ method #_"TransactionSignature" (§ fn dummy) [])
    (§ block
        (§ var #_"BigInteger" (§ name val) (§ expr ECKey/HALF_CURVE_ORDER))
        (§ return (§ new #_"TransactionSignature" (§ pars val, val)))
    )

    ;;; Calculates the byte used in the protocol to represent the combination of mode and anyoneCanPay. ;;
    #_public
    #_static
    (§ method #_"int" (§ fn calcSigHashValue) [#_"Transaction.SigHash" (§ name mode), #_"boolean" (§ name anyoneCanPay)])
    (§ block
        ;; Enforce compatibility since this code was made before the SigHash enum was updated.
        (§ expr Preconditions/checkArgument(§ pars SigHash/ALL == mode || SigHash/NONE == mode || SigHash/SINGLE == mode))

        (§ var #_"int" (§ name sighashFlags) (§ expr mode.value))
        (§ if anyoneCanPay)
        (§ block
            (§ ass (§ name sighashFlags) (§ expr sighashFlags | Transaction/SigHash/ANYONECANPAY.value))
        )
        (§ return sighashFlags)
    )

    ;;;
     ; Returns true if the given signature is has canonical encoding, and will thus be accepted as standard by
     ; Bitcoin Core.  DER and the SIGHASH encoding allow for quite some flexibility in how the same structures
     ; are encoded, and this can open up novel attacks in which a man in the middle takes a transaction and then
     ; changes its signature such that the transaction hash is different but it's still valid.  This can confuse
     ; wallets and generally violates people's mental model of how Bitcoin should work, thus non-canonical
     ; signatures are now not relayed by default.
     ;;
    #_public
    #_static
    (§ method #_"boolean" (§ fn isEncodingCanonical) [#_"byte[]" (§ name signature)])
    (§ block
        ;; See Bitcoin Core's IsCanonicalSignature, https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623
        ;; A canonical signature exists of: <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>
        ;; Where R and S are not negative (their first byte has its highest bit not set), and not
        ;; excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,
        ;; in which case a single 0 byte is necessary and even required).
        (§ if (§ expr signature.length < 9 || 73 < signature.length))
        (§ block
            (§ return false)
        )

        (§ var #_"int" (§ name hashType) (§ expr (§ expr signature[signature.length-1] & 0xff) & (§ expr (§ flip Transaction/SigHash/ANYONECANPAY.value)))) ;; mask the byte to prevent sign-extension hurting us
        (§ if (§ expr hashType < Transaction/SigHash/ALL.value || Transaction/SigHash/SINGLE.value < hashType))
        (§ block
            (§ return false)
        )

        ;;                   "wrong type"                  "wrong length marker"
        (§ if (§ expr (§ expr signature[0] & 0xff) != 0x30 || (§ expr signature[1] & 0xff) != signature.length - 3))
        (§ block
            (§ return false)
        )

        (§ var #_"int" (§ name lenR) (§ expr signature[3] & 0xff))
        (§ if (§ expr signature.length <= 5 + lenR || lenR == 0))
        (§ block
            (§ return false)
        )
        (§ var #_"int" (§ name lenS) (§ expr signature[5 + lenR] & 0xff))
        (§ if (§ expr lenR + lenS + 7 != signature.length || lenS == 0))
        (§ block
            (§ return false)
        )

        ;;    R value type mismatch          R value negative
        (§ if (§ expr signature[4 - 2] != 0x02 || (§ expr signature[4] & 0x80) == 0x80))
        (§ block
            (§ return false)
        )
        (§ if (§ expr 1 < lenR && signature[4] == 0x00 && (§ expr signature[4 + 1] & 0x80) != 0x80))
        (§ block
            (§ return false) ;; R value excessively padded
        )

        ;;       S value type mismatch                    S value negative
        (§ if (§ expr signature[6 + lenR - 2] != 0x02 || (§ expr signature[6 + lenR] & 0x80) == 0x80))
        (§ block
            (§ return false)
        )
        (§ if (§ expr 1 < lenS && signature[6 + lenR] == 0x00 && (§ expr signature[6 + lenR + 1] & 0x80) != 0x80))
        (§ block
            (§ return false) ;; S value excessively padded
        )

        (§ return true)
    )

    #_public
    (§ method #_"boolean" (§ fn anyoneCanPay) [])
    (§ block
        (§ return (§ expr (§ expr sighashFlags & Transaction/SigHash/ANYONECANPAY.value) != 0))
    )

    #_public
    (§ method #_"Transaction.SigHash" (§ fn sigHashMode) [])
    (§ block
        #_final
        (§ var #_"int" (§ name mode) (§ expr sighashFlags & 0x1f))

        (§ if (§ expr mode == Transaction/SigHash/NONE.value))
        (§ block
            (§ return (§ expr Transaction/SigHash/NONE))
        )
        (§ if (§ expr mode == Transaction/SigHash/SINGLE.value))
        (§ block
            (§ return (§ expr Transaction/SigHash/SINGLE))
        )

        (§ return (§ expr Transaction/SigHash/ALL))
    )

    ;;;
     ; What we get back from the signer are the two components of a signature, r and s.  To get a flat byte stream
     ; of the type used by Bitcoin we have to encode them using DER encoding, which is just a way to pack the two
     ; components into a structure, and then we append a byte to the end for the sighash flags.
     ;;
    #_public
    (§ method #_"byte[]" (§ fn encodeToBitcoin) [])
    (§ block
        (§ try )
        (§ block
            (§ var #_"ByteArrayOutputStream" (§ name bos) (§ expr derByteStream(§ pars )))
            (§ expr bos.write(§ pars sighashFlags))
            (§ return (§ expr bos.toByteArray(§ pars )))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
    )

    #_override
    #_public
    (§ method #_"ECKey.ECDSASignature" (§ fn toCanonicalised) [])
    (§ block
        (§ return (§ new #_"TransactionSignature" (§ pars super.toCanonicalised(§ pars ), sigHashMode(§ pars ), anyoneCanPay(§ pars ))))
    )

    ;;;
     ; Returns a decoded signature.
     ;
     ; @param requireCanonicalEncoding if the encoding of the signature must be canonical.
     ; @throws RuntimeException if the signature is invalid or unparseable in some way.
     ; @deprecated use {@link #decodeFromBitcoin(byte[], boolean, boolean)} instead.
     ;;
    #_deprecated
    #_public
    #_static
    (§ method #_"TransactionSignature" (§ fn decodeFromBitcoin) [#_"byte[]" (§ name bytes), #_"boolean" (§ name requireCanonicalEncoding)])
        (§ throws #_"VerificationException")
    (§ block
        (§ return (§ expr decodeFromBitcoin(§ pars bytes, requireCanonicalEncoding, false)))
    )

    ;;;
     ; Returns a decoded signature.
     ;
     ; @param requireCanonicalEncoding if the encoding of the signature must be canonical.
     ; @param requireCanonicalSValue if the S-value must be canonical (below half the order of the curve).
     ; @throws RuntimeException if the signature is invalid or unparseable in some way.
     ;;
    #_public
    #_static
    (§ method #_"TransactionSignature" (§ fn decodeFromBitcoin) [#_"byte[]" (§ name bytes), #_"boolean" (§ name requireCanonicalEncoding), #_"boolean" (§ name requireCanonicalSValue)])
        (§ throws #_"VerificationException")
    (§ block
        ;; Bitcoin encoding is DER signature + sighash byte.
        (§ if (§ expr requireCanonicalEncoding && (§ not isEncodingCanonical(§ pars bytes))))
        (§ block
            (§ throw (§ new #_"VerificationException" (§ pars "Signature encoding is not canonical.")))
        )

        (§ var #_"ECKey.ECDSASignature" (§ name sig))
        (§ try )
        (§ block
            (§ ass (§ name sig) (§ expr ECKey/ECDSASignature.decodeFromDER(§ pars bytes)))
        )
        (§ catch #_"IllegalArgumentException" (§ name e))
        (§ block
            (§ throw (§ new #_"VerificationException" (§ pars "Could not decode DER", e)))
        )
        (§ if (§ expr requireCanonicalSValue && (§ not sig.isCanonical(§ pars ))))
        (§ block
            (§ throw (§ new #_"VerificationException" (§ pars "S-value is not canonical.")))
        )

        ;; In Bitcoin, any value of the final byte is valid, but not necessarily canonical.  See javadocs
        ;; for isEncodingCanonical to learn more about this.  So we must store the exact byte found.
        (§ return (§ new #_"TransactionSignature" (§ pars sig.r, sig.s, bytes[bytes.length - 1])))
    )
)

#_(ns org.bitcoinj.kits #_"WalletAppKit"
    (:import [java.io *]
             [java.net *]
             [java.nio.channels *]
             [java.util *]
             [java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect *]
             [com.google.common.util.concurrent *]
             [org.slf4j *])
   (:require [org.bitcoinj.core.listeners *]
             [org.bitcoinj.core *]
             [org.bitcoinj.net.discovery *]
             [org.bitcoinj.store *]
             [org.bitcoinj.wallet *]))

;;;
 ; <p>Utility class that wraps the boilerplate needed to set up a new SPV bitcoinj app.  Instantiate it with a directory
 ; and file prefix, optionally configure a few things, then use startAsync and optionally awaitRunning.  The object will
 ; construct and configure a {@link BlockChain}, {@link SPVBlockStore}, {@link Wallet} and {@link PeerGroup}.  Depending
 ; on the value of the blockingStartup property, startup will be considered complete once the block chain has fully
 ; synchronized, so it can take a while.</p>
 ;
 ; <p>To add listeners and modify the objects that are constructed, you can either do that by overriding the
 ; {@link #onSetupCompleted()} method (which will run on a background thread) and make your changes there,
 ; or by waiting for the service to start and then accessing the objects from wherever you want.  However, you cannot
 ; access the objects this class creates until startup is complete.</p>
 ;
 ; <p>The asynchronous design of this class may seem puzzling (just use {@link #awaitRunning()} if you don't want that).
 ; It is to make it easier to fit bitcoinj into GUI apps, which require a high degree of responsiveness on their main
 ; thread which handles all the animation and user interaction.  Even when blockingStart is false, initializing bitcoinj
 ; means doing potentially blocking file IO, generating keys and other potentially intensive operations.  By running it
 ; on a background thread, there's no risk of accidentally causing UI lag.</p>
 ;
 ; <p>Note that {@link #awaitRunning()} can throw an unchecked {@link java.lang.IllegalStateException}
 ; if anything goes wrong during startup - you should probably handle it and use {@link Exception#getCause()} to figure
 ; out what went wrong more precisely.  Same thing if you just use the {@link #startAsync()} method.</p>
 ;;
#_public
(§ class #_"WalletAppKit" (§ extends #_"AbstractIdleService")
    #_protected
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"WalletAppKit"))))

    #_protected
    #_final
    (§ field #_"String" (§ name filePrefix))
    #_protected
    #_final
    (§ field #_"NetworkParameters" (§ name params))
    #_protected
    #_volatile
    (§ field #_"BlockChain" (§ name vChain))
    #_protected
    #_volatile
    (§ field #_"BlockStore" (§ name vStore))
    #_protected
    #_volatile
    (§ field #_"Wallet" (§ name vWallet))
    #_protected
    #_volatile
    (§ field #_"PeerGroup" (§ name vPeerGroup))

    #_protected
    #_final
    (§ field #_"File" (§ name directory))
    #_protected
    #_volatile
    (§ field #_"File" (§ name vWalletFile))

    #_protected
    (§ field #_"boolean" (§ name useAutoSave) true)
    #_protected
    (§ field #_"PeerAddress[]" (§ name peerAddresses))
    #_protected
    (§ field #_"DownloadProgressTracker" (§ name downloadListener))
    #_protected
    (§ field #_"boolean" (§ name autoStop) true)
    #_protected
    (§ field #_"InputStream" (§ name checkpoints))
    #_protected
    (§ field #_"boolean" (§ name blockingStartup) true)
    #_protected
    (§ field #_"String" (§ name userAgent))
    #_protected
    (§ field #_"String" (§ name version))
    #_protected
    (§ field #_"WalletProtobufSerializer.WalletFactory" (§ name walletFactory))
    #_nilable
    #_protected
    (§ field #_"DeterministicSeed" (§ name restoreFromSeed))
    #_nilable
    #_protected
    (§ field #_"PeerDiscovery" (§ name discovery))

    #_protected
    #_volatile
    (§ field #_"Context" (§ name context))

    ;;;
     ; Creates a new WalletAppKit, with a newly created {@link Context}.  Files will be stored in the given directory.
     ;;
    #_public
    (§ constructor #_"WalletAppKit" [#_"NetworkParameters" (§ name params), #_"File" (§ name directory), #_"String" (§ name filePrefix)])
    (§ block
        (§ this (§ pars (§ new #_"Context" (§ pars params)), directory, filePrefix))
        (§ void this)
    )

    ;;;
     ; Creates a new WalletAppKit, with the given {@link Context}.  Files will be stored in the given directory.
     ;;
    #_public
    (§ constructor #_"WalletAppKit" [#_"Context" (§ name context), #_"File" (§ name directory), #_"String" (§ name filePrefix)])
    (§ block
        (§ ass (§ name this.context) context)
        (§ ass (§ name this.params) (§ expr Preconditions/checkNotNull(§ pars context.getParams(§ pars ))))
        (§ ass (§ name this.directory) (§ expr Preconditions/checkNotNull(§ pars directory)))
        (§ ass (§ name this.filePrefix) (§ expr Preconditions/checkNotNull(§ pars filePrefix)))
        (§ void this)
    )

    ;;; Will only connect to the given addresses.  Cannot be called after startup. ;;
    #_public
    (§ method #_"WalletAppKit" (§ fn setPeerNodes) [#_"PeerAddress..." (§ name addresses)])
    (§ block
        (§ expr Preconditions/checkState(§ pars state(§ pars ) == State/NEW, "Cannot call after startup"))
        (§ ass (§ name this.peerAddresses) addresses)
        (§ return this)
    )

    ;;; Will only connect to localhost.  Cannot be called after startup. ;;
    #_public
    (§ method #_"WalletAppKit" (§ fn connectToLocalHost) [])
    (§ block
        (§ try )
        (§ block
            #_final
            (§ var #_"InetAddress" (§ name localHost) (§ expr InetAddress/getLocalHost(§ pars )))
            (§ return (§ expr setPeerNodes(§ pars (§ new #_"PeerAddress" (§ pars params, localHost, params.getPort(§ pars ))))))
        )
        (§ catch #_"UnknownHostException" (§ name e))
        (§ block
            ;; Borked machine with no loopback adapter configured properly.
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
    )

    ;;; If true, the wallet will save itself to disk automatically whenever it changes. ;;
    #_public
    (§ method #_"WalletAppKit" (§ fn setAutoSave) [#_"boolean" (§ name value)])
    (§ block
        (§ expr Preconditions/checkState(§ pars state(§ pars ) == State/NEW, "Cannot call after startup"))
        (§ ass (§ name useAutoSave) value)
        (§ return this)
    )

    ;;;
     ; If you want to learn about the sync process, you can provide a listener here.  For instance,
     ; a {@link org.bitcoinj.core.DownloadProgressTracker} is a good choice.  This has no effect unless
     ; setBlockingStartup(false) has been called too, due to some missing implementation code.
     ;;
    #_public
    (§ method #_"WalletAppKit" (§ fn setDownloadListener) [#_"DownloadProgressTracker" (§ name listener)])
    (§ block
        (§ ass (§ name this.downloadListener) listener)
        (§ return this)
    )

    ;;; If true, will register a shutdown hook to stop the library.  Defaults to true. ;;
    #_public
    (§ method #_"WalletAppKit" (§ fn setAutoStop) [#_"boolean" (§ name autoStop)])
    (§ block
        (§ ass (§ name this.autoStop) autoStop)
        (§ return this)
    )

    ;;;
     ; If set, the file is expected to contain a checkpoints file calculated with BuildCheckpoints.
     ; It makes initial block sync faster for new users - please refer to the documentation on the
     ; bitcoinj website (https://bitcoinj.github.io/speeding-up-chain-sync) for further details.
     ;;
    #_public
    (§ method #_"WalletAppKit" (§ fn setCheckpoints) [#_"InputStream" (§ name checkpoints)])
    (§ block
        (§ if (§ expr this.checkpoints != nil))
        (§ block
            (§ expr Utils/closeUnchecked(§ pars this.checkpoints))
        )
        (§ ass (§ name this.checkpoints) (§ expr Preconditions/checkNotNull(§ pars checkpoints)))
        (§ return this)
    )

    ;;;
     ; If true (the default) then the startup of this service won't be considered complete until the network has been
     ; brought up, peer connections established and the block chain synchronised.  Therefore {@link #awaitRunning()} can
     ; potentially take a very long time.  If false, then startup is considered complete once the network activity
     ; begins and peer connections/block chain sync will continue in the background.
     ;;
    #_public
    (§ method #_"WalletAppKit" (§ fn setBlockingStartup) [#_"boolean" (§ name blockingStartup)])
    (§ block
        (§ ass (§ name this.blockingStartup) blockingStartup)
        (§ return this)
    )

    ;;;
     ; Sets the string that will appear in the subver field of the version message.
     ; @param userAgent A short string that should be the name of your app, e.g. "My Wallet".
     ; @param version A short string that contains the version number, e.g. "1.0-BETA".
     ;;
    #_public
    (§ method #_"WalletAppKit" (§ fn setUserAgent) [#_"String" (§ name userAgent), #_"String" (§ name version)])
    (§ block
        (§ ass (§ name this.userAgent) (§ expr Preconditions/checkNotNull(§ pars userAgent)))
        (§ ass (§ name this.version) (§ expr Preconditions/checkNotNull(§ pars version)))
        (§ return this)
    )

    ;;;
     ; Sets a wallet factory which will be used when the kit creates a new wallet.
     ;;
    #_public
    (§ method #_"WalletAppKit" (§ fn setWalletFactory) [#_"WalletProtobufSerializer.WalletFactory" (§ name walletFactory)])
    (§ block
        (§ ass (§ name this.walletFactory) walletFactory)
        (§ return this)
    )

    ;;;
     ; If a seed is set here then any existing wallet that matches the file name will be renamed to a backup name,
     ; the chain file will be deleted, and the wallet object will be instantiated with the given seed instead of
     ; a fresh one being created.  This is intended for restoring a wallet from the original seed.  To implement
     ; restore, you would shut down the existing appkit, if any, then recreate it with the seed given by the user,
     ; then start up the new kit.  The next time your app starts it should work as normal (that is, don't keep
     ; calling this each time).
     ;;
    #_public
    (§ method #_"WalletAppKit" (§ fn restoreWalletFromSeed) [#_"DeterministicSeed" (§ name seed)])
    (§ block
        (§ ass (§ name this.restoreFromSeed) seed)
        (§ return this)
    )

    ;;;
     ; Sets the peer discovery class to use.  If none is provided then DNS is used, which is a reasonable default.
     ;;
    #_public
    (§ method #_"WalletAppKit" (§ fn setDiscovery) [#_nilable #_"PeerDiscovery" (§ name discovery)])
    (§ block
        (§ ass (§ name this.discovery) discovery)
        (§ return this)
    )

    ;;;
     ; Override this to use a {@link BlockStore} that isn't the default of {@link SPVBlockStore}.
     ;;
    #_protected
    (§ method #_"BlockStore" (§ fn provideBlockStore) [#_"File" (§ name file)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ return (§ new #_"SPVBlockStore" (§ pars params, file)))
    )

    ;;;
     ; This method is invoked on a background thread after all objects are initialised, but before the peer group
     ; or block chain download is started.  You can tweak the objects configuration here.
     ;;
    #_protected
    (§ method #_"void" (§ fn onSetupCompleted) [])
    (§ block
        (§ void nil)
    )

    ;;;
     ; Tests to see if the spvchain file has an operating system file lock on it.  Useful for checking if your app
     ; is already running.  If another copy of your app is running and you start the appkit anyway, an exception will
     ; be thrown during the startup process.  Returns false if the chain file does not exist or is a directory.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isChainFileLocked) [])
        (§ throws #_"IOException")
    (§ block
        (§ var #_"RandomAccessFile" (§ name file2) nil)
        (§ try )
        (§ block
            (§ var #_"File" (§ name file) (§ new #_"File" (§ pars directory, filePrefix + ".spvchain")))
            (§ if (§ expr (§ not file.exists(§ pars ))))
            (§ block
                (§ return false)
            )
            (§ if (§ expr file.isDirectory(§ pars )))
            (§ block
                (§ return false)
            )
            (§ ass (§ name file2) (§ new #_"RandomAccessFile" (§ pars file, "rw")))
            (§ var #_"FileLock" (§ name lock) (§ expr file2.getChannel(§ pars ).tryLock(§ pars )))
            (§ if (§ expr lock == nil))
            (§ block
                (§ return true)
            )
            (§ expr lock.release(§ pars ))
            (§ return false)
        )
        (§ finally )
        (§ block
            (§ if (§ expr file2 != nil))
            (§ block
                (§ expr file2.close(§ pars ))
            )
        )
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn startUp) [])
        (§ throws #_"Exception")
    (§ block
        ;; Runs in a separate thread.
        (§ expr Context/propagate(§ pars context))
        (§ if (§ expr (§ not directory.exists(§ pars )) && (§ not directory.mkdirs(§ pars ))))
        (§ block
            (§ throw (§ new #_"IOException" (§ pars "Could not create directory " + directory.getAbsolutePath(§ pars ))))
        )

        (§ expr log.info(§ pars "Starting up with directory = {}", directory))
        (§ try )
        (§ block
            (§ var #_"File" (§ name chainFile) (§ new #_"File" (§ pars directory, filePrefix + ".spvchain")))
            (§ var #_"boolean" (§ name chainFileExists) (§ expr chainFile.exists(§ pars )))
            (§ ass (§ name vWalletFile) (§ new #_"File" (§ pars directory, filePrefix + ".wallet")))
            (§ var #_"boolean" (§ name shouldReplayWallet) (§ expr (§ expr vWalletFile.exists(§ pars ) && (§ not chainFileExists)) || restoreFromSeed != nil))
            (§ ass (§ name vWallet) (§ expr createOrLoadWallet(§ pars shouldReplayWallet)))

            ;; Initiate Bitcoin network objects (block store, blockchain and peer group).
            (§ ass (§ name vStore) (§ expr provideBlockStore(§ pars chainFile)))
            (§ if (§ expr (§ not chainFileExists) || restoreFromSeed != nil))
            (§ block
                (§ if (§ expr checkpoints == nil && (§ not Utils/isAndroidRuntime(§ pars ))))
                (§ block
                    (§ ass (§ name checkpoints) (§ expr CheckpointManager/openStream(§ pars params)))
                )

                (§ if (§ expr checkpoints != nil))
                (§ block
                    ;; Initialize the chain file with a checkpoint to speed up first-run sync.
                    (§ var #_"long" (§ name time))
                    (§ if (§ expr restoreFromSeed != nil))
                    (§ block
                        (§ ass (§ name time) (§ expr restoreFromSeed.getCreationTimeSeconds(§ pars )))
                        (§ if chainFileExists)
                        (§ block
                            (§ expr log.info(§ pars "Deleting the chain file in preparation from restore."))
                            (§ expr vStore.close(§ pars ))
                            (§ if (§ expr (§ not chainFile.delete(§ pars ))))
                            (§ block
                                (§ throw (§ new #_"IOException" (§ pars "Failed to delete chain file in preparation for restore.")))
                            )

                            (§ ass (§ name vStore) (§ new #_"SPVBlockStore" (§ pars params, chainFile)))
                        )
                    )
                    (§ else )
                    (§ block
                        (§ ass (§ name time) (§ expr vWallet.getEarliestKeyCreationTime(§ pars )))
                    )
                    (§ if (§ expr 0 < time))
                    (§ block
                        (§ expr CheckpointManager/checkpoint(§ pars params, checkpoints, vStore, time))
                    )
                    (§ else )
                    (§ block
                        (§ expr log.warn(§ pars "Creating a new uncheckpointed block store due to a wallet with a creation time of zero: this will result in a very slow chain sync"))
                    )
                )
                (§ elseif chainFileExists)
                (§ block
                    (§ expr log.info(§ pars "Deleting the chain file in preparation from restore."))
                    (§ expr vStore.close(§ pars ))
                    (§ if (§ expr (§ not chainFile.delete(§ pars ))))
                    (§ block
                        (§ throw (§ new #_"IOException" (§ pars "Failed to delete chain file in preparation for restore.")))
                    )

                    (§ ass (§ name vStore) (§ new #_"SPVBlockStore" (§ pars params, chainFile)))
                )
            )
            (§ ass (§ name vChain) (§ new #_"BlockChain" (§ pars params, vStore)))
            (§ ass (§ name vPeerGroup) (§ expr createPeerGroup(§ pars )))
            (§ if (§ expr this.userAgent != nil))
            (§ block
                (§ expr vPeerGroup.setUserAgent(§ pars userAgent, version))
            )

            ;; Set up peer addresses or discovery first, so if wallet extensions try to broadcast a transaction
            ;; before we're actually connected the broadcast waits for an appropriate number of connections.
            (§ if (§ expr peerAddresses != nil))
            (§ block
                (§ for (§ var #_"PeerAddress" (§ name addr)) :for peerAddresses)
                (§ block
                    (§ expr vPeerGroup.addAddress(§ pars addr))
                )
                (§ expr vPeerGroup.setMaxConnections(§ pars peerAddresses.length))
                (§ ass (§ name peerAddresses) nil)
            )
            (§ else )
            (§ block
                (§ expr vPeerGroup.addPeerDiscovery(§ pars (§ quest (§ expr discovery != nil) ? discovery :else (§ new #_"DnsDiscovery" (§ pars params)))))
            )
            (§ expr vChain.addWallet(§ pars vWallet))
            (§ expr vPeerGroup.addWallet(§ pars vWallet))
            (§ expr onSetupCompleted(§ pars ))

            (§ if blockingStartup)
            (§ block
                (§ expr vPeerGroup.start(§ pars ))
                ;; Make sure we shut down cleanly.
                (§ expr installShutdownHook(§ pars ))

                ;; TODO: Be able to use the provided download listener when doing a blocking startup.
                #_final
                (§ var #_"DownloadProgressTracker" (§ name listener) (§ new #_"DownloadProgressTracker" (§ pars )))
                (§ expr vPeerGroup.startBlockChainDownload(§ pars listener))
                (§ expr listener.await(§ pars ))
            )
            (§ else )
            (§ block
                (§ expr Futures/addCallback(§ pars vPeerGroup.startAsync(§ pars ), new FutureCallback(§ pars )
                (§ anon
                    #_override
                    #_public
                    (§ method #_"void" (§ fn onSuccess) [#_nilable #_"Object" (§ name result)])
                    (§ block
                        #_final
                        (§ var #_"DownloadProgressTracker" (§ name l) (§ quest (§ expr downloadListener != nil) ? downloadListener :else (§ new #_"DownloadProgressTracker" (§ pars ))))
                        (§ expr vPeerGroup.startBlockChainDownload(§ pars l))
                        (§ void nil)
                    )

                    #_override
                    #_public
                    (§ method #_"void" (§ fn onFailure) [#_"Throwable" (§ name t)])
                    (§ block
                        (§ throw (§ new #_"RuntimeException" (§ pars t)))
                        (§ void nil)
                    )
                )))
            )
        )
        (§ catch #_"BlockStoreException" (§ name e))
        (§ block
            (§ throw (§ new #_"IOException" (§ pars e)))
        )
        (§ void nil)
    )

    #_private
    (§ method #_"Wallet" (§ fn createOrLoadWallet) [#_"boolean" (§ name shouldReplayWallet)])
        (§ throws #_"Exception")
    (§ block
        (§ var #_"Wallet" (§ name wallet))

        (§ expr maybeMoveOldWalletOutOfTheWay(§ pars ))

        (§ if (§ expr vWalletFile.exists(§ pars )))
        (§ block
            (§ ass (§ name wallet) (§ expr loadWallet(§ pars shouldReplayWallet)))
        )
        (§ else )
        (§ block
            (§ ass (§ name wallet) (§ expr createWallet(§ pars )))
            (§ expr wallet.freshReceiveKey(§ pars ))

            ;; Currently the only way we can be sure that an extension is aware of its containing wallet is
            ;; by deserializing the extension.
            ;; Hence, we first save and then load wallet to ensure any extensions are correctly initialized.
            (§ expr wallet.saveToFile(§ pars vWalletFile))
            (§ ass (§ name wallet) (§ expr loadWallet(§ pars false)))
        )

        (§ if useAutoSave)
        (§ block
            (§ expr this.setupAutoSave(§ pars wallet))
        )

        (§ return wallet)
    )

    #_protected
    (§ method #_"void" (§ fn setupAutoSave) [#_"Wallet" (§ name wallet)])
    (§ block
        (§ expr wallet.autosaveToFile(§ pars vWalletFile, 5, TimeUnit/SECONDS, nil))
        (§ void nil)
    )

    #_private
    (§ method #_"Wallet" (§ fn loadWallet) [#_"boolean" (§ name shouldReplayWallet)])
        (§ throws #_"Exception")
    (§ block
        (§ var #_"Wallet" (§ name wallet))
        (§ var #_"FileInputStream" (§ name walletStream) (§ new #_"FileInputStream" (§ pars vWalletFile)))
        (§ try )
        (§ block
            (§ var #_"Protos.Wallet" (§ name proto) (§ expr WalletProtobufSerializer/parseToProto(§ pars walletStream)))
            #_final
            (§ var #_"WalletProtobufSerializer" (§ name serializer))
            (§ if (§ expr walletFactory != nil))
            (§ block
                (§ ass (§ name serializer) (§ new #_"WalletProtobufSerializer" (§ pars walletFactory)))
            )
            (§ else )
            (§ block
                (§ ass (§ name serializer) (§ new #_"WalletProtobufSerializer" (§ pars )))
            )
            (§ ass (§ name wallet) (§ expr serializer.readWallet(§ pars params, proto)))
            (§ if shouldReplayWallet)
            (§ block
                (§ expr wallet.reset(§ pars ))
            )
        )
        (§ finally )
        (§ block
            (§ expr walletStream.close(§ pars ))
        )
        (§ return wallet)
    )

    #_protected
    (§ method #_"Wallet" (§ fn createWallet) [])
    (§ block
        (§ var #_"KeyChainGroup" (§ name kcg))
        (§ if (§ expr restoreFromSeed != nil))
        (§ block
            (§ ass (§ name kcg) (§ new #_"KeyChainGroup" (§ pars params, restoreFromSeed)))
        )
        (§ else )
        (§ block
            (§ ass (§ name kcg) (§ new #_"KeyChainGroup" (§ pars params)))
        )
        (§ return (§ quest (§ expr walletFactory != nil) ? (§ expr walletFactory.create(§ pars params, kcg)) :else (§ new #_"Wallet" (§ pars params, kcg)))) ;; default
    )

    #_private
    (§ method #_"void" (§ fn maybeMoveOldWalletOutOfTheWay) [])
    (§ block
        (§ if (§ expr restoreFromSeed == nil))
        (§ block
            (§ return nil)
        )
        (§ if (§ expr (§ not vWalletFile.exists(§ pars ))))
        (§ block
            (§ return nil)
        )

        (§ var #_"int" (§ name counter) 1)
        (§ var #_"File" (§ name newName))
        (§ do )
        (§ block
            (§ ass (§ name newName) (§ new #_"File" (§ pars vWalletFile.getParent(§ pars ), "Backup " + counter + " for " + vWalletFile.getName(§ pars ))))
            (§ ass (§ name counter) (§ expr counter + 1))
        )
        (§ again (§ expr newName.exists(§ pars )))

        (§ expr log.info(§ pars "Renaming old wallet file {} to {}", vWalletFile, newName))

        ;; This should not happen unless something is really messed up.
        (§ if (§ expr (§ not vWalletFile.renameTo(§ pars newName))))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars "Failed to rename wallet for restore")))
        )
        (§ void nil)
    )

    #_protected
    (§ method #_"PeerGroup" (§ fn createPeerGroup) [])
        (§ throws #_"TimeoutException")
    (§ block
        (§ return (§ new #_"PeerGroup" (§ pars params, vChain)))
    )

    #_private
    (§ method #_"void" (§ fn installShutdownHook) [])
    (§ block
        (§ if autoStop)
        (§ block
            (§ expr Runtime/getRuntime(§ pars ).addShutdownHook(§ pars (§ new #_"Thread" (§ pars ))
            (§ anon
                #_override
                #_public
                (§ method #_"void" (§ fn run) [])
                (§ block
                    (§ try )
                    (§ block
                        (§ expr WalletAppKit.this.stopAsync(§ pars ))
                        (§ expr WalletAppKit.this.awaitTerminated(§ pars ))
                    )
                    (§ catch #_"Exception" (§ name e))
                    (§ block
                        (§ throw (§ new #_"RuntimeException" (§ pars e)))
                    )
                    (§ void nil)
                )
            )))
        )
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn shutDown) [])
        (§ throws #_"Exception")
    (§ block
        ;; Runs in a separate thread.
        (§ try )
        (§ block
            (§ expr Context/propagate(§ pars context))
            (§ expr vPeerGroup.stop(§ pars ))
            (§ expr vWallet.saveToFile(§ pars vWalletFile))
            (§ expr vStore.close(§ pars ))

            (§ ass (§ name vPeerGroup) nil)
            (§ ass (§ name vWallet) nil)
            (§ ass (§ name vStore) nil)
            (§ ass (§ name vChain) nil)
        )
        (§ catch #_"BlockStoreException" (§ name e))
        (§ block
            (§ throw (§ new #_"IOException" (§ pars e)))
        )
        (§ void nil)
    )

    #_public
    (§ method #_"NetworkParameters" (§ fn params) [])
    (§ block
        (§ return params)
    )

    #_public
    (§ method #_"BlockChain" (§ fn chain) [])
    (§ block
        (§ expr Preconditions/checkState(§ pars state(§ pars ) == State/STARTING || state(§ pars ) == State/RUNNING, "Cannot call until startup is complete"))
        (§ return vChain)
    )

    #_public
    (§ method #_"BlockStore" (§ fn store) [])
    (§ block
        (§ expr Preconditions/checkState(§ pars state(§ pars ) == State/STARTING || state(§ pars ) == State/RUNNING, "Cannot call until startup is complete"))
        (§ return vStore)
    )

    #_public
    (§ method #_"Wallet" (§ fn wallet) [])
    (§ block
        (§ expr Preconditions/checkState(§ pars state(§ pars ) == State/STARTING || state(§ pars ) == State/RUNNING, "Cannot call until startup is complete"))
        (§ return vWallet)
    )

    #_public
    (§ method #_"PeerGroup" (§ fn peerGroup) [])
    (§ block
        (§ expr Preconditions/checkState(§ pars state(§ pars ) == State/STARTING || state(§ pars ) == State/RUNNING, "Cannot call until startup is complete"))
        (§ return vPeerGroup)
    )

    #_public
    (§ method #_"File" (§ fn directory) [])
    (§ block
        (§ return directory)
    )
)

#_(ns org.bitcoinj.net #_"AbstractTimeoutHandler"
    (:import [java.util Timer TimerTask]))

;;;
 ; <p>A base class which provides basic support for socket timeouts.  It is used instead of integrating timeouts into the
 ; NIO select thread both for simplicity and to keep code shared between NIO and blocking sockets as much as possible.
 ; </p>
 ;;
#_public
#_abstract
(§ class #_"AbstractTimeoutHandler"
    ;; TimerTask and timeout value which are added to a timer to kill the connection on timeout.
    #_private
    (§ field #_"TimerTask" (§ name timeoutTask))
    #_private
    (§ field #_"long" (§ name timeoutMillis) 0)
    #_private
    (§ field #_"boolean" (§ name timeoutEnabled) true)

    ;; A timer which manages expiring channels as their timeouts occur (if configured).
    #_private
    #_static
    #_final
    (§ field #_"Timer" (§ name timeoutTimer) (§ new #_"Timer" (§ pars "AbstractTimeoutHandler timeouts", true)))

    ;;;
     ; <p>Enables or disables the timeout entirely.  This may be useful if you want to store the timeout value
     ; but wish to temporarily disable/enable timeouts.</p>
     ;
     ; <p>The default is for timeoutEnabled to be true but timeoutMillis to be set to 0 (i.e. disabled).</p>
     ;
     ; <p>This call will reset the current progress towards the timeout.</p>
     ;;
    #_public
    #_synchronized
    #_final
    (§ method #_"void" (§ fn setTimeoutEnabled) [#_"boolean" (§ name timeoutEnabled)])
    (§ block
        (§ ass (§ name this.timeoutEnabled) timeoutEnabled)
        (§ expr resetTimeout(§ pars ))
        (§ void nil)
    )

    ;;;
     ; <p>Sets the receive timeout to the given number of milliseconds, automatically killing the connection
     ; if no messages are received for this long.</p>
     ;
     ; <p>A timeout of 0 is interpreted as no timeout.</p>
     ;
     ; <p>The default is for timeoutEnabled to be true but timeoutMillis to be set to 0 (i.e. disabled).</p>
     ;
     ; <p>This call will reset the current progress towards the timeout.</p>
     ;;
    #_public
    #_synchronized
    #_final
    (§ method #_"void" (§ fn setSocketTimeout) [#_"int" (§ name timeoutMillis)])
    (§ block
        (§ ass (§ name this.timeoutMillis) timeoutMillis)
        (§ expr resetTimeout(§ pars ))
        (§ void nil)
    )

    ;;;
     ; Resets the current progress towards timeout to 0.
     ;;
    #_protected
    #_synchronized
    (§ method #_"void" (§ fn resetTimeout) [])
    (§ block
        (§ if (§ expr timeoutTask != nil))
        (§ block
            (§ expr timeoutTask.cancel(§ pars ))
        )
        (§ if (§ expr timeoutMillis == 0 || (§ not timeoutEnabled)))
        (§ block
            (§ return nil)
        )

        (§ ass (§ name timeoutTask) (§ new #_"TimerTask" (§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn run) [])
            (§ block
                (§ expr timeoutOccurred(§ pars ))
                (§ void nil)
            )
        )))
        (§ expr timeoutTimer.schedule(§ pars timeoutTask, timeoutMillis))
        (§ void nil)
    )

    #_protected
    #_abstract
    (§ method #_"void" (§ fn timeoutOccurred) [])
)

#_(ns org.bitcoinj.net #_"BlockingClient"
    (:import [java.io *]
             [java.net *]
             [java.nio *]
             [java.util *]
             [javax.net *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.util.concurrent *]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]))

;;;
 ; <p>Creates a simple connection to a server using a {@link StreamConnection} to process data.</p>
 ;
 ; <p>Generally, using {@link NioClient} and {@link NioClientManager} should be preferred over {@link BlockingClient}
 ; and {@link BlockingClientManager}, unless you wish to connect over a proxy or use some other network settings that
 ; cannot be set using NIO.</p>
 ;;
#_public
(§ class #_"BlockingClient" (§ implements #_"MessageWriteTarget")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"BlockingClient"))))

    #_private
    #_static
    #_final
    (§ field #_"int" (§ name BUFFER_SIZE_LOWER_BOUND) 4096)
    #_private
    #_static
    #_final
    (§ field #_"int" (§ name BUFFER_SIZE_UPPER_BOUND) 65536)

    #_private
    (§ field #_"Socket" (§ name socket))
    #_private
    #_volatile
    (§ field #_"boolean" (§ name vCloseRequested) false)
    #_private
    (§ field #_"SettableFuture<SocketAddress>" (§ name connectFuture))

    ;;;
     ; <p>Creates a new client to the given server address using the given {@link StreamConnection} to decode the data.
     ; The given connection <b>MUST</b> be unique to this object.  This does not block while waiting for the connection
     ; to open, but will call either the {@link StreamConnection#connectionOpened()} or
     ; {@link StreamConnection#connectionClosed()} callback on the created network event processing thread.</p>
     ;
     ; @param connectTimeoutMillis The connect timeout set on the connection (in milliseconds).
     ;                             0 is interpreted as no timeout.
     ; @param socketFactory An object that creates {@link Socket} objects on demand, which may be customised to control
     ;                      how this client connects to the internet.  If not sure, use SocketFactory.getDefault().
     ; @param clientSet A set which this object will add itself to after initialization, and then remove itself from.
     ;;
    #_public
    (§ constructor #_"BlockingClient" [#_final #_"SocketAddress" (§ name serverAddress), #_final #_"StreamConnection" (§ name connection), #_final #_"int" (§ name connectTimeoutMillis), #_final #_"SocketFactory" (§ name socketFactory), #_nilable #_final #_"Set<BlockingClient>" (§ name clientSet)])
        (§ throws #_"IOException")
    (§ block
        (§ ass (§ name connectFuture) (§ expr SettableFuture/create(§ pars )))
        ;; Try to fit at least one message in the network buffer, but place an upper and lower limit on its size to make
        ;; sure it doesnt get too large or have to call read too often.
        (§ expr connection.setWriteTarget(§ pars this))
        (§ ass (§ name socket) (§ expr socketFactory.createSocket(§ pars )))
        #_final
        (§ var #_"Context" (§ name context) (§ expr Context/get(§ pars )))
        (§ var #_"Thread" (§ name t) (§ new #_"Thread" (§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn run) [])
            (§ block
                (§ expr Context/propagate(§ pars context))
                (§ if (§ expr clientSet != nil))
                (§ block
                    (§ expr clientSet.add(§ pars BlockingClient.this))
                )
                (§ try )
                (§ block
                    (§ expr socket.connect(§ pars serverAddress, connectTimeoutMillis))
                    (§ expr connection.connectionOpened(§ pars ))
                    (§ expr connectFuture.set(§ pars serverAddress))
                    (§ var #_"InputStream" (§ name stream) (§ expr socket.getInputStream(§ pars )))
                    (§ expr runReadLoop(§ pars stream, connection))
                )
                (§ catch #_"Exception" (§ name e))
                (§ block
                    (§ if (§ expr (§ not vCloseRequested)))
                    (§ block
                        (§ expr log.error(§ pars "Error trying to open/read from connection: {}: {}", serverAddress, e.getMessage(§ pars )))
                        (§ expr connectFuture.setException(§ pars e))
                    )
                )
                (§ finally )
                (§ block
                    (§ try )
                    (§ block
                        (§ expr socket.close(§ pars ))
                    )
                    (§ catch #_"IOException" (§ name e1))
                    (§ block
                        ;; At this point there isn't much we can do, and we can probably assume the channel is closed.
                    )
                    (§ if (§ expr clientSet != nil))
                    (§ block
                        (§ expr clientSet.remove(§ pars BlockingClient.this))
                    )
                    (§ expr connection.connectionClosed(§ pars ))
                )
                (§ void nil)
            )
        )))
        (§ expr t.setName(§ pars "BlockingClient network thread for " + serverAddress))
        (§ expr t.setDaemon(§ pars true))
        (§ expr t.start(§ pars ))
        (§ void this)
    )

    ;;;
     ; A blocking call that never returns, except by throwing an exception.  It reads bytes from the input stream
     ; and feeds them to the provided {@link StreamConnection}, for example, a {@link Peer}.
     ;;
    #_public
    #_static
    (§ method #_"void" (§ fn runReadLoop) [#_"InputStream" (§ name stream), #_"StreamConnection" (§ name connection)])
        (§ throws #_"Exception")
    (§ block
        (§ var #_"ByteBuffer" (§ name dbuf) (§ expr ByteBuffer/allocateDirect(§ pars Math/min(§ pars Math/max(§ pars connection.getMaxMessageSize(§ pars ), BUFFER_SIZE_LOWER_BOUND), BUFFER_SIZE_UPPER_BOUND))))
        (§ var #_"byte[]" (§ name readBuff) (§ new #_"byte[]" (§ count dbuf.capacity(§ pars ))))
        (§ while true)
        (§ block
            ;; TODO: Kill the message duplication here.
            (§ expr Preconditions/checkState(§ pars 0 < dbuf.remaining(§ pars ) && dbuf.remaining(§ pars ) <= readBuff.length))
            (§ var #_"int" (§ name read) (§ expr stream.read(§ pars readBuff, 0, Math/max(§ pars 1, Math/min(§ pars dbuf.remaining(§ pars ), stream.available(§ pars ))))))
            (§ if (§ expr read == -1))
            (§ block
                (§ return nil)
            )

            (§ expr dbuf.put(§ pars readBuff, 0, read))
            ;; "flip" the buffer - setting the limit to the current position and setting position to 0
            (§ expr dbuf.flip(§ pars ))
            ;; Use connection.receiveBytes's return value as a double-check that it stopped reading at the right location.
            (§ var #_"int" (§ name bytesConsumed) (§ expr connection.receiveBytes(§ pars dbuf)))
            (§ expr Preconditions/checkState(§ pars dbuf.position(§ pars ) == bytesConsumed))
            ;; Now drop the bytes which were read by compacting dbuf (resetting limit and keeping relative position).
            (§ expr dbuf.compact(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Closes the connection to the server, triggering the {@link StreamConnection#connectionClosed()}
     ; event on the network-handling thread where all callbacks occur.
     ;;
    #_override
    #_public
    (§ method #_"void" (§ fn closeConnection) [])
    (§ block
        ;; Closes the channel, triggering an exception in the network-handling thread triggering connectionClosed().
        (§ try )
        (§ block
            (§ ass (§ name vCloseRequested) true)
            (§ expr socket.close(§ pars ))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
        (§ void nil)
    )

    #_override
    #_public
    #_synchronized
    (§ method #_"void" (§ fn writeBytes) [#_"byte[]" (§ name message)])
        (§ throws #_"IOException")
    (§ block
        (§ try )
        (§ block
            (§ var #_"OutputStream" (§ name stream) (§ expr socket.getOutputStream(§ pars )))
            (§ expr stream.write(§ pars message))
            (§ expr stream.flush(§ pars ))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ expr log.error(§ pars "Error writing message to connection, closing connection", e))
            (§ expr closeConnection(§ pars ))
            (§ throw e)
        )
        (§ void nil)
    )

    ;;; Returns a future that completes once connection has occurred at the socket level or with an exception if failed to connect. ;;
    #_public
    (§ method #_"ListenableFuture<SocketAddress>" (§ fn getConnectFuture) [])
    (§ block
        (§ return connectFuture)
    )
)

#_(ns org.bitcoinj.net #_"BlockingClientManager"
    (:import [java.io IOException]
             [java.net SocketAddress]
             [java.util Collections HashSet Iterator Set]
             [javax.net SocketFactory])
    (:import [com.google.common.base Preconditions]
             [com.google.common.util.concurrent AbstractIdleService ListenableFuture]))

;;;
 ; <p>A thin wrapper around a set of {@link BlockingClient}s.</p>
 ;
 ; <p>Generally, using {@link NioClient} and {@link NioClientManager} should be preferred over {@link BlockingClient}
 ; and {@link BlockingClientManager} as they scale significantly better, unless you wish to connect over a proxy or use
 ; some other network settings that cannot be set using NIO.</p>
 ;;
#_public
(§ class #_"BlockingClientManager" (§ extends #_"AbstractIdleService") (§ implements #_"ClientConnectionManager")
    #_private
    #_final
    (§ field #_"SocketFactory" (§ name socketFactory))
    #_private
    #_final
    (§ field #_"Set<BlockingClient>" (§ name clients) (§ expr Collections/synchronizedSet(§ pars (§ new #_"HashSet<BlockingClient>" (§ pars )))))

    #_private
    (§ field #_"int" (§ name connectTimeoutMillis) 1000)

    #_public
    (§ constructor #_"BlockingClientManager" [])
    (§ block
        (§ ass (§ name socketFactory) (§ expr SocketFactory/getDefault(§ pars )))
        (§ void this)
    )

    ;;;
     ; Creates a blocking client manager that will obtain sockets from the given factory.
     ; Useful for customising how bitcoinj connects to the P2P network.
     ;;
    #_public
    (§ constructor #_"BlockingClientManager" [#_"SocketFactory" (§ name socketFactory)])
    (§ block
        (§ ass (§ name this.socketFactory) (§ expr Preconditions/checkNotNull(§ pars socketFactory)))
        (§ void this)
    )

    #_override
    #_public
    (§ method #_"ListenableFuture<SocketAddress>" (§ fn openConnection) [#_"SocketAddress" (§ name serverAddress), #_"StreamConnection" (§ name connection)])
    (§ block
        (§ try )
        (§ block
            (§ if (§ expr (§ not isRunning(§ pars ))))
            (§ block
                (§ throw (§ new #_"IllegalStateException" (§ pars )))
            )

            (§ return (§ new #_"BlockingClient" (§ pars serverAddress, connection, connectTimeoutMillis, socketFactory, clients)).getConnectFuture(§ pars ))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; This should only happen if we are, e.g. out of system resources.
        )
    )

    ;;; Sets the number of milliseconds to wait before giving up on a connect attempt. ;;
    #_public
    (§ method #_"void" (§ fn setConnectTimeoutMillis) [#_"int" (§ name connectTimeoutMillis)])
    (§ block
        (§ ass (§ name this.connectTimeoutMillis) connectTimeoutMillis)
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn startUp) [])
        (§ throws #_"Exception")
    (§ block
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn shutDown) [])
        (§ throws #_"Exception")
    (§ block
        (§ sync clients)
        (§ block
            (§ for (§ var #_"BlockingClient" (§ name client)) :for clients)
            (§ block
                (§ expr client.closeConnection(§ pars ))
            )
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"int" (§ fn getConnectedClientCount) [])
    (§ block
        (§ return (§ expr clients.size(§ pars )))
    )

    #_override
    #_public
    (§ method #_"void" (§ fn closeConnections) [#_"int" (§ name n)])
    (§ block
        (§ if (§ expr (§ not isRunning(§ pars ))))
        (§ block
            (§ throw (§ new #_"IllegalStateException" (§ pars )))
        )

        (§ sync clients)
        (§ block
            (§ for (§ var #_"Iterator<BlockingClient>" (§ name it) (§ expr clients.iterator(§ pars ))) :for (§ expr 0 < n && it.hasNext(§ pars )) :for (§ ass (§ name n) (§ expr n - 1)))
            (§ block
                (§ expr it.next(§ pars ).closeConnection(§ pars ))
            )
        )
        (§ void nil)
    )
)

#_(ns org.bitcoinj.net #_"ClientConnectionManager"
    (:import [java.net SocketAddress])
    (:import [com.google.common.util.concurrent ListenableFuture Service]))

;;;
 ; <p>A generic interface for an object which keeps track of a set of open client connections, creates new ones and
 ; ensures they are serviced properly.</p>
 ;
 ; <p>When the service is {@link com.google.common.util.concurrent.Service#stop()}ed, all connections will be closed
 ; and the appropriate connectionClosed() calls must be made.</p>
 ;;
#_public
(§ interface #_"ClientConnectionManager" (§ extends #_"Service")
    ;;;
     ; Creates a new connection to the given address, with the given connection used to handle incoming data.  Any errors
     ; that occur during connection will be returned in the given future, including errors that can occur immediately.
     ;;
    (§ method #_"ListenableFuture<SocketAddress>" (§ fn openConnection) [#_"SocketAddress" (§ name serverAddress), #_"StreamConnection" (§ name connection)])

    ;;; Gets the number of connected peers. ;;
    (§ method #_"int" (§ fn getConnectedClientCount) [])

    ;;; Closes n peer connections. ;;
    (§ method #_"void" (§ fn closeConnections) [#_"int" (§ name n)])
)

#_(ns org.bitcoinj.net #_"ConnectionHandler"
    (:import [java.io IOException]
             [java.nio ByteBuffer]
             [java.nio.channels CancelledKeyException SelectionKey SocketChannel]
             [java.util Arrays Iterator LinkedList Set]
             [java.util.concurrent.locks ReentrantLock]
             [javax.annotation.concurrent GuardedBy])
    (:import [com.google.common.base Preconditions Throwables]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core Message]
             [org.bitcoinj.utils Threading]))

;; TODO: The locking in all this class is horrible and not really necessary.  We should just run all network stuff on one thread.

;;;
 ; A simple NIO MessageWriteTarget which handles all the business logic of a connection (reading+writing bytes).
 ; Used only by the NioClient and NioServer classes.
 ;;
(§ class #_"ConnectionHandler" (§ implements #_"MessageWriteTarget")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"ConnectionHandler"))))

    #_private
    #_static
    #_final
    (§ field #_"int" (§ name BUFFER_SIZE_LOWER_BOUND) 4096)
    #_private
    #_static
    #_final
    (§ field #_"int" (§ name BUFFER_SIZE_UPPER_BOUND) 65536)

    #_private
    #_static
    #_final
    (§ field #_"int" (§ name OUTBOUND_BUFFER_BYTE_COUNT) (§ expr Message/MAX_SIZE + 24)) ;; 24 byte message header

    ;; We lock when touching local flags and when writing data, but NEVER when calling any methods which leave
    ;; this class into non-Java classes.
    #_private
    #_final
    (§ field #_"ReentrantLock" (§ name lock) (§ expr Threading/lock(§ pars "nioConnectionHandler")))
    #_guarded-by(§ opt "lock")
    #_private
    #_final
    (§ field #_"ByteBuffer" (§ name readBuff))
    #_guarded-by(§ opt "lock")
    #_private
    #_final
    (§ field #_"SocketChannel" (§ name channel))
    #_guarded-by(§ opt "lock")
    #_private
    #_final
    (§ field #_"SelectionKey" (§ name key))
    #_guarded-by(§ opt "lock")
    (§ field #_"StreamConnection" (§ name connection))
    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"boolean" (§ name closeCalled) false)

    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"long" (§ name bytesToWriteRemaining) 0)
    #_guarded-by(§ opt "lock")
    #_private
    #_final
    (§ field #_"LinkedList<ByteBuffer>" (§ name bytesToWrite) (§ new #_"LinkedList<>" (§ pars )))

    #_private
    (§ field #_"Set<ConnectionHandler>" (§ name connectedHandlers))

    #_public
    (§ constructor #_"ConnectionHandler" [#_"StreamConnectionFactory" (§ name connectionFactory), #_"SelectionKey" (§ name key)])
        (§ throws #_"IOException")
    (§ block
        (§ this (§ pars connectionFactory.getNewConnection(§ pars (§ expr (§ cast #_"SocketChannel" (§ expr key.channel(§ pars )))).socket(§ pars ).getInetAddress(§ pars ), (§ expr (§ cast #_"SocketChannel" (§ expr key.channel(§ pars )))).socket(§ pars ).getPort(§ pars )), key))
        (§ if (§ expr connection == nil))
        (§ block
            (§ throw (§ new #_"IOException" (§ pars "Parser factory.getNewConnection returned nil")))
        )
        (§ void this)
    )

    #_private
    (§ constructor #_"ConnectionHandler" [#_nilable #_"StreamConnection" (§ name connection), #_"SelectionKey" (§ name key)])
    (§ block
        (§ ass (§ name this.key) key)
        (§ ass (§ name this.channel) (§ expr Preconditions/checkNotNull(§ pars (§ expr (§ cast #_"SocketChannel" (§ expr key.channel(§ pars )))))))
        (§ if (§ expr connection == nil))
        (§ block
            (§ ass (§ name readBuff) nil)
            (§ return nil)
        )

        (§ ass (§ name this.connection) connection)
        (§ ass (§ name readBuff) (§ expr ByteBuffer/allocateDirect(§ pars Math/min(§ pars Math/max(§ pars connection.getMaxMessageSize(§ pars ), BUFFER_SIZE_LOWER_BOUND), BUFFER_SIZE_UPPER_BOUND))))
        (§ expr connection.setWriteTarget(§ pars this)) ;; May callback into us (e.g. closeConnection() now).
        (§ ass (§ name connectedHandlers) nil)
        (§ void this)
    )

    #_public
    (§ constructor #_"ConnectionHandler" [#_"StreamConnection" (§ name connection), #_"SelectionKey" (§ name key), #_"Set<ConnectionHandler>" (§ name connectedHandlers)])
    (§ block
        (§ this (§ pars Preconditions/checkNotNull(§ pars connection), key))

        ;; closeConnection() may have already happened because we invoked the other c'tor above, which called
        ;; connection.setWriteTarget which might have re-entered already.  In this case we shouldn't add ourselves
        ;; to the connectedHandlers set.
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name this.connectedHandlers) connectedHandlers)
            (§ if (§ expr (§ not closeCalled)))
            (§ block
                (§ expr Preconditions/checkState(§ pars this.connectedHandlers.add(§ pars this)))
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void this)
    )

    #_guarded-by(§ opt "lock")
    #_private
    (§ method #_"void" (§ fn setWriteOps) [])
    (§ block
        ;; Make sure we are registered to get updated when writing is available again.
        (§ expr key.interestOps(§ pars key.interestOps(§ pars ) | SelectionKey/OP_WRITE))
        ;; Refresh the selector to make sure it gets the new interestOps.
        (§ expr key.selector(§ pars ).wakeup(§ pars ))
        (§ void nil)
    )

    ;; Tries to write any outstanding write bytes, runs in any thread (possibly unlocked).
    #_private
    (§ method #_"void" (§ fn tryWriteBytes) [])
        (§ throws #_"IOException")
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; Iterate through the outbound ByteBuff queue, pushing as much as possible into the OS' network buffer.
            (§ var #_"Iterator<ByteBuffer>" (§ name bytesIterator) (§ expr bytesToWrite.iterator(§ pars )))
            (§ while (§ expr bytesIterator.hasNext(§ pars )))
            (§ block
                (§ var #_"ByteBuffer" (§ name buff) (§ expr bytesIterator.next(§ pars )))
                (§ ass (§ name bytesToWriteRemaining) (§ expr bytesToWriteRemaining - channel.write(§ pars buff)))
                (§ if (§ expr (§ not buff.hasRemaining(§ pars ))))
                (§ block
                    (§ expr bytesIterator.remove(§ pars ))
                )
                (§ else )
                (§ block
                    (§ expr setWriteOps(§ pars ))
                    (§ break )
                )
            )
            ;; If we are done writing, clear the OP_WRITE interestOps.
            (§ if (§ expr bytesToWrite.isEmpty(§ pars )))
            (§ block
                (§ expr key.interestOps(§ pars key.interestOps(§ pars ) & (§ flip SelectionKey/OP_WRITE)))
            )
            ;; Don't bother waking up the selector here, since we're just removing an op, not adding.
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn writeBytes) [#_"byte[]" (§ name message)])
        (§ throws #_"IOException")
    (§ block
        (§ var #_"boolean" (§ name andUnlock) true)
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; Network buffers are not unlimited (and are often smaller than some messages we may wish to send), and
            ;; thus we have to buffer outbound messages sometimes.  To do this, we use a queue of ByteBuffers and just
            ;; append to it when we want to send a message.  We then let tryWriteBytes() either send the message or
            ;; register our SelectionKey to wakeup when we have free outbound buffer space available.
            (§ if (§ expr OUTBOUND_BUFFER_BYTE_COUNT < bytesToWriteRemaining + message.length))
            (§ block
                (§ throw (§ new #_"IOException" (§ pars "Outbound buffer overflowed")))
            )

            ;; Just dump the message onto the write buffer and call tryWriteBytes.
            ;; TODO: Kill the needless message duplication when the write completes right away.
            (§ expr bytesToWrite.offer(§ pars ByteBuffer/wrap(§ pars Arrays/copyOf(§ pars message, message.length))))
            (§ ass (§ name bytesToWriteRemaining) (§ expr bytesToWriteRemaining + message.length))
            (§ expr setWriteOps(§ pars ))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ expr lock.unlock(§ pars ))
            (§ ass (§ name andUnlock) false)
            (§ expr log.warn(§ pars "Error writing message to connection, closing connection", e))
            (§ expr closeConnection(§ pars ))
            (§ throw e)
        )
        (§ catch #_"CancelledKeyException" (§ name e))
        (§ block
            (§ expr lock.unlock(§ pars ))
            (§ ass (§ name andUnlock) false)
            (§ expr log.warn(§ pars "Error writing message to connection, closing connection", e))
            (§ expr closeConnection(§ pars ))
            (§ throw (§ new #_"IOException" (§ pars e)))
        )
        (§ finally )
        (§ block
            (§ if andUnlock)
            (§ block
                (§ expr lock.unlock(§ pars ))
            )
        )
        (§ void nil)
    )

    ;; May NOT be called with lock held.
    #_override
    #_public
    (§ method #_"void" (§ fn closeConnection) [])
    (§ block
        (§ expr Preconditions/checkState(§ pars (§ not lock.isHeldByCurrentThread(§ pars ))))
        (§ try )
        (§ block
            (§ expr channel.close(§ pars ))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
        (§ expr connectionClosed(§ pars ))
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn connectionClosed) [])
    (§ block
        (§ var #_"boolean" (§ name callClosed) false)
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name callClosed) (§ expr (§ not closeCalled)))
            (§ ass (§ name closeCalled) true)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ if callClosed)
        (§ block
            (§ expr Preconditions/checkState(§ pars connectedHandlers == nil || connectedHandlers.remove(§ pars this)))
            (§ expr connection.connectionClosed(§ pars ))
        )
        (§ void nil)
    )

    ;; Handle a SelectionKey which was selected.
    ;; Runs unlocked as the caller is single-threaded (or if not, should enforce that handleKey is only called
    ;; atomically for a given ConnectionHandler).
    #_public
    #_static
    (§ method #_"void" (§ fn handleKey) [#_"SelectionKey" (§ name key)])
    (§ block
        (§ var #_"ConnectionHandler" (§ name handler) (§ expr (§ cast #_"ConnectionHandler" (§ expr key.attachment(§ pars )))))
        (§ try )
        (§ block
            (§ if (§ expr handler == nil))
            (§ block
                (§ return nil)
            )
            (§ if (§ expr (§ not key.isValid(§ pars ))))
            (§ block
                (§ expr handler.closeConnection(§ pars )) ;; Key has been cancelled, make sure the socket gets closed.
                (§ return nil)
            )
            (§ if (§ expr key.isReadable(§ pars )))
            (§ block
                ;; Do a socket read and invoke the connection's receiveBytes message.
                (§ var #_"int" (§ name read) (§ expr handler.channel.read(§ pars handler.readBuff)))
                (§ if (§ expr read == 0))
                (§ block
                    (§ return nil) ;; Was probably waiting on a write.
                )
                (§ elseif (§ expr read == -1)) ;; Socket was closed.
                (§ block
                    (§ expr key.cancel(§ pars ))
                    (§ expr handler.closeConnection(§ pars ))
                    (§ return nil)
                )
                ;; "flip" the buffer - setting the limit to the current position and setting position to 0
                (§ expr handler.readBuff.flip(§ pars ))
                ;; Use connection.receiveBytes's return value as a check that it stopped reading at the right location.
                (§ var #_"int" (§ name bytesConsumed) (§ expr Preconditions/checkNotNull(§ pars handler.connection).receiveBytes(§ pars handler.readBuff)))
                (§ expr Preconditions/checkState(§ pars handler.readBuff.position(§ pars ) == bytesConsumed))
                ;; Now drop the bytes which were read by compacting readBuff (resetting limit and keeping relative position).
                (§ expr handler.readBuff.compact(§ pars ))
            )
            (§ if (§ expr key.isWritable(§ pars )))
            (§ block
                (§ expr handler.tryWriteBytes(§ pars ))
            )
        )
        (§ catch #_"Exception" (§ name e))
        (§ block
            ;; This can happen e.g. if the channel closes while the thread is about to get killed
            ;; (ClosedByInterruptException), or if handler.connection.receiveBytes throws something.
            (§ var #_"Throwable" (§ name t) (§ expr Throwables/getRootCause(§ pars e)))
            (§ expr log.warn(§ pars "Error handling SelectionKey: {} {}", t.getClass(§ pars ).getName(§ pars ), (§ quest (§ expr t.getMessage(§ pars ) != nil) ? (§ expr t.getMessage(§ pars )) :else (§ expr "")), e))
            (§ expr handler.closeConnection(§ pars ))
        )
        (§ void nil)
    )
)

#_(ns org.bitcoinj.net #_"FilterMerger"
    (:import [java.util LinkedList])
    (:import [com.google.common.collect ImmutableList Lists])
   (:require [org.bitcoinj.core BloomFilter PeerFilterProvider]))

;;;
 ; <p>A reusable object that will calculate, given a list of {@link org.bitcoinj.core.PeerFilterProvider}s, a merged
 ; {@link org.bitcoinj.core.BloomFilter} and earliest key time for all of them.
 ; Used by the {@link org.bitcoinj.core.PeerGroup} class internally.</p>
 ;
 ; <p>Thread safety: threading here can be complicated.  Each filter provider is given a begin event, which may acquire
 ; a lock (and is guaranteed to receive an end event).  This class is mostly thread unsafe and is meant to be used from
 ; a single thread only, PeerGroup ensures this by only accessing it from the dedicated PeerGroup thread.  PeerGroup
 ; does not hold any locks whilst this object is used, relying on the single thread to prevent multiple filters being
 ; calculated in parallel, thus a filter provider can do things like make blocking calls into PeerGroup from a separate
 ; thread.  However the bloomFilterFPRate property IS thread safe, for convenience.</p>
 ;;
#_public
(§ class #_"FilterMerger"
    ;; We use a constant tweak to avoid giving up privacy when we regenerate our filter with new keys.
    #_private
    #_final
    (§ field #_"long" (§ name bloomFilterTweak) (§ expr (§ cast #_"long" (§ expr Math/random(§ pars ) * Long/MAX_VALUE))))

    #_private
    #_volatile
    (§ field #_"double" (§ name vBloomFilterFPRate))
    #_private
    (§ field #_"int" (§ name lastBloomFilterElementCount))
    #_private
    (§ field #_"BloomFilter" (§ name lastFilter))

    #_public
    (§ constructor #_"FilterMerger" [#_"double" (§ name bloomFilterFPRate)])
    (§ block
        (§ ass (§ name this.vBloomFilterFPRate) bloomFilterFPRate)
        (§ void this)
    )

    #_public
    #_static
    (§ class #_"Result"
        #_public
        (§ field #_"BloomFilter" (§ name filter))
        #_public
        (§ field #_"long" (§ name earliestKeyTimeSecs))
        #_public
        (§ field #_"boolean" (§ name changed))
    )

    #_public
    (§ method #_"Result" (§ fn calculate) [#_"ImmutableList<PeerFilterProvider>" (§ name providers)])
    (§ block
        (§ var #_"LinkedList<PeerFilterProvider>" (§ name begunProviders) (§ expr Lists/newLinkedList(§ pars )))
        (§ try )
        (§ block
            ;; All providers must be in a consistent, unchanging state because the filter is a merged one that's
            ;; large enough for all providers elements: if a provider were to get more elements in the middle of the
            ;; calculation, we might assert or calculate the filter wrongly.  Most providers use a lock here but
            ;; snapshotting required state is also a legitimate strategy.
            (§ for (§ var #_"PeerFilterProvider" (§ name provider)) :for providers)
            (§ block
                (§ expr provider.beginBloomFilterCalculation(§ pars ))
                (§ expr begunProviders.add(§ pars provider))
            )
            (§ var #_"Result" (§ name result) (§ new #_"Result" (§ pars )))
            (§ ass (§ name result.earliestKeyTimeSecs) (§ expr Long/MAX_VALUE))
            (§ var #_"int" (§ name elements) 0)
            (§ var #_"boolean" (§ name requiresUpdateAll) false)
            (§ for (§ var #_"PeerFilterProvider" (§ name p)) :for providers)
            (§ block
                (§ ass (§ name result.earliestKeyTimeSecs) (§ expr Math/min(§ pars result.earliestKeyTimeSecs, p.getEarliestKeyCreationTime(§ pars ))))
                (§ ass (§ name elements) (§ expr elements + p.getBloomFilterElementCount(§ pars )))
            )

            (§ if (§ expr 0 < elements))
            (§ block
                ;; We stair-step our element count so that we avoid creating a filter with different parameters
                ;; as much as possible as that results in a loss of privacy.
                ;; The constant 100 here is somewhat arbitrary, but makes sense for small to medium wallets -
                ;; it will likely mean we never need to create a filter with different parameters.
                (§ ass (§ name lastBloomFilterElementCount) (§ quest (§ expr lastBloomFilterElementCount < elements) ? (§ expr elements + 100) :else lastBloomFilterElementCount))
                (§ var #_"BloomFilter.BloomUpdate" (§ name bloomFlags) (§ quest requiresUpdateAll ? (§ expr BloomFilter/BloomUpdate/UPDATE_ALL) :else (§ expr BloomFilter/BloomUpdate/UPDATE_P2PUBKEY_ONLY)))
                (§ var #_"double" (§ name fpRate) vBloomFilterFPRate)
                (§ var #_"BloomFilter" (§ name filter) (§ new #_"BloomFilter" (§ pars lastBloomFilterElementCount, fpRate, bloomFilterTweak, bloomFlags)))
                (§ for (§ var #_"PeerFilterProvider" (§ name p)) :for providers)
                (§ block
                    (§ expr filter.merge(§ pars p.getBloomFilter(§ pars lastBloomFilterElementCount, fpRate, bloomFilterTweak)))
                )

                (§ ass (§ name result.changed) (§ expr (§ not filter.equals(§ pars lastFilter))))
                (§ ass (§ name result.filter) (§ ass (§ name lastFilter) filter))
            )
            ;; Now adjust the earliest key time backwards by a week to handle the case of clock drift.  This can occur
            ;; both in block header timestamps and if the users clock was out of sync when the key was first created
            ;; (to within a small amount of tolerance).
            (§ ass (§ name result.earliestKeyTimeSecs) (§ expr earliestKeyTimeSecs - (§ expr 86400 * 7)))
            (§ return result)
        )
        (§ finally )
        (§ block
            (§ for (§ var #_"PeerFilterProvider" (§ name provider)) :for begunProviders)
            (§ block
                (§ expr provider.endBloomFilterCalculation(§ pars ))
            )
        )
    )

    #_public
    (§ method #_"void" (§ fn setBloomFilterFPRate) [#_"double" (§ name bloomFilterFPRate)])
    (§ block
        (§ ass (§ name this.vBloomFilterFPRate) bloomFilterFPRate)
        (§ void nil)
    )

    #_public
    (§ method #_"double" (§ fn getBloomFilterFPRate) [])
    (§ block
        (§ return vBloomFilterFPRate)
    )

    #_public
    (§ method #_"BloomFilter" (§ fn getLastFilter) [])
    (§ block
        (§ return lastFilter)
    )
)

#_(ns org.bitcoinj.net #_"MessageWriteTarget"
    (:import [java.io IOException]))

;;;
 ; A target to which messages can be written/connection can be closed.
 ;;
#_public
(§ interface #_"MessageWriteTarget"
    ;;;
     ; Writes the given bytes to the remote server.
     ;;
    (§ method #_"void" (§ fn writeBytes) [#_"byte[]" (§ name message)])
        (§ throws #_"IOException")
    ;;;
     ; Closes the connection to the server, triggering the {@link StreamConnection#connectionClosed()}
     ; event on the network-handling thread where all callbacks occur.
     ;;
    (§ method #_"void" (§ fn closeConnection) [])
)

#_(ns org.bitcoinj.net #_"NioClient"
    (:import [java.io *]
             [java.net *]
             [java.nio *])
    (:import [com.google.common.base *]
             [com.google.common.util.concurrent *]
             [org.slf4j *]))

;;;
 ; Creates a simple connection to a server using a {@link StreamConnection} to process data.
 ;;
#_public
(§ class #_"NioClient" (§ implements #_"MessageWriteTarget")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"NioClient"))))

    #_private
    #_final
    (§ field #_"Handler" (§ name handler))
    #_private
    #_final
    (§ field #_"NioClientManager" (§ name manager) (§ new #_"NioClientManager" (§ pars )))

    (§ class #_"Handler" (§ extends #_"AbstractTimeoutHandler") (§ implements #_"StreamConnection")
        #_private
        #_final
        (§ field #_"StreamConnection" (§ name upstreamConnection))
        #_private
        (§ field #_"MessageWriteTarget" (§ name writeTarget))
        #_private
        (§ field #_"boolean" (§ name closeOnOpen))
        #_private
        (§ field #_"boolean" (§ name closeCalled))

        (§ constructor #_"Handler" [#_"StreamConnection" (§ name upstreamConnection), #_"int" (§ name connectTimeoutMillis)])
        (§ block
            (§ ass (§ name this.upstreamConnection) upstreamConnection)
            (§ expr setSocketTimeout(§ pars connectTimeoutMillis))
            (§ expr setTimeoutEnabled(§ pars true))
            (§ void this)
        )

        #_override
        #_protected
        #_synchronized
        (§ method #_"void" (§ fn timeoutOccurred) [])
        (§ block
            (§ ass (§ name closeOnOpen) true)
            (§ expr connectionClosed(§ pars ))
            (§ void nil)
        )

        #_override
        #_public
        #_synchronized
        (§ method #_"void" (§ fn connectionClosed) [])
        (§ block
            (§ expr manager.stopAsync(§ pars ))
            (§ if (§ expr (§ not closeCalled)))
            (§ block
                (§ ass (§ name closeCalled) true)
                (§ expr upstreamConnection.connectionClosed(§ pars ))
            )
            (§ void nil)
        )

        #_override
        #_public
        #_synchronized
        (§ method #_"void" (§ fn connectionOpened) [])
        (§ block
            (§ if (§ expr (§ not closeOnOpen)))
            (§ block
                (§ expr upstreamConnection.connectionOpened(§ pars ))
            )
            (§ void nil)
        )

        #_override
        #_public
        (§ method #_"int" (§ fn receiveBytes) [#_"ByteBuffer" (§ name buff)])
            (§ throws #_"Exception")
        (§ block
            (§ return (§ expr upstreamConnection.receiveBytes(§ pars buff)))
        )

        #_override
        #_public
        #_synchronized
        (§ method #_"void" (§ fn setWriteTarget) [#_"MessageWriteTarget" (§ name writeTarget)])
        (§ block
            (§ if closeOnOpen)
            (§ block
                (§ expr writeTarget.closeConnection(§ pars ))
            )
            (§ else )
            (§ block
                (§ expr setTimeoutEnabled(§ pars false))
                (§ ass (§ name this.writeTarget) writeTarget)
                (§ expr upstreamConnection.setWriteTarget(§ pars writeTarget))
            )
            (§ void nil)
        )

        #_override
        #_public
        (§ method #_"int" (§ fn getMaxMessageSize) [])
        (§ block
            (§ return (§ expr upstreamConnection.getMaxMessageSize(§ pars )))
        )
    )

    ;;;
     ; <p>Creates a new client to the given server address using the given {@link StreamConnection} to decode the data.
     ; The given connection <b>MUST</b> be unique to this object.  This does not block while waiting for the connection
     ; to open, but will call either the {@link StreamConnection#connectionOpened()} or
     ; {@link StreamConnection#connectionClosed()} callback on the created network event processing thread.</p>
     ;
     ; @param connectTimeoutMillis The connect timeout set on the connection (in milliseconds).
     ;                             0 is interpreted as no timeout.
     ;;
    #_public
    (§ constructor #_"NioClient" [#_final #_"SocketAddress" (§ name serverAddress), #_final #_"StreamConnection" (§ name parser), #_final #_"int" (§ name connectTimeoutMillis)])
        (§ throws #_"IOException")
    (§ block
        (§ expr manager.startAsync(§ pars ))
        (§ expr manager.awaitRunning(§ pars ))
        (§ ass (§ name handler) (§ new #_"Handler" (§ pars parser, connectTimeoutMillis)))
        (§ expr Futures/addCallback(§ pars manager.openConnection(§ pars serverAddress, handler), new FutureCallback<SocketAddress>(§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn onSuccess) [#_"SocketAddress" (§ name result)])
            (§ block
                (§ void nil)
            )

            #_override
            #_public
            (§ method #_"void" (§ fn onFailure) [#_"Throwable" (§ name t)])
            (§ block
                (§ expr log.error(§ pars "Connect to {} failed: {}", serverAddress, Throwables/getRootCause(§ pars t)))
                (§ void nil)
            )
        )))
        (§ void this)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn closeConnection) [])
    (§ block
        (§ expr handler.writeTarget.closeConnection(§ pars ))
        (§ void nil)
    )

    #_override
    #_public
    #_synchronized
    (§ method #_"void" (§ fn writeBytes) [#_"byte[]" (§ name message)])
        (§ throws #_"IOException")
    (§ block
        (§ expr handler.writeTarget.writeBytes(§ pars message))
        (§ void nil)
    )
)

#_(ns org.bitcoinj.net #_"NioClientManager"
    (:import [java.io IOException]
             [java.net ConnectException SocketAddress]
             [java.nio.channels *]
             [java.nio.channels.spi SelectorProvider]
             [java.util *]
             [java.util.concurrent *])
    (:import [com.google.common.base Throwables]
             [com.google.common.util.concurrent *]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.utils *]))

;;;
 ; A class which manages a set of client connections.  Uses Java NIO to select network events and processes them
 ; in a single network processing thread.
 ;;
#_public
(§ class #_"NioClientManager" (§ extends #_"AbstractExecutionThreadService") (§ implements #_"ClientConnectionManager")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"NioClientManager"))))

    #_private
    #_final
    (§ field #_"Selector" (§ name selector))

    (§ class #_"PendingConnect"
        (§ var #_"SocketChannel" (§ name sc))
        (§ var #_"StreamConnection" (§ name connection))
        (§ var #_"SocketAddress" (§ name address))
        (§ var #_"SettableFuture<SocketAddress>" (§ name future) (§ expr SettableFuture/create(§ pars )))

        (§ constructor #_"PendingConnect" [#_"SocketChannel" (§ name sc), #_"StreamConnection" (§ name connection), #_"SocketAddress" (§ name address)])
        (§ block
            (§ ass (§ name this.sc) sc)
            (§ ass (§ name this.connection) connection)
            (§ ass (§ name this.address) address)
            (§ void this)
        )
    )
    #_final
    (§ field #_"Queue<PendingConnect>" (§ name newConnectionChannels) (§ new #_"LinkedBlockingQueue<>" (§ pars )))

    ;; Added to/removed from by the individual ConnectionHandler's, thus must by synchronized on its own.
    #_private
    #_final
    (§ field #_"Set<ConnectionHandler>" (§ name connectedHandlers) (§ expr Collections/synchronizedSet(§ pars (§ new #_"HashSet<ConnectionHandler>" (§ pars )))))

    ;; Handle a SelectionKey which was selected.
    #_private
    (§ method #_"void" (§ fn handleKey) [#_"SelectionKey" (§ name key)])
        (§ throws #_"IOException")
    (§ block
        ;; We could have a !isValid() key here if the connection is already closed at this point,
        ;; i.e. a client connection which has finished the initial connect process.
        (§ if (§ expr key.isValid(§ pars ) && key.isConnectable(§ pars )))
        (§ block
            ;; Create a ConnectionHandler and hook everything together.
            (§ var #_"PendingConnect" (§ name data) (§ expr (§ cast #_"PendingConnect" (§ expr key.attachment(§ pars )))))
            (§ var #_"StreamConnection" (§ name connection) (§ expr data.connection))
            (§ var #_"SocketChannel" (§ name sc) (§ expr (§ cast #_"SocketChannel" (§ expr key.channel(§ pars )))))
            (§ var #_"ConnectionHandler" (§ name handler) (§ new #_"ConnectionHandler" (§ pars connection, key, connectedHandlers)))
            (§ try )
            (§ block
                (§ if (§ expr sc.finishConnect(§ pars )))
                (§ block
                    (§ expr log.info(§ pars "Connected to {}", sc.socket(§ pars ).getRemoteSocketAddress(§ pars )))
                    (§ expr key.interestOps(§ pars (§ expr key.interestOps(§ pars ) | SelectionKey/OP_READ) & (§ flip SelectionKey/OP_CONNECT)).attach(§ pars handler))
                    (§ expr connection.connectionOpened(§ pars ))
                    (§ expr data.future.set(§ pars data.address))
                )
                (§ else )
                (§ block
                    (§ expr log.warn(§ pars "Failed to connect to {}", sc.socket(§ pars ).getRemoteSocketAddress(§ pars )))
                    (§ expr handler.closeConnection(§ pars )) ;; Failed to connect for some reason.
                    (§ expr data.future.setException(§ pars (§ new #_"ConnectException" (§ pars "Unknown reason"))))
                    (§ ass (§ name data.future) nil)
                )
            )
            (§ catch #_"Exception" (§ name e))
            (§ block
                ;; If e is a CancelledKeyException, there is a race to get to interestOps after finishConnect() which
                ;; may cause this.  Otherwise it may be any arbitrary kind of connection failure.
                ;; Calling sc.socket().getRemoteSocketAddress() here throws an exception, so we can only log the error itself.
                (§ var #_"Throwable" (§ name cause) (§ expr Throwables/getRootCause(§ pars e)))
                (§ expr log.warn(§ pars "Failed to connect with exception: {}: {}", cause.getClass(§ pars ).getName(§ pars ), cause.getMessage(§ pars ), e))
                (§ expr handler.closeConnection(§ pars ))
                (§ expr data.future.setException(§ pars cause))
                (§ ass (§ name data.future) nil)
            )
        )
        (§ else ) ;; Process bytes read.
        (§ block
            (§ expr ConnectionHandler/handleKey(§ pars key))
        )
        (§ void nil)
    )

    ;;;
     ; Creates a new client manager which uses Java NIO for socket management.
     ; Uses a single thread to handle all select calls.
     ;;
    #_public
    (§ constructor #_"NioClientManager" [])
    (§ block
        (§ try )
        (§ block
            (§ ass (§ name selector) (§ expr SelectorProvider/provider(§ pars ).openSelector(§ pars )))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Shouldn't ever happen.
        )
        (§ void this)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn run) [])
    (§ block
        (§ try )
        (§ block
            (§ expr Thread/currentThread(§ pars ).setPriority(§ pars Thread/MIN_PRIORITY))
            (§ while (§ expr isRunning(§ pars )))
            (§ block
                (§ var #_"PendingConnect" (§ name conn))
                (§ while (§ expr (§ ass (§ name conn) (§ expr newConnectionChannels.poll(§ pars ))) != nil))
                (§ block
                    (§ try )
                    (§ block
                        (§ var #_"SelectionKey" (§ name key) (§ expr conn.sc.register(§ pars selector, SelectionKey/OP_CONNECT)))
                        (§ expr key.attach(§ pars conn))
                    )
                    (§ catch #_"ClosedChannelException" (§ name _))
                    (§ block
                        (§ expr log.warn(§ pars "SocketChannel was closed before it could be registered"))
                    )
                )

                (§ expr selector.select(§ pars ))

                (§ var #_"Iterator<SelectionKey>" (§ name keyIterator) (§ expr selector.selectedKeys(§ pars ).iterator(§ pars )))
                (§ while (§ expr keyIterator.hasNext(§ pars )))
                (§ block
                    (§ var #_"SelectionKey" (§ name key) (§ expr keyIterator.next(§ pars )))
                    (§ expr keyIterator.remove(§ pars ))
                    (§ expr handleKey(§ pars key))
                )
            )
        )
        (§ catch #_"Exception" (§ name e))
        (§ block
            (§ expr log.warn(§ pars "Error trying to open/read from connection: ", e))
        )
        (§ finally )
        (§ block
            ;; Go through and close everything, without letting IOExceptions get in our way.
            (§ for (§ var #_"SelectionKey" (§ name key)) :for (§ expr selector.keys(§ pars )))
            (§ block
                (§ try )
                (§ block
                    (§ expr key.channel(§ pars ).close(§ pars ))
                )
                (§ catch #_"IOException" (§ name e))
                (§ block
                    (§ expr log.warn(§ pars "Error closing channel", e))
                )
                (§ expr key.cancel(§ pars ))
                (§ if (§ expr (§ insta (§ dot key.attachment(§ pars )) #_"ConnectionHandler")))
                (§ block
                    (§ expr ConnectionHandler/handleKey(§ pars key)) ;; Close connection if relevant.
                )
            )
            (§ try )
            (§ block
                (§ expr selector.close(§ pars ))
            )
            (§ catch #_"IOException" (§ name e))
            (§ block
                (§ expr log.warn(§ pars "Error closing client manager selector", e))
            )
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"ListenableFuture<SocketAddress>" (§ fn openConnection) [#_"SocketAddress" (§ name serverAddress), #_"StreamConnection" (§ name connection)])
    (§ block
        (§ if (§ expr (§ not isRunning(§ pars ))))
        (§ block
            (§ throw (§ new #_"IllegalStateException" (§ pars )))
        )

        ;; Create a new connection, give it a connection as an attachment.
        (§ try )
        (§ block
            (§ var #_"SocketChannel" (§ name sc) (§ expr SocketChannel/open(§ pars )))
            (§ expr sc.configureBlocking(§ pars false))
            (§ expr sc.connect(§ pars serverAddress))
            (§ var #_"PendingConnect" (§ name data) (§ new #_"PendingConnect" (§ pars sc, connection, serverAddress)))
            (§ expr newConnectionChannels.offer(§ pars data))
            (§ expr selector.wakeup(§ pars ))
            (§ return (§ expr data.future))
        )
        (§ catch #_"Throwable" (§ name e))
        (§ block
            (§ return (§ expr Futures/immediateFailedFuture(§ pars e)))
        )
    )

    #_override
    #_public
    (§ method #_"void" (§ fn triggerShutdown) [])
    (§ block
        (§ expr selector.wakeup(§ pars ))
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"int" (§ fn getConnectedClientCount) [])
    (§ block
        (§ return (§ expr connectedHandlers.size(§ pars )))
    )

    #_override
    #_public
    (§ method #_"void" (§ fn closeConnections) [#_"int" (§ name n)])
    (§ block
        (§ for (§ var ) :for (§ expr 0 < n) :for (§ ass (§ name n) (§ expr n - 1)))
        (§ block
            (§ var #_"ConnectionHandler" (§ name handler))
            (§ sync connectedHandlers)
            (§ block
                (§ ass (§ name handler) (§ expr connectedHandlers.iterator(§ pars ).next(§ pars )))
            )
            (§ if (§ expr handler != nil))
            (§ block
                (§ expr handler.closeConnection(§ pars )) ;; Removes handler from connectedHandlers before returning.
            )
        )
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"Executor" (§ fn executor) [])
    (§ block
        (§ return (§ new #_"Executor" (§ pars ))
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn execute) [#_"Runnable" (§ name command)])
            (§ block
                (§ expr (§ new #_"ContextPropagatingThreadFactory" (§ pars "NioClientManager")).newThread(§ pars command).start(§ pars ))
                (§ void nil)
            )
        ))
    )
)

#_(ns org.bitcoinj.net #_"NioServer"
    (:import [java.io IOException]
             [java.net InetSocketAddress]
             [java.nio.channels *]
             [java.nio.channels.spi SelectorProvider]
             [java.util Iterator])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base Throwables]
             [com.google.common.util.concurrent AbstractExecutionThreadService]
             [org.slf4j Logger LoggerFactory]))

;;;
 ; Creates a simple server listener which listens for incoming client connections and uses a {@link StreamConnection}
 ; to process data.
 ;;
#_public
(§ class #_"NioServer" (§ extends #_"AbstractExecutionThreadService")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"NioServer"))))

    #_private
    #_final
    (§ field #_"StreamConnectionFactory" (§ name connectionFactory))

    #_private
    #_final
    (§ field #_"ServerSocketChannel" (§ name sc))
    #_testing
    #_final
    (§ field #_"Selector" (§ name selector))

    ;; Handle a SelectionKey which was selected.
    #_private
    (§ method #_"void" (§ fn handleKey) [#_"Selector" (§ name selector), #_"SelectionKey" (§ name key)])
        (§ throws #_"IOException")
    (§ block
        (§ if (§ expr key.isValid(§ pars ) && key.isAcceptable(§ pars )))
        (§ block
            ;; Accept a new connection, give it a stream connection as an attachment.
            (§ var #_"SocketChannel" (§ name newChannel) (§ expr sc.accept(§ pars )))
            (§ expr newChannel.configureBlocking(§ pars false))
            (§ var #_"SelectionKey" (§ name newKey) (§ expr newChannel.register(§ pars selector, SelectionKey/OP_READ)))
            (§ try )
            (§ block
                (§ var #_"ConnectionHandler" (§ name handler) (§ new #_"ConnectionHandler" (§ pars connectionFactory, newKey)))
                (§ expr newKey.attach(§ pars handler))
                (§ expr handler.connection.connectionOpened(§ pars ))
            )
            (§ catch #_"IOException" (§ name e))
            (§ block
                ;; This can happen if ConnectionHandler's call to get a new handler returned null.
                (§ expr log.error(§ pars "Error handling new connection", Throwables/getRootCause(§ pars e).getMessage(§ pars )))
                (§ expr newKey.channel(§ pars ).close(§ pars ))
            )
        )
        (§ else ) ;; Got a closing channel or a channel to a client connection.
        (§ block
            (§ expr ConnectionHandler/handleKey(§ pars key))
        )
        (§ void nil)
    )

    ;;;
     ; Creates a new server which is capable of listening for incoming connections and processing client provided data
     ; using {@link StreamConnection}s created by the given {@link StreamConnectionFactory}.
     ;
     ; @throws IOException if there is an issue opening the server socket or binding fails for some reason.
     ;;
    #_public
    (§ constructor #_"NioServer" [#_final #_"StreamConnectionFactory" (§ name connectionFactory), #_"InetSocketAddress" (§ name bindAddress)])
        (§ throws #_"IOException")
    (§ block
        (§ ass (§ name this.connectionFactory) connectionFactory)

        (§ ass (§ name sc) (§ expr ServerSocketChannel/open(§ pars )))
        (§ expr sc.configureBlocking(§ pars false))
        (§ expr sc.socket(§ pars ).bind(§ pars bindAddress))
        (§ ass (§ name selector) (§ expr SelectorProvider/provider(§ pars ).openSelector(§ pars )))
        (§ expr sc.register(§ pars selector, SelectionKey/OP_ACCEPT))
        (§ void this)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn run) [])
        (§ throws #_"Exception")
    (§ block
        (§ try )
        (§ block
            (§ while (§ expr isRunning(§ pars )))
            (§ block
                (§ expr selector.select(§ pars ))

                (§ var #_"Iterator<SelectionKey>" (§ name keyIterator) (§ expr selector.selectedKeys(§ pars ).iterator(§ pars )))
                (§ while (§ expr keyIterator.hasNext(§ pars )))
                (§ block
                    (§ var #_"SelectionKey" (§ name key) (§ expr keyIterator.next(§ pars )))
                    (§ expr keyIterator.remove(§ pars ))

                    (§ expr handleKey(§ pars selector, key))
                )
            )
        )
        (§ catch #_"Exception" (§ name e))
        (§ block
            (§ expr log.error(§ pars "Error trying to open/read from connection: {}", e))
        )
        (§ finally )
        (§ block
            ;; Go through and close everything, without letting IOExceptions get in our way.
            (§ for (§ var #_"SelectionKey" (§ name key)) :for (§ expr selector.keys(§ pars )))
            (§ block
                (§ try )
                (§ block
                    (§ expr key.channel(§ pars ).close(§ pars ))
                )
                (§ catch #_"IOException" (§ name e))
                (§ block
                    (§ expr log.error(§ pars "Error closing channel", e))
                )
                (§ try )
                (§ block
                    (§ expr key.cancel(§ pars ))
                    (§ expr handleKey(§ pars selector, key))
                )
                (§ catch #_"IOException" (§ name e))
                (§ block
                    (§ expr log.error(§ pars "Error closing selection key", e))
                )
            )
            (§ try )
            (§ block
                (§ expr selector.close(§ pars ))
            )
            (§ catch #_"IOException" (§ name e))
            (§ block
                (§ expr log.error(§ pars "Error closing server selector", e))
            )
            (§ try )
            (§ block
                (§ expr sc.close(§ pars ))
            )
            (§ catch #_"IOException" (§ name e))
            (§ block
                (§ expr log.error(§ pars "Error closing server channel", e))
            )
        )
        (§ void nil)
    )

    ;;;
     ; Invoked by the Execution service when it's time to stop.
     ; Calling this method directly will NOT stop the service, call
     ; {@link com.google.common.util.concurrent.AbstractExecutionThreadService#stop()} instead.
     ;;
    #_override
    #_public
    (§ method #_"void" (§ fn triggerShutdown) [])
    (§ block
        ;; Wake up the selector and let the selection thread break its loop as the ExecutionService !isRunning().
        (§ expr selector.wakeup(§ pars ))
        (§ void nil)
    )
)

#_(ns org.bitcoinj.net #_"ProtobufConnection"
    (:import [java.io IOException]
             [java.nio ByteBuffer ByteOrder]
             [java.util.concurrent.atomic AtomicReference]
             [java.util.concurrent.locks ReentrantLock]
             [javax.annotation.concurrent GuardedBy])
    (:import [com.google.common.annotations VisibleForTesting]
             [com.google.common.base Preconditions]
             [com.google.protobuf ByteString MessageLite]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core Utils]
             [org.bitcoinj.utils Threading]))

;;;
 ; <p>A handler which is used in {@link NioServer} and {@link NioClient} to split up incoming data streams
 ; into protobufs and provide an interface for writing protobufs to the connections.</p>
 ;
 ; <p>Messages are encoded with a 4-byte signed integer (big endian) prefix to indicate their length followed
 ; by the serialized protobuf.</p>
 ;;
#_public
(§ class #_"ProtobufConnection<MessageType extends MessageLite>" (§ extends #_"AbstractTimeoutHandler") (§ implements #_"StreamConnection")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"ProtobufConnection"))))

    ;;;
     ; An interface which can be implemented to handle callbacks as new messages are generated and socket events occur.
     ; @param <MessageType> The protobuf type which is used on this socket.
     ;                      This <b>MUST</b> match the MessageType used in the parent {@link ProtobufConnection}.
     ;;
    #_public
    (§ interface #_"Listener<MessageType extends MessageLite>"
        ;;; Called when a new protobuf is received from the remote side. ;;
        (§ method #_"void" (§ fn messageReceived) [#_"ProtobufConnection<MessageType>" (§ name handler), #_"MessageType" (§ name msg)])
        ;;; Called when the connection is opened and available for writing data to. ;;
        (§ method #_"void" (§ fn connectionOpen) [#_"ProtobufConnection<MessageType>" (§ name handler)])
        ;;; Called when the connection is closed and no more data should be provided. ;;
        (§ method #_"void" (§ fn connectionClosed) [#_"ProtobufConnection<MessageType>" (§ name handler)])
    )

    ;; The callback listener.
    #_private
    #_final
    (§ field #_"Listener<MessageType>" (§ name handler))
    ;; The prototype which is used to deserialize messages.
    #_private
    #_final
    (§ field #_"MessageLite" (§ name prototype))

    ;; The maximum message size (NOT INCLUDING LENGTH PREFIX).
    #_final
    (§ field #_"int" (§ name maxMessageSize))

    ;; A temporary buffer used when the message size is larger than the buffer being used by the network code.
    ;; Because the networking code uses a constant size buffer and we want to allow for very large message sizes, we use
    ;; a smaller network buffer per client and only allocate more memory when we need it to deserialize large messages.
    ;; Though this is not in of itself a DoS protection, it allows for handling more legitimate clients per server and
    ;; attacking clients can be made to timeout/get blocked if they are sending crap to fill buffers.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"int" (§ name messageBytesOffset) 0)
    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"byte[]" (§ name messageBytes))
    #_private
    #_final
    (§ field #_"ReentrantLock" (§ name lock) (§ expr Threading/lock(§ pars "ProtobufConnection")))

    #_testing
    #_final
    (§ field #_"AtomicReference<MessageWriteTarget>" (§ name writeTarget) (§ new #_"AtomicReference<>" (§ pars )))

    ;;;
     ; Creates a new protobuf handler.
     ;
     ; @param handler The callback listener.
     ; @param prototype The default instance of the message type used in both directions of this channel.
     ;                  This should be the return value from {@link MessageType#getDefaultInstanceForType()}.
     ; @param maxMessageSize The maximum message size (not including the 4-byte length prefix).
     ;                       Note that this has an upper bound of {@link Integer#MAX_VALUE} - 4.
     ; @param timeoutMillis The timeout between messages before the connection is automatically closed.
     ;                      Only enabled after the connection is established.
     ;;
    #_public
    (§ constructor #_"ProtobufConnection" [#_"Listener<MessageType>" (§ name handler), #_"MessageType" (§ name prototype), #_"int" (§ name maxMessageSize), #_"int" (§ name timeoutMillis)])
    (§ block
        (§ ass (§ name this.handler) handler)
        (§ ass (§ name this.prototype) prototype)
        (§ ass (§ name this.maxMessageSize) (§ expr Math/min(§ pars maxMessageSize, Integer/MAX_VALUE - 4)))
        (§ expr setTimeoutEnabled(§ pars false))
        (§ expr setSocketTimeout(§ pars timeoutMillis))
        (§ void this)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn setWriteTarget) [#_"MessageWriteTarget" (§ name writeTarget)])
    (§ block
        ;; Only allow it to be set once.
        (§ expr Preconditions/checkState(§ pars this.writeTarget.getAndSet(§ pars Preconditions/checkNotNull(§ pars writeTarget)) == nil))
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"int" (§ fn getMaxMessageSize) [])
    (§ block
        (§ return maxMessageSize)
    )

    ;;;
     ; Closes this connection, eventually triggering a {@link ProtobufConnection.Listener#connectionClosed()} event.
     ;;
    #_public
    (§ method #_"void" (§ fn closeConnection) [])
    (§ block
        (§ expr this.writeTarget.get(§ pars ).closeConnection(§ pars ))
        (§ void nil)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn timeoutOccurred) [])
    (§ block
        (§ expr log.warn(§ pars "Timeout occurred for " + handler))
        (§ expr closeConnection(§ pars ))
        (§ void nil)
    )

    ;; Deserializes and provides a listener event (buff must not have the length prefix in it).
    ;; Does set the buffers's position to its limit.
    #_suppress(§ opt "unchecked")
    ;; The warning 'unchecked cast' being suppressed here comes from the build() formally returning
    ;; a MessageLite-derived class that cannot be statically guaranteed to be the MessageType.
    #_private
    (§ method #_"void" (§ fn deserializeMessage) [#_"ByteBuffer" (§ name buff)])
        (§ throws #_"Exception")
    (§ block
        (§ var #_"MessageType" (§ name msg) (§ expr (§ cast #_"MessageType" (§ dot prototype.newBuilderForType(§ pars ).mergeFrom(§ pars ByteString/copyFrom(§ pars buff)).build(§ pars )))))
        (§ expr resetTimeout(§ pars ))
        (§ expr handler.messageReceived(§ pars this, msg))
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"int" (§ fn receiveBytes) [#_"ByteBuffer" (§ name buff)])
        (§ throws #_"Exception")
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr messageBytes != nil))
            (§ block
                ;; Just keep filling up the currently being worked on message.
                (§ var #_"int" (§ name bytesToGet) (§ expr Math/min(§ pars messageBytes.length - messageBytesOffset, buff.remaining(§ pars ))))
                (§ expr buff.get(§ pars messageBytes, messageBytesOffset, bytesToGet))
                (§ ass (§ name messageBytesOffset) (§ expr messageBytesOffset + bytesToGet))
                (§ if (§ expr messageBytesOffset == messageBytes.length))
                (§ block
                    ;; Filled up our buffer, decode the message.
                    (§ expr deserializeMessage(§ pars ByteBuffer/wrap(§ pars messageBytes)))
                    (§ ass (§ name messageBytes) nil)
                    (§ if (§ expr buff.hasRemaining(§ pars )))
                    (§ block
                        (§ return (§ expr bytesToGet + receiveBytes(§ pars buff)))
                    )
                )
                (§ return bytesToGet)
            )

            ;; If we cant read the length prefix yet, give up.
            (§ if (§ expr buff.remaining(§ pars ) < 4))
            (§ block
                (§ return 0)
            )

            ;; Read one integer in big endian.
            (§ expr buff.order(§ pars ByteOrder/BIG_ENDIAN))
            #_final
            (§ var #_"int" (§ name len) (§ expr buff.getInt(§ pars )))

            ;; If length is larger than the maximum message size (or is negative/overflows) throw an exception and close
            ;; the connection.
            (§ if (§ expr maxMessageSize < len || len + 4 < 4))
            (§ block
                (§ throw (§ new #_"IllegalStateException" (§ pars "Message too large or length underflowed")))
            )

            ;; If the buffer's capacity is less than the next messages length + 4 (length prefix), we must use messageBytes
            ;; as a temporary buffer to store the message.
            (§ if (§ expr buff.capacity(§ pars ) < len + 4))
            (§ block
                (§ ass (§ name messageBytes) (§ new #_"byte[]" (§ count len)))
                ;; Now copy all remaining bytes into the new buffer, set messageBytesOffset and tell the caller how many
                ;; bytes we consumed.
                (§ var #_"int" (§ name bytesToRead) (§ expr buff.remaining(§ pars )))
                (§ expr buff.get(§ pars messageBytes, 0, bytesToRead))
                (§ ass (§ name messageBytesOffset) bytesToRead)
                (§ return (§ expr bytesToRead + 4))
            )

            ;; Wait until the whole message is available in the buffer.
            (§ if (§ expr buff.remaining(§ pars ) < len))
            (§ block
                ;; Make sure the buffer's position is right at the end.
                (§ expr buff.position(§ pars buff.position(§ pars ) - 4))
                (§ return 0)
            )

            ;; Temporarily limit the buffer to the size of the message, so that the protobuf decode doesn't get messed up.
            (§ var #_"int" (§ name limit) (§ expr buff.limit(§ pars )))
            (§ expr buff.limit(§ pars buff.position(§ pars ) + len))
            (§ expr deserializeMessage(§ pars buff))
            (§ expr Preconditions/checkState(§ pars buff.remaining(§ pars ) == 0))
            ;; Reset the limit in case we have to recurse.
            (§ expr buff.limit(§ pars limit))

            ;; If there are still bytes remaining, see if we can pull out another message since we won't get called again.
            (§ if (§ expr buff.hasRemaining(§ pars )))
            (§ block
                (§ return (§ expr len + 4 + receiveBytes(§ pars buff)))
            )
            (§ else )
            (§ block
                (§ return (§ expr len + 4))
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method #_"void" (§ fn connectionClosed) [])
    (§ block
        (§ expr handler.connectionClosed(§ pars this))
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn connectionOpened) [])
    (§ block
        (§ expr setTimeoutEnabled(§ pars true))
        (§ expr handler.connectionOpen(§ pars this))
        (§ void nil)
    )

    ;;;
     ; <p>Writes the given message to the other side of the connection, prefixing it with the proper 4-byte prefix.</p>
     ;
     ; <p>Provides a write-order guarantee.</p>
     ;
     ; @throws IllegalStateException if the encoded message is larger than the maximum message size.
     ;;
    #_public
    (§ method #_"void" (§ fn write) [#_"MessageType" (§ name msg)])
        (§ throws #_"IllegalStateException")
    (§ block
        (§ var #_"byte[]" (§ name messageBytes) (§ expr msg.toByteArray(§ pars )))
        (§ expr Preconditions/checkState(§ pars messageBytes.length <= maxMessageSize))

        (§ var #_"byte[]" (§ name messageLength) (§ new #_"byte[]" (§ count 4)))
        (§ expr Utils/uint32ToByteArrayBE(§ pars messageBytes.length, messageLength, 0))
        (§ try )
        (§ block
            (§ var #_"MessageWriteTarget" (§ name target) (§ expr writeTarget.get(§ pars )))
            (§ expr target.writeBytes(§ pars messageLength))
            (§ expr target.writeBytes(§ pars messageBytes))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ expr closeConnection(§ pars ))
        )
        (§ void nil)
    )
)

#_(ns org.bitcoinj.net #_"StreamConnection"
    (:import [java.nio ByteBuffer]))

;;;
 ; A generic handler which is used in {@link NioServer}, {@link NioClient} and {@link BlockingClient} to handle incoming
 ; data streams.
 ;;
#_public
(§ interface #_"StreamConnection"
    ;;; Called when the connection socket is closed. ;;
    (§ method #_"void" (§ fn connectionClosed) [])

    ;;; Called when the connection socket is first opened. ;;
    (§ method #_"void" (§ fn connectionOpened) [])

    ;;;
     ; <p>Called when new bytes are available from the remote end.  This should only ever be called by the single
     ; writeTarget associated with any given StreamConnection, multiple callers will likely confuse implementations.</p>
     ;
     ; Implementers/callers must follow the following conventions exactly:
     ; <ul>
     ; <li>buff will start with its limit set to the position we can read to and its position set to the location we
     ;     will start reading at (always 0).</li>
     ; <li>May read more than one message (recursively) if there are enough bytes available.</li>
     ; <li>Uses some internal buffering to store message which are larger (incl. their length prefix) than buff's
     ;     capacity(), i.e. it is up to this method to ensure we dont run out of buffer space to decode the next message.</li>
     ; <li>buff will end with its limit the same as it was previously, and its position set to the position up to which
     ;     bytes have been read (the same as its return value).</li>
     ; <li>buff must be at least the size of a Bitcoin header (incl. magic bytes).</li>
     ; </ul>
     ;
     ; @return the amount of bytes consumed which should not be provided again.
     ;;
    (§ method #_"int" (§ fn receiveBytes) [#_"ByteBuffer" (§ name buff)])
        (§ throws #_"Exception")

    ;;;
     ; Called when this connection is attached to an upstream write target (i.e. a low-level connection handler).
     ; This writeTarget should be stored and used to close the connection or write data to the socket.
     ;;
    (§ method #_"void" (§ fn setWriteTarget) [#_"MessageWriteTarget" (§ name writeTarget)])

    ;;;
     ; Returns the maximum message size of a message on the socket. This is used in calculating size of buffers
     ; to allocate.
     ;;
    (§ method #_"int" (§ fn getMaxMessageSize) [])
)

#_(ns org.bitcoinj.net #_"StreamConnectionFactory"
    (:import [java.net InetAddress]))

;;;
 ; A factory which generates new {@link StreamConnection}s when a new connection is opened.
 ;;
#_public
(§ interface #_"StreamConnectionFactory"
    ;;;
     ; Returns a new handler or null to have the connection close.
     ; @param inetAddress The client's (IP) address.
     ; @param port The remote port on the client side.
     ;;
    #_nilable
    (§ method #_"StreamConnection" (§ fn getNewConnection) [#_"InetAddress" (§ name inetAddress), #_"int" (§ name port)])
)

#_(ns org.bitcoinj.net.discovery #_"DnsDiscovery"
    (:import [java.net *]
             [java.util *]
             [java.util.concurrent *])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.utils *]))

;;;
 ; <p>Supports peer discovery through DNS.</p>
 ;
 ; <p>Failure to resolve individual host names will not cause an Exception to be thrown.
 ; However, if all hosts passed fail to resolve a PeerDiscoveryException will be thrown during getPeers().</p>
 ;
 ; <p>DNS seeds do not attempt to enumerate every peer on the network.
 ; {@link DnsDiscovery#getPeers(long, java.util.concurrent.TimeUnit)} will return up to 30 random peers
 ; from the set of those returned within the timeout period.  If you want more peers to connect to,
 ; you need to discover them via other means (like addr broadcasts).</p>
 ;;
#_public
(§ class #_"DnsDiscovery" (§ extends #_"MultiplexingDiscovery")
    ;;;
     ; Supports finding peers through DNS A records.  Community run DNS entry points will be used.
     ;
     ; @param netParams Network parameters to be used for port information.
     ;;
    #_public
    (§ constructor #_"DnsDiscovery" [#_"NetworkParameters" (§ name netParams)])
    (§ block
        (§ this (§ pars netParams.getDnsSeeds(§ pars ), netParams))
        (§ void this)
    )

    ;;;
     ; Supports finding peers through DNS A records.
     ;
     ; @param dnsSeeds Host names to be examined for seed addresses.
     ; @param params Network parameters to be used for port information.
     ;;
    #_public
    (§ constructor #_"DnsDiscovery" [#_"String[]" (§ name dnsSeeds), #_"NetworkParameters" (§ name params)])
    (§ block
        (§ super (§ pars params, buildDiscoveries(§ pars params, dnsSeeds)))
        (§ void this)
    )

    #_private
    #_static
    (§ method #_"List<PeerDiscovery>" (§ fn buildDiscoveries) [#_"NetworkParameters" (§ name params), #_"String[]" (§ name seeds)])
    (§ block
        (§ var #_"List<PeerDiscovery>" (§ name discoveries) (§ new #_"ArrayList<>" (§ pars )))
        (§ if (§ expr seeds != nil))
        (§ block
            (§ for (§ var #_"String" (§ name seed)) :for seeds)
            (§ block
                (§ expr discoveries.add(§ pars (§ new #_"DnsSeedDiscovery" (§ pars params, seed))))
            )
        )
        (§ return discoveries)
    )

    #_override
    #_protected
    (§ method #_"ExecutorService" (§ fn createExecutor) [])
    (§ block
        ;; Attempted workaround for reported bugs on Linux in which gethostbyname does not appear to be properly
        ;; thread safe and can cause segfaults on some libc versions.
        (§ if (§ expr System/getProperty(§ pars "os.name").toLowerCase(§ pars ).contains(§ pars "linux")))
        (§ block
            (§ return (§ expr Executors/newSingleThreadExecutor(§ pars (§ new #_"ContextPropagatingThreadFactory" (§ pars "DNS seed lookups")))))
        )
        (§ else )
        (§ block
            (§ return (§ expr Executors/newFixedThreadPool(§ pars seeds.size(§ pars ), new DaemonThreadFactory(§ pars "DNS seed lookups"))))
        )
    )

    ;;; Implements discovery from a single DNS host. ;;
    #_public
    #_static
    (§ class #_"DnsSeedDiscovery" (§ implements #_"PeerDiscovery")
        #_private
        #_final
        (§ field #_"String" (§ name hostname))
        #_private
        #_final
        (§ field #_"NetworkParameters" (§ name params))

        #_public
        (§ constructor #_"DnsSeedDiscovery" [#_"NetworkParameters" (§ name params), #_"String" (§ name hostname)])
        (§ block
            (§ ass (§ name this.hostname) hostname)
            (§ ass (§ name this.params) params)
            (§ void this)
        )

        #_override
        #_public
        (§ method #_"InetSocketAddress[]" (§ fn getPeers) [#_"long" (§ name services), #_"long" (§ name timeoutValue), #_"TimeUnit" (§ name timeoutUnit)])
            (§ throws #_"PeerDiscoveryException")
        (§ block
            (§ if (§ expr services != 0))
            (§ block
                (§ throw (§ new #_"PeerDiscoveryException" (§ pars "DNS seeds cannot filter by services: " + services)))
            )

            (§ try )
            (§ block
                (§ var #_"InetAddress[]" (§ name response) (§ expr InetAddress/getAllByName(§ pars hostname)))
                (§ var #_"InetSocketAddress[]" (§ name result) (§ new #_"InetSocketAddress[]" (§ count response.length)))
                (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < response.length) :for (§ ass (§ name i) (§ expr i + 1)))
                (§ block
                    (§ ass (§ name result[i]) (§ new #_"InetSocketAddress" (§ pars response[i], params.getPort(§ pars ))))
                )
                (§ return result)
            )
            (§ catch #_"UnknownHostException" (§ name e))
            (§ block
                (§ throw (§ new #_"PeerDiscoveryException" (§ pars e)))
            )
        )

        #_override
        #_public
        (§ method #_"void" (§ fn shutdown) [])
        (§ block
            (§ void nil)
        )

        #_override
        #_public
        (§ method #_"String" (§ fn toString) [])
        (§ block
            (§ return hostname)
        )
    )
)

#_(ns org.bitcoinj.net.discovery #_"MultiplexingDiscovery"
    (:import [java.net InetSocketAddress]
             [java.util ArrayList Collections List]
             [java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core NetworkParameters VersionMessage]
             [org.bitcoinj.net.discovery.DnsDiscovery DnsSeedDiscovery]
             [org.bitcoinj.utils *]))

;;;
 ; MultiplexingDiscovery queries multiple PeerDiscovery objects, shuffles their responses and then returns the results,
 ; thus selecting randomly between them and reducing the influence of any particular seed.  Any that don't respond
 ; within the timeout are ignored.  Backends are queried in parallel.  Backends may block.
 ;;
#_public
(§ class #_"MultiplexingDiscovery" (§ implements #_"PeerDiscovery")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"MultiplexingDiscovery"))))

    #_protected
    #_final
    (§ field #_"List<PeerDiscovery>" (§ name seeds))
    #_protected
    #_final
    (§ field #_"NetworkParameters" (§ name netParams))
    #_private
    #_volatile
    (§ field #_"ExecutorService" (§ name vThreadPool))

    ;;;
     ; Builds a suitable set of peer discoveries.  Will query them in parallel before producing a merged response.
     ; If specific services are required, DNS is not used as the protocol can't handle it.
     ; @param params Network to use.
     ; @param services Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     ;;
    #_public
    #_static
    (§ method #_"MultiplexingDiscovery" (§ fn forServices) [#_"NetworkParameters" (§ name params), #_"long" (§ name services)])
    (§ block
        (§ var #_"List<PeerDiscovery>" (§ name discoveries) (§ expr Lists/newArrayList(§ pars )))
        ;; Also use DNS seeds if there is no specific service requirement.
        (§ if (§ expr services == 0))
        (§ block
            (§ var #_"String[]" (§ name dnsSeeds) (§ expr params.getDnsSeeds(§ pars )))
            (§ if (§ expr dnsSeeds != nil))
            (§ block
                (§ for (§ var #_"String" (§ name dnsSeed)) :for dnsSeeds)
                (§ block
                    (§ expr discoveries.add(§ pars (§ new #_"DnsSeedDiscovery" (§ pars params, dnsSeed))))
                )
            )
        )
        (§ return (§ new #_"MultiplexingDiscovery" (§ pars params, discoveries)))
    )

    ;;;
     ; Will query the given seeds in parallel before producing a merged response.
     ;;
    #_public
    (§ constructor #_"MultiplexingDiscovery" [#_"NetworkParameters" (§ name params), #_"List<PeerDiscovery>" (§ name seeds)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars (§ not seeds.isEmpty(§ pars ))))

        (§ ass (§ name this.netParams) params)
        (§ ass (§ name this.seeds) seeds)
        (§ void this)
    )

    #_override
    #_public
    (§ method #_"InetSocketAddress[]" (§ fn getPeers) [#_final #_"long" (§ name services), #_final #_"long" (§ name timeoutValue), #_final #_"TimeUnit" (§ name timeoutUnit)])
        (§ throws #_"PeerDiscoveryException")
    (§ block
        (§ ass (§ name vThreadPool) (§ expr createExecutor(§ pars )))
        (§ try )
        (§ block
            (§ var #_"List<Callable<InetSocketAddress[]>>" (§ name tasks) (§ expr Lists/newArrayList(§ pars )))
            (§ for (§ var #_final PeerDiscovery seed) :for seeds)
            (§ block
                (§ expr tasks.add(§ pars (§ new #_"Callable<InetSocketAddress[]>" (§ pars )
                (§ anon
                    #_override
                    #_public
                    (§ method #_"InetSocketAddress[]" (§ fn call) [])
                        (§ throws #_"Exception")
                    (§ block
                        (§ return (§ expr seed.getPeers(§ pars services, timeoutValue,  timeoutUnit)))
                    )
                ))))
            )
            #_final
            (§ var #_"List<Future<InetSocketAddress[]>>" (§ name futures) (§ expr vThreadPool.invokeAll(§ pars tasks, timeoutValue, timeoutUnit)))
            (§ var #_"ArrayList<InetSocketAddress>" (§ name addrs) (§ expr Lists/newArrayList(§ pars )))
            (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < futures.size(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
            (§ block
                (§ var #_"Future<InetSocketAddress[]>" (§ name future) (§ expr futures.get(§ pars i)))
                (§ if (§ expr future.isCancelled(§ pars )))
                (§ block
                    (§ expr log.warn(§ pars "Seed {}: timed out", seeds.get(§ pars i)))
                    (§ continue ) ;; Timed out.
                )
                #_final
                (§ var #_"InetSocketAddress[]" (§ name inetAddresses))
                (§ try )
                (§ block
                    (§ ass (§ name inetAddresses) (§ expr future.get(§ pars )))
                )
                (§ catch #_"ExecutionException" (§ name e))
                (§ block
                    (§ expr log.warn(§ pars "Seed {}: failed to look up: {}", seeds.get(§ pars i), e.getMessage(§ pars )))
                    (§ continue )
                )
                (§ expr Collections/addAll(§ pars addrs, inetAddresses))
            )
            (§ if (§ expr addrs.size(§ pars ) == 0))
            (§ block
                (§ throw (§ new #_"PeerDiscoveryException" (§ pars "No peer discovery returned any results in " + timeoutUnit.toMillis(§ pars timeoutValue) + "ms. Check internet connection?")))
            )

            (§ expr Collections/shuffle(§ pars addrs))
            (§ expr vThreadPool.shutdownNow(§ pars ))
            (§ return (§ expr addrs.toArray(§ pars (§ new #_"InetSocketAddress[]" (§ count addrs.size(§ pars ))))))
        )
        (§ catch #_"InterruptedException" (§ name e))
        (§ block
            (§ throw (§ new #_"PeerDiscoveryException" (§ pars e)))
        )
        (§ finally )
        (§ block
            (§ expr vThreadPool.shutdown(§ pars ))
        )
    )

    #_protected
    (§ method #_"ExecutorService" (§ fn createExecutor) [])
    (§ block
        (§ return (§ expr Executors/newFixedThreadPool(§ pars seeds.size(§ pars ), new ContextPropagatingThreadFactory(§ pars "Multiplexing discovery"))))
    )

    #_override
    #_public
    (§ method #_"void" (§ fn shutdown) [])
    (§ block
        (§ var #_"ExecutorService" (§ name tp) vThreadPool)
        (§ if (§ expr tp != nil))
        (§ block
            (§ expr tp.shutdown(§ pars ))
        )
        (§ void nil)
    )
)

#_(ns org.bitcoinj.net.discovery #_"PeerDiscovery"
    (:import [java.net InetSocketAddress]
             [java.util.concurrent TimeUnit]))

;;;
 ; A PeerDiscovery object is responsible for finding addresses of other nodes in the Bitcoin P2P network.
 ; Note that the addresses returned may or may not be accepting connections.
 ;;
#_public
(§ interface #_"PeerDiscovery"
    ;; TODO: Flesh out this interface a lot more.

    ;;;
     ; Returns an array of addresses.  This method may block.
     ; @param services Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     ;;
    (§ method #_"InetSocketAddress[]" (§ fn getPeers) [#_"long" (§ name services), #_"long" (§ name timeoutValue), #_"TimeUnit" (§ name timeoutUnit)])
        (§ throws #_"PeerDiscoveryException")

    ;;; Stops any discovery in progress when we want to shut down quickly. ;;
    (§ method #_"void" (§ fn shutdown) [])
)

#_(ns org.bitcoinj.net.discovery #_"PeerDiscoveryException")

#_public
(§ class #_"PeerDiscoveryException" (§ extends #_"Exception")
    #_public
    (§ constructor #_"PeerDiscoveryException" [])
    (§ block
        (§ super (§ pars ))
        (§ void this)
    )

    #_public
    (§ constructor #_"PeerDiscoveryException" [#_"String" (§ name message)])
    (§ block
        (§ super (§ pars message))
        (§ void this)
    )

    #_public
    (§ constructor #_"PeerDiscoveryException" [#_"Throwable" (§ name arg0)])
    (§ block
        (§ super (§ pars arg0))
        (§ void this)
    )

    #_public
    (§ constructor #_"PeerDiscoveryException" [#_"String" (§ name message), #_"Throwable" (§ name arg0)])
    (§ block
        (§ super (§ pars message, arg0))
        (§ void this)
    )
)

#_(ns org.bitcoinj.net.discovery #_"SeedPeers"
    (:import [java.net InetAddress InetSocketAddress UnknownHostException]
             [java.util.concurrent TimeUnit])
   (:require [org.bitcoinj.core NetworkParameters]))

;;;
 ; SeedPeers stores a pre-determined list of Bitcoin node addresses.  These nodes are selected based on
 ; being active on the network for a long period of time.  The intention is to be a last resort way of finding
 ; a connection to the network, in case IRC and DNS fail.  The list comes from the Bitcoin C++ source code.
 ;;
#_public
(§ class #_"SeedPeers" (§ implements #_"PeerDiscovery")
    #_private
    (§ field #_"NetworkParameters" (§ name params))
    #_private
    (§ field #_"int[]" (§ name seedAddrs))
    #_private
    (§ field #_"int" (§ name pnseedIndex))

    ;;;
     ; Supports finding peers by IP addresses.
     ;
     ; @param params Network parameters to be used for port information.
     ;;
    #_public
    (§ constructor #_"SeedPeers" [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ this (§ pars params.getAddrSeeds(§ pars ), params))
        (§ void this)
    )

    ;;;
     ; Supports finding peers by IP addresses.
     ;
     ; @param seedAddrs IP addresses for seed addresses.
     ; @param params Network parameters to be used for port information.
     ;;
    #_public
    (§ constructor #_"SeedPeers" [#_"int[]" (§ name seedAddrs), #_"NetworkParameters" (§ name params)])
    (§ block
        (§ ass (§ name this.seedAddrs) seedAddrs)
        (§ ass (§ name this.params) params)
        (§ void this)
    )

    ;;;
     ; Acts as an iterator, returning the address of each node in the list sequentially.
     ; Once all the list has been iterated, null will be returned for each subsequent query.
     ;
     ; @return InetSocketAddress - the address/port of the next node.
     ; @throws PeerDiscoveryException
     ;;
    #_nilable
    #_public
    (§ method #_"InetSocketAddress" (§ fn getPeer) [])
        (§ throws #_"PeerDiscoveryException")
    (§ block
        (§ try )
        (§ block
            (§ return (§ expr nextPeer(§ pars )))
        )
        (§ catch #_"UnknownHostException" (§ name e))
        (§ block
            (§ throw (§ new #_"PeerDiscoveryException" (§ pars e)))
        )
    )

    #_nilable
    #_private
    (§ method #_"InetSocketAddress" (§ fn nextPeer) [])
        (§ throws #_"UnknownHostException", #_"PeerDiscoveryException")
    (§ block
        (§ if (§ expr seedAddrs == nil || seedAddrs.length == 0))
        (§ block
            (§ throw (§ new #_"PeerDiscoveryException" (§ pars "No IP address seeds configured; unable to find any peers")))
        )

        (§ if (§ expr seedAddrs.length <= pnseedIndex))
        (§ block
            (§ return nil)
        )

        (§ var #_"int" (§ name i) pnseedIndex)
        (§ ass (§ name pnseedIndex) (§ expr pnseedIndex + 1))
        (§ return (§ new #_"InetSocketAddress" (§ pars convertAddress(§ pars seedAddrs[i]), params.getPort(§ pars ))))
    )

    ;;;
     ; Returns an array containing all the Bitcoin nodes within the list.
     ;;
    #_override
    #_public
    (§ method #_"InetSocketAddress[]" (§ fn getPeers) [#_"long" (§ name services), #_"long" (§ name timeoutValue), #_"TimeUnit" (§ name timeoutUnit)])
        (§ throws #_"PeerDiscoveryException")
    (§ block
        (§ if (§ expr services != 0))
        (§ block
            (§ throw (§ new #_"PeerDiscoveryException" (§ pars "Pre-determined peers cannot be filtered by services: " + services)))
        )

        (§ try )
        (§ block
            (§ return (§ expr allPeers(§ pars )))
        )
        (§ catch #_"UnknownHostException" (§ name e))
        (§ block
            (§ throw (§ new #_"PeerDiscoveryException" (§ pars e)))
        )
    )

    #_private
    (§ method #_"InetSocketAddress[]" (§ fn allPeers) [])
        (§ throws #_"UnknownHostException")
    (§ block
        (§ var #_"InetSocketAddress[]" (§ name addresses) (§ new #_"InetSocketAddress[]" (§ count seedAddrs.length)))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < seedAddrs.length) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ ass (§ name addresses[i]) (§ new #_"InetSocketAddress" (§ pars convertAddress(§ pars seedAddrs[i]), params.getPort(§ pars ))))
        )
        (§ return addresses)
    )

    #_private
    (§ method #_"InetAddress" (§ fn convertAddress) [#_"int" (§ name seed)])
        (§ throws #_"UnknownHostException")
    (§ block
        (§ var #_"byte[]" (§ name v4addr) (§ new #_"byte[]" (§ count 4)))
        (§ ass (§ name v4addr[0]) (§ cast #_"byte" (§ expr 0xff & seed)))
        (§ ass (§ name v4addr[1]) (§ cast #_"byte" (§ expr 0xff & (§ expr seed >> 8))))
        (§ ass (§ name v4addr[2]) (§ cast #_"byte" (§ expr 0xff & (§ expr seed >> 16))))
        (§ ass (§ name v4addr[3]) (§ cast #_"byte" (§ expr 0xff & (§ expr seed >> 24))))
        (§ return (§ expr InetAddress/getByAddress(§ pars v4addr)))
    )

    #_override
    #_public
    (§ method #_"void" (§ fn shutdown) [])
    (§ block
        (§ void nil)
    )
)

#_(ns org.bitcoinj.params #_"AbstractBitcoinNetParams"
    (:import [java.math BigInteger]
             [java.util.concurrent TimeUnit])
    (:import [com.google.common.base Preconditions Stopwatch]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core BitcoinSerializer Block Coin NetworkParameters Sha256Hash StoredBlock Transaction Utils VerificationException]
             [org.bitcoinj.utils MonetaryFormat]
             [org.bitcoinj.store BlockStore BlockStoreException]))

;;;
 ; Parameters for Bitcoin-like networks.
 ;;
#_public
#_abstract
(§ class #_"AbstractBitcoinNetParams" (§ extends #_"NetworkParameters")
    ;;;
     ; Scheme part for Bitcoin URIs.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name BITCOIN_SCHEME) (§ expr "bitcoin"))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name REWARD_HALVING_INTERVAL) 210000)

    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"AbstractBitcoinNetParams"))))

    #_public
    (§ constructor #_"AbstractBitcoinNetParams" [])
    (§ block
        (§ super (§ pars ))
        (§ void this)
    )

    ;;;
     ; Checks if we are at a reward halving point.
     ; @param height The height of the previous stored block.
     ; @return if this is a reward halving point.
     ;;
    #_public
    #_final
    (§ method #_"boolean" (§ fn isRewardHalvingPoint) [#_final #_"int" (§ name height)])
    (§ block
        (§ return (§ expr (§ expr (§ expr height + 1) % REWARD_HALVING_INTERVAL) == 0))
    )

    ;;;
     ; Checks if we are at a difficulty transition point.
     ; @param height The height of the previous stored block.
     ; @return if this is a difficulty transition point.
     ;;
    #_public
    #_final
    (§ method #_"boolean" (§ fn isDifficultyTransitionPoint) [#_final #_"int" (§ name height)])
    (§ block
        (§ return (§ expr (§ expr (§ expr height + 1) % this.getInterval(§ pars )) == 0))
    )

    #_override
    #_public
    (§ method #_"void" (§ fn checkDifficultyTransitions) [#_final #_"StoredBlock" (§ name storedPrev), #_final #_"Block" (§ name nextBlock), #_final #_"BlockStore" (§ name blockStore)])
        (§ throws #_"VerificationException", #_"BlockStoreException")
    (§ block
        #_final
        (§ var #_"Block" (§ name prev) (§ expr storedPrev.getHeader(§ pars )))

        ;; Is this supposed to be a difficulty transition point?
        (§ if (§ expr (§ not isDifficultyTransitionPoint(§ pars storedPrev.getHeight(§ pars )))))
        (§ block
            ;; No ... so check the difficulty didn't actually change.
            (§ if (§ expr nextBlock.getDifficultyTarget(§ pars ) != prev.getDifficultyTarget(§ pars )))
            (§ block
                (§ throw (§ new #_"VerificationException" (§ pars "Unexpected change in difficulty at height " + storedPrev.getHeight(§ pars ) + ": " + Long/toHexString(§ pars nextBlock.getDifficultyTarget(§ pars )) + " vs " + Long/toHexString(§ pars prev.getDifficultyTarget(§ pars )))))
            )
            (§ return nil)
        )

        ;; We need to find a block far back in the chain.  It's OK that this is expensive because it only occurs every
        ;; two weeks after the initial block chain download.
        #_final
        (§ var #_"Stopwatch" (§ name watch) (§ expr Stopwatch/createStarted(§ pars )))

        (§ var #_"Sha256Hash" (§ name hash) (§ expr prev.getHash(§ pars )))
        (§ var #_"StoredBlock" (§ name cursor) nil)
        #_final
        (§ var #_"int" (§ name interval) (§ expr this.getInterval(§ pars )))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < interval) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ ass (§ name cursor) (§ expr blockStore.get(§ pars hash)))
            (§ if (§ expr cursor == nil))
            (§ block
                ;; This should never happen.  If it does, it means we are following an incorrect or busted chain.
                (§ throw (§ new #_"VerificationException" (§ pars "Difficulty transition point but we did not find a way back to the last transition point. Not found: " + hash)))
            )
            (§ ass (§ name hash) (§ expr cursor.getHeader(§ pars ).getPrevBlockHash(§ pars )))
        )
        (§ expr Preconditions/checkState(§ pars cursor != nil && isDifficultyTransitionPoint(§ pars cursor.getHeight(§ pars ) - 1), "Didn't arrive at a transition point."))

        (§ expr watch.stop(§ pars ))
        (§ if (§ expr 50 < watch.elapsed(§ pars TimeUnit/MILLISECONDS)))
        (§ block
            (§ expr log.info(§ pars "Difficulty transition traversal took {}", watch))
        )

        (§ var #_"Block" (§ name blockIntervalAgo) (§ expr cursor.getHeader(§ pars )))
        (§ var #_"int" (§ name timespan) (§ expr (§ cast #_"int" (§ expr prev.getTimeSeconds(§ pars ) - blockIntervalAgo.getTimeSeconds(§ pars )))))
        ;; Limit the adjustment step.
        #_final
        (§ var #_"int" (§ name targetTimespan) (§ expr this.getTargetTimespan(§ pars )))
        (§ if (§ expr timespan < targetTimespan / 4))
        (§ block
            (§ ass (§ name timespan) (§ expr targetTimespan / 4))
        )
        (§ if (§ expr timespan > targetTimespan * 4))
        (§ block
            (§ ass (§ name timespan) (§ expr targetTimespan * 4))
        )

        (§ var #_"BigInteger" (§ name newTarget) (§ expr Utils/decodeCompactBits(§ pars prev.getDifficultyTarget(§ pars ))))
        (§ ass (§ name newTarget) (§ expr newTarget.multiply(§ pars BigInteger/valueOf(§ pars timespan))))
        (§ ass (§ name newTarget) (§ expr newTarget.divide(§ pars BigInteger/valueOf(§ pars targetTimespan))))

        (§ if (§ expr 0 < newTarget.compareTo(§ pars this.getMaxTarget(§ pars ))))
        (§ block
            (§ expr log.info(§ pars "Difficulty hit proof of work limit: {}", newTarget.toString(§ pars 16)))
            (§ ass (§ name newTarget) (§ expr this.getMaxTarget(§ pars )))
        )

        (§ var #_"int" (§ name accuracyBytes) (§ expr (§ cast #_"int" (§ expr nextBlock.getDifficultyTarget(§ pars ) >>> 24)) - 3))
        (§ var #_"long" (§ name receivedTargetCompact) (§ expr nextBlock.getDifficultyTarget(§ pars )))

        ;; The calculated difficulty is to a higher precision than received, so reduce here.
        (§ var #_"BigInteger" (§ name mask) (§ expr BigInteger/valueOf(§ pars 0xffffff).shiftLeft(§ pars accuracyBytes * 8)))
        (§ ass (§ name newTarget) (§ expr newTarget.and(§ pars mask)))
        (§ var #_"long" (§ name newTargetCompact) (§ expr Utils/encodeCompactBits(§ pars newTarget)))

        (§ if (§ expr newTargetCompact != receivedTargetCompact))
        (§ block
            (§ throw (§ new #_"VerificationException" (§ pars "Network provided difficulty bits do not match what was calculated: " + Long/toHexString(§ pars newTargetCompact) + " vs " + Long/toHexString(§ pars receivedTargetCompact))))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"Coin" (§ fn getMaxMoney) [])
    (§ block
        (§ return (§ expr MAX_MONEY))
    )

    #_override
    #_public
    (§ method #_"Coin" (§ fn getMinNonDustOutput) [])
    (§ block
        (§ return (§ expr Transaction/MIN_NONDUST_OUTPUT))
    )

    #_override
    #_public
    (§ method #_"MonetaryFormat" (§ fn getMonetaryFormat) [])
    (§ block
        (§ return (§ new #_"MonetaryFormat" (§ pars )))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn getProtocolVersionNum) [#_final #_"ProtocolVersion" (§ name version)])
    (§ block
        (§ return (§ expr version.getBitcoinProtocolVersion(§ pars )))
    )

    #_override
    #_public
    (§ method #_"BitcoinSerializer" (§ fn getSerializer) [#_"boolean" (§ name parseRetain)])
    (§ block
        (§ return (§ new #_"BitcoinSerializer" (§ pars this, parseRetain)))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn getUriScheme) [])
    (§ block
        (§ return (§ expr BITCOIN_SCHEME))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn hasMaxMoney) [])
    (§ block
        (§ return true)
    )
)

#_(ns org.bitcoinj.params #_"MainNetParams"
    (:import [java.net *])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.net.discovery *]))

;;;
 ; Parameters for the main production network on which people trade goods and services.
 ;;
#_public
(§ class #_"MainNetParams" (§ extends #_"AbstractBitcoinNetParams")
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name MAINNET_MAJORITY_WINDOW) 1000)
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name MAINNET_MAJORITY_REJECT_BLOCK_OUTDATED) 950)
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name MAINNET_MAJORITY_ENFORCE_BLOCK_UPGRADE) 750)

    #_public
    (§ constructor #_"MainNetParams" [])
    (§ block
        (§ super (§ pars ))

        (§ ass (§ name interval) (§ expr INTERVAL))
        (§ ass (§ name targetTimespan) (§ expr TARGET_TIMESPAN))
        (§ ass (§ name maxTarget) (§ expr Utils/decodeCompactBits(§ pars 0x1d00ffff)))
        (§ ass (§ name addressHeader) 0)
        (§ ass (§ name p2shHeader) 5)
        (§ ass (§ name acceptableAddressCodes) (§ new #_"int[]" (§ coll addressHeader, p2shHeader )))
        (§ ass (§ name port) 8333)
        (§ ass (§ name packetMagic) (§ expr 0xf9beb4d9))
        (§ ass (§ name bip32HeaderPub) (§ expr 0x0488b21e)) ;; 4 byte header that serializes in base58 to "xpub"
        (§ ass (§ name bip32HeaderPriv) (§ expr 0x0488ade4)) ;; 4 byte header that serializes in base58 to "xprv"

        (§ ass (§ name majorityEnforceBlockUpgrade) (§ expr MAINNET_MAJORITY_ENFORCE_BLOCK_UPGRADE))
        (§ ass (§ name majorityRejectBlockOutdated) (§ expr MAINNET_MAJORITY_REJECT_BLOCK_OUTDATED))
        (§ ass (§ name majorityWindow) (§ expr MAINNET_MAJORITY_WINDOW))

        (§ expr genesisBlock.setDifficultyTarget(§ pars 0x1d00ffff))
        (§ expr genesisBlock.setTime(§ pars 1231006505))
        (§ expr genesisBlock.setNonce(§ pars 2083236893))
        (§ ass (§ name id) (§ expr ID_MAINNET))
        (§ ass (§ name subsidyDecreaseBlockCount) 210000)
        (§ ass (§ name spendableCoinbaseDepth) 100)
        (§ var #_"String" (§ name genesisHash) (§ expr genesisBlock.getHashAsString(§ pars )))
        (§ expr Preconditions/checkState(§ pars genesisHash.equals(§ pars "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f"), genesisHash))

        ;; This contains (at a minimum) the blocks which are not BIP30 compliant.  BIP30 changed how duplicate
        ;; transactions are handled.  Duplicated transactions could occur in the case where a coinbase had the same
        ;; extraNonce and the same outputs but appeared at different heights, and greatly complicated re-org handling.
        ;; Having these here simplifies block connection logic considerably.
        (§ expr checkpoints.put(§ pars 91722, Sha256Hash/wrap(§ pars "00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e")))
        (§ expr checkpoints.put(§ pars 91812, Sha256Hash/wrap(§ pars "00000000000af0aed4792b1acee3d966af36cf5def14935db8de83d6f9306f2f")))
        (§ expr checkpoints.put(§ pars 91842, Sha256Hash/wrap(§ pars "00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec")))
        (§ expr checkpoints.put(§ pars 91880, Sha256Hash/wrap(§ pars "00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721")))
        (§ expr checkpoints.put(§ pars 200000, Sha256Hash/wrap(§ pars "000000000000034a7dedef4a161fa058a2d67a173a90155f3a2fe6fc132e0ebf")))

        (§ ass (§ name dnsSeeds) (§ new #_"String[]"
        (§ coll
            "seed.bitcoin.sipa.be",          ;; Pieter Wuille
            "dnsseed.bluematt.me",           ;; Matt Corallo
            "dnsseed.bitcoin.dashjr.org",    ;; Luke Dashjr
            "seed.bitcoinstats.com",         ;; Chris Decker
            "seed.bitnodes.io",              ;; Addy Yeow
            "bitseed.xf2.org",               ;; Jeff Garzik
            "seed.bitcoin.jonasschnelli.ch", ;; Jonas Schnelli
        )))

        (§ ass (§ name addrSeeds) (§ new #_"int[]"
        (§ coll
                0x1ddb1032, 0x6242ce40, 0x52d6a445, 0x2dd7a445, 0x8a53cd47, 0x73263750, 0xda23c257, 0xecd4ed57,
                0x0a40ec59, 0x75dce160, 0x7df76791, 0x89370bad, 0xa4f214ad, 0x767700ae, 0x638b0418, 0x868a1018,
                0xcd9f332e, 0x0129653e, 0xcc92dc3e, 0x96671640, 0x56487e40, 0x5b66f440, 0xb1d01f41, 0xf1dc6041,
                0xc1d12b42, 0x86ba1243, 0x6be4df43, 0x6d4cef43, 0xd18e0644, 0x1ab0b344, 0x6584a345, 0xe7c1a445,
                0x58cea445, 0xc5daa445, 0x21dda445, 0x3d3b5346, 0x13e55347, 0x1080d24a, 0x8e611e4b, 0x81518e4b,
                0x6c839e4b, 0xe2ad0a4c, 0xfbbc0a4c, 0x7f5b6e4c, 0x7244224e, 0x1300554e, 0x20690652, 0x5a48b652,
                0x75c5c752, 0x4335cc54, 0x340fd154, 0x87c07455, 0x087b2b56, 0x8a133a57, 0xac23c257, 0x70374959,
                0xfb63d45b, 0xb9a1685c, 0x180d765c, 0x674f645d, 0x04d3495e, 0x1de44b5e, 0x4ee8a362, 0x0ded1b63,
                0xc1b04b6d, 0x8d921581, 0x97b7ea82, 0x1cf83a8e, 0x91490bad, 0x09dc75ae, 0x9a6d79ae, 0xa26d79ae,
                0x0fd08fae, 0x0f3e3fb2, 0x4f944fb2, 0xcca448b8, 0x3ecd6ab8, 0xa9d5a5bc, 0x8d0119c1, 0x045997d5,
                0xca019dd9, 0x0d526c4d, 0xabf1ba44, 0x66b1ab55, 0x1165f462, 0x3ed7cbad, 0xa38fae6e, 0x3bd2cbad,
                0xd36f0547, 0x20df7840, 0x7a337742, 0x549f8e4b, 0x9062365c, 0xd399f562, 0x2b5274a1, 0x8edfa153,
                0x3bffb347, 0x7074bf58, 0xb74fcbad, 0x5b5a795b, 0x02fa29ce, 0x5a6738d4, 0xe8a1d23e, 0xef98c445,
                0x4b0f494c, 0xa2bc1e56, 0x7694ad63, 0xa4a800c3, 0x05fda6cd, 0x9f22175e, 0x364a795b, 0x536285d5,
                0xac44c9d4, 0x0b06254d, 0x150c2fd4, 0x32a50dcc, 0xfd79ce48, 0xf15cfa53, 0x66c01e60, 0x6bc26661,
                0xc03b47ae, 0x4dda1b81, 0x3285a4c1, 0x883ca96d, 0x35d60a4c, 0xdae09744, 0x2e314d61, 0x84e247cf,
                0x6c814552, 0x3a1cc658, 0x98d8f382, 0xe584cb5b, 0x15e86057, 0x7b01504e, 0xd852dd48, 0x56382f56,
                0x0a5df454, 0xa0d18d18, 0x2e89b148, 0xa79c114c, 0xcbdcd054, 0x5523bc43, 0xa9832640, 0x8a066144,
                0x3894c3bc, 0xab76bf58, 0x6a018ac1, 0xfebf4f43, 0x2f26c658, 0x31102f4e, 0x85e929d5, 0x2a1c175e,
                0xfc6c2cd1, 0x27b04b6d, 0xdf024650, 0x161748b8, 0x28be6580, 0x57be6580, 0x1cee677a, 0xaa6bb742,
                0x9a53964b, 0x0a5a2d4d, 0x2434c658, 0x9a494f57, 0x1ebb0e48, 0xf610b85d, 0x077ecf44, 0x085128bc,
                0x5ba17a18, 0x27ca1b42, 0xf8a00b56, 0xfcd4c257, 0xcf2fc15e, 0xd897e052, 0x4cada04f, 0x2f35f6d5,
                0x382ce8c9, 0xe523984b, 0x3f946846, 0x60c8be43, 0x41da6257, 0xde0be142, 0xae8a544b, 0xeff0c254,
                0x1e0f795b, 0xaeb28890, 0xca16acd9, 0x1e47ddd8, 0x8c8c4829, 0xd27dc747, 0xd53b1663, 0x4096b163,
                0x9c8dd958, 0xcb12f860, 0x9e79305c, 0x40c1a445, 0x4a90c2bc, 0x2c3a464d, 0x2727f23c, 0x30b04b6d,
                0x59024cb8, 0xa091e6ad, 0x31b04b6d, 0xc29d46a6, 0x63934fb2, 0xd9224dbe, 0x9f5910d8, 0x7f530a6b,
                0x752e9c95, 0x65453548, 0xa484be46, 0xce5a1b59, 0x710e0718, 0x46a13d18, 0xdaaf5318, 0xc4a8ff53,
                0x87abaa52, 0xb764cf51, 0xb2025d4a, 0x6d351e41, 0xc035c33e, 0xa432c162, 0x61ef34ae, 0xd16fddbc,
                0x0870e8c1, 0x3070e8c1, 0x9c71e8c1, 0xa4992363, 0x85a1f663, 0x4184e559, 0x18d96ed8, 0x17b8dbd5,
                0x60e7cd18, 0xe5ee104c, 0xab17ac62, 0x1e786e1b, 0x5d23b762, 0xf2388fae, 0x88270360, 0x9e5b3d80,
                0x7da518b2, 0xb5613b45, 0x1ad41f3e, 0xd550854a, 0x8617e9a9, 0x925b229c, 0xf2e92542, 0x47af0544,
                0x73b5a843, 0xb9b7a0ad, 0x03a748d0, 0x0a6ff862, 0x6694df62, 0x3bfac948, 0x8e098f4f, 0x746916c3,
                0x02f38e4f, 0x40bb1243, 0x6a54d162, 0x6008414b, 0xa513794c, 0x514aa343, 0x63781747, 0xdbb6795b,
                0xed065058, 0x42d24b46, 0x1518794c, 0x9b271681, 0x73e4ffad, 0x0654784f, 0x438dc945, 0x641846a6,
                0x2d1b0944, 0x94b59148, 0x8d369558, 0xa5a97662, 0x8b705b42, 0xce9204ae, 0x8d584450, 0x2df61555,
                0xeebff943, 0x2e75fb4d, 0x3ef8fc57, 0x9921135e, 0x8e31042e, 0xb5afad43, 0x89ecedd1, 0x9cfcc047,
                0x8fcd0f4c, 0xbe49f5ad, 0x146a8d45, 0x98669ab8, 0x98d9175e, 0xd1a8e46d, 0x839a3ab8, 0x40a0016c,
                0x6d27c257, 0x977fffad, 0x7baa5d5d, 0x1213be43, 0xb167e5a9, 0x640fe8ca, 0xbc9ea655, 0x0f820a4c,
                0x0f097059, 0x69ac957c, 0x366d8453, 0xb1ba2844, 0x8857f081, 0x70b5be63, 0xc545454b, 0xaf36ded1,
                0xb5a4b052, 0x21f062d1, 0x72ab89b2, 0x74a45318, 0x8312e6bc, 0xb916965f, 0x8aa7c858, 0xfe7effad,
        )))
        (§ void this)
    )

    #_private
    #_static
    (§ field #_"MainNetParams" (§ name instance))

    #_public
    #_static
    #_synchronized
    (§ method #_"MainNetParams" (§ fn get) [])
    (§ block
        (§ if (§ expr instance == nil))
        (§ block
            (§ ass (§ name instance) (§ new #_"MainNetParams" (§ pars )))
        )
        (§ return instance)
    )

    #_override
    #_public
    (§ method #_"String" (§ fn getPaymentProtocolId) [])
    (§ block
        (§ return (§ expr PAYMENT_PROTOCOL_ID_MAINNET))
    )
)

#_(ns org.bitcoinj.params #_"Networks"
    (:import [java.util Collection Set])
    (:import [com.google.common.collect ImmutableSet Lists])
   (:require [org.bitcoinj.core NetworkParameters]))

;;;
 ; Utility class that holds all the registered NetworkParameters types used for Address auto discovery.
 ; By default only MainNetParams and TestNet3Params are used.  If you want to use UnitTestParams, use
 ; the register and unregister the TestNet3Params as they don't have their own address version/type code.
 ;;
#_public
(§ class #_"Networks"
    ;;; Registered networks. ;;
    #_private
    #_static
    (§ field #_"Set<? extends NetworkParameters>" (§ name networks) (§ expr ImmutableSet/of(§ pars TestNet3Params/get(§ pars ), MainNetParams/get(§ pars ))))

    #_public
    #_static
    (§ method #_"Set<? extends NetworkParameters>" (§ fn get) [])
    (§ block
        (§ return networks)
    )

    #_public
    #_static
    (§ method #_"void" (§ fn register) [#_"NetworkParameters" (§ name network)])
    (§ block
        (§ expr register(§ pars Lists/newArrayList(§ pars network)))
        (§ void nil)
    )

    #_public
    #_static
    (§ method #_"void" (§ fn register) [#_"Collection<? extends NetworkParameters>" (§ name networks)])
    (§ block
        (§ var #_"ImmutableSet.Builder<NetworkParameters>" (§ name builder) (§ expr ImmutableSet/builder(§ pars )))
        (§ expr builder.addAll(§ pars Networks.networks))
        (§ expr builder.addAll(§ pars networks))
        (§ ass (§ name Networks.networks) (§ expr builder.build(§ pars )))
        (§ void nil)
    )

    #_public
    #_static
    (§ method #_"void" (§ fn unregister) [#_"NetworkParameters" (§ name network)])
    (§ block
        (§ if (§ expr networks.contains(§ pars network)))
        (§ block
            (§ var #_"ImmutableSet.Builder<NetworkParameters>" (§ name builder) (§ expr ImmutableSet/builder(§ pars )))

            (§ for (§ var #_"NetworkParameters" (§ name parameters)) :for networks)
            (§ block
                (§ if (§ expr (§ not parameters.equals(§ pars network))))
                (§ block
                    (§ expr builder.add(§ pars parameters))
                )
            )

            (§ ass (§ name networks) (§ expr builder.build(§ pars )))
        )
        (§ void nil)
    )
)

#_(ns org.bitcoinj.params #_"TestNet3Params"
    (:import [java.math BigInteger]
             [java.util Date])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.core Block NetworkParameters StoredBlock Utils VerificationException]
             [org.bitcoinj.store BlockStore BlockStoreException]))

;;;
 ; Parameters for the testnet, a separate public instance of Bitcoin that has relaxed rules suitable for development
 ; and testing of applications and new Bitcoin versions.
 ;;
#_public
(§ class #_"TestNet3Params" (§ extends #_"AbstractBitcoinNetParams")
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name TESTNET_MAJORITY_WINDOW) 100)
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name TESTNET_MAJORITY_REJECT_BLOCK_OUTDATED) 75)
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name TESTNET_MAJORITY_ENFORCE_BLOCK_UPGRADE) 51)

    #_public
    (§ constructor #_"TestNet3Params" [])
    (§ block
        (§ super (§ pars ))

        (§ ass (§ name id) (§ expr ID_TESTNET))
        (§ ass (§ name packetMagic) (§ expr 0x0b110907))
        (§ ass (§ name interval) (§ expr INTERVAL))
        (§ ass (§ name targetTimespan) (§ expr TARGET_TIMESPAN))
        (§ ass (§ name maxTarget) (§ expr Utils/decodeCompactBits(§ pars 0x1d00ffff)))
        (§ ass (§ name port) 18333)
        (§ ass (§ name addressHeader) 111)
        (§ ass (§ name p2shHeader) 196)
        (§ ass (§ name acceptableAddressCodes) (§ new #_"int[]" (§ coll addressHeader, p2shHeader )))
        (§ expr genesisBlock.setTime(§ pars 1296688602))
        (§ expr genesisBlock.setDifficultyTarget(§ pars 0x1d00ffff))
        (§ expr genesisBlock.setNonce(§ pars 414098458))
        (§ ass (§ name spendableCoinbaseDepth) 100)
        (§ ass (§ name subsidyDecreaseBlockCount) 210000)
        (§ var #_"String" (§ name genesisHash) (§ expr genesisBlock.getHashAsString(§ pars )))
        (§ expr Preconditions/checkState(§ pars genesisHash.equals(§ pars "000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943")))
        (§ ass (§ name alertSigningKey) (§ expr Utils/HEX.decode(§ pars "04302390343f91cc401d56d68b123028bf52e5fca1939df127f63c6467cdf9c8e2c14b61104cf817d0b780da337893ecc4aaff1309e536162dabbdb45200ca2b0a")))

        (§ ass (§ name dnsSeeds) (§ new #_"String[]"
        (§ coll
            "testnet-seed.bitcoin.jonasschnelli.ch", ;; Jonas Schnelli
            "testnet-seed.bluematt.me",              ;; Matt Corallo
            "testnet-seed.bitcoin.petertodd.org",    ;; Peter Todd
            "testnet-seed.bitcoin.schildbach.de",    ;; Andreas Schildbach
        )))
        (§ ass (§ name addrSeeds) nil)
        (§ ass (§ name bip32HeaderPub) (§ expr 0x043587cf))
        (§ ass (§ name bip32HeaderPriv) (§ expr 0x04358394))

        (§ ass (§ name majorityEnforceBlockUpgrade) (§ expr TESTNET_MAJORITY_ENFORCE_BLOCK_UPGRADE))
        (§ ass (§ name majorityRejectBlockOutdated) (§ expr TESTNET_MAJORITY_REJECT_BLOCK_OUTDATED))
        (§ ass (§ name majorityWindow) (§ expr TESTNET_MAJORITY_WINDOW))
        (§ void this)
    )

    #_private
    #_static
    (§ field #_"TestNet3Params" (§ name instance))

    #_public
    #_static
    #_synchronized
    (§ method #_"TestNet3Params" (§ fn get) [])
    (§ block
        (§ if (§ expr instance == nil))
        (§ block
            (§ ass (§ name instance) (§ new #_"TestNet3Params" (§ pars )))
        )
        (§ return instance)
    )

    #_override
    #_public
    (§ method #_"String" (§ fn getPaymentProtocolId) [])
    (§ block
        (§ return (§ expr PAYMENT_PROTOCOL_ID_TESTNET))
    )

    ;; February 16th 2012
    #_private
    #_static
    #_final
    (§ field #_"Date" (§ name testnetDiffDate) (§ new #_"Date" (§ pars 1329264000000)))

    #_override
    #_public
    (§ method #_"void" (§ fn checkDifficultyTransitions) [#_final #_"StoredBlock" (§ name storedPrev), #_final #_"Block" (§ name nextBlock), #_final #_"BlockStore" (§ name blockStore)])
        (§ throws #_"VerificationException", #_"BlockStoreException")
    (§ block
        (§ if (§ expr (§ not isDifficultyTransitionPoint(§ pars storedPrev.getHeight(§ pars ))) && nextBlock.getTime(§ pars ).after(§ pars testnetDiffDate)))
        (§ block
            (§ var #_"Block" (§ name prev) (§ expr storedPrev.getHeader(§ pars )))

            ;; After 15th February 2012 the rules on the testnet change to avoid people running up the difficulty
            ;; and then leaving, making it too hard to mine a block.  On non-difficulty transition points, easy
            ;; blocks are allowed if there has been a span of 20 minutes without one.
            #_final
            (§ var #_"long" (§ name timeDelta) (§ expr nextBlock.getTimeSeconds(§ pars ) - prev.getTimeSeconds(§ pars )))
            ;; There is an integer underflow bug in bitcoin-qt that means mindiff blocks are accepted when time
            ;; goes backwards.
            (§ if (§ expr 0 <= timeDelta && timeDelta <= NetworkParameters/TARGET_SPACING * 2))
            (§ block
                ;; Walk backwards until we find a block that doesn't have the easiest proof of work, then check
                ;; that difficulty is equal to that one.
                (§ var #_"StoredBlock" (§ name cursor) storedPrev)
                (§ while (§ expr (§ not (§ dot cursor.getHeader(§ pars ).equals(§ pars getGenesisBlock(§ pars )))) && cursor.getHeight(§ pars ) % getInterval(§ pars ) != 0 && cursor.getHeader(§ pars ).getDifficultyTargetAsInteger(§ pars ).equals(§ pars getMaxTarget(§ pars ))))
                (§ block
                    (§ ass (§ name cursor) (§ expr cursor.getPrev(§ pars blockStore)))
                )
                (§ var #_"BigInteger" (§ name cursorTarget) (§ expr cursor.getHeader(§ pars ).getDifficultyTargetAsInteger(§ pars )))
                (§ var #_"BigInteger" (§ name newTarget) (§ expr nextBlock.getDifficultyTargetAsInteger(§ pars )))
                (§ if (§ expr (§ not cursorTarget.equals(§ pars newTarget))))
                (§ block
                    (§ throw (§ new #_"VerificationException" (§ pars "Testnet block transition that is not allowed: " + Long/toHexString(§ pars cursor.getHeader(§ pars ).getDifficultyTarget(§ pars )) + " vs " + Long/toHexString(§ pars nextBlock.getDifficultyTarget(§ pars )))))
                )
            )
        )
        (§ else )
        (§ block
            (§ expr super.checkDifficultyTransitions(§ pars storedPrev, nextBlock, blockStore))
        )
        (§ void nil)
    )
)

#_(ns org.bitcoinj.params #_"UnitTestParams"
    (:import [java.math BigInteger])
   (:require [org.bitcoinj.core *]))

;;;
 ; Network parameters used by the bitcoinj unit tests (and potentially your own).  This lets you solve a block using
 ; {@link org.bitcoinj.core.Block#solve()} by setting difficulty to the easiest possible.
 ;;
#_public
(§ class #_"UnitTestParams" (§ extends #_"AbstractBitcoinNetParams")
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name UNITNET_MAJORITY_WINDOW) 8)
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name TESTNET_MAJORITY_REJECT_BLOCK_OUTDATED) 6)
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name TESTNET_MAJORITY_ENFORCE_BLOCK_UPGRADE) 4)

    #_public
    (§ constructor #_"UnitTestParams" [])
    (§ block
        (§ super (§ pars ))

        (§ ass (§ name id) (§ expr ID_UNITTESTNET))
        (§ ass (§ name packetMagic) (§ expr 0x0b110907))
        (§ ass (§ name addressHeader) 111)
        (§ ass (§ name p2shHeader) 196)
        (§ ass (§ name acceptableAddressCodes) (§ new #_"int[]" (§ coll addressHeader, p2shHeader )))
        (§ ass (§ name maxTarget) (§ new #_"BigInteger" (§ pars "00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16)))
        (§ expr genesisBlock.setTime(§ pars System/currentTimeMillis(§ pars ) / 1000))
        (§ expr genesisBlock.setDifficultyTarget(§ pars Block/EASIEST_DIFFICULTY_TARGET))
        (§ expr genesisBlock.solve(§ pars ))
        (§ ass (§ name port) 18333)
        (§ ass (§ name interval) 10)
        (§ ass (§ name targetTimespan) 200000000) ;; 6 years.  Just a very big number.
        (§ ass (§ name spendableCoinbaseDepth) 5)
        (§ ass (§ name subsidyDecreaseBlockCount) 100)
        (§ ass (§ name dnsSeeds) nil)
        (§ ass (§ name addrSeeds) nil)
        (§ ass (§ name bip32HeaderPub) (§ expr 0x043587cf))
        (§ ass (§ name bip32HeaderPriv) (§ expr 0x04358394))

        (§ ass (§ name majorityEnforceBlockUpgrade) 3)
        (§ ass (§ name majorityRejectBlockOutdated) 4)
        (§ ass (§ name majorityWindow) 7)
        (§ void this)
    )

    #_private
    #_static
    (§ field #_"UnitTestParams" (§ name instance))

    #_public
    #_static
    #_synchronized
    (§ method #_"UnitTestParams" (§ fn get) [])
    (§ block
        (§ if (§ expr instance == nil))
        (§ block
            (§ ass (§ name instance) (§ new #_"UnitTestParams" (§ pars )))
        )
        (§ return instance)
    )

    #_override
    #_public
    (§ method #_"String" (§ fn getPaymentProtocolId) [])
    (§ block
        (§ return (§ expr "unittest"))
    )
)

#_(ns org.bitcoinj.script #_"Script"
    (:import [java.io ByteArrayInputStream ByteArrayOutputStream IOException OutputStream]
             [java.math BigInteger]
             [java.security MessageDigest NoSuchAlgorithmException]
             [java.util *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto.digests RIPEMD160Digest])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.crypto TransactionSignature]
             #_static [org.bitcoinj.script.ScriptOpCodes *]))

;; TODO: Redesign this entire API to be more type safe and organised.

;;;
 ; <p>Programs embedded inside transactions that control redemption of payments.</p>
 ;
 ; <p>Bitcoin transactions don't specify what they do directly.  Instead
 ; <a href="https://en.bitcoin.it/wiki/Script">a small binary stack language</a> is used to define programs that
 ; when evaluated, return whether the transaction "accepts" or rejects the other transactions connected to it.</p>
 ;
 ; <p>In SPV mode, scripts are not run, because that would require all transactions to be available and lightweight
 ; clients don't have that data.  In full mode, this class is used to run the interpreted language.  It also has
 ; static methods for building scripts.</p>
 ;;
#_public
(§ class #_"Script"
    ;;; Enumeration to encapsulate the type of this script. ;;
    #_public
    (§ enum #_"ScriptType"
        ;; Do NOT change the ordering of the following definitions because their ordinals are stored in databases.
        (§ item NO_TYPE)
        (§ item P2PKH)
        (§ item PUB_KEY)
        (§ item P2SH)
    )

    ;;; Flags to pass to {@link Script#correctlySpends(Transaction, long, Script, Set)}.
     ; Note currently only P2SH, DERSIG and NULLDUMMY are actually supported.
     ;;
    #_public
    (§ enum #_"VerifyFlag"
        (§ item P2SH) ;; Enable BIP16-style subscript evaluation.
        (§ item STRICTENC) ;; Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.
        (§ item DERSIG) ;; Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP66 rule 1).
        (§ item LOW_S) ;; Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure.
        (§ item NULLDUMMY) ;; Verify dummy stack item consumed by CHECKMULTISIG is of zero-length.
        (§ item SIGPUSHONLY) ;; Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).
        (§ item MINIMALDATA) ;; Require minimal encodings for all push operations.
        (§ item DISCOURAGE_UPGRADABLE_NOPS) ;; Discourage use of NOPs reserved for upgrades (NOP1-10).
        (§ item CLEANSTACK) ;; Require that only a single stack element remains after evaluation.
        (§ item CHECKLOCKTIMEVERIFY) ;; Enable CHECKLOCKTIMEVERIFY operation.
        (§ item CHECKSEQUENCEVERIFY) ;; Enable CHECKSEQUENCEVERIFY operation.
    )
    #_public
    #_static
    #_final
    (§ field #_"EnumSet<VerifyFlag>" (§ name ALL_VERIFY_FLAGS) (§ expr EnumSet/allOf(§ pars (§ klass #_"VerifyFlag"))))

    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"Script"))))

    #_public
    #_static
    #_final
    (§ field #_"long" (§ name MAX_SCRIPT_ELEMENT_SIZE) 520) ;; bytes
    #_private
    #_static
    #_final
    (§ field #_"int" (§ name MAX_OPS_PER_SCRIPT) 201)
    #_private
    #_static
    #_final
    (§ field #_"int" (§ name MAX_STACK_SIZE) 1000)
    #_private
    #_static
    #_final
    (§ field #_"int" (§ name MAX_PUBKEYS_PER_MULTISIG) 20)
    #_private
    #_static
    #_final
    (§ field #_"int" (§ name MAX_SCRIPT_SIZE) 10000)
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name SIG_SIZE) 75)
    ;;; Max number of sigops allowed in a standard p2sh redeem script. ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name MAX_P2SH_SIGOPS) 15)

    ;; The program is a set of chunks where each element is either [opcode] or [data, data, data ...].
    #_protected
    (§ field #_"List<ScriptChunk>" (§ name chunks))
    ;; Unfortunately, scripts are not ever re-serialized or canonicalized when used in signature hashing.
    ;; Thus we must preserve the exact bytes that we read off the wire, along with the parsed form.
    #_protected
    (§ field #_"byte[]" (§ name program))

    ;; Creation time of the associated keys in seconds since the epoch.
    #_private
    (§ field #_"long" (§ name creationTimeSeconds))

    ;;; Creates an empty script that serializes to nothing. ;;
    #_private
    (§ constructor #_"Script" [])
    (§ block
        (§ ass (§ name chunks) (§ expr Lists/newArrayList(§ pars )))
        (§ void this)
    )

    ;; Used from ScriptBuilder.
    (§ constructor #_"Script" [#_"List<ScriptChunk>" (§ name chunks)])
    (§ block
        (§ ass (§ name this.chunks) (§ expr Collections/unmodifiableList(§ pars (§ new #_"ArrayList<>" (§ pars chunks)))))
        (§ ass (§ name creationTimeSeconds) (§ expr Utils/currentTimeSeconds(§ pars )))
        (§ void this)
    )

    ;;;
     ; Construct a Script that copies and wraps the programBytes array.
     ; The array is parsed and checked for syntactic validity.
     ; @param programBytes Array of program bytes from a transaction.
     ;;
    #_public
    (§ constructor #_"Script" [#_"byte[]" (§ name programBytes)])
        (§ throws #_"ScriptException")
    (§ block
        (§ ass (§ name program) programBytes)
        (§ expr parse(§ pars programBytes))
        (§ ass (§ name creationTimeSeconds) 0)
        (§ void this)
    )

    #_public
    (§ constructor #_"Script" [#_"byte[]" (§ name programBytes), #_"long" (§ name creationTimeSeconds)])
        (§ throws #_"ScriptException")
    (§ block
        (§ ass (§ name program) programBytes)
        (§ expr parse(§ pars programBytes))
        (§ ass (§ name this.creationTimeSeconds) creationTimeSeconds)
        (§ void this)
    )

    #_public
    (§ method #_"long" (§ fn getCreationTimeSeconds) [])
    (§ block
        (§ return creationTimeSeconds)
    )

    #_public
    (§ method #_"void" (§ fn setCreationTimeSeconds) [#_"long" (§ name creationTimeSeconds)])
    (§ block
        (§ ass (§ name this.creationTimeSeconds) creationTimeSeconds)
        (§ void nil)
    )

    ;;;
     ; Returns the program opcodes as a string, for example "[1234] DUP HASH160".
     ;;
    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr Utils/SPACE_JOINER.join(§ pars chunks)))
    )

    ;;; Returns the serialized program as a newly created byte array. ;;
    #_public
    (§ method #_"byte[]" (§ fn getProgram) [])
    (§ block
        (§ try )
        (§ block
            ;; Don't round-trip as Bitcoin Core doesn't and it would introduce a mismatch.
            (§ if (§ expr program != nil))
            (§ block
                (§ return (§ expr Arrays/copyOf(§ pars program, program.length)))
            )

            (§ var #_"ByteArrayOutputStream" (§ name bos) (§ new #_"ByteArrayOutputStream" (§ pars )))
            (§ for (§ var #_"ScriptChunk" (§ name chunk)) :for chunks)
            (§ block
                (§ expr chunk.write(§ pars bos))
            )
            (§ ass (§ name program) (§ expr bos.toByteArray(§ pars )))
            (§ return program)
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
    )

    ;;; Returns an immutable list of the scripts parsed form.  Each chunk is either an opcode or data element. ;;
    #_public
    (§ method #_"List<ScriptChunk>" (§ fn getChunks) [])
    (§ block
        (§ return (§ expr Collections/unmodifiableList(§ pars chunks)))
    )

    #_private
    #_static
    #_final
    (§ var #_"ScriptChunk[]" (§ name STANDARD_TRANSACTION_SCRIPT_CHUNKS)
    (§ coll
        (§ new #_"ScriptChunk" (§ pars ScriptOpCodes/OP_DUP, nil, 0))
        (§ new #_"ScriptChunk" (§ pars ScriptOpCodes/OP_HASH160, nil, 1))
        (§ new #_"ScriptChunk" (§ pars ScriptOpCodes/OP_EQUALVERIFY, nil, 23))
        (§ new #_"ScriptChunk" (§ pars ScriptOpCodes/OP_CHECKSIG, nil, 24))
    ))

    ;;;
     ; <p>To run a script, first we parse it which breaks it up into chunks representing pushes of data
     ; or logical opcodes.  Then we can run the parsed chunks.</p>
     ;
     ; <p>The reason for this split, instead of just interpreting directly, is to make it easier
     ; to reach into a programs structure and pull out bits of data without having to run it.
     ; This is necessary to render the to/from addresses of transactions in a user interface.
     ; Bitcoin Core does something similar.</p>
     ;;
    #_private
    (§ method #_"void" (§ fn parse) [#_"byte[]" (§ name program)])
        (§ throws #_"ScriptException")
    (§ block
        (§ ass (§ name chunks) (§ new #_"ArrayList<>" (§ pars 5))) ;; Common size.
        (§ var #_"ByteArrayInputStream" (§ name bis) (§ new #_"ByteArrayInputStream" (§ pars program)))
        (§ var #_"int" (§ name initialSize) (§ expr bis.available(§ pars )))
        (§ while (§ expr 0 < bis.available(§ pars )))
        (§ block
            (§ var #_"int" (§ name startLocationInProgram) (§ expr initialSize - bis.available(§ pars )))
            (§ var #_"int" (§ name opcode) (§ expr bis.read(§ pars )))

            (§ var #_"long" (§ name dataToRead) -1)
            (§ if (§ expr 0 <= opcode && opcode < OP_PUSHDATA1))
            (§ block
                ;; Read some bytes of data, where how many is the opcode value itself.
                (§ ass (§ name dataToRead) opcode)
            )
            (§ elseif (§ expr opcode == OP_PUSHDATA1))
            (§ block
                (§ if (§ expr bis.available(§ pars ) < 1))
                (§ block
                    (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Unexpected end of script")))
                )
                (§ ass (§ name dataToRead) (§ expr bis.read(§ pars )))
            )
            (§ elseif (§ expr opcode == OP_PUSHDATA2))
            (§ block
                ;; Read a short, then read that many bytes of data.
                (§ if (§ expr bis.available(§ pars ) < 2))
                (§ block
                    (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Unexpected end of script")))
                )
                (§ ass (§ name dataToRead) (§ expr bis.read(§ pars ) | (§ expr bis.read(§ pars ) << 8)))
            )
            (§ elseif (§ expr opcode == OP_PUSHDATA4))
            (§ block
                ;; Read a uint32, then read that many bytes of data.
                ;; Though this is allowed, because its value cannot be > 520, it should never actually be used.
                (§ if (§ expr bis.available(§ pars ) < 4))
                (§ block
                    (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Unexpected end of script")))
                )
                (§ ass (§ name dataToRead) (§ expr (§ expr (§ cast #_"long" (§ expr bis.read(§ pars )))) | (§ expr (§ expr (§ cast #_"long" (§ expr bis.read(§ pars )))) << 8) | (§ expr (§ expr (§ cast #_"long" (§ expr bis.read(§ pars )))) << 16) | (§ expr (§ expr (§ cast #_"long" (§ expr bis.read(§ pars )))) << 24)))
            )

            (§ var #_"ScriptChunk" (§ name chunk))
            (§ if (§ expr dataToRead == -1))
            (§ block
                (§ ass (§ name chunk) (§ new #_"ScriptChunk" (§ pars opcode, nil, startLocationInProgram)))
            )
            (§ else )
            (§ block
                (§ if (§ expr bis.available(§ pars ) < dataToRead))
                (§ block
                    (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_BAD_OPCODE, "Push of data element that is larger than remaining data")))
                )

                (§ var #_"byte[]" (§ name data) (§ new #_"byte[]" (§ count (§ cast #_"int" dataToRead))))
                (§ expr Preconditions/checkState(§ pars dataToRead == 0 || bis.read(§ pars data, 0, (§ cast #_"int" dataToRead)) == dataToRead))
                (§ ass (§ name chunk) (§ new #_"ScriptChunk" (§ pars opcode, data, startLocationInProgram)))
            )
            ;; Save some memory by eliminating redundant copies of the same chunk objects.
            (§ for (§ var #_"ScriptChunk" (§ name c)) :for (§ expr STANDARD_TRANSACTION_SCRIPT_CHUNKS))
            (§ block
                (§ if (§ expr c.equals(§ pars chunk)))
                (§ block
                    (§ ass (§ name chunk) c)
                )
            )
            (§ expr chunks.add(§ pars chunk))
        )
        (§ void nil)
    )

    ;;;
     ; Returns true if this script is of the form <pubkey> OP_CHECKSIG.  This form was originally intended for
     ; transactions where the peers talked to each other directly via TCP/IP, but has fallen out of favor with time
     ; due to that mode of operation being susceptible to man-in-the-middle attacks.  It is still used in coinbase
     ; outputs and can be useful more exotic types of transaction, but today most payments are to addresses.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isSentToRawPubKey) [])
    (§ block
        (§ return (§ expr chunks.size(§ pars ) == 2 && chunks.get(§ pars 1).equalsOpCode(§ pars OP_CHECKSIG) && (§ not (§ dot chunks.get(§ pars 0).isOpCode(§ pars ))) && 1 < chunks.get(§ pars 0).data.length))
    )

    ;;;
     ; Returns true if this script is of the form DUP HASH160 <pubkey hash> EQUALVERIFY CHECKSIG, i.e. payment to an
     ; address like 1VayNert3x1KzbpzMGt2qdqrAThiRovi8.  This form was originally intended for the case where you wish
     ; to send somebody money with a written code because their node is offline, but over time has become the standard
     ; way to make payments due to the short and recognizable base58 form addresses come in.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isSentToAddress) [])
    (§ block
        (§ return (§ expr chunks.size(§ pars ) == 5 && chunks.get(§ pars 0).equalsOpCode(§ pars OP_DUP) && chunks.get(§ pars 1).equalsOpCode(§ pars OP_HASH160) && chunks.get(§ pars 2).data.length == Address/LENGTH && chunks.get(§ pars 3).equalsOpCode(§ pars OP_EQUALVERIFY) && chunks.get(§ pars 4).equalsOpCode(§ pars OP_CHECKSIG)))
    )

    ;;;
     ; <p>If a program matches the standard template DUP HASH160 &lt;pubkey hash&gt; EQUALVERIFY CHECKSIG,
     ; then this function retrieves the third element.
     ; In this case, this is useful for fetching the destination address of a transaction.</p>
     ;
     ; <p>If a program matches the standard template HASH160 &lt;script hash&gt; EQUAL,
     ; then this function retrieves the second element.
     ; In this case, this is useful for fetching the hash of the redeem script of a transaction.</p>
     ;
     ; <p>Otherwise it throws a ScriptException.</p>
     ;
     ;;
    #_public
    (§ method #_"byte[]" (§ fn getPubKeyHash) [])
        (§ throws #_"ScriptException")
    (§ block
        (§ if (§ expr isSentToAddress(§ pars )))
        (§ block
            (§ return (§ expr chunks.get(§ pars 2).data))
        )
        (§ if (§ expr isPayToScriptHash(§ pars )))
        (§ block
            (§ return (§ expr chunks.get(§ pars 1).data))
        )

        (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Script not in the standard scriptPubKey form")))
    )

    ;;;
     ; Returns the public key in this script.  If a script contains two constants and nothing else, it is assumed
     ; to be a scriptSig (input) for a pay-to-address output and the second constant is returned (the first is the
     ; signature).  If a script contains a constant and an OP_CHECKSIG opcode, the constant is returned as it is
     ; assumed to be a direct pay-to-key scriptPubKey (output) and the first constant is the public key.
     ;
     ; @throws ScriptException if the script is none of the named forms.
     ;;
    #_public
    (§ method #_"byte[]" (§ fn getPubKey) [])
        (§ throws #_"ScriptException")
    (§ block
        (§ if (§ expr chunks.size(§ pars ) != 2))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Script not of right size, expecting 2 but got " + chunks.size(§ pars ))))
        )

        #_final
        (§ var #_"ScriptChunk" (§ name chunk0) (§ expr chunks.get(§ pars 0)))
        #_final
        (§ var #_"byte[]" (§ name chunk0data) (§ expr chunk0.data))
        #_final
        (§ var #_"ScriptChunk" (§ name chunk1) (§ expr chunks.get(§ pars 1)))
        #_final
        (§ var #_"byte[]" (§ name chunk1data) (§ expr chunk1.data))

        ;; If we have two large constants assume the input to a pay-to-address output.
        (§ if (§ expr chunk0data != nil && 2 < chunk0data.length && chunk1data != nil && 2 < chunk1data.length))
        (§ block
            (§ return chunk1data)
        )

        ;; A large constant followed by an OP_CHECKSIG is the key.
        (§ if (§ expr chunk1.equalsOpCode(§ pars OP_CHECKSIG) && chunk0data != nil && 2 < chunk0data.length))
        (§ block
            (§ return chunk0data)
        )

        (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Script did not match expected form: " + this)))
    )

    ;;;
     ; Retrieves the sender public key from a LOCKTIMEVERIFY transaction.
     ;
     ; @throws ScriptException
     ;;
    #_public
    (§ method #_"byte[]" (§ fn getCLTVPaymentChannelSenderPubKey) [])
        (§ throws #_"ScriptException")
    (§ block
        (§ if (§ expr isSentToCLTVPaymentChannel(§ pars )))
        (§ block
            (§ return (§ expr chunks.get(§ pars 8).data))
        )

        (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Script not a standard CHECKLOCKTIMVERIFY transaction: " + this)))
    )

    ;;;
     ; Retrieves the recipient public key from a LOCKTIMEVERIFY transaction.
     ;
     ; @throws ScriptException
     ;;
    #_public
    (§ method #_"byte[]" (§ fn getCLTVPaymentChannelRecipientPubKey) [])
        (§ throws #_"ScriptException")
    (§ block
        (§ if (§ expr isSentToCLTVPaymentChannel(§ pars )))
        (§ block
            (§ return (§ expr chunks.get(§ pars 1).data))
        )

        (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Script not a standard CHECKLOCKTIMVERIFY transaction: " + this)))
    )

    #_public
    (§ method #_"BigInteger" (§ fn getCLTVPaymentChannelExpiry) [])
    (§ block
        (§ if (§ expr isSentToCLTVPaymentChannel(§ pars )))
        (§ block
            (§ return (§ expr castToBigInteger(§ pars chunks.get(§ pars 4).data, 5, false)))
        )

        (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Script not a standard CHECKLOCKTIMEVERIFY transaction: " + this)))
    )

    ;;;
     ; For 2-element [input] scripts assumes that the paid-to-address can be derived from the public key.
     ; The concept of a "from address" isn't well defined in Bitcoin and you should not assume the sender
     ; of a transaction can actually receive coins on it. This method may be removed in future.
     ;;
    #_deprecated
    #_public
    (§ method #_"Address" (§ fn getFromAddress) [#_"NetworkParameters" (§ name params)])
        (§ throws #_"ScriptException")
    (§ block
        (§ return (§ new #_"Address" (§ pars params, Utils/sha256hash160(§ pars getPubKey(§ pars )))))
    )

    ;;;
     ; Gets the destination address from this script, if it's in the required form (see getPubKey).
     ;;
    #_public
    (§ method #_"Address" (§ fn getToAddress) [#_"NetworkParameters" (§ name params)])
        (§ throws #_"ScriptException")
    (§ block
        (§ return (§ expr getToAddress(§ pars params, false)))
    )

    ;;;
     ; Gets the destination address from this script, if it's in the required form (see getPubKey).
     ;
     ; @param forcePayToPubKey If true, allow payToPubKey to be casted to the corresponding address.
     ;                         This is useful if you prefer showing addresses rather than pubkeys.
     ;;
    #_public
    (§ method #_"Address" (§ fn getToAddress) [#_"NetworkParameters" (§ name params), #_"boolean" (§ name forcePayToPubKey)])
        (§ throws #_"ScriptException")
    (§ block
        (§ if (§ expr isSentToAddress(§ pars )))
        (§ block
            (§ return (§ new #_"Address" (§ pars params, getPubKeyHash(§ pars ))))
        )
        (§ if (§ expr isPayToScriptHash(§ pars )))
        (§ block
            (§ return (§ expr Address/fromP2SHScript(§ pars params, this)))
        )
        (§ if (§ expr forcePayToPubKey && isSentToRawPubKey(§ pars )))
        (§ block
            (§ return (§ expr ECKey/fromPublicOnly(§ pars getPubKey(§ pars )).toAddress(§ pars params)))
        )

        (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Cannot cast this script to a pay-to-address type")))
    )

    ;;;
     ; Writes out the given byte buffer to the output stream with the correct opcode prefix.
     ; To write an integer call writeBytes(out, Utils.reverseBytes(Utils.encodeMPI(val, false))).
     ;;
    #_public
    #_static
    (§ method #_"void" (§ fn writeBytes) [#_"OutputStream" (§ name os), #_"byte[]" (§ name buf)])
        (§ throws #_"IOException")
    (§ block
        (§ if (§ expr buf.length < OP_PUSHDATA1))
        (§ block
            (§ expr os.write(§ pars buf.length))
            (§ expr os.write(§ pars buf))
        )
        (§ elseif (§ expr buf.length < 256))
        (§ block
            (§ expr os.write(§ pars OP_PUSHDATA1))
            (§ expr os.write(§ pars buf.length))
            (§ expr os.write(§ pars buf))
        )
        (§ elseif (§ expr buf.length < 65536))
        (§ block
            (§ expr os.write(§ pars OP_PUSHDATA2))
            (§ expr os.write(§ pars 0xff & buf.length))
            (§ expr os.write(§ pars 0xff & (§ expr buf.length >> 8)))
            (§ expr os.write(§ pars buf))
        )
        (§ else )
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars "Unimplemented")))
        )
        (§ void nil)
    )

    ;;; Creates a program that requires at least N of the given keys to sign, using OP_CHECKMULTISIG. ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn createMultiSigOutputScript) [#_"int" (§ name threshold), #_"List<ECKey>" (§ name pubkeys)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars 0 < threshold))
        (§ expr Preconditions/checkArgument(§ pars threshold <= pubkeys.size(§ pars )))
        (§ expr Preconditions/checkArgument(§ pars pubkeys.size(§ pars ) <= 16)) ;; That's the max we can represent with a single opcode.

        (§ if (§ expr 3 < pubkeys.size(§ pars )))
        (§ block
            (§ expr log.warn(§ pars "Creating a multi-signature output that is non-standard: {} pubkeys, should be <= 3", pubkeys.size(§ pars )))
        )

        (§ try )
        (§ block
            (§ var #_"ByteArrayOutputStream" (§ name bits) (§ new #_"ByteArrayOutputStream" (§ pars )))
            (§ expr bits.write(§ pars encodeToOpN(§ pars threshold)))
            (§ for (§ var #_"ECKey" (§ name key)) :for pubkeys)
            (§ block
                (§ expr writeBytes(§ pars bits, key.getPubKey(§ pars )))
            )
            (§ expr bits.write(§ pars encodeToOpN(§ pars pubkeys.size(§ pars ))))
            (§ expr bits.write(§ pars OP_CHECKMULTISIG))
            (§ return (§ expr bits.toByteArray(§ pars )))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
    )

    #_public
    #_static
    (§ method #_"byte[]" (§ fn createInputScript) [#_"byte[]" (§ name signature), #_"byte[]" (§ name pubkey)])
    (§ block
        (§ try )
        (§ block
            ;; TODO: Do this by creating a Script *first* then having the script reassemble itself into bytes.
            (§ var #_"ByteArrayOutputStream" (§ name bits) (§ new #_"UnsafeByteArrayOutputStream" (§ pars signature.length + pubkey.length + 2)))
            (§ expr writeBytes(§ pars bits, signature))
            (§ expr writeBytes(§ pars bits, pubkey))
            (§ return (§ expr bits.toByteArray(§ pars )))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
    )

    #_public
    #_static
    (§ method #_"byte[]" (§ fn createInputScript) [#_"byte[]" (§ name signature)])
    (§ block
        (§ try )
        (§ block
            ;; TODO: Do this by creating a Script *first* then having the script reassemble itself into bytes.
            (§ var #_"ByteArrayOutputStream" (§ name bits) (§ new #_"UnsafeByteArrayOutputStream" (§ pars signature.length + 2)))
            (§ expr writeBytes(§ pars bits, signature))
            (§ return (§ expr bits.toByteArray(§ pars )))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
    )

    ;;;
     ; Creates an incomplete scriptSig that, once filled with signatures, can redeem output containing this scriptPubKey.
     ; Instead of the signatures resulting script has OP_0.
     ; Having incomplete input script allows to pass around partially signed tx.
     ; It is expected that this program later on will be updated with proper signatures.
     ;;
    #_public
    (§ method #_"Script" (§ fn createEmptyInputScript) [#_nilable #_"ECKey" (§ name key), #_nilable #_"Script" (§ name redeemScript)])
    (§ block
        (§ if (§ expr isSentToAddress(§ pars )))
        (§ block
            (§ expr Preconditions/checkArgument(§ pars key != nil, "Key required to create pay-to-address input script"))
            (§ return (§ expr ScriptBuilder/createInputScript(§ pars nil, key)))
        )

        (§ if (§ expr isSentToRawPubKey(§ pars )))
        (§ block
            (§ return (§ expr ScriptBuilder/createInputScript(§ pars nil)))
        )

        (§ if (§ expr isPayToScriptHash(§ pars )))
        (§ block
            (§ expr Preconditions/checkArgument(§ pars redeemScript != nil, "Redeem script required to create P2SH input script"))
            (§ return (§ expr ScriptBuilder/createP2SHMultiSigInputScript(§ pars nil, redeemScript)))
        )

        (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Do not understand script type: " + this)))
    )

    ;;;
     ; Returns a copy of the given scriptSig with the signature inserted in the given position.
     ;;
    #_public
    (§ method #_"Script" (§ fn getScriptSigWithSignature) [#_"Script" (§ name scriptSig), #_"byte[]" (§ name sigBytes), #_"int" (§ name index)])
    (§ block
        (§ var #_"int" (§ name sigsPrefixCount) 0)
        (§ var #_"int" (§ name sigsSuffixCount) 0)
        (§ if (§ expr isPayToScriptHash(§ pars )))
        (§ block
            (§ ass (§ name sigsPrefixCount) 1) ;; OP_0 <sig>* <redeemScript>
            (§ ass (§ name sigsSuffixCount) 1)
        )
        (§ elseif (§ expr isSentToMultiSig(§ pars )))
        (§ block
            (§ ass (§ name sigsPrefixCount) 1) ;; OP_0 <sig>*
        )
        (§ elseif (§ expr isSentToAddress(§ pars )))
        (§ block
            (§ ass (§ name sigsSuffixCount) 1) ;; <sig> <pubkey>
        )
        (§ return (§ expr ScriptBuilder/updateScriptWithSignature(§ pars scriptSig, sigBytes, index, sigsPrefixCount, sigsSuffixCount)))
    )

    ;;;
     ; Returns the index where a signature by the key should be inserted.
     ; Only applicable to a P2SH scriptSig.
     ;;
    #_public
    (§ method #_"int" (§ fn getSigInsertionIndex) [#_"Sha256Hash" (§ name hash), #_"ECKey" (§ name signingKey)])
    (§ block
        ;; Iterate over existing signatures, skipping the initial OP_0, the final redeem script
        ;; and any placeholder OP_0 sigs.
        (§ var #_"List<ScriptChunk>" (§ name existingChunks) (§ expr chunks.subList(§ pars 1, chunks.size(§ pars ) - 1)))
        (§ var #_"ScriptChunk" (§ name redeemScriptChunk) (§ expr chunks.get(§ pars chunks.size(§ pars ) - 1)))
        (§ expr Preconditions/checkNotNull(§ pars redeemScriptChunk.data))
        (§ var #_"Script" (§ name redeemScript) (§ new #_"Script" (§ pars redeemScriptChunk.data)))

        (§ var #_"int" (§ name sigCount) 0)
        (§ var #_"int" (§ name myIndex) (§ expr redeemScript.findKeyInRedeem(§ pars signingKey)))
        (§ for (§ var #_"ScriptChunk" (§ name chunk)) :for existingChunks)
        (§ block
            (§ if (§ expr chunk.opcode == OP_0))
            (§ block
                ;; OP_0, skip
            )
            (§ else )
            (§ block
                (§ expr Preconditions/checkNotNull(§ pars chunk.data))
                (§ if (§ expr myIndex < redeemScript.findSigInRedeem(§ pars chunk.data, hash)))
                (§ block
                    (§ return sigCount)
                )
                (§ ass (§ name sigCount) (§ expr sigCount + 1))
            )
        )
        (§ return sigCount)
    )

    #_private
    (§ method #_"int" (§ fn findKeyInRedeem) [#_"ECKey" (§ name key)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars chunks.get(§ pars 0).isOpCode(§ pars ))) ;; P2SH scriptSig

        (§ var #_"int" (§ name numKeys) (§ expr Script/decodeFromOpN(§ pars chunks.get(§ pars chunks.size(§ pars ) - 2).opcode)))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numKeys) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ if (§ expr Arrays/equals(§ pars chunks.get(§ pars 1 + i).data, key.getPubKey(§ pars ))))
            (§ block
                (§ return i)
            )
        )

        (§ throw (§ new #_"IllegalStateException" (§ pars "Could not find matching key " + key + " in script " + this)))
    )

    ;;;
     ; Returns a list of the keys required by this script, assuming a multi-sig script.
     ;
     ; @throws ScriptException if the script type is not understood or is pay to address or is P2SH (run this method on the "Redeem script" instead).
     ;;
    #_public
    (§ method #_"List<ECKey>" (§ fn getPubKeys) [])
    (§ block
        (§ if (§ expr (§ not isSentToMultiSig(§ pars ))))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Only usable for multisig scripts.")))
        )

        (§ var #_"ArrayList<ECKey>" (§ name result) (§ expr Lists/newArrayList(§ pars )))
        (§ var #_"int" (§ name numKeys) (§ expr Script/decodeFromOpN(§ pars chunks.get(§ pars chunks.size(§ pars ) - 2).opcode)))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numKeys) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ expr result.add(§ pars ECKey/fromPublicOnly(§ pars chunks.get(§ pars 1 + i).data)))
        )
        (§ return result)
    )

    #_private
    (§ method #_"int" (§ fn findSigInRedeem) [#_"byte[]" (§ name signatureBytes), #_"Sha256Hash" (§ name hash)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars chunks.get(§ pars 0).isOpCode(§ pars ))) ;; P2SH scriptSig

        (§ var #_"int" (§ name numKeys) (§ expr Script/decodeFromOpN(§ pars chunks.get(§ pars chunks.size(§ pars ) - 2).opcode)))
        (§ var #_"TransactionSignature" (§ name signature) (§ expr TransactionSignature/decodeFromBitcoin(§ pars signatureBytes, true)))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numKeys) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ if (§ expr ECKey/fromPublicOnly(§ pars chunks.get(§ pars i + 1).data).verify(§ pars hash, signature)))
            (§ block
                (§ return i)
            )
        )

        (§ throw (§ new #_"IllegalStateException" (§ pars "Could not find matching key for signature on " + hash + " sig " + Utils/HEX.encode(§ pars signatureBytes))))
    )

    #_private
    #_static
    (§ method #_"int" (§ fn getSigOpCount) [#_"List<ScriptChunk>" (§ name chunks), #_"boolean" (§ name accurate)])
        (§ throws #_"ScriptException")
    (§ block
        (§ var #_"int" (§ name sigOps) 0)
        (§ var #_"int" (§ name lastOpCode) (§ expr OP_INVALIDOPCODE))
        (§ for (§ var #_"ScriptChunk" (§ name chunk)) :for chunks)
        (§ block
            (§ if (§ expr chunk.isOpCode(§ pars )))
            (§ block
                (§ switch (§ expr chunk.opcode))
                (§ block
                    (§ case OP_CHECKSIG)
                    (§ case OP_CHECKSIGVERIFY)
                    (§ block
                        (§ ass (§ name sigOps) (§ expr sigOps + 1))
                        (§ break )
                    )
                    (§ case OP_CHECKMULTISIG)
                    (§ case OP_CHECKMULTISIGVERIFY)
                    (§ block
                        (§ if (§ expr accurate && OP_1 <= lastOpCode && lastOpCode <= OP_16))
                        (§ block
                            (§ ass (§ name sigOps) (§ expr sigOps + decodeFromOpN(§ pars lastOpCode)))
                        )
                        (§ else )
                        (§ block
                            (§ ass (§ name sigOps) (§ expr sigOps + 20))
                        )
                        (§ break )
                    )
                    (§ default )
                    (§ block
                        (§ break )
                    )
                )
                (§ ass (§ name lastOpCode) (§ expr chunk.opcode))
            )
        )
        (§ return sigOps)
    )

    #_static
    (§ method #_"int" (§ fn decodeFromOpN) [#_"int" (§ name opcode)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars (§ expr opcode == OP_0 || opcode == OP_1NEGATE) || (§ expr OP_1 <= opcode && opcode <= OP_16), "decodeFromOpN called on non OP_N opcode"))

        (§ if (§ expr opcode == OP_0))
        (§ block
            (§ return 0)
        )
        (§ if (§ expr opcode == OP_1NEGATE))
        (§ block
            (§ return -1)
        )

        (§ return (§ expr opcode + 1 - OP_1))
    )

    #_static
    (§ method #_"int" (§ fn encodeToOpN) [#_"int" (§ name value)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars -1 <= value && value <= 16, "encodeToOpN called for " + value + " which we cannot encode in an opcode."))

        (§ if (§ expr value == 0))
        (§ block
            (§ return (§ expr OP_0))
        )
        (§ if (§ expr value == -1))
        (§ block
            (§ return (§ expr OP_1NEGATE))
        )

        (§ return (§ expr value - 1 + OP_1))
    )

    ;;;
     ; Gets the count of regular SigOps in the script program (counting multisig ops as 20).
     ;;
    #_public
    #_static
    (§ method #_"int" (§ fn getSigOpCount) [#_"byte[]" (§ name program)])
        (§ throws #_"ScriptException")
    (§ block
        (§ var #_"Script" (§ name script) (§ new #_"Script" (§ pars )))
        (§ try )
        (§ block
            (§ expr script.parse(§ pars program))
        )
        (§ catch #_"ScriptException" (§ name _))
        (§ block
            ;; Ignore errors and count up to the parse-able length.
        )
        (§ return (§ expr getSigOpCount(§ pars script.chunks, false)))
    )

    ;;;
     ; Gets the count of P2SH Sig Ops in the Script scriptSig.
     ;;
    #_public
    #_static
    (§ method #_"long" (§ fn getP2SHSigOpCount) [#_"byte[]" (§ name scriptSig)])
        (§ throws #_"ScriptException")
    (§ block
        (§ var #_"Script" (§ name script) (§ new #_"Script" (§ pars )))
        (§ try )
        (§ block
            (§ expr script.parse(§ pars scriptSig))
        )
        (§ catch #_"ScriptException" (§ name _))
        (§ block
            ;; Ignore errors and count up to the parse-able length.
        )
        (§ for (§ var #_"int" (§ name i) (§ expr script.chunks.size(§ pars ) - 1)) :for (§ expr 0 <= i) :for (§ ass (§ name i) (§ expr i - 1)))
        (§ block
            (§ if (§ not (§ dot script.chunks.get(§ pars i).isOpCode(§ pars ))))
            (§ block
                (§ var #_"Script" (§ name subScript) (§ new #_"Script" (§ pars )))
                (§ expr subScript.parse(§ pars script.chunks.get(§ pars i).data))
                (§ return (§ expr getSigOpCount(§ pars subScript.chunks, true)))
            )
        )
        (§ return 0)
    )

    ;;;
     ; Returns number of signatures required to satisfy this script.
     ;;
    #_public
    (§ method #_"int" (§ fn getNumberOfSignaturesRequiredToSpend) [])
    (§ block
        ;; For N of M CHECKMULTISIG script we will need N signatures to spend.
        (§ if (§ expr isSentToMultiSig(§ pars )))
        (§ block
            (§ return (§ expr Script/decodeFromOpN(§ pars chunks.get(§ pars 0).opcode)))
        )

        ;; pay-to-address and pay-to-pubkey require single sig
        (§ if (§ expr isSentToAddress(§ pars ) || isSentToRawPubKey(§ pars )))
        (§ block
            (§ return 1)
        )

        (§ if (§ expr isPayToScriptHash(§ pars )))
        (§ block
            (§ throw (§ new #_"IllegalStateException" (§ pars "For P2SH number of signatures depends on redeem script")))
        )

        (§ throw (§ new #_"IllegalStateException" (§ pars "Unsupported script type")))
    )

    ;;;
     ; Returns number of bytes required to spend this script.  It accepts optional ECKey and redeemScript
     ; that may be required for certain types of script to estimate target size.
     ;;
    #_public
    (§ method #_"int" (§ fn getNumberOfBytesRequiredToSpend) [#_nilable #_"ECKey" (§ name pubKey), #_nilable #_"Script" (§ name redeemScript)])
    (§ block
        (§ if (§ expr isPayToScriptHash(§ pars )))
        (§ block
            ;; scriptSig: <sig> [sig] [sig...] <redeemscript>
            (§ expr Preconditions/checkArgument(§ pars redeemScript != nil, "P2SH script requires redeemScript to be spent"))
            (§ return (§ expr redeemScript.getNumberOfSignaturesRequiredToSpend(§ pars ) * SIG_SIZE + redeemScript.getProgram(§ pars ).length))
        )
        (§ elseif (§ expr isSentToMultiSig(§ pars )))
        (§ block
            ;; scriptSig: OP_0 <sig> [sig] [sig...]
            (§ return (§ expr getNumberOfSignaturesRequiredToSpend(§ pars ) * SIG_SIZE + 1))
        )
        (§ elseif (§ expr isSentToRawPubKey(§ pars )))
        (§ block
            ;; scriptSig: <sig>
            (§ return (§ expr SIG_SIZE))
        )
        (§ elseif (§ expr isSentToAddress(§ pars )))
        (§ block
            ;; scriptSig: <sig> <pubkey>
            (§ var #_"int" (§ name uncompressedPubKeySize) 65)
            (§ return (§ expr SIG_SIZE + (§ quest (§ expr pubKey != nil) ? (§ expr pubKey.getPubKey(§ pars ).length) :else uncompressedPubKeySize)))
        )
        (§ else )
        (§ block
            (§ throw (§ new #_"IllegalStateException" (§ pars "Unsupported script type")))
        )
    )

    ;;;
     ; <p>Whether or not this is a scriptPubKey representing a pay-to-script-hash output.  In such outputs, the logic
     ; that controls reclamation is not actually in the output at all.  Instead there's just a hash, and it's up to the
     ; spending input to provide a program matching that hash.  This rule is "soft enforced" by the network as it does
     ; not exist in Bitcoin Core.  It means blocks containing P2SH transactions that don't match
     ; correctly are considered valid, but won't be mined upon, so they'll be rapidly re-orgd out of the chain.  This
     ; logic is defined by <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP 16</a>.</p>
     ;
     ; <p>bitcoinj does not support creation of P2SH transactions today.  The goal of P2SH is to allow short addresses
     ; even for complex scripts (e.g. multi-sig outputs) so they are convenient to work with in things like QRcodes or
     ; with copy/paste, and also to minimize the size of the unspent output set (which improves performance of the
     ; Bitcoin system).</p>
     ;;
    #_public
    (§ method #_"boolean" (§ fn isPayToScriptHash) [])
    (§ block
        ;; We have to check against the serialized form because BIP16 defines a P2SH output using an exact byte
        ;; template, not the logical program structure.  Thus you can have two programs that look identical when
        ;; printed out but one is a P2SH script and the other isn't! :( ;; )
        (§ var #_"byte[]" (§ name program) (§ expr getProgram(§ pars )))
        (§ return (§ expr program.length == 23 && (§ expr program[0] & 0xff) == OP_HASH160 && (§ expr program[1] & 0xff) == 0x14 && (§ expr program[22] & 0xff) == OP_EQUAL))
    )

    ;;;
     ; Returns whether this script matches the format used for multisig outputs: [n] [keys...] [m] CHECKMULTISIG.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isSentToMultiSig) [])
    (§ block
        (§ if (§ expr chunks.size(§ pars ) < 4))
        (§ block
            (§ return false)
        )

        (§ var #_"ScriptChunk" (§ name chunk) (§ expr chunks.get(§ pars chunks.size(§ pars ) - 1)))
        ;; Must end in OP_CHECKMULTISIG[VERIFY].
        (§ if (§ expr (§ not chunk.isOpCode(§ pars ))))
        (§ block
            (§ return false)
        )
        (§ if (§ expr (§ not (§ expr chunk.equalsOpCode(§ pars OP_CHECKMULTISIG) || chunk.equalsOpCode(§ pars OP_CHECKMULTISIGVERIFY)))))
        (§ block
            (§ return false)
        )

        (§ try )
        (§ block
            ;; Second to last chunk must be an OP_N opcode and there should be that many data chunks (keys).
            (§ var #_"ScriptChunk" (§ name m) (§ expr chunks.get(§ pars chunks.size(§ pars ) - 2)))
            (§ if (§ expr (§ not m.isOpCode(§ pars ))))
            (§ block
                (§ return false)
            )

            (§ var #_"int" (§ name numKeys) (§ expr decodeFromOpN(§ pars m.opcode)))
            (§ if (§ expr numKeys < 1 || chunks.size(§ pars ) != 3 + numKeys))
            (§ block
                (§ return false)
            )

            (§ for (§ var #_"int" (§ name i) 1) :for (§ expr i < chunks.size(§ pars ) - 2) :for (§ ass (§ name i) (§ expr i + 1)))
            (§ block
                (§ if (§ expr chunks.get(§ pars i).isOpCode(§ pars )))
                (§ block
                    (§ return false)
                )
            )

            ;; First chunk must be an OP_N opcode too.
            (§ if (§ expr decodeFromOpN(§ pars chunks.get(§ pars 0).opcode) < 1))
            (§ block
                (§ return false)
            )
        )
        (§ catch #_"IllegalStateException" (§ name e))
        (§ block
            (§ return false) ;; Not an OP_N opcode.
        )
        (§ return true)
    )

    #_public
    (§ method #_"boolean" (§ fn isSentToCLTVPaymentChannel) [])
    (§ block
        ;; Check that opcodes match the pre-determined format.
        ;; chunk[1] = recipient pubkey
        ;; chunk[4] = locktime
        ;; chunk[8] = sender pubkey
        (§ return (§ expr (§ expr chunks.size(§ pars ) == 10) && chunks.get(§ pars 0).equalsOpCode(§ pars OP_IF) && chunks.get(§ pars 2).equalsOpCode(§ pars OP_CHECKSIGVERIFY) && chunks.get(§ pars 3).equalsOpCode(§ pars OP_ELSE) && chunks.get(§ pars 5).equalsOpCode(§ pars OP_CHECKLOCKTIMEVERIFY) && chunks.get(§ pars 6).equalsOpCode(§ pars OP_DROP) && chunks.get(§ pars 7).equalsOpCode(§ pars OP_ENDIF) && chunks.get(§ pars 9).equalsOpCode(§ pars OP_CHECKSIG)))
    )

    #_private
    #_static
    (§ method #_"boolean" (§ fn equalsRange) [#_"byte[]" (§ name a), #_"int" (§ name start), #_"byte[]" (§ name b)])
    (§ block
        (§ if (§ expr a.length < start + b.length))
        (§ block
            (§ return false)
        )

        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < b.length) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ if (§ expr a[i + start] != b[i]))
            (§ block
                (§ return false)
            )
        )

        (§ return true)
    )

    ;;;
     ; Returns the script bytes of inputScript with all instances of the specified script object removed.
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn removeAllInstancesOf) [#_"byte[]" (§ name inputScript), #_"byte[]" (§ name chunkToRemove)])
    (§ block
        ;; We usually don't end up removing anything.
        (§ var #_"UnsafeByteArrayOutputStream" (§ name bos) (§ new #_"UnsafeByteArrayOutputStream" (§ pars inputScript.length)))

        (§ var #_"int" (§ name cursor) 0)
        (§ while (§ expr cursor < inputScript.length))
        (§ block
            (§ var #_"boolean" (§ name skip) (§ expr equalsRange(§ pars inputScript, cursor, chunkToRemove)))

            (§ var #_"int" (§ name opcode) (§ expr inputScript[cursor] & 0xff))
            (§ ass (§ name cursor) (§ expr cursor + 1))
            (§ var #_"int" (§ name additionalBytes) 0)
            (§ if (§ expr 0 <= opcode && opcode < OP_PUSHDATA1))
            (§ block
                (§ ass (§ name additionalBytes) opcode)
            )
            (§ elseif (§ expr opcode == OP_PUSHDATA1))
            (§ block
                (§ ass (§ name additionalBytes) (§ expr (§ expr 0xff & inputScript[cursor]) + 1))
            )
            (§ elseif (§ expr opcode == OP_PUSHDATA2))
            (§ block
                (§ ass (§ name additionalBytes) (§ expr (§ expr (§ expr 0xff & inputScript[cursor]) | (§ expr (§ expr 0xff & inputScript[cursor + 1]) << 8)) + 2))
            )
            (§ elseif (§ expr opcode == OP_PUSHDATA4))
            (§ block
                (§ ass (§ name additionalBytes) (§ expr (§ expr (§ expr 0xff & inputScript[cursor]) | (§ expr (§ expr 0xff & inputScript[cursor + 1]) << 8) | (§ expr (§ expr 0xff & inputScript[cursor + 1]) << 16) | (§ expr (§ expr 0xff & inputScript[cursor + 1]) << 24)) + 4))
            )
            (§ if (§ expr (§ not skip)))
            (§ block
                (§ try )
                (§ block
                    (§ expr bos.write(§ pars opcode))
                    (§ expr bos.write(§ pars Arrays/copyOfRange(§ pars inputScript, cursor, cursor + additionalBytes)))
                )
                (§ catch #_"IOException" (§ name e))
                (§ block
                    (§ throw (§ new #_"RuntimeException" (§ pars e)))
                )
            )
            (§ ass (§ name cursor) (§ expr cursor + additionalBytes))
        )
        (§ return (§ expr bos.toByteArray(§ pars )))
    )

    ;;;
     ; Returns the script bytes of inputScript with all instances of the given op code removed.
     ;;
    #_public
    #_static
    (§ method #_"byte[]" (§ fn removeAllInstancesOfOp) [#_"byte[]" (§ name inputScript), #_"int" (§ name opCode)])
    (§ block
        (§ return (§ expr removeAllInstancesOf(§ pars inputScript, new byte[] (§ coll (§ cast #_"byte" opCode)))))
    )

    #_private
    #_static
    (§ method #_"boolean" (§ fn castToBool) [#_"byte[]" (§ name data)])
    (§ block
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < data.length) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            ;; "Can be negative zero" - Bitcoin Core (see OpenSSL's BN_bn2mpi)
            (§ if (§ expr data[i] != 0))
            (§ block
                (§ return (§ expr i != data.length - 1 || (§ expr data[i] & 0xff) != 0x80))
            )
        )
        (§ return false)
    )

    ;;;
     ; Cast a script chunk to a BigInteger.
     ;
     ; @see #castToBigInteger(byte[], int) for values with different maximum sizes.
     ; @throws ScriptException if the chunk is longer than 4 bytes.
     ;;
    #_private
    #_static
    (§ method #_"BigInteger" (§ fn castToBigInteger) [#_"byte[]" (§ name chunk), #_final #_"boolean" (§ name requireMinimal)])
        (§ throws #_"ScriptException")
    (§ block
        (§ return (§ expr castToBigInteger(§ pars chunk, 4, requireMinimal)))
    )

    ;;;
     ; Cast a script chunk to a BigInteger.  Normally you would want {@link #castToBigInteger(byte[])} instead, this
     ; is only for cases where the normal maximum length does not apply (i.e. CHECKLOCKTIMEVERIFY, CHECKSEQUENCEVERIFY).
     ;
     ; @param maxLength The maximum length in bytes.
     ; @param requireMinimal Check if the number is encoded with the minimum possible number of bytes.
     ; @throws ScriptException if the chunk is longer than the specified maximum.
     ;;
    #_private
    #_static
    (§ method #_"BigInteger" (§ fn castToBigInteger) [#_final #_"byte[]" (§ name chunk), #_final #_"int" (§ name maxLength), #_final #_"boolean" (§ name requireMinimal)])
        (§ throws #_"ScriptException")
    (§ block
        (§ if (§ expr maxLength < chunk.length))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "Script attempted to use an integer larger than " + maxLength + " bytes")))
        )

        (§ if (§ expr requireMinimal && 0 < chunk.length))
        (§ block
            ;; Check that the number is encoded with the minimum possible number of bytes.
            ;;
            ;; If the most-significant-byte - excluding the sign bit - is zero, then we're not minimal.
            ;; Note how this test also rejects the negative-zero encoding, 0x80.
            (§ if (§ expr (§ expr chunk[chunk.length - 1] & 0x7f) == 0))
            (§ block
                ;; One exception: if there's more than one byte and the most significant bit
                ;; of the second-most-significant-byte is set, it would conflict with the sign bit.
                ;; An example of this case is +-255, which encode to 0xff00 and 0xff80 respectively.
                ;; (big-endian)
                (§ if (§ expr chunk.length <= 1 || (§ expr chunk[chunk.length - 2] & 0x80) == 0))
                (§ block
                    (§ throw  new ScriptException(§ pars ScriptError/SCRIPT_ERR_UNKNOWN_ERROR, "non-minimally encoded script number"))
                )
            )
        )

        (§ return (§ expr Utils/decodeMPI(§ pars Utils/reverseBytes(§ pars chunk), false)))
    )

    #_public
    (§ method #_"boolean" (§ fn isOpReturn) [])
    (§ block
        (§ return (§ expr 0 < chunks.size(§ pars ) && chunks.get(§ pars 0).equalsOpCode(§ pars OP_RETURN)))
    )

    ;;;
     ; Exposes the script interpreter.  Normally you should not use this directly, instead use
     ; {@link org.bitcoinj.core.TransactionInput#verify(org.bitcoinj.core.TransactionOutput)} or
     ; {@link org.bitcoinj.script.Script#correctlySpends(org.bitcoinj.core.Transaction, long, Script)}.
     ; This method is useful if you need more precise control or access to the final state of the stack.
     ; This interface is very likely to change in future.
     ;
     ; @deprecated Use {@link #executeScript(org.bitcoinj.core.Transaction, long, org.bitcoinj.script.Script, java.util.LinkedList, java.util.Set)}
     ; instead.
     ;;
    #_deprecated
    #_public
    #_static
    (§ method #_"void" (§ fn executeScript) [#_nilable #_"Transaction" (§ name txContainingThis), #_"long" (§ name index), #_"Script" (§ name script), #_"LinkedList<byte[]>" (§ name stack), #_"boolean" (§ name enforceNullDummy)])
        (§ throws #_"ScriptException")
    (§ block
        #_final
        (§ var #_"EnumSet<VerifyFlag>" (§ name flags) (§ quest enforceNullDummy ? (§ expr EnumSet/of(§ pars VerifyFlag/NULLDUMMY)) :else (§ expr EnumSet/noneOf(§ pars (§ klass #_"VerifyFlag")))))

        (§ expr executeScript(§ pars txContainingThis, index, script, stack, flags))
        (§ void nil)
    )

    ;;;
     ; Exposes the script interpreter.  Normally you should not use this directly, instead use
     ; {@link org.bitcoinj.core.TransactionInput#verify(org.bitcoinj.core.TransactionOutput)} or
     ; {@link org.bitcoinj.script.Script#correctlySpends(org.bitcoinj.core.Transaction, long, Script)}.
     ; This method is useful if you need more precise control or access to the final state of the stack.
     ; This interface is very likely to change in future.
     ;;
    #_public
    #_static
    (§ method #_"void" (§ fn executeScript) [#_nilable #_"Transaction" (§ name txContainingThis), #_"long" (§ name index), #_"Script" (§ name script), #_"LinkedList<byte[]>" (§ name stack), #_"Set<VerifyFlag>" (§ name verifyFlags)])
        (§ throws #_"ScriptException")
    (§ block
        (§ var #_"int" (§ name opCount) 0)
        (§ var #_"int" (§ name lastCodeSepLocation) 0)

        (§ var #_"LinkedList<byte[]>" (§ name altstack) (§ new #_"LinkedList<>" (§ pars )))
        (§ var #_"LinkedList<Boolean>" (§ name ifStack) (§ new #_"LinkedList<>" (§ pars )))

        (§ for (§ var #_"ScriptChunk" (§ name chunk)) :for (§ expr script.chunks))
        (§ block
            (§ var #_"boolean" (§ name shouldExecute) (§ expr (§ not ifStack.contains(§ pars false))))
            (§ var #_"int" (§ name opcode) (§ expr chunk.opcode))

            ;; Check stack element size.
            (§ if (§ expr chunk.data != nil && MAX_SCRIPT_ELEMENT_SIZE < chunk.data.length))
            (§ block
                (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_PUSH_SIZE, "Attempted to push a data string larger than 520 bytes")))
            )

            ;; Note how OP_RESERVED does not count towards the opcode limit.
            (§ if (§ expr OP_16 < opcode))
            (§ block
                (§ ass (§ name opCount) (§ expr opCount + 1))
                (§ if (§ expr MAX_OPS_PER_SCRIPT < opCount))
                (§ block
                    (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_OP_COUNT, "More script operations than is allowed")))
                )
            )

            ;; Disabled opcodes.
            (§ if (§ expr opcode == OP_CAT || opcode == OP_SUBSTR || opcode == OP_LEFT || opcode == OP_RIGHT || opcode == OP_INVERT || opcode == OP_AND || opcode == OP_OR || opcode == OP_XOR || opcode == OP_2MUL || opcode == OP_2DIV || opcode == OP_MUL || opcode == OP_DIV || opcode == OP_MOD || opcode == OP_LSHIFT || opcode == OP_RSHIFT))
            (§ block
                (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_DISABLED_OPCODE, "Script included a disabled Script Op.")))
            )

            (§ if (§ expr shouldExecute && OP_0 <= opcode && opcode <= OP_PUSHDATA4))
            (§ block
                ;; Check minimal push.
                (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag/MINIMALDATA) && (§ not chunk.isShortestPossiblePushData(§ pars ))))
                (§ block
                    (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_MINIMALDATA, "Script included a not minimal push operation.")))
                )

                (§ if (§ expr opcode == OP_0))
                (§ block
                    (§ expr stack.add(§ pars (§ new #_"byte[]" (§ coll ))))
                )
                (§ else )
                (§ block
                    (§ expr stack.add(§ pars chunk.data))
                )
            )
            (§ elseif (§ expr shouldExecute || (§ expr OP_IF <= opcode && opcode <= OP_ENDIF)))
            (§ block
                (§ switch opcode)
                (§ block
                    (§ case OP_IF)
                    (§ block
                        (§ if (§ expr (§ not shouldExecute)))
                        (§ block
                            (§ expr ifStack.add(§ pars false))
                            (§ continue )
                        )
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_IF on an empty stack")))
                        )
                        (§ expr ifStack.add(§ pars castToBool(§ pars stack.pollLast(§ pars ))))
                        (§ continue )
                    )
                    (§ case OP_NOTIF)
                    (§ block
                        (§ if (§ expr (§ not shouldExecute)))
                        (§ block
                            (§ expr ifStack.add(§ pars false))
                            (§ continue )
                        )
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_NOTIF on an empty stack")))
                        )
                        (§ expr ifStack.add(§ pars (§ not castToBool(§ pars stack.pollLast(§ pars )))))
                        (§ continue )
                    )
                    (§ case OP_ELSE)
                    (§ block
                        (§ if (§ expr ifStack.isEmpty(§ pars )))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_ELSE without OP_IF/NOTIF")))
                        )
                        (§ expr ifStack.add(§ pars (§ not ifStack.pollLast(§ pars ))))
                        (§ continue )
                    )
                    (§ case OP_ENDIF)
                    (§ block
                        (§ if (§ expr ifStack.isEmpty(§ pars )))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNBALANCED_CONDITIONAL, "Attempted OP_ENDIF without OP_IF/NOTIF")))
                        )
                        (§ expr ifStack.pollLast(§ pars ))
                        (§ continue )
                    )

                    ;; OP_0 is no opcode
                    (§ case OP_1NEGATE)
                    (§ block
                        (§ expr stack.add(§ pars Utils/reverseBytes(§ pars Utils/encodeMPI(§ pars BigInteger/ONE.negate(§ pars ), false))))
                        (§ break )
                    )
                    (§ case OP_1)
                    (§ case OP_2)
                    (§ case OP_3)
                    (§ case OP_4)
                    (§ case OP_5)
                    (§ case OP_6)
                    (§ case OP_7)
                    (§ case OP_8)
                    (§ case OP_9)
                    (§ case OP_10)
                    (§ case OP_11)
                    (§ case OP_12)
                    (§ case OP_13)
                    (§ case OP_14)
                    (§ case OP_15)
                    (§ case OP_16)
                    (§ block
                        (§ expr stack.add(§ pars Utils/reverseBytes(§ pars Utils/encodeMPI(§ pars BigInteger/valueOf(§ pars decodeFromOpN(§ pars opcode)), false))))
                        (§ break )
                    )
                    (§ case OP_NOP)
                    (§ block
                        (§ break )
                    )
                    (§ case OP_VERIFY)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_VERIFY on an empty stack")))
                        )
                        (§ if (§ expr (§ not castToBool(§ pars stack.pollLast(§ pars )))))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_VERIFY, "OP_VERIFY failed")))
                        )
                        (§ break )
                    )
                    (§ case OP_RETURN)
                    (§ block
                        (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_OP_RETURN, "Script called OP_RETURN")))
                    )
                    (§ case OP_TOALTSTACK)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_TOALTSTACK on an empty stack")))
                        )
                        (§ expr altstack.add(§ pars stack.pollLast(§ pars )))
                        (§ break )
                    )
                    (§ case OP_FROMALTSTACK)
                    (§ block
                        (§ if (§ expr altstack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_ALTSTACK_OPERATION, "Attempted OP_FROMALTSTACK on an empty altstack")))
                        )
                        (§ expr stack.add(§ pars altstack.pollLast(§ pars )))
                        (§ break )
                    )
                    (§ case OP_2DROP)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 2))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2DROP on a stack with size < 2")))
                        )
                        (§ expr stack.pollLast(§ pars ))
                        (§ expr stack.pollLast(§ pars ))
                        (§ break )
                    )
                    (§ case OP_2DUP)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 2))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2DUP on a stack with size < 2")))
                        )
                        (§ var #_"Iterator<byte[]>" (§ name it2DUP) (§ expr stack.descendingIterator(§ pars )))
                        (§ var #_"byte[]" (§ name OP2DUPtmpChunk2) (§ expr it2DUP.next(§ pars )))
                        (§ expr stack.add(§ pars it2DUP.next(§ pars )))
                        (§ expr stack.add(§ pars OP2DUPtmpChunk2))
                        (§ break )
                    )
                    (§ case OP_3DUP)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 3))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_3DUP on a stack with size < 3")))
                        )
                        (§ var #_"Iterator<byte[]>" (§ name it3DUP) (§ expr stack.descendingIterator(§ pars )))
                        (§ var #_"byte[]" (§ name OP3DUPtmpChunk3) (§ expr it3DUP.next(§ pars )))
                        (§ var #_"byte[]" (§ name OP3DUPtmpChunk2) (§ expr it3DUP.next(§ pars )))
                        (§ expr stack.add(§ pars it3DUP.next(§ pars )))
                        (§ expr stack.add(§ pars OP3DUPtmpChunk2))
                        (§ expr stack.add(§ pars OP3DUPtmpChunk3))
                        (§ break )
                    )
                    (§ case OP_2OVER)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 4))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2OVER on a stack with size < 4")))
                        )
                        (§ var #_"Iterator<byte[]>" (§ name it2OVER) (§ expr stack.descendingIterator(§ pars )))
                        (§ expr it2OVER.next(§ pars ))
                        (§ expr it2OVER.next(§ pars ))
                        (§ var #_"byte[]" (§ name OP2OVERtmpChunk2) (§ expr it2OVER.next(§ pars )))
                        (§ expr stack.add(§ pars it2OVER.next(§ pars )))
                        (§ expr stack.add(§ pars OP2OVERtmpChunk2))
                        (§ break )
                    )
                    (§ case OP_2ROT)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 6))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2ROT on a stack with size < 6")))
                        )
                        (§ var #_"byte[]" (§ name OP2ROTtmpChunk6) (§ expr stack.pollLast(§ pars )))
                        (§ var #_"byte[]" (§ name OP2ROTtmpChunk5) (§ expr stack.pollLast(§ pars )))
                        (§ var #_"byte[]" (§ name OP2ROTtmpChunk4) (§ expr stack.pollLast(§ pars )))
                        (§ var #_"byte[]" (§ name OP2ROTtmpChunk3) (§ expr stack.pollLast(§ pars )))
                        (§ var #_"byte[]" (§ name OP2ROTtmpChunk2) (§ expr stack.pollLast(§ pars )))
                        (§ var #_"byte[]" (§ name OP2ROTtmpChunk1) (§ expr stack.pollLast(§ pars )))
                        (§ expr stack.add(§ pars OP2ROTtmpChunk3))
                        (§ expr stack.add(§ pars OP2ROTtmpChunk4))
                        (§ expr stack.add(§ pars OP2ROTtmpChunk5))
                        (§ expr stack.add(§ pars OP2ROTtmpChunk6))
                        (§ expr stack.add(§ pars OP2ROTtmpChunk1))
                        (§ expr stack.add(§ pars OP2ROTtmpChunk2))
                        (§ break )
                    )
                    (§ case OP_2SWAP)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 4))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_2SWAP on a stack with size < 4")))
                        )
                        (§ var #_"byte[]" (§ name OP2SWAPtmpChunk4) (§ expr stack.pollLast(§ pars )))
                        (§ var #_"byte[]" (§ name OP2SWAPtmpChunk3) (§ expr stack.pollLast(§ pars )))
                        (§ var #_"byte[]" (§ name OP2SWAPtmpChunk2) (§ expr stack.pollLast(§ pars )))
                        (§ var #_"byte[]" (§ name OP2SWAPtmpChunk1) (§ expr stack.pollLast(§ pars )))
                        (§ expr stack.add(§ pars OP2SWAPtmpChunk3))
                        (§ expr stack.add(§ pars OP2SWAPtmpChunk4))
                        (§ expr stack.add(§ pars OP2SWAPtmpChunk1))
                        (§ expr stack.add(§ pars OP2SWAPtmpChunk2))
                        (§ break )
                    )
                    (§ case OP_IFDUP)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_IFDUP on an empty stack")))
                        )
                        (§ if (§ expr castToBool(§ pars stack.getLast(§ pars ))))
                        (§ block
                            (§ expr stack.add(§ pars stack.getLast(§ pars )))
                        )
                        (§ break )
                    )
                    (§ case OP_DEPTH)
                    (§ block
                        (§ expr stack.add(§ pars Utils/reverseBytes(§ pars Utils/encodeMPI(§ pars BigInteger/valueOf(§ pars stack.size(§ pars )), false))))
                        (§ break )
                    )
                    (§ case OP_DROP)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_DROP on an empty stack")))
                        )
                        (§ expr stack.pollLast(§ pars ))
                        (§ break )
                    )
                    (§ case OP_DUP)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_DUP on an empty stack")))
                        )
                        (§ expr stack.add(§ pars stack.getLast(§ pars )))
                        (§ break )
                    )
                    (§ case OP_NIP)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 2))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_NIP on a stack with size < 2")))
                        )
                        (§ var #_"byte[]" (§ name OPNIPtmpChunk) (§ expr stack.pollLast(§ pars )))
                        (§ expr stack.pollLast(§ pars ))
                        (§ expr stack.add(§ pars OPNIPtmpChunk))
                        (§ break )
                    )
                    (§ case OP_OVER)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 2))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_OVER on a stack with size < 2")))
                        )
                        (§ var #_"Iterator<byte[]>" (§ name itOVER) (§ expr stack.descendingIterator(§ pars )))
                        (§ expr itOVER.next(§ pars ))
                        (§ expr stack.add(§ pars itOVER.next(§ pars )))
                        (§ break )
                    )
                    (§ case OP_PICK)
                    (§ case OP_ROLL)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_PICK/OP_ROLL on an empty stack")))
                        )
                        (§ var #_"long" (§ name val) (§ expr castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag/MINIMALDATA)).longValue(§ pars )))
                        (§ if (§ expr val < 0 || stack.size(§ pars ) <= val))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "OP_PICK/OP_ROLL attempted to get data deeper than stack size")))
                        )
                        (§ var #_"Iterator<byte[]>" (§ name itPICK) (§ expr stack.descendingIterator(§ pars )))
                        (§ for (§ var #_"long" (§ name i) 0) :for (§ expr i < val) :for (§ ass (§ name i) (§ expr i + 1)))
                        (§ block
                            (§ expr itPICK.next(§ pars ))
                        )
                        (§ var #_"byte[]" (§ name OPROLLtmpChunk) (§ expr itPICK.next(§ pars )))
                        (§ if (§ expr opcode == OP_ROLL))
                        (§ block
                            (§ expr itPICK.remove(§ pars ))
                        )
                        (§ expr stack.add(§ pars OPROLLtmpChunk))
                        (§ break )
                    )
                    (§ case OP_ROT)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 3))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_ROT on a stack with size < 3")))
                        )
                        (§ var #_"byte[]" (§ name OPROTtmpChunk3) (§ expr stack.pollLast(§ pars )))
                        (§ var #_"byte[]" (§ name OPROTtmpChunk2) (§ expr stack.pollLast(§ pars )))
                        (§ var #_"byte[]" (§ name OPROTtmpChunk1) (§ expr stack.pollLast(§ pars )))
                        (§ expr stack.add(§ pars OPROTtmpChunk2))
                        (§ expr stack.add(§ pars OPROTtmpChunk3))
                        (§ expr stack.add(§ pars OPROTtmpChunk1))
                        (§ break )
                    )
                    (§ case OP_SWAP)
                    (§ case OP_TUCK)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 2))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SWAP on a stack with size < 2")))
                        )
                        (§ var #_"byte[]" (§ name OPSWAPtmpChunk2) (§ expr stack.pollLast(§ pars )))
                        (§ var #_"byte[]" (§ name OPSWAPtmpChunk1) (§ expr stack.pollLast(§ pars )))
                        (§ expr stack.add(§ pars OPSWAPtmpChunk2))
                        (§ expr stack.add(§ pars OPSWAPtmpChunk1))
                        (§ if (§ expr opcode == OP_TUCK))
                        (§ block
                            (§ expr stack.add(§ pars OPSWAPtmpChunk2))
                        )
                        (§ break )
                    )
                    (§ case OP_SIZE)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SIZE on an empty stack")))
                        )
                        (§ expr stack.add(§ pars Utils/reverseBytes(§ pars Utils/encodeMPI(§ pars BigInteger/valueOf(§ pars stack.getLast(§ pars ).length), false))))
                        (§ break )
                    )
                    (§ case OP_EQUAL)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 2))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_EQUAL on a stack with size < 2")))
                        )
                        (§ expr stack.add(§ pars (§ quest (§ expr Arrays/equals(§ pars stack.pollLast(§ pars ), stack.pollLast(§ pars ))) ? (§ new #_"byte[]" (§ coll 1 )) :else (§ new #_"byte[]" (§ coll )))))
                        (§ break )
                    )
                    (§ case OP_EQUALVERIFY)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 2))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_EQUALVERIFY on a stack with size < 2")))
                        )
                        (§ if (§ expr (§ not Arrays/equals(§ pars stack.pollLast(§ pars ), stack.pollLast(§ pars )))))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_EQUALVERIFY, "OP_EQUALVERIFY: non-equal data")))
                        )
                        (§ break )
                    )
                    (§ case OP_1ADD)
                    (§ case OP_1SUB)
                    (§ case OP_NEGATE)
                    (§ case OP_ABS)
                    (§ case OP_NOT)
                    (§ case OP_0NOTEQUAL)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted a numeric op on an empty stack")))
                        )
                        (§ var #_"BigInteger" (§ name numericOPnum) (§ expr castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag/MINIMALDATA))))

                        (§ switch opcode)
                        (§ block
                            (§ case OP_1ADD)
                            (§ block
                                (§ ass (§ name numericOPnum) (§ expr numericOPnum.add(§ pars BigInteger/ONE)))
                                (§ break )
                            )
                            (§ case OP_1SUB)
                            (§ block
                                (§ ass (§ name numericOPnum) (§ expr numericOPnum.subtract(§ pars BigInteger/ONE)))
                                (§ break )
                            )
                            (§ case OP_NEGATE)
                            (§ block
                                (§ ass (§ name numericOPnum) (§ expr numericOPnum.negate(§ pars )))
                                (§ break )
                            )
                            (§ case OP_ABS)
                            (§ block
                                (§ if (§ expr numericOPnum.signum(§ pars ) < 0))
                                (§ block
                                    (§ ass (§ name numericOPnum) (§ expr numericOPnum.negate(§ pars )))
                                )
                                (§ break )
                            )
                            (§ case OP_NOT)
                            (§ block
                                (§ if (§ expr numericOPnum.equals(§ pars BigInteger/ZERO)))
                                (§ block
                                    (§ ass (§ name numericOPnum) (§ expr BigInteger/ONE))
                                )
                                (§ else )
                                (§ block
                                    (§ ass (§ name numericOPnum) (§ expr BigInteger/ZERO))
                                )
                                (§ break )
                            )
                            (§ case OP_0NOTEQUAL)
                            (§ block
                                (§ if (§ expr numericOPnum.equals(§ pars BigInteger/ZERO)))
                                (§ block
                                    (§ ass (§ name numericOPnum) (§ expr BigInteger/ZERO))
                                )
                                (§ else )
                                (§ block
                                    (§ ass (§ name numericOPnum) (§ expr BigInteger/ONE))
                                )
                                (§ break )
                            )
                            (§ default )
                            (§ block
                                (§ throw (§ new #_"AssertionError" (§ pars "Unreachable")))
                            )
                        )

                        (§ expr stack.add(§ pars Utils/reverseBytes(§ pars Utils/encodeMPI(§ pars numericOPnum, false))))
                        (§ break )
                    )
                    (§ case OP_ADD)
                    (§ case OP_SUB)
                    (§ case OP_BOOLAND)
                    (§ case OP_BOOLOR)
                    (§ case OP_NUMEQUAL)
                    (§ case OP_NUMNOTEQUAL)
                    (§ case OP_LESSTHAN)
                    (§ case OP_GREATERTHAN)
                    (§ case OP_LESSTHANOREQUAL)
                    (§ case OP_GREATERTHANOREQUAL)
                    (§ case OP_MIN)
                    (§ case OP_MAX)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 2))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted a numeric op on a stack with size < 2")))
                        )
                        (§ var #_"BigInteger" (§ name numericOPnum2) (§ expr castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag/MINIMALDATA))))
                        (§ var #_"BigInteger" (§ name numericOPnum1) (§ expr castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag/MINIMALDATA))))

                        (§ var #_"BigInteger" (§ name numericOPresult))
                        (§ switch opcode)
                        (§ block
                            (§ case OP_ADD)
                            (§ block
                                (§ ass (§ name numericOPresult) (§ expr numericOPnum1.add(§ pars numericOPnum2)))
                                (§ break )
                            )
                            (§ case OP_SUB)
                            (§ block
                                (§ ass (§ name numericOPresult) (§ expr numericOPnum1.subtract(§ pars numericOPnum2)))
                                (§ break )
                            )
                            (§ case OP_BOOLAND)
                            (§ block
                                (§ if (§ expr (§ not numericOPnum1.equals(§ pars BigInteger/ZERO)) && (§ not numericOPnum2.equals(§ pars BigInteger/ZERO))))
                                (§ block
                                    (§ ass (§ name numericOPresult) (§ expr BigInteger/ONE))
                                )
                                (§ else )
                                (§ block
                                    (§ ass (§ name numericOPresult) (§ expr BigInteger/ZERO))
                                )
                                (§ break )
                            )
                            (§ case OP_BOOLOR)
                            (§ block
                                (§ if (§ expr (§ not numericOPnum1.equals(§ pars BigInteger/ZERO)) || (§ not numericOPnum2.equals(§ pars BigInteger/ZERO))))
                                (§ block
                                    (§ ass (§ name numericOPresult) (§ expr BigInteger/ONE))
                                )
                                (§ else )
                                (§ block
                                    (§ ass (§ name numericOPresult) (§ expr BigInteger/ZERO))
                                )
                                (§ break )
                            )
                            (§ case OP_NUMEQUAL)
                            (§ block
                                (§ if (§ expr numericOPnum1.equals(§ pars numericOPnum2)))
                                (§ block
                                    (§ ass (§ name numericOPresult) (§ expr BigInteger/ONE))
                                )
                                (§ else )
                                (§ block
                                    (§ ass (§ name numericOPresult) (§ expr BigInteger/ZERO))
                                )
                                (§ break )
                            )
                            (§ case OP_NUMNOTEQUAL)
                            (§ block
                                (§ if (§ expr (§ not numericOPnum1.equals(§ pars numericOPnum2))))
                                (§ block
                                    (§ ass (§ name numericOPresult) (§ expr BigInteger/ONE))
                                )
                                (§ else )
                                (§ block
                                    (§ ass (§ name numericOPresult) (§ expr BigInteger/ZERO))
                                )
                                (§ break )
                            )
                            (§ case OP_LESSTHAN)
                            (§ block
                                (§ if (§ expr numericOPnum1.compareTo(§ pars numericOPnum2) < 0))
                                (§ block
                                    (§ ass (§ name numericOPresult) (§ expr BigInteger/ONE))
                                )
                                (§ else )
                                (§ block
                                    (§ ass (§ name numericOPresult) (§ expr BigInteger/ZERO))
                                )
                                (§ break )
                            )
                            (§ case OP_GREATERTHAN)
                            (§ block
                                (§ if (§ expr numericOPnum1.compareTo(§ pars numericOPnum2) > 0))
                                (§ block
                                    (§ ass (§ name numericOPresult) (§ expr BigInteger/ONE))
                                )
                                (§ else )
                                (§ block
                                    (§ ass (§ name numericOPresult) (§ expr BigInteger/ZERO))
                                )
                                (§ break )
                            )
                            (§ case OP_LESSTHANOREQUAL)
                            (§ block
                                (§ if (§ expr numericOPnum1.compareTo(§ pars numericOPnum2) <= 0))
                                (§ block
                                    (§ ass (§ name numericOPresult) (§ expr BigInteger/ONE))
                                )
                                (§ else )
                                (§ block
                                    (§ ass (§ name numericOPresult) (§ expr BigInteger/ZERO))
                                )
                                (§ break )
                            )
                            (§ case OP_GREATERTHANOREQUAL)
                            (§ block
                                (§ if (§ expr numericOPnum1.compareTo(§ pars numericOPnum2) >= 0))
                                (§ block
                                    (§ ass (§ name numericOPresult) (§ expr BigInteger/ONE))
                                )
                                (§ else )
                                (§ block
                                    (§ ass (§ name numericOPresult) (§ expr BigInteger/ZERO))
                                )
                                (§ break )
                            )
                            (§ case OP_MIN)
                            (§ block
                                (§ if (§ expr numericOPnum1.compareTo(§ pars numericOPnum2) < 0))
                                (§ block
                                    (§ ass (§ name numericOPresult) numericOPnum1)
                                )
                                (§ else )
                                (§ block
                                    (§ ass (§ name numericOPresult) numericOPnum2)
                                )
                                (§ break )
                            )
                            (§ case OP_MAX)
                            (§ block
                                (§ if (§ expr numericOPnum1.compareTo(§ pars numericOPnum2) > 0))
                                (§ block
                                    (§ ass (§ name numericOPresult) numericOPnum1)
                                )
                                (§ else )
                                (§ block
                                    (§ ass (§ name numericOPresult) numericOPnum2)
                                )
                                (§ break )
                            )
                            (§ default )
                            (§ block
                                (§ throw (§ new #_"RuntimeException" (§ pars "Opcode switched at runtime?")))
                            )
                        )

                        (§ expr stack.add(§ pars Utils/reverseBytes(§ pars Utils/encodeMPI(§ pars numericOPresult, false))))
                        (§ break )
                    )
                    (§ case OP_NUMEQUALVERIFY)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 2))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_NUMEQUALVERIFY on a stack with size < 2")))
                        )
                        (§ var #_"BigInteger" (§ name OPNUMEQUALVERIFYnum2) (§ expr castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag/MINIMALDATA))))
                        (§ var #_"BigInteger" (§ name OPNUMEQUALVERIFYnum1) (§ expr castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag/MINIMALDATA))))

                        (§ if (§ expr (§ not OPNUMEQUALVERIFYnum1.equals(§ pars OPNUMEQUALVERIFYnum2))))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_NUMEQUALVERIFY, "OP_NUMEQUALVERIFY failed")))
                        )
                        (§ break )
                    )
                    (§ case OP_WITHIN)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 3))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_WITHIN on a stack with size < 3")))
                        )
                        (§ var #_"BigInteger" (§ name OPWITHINnum3) (§ expr castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag/MINIMALDATA))))
                        (§ var #_"BigInteger" (§ name OPWITHINnum2) (§ expr castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag/MINIMALDATA))))
                        (§ var #_"BigInteger" (§ name OPWITHINnum1) (§ expr castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag/MINIMALDATA))))
                        (§ if (§ expr OPWITHINnum2.compareTo(§ pars OPWITHINnum1) <= 0 && OPWITHINnum1.compareTo(§ pars OPWITHINnum3) < 0))
                        (§ block
                            (§ expr stack.add(§ pars Utils/reverseBytes(§ pars Utils/encodeMPI(§ pars BigInteger/ONE, false))))
                        )
                        (§ else )
                        (§ block
                            (§ expr stack.add(§ pars Utils/reverseBytes(§ pars Utils/encodeMPI(§ pars BigInteger/ZERO, false))))
                        )
                        (§ break )
                    )
                    (§ case OP_RIPEMD160)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_RIPEMD160 on an empty stack")))
                        )
                        (§ var #_"RIPEMD160Digest" (§ name digest) (§ new #_"RIPEMD160Digest" (§ pars )))
                        (§ var #_"byte[]" (§ name dataToHash) (§ expr stack.pollLast(§ pars )))
                        (§ expr digest.update(§ pars dataToHash, 0, dataToHash.length))
                        (§ var #_"byte[]" (§ name ripmemdHash) (§ new #_"byte[]" (§ count 20)))
                        (§ expr digest.doFinal(§ pars ripmemdHash, 0))
                        (§ expr stack.add(§ pars ripmemdHash))
                        (§ break )
                    )
                    (§ case OP_SHA1)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SHA1 on an empty stack")))
                        )
                        (§ try )
                        (§ block
                            (§ expr stack.add(§ pars MessageDigest/getInstance(§ pars "SHA-1").digest(§ pars stack.pollLast(§ pars ))))
                        )
                        (§ catch #_"NoSuchAlgorithmException" (§ name e))
                        (§ block
                            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
                        )
                        (§ break )
                    )
                    (§ case OP_SHA256)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SHA256 on an empty stack")))
                        )
                        (§ expr stack.add(§ pars Sha256Hash/hash(§ pars stack.pollLast(§ pars ))))
                        (§ break )
                    )
                    (§ case OP_HASH160)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_HASH160 on an empty stack")))
                        )
                        (§ expr stack.add(§ pars Utils/sha256hash160(§ pars stack.pollLast(§ pars ))))
                        (§ break )
                    )
                    (§ case OP_HASH256)
                    (§ block
                        (§ if (§ expr stack.size(§ pars ) < 1))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_SHA256 on an empty stack")))
                        )
                        (§ expr stack.add(§ pars Sha256Hash/hashTwice(§ pars stack.pollLast(§ pars ))))
                        (§ break )
                    )
                    (§ case OP_CODESEPARATOR)
                    (§ block
                        (§ ass (§ name lastCodeSepLocation) (§ expr chunk.getStartLocationInProgram(§ pars ) + 1))
                        (§ break )
                    )
                    (§ case OP_CHECKSIG)
                    (§ case OP_CHECKSIGVERIFY)
                    (§ block
                        (§ if (§ expr txContainingThis == nil))
                        (§ block
                            (§ throw (§ new #_"IllegalStateException" (§ pars "Script attempted signature check but no tx was provided")))
                        )
                        (§ expr executeCheckSig(§ pars txContainingThis, (§ cast #_"int" index), script, stack, lastCodeSepLocation, opcode, verifyFlags))
                        (§ break )
                    )
                    (§ case OP_CHECKMULTISIG)
                    (§ case OP_CHECKMULTISIGVERIFY)
                    (§ block
                        (§ if (§ expr txContainingThis == nil))
                        (§ block
                            (§ throw (§ new #_"IllegalStateException" (§ pars "Script attempted signature check but no tx was provided")))
                        )
                        (§ ass (§ name opCount) (§ expr executeMultiSig(§ pars txContainingThis, (§ cast #_"int" index), script, stack, opCount, lastCodeSepLocation, opcode, verifyFlags)))
                        (§ break )
                    )
                    (§ case OP_CHECKLOCKTIMEVERIFY)
                    (§ block
                        (§ if (§ expr (§ not verifyFlags.contains(§ pars VerifyFlag/CHECKLOCKTIMEVERIFY))))
                        (§ block
                            ;; not enabled; treat as a NOP2
                            (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag/DISCOURAGE_UPGRADABLE_NOPS)))
                            (§ block
                                (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, "Script used a reserved opcode " + opcode)))
                            )
                            (§ break )
                        )
                        (§ expr executeCheckLockTimeVerify(§ pars txContainingThis, (§ cast #_"int" index), stack, verifyFlags))
                        (§ break )
                    )
                    (§ case OP_CHECKSEQUENCEVERIFY)
                    (§ block
                        (§ if (§ expr (§ not verifyFlags.contains(§ pars VerifyFlag/CHECKSEQUENCEVERIFY))))
                        (§ block
                            ;; not enabled; treat as a NOP3
                            (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag/DISCOURAGE_UPGRADABLE_NOPS)))
                            (§ block
                                (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, "Script used a reserved opcode " + opcode)))
                            )
                            (§ break )
                        )
                        (§ expr executeCheckSequenceVerify(§ pars txContainingThis, (§ cast #_"int" index), stack, verifyFlags))
                        (§ break )
                    )
                    (§ case OP_NOP1)
                    (§ case OP_NOP4)
                    (§ case OP_NOP5)
                    (§ case OP_NOP6)
                    (§ case OP_NOP7)
                    (§ case OP_NOP8)
                    (§ case OP_NOP9)
                    (§ case OP_NOP10)
                    (§ block
                        (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag/DISCOURAGE_UPGRADABLE_NOPS)))
                        (§ block
                            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS, "Script used a reserved opcode " + opcode)))
                        )
                        (§ break )
                    )

                    (§ default )
                    (§ block
                        (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_BAD_OPCODE, "Script used a reserved or disabled opcode: " + opcode)))
                    )
                )
            )

            (§ if (§ expr MAX_STACK_SIZE < stack.size(§ pars ) + altstack.size(§ pars ) || stack.size(§ pars ) + altstack.size(§ pars ) < 0))
            (§ block
                (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_STACK_SIZE, "Stack size exceeded range")))
            )
        )

        (§ if (§ expr (§ not ifStack.isEmpty(§ pars ))))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNBALANCED_CONDITIONAL, "OP_IF/OP_NOTIF without OP_ENDIF")))
        )
        (§ void nil)
    )

    ;; This is more or less a direct translation of the code in Bitcoin Core.
    #_private
    #_static
    (§ method #_"void" (§ fn executeCheckLockTimeVerify) [#_"Transaction" (§ name txContainingThis), #_"int" (§ name index), #_"LinkedList<byte[]>" (§ name stack), #_"Set<VerifyFlag>" (§ name verifyFlags)])
        (§ throws #_"ScriptException")
    (§ block
        (§ if (§ expr stack.size(§ pars ) < 1))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKLOCKTIMEVERIFY on a stack with size < 1")))
        )

        ;; Thus as a special case we tell CScriptNum to accept up to 5-byte bignums to avoid year 2038 issue.
        #_final
        (§ var #_"BigInteger" (§ name nLockTime) (§ expr castToBigInteger(§ pars stack.getLast(§ pars ), 5, verifyFlags.contains(§ pars VerifyFlag/MINIMALDATA))))

        (§ if (§ expr nLockTime.compareTo(§ pars BigInteger/ZERO) < 0))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_NEGATIVE_LOCKTIME, "Negative locktime")))
        )

        ;; There are two kinds of nLockTime, need to ensure we're comparing apples-to-apples.
        (§ if (§ expr (§ not (§ expr (§ expr (§ expr txContainingThis.getLockTime(§ pars ) <  Transaction/LOCKTIME_THRESHOLD) && (§ expr nLockTime.compareTo(§ pars Transaction/LOCKTIME_THRESHOLD_BIG)) <  0) || (§ expr (§ expr txContainingThis.getLockTime(§ pars ) >= Transaction/LOCKTIME_THRESHOLD) && (§ expr nLockTime.compareTo(§ pars Transaction/LOCKTIME_THRESHOLD_BIG)) >= 0)))))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Locktime requirement type mismatch")))
        )

        ;; Now that we know we're comparing apples-to-apples, the comparison is a simple numeric one.
        (§ if (§ expr 0 < nLockTime.compareTo(§ pars BigInteger/valueOf(§ pars txContainingThis.getLockTime(§ pars )))))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Locktime requirement not satisfied")))
        )

        ;; Finally the nLockTime feature can be disabled and thus CHECKLOCKTIMEVERIFY bypassed if every txin has been
        ;; finalized by setting nSequence to maxint.  The transaction would be allowed into the blockchain, making
        ;; the opcode ineffective.
        ;;
        ;; Testing if this vin is not final is sufficient to prevent this condition.  Alternatively we could test all
        ;; inputs, but testing just this input minimizes the data required to prove correct CHECKLOCKTIMEVERIFY execution.
        (§ if (§ not (§ dot txContainingThis.getInput(§ pars index).hasSequence(§ pars ))))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Transaction contains a final transaction input for a CHECKLOCKTIMEVERIFY script.")))
        )
        (§ void nil)
    )

    #_private
    #_static
    (§ method #_"void" (§ fn executeCheckSequenceVerify) [#_"Transaction" (§ name txContainingThis), #_"int" (§ name index), #_"LinkedList<byte[]>" (§ name stack), #_"Set<VerifyFlag>" (§ name verifyFlags)])
        (§ throws #_"ScriptException")
    (§ block
        (§ if (§ expr stack.size(§ pars ) < 1))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKSEQUENCEVERIFY on a stack with size < 1")))
        )

        ;; Note that elsewhere numeric opcodes are limited to operands in the range -2**31+1 to 2**31-1, however
        ;; it is legal for opcodes to produce results exceeding that range.  This limitation is implemented by
        ;; CScriptNum's default 4-byte limit.
        ;;
        ;; Thus as a special case we tell CScriptNum to accept up to 5-byte bignums, which are good until 2**39-1,
        ;; well beyond the 2**32-1 limit of the nSequence field itself.
        #_final
        (§ var #_"long" (§ name nSequence) (§ expr castToBigInteger(§ pars stack.getLast(§ pars ), 5, verifyFlags.contains(§ pars VerifyFlag/MINIMALDATA)).longValue(§ pars )))

        ;; In the rare event that the argument may be < 0 due to some arithmetic being done first, you can always
        ;; use 0 MAX CHECKSEQUENCEVERIFY.
        (§ if (§ expr nSequence < 0))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_NEGATIVE_LOCKTIME, "Negative sequence")))
        )

        ;; To provide for future soft-fork extensibility, if the operand has the disabled lock-time flag set,
        ;; CHECKSEQUENCEVERIFY behaves as a NOP.
        (§ if (§ expr (§ expr nSequence & Transaction/SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0))
        (§ block
            (§ return nil)
        )

        ;; Compare the specified sequence number with the input.
        (§ if (§ expr (§ not checkSequence(§ pars nSequence, txContainingThis, index))))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_UNSATISFIED_LOCKTIME, "Unsatisfied CHECKLOCKTIMEVERIFY lock time")))
        )
        (§ void nil)
    )

    #_private
    #_static
    (§ method #_"boolean" (§ fn checkSequence) [#_"long" (§ name nSequence), #_"Transaction" (§ name txContainingThis), #_"int" (§ name index)])
    (§ block
        ;; Relative lock times are supported by comparing the passed in operand to the sequence number
        ;; of the input.
        (§ var #_"long" (§ name txToSequence) (§ expr txContainingThis.getInput(§ pars index).getSequenceNumber(§ pars )))

        ;; Fail if the transaction's version number is not set high enough to trigger BIP 68 rules.
        (§ if (§ expr txContainingThis.getVersion(§ pars ) < 2))
        (§ block
            (§ return false)
        )

        ;; Sequence numbers with their most significant bit set are not consensus constrained.  Testing
        ;; that the transaction's sequence number do not have this bit set prevents using this property
        ;; to get around a CHECKSEQUENCEVERIFY check.
        (§ if (§ expr (§ expr txToSequence & Transaction/SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0))
        (§ block
            (§ return false)
        )

        ;; Mask off any bits that do not have consensus-enforced meaning before doing the integer comparisons.
        (§ var #_"long" (§ name nLockTimeMask) (§ expr  Transaction/SEQUENCE_LOCKTIME_TYPE_FLAG | Transaction/SEQUENCE_LOCKTIME_MASK))
        (§ var #_"long" (§ name txToSequenceMasked) (§ expr txToSequence & nLockTimeMask))
        (§ var #_"long" (§ name nSequenceMasked) (§ expr nSequence & nLockTimeMask))

        ;; There are two kinds of nSequence: lock-by-blockheight and lock-by-blocktime, distinguished by
        ;; whether nSequenceMasked < CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.
        ;;
        ;; We want to compare apples to apples, so fail the script unless the type of nSequenceMasked
        ;; being tested is the same as the nSequenceMasked in the transaction.
        (§ if (§ expr (§ not (§ expr (§ expr txToSequenceMasked <  Transaction/SEQUENCE_LOCKTIME_TYPE_FLAG && nSequenceMasked <  Transaction/SEQUENCE_LOCKTIME_TYPE_FLAG) || (§ expr txToSequenceMasked >= Transaction/SEQUENCE_LOCKTIME_TYPE_FLAG && nSequenceMasked >= Transaction/SEQUENCE_LOCKTIME_TYPE_FLAG)))))
        (§ block
            (§ return false)
        )

        ;; Now that we know we're comparing apples-to-apples, the comparison is a simple numeric one.
        (§ if (§ expr txToSequenceMasked < nSequenceMasked))
        (§ block
            (§ return false)
        )

        (§ return true)
    )

    #_private
    #_static
    (§ method #_"void" (§ fn executeCheckSig) [#_"Transaction" (§ name txContainingThis), #_"int" (§ name index), #_"Script" (§ name script), #_"LinkedList<byte[]>" (§ name stack), #_"int" (§ name lastCodeSepLocation), #_"int" (§ name opcode), #_"Set<VerifyFlag>" (§ name verifyFlags)])
        (§ throws #_"ScriptException")
    (§ block
        #_final
        (§ var #_"boolean" (§ name requireCanonical) (§ expr verifyFlags.contains(§ pars VerifyFlag/STRICTENC) || verifyFlags.contains(§ pars VerifyFlag/DERSIG) || verifyFlags.contains(§ pars VerifyFlag/LOW_S)))
        (§ if (§ expr stack.size(§ pars ) < 2))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKSIG(VERIFY) on a stack with size < 2")))
        )

        (§ var #_"byte[]" (§ name pubKey) (§ expr stack.pollLast(§ pars )))
        (§ var #_"byte[]" (§ name sigBytes) (§ expr stack.pollLast(§ pars )))

        (§ var #_"byte[]" (§ name prog) (§ expr script.getProgram(§ pars )))
        (§ var #_"byte[]" (§ name connectedScript) (§ expr Arrays/copyOfRange(§ pars prog, lastCodeSepLocation, prog.length)))

        (§ var #_"UnsafeByteArrayOutputStream" (§ name outStream) (§ new #_"UnsafeByteArrayOutputStream" (§ pars sigBytes.length + 1)))
        (§ try )
        (§ block
            (§ expr writeBytes(§ pars outStream, sigBytes))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
        (§ ass (§ name connectedScript) (§ expr removeAllInstancesOf(§ pars connectedScript, outStream.toByteArray(§ pars ))))

        ;; TODO: Use int for indexes everywhere, we can't have that many inputs/outputs.
        (§ var #_"boolean" (§ name sigValid) false)
        (§ try )
        (§ block
            (§ var #_"TransactionSignature" (§ name sig) (§ expr TransactionSignature/decodeFromBitcoin(§ pars sigBytes, requireCanonical, verifyFlags.contains(§ pars VerifyFlag/LOW_S))))

            ;; TODO: Should check hash type is known.
            (§ var #_"Sha256Hash" (§ name hash) (§ expr txContainingThis.hashForSignature(§ pars index, connectedScript, (§ cast #_"byte" sig.sighashFlags))))
            (§ ass (§ name sigValid) (§ expr ECKey/verify(§ pars hash.getBytes(§ pars ), sig, pubKey)))
        )
        (§ catch #_"Exception" (§ name e))
        (§ block
            ;; There is (at least) one exception that could be hit here (EOFException, if the sig is too short).
            ;; Because I can't verify there aren't more, we use a very generic Exception catch.

            ;; This RuntimeException occurs when signing as we run partial/invalid scripts to see if they need more
            ;; signing work to be done inside LocalTransactionSigner.signInputs.
            (§ if (§ not (§ dot e.getMessage(§ pars ).contains(§ pars "Reached past end of ASN.1 stream"))))
            (§ block
                (§ expr log.warn(§ pars "Signature checking failed!", e))
            )
        )

        (§ if (§ expr opcode == OP_CHECKSIG))
        (§ block
            (§ expr stack.add(§ pars (§ quest sigValid ? (§ new #_"byte[]" (§ coll 1 )) :else (§ new #_"byte[]" (§ coll )))))
        )
        (§ elseif (§ expr opcode == OP_CHECKSIGVERIFY && (§ not sigValid)))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_CHECKSIGVERIFY, "Script failed OP_CHECKSIGVERIFY")))
        )
        (§ void nil)
    )

    #_private
    #_static
    (§ method #_"int" (§ fn executeMultiSig) [#_"Transaction" (§ name txContainingThis), #_"int" (§ name index), #_"Script" (§ name script), #_"LinkedList<byte[]>" (§ name stack), #_"int" (§ name opCount), #_"int" (§ name lastCodeSepLocation), #_"int" (§ name opcode), #_"Set<VerifyFlag>" (§ name verifyFlags)])
        (§ throws #_"ScriptException")
    (§ block
        #_final
        (§ var #_"boolean" (§ name requireCanonical) (§ expr verifyFlags.contains(§ pars VerifyFlag/STRICTENC) || verifyFlags.contains(§ pars VerifyFlag/DERSIG) || verifyFlags.contains(§ pars VerifyFlag/LOW_S)))
        (§ if (§ expr stack.size(§ pars ) < 1))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size < 2")))
        )

        (§ var #_"int" (§ name pubKeyCount) (§ expr castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag/MINIMALDATA)).intValue(§ pars )))
        (§ if (§ expr pubKeyCount < 0 || MAX_PUBKEYS_PER_MULTISIG < pubKeyCount))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_PUBKEY_COUNT, "OP_CHECKMULTISIG(VERIFY) with pubkey count out of range")))
        )

        (§ ass (§ name opCount) (§ expr opCount + pubKeyCount))
        (§ if (§ expr MAX_OPS_PER_SCRIPT < opCount))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_OP_COUNT, "Total op count > 201 during OP_CHECKMULTISIG(VERIFY)")))
        )
        (§ if (§ expr stack.size(§ pars ) < pubKeyCount + 1))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size < num_of_pubkeys + 2")))
        )

        (§ var #_"LinkedList<byte[]>" (§ name pubkeys) (§ new #_"LinkedList<>" (§ pars )))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < pubKeyCount) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ expr pubkeys.add(§ pars stack.pollLast(§ pars )))
        )

        (§ var #_"int" (§ name sigCount) (§ expr castToBigInteger(§ pars stack.pollLast(§ pars ), verifyFlags.contains(§ pars VerifyFlag/MINIMALDATA)).intValue(§ pars )))
        (§ if (§ expr sigCount < 0 || pubKeyCount < sigCount))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_SIG_COUNT, "OP_CHECKMULTISIG(VERIFY) with sig count out of range")))
        )
        (§ if (§ expr stack.size(§ pars ) < sigCount + 1))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_INVALID_STACK_OPERATION, "Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size < num_of_pubkeys + num_of_signatures + 3")))
        )

        (§ var #_"LinkedList<byte[]>" (§ name sigs) (§ new #_"LinkedList<>" (§ pars )))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < sigCount) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ expr sigs.add(§ pars stack.pollLast(§ pars )))
        )

        (§ var #_"byte[]" (§ name prog) (§ expr script.getProgram(§ pars )))
        (§ var #_"byte[]" (§ name connectedScript) (§ expr Arrays/copyOfRange(§ pars prog, lastCodeSepLocation, prog.length)))

        (§ for (§ var #_"byte[]" (§ name sig)) :for sigs)
        (§ block
            (§ var #_"UnsafeByteArrayOutputStream" (§ name outStream) (§ new #_"UnsafeByteArrayOutputStream" (§ pars sig.length + 1)))
            (§ try )
            (§ block
                (§ expr writeBytes(§ pars outStream, sig))
            )
            (§ catch #_"IOException" (§ name e))
            (§ block
                (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
            )
            (§ ass (§ name connectedScript) (§ expr removeAllInstancesOf(§ pars connectedScript, outStream.toByteArray(§ pars ))))
        )

        (§ var #_"boolean" (§ name valid) true)
        (§ while (§ expr 0 < sigs.size(§ pars )))
        (§ block
            (§ var #_"byte[]" (§ name pubKey) (§ expr pubkeys.pollFirst(§ pars )))
            ;; We could reasonably move this out of the loop, but because signature verification is significantly
            ;; more expensive than hashing, its not a big deal.
            (§ try )
            (§ block
                (§ var #_"TransactionSignature" (§ name sig) (§ expr TransactionSignature/decodeFromBitcoin(§ pars sigs.getFirst(§ pars ), requireCanonical)))
                (§ var #_"Sha256Hash" (§ name hash) (§ expr txContainingThis.hashForSignature(§ pars index, connectedScript, (§ cast #_"byte" sig.sighashFlags))))
                (§ if (§ expr ECKey/verify(§ pars hash.getBytes(§ pars ), sig, pubKey)))
                (§ block
                    (§ expr sigs.pollFirst(§ pars ))
                )
            )
            (§ catch #_"Exception" (§ name _))
            (§ block
                ;; There is (at least) one exception that could be hit here (EOFException, if the sig is too short).
                ;; Because I can't verify there aren't more, we use a very generic Exception catch.
            )

            (§ if (§ expr pubkeys.size(§ pars ) < sigs.size(§ pars )))
            (§ block
                (§ ass (§ name valid) false)
                (§ break )
            )
        )

        ;; We uselessly remove a stack object to emulate a Bitcoin Core bug.
        (§ var #_"byte[]" (§ name nullDummy) (§ expr stack.pollLast(§ pars )))
        (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag/NULLDUMMY) && 0 < nullDummy.length))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_SIG_NULLFAIL, "OP_CHECKMULTISIG(VERIFY) with non-null nulldummy: " + Arrays/toString(§ pars nullDummy))))
        )

        (§ if (§ expr opcode == OP_CHECKMULTISIG))
        (§ block
            (§ expr stack.add(§ pars (§ quest valid ? (§ new #_"byte[]" (§ coll 1 )) :else (§ new #_"byte[]" (§ coll )))))
        )
        (§ elseif (§ expr opcode == OP_CHECKMULTISIGVERIFY && (§ not valid)))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_SIG_NULLFAIL, "Script failed OP_CHECKMULTISIGVERIFY")))
        )

        (§ return opCount)
    )

    ;;;
     ; Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey, enabling all validation rules.
     ; @param txContainingThis The transaction in which this input scriptSig resides.
     ;                         Accessing txContainingThis from another thread while this method runs results in undefined behavior.
     ; @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
     ; @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
     ; @deprecated Use {@link #correctlySpends(org.bitcoinj.core.Transaction, long, org.bitcoinj.script.Script, java.util.Set)}
     ; instead so that verification flags do not change as new verification options are added.
     ;;
    #_deprecated
    #_public
    (§ method #_"void" (§ fn correctlySpends) [#_"Transaction" (§ name txContainingThis), #_"long" (§ name scriptSigIndex), #_"Script" (§ name scriptPubKey)])
        (§ throws #_"ScriptException")
    (§ block
        (§ expr correctlySpends(§ pars txContainingThis, scriptSigIndex, scriptPubKey, ALL_VERIFY_FLAGS))
        (§ void nil)
    )

    ;;;
     ; Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey.
     ; @param txContainingThis The transaction in which this input scriptSig resides.
     ;                         Accessing txContainingThis from another thread while this method runs results in undefined behavior.
     ; @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
     ; @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
     ; @param verifyFlags Each flag enables one validation rule.  If in doubt, use {@link #correctlySpends(Transaction, long, Script)}
     ;                    which sets all flags.
     ;;
    #_public
    (§ method #_"void" (§ fn correctlySpends) [#_"Transaction" (§ name txContainingThis), #_"long" (§ name scriptSigIndex), #_"Script" (§ name scriptPubKey), #_"Set<VerifyFlag>" (§ name verifyFlags)])
        (§ throws #_"ScriptException")
    (§ block
        ;; Clone the transaction because executing the script involves editing it, and if we die, we'll leave
        ;; the tx half broken (also it's not so thread safe to work on it directly).
        (§ try )
        (§ block
            (§ ass (§ name txContainingThis) (§ expr txContainingThis.getParams(§ pars ).getDefaultSerializer(§ pars ).makeTransaction(§ pars txContainingThis.bitcoinSerialize(§ pars ))))
        )
        (§ catch #_"ProtocolException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Should not happen unless we were given a totally broken transaction.
        )

        (§ if (§ expr MAX_SCRIPT_SIZE < getProgram(§ pars ).length || MAX_SCRIPT_SIZE < scriptPubKey.getProgram(§ pars ).length))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_SCRIPT_SIZE, "Script larger than 10,000 bytes")))
        )

        (§ var #_"LinkedList<byte[]>" (§ name stack) (§ new #_"LinkedList<>" (§ pars )))
        (§ var #_"LinkedList<byte[]>" (§ name p2shStack) nil)

        (§ expr executeScript(§ pars txContainingThis, scriptSigIndex, this, stack, verifyFlags))
        (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag/P2SH)))
        (§ block
            (§ ass (§ name p2shStack) (§ new #_"LinkedList<>" (§ pars stack)))
        )
        (§ expr executeScript(§ pars txContainingThis, scriptSigIndex, scriptPubKey, stack, verifyFlags))

        (§ if (§ expr stack.size(§ pars ) == 0))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_EVAL_FALSE, "Stack empty at end of script execution.")))
        )

        (§ if (§ expr (§ not castToBool(§ pars stack.pollLast(§ pars )))))
        (§ block
            (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_EVAL_FALSE, "Script resulted in a non-true stack: " + stack)))
        )

        ;; P2SH is pay to script hash.  It means that the scriptPubKey has a special form which is a valid
        ;; program but it has "useless" form that if evaluated as a normal program always returns true.
        ;; Instead, miners recognize it as special based on its template - it provides a hash of the real scriptPubKey
        ;; and that must be provided by the input.  The goal of this bizarre arrangement is twofold:
        ;;
        ;; (1) You can sum up a large, complex script (like a CHECKMULTISIG script) with an address that's the same
        ;;     size as a regular address.  This means it doesn't overload scannable QR codes/NFC tags or become
        ;;     un-wieldy to copy/paste.
        ;; (2) It allows the working set to be smaller: nodes perform best when they can store as many unspent outputs
        ;;     in RAM as possible, so if the outputs are made smaller and the inputs get bigger, then it's better for
        ;;     overall scalability and performance.

        ;; TODO: Check if we can take out enforceP2SH if there's a checkpoint at the enforcement block.
        (§ if (§ expr verifyFlags.contains(§ pars VerifyFlag/P2SH) && scriptPubKey.isPayToScriptHash(§ pars )))
        (§ block
            (§ for (§ var #_"ScriptChunk" (§ name chunk)) :for chunks)
            (§ block
                (§ if (§ expr chunk.isOpCode(§ pars ) && OP_16 < chunk.opcode))
                (§ block
                    (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_SIG_PUSHONLY, "Attempted to spend a P2SH scriptPubKey with a script that contained script ops")))
                )
            )

            (§ var #_"byte[]" (§ name scriptPubKeyBytes) (§ expr p2shStack.pollLast(§ pars )))
            (§ var #_"Script" (§ name scriptPubKeyP2SH) (§ new #_"Script" (§ pars scriptPubKeyBytes)))

            (§ expr executeScript(§ pars txContainingThis, scriptSigIndex, scriptPubKeyP2SH, p2shStack, verifyFlags))

            (§ if (§ expr p2shStack.size(§ pars ) == 0))
            (§ block
                (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_EVAL_FALSE, "P2SH stack empty at end of script execution.")))
            )

            (§ if (§ expr (§ not castToBool(§ pars p2shStack.pollLast(§ pars )))))
            (§ block
                (§ throw (§ new #_"ScriptException" (§ pars ScriptError/SCRIPT_ERR_EVAL_FALSE, "P2SH script execution resulted in a non-true stack")))
            )
        )
        (§ void nil)
    )

    ;; Utility that doesn't copy for internal use.
    #_private
    (§ method #_"byte[]" (§ fn getQuickProgram) [])
    (§ block
        (§ return (§ quest (§ expr program != nil) ? program :else (§ expr getProgram(§ pars ))))
    )

    ;;;
     ; Get the {@link org.bitcoinj.script.Script.ScriptType}.
     ; @return The script type.
     ;;
    #_public
    (§ method #_"ScriptType" (§ fn getScriptType) [])
    (§ block
        (§ if (§ expr isSentToAddress(§ pars )))
        (§ block
            (§ return (§ expr ScriptType/P2PKH))
        )
        (§ if (§ expr isSentToRawPubKey(§ pars )))
        (§ block
            (§ return (§ expr ScriptType/PUB_KEY))
        )
        (§ if (§ expr isPayToScriptHash(§ pars )))
        (§ block
            (§ return (§ expr ScriptType/P2SH))
        )

        (§ return (§ expr ScriptType/NO_TYPE))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ return (§ expr Arrays/equals(§ pars getQuickProgram(§ pars ), (§ expr (§ cast #_"Script" o)).getQuickProgram(§ pars ))))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Arrays/hashCode(§ pars getQuickProgram(§ pars ))))
    )
)

#_(ns org.bitcoinj.script #_"ScriptBuilder"
    (:import [java.math BigInteger]
             [java.util ArrayList Arrays Collections List Stack])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists])
   (:require [org.bitcoinj.core Address ECKey Utils]
             [org.bitcoinj.crypto TransactionSignature]
             #_static [org.bitcoinj.script.ScriptOpCodes *]))

;;;
 ; <p>Tools for the construction of commonly used script types.  You don't normally need this as it's hidden
 ; behind convenience methods on {@link org.bitcoinj.core.Transaction}, but they are useful when working with
 ; the protocol at a lower level.</p>
 ;;
#_public
(§ class #_"ScriptBuilder"
    #_private
    (§ field #_"List<ScriptChunk>" (§ name chunks))

    ;;; Creates a fresh ScriptBuilder with an empty program. ;;
    #_public
    (§ constructor #_"ScriptBuilder" [])
    (§ block
        (§ ass (§ name chunks) (§ expr Lists/newLinkedList(§ pars )))
        (§ void this)
    )

    ;;; Creates a fresh ScriptBuilder with the given program as the starting point. ;;
    #_public
    (§ constructor #_"ScriptBuilder" [#_"Script" (§ name template)])
    (§ block
        (§ ass (§ name chunks) (§ new #_"ArrayList<>" (§ pars template.getChunks(§ pars ))))
        (§ void this)
    )

    ;;; Adds the given chunk to the end of the program. ;;
    #_public
    (§ method #_"ScriptBuilder" (§ fn addChunk) [#_"ScriptChunk" (§ name chunk)])
    (§ block
        (§ return (§ expr addChunk(§ pars chunks.size(§ pars ), chunk)))
    )

    ;;; Adds the given chunk at the given index in the program. ;;
    #_public
    (§ method #_"ScriptBuilder" (§ fn addChunk) [#_"int" (§ name index), #_"ScriptChunk" (§ name chunk)])
    (§ block
        (§ expr chunks.add(§ pars index, chunk))
        (§ return this)
    )

    ;;; Adds the given opcode to the end of the program. ;;
    #_public
    (§ method #_"ScriptBuilder" (§ fn op) [#_"int" (§ name opcode)])
    (§ block
        (§ return (§ expr op(§ pars chunks.size(§ pars ), opcode)))
    )

    ;;; Adds the given opcode to the given index in the program. ;;
    #_public
    (§ method #_"ScriptBuilder" (§ fn op) [#_"int" (§ name index), #_"int" (§ name opcode)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars OP_PUSHDATA4 < opcode))
        (§ return (§ expr addChunk(§ pars index, new ScriptChunk(§ pars opcode, nil))))
    )

    ;;; Adds a copy of the given byte array as a data element (i.e. PUSHDATA) at the end of the program. ;;
    #_public
    (§ method #_"ScriptBuilder" (§ fn data) [#_"byte[]" (§ name data)])
    (§ block
        (§ return (§ quest (§ expr data.length == 0) ? (§ expr smallNum(§ pars 0)) :else (§ expr data(§ pars chunks.size(§ pars ), data))))
    )

    ;;; Adds a copy of the given byte array as a data element (i.e. PUSHDATA) at the given index in the program. ;;
    #_public
    (§ method #_"ScriptBuilder" (§ fn data) [#_"int" (§ name index), #_"byte[]" (§ name data)])
    (§ block
        ;; implements BIP62
        (§ var #_"byte[]" (§ name copy) (§ expr Arrays/copyOf(§ pars data, data.length)))
        (§ var #_"int" (§ name opcode))
        (§ if (§ expr data.length == 0))
        (§ block
            (§ ass (§ name opcode) (§ expr OP_0))
        )
        (§ elseif (§ expr data.length == 1))
        (§ block
            (§ var #_"byte" (§ name b) (§ expr data[0]))
            (§ if (§ expr 1 <= b && b <= 16))
            (§ block
                (§ ass (§ name opcode) (§ expr Script/encodeToOpN(§ pars b)))
            )
            (§ else )
            (§ block
                (§ ass (§ name opcode) 1)
            )
        )
        (§ elseif (§ expr data.length < OP_PUSHDATA1))
        (§ block
            (§ ass (§ name opcode) (§ expr data.length))
        )
        (§ elseif (§ expr data.length < 256))
        (§ block
            (§ ass (§ name opcode) (§ expr OP_PUSHDATA1))
        )
        (§ elseif (§ expr data.length < 65536))
        (§ block
            (§ ass (§ name opcode) (§ expr OP_PUSHDATA2))
        )
        (§ else )
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars "Unimplemented")))
        )
        (§ return (§ expr addChunk(§ pars index, new ScriptChunk(§ pars opcode, copy))))
    )

    ;;;
     ; Adds the given number to the end of the program.
     ; Automatically uses shortest encoding possible.
     ;;
    #_public
    (§ method #_"ScriptBuilder" (§ fn number) [#_"long" (§ name num)])
    (§ block
        (§ return (§ quest (§ expr 0 <= num && num <= 16) ? (§ expr smallNum(§ pars (§ cast #_"int" num))) :else (§ expr bigNum(§ pars num))))
    )

    ;;;
     ; Adds the given number to the given index in the program.
     ; Automatically uses shortest encoding possible.
     ;;
    #_public
    (§ method #_"ScriptBuilder" (§ fn number) [#_"int" (§ name index), #_"long" (§ name num)])
    (§ block
        (§ return (§ quest (§ expr 0 <= num && num <= 16) ? (§ expr smallNum(§ pars index, (§ cast #_"int" num))) :else (§ expr bigNum(§ pars index, num))))
    )

    ;;;
     ; Adds the given number as a OP_N opcode to the end of the program.
     ; Only handles values 0-16 inclusive.
     ;
     ; @see #number(int)
     ;;
    #_public
    (§ method #_"ScriptBuilder" (§ fn smallNum) [#_"int" (§ name num)])
    (§ block
        (§ return (§ expr smallNum(§ pars chunks.size(§ pars ), num)))
    )

    ;;; Adds the given number as a push data chunk.
     ; This is intended to use for negative numbers or values > 16, and although
     ; it will accept numbers in the range 0-16 inclusive, the encoding would be
     ; considered non-standard.
     ;
     ; @see #number(int)
     ;;
    #_protected
    (§ method #_"ScriptBuilder" (§ fn bigNum) [#_"long" (§ name num)])
    (§ block
        (§ return (§ expr bigNum(§ pars chunks.size(§ pars ), num)))
    )

    ;;;
     ; Adds the given number as a OP_N opcode to the given index in the program.
     ; Only handles values 0-16 inclusive.
     ;
     ; @see #number(int)
     ;;
    #_public
    (§ method #_"ScriptBuilder" (§ fn smallNum) [#_"int" (§ name index), #_"int" (§ name num)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars 0 <= num, "Cannot encode negative numbers with smallNum"))
        (§ expr Preconditions/checkArgument(§ pars num <= 16, "Cannot encode numbers larger than 16 with smallNum"))

        (§ return (§ expr addChunk(§ pars index, new ScriptChunk(§ pars Script/encodeToOpN(§ pars num), nil))))
    )

    ;;;
     ; Adds the given number as a push data chunk to the given index in the program.
     ; This is intended to use for negative numbers or values > 16, and although
     ; it will accept numbers in the range 0-16 inclusive, the encoding would be
     ; considered non-standard.
     ;
     ; @see #number(int)
     ;;
    #_protected
    (§ method #_"ScriptBuilder" (§ fn bigNum) [#_"int" (§ name index), #_"long" (§ name num)])
    (§ block
        #_final
        (§ var #_"byte[]" (§ name data))

        (§ if (§ expr num == 0))
        (§ block
            (§ ass (§ name data) (§ new #_"byte[]" (§ count 0)))
        )
        (§ else )
        (§ block
            (§ var #_"Stack<Byte>" (§ name result) (§ new #_"Stack<>" (§ pars )))
            #_final
            (§ var #_"boolean" (§ name neg) (§ expr num < 0))
            (§ var #_"long" (§ name absvalue) (§ expr Math/abs(§ pars num)))

            (§ while (§ expr absvalue != 0))
            (§ block
                (§ expr result.push(§ pars (§ cast #_"byte" (§ expr absvalue & 0xff))))
                (§ ass (§ name absvalue) (§ expr absvalue >> 8))
            )

            (§ if (§ expr (§ expr result.peek(§ pars ) & 0x80) != 0))
            (§ block
                ;; The most significant byte is >= 0x80, so push an extra byte that
                ;; contains just the sign of the value.
                (§ expr result.push(§ pars (§ cast #_"byte" (§ quest neg ? 0x80 :else 0))))
            )
            (§ elseif neg)
            (§ block
                ;; The most significant byte is < 0x80 and the value is negative,
                ;; set the sign bit so it is subtracted and interpreted as a
                ;; negative when converting back to an integral.
                (§ expr result.push(§ pars (§ cast #_"byte" (§ expr result.pop(§ pars ) | 0x80))))
            )

            (§ ass (§ name data) (§ new #_"byte[]" (§ count result.size(§ pars ))))
            (§ for (§ var #_"int" (§ name byteIdx) 0) :for (§ expr byteIdx < data.length) :for (§ ass (§ name byteIdx) (§ expr byteIdx + 1)))
            (§ block
                (§ ass (§ name data[byteIdx]) (§ expr result.get(§ pars byteIdx)))
            )
        )

        ;; At most the encoded value could take up to 8 bytes, so we don't need
        ;; to use OP_PUSHDATA opcodes.
        (§ return (§ expr addChunk(§ pars index, new ScriptChunk(§ pars data.length, data))))
    )

    ;;; Creates a new immutable Script based on the state of the builder. ;;
    #_public
    (§ method #_"Script" (§ fn build) [])
    (§ block
        (§ return (§ new #_"Script" (§ pars chunks)))
    )

    ;;; Creates a scriptPubKey that encodes payment to the given address. ;;
    #_public
    #_static
    (§ method #_"Script" (§ fn createOutputScript) [#_"Address" (§ name to)])
    (§ block
        (§ if (§ expr to.isP2SHAddress(§ pars )))
        (§ block
            ;; OP_HASH160 <scriptHash> OP_EQUAL
            (§ return (§ new #_"ScriptBuilder" (§ pars )).op(§ pars OP_HASH160).data(§ pars to.getHash160(§ pars )).op(§ pars OP_EQUAL).build(§ pars ))
        )
        (§ else )
        (§ block
            ;; OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
            (§ return (§ new #_"ScriptBuilder" (§ pars )).op(§ pars OP_DUP).op(§ pars OP_HASH160).data(§ pars to.getHash160(§ pars )).op(§ pars OP_EQUALVERIFY).op(§ pars OP_CHECKSIG).build(§ pars ))
        )
    )

    ;;; Creates a scriptPubKey that encodes payment to the given raw public key. ;;
    #_public
    #_static
    (§ method #_"Script" (§ fn createOutputScript) [#_"ECKey" (§ name key)])
    (§ block
        (§ return (§ new #_"ScriptBuilder" (§ pars )).data(§ pars key.getPubKey(§ pars )).op(§ pars OP_CHECKSIG).build(§ pars ))
    )

    ;;;
     ; Creates a scriptSig that can redeem a pay-to-address output.
     ; If given signature is null, incomplete scriptSig will be created with OP_0 instead of signature.
     ;;
    #_public
    #_static
    (§ method #_"Script" (§ fn createInputScript) [#_nilable #_"TransactionSignature" (§ name signature), #_"ECKey" (§ name pubKey)])
    (§ block
        (§ var #_"byte[]" (§ name pubkeyBytes) (§ expr pubKey.getPubKey(§ pars )))
        (§ var #_"byte[]" (§ name sigBytes) (§ quest (§ expr signature != nil) ? (§ expr signature.encodeToBitcoin(§ pars )) :else (§ new #_"byte[]" (§ coll ))))
        (§ return (§ new #_"ScriptBuilder" (§ pars )).data(§ pars sigBytes).data(§ pars pubkeyBytes).build(§ pars ))
    )

    ;;;
     ; Creates a scriptSig that can redeem a pay-to-pubkey output.
     ; If given signature is null, incomplete scriptSig will be created with OP_0 instead of signature.
     ;;
    #_public
    #_static
    (§ method #_"Script" (§ fn createInputScript) [#_nilable #_"TransactionSignature" (§ name signature)])
    (§ block
        (§ var #_"byte[]" (§ name sigBytes) (§ quest (§ expr signature != nil) ? (§ expr signature.encodeToBitcoin(§ pars )) :else (§ new #_"byte[]" (§ coll ))))
        (§ return (§ new #_"ScriptBuilder" (§ pars )).data(§ pars sigBytes).build(§ pars ))
    )

    ;;; Creates a program that requires at least N of the given keys to sign, using OP_CHECKMULTISIG. ;;
    #_public
    #_static
    (§ method #_"Script" (§ fn createMultiSigOutputScript) [#_"int" (§ name threshold), #_"List<ECKey>" (§ name pubkeys)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars 0 < threshold))
        (§ expr Preconditions/checkArgument(§ pars threshold <= pubkeys.size(§ pars )))
        (§ expr Preconditions/checkArgument(§ pars pubkeys.size(§ pars ) <= 16)) ;; That's the max we can represent with a single opcode.

        (§ var #_"ScriptBuilder" (§ name builder) (§ new #_"ScriptBuilder" (§ pars )))
        (§ expr builder.smallNum(§ pars threshold))
        (§ for (§ var #_"ECKey" (§ name key)) :for pubkeys)
        (§ block
            (§ expr builder.data(§ pars key.getPubKey(§ pars )))
        )
        (§ expr builder.smallNum(§ pars pubkeys.size(§ pars )))
        (§ expr builder.op(§ pars OP_CHECKMULTISIG))
        (§ return (§ expr builder.build(§ pars )))
    )

    ;;; Create a program that satisfies an OP_CHECKMULTISIG program. ;;
    #_public
    #_static
    (§ method #_"Script" (§ fn createMultiSigInputScript) [#_"List<TransactionSignature>" (§ name signatures)])
    (§ block
        (§ var #_"List<byte[]>" (§ name sigs) (§ new #_"ArrayList<>" (§ pars signatures.size(§ pars ))))
        (§ for (§ var #_"TransactionSignature" (§ name signature)) :for signatures)
        (§ block
            (§ expr sigs.add(§ pars signature.encodeToBitcoin(§ pars )))
        )

        (§ return (§ expr createMultiSigInputScriptBytes(§ pars sigs, nil)))
    )

    ;;; Create a program that satisfies an OP_CHECKMULTISIG program. ;;
    #_public
    #_static
    (§ method #_"Script" (§ fn createMultiSigInputScript) [#_"TransactionSignature..." (§ name signatures)])
    (§ block
        (§ return (§ expr createMultiSigInputScript(§ pars Arrays/asList(§ pars signatures))))
    )

    ;;; Create a program that satisfies an OP_CHECKMULTISIG program, using pre-encoded signatures. ;;
    #_public
    #_static
    (§ method #_"Script" (§ fn createMultiSigInputScriptBytes) [#_"List<byte[]>" (§ name signatures)])
    (§ block
        (§ return (§ expr createMultiSigInputScriptBytes(§ pars signatures, nil)))
    )

    ;;;
     ; Create a program that satisfies a pay-to-script hashed OP_CHECKMULTISIG program.
     ; If given signature list is null, incomplete scriptSig will be created with OP_0 instead of signatures.
     ;;
    #_public
    #_static
    (§ method #_"Script" (§ fn createP2SHMultiSigInputScript) [#_nilable #_"List<TransactionSignature>" (§ name signatures), #_"Script" (§ name multisigProgram)])
    (§ block
        (§ var #_"List<byte[]>" (§ name sigs) (§ new #_"ArrayList<>" (§ pars )))
        (§ if (§ expr signatures == nil))
        (§ block
            ;; Create correct number of empty signatures.
            (§ var #_"int" (§ name numSigs) (§ expr multisigProgram.getNumberOfSignaturesRequiredToSpend(§ pars )))
            (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numSigs) :for (§ ass (§ name i) (§ expr i + 1)))
            (§ block
                (§ expr sigs.add(§ pars (§ new #_"byte[]" (§ coll ))))
            )
        )
        (§ else )
        (§ block
            (§ for (§ var #_"TransactionSignature" (§ name signature)) :for signatures)
            (§ block
                (§ expr sigs.add(§ pars signature.encodeToBitcoin(§ pars )))
            )
        )
        (§ return (§ expr createMultiSigInputScriptBytes(§ pars sigs, multisigProgram.getProgram(§ pars ))))
    )

    ;;;
     ; Create a program that satisfies an OP_CHECKMULTISIG program, using pre-encoded signatures.
     ; Optionally, appends the script program bytes if spending a P2SH output.
     ;;
    #_public
    #_static
    (§ method #_"Script" (§ fn createMultiSigInputScriptBytes) [#_"List<byte[]>" (§ name signatures), #_nilable #_"byte[]" (§ name multisigProgramBytes)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars signatures.size(§ pars ) <= 16))

        (§ var #_"ScriptBuilder" (§ name builder) (§ new #_"ScriptBuilder" (§ pars )))
        (§ expr builder.smallNum(§ pars 0)) ;; Work around a bug in CHECKMULTISIG that is now a required part of the protocol.
        (§ for (§ var #_"byte[]" (§ name signature)) :for signatures)
        (§ block
            (§ expr builder.data(§ pars signature))
        )
        (§ if (§ expr multisigProgramBytes!= nil))
        (§ block
            (§ expr builder.data(§ pars multisigProgramBytes))
        )
        (§ return (§ expr builder.build(§ pars )))
    )

    ;;;
     ; Returns a copy of the given scriptSig with the signature inserted in the given position.
     ;
     ; This function assumes that any missing sigs have OP_0 placeholders.  If given scriptSig
     ; already has all the signatures in place, IllegalArgumentException will be thrown.
     ;
     ; @param targetIndex Where to insert the signature.
     ; @param sigsPrefixCount How many items to copy verbatim (e.g. initial OP_0 for multisig).
     ; @param sigsSuffixCount How many items to copy verbatim at end (e.g. redeemScript for P2SH).
     ;;
    #_public
    #_static
    (§ method #_"Script" (§ fn updateScriptWithSignature) [#_"Script" (§ name scriptSig), #_"byte[]" (§ name signature), #_"int" (§ name targetIndex), #_"int" (§ name sigsPrefixCount), #_"int" (§ name sigsSuffixCount)])
    (§ block
        (§ var #_"List<ScriptChunk>" (§ name inputChunks) (§ expr scriptSig.getChunks(§ pars )))
        (§ var #_"int" (§ name totalChunks) (§ expr inputChunks.size(§ pars )))

        ;; Check if we have a place to insert, otherwise just return given scriptSig unchanged.
        ;; We assume here that OP_0 placeholders always go after the sigs, so
        ;; to find if we have sigs missing, we can just check the chunk in latest sig position.
        (§ var #_"boolean" (§ name hasMissingSigs) (§ expr inputChunks.get(§ pars totalChunks - sigsSuffixCount - 1).equalsOpCode(§ pars OP_0)))
        (§ expr Preconditions/checkArgument(§ pars hasMissingSigs, "ScriptSig is already filled with signatures"))

        ;; copy the prefix
        (§ var #_"ScriptBuilder" (§ name builder) (§ new #_"ScriptBuilder" (§ pars )))
        (§ for (§ var #_"ScriptChunk" (§ name chunk)) :for (§ expr inputChunks.subList(§ pars 0, sigsPrefixCount)))
        (§ block
            (§ expr builder.addChunk(§ pars chunk))
        )

        ;; Copy the sigs.
        (§ var #_"int" (§ name pos) 0)
        (§ var #_"boolean" (§ name inserted) false)
        (§ for (§ var #_"ScriptChunk" (§ name chunk)) :for (§ expr inputChunks.subList(§ pars sigsPrefixCount, totalChunks - sigsSuffixCount)))
        (§ block
            (§ if (§ expr pos == targetIndex))
            (§ block
                (§ ass (§ name inserted) true)
                (§ expr builder.data(§ pars signature))
                (§ ass (§ name pos) (§ expr pos + 1))
            )
            (§ if (§ expr (§ not chunk.equalsOpCode(§ pars OP_0))))
            (§ block
                (§ expr builder.addChunk(§ pars chunk))
                (§ ass (§ name pos) (§ expr pos + 1))
            )
        )

        ;; Add OP_0's if needed, since we skipped them in the previous loop.
        (§ while (§ expr pos < totalChunks - sigsPrefixCount - sigsSuffixCount))
        (§ block
            (§ if (§ expr pos == targetIndex))
            (§ block
                (§ ass (§ name inserted) true)
                (§ expr builder.data(§ pars signature))
            )
            (§ else )
            (§ block
                (§ expr builder.addChunk(§ pars (§ new #_"ScriptChunk" (§ pars OP_0, nil))))
            )
            (§ ass (§ name pos) (§ expr pos + 1))
        )

        ;; Copy the suffix.
        (§ for (§ var #_"ScriptChunk" (§ name chunk)) :for (§ expr inputChunks.subList(§ pars totalChunks - sigsSuffixCount, totalChunks)))
        (§ block
            (§ expr builder.addChunk(§ pars chunk))
        )

        (§ expr Preconditions/checkState(§ pars inserted))
        (§ return (§ expr builder.build(§ pars )))
    )

    ;;;
     ; Creates a scriptPubKey that sends to the given script hash.  Read
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP 16</a>
     ; to learn more about this kind of script.
     ;;
    #_public
    #_static
    (§ method #_"Script" (§ fn createP2SHOutputScript) [#_"byte[]" (§ name hash)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars hash.length == 20))

        (§ return (§ new #_"ScriptBuilder" (§ pars )).op(§ pars OP_HASH160).data(§ pars hash).op(§ pars OP_EQUAL).build(§ pars ))
    )

    ;;;
     ; Creates a scriptPubKey for the given redeem script.
     ;;
    #_public
    #_static
    (§ method #_"Script" (§ fn createP2SHOutputScript) [#_"Script" (§ name redeemScript)])
    (§ block
        (§ var #_"byte[]" (§ name hash) (§ expr Utils/sha256hash160(§ pars redeemScript.getProgram(§ pars ))))
        (§ return (§ expr ScriptBuilder/createP2SHOutputScript(§ pars hash)))
    )

    ;;;
     ; Creates a P2SH output script with given public keys and threshold.
     ; Given public keys will be placed in redeem script in the lexicographical sorting order.
     ;;
    #_public
    #_static
    (§ method #_"Script" (§ fn createP2SHOutputScript) [#_"int" (§ name threshold), #_"List<ECKey>" (§ name pubkeys)])
    (§ block
        (§ var #_"Script" (§ name redeemScript) (§ expr createRedeemScript(§ pars threshold, pubkeys)))
        (§ return (§ expr createP2SHOutputScript(§ pars redeemScript)))
    )

    ;;;
     ; Creates redeem script with given public keys and threshold.
     ; Given public keys will be placed in redeem script in the lexicographical sorting order.
     ;;
    #_public
    #_static
    (§ method #_"Script" (§ fn createRedeemScript) [#_"int" (§ name threshold), #_"List<ECKey>" (§ name pubkeys)])
    (§ block
        (§ ass (§ name pubkeys) (§ new #_"ArrayList<>" (§ pars pubkeys)))
        (§ expr Collections/sort(§ pars pubkeys, ECKey/PUBKEY_COMPARATOR))
        (§ return (§ expr ScriptBuilder/createMultiSigOutputScript(§ pars threshold, pubkeys)))
    )

    ;;;
     ; Creates a script of the form OP_RETURN [data].  This feature allows you to attach
     ; a small piece of data (like a hash of something stored elsewhere) to a zero valued
     ; output which can never be spent and thus does not pollute the ledger.
     ;;
    #_public
    #_static
    (§ method #_"Script" (§ fn createOpReturnScript) [#_"byte[]" (§ name data)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars data.length <= 80))

        (§ return (§ new #_"ScriptBuilder" (§ pars )).op(§ pars OP_RETURN).data(§ pars data).build(§ pars ))
    )

    #_public
    #_static
    (§ method #_"Script" (§ fn createCLTVPaymentChannelOutput) [#_"BigInteger" (§ name time), #_"ECKey" (§ name from), #_"ECKey" (§ name to)])
    (§ block
        (§ var #_"byte[]" (§ name timeBytes) (§ expr Utils/reverseBytes(§ pars Utils/encodeMPI(§ pars time, false))))
        (§ if (§ expr 5 < timeBytes.length))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars "Time too large to encode as 5-byte int")))
        )

        (§ return (§ new #_"ScriptBuilder" (§ pars )).op(§ pars OP_IF).data(§ pars to.getPubKey(§ pars )).op(§ pars OP_CHECKSIGVERIFY).op(§ pars OP_ELSE).data(§ pars timeBytes).op(§ pars OP_CHECKLOCKTIMEVERIFY).op(§ pars OP_DROP).op(§ pars OP_ENDIF).data(§ pars from.getPubKey(§ pars )).op(§ pars OP_CHECKSIG).build(§ pars ))
    )

    #_public
    #_static
    (§ method #_"Script" (§ fn createCLTVPaymentChannelRefund) [#_"TransactionSignature" (§ name signature)])
    (§ block
        (§ var #_"ScriptBuilder" (§ name builder) (§ new #_"ScriptBuilder" (§ pars )))
        (§ expr builder.data(§ pars signature.encodeToBitcoin(§ pars )))
        (§ expr builder.data(§ pars (§ new #_"byte[]" (§ coll 0 )))) ;; Use the CHECKLOCKTIMEVERIFY if branch.
        (§ return (§ expr builder.build(§ pars )))
    )

    #_public
    #_static
    (§ method #_"Script" (§ fn createCLTVPaymentChannelP2SHRefund) [#_"TransactionSignature" (§ name signature), #_"Script" (§ name redeemScript)])
    (§ block
        (§ var #_"ScriptBuilder" (§ name builder) (§ new #_"ScriptBuilder" (§ pars )))
        (§ expr builder.data(§ pars signature.encodeToBitcoin(§ pars )))
        (§ expr builder.data(§ pars (§ new #_"byte[]" (§ coll 0 )))) ;; Use the CHECKLOCKTIMEVERIFY if branch.
        (§ expr builder.data(§ pars redeemScript.getProgram(§ pars )))
        (§ return (§ expr builder.build(§ pars )))
    )

    #_public
    #_static
    (§ method #_"Script" (§ fn createCLTVPaymentChannelP2SHInput) [#_"byte[]" (§ name from), #_"byte[]" (§ name to), #_"Script" (§ name redeemScript)])
    (§ block
        (§ var #_"ScriptBuilder" (§ name builder) (§ new #_"ScriptBuilder" (§ pars )))
        (§ expr builder.data(§ pars from))
        (§ expr builder.data(§ pars to))
        (§ expr builder.smallNum(§ pars 1)) ;; Use the CHECKLOCKTIMEVERIFY if branch.
        (§ expr builder.data(§ pars redeemScript.getProgram(§ pars )))
        (§ return (§ expr builder.build(§ pars )))
    )

    #_public
    #_static
    (§ method #_"Script" (§ fn createCLTVPaymentChannelInput) [#_"TransactionSignature" (§ name from), #_"TransactionSignature" (§ name to)])
    (§ block
        (§ return (§ expr createCLTVPaymentChannelInput(§ pars from.encodeToBitcoin(§ pars ), to.encodeToBitcoin(§ pars ))))
    )

    #_public
    #_static
    (§ method #_"Script" (§ fn createCLTVPaymentChannelInput) [#_"byte[]" (§ name from), #_"byte[]" (§ name to)])
    (§ block
        (§ var #_"ScriptBuilder" (§ name builder) (§ new #_"ScriptBuilder" (§ pars )))
        (§ expr builder.data(§ pars from))
        (§ expr builder.data(§ pars to))
        (§ expr builder.smallNum(§ pars 1)) ;; Use the CHECKLOCKTIMEVERIFY if branch.
        (§ return (§ expr builder.build(§ pars )))
    )
)

#_(ns org.bitcoinj.script #_"ScriptChunk"
    (:import [java.io IOException OutputStream]
             [java.util Arrays])
    (:import [com.google.common.base Objects Preconditions])
   (:require [org.bitcoinj.core Utils]
             #_static [org.bitcoinj.script.ScriptOpCodes *]))

;;;
 ; A script element that is either a data push (signature, pubkey, etc.) or a non-push (logic, numeric, etc.) operation.
 ;;
#_public
(§ class #_"ScriptChunk"
    ;;; Operation to be executed.  Opcodes are defined in {@link ScriptOpCodes}. ;;
    #_public
    #_final
    (§ field #_"int" (§ name opcode))
    ;;;
     ; For push operations, this is the vector to be pushed on the stack.
     ; For {@link ScriptOpCodes#OP_0}, the vector is empty.
     ; Null for non-push operations.
     ;;
    #_nilable
    #_public
    #_final
    (§ field #_"byte[]" (§ name data))
    #_private
    (§ field #_"int" (§ name startLocationInProgram))

    #_public
    (§ constructor #_"ScriptChunk" [#_"int" (§ name opcode), #_"byte[]" (§ name data)])
    (§ block
        (§ this (§ pars opcode, data, -1))
        (§ void this)
    )

    #_public
    (§ constructor #_"ScriptChunk" [#_"int" (§ name opcode), #_"byte[]" (§ name data), #_"int" (§ name startLocationInProgram)])
    (§ block
        (§ ass (§ name this.opcode) opcode)
        (§ ass (§ name this.data) data)
        (§ ass (§ name this.startLocationInProgram) startLocationInProgram)
        (§ void this)
    )

    #_public
    (§ method #_"boolean" (§ fn equalsOpCode) [#_"int" (§ name opcode)])
    (§ block
        (§ return (§ expr opcode == this.opcode))
    )

    ;;;
     ; If this chunk is a single byte of non-pushdata content (could be OP_RESERVED or some invalid Opcode).
     ;;
    #_public
    (§ method #_"boolean" (§ fn isOpCode) [])
    (§ block
        (§ return (§ expr OP_PUSHDATA4 < opcode))
    )

    ;;;
     ; Returns true if this chunk is pushdata content, including the single-byte pushdatas.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isPushData) [])
    (§ block
        (§ return (§ expr opcode <= OP_16))
    )

    #_public
    (§ method #_"int" (§ fn getStartLocationInProgram) [])
    (§ block
        (§ expr Preconditions/checkState(§ pars 0 <= startLocationInProgram))

        (§ return startLocationInProgram)
    )

    ;;; If this chunk is an OP_N opcode returns the equivalent integer value. ;;
    #_public
    (§ method #_"int" (§ fn decodeOpN) [])
    (§ block
        (§ expr Preconditions/checkState(§ pars isOpCode(§ pars )))

        (§ return (§ expr Script/decodeFromOpN(§ pars opcode)))
    )

    ;;;
     ; Called on a pushdata chunk, returns true if it uses the smallest possible way (according to BIP62) to push the data.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isShortestPossiblePushData) [])
    (§ block
        (§ expr Preconditions/checkState(§ pars isPushData(§ pars )))

        (§ if (§ expr data == nil))
        (§ block
            (§ return true) ;; OP_N
        )
        (§ if (§ expr data.length == 0))
        (§ block
            (§ return (§ expr opcode == OP_0))
        )
        (§ if (§ expr data.length == 1))
        (§ block
            (§ var #_"byte" (§ name b) (§ expr data[0]))
            (§ if (§ expr 0x01 <= b && b <= 0x10))
            (§ block
                (§ return (§ expr opcode == OP_1 + b - 1))
            )
            (§ if (§ expr (§ expr b & 0xff) == 0x81))
            (§ block
                (§ return (§ expr opcode == OP_1NEGATE))
            )
        )
        (§ if (§ expr data.length < OP_PUSHDATA1))
        (§ block
            (§ return (§ expr opcode == data.length))
        )
        (§ if (§ expr data.length < 256))
        (§ block
            (§ return (§ expr opcode == OP_PUSHDATA1))
        )
        (§ if (§ expr data.length < 65536))
        (§ block
            (§ return (§ expr opcode == OP_PUSHDATA2))
        )

        ;; Can never be used, but implemented for completeness.
        (§ return (§ expr opcode == OP_PUSHDATA4))
    )

    #_public
    (§ method #_"void" (§ fn write) [#_"OutputStream" (§ name stream)])
        (§ throws #_"IOException")
    (§ block
        (§ if (§ expr isOpCode(§ pars )))
        (§ block
            (§ expr Preconditions/checkState(§ pars data == nil))
            (§ expr stream.write(§ pars opcode))
        )
        (§ elseif (§ expr data != nil))
        (§ block
            (§ if (§ expr opcode < OP_PUSHDATA1))
            (§ block
                (§ expr Preconditions/checkState(§ pars data.length == opcode))
                (§ expr stream.write(§ pars opcode))
            )
            (§ elseif (§ expr opcode == OP_PUSHDATA1))
            (§ block
                (§ expr Preconditions/checkState(§ pars data.length <= 0xff))
                (§ expr stream.write(§ pars OP_PUSHDATA1))
                (§ expr stream.write(§ pars data.length))
            )
            (§ elseif (§ expr opcode == OP_PUSHDATA2))
            (§ block
                (§ expr Preconditions/checkState(§ pars data.length <= 0xffff))
                (§ expr stream.write(§ pars OP_PUSHDATA2))
                (§ expr stream.write(§ pars 0xff & data.length))
                (§ expr stream.write(§ pars 0xff & (§ expr data.length >> 8)))
            )
            (§ elseif (§ expr opcode == OP_PUSHDATA4))
            (§ block
                (§ expr Preconditions/checkState(§ pars data.length <= Script/MAX_SCRIPT_ELEMENT_SIZE))
                (§ expr stream.write(§ pars OP_PUSHDATA4))
                (§ expr Utils/uint32ToByteStreamLE(§ pars data.length, stream))
            )
            (§ else )
            (§ block
                (§ throw (§ new #_"RuntimeException" (§ pars "Unimplemented")))
            )
            (§ expr stream.write(§ pars data))
        )
        (§ else )
        (§ block
            (§ expr stream.write(§ pars opcode)) ;; smallNum
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ var #_"StringBuilder" (§ name sb) (§ new #_"StringBuilder" (§ pars )))
        (§ if (§ expr isOpCode(§ pars )))
        (§ block
            (§ expr sb.append(§ pars getOpCodeName(§ pars opcode)))
        )
        (§ elseif (§ expr data != nil)) ;; Data chunk.
        (§ block
            (§ expr sb.append(§ pars getPushDataName(§ pars opcode)).append(§ pars "[").append(§ pars Utils/HEX.encode(§ pars data)).append(§ pars "]"))
        )
        (§ else ) ;; Small num.
        (§ block
            (§ expr sb.append(§ pars Script/decodeFromOpN(§ pars opcode)))
        )
        (§ return (§ expr sb.toString(§ pars )))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"ScriptChunk" (§ name other) (§ expr (§ cast #_"ScriptChunk" o)))
        (§ return (§ expr opcode == other.opcode && startLocationInProgram == other.startLocationInProgram && Arrays/equals(§ pars data, other.data)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars opcode, startLocationInProgram, Arrays/hashCode(§ pars data))))
    )
)

#_(ns org.bitcoinj.script #_"ScriptError"
    (:import [java.util HashMap Map]))

#_public
(§ enum #_"ScriptError"
    (§ item SCRIPT_ERR_OK(§ pars "OK"))
    (§ item SCRIPT_ERR_UNKNOWN_ERROR(§ pars "UNKNOWN_ERROR"))
    (§ item SCRIPT_ERR_EVAL_FALSE(§ pars "EVAL_FALSE"))
    (§ item SCRIPT_ERR_OP_RETURN(§ pars "OP_RETURN"))

    ;;;max sizes ;;
    (§ item SCRIPT_ERR_SCRIPT_SIZE(§ pars "SCRIPT_SIZE"))
    (§ item SCRIPT_ERR_PUSH_SIZE(§ pars "PUSH_SIZE"))
    (§ item SCRIPT_ERR_OP_COUNT(§ pars "OP_COUNT"))
    (§ item SCRIPT_ERR_STACK_SIZE(§ pars "STACK_SIZE"))
    (§ item SCRIPT_ERR_SIG_COUNT(§ pars "SIG_COUNT"))
    (§ item SCRIPT_ERR_PUBKEY_COUNT(§ pars "PUBKEY_COUNT"))

    ;;;failed verify operations ;;
    (§ item SCRIPT_ERR_VERIFY(§ pars "VERIFY"))
    (§ item SCRIPT_ERR_EQUALVERIFY(§ pars "EQUALVERIFY"))
    (§ item SCRIPT_ERR_CHECKMULTISIGVERIFY(§ pars "CHECKMULTISIGVERIFY"))
    (§ item SCRIPT_ERR_CHECKSIGVERIFY(§ pars "CHECKSIGVERIFY"))
    (§ item SCRIPT_ERR_NUMEQUALVERIFY(§ pars "NUMEQUALVERIFY"))

    ;;;logical/format/canonical errors ;;
    (§ item SCRIPT_ERR_BAD_OPCODE(§ pars "BAD_OPCODE"))
    (§ item SCRIPT_ERR_DISABLED_OPCODE(§ pars "DISABLED_OPCODE"))
    (§ item SCRIPT_ERR_INVALID_STACK_OPERATION(§ pars "INVALID_STACK_OPERATION"))
    (§ item SCRIPT_ERR_INVALID_ALTSTACK_OPERATION(§ pars "INVALID_ALTSTACK_OPERATION"))
    (§ item SCRIPT_ERR_UNBALANCED_CONDITIONAL(§ pars "UNBALANCED_CONDITIONAL"))

    ;;;CHECKLOCKTIMEVERIFY and CHECKSEQUENCEVERIFY ;;
    (§ item SCRIPT_ERR_NEGATIVE_LOCKTIME(§ pars "NEGATIVE_LOCKTIME"))
    (§ item SCRIPT_ERR_UNSATISFIED_LOCKTIME(§ pars "UNSATISFIED_LOCKTIME"))

    ;;;malleability ;;
    (§ item SCRIPT_ERR_SIG_HASHTYPE(§ pars "SIG_HASHTYPE"))
    (§ item SCRIPT_ERR_SIG_DER(§ pars "SIG_DER"))
    (§ item SCRIPT_ERR_MINIMALDATA(§ pars "MINIMALDATA"))
    (§ item SCRIPT_ERR_SIG_PUSHONLY(§ pars "SIG_PUSHONLY"))
    (§ item SCRIPT_ERR_SIG_HIGH_S(§ pars "SIG_HIGH_S"))
    (§ item SCRIPT_ERR_SIG_NULLDUMMY(§ pars "SIG_NULLDUMMY"))
    (§ item SCRIPT_ERR_PUBKEYTYPE(§ pars "PUBKEYTYPE"))
    (§ item SCRIPT_ERR_CLEANSTACK(§ pars "CLEANSTACK"))
    (§ item SCRIPT_ERR_MINIMALIF(§ pars "MINIMALIF"))
    (§ item SCRIPT_ERR_SIG_NULLFAIL(§ pars "NULLFAIL"))

    ;;;softfork safeness ;;
    (§ item SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS(§ pars "DISCOURAGE_UPGRADABLE_NOPS"))
    (§ item SCRIPT_ERR_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM(§ pars "DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM"))

    ;;;segregated witness ;;
    (§ item SCRIPT_ERR_WITNESS_PROGRAM_WRONG_LENGTH(§ pars "WITNESS_PROGRAM_WRONG_LENGTH"))
    (§ item SCRIPT_ERR_WITNESS_PROGRAM_WITNESS_EMPTY(§ pars "WITNESS_PROGRAM_WITNESS_EMPTY"))
    (§ item SCRIPT_ERR_WITNESS_PROGRAM_MISMATCH(§ pars "WITNESS_PROGRAM_MISMATCH"))
    (§ item SCRIPT_ERR_WITNESS_MALLEATED(§ pars "WITNESS_MALLEATED"))
    (§ item SCRIPT_ERR_WITNESS_MALLEATED_P2SH(§ pars "WITNESS_MALLEATED_P2SH"))
    (§ item SCRIPT_ERR_WITNESS_UNEXPECTED(§ pars "WITNESS_UNEXPECTED"))
    (§ item SCRIPT_ERR_WITNESS_PUBKEYTYPE(§ pars "WITNESS_PUBKEYTYPE"))

    (§ item SCRIPT_ERR_ERROR_COUNT(§ pars "ERROR_COUNT"))

    #_private
    #_final
    (§ field #_"String" (§ name mnemonic))
    #_private
    #_static
    #_final
    (§ field #_"Map<String, ScriptError>" (§ name mnemonicToScriptErrorMap))

    #_private
    (§ constructor #_"ScriptError" [#_"String" (§ name name)])
    (§ block
        (§ ass (§ name this.mnemonic) name)
        (§ void this)
    )

    #_static
    (§ block
        (§ ass (§ name mnemonicToScriptErrorMap) (§ new #_"HashMap<>" (§ pars )))
        (§ for (§ var #_"ScriptError" (§ name err)) :for (§ expr ScriptError/values(§ pars )))
        (§ block
            (§ expr mnemonicToScriptErrorMap.put(§ pars err.getMnemonic(§ pars ), err))
        )
    )

    #_public
    (§ method #_"String" (§ fn getMnemonic) [])
    (§ block
        (§ return mnemonic)
    )

    #_public
    #_static
    (§ method #_"ScriptError" (§ fn fromMnemonic) [#_"String" (§ name name)])
    (§ block
        (§ var #_"ScriptError" (§ name err) (§ expr mnemonicToScriptErrorMap.get(§ pars name)))
        (§ if (§ expr err == nil))
        (§ block
            (§ throw (§ new #_"IllegalArgumentException" (§ pars name + " is not a valid name")))
        )
        (§ return err)
    )
)

#_(ns org.bitcoinj.script #_"ScriptOpCodes"
    (:import [java.util Map])
    (:import [com.google.common.collect ImmutableMap]))

;;;
 ; Various constants that define the assembly-like scripting language that forms part of the Bitcoin protocol.
 ; See {@link org.bitcoinj.script.Script} for details.  Also provides a method to convert them to a string.
 ;;
#_public
(§ class #_"ScriptOpCodes"
    ;; push value
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_0) (§ expr 0x00)) ;; push empty vector
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_FALSE) (§ expr OP_0))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_PUSHDATA1) (§ expr 0x4c))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_PUSHDATA2) (§ expr 0x4d))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_PUSHDATA4) (§ expr 0x4e))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_1NEGATE) (§ expr 0x4f))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_RESERVED) (§ expr 0x50))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_1) (§ expr 0x51))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_TRUE) (§ expr OP_1))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_2) (§ expr 0x52))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_3) (§ expr 0x53))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_4) (§ expr 0x54))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_5) (§ expr 0x55))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_6) (§ expr 0x56))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_7) (§ expr 0x57))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_8) (§ expr 0x58))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_9) (§ expr 0x59))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_10) (§ expr 0x5a))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_11) (§ expr 0x5b))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_12) (§ expr 0x5c))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_13) (§ expr 0x5d))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_14) (§ expr 0x5e))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_15) (§ expr 0x5f))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_16) (§ expr 0x60))

    ;; control
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_NOP) (§ expr 0x61))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_VER) (§ expr 0x62))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_IF) (§ expr 0x63))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_NOTIF) (§ expr 0x64))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_VERIF) (§ expr 0x65))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_VERNOTIF) (§ expr 0x66))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_ELSE) (§ expr 0x67))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_ENDIF) (§ expr 0x68))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_VERIFY) (§ expr 0x69))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_RETURN) (§ expr 0x6a))

    ;; stack ops
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_TOALTSTACK) (§ expr 0x6b))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_FROMALTSTACK) (§ expr 0x6c))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_2DROP) (§ expr 0x6d))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_2DUP) (§ expr 0x6e))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_3DUP) (§ expr 0x6f))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_2OVER) (§ expr 0x70))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_2ROT) (§ expr 0x71))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_2SWAP) (§ expr 0x72))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_IFDUP) (§ expr 0x73))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_DEPTH) (§ expr 0x74))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_DROP) (§ expr 0x75))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_DUP) (§ expr 0x76))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_NIP) (§ expr 0x77))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_OVER) (§ expr 0x78))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_PICK) (§ expr 0x79))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_ROLL) (§ expr 0x7a))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_ROT) (§ expr 0x7b))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_SWAP) (§ expr 0x7c))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_TUCK) (§ expr 0x7d))

    ;; splice ops
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_CAT) (§ expr 0x7e))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_SUBSTR) (§ expr 0x7f))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_LEFT) (§ expr 0x80))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_RIGHT) (§ expr 0x81))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_SIZE) (§ expr 0x82))

    ;; bit logic
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_INVERT) (§ expr 0x83))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_AND) (§ expr 0x84))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_OR) (§ expr 0x85))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_XOR) (§ expr 0x86))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_EQUAL) (§ expr 0x87))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_EQUALVERIFY) (§ expr 0x88))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_RESERVED1) (§ expr 0x89))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_RESERVED2) (§ expr 0x8a))

    ;; numeric
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_1ADD) (§ expr 0x8b))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_1SUB) (§ expr 0x8c))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_2MUL) (§ expr 0x8d))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_2DIV) (§ expr 0x8e))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_NEGATE) (§ expr 0x8f))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_ABS) (§ expr 0x90))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_NOT) (§ expr 0x91))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_0NOTEQUAL) (§ expr 0x92))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_ADD) (§ expr 0x93))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_SUB) (§ expr 0x94))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_MUL) (§ expr 0x95))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_DIV) (§ expr 0x96))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_MOD) (§ expr 0x97))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_LSHIFT) (§ expr 0x98))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_RSHIFT) (§ expr 0x99))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_BOOLAND) (§ expr 0x9a))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_BOOLOR) (§ expr 0x9b))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_NUMEQUAL) (§ expr 0x9c))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_NUMEQUALVERIFY) (§ expr 0x9d))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_NUMNOTEQUAL) (§ expr 0x9e))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_LESSTHAN) (§ expr 0x9f))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_GREATERTHAN) (§ expr 0xa0))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_LESSTHANOREQUAL) (§ expr 0xa1))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_GREATERTHANOREQUAL) (§ expr 0xa2))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_MIN) (§ expr 0xa3))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_MAX) (§ expr 0xa4))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_WITHIN) (§ expr 0xa5))

    ;; crypto
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_RIPEMD160) (§ expr 0xa6))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_SHA1) (§ expr 0xa7))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_SHA256) (§ expr 0xa8))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_HASH160) (§ expr 0xa9))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_HASH256) (§ expr 0xaa))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_CODESEPARATOR) (§ expr 0xab))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_CHECKSIG) (§ expr 0xac))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_CHECKSIGVERIFY) (§ expr 0xad))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_CHECKMULTISIG) (§ expr 0xae))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_CHECKMULTISIGVERIFY) (§ expr 0xaf))

    ;; block state
    ;;; Check lock time of the block.  Introduced in BIP 65, replacing OP_NOP2 ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_CHECKLOCKTIMEVERIFY) (§ expr 0xb1))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_CHECKSEQUENCEVERIFY) (§ expr 0xb2))

    ;; expansion
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_NOP1) (§ expr 0xb0))
    ;;; Deprecated by BIP 65 ;;
    #_deprecated
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_NOP2) (§ expr OP_CHECKLOCKTIMEVERIFY))
    ;;; Deprecated by BIP 112 ;;
    #_deprecated
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_NOP3) (§ expr OP_CHECKSEQUENCEVERIFY))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_NOP4) (§ expr 0xb3))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_NOP5) (§ expr 0xb4))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_NOP6) (§ expr 0xb5))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_NOP7) (§ expr 0xb6))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_NOP8) (§ expr 0xb7))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_NOP9) (§ expr 0xb8))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_NOP10) (§ expr 0xb9))
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name OP_INVALIDOPCODE) (§ expr 0xff))

    #_private
    #_static
    #_final
    (§ var #_"Map<Integer, String>" (§ name opCodeMap) (§ expr ImmutableMap.<Integer, String>builder(§ pars ).put(§ pars OP_0, "0").put(§ pars OP_PUSHDATA1, "PUSHDATA1").put(§ pars OP_PUSHDATA2, "PUSHDATA2").put(§ pars OP_PUSHDATA4, "PUSHDATA4").put(§ pars OP_1NEGATE, "1NEGATE").put(§ pars OP_RESERVED, "RESERVED").put(§ pars OP_1, "1").put(§ pars OP_2, "2").put(§ pars OP_3, "3").put(§ pars OP_4, "4").put(§ pars OP_5, "5").put(§ pars OP_6, "6").put(§ pars OP_7, "7").put(§ pars OP_8, "8").put(§ pars OP_9, "9").put(§ pars OP_10, "10").put(§ pars OP_11, "11").put(§ pars OP_12, "12").put(§ pars OP_13, "13").put(§ pars OP_14, "14").put(§ pars OP_15, "15").put(§ pars OP_16, "16").put(§ pars OP_NOP, "NOP").put(§ pars OP_VER, "VER").put(§ pars OP_IF, "IF").put(§ pars OP_NOTIF, "NOTIF").put(§ pars OP_VERIF, "VERIF").put(§ pars OP_VERNOTIF, "VERNOTIF").put(§ pars OP_ELSE, "ELSE").put(§ pars OP_ENDIF, "ENDIF").put(§ pars OP_VERIFY, "VERIFY").put(§ pars OP_RETURN, "RETURN").put(§ pars OP_TOALTSTACK, "TOALTSTACK").put(§ pars OP_FROMALTSTACK, "FROMALTSTACK").put(§ pars OP_2DROP, "2DROP").put(§ pars OP_2DUP, "2DUP").put(§ pars OP_3DUP, "3DUP").put(§ pars OP_2OVER, "2OVER").put(§ pars OP_2ROT, "2ROT").put(§ pars OP_2SWAP, "2SWAP").put(§ pars OP_IFDUP, "IFDUP").put(§ pars OP_DEPTH, "DEPTH").put(§ pars OP_DROP, "DROP").put(§ pars OP_DUP, "DUP").put(§ pars OP_NIP, "NIP").put(§ pars OP_OVER, "OVER").put(§ pars OP_PICK, "PICK").put(§ pars OP_ROLL, "ROLL").put(§ pars OP_ROT, "ROT").put(§ pars OP_SWAP, "SWAP").put(§ pars OP_TUCK, "TUCK").put(§ pars OP_CAT, "CAT").put(§ pars OP_SUBSTR, "SUBSTR").put(§ pars OP_LEFT, "LEFT").put(§ pars OP_RIGHT, "RIGHT").put(§ pars OP_SIZE, "SIZE").put(§ pars OP_INVERT, "INVERT").put(§ pars OP_AND, "AND").put(§ pars OP_OR, "OR").put(§ pars OP_XOR, "XOR").put(§ pars OP_EQUAL, "EQUAL").put(§ pars OP_EQUALVERIFY, "EQUALVERIFY").put(§ pars OP_RESERVED1, "RESERVED1").put(§ pars OP_RESERVED2, "RESERVED2").put(§ pars OP_1ADD, "1ADD").put(§ pars OP_1SUB, "1SUB").put(§ pars OP_2MUL, "2MUL").put(§ pars OP_2DIV, "2DIV").put(§ pars OP_NEGATE, "NEGATE").put(§ pars OP_ABS, "ABS").put(§ pars OP_NOT, "NOT").put(§ pars OP_0NOTEQUAL, "0NOTEQUAL").put(§ pars OP_ADD, "ADD").put(§ pars OP_SUB, "SUB").put(§ pars OP_MUL, "MUL").put(§ pars OP_DIV, "DIV").put(§ pars OP_MOD, "MOD").put(§ pars OP_LSHIFT, "LSHIFT").put(§ pars OP_RSHIFT, "RSHIFT").put(§ pars OP_BOOLAND, "BOOLAND").put(§ pars OP_BOOLOR, "BOOLOR").put(§ pars OP_NUMEQUAL, "NUMEQUAL").put(§ pars OP_NUMEQUALVERIFY, "NUMEQUALVERIFY").put(§ pars OP_NUMNOTEQUAL, "NUMNOTEQUAL").put(§ pars OP_LESSTHAN, "LESSTHAN").put(§ pars OP_GREATERTHAN, "GREATERTHAN").put(§ pars OP_LESSTHANOREQUAL, "LESSTHANOREQUAL").put(§ pars OP_GREATERTHANOREQUAL, "GREATERTHANOREQUAL").put(§ pars OP_MIN, "MIN").put(§ pars OP_MAX, "MAX").put(§ pars OP_WITHIN, "WITHIN").put(§ pars OP_RIPEMD160, "RIPEMD160").put(§ pars OP_SHA1, "SHA1").put(§ pars OP_SHA256, "SHA256").put(§ pars OP_HASH160, "HASH160").put(§ pars OP_HASH256, "HASH256").put(§ pars OP_CODESEPARATOR, "CODESEPARATOR").put(§ pars OP_CHECKSIG, "CHECKSIG").put(§ pars OP_CHECKSIGVERIFY, "CHECKSIGVERIFY").put(§ pars OP_CHECKMULTISIG, "CHECKMULTISIG").put(§ pars OP_CHECKMULTISIGVERIFY, "CHECKMULTISIGVERIFY").put(§ pars OP_NOP1, "NOP1").put(§ pars OP_CHECKLOCKTIMEVERIFY, "CHECKLOCKTIMEVERIFY").put(§ pars OP_CHECKSEQUENCEVERIFY, "CHECKSEQUENCEVERIFY").put(§ pars OP_NOP4, "NOP4").put(§ pars OP_NOP5, "NOP5").put(§ pars OP_NOP6, "NOP6").put(§ pars OP_NOP7, "NOP7").put(§ pars OP_NOP8, "NOP8").put(§ pars OP_NOP9, "NOP9").put(§ pars OP_NOP10, "NOP10").build(§ pars )))

    #_private
    #_static
    #_final
    (§ var #_"Map<String, Integer>" (§ name opCodeNameMap) (§ expr ImmutableMap.<String, Integer>builder(§ pars ).put(§ pars "0", OP_0).put(§ pars "PUSHDATA1", OP_PUSHDATA1).put(§ pars "PUSHDATA2", OP_PUSHDATA2).put(§ pars "PUSHDATA4", OP_PUSHDATA4).put(§ pars "1NEGATE", OP_1NEGATE).put(§ pars "RESERVED", OP_RESERVED).put(§ pars "1", OP_1).put(§ pars "2", OP_2).put(§ pars "3", OP_3).put(§ pars "4", OP_4).put(§ pars "5", OP_5).put(§ pars "6", OP_6).put(§ pars "7", OP_7).put(§ pars "8", OP_8).put(§ pars "9", OP_9).put(§ pars "10", OP_10).put(§ pars "11", OP_11).put(§ pars "12", OP_12).put(§ pars "13", OP_13).put(§ pars "14", OP_14).put(§ pars "15", OP_15).put(§ pars "16", OP_16).put(§ pars "NOP", OP_NOP).put(§ pars "VER", OP_VER).put(§ pars "IF", OP_IF).put(§ pars "NOTIF", OP_NOTIF).put(§ pars "VERIF", OP_VERIF).put(§ pars "VERNOTIF", OP_VERNOTIF).put(§ pars "ELSE", OP_ELSE).put(§ pars "ENDIF", OP_ENDIF).put(§ pars "VERIFY", OP_VERIFY).put(§ pars "RETURN", OP_RETURN).put(§ pars "TOALTSTACK", OP_TOALTSTACK).put(§ pars "FROMALTSTACK", OP_FROMALTSTACK).put(§ pars "2DROP", OP_2DROP).put(§ pars "2DUP", OP_2DUP).put(§ pars "3DUP", OP_3DUP).put(§ pars "2OVER", OP_2OVER).put(§ pars "2ROT", OP_2ROT).put(§ pars "2SWAP", OP_2SWAP).put(§ pars "IFDUP", OP_IFDUP).put(§ pars "DEPTH", OP_DEPTH).put(§ pars "DROP", OP_DROP).put(§ pars "DUP", OP_DUP).put(§ pars "NIP", OP_NIP).put(§ pars "OVER", OP_OVER).put(§ pars "PICK", OP_PICK).put(§ pars "ROLL", OP_ROLL).put(§ pars "ROT", OP_ROT).put(§ pars "SWAP", OP_SWAP).put(§ pars "TUCK", OP_TUCK).put(§ pars "CAT", OP_CAT).put(§ pars "SUBSTR", OP_SUBSTR).put(§ pars "LEFT", OP_LEFT).put(§ pars "RIGHT", OP_RIGHT).put(§ pars "SIZE", OP_SIZE).put(§ pars "INVERT", OP_INVERT).put(§ pars "AND", OP_AND).put(§ pars "OR", OP_OR).put(§ pars "XOR", OP_XOR).put(§ pars "EQUAL", OP_EQUAL).put(§ pars "EQUALVERIFY", OP_EQUALVERIFY).put(§ pars "RESERVED1", OP_RESERVED1).put(§ pars "RESERVED2", OP_RESERVED2).put(§ pars "1ADD", OP_1ADD).put(§ pars "1SUB", OP_1SUB).put(§ pars "2MUL", OP_2MUL).put(§ pars "2DIV", OP_2DIV).put(§ pars "NEGATE", OP_NEGATE).put(§ pars "ABS", OP_ABS).put(§ pars "NOT", OP_NOT).put(§ pars "0NOTEQUAL", OP_0NOTEQUAL).put(§ pars "ADD", OP_ADD).put(§ pars "SUB", OP_SUB).put(§ pars "MUL", OP_MUL).put(§ pars "DIV", OP_DIV).put(§ pars "MOD", OP_MOD).put(§ pars "LSHIFT", OP_LSHIFT).put(§ pars "RSHIFT", OP_RSHIFT).put(§ pars "BOOLAND", OP_BOOLAND).put(§ pars "BOOLOR", OP_BOOLOR).put(§ pars "NUMEQUAL", OP_NUMEQUAL).put(§ pars "NUMEQUALVERIFY", OP_NUMEQUALVERIFY).put(§ pars "NUMNOTEQUAL", OP_NUMNOTEQUAL).put(§ pars "LESSTHAN", OP_LESSTHAN).put(§ pars "GREATERTHAN", OP_GREATERTHAN).put(§ pars "LESSTHANOREQUAL", OP_LESSTHANOREQUAL).put(§ pars "GREATERTHANOREQUAL", OP_GREATERTHANOREQUAL).put(§ pars "MIN", OP_MIN).put(§ pars "MAX", OP_MAX).put(§ pars "WITHIN", OP_WITHIN).put(§ pars "RIPEMD160", OP_RIPEMD160).put(§ pars "SHA1", OP_SHA1).put(§ pars "SHA256", OP_SHA256).put(§ pars "HASH160", OP_HASH160).put(§ pars "HASH256", OP_HASH256).put(§ pars "CODESEPARATOR", OP_CODESEPARATOR).put(§ pars "CHECKSIG", OP_CHECKSIG).put(§ pars "CHECKSIGVERIFY", OP_CHECKSIGVERIFY).put(§ pars "CHECKMULTISIG", OP_CHECKMULTISIG).put(§ pars "CHECKMULTISIGVERIFY", OP_CHECKMULTISIGVERIFY).put(§ pars "NOP1", OP_NOP1).put(§ pars "CHECKLOCKTIMEVERIFY", OP_CHECKLOCKTIMEVERIFY).put(§ pars "CHECKSEQUENCEVERIFY", OP_CHECKSEQUENCEVERIFY).put(§ pars "NOP2", OP_NOP2).put(§ pars "NOP3", OP_NOP3).put(§ pars "NOP4", OP_NOP4).put(§ pars "NOP5", OP_NOP5).put(§ pars "NOP6", OP_NOP6).put(§ pars "NOP7", OP_NOP7).put(§ pars "NOP8", OP_NOP8).put(§ pars "NOP9", OP_NOP9).put(§ pars "NOP10", OP_NOP10).build(§ pars )))

    ;;;
     ; Converts the given OpCode into a string (e.g. "0", "PUSHDATA", or "NON_OP(10)")
     ;;
    #_public
    #_static
    (§ method #_"String" (§ fn getOpCodeName) [#_"int" (§ name opcode)])
    (§ block
        (§ if (§ expr opCodeMap.containsKey(§ pars opcode)))
        (§ block
            (§ return (§ expr opCodeMap.get(§ pars opcode)))
        )

        (§ return (§ expr "NON_OP(" + opcode + ")"))
    )

    ;;;
     ; Converts the given pushdata OpCode into a string (e.g. "PUSHDATA2", or "PUSHDATA(23)")
     ;;
    #_public
    #_static
    (§ method #_"String" (§ fn getPushDataName) [#_"int" (§ name opcode)])
    (§ block
        (§ if (§ expr opCodeMap.containsKey(§ pars opcode)))
        (§ block
            (§ return (§ expr opCodeMap.get(§ pars opcode)))
        )

        (§ return (§ expr "PUSHDATA(" + opcode + ")"))
    )

    ;;;
     ; Converts the given OpCodeName into an int.
     ;;
    #_public
    #_static
    (§ method #_"int" (§ fn getOpCode) [#_"String" (§ name opCodeName)])
    (§ block
        (§ return (§ quest (§ expr opCodeNameMap.containsKey(§ pars opCodeName)) ? (§ expr opCodeNameMap.get(§ pars opCodeName)) :else (§ expr OP_INVALIDOPCODE)))
    )
)

#_(ns org.bitcoinj.signers #_"CustomTransactionSigner"
    (:import [java.util List])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.crypto ChildNumber TransactionSignature]
             [org.bitcoinj.script Script]
             [org.bitcoinj.wallet KeyBag RedeemData]))

;;;
 ; <p>This signer may be used as a template for creating custom multisig transaction signers.</p>
 ;
 ; Concrete implementations have to implement {@link #getSignature(org.bitcoinj.core.Sha256Hash, java.util.List)}
 ; method returning a signature and a public key of the keypair used to created that signature.
 ; It's up to custom implementation where to locate signatures: it may be a network connection,
 ; some local API or something else.
 ; </p>
 ;;
#_public
#_abstract
(§ class #_"CustomTransactionSigner" (§ extends #_"StatelessTransactionSigner")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"CustomTransactionSigner"))))

    #_override
    #_public
    (§ method #_"boolean" (§ fn isReady) [])
    (§ block
        (§ return true)
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn signInputs) [#_"ProposedTransaction" (§ name propTx), #_"KeyBag" (§ name keyBag)])
    (§ block
        (§ var #_"Transaction" (§ name tx) (§ expr propTx.partialTx))
        (§ var #_"int" (§ name numInputs) (§ expr tx.getInputs(§ pars ).size(§ pars )))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numInputs) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ var #_"TransactionInput" (§ name txIn) (§ expr tx.getInput(§ pars i)))
            (§ var #_"TransactionOutput" (§ name txOut) (§ expr txIn.getConnectedOutput(§ pars )))
            (§ if (§ expr txOut == nil))
            (§ block
                (§ continue )
            )

            (§ var #_"Script" (§ name scriptPubKey) (§ expr txOut.getScriptPubKey(§ pars )))
            (§ if (§ expr (§ not scriptPubKey.isPayToScriptHash(§ pars ))))
            (§ block
                (§ expr log.warn(§ pars "CustomTransactionSigner works only with P2SH transactions"))
                (§ return false)
            )

            (§ var #_"Script" (§ name inputScript) (§ expr Preconditions/checkNotNull(§ pars txIn.getScriptSig(§ pars ))))

            (§ try )
            (§ block
                ;; We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                ;; we sign missing pieces (to check this would require either assuming any signatures are signing
                ;; standard output types or a way to get processed signatures out of script execution).
                (§ expr txIn.getScriptSig(§ pars ).correctlySpends(§ pars tx, i, txIn.getConnectedOutput(§ pars ).getScriptPubKey(§ pars )))
                (§ expr log.warn(§ pars "Input {} already correctly spends output, assuming SIGHASH type used will be safe and skipping signing.", i))
                (§ continue )
            )
            (§ catch #_"ScriptException" (§ name _))
            (§ block
                ;; Expected.
            )

            (§ var #_"RedeemData" (§ name redeemData) (§ expr txIn.getConnectedRedeemData(§ pars keyBag)))
            (§ if (§ expr redeemData == nil))
            (§ block
                (§ expr log.warn(§ pars "No redeem data found for input {}", i))
                (§ continue )
            )

            (§ var #_"Sha256Hash" (§ name sighash) (§ expr tx.hashForSignature(§ pars i, redeemData.redeemScript, Transaction/SigHash/ALL, false)))
            (§ var #_"SignatureAndKey" (§ name sigKey) (§ expr getSignature(§ pars sighash, propTx.keyPaths.get(§ pars scriptPubKey))))
            (§ var #_"TransactionSignature" (§ name txSig) (§ new #_"TransactionSignature" (§ pars sigKey.sig, Transaction/SigHash/ALL, false)))
            (§ var #_"int" (§ name sigIndex) (§ expr inputScript.getSigInsertionIndex(§ pars sighash, sigKey.pubKey)))
            (§ ass (§ name inputScript) (§ expr scriptPubKey.getScriptSigWithSignature(§ pars inputScript, txSig.encodeToBitcoin(§ pars ), sigIndex)))
            (§ expr txIn.setScriptSig(§ pars inputScript))
        )
        (§ return true)
    )

    #_protected
    #_abstract
    (§ method #_"SignatureAndKey" (§ fn getSignature) [#_"Sha256Hash" (§ name sighash), #_"List<ChildNumber>" (§ name derivationPath)])

    #_public
    (§ class #_"SignatureAndKey"
        #_public
        #_final
        (§ field #_"ECKey.ECDSASignature" (§ name sig))
        #_public
        #_final
        (§ field #_"ECKey" (§ name pubKey))

        #_public
        (§ constructor #_"SignatureAndKey" [#_"ECKey.ECDSASignature" (§ name sig), #_"ECKey" (§ name pubKey)])
        (§ block
            (§ ass (§ name this.sig) sig)
            (§ ass (§ name this.pubKey) pubKey)
            (§ void this)
        )
    )
)

#_(ns org.bitcoinj.signers #_"LocalTransactionSigner"
    (:import [java.util EnumSet])
    (:import [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core ECKey ScriptException Transaction TransactionInput]
             [org.bitcoinj.crypto DeterministicKey TransactionSignature]
             [org.bitcoinj.script Script]
             [org.bitcoinj.script.Script VerifyFlag]
             [org.bitcoinj.wallet KeyBag RedeemData]))

;;;
 ; <p>{@link TransactionSigner} implementation for signing inputs using keys from provided {@link org.bitcoinj.wallet.KeyBag}.</p>
 ; <p>This signer doesn't create input scripts for tx inputs.  Instead it expects inputs to contain scripts with
 ; empty sigs and replaces one of the empty sigs with calculated signature.
 ; </p>
 ; <p>This signer is always implicitly added into every wallet and it is the first signer to be executed during tx
 ; completion.  As the first signer to create a signature, it stores derivation path of the signing key in a given
 ; {@link ProposedTransaction} object that will be also passed then to the next signer in chain.  This allows other
 ; signers to use correct signing key for P2SH inputs, because all the keys involved in a single P2SH address have
 ; the same derivation path.</p>
 ; <p>This signer always uses {@link org.bitcoinj.core.Transaction.SigHash#ALL} signing mode.</p>
 ;;
#_public
(§ class #_"LocalTransactionSigner" (§ extends #_"StatelessTransactionSigner")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"LocalTransactionSigner"))))

    ;;;
     ; Verify flags that are safe to use when testing if an input is already signed.
     ;;
    #_private
    #_static
    #_final
    (§ field #_"EnumSet<VerifyFlag>" (§ name MINIMUM_VERIFY_FLAGS) (§ expr EnumSet/of(§ pars VerifyFlag/P2SH, VerifyFlag/NULLDUMMY)))

    #_override
    #_public
    (§ method #_"boolean" (§ fn isReady) [])
    (§ block
        (§ return true)
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn signInputs) [#_"ProposedTransaction" (§ name propTx), #_"KeyBag" (§ name keyBag)])
    (§ block
        (§ var #_"Transaction" (§ name tx) (§ expr propTx.partialTx))
        (§ var #_"int" (§ name numInputs) (§ expr tx.getInputs(§ pars ).size(§ pars )))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numInputs) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ var #_"TransactionInput" (§ name txIn) (§ expr tx.getInput(§ pars i)))
            (§ if (§ expr txIn.getConnectedOutput(§ pars ) == nil))
            (§ block
                (§ expr log.warn(§ pars "Missing connected output, assuming input {} is already signed.", i))
                (§ continue )
            )

            (§ try )
            (§ block
                ;; We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                ;; we sign missing pieces (to check this would require either assuming any signatures are signing
                ;; standard output types or a way to get processed signatures out of script execution).
                (§ expr txIn.getScriptSig(§ pars ).correctlySpends(§ pars tx, i, txIn.getConnectedOutput(§ pars ).getScriptPubKey(§ pars ), MINIMUM_VERIFY_FLAGS))
                (§ expr log.warn(§ pars "Input {} already correctly spends output, assuming SIGHASH type used will be safe and skipping signing.", i))
                (§ continue )
            )
            (§ catch #_"ScriptException" (§ name _))
            (§ block
                ;; Expected.
            )

            (§ var #_"RedeemData" (§ name redeemData) (§ expr txIn.getConnectedRedeemData(§ pars keyBag)))

            (§ var #_"Script" (§ name scriptPubKey) (§ expr txIn.getConnectedOutput(§ pars ).getScriptPubKey(§ pars )))

            ;; For P2SH inputs we need to share derivation path of the signing key with other signers, so that they
            ;; use correct key to calculate their signatures.
            ;; Married keys all have the same derivation path, so we can safely just take first one here.
            (§ var #_"ECKey" (§ name pubKey) (§ expr redeemData.keys.get(§ pars 0)))
            (§ if (§ insta pubKey #_"DeterministicKey"))
            (§ block
                (§ expr propTx.keyPaths.put(§ pars scriptPubKey, (§ expr (§ expr (§ cast #_"DeterministicKey" pubKey)).getPath(§ pars ))))
            )

            (§ var #_"ECKey" (§ name key))
            ;; Locate private key in redeem data.  For pay-to-address and pay-to-key inputs RedeemData will always contain
            ;; only one key (with private bytes).  For P2SH inputs RedeemData will contain multiple keys, one of which MAY
            ;; have private bytes.
            (§ if (§ expr (§ ass (§ name key) (§ expr redeemData.getFullKey(§ pars ))) == nil))
            (§ block
                (§ expr log.warn(§ pars "No local key found for input {}", i))
                (§ continue )
            )

            (§ var #_"Script" (§ name inputScript) (§ expr txIn.getScriptSig(§ pars )))
            ;; script here would be either a standard CHECKSIG program for pay-to-address or pay-to-pubkey inputs or
            ;; a CHECKMULTISIG program for P2SH inputs.
            (§ var #_"byte[]" (§ name script) (§ expr redeemData.redeemScript.getProgram(§ pars )))
            (§ try )
            (§ block
                (§ var #_"TransactionSignature" (§ name signature) (§ expr tx.calculateSignature(§ pars i, key, script, Transaction/SigHash/ALL, false)))

                ;; At this point we have incomplete inputScript with OP_0 in place of one or more signatures.  We already
                ;; have calculated the signature using the local key and now need to insert it in the correct place
                ;; within inputScript.  For pay-to-address and pay-to-key script there is only one signature and it always
                ;; goes first in an inputScript (sigIndex = 0).  In P2SH input scripts we need to figure out our relative
                ;; position relative to other signers.  Since we don't have that information at this point, and since
                ;; we always run first, we have to depend on the other signers rearranging the signatures as needed.
                ;; Therefore, always place as first signature.
                (§ var #_"int" (§ name sigIndex) 0)
                (§ ass (§ name inputScript) (§ expr scriptPubKey.getScriptSigWithSignature(§ pars inputScript, signature.encodeToBitcoin(§ pars ), sigIndex)))
                (§ expr txIn.setScriptSig(§ pars inputScript))
            )
            (§ catch #_"ECKey.KeyIsEncryptedException" (§ name e))
            (§ block
                (§ throw e)
            )
            (§ catch #_"ECKey.MissingPrivateKeyException" (§ name _))
            (§ block
                (§ expr log.warn(§ pars "No private key in keypair for input {}", i))
            )
        )
        (§ return true)
    )
)

#_(ns org.bitcoinj.signers #_"MissingSigResolutionSigner"
    (:import [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core ECKey TransactionInput]
             [org.bitcoinj.crypto TransactionSignature]
             [org.bitcoinj.script Script ScriptChunk]
             [org.bitcoinj.wallet KeyBag Wallet]))

;;;
 ; This transaction signer resolves missing signatures in accordance with the given {@link org.bitcoinj.wallet.Wallet.MissingSigsMode}.
 ; If missingSigsMode is USE_OP_ZERO this signer does nothing assuming missing signatures are already presented in scriptSigs as OP_0.
 ; In MissingSigsMode.THROW mode this signer will throw an exception.  It would be MissingSignatureException
 ; for P2SH or MissingPrivateKeyException for other transaction types.
 ;;
#_public
(§ class #_"MissingSigResolutionSigner" (§ extends #_"StatelessTransactionSigner")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"MissingSigResolutionSigner"))))

    #_public
    (§ field #_"Wallet.MissingSigsMode" (§ name missingSigsMode) (§ expr Wallet/MissingSigsMode/USE_DUMMY_SIG))

    #_public
    (§ constructor #_"MissingSigResolutionSigner" [])
    (§ block
        (§ void this)
    )

    #_public
    (§ constructor #_"MissingSigResolutionSigner" [#_"Wallet.MissingSigsMode" (§ name missingSigsMode)])
    (§ block
        (§ ass (§ name this.missingSigsMode) missingSigsMode)
        (§ void this)
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn isReady) [])
    (§ block
        (§ return true)
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn signInputs) [#_"ProposedTransaction" (§ name propTx), #_"KeyBag" (§ name keyBag)])
    (§ block
        (§ if (§ expr missingSigsMode == Wallet/MissingSigsMode/USE_OP_ZERO))
        (§ block
            (§ return true)
        )

        (§ var #_"int" (§ name numInputs) (§ expr propTx.partialTx.getInputs(§ pars ).size(§ pars )))
        (§ var #_"byte[]" (§ name dummySig) (§ expr TransactionSignature/dummy(§ pars ).encodeToBitcoin(§ pars )))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numInputs) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ var #_"TransactionInput" (§ name txIn) (§ expr propTx.partialTx.getInput(§ pars i)))
            (§ if (§ expr txIn.getConnectedOutput(§ pars ) == nil))
            (§ block
                (§ expr log.warn(§ pars "Missing connected output, assuming input {} is already signed.", i))
                (§ continue )
            )

            (§ var #_"Script" (§ name scriptPubKey) (§ expr txIn.getConnectedOutput(§ pars ).getScriptPubKey(§ pars )))
            (§ var #_"Script" (§ name inputScript) (§ expr txIn.getScriptSig(§ pars )))
            (§ if (§ expr scriptPubKey.isPayToScriptHash(§ pars ) || scriptPubKey.isSentToMultiSig(§ pars )))
            (§ block
                (§ var #_"int" (§ name sigSuffixCount) (§ quest (§ expr scriptPubKey.isPayToScriptHash(§ pars )) ? 1 :else 0))
                ;; All chunks except the first one (OP_0) and the last (redeem script) are signatures.
                (§ for (§ var #_"int" (§ name j) 1) :for (§ expr j < inputScript.getChunks(§ pars ).size(§ pars ) - sigSuffixCount) :for (§ ass (§ name j) (§ expr j + 1)))
                (§ block
                    (§ var #_"ScriptChunk" (§ name scriptChunk) (§ expr inputScript.getChunks(§ pars ).get(§ pars j)))
                    (§ if (§ expr scriptChunk.equalsOpCode(§ pars 0)))
                    (§ block
                        (§ if (§ expr missingSigsMode == Wallet/MissingSigsMode/THROW))
                        (§ block
                            (§ throw (§ new #_"MissingSignatureException" (§ pars )))
                        )

                        (§ if (§ expr missingSigsMode == Wallet/MissingSigsMode/USE_DUMMY_SIG))
                        (§ block
                            (§ expr txIn.setScriptSig(§ pars scriptPubKey.getScriptSigWithSignature(§ pars inputScript, dummySig, j - 1)))
                        )
                    )
                )
            )
            (§ else )
            (§ block
                (§ if (§ expr inputScript.getChunks(§ pars ).get(§ pars 0).equalsOpCode(§ pars 0)))
                (§ block
                    (§ if (§ expr missingSigsMode == Wallet/MissingSigsMode/THROW))
                    (§ block
                        (§ throw (§ new #_"ECKey.MissingPrivateKeyException" (§ pars )))
                    )

                    (§ if (§ expr missingSigsMode == Wallet/MissingSigsMode/USE_DUMMY_SIG))
                    (§ block
                        (§ expr txIn.setScriptSig(§ pars scriptPubKey.getScriptSigWithSignature(§ pars inputScript, dummySig, 0)))
                    )
                )
            )
            ;; TODO: Handle non-P2SH multisig.
        )
        (§ return true)
    )
)

#_(ns org.bitcoinj.signers #_"StatelessTransactionSigner")

;;;
 ; A signer that doesn't have any state to be serialized.
 ;;
#_public
#_abstract
(§ class #_"StatelessTransactionSigner" (§ implements #_"TransactionSigner")
    #_override
    #_public
    (§ method #_"void" (§ fn deserialize) [#_"byte[]" (§ name data)])
    (§ block
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"byte[]" (§ fn serialize) [])
    (§ block
        (§ return (§ new #_"byte[]" (§ count 0)))
    )
)

#_(ns org.bitcoinj.signers #_"TransactionSigner"
    (:import [java.util HashMap List Map])
   (:require [org.bitcoinj.core Transaction]
             [org.bitcoinj.crypto ChildNumber]
             [org.bitcoinj.script Script]
             [org.bitcoinj.wallet KeyBag]))

;;;
 ; <p>Implementations of this interface are intended to sign inputs of the given transaction.
 ; Given transaction may already be partially signed or somehow altered by other signers.</p>
 ; <p>To make use of the signer, you need to add it into the wallet by calling
 ; {@link org.bitcoinj.wallet.Wallet#addTransactionSigner(TransactionSigner)}.
 ; Signer will be serialized along with the wallet data.  In order for a wallet to recreate
 ; signer after deserialization, each signer should have no-args constructor.</p>
 ;;
#_public
(§ interface #_"TransactionSigner"
    ;;;
     ; This class wraps transaction proposed to complete keeping a metadata that may be updated, used and effectively
     ; shared by transaction signers.
     ;;
    (§ class #_"ProposedTransaction"
        #_public
        #_final
        (§ field #_"Transaction" (§ name partialTx))

        ;;;
         ; HD key paths used for each input to derive a signing key.  It's useful for multisig inputs only.
         ; The keys used to create a single P2SH address have the same derivation path, so to use a correct key each signer
         ; has to know a derivation path of signing keys used by previous signers.  For each input signers will use the
         ; same derivation path and we need to store only one key path per input.  As TransactionInput is mutable, inputs
         ; are identified by their scriptPubKeys (keys in this map).
         ;;
        #_public
        #_final
        (§ field #_"Map<Script, List<ChildNumber>" (§ name>) keyPaths)

        #_public
        (§ constructor #_"ProposedTransaction" [#_"Transaction" (§ name partialTx)])
        (§ block
            (§ ass (§ name this.partialTx) partialTx)
            (§ ass (§ name this.keyPaths) (§ new #_"HashMap<>" (§ pars )))
            (§ void this)
        )
    )

    (§ class #_"MissingSignatureException" (§ extends #_"RuntimeException")
    )

    ;;;
     ; Returns true if this signer is ready to be used.
     ;;
    (§ method #_"boolean" (§ fn isReady) [])

    ;;;
     ; Returns byte array of data representing state of this signer.
     ; It's used to serialize/deserialize this signer.
     ;;
    (§ method #_"byte[]" (§ fn serialize) [])

    ;;;
     ; Uses given byte array of data to reconstruct internal state of this signer.
     ;;
    (§ method #_"void" (§ fn deserialize) [#_"byte[]" (§ name data)])

    ;;;
     ; Signs given transaction's inputs.
     ; Returns true if signer is compatible with given transaction (can do something meaningful with it).
     ; Otherwise this method returns false.
     ;;
    (§ method #_"boolean" (§ fn signInputs) [#_"ProposedTransaction" (§ name propTx), #_"KeyBag" (§ name keyBag)])
)

#_(ns org.bitcoinj.store #_"BlockStore"
   (:require [org.bitcoinj.core NetworkParameters Sha256Hash StoredBlock]))

;;;
 ; An implementor of BlockStore saves StoredBlock objects to disk.  Different implementations store them in
 ; different ways.  An in-memory implementation (MemoryBlockStore) exists for unit testing but real apps will
 ; want to use implementations that save to disk.
 ;
 ; A BlockStore is a map of hashes to StoredBlock.  The hash is the double digest of the Bitcoin serialization
 ; of the block header, <b>not</b> the header with the extra data as well.
 ;
 ; BlockStores are thread safe.
 ;;
#_public
(§ interface #_"BlockStore"
    ;;;
     ; Saves the given block header+extra data.  The key isn't specified explicitly as it can be calculated
     ; from the StoredBlock directly.  Can throw if there is a problem with the underlying storage layer such
     ; as running out of disk space.
     ;;
    (§ method #_"void" (§ fn put) [#_"StoredBlock" (§ name block)])
        (§ throws #_"BlockStoreException")

    ;;;
     ; Returns the StoredBlock given a hash.  The returned values block.getHash() method will be equal to the
     ; parameter. If no such block is found, returns null.
     ;;
    (§ method #_"StoredBlock" (§ fn get) [#_"Sha256Hash" (§ name hash)])
        (§ throws #_"BlockStoreException")

    ;;;
     ; Returns the {@link StoredBlock} that represents the top of the chain of greatest total work.  Note that
     ; this can be arbitrarily expensive, you probably should use {@link org.bitcoinj.core.BlockChain#getChainHead()}
     ; or perhaps {@link org.bitcoinj.core.BlockChain#getBestChainHeight()} which will run in constant time and
     ; not take any heavyweight locks.
     ;;
    (§ method #_"StoredBlock" (§ fn getChainHead) [])
        (§ throws #_"BlockStoreException")

    ;;;
     ; Sets the {@link StoredBlock} that represents the top of the chain of greatest total work.
     ;;
    (§ method #_"void" (§ fn setChainHead) [#_"StoredBlock" (§ name chainHead)])
        (§ throws #_"BlockStoreException")

    ;;; Closes the store. ;;
    (§ method #_"void" (§ fn close) [])
        (§ throws #_"BlockStoreException")

    ;;;
     ; Get the {@link org.bitcoinj.core.NetworkParameters} of this store.
     ; @return the network params.
     ;;
    (§ method #_"NetworkParameters" (§ fn getParams) [])
)

#_(ns org.bitcoinj.store #_"BlockStoreException")

;;;
 ; Thrown when something goes wrong with storing a block.  Examples: out of disk space.
 ;;
#_public
(§ class #_"BlockStoreException" (§ extends #_"Exception")
    #_public
    (§ constructor #_"BlockStoreException" [#_"String" (§ name message)])
    (§ block
        (§ super (§ pars message))
        (§ void this)
    )

    #_public
    (§ constructor #_"BlockStoreException" [#_"Throwable" (§ name t)])
    (§ block
        (§ super (§ pars t))
        (§ void this)
    )

    #_public
    (§ constructor #_"BlockStoreException" [#_"String" (§ name message), #_"Throwable" (§ name t)])
    (§ block
        (§ super (§ pars message, t))
        (§ void this)
    )
)

#_(ns org.bitcoinj.store #_"ChainFileLockedException")

;;;
 ; Thrown by {@link SPVBlockStore} when the process cannot gain exclusive access to the chain file.
 ;;
#_public
(§ class #_"ChainFileLockedException" (§ extends #_"BlockStoreException")
    #_public
    (§ constructor #_"ChainFileLockedException" [#_"String" (§ name message)])
    (§ block
        (§ super (§ pars message))
        (§ void this)
    )

    #_public
    (§ constructor #_"ChainFileLockedException" [#_"Throwable" (§ name t)])
    (§ block
        (§ super (§ pars t))
        (§ void this)
    )
)

#_(ns org.bitcoinj.store #_"DatabaseFullPrunedBlockStore"
    (:import [java.io ByteArrayInputStream ByteArrayOutputStream IOException]
             [java.math BigInteger]
             [java.sql *]
             [java.util *])
    (:import [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.script Script]))

;;;
 ; <p>A generic full pruned block store for a relational database.  This generic class
 ; requires certain table structures for the block store.</p>
 ;
 ; <p>The following are the tables and field names/types that are assumed:</p>
 ;
 ; <p><br/>
 ; <b>setting</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>name</td><td>string</td></tr>
 ;     <tr><td>value</td><td>binary</td></tr>
 ; </table>
 ; </p>
 ;
 ; <p><br/>
 ; <b>headers</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>hash</td><td>binary</td></tr>
 ;     <tr><td>chainwork</td><td>binary</td></tr>
 ;     <tr><td>height</td><td>integer</td></tr>
 ;     <tr><td>header</td><td>binary</td></tr>
 ;     <tr><td>wasundoable</td><td>boolean</td></tr>
 ; </table>
 ; </p>
 ;
 ; <p><br/>
 ; <b>undoableblocks</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>hash</td><td>binary</td></tr>
 ;     <tr><td>height</td><td>integer</td></tr>
 ;     <tr><td>txoutchanges</td><td>binary</td></tr>
 ;     <tr><td>transactions</td><td>binary</td></tr>
 ; </table>
 ; </p>
 ;
 ; <p><br/>
 ; <b>openoutputs</b> table
 ; <table>
 ;     <tr><th>Field Name</th><th>Type (generic)</th></tr>
 ;     <tr><td>hash</td><td>binary</td></tr>
 ;     <tr><td>index</td><td>integer</td></tr>
 ;     <tr><td>height</td><td>integer</td></tr>
 ;     <tr><td>value</td><td>integer</td></tr>
 ;     <tr><td>scriptbytes</td><td>binary</td></tr>
 ;     <tr><td>toaddress</td><td>string</td></tr>
 ;     <tr><td>addresstargetable</td><td>integer</td></tr>
 ;     <tr><td>coinbase</td><td>boolean</td></tr>
 ; </table>
 ; </p>
 ;
 ;;
#_public
#_abstract
(§ class #_"DatabaseFullPrunedBlockStore" (§ implements #_"FullPrunedBlockStore")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"DatabaseFullPrunedBlockStore"))))

    #_private
    #_static
    #_final
    (§ field #_"String" (§ name CHAIN_HEAD_SETTING) (§ expr "chainhead"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name VERIFIED_CHAIN_HEAD_SETTING) (§ expr "verifiedchainhead"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name VERSION_SETTING) (§ expr "version"))

    ;; Drop table SQL.
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name DROP_SETTINGS_TABLE) (§ expr "DROP TABLE settings"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name DROP_HEADERS_TABLE) (§ expr "DROP TABLE headers"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name DROP_UNDOABLE_TABLE) (§ expr "DROP TABLE undoableblocks"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name DROP_OPEN_OUTPUT_TABLE) (§ expr "DROP TABLE openoutputs"))

    ;; Queries SQL.
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name SELECT_SETTINGS_SQL) (§ expr "SELECT value FROM settings WHERE name = ?"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name INSERT_SETTINGS_SQL) (§ expr "INSERT INTO settings(name, value) VALUES(?, ?)"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name UPDATE_SETTINGS_SQL) (§ expr "UPDATE settings SET value = ? WHERE name = ?"))

    #_private
    #_static
    #_final
    (§ field #_"String" (§ name SELECT_HEADERS_SQL) (§ expr "SELECT chainwork, height, header, wasundoable FROM headers WHERE hash = ?"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name INSERT_HEADERS_SQL) (§ expr "INSERT INTO headers(hash, chainwork, height, header, wasundoable) VALUES(?, ?, ?, ?, ?)"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name UPDATE_HEADERS_SQL) (§ expr "UPDATE headers SET wasundoable=? WHERE hash=?"))

    #_private
    #_static
    #_final
    (§ field #_"String" (§ name SELECT_UNDOABLEBLOCKS_SQL) (§ expr "SELECT txoutchanges, transactions FROM undoableblocks WHERE hash = ?"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name INSERT_UNDOABLEBLOCKS_SQL) (§ expr "INSERT INTO undoableblocks(hash, height, txoutchanges, transactions) VALUES(?, ?, ?, ?)"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name UPDATE_UNDOABLEBLOCKS_SQL) (§ expr "UPDATE undoableblocks SET txoutchanges=?, transactions=? WHERE hash = ?"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name DELETE_UNDOABLEBLOCKS_SQL) (§ expr "DELETE FROM undoableblocks WHERE height <= ?"))

    #_private
    #_static
    #_final
    (§ field #_"String" (§ name SELECT_OPENOUTPUTS_SQL) (§ expr "SELECT height, value, scriptbytes, coinbase, toaddress, addresstargetable FROM openoutputs WHERE hash = ? AND index = ?"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name SELECT_OPENOUTPUTS_COUNT_SQL) (§ expr "SELECT COUNT(*) FROM openoutputs WHERE hash = ?"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name INSERT_OPENOUTPUTS_SQL) (§ expr "INSERT INTO openoutputs (hash, index, height, value, scriptbytes, toaddress, addresstargetable, coinbase) VALUES (?, ?, ?, ?, ?, ?, ?, ?)"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name DELETE_OPENOUTPUTS_SQL) (§ expr "DELETE FROM openoutputs WHERE hash = ? AND index = ?"))

    ;; Dump table SQL (this is just for data sizing statistics).
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name SELECT_DUMP_SETTINGS_SQL) (§ expr "SELECT name, value FROM settings"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name SELECT_DUMP_HEADERS_SQL) (§ expr "SELECT chainwork, header FROM headers"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name SELECT_DUMP_UNDOABLEBLOCKS_SQL) (§ expr "SELECT txoutchanges, transactions FROM undoableblocks"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name SELECT_DUMP_OPENOUTPUTS_SQL) (§ expr "SELECT value, scriptbytes FROM openoutputs"))

    #_private
    #_static
    #_final
    (§ field #_"String" (§ name SELECT_TRANSACTION_OUTPUTS_SQL) (§ expr "SELECT hash, value, scriptbytes, height, index, coinbase, toaddress, addresstargetable FROM openoutputs where toaddress = ?"))

    ;; Select the balance of an address SQL.
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name SELECT_BALANCE_SQL) (§ expr "select sum(value) from openoutputs where toaddress = ?"))

    ;; Tables exist SQL.
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name SELECT_CHECK_TABLES_EXIST_SQL) (§ expr "SELECT * FROM settings WHERE 1 = 2"))

    ;; Compatibility SQL.
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name SELECT_COMPATIBILITY_COINBASE_SQL) (§ expr "SELECT coinbase FROM openoutputs WHERE 1 = 2"))

    #_protected
    (§ field #_"Sha256Hash" (§ name chainHeadHash))
    #_protected
    (§ field #_"StoredBlock" (§ name chainHeadBlock))
    #_protected
    (§ field #_"Sha256Hash" (§ name verifiedChainHeadHash))
    #_protected
    (§ field #_"StoredBlock" (§ name verifiedChainHeadBlock))
    #_protected
    (§ field #_"NetworkParameters" (§ name params))
    #_protected
    (§ field #_"ThreadLocal<Connection>" (§ name conn))
    #_protected
    (§ field #_"List<Connection>" (§ name allConnections))
    #_protected
    (§ field #_"String" (§ name connectionURL))
    #_protected
    (§ field #_"int" (§ name fullStoreDepth))
    #_protected
    (§ field #_"String" (§ name username))
    #_protected
    (§ field #_"String" (§ name password))
    #_protected
    (§ field #_"String" (§ name schemaName))

    ;;;
     ; <p>Create a new DatabaseFullPrunedBlockStore, using the full connection URL instead of a hostname and password,
     ; and optionally allowing a schema to be specified.</p>
     ;
     ; @param params A copy of the NetworkParameters used.
     ; @param connectionURL The jdbc url to connect to the database.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param username The database username.
     ; @param password The password to the database.
     ; @param schemaName The name of the schema to put the tables in.  May be null if no schema is being used.
     ; @throws BlockStoreException if there is a failure to connect and/or initialise the database.
     ;;
    #_public
    (§ constructor #_"DatabaseFullPrunedBlockStore" [#_"NetworkParameters" (§ name params), #_"String" (§ name connectionURL), #_"int" (§ name fullStoreDepth), #_nilable #_"String" (§ name username), #_nilable #_"String" (§ name password), #_nilable #_"String" (§ name schemaName)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ ass (§ name this.params) params)
        (§ ass (§ name this.fullStoreDepth) fullStoreDepth)
        (§ ass (§ name this.connectionURL) connectionURL)
        (§ ass (§ name this.schemaName) schemaName)
        (§ ass (§ name this.username) username)
        (§ ass (§ name this.password) password)
        (§ ass (§ name this.conn) (§ new #_"ThreadLocal<>" (§ pars )))
        (§ ass (§ name this.allConnections) (§ new #_"LinkedList<>" (§ pars )))

        (§ try )
        (§ block
            (§ expr Class/forName(§ pars getDatabaseDriverClass(§ pars )))
            (§ expr log.info(§ pars getDatabaseDriverClass(§ pars ) + " loaded. "))
        )
        (§ catch #_"ClassNotFoundException" (§ name e))
        (§ block
            (§ expr log.error(§ pars "check CLASSPATH for database driver jar ", e))
        )

        (§ expr maybeConnect(§ pars ))

        (§ try )
        (§ block
            ;; Create tables if needed.
            (§ if (§ expr (§ not tablesExist(§ pars ))))
            (§ block
                (§ expr createTables(§ pars ))
            )
            (§ else )
            (§ block
                (§ expr checkCompatibility(§ pars ))
            )
            (§ expr initFromDatabase(§ pars ))
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ void this)
    )

    ;;;
     ; Get the database driver class, i.e <i>org.postgresql.Driver</i>.
     ; @return the fully qualified database driver class.
     ;;
    #_protected
    #_abstract
    (§ method #_"String" (§ fn getDatabaseDriverClass) [])

    ;;;
     ; Get the SQL statements that create the schema (DDL).
     ; @return the list of SQL statements.
     ;;
    #_protected
    #_abstract
    (§ method #_"List<String>" (§ fn getCreateSchemeSQL) [])

    ;;;
     ; Get the SQL statements that create the tables (DDL).
     ; @return the list of SQL statements.
     ;;
    #_protected
    #_abstract
    (§ method #_"List<String>" (§ fn getCreateTablesSQL) [])

    ;;;
     ; Get the SQL statements that create the indexes (DDL).
     ; @return the list of SQL statements.
     ;;
    #_protected
    #_abstract
    (§ method #_"List<String>" (§ fn getCreateIndexesSQL) [])

    ;;;
     ; Get the database specific error code that indicated a duplicate key error when inserting a record.
     ; <p>This is the code returned by {@link java.sql.SQLException#getSQLState()}.</p>
     ; @return the database duplicate error code.
     ;;
    #_protected
    #_abstract
    (§ method #_"String" (§ fn getDuplicateKeyErrorCode) [])

    ;;;
     ; Get the SQL to select the total balance for a given address.
     ; @return the SQL prepared statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getBalanceSelectSQL) [])
    (§ block
        (§ return (§ expr SELECT_BALANCE_SQL))
    )

    ;;;
     ; Get the SQL statement that checks if tables exist.
     ; @return the SQL prepared statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getTablesExistSQL) [])
    (§ block
        (§ return (§ expr SELECT_CHECK_TABLES_EXIST_SQL))
    )

    ;;;
     ; Get the SQL statements to check if the database is compatible.
     ; @return the SQL prepared statements.
     ;;
    #_protected
    (§ method #_"List<String>" (§ fn getCompatibilitySQL) [])
    (§ block
        (§ var #_"List<String>" (§ name sql) (§ new #_"ArrayList<>" (§ pars )))
        (§ expr sql.add(§ pars SELECT_COMPATIBILITY_COINBASE_SQL))
        (§ return sql)
    )

    ;;;
     ; Get the SQL to select the transaction outputs for a given address.
     ; @return the SQL prepared statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getTransactionOutputSelectSQL) [])
    (§ block
        (§ return (§ expr SELECT_TRANSACTION_OUTPUTS_SQL))
    )

    ;;;
     ; Get the SQL to drop all the tables (DDL).
     ; @return the SQL drop statements.
     ;;
    #_protected
    (§ method #_"List<String>" (§ fn getDropTablesSQL) [])
    (§ block
        (§ var #_"List<String>" (§ name sql) (§ new #_"ArrayList<>" (§ pars )))
        (§ expr sql.add(§ pars DROP_SETTINGS_TABLE))
        (§ expr sql.add(§ pars DROP_HEADERS_TABLE))
        (§ expr sql.add(§ pars DROP_UNDOABLE_TABLE))
        (§ expr sql.add(§ pars DROP_OPEN_OUTPUT_TABLE))
        (§ return sql)
    )

    ;;;
     ; Get the SQL to select a setting value.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getSelectSettingsSQL) [])
    (§ block
        (§ return (§ expr SELECT_SETTINGS_SQL))
    )

    ;;;
     ; Get the SQL to insert a settings record.
     ; @return the SQL insert statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getInsertSettingsSQL) [])
    (§ block
        (§ return (§ expr INSERT_SETTINGS_SQL))
    )

    ;;;
     ; Get the SQL to update a setting value.
     ; @return the SQL update statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getUpdateSettingsSLQ) [])
    (§ block
        (§ return (§ expr UPDATE_SETTINGS_SQL))
    )

    ;;;
     ; Get the SQL to select a headers record.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getSelectHeadersSQL) [])
    (§ block
        (§ return (§ expr SELECT_HEADERS_SQL))
    )

    ;;;
     ; Get the SQL to insert a headers record.
     ; @return the SQL insert statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getInsertHeadersSQL) [])
    (§ block
        (§ return (§ expr INSERT_HEADERS_SQL))
    )

    ;;;
     ; Get the SQL to update a headers record.
     ; @return the SQL update statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getUpdateHeadersSQL) [])
    (§ block
        (§ return (§ expr UPDATE_HEADERS_SQL))
    )

    ;;;
     ; Get the SQL to select an undoableblocks record.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getSelectUndoableBlocksSQL) [])
    (§ block
        (§ return (§ expr SELECT_UNDOABLEBLOCKS_SQL))
    )

    ;;;
     ; Get the SQL to insert a undoableblocks record.
     ; @return the SQL insert statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getInsertUndoableBlocksSQL) [])
    (§ block
        (§ return (§ expr INSERT_UNDOABLEBLOCKS_SQL))
    )

    ;;;
     ; Get the SQL to update a undoableblocks record.
     ; @return the SQL update statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getUpdateUndoableBlocksSQL) [])
    (§ block
        (§ return (§ expr UPDATE_UNDOABLEBLOCKS_SQL))
    )

    ;;;
     ; Get the SQL to delete a undoableblocks record.
     ; @return the SQL delete statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getDeleteUndoableBlocksSQL) [])
    (§ block
        (§ return (§ expr DELETE_UNDOABLEBLOCKS_SQL))
    )

    ;;;
     ; Get the SQL to select a openoutputs record.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getSelectOpenoutputsSQL) [])
    (§ block
        (§ return (§ expr SELECT_OPENOUTPUTS_SQL))
    )

    ;;;
     ; Get the SQL to select count of openoutputs.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getSelectOpenoutputsCountSQL) [])
    (§ block
        (§ return (§ expr SELECT_OPENOUTPUTS_COUNT_SQL))
    )

    ;;;
     ; Get the SQL to insert a openoutputs record.
     ; @return the SQL insert statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getInsertOpenoutputsSQL) [])
    (§ block
        (§ return (§ expr INSERT_OPENOUTPUTS_SQL))
    )

    ;;;
     ; Get the SQL to delete a openoutputs record.
     ; @return the SQL delete statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getDeleteOpenoutputsSQL) [])
    (§ block
        (§ return (§ expr DELETE_OPENOUTPUTS_SQL))
    )

    ;;;
     ; Get the SQL to select the setting dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getSelectSettingsDumpSQL) [])
    (§ block
        (§ return (§ expr SELECT_DUMP_SETTINGS_SQL))
    )

    ;;;
     ; Get the SQL to select the headers dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getSelectHeadersDumpSQL) [])
    (§ block
        (§ return (§ expr SELECT_DUMP_HEADERS_SQL))
    )

    ;;;
     ; Get the SQL to select the undoableblocks dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getSelectUndoableblocksDumpSQL) [])
    (§ block
        (§ return (§ expr SELECT_DUMP_UNDOABLEBLOCKS_SQL))
    )

    ;;;
     ; Get the SQL to select the openoutouts dump fields for sizing/statistics.
     ; @return the SQL select statement.
     ;;
    #_protected
    (§ method #_"String" (§ fn getSelectopenoutputsDumpSQL) [])
    (§ block
        (§ return (§ expr SELECT_DUMP_OPENOUTPUTS_SQL))
    )

    ;;;
     ; <p>If there isn't a connection on the {@link ThreadLocal} then create and store it.</p>
     ; <p>This will also automatically set up the schema if it does not exist within the DB.</p>
     ; @throws BlockStoreException if successful connection to the DB couldn't be made.
     ;;
    #_protected
    #_synchronized
    #_final
    (§ method #_"void" (§ fn maybeConnect) [])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ try )
        (§ block
            (§ if (§ expr conn.get(§ pars ) != nil && (§ not (§ dot conn.get(§ pars ).isClosed(§ pars )))))
            (§ block
                (§ return nil)
            )

            (§ if (§ expr username == nil || password == nil))
            (§ block
                (§ expr conn.set(§ pars DriverManager/getConnection(§ pars connectionURL)))
            )
            (§ else )
            (§ block
                (§ var #_"Properties" (§ name props) (§ new #_"Properties" (§ pars )))
                (§ expr props.setProperty(§ pars "user", this.username))
                (§ expr props.setProperty(§ pars "password", this.password))
                (§ expr conn.set(§ pars DriverManager/getConnection(§ pars connectionURL, props)))
            )
            (§ expr allConnections.add(§ pars conn.get(§ pars )))
            (§ var #_"Connection" (§ name connection) (§ expr conn.get(§ pars )))
            ;; Set the schema if one is needed.
            (§ if (§ expr schemaName != nil))
            (§ block
                (§ var #_"Statement" (§ name s) (§ expr connection.createStatement(§ pars )))
                (§ for (§ var #_"String" (§ name sql)) :for (§ expr getCreateSchemeSQL(§ pars )))
                (§ block
                    (§ expr s.execute(§ pars sql))
                )
            )
            (§ expr log.info(§ pars "Made a new connection to database " + connectionURL))
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ void nil)
    )

    #_override
    #_public
    #_synchronized
    (§ method #_"void" (§ fn close) [])
    (§ block
        (§ for (§ var #_"Connection" (§ name conn)) :for allConnections)
        (§ block
            (§ try )
            (§ block
                (§ if (§ expr (§ not conn.getAutoCommit(§ pars ))))
                (§ block
                    (§ expr conn.rollback(§ pars ))
                )
                (§ expr conn.close(§ pars ))
                (§ if (§ expr conn == this.conn.get(§ pars )))
                (§ block
                    (§ expr this.conn.set(§ pars nil))
                )
            )
            (§ catch #_"SQLException" (§ name e))
            (§ block
                (§ throw (§ new #_"RuntimeException" (§ pars e)))
            )
        )
        (§ expr allConnections.clear(§ pars ))
        (§ void nil)
    )

    ;;;
     ; <p>Check if a tables exists within the database.</p>
     ;
     ; <p>This specifically checks for the 'settings' table and
     ; if it exists makes an assumption that the rest of the data
     ; structures are present.</p>
     ;
     ; @return if the tables exist.
     ; @throws java.sql.SQLException
     ;;
    #_private
    (§ method #_"boolean" (§ fn tablesExist) [])
        (§ throws #_"SQLException")
    (§ block
        (§ var #_"PreparedStatement" (§ name ps) nil)
        (§ try )
        (§ block
            (§ ass (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars getTablesExistSQL(§ pars ))))
            (§ var #_"ResultSet" (§ name results) (§ expr ps.executeQuery(§ pars )))
            (§ expr results.close(§ pars ))
            (§ return true)
        )
        (§ catch #_"SQLException" (§ name _))
        (§ block
            (§ return false)
        )
        (§ finally )
        (§ block
            (§ if (§ expr ps != nil && (§ not ps.isClosed(§ pars ))))
            (§ block
                (§ expr ps.close(§ pars ))
            )
        )
    )

    ;;;
     ; Check that the database is compatible with this version of the {@link DatabaseFullPrunedBlockStore}.
     ; @throws BlockStoreException if the database is not compatible.
     ;;
    #_private
    (§ method #_"void" (§ fn checkCompatibility) [])
        (§ throws #_"SQLException", #_"BlockStoreException")
    (§ block
        (§ for (§ var #_"String" (§ name sql)) :for (§ expr getCompatibilitySQL(§ pars )))
        (§ block
            (§ var #_"PreparedStatement" (§ name ps) nil)
            (§ try )
            (§ block
                (§ ass (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars sql)))
                (§ var #_"ResultSet" (§ name results) (§ expr ps.executeQuery(§ pars )))
                (§ expr results.close(§ pars ))
            )
            (§ catch #_"SQLException" (§ name e))
            (§ block
                (§ throw (§ new #_"BlockStoreException" (§ pars "Database block store is not compatible with the current release.  See bitcoinj release notes for further information: " + e.getMessage(§ pars ))))
            )
            (§ finally )
            (§ block
                (§ if (§ expr ps != nil && (§ not ps.isClosed(§ pars ))))
                (§ block
                    (§ expr ps.close(§ pars ))
                )
            )
        )
        (§ void nil)
    )

    ;;;
     ; Create the tables in the database.
     ; @throws java.sql.SQLException if there is a database error.
     ; @throws BlockStoreException if the block store could not be created.
     ;;
    #_private
    (§ method #_"void" (§ fn createTables) [])
        (§ throws #_"SQLException", #_"BlockStoreException")
    (§ block
        (§ var #_"Statement" (§ name s) (§ expr conn.get(§ pars ).createStatement(§ pars )))
        ;; Create all the database tables.
        (§ for (§ var #_"String" (§ name sql)) :for (§ expr getCreateTablesSQL(§ pars )))
        (§ block
            (§ if (§ expr log.isDebugEnabled(§ pars )))
            (§ block
                (§ expr log.debug(§ pars "DatabaseFullPrunedBlockStore : CREATE table [SQL= {0}]", sql))
            )
            (§ expr s.executeUpdate(§ pars sql))
        )
        ;; Create all the database indexes.
        (§ for (§ var #_"String" (§ name sql)) :for (§ expr getCreateIndexesSQL(§ pars )))
        (§ block
            (§ if (§ expr log.isDebugEnabled(§ pars )))
            (§ block
                (§ expr log.debug(§ pars "DatabaseFullPrunedBlockStore : CREATE index [SQL= {0}]", sql))
            )
            (§ expr s.executeUpdate(§ pars sql))
        )
        (§ expr s.close(§ pars ))

        ;; Insert the initial settings for this store.
        (§ var #_"PreparedStatement" (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars getInsertSettingsSQL(§ pars ))))
        (§ expr ps.setString(§ pars 1, CHAIN_HEAD_SETTING))
        (§ expr ps.setNull(§ pars 2, Types/BINARY))
        (§ expr ps.execute(§ pars ))
        (§ expr ps.setString(§ pars 1, VERIFIED_CHAIN_HEAD_SETTING))
        (§ expr ps.setNull(§ pars 2, Types/BINARY))
        (§ expr ps.execute(§ pars ))
        (§ expr ps.setString(§ pars 1, VERSION_SETTING))
        (§ expr ps.setBytes(§ pars 2, "03".getBytes(§ pars )))
        (§ expr ps.execute(§ pars ))
        (§ expr ps.close(§ pars ))

        (§ expr createNewStore(§ pars params))
        (§ void nil)
    )

    ;;;
     ; Create a new store for the given {@link org.bitcoinj.core.NetworkParameters}.
     ; @param params The network.
     ; @throws BlockStoreException if the store couldn't be created.
     ;;
    #_private
    (§ method #_"void" (§ fn createNewStore) [#_"NetworkParameters" (§ name params)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ try )
        (§ block
            ;; Set up the genesis block.  When we start out fresh, it is by definition the top of the chain.
            (§ var #_"StoredBlock" (§ name storedGenesisHeader) (§ new #_"StoredBlock" (§ pars params.getGenesisBlock(§ pars ).cloneAsHeader(§ pars ), params.getGenesisBlock(§ pars ).getWork(§ pars ), 0)))
            ;; The coinbase in the genesis block is not spendable.  This is because of how Bitcoin Core inits
            ;; its database - the genesis transaction isn't actually in the db so its spent flags can never be updated.
            (§ var #_"List<Transaction>" (§ name genesisTransactions) (§ expr Lists/newLinkedList(§ pars )))
            (§ var #_"StoredUndoableBlock" (§ name storedGenesis) (§ new #_"StoredUndoableBlock" (§ pars params.getGenesisBlock(§ pars ).getHash(§ pars ), genesisTransactions)))
            (§ expr put(§ pars storedGenesisHeader, storedGenesis))
            (§ expr setChainHead(§ pars storedGenesisHeader))
            (§ expr setVerifiedChainHead(§ pars storedGenesisHeader))
        )
        (§ catch #_"VerificationException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
        (§ void nil)
    )

    ;;;
     ; Initialise the store state from the database.
     ; @throws java.sql.SQLException if there is a database error.
     ; @throws BlockStoreException if there is a block store error.
     ;;
    #_private
    (§ method #_"void" (§ fn initFromDatabase) [])
        (§ throws #_"SQLException", #_"BlockStoreException")
    (§ block
        (§ var #_"PreparedStatement" (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars getSelectSettingsSQL(§ pars ))))
        (§ var #_"ResultSet" (§ name rs))
        (§ expr ps.setString(§ pars 1, CHAIN_HEAD_SETTING))
        (§ ass (§ name rs) (§ expr ps.executeQuery(§ pars )))
        (§ if (§ expr (§ not rs.next(§ pars ))))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars "corrupt database block store - no chain head pointer")))
        )

        (§ var #_"Sha256Hash" (§ name hash) (§ expr Sha256Hash/wrap(§ pars rs.getBytes(§ pars 1))))
        (§ expr rs.close(§ pars ))
        (§ ass (§ name this.chainHeadBlock) (§ expr get(§ pars hash)))
        (§ ass (§ name this.chainHeadHash) hash)
        (§ if (§ expr this.chainHeadBlock == nil))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars "corrupt database block store - head block not found")))
        )

        (§ expr ps.setString(§ pars 1, VERIFIED_CHAIN_HEAD_SETTING))
        (§ ass (§ name rs) (§ expr ps.executeQuery(§ pars )))
        (§ if (§ expr (§ not rs.next(§ pars ))))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars "corrupt database block store - no verified chain head pointer")))
        )

        (§ ass (§ name hash) (§ expr Sha256Hash/wrap(§ pars rs.getBytes(§ pars 1))))
        (§ expr rs.close(§ pars ))
        (§ expr ps.close(§ pars ))
        (§ ass (§ name this.verifiedChainHeadBlock) (§ expr get(§ pars hash)))
        (§ ass (§ name this.verifiedChainHeadHash) hash)
        (§ if (§ expr this.verifiedChainHeadBlock == nil))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars "corrupt database block store - verified head block not found")))
        )
        (§ void nil)
    )

    #_protected
    (§ method #_"void" (§ fn putUpdateStoredBlock) [#_"StoredBlock" (§ name storedBlock), #_"boolean" (§ name wasUndoable)])
        (§ throws #_"SQLException")
    (§ block
        (§ try )
        (§ block
            (§ var #_"PreparedStatement" (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars getInsertHeadersSQL(§ pars ))))
            ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
            (§ var #_"byte[]" (§ name hashBytes) (§ new #_"byte[]" (§ count 28)))
            (§ expr System/arraycopy(§ pars storedBlock.getHeader(§ pars ).getHash(§ pars ).getBytes(§ pars ), 4, hashBytes, 0, 28))
            (§ expr ps.setBytes(§ pars 1, hashBytes))
            (§ expr ps.setBytes(§ pars 2, storedBlock.getChainWork(§ pars ).toByteArray(§ pars )))
            (§ expr ps.setInt(§ pars 3, storedBlock.getHeight(§ pars )))
            (§ expr ps.setBytes(§ pars 4, storedBlock.getHeader(§ pars ).cloneAsHeader(§ pars ).unsafeBitcoinSerialize(§ pars )))
            (§ expr ps.setBoolean(§ pars 5, wasUndoable))
            (§ expr ps.executeUpdate(§ pars ))
            (§ expr ps.close(§ pars ))
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            ;; It is possible we try to add a duplicate StoredBlock if we upgraded.
            ;; In that case, we just update the entry to mark it wasUndoable.
            (§ if (§ expr (§ not (§ dot e.getSQLState(§ pars ).equals(§ pars getDuplicateKeyErrorCode(§ pars )))) || (§ not wasUndoable)))
            (§ block
                (§ throw e)
            )

            (§ var #_"PreparedStatement" (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars getUpdateHeadersSQL(§ pars ))))
            (§ expr ps.setBoolean(§ pars 1, true))
            ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
            (§ var #_"byte[]" (§ name hashBytes) (§ new #_"byte[]" (§ count 28)))
            (§ expr System/arraycopy(§ pars storedBlock.getHeader(§ pars ).getHash(§ pars ).getBytes(§ pars ), 4, hashBytes, 0, 28))
            (§ expr ps.setBytes(§ pars 2, hashBytes))
            (§ expr ps.executeUpdate(§ pars ))
            (§ expr ps.close(§ pars ))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn put) [#_"StoredBlock" (§ name storedBlock)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr maybeConnect(§ pars ))
        (§ try )
        (§ block
            (§ expr putUpdateStoredBlock(§ pars storedBlock, false))
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn put) [#_"StoredBlock" (§ name storedBlock), #_"StoredUndoableBlock" (§ name undoableBlock)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr maybeConnect(§ pars ))
        ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
        (§ var #_"byte[]" (§ name hashBytes) (§ new #_"byte[]" (§ count 28)))
        (§ expr System/arraycopy(§ pars storedBlock.getHeader(§ pars ).getHash(§ pars ).getBytes(§ pars ), 4, hashBytes, 0, 28))
        (§ var #_"int" (§ name height) (§ expr storedBlock.getHeight(§ pars )))
        (§ var #_"byte[]" (§ name transactions) nil)
        (§ var #_"byte[]" (§ name txOutChanges) nil)
        (§ try )
        (§ block
            (§ var #_"ByteArrayOutputStream" (§ name bos) (§ new #_"ByteArrayOutputStream" (§ pars )))
            (§ if (§ expr undoableBlock.getTxOutChanges(§ pars ) != nil))
            (§ block
                (§ expr undoableBlock.getTxOutChanges(§ pars ).serializeToStream(§ pars bos))
                (§ ass (§ name txOutChanges) (§ expr bos.toByteArray(§ pars )))
            )
            (§ else )
            (§ block
                (§ var #_"int" (§ name numTxn) (§ expr undoableBlock.getTransactions(§ pars ).size(§ pars )))
                (§ expr bos.write(§ pars 0xff & numTxn))
                (§ expr bos.write(§ pars 0xff & (§ expr numTxn >> 8)))
                (§ expr bos.write(§ pars 0xff & (§ expr numTxn >> 16)))
                (§ expr bos.write(§ pars 0xff & (§ expr numTxn >> 24)))
                (§ for (§ var #_"Transaction" (§ name tx)) :for (§ expr undoableBlock.getTransactions(§ pars )))
                (§ block
                    (§ expr tx.bitcoinSerialize(§ pars bos))
                )
                (§ ass (§ name transactions) (§ expr bos.toByteArray(§ pars )))
            )
            (§ expr bos.close(§ pars ))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )

        (§ try )
        (§ block
            (§ try )
            (§ block
                (§ var #_"PreparedStatement" (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars getInsertUndoableBlocksSQL(§ pars ))))
                (§ expr ps.setBytes(§ pars 1, hashBytes))
                (§ expr ps.setInt(§ pars 2, height))
                (§ if (§ expr transactions == nil))
                (§ block
                    (§ expr ps.setBytes(§ pars 3, txOutChanges))
                    (§ expr ps.setNull(§ pars 4, Types/BINARY))
                )
                (§ else )
                (§ block
                    (§ expr ps.setNull(§ pars 3, Types/BINARY))
                    (§ expr ps.setBytes(§ pars 4, transactions))
                )
                (§ expr ps.executeUpdate(§ pars ))
                (§ expr ps.close(§ pars ))
                (§ try )
                (§ block
                    (§ expr putUpdateStoredBlock(§ pars storedBlock, true))
                )
                (§ catch #_"SQLException" (§ name e))
                (§ block
                    (§ throw (§ new #_"BlockStoreException" (§ pars e)))
                )
            )
            (§ catch #_"SQLException" (§ name e))
            (§ block
                (§ if (§ not (§ dot e.getSQLState(§ pars ).equals(§ pars getDuplicateKeyErrorCode(§ pars )))))
                (§ block
                    (§ throw (§ new #_"BlockStoreException" (§ pars e)))
                )

                ;; There is probably an update-or-insert statement, but it wasn't obvious from the docs.
                (§ var #_"PreparedStatement" (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars getUpdateUndoableBlocksSQL(§ pars ))))
                (§ expr ps.setBytes(§ pars 3, hashBytes))
                (§ if (§ expr transactions == nil))
                (§ block
                    (§ expr ps.setBytes(§ pars 1, txOutChanges))
                    (§ expr ps.setNull(§ pars 2, Types/BINARY))
                )
                (§ else )
                (§ block
                    (§ expr ps.setNull(§ pars 1, Types/BINARY))
                    (§ expr ps.setBytes(§ pars 2, transactions))
                )
                (§ expr ps.executeUpdate(§ pars ))
                (§ expr ps.close(§ pars ))
            )
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ void nil)
    )

    #_public
    (§ method #_"StoredBlock" (§ fn get) [#_"Sha256Hash" (§ name hash), #_"boolean" (§ name wasUndoableOnly)])
        (§ throws #_"BlockStoreException")
    (§ block
        ;; Optimize for chain head.
        (§ if (§ expr chainHeadHash != nil && chainHeadHash.equals(§ pars hash)))
        (§ block
            (§ return chainHeadBlock)
        )

        (§ if (§ expr verifiedChainHeadHash != nil && verifiedChainHeadHash.equals(§ pars hash)))
        (§ block
            (§ return verifiedChainHeadBlock)
        )

        (§ expr maybeConnect(§ pars ))
        (§ var #_"PreparedStatement" (§ name ps) nil)
        (§ try )
        (§ block
            (§ ass (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars getSelectHeadersSQL(§ pars ))))
            ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
            (§ var #_"byte[]" (§ name hashBytes) (§ new #_"byte[]" (§ count 28)))
            (§ expr System/arraycopy(§ pars hash.getBytes(§ pars ), 4, hashBytes, 0, 28))
            (§ expr ps.setBytes(§ pars 1, hashBytes))
            (§ var #_"ResultSet" (§ name results) (§ expr ps.executeQuery(§ pars )))
            (§ if (§ expr (§ not results.next(§ pars ))))
            (§ block
                (§ return nil)
            )

            ;; Parse it.
            (§ if (§ expr wasUndoableOnly && (§ not results.getBoolean(§ pars 4))))
            (§ block
                (§ return nil)
            )

            (§ var #_"BigInteger" (§ name chainWork) (§ new #_"BigInteger" (§ pars results.getBytes(§ pars 1))))
            (§ var #_"int" (§ name height) (§ expr results.getInt(§ pars 2)))
            (§ var #_"Block" (§ name b) (§ expr params.getDefaultSerializer(§ pars ).makeBlock(§ pars results.getBytes(§ pars 3))))
            (§ expr b.verifyHeader(§ pars ))
            (§ var #_"StoredBlock" (§ name stored) (§ new #_"StoredBlock" (§ pars b, chainWork, height)))
            (§ return stored)
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ catch #_"ProtocolException" (§ name e))
        (§ block
            ;; Corrupted database.
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ catch #_"VerificationException" (§ name e))
        (§ block
            ;; Should not be able to happen unless the database contains bad blocks.
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ finally )
        (§ block
            (§ if (§ expr ps != nil))
            (§ block
                (§ try )
                (§ block
                    (§ expr ps.close(§ pars ))
                )
                (§ catch #_"SQLException" (§ name _))
                (§ block
                    (§ throw (§ new #_"BlockStoreException" (§ pars "Failed to close PreparedStatement")))
                )
            )
        )
    )

    #_override
    #_public
    (§ method #_"StoredBlock" (§ fn get) [#_"Sha256Hash" (§ name hash)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ return (§ expr get(§ pars hash, false)))
    )

    #_override
    #_public
    (§ method #_"StoredBlock" (§ fn getOnceUndoableStoredBlock) [#_"Sha256Hash" (§ name hash)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ return (§ expr get(§ pars hash, true)))
    )

    #_override
    #_public
    (§ method #_"StoredUndoableBlock" (§ fn getUndoBlock) [#_"Sha256Hash" (§ name hash)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr maybeConnect(§ pars ))
        (§ var #_"PreparedStatement" (§ name ps) nil)
        (§ try )
        (§ block
            (§ ass (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars getSelectUndoableBlocksSQL(§ pars ))))
            ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.

            (§ var #_"byte[]" (§ name hashBytes) (§ new #_"byte[]" (§ count 28)))
            (§ expr System/arraycopy(§ pars hash.getBytes(§ pars ), 4, hashBytes, 0, 28))
            (§ expr ps.setBytes(§ pars 1, hashBytes))
            (§ var #_"ResultSet" (§ name results) (§ expr ps.executeQuery(§ pars )))
            (§ if (§ expr (§ not results.next(§ pars ))))
            (§ block
                (§ return nil)
            )

            ;; Parse it.
            (§ var #_"byte[]" (§ name txOutChanges) (§ expr results.getBytes(§ pars 1)))
            (§ var #_"byte[]" (§ name transactions) (§ expr results.getBytes(§ pars 2)))
            (§ var #_"StoredUndoableBlock" (§ name block))
            (§ if (§ expr txOutChanges == nil))
            (§ block
                (§ var #_"int" (§ name numTxn) (§ expr (§ expr transactions[0] & 0xff) | (§ expr (§ expr transactions[1] & 0xff) << 8) | (§ expr (§ expr transactions[2] & 0xff) << 16) | (§ expr (§ expr transactions[3] & 0xff) << 24)))
                (§ var #_"int" (§ name offset) 4)
                (§ var #_"List<Transaction>" (§ name transactionList) (§ new #_"LinkedList<>" (§ pars )))
                (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numTxn) :for (§ ass (§ name i) (§ expr i + 1)))
                (§ block
                    (§ var #_"Transaction" (§ name tx) (§ expr params.getDefaultSerializer(§ pars ).makeTransaction(§ pars transactions, offset)))
                    (§ expr transactionList.add(§ pars tx))
                    (§ ass (§ name offset) (§ expr offset + tx.getMessageSize(§ pars )))
                )
                (§ ass (§ name block) (§ new #_"StoredUndoableBlock" (§ pars hash, transactionList)))
            )
            (§ else )
            (§ block
                (§ var #_"TransactionOutputChanges" (§ name outChangesObject) (§ new #_"TransactionOutputChanges" (§ pars (§ new #_"ByteArrayInputStream" (§ pars txOutChanges)))))
                (§ ass (§ name block) (§ new #_"StoredUndoableBlock" (§ pars hash, outChangesObject)))
            )
            (§ return block)
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ catch #_"NullPointerException" (§ name e))
        (§ block
            ;; Corrupted database.
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ catch #_"ClassCastException" (§ name e))
        (§ block
            ;; Corrupted database.
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ catch #_"ProtocolException" (§ name e))
        (§ block
            ;; Corrupted database.
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            ;; Corrupted database.
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ finally )
        (§ block
            (§ if (§ expr ps != nil))
            (§ block
                (§ try )
                (§ block
                    (§ expr ps.close(§ pars ))
                )
                (§ catch #_"SQLException" (§ name _))
                (§ block
                    (§ throw (§ new #_"BlockStoreException" (§ pars "Failed to close PreparedStatement")))
                )
            )
        )
    )

    #_override
    #_public
    (§ method #_"StoredBlock" (§ fn getChainHead) [])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ return chainHeadBlock)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn setChainHead) [#_"StoredBlock" (§ name chainHead)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ var #_"Sha256Hash" (§ name hash) (§ expr chainHead.getHeader(§ pars ).getHash(§ pars )))
        (§ ass (§ name this.chainHeadHash) hash)
        (§ ass (§ name this.chainHeadBlock) chainHead)
        (§ expr maybeConnect(§ pars ))
        (§ try )
        (§ block
            (§ var #_"PreparedStatement" (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars getUpdateSettingsSLQ(§ pars ))))
            (§ expr ps.setString(§ pars 2, CHAIN_HEAD_SETTING))
            (§ expr ps.setBytes(§ pars 1, hash.getBytes(§ pars )))
            (§ expr ps.executeUpdate(§ pars ))
            (§ expr ps.close(§ pars ))
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"StoredBlock" (§ fn getVerifiedChainHead) [])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ return verifiedChainHeadBlock)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn setVerifiedChainHead) [#_"StoredBlock" (§ name chainHead)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ var #_"Sha256Hash" (§ name hash) (§ expr chainHead.getHeader(§ pars ).getHash(§ pars )))
        (§ ass (§ name this.verifiedChainHeadHash) hash)
        (§ ass (§ name this.verifiedChainHeadBlock) chainHead)
        (§ expr maybeConnect(§ pars ))
        (§ try )
        (§ block
            (§ var #_"PreparedStatement" (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars getUpdateSettingsSLQ(§ pars ))))
            (§ expr ps.setString(§ pars 2, VERIFIED_CHAIN_HEAD_SETTING))
            (§ expr ps.setBytes(§ pars 1, hash.getBytes(§ pars )))
            (§ expr ps.executeUpdate(§ pars ))
            (§ expr ps.close(§ pars ))
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ if (§ expr this.chainHeadBlock.getHeight(§ pars ) < chainHead.getHeight(§ pars )))
        (§ block
            (§ expr setChainHead(§ pars chainHead))
        )
        (§ expr removeUndoableBlocksWhereHeightIsLessThan(§ pars chainHead.getHeight(§ pars ) - fullStoreDepth))
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn removeUndoableBlocksWhereHeightIsLessThan) [#_"int" (§ name height)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ try )
        (§ block
            (§ var #_"PreparedStatement" (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars getDeleteUndoableBlocksSQL(§ pars ))))
            (§ expr ps.setInt(§ pars 1, height))
            (§ if (§ expr log.isDebugEnabled(§ pars )))
            (§ block
                (§ expr log.debug(§ pars "Deleting undoable undoable block with height <= " + height))
            )
            (§ expr ps.executeUpdate(§ pars ))
            (§ expr ps.close(§ pars ))
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"UTXO" (§ fn getTransactionOutput) [#_"Sha256Hash" (§ name hash), #_"long" (§ name index)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr maybeConnect(§ pars ))
        (§ var #_"PreparedStatement" (§ name ps) nil)
        (§ try )
        (§ block
            (§ ass (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars getSelectOpenoutputsSQL(§ pars ))))
            (§ expr ps.setBytes(§ pars 1, hash.getBytes(§ pars )))
            ;; index is actually an unsigned int
            (§ expr ps.setInt(§ pars 2, (§ cast #_"int" index)))
            (§ var #_"ResultSet" (§ name results) (§ expr ps.executeQuery(§ pars )))
            (§ if (§ expr (§ not results.next(§ pars ))))
            (§ block
                (§ return nil)
            )

            ;; Parse it.
            (§ var #_"int" (§ name height) (§ expr results.getInt(§ pars 1)))
            (§ var #_"Coin" (§ name value) (§ expr Coin/valueOf(§ pars results.getLong(§ pars 2))))
            (§ var #_"byte[]" (§ name scriptBytes) (§ expr results.getBytes(§ pars 3)))
            (§ var #_"boolean" (§ name coinbase) (§ expr results.getBoolean(§ pars 4)))
            (§ var #_"String" (§ name address) (§ expr results.getString(§ pars 5)))
            (§ return (§ new #_"UTXO" (§ pars hash, index, value, height, coinbase, new Script(§ pars scriptBytes), address)))
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ finally )
        (§ block
            (§ if (§ expr ps != nil))
            (§ block
                (§ try )
                (§ block
                    (§ expr ps.close(§ pars ))
                )
                (§ catch #_"SQLException" (§ name _))
                (§ block
                    (§ throw (§ new #_"BlockStoreException" (§ pars "Failed to close PreparedStatement")))
                )
            )
        )
    )

    #_override
    #_public
    (§ method #_"void" (§ fn addUnspentTransactionOutput) [#_"UTXO" (§ name out)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr maybeConnect(§ pars ))
        (§ var #_"PreparedStatement" (§ name ps) nil)
        (§ try )
        (§ block
            (§ ass (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars getInsertOpenoutputsSQL(§ pars ))))
            (§ expr ps.setBytes(§ pars 1, out.getHash(§ pars ).getBytes(§ pars )))
            ;; index is actually an unsigned int
            (§ expr ps.setInt(§ pars 2, (§ cast #_"int" (§ expr out.getIndex(§ pars )))))
            (§ expr ps.setInt(§ pars 3, out.getHeight(§ pars )))
            (§ expr ps.setLong(§ pars 4, out.getValue(§ pars ).value))
            (§ expr ps.setBytes(§ pars 5, out.getScript(§ pars ).getProgram(§ pars )))
            (§ expr ps.setString(§ pars 6, out.getAddress(§ pars )))
            (§ expr ps.setInt(§ pars 7, out.getScript(§ pars ).getScriptType(§ pars ).ordinal(§ pars )))
            (§ expr ps.setBoolean(§ pars 8, out.isCoinbase(§ pars )))
            (§ expr ps.executeUpdate(§ pars ))
            (§ expr ps.close(§ pars ))
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ if (§ not (§ dot e.getSQLState(§ pars ).equals(§ pars getDuplicateKeyErrorCode(§ pars )))))
            (§ block
                (§ throw (§ new #_"BlockStoreException" (§ pars e)))
            )
        )
        (§ finally )
        (§ block
            (§ if (§ expr ps != nil))
            (§ block
                (§ try )
                (§ block
                    (§ expr ps.close(§ pars ))
                )
                (§ catch #_"SQLException" (§ name e))
                (§ block
                    (§ throw (§ new #_"BlockStoreException" (§ pars e)))
                )
            )
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn removeUnspentTransactionOutput) [#_"UTXO" (§ name out)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr maybeConnect(§ pars ))
        ;; TODO: This should only need one query (maybe a stored procedure).
        (§ if (§ expr getTransactionOutput(§ pars out.getHash(§ pars ), out.getIndex(§ pars )) == nil))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars "Tried to remove a UTXO from DatabaseFullPrunedBlockStore that it didn't have!")))
        )

        (§ try )
        (§ block
            (§ var #_"PreparedStatement" (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars getDeleteOpenoutputsSQL(§ pars ))))
            (§ expr ps.setBytes(§ pars 1, out.getHash(§ pars ).getBytes(§ pars )))
            ;; index is actually an unsigned int
            (§ expr ps.setInt(§ pars 2, (§ cast #_"int" (§ expr out.getIndex(§ pars )))))
            (§ expr ps.executeUpdate(§ pars ))
            (§ expr ps.close(§ pars ))
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn beginDatabaseBatchWrite) [])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr maybeConnect(§ pars ))
        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ expr log.debug(§ pars "Starting database batch write with connection: " + conn.get(§ pars )))
        )

        (§ try )
        (§ block
            (§ expr conn.get(§ pars ).setAutoCommit(§ pars false))
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn commitDatabaseBatchWrite) [])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr maybeConnect(§ pars ))
        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ expr log.debug(§ pars "Committing database batch write with connection: " + conn.get(§ pars )))
        )

        (§ try )
        (§ block
            (§ expr conn.get(§ pars ).commit(§ pars ))
            (§ expr conn.get(§ pars ).setAutoCommit(§ pars true))
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn abortDatabaseBatchWrite) [])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr maybeConnect(§ pars ))
        (§ if (§ expr log.isDebugEnabled(§ pars )))
        (§ block
            (§ expr log.debug(§ pars "Rollback database batch write with connection: " + conn.get(§ pars )))
        )

        (§ try )
        (§ block
            (§ if (§ not (§ dot conn.get(§ pars ).getAutoCommit(§ pars ))))
            (§ block
                (§ expr conn.get(§ pars ).rollback(§ pars ))
                (§ expr conn.get(§ pars ).setAutoCommit(§ pars true))
            )
            (§ else )
            (§ block
                (§ expr log.warn(§ pars "Warning: Rollback attempt without transaction"))
            )
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn hasUnspentOutputs) [#_"Sha256Hash" (§ name hash), #_"int" (§ name numOutputs)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr maybeConnect(§ pars ))
        (§ var #_"PreparedStatement" (§ name ps) nil)
        (§ try )
        (§ block
            (§ ass (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars getSelectOpenoutputsCountSQL(§ pars ))))
            (§ expr ps.setBytes(§ pars 1, hash.getBytes(§ pars )))
            (§ var #_"ResultSet" (§ name results) (§ expr ps.executeQuery(§ pars )))
            (§ if (§ expr (§ not results.next(§ pars ))))
            (§ block
                (§ throw (§ new #_"BlockStoreException" (§ pars "Got no results from a COUNT(*) query")))
            )

            (§ var #_"int" (§ name count) (§ expr results.getInt(§ pars 1)))
            (§ return (§ expr count != 0))
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ finally )
        (§ block
            (§ if (§ expr ps != nil))
            (§ block
                (§ try )
                (§ block
                    (§ expr ps.close(§ pars ))
                )
                (§ catch #_"SQLException" (§ name _))
                (§ block
                    (§ throw (§ new #_"BlockStoreException" (§ pars "Failed to close PreparedStatement")))
                )
            )
        )
    )

    #_override
    #_public
    (§ method #_"NetworkParameters" (§ fn getParams) [])
    (§ block
        (§ return params)
    )

    ;;;
     ; Resets the store by deleting the contents of the tables and reinitialising them.
     ; @throws BlockStoreException if the tables couldn't be cleared and initialised.
     ;;
    #_public
    (§ method #_"void" (§ fn resetStore) [])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr maybeConnect(§ pars ))
        (§ try )
        (§ block
            (§ expr deleteStore(§ pars ))
            (§ expr createTables(§ pars ))
            (§ expr initFromDatabase(§ pars ))
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
        (§ void nil)
    )

    ;;;
     ; Deletes the store by deleting the tables within the database.
     ; @throws BlockStoreException if tables couldn't be deleted.
     ;;
    #_public
    (§ method #_"void" (§ fn deleteStore) [])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr maybeConnect(§ pars ))
        (§ try )
        (§ block
            (§ var #_"Statement" (§ name s) (§ expr conn.get(§ pars ).createStatement(§ pars )))
            (§ for (§ var #_"String" (§ name sql)) :for (§ expr getDropTablesSQL(§ pars )))
            (§ block
                (§ expr s.execute(§ pars sql))
            )
            (§ expr s.close(§ pars ))
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
        (§ void nil)
    )

    ;;;
     ; Calculate the balance for a coinbase, to-address, or p2sh address.
     ;
     ; <p>The balance {@link org.bitcoinj.store.DatabaseFullPrunedBlockStore#getBalanceSelectSQL()} returns
     ; the balance (summed) as a number, then use calculateClientSide=false.</p>
     ;
     ; <p>The balance {@link org.bitcoinj.store.DatabaseFullPrunedBlockStore#getBalanceSelectSQL()} returns
     ; all the open outputs as stored in the DB (binary), then use calculateClientSide=true.</p>
     ;
     ; @param address The address to calculate the balance of.
     ; @return The balance of the address supplied.  If the address has not been seen,
     ;         or there are no outputs open for this address, the return value is 0.
     ; @throws BlockStoreException if there is an error getting the balance.
     ;;
    #_public
    (§ method #_"BigInteger" (§ fn calculateBalanceForAddress) [#_"Address" (§ name address)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr maybeConnect(§ pars ))
        (§ var #_"PreparedStatement" (§ name ps) nil)
        (§ try )
        (§ block
            (§ ass (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars getBalanceSelectSQL(§ pars ))))
            (§ expr ps.setString(§ pars 1, address.toString(§ pars )))
            (§ var #_"ResultSet" (§ name rs) (§ expr ps.executeQuery(§ pars )))
            (§ var #_"BigInteger" (§ name balance) (§ expr BigInteger/ZERO))
            (§ return (§ quest (§ expr rs.next(§ pars )) ? (§ expr BigInteger/valueOf(§ pars rs.getLong(§ pars 1))) :else balance))
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ finally )
        (§ block
            (§ if (§ expr ps != nil))
            (§ block
                (§ try )
                (§ block
                    (§ expr ps.close(§ pars ))
                )
                (§ catch #_"SQLException" (§ name _))
                (§ block
                    (§ throw (§ new #_"BlockStoreException" (§ pars "Could not close statement")))
                )
            )
        )
    )
)

#_(ns org.bitcoinj.store #_"FullPrunedBlockStore"
   (:require [org.bitcoinj.core *]))

;;;
 ; <p>An implementor of FullPrunedBlockStore saves StoredBlock objects to some storage mechanism.</p>
 ;
 ; <p>In addition to keeping track of a chain using {@link StoredBlock}s, it should also keep track of
 ; a second copy of the chain which holds {@link StoredUndoableBlock}s.  In this way, an application can
 ; perform a headers-only initial sync and then use that information to more efficiently download a locally
 ; verified full copy of the block chain.</p>
 ;
 ; <p>A FullPrunedBlockStore should function well as a standard {@link BlockStore} and then be able to
 ; trivially switch to being used as a FullPrunedBlockStore.</p>
 ;
 ; <p>It should store the {@link StoredUndoableBlock}s of a number of recent blocks before verifiedHead.height
 ; and all those after verifiedHead.height.
 ; It is advisable to store any {@link StoredUndoableBlock} which has a height > verifiedHead.height - N.
 ; Because N determines the memory usage, it is recommended that N be customizable.  N should be chosen such
 ; that re-orgs beyond that point are vanishingly unlikely, e.g. a few thousand blocks is a reasonable choice.</p>
 ;
 ; <p>It must store the {@link StoredBlock} of all blocks.</p>
 ;
 ; <p>A FullPrunedBlockStore contains a map of hashes to [Full]StoredBlock.  The hash is the double digest of
 ; the Bitcoin serialization of the block header, <b>not</b> the header with the extra data as well.</p>
 ;
 ; <p>A FullPrunedBlockStore also contains a map of hash+index to UTXO.  Again, the hash is
 ; a standard Bitcoin double-SHA256 hash of the transaction.</p>
 ;
 ; <p>FullPrunedBlockStores are thread safe.</p>
 ;;
#_public
(§ interface #_"FullPrunedBlockStore" (§ extends #_"BlockStore")
    ;;;
     ; <p>Saves the given {@link StoredUndoableBlock} and {@link StoredBlock}.  Calculates keys from the {@link StoredBlock}.</p>
     ;
     ; <p>Though not required for proper function of a FullPrunedBlockStore, any user of a FullPrunedBlockStore should ensure
     ; that a StoredUndoableBlock for each block up to the fully verified chain head has been added to this block store using
     ; this function (not put(StoredBlock)), so that the ability to perform reorgs is maintained.</p>
     ;
     ; @throws BlockStoreException if there is a problem with the underlying storage layer, such as running out of disk space.
     ;;
    (§ method #_"void" (§ fn put) [#_"StoredBlock" (§ name storedBlock), #_"StoredUndoableBlock" (§ name undoableBlock)])
        (§ throws #_"BlockStoreException")

    ;;;
     ; Returns the StoredBlock that was added as a StoredUndoableBlock given a hash.  The returned values block.getHash()
     ; method will be equal to the parameter.  If no such block is found, returns null.
     ;;
    (§ method #_"StoredBlock" (§ fn getOnceUndoableStoredBlock) [#_"Sha256Hash" (§ name hash)])
        (§ throws #_"BlockStoreException")

    ;;;
     ; Returns a {@link StoredUndoableBlock} whose block.getHash() method will be equal to the parameter.  If no such
     ; block is found, returns null.  Note that this may return null more often than get(Sha256Hash hash) as not all
     ; {@link StoredBlock}s have a {@link StoredUndoableBlock} copy stored as well.
     ;;
    (§ method #_"StoredUndoableBlock" (§ fn getUndoBlock) [#_"Sha256Hash" (§ name hash)])
        (§ throws #_"BlockStoreException")

    ;;;
     ; Gets a {@link org.bitcoinj.core.UTXO} with the given hash and index, or null if none is found.
     ;;
    (§ method #_"UTXO" (§ fn getTransactionOutput) [#_"Sha256Hash" (§ name hash), #_"long" (§ name index)])
        (§ throws #_"BlockStoreException")

    ;;;
     ; Adds a {@link org.bitcoinj.core.UTXO} to the list of unspent TransactionOutputs.
     ;;
    (§ method #_"void" (§ fn addUnspentTransactionOutput) [#_"UTXO" (§ name out)])
        (§ throws #_"BlockStoreException")

    ;;;
     ; Removes a {@link org.bitcoinj.core.UTXO} from the list of unspent TransactionOutputs.
     ; Note that the coinbase of the genesis block should NEVER be spendable and thus never in the list.
     ; @throws BlockStoreException if there is an underlying storage issue, or out was not in the list.
     ;;
    (§ method #_"void" (§ fn removeUnspentTransactionOutput) [#_"UTXO" (§ name out)])
        (§ throws #_"BlockStoreException")

    ;;;
     ; True if this store has any unspent outputs from a transaction with a hash equal to the first parameter.
     ; @param numOutputs The number of outputs the given transaction has.
     ;;
    (§ method #_"boolean" (§ fn hasUnspentOutputs) [#_"Sha256Hash" (§ name hash), #_"int" (§ name numOutputs)])
        (§ throws #_"BlockStoreException")

    ;;;
     ; Returns the {@link StoredBlock} that represents the top of the chain of greatest total work that has
     ; been fully verified and the point in the chain at which the unspent transaction output set in this
     ; store represents.
     ;;
    (§ method #_"StoredBlock" (§ fn getVerifiedChainHead) [])
        (§ throws #_"BlockStoreException")

    ;;;
     ; Sets the {@link StoredBlock} that represents the top of the chain of greatest total work that has been
     ; fully verified.  It should generally be set after a batch of updates to the transaction unspent output set,
     ; before a call to commitDatabaseBatchWrite.
     ;
     ; If chainHead has a greater height than the non-verified chain head (i.e. that set with
     ; {@link BlockStore#setChainHead}) the non-verified chain head should be set to the one set here.
     ; In this way a class using a FullPrunedBlockStore only in full-verification mode can ignore the regular
     ; {@link BlockStore} functions implemented as a part of a FullPrunedBlockStore.
     ;;
    (§ method #_"void" (§ fn setVerifiedChainHead) [#_"StoredBlock" (§ name chainHead)])
        (§ throws #_"BlockStoreException")

    ;;;
     ; <p>Begins/Commits/Aborts a database transaction.</p>
     ;
     ; <p>If abortDatabaseBatchWrite() is called by the same thread that called beginDatabaseBatchWrite(),
     ; any data writes between this call and abortDatabaseBatchWrite() made by the same thread
     ; should be discarded.</p>
     ;
     ; <p>Furthermore, any data written after a call to beginDatabaseBatchWrite() should not be readable
     ; by any other threads until commitDatabaseBatchWrite() has been called by this thread.
     ; Multiple calls to beginDatabaseBatchWrite() in any given thread should be ignored and treated as one call.</p>
     ;;
    (§ method #_"void" (§ fn beginDatabaseBatchWrite) [])
        (§ throws #_"BlockStoreException")

    (§ method #_"void" (§ fn commitDatabaseBatchWrite) [])
        (§ throws #_"BlockStoreException")

    (§ method #_"void" (§ fn abortDatabaseBatchWrite) [])
        (§ throws #_"BlockStoreException")
)

#_(ns org.bitcoinj.store #_"H2FullPrunedBlockStore"
    (:import [java.sql *]
             [java.util ArrayList Collections List])
   (:require [org.bitcoinj.core *]))

;;;
 ; A full pruned block store using the H2 pure-java embedded database.
 ;
 ; Note that because of the heavy delete load on the database, during IBD,
 ; you may see the database files grow quite large (around 1.5G).
 ; H2 automatically frees some space at shutdown, so close()ing the database
 ; decreases the space usage somewhat (to only around 1.3G).
 ;;
#_public
(§ class #_"H2FullPrunedBlockStore" (§ extends #_"DatabaseFullPrunedBlockStore")
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name H2_DUPLICATE_KEY_ERROR_CODE) (§ expr "23505"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name DATABASE_DRIVER_CLASS) (§ expr "org.h2.Driver"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name DATABASE_CONNECTION_URL_PREFIX) (§ expr "jdbc:h2:"))

    ;; create table SQL
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name CREATE_SETTINGS_TABLE) (§ expr "CREATE TABLE settings ( "
            + "name VARCHAR(32) NOT NULL CONSTRAINT settings_pk PRIMARY KEY,"
            + "value BLOB"
            + ")"))

    #_private
    #_static
    #_final
    (§ field #_"String" (§ name CREATE_HEADERS_TABLE) (§ expr "CREATE TABLE headers ( "
            + "hash BINARY(28) NOT NULL CONSTRAINT headers_pk PRIMARY KEY,"
            + "chainwork BLOB NOT NULL,"
            + "height INT NOT NULL,"
            + "header BLOB NOT NULL,"
            + "wasundoable BOOL NOT NULL"
            + ")"))

    #_private
    #_static
    #_final
    (§ field #_"String" (§ name CREATE_UNDOABLE_TABLE) (§ expr "CREATE TABLE undoableblocks ( "
            + "hash BINARY(28) NOT NULL CONSTRAINT undoableblocks_pk PRIMARY KEY,"
            + "height INT NOT NULL,"
            + "txoutchanges BLOB,"
            + "transactions BLOB"
            + ")"))

    #_private
    #_static
    #_final
    (§ field #_"String" (§ name CREATE_OPEN_OUTPUT_TABLE) (§ expr "CREATE TABLE openoutputs ("
            + "hash BINARY(32) NOT NULL,"
            + "index INT NOT NULL,"
            + "height INT NOT NULL,"
            + "value BIGINT NOT NULL,"
            + "scriptbytes BLOB NOT NULL,"
            + "toaddress VARCHAR(35),"
            + "addresstargetable TINYINT,"
            + "coinbase BOOLEAN,"
            + "PRIMARY KEY (hash, index),"
            + ")"))

    ;; Some indexes to speed up inserts.
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name CREATE_OUTPUTS_ADDRESS_MULTI_INDEX) (§ expr "CREATE INDEX openoutputs_hash_index_height_toaddress_idx ON openoutputs (hash, index, height, toaddress)"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name CREATE_OUTPUTS_TOADDRESS_INDEX) (§ expr "CREATE INDEX openoutputs_toaddress_idx ON openoutputs (toaddress)"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX) (§ expr "CREATE INDEX openoutputs_addresstargetable_idx ON openoutputs (addresstargetable)"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name CREATE_OUTPUTS_HASH_INDEX) (§ expr "CREATE INDEX openoutputs_hash_idx ON openoutputs (hash)"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name CREATE_UNDOABLE_TABLE_INDEX) (§ expr "CREATE INDEX undoableblocks_height_idx ON undoableblocks (height)"))

    ;;;
     ; Creates a new H2FullPrunedBlockStore, with given credentials for H2 database.
     ; @param params A copy of the NetworkParameters used.
     ; @param dbName The path to the database on disk.
     ; @param username The username to use in the database.
     ; @param password The username's password to use in the database.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    (§ constructor #_"H2FullPrunedBlockStore" [#_"NetworkParameters" (§ name params), #_"String" (§ name dbName), #_"String" (§ name username), #_"String" (§ name password), #_"int" (§ name fullStoreDepth)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ super (§ pars params, DATABASE_CONNECTION_URL_PREFIX + dbName + ";create=true;LOCK_TIMEOUT=60000;DB_CLOSE_ON_EXIT=FALSE", fullStoreDepth, username, password, nil))
        (§ void this)
    )

    ;;;
     ; Creates a new H2FullPrunedBlockStore.
     ; @param params A copy of the NetworkParameters used.
     ; @param dbName The path to the database on disk.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    (§ constructor #_"H2FullPrunedBlockStore" [#_"NetworkParameters" (§ name params), #_"String" (§ name dbName), #_"int" (§ name fullStoreDepth)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ this (§ pars params, dbName, nil, nil, fullStoreDepth))
        (§ void this)
    )

    ;;;
     ; Creates a new H2FullPrunedBlockStore with the given cache size.
     ; @param params A copy of the NetworkParameters used.
     ; @param dbName The path to the database on disk.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param cacheSize The number of kilobytes to dedicate to H2 Cache.  The default value of 16MB (16384) is a safe bet
     ;                  to achieve good performance/cost when importing blocks from disk, past 32MB makes little sense,
     ;                  and below 4MB sees a sharp drop in performance.
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    (§ constructor #_"H2FullPrunedBlockStore" [#_"NetworkParameters" (§ name params), #_"String" (§ name dbName), #_"int" (§ name fullStoreDepth), #_"int" (§ name cacheSize)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ this (§ pars params, dbName, fullStoreDepth))

        (§ try )
        (§ block
            (§ var #_"Statement" (§ name s) (§ expr conn.get(§ pars ).createStatement(§ pars )))
            (§ expr s.executeUpdate(§ pars "SET CACHE_SIZE " + cacheSize))
            (§ expr s.close(§ pars ))
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ void this)
    )

    #_override
    #_protected
    (§ method #_"String" (§ fn getDuplicateKeyErrorCode) [])
    (§ block
        (§ return (§ expr H2_DUPLICATE_KEY_ERROR_CODE))
    )

    #_override
    #_protected
    (§ method #_"List<String>" (§ fn getCreateTablesSQL) [])
    (§ block
        (§ var #_"List<String>" (§ name sql) (§ new #_"ArrayList<>" (§ pars )))
        (§ expr sql.add(§ pars CREATE_SETTINGS_TABLE))
        (§ expr sql.add(§ pars CREATE_HEADERS_TABLE))
        (§ expr sql.add(§ pars CREATE_UNDOABLE_TABLE))
        (§ expr sql.add(§ pars CREATE_OPEN_OUTPUT_TABLE))
        (§ return sql)
    )

    #_override
    #_protected
    (§ method #_"List<String>" (§ fn getCreateIndexesSQL) [])
    (§ block
        (§ var #_"List<String>" (§ name sql) (§ new #_"ArrayList<>" (§ pars )))
        (§ expr sql.add(§ pars CREATE_UNDOABLE_TABLE_INDEX))
        (§ expr sql.add(§ pars CREATE_OUTPUTS_ADDRESS_MULTI_INDEX))
        (§ expr sql.add(§ pars CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX))
        (§ expr sql.add(§ pars CREATE_OUTPUTS_HASH_INDEX))
        (§ expr sql.add(§ pars CREATE_OUTPUTS_TOADDRESS_INDEX))
        (§ return sql)
    )

    #_override
    #_protected
    (§ method #_"List<String>" (§ fn getCreateSchemeSQL) [])
    (§ block
        ;; do nothing
        (§ return (§ expr Collections/emptyList(§ pars )))
    )

    #_override
    #_protected
    (§ method #_"String" (§ fn getDatabaseDriverClass) [])
    (§ block
        (§ return (§ expr DATABASE_DRIVER_CLASS))
    )
)

#_(ns org.bitcoinj.store #_"MemoryBlockStore"
    (:import [java.util LinkedHashMap Map])
   (:require [org.bitcoinj.core *]))

;;;
 ; Keeps {@link org.bitcoinj.core.StoredBlock}s in memory.  Used primarily for unit testing.
 ;;
#_public
(§ class #_"MemoryBlockStore" (§ implements #_"BlockStore")
    #_private
    (§ field #_"LinkedHashMap<Sha256Hash, StoredBlock>" (§ name blockMap) (§ new #_"LinkedHashMap<Sha256Hash, StoredBlock>" (§ pars )
        (§ anon
            #_override
            #_protected
            (§ method #_"boolean" (§ fn removeEldestEntry) [#_"Map.Entry<Sha256Hash, StoredBlock>" (§ name eldest)])
            (§ block
                (§ return (§ expr 5000 < blockMap.size(§ pars )))
            )
        )))
    #_private
    (§ field #_"StoredBlock" (§ name chainHead))
    #_private
    (§ field #_"NetworkParameters" (§ name params))

    #_public
    (§ constructor #_"MemoryBlockStore" [#_"NetworkParameters" (§ name params)])
    (§ block
        ;; Insert the genesis block.
        (§ try )
        (§ block
            (§ var #_"Block" (§ name genesisHeader) (§ expr params.getGenesisBlock(§ pars ).cloneAsHeader(§ pars )))
            (§ var #_"StoredBlock" (§ name storedGenesis) (§ new #_"StoredBlock" (§ pars genesisHeader, genesisHeader.getWork(§ pars ), 0)))
            (§ expr put(§ pars storedGenesis))
            (§ expr setChainHead(§ pars storedGenesis))
            (§ ass (§ name this.params) params)
        )
        (§ catch #_"BlockStoreException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
        (§ catch #_"VerificationException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
        (§ void this)
    )

    #_override
    #_public
    #_synchronized
    #_final
    (§ method #_"void" (§ fn put) [#_"StoredBlock" (§ name block)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ if (§ expr blockMap == nil))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars "MemoryBlockStore is closed")))
        )

        (§ var #_"Sha256Hash" (§ name hash) (§ expr block.getHeader(§ pars ).getHash(§ pars )))
        (§ expr blockMap.put(§ pars hash, block))
        (§ void nil)
    )

    #_override
    #_public
    #_synchronized
    (§ method #_"StoredBlock" (§ fn get) [#_"Sha256Hash" (§ name hash)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ if (§ expr blockMap == nil))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars "MemoryBlockStore is closed")))
        )

        (§ return (§ expr blockMap.get(§ pars hash)))
    )

    #_override
    #_public
    (§ method #_"StoredBlock" (§ fn getChainHead) [])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ if (§ expr blockMap == nil))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars "MemoryBlockStore is closed")))
        )

        (§ return chainHead)
    )

    #_override
    #_public
    #_final
    (§ method #_"void" (§ fn setChainHead) [#_"StoredBlock" (§ name chainHead)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ if (§ expr blockMap == nil))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars "MemoryBlockStore is closed")))
        )

        (§ ass (§ name this.chainHead) chainHead)
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn close) [])
    (§ block
        (§ ass (§ name blockMap) nil)
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"NetworkParameters" (§ fn getParams) [])
    (§ block
        (§ return params)
    )
)

#_(ns org.bitcoinj.store #_"MemoryFullPrunedBlockStore"
    (:import [java.util *])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.collect Lists])
   (:require [org.bitcoinj.core *]))

;;;
 ; Used as a key for memory map (to avoid having to think about NetworkParameters,
 ; which is required for {@link TransactionOutPoint}.
 ;;
(§ class #_"StoredTransactionOutPoint"
    ;;; Hash of the transaction to which we refer. ;;
    (§ field #_"Sha256Hash" (§ name hash))
    ;;; Which output of that transaction we are talking about. ;;
    (§ field #_"long" (§ name index))

    (§ constructor #_"StoredTransactionOutPoint" [#_"Sha256Hash" (§ name hash), #_"long" (§ name index)])
    (§ block
        (§ ass (§ name this.hash) hash)
        (§ ass (§ name this.index) index)
        (§ void this)
    )

    (§ constructor #_"StoredTransactionOutPoint" [#_"UTXO" (§ name out)])
    (§ block
        (§ ass (§ name this.hash) (§ expr out.getHash(§ pars )))
        (§ ass (§ name this.index) (§ expr out.getIndex(§ pars )))
        (§ void this)
    )

    ;;;
     ; The hash of the transaction to which we refer.
     ;;
    (§ method #_"Sha256Hash" (§ fn getHash) [])
    (§ block
        (§ return hash)
    )

    ;;;
     ; The index of the output in transaction to which we refer.
     ;;
    (§ method #_"long" (§ fn getIndex) [])
    (§ block
        (§ return index)
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars getIndex(§ pars ), getHash(§ pars ))))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr "Stored transaction out point: " + hash + ":" + index))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"StoredTransactionOutPoint" (§ name other) (§ expr (§ cast #_"StoredTransactionOutPoint" o)))
        (§ return (§ expr getIndex(§ pars ) == other.getIndex(§ pars ) && Objects/equal(§ pars getHash(§ pars ), other.getHash(§ pars ))))
    )
)

;;;
 ; A HashMap<KeyType, ValueType> that is DB transaction-aware.
 ; This class is not thread-safe.
 ;;
(§ class #_"TransactionalHashMap<KeyType, ValueType>"
    (§ field #_"ThreadLocal<HashMap<KeyType, ValueType>>" (§ name tempMap))
    (§ field #_"ThreadLocal<HashSet<KeyType>>" (§ name tempSetRemoved))
    #_private
    (§ field #_"ThreadLocal<Boolean>" (§ name inTransaction))

    (§ field #_"HashMap<KeyType, ValueType>" (§ name map))

    #_public
    (§ constructor #_"TransactionalHashMap" [])
    (§ block
        (§ ass (§ name tempMap) (§ new #_"ThreadLocal<>" (§ pars )))
        (§ ass (§ name tempSetRemoved) (§ new #_"ThreadLocal<>" (§ pars )))
        (§ ass (§ name inTransaction) (§ new #_"ThreadLocal<>" (§ pars )))
        (§ ass (§ name map) (§ new #_"HashMap<>" (§ pars )))
        (§ void this)
    )

    #_public
    (§ method #_"void" (§ fn beginDatabaseBatchWrite) [])
    (§ block
        (§ expr inTransaction.set(§ pars true))
        (§ void nil)
    )

    #_public
    (§ method #_"void" (§ fn commitDatabaseBatchWrite) [])
    (§ block
        (§ if (§ expr tempSetRemoved.get(§ pars ) != nil))
        (§ block
            (§ for (§ var #_"KeyType" (§ name key)) :for (§ expr tempSetRemoved.get(§ pars )))
            (§ block
                (§ expr map.remove(§ pars key))
            )
        )
        (§ if (§ expr tempMap.get(§ pars ) != nil))
        (§ block
            (§ for (§ var #_"Map.Entry<KeyType, ValueType>" (§ name entry)) :for (§ expr tempMap.get(§ pars ).entrySet(§ pars )))
            (§ block
                (§ expr map.put(§ pars entry.getKey(§ pars ), entry.getValue(§ pars )))
            )
        )
        (§ expr abortDatabaseBatchWrite(§ pars ))
        (§ void nil)
    )

    #_public
    (§ method #_"void" (§ fn abortDatabaseBatchWrite) [])
    (§ block
        (§ expr inTransaction.set(§ pars false))
        (§ expr tempSetRemoved.remove(§ pars ))
        (§ expr tempMap.remove(§ pars ))
        (§ void nil)
    )

    #_nilable
    #_public
    (§ method #_"ValueType" (§ fn get) [#_"KeyType" (§ name key)])
    (§ block
        (§ if (§ expr Boolean/TRUE.equals(§ pars inTransaction.get(§ pars ))))
        (§ block
            (§ if (§ expr tempMap.get(§ pars ) != nil))
            (§ block
                (§ var #_"ValueType" (§ name value) (§ expr tempMap.get(§ pars ).get(§ pars key)))
                (§ if (§ expr value != nil))
                (§ block
                    (§ return value)
                )
            )
            (§ if (§ expr tempSetRemoved.get(§ pars ) != nil && tempSetRemoved.get(§ pars ).contains(§ pars key)))
            (§ block
                (§ return nil)
            )
        )
        (§ return (§ expr map.get(§ pars key)))
    )

    #_public
    (§ method #_"List<ValueType>" (§ fn values) [])
    (§ block
        (§ var #_"List<ValueType>" (§ name valueTypes) (§ new #_"ArrayList<>" (§ pars )))
        (§ for (§ var #_"KeyType" (§ name keyType)) :for (§ expr map.keySet(§ pars )))
        (§ block
            (§ expr valueTypes.add(§ pars get(§ pars keyType)))
        )
        (§ return valueTypes)
    )

    #_public
    (§ method #_"void" (§ fn put) [#_"KeyType" (§ name key), #_"ValueType" (§ name value)])
    (§ block
        (§ if (§ expr Boolean/TRUE.equals(§ pars inTransaction.get(§ pars ))))
        (§ block
            (§ if (§ expr tempSetRemoved.get(§ pars ) != nil))
            (§ block
                (§ expr tempSetRemoved.get(§ pars ).remove(§ pars key))
            )
            (§ if (§ expr tempMap.get(§ pars ) == nil))
            (§ block
                (§ expr tempMap.set(§ pars (§ new #_"HashMap<KeyType, ValueType>" (§ pars ))))
            )
            (§ expr tempMap.get(§ pars ).put(§ pars key, value))
        )
        (§ else )
        (§ block
            (§ expr map.put(§ pars key, value))
        )
        (§ void nil)
    )

    #_nilable
    #_public
    (§ method #_"ValueType" (§ fn remove) [#_"KeyType" (§ name key)])
    (§ block
        (§ if (§ expr Boolean/TRUE.equals(§ pars inTransaction.get(§ pars ))))
        (§ block
            (§ var #_"ValueType" (§ name retVal) (§ expr map.get(§ pars key)))
            (§ if (§ expr retVal != nil))
            (§ block
                (§ if (§ expr tempSetRemoved.get(§ pars ) == nil))
                (§ block
                    (§ expr tempSetRemoved.set(§ pars (§ new #_"HashSet<KeyType>" (§ pars ))))
                )
                (§ expr tempSetRemoved.get(§ pars ).add(§ pars key))
            )
            (§ if (§ expr tempMap.get(§ pars ) != nil))
            (§ block
                (§ var #_"ValueType" (§ name tempVal) (§ expr tempMap.get(§ pars ).remove(§ pars key)))
                (§ if (§ expr tempVal != nil))
                (§ block
                    (§ return tempVal)
                )
            )
            (§ return retVal)
        )
        (§ else )
        (§ block
            (§ return (§ expr map.remove(§ pars key)))
        )
    )
)

;;;
 ; A Map with multiple key types that is DB per-thread-transaction-aware.
 ; However, this class is not thread-safe.
 ; @param <UniqueKeyType> Is a key that must be unique per object.
 ; @param <MultiKeyType> Is a key that can have multiple values.
 ;;
(§ class #_"TransactionalMultiKeyHashMap<UniqueKeyType, MultiKeyType, ValueType>"
    (§ field #_"TransactionalHashMap<UniqueKeyType, ValueType>" (§ name mapValues))
    (§ field #_"HashMap<MultiKeyType, Set<UniqueKeyType>>" (§ name mapKeys))

    #_public
    (§ constructor #_"TransactionalMultiKeyHashMap" [])
    (§ block
        (§ ass (§ name mapValues) (§ new #_"TransactionalHashMap<>" (§ pars )))
        (§ ass (§ name mapKeys) (§ new #_"HashMap<>" (§ pars )))
        (§ void this)
    )

    #_public
    (§ method #_"void" (§ fn beginTransaction) [])
    (§ block
        (§ expr mapValues.beginDatabaseBatchWrite(§ pars ))
        (§ void nil)
    )

    #_public
    (§ method #_"void" (§ fn commitTransaction) [])
    (§ block
        (§ expr mapValues.commitDatabaseBatchWrite(§ pars ))
        (§ void nil)
    )

    #_public
    (§ method #_"void" (§ fn abortTransaction) [])
    (§ block
        (§ expr mapValues.abortDatabaseBatchWrite(§ pars ))
        (§ void nil)
    )

    #_nilable
    #_public
    (§ method #_"ValueType" (§ fn get) [#_"UniqueKeyType" (§ name key)])
    (§ block
        (§ return (§ expr mapValues.get(§ pars key)))
    )

    #_public
    (§ method #_"void" (§ fn put) [#_"UniqueKeyType" (§ name uniqueKey), #_"MultiKeyType" (§ name multiKey), #_"ValueType" (§ name value)])
    (§ block
        (§ expr mapValues.put(§ pars uniqueKey, value))
        (§ var #_"Set<UniqueKeyType>" (§ name set) (§ expr mapKeys.get(§ pars multiKey)))
        (§ if (§ expr set == nil))
        (§ block
            (§ ass (§ name set) (§ new #_"HashSet<>" (§ pars )))
            (§ expr set.add(§ pars uniqueKey))
            (§ expr mapKeys.put(§ pars multiKey, set))
        )
        (§ else )
        (§ block
            (§ expr set.add(§ pars uniqueKey))
        )
        (§ void nil)
    )

    #_nilable
    #_public
    (§ method #_"ValueType" (§ fn removeByUniqueKey) [#_"UniqueKeyType" (§ name key)])
    (§ block
        (§ return (§ expr mapValues.remove(§ pars key)))
    )

    #_public
    (§ method #_"void" (§ fn removeByMultiKey) [#_"MultiKeyType" (§ name key)])
    (§ block
        (§ var #_"Set<UniqueKeyType>" (§ name set) (§ expr mapKeys.remove(§ pars key)))
        (§ if (§ expr set != nil))
        (§ block
            (§ for (§ var #_"UniqueKeyType" (§ name uniqueKey)) :for set)
            (§ block
                (§ expr removeByUniqueKey(§ pars uniqueKey))
            )
        )
        (§ void nil)
    )
)

;;;
 ; Keeps {@link StoredBlock}s, {@link StoredUndoableBlock}s and {@link org.bitcoinj.core.UTXO}s in memory.
 ; Used primarily for unit testing.
 ;;
#_public
(§ class #_"MemoryFullPrunedBlockStore" (§ implements #_"FullPrunedBlockStore")
    #_protected
    #_static
    (§ class #_"StoredBlockAndWasUndoableFlag"
        #_public
        (§ field #_"StoredBlock" (§ name block))
        #_public
        (§ field #_"boolean" (§ name wasUndoable))
        #_public
        (§ constructor #_"StoredBlockAndWasUndoableFlag" [#_"StoredBlock" (§ name block), #_"boolean" (§ name wasUndoable)])
        (§ block
            (§ ass (§ name this.block) block)
            (§ ass (§ name this.wasUndoable) wasUndoable)
            (§ void this)
        )
    )
    #_private
    (§ field #_"TransactionalHashMap<Sha256Hash, StoredBlockAndWasUndoableFlag>" (§ name blockMap))
    #_private
    (§ field #_"TransactionalMultiKeyHashMap<Sha256Hash, Integer, StoredUndoableBlock>" (§ name fullBlockMap))
    ;; TODO: Use something more suited to remove-heavy use?
    #_private
    (§ field #_"TransactionalHashMap<StoredTransactionOutPoint, UTXO>" (§ name transactionOutputMap))
    #_private
    (§ field #_"StoredBlock" (§ name chainHead))
    #_private
    (§ field #_"StoredBlock" (§ name verifiedChainHead))
    #_private
    (§ field #_"int" (§ name fullStoreDepth))
    #_private
    (§ field #_"NetworkParameters" (§ name params))

    ;;;
     ; Set up the MemoryFullPrunedBlockStore.
     ; @param params The network parameters of this block store - used to get genesis block.
     ; @param fullStoreDepth The depth of blocks to keep FullStoredBlocks instead of StoredBlocks.
     ;;
    #_public
    (§ constructor #_"MemoryFullPrunedBlockStore" [#_"NetworkParameters" (§ name params), #_"int" (§ name fullStoreDepth)])
    (§ block
        (§ ass (§ name blockMap) (§ new #_"TransactionalHashMap<>" (§ pars )))
        (§ ass (§ name fullBlockMap) (§ new #_"TransactionalMultiKeyHashMap<>" (§ pars )))
        (§ ass (§ name transactionOutputMap) (§ new #_"TransactionalHashMap<>" (§ pars )))
        (§ ass (§ name this.fullStoreDepth) (§ quest (§ expr 0 < fullStoreDepth) ? fullStoreDepth :else 1))
        ;; Insert the genesis block.
        (§ try )
        (§ block
            (§ var #_"StoredBlock" (§ name storedGenesisHeader) (§ new #_"StoredBlock" (§ pars params.getGenesisBlock(§ pars ).cloneAsHeader(§ pars ), params.getGenesisBlock(§ pars ).getWork(§ pars ), 0)))
            ;; The coinbase in the genesis block is not spendable.
            (§ var #_"List<Transaction>" (§ name genesisTransactions) (§ expr Lists/newLinkedList(§ pars )))
            (§ var #_"StoredUndoableBlock" (§ name storedGenesis) (§ new #_"StoredUndoableBlock" (§ pars params.getGenesisBlock(§ pars ).getHash(§ pars ), genesisTransactions)))
            (§ expr put(§ pars storedGenesisHeader, storedGenesis))
            (§ expr setChainHead(§ pars storedGenesisHeader))
            (§ expr setVerifiedChainHead(§ pars storedGenesisHeader))
            (§ ass (§ name this.params) params)
        )
        (§ catch #_"BlockStoreException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
        (§ catch #_"VerificationException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
        (§ void this)
    )

    #_override
    #_public
    #_synchronized
    (§ method #_"void" (§ fn put) [#_"StoredBlock" (§ name block)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ var #_"Sha256Hash" (§ name hash) (§ expr block.getHeader(§ pars ).getHash(§ pars )))
        (§ expr blockMap.put(§ pars hash, new StoredBlockAndWasUndoableFlag(§ pars block, false)))
        (§ void nil)
    )

    #_override
    #_public
    #_synchronized
    #_final
    (§ method #_"void" (§ fn put) [#_"StoredBlock" (§ name storedBlock), #_"StoredUndoableBlock" (§ name undoableBlock)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ var #_"Sha256Hash" (§ name hash) (§ expr storedBlock.getHeader(§ pars ).getHash(§ pars )))
        (§ expr fullBlockMap.put(§ pars hash, storedBlock.getHeight(§ pars ), undoableBlock))
        (§ expr blockMap.put(§ pars hash, new StoredBlockAndWasUndoableFlag(§ pars storedBlock, true)))
        (§ void nil)
    )

    #_override
    #_nilable
    #_public
    #_synchronized
    (§ method #_"StoredBlock" (§ fn get) [#_"Sha256Hash" (§ name hash)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ var #_"StoredBlockAndWasUndoableFlag" (§ name storedBlock) (§ expr blockMap.get(§ pars hash)))
        (§ return (§ quest (§ expr storedBlock != nil) ? (§ expr storedBlock.block) :else nil))
    )

    #_override
    #_nilable
    #_public
    #_synchronized
    (§ method #_"StoredBlock" (§ fn getOnceUndoableStoredBlock) [#_"Sha256Hash" (§ name hash)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ var #_"StoredBlockAndWasUndoableFlag" (§ name storedBlock) (§ expr blockMap.get(§ pars hash)))
        (§ return (§ quest (§ expr storedBlock != nil && storedBlock.wasUndoable) ? (§ expr storedBlock.block) :else nil))
    )

    #_override
    #_nilable
    #_public
    #_synchronized
    (§ method #_"StoredUndoableBlock" (§ fn getUndoBlock) [#_"Sha256Hash" (§ name hash)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars fullBlockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ return (§ expr fullBlockMap.get(§ pars hash)))
    )

    #_override
    #_public
    #_synchronized
    (§ method #_"StoredBlock" (§ fn getChainHead) [])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ return chainHead)
    )

    #_override
    #_public
    #_synchronized
    #_final
    (§ method #_"void" (§ fn setChainHead) [#_"StoredBlock" (§ name chainHead)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ ass (§ name this.chainHead) chainHead)
        (§ void nil)
    )

    #_override
    #_public
    #_synchronized
    (§ method #_"StoredBlock" (§ fn getVerifiedChainHead) [])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ return verifiedChainHead)
    )

    #_override
    #_public
    #_synchronized
    #_final
    (§ method #_"void" (§ fn setVerifiedChainHead) [#_"StoredBlock" (§ name chainHead)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars blockMap, "MemoryFullPrunedBlockStore is closed"))
        (§ ass (§ name this.verifiedChainHead) chainHead)
        (§ if (§ expr this.chainHead.getHeight(§ pars ) < chainHead.getHeight(§ pars )))
        (§ block
            (§ expr setChainHead(§ pars chainHead))
        )
        ;; Potential leak here if not all blocks get setChainHead'd.
        ;; Though the FullPrunedBlockStore allows for this, the current AbstractBlockChain will not do it.
        (§ expr fullBlockMap.removeByMultiKey(§ pars chainHead.getHeight(§ pars ) - fullStoreDepth))
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn close) [])
    (§ block
        (§ ass (§ name blockMap) nil)
        (§ ass (§ name fullBlockMap) nil)
        (§ ass (§ name transactionOutputMap) nil)
        (§ void nil)
    )

    #_override
    #_nilable
    #_public
    #_synchronized
    (§ method #_"UTXO" (§ fn getTransactionOutput) [#_"Sha256Hash" (§ name hash), #_"long" (§ name index)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars transactionOutputMap, "MemoryFullPrunedBlockStore is closed"))
        (§ return (§ expr transactionOutputMap.get(§ pars (§ new #_"StoredTransactionOutPoint" (§ pars hash, index)))))
    )

    #_override
    #_public
    #_synchronized
    (§ method #_"void" (§ fn addUnspentTransactionOutput) [#_"UTXO" (§ name out)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars transactionOutputMap, "MemoryFullPrunedBlockStore is closed"))
        (§ expr transactionOutputMap.put(§ pars (§ new #_"StoredTransactionOutPoint" (§ pars out)), out))
        (§ void nil)
    )

    #_override
    #_public
    #_synchronized
    (§ method #_"void" (§ fn removeUnspentTransactionOutput) [#_"UTXO" (§ name out)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars transactionOutputMap, "MemoryFullPrunedBlockStore is closed"))
        (§ if (§ expr transactionOutputMap.remove(§ pars (§ new #_"StoredTransactionOutPoint" (§ pars out))) == nil))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars "Tried to remove a UTXO from MemoryFullPrunedBlockStore that it didn't have!")))
        )
        (§ void nil)
    )

    #_override
    #_public
    #_synchronized
    (§ method #_"void" (§ fn beginDatabaseBatchWrite) [])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr blockMap.beginDatabaseBatchWrite(§ pars ))
        (§ expr fullBlockMap.beginTransaction(§ pars ))
        (§ expr transactionOutputMap.beginDatabaseBatchWrite(§ pars ))
        (§ void nil)
    )

    #_override
    #_public
    #_synchronized
    (§ method #_"void" (§ fn commitDatabaseBatchWrite) [])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr blockMap.commitDatabaseBatchWrite(§ pars ))
        (§ expr fullBlockMap.commitTransaction(§ pars ))
        (§ expr transactionOutputMap.commitDatabaseBatchWrite(§ pars ))
        (§ void nil)
    )

    #_override
    #_public
    #_synchronized
    (§ method #_"void" (§ fn abortDatabaseBatchWrite) [])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr blockMap.abortDatabaseBatchWrite(§ pars ))
        (§ expr fullBlockMap.abortTransaction(§ pars ))
        (§ expr transactionOutputMap.abortDatabaseBatchWrite(§ pars ))
        (§ void nil)
    )

    #_override
    #_public
    #_synchronized
    (§ method #_"boolean" (§ fn hasUnspentOutputs) [#_"Sha256Hash" (§ name hash), #_"int" (§ name numOutputs)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numOutputs) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ if (§ expr getTransactionOutput(§ pars hash, i) != nil))
            (§ block
                (§ return true)
            )
        )
        (§ return false)
    )

    #_override
    #_public
    (§ method #_"NetworkParameters" (§ fn getParams) [])
    (§ block
        (§ return params)
    )
)

#_(ns org.bitcoinj.store #_"PostgresFullPrunedBlockStore"
    (:import [java.io ByteArrayOutputStream IOException]
             [java.sql PreparedStatement ResultSet SQLException Types]
             [java.util ArrayList List])
    (:import [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]))

;;;
 ; <p>A full pruned block store using the Postgres database engine.  As an added bonus an address index is calculated,
 ; so you can use {@link #calculateBalanceForAddress(org.bitcoinj.core.Address)} to quickly look up
 ; the quantity of bitcoins controlled by that address.</p>
 ;;
#_public
(§ class #_"PostgresFullPrunedBlockStore" (§ extends #_"DatabaseFullPrunedBlockStore")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"PostgresFullPrunedBlockStore"))))

    #_private
    #_static
    #_final
    (§ field #_"String" (§ name POSTGRES_DUPLICATE_KEY_ERROR_CODE) (§ expr "23505"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name DATABASE_DRIVER_CLASS) (§ expr "org.postgresql.Driver"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name DATABASE_CONNECTION_URL_PREFIX) (§ expr "jdbc:postgresql://"))

    ;; create table SQL
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name CREATE_SETTINGS_TABLE) (§ expr "CREATE TABLE settings ("
          + "name character varying(32) NOT NULL, "
          + "value bytea, "
          + "CONSTRAINT setting_pk PRIMARY KEY (name)"
          + ")"))

    #_private
    #_static
    #_final
    (§ field #_"String" (§ name CREATE_HEADERS_TABLE) (§ expr "CREATE TABLE headers ("
          + "hash bytea NOT NULL, "
          + "chainwork bytea NOT NULL, "
          + "height integer NOT NULL, "
          + "header bytea NOT NULL, "
          + "wasundoable boolean NOT NULL, "
          + "CONSTRAINT headers_pk PRIMARY KEY (hash)"
          + ")"))

    #_private
    #_static
    #_final
    (§ field #_"String" (§ name CREATE_UNDOABLE_TABLE) (§ expr "CREATE TABLE undoableblocks ("
          + "hash bytea NOT NULL, "
          + "height integer NOT NULL, "
          + "txoutchanges bytea, "
          + "transactions bytea, "
          + "CONSTRAINT undoableblocks_pk PRIMARY KEY (hash)"
          + ")"))

    #_private
    #_static
    #_final
    (§ field #_"String" (§ name CREATE_OPEN_OUTPUT_TABLE) (§ expr "CREATE TABLE openoutputs ("
          + "hash bytea NOT NULL, "
          + "index integer NOT NULL, "
          + "height integer NOT NULL, "
          + "value bigint NOT NULL, "
          + "scriptbytes bytea NOT NULL, "
          + "toaddress character varying(35), "
          + "addresstargetable smallint, "
          + "coinbase boolean, "
          + "CONSTRAINT openoutputs_pk PRIMARY KEY (hash,index)"
          + ")"))

    ;; Some indexes to speed up inserts.
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name CREATE_OUTPUTS_ADDRESS_MULTI_INDEX) (§ expr "CREATE INDEX openoutputs_hash_index_num_height_toaddress_idx ON openoutputs USING btree (hash, index, height, toaddress)"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name CREATE_OUTPUTS_TOADDRESS_INDEX) (§ expr "CREATE INDEX openoutputs_toaddress_idx ON openoutputs USING btree (toaddress)"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX) (§ expr "CREATE INDEX openoutputs_addresstargetable_idx ON openoutputs USING btree (addresstargetable)"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name CREATE_OUTPUTS_HASH_INDEX) (§ expr "CREATE INDEX openoutputs_hash_idx ON openoutputs USING btree (hash)"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name CREATE_UNDOABLE_TABLE_INDEX) (§ expr "CREATE INDEX undoableblocks_height_idx ON undoableBlocks USING btree (height)"))

    #_private
    #_static
    #_final
    (§ field #_"String" (§ name SELECT_UNDOABLEBLOCKS_EXISTS_SQL) (§ expr "select 1 from undoableblocks where hash = ?"))

    ;;;
     ; Creates a new PostgresFullPrunedBlockStore.
     ;
     ; @param params A copy of the NetworkParameters used.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param hostname The hostname of the database to connect to.
     ; @param dbName The database to connect to.
     ; @param username The database username.
     ; @param password The password to the database.
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    (§ constructor #_"PostgresFullPrunedBlockStore" [#_"NetworkParameters" (§ name params), #_"int" (§ name fullStoreDepth), #_"String" (§ name hostname), #_"String" (§ name dbName), #_"String" (§ name username), #_"String" (§ name password)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ super (§ pars params, DATABASE_CONNECTION_URL_PREFIX + hostname + "/" + dbName, fullStoreDepth, username, password, nil))
        (§ void this)
    )

    ;;;
     ; <p>Create a new PostgresFullPrunedBlockStore, storing the tables in the schema specified.  You may want to
     ; specify a schema to avoid name collisions, or just to keep the database better organized.  The schema is not
     ; required, and if one is not provided than the default schema for the username will be used.  See
     ; <a href="http://www.postgres.org/docs/9.3/static/ddl-schemas.html">the postgres schema docs</a>
     ; for more on schemas.</p>
     ;
     ; @param params A copy of the NetworkParameters used.
     ; @param fullStoreDepth The number of blocks of history stored in full (something like 1000 is pretty safe).
     ; @param hostname The hostname of the database to connect to.
     ; @param dbName The database to connect to.
     ; @param username The database username.
     ; @param password The password to the database.
     ; @param schemaName The name of the schema to put the tables in.  May be null if no schema is being used.
     ; @throws BlockStoreException if the database fails to open for any reason.
     ;;
    #_public
    (§ constructor #_"PostgresFullPrunedBlockStore" [#_"NetworkParameters" (§ name params), #_"int" (§ name fullStoreDepth), #_"String" (§ name hostname), #_"String" (§ name dbName), #_"String" (§ name username), #_"String" (§ name password), #_nilable #_"String" (§ name schemaName)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ super (§ pars params, DATABASE_CONNECTION_URL_PREFIX + hostname + "/" + dbName, fullStoreDepth, username, password, schemaName))
        (§ void this)
    )

    #_override
    #_protected
    (§ method #_"String" (§ fn getDuplicateKeyErrorCode) [])
    (§ block
        (§ return (§ expr POSTGRES_DUPLICATE_KEY_ERROR_CODE))
    )

    #_override
    #_protected
    (§ method #_"List<String>" (§ fn getCreateTablesSQL) [])
    (§ block
        (§ var #_"List<String>" (§ name sql) (§ new #_"ArrayList<>" (§ pars )))
        (§ expr sql.add(§ pars CREATE_SETTINGS_TABLE))
        (§ expr sql.add(§ pars CREATE_HEADERS_TABLE))
        (§ expr sql.add(§ pars CREATE_UNDOABLE_TABLE))
        (§ expr sql.add(§ pars CREATE_OPEN_OUTPUT_TABLE))
        (§ return sql)
    )

    #_override
    #_protected
    (§ method #_"List<String>" (§ fn getCreateIndexesSQL) [])
    (§ block
        (§ var #_"List<String>" (§ name sql) (§ new #_"ArrayList<>" (§ pars )))
        (§ expr sql.add(§ pars CREATE_UNDOABLE_TABLE_INDEX))
        (§ expr sql.add(§ pars CREATE_OUTPUTS_ADDRESS_MULTI_INDEX))
        (§ expr sql.add(§ pars CREATE_OUTPUTS_ADDRESSTARGETABLE_INDEX))
        (§ expr sql.add(§ pars CREATE_OUTPUTS_HASH_INDEX))
        (§ expr sql.add(§ pars CREATE_OUTPUTS_TOADDRESS_INDEX))
        (§ return sql)
    )

    #_override
    #_protected
    (§ method #_"List<String>" (§ fn getCreateSchemeSQL) [])
    (§ block
        (§ var #_"List<String>" (§ name sql) (§ new #_"ArrayList<>" (§ pars )))
        (§ expr sql.add(§ pars "CREATE SCHEMA IF NOT EXISTS " + schemaName))
        (§ expr sql.add(§ pars "set search_path to '" + schemaName +"'"))
        (§ return sql)
    )

    #_override
    #_protected
    (§ method #_"String" (§ fn getDatabaseDriverClass) [])
    (§ block
        (§ return (§ expr DATABASE_DRIVER_CLASS))
    )

    #_override
    #_public
    (§ method #_"void" (§ fn put) [#_"StoredBlock" (§ name storedBlock), #_"StoredUndoableBlock" (§ name undoableBlock)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr maybeConnect(§ pars ))
        ;; We skip the first 4 bytes because (on mainnet) the minimum target has 4 0-bytes.
        (§ var #_"byte[]" (§ name hashBytes) (§ new #_"byte[]" (§ count 28)))
        (§ expr System/arraycopy(§ pars storedBlock.getHeader(§ pars ).getHash(§ pars ).getBytes(§ pars ), 4, hashBytes, 0, 28))
        (§ var #_"int" (§ name height) (§ expr storedBlock.getHeight(§ pars )))
        (§ var #_"byte[]" (§ name transactions) nil)
        (§ var #_"byte[]" (§ name txOutChanges) nil)
        (§ try )
        (§ block
            (§ var #_"ByteArrayOutputStream" (§ name bos) (§ new #_"ByteArrayOutputStream" (§ pars )))
            (§ if (§ expr undoableBlock.getTxOutChanges(§ pars ) != nil))
            (§ block
                (§ expr undoableBlock.getTxOutChanges(§ pars ).serializeToStream(§ pars bos))
                (§ ass (§ name txOutChanges) (§ expr bos.toByteArray(§ pars )))
            )
            (§ else )
            (§ block
                (§ var #_"int" (§ name numTxn) (§ expr undoableBlock.getTransactions(§ pars ).size(§ pars )))
                (§ expr bos.write(§ pars 0xff & numTxn))
                (§ expr bos.write(§ pars 0xff & (§ expr numTxn >> 8)))
                (§ expr bos.write(§ pars 0xff & (§ expr numTxn >> 16)))
                (§ expr bos.write(§ pars 0xff & (§ expr numTxn >> 24)))
                (§ for (§ var #_"Transaction" (§ name tx)) :for (§ expr undoableBlock.getTransactions(§ pars )))
                (§ block
                    (§ expr tx.bitcoinSerialize(§ pars bos))
                )
                (§ ass (§ name transactions) (§ expr bos.toByteArray(§ pars )))
            )
            (§ expr bos.close(§ pars ))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )

        (§ try )
        (§ block
            (§ if (§ expr log.isDebugEnabled(§ pars )))
            (§ block
                (§ expr log.debug(§ pars "Looking for undoable block with hash: " + Utils/HEX.encode(§ pars hashBytes)))
            )

            (§ var #_"PreparedStatement" (§ name findS) (§ expr conn.get(§ pars ).prepareStatement(§ pars SELECT_UNDOABLEBLOCKS_EXISTS_SQL)))
            (§ expr findS.setBytes(§ pars 1, hashBytes))

            (§ var #_"ResultSet" (§ name rs) (§ expr findS.executeQuery(§ pars )))
            (§ if (§ expr rs.next(§ pars )))
            (§ block
                ;; We already have this output, update it.
                (§ expr findS.close(§ pars ))

                ;; Postgres insert-or-updates are very complex (and finnicky).
                ;; This level of transaction isolation seems to work for bitcoinj.
                (§ var #_"PreparedStatement" (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars getUpdateUndoableBlocksSQL(§ pars ))))
                (§ expr ps.setBytes(§ pars 3, hashBytes))

                (§ if (§ expr log.isDebugEnabled(§ pars )))
                (§ block
                    (§ expr log.debug(§ pars "Updating undoable block with hash: " + Utils/HEX.encode(§ pars hashBytes)))
                )

                (§ if (§ expr transactions == nil))
                (§ block
                    (§ expr ps.setBytes(§ pars 1, txOutChanges))
                    (§ expr ps.setNull(§ pars 2, Types/BINARY))
                )
                (§ else )
                (§ block
                    (§ expr ps.setNull(§ pars 1, Types/BINARY))
                    (§ expr ps.setBytes(§ pars 2, transactions))
                )
                (§ expr ps.executeUpdate(§ pars ))
                (§ expr ps.close(§ pars ))

                (§ return nil)
            )

            (§ var #_"PreparedStatement" (§ name ps) (§ expr conn.get(§ pars ).prepareStatement(§ pars getInsertUndoableBlocksSQL(§ pars ))))
            (§ expr ps.setBytes(§ pars 1, hashBytes))
            (§ expr ps.setInt(§ pars 2, height))

            (§ if (§ expr log.isDebugEnabled(§ pars )))
            (§ block
                (§ expr log.debug(§ pars "Inserting undoable block with hash: " + Utils/HEX.encode(§ pars hashBytes)  + " at height " + height))
            )

            (§ if (§ expr transactions == nil))
            (§ block
                (§ expr ps.setBytes(§ pars 3, txOutChanges))
                (§ expr ps.setNull(§ pars 4, Types/BINARY))
            )
            (§ else )
            (§ block
                (§ expr ps.setNull(§ pars 3, Types/BINARY))
                (§ expr ps.setBytes(§ pars 4, transactions))
            )
            (§ expr ps.executeUpdate(§ pars ))
            (§ expr ps.close(§ pars ))
            (§ try )
            (§ block
                (§ expr putUpdateStoredBlock(§ pars storedBlock, true))
            )
            (§ catch #_"SQLException" (§ name e))
            (§ block
                (§ throw (§ new #_"BlockStoreException" (§ pars e)))
            )
        )
        (§ catch #_"SQLException" (§ name e))
        (§ block
            (§ if (§ not (§ dot e.getSQLState(§ pars ).equals(§ pars POSTGRES_DUPLICATE_KEY_ERROR_CODE))))
            (§ block
                (§ throw (§ new #_"BlockStoreException" (§ pars e)))
            )
        )
        (§ void nil)
    )
)

#_(ns org.bitcoinj.store #_"SPVBlockStore"
    (:import [java.io *]
             [java.nio *]
             [java.nio.channels *]
             [java.util *]
             [java.util.concurrent.locks *])
    (:import [com.google.common.base Charsets Preconditions]
             [org.slf4j *])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.utils *]))

;; TODO: Lose the mmap in this class.  There are too many platform bugs that require odd workarounds.

;;;
 ; An SPVBlockStore holds a limited number of block headers in a memory mapped ring buffer.  With such a store,
 ; you may not be able to process very deep re-orgs and could be disconnected from the chain (requiring a replay),
 ; but as they are virtually unheard of this is not a significant risk.
 ;;
#_public
(§ class #_"SPVBlockStore" (§ implements #_"BlockStore")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"SPVBlockStore"))))

    ;;; The default number of headers that will be stored in the ring buffer. ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name DEFAULT_CAPACITY) 5000)
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name HEADER_MAGIC) (§ expr "SPVB"))

    #_protected
    #_volatile
    (§ field #_"MappedByteBuffer" (§ name buffer))
    #_protected
    #_final
    (§ field #_"int" (§ name capacity))
    #_protected
    #_final
    (§ field #_"NetworkParameters" (§ name params))

    #_protected
    (§ field #_"ReentrantLock" (§ name lock) (§ expr Threading/lock(§ pars "SPVBlockStore")))

    ;; The entire ring-buffer is mmapped and accessing it should be as fast as accessing regular memory once it's
    ;; faulted in.  Unfortunately, in theory practice and theory are the same.  In practice they aren't.
    ;;
    ;; MMapping a file in Java does not give us a byte[] as you may expect but rather a ByteBuffer, and whilst on
    ;; the OpenJDK/Oracle JVM calls into the get() methods are compiled down to inlined native code on Android each
    ;; get() call is actually a full-blown JNI method under the hood, meaning it's unbelievably slow.  The caches
    ;; below let us stay in the JIT-compiled Java world without expensive JNI transitions and make a 10x difference!
    #_protected
    (§ field #_"LinkedHashMap<Sha256Hash, StoredBlock>" (§ name blockCache) (§ new #_"LinkedHashMap<Sha256Hash, StoredBlock>" (§ pars )
        (§ anon
            #_override
            #_protected
            (§ method #_"boolean" (§ fn removeEldestEntry) [#_"Map.Entry<Sha256Hash, StoredBlock>" (§ name entry)])
            (§ block
                (§ return (§ expr 2050 < size(§ pars ))) ;; Slightly more than the difficulty transition period.
            )
        )))

    ;; Use a separate cache to track get() misses.  This is to efficiently handle the case of an unconnected block
    ;; during chain download.  Each new block will do a get() on the unconnected block so if we haven't seen it yet
    ;; we must efficiently respond.
    ;;
    ;; We don't care about the value in this cache.  It is always notFoundMarker.  Unfortunately LinkedHashSet does
    ;; not provide the removeEldestEntry control.
    #_private
    #_static
    #_final
    (§ field #_"Object" (§ name NOT_FOUND_MARKER) (§ new #_"Object" (§ pars )))
    #_protected
    (§ field #_"LinkedHashMap<Sha256Hash, Object>" (§ name notFoundCache) (§ new #_"LinkedHashMap<Sha256Hash, Object>" (§ pars )
        (§ anon
            #_override
            #_protected
            (§ method #_"boolean" (§ fn removeEldestEntry) [#_"Map.Entry<Sha256Hash, Object>" (§ name entry)])
            (§ block
                (§ return (§ expr 100 < size(§ pars ))) ;; This was chosen arbitrarily.
            )
        )))

    ;; Used to stop other applications/processes from opening the store.
    #_protected
    (§ field #_"FileLock" (§ name fileLock))
    #_protected
    (§ field #_"RandomAccessFile" (§ name randomAccessFile))

    ;;;
     ; Creates and initializes an SPV block store that can hold {@link #DEFAULT_CAPACITY} blocks.
     ; Will create the given file if it's missing.  This operation will block on disk.
     ; @param file File to use for the block store.
     ; @throws BlockStoreException if something goes wrong.
     ;;
    #_public
    (§ constructor #_"SPVBlockStore" [#_"NetworkParameters" (§ name params), #_"File" (§ name file)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ this (§ pars params, file, DEFAULT_CAPACITY))
        (§ void this)
    )

    ;;;
     ; Creates and initializes an SPV block store that can hold a given amount of blocks.
     ; Will create the given file if it's missing.  This operation will block on disk.
     ; @param file File to use for the block store.
     ; @param capacity Custom capacity.
     ; @throws BlockStoreException if something goes wrong.
     ;;
    #_public
    (§ constructor #_"SPVBlockStore" [#_"NetworkParameters" (§ name params), #_"File" (§ name file), #_"int" (§ name capacity)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars file))
        (§ ass (§ name this.params) (§ expr Preconditions/checkNotNull(§ pars params)))
        (§ expr Preconditions/checkArgument(§ pars capacity > 0))

        (§ ass (§ name this.capacity) capacity)
        (§ try )
        (§ block
            (§ var #_"boolean" (§ name exists) (§ expr file.exists(§ pars )))
            ;; Set up the backing file.
            (§ ass (§ name randomAccessFile) (§ new #_"RandomAccessFile" (§ pars file, "rw")))
            (§ var #_"long" (§ name fileSize) (§ expr getFileSize(§ pars capacity)))
            (§ if (§ expr (§ not exists)))
            (§ block
                (§ expr log.info(§ pars "Creating new SPV block chain file " + file))
                (§ expr randomAccessFile.setLength(§ pars fileSize))
            )
            (§ elseif (§ expr randomAccessFile.length(§ pars ) != fileSize))
            (§ block
                (§ throw (§ new #_"BlockStoreException" (§ pars "File size on disk does not match expected size: " + randomAccessFile.length(§ pars ) + " vs " + fileSize)))
            )

            (§ var #_"FileChannel" (§ name channel) (§ expr randomAccessFile.getChannel(§ pars )))
            (§ ass (§ name fileLock) (§ expr channel.tryLock(§ pars )))
            (§ if (§ expr fileLock == nil))
            (§ block
                (§ throw (§ new #_"ChainFileLockedException" (§ pars "Store file is already locked by another process")))
            )

            ;; Map it into memory read/write.  The kernel will take care of flushing writes to disk at the most
            ;; efficient times, which may mean that until the map is deallocated the data on disk is randomly
            ;; inconsistent.  However the only process accessing it is us, via this mapping, so our own view will
            ;; always be correct.  Once we establish the mmap the underlying file and channel can go away.  Note
            ;; that the details of mmapping vary between platforms.
            (§ ass (§ name buffer) (§ expr channel.map(§ pars FileChannel/MapMode/READ_WRITE, 0, fileSize)))

            ;; Check or initialize the header bytes to ensure we don't try to open some random file.
            (§ var #_"byte[]" (§ name header))
            (§ if exists)
            (§ block
                (§ ass (§ name header) (§ new #_"byte[]" (§ count 4)))
                (§ expr buffer.get(§ pars header))
                (§ if (§ not (§ dot (§ new #_"String" (§ pars header, Charsets/US_ASCII)).equals(§ pars HEADER_MAGIC))))
                (§ block
                    (§ throw (§ new #_"BlockStoreException" (§ pars "Header bytes do not equal " + HEADER_MAGIC)))
                )
            )
            (§ else )
            (§ block
                (§ expr initNewStore(§ pars params))
            )
        )
        (§ catch #_"Exception" (§ name e1))
        (§ block
            (§ try )
            (§ block
                (§ if (§ expr randomAccessFile != nil))
                (§ block
                    (§ expr randomAccessFile.close(§ pars ))
                )
            )
            (§ catch #_"IOException" (§ name e2))
            (§ block
                (§ throw (§ new #_"BlockStoreException" (§ pars e2)))
            )
            (§ throw (§ new #_"BlockStoreException" (§ pars e1)))
        )
        (§ void this)
    )

    #_private
    (§ method #_"void" (§ fn initNewStore) [#_"NetworkParameters" (§ name params)])
        (§ throws #_"Exception")
    (§ block
        (§ var #_"byte[]" (§ name header) (§ expr HEADER_MAGIC.getBytes(§ pars "US-ASCII")))
        (§ expr buffer.put(§ pars header))
        ;; Insert the genesis block.
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr setRingCursor(§ pars buffer, FILE_PROLOGUE_BYTES))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ var #_"Block" (§ name genesis) (§ expr params.getGenesisBlock(§ pars ).cloneAsHeader(§ pars )))
        (§ var #_"StoredBlock" (§ name storedGenesis) (§ new #_"StoredBlock" (§ pars genesis, genesis.getWork(§ pars ), 0)))
        (§ expr put(§ pars storedGenesis))
        (§ expr setChainHead(§ pars storedGenesis))
        (§ void nil)
    )

    ;;; Returns the size in bytes of the file that is used to store the chain with the current parameters. ;;
    #_public
    #_static
    #_final
    (§ method #_"int" (§ fn getFileSize) [#_"int" (§ name capacity)])
    (§ block
        (§ return (§ expr RECORD_SIZE * capacity + FILE_PROLOGUE_BYTES)) ;; extra kilobyte for stuff
    )

    #_override
    #_public
    (§ method #_"void" (§ fn put) [#_"StoredBlock" (§ name block)])
        (§ throws #_"BlockStoreException")
    (§ block
        #_final
        (§ var #_"MappedByteBuffer" (§ name buffer) (§ expr this.buffer))
        (§ if (§ expr buffer == nil))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars "Store closed")))
        )

        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"int" (§ name cursor) (§ expr getRingCursor(§ pars buffer)))
            ;; Wrapped around.
            (§ if (§ expr cursor == getFileSize(§ pars capacity)))
            (§ block
                (§ ass (§ name cursor) (§ expr FILE_PROLOGUE_BYTES))
            )
            (§ expr buffer.position(§ pars cursor))
            (§ var #_"Sha256Hash" (§ name hash) (§ expr block.getHeader(§ pars ).getHash(§ pars )))
            (§ expr notFoundCache.remove(§ pars hash))
            (§ expr buffer.put(§ pars hash.getBytes(§ pars )))
            (§ expr block.serializeCompact(§ pars buffer))
            (§ expr setRingCursor(§ pars buffer, buffer.position(§ pars )))
            (§ expr blockCache.put(§ pars hash, block))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    #_override
    #_nilable
    #_public
    (§ method #_"StoredBlock" (§ fn get) [#_"Sha256Hash" (§ name hash)])
        (§ throws #_"BlockStoreException")
    (§ block
        #_final
        (§ var #_"MappedByteBuffer" (§ name buffer) (§ expr this.buffer))
        (§ if (§ expr buffer == nil))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars "Store closed")))
        )

        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"StoredBlock" (§ name cacheHit) (§ expr blockCache.get(§ pars hash)))
            (§ if (§ expr cacheHit != nil))
            (§ block
                (§ return cacheHit)
            )
            (§ if (§ expr notFoundCache.get(§ pars hash) != nil))
            (§ block
                (§ return nil)
            )

            ;; Starting from the current tip of the ring work backwards until we have either
            ;; found the block or wrapped around.
            (§ var #_"int" (§ name cursor) (§ expr getRingCursor(§ pars buffer)))
            #_final
            (§ var #_"int" (§ name startingPoint) cursor)
            #_final
            (§ var #_"int" (§ name fileSize) (§ expr getFileSize(§ pars capacity)))
            #_final
            (§ var #_"byte[]" (§ name targetHashBytes) (§ expr hash.getBytes(§ pars )))
            (§ var #_"byte[]" (§ name scratch) (§ new #_"byte[]" (§ count 32)))
            (§ do )
            (§ block
                (§ ass (§ name cursor) (§ expr cursor - RECORD_SIZE))
                ;; We hit the start, so wrap around.
                (§ if (§ expr cursor < FILE_PROLOGUE_BYTES))
                (§ block
                    (§ ass (§ name cursor) (§ expr fileSize - RECORD_SIZE))
                )
                ;; Cursor is now at the start of the next record to check, so read the hash and compare it.
                (§ expr buffer.position(§ pars cursor))
                (§ expr buffer.get(§ pars scratch))
                (§ if (§ expr Arrays/equals(§ pars scratch, targetHashBytes)))
                (§ block
                    ;; Found the target.
                    (§ var #_"StoredBlock" (§ name storedBlock) (§ expr StoredBlock/deserializeCompact(§ pars params, buffer)))
                    (§ expr blockCache.put(§ pars hash, storedBlock))
                    (§ return storedBlock)
                )
            )
            (§ again (§ expr cursor != startingPoint))

            ;; Not found.
            (§ expr notFoundCache.put(§ pars hash, NOT_FOUND_MARKER))
            (§ return nil)
        )
        (§ catch #_"ProtocolException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_protected
    (§ field #_"StoredBlock" (§ name lastChainHead))

    #_override
    #_public
    (§ method #_"StoredBlock" (§ fn getChainHead) [])
        (§ throws #_"BlockStoreException")
    (§ block
        #_final
        (§ var #_"MappedByteBuffer" (§ name buffer) (§ expr this.buffer))
        (§ if (§ expr buffer == nil))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars "Store closed")))
        )

        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr lastChainHead == nil))
            (§ block
                (§ var #_"byte[]" (§ name headHash) (§ new #_"byte[]" (§ count 32)))
                (§ expr buffer.position(§ pars 8))
                (§ expr buffer.get(§ pars headHash))
                (§ var #_"Sha256Hash" (§ name hash) (§ expr Sha256Hash/wrap(§ pars headHash)))
                (§ var #_"StoredBlock" (§ name block) (§ expr get(§ pars hash)))
                (§ if (§ expr block == nil))
                (§ block
                    (§ throw (§ new #_"BlockStoreException" (§ pars "Corrupted block store: could not find chain head: " + hash)))
                )

                (§ ass (§ name lastChainHead) block)
            )
            (§ return lastChainHead)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method #_"void" (§ fn setChainHead) [#_"StoredBlock" (§ name chainHead)])
        (§ throws #_"BlockStoreException")
    (§ block
        #_final
        (§ var #_"MappedByteBuffer" (§ name buffer) (§ expr this.buffer))
        (§ if (§ expr buffer == nil))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars "Store closed")))
        )

        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name lastChainHead) chainHead)
            (§ var #_"byte[]" (§ name headHash) (§ expr chainHead.getHeader(§ pars ).getHash(§ pars ).getBytes(§ pars )))
            (§ expr buffer.position(§ pars 8))
            (§ expr buffer.put(§ pars headHash))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn close) [])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ try )
        (§ block
            (§ expr buffer.force(§ pars ))
            (§ ass (§ name buffer) nil) ;; Allow it to be GCd and the underlying file mapping to go away.
            (§ expr randomAccessFile.close(§ pars ))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"BlockStoreException" (§ pars e)))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"NetworkParameters" (§ fn getParams) [])
    (§ block
        (§ return params)
    )

    #_protected
    #_static
    #_final
    (§ field #_"int" (§ name RECORD_SIZE) (§ expr 32 + StoredBlock/COMPACT_SERIALIZED_SIZE)) ;; hash

    ;; File format:
    ;;   4 header bytes = "SPVB"
    ;;   4 cursor bytes, which indicate the offset from the first kb where the next block header should be written
    ;;   32 bytes for the hash of the chain head
    ;;
    ;; For each header (128 bytes)
    ;;   32 bytes hash of the header
    ;;   12 bytes of chain work
    ;;    4 bytes of height
    ;;   80 bytes of block header data
    #_protected
    #_static
    #_final
    (§ field #_"int" (§ name FILE_PROLOGUE_BYTES) 1024)

    ;;; Returns the offset from the file start where the latest block should be written (end of prev block). ;;
    #_private
    (§ method #_"int" (§ fn getRingCursor) [#_"ByteBuffer" (§ name buffer)])
    (§ block
        (§ var #_"int" (§ name c) (§ expr buffer.getInt(§ pars 4)))
        (§ expr Preconditions/checkState(§ pars FILE_PROLOGUE_BYTES <= c, "Integer overflow"))
        (§ return c)
    )

    #_private
    (§ method #_"void" (§ fn setRingCursor) [#_"ByteBuffer" (§ name buffer), #_"int" (§ name newCursor)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars 0 <= newCursor))
        (§ expr buffer.putInt(§ pars 4, newCursor))
        (§ void nil)
    )
)

#_(ns org.bitcoinj.uri #_"BitcoinURI"
    (:import [java.io UnsupportedEncodingException]
             [java.net URI URISyntaxException URLDecoder]
             [java.util ArrayList Collections LinkedHashMap List Locale Map])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.core Address AddressFormatException Coin NetworkParameters]
             [org.bitcoinj.params AbstractBitcoinNetParams]))

;;;
 ; <p>Provides a standard implementation of a Bitcoin URI with support for the following:</p>
 ;
 ; <ul>
 ; <li>URLEncoded URIs (as passed in by IE on the command line)</li>
 ; <li>BIP21 names (including the "req-" prefix handling requirements)</li>
 ; </ul>
 ;
 ; <h2>Accepted formats</h2>
 ;
 ; <p>The following input forms are accepted:</p>
 ;
 ; <ul>
 ; <li>{@code bitcoin:<address>}</li>
 ; <li>{@code bitcoin:<address>?<name1>=<value1>&<name2>=<value2>} with multiple additional name/value pairs</li>
 ; </ul>
 ;
 ; <p>The name/value pairs are processed as follows.</p>
 ; <ol>
 ; <li>URL encoding is stripped and treated as UTF-8</li>
 ; <li>names prefixed with {@code req-} are treated as required and if unknown or conflicting cause a parse exception</li>
 ; <li>Unknown names not prefixed with {@code req-} are added to a Map, accessible by parameter name</li>
 ; <li>Known names not prefixed with {@code req-} are processed unless they are malformed</li>
 ; </ol>
 ;
 ; <p>The following names are known and have the following formats:</p>
 ; <ul>
 ; <li>{@code amount} decimal value to 8 dp (e.g. 0.12345678) <b>Note that the exponent notation is not supported any more.</b></li>
 ; <li>{@code label} any URL encoded alphanumeric</li>
 ; <li>{@code message} any URL encoded alphanumeric</li>
 ; </ul>
 ;
 ; @author Andreas Schildbach (initial code)
 ; @author Jim Burton (enhancements for MultiBit)
 ; @author Gary Rowe (BIP21 support)
 ; @see <a href="https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki">BIP 0021</a>
 ;;
#_public
(§ class #_"BitcoinURI"
    ;; Not worth turning into an enum.
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name FIELD_MESSAGE) (§ expr "message"))
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name FIELD_LABEL) (§ expr "label"))
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name FIELD_AMOUNT) (§ expr "amount"))
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name FIELD_ADDRESS) (§ expr "address"))
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name FIELD_PAYMENT_REQUEST_URL) (§ expr "r"))

    ;;;
     ; URI for Bitcoin network.  Use {@link org.bitcoinj.params.AbstractBitcoinNetParams#BITCOIN_SCHEME}
     ; if you specifically need Bitcoin, or use {@link org.bitcoinj.core.NetworkParameters#getUriScheme}
     ; to get the scheme from network parameters.
     ;;
    #_deprecated
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name BITCOIN_SCHEME) (§ expr "bitcoin"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name ENCODED_SPACE_CHARACTER) (§ expr "%20"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name AMPERSAND_SEPARATOR) (§ expr "&"))
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name QUESTION_MARK_SEPARATOR) (§ expr "?"))

    ;;;
     ; Contains all the parameters in the order in which they were processed.
     ;;
    #_private
    #_final
    (§ field #_"Map<String, Object>" (§ name parameterMap) (§ new #_"LinkedHashMap<>" (§ pars )))

    ;;;
     ; Constructs a new BitcoinURI from the given string.  Can be for any network.
     ;
     ; @param uri The raw URI data to be parsed (see class comments for accepted formats).
     ; @throws BitcoinURIParseException if the URI is not syntactically or semantically valid.
     ;;
    #_public
    (§ constructor #_"BitcoinURI" [#_"String" (§ name uri)])
        (§ throws #_"BitcoinURIParseException")
    (§ block
        (§ this (§ pars nil, uri))
        (§ void this)
    )

    ;;;
     ; Constructs a new object by trying to parse the input as a valid Bitcoin URI.
     ;
     ; @param params The network parameters that determine which network the URI is from, or null if you
     ;               don't have any expectation about what network the URI is for and wish to check yourself.
     ; @param input The raw URI data to be parsed (see class comments for accepted formats).
     ;
     ; @throws BitcoinURIParseException if the input fails Bitcoin URI syntax and semantic checks.
     ;;
    #_public
    (§ constructor #_"BitcoinURI" [#_nilable #_"NetworkParameters" (§ name params), #_"String" (§ name input)])
        (§ throws #_"BitcoinURIParseException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars input))

        (§ var #_"String" (§ name scheme) (§ quest (§ expr params != nil) ? (§ expr params.getUriScheme(§ pars )) :else (§ expr AbstractBitcoinNetParams/BITCOIN_SCHEME)))

        ;; Attempt to form the URI (fail fast syntax checking to official standards).
        (§ var #_"URI" (§ name uri))
        (§ try )
        (§ block
            (§ ass (§ name uri) (§ new #_"URI" (§ pars input)))
        )
        (§ catch #_"URISyntaxException" (§ name e))
        (§ block
            (§ throw (§ new #_"BitcoinURIParseException" (§ pars "Bad URI syntax", e)))
        )

        ;; URI is formed as  bitcoin:<address>?<query parameters>
        ;; blockchain.info generates URIs of non-BIP compliant form bitcoin://address?....
        ;; We support both until Ben fixes his code.

        ;; Remove the bitcoin scheme.
        ;; (Note: getSchemeSpecificPart() is not used as it unescapes the label and parse then fails.
        ;; For instance with  bitcoin:129mVqKUmJ9uwPxKJBnNdABbuaaNfho4Ha?amount=0.06&label=Tom%20%26%20Jerry
        ;; the & (%26) in Tom and Jerry gets interpreted as a separator and the label then gets parsed
        ;; as 'Tom ' instead of 'Tom & Jerry'.)
        (§ var #_"String" (§ name blockchainInfoScheme) (§ expr scheme + "://"))
        (§ var #_"String" (§ name correctScheme) (§ expr scheme + ":"))
        (§ var #_"String" (§ name schemeSpecificPart))
        (§ if (§ expr input.startsWith(§ pars blockchainInfoScheme)))
        (§ block
            (§ ass (§ name schemeSpecificPart) (§ expr input.substring(§ pars blockchainInfoScheme.length(§ pars ))))
        )
        (§ elseif (§ expr input.startsWith(§ pars correctScheme)))
        (§ block
            (§ ass (§ name schemeSpecificPart) (§ expr input.substring(§ pars correctScheme.length(§ pars ))))
        )
        (§ else )
        (§ block
            (§ throw (§ new #_"BitcoinURIParseException" (§ pars "Unsupported URI scheme: " + uri.getScheme(§ pars ))))
        )

        ;; Split off the address from the rest of the query parameters.
        (§ var #_"String[]" (§ name addressSplitTokens) (§ expr schemeSpecificPart.split(§ pars "\\?", 2)))
        (§ if (§ expr addressSplitTokens.length == 0))
        (§ block
            (§ throw (§ new #_"BitcoinURIParseException" (§ pars "No data found after the bitcoin: prefix")))
        )

        (§ var #_"String" (§ name addressToken) (§ expr addressSplitTokens[0])) ;; may be empty!

        (§ var #_"String[]" (§ name nameValuePairTokens))
        (§ if (§ expr addressSplitTokens.length == 1))
        (§ block
            ;; Only an address is specified - use an empty '<name>=<value>' token array.
            (§ ass (§ name nameValuePairTokens) (§ new #_"String[]" (§ coll )))
        )
        (§ else )
        (§ block
            ;; Split into '<name>=<value>' tokens.
            (§ ass (§ name nameValuePairTokens) (§ expr addressSplitTokens[1].split(§ pars "&")))
        )

        ;; Attempt to parse the rest of the URI parameters.
        (§ expr parseParameters(§ pars params, addressToken, nameValuePairTokens))

        (§ if (§ expr (§ not addressToken.isEmpty(§ pars ))))
        (§ block
            ;; Attempt to parse the addressToken as a Bitcoin address for this network.
            (§ try )
            (§ block
                (§ var #_"Address" (§ name address) (§ expr Address/fromBase58(§ pars params, addressToken)))
                (§ expr putWithValidation(§ pars FIELD_ADDRESS, address))
            )
            (§ catch [#_final #_"AddressFormatException" (§ name e)])
            (§ block
                (§ throw (§ new #_"BitcoinURIParseException" (§ pars "Bad address", e)))
            )
        )

        (§ if (§ expr addressToken.isEmpty(§ pars ) && getPaymentRequestUrl(§ pars ) == nil))
        (§ block
            (§ throw (§ new #_"BitcoinURIParseException" (§ pars "No address and no r= parameter found")))
        )
        (§ void this)
    )

    ;;;
     ; @param params The network parameters or null.
     ; @param nameValuePairTokens The tokens representing the name value pairs (assumed to be separated by '=' e.g. 'amount=0.2').
     ;;
    #_private
    (§ method #_"void" (§ fn parseParameters) [#_nilable #_"NetworkParameters" (§ name params), #_"String" (§ name addressToken), #_"String[]" (§ name nameValuePairTokens)])
        (§ throws #_"BitcoinURIParseException")
    (§ block
        ;; Attempt to decode the rest of the tokens into a parameter map.
        (§ for (§ var #_"String" (§ name nameValuePairToken)) :for nameValuePairTokens)
        (§ block
            #_final
            (§ var #_"int" (§ name sepIndex) (§ expr nameValuePairToken.indexOf(§ pars "=")))
            (§ if (§ expr sepIndex == -1))
            (§ block
                (§ throw (§ new #_"BitcoinURIParseException" (§ pars "Malformed Bitcoin URI - no separator in '" + nameValuePairToken + "'")))
            )
            (§ if (§ expr sepIndex == 0))
            (§ block
                (§ throw (§ new #_"BitcoinURIParseException" (§ pars "Malformed Bitcoin URI - empty name '" + nameValuePairToken + "'")))
            )

            #_final
            (§ var #_"String" (§ name nameToken) (§ expr nameValuePairToken.substring(§ pars 0, sepIndex).toLowerCase(§ pars Locale/ENGLISH)))
            #_final
            (§ var #_"String" (§ name valueToken) (§ expr nameValuePairToken.substring(§ pars sepIndex + 1)))

            ;; Parse the amount.
            (§ if (§ expr FIELD_AMOUNT.equals(§ pars nameToken)))
            (§ block
                ;; Decode the amount (contains an optional decimal component to 8dp).
                (§ try )
                (§ block
                    (§ var #_"Coin" (§ name amount) (§ expr Coin/parseCoin(§ pars valueToken)))
                    (§ if (§ expr params != nil && amount.isGreaterThan(§ pars params.getMaxMoney(§ pars ))))
                    (§ block
                        (§ throw (§ new #_"BitcoinURIParseException" (§ pars "Max number of coins exceeded")))
                    )
                    (§ if (§ expr amount.signum(§ pars ) < 0))
                    (§ block
                        (§ throw (§ new #_"ArithmeticException" (§ pars "Negative coins specified")))
                    )

                    (§ expr putWithValidation(§ pars FIELD_AMOUNT, amount))
                )
                (§ catch #_"IllegalArgumentException" (§ name e))
                (§ block
                    (§ throw (§ new #_"OptionalFieldValidationException" (§ pars String/format(§ pars Locale/US, "'%s' is not a valid amount", valueToken), e)))
                )
                (§ catch #_"ArithmeticException" (§ name e))
                (§ block
                    (§ throw (§ new #_"OptionalFieldValidationException" (§ pars String/format(§ pars Locale/US, "'%s' has too many decimal places", valueToken), e)))
                )
            )
            (§ else )
            (§ block
                (§ if (§ expr nameToken.startsWith(§ pars "req-")))
                (§ block
                    ;; A required parameter that we do not know about.
                    (§ throw (§ new #_"RequiredFieldValidationException" (§ pars "'" + nameToken + "' is required but not known, this URI is not valid")))
                )

                ;; Known fields and unknown parameters that are optional.
                (§ try )
                (§ block
                    (§ if (§ expr 0 < valueToken.length(§ pars )))
                    (§ block
                        (§ expr putWithValidation(§ pars nameToken, URLDecoder/decode(§ pars valueToken, "UTF-8")))
                    )
                )
                (§ catch #_"UnsupportedEncodingException" (§ name e))
                (§ block
                    (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Can't happen.
                )
            )
        )

        ;; Note to the future:
        ;; when you want to implement 'req-expires', have a look at commit 410a53791841 which had it in.
        (§ void nil)
    )

    ;;;
     ; Put the value against the key in the map checking for duplication.  This avoids address field overwrite etc.
     ;
     ; @param key The key for the map.
     ; @param value The value to store.
     ;;
    #_private
    (§ method #_"void" (§ fn putWithValidation) [#_"String" (§ name key), #_"Object" (§ name value)])
        (§ throws #_"BitcoinURIParseException")
    (§ block
        (§ if (§ expr parameterMap.containsKey(§ pars key)))
        (§ block
            (§ throw (§ new #_"BitcoinURIParseException" (§ pars String/format(§ pars Locale/US, "'%s' is duplicated, URI is invalid", key))))
        )

        (§ expr parameterMap.put(§ pars key, value))
        (§ void nil)
    )

    ;;;
     ; The Bitcoin Address from the URI, if one was present.  It's possible to have Bitcoin URI's with no address
     ; if a r= payment protocol parameter is specified, though this form is not recommended as older wallets
     ; can't understand it.
     ;;
    #_nilable
    #_public
    (§ method #_"Address" (§ fn getAddress) [])
    (§ block
        (§ return (§ cast #_"Address" (§ expr parameterMap.get(§ pars FIELD_ADDRESS))))
    )

    ;;;
     ; @return The amount name encoded using a pure integer value based at 10,000,000 units is 1 BTC.
     ;         May be null if no amount is specified.
     ;;
    #_public
    (§ method #_"Coin" (§ fn getAmount) [])
    (§ block
        (§ return (§ cast #_"Coin" (§ expr parameterMap.get(§ pars FIELD_AMOUNT))))
    )

    ;;;
     ; @return the label from the URI.
     ;;
    #_public
    (§ method #_"String" (§ fn getLabel) [])
    (§ block
        (§ return (§ cast #_"String" (§ expr parameterMap.get(§ pars FIELD_LABEL))))
    )

    ;;;
     ; @return the message from the URI.
     ;;
    #_public
    (§ method #_"String" (§ fn getMessage) [])
    (§ block
        (§ return (§ cast #_"String" (§ expr parameterMap.get(§ pars FIELD_MESSAGE))))
    )

    ;;;
     ; @return the URL where a payment request (as specified in BIP 70) may be fetched.
     ;;
    #_public
    #_final
    (§ method #_"String" (§ fn getPaymentRequestUrl) [])
    (§ block
        (§ return (§ cast #_"String" (§ expr parameterMap.get(§ pars FIELD_PAYMENT_REQUEST_URL))))
    )

    ;;;
     ; Returns the URLs where a payment request (as specified in BIP 70) may be fetched.
     ; The first URL is the main URL, all subsequent URLs are fallbacks.
     ;;
    #_public
    (§ method #_"List<String>" (§ fn getPaymentRequestUrls) [])
    (§ block
        (§ var #_"ArrayList<String>" (§ name urls) (§ new #_"ArrayList<>" (§ pars )))
        (§ while true)
        (§ block
            (§ var #_"int" (§ name i) (§ expr urls.size(§ pars )))
            (§ var #_"String" (§ name paramName) (§ str FIELD_PAYMENT_REQUEST_URL + (§ quest (§ expr 0 < i) ? (§ expr Integer/toString(§ pars i)) :else (§ expr ""))))
            (§ var #_"String" (§ name url) (§ expr (§ cast #_"String" (§ expr parameterMap.get(§ pars paramName)))))
            (§ if (§ expr url == nil))
            (§ block
                (§ break )
            )
            (§ expr urls.add(§ pars url))
        )
        (§ expr Collections/reverse(§ pars urls))
        (§ return urls)
    )

    ;;;
     ; @param name The name of the parameter.
     ; @return the parameter value, or null if not present.
     ;;
    #_public
    (§ method #_"Object" (§ fn getParameterByName) [#_"String" (§ name name)])
    (§ block
        (§ return (§ expr parameterMap.get(§ pars name)))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ var #_"StringBuilder" (§ name sb) (§ new #_"StringBuilder" (§ pars "BitcoinURI[")))
        (§ var #_"boolean" (§ name first) true)
        (§ for (§ var #_"Map.Entry<String, Object>" (§ name entry)) :for (§ expr parameterMap.entrySet(§ pars )))
        (§ block
            (§ if first)
            (§ block
                (§ ass (§ name first) false)
            )
            (§ else )
            (§ block
                (§ expr sb.append(§ pars ","))
            )
            (§ expr sb.append(§ pars "'").append(§ pars entry.getKey(§ pars )).append(§ pars "'='").append(§ pars entry.getValue(§ pars )).append(§ pars "'"))
        )
        (§ expr sb.append(§ pars "]"))
        (§ return (§ expr sb.toString(§ pars )))
    )

    ;;;
     ; Simple Bitcoin URI builder using known good fields.
     ;
     ; @param address The Bitcoin address.
     ; @param amount The amount.
     ; @param label A label.
     ; @param message A message.
     ; @return a String containing the Bitcoin URI.
     ;;
    #_public
    #_static
    (§ method #_"String" (§ fn convertToBitcoinURI) [#_"Address" (§ name address), #_"Coin" (§ name amount), #_"String" (§ name label), #_"String" (§ name message)])
    (§ block
        (§ return (§ expr convertToBitcoinURI(§ pars address.getParameters(§ pars ), address.toString(§ pars ), amount, label, message)))
    )

    ;;;
     ; Simple Bitcoin URI builder using known good fields.
     ;
     ; @param params The network parameters that determine which network the URI is for.
     ; @param address The Bitcoin address.
     ; @param amount The amount.
     ; @param label A label.
     ; @param message A message.
     ; @return a String containing the Bitcoin URI.
     ;;
    #_public
    #_static
    (§ method #_"String" (§ fn convertToBitcoinURI) [#_"NetworkParameters" (§ name params), #_"String" (§ name address), #_nilable #_"Coin" (§ name amount), #_nilable #_"String" (§ name label), #_nilable #_"String" (§ name message)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars params))
        (§ expr Preconditions/checkNotNull(§ pars address))

        (§ if (§ expr amount != nil && amount.signum(§ pars ) < 0))
        (§ block
            (§ throw (§ new #_"IllegalArgumentException" (§ pars "Coin must be positive")))
        )

        (§ var #_"StringBuilder" (§ name sb) (§ new #_"StringBuilder" (§ pars )))
        (§ var #_"String" (§ name scheme) (§ expr params.getUriScheme(§ pars )))
        (§ expr sb.append(§ pars scheme).append(§ pars ":").append(§ pars address))

        (§ var #_"boolean" (§ name questionMarkHasBeenOutput) false)

        (§ if (§ expr amount != nil))
        (§ block
            (§ expr sb.append(§ pars QUESTION_MARK_SEPARATOR).append(§ pars FIELD_AMOUNT).append(§ pars "="))
            (§ expr sb.append(§ pars amount.toPlainString(§ pars )))
            (§ ass (§ name questionMarkHasBeenOutput) true)
        )

        (§ if (§ expr label != nil && (§ not "".equals(§ pars label))))
        (§ block
            (§ if questionMarkHasBeenOutput)
            (§ block
                (§ expr sb.append(§ pars AMPERSAND_SEPARATOR))
            )
            (§ else )
            (§ block
                (§ expr sb.append(§ pars QUESTION_MARK_SEPARATOR))
                (§ ass (§ name questionMarkHasBeenOutput) true)
            )
            (§ expr sb.append(§ pars FIELD_LABEL).append(§ pars "=").append(§ pars encodeURLString(§ pars label)))
        )

        (§ if (§ expr message != nil && (§ not "".equals(§ pars message))))
        (§ block
            (§ if questionMarkHasBeenOutput)
            (§ block
                (§ expr sb.append(§ pars AMPERSAND_SEPARATOR))
            )
            (§ else )
            (§ block
                (§ expr sb.append(§ pars QUESTION_MARK_SEPARATOR))
            )
            (§ expr sb.append(§ pars FIELD_MESSAGE).append(§ pars "=").append(§ pars encodeURLString(§ pars message)))
        )

        (§ return (§ expr sb.toString(§ pars )))
    )

    ;;;
     ; Encode a string using URL encoding.
     ;
     ; @param stringToEncode The string to URL encode.
     ;;
    #_static
    (§ method #_"String" (§ fn encodeURLString) [#_"String" (§ name stringToEncode)])
    (§ block
        (§ try )
        (§ block
            (§ return (§ expr java.net.URLEncoder.encode(§ pars stringToEncode, "UTF-8").replace(§ pars "+", ENCODED_SPACE_CHARACTER)))
        )
        (§ catch #_"UnsupportedEncodingException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Can't happen.
        )
    )
)

#_(ns org.bitcoinj.uri #_"BitcoinURIParseException")

;;;
 ; <p>Exception to provide the following to {@link BitcoinURI}:</p>
 ; <ul>
 ; <li>Provision of parsing error messages.</li>
 ; </ul>
 ; <p>This base exception acts as a general failure mode not attributable to a specific cause (other than
 ; that reported in the exception message).  Since this is in English, it may not be worth reporting directly
 ; to the user other than as part of a "general failure to parse" response.</p>
 ;;
#_public
(§ class #_"BitcoinURIParseException" (§ extends #_"Exception")
    #_public
    (§ constructor #_"BitcoinURIParseException" [#_"String" (§ name s)])
    (§ block
        (§ super (§ pars s))
        (§ void this)
    )

    #_public
    (§ constructor #_"BitcoinURIParseException" [#_"String" (§ name s), #_"Throwable" (§ name throwable)])
    (§ block
        (§ super (§ pars s, throwable))
        (§ void this)
    )
)

#_(ns org.bitcoinj.uri #_"OptionalFieldValidationException")

;;;
 ; <p>Exception to provide the following to {@link org.bitcoinj.uri.BitcoinURI}:</p>
 ; <ul>
 ; <li>Provision of parsing error messages.</li>
 ; </ul>
 ; <p>This exception occurs when an optional field is detected (under the Bitcoin URI scheme) and fails
 ; to pass the associated test (such as {@code amount} not being a valid number).</p>
 ;
 ; @since 0.3.0
 ;
 ;;
#_public
(§ class #_"OptionalFieldValidationException" (§ extends #_"BitcoinURIParseException")
    #_public
    (§ constructor #_"OptionalFieldValidationException" [#_"String" (§ name s)])
    (§ block
        (§ super (§ pars s))
        (§ void this)
    )

    #_public
    (§ constructor #_"OptionalFieldValidationException" [#_"String" (§ name s), #_"Throwable" (§ name throwable)])
    (§ block
        (§ super (§ pars s, throwable))
        (§ void this)
    )
)

#_(ns org.bitcoinj.uri #_"RequiredFieldValidationException")

;;;
 ; <p>Exception to provide the following to {@link BitcoinURI}:</p>
 ; <ul>
 ; <li>Provision of parsing error messages.</li>
 ; </ul>
 ; <p>This exception occurs when a required field is detected (under the BIP21 rules) and fails
 ; to pass the associated test (such as {@code req-expires} being out of date), or the required field is unknown
 ; to this version of the client in which case it should fail for security reasons.</p>
 ;
 ; @since 0.3.0
 ;
 ;;
#_public
(§ class #_"RequiredFieldValidationException" (§ extends #_"BitcoinURIParseException")
    #_public
    (§ constructor #_"RequiredFieldValidationException" [#_"String" (§ name s)])
    (§ block
        (§ super (§ pars s))
        (§ void this)
    )

    #_public
    (§ constructor #_"RequiredFieldValidationException" [#_"String" (§ name s), #_"Throwable" (§ name throwable)])
    (§ block
        (§ super (§ pars s, throwable))
        (§ void this)
    )
)

#_(ns org.bitcoinj.utils #_"BtcAutoFormat"
    (:import [java.math BigDecimal]
             #_static [java.math.BigDecimal ONE]
             #_static [java.math.BigDecimal ZERO]
             [java.math BigInteger]
             #_static [java.math.RoundingMode HALF_UP]
             [java.text DecimalFormat DecimalFormatSymbols NumberFormat]
             [java.util Locale])
    (:import [com.google.common.collect ImmutableList])
    (:import #_static [org.bitcoinj.core.Coin SMALLEST_UNIT_EXPONENT]))

;;;
 ; <p>This class, a concrete extension of {@link BtcFormat}, is distinguished by its
 ; accommodation of multiple denominational units as follows:
 ;
 ; <p>When formatting Bitcoin monetary values, an instance of this class automatically adjusts
 ; the denominational units in which it represents a given value so as to minimize the number
 ; of consecutive zeros in the number that is displayed, and includes either a currency code or
 ; symbol in the formatted value to indicate which denomination was chosen.
 ;
 ; <p>When parsing <code>String</code> representations of Bitcoin monetary values, instances of
 ; this class automatically recognize units indicators consisting of currency codes and
 ; symbols, including including those containing currency or metric prefixes such as
 ; <code>"¢"</code> or <code>"c"</code> to indicate hundredths, and interpret each number being
 ; parsed in accordance with the recognized denominational units.
 ;
 ; <p>A more detailed explanation, including examples, is in the documentation for the {@link
 ; BtcFormat} class, and further information beyond that is in the documentation for the {@link
 ; java.text.Format} class, from which this class descends.
 ;
 ; @see java.text.Format
 ; @see java.text.NumberFormat
 ; @see java.text.DecimalFormat
 ; @see DecimalFormatSymbols
 ; @see org.bitcoinj.core.Coin
 ;;

#_public
#_final
(§ class #_"BtcAutoFormat" (§ extends #_"BtcFormat")
    ;;;
     ; Enum for specifying the style of currency indicators thas are used
     ; when formatting, ether codes or symbols.
     ;;
    #_public
    (§ enum #_"Style"
        ;; Notes:
         ; 1) The odd-looking character in the replacements below, named "currency sign," is used
         ;    in the patterns recognized by Java's number formatter.  A single occurrence of this
         ;    character specifies a currency symbol, while two adjacent occurrences indicate an
         ;    international currency code.
         ; 2) The positive and negative patterns each have three parts: prefix, number, suffix.
         ;    The number characters are limited to digits, zero, decimal-separator, group-separator,
         ;    and scientific-notation specifier: [#0.,E]
         ;    All number characters besides 'E' must be single-quoted in order to appear as
         ;    literals in either the prefix or suffix.
         ; These patterns are explained in the documentation for java.text.DecimalFormat.
         ;;

        ;;; Constant for the formatting style that uses a currency code, e.g. "BTC". ;;
        (§ item CODE
        (§ anon
            #_override
            (§ method #_"void" (§ fn apply) [#_"DecimalFormat" (§ name decimalFormat)])
            (§ block
                ;; To switch to using codes from symbols, we replace each single occurrence of the
                 ; currency-sign character with two such characters in a row.
                 ; We also insert a space character between every occurence of this character and an
                 ; adjacent numerical digit or negative sign (that is, between the currency-sign and
                 ; the signed-number).
                 ;;
                (§ expr decimalFormat.applyPattern(§ pars negify(§ pars decimalFormat.toPattern(§ pars )).replaceAll(§ pars "¤", "¤¤").replaceAll(§ pars "([#0.,E-])¤¤", "$1 ¤¤").replaceAll(§ pars "¤¤([0#.,E-])", "¤¤ $1")))
                (§ void nil)
            )
        ))

        ;;; Constant for the formatting style that uses a currency symbol, e.g. "฿". ;;
        (§ item SYMBOL
        (§ anon
            #_override
            (§ method #_"void" (§ fn apply) [#_"DecimalFormat" (§ name decimalFormat)])
            (§ block
                ;; To make certain we are using symbols rather than codes, we replace
                 ; each double occurrence of the currency sign character with a single.
                 ;;
                (§ expr decimalFormat.applyPattern(§ pars negify(§ pars decimalFormat.toPattern(§ pars )).replaceAll(§ pars "¤¤", "¤")))
                (§ void nil)
            )
        ))

        ;;; Effect a style corresponding to an enum value on the given number formatter object. ;;
        #_abstract
        (§ method #_"void" (§ fn apply) [#_"DecimalFormat" (§ name decimalFormat)])
    )

    ;;; Constructor. ;;
    #_protected
    (§ constructor #_"BtcAutoFormat" [#_"Locale" (§ name locale), #_"Style" (§ name style), #_"int" (§ name fractionPlaces)])
    (§ block
        (§ super (§ pars (§ cast #_"DecimalFormat" (§ expr NumberFormat/getCurrencyInstance(§ pars locale))), fractionPlaces, ImmutableList.<Integer>of(§ pars )))

        (§ expr style.apply(§ pars this.numberFormat))
        (§ void this)
    )

    ;;;
     ; Calculate the appropriate denomination for the given Bitcoin monetary value.
     ; This method takes a BigInteger representing a quantity of satoshis, and returns the
     ; number of places that value's decimal point is to be moved when formatting said value
     ; in order that the resulting number represents the correct quantity of denominational
     ; units.
     ;
     ; <p>As a side-effect, this sets the units indicators of the underlying NumberFormat object.
     ; Only invoke this from a synchronized method, and be sure to put the DecimalFormatSymbols
     ; back to its proper state, otherwise immutability, equals() and hashCode() fail.
     ;;
    #_override
    #_protected
    (§ method #_"int" (§ fn scale) [#_"BigInteger" (§ name satoshis), #_"int" (§ name fractionPlaces)])
    (§ block
        ;; The algorithm is as follows.  TODO: is there a way to optimize step 4?
         ; 1. Can we use coin denomination w/ no rounding?  If yes, do it.
         ; 2. Else, can we use millicoin denomination w/ no rounding?  If yes, do it.
         ; 3. Else, can we use micro denomination w/ no rounding?  If yes, do it.
         ; 4. Otherwise we must round:
         ;   (a) round to nearest coin + decimals
         ;   (b) round to nearest millicoin + decimals
         ;   (c) round to nearest microcoin + decimals
         ;   Subtract each of (a), (b) and (c) from the true value, and choose the
         ;   denomination that gives smallest absolute difference.  It case of tie,
         ;   use the smaller denomination.
         ;;
        (§ var #_"int" (§ name places))
        (§ var #_"int" (§ name coinOffset) (§ expr Math/max(§ pars SMALLEST_UNIT_EXPONENT - fractionPlaces, 0)))
        (§ var #_"BigDecimal" (§ name inCoins) (§ expr (§ new #_"BigDecimal" (§ pars satoshis)).movePointLeft(§ pars coinOffset)))
        (§ if (§ expr inCoins.remainder(§ pars ONE).compareTo(§ pars ZERO) == 0))
        (§ block
            (§ ass (§ name places) (§ expr COIN_SCALE))
        )
        (§ else )
        (§ block
            (§ var #_"BigDecimal" (§ name inMillis) (§ expr inCoins.movePointRight(§ pars MILLICOIN_SCALE)))
            (§ if (§ expr inMillis.remainder(§ pars ONE).compareTo(§ pars ZERO) == 0))
            (§ block
                (§ ass (§ name places) (§ expr MILLICOIN_SCALE))
            )
            (§ else )
            (§ block
                (§ var #_"BigDecimal" (§ name inMicros) (§ expr inCoins.movePointRight(§ pars MICROCOIN_SCALE)))
                (§ if (§ expr inMicros.remainder(§ pars ONE).compareTo(§ pars ZERO) == 0))
                (§ block
                    (§ ass (§ name places) (§ expr MICROCOIN_SCALE))
                )
                (§ else )
                (§ block
                    ;; No way to avoid rounding: so what denomination gives smallest error?
                    (§ var #_"BigDecimal" (§ name a) (§ expr inCoins.subtract(§ pars inCoins.setScale(§ pars 0, HALF_UP)).movePointRight(§ pars coinOffset).abs(§ pars )))
                    (§ var #_"BigDecimal" (§ name b) (§ expr inMillis.subtract(§ pars inMillis.setScale(§ pars 0, HALF_UP)).movePointRight(§ pars coinOffset - MILLICOIN_SCALE).abs(§ pars )))
                    (§ var #_"BigDecimal" (§ name c) (§ expr inMicros.subtract(§ pars inMicros.setScale(§ pars 0, HALF_UP)).movePointRight(§ pars coinOffset - MICROCOIN_SCALE).abs(§ pars )))
                    (§ if (§ expr a.compareTo(§ pars b) < 0))
                    (§ block
                        (§ ass (§ name places) (§ quest (§ expr a.compareTo(§ pars c) < 0) ? (§ expr COIN_SCALE) :else (§ expr MICROCOIN_SCALE)))
                    )
                    (§ elseif (§ expr b.compareTo(§ pars c) < 0))
                    (§ block
                        (§ ass (§ name places) (§ expr MILLICOIN_SCALE))
                    )
                    (§ else )
                    (§ block
                        (§ ass (§ name places) (§ expr MICROCOIN_SCALE))
                    )
                )
            )
        )
        (§ expr prefixUnitsIndicator(§ pars numberFormat, places))
        (§ return places)
    )

    ;;;
     ; Returns the <code>int</code> value indicating coin denomination.  This is what causes
     ; the number in a parsed value that lacks a units indicator to be interpreted as a quantity
     ; of bitcoins.
     ;;
    #_override
    #_protected
    (§ method #_"int" (§ fn scale) [])
    (§ block
        (§ return (§ expr COIN_SCALE))
    )

    ;;;
     ; Return the number of decimal places in the fraction part of numbers formatted by this
     ; instance.  This is the maximum number of fraction places that will be displayed;
     ; the actual number used is limited to a precision of satoshis.
     ;;
    #_public
    (§ method #_"int" (§ fn fractionPlaces) [])
    (§ block
        (§ return minimumFractionDigits)
    )

    ;;;
     ; Return true if the other instance is equivalent to this one.
     ; Formatters for different locales will never be equal, even if they behave identically.
     ;;
    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr (§ not (§ insta o #_"BtcAutoFormat"))))
        (§ block
            (§ return false)
        )
        (§ return (§ expr super.equals(§ pars o)))
    )

    ;;;
     ; Return a brief description of this formatter.  The exact details of the representation
     ; are unspecified and subject to change, but will include some representation of the
     ; pattern and the number of fractional decimal places.
     ;;
    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr "Auto-format " + pattern(§ pars )))
    )
)

#_(ns org.bitcoinj.utils #_"BtcFixedFormat"
    (:import [java.math BigInteger]
             [java.text DecimalFormat NumberFormat]
             [java.util Locale List])
    (:import [com.google.common.base Objects Preconditions])
    (:import #_static [org.bitcoinj.core.Coin SMALLEST_UNIT_EXPONENT]))

;;;
 ; This class, a concrete extension of {@link BtcFormat}, is distinguished in that each
 ; instance formats and by-default parses all Bitcoin monetary values in units of a single
 ; denomination that is specified at the time that instance is constructed.
 ;
 ; By default, neither currency codes nor symbols are included in formatted values as
 ; output, nor recognized in parsed values as input.  The can be overridden by applying a
 ; custom pattern using either the {@link BtcFormat.Builder#localizedPattern}
 ; or {@link BtcFormat.Builder#localizedPattern} methods, as described in the documentation
 ; for the {@link BtcFormat.Builder} class.
 ;
 ; A more detailed explanation, including examples, is in the documentation for the
 ; {@link BtcFormat} class, and further information beyond that is in the documentation
 ; for the {@link java.text.Format} class, from which this class descends.
 ;
 ; @see java.text.Format
 ; @see java.text.NumberFormat
 ; @see java.text.DecimalFormat
 ; @see org.bitcoinj.core.Coin
 ;;

#_public
#_final
(§ class #_"BtcFixedFormat" (§ extends #_"BtcFormat")
    ;;;
     ; A constant specifying the use of as many optional decimal places in the fraction part
     ; of a formatted number as are useful for expressing precision.  This value can be passed
     ; as the final argument to a factory method or {@link #format(Object, int, int...)}.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"int[]" (§ name REPEATING_PLACES) (§ coll 1,1,1,1,1,1,1,1,1,1,1,1,1,1 ))

    ;;;
     ; A constant specifying the use of as many optional groups of <strong>two</strong>
     ; decimal places in the fraction part of a formatted number as are useful for expressing
     ; precision.  This value can be passed as the final argument to a factory method or
     ; {@link #format(Object, int, int...)}.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"int[]" (§ name REPEATING_DOUBLETS) (§ coll 2,2,2,2,2,2,2 ))

    ;;;
     ; A constant specifying the use of as many optional groups of <strong>three</strong>
     ; decimal places in the fraction part of a formatted number as are useful for expressing
     ; precision.  This value can be passed as the final argument to a factory method or
     ; {@link #format(Object, int, int...)}.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"int[]" (§ name REPEATING_TRIPLETS) (§ coll 3,3,3,3,3 ))

    ;;;
     ; The number of places the decimal point of formatted values is shifted rightward from
     ; thet same value expressed in bitcoins.
     ;;
    #_private
    #_final
    (§ field #_"int" (§ name scale))

    ;;; Constructor. ;;
    #_protected
    (§ constructor #_"BtcFixedFormat" [#_"Locale" (§ name locale), #_"int" (§ name scale), #_"int" (§ name minDecimals), #_"List<Integer>" (§ name groups)])
    (§ block
        (§ super (§ pars (§ cast #_"DecimalFormat" (§ expr NumberFormat/getInstance(§ pars locale))), minDecimals, groups))

        (§ expr Preconditions/checkArgument(§ pars scale <= SMALLEST_UNIT_EXPONENT, "decimal cannot be shifted " + String/valueOf(§ pars scale) + " places"))

        (§ ass (§ name this.scale) scale)
        (§ void this)
    )

    ;;;
     ; Return the decimal-place shift for this object's unit-denomination.  For example, if
     ; the denomination is millibitcoins, this method will return the value <code>3</code>.
     ; As a side-effect, prefixes the currency signs of the underlying NumberFormat object.
     ; This method is invoked by the superclass when formatting.  The arguments are ignored
     ; because the denomination is fixed regardless of the value being formatted.
     ;;
    #_override
    #_protected
    (§ method #_"int" (§ fn scale) [#_"BigInteger" (§ name satoshis), #_"int" (§ name fractionPlaces)])
    (§ block
        (§ expr prefixUnitsIndicator(§ pars numberFormat, scale))
        (§ return scale)
    )

    ;;;
     ; Return the decimal-place shift for this object's fixed unit-denomination.  For example,
     ; if the denomination is millibitcoins, this method will return the value <code>3</code>.
     ;;
    #_override
    #_public
    (§ method #_"int" (§ fn scale) [])
    (§ block
        (§ return scale)
    )

    ;;;
     ; Return the currency code that identifies the units in which values formatted and
     ; (by-default) parsed by this instance are denominated.  For example, if the formatter's
     ; denomination is millibitcoins, then this method will return <code>"mBTC"</code>,
     ; assuming the default base currency-code is not overridden using a {@link BtcFormat.Builder}.
     ;;
    #_public
    (§ method #_"String" (§ fn code) [])
    (§ block
        (§ return (§ expr prefixCode(§ pars coinCode(§ pars ), scale)))
    )

    ;;;
     ; Return the currency symbol that identifies the units in which values formatted by this
     ; instance are denominated.  For example, when invoked on an instance denominated in
     ; millibitcoins, this method by default returns <code>"₥฿"</code>, depending on the
     ; locale.
     ;;
    #_public
    (§ method #_"String" (§ fn symbol) [])
    (§ block
        (§ return (§ expr prefixSymbol(§ pars coinSymbol(§ pars ), scale)))
    )

    ;;;
     ; Return the fractional decimal-placing used when formatting.  This method returns an
     ; <code>int</code> array.  The value of the first element is the minimum number of
     ; decimal places to be used in all cases, limited to a precision of satoshis.  The value
     ; of each successive element is the size of an optional place-group that will be applied,
     ; possibly partially, if useful for expressing precision.  The actual size of each group
     ; is limited to, and may be reduced to the limit of, a precision of no smaller than
     ; satoshis.
     ;;
    #_public
    (§ method #_"int[]" (§ fn fractionPlaceGroups) [])
    (§ block
        (§ var #_"Object[]" (§ name boxedArray) (§ expr decimalGroups.toArray(§ pars )))
        (§ var #_"int" (§ name len) (§ expr boxedArray.length + 1))
        (§ var #_"int[]" (§ name array) (§ new #_"int[]" (§ count len)))
        (§ ass (§ name array[0]) minimumFractionDigits)
        (§ for (§ var #_"int" (§ name i) 1) :for (§ expr i < len) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ ass (§ name array[i]) (§ cast #_"Integer" boxedArray[i - 1]))
        )
        (§ return array)
    )

    ;;;
     ; Return true if the given object is equivalent to this one.  Formatters for different
     ; locales will never be equal, even if they behave identically.
     ;;
    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr o == this))
        (§ block
            (§ return true)
        )
        (§ if (§ expr (§ not (§ insta o #_"BtcFixedFormat"))))
        (§ block
            (§ return false)
        )
        (§ var #_"BtcFixedFormat" (§ name other) (§ expr (§ cast #_"BtcFixedFormat" o)))
        (§ return (§ expr super.equals(§ pars other) && other.scale(§ pars ) == scale(§ pars ) && other.decimalGroups.equals(§ pars decimalGroups)))
    )

    ;;; Return a hash code value for this instance.
     ;  @see java.lang.Object#hashCode
     ;;
    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars super.hashCode(§ pars ), scale)))
    )

    #_private
    #_static
    (§ method #_"String" (§ fn prefixLabel) [#_"int" (§ name scale)])
    (§ block
        (§ switch scale)
        (§ block
            (§ case COIN_SCALE)
            (§ block
                (§ return (§ expr "Coin-"))
            )
            (§ case 1)
            (§ block
                (§ return (§ expr "Decicoin-"))
            )
            (§ case 2)
            (§ block
                (§ return (§ expr "Centicoin-"))
            )
            (§ case MILLICOIN_SCALE)
            (§ block
                (§ return (§ expr "Millicoin-"))
            )
            (§ case MICROCOIN_SCALE)
            (§ block
                (§ return (§ expr "Microcoin-"))
            )
            (§ case -1)
            (§ block
                (§ return (§ expr "Dekacoin-"))
            )
            (§ case -2)
            (§ block
                (§ return (§ expr "Hectocoin-"))
            )
            (§ case -3)
            (§ block
                (§ return (§ expr "Kilocoin-"))
            )
            (§ case -6)
            (§ block
                (§ return (§ expr "Megacoin-"))
            )
            (§ default )
            (§ block
                (§ return (§ expr "Fixed (" + scale + ") "))
            )
        )
    )

    ;;;
     ; Returns a brief description of this formatter.  The exact details of the representation
     ; are unspecified and subject to change, but will include some representation of the
     ; formatting/parsing pattern and the fractional decimal place grouping.
     ;;
    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr prefixLabel(§ pars scale) + "format " + pattern(§ pars )))
    )
)

#_(ns org.bitcoinj.utils #_"BtcFormat"
    (:import [java.math BigDecimal BigInteger]
             #_static [java.math.RoundingMode HALF_UP]
             [java.text AttributedCharacterIterator DecimalFormat DecimalFormatSymbols FieldPosition Format NumberFormat ParseException ParsePosition]
             [java.util Locale List ArrayList]
             [java.util.regex Matcher Pattern])
    (:import [com.google.common.base Objects Preconditions Strings]
             [com.google.common.collect ImmutableList])
   (:require [org.bitcoinj.core Coin]
             [org.bitcoinj.utils.BtcAutoFormat Style]
             #_static [org.bitcoinj.utils.BtcAutoFormat.Style *]))

;;;
 ; <p>Instances of this class format and parse locale-specific numerical representations of Bitcoin monetary values.
 ;
 ; <p>A primary goal of this class is to minimize the danger of human-misreading of monetary values due to mis-counting
 ; the number of zeros (or, more generally, of decimal places) in the number that represents a Bitcoin monetary value.
 ; Some of the features offered for doing this are:
 ; <ol>
 ;   <li>automatic adjustment of denominational units in which a value is represented so as to lessen the number of adjacent zeros,
 ;   <li>use of locale-specific decimal-separators to group digits in the integer portion of formatted numbers,
 ;   <li>fine control over the number and  grouping of fractional decimal places, and
 ;   <li>access to character information that allows for vertical alignment of tabular columns of formatted values.
 ; </ol>
 ;
 ; <h3>Basic Usage</h3>
 ;
 ; Basic usage is very simple:
 ; <ol>
 ;   <li>Construct a new formatter object using one of the factory methods.
 ;   <li>Format a value by passing it as an argument to the {@link BtcFormat#format(Object)} method.
 ;   <li>Parse a value by passing a <code>String</code>-type representation of it to the {@link BtcFormat#parse(String)} method.
 ; </ol>
 ;
 ; <p>For example, depending on your locale, values might be formatted and parsed as follows:
 ;
 ; <blockquote><pre>
 ; BtcFormat f = BtcFormat.getInstance();
 ; String c = f.format(Coin.COIN);                <strong>// "BTC 1.00"</strong>
 ; String k = f.format(Coin.COIN.multiply(1000)); <strong>// "BTC 1,000.00"</strong>
 ; String m = f.format(Coin.COIN.divide(1000));   <strong>// "mBTC 1.00"</strong>
 ; Coin all = f.parseObject("M฿ 21");             <strong>// All the money in the world</strong>
 ; </pre></blockquote>
 ;
 ; <h3>Auto-Denomination versus Fixed-Denomination</h3>
 ;
 ; There are two provided concrete classes, one that automatically denominates values to be formatted, {@link BtcAutoFormat},
 ; and another that formats any value in units of a fixed, specified denomination, {@link BtcFixedFormat}.
 ;
 ; <h5>Automatic Denomination</h5>
 ;
 ; Automatic denomination means that the formatter adjusts the denominational units in which a formatted number is
 ; expressed based on the monetary value that number represents.  An auto-denominating formatter is defined by its
 ; style, specified by one of the enumerated values of {@link BtcAutoFormat.Style}.  There are two styles constants:
 ; {@link BtcAutoFormat.Style#CODE} (the default), and {@link BtcAutoFormat.Style#SYMBOL}.  The difference is that
 ; the <code>CODE</code> style uses an internationally-distinct currency code, such as <code>"BTC"</code>, to indicate
 ; the units of denomination, while the <code>SYMBOL</code> style uses a possibly-ambiguous currency symbol such as
 ; <code>"฿"</code>.
 ;
 ; <p>The denomination used when formatting will be either bitcoin, millicoin or microcoin, depending on the value
 ; being represented, chosen so as to minimize the number of consecutive zeros displayed without losing precision.
 ; For example, depending on the locale, a value of one bitcoin might be formatted as <pre>฿1.00</pre> where a value
 ; exceeding that by one satoshi would be <pre>µ฿1,000,000.01</pre>.
 ;
 ; <h5>Fixed Denomination</h5>
 ;
 ; Fixed denomination means that the same denomination of units is used for every value that is formatted or parsed
 ; by a given formatter instance.  A fixed-denomination formatter is defined by its scale, which is the number of
 ; places one must shift the decimal point in increasing precision to convert the representation of a given quantity
 ; of bitcoins into a representation of the same value denominated in the formatter's units.  For example, a scale
 ; value of <code>3</code> specifies a denomination of millibitcoins, because to represent <code>1.0000 BTC</code>,
 ; or one bitcoin, in millibitcoins, one shifts the decimal point three places, that is, to <code>1000.0 mBTC</code>.
 ;
 ; <h3>Construction</h3>
 ;
 ; There are two ways to obtain an instance of this class:
 ; <ol>
 ;   <li>Use one of the factory methods; or
 ;   <li>Use a {@link BtcFormat.Builder} object.
 ; </ol>
 ;
 ; <p>The factory methods are appropriate for basic use where the default configuration is either used or modified.
 ; The <code>Builder</code> class provides more control over the configuration, and gives access to some features
 ; not available through the factory methods, such as using custom formatting patterns and currency symbols.
 ;
 ; <h5>Factory Methods</h5>
 ;
 ; Although formatting and parsing is performed by one of the concrete subclasses, you can obtain formatters using
 ; the various static factory methods of this abstract base class <code>BtcFormat</code>.  There are a variety of
 ; overloaded methods that allow you to obtain a formatter that behaves according to your needs.
 ;
 ; <p>The primary distinction is between automatic- and fixed-denomination formatters.  By default, the
 ; <code>getInstance()</code> method with no arguments returns a new, automatic-denominating <code>BtcAutoFormat</code>
 ; instance for your default locale that will display exactly two fractional decimal places and a currency code.
 ; For example, if you happen to be in the USA:
 ;
 ; <blockquote><pre>
 ; BtcFormat f = BtcFormat.getInstance();
 ; String s = f.format(Coin.COIN); <strong>// "BTC 1.00"</strong>
 ; </pre></blockquote>
 ;
 ; <p>The first argument to <code>getInstance()</code> can determine whether you get an auto- or fixed-denominating
 ; formatter.  If the type of the first argument is an <code>int</code>, then the value of that <code>int</code>
 ; will be interpreted as the decimal-place scale of the {@link BtcFixedFormat} instance that is returned, and thus
 ; will determine its denomination.  For example, if you want to format values in units of microbitcoins:
 ;
 ; <blockquote><pre>
 ; BtcFormat m = BtcFormat.getInstance(6);
 ; String s = m.format(Coin.COIN); <strong>// "1,000,000.00"</strong>
 ; </pre></blockquote>
 ;
 ; <p>This class provides several constants bound to common scale values:
 ;
 ; <blockquote><pre>
 ; BtcFormat milliFormat = BtcFormat.getInstance(MILLICOIN_SCALE);
 ; </pre></blockquote>
 ;
 ; <p>Alternatively, if the type of the first argument to <code>getInstance()</code> is one of the enumerated values
 ; of the {@link BtcAutoFormat.Style} type, either <code>CODE</code> or <code>SYMBOL</code>, then you will get a
 ; {@link BtcAutoFormat} instance that uses either a currency code or symbol, respectively, to indicate the results
 ; of its auto-denomination.
 ;
 ; <blockquote><pre>
 ; BtcFormat s = BtcFormat.getInstance(SYMBOL);
 ; Coin value = Coin.parseCoin("0.1234");
 ; String mil = s.format(value);              <strong>// "₥฿123.40"</strong>
 ; String mic = s.format(value.divide(1000)); <strong>// "µ฿123.40"</strong>
 ; </pre></blockquote>
 ;
 ; <p>An alternative way to specify whether you want an auto- or fixed-denomination formatter is to use one
 ; of the factory methods that is named to indicate that characteristics of the new instance returned.  For
 ; fixed-denomination formatters, these methods are {@link #getCoinInstance()}, {@link #getMilliInstance()},
 ; and {@link #getMicroInstance()}.  These three methods are equivalent to invoking <code>getInstance()</code>
 ; with a first argument of <code>0</code>, <code>3</code> and <code>6</code>, respectively.  For auto-denominating
 ; formatters the relevant factory methods are {@link #getCodeInstance()} and {@link #getSymbolInstance()},
 ; which are equivalent to <code>getInstance(Style.CODE)</code>, and <code>getInstance(Style.SYMBOL)</code>.
 ;
 ; <p>Regardless of how you specify whether your new formatter is to be of automatic- or fixed-denomination, the
 ; next (and possibly first) parameter to each of the factory methods is an optional <code>Locale</code> value.
 ;
 ; For example, here we construct four instances for the same locale that each format
 ; differently the same one-bitcoin value:
 ;
 ; <blockquote><pre>
 ; <strong>// Next line returns "1,00 BTC"</strong>
 ; BtcFormat.getInstance(Locale.GERMANY).format(Coin.COIN);
 ; <strong>// Next line returns "1,00 ฿"</strong>
 ; BtcFormat.getInstance(SYMBOL, Locale.GERMANY).format(Coin.COIN);
 ; <strong>// Next line returns "1.000,00"</strong>
 ; BtcFormat.getMilliInstance(Locale.GERMANY).format(Coin.COIN);
 ; <strong>// Next line returns "10.000,00"</strong>
 ; BtcFormat.getInstance(4, Locale.GERMANY).format(Coin.COIN);
 ; </pre></blockquote>
 ;
 ; Omitting such a <code>Locale</code> parameter will give you a formatter for your default locale.
 ;
 ; <p>The final (and possibly only) arguments to the factory methods serve to set the default number of
 ; fractional decimal places that will be displayed when formatting monetary values.  In the case of an
 ; auto-denominating formatter, this can be a single <code>int</code> value, which will determine the number
 ; of fractional decimal places to be used in all cases, except where either (1) doing so would provide
 ; a place for fractional satoshis, or (2) that default value is overridden when invoking
 ; the <code>format()</code> method as described below.
 ;
 ; <p>In the case of a fixed-denomination formatter, you can pass any number of <code>int</code> values.
 ; The first will determine the minimum number of fractional decimal places, and each following <code>int</code>
 ; value specifies the size of an optional group of decimal-places to be displayed only if useful for expressing
 ; precision.  As with auto-denominating formatters, numbers will never be formatted with a decimal place that
 ; represents a fractional quantity of satoshis, and these defaults can be overridden by arguments to the
 ; <code>format()</code> method.  See below for examples.
 ;
 ; <h5>The <code>Builder</code> Class</h5>
 ;
 ; A new {@link BtcFormat.Builder} instance is returned by the {@link #builder()} method.  Such an object has
 ; methods that set the configuration parameters of a <code>BtcFormat</code> object.  Its {@link Builder#build()}
 ; method constructs and returns a <code>BtcFormat</code> instance configured according to those settings.
 ;
 ; <p>In addition to setter-methods that correspond to the factory-method parameters explained above,
 ; a <code>Builder</code> also allows you to specify custom formatting and parsing patterns and currency symbols
 ; and codes.  For example, rather than using the default currency symbol, which has the same unicode character
 ; point as the national currency symbol of Thailand, some people prefer to use a capital letter "B" with
 ; a vertical overstrike.
 ;
 ; <blockquote><pre>
 ; BtcFormat.Builder builder = BtcFormat.builder();
 ; builder.style(SYMBOL);
 ; builder.symbol("B&#x5c;u20e6"); <strong>// unicode char "double vertical stroke overlay"</strong>
 ; BtcFormat f = builder.build();
 ; String out = f.format(COIN); <strong>// "B⃦1.00" depending on locale</strong>
 ; </pre></blockquote>
 ;
 ; The <code>Builder</code> methods are chainable.  So, for example, if you are
 ; deferential to ISO 4217, you might construct a formatter in a single line this way:
 ;
 ; <blockquote><pre>
 ; BtcFormat f = BtcFormat.builder().style(CODE).code("XBT").build();
 ; String out = f.format(COIN); <strong>// "XBT 1.00"</strong>
 ; </pre></blockquote>
 ;
 ; <p>See the documentation of the {@link BtcFormat.Builder} class for details.
 ;
 ; <h3>Formatting</h3>
 ;
 ; <p>You format a Bitcoin monetary value by passing it to the {@link BtcFormat#format(Object)} method.  This argument
 ; can be either a {@link org.bitcoinj.core.Coin}-type object or a numerical object such as {@link java.lang.Long} or
 ; {@link java.math.BigDecimal}.  Integer-based types such as {@link java.math.BigInteger} are interpreted as representing
 ; a number of satoshis, while a {@link java.math.BigDecimal} is interpreted as representing a number of bitcoins.
 ; A value having a fractional amount of satoshis is rounded to the nearest whole satoshi at least, and possibly to
 ; a greater unit depending on the number of fractional decimal-places displayed.  The <code>format()</code> method will
 ; not accept an argument whose type is <code>String</code>, <code>Float</code> nor <code>Double</code>.
 ;
 ; <p>Subsequent to the monetary value to be formatted, the {@link #format(Object)} method also accepts as arguments
 ; optional <code>int</code> values that specify the number of decimal places to use to represent the fractional portion
 ; of the number.  This overrides the default, and enables a single formatter instance to be reused, formatting different
 ; values that require different numbers of fractional decimal places.  These parameters have the same meaning as those
 ; that set the default values in the factory methods as described above.  Namely, a single <code>int</code> value determines
 ; the minimum number of fractional decimal places that will be used in all cases, to a precision limit of satoshis.
 ; Instances of {@link BtcFixedFormat} also accept a variable-length sequence of additional <code>int</code> values, each
 ; of which specifies the size of a group of fractional decimal-places to be used in addition to all preceding places, only
 ; if useful to express precision, and only to a maximum precision of satoshis.  For example:
 ;
 ; <blockquote><pre>
 ; BtcFormat f = BtcFormat.getCoinInstance();
 ; Coin value = COIN.add(Coin.valueOf(5)); <strong>// 100000005 satoshis</strong>
 ; f.format(value, 2);       <strong>// "1.00"</strong>
 ; f.format(value, 3);       <strong>// "1.000"</strong>
 ; f.format(value, 2, 3);    <strong>// "1.00" three more zeros doesn't help</strong>
 ; f.format(value, 2, 3, 3); <strong>// "1.00000005" </strong>
 ; f.format(value, 2, 3, 4); <strong>// "1.00000005" fractions of satoshis have no place</strong>
 ; f.format(value, 2, 3, 2); <strong>// "1.0000001" rounds to nearest usable place</strong>
 ; </pre></blockquote>
 ;
 ; <p>Note that if using all the fractional decimal places in a specified group would give a place to fractions of satoshis,
 ; then the size of that group will be reduced to a maximum precision of satoshis.  Either all or none of the allowed decimal
 ; places of that group will still be applied as doing so is useful for expressing the precision of the value being formatted.
 ;
 ; <p>Several convenient constants of repeating group-size sequences are provided: {@link BtcFixedFormat#REPEATING_PLACES},
 ; {@link BtcFixedFormat#REPEATING_DOUBLETS} and {@link BtcFixedFormat#REPEATING_TRIPLETS}.  These signify repeating groups
 ; of one, two and three decimals places, respectively.  For example, to display only as many fractional places as useful
 ; in order to prevent hanging zeros on the least-significant end of formatted numbers:
 ;
 ; <blockquote><pre>
 ; format(value, 0, REPEATING_PLACES);
 ; </pre></blockquote>
 ;
 ; <p>When using an automatically-denominating formatter, you might want to know what denomination was chosen.  You can get
 ; the currency-units indicator, as well as any other field in the formatted output, by using a {@link java.text.FieldPosition}
 ; instance constructed using an appropriate constant from the {@link java.text.NumberFormat.Field} class:
 ;
 ; <blockquote><pre>
 ; BtcFormat de = BtcFormat.getInstance(Locale.GERMANY);
 ; FieldPosition currField = new FieldPosition(NumberFormat.Field.CURRENCY);
 ; <strong>// next line formats the value as "987.654.321,23 µBTC"</strong>
 ; String output = de.format(valueOf(98765432123L), new StringBuffer(), currField);
 ; <strong>// next line sets variable currencyCode to "µBTC"</strong>
 ; String currencyCode = output.substring(currField.getBeginIndex(), currField.getEndIndex()));
 ; </pre></blockquote>
 ;
 ; <p>When using a fixed-denomination formatter whose scale can be expressed as a standard "metric" prefix,
 ; you can invoke the <code>code()</code> and <code>symbol()</code> methods to obtain a <code>String</code>
 ; whose value is the appropriate currency code or symbol, respectively, for that formatter.
 ;
 ; <blockquote><pre>
 ; BtcFixedFormat kilo = (BtcFixedFormat)BtcFormat(-3); <strong>// scale -3 for kilocoins</strong>
 ; Coin value = Coin.parseCoin("1230");
 ; <strong>// variable coded will be set to "kBTC 1.23"</strong>
 ; String coded = kilo.code() + " " + kilo.format(value);
 ; <strong>// variable symbolic will be set to "k฿1.23"</strong>
 ; String symbolic = kilo.symbol() + kilo.format(value);
 ; BtcFormat(4).code(); <strong>// unnamed denomination has no code; raises exception</strong>
 ; </pre></blockquote>
 ;
 ; <h5>Formatting for Tabular Columns</h5>
 ;
 ; When displaying tables of monetary values, you can lessen the risk of human misreading-error by vertically
 ; aligning the decimal separator of those values.  This example demonstrates one way to do that:
 ;
 ; <blockquote><pre>
 ; <strong>// The elements of this array are the values we will format:</strong>
 ; Coin[] rows = { MAX_MONEY, MAX_MONEY.subtract(SATOSHI), Coin.parseCoin("1234"), COIN,
 ;                 COIN.divide(1000), valueOf(10000), valueOf(1000), valueOf(100), SATOSHI };
 ; BtcFormat f = BtcFormat.getCoinInstance(2, REPEATING_PLACES);
 ; FieldPosition fp = new FieldPosition(DECIMAL_SEPARATOR); <strong>// see java.text.NumberFormat.Field</strong>
 ; String[] output = new String[rows.length];
 ; int[] indexes = new int[rows.length];
 ; int maxIndex = 0;
 ; for (int i = 0; i < rows.length; i++)
 ; {
 ;     output[i] = f.format(rows[i], new StringBuffer(), fp).toString();
 ;     indexes[i] = fp.getBeginIndex();
 ;     if (maxIndex < indexes[i])
 ;         maxIndex = indexes[i];
 ; }
 ; for (int i = 0; i < output.length; i++)
 ; {
 ;     System.out.println(repeat(" ", maxIndex - indexes[i]) + output[i]);
 ; }
 ; </pre></blockquote>
 ;
 ; Assuming you are using a monospaced font, and depending on your locale, the foregoing will print the following:
 ;
 ; <blockquote><pre>
 ; 21,000,000.00
 ; 20,999,999.99999999
 ;      1,234.00
 ;          1.00
 ;          0.001
 ;          0.0001
 ;          0.00001
 ;          0.000001
 ;          0.00000001
 ; </pre></blockquote>
 ;
 ; If you need to vertically-align columns printed in a proportional font, then see the documentation
 ; for the {@link java.text.NumberFormat} class for an explanation of how to do that.
 ;
 ; <h3>Parsing</h3>
 ;
 ; <p>The {@link #parse(String)} method accepts a <code>String</code> argument, and returns a {@link Coin}-type value.
 ; The difference in parsing behavior between instances of {@link BtcFixedFormat} and {@link BtcAutoFormat} is analogous
 ; to the difference in formatting behavior between instances of those classes.  Instances of {@link BtcAutoFormat} recognize
 ; currency codes and symbols in the <code>String</code> being parsed, and interpret them as indicators of the units in which
 ; the number being parsed is denominated.  On the other hand, instances of {@link BtcFixedFormat} by default recognize no
 ; codes nor symbols, but rather interpret every number as being denominated in the units that were specified when constructing
 ; the instance doing the parsing.  This default behavior of {@link BtcFixedFormat} can be overridden by setting a parsing
 ; pattern that includes a currency sign using the {@link BtcFormat.Builder#pattern()} method.
 ;
 ; <p>The {@link BtcAutoFormat#parse(String)}</code> method of {@link BtcAutoFormat} (and of {@link BtcAutoFormat} configured
 ; with applicable non-default pattern) will recognize a variety of currency symbols and codes, including all standard
 ; international (metric) prefixes from micro to mega.  For example, denominational units of microcoins may be specified
 ; by <code>µ฿</code>, <code>u฿</code>, <code>µB⃦</code>, <code>µɃ</code>, <code>µBTC</code> or other appropriate permutations
 ; of those characters.  Additionally, if either or both of a custom currency code or symbol is configured using
 ; {@link BtcFormat.Builder#code} or {@link BtcFormat.Builder#code}, then such code or symbol will be recognized in addition
 ; to those recognized by default.
 ;
 ; <p>Instances of this class that recognize currency signs will recognize both currency symbols and codes, regardless of which
 ; that instance uses for formatting.  However, if the style is <code>CODE</code> (and unless overridden by a custom pattern)
 ; then a space character must separate the units indicator from the number.  When parsing with a <code>SYMBOL</code>-style
 ; <code>BtcFormat</code> instance, on the other hand, whether or not the units indicator must be separated by a space from
 ; the number is determined by the locale.  The {@link BtcFormat#pattern()} method returns a representation of the pattern
 ; that can be examined to determine whether a space must separate currency signs from numbers in parsed <code>String</code>s.
 ;
 ; <p>When parsing, if the currency-units indicator is absent, then a {@link BtcAutoFormat} instance will infer a denomination
 ; of bitcoins while a {@link BtcFixedFormat} will infer the denomination in which it expresses formatted values.  Note: by
 ; default (unless overridden by a custom pattern), if the locale or style requires a space to separate the number from the
 ; units indicator, that space must be present in the String to be parsed, even if the units indicator is absent.
 ;
 ; <p>The <code>parse()</code> method returns an instance of the {@link Coin} class.  Therefore, attempting to parse a value
 ; greater than the maximum that a <code>Coin</code> object can represent will raise a <code>ParseException</code>, as will
 ; any other detected parsing error.
 ;
 ; <h3>Limitations</h3>
 ;
 ; <h5>Parsing</h5>
 ;
 ; Parsing is performed by an underlying {@link java.text.NumberFormat} object.  While this delivers the benefit
 ; of recognizing locale-specific patterns, some have criticized other aspects of its behavior.  For example, see
 ; <a href="http://www.ibm.com/developerworks/library/j-numberformat/">this article by Joe Sam Shirah</a>.  In particular,
 ; explicit positive-signs are not recognized.  If you are parsing input from end-users, then you should consider whether
 ; you would benefit from any of the work-arounds mentioned in that article.
 ;
 ; <h5>Exotic Locales</h5>
 ;
 ; This class is not well-tested in locales that use non-ascii character sets, especially those where writing proceeds
 ; from right-to-left.  Helpful feedback in that regard is appreciated.
 ;
 ; <h3>Thread-Safety</h3>
 ;
 ; <p>Instances of this class are immutable.
 ;
 ; @see java.text.Format
 ; @see java.text.NumberFormat
 ; @see java.text.DecimalFormat
 ; @see java.text.DecimalFormatSymbols
 ; @see java.text.FieldPosition
 ; @see org.bitcoinj.core.Coin
 ;;

#_public
#_abstract
(§ class #_"BtcFormat" (§ extends #_"Format")
    ;; CONCURRENCY NOTES
     ;
     ; There is one mutable member of this class, the `DecimalFormat` object bound to variable `numberFormat`.
     ; The relevant methods invoked on it are: setMinimumFractionDigits(), setMaximumFractionDigits(), and
     ; setDecimalFormatSymbols(), along with the respective getter methods corresponding to each.  The first
     ; two methods are used to set the number of fractional decimal places displayed when formatting, which is
     ; reflected in the patterns returned by the public pattern() and localizedPattern() methods.  The last
     ; method sets the value of that object's member `DecimalFormatSymbols` object for formatting and parsing,
     ; which is also reflected in the aforementioned patterns.  The patterns, which are the passed-through
     ; return values of the DecimalFormat object's toPattern() and toLocalizedPattern() methods, and the value
     ; of the DecimalFormat object's DecimalFormatSymbols member are among the values compared between instances
     ; of this class in determining the return values of the `equals()` and `hashCode()` methods.
     ;
     ; From the foregoing, you can understand that immutability is achieved as follows: access to the variable
     ; `numberFormat` referent's fraction-digits and format-symbols fields are synchronized on that DecimalFormat
     ; object.  The state of those fraction-digits limits and decimal-format symbols must be returned to a static
     ; state after being changed for formatting or parsing since the user can see them reflected in the return
     ; values of above-mentioned methods and because `equals()` and `hashCode()` use them for comparisons.
     ;;

    ;;; The conventional international currency code for bitcoins: "BTC" ;;
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name COIN_CODE) (§ expr "BTC"))
    ;;; The default currency symbols for bitcoins. ;;
    #_private
    #_static
    #_final
    (§ field #_"String" (§ name COIN_SYMBOL) (§ expr "฿"))
    ;;; An alternative currency symbol to use in locales where the default symbol is used for the national currency. ;;
    #_protected
    #_static
    #_final
    (§ field #_"String" (§ name COIN_SYMBOL_ALT) (§ expr "Ƀ"))

    #_protected
    #_final
    (§ field #_"DecimalFormat" (§ name numberFormat)) ;; warning: mutable
    #_protected
    #_final
    (§ field #_"int" (§ name minimumFractionDigits))
    #_protected
    #_final
    (§ field #_"List<Integer>" (§ name decimalGroups))

    ;; Scale is the number of decimal-places difference from same value in bitcoins.

    ;;;
     ; A constant useful for specifying a denomination of bitcoins, the <code>int</code> value <code>0</code>.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name COIN_SCALE) 0)

    ;;;
     ; A constant useful for specifying a denomination of millibitcoins, the <code>int</code> value <code>3</code>.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name MILLICOIN_SCALE) 3)

    ;;;
     ; A constant useful for specifying a denomination of microbitcoins, the <code>int</code> value <code>6</code>.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name MICROCOIN_SCALE) 6)

    ;;;
     ; Return the number of decimal places by which any value denominated in the units indicated
     ; by the given scale differs from that same value denominated in satoshis.
     ;;
    #_private
    #_static
    (§ method #_"int" (§ fn offSatoshis) [#_"int" (§ name scale)])
    (§ block
        (§ return (§ expr Coin/SMALLEST_UNIT_EXPONENT - scale))
    )

    #_private
    #_static
    (§ method #_"Locale" (§ fn defaultLocale) [])
    (§ block
        (§ return (§ expr Locale/getDefault(§ pars )))
    )

    ;;;
     ; <p>This class constructs new instances of {@link BtcFormat}, allowing for the configuration of those instances
     ; before they are constructed.  After obtaining a <code>Builder</code> object from the {@link BtcFormat#builder()}
     ; method, invoke the necessary setter methods to obtain your desired configuration.  Finaly, the {@link #build()}
     ; method returns a new <code>BtcFormat</code> object that has the specified configuration.
     ;
     ; <p>All the setter methods override defaults.  Invoking <code>build()</code> without invoking any of the setting
     ; methods is equivalent to invoking {@link BtcFormat#getInstance()} with no arguments.
     ;
     ; <p>Each setter methods returns the same instance on which it is invoked, thus these methods can be chained.
     ;
     ; <p>Instances of this class are <strong>not</strong> thread-safe.
     ;;
    #_public
    #_static
    (§ class #_"Builder"
        #_private
        (§ enum #_"Variant"
            (§ item AUTO
            (§ anon
                #_override
                (§ method #_"BtcFormat" (§ fn newInstance) [#_"Builder" (§ name b)])
                (§ block
                    (§ return (§ expr getInstance(§ pars b.style, b.locale, b.minimumFractionDigits)))
                )
            ))
            (§ item FIXED)
            (§ item UNSET)

            (§ method #_"BtcFormat" (§ fn newInstance) [#_"Builder" (§ name b)])
            (§ block
                (§ return (§ expr getInstance(§ pars b.scale, b.locale, b.minimumFractionDigits, b.fractionGroups)))
            )
        )
        ;; Parameters are initialized to default or unset values.
        #_private
        (§ field #_"Variant" (§ name variant) (§ expr Variant/UNSET))
        #_private
        (§ field #_"Locale" (§ name locale) (§ expr defaultLocale(§ pars )))
        #_private
        (§ field #_"int" (§ name minimumFractionDigits) 2)
        #_private
        (§ field #_"int[]" (§ name fractionGroups) (§ coll ))
        #_private
        (§ field #_"Style" (§ name style) (§ expr BtcAutoFormat/Style/CODE))
        #_private
        (§ field #_"int" (§ name scale) 0)
        #_private
        (§ field #_"String" (§ name symbol) (§ expr ""))
        #_private
        (§ field #_"String" (§ name code) (§ expr ""))
        #_private
        (§ field #_"String" (§ name pattern) (§ expr ""))
        #_private
        (§ field #_"String" (§ name localizedPattern) (§ expr ""))

        #_private
        (§ constructor #_"Builder" [])
        (§ block
            (§ void this)
        )

        ;;;
         ; Specify the new <code>BtcFormat</code> is to be automatically-denominating.
         ; The argument determines which of either codes or symbols the new <code>BtcFormat</code>
         ; will use by default to indicate the denominations it chooses when formatting values.
         ;
         ; <p>Note that the <code>Style</code> argument specifies the <em>default</em> style, which is
         ; overridden by invoking either {@link #pattern(String)} or {@link #localizedPattern(String)}.
         ;
         ; @throws IllegalArgumentException if {@link #scale(int)} has previously been invoked on this instance.
         ;;
        #_public
        (§ method #_"Builder" (§ fn style) [#_"BtcAutoFormat.Style" (§ name val)])
        (§ block
            (§ if (§ expr variant == Variant/FIXED))
            (§ block
                (§ throw (§ new #_"IllegalStateException" (§ pars "You cannot invoke both style() and scale()")))
            )

            (§ ass (§ name variant) (§ expr Variant/AUTO))
            (§ ass (§ name style) val)
            (§ return this)
        )

        ;;;
         ; Specify the number of decimal places in the fraction part of formatted numbers.
         ; This is equivalent to the {@link #minimumFractionDigits(int)} method, but named
         ; appropriately for the context of generating {@link BtcAutoFormat} instances.
         ;
         ; <p>If neither this method nor <code>minimumFactionDigits()</code> is invoked,
         ; the default value will be <code>2</code>.
         ;;
        #_public
        (§ method #_"Builder" (§ fn fractionDigits) [#_"int" (§ name val)])
        (§ block
            (§ return (§ expr minimumFractionDigits(§ pars val)))
        )

        ;;;
         ; Specify a fixed-denomination of units to use when formatting and parsing values.
         ; The argument specifies the number of decimal places, in increasing precision, by which
         ; each formatted value will differ from that same value denominated in bitcoins.  For example,
         ; a denomination of millibitcoins is specified with a value of <code>3</code>.
         ;
         ; <p>The <code>BtcFormat</code> class provides appropriately named <code>int</code>-type constants
         ; for the three common values, {@link BtcFormat#COIN_SCALE}, {@link BtcFormat#MILLICOIN_SCALE}
         ; and {@link BtcFormat#MICROCOIN_SCALE}.
         ;
         ; <p>If neither this method nor {@link #style(BtcAutoFormat.Style)} is invoked on a <code>Builder</code>,
         ; then the <code>BtcFormat</code> will default to a fixed-denomination of bitcoins, equivalent
         ; to invoking this method with an argument of <code>0</code>.
         ;;
        #_public
        (§ method #_"Builder" (§ fn scale) [#_"int" (§ name val)])
        (§ block
            (§ if (§ expr variant == Variant/AUTO))
            (§ block
                (§ throw (§ new #_"IllegalStateException" (§ pars "You cannot invoke both scale() and style()")))
            )

            (§ ass (§ name variant) (§ expr Variant/FIXED))
            (§ ass (§ name scale) val)
            (§ return this)
        )

        ;;;
         ; Specify the minimum number of decimal places in the fraction part of formatted values.
         ; This method is equivalent to {@link #fractionDigits(int)}, but named appropriately for
         ; the context of generating a fixed-denomination formatter.
         ;
         ; <p>If neither this method nor <code>fractionDigits()</code> is invoked, the default value
         ; will be <code>2</code>.
         ;;
        #_public
        (§ method #_"Builder" (§ fn minimumFractionDigits) [#_"int" (§ name val)])
        (§ block
            (§ ass (§ name minimumFractionDigits) val)
            (§ return this)
        )

        ;;;
         ; Specify the sizes of a variable number of optional decimal-place groups in the fraction
         ; part of formatted values.  A group of each specified size will be used in addition to
         ; all previously applied decimal places only if doing so is useful for expressing precision.
         ; The size of each group is limited to a maximum precision of satoshis.
         ;
         ; <p>If this method is not invoked, then the number of fractional decimal places will be limited to
         ; the value passed to {@link #minimumFractionDigits}, or <code>2</code> if that method is not invoked.
         ;;
        #_public
        (§ method #_"Builder" (§ fn fractionGroups) [#_"int..." (§ name val)])
        (§ block
            (§ ass (§ name fractionGroups) val)
            (§ return this)
        )

        ;;;
         ; Specify the {@link java.util.Locale} for formatting and parsing.
         ; If this method is not invoked, then the runtime default locale will be used.
         ;;
        #_public
        (§ method #_"Builder" (§ fn locale) [#_"Locale" (§ name val)])
        (§ block
            (§ ass (§ name locale) val)
            (§ return this)
        )

        ;;;
         ; Specify a currency symbol to be used in the denomination-unit indicators of formatted values.
         ; This method only sets the symbol, but does not cause it to be used.  You must also invoke either
         ; <code>style(SYMBOL)</code>, or else apply a custom pattern that includes a single currency-sign
         ; character by invoking either {@link #pattern(String)} or {@link #localizedPattern(String)}.
         ;
         ; <p>Specify only the base symbol.  The appropriate prefix will be applied according to
         ; the denomination of formatted and parsed values.
         ;;
        #_public
        (§ method #_"Builder" (§ fn symbol) [#_"String" (§ name val)])
        (§ block
            (§ ass (§ name symbol) val)
            (§ return this)
        )

        ;;;
         ; Specify a custom currency code to be used in the denomination-unit indicators of formatted values.
         ; This method only sets the code, but does not cause it to be used.  You must also invoke either
         ; <code>style(CODE)</code>, or else apply a custom pattern that includes a double currency-sign
         ; character by invoking either {@link #pattern(String)} or {@link #localizedPattern(String)}.
         ;
         ; <p>Specify only the base code.  The appropriate prefix will be applied according to
         ; the denomination of formatted and parsed values.
         ;;
        #_public
        (§ method #_"Builder" (§ fn code) [#_"String" (§ name val)])
        (§ block
            (§ ass (§ name code) val)
            (§ return this)
        )

        ;;;
         ; Use the given pattern when formatting and parsing.  The format of this pattern is identical to
         ; that used by the {@link java.text.DecimalFormat} class.
         ;
         ; <p>If the pattern lacks a negative subpattern, then the formatter will indicate negative values
         ; by placing a minus sign immediately preceding the number part of formatted values.
         ;
         ; <p>Note that while the pattern format specified by the {@link java.text.DecimalFormat} class
         ; includes a mechanism for setting the number of fractional decimal places, that part of the pattern
         ; is ignored.  Instead, use the {@link #fractionDigits(int)}, {@link #minimumFractionDigits(int)}
         ; and {@link #fractionGroups(int...)} methods.
         ;
         ; <p>Warning: if you set a pattern that includes a currency-sign for a fixed-denomination formatter
         ; that uses a non-standard scale, then an exception will be raised when you try to format a value.
         ; The standard scales include all for which a metric prefix exists from micro to mega.
         ;
         ; <p>Note that by applying a pattern you override the configured formatting style of
         ; {@link BtcAutoFormat} instances.
         ;;
        #_public
        (§ method #_"Builder" (§ fn pattern) [#_"String" (§ name val)])
        (§ block
            (§ if (§ expr localizedPattern != ""))
            (§ block
                (§ throw (§ new #_"IllegalStateException" (§ pars "You cannot invoke both pattern() and localizedPattern()")))
            )

            (§ ass (§ name pattern) val)
            (§ return this)
        )

        ;;;
         ; Use the given localized-pattern for formatting and parsing.  The format of this pattern is identical
         ; to the patterns used by the {@link java.text.DecimalFormat} class.
         ;
         ; <p>The pattern is localized according to the locale of the <code>BtcFormat</code> instance, the symbols
         ; for which can be examined by inspecting the {@link java.text.DecimalFormatSymbols} object returned by
         ; {@link BtcFormat#symbols()}.  So, for example, if you are in Germany, then the non-localized pattern of
         ; <pre>"#,##0.###"</pre> would be localized as <pre>"#.##0,###"</pre>.
         ;
         ; <p>If the pattern lacks a negative subpattern, then the formatter will indicate negative values by
         ; placing a minus sign immediately preceding the number part of formatted values.
         ;
         ; <p>Note that while the pattern format specified by the {@link java.text.DecimalFormat} class includes
         ; a mechanism for setting the number of fractional decimal places, that part of the pattern is ignored.
         ; Instead, use the {@link #fractionDigits(int)}, {@link #minimumFractionDigits(int)} and
         ; {@link #fractionGroups(int...)} methods.
         ;
         ; <p>Warning: if you set a pattern that includes a currency-sign for a fixed-denomination formatter
         ; that uses a non-standard scale, then an exception will be raised when you try to format a value.
         ; The standard scales include all for which a metric prefix exists from micro to mega.
         ;
         ; <p>Note that by applying a pattern you override the configured formatting style of
         ; {@link BtcAutoFormat} instances.
         ;;
        #_public
        (§ method #_"Builder" (§ fn localizedPattern) [#_"String" (§ name val)])
        (§ block
            (§ if (§ expr pattern != ""))
            (§ block
                (§ throw (§ new #_"IllegalStateException" (§ pars "You cannot invoke both pattern() and localizedPattern().")))
            )

            (§ ass (§ name localizedPattern) val)
            (§ return this)
        )

        ;;;
         ; Return a new {@link BtcFormat} instance.  The object returned will be configured according
         ; to the state of this <code>Builder</code> instance at the time this method is invoked.
         ;;
        #_public
        (§ method #_"BtcFormat" (§ fn build) [])
        (§ block
            (§ var #_"BtcFormat" (§ name f) (§ expr variant.newInstance(§ pars this)))
            (§ if (§ expr symbol != "" || code != ""))
            (§ block
                (§ sync f.numberFormat)
                (§ block
                    (§ var #_"DecimalFormatSymbols" (§ name defaultSigns) (§ expr f.numberFormat.getDecimalFormatSymbols(§ pars )))
                    (§ expr setSymbolAndCode(§ pars (§ expr f.numberFormat), (§ quest (§ expr symbol != "") ? symbol :else (§ expr defaultSigns.getCurrencySymbol(§ pars ))), (§ quest (§ expr code != "") ? code :else (§ expr defaultSigns.getInternationalCurrencySymbol(§ pars )))))
                )
            )
            (§ if (§ expr localizedPattern != "" || pattern != ""))
            (§ block
                (§ var #_"int" (§ name places) (§ expr f.numberFormat.getMinimumFractionDigits(§ pars )))
                (§ if (§ expr localizedPattern != ""))
                (§ block
                    (§ expr f.numberFormat.applyLocalizedPattern(§ pars negify(§ pars localizedPattern)))
                )
                (§ else )
                (§ block
                    (§ expr f.numberFormat.applyPattern(§ pars negify(§ pars pattern)))
                )
                (§ expr f.numberFormat.setMinimumFractionDigits(§ pars places))
                (§ expr f.numberFormat.setMaximumFractionDigits(§ pars places))
            )
            (§ return f)
        )
    )

    ;;; Return a new {@link Builder} object.  See the documentation of that class for usage details. ;;
    #_public
    #_static
    (§ method #_"Builder" (§ fn builder) [])
    (§ block
        (§ return (§ new #_"Builder" (§ pars )))
    )

    ;;; This single constructor is invoked by the overriding subclass constructors. ;;
    #_protected
    (§ constructor #_"BtcFormat" [#_"DecimalFormat" (§ name numberFormat), #_"int" (§ name minDecimals), #_"List<Integer>" (§ name groups)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars 0 <= minDecimals, "There can be no fewer than zero fractional decimal places"))

        (§ ass (§ name this.numberFormat) numberFormat)
        (§ expr this.numberFormat.setParseBigDecimal(§ pars true))
        (§ expr this.numberFormat.setRoundingMode(§ pars HALF_UP))
        (§ ass (§ name this.minimumFractionDigits) minDecimals)
        (§ expr this.numberFormat.setMinimumFractionDigits(§ pars this.minimumFractionDigits))
        (§ expr this.numberFormat.setMaximumFractionDigits(§ pars this.minimumFractionDigits))
        (§ ass (§ name this.decimalGroups) groups)
        (§ sync this.numberFormat)
        (§ block
            (§ expr setSymbolAndCode(§ pars this.numberFormat, (§ quest (§ dot this.numberFormat.getDecimalFormatSymbols(§ pars ).getCurrencySymbol(§ pars ).contains(§ pars COIN_SYMBOL)) ? (§ expr COIN_SYMBOL_ALT) :else (§ expr COIN_SYMBOL)), COIN_CODE))
        )
        (§ void this)
    )

    ;;;
     ; Return a new instance of this class using all defaults.  The returned formatter will auto-denominate
     ; values so as to minimize zeros without loss of precision and display a currency code, for example
     ; "<code>BTC</code>", to indicate that denomination.  The returned object will uses the default locale
     ; for formatting the number and placement of the currency-code.  Two fractional decimal places will
     ; be displayed in all formatted numbers.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getInstance) [])
    (§ block
        (§ return (§ expr getInstance(§ pars defaultLocale(§ pars ))))
    )

    ;;;
     ; Return a new auto-denominating instance that will indicate units using a currency symbol, for example,
     ; <code>"฿"</code>.  Formatting and parsing will be done according to the default locale.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getSymbolInstance) [])
    (§ block
        (§ return (§ expr getSymbolInstance(§ pars defaultLocale(§ pars ))))
    )

    ;;;
     ; Return a new auto-denominating instance that will indicate units using a currency code, for example,
     ; <code>"BTC"</code>.  Formatting and parsing will be done according to the default locale.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getCodeInstance) [])
    (§ block
        (§ return (§ expr getCodeInstance(§ pars defaultLocale(§ pars ))))
    )

    ;;;
     ; Return a new symbol-style auto-formatter with the given number of fractional decimal places.
     ; Denominational units will be indicated using a currency symbol, for example, <code>"฿"</code>.
     ; The returned object will format the fraction-part of numbers using the given number of decimal
     ; places, or fewer as necessary to avoid giving a place to fractional satoshis.  Formatting and
     ; parsing will be done according to the default locale.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getSymbolInstance) [#_"int" (§ name fractionPlaces)])
    (§ block
        (§ return (§ expr getSymbolInstance(§ pars defaultLocale(§ pars ), fractionPlaces)))
    )

    ;;;
     ; Return a new code-style auto-formatter with the given number of fractional decimal places.
     ; Denominational units will be indicated using a currency code, for example, <code>"BTC"</code>.
     ; The returned object will format the fraction-part of numbers using the given number of decimal
     ; places, or fewer as necessary to avoid giving a place to fractional satoshis.  Formatting and
     ; parsing will be done according to the default locale.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getCodeInstance) [#_"int" (§ name minDecimals)])
    (§ block
        (§ return (§ expr getCodeInstance(§ pars defaultLocale(§ pars ), minDecimals)))
    )

    ;;;
     ; Return a new code-style auto-formatter for the given locale.  The returned object will
     ; select denominational units based on each value being formatted, and will indicate those
     ; units using a currency code, for example, <code>"mBTC"</code>.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getInstance) [#_"Locale" (§ name locale)])
    (§ block
        (§ return (§ expr getCodeInstance(§ pars locale)))
    )

    ;;;
     ; Return a new code-style auto-formatter for the given locale.  The returned object will
     ; select denominational units based on each value being formatted, and will indicate those
     ; units using a currency code, for example, <code>"mBTC"</code>.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getCodeInstance) [#_"Locale" (§ name locale)])
    (§ block
        (§ return (§ expr getInstance(§ pars CODE, locale)))
    )

    ;;;
     ; Return a new code-style auto-formatter for the given locale with the given number of
     ; fraction places.  The returned object will select denominational units based on each
     ; value being formatted, and will indicate those units using a currency code, for example,
     ; <code>"mBTC"</code>.  The returned object will format the fraction-part of numbers using
     ; the given number of decimal places, or fewer as necessary to avoid giving a place to
     ; fractional satoshis.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getInstance) [#_"Locale" (§ name locale), #_"int" (§ name minDecimals)])
    (§ block
        (§ return (§ expr getCodeInstance(§ pars locale, minDecimals)))
    )

    ;;;
     ; Return a new code-style auto-formatter for the given locale with the given number of
     ; fraction places.  The returned object will select denominational units based on each
     ; value being formatted, and will indicate those units using a currency code, for example,
     ; <code>"mBTC"</code>.  The returned object will format the fraction-part of numbers using
     ; the given number of decimal places, or fewer as necessary to avoid giving a place to
     ; fractional satoshis.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getCodeInstance) [#_"Locale" (§ name locale), #_"int" (§ name minDecimals)])
    (§ block
        (§ return (§ expr getInstance(§ pars CODE, locale, minDecimals)))
    )

    ;;;
     ; Return a new symbol-style auto-formatter for the given locale.  The returned object will
     ; select denominational units based on each value being formatted, and will indicate those
     ; units using a currency symbol, for example, <code>"µ฿"</code>.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getSymbolInstance) [#_"Locale" (§ name locale)])
    (§ block
        (§ return (§ expr getInstance(§ pars SYMBOL, locale)))
    )

    ;;;
     ; Return a new symbol-style auto-formatter for the given locale with the given number of
     ; fraction places.  The returned object will select denominational units based on each
     ; value being formatted, and will indicate those units using a currency symbol, for example,
     ; <code>"µ฿"</code>.  The returned object will format the fraction-part of numbers using
     ; the given number of decimal places, or fewer as necessary to avoid giving a place to
     ; fractional satoshis.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getSymbolInstance) [#_"Locale" (§ name locale), #_"int" (§ name fractionPlaces)])
    (§ block
        (§ return (§ expr getInstance(§ pars SYMBOL, locale, fractionPlaces)))
    )

    ;;;
     ; Return a new auto-denominating formatter.  The returned object will indicate the
     ; denominational units of formatted values using either a currency symbol, such as,
     ; <code>"฿"</code>, or code, such as <code>"mBTC"</code>, depending on the value of
     ; the argument.  Formatting and parsing will be done according to the default locale.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getInstance) [#_"Style" (§ name style)])
    (§ block
        (§ return (§ expr getInstance(§ pars style, defaultLocale(§ pars ))))
    )

    ;;;
     ; Return a new auto-denominating formatter with the given number of fractional decimal
     ; places.  The returned object will indicate the denominational units of formatted values
     ; using either a currency symbol, such as, <code>"฿"</code>, or code, such as
     ; <code>"mBTC"</code>, depending on the value of the first argument.  The returned object
     ; will format the fraction-part of numbers using the given number of decimal places, or
     ; fewer as necessary to avoid giving a place to fractional satoshis.  Formatting and
     ; parsing will be done according to the default locale.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getInstance) [#_"Style" (§ name style), #_"int" (§ name fractionPlaces)])
    (§ block
        (§ return (§ expr getInstance(§ pars style, defaultLocale(§ pars ), fractionPlaces)))
    )

    ;;;
     ; Return a new auto-formatter with the given style for the given locale.
     ; The returned object that will auto-denominate each formatted value, and will indicate
     ; that denomination using either a currency code, such as "<code>BTC</code>", or symbol,
     ; such as "<code>฿</code>", depending on the value of the first argument.
     ; <p>The number of fractional decimal places in formatted number will be two, or fewer
     ; as necessary to avoid giving a place to fractional satoshis.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getInstance) [#_"Style" (§ name style), #_"Locale" (§ name locale)])
    (§ block
        (§ return (§ expr getInstance(§ pars style, locale, 2)))
    )

    ;;;
     ; Return a new auto-formatter for the given locale with the given number of fraction places.
     ; The returned object will automatically-denominate each formatted value, and will indicate
     ; that denomination using either a currency code, such as <code>"mBTC"</code>, or symbol,
     ; such as "<code>฿</code>", according to the given style argument.  It will format each
     ; number according to the given locale.
     ;
     ; <p>The third parameter is the number of fractional decimal places to use for each formatted
     ; number, reduced as neccesary when formatting to avoid giving a place to fractional satoshis.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getInstance) [#_"Style" (§ name style), #_"Locale" (§ name locale), #_"int" (§ name fractionPlaces)])
    (§ block
        (§ return (§ new #_"BtcAutoFormat" (§ pars locale, style, fractionPlaces)))
    )

    ;;;
     ; Return a new coin-denominated formatter.  The returned object will format and parse values
     ; according to the default locale, and will format numbers with two fractional decimal places,
     ; rounding values as necessary.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getCoinInstance) [])
    (§ block
        (§ return (§ expr getCoinInstance(§ pars defaultLocale(§ pars ))))
    )

    #_private
    #_static
    (§ method #_"List<Integer>" (§ fn boxAsList) [#_"int[]" (§ name elements)])
        (§ throws #_"IllegalArgumentException")
    (§ block
        (§ var #_"List<Integer>" (§ name list) (§ new #_"ArrayList<>" (§ pars elements.length)))
        (§ for (§ var #_"int" (§ name e)) :for elements)
        (§ block
            (§ expr Preconditions/checkArgument(§ pars 0 < e, "Size of decimal group must be at least one."))
            (§ expr list.add(§ pars e))
        )
        (§ return list)
    )

    ;;;
     ; Return a new coin-denominated formatter with the specified fraction-places.  The returned
     ; object will format and parse values according to the default locale, and will format the
     ; fraction part of numbers with at least two decimal places.  The sizes of additional groups
     ; of decimal places can be specified by a variable number of <code>int</code> arguments.
     ; Each optional decimal-place group will be applied only if useful for expressing precision,
     ; and will be only partially applied if necessary to avoid giving a place to fractional satoshis.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getCoinInstance) [#_"int" (§ name minFractionPlaces), #_"int..." (§ name groups)])
    (§ block
        (§ return (§ expr getInstance(§ pars COIN_SCALE, defaultLocale(§ pars ), minFractionPlaces, boxAsList(§ pars groups))))
    )

    ;;;
     ; Return a new coin-denominated formatter for the given locale.  The returned object will
     ; format the fractional part of numbers with two decimal places, rounding as necessary.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getCoinInstance) [#_"Locale" (§ name locale)])
    (§ block
        (§ return (§ expr getInstance(§ pars COIN_SCALE, locale, 2)))
    )

    ;;;
     ; Return a newly-constructed instance for the given locale that will format values in terms of bitcoins,
     ; with the given minimum number of fractional decimal places.  Optionally, repeating integer arguments
     ; can be passed, each indicating the size of an additional group of fractional decimal places to be used
     ; as necessary to avoid rounding, to a limiting precision of satoshis.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getCoinInstance) [#_"Locale" (§ name locale), #_"int" (§ name scale), #_"int..." (§ name groups)])
    (§ block
        (§ return (§ expr getInstance(§ pars COIN_SCALE, locale, scale, boxAsList(§ pars groups))))
    )

    ;;;
     ; Return a new millicoin-denominated formatter.  The returned object will format and parse values for
     ; the default locale, and will format the fractional part of numbers with two decimal places, rounding
     ; as necessary.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getMilliInstance) [])
    (§ block
        (§ return (§ expr getMilliInstance(§ pars defaultLocale(§ pars ))))
    )

    ;;;
     ; Return a new millicoin-denominated formatter for the given locale.  The returned object will
     ; format the fractional part of numbers with two decimal places, rounding as necessary.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getMilliInstance) [#_"Locale" (§ name locale)])
    (§ block
        (§ return (§ expr getInstance(§ pars MILLICOIN_SCALE, locale, 2)))
    )

    ;;;
     ; Return a new millicoin-denominated formatter with the specified fractional decimal placing.
     ; The returned object will format and parse values according to the default locale, and will format the
     ; fractional part of numbers with the given minimum number of fractional decimal places.  Optionally,
     ; repeating integer arguments can be passed, each indicating the size of an additional group of fractional
     ; decimal places to be used as necessary to avoid rounding, to a limiting precision of satoshis.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getMilliInstance) [#_"int" (§ name scale), #_"int..." (§ name groups)])
    (§ block
        (§ return (§ expr getInstance(§ pars MILLICOIN_SCALE, defaultLocale(§ pars ), scale, boxAsList(§ pars groups))))
    )

    ;;;
     ; Return a new millicoin-denominated formatter for the given locale with the specified fractional
     ; decimal placing.  The returned object will format the fractional part of numbers with the given
     ; minimum number of fractional decimal places.  Optionally, repeating integer arguments can be passed,
     ; each indicating the size of an additional group of fractional decimal places to be used as necessary
     ; to avoid rounding, to a limiting precision of satoshis.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getMilliInstance) [#_"Locale" (§ name locale), #_"int" (§ name scale), #_"int..." (§ name groups)])
    (§ block
        (§ return (§ expr getInstance(§ pars MILLICOIN_SCALE, locale, scale, boxAsList(§ pars groups))))
    )

    ;;;
     ; Return a new microcoin-denominated formatter for the default locale.  The returned object will
     ; format the fractional part of numbers with two decimal places, rounding as necessary.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getMicroInstance) [])
    (§ block
        (§ return (§ expr getMicroInstance(§ pars defaultLocale(§ pars ))))
    )

    ;;;
     ; Return a new microcoin-denominated formatter for the given locale.  The returned object will
     ; format the fractional part of numbers with two decimal places, rounding as necessary.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getMicroInstance) [#_"Locale" (§ name locale)])
    (§ block
        (§ return (§ expr getInstance(§ pars MICROCOIN_SCALE, locale)))
    )

    ;;;
     ; Return a new microcoin-denominated formatter with the specified fractional decimal placing.
     ; The returned object will format and parse values according to the default locale, and will format the
     ; fractional part of numbers with the given minimum number of fractional decimal places.  Optionally,
     ; repeating integer arguments can be passed, each indicating the size of an additional group of fractional
     ; decimal places to be used as necessary to avoid rounding, to a limiting precision of satoshis.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getMicroInstance) [#_"int" (§ name scale), #_"int..." (§ name groups)])
    (§ block
        (§ return (§ expr getInstance(§ pars MICROCOIN_SCALE, defaultLocale(§ pars ), scale, boxAsList(§ pars groups))))
    )

    ;;;
     ; Return a new microcoin-denominated formatter for the given locale with the specified fractional
     ; decimal placing.  The returned object will format the fractional part of numbers with the given
     ; minimum number of fractional decimal places.  Optionally, repeating integer arguments can be passed,
     ; each indicating the size of an additional group of fractional decimal places to be used as necessary
     ; to avoid rounding, to a limiting precision of satoshis.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getMicroInstance) [#_"Locale" (§ name locale), #_"int" (§ name scale), #_"int..." (§ name groups)])
    (§ block
        (§ return (§ expr getInstance(§ pars MICROCOIN_SCALE, locale, scale, boxAsList(§ pars groups))))
    )

    ;;;
     ; Return a new fixeed-denomination formatter with the specified fractional decimal placing.
     ; The first argument specifies the denomination as the size of the shift from coin-denomination
     ; in increasingly-precise decimal places.  The returned object will format and parse values according
     ; to the default locale, and will format the fractional part of numbers with the given minimum number
     ; of fractional decimal places.  Optionally, repeating integer arguments can be passed, each indicating
     ; the size of an additional group of fractional decimal places to be used as necessary to avoid rounding,
     ; to a limiting precision of satoshis.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getInstance) [#_"int" (§ name scale), #_"int" (§ name minDecimals), #_"int..." (§ name groups)])
    (§ block
        (§ return (§ expr getInstance(§ pars scale, defaultLocale(§ pars ), minDecimals, boxAsList(§ pars groups))))
    )

    ;;;
     ; Return a new fixeed-denomination formatter.  The argument specifies the denomination as the size of
     ; the shift from coin-denomination in increasingly-precise decimal places.  The returned object will
     ; format and parse values according to the default locale, and will format the fractional part of
     ; numbers with two decimal places, or fewer as necessary to avoid giving a place to fractional satoshis.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getInstance) [#_"int" (§ name scale)])
    (§ block
        (§ return (§ expr getInstance(§ pars scale, defaultLocale(§ pars ))))
    )

    ;;;
     ; Return a new fixeed-denomination formatter for the given locale.  The first argument specifies the
     ; denomination as the size of the shift from coin-denomination in increasingly-precise decimal places.
     ; The returned object will format and parse values according to the locale specified by the second
     ; argument, and will format the fractional part of numbers with two decimal places, or fewer as
     ; necessary to avoid giving a place to fractional satoshis.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getInstance) [#_"int" (§ name scale), #_"Locale" (§ name locale)])
    (§ block
        (§ return (§ expr getInstance(§ pars scale, locale, 2)))
    )

    ;;;
     ; Return a new fixed-denomination formatter for the given locale, with the specified fractional
     ; decimal placing.  The first argument specifies the denomination as the size of the shift from
     ; coin-denomination in increasingly-precise decimal places.  The third parameter is the minimum
     ; number of fractional decimal places to use, followed by optional repeating integer parameters
     ; each specifying the size of an additional group of fractional decimal places to use as
     ; necessary to avoid rounding, down to a maximum precision of satoshis.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getInstance) [#_"int" (§ name scale), #_"Locale" (§ name locale), #_"int" (§ name minDecimals), #_"int..." (§ name groups)])
    (§ block
        (§ return (§ expr getInstance(§ pars scale, locale, minDecimals, boxAsList(§ pars groups))))
    )

    ;;;
     ; Return a new fixed-denomination formatter for the given locale, with the specified fractional
     ; decimal placing.  The first argument specifies the denomination as the size of the shift from
     ; coin-denomination in increasingly-precise decimal places.  The third parameter is the minimum
     ; number of fractional decimal places to use.  The third argument specifies the minimum number of
     ; fractional decimal places in formatted numbers.  The last argument is a <code>List</code> of
     ; <code>Integer</code> values, each of which specifies the size of an additional group of fractional
     ; decimal places to use as necessary to avoid rounding, down to a maximum precision of satoshis.
     ;;
    #_public
    #_static
    (§ method #_"BtcFormat" (§ fn getInstance) [#_"int" (§ name scale), #_"Locale" (§ name locale), #_"int" (§ name minDecimals), #_"List<Integer>" (§ name groups)])
    (§ block
        (§ return (§ new #_"BtcFixedFormat" (§ pars locale, scale, minDecimals, groups)))
    )

    ;;;
     ; Formats a bitcoin monetary value and returns an {@link java.text.AttributedCharacterIterator}.
     ; By iterating, you can examine what fields apply to each character.  This can be useful since a character
     ; may be part of more than one field, for example a grouping separator that is also part of the integer field.
     ;
     ; @see java.text.AttributedCharacterIterator
     ;;
    #_override
    #_public
    (§ method #_"AttributedCharacterIterator" (§ fn formatToCharacterIterator) [#_"Object" (§ name obj)])
    (§ block
        (§ sync numberFormat)
        (§ block
            (§ var #_"DecimalFormatSymbols" (§ name anteSigns) (§ expr numberFormat.getDecimalFormatSymbols(§ pars )))
            (§ var #_"BigDecimal" (§ name units) (§ expr denominateAndRound(§ pars inSatoshis(§ pars obj), minimumFractionDigits, decimalGroups)))
            (§ var #_"List<Integer>" (§ name anteDigits) (§ expr setFormatterDigits(§ pars numberFormat, units.scale(§ pars ), units.scale(§ pars ))))
            (§ var #_"AttributedCharacterIterator" (§ name i) (§ expr numberFormat.formatToCharacterIterator(§ pars units)))
            (§ expr numberFormat.setDecimalFormatSymbols(§ pars anteSigns))
            (§ expr setFormatterDigits(§ pars numberFormat, anteDigits.get(§ pars 0), anteDigits.get(§ pars 1)))
            (§ return i)
        )
    )

    ;;;
     ; Formats a bitcoin value as a number and possibly a units indicator and appends the resulting text
     ; to the given string buffer.  The type of monetary value argument can be any one of any of the following
     ; classes: <code>{@link Coin}</code>, <code>Integer</code>, <code>Long</code>, <code>BigInteger</code>,
     ; <code>BigDecimal</code>.  Numeric types that can represent only an integer are interpreted as that
     ; number of satoshis.  The value of a <code>BigDecimal</code> is interpreted as that number of bitcoins,
     ; rounded to the nearest satoshi as necessary.
     ;
     ; @return the <code>StringBuffer</code> passed in as <code>toAppendTo</code>.
     ;;
    #_override
    #_public
    (§ method #_"StringBuffer" (§ fn format) [#_"Object" (§ name qty), #_"StringBuffer" (§ name toAppendTo), #_"FieldPosition" (§ name pos)])
    (§ block
        (§ return (§ expr format(§ pars qty, toAppendTo, pos, minimumFractionDigits, decimalGroups)))
    )

    ;;;
     ; Formats a bitcoin value as a number and possibly a units indicator to a <code>String</code>.
     ; The type of monetary value argument can be any one of any of the following classes:
     ; <code>{@link Coin}</code>, <code>Integer</code>, <code>Long</code>, <code>BigInteger</code>,
     ; <code>BigDecimal</code>.  Numeric types that can represent only an integer are interpreted
     ; as that number of satoshis.  The value of a <code>BigDecimal</code> is interpreted as that
     ; number of bitcoins, rounded to the nearest satoshi as necessary.
     ;
     ; @param minDecimals The minimum number of decimal places in the fractional part of the formatted number.
     ; @param fractionGroups The sizes of optional additional fractional decimal-place groups.
     ; @throws IllegalArgumentException if the number of fraction places is negative.
     ;;
    #_public
    (§ method #_"String" (§ fn format) [#_"Object" (§ name qty), #_"int" (§ name minDecimals), #_"int..." (§ name fractionGroups)])
    (§ block
        (§ return (§ expr format(§ pars qty, new StringBuffer(§ pars ), new FieldPosition(§ pars 0), minDecimals, boxAsList(§ pars fractionGroups)).toString(§ pars )))
    )

    ;;;
     ; Formats a bitcoin value as a number and possibly a units indicator and appends the resulting
     ; text to the given string buffer.  The type of monetary value argument can be any one of any of
     ; the following classes: <code>{@link Coin}</code>, <code>Integer</code>, <code>Long</code>,
     ; <code>BigInteger</code>, <code>BigDecimal</code>.  Numeric types that can represent only an
     ; integer are interpreted as that number of satoshis.  The value of a <code>BigDecimal</code> is
     ; interpreted as that number of bitcoins, rounded to the nearest satoshi as necessary.
     ;
     ; @param minDecimals The minimum number of decimal places in the fractional part of the formatted number.
     ; @param fractionGroups The sizes of optional additional fractional decimal-place groups.
     ; @throws IllegalArgumentException if the number of fraction places is negative.
     ;;
    #_public
    (§ method #_"StringBuffer" (§ fn format) [#_"Object" (§ name qty), #_"StringBuffer" (§ name toAppendTo), #_"FieldPosition" (§ name pos), #_"int" (§ name minDecimals), #_"int..." (§ name fractionGroups)])
    (§ block
        (§ return (§ expr format(§ pars qty, toAppendTo, pos, minDecimals, boxAsList(§ pars fractionGroups))))
    )

    #_private
    (§ method #_"StringBuffer" (§ fn format) [#_"Object" (§ name qty), #_"StringBuffer" (§ name toAppendTo), #_"FieldPosition" (§ name pos), #_"int" (§ name minDecimals), #_"List<Integer>" (§ name fractionGroups)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars 0 <= minDecimals, "There can be no fewer than zero fractional decimal places"))

        (§ sync numberFormat)
        (§ block
            (§ var #_"DecimalFormatSymbols" (§ name anteSigns) (§ expr numberFormat.getDecimalFormatSymbols(§ pars )))
            (§ var #_"BigDecimal" (§ name denominatedUnitCount) (§ expr denominateAndRound(§ pars inSatoshis(§ pars qty), minDecimals, fractionGroups)))
            (§ var #_"List<Integer>" (§ name antePlaces) (§ expr setFormatterDigits(§ pars numberFormat, denominatedUnitCount.scale(§ pars ), denominatedUnitCount.scale(§ pars ))))
            (§ var #_"StringBuffer" (§ name s) (§ expr numberFormat.format(§ pars denominatedUnitCount, toAppendTo, pos)))
            (§ expr numberFormat.setDecimalFormatSymbols(§ pars anteSigns))
            (§ expr setFormatterDigits(§ pars numberFormat, antePlaces.get(§ pars 0), antePlaces.get(§ pars 1)))
            (§ return s)
        )
    )

    ;;;
     ; Return the denomination for formatting the given value.  The returned <code>int</code> is the size
     ; of the decimal-place shift between the given Bitcoin-value denominated in bitcoins and that same value
     ; as formatted.  A fixed-denomination formatter will ignore the arguments.
     ;
     ; @param satoshis The number of satoshis having the value for which the shift is calculated.
     ; @param fractionPlaces The number of decimal places available for displaying the fractional part of the denominated value.
     ; @return the size of the shift in increasingly-precise decimal places.
     ;;
    #_protected
    #_abstract
    (§ method #_"int" (§ fn scale) [#_"BigInteger" (§ name satoshis), #_"int" (§ name fractionPlaces)])

    ;;;
     ; Return the denomination of this object.  Fixed-denomination formatters will override with their configured
     ; denomination, auto-formatters with coin denomination.  This determines the interpretation of parsed numbers
     ; lacking a units-indicator.
     ;;
    #_protected
    #_abstract
    (§ method #_"int" (§ fn scale) [])

    ;;;
     ; Takes a bitcoin monetary value that the client wants to format and returns the number of denominational units
     ; having the equal value, rounded to the appropriate number of decimal places.  Calls the scale() method of the
     ; subclass, which may have the side-effect of changing the currency symbol and code of the underlying `NumberFormat`
     ; object, therefore only invoke this from a synchronized method that resets the NumberFormat.
     ;;
    #_private
    (§ method #_"BigDecimal" (§ fn denominateAndRound) [#_"BigInteger" (§ name satoshis), #_"int" (§ name minDecimals), #_"List<Integer>" (§ name fractionGroups)])
    (§ block
        (§ var #_"int" (§ name scale) (§ expr scale(§ pars satoshis, minDecimals)))
        (§ var #_"BigDecimal" (§ name denominatedUnitCount) (§ expr (§ new #_"BigDecimal" (§ pars satoshis)).movePointLeft(§ pars offSatoshis(§ pars scale))))
        (§ var #_"int" (§ name places) (§ expr calculateFractionPlaces(§ pars denominatedUnitCount, scale, minDecimals, fractionGroups)))
        (§ return (§ expr denominatedUnitCount.setScale(§ pars places, HALF_UP)))
    )

    ;;;
     ; Sets the number of fractional decimal places to be displayed on the given NumberFormat object to the value
     ; of the given integer.
     ; @return the minimum and maximum fractional places settings that the formatter had before this change,
     ; as an ImmutableList.
     ;;
    #_private
    #_static
    (§ method #_"ImmutableList<Integer>" (§ fn setFormatterDigits) [#_"DecimalFormat" (§ name formatter), #_"int" (§ name min), #_"int" (§ name max)])
    (§ block
        (§ var #_"ImmutableList<Integer>" (§ name ante) (§ expr ImmutableList/of(§ pars formatter.getMinimumFractionDigits(§ pars ), formatter.getMaximumFractionDigits(§ pars ))))
        (§ expr formatter.setMinimumFractionDigits(§ pars min))
        (§ expr formatter.setMaximumFractionDigits(§ pars max))
        (§ return ante)
    )

    ;;;
     ; Return the number of fractional decimal places to be displayed when formatting the given number of monetory
     ; units of the denomination indicated by the given decimal scale value, where 0 = coin, 3 = millicoin, and so on.
     ;
     ; @param unitCount      The number of monetary units to be formatted.
     ; @param scale          The denomination of those units as the decimal-place shift from coins.
     ; @param minDecimals    The minimum number of fractional decimal places.
     ; @param fractionGroups The sizes of option fractional decimal-place groups.
     ;;
    #_private
    #_static
    (§ method #_"int" (§ fn calculateFractionPlaces) [#_"BigDecimal" (§ name unitCount), #_"int" (§ name scale), #_"int" (§ name minDecimals), #_"List<Integer>" (§ name fractionGroups)])
    (§ block
        ;; Taking into account BOTH the user's preference for decimal-place groups, AND the prohibition against displaying
         ; a fractional number of satoshis, determine the maximum possible number of fractional decimal places.
         ;;
        (§ var #_"int" (§ name places) minDecimals)
        (§ for (§ var #_"int" (§ name group)) :for fractionGroups)
        (§ block
            (§ ass (§ name places) (§ expr places + group))
        )
        (§ var #_"int" (§ name max) (§ expr Math/min(§ pars places, offSatoshis(§ pars scale))))

        (§ ass (§ name places) (§ expr Math/min(§ pars minDecimals, max)))
        (§ for (§ var #_"int" (§ name group)) :for fractionGroups)
        (§ block
            ;; Compare the value formatted using only this many decimal places to the same value using as many places
             ; as possible.  If there's no difference, then there's no reason to continue adding more places.
             ;;
            (§ if (§ expr unitCount.setScale(§ pars places, HALF_UP).compareTo(§ pars unitCount.setScale(§ pars max, HALF_UP)) == 0))
            (§ block
                (§ break )
            )
            (§ ass (§ name places) (§ expr places + group))
            (§ if (§ expr max < places))
            (§ block
                (§ ass (§ name places) max)
            )
        )
        (§ return places)
    )

    ;;;
     ; Takes an object representing a bitcoin quantity of any type the client is permitted to pass us, and return
     ; a BigInteger representing the number of satoshis having the equivalent value.
     ;;
    #_private
    #_static
    (§ method #_"BigInteger" (§ fn inSatoshis) [#_"Object" (§ name qty)])
    (§ block
        ;; The value might be bitcoins or satoshis.
        (§ if (§ expr (§ insta qty #_"Long") || (§ insta qty #_"Integer")))
        (§ block
            (§ return (§ expr BigInteger/valueOf(§ pars (§ expr (§ cast #_"Number" qty)).longValue(§ pars ))))
        )
        (§ if (§ insta qty #_"BigInteger"))
        (§ block
            (§ return (§ cast #_"BigInteger" qty))
        )
        (§ if (§ insta qty #_"BigDecimal"))
        (§ block
            (§ return (§ expr (§ expr (§ cast #_"BigDecimal" qty)).movePointRight(§ pars Coin/SMALLEST_UNIT_EXPONENT).setScale(§ pars 0, BigDecimal/ROUND_HALF_UP).unscaledValue(§ pars )))
        )
        (§ if (§ insta qty #_"Coin"))
        (§ block
            (§ return (§ expr BigInteger/valueOf(§ pars (§ expr (§ cast #_"Coin" qty)).value)))
        )

        (§ throw (§ new #_"IllegalArgumentException" (§ pars "Cannot format a " + qty.getClass(§ pars ).getSimpleName(§ pars ) + " as a Bicoin value")))
    )

    ;;;
     ; Parse a <code>String</code> representation of a Bitcoin monetary value.
     ; Returns a {@link org.bitcoinj.core.Coin} object that represents the parsed value.
     ; @see java.text.NumberFormat
     ;;
    #_override
    #_public
    #_final
    (§ method #_"Object" (§ fn parseObject) [#_"String" (§ name source), #_"ParsePosition" (§ name pos)])
    (§ block
        (§ return (§ expr parse(§ pars source, pos)))
    )

    #_private
    (§ class #_"ScaleMatcher"
        #_public
        (§ field #_"Pattern" (§ name pattern))
        #_public
        (§ field #_"int" (§ name scale))

        (§ constructor #_"ScaleMatcher" [#_"Pattern" (§ name p), #_"int" (§ name s)])
        (§ block
            (§ ass (§ name pattern) p)
            (§ ass (§ name scale) s)
            (§ void this)
        )
    )

    ;; Lazy initialization.  No reason to create all these objects unless needed for parsing.
    ;; Coin indicator regex String.  TODO: does this need to be volatile?
    #_private
    #_volatile
    (§ field #_"String" (§ name ci) (§ expr "(" + COIN_SYMBOL + "|" + COIN_SYMBOL_ALT + "|B⃦|" + COIN_CODE + "|XBT)"))
    #_private
    (§ field #_"Pattern" (§ name coinPattern))
    #_private
    #_volatile
    (§ field #_"ScaleMatcher[]" (§ name denoms))
    (§ method #_"ScaleMatcher[]" (§ fn denomMatchers) [])
    (§ block
        (§ var #_"ScaleMatcher[]" (§ name result) denoms)
        (§ if (§ expr result == nil))
        (§ block
            (§ sync this)
            (§ block
                (§ ass (§ name result) denoms)
                (§ if (§ expr result == nil))
                (§ block
                    (§ if (§ not (§ dot coinSymbol(§ pars ).matches(§ pars ci))))
                    (§ block
                        (§ ass (§ name ci) (§ expr ci.replaceFirst(§ pars "\\(", "(" + coinSymbol(§ pars ) + "|")))
                    )
                    (§ if (§ not (§ dot coinCode(§ pars ).matches(§ pars ci))))
                    (§ block
                        (§ ass (§ name ci) (§ expr ci.replaceFirst(§ pars "\\)", "|" + coinCode(§ pars ) + ")")))
                    )
                    (§ ass (§ name coinPattern) (§ expr Pattern/compile(§ pars ci + "?")))
                    (§ ass (§ name result) (§ ass (§ name denoms) (§ new #_"ScaleMatcher[]"
                    (§ coll
                        (§ new #_"ScaleMatcher" (§ pars Pattern/compile(§ pars "¢" + ci + "?|c" + ci), 2)) ;; centi
                        (§ new #_"ScaleMatcher" (§ pars Pattern/compile(§ pars "₥" + ci + "?|m" + ci), MILLICOIN_SCALE))
                        (§ new #_"ScaleMatcher" (§ pars Pattern/compile(§ pars "([µu]" + ci + ")"),    MICROCOIN_SCALE))
                        (§ new #_"ScaleMatcher" (§ pars Pattern/compile(§ pars "(da" + ci + ")"),     -1)) ;; deka
                        (§ new #_"ScaleMatcher" (§ pars Pattern/compile(§ pars "(h" + ci + ")"),      -2)) ;; hekto
                        (§ new #_"ScaleMatcher" (§ pars Pattern/compile(§ pars "(k" + ci + ")"),      -3)) ;; kilo
                        (§ new #_"ScaleMatcher" (§ pars Pattern/compile(§ pars "(M" + ci + ")"),      -6)) ;; mega
                    ))))
                )
            )
        )
        (§ return result)
    )

    ;;;
     ; Set both the currency symbol and international code of the underlying {@link java.text.NumberFormat} object
     ; to the value of the given <code>String</code>.
     ; This method is invoked in the process of parsing, not formatting.
     ;
     ; Only invoke this from code synchronized on the value of the first argument, and don't forget
     ; to put the symbols back otherwise equals(), hashCode() and immutability will break.
     ;;
    #_private
    #_static
    (§ method #_"DecimalFormatSymbols" (§ fn setSymbolAndCode) [#_"DecimalFormat" (§ name numberFormat), #_"String" (§ name sign)])
    (§ block
        (§ return (§ expr setSymbolAndCode(§ pars numberFormat, sign, sign)))
    )

    ;;;
     ; Set the currency symbol and international code of the underlying {@link java.text.NumberFormat} object
     ; to the values of the last two arguments, respectively.
     ; This method is invoked in the process of parsing, not formatting.
     ;
     ; Only invoke this from code synchronized on value of the first argument, and don't forget
     ; to put the symbols back otherwise equals(), hashCode() and immutability will break.
     ;;
    #_private
    #_static
    (§ method #_"DecimalFormatSymbols" (§ fn setSymbolAndCode) [#_"DecimalFormat" (§ name numberFormat), #_"String" (§ name symbol), #_"String" (§ name code)])
    (§ block
        (§ expr Preconditions/checkState(§ pars Thread/holdsLock(§ pars numberFormat)))

        (§ var #_"DecimalFormatSymbols" (§ name fs) (§ expr numberFormat.getDecimalFormatSymbols(§ pars )))
        (§ var #_"DecimalFormatSymbols" (§ name ante) (§ expr (§ cast #_"DecimalFormatSymbols" (§ expr fs.clone(§ pars )))))
        (§ expr fs.setInternationalCurrencySymbol(§ pars code))
        (§ expr fs.setCurrencySymbol(§ pars symbol))
        (§ expr numberFormat.setDecimalFormatSymbols(§ pars fs))
        (§ return ante)
    )

    ;;;
     ; Set both the currency symbol and code of the underlying, mutable NumberFormat object according to
     ; the given denominational units scale factor.  This is for formatting, not parsing.
     ;
     ; Set back to zero when you're done formatting otherwise immutability, equals() and hashCode() will break!
     ;
     ; @param scale Number of places the decimal point will be shifted when formatting a quantity of satoshis.
     ; @return the DecimalFormatSymbols before changing.
     ;;
    #_protected
    #_static
    (§ method #_"void" (§ fn prefixUnitsIndicator) [#_"DecimalFormat" (§ name numberFormat), #_"int" (§ name scale)])
    (§ block
        ;; Make sure caller intends to reset before changing.
        (§ expr Preconditions/checkState(§ pars Thread/holdsLock(§ pars numberFormat)))

        (§ var #_"DecimalFormatSymbols" (§ name fs) (§ expr numberFormat.getDecimalFormatSymbols(§ pars )))
        (§ expr setSymbolAndCode(§ pars numberFormat, prefixSymbol(§ pars fs.getCurrencySymbol(§ pars ), scale), prefixCode(§ pars fs.getInternationalCurrencySymbol(§ pars ), scale)))
        (§ void nil)
    )

    ;;;
     ; Parse a <code>String</code> representation of a Bitcoin monetary value.  If this object's pattern includes
     ; a currency sign, either symbol or code, as by default is true for instances of {@link BtcAutoFormat} and
     ; false for instances of {@link BtcFixedFormat}, then denominated (i.e. prefixed) currency signs in the parsed
     ; String will be recognized, and the parsed number will be interpreted as a quantity of units having that
     ; recognized denomination.
     ;
     ; If the pattern includes a currency sign but no currency sign is detected in the parsed String,
     ; then the number is interpreted as a quatity of bitcoins.
     ;
     ; If the pattern contains neither a currency symbol nor sign, then instances of {@link BtcAutoFormat} will
     ; interpret the parsed number as a quantity of bitcoins, and instances of {@link BtcAutoFormat} will interpret
     ; the number as a quantity of that instance's configured denomination, which can be ascertained by invoking
     ; the {@link BtcFixedFormat#symbol()} or {@link BtcFixedFormat#code()} method.
     ;
     ; Consider using the single-argument version of this overloaded method unless you need to keep track
     ; of the current parse position.
     ;
     ; @return a Coin object representing the parsed value.
     ; @see java.text.ParsePosition
     ;;
    #_public
    (§ method #_"Coin" (§ fn parse) [#_"String" (§ name source), #_"ParsePosition" (§ name pos)])
    (§ block
        (§ var #_"DecimalFormatSymbols" (§ name anteSigns) nil)
        (§ var #_"int" (§ name parseScale) (§ expr COIN_SCALE)) ;; default
        (§ var #_"Coin" (§ name coin) nil)
        (§ sync numberFormat)
        (§ block
            (§ if (§ expr numberFormat.toPattern(§ pars ).contains(§ pars "¤")))
            (§ block
                (§ for (§ var #_"ScaleMatcher" (§ name d)) :for (§ expr denomMatchers(§ pars )))
                (§ block
                    (§ var #_"Matcher" (§ name matcher) (§ expr d.pattern.matcher(§ pars source)))
                    (§ if (§ expr matcher.find(§ pars )))
                    (§ block
                        (§ ass (§ name anteSigns) (§ expr setSymbolAndCode(§ pars numberFormat, matcher.group(§ pars ))))
                        (§ ass (§ name parseScale) (§ expr d.scale))
                        (§ break )
                    )
                )
                (§ if (§ expr parseScale == COIN_SCALE))
                (§ block
                    (§ var #_"Matcher" (§ name matcher) (§ expr coinPattern.matcher(§ pars source)))
                    (§ expr matcher.find(§ pars ))
                    (§ ass (§ name anteSigns) (§ expr setSymbolAndCode(§ pars numberFormat, matcher.group(§ pars ))))
                )
            )
            (§ else )
            (§ block
                (§ ass (§ name parseScale) (§ expr scale(§ pars )))
            )

            (§ var #_"Number" (§ name number) (§ expr numberFormat.parse(§ pars source, pos)))
            (§ if (§ expr number != nil))
            (§ block
                (§ try )
                (§ block
                    (§ ass (§ name coin) (§ expr Coin/valueOf(§ pars (§ expr (§ cast #_"BigDecimal" number)).movePointRight(§ pars offSatoshis(§ pars parseScale)).setScale(§ pars 0, HALF_UP).longValue(§ pars ))))
                )
                (§ catch #_"IllegalArgumentException" (§ name _))
                (§ block
                    (§ expr pos.setIndex(§ pars 0))
                )
            )
            (§ if (§ expr anteSigns != nil))
            (§ block
                (§ expr numberFormat.setDecimalFormatSymbols(§ pars anteSigns))
            )
        )
        (§ return coin)
    )

    ;;; Parse a <code>String</code> representation of a Bitcoin monetary value.  If this object's pattern includes
     ; a currency sign, either symbol or code, as by default is true for instances of {@link BtcAutoFormat} and
     ; false for instances of {@link BtcFixedFormat}, then denominated (i.e. prefixed) currency signs in the parsed
     ; String will be recognized, and the parsed number will be interpreted as a quantity of units having that
     ; recognized denomination.
     ;
     ; If the pattern includes a currency sign but no currency sign is detected in the parsed String,
     ; then the number is interpreted as a quatity of bitcoins.
     ;
     ; If the pattern contains neither a currency symbol nor sign, then instances of {@link BtcAutoFormat} will
     ; interpret the parsed number as a quantity of bitcoins, and instances of {@link BtcAutoFormat} will interpret
     ; the number as a quantity of that instance's configured denomination, which can be ascertained by invoking
     ; the {@link BtcFixedFormat#symbol()} or {@link BtcFixedFormat#code()} method.
     ;
     ; @return a Coin object representing the parsed value.
     ;;
    #_public
    (§ method #_"Coin" (§ fn parse) [#_"String" (§ name source)])
        (§ throws #_"ParseException")
    (§ block
        (§ return (§ cast #_"Coin" (§ expr parseObject(§ pars source))))
    )

    #_protected
    #_static
    (§ method #_"String" (§ fn prefixCode) [#_"String" (§ name code), #_"int" (§ name scale)])
    (§ block
        (§ switch scale)
        (§ block
            (§ case COIN_SCALE)
            (§ block
                (§ return code)
            )
            (§ case 1)
            (§ block
                (§ return (§ expr "d" + code))
            )
            (§ case 2)
            (§ block
                (§ return (§ expr "c" + code))
            )
            (§ case MILLICOIN_SCALE)
            (§ block
                (§ return (§ expr "m" + code))
            )
            (§ case MICROCOIN_SCALE)
            (§ block
                (§ return (§ expr "µ" + code))
            )
            (§ case -1)
            (§ block
                (§ return (§ expr "da" + code))
            )
            (§ case -2)
            (§ block
                (§ return (§ expr "h" + code))
            )
            (§ case -3)
            (§ block
                (§ return (§ expr "k" + code))
            )
            (§ case -6)
            (§ block
                (§ return (§ expr "M" + code))
            )
            (§ default )
            (§ block
                (§ throw (§ new #_"IllegalStateException" (§ pars "No known prefix for scale " + String/valueOf(§ pars scale))))
            )
        )
    )

    #_protected
    #_static
    (§ method #_"String" (§ fn prefixSymbol) [#_"String" (§ name symbol), #_"int" (§ name scale)])
    (§ block
        (§ switch scale)
        (§ block
            (§ case COIN_SCALE)
            (§ block
                (§ return symbol)
            )
            (§ case 1)
            (§ block
                (§ return (§ expr "d" + symbol))
            )
            (§ case 2)
            (§ block
                (§ return (§ expr "¢" + symbol))
            )
            (§ case MILLICOIN_SCALE)
            (§ block
                (§ return (§ expr "₥" + symbol))
            )
            (§ case MICROCOIN_SCALE)
            (§ block
                (§ return (§ expr "µ" + symbol))
            )
            (§ case -1)
            (§ block
                (§ return (§ expr "da" + symbol))
            )
            (§ case -2)
            (§ block
                (§ return (§ expr "h" + symbol))
            )
            (§ case -3)
            (§ block
                (§ return (§ expr "k" + symbol))
            )
            (§ case -6)
            (§ block
                (§ return (§ expr "M" + symbol))
            )
            (§ default )
            (§ block
                (§ throw (§ new #_"IllegalStateException" (§ pars "No known prefix for scale " + String/valueOf(§ pars scale))))
            )
        )
    )

    ;;;
     ; Guarantee a formatting pattern has a subpattern for negative values.  This method takes
     ; a pattern that may be missing a negative subpattern, and returns the same pattern with
     ; a negative subpattern appended as needed.
     ;
     ; This method accommodates an imperfection in the Java formatting code and distributed
     ; locale data.  To wit: the subpattern for negative numbers is optional and not all
     ; locales have one.  In those cases, {@link java.text.DecimalFormat} will indicate numbers
     ; less than zero by adding a negative sign as the first character of the prefix of the
     ; positive subpattern.
     ;
     ; We don't like this, since we claim the negative sign applies to the number not the
     ; units, and therefore it ought to be adjacent to the number, displacing the
     ; currency-units indicator if necessary.
     ;;
    #_protected
    #_static
    (§ method #_"String" (§ fn negify) [#_"String" (§ name pattern)])
    (§ block
        (§ if (§ expr pattern.contains(§ pars ";")))
        (§ block
            (§ return pattern)
        )

        (§ if (§ expr pattern.contains(§ pars "-")))
        (§ block
            (§ throw (§ new #_"IllegalStateException" (§ pars "Positive pattern contains negative sign")))
        )

        ;; The regex matches everything until the first non-quoted number character.
        (§ return (§ expr pattern + ";" + pattern.replaceFirst(§ pars "^([^#0,.']*('[^']*')?)*", "$0-")))
    )

    ;;;
     ; Return an array of all locales for which the getInstance() method of this class can
     ; return localized instances.  See {@link java.text.NumberFormat#getAvailableLocales()}.
     ;;
    #_public
    #_static
    (§ method #_"Locale[]" (§ fn getAvailableLocales) [])
    (§ block
        (§ return (§ expr NumberFormat/getAvailableLocales(§ pars )))
    )

    ;;;
     ; Return the unprefixed currency symbol for bitcoins configured for this object.
     ; The return value of this method is constant throughough the life of an instance.
     ;;
    #_public
    (§ method #_"String" (§ fn coinSymbol) [])
    (§ block
        (§ sync numberFormat)
        (§ block
            (§ return (§ expr numberFormat.getDecimalFormatSymbols(§ pars ).getCurrencySymbol(§ pars )))
        )
    )

    ;;;
     ; Return the unprefixed international currency code for bitcoins configured for this object.
     ; The return value of this method is constant throughough the life of an instance.
     ;;
    #_public
    (§ method #_"String" (§ fn coinCode) [])
    (§ block
        (§ sync numberFormat)
        (§ block
            (§ return (§ expr numberFormat.getDecimalFormatSymbols(§ pars ).getInternationalCurrencySymbol(§ pars )))
        )
    )

    ;;;
     ; Return a representation of the pattern used by this instance for formatting and parsing.
     ; The format is similar to, but not the same as the format recognized by the {@link Builder#pattern}
     ; and {@link Builder#localizedPattern} methods.  The pattern returned by this method is localized,
     ; any currency signs expressed are literally, and optional fractional decimal places are shown
     ; grouped in parentheses.
     ;;
    #_public
    (§ method #_"String" (§ fn pattern) [])
    (§ block
        (§ sync numberFormat)
        (§ block
            (§ var #_"StringBuilder" (§ name groups) (§ new #_"StringBuilder" (§ pars )))
            (§ for (§ var #_"int" (§ name group)) :for decimalGroups)
            (§ block
                (§ expr groups.append(§ pars "(").append(§ pars Strings/repeat(§ pars "#", group)).append(§ pars ")"))
            )

            (§ var #_"DecimalFormatSymbols" (§ name s) (§ expr numberFormat.getDecimalFormatSymbols(§ pars )))
            (§ var #_"String" (§ name digit) (§ expr String/valueOf(§ pars s.getDigit(§ pars ))))
            (§ var #_"String" (§ name exp) (§ expr s.getExponentSeparator(§ pars )))
            (§ var #_"String" (§ name groupSep) (§ expr String/valueOf(§ pars s.getGroupingSeparator(§ pars ))))
            (§ var #_"String" (§ name moneySep) (§ expr String/valueOf(§ pars s.getMonetaryDecimalSeparator(§ pars ))))
            (§ var #_"String" (§ name zero) (§ expr String/valueOf(§ pars s.getZeroDigit(§ pars ))))
            (§ var #_"String" (§ name boundary) (§ expr String/valueOf(§ pars s.getPatternSeparator(§ pars ))))
            (§ var #_"String" (§ name minus) (§ expr String/valueOf(§ pars s.getMinusSign(§ pars ))))
            (§ var #_"String" (§ name decSep) (§ expr String/valueOf(§ pars s.getDecimalSeparator(§ pars ))))

            (§ var #_"String" (§ name prefixAndNumber) (§ expr "(^|" + boundary + ")" + "([^" + Matcher/quoteReplacement(§ pars digit + zero + groupSep + decSep + moneySep) + "']*('[^']*')?)*" + "[" + Matcher/quoteReplacement(§ pars digit + zero + groupSep + decSep + moneySep + exp) + "]+"))

            (§ return (§ expr numberFormat.toLocalizedPattern(§ pars ).replaceAll(§ pars prefixAndNumber, "$0" + groups).replaceAll(§ pars "¤¤", Matcher/quoteReplacement(§ pars coinCode(§ pars ))).replaceAll(§ pars "¤", Matcher/quoteReplacement(§ pars coinSymbol(§ pars )))))
        )
    )

    ;;; Return a copy of the localized symbols used by this instance for formatting and parsing. ;;
    #_public
    (§ method #_"DecimalFormatSymbols" (§ fn symbols) [])
    (§ block
        (§ sync numberFormat)
        (§ block
            (§ return (§ expr numberFormat.getDecimalFormatSymbols(§ pars )))
        )
    )

    ;;;
     ; Return true if the given object is equivalent to this one.
     ; Formatters for different locales will never be equal, even if they behave identically.
     ;;
    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr o == this))
        (§ block
            (§ return true)
        )
        (§ if (§ expr (§ not (§ insta o #_"BtcFormat"))))
        (§ block
            (§ return false)
        )
        (§ var #_"BtcFormat" (§ name other) (§ expr (§ cast #_"BtcFormat" o)))
        (§ return (§ expr other.pattern(§ pars ).equals(§ pars pattern(§ pars )) && other.symbols(§ pars ).equals(§ pars symbols(§ pars )) && other.minimumFractionDigits == minimumFractionDigits))
    )

    ;;;
     ; Return a hash code value for this instance.
     ; @see java.lang.Object#hashCode
     ;;
    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars pattern(§ pars ), symbols(§ pars ), minimumFractionDigits, decimalGroups)))
    )
)

#_(ns org.bitcoinj.utils #_"ContextPropagatingThreadFactory"
    (:import [java.util.concurrent *])
    (:import [com.google.common.base *]
             [org.slf4j *])
   (:require [org.bitcoinj.core *]))

;;;
 ; A {@link java.util.concurrent.ThreadFactory} that propagates a {@link org.bitcoinj.core.Context}
 ; from the creating thread into the new thread.  This factory creates daemon threads.
 ;;
#_public
(§ class #_"ContextPropagatingThreadFactory" (§ implements #_"ThreadFactory")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"ContextPropagatingThreadFactory"))))

    #_private
    #_final
    (§ field #_"String" (§ name name))
    #_private
    #_final
    (§ field #_"int" (§ name priority))

    #_public
    (§ constructor #_"ContextPropagatingThreadFactory" [#_"String" (§ name name), #_"int" (§ name priority)])
    (§ block
        (§ ass (§ name this.name) name)
        (§ ass (§ name this.priority) priority)
        (§ void this)
    )

    #_public
    (§ constructor #_"ContextPropagatingThreadFactory" [#_"String" (§ name name)])
    (§ block
        (§ this (§ pars name, Thread/NORM_PRIORITY))
        (§ void this)
    )

    #_override
    #_public
    (§ method #_"Thread" (§ fn newThread) [#_final #_"Runnable" (§ name r)])
    (§ block
        #_final
        (§ var #_"Context" (§ name context) (§ expr Context/get(§ pars )))
        (§ var #_"Thread" (§ name thread) (§ new #_"Thread" (§ pars (§ new #_"Runnable" (§ pars ))
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn run) [])
            (§ block
                (§ try )
                (§ block
                    (§ expr Context/propagate(§ pars context))
                    (§ expr r.run(§ pars ))
                )
                (§ catch #_"Exception" (§ name e))
                (§ block
                    (§ expr log.error(§ pars "Exception in thread", e))
                    (§ expr Throwables/propagate(§ pars e))
                )
                (§ void nil)
            )
        ), name)))
        (§ expr thread.setPriority(§ pars priority))
        (§ expr thread.setDaemon(§ pars true))
        (§ var #_"Thread.UncaughtExceptionHandler" (§ name handler) (§ expr Threading.uncaughtExceptionHandler))
        (§ if (§ expr handler != nil))
        (§ block
            (§ expr thread.setUncaughtExceptionHandler(§ pars handler))
        )
        (§ return thread)
    )
)

#_(ns org.bitcoinj.utils #_"DaemonThreadFactory"
    (:import [java.util.concurrent Executors ThreadFactory]))

;;; Thread factory whose threads are marked as daemon and won't prevent process exit. ;;
#_public
(§ class #_"DaemonThreadFactory" (§ implements #_"ThreadFactory")
    #_nilable
    #_private
    #_final
    (§ field #_"String" (§ name name))

    #_public
    (§ constructor #_"DaemonThreadFactory" [#_nilable #_"String" (§ name name)])
    (§ block
        (§ ass (§ name this.name) name)
        (§ void this)
    )

    #_public
    (§ constructor #_"DaemonThreadFactory" [])
    (§ block
        (§ this (§ pars nil))
        (§ void this)
    )

    #_override
    #_public
    (§ method #_"Thread" (§ fn newThread) [#_non-nil #_"Runnable" (§ name runnable)])
    (§ block
        (§ var #_"Thread" (§ name thread) (§ expr Executors/defaultThreadFactory(§ pars ).newThread(§ pars runnable)))
        (§ expr thread.setDaemon(§ pars true))
        (§ if (§ expr name != nil))
        (§ block
            (§ expr thread.setName(§ pars name))
        )
        (§ return thread)
    )
)

#_(ns org.bitcoinj.utils #_"ExchangeRate"
    (:import [java.io Serializable]
             [java.math BigInteger])
    (:import [com.google.common.base Objects Preconditions])
   (:require [org.bitcoinj.core Coin]))

;;;
 ; An exchange rate is expressed as a ratio of a {@link Coin} and a {@link Fiat} amount.
 ;;
#_public
(§ class #_"ExchangeRate" (§ implements #_"Serializable")
    #_public
    #_final
    (§ field #_"Coin" (§ name coin))
    #_public
    #_final
    (§ field #_"Fiat" (§ name fiat))

    ;;; Construct exchange rate.  This amount of coin is worth that amount of fiat. ;;
    #_public
    (§ constructor #_"ExchangeRate" [#_"Coin" (§ name coin), #_"Fiat" (§ name fiat)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars coin.isPositive(§ pars )))
        (§ expr Preconditions/checkArgument(§ pars fiat.isPositive(§ pars )))
        (§ expr Preconditions/checkArgument(§ pars fiat.currencyCode != nil, "currency code required"))

        (§ ass (§ name this.coin) coin)
        (§ ass (§ name this.fiat) fiat)
        (§ void this)
    )

    ;;; Construct exchange rate.  One coin is worth this amount of fiat. ;;
    #_public
    (§ constructor #_"ExchangeRate" [#_"Fiat" (§ name fiat)])
    (§ block
        (§ this (§ pars Coin/COIN, fiat))
        (§ void this)
    )

    ;;;
     ; Convert a coin amount to a fiat amount using this exchange rate.
     ; @throws ArithmeticException if the converted fiat amount is too high or too low.
     ;;
    #_public
    (§ method #_"Fiat" (§ fn coinToFiat) [#_"Coin" (§ name convertCoin)])
    (§ block
        ;; Use BigInteger because it's much easier to maintain full precision without overflowing.
        #_final
        (§ var #_"BigInteger" (§ name converted) (§ expr BigInteger/valueOf(§ pars convertCoin.value).multiply(§ pars BigInteger/valueOf(§ pars fiat.value)).divide(§ pars BigInteger/valueOf(§ pars coin.value))))

        (§ if (§ expr 0 < converted.compareTo(§ pars BigInteger/valueOf(§ pars Long/MAX_VALUE)) || converted.compareTo(§ pars BigInteger/valueOf(§ pars Long/MIN_VALUE)) < 0))
        (§ block
            (§ throw (§ new #_"ArithmeticException" (§ pars "Overflow")))
        )

        (§ return (§ expr Fiat/valueOf(§ pars fiat.currencyCode, converted.longValue(§ pars ))))
    )

    ;;;
     ; Convert a fiat amount to a coin amount using this exchange rate.
     ; @throws ArithmeticException if the converted coin amount is too high or too low.
     ;;
    #_public
    (§ method #_"Coin" (§ fn fiatToCoin) [#_"Fiat" (§ name convertFiat)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars convertFiat.currencyCode.equals(§ pars fiat.currencyCode), "Currency mismatch: %s vs %s", convertFiat.currencyCode, fiat.currencyCode))

        ;; Use BigInteger because it's much easier to maintain full precision without overflowing.
        #_final
        (§ var #_"BigInteger" (§ name converted) (§ expr BigInteger/valueOf(§ pars convertFiat.value).multiply(§ pars BigInteger/valueOf(§ pars coin.value)).divide(§ pars BigInteger/valueOf(§ pars fiat.value))))

        (§ if (§ expr 0 < converted.compareTo(§ pars BigInteger/valueOf(§ pars Long/MAX_VALUE)) || converted.compareTo(§ pars BigInteger/valueOf(§ pars Long/MIN_VALUE)) < 0))
        (§ block
            (§ throw (§ new #_"ArithmeticException" (§ pars "Overflow")))
        )

        (§ try )
        (§ block
            (§ return (§ expr Coin/valueOf(§ pars converted.longValue(§ pars ))))
        )
        (§ catch #_"IllegalArgumentException" (§ name e))
        (§ block
            (§ throw (§ new #_"ArithmeticException" (§ pars "Overflow: " + e.getMessage(§ pars ))))
        )
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"ExchangeRate" (§ name other) (§ expr (§ cast #_"ExchangeRate" o)))
        (§ return (§ expr Objects/equal(§ pars this.coin, other.coin) && Objects/equal(§ pars this.fiat, other.fiat)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars coin, fiat)))
    )
)

#_(ns org.bitcoinj.utils #_"ExponentialBackoff"
    (:import [com.google.common.base Preconditions]
             [com.google.common.primitives Longs])
   (:require [org.bitcoinj.core Utils]))

;;;
 ; <p>Tracks successes and failures and calculates a time to retry the operation.</p>
 ;
 ; <p>The retries are exponentially backed off, up to a maximum interval.  On success the back off interval is reset.</p>
 ;;
#_public
(§ class #_"ExponentialBackoff" (§ implements #_"Comparable<ExponentialBackoff>")
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name DEFAULT_INITIAL_MILLIS) 100)
    #_public
    #_static
    #_final
    (§ field #_"float" (§ name DEFAULT_MULTIPLIER) 1.1)
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name DEFAULT_MAXIMUM_MILLIS) (§ expr 30 * 1000))

    #_private
    (§ field #_"float" (§ name backoff))
    #_private
    (§ field #_"long" (§ name retryTime))
    #_private
    #_final
    (§ field #_"Params" (§ name params))

    ;;;
     ; Parameters to configure a particular kind of exponential backoff.
     ;;
    #_public
    #_static
    (§ class #_"Params"
        #_private
        #_final
        (§ field #_"float" (§ name initial))
        #_private
        #_final
        (§ field #_"float" (§ name multiplier))
        #_private
        #_final
        (§ field #_"float" (§ name maximum))

        ;;;
         ; @param initialMillis The initial interval to wait, in milliseconds.
         ; @param multiplier The multiplier to apply on each failure.
         ; @param maximumMillis The maximum interval to wait, in milliseconds.
         ;;
        #_public
        (§ constructor #_"Params" [#_"long" (§ name initialMillis), #_"float" (§ name multiplier), #_"long" (§ name maximumMillis)])
        (§ block
            (§ expr Preconditions/checkArgument(§ pars 1.0 < multiplier, "multiplier must be greater than 1.0"))
            (§ expr Preconditions/checkArgument(§ pars initialMillis <= maximumMillis, "maximum must not be less than initial"))

            (§ ass (§ name this.initial) initialMillis)
            (§ ass (§ name this.multiplier) multiplier)
            (§ ass (§ name this.maximum) maximumMillis)
            (§ void this)
        )

        ;;;
         ; Construct params with default values.
         ;;
        #_public
        (§ constructor #_"Params" [])
        (§ block
            (§ ass (§ name initial) (§ expr DEFAULT_INITIAL_MILLIS))
            (§ ass (§ name multiplier) (§ expr DEFAULT_MULTIPLIER))
            (§ ass (§ name maximum) (§ expr DEFAULT_MAXIMUM_MILLIS))
            (§ void this)
        )
    )

    #_public
    (§ constructor #_"ExponentialBackoff" [#_"Params" (§ name params)])
    (§ block
        (§ ass (§ name this.params) params)
        (§ expr trackSuccess(§ pars ))
        (§ void this)
    )

    ;;; Track a success - reset back off interval to the initial value. ;;
    #_public
    #_final
    (§ method #_"void" (§ fn trackSuccess) [])
    (§ block
        (§ ass (§ name backoff) (§ expr params.initial))
        (§ ass (§ name retryTime) (§ expr Utils/currentTimeMillis(§ pars )))
        (§ void nil)
    )

    ;;; Track a failure - multiply the back off interval by the multiplier. ;;
    #_public
    (§ method #_"void" (§ fn trackFailure) [])
    (§ block
        (§ ass (§ name retryTime) (§ expr Utils/currentTimeMillis(§ pars ) + (§ cast #_"long" backoff)))
        (§ ass (§ name backoff) (§ expr Math/min(§ pars backoff * params.multiplier, params.maximum)))
        (§ void nil)
    )

    ;;; Get the next time to retry, in milliseconds since the epoch. ;;
    #_public
    (§ method #_"long" (§ fn getRetryTime) [])
    (§ block
        (§ return retryTime)
    )

    #_override
    #_public
    (§ method #_"int" (§ fn compareTo) [#_"ExponentialBackoff" (§ name other)])
    (§ block
        ;; Note that in this implementation compareTo() is not consistent with equals().
        (§ return (§ expr Longs/compare(§ pars retryTime, other.retryTime)))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr "ExponentialBackoff retry=" + retryTime + " backoff=" + backoff))
    )
)

#_(ns org.bitcoinj.utils #_"Fiat"
    (:import [java.io Serializable]
             [java.math BigDecimal])
    (:import [com.google.common.base Objects Preconditions]
             [com.google.common.math LongMath]
             [com.google.common.primitives Longs])
   (:require [org.bitcoinj.core Monetary]))

;;;
 ; Represents a monetary fiat value.  It was decided to not fold this into {@link org.bitcoinj.core.Coin}
 ; because of type safety.  Fiat values always come with an attached currency code.
 ;
 ; This class is immutable.
 ;;
#_public
#_final
(§ class #_"Fiat" (§ implements #_"Monetary", #_"Comparable<Fiat>", #_"Serializable")
    ;;;
     ; The absolute value of exponent of the value of a "smallest unit" in scientific notation.
     ; We picked 4 rather than 2, because in financial applications it's common to use sub-cent precision.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name SMALLEST_UNIT_EXPONENT) 4)

    ;;;
     ; The number of smallest units of this monetary value.
     ;;
    #_public
    #_final
    (§ field #_"long" (§ name value))
    #_public
    #_final
    (§ field #_"String" (§ name currencyCode))

    #_private
    (§ constructor #_"Fiat" [#_final #_"String" (§ name currencyCode), #_final #_"long" (§ name value)])
    (§ block
        (§ ass (§ name this.value) value)
        (§ ass (§ name this.currencyCode) currencyCode)
        (§ void this)
    )

    #_public
    #_static
    (§ method #_"Fiat" (§ fn valueOf) [#_final #_"String" (§ name currencyCode), #_final #_"long" (§ name value)])
    (§ block
        (§ return (§ new #_"Fiat" (§ pars currencyCode, value)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn smallestUnitExponent) [])
    (§ block
        (§ return (§ expr SMALLEST_UNIT_EXPONENT))
    )

    ;;;
     ; Returns the number of "smallest units" of this monetary value.
     ;;
    #_override
    #_public
    (§ method #_"long" (§ fn getValue) [])
    (§ block
        (§ return value)
    )

    #_public
    (§ method #_"String" (§ fn getCurrencyCode) [])
    (§ block
        (§ return currencyCode)
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify more than 4 digits after the comma, or a value out of range.
     ;;
    #_public
    #_static
    (§ method #_"Fiat" (§ fn parseFiat) [#_final #_"String" (§ name currencyCode), #_final #_"String" (§ name str)])
    (§ block
        (§ try )
        (§ block
            (§ var #_"long" (§ name val) (§ expr (§ new #_"BigDecimal" (§ pars str)).movePointRight(§ pars SMALLEST_UNIT_EXPONENT).longValueExact(§ pars )))
            (§ return (§ expr Fiat/valueOf(§ pars currencyCode, val)))
        )
        (§ catch #_"ArithmeticException" (§ name e))
        (§ block
            (§ throw (§ new #_"IllegalArgumentException" (§ pars e)))
        )
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.  The amount is cut to 4 digits after the comma.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify a value out of range.
     ;;
    #_public
    #_static
    (§ method #_"Fiat" (§ fn parseFiatInexact) [#_final #_"String" (§ name currencyCode), #_final #_"String" (§ name str)])
    (§ block
        (§ try )
        (§ block
            (§ var #_"long" (§ name val) (§ expr (§ new #_"BigDecimal" (§ pars str)).movePointRight(§ pars SMALLEST_UNIT_EXPONENT).longValue(§ pars )))
            (§ return (§ expr Fiat/valueOf(§ pars currencyCode, val)))
        )
        (§ catch #_"ArithmeticException" (§ name e))
        (§ block
            (§ throw (§ new #_"IllegalArgumentException" (§ pars e)))
        )
    )

    #_public
    (§ method #_"Fiat" (§ fn add) [#_final #_"Fiat" (§ name value)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars value.currencyCode.equals(§ pars currencyCode)))

        (§ return (§ new #_"Fiat" (§ pars currencyCode, LongMath/checkedAdd(§ pars this.value, value.value))))
    )

    #_public
    (§ method #_"Fiat" (§ fn subtract) [#_final #_"Fiat" (§ name value)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars value.currencyCode.equals(§ pars currencyCode)))

        (§ return (§ new #_"Fiat" (§ pars currencyCode, LongMath/checkedSubtract(§ pars this.value, value.value))))
    )

    #_public
    (§ method #_"Fiat" (§ fn multiply) [#_final #_"long" (§ name factor)])
    (§ block
        (§ return (§ new #_"Fiat" (§ pars currencyCode, LongMath/checkedMultiply(§ pars this.value, factor))))
    )

    #_public
    (§ method #_"Fiat" (§ fn divide) [#_final #_"long" (§ name divisor)])
    (§ block
        (§ return (§ new #_"Fiat" (§ pars currencyCode, this.value / divisor)))
    )

    #_public
    (§ method #_"Fiat[]" (§ fn divideAndRemainder) [#_final #_"long" (§ name divisor)])
    (§ block
        (§ return (§ new #_"Fiat[]" (§ coll (§ new #_"Fiat" (§ pars currencyCode, this.value / divisor)), (§ new #_"Fiat" (§ pars currencyCode, this.value % divisor)) )))
    )

    #_public
    (§ method #_"long" (§ fn divide) [#_final #_"Fiat" (§ name divisor)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars divisor.currencyCode.equals(§ pars currencyCode)))

        (§ return (§ expr this.value / divisor.value))
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value greater than zero, otherwise false.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isPositive) [])
    (§ block
        (§ return (§ expr signum(§ pars ) == 1))
    )

    ;;;
     ; Returns true if and only if this instance represents a monetary value less than zero, otherwise false.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isNegative) [])
    (§ block
        (§ return (§ expr signum(§ pars ) == -1))
    )

    ;;;
     ; Returns true if and only if this instance represents zero monetary value, otherwise false.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isZero) [])
    (§ block
        (§ return (§ expr signum(§ pars ) == 0))
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is greater than that of the given other Fiat,
     ; otherwise false.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isGreaterThan) [#_"Fiat" (§ name other)])
    (§ block
        (§ return (§ expr compareTo(§ pars other) > 0))
    )

    ;;;
     ; Returns true if the monetary value represented by this instance is less than that of the given other Fiat,
     ; otherwise false.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isLessThan) [#_"Fiat" (§ name other)])
    (§ block
        (§ return (§ expr compareTo(§ pars other) < 0))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn signum) [])
    (§ block
        (§ return (§ quest (§ expr this.value == 0) ? 0 :else (§ quest (§ expr this.value < 0) ? -1 :else 1)))
    )

    #_public
    (§ method #_"Fiat" (§ fn negate) [])
    (§ block
        (§ return (§ new #_"Fiat" (§ pars currencyCode, (§ neg this.value))))
    )

    ;;;
     ; Returns the number of "smallest units" of this monetary value.
     ; It's deprecated in favour of accessing {@link #value} directly.
     ;;
    #_public
    (§ method #_"long" (§ fn longValue) [])
    (§ block
        (§ return (§ expr this.value))
    )

    #_private
    #_static
    #_final
    (§ field #_"MonetaryFormat" (§ name FRIENDLY_FORMAT) (§ expr MonetaryFormat/FIAT.postfixCode(§ pars )))

    ;;;
     ; Returns the value as a 0.12 type string.
     ; More digits after the decimal place will be used if necessary, but two will always be present.
     ;;
    #_public
    (§ method #_"String" (§ fn toFriendlyString) [])
    (§ block
        (§ return (§ expr FRIENDLY_FORMAT.code(§ pars 0, currencyCode).format(§ pars this).toString(§ pars )))
    )

    #_private
    #_static
    #_final
    (§ field #_"MonetaryFormat" (§ name PLAIN_FORMAT) (§ expr MonetaryFormat/FIAT.minDecimals(§ pars 0).repeatOptionalDecimals(§ pars 1, 4).noCode(§ pars )))

    ;;;
     ; Returns the value as a plain string.  The result is unformatted with no trailing zeroes.
     ; For instance, a value of 150000 "smallest units" gives an output string of "0.0015".
     ;;
    #_public
    (§ method #_"String" (§ fn toPlainString) [])
    (§ block
        (§ return (§ expr PLAIN_FORMAT.format(§ pars this).toString(§ pars )))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr Long/toString(§ pars value)))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_final #_"Object" (§ name o)])
    (§ block
        (§ if (§ expr o == this))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || o.getClass(§ pars ) != getClass(§ pars )))
        (§ block
            (§ return false)
        )
        #_final
        (§ var #_"Fiat" (§ name other) (§ expr (§ cast #_"Fiat" o)))
        (§ return (§ expr this.value == other.value && this.currencyCode.equals(§ pars other.currencyCode)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars value, currencyCode)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn compareTo) [#_final #_"Fiat" (§ name other)])
    (§ block
        (§ return (§ quest (§ expr this.currencyCode.equals(§ pars other.currencyCode)) ? (§ expr Longs/compare(§ pars this.value, other.value)) :else (§ expr this.currencyCode.compareTo(§ pars other.currencyCode))))
    )
)

#_(ns org.bitcoinj.utils #_"ListenerRegistration"
    (:import [java.util List]
             [java.util.concurrent Executor])
    (:import [com.google.common.base Preconditions]))

;;;
 ; A simple wrapper around a listener and an executor, with some utility methods.
 ;;
#_public
(§ class #_"ListenerRegistration<T>"
    #_public
    #_final
    (§ field #_"T" (§ name listener))
    #_public
    #_final
    (§ field #_"Executor" (§ name executor))

    #_public
    (§ constructor #_"ListenerRegistration" [#_"T" (§ name listener), #_"Executor" (§ name executor)])
    (§ block
        (§ ass (§ name this.listener) (§ expr Preconditions/checkNotNull(§ pars listener)))
        (§ ass (§ name this.executor) (§ expr Preconditions/checkNotNull(§ pars executor)))
        (§ void this)
    )

    ;;; Returns true if the listener was removed, else false. ;;
    #_public
    #_static
    (§ method #_"<T> boolean" (§ fn removeFromList) [#_"T" (§ name listener), #_"List<? extends ListenerRegistration<T>>" (§ name list)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars listener))

        (§ var #_"ListenerRegistration<T>" (§ name item) nil)
        (§ for (§ var #_"ListenerRegistration<T>" (§ name registration)) :for list)
        (§ block
            (§ if (§ expr registration.listener == listener))
            (§ block
                (§ ass (§ name item) registration)
                (§ break )
            )
        )
        (§ return (§ expr item != nil && list.remove(§ pars item)))
    )
)

#_(ns org.bitcoinj.utils #_"MonetaryFormat"
    (:import [java.math RoundingMode]
             [java.text DecimalFormatSymbols]
             [java.util ArrayList Arrays List Locale])
    (:import [com.google.common.base Preconditions]
             #_static [com.google.common.math.LongMath checkedMultiply]
             #_static [com.google.common.math.LongMath checkedPow]
             #_static [com.google.common.math.LongMath divide])
   (:require [org.bitcoinj.core Coin Monetary]))

;;;
 ; Utility for formatting and parsing coin values to and from human readable form.
 ;
 ; MonetaryFormat instances are immutable.  Invoking a configuration method has no effect on the receiving instance;
 ; you must store and use the new instance it returns, instead.  Instances are thread safe, so they may be stored safely
 ; as static constants.
 ;;
#_public
#_final
(§ class #_"MonetaryFormat"
    ;;; Standard format for the BTC denomination. ;;
    #_public
    #_static
    #_final
    (§ field #_"MonetaryFormat" (§ name BTC) (§ expr (§ new #_"MonetaryFormat" (§ pars )).shift(§ pars 0).minDecimals(§ pars 2).repeatOptionalDecimals(§ pars 2, 3)))
    ;;; Standard format for the mBTC denomination. ;;
    #_public
    #_static
    #_final
    (§ field #_"MonetaryFormat" (§ name MBTC) (§ expr (§ new #_"MonetaryFormat" (§ pars )).shift(§ pars 3).minDecimals(§ pars 2).optionalDecimals(§ pars 2)))
    ;;; Standard format for the µBTC denomination. ;;
    #_public
    #_static
    #_final
    (§ field #_"MonetaryFormat" (§ name UBTC) (§ expr (§ new #_"MonetaryFormat" (§ pars )).shift(§ pars 6).minDecimals(§ pars 0).optionalDecimals(§ pars 2)))
    ;;; Standard format for fiat amounts. ;;
    #_public
    #_static
    #_final
    (§ field #_"MonetaryFormat" (§ name FIAT) (§ expr (§ new #_"MonetaryFormat" (§ pars )).shift(§ pars 0).minDecimals(§ pars 2).repeatOptionalDecimals(§ pars 2, 1)))
    ;;; Currency code for base 1 Bitcoin. ;;
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name CODE_BTC) (§ expr "BTC"))
    ;;; Currency code for base 1/1000 Bitcoin. ;;
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name CODE_MBTC) (§ expr "mBTC"))
    ;;; Currency code for base 1/1000000 Bitcoin. ;;
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name CODE_UBTC) (§ expr "µBTC"))

    #_public
    #_static
    #_final
    (§ field #_"int" (§ name MAX_DECIMALS) 8)

    #_private
    #_final
    (§ field #_"char" (§ name negativeSign))
    #_private
    #_final
    (§ field #_"char" (§ name positiveSign))
    #_private
    #_final
    (§ field #_"char" (§ name zeroDigit))
    #_private
    #_final
    (§ field #_"char" (§ name decimalMark))
    #_private
    #_final
    (§ field #_"int" (§ name minDecimals))
    #_private
    #_final
    (§ field #_"List<Integer>" (§ name decimalGroups))
    #_private
    #_final
    (§ field #_"int" (§ name shift))
    #_private
    #_final
    (§ field #_"RoundingMode" (§ name roundingMode))
    #_private
    #_final
    (§ field #_"String[]" (§ name codes))
    #_private
    #_final
    (§ field #_"char" (§ name codeSeparator))
    #_private
    #_final
    (§ field #_"boolean" (§ name codePrefixed))

    #_private
    #_static
    #_final
    (§ field #_"String" (§ name DECIMALS_PADDING) (§ expr "0000000000000000")) ;; a few more than necessary for Bitcoin

    ;;;
     ; Set character to prefix negative values.
     ;;
    #_public
    (§ method #_"MonetaryFormat" (§ fn negativeSign) [#_"char" (§ name negativeSign)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars (§ not Character/isDigit(§ pars negativeSign))))
        (§ expr Preconditions/checkArgument(§ pars 0 < negativeSign))

        (§ return (§ quest (§ expr negativeSign == this.negativeSign) ? this :else (§ new #_"MonetaryFormat" (§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))))
    )

    ;;;
     ; Set character to prefix positive values.  A zero value means no sign is used in this case.
     ; For parsing, a missing sign will always be interpreted as if the positive sign was used.
     ;;
    #_public
    (§ method #_"MonetaryFormat" (§ fn positiveSign) [#_"char" (§ name positiveSign)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars (§ not Character/isDigit(§ pars positiveSign))))

        (§ return (§ quest (§ expr positiveSign == this.positiveSign) ? this :else (§ new #_"MonetaryFormat" (§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))))
    )

    ;;;
     ; Set character range to use for representing digits.  It starts with the specified character representing zero.
     ;;
    #_public
    (§ method #_"MonetaryFormat" (§ fn digits) [#_"char" (§ name zeroDigit)])
    (§ block
        (§ return (§ quest (§ expr zeroDigit == this.zeroDigit) ? this :else (§ new #_"MonetaryFormat" (§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))))
    )

    ;;;
     ; Set character to use as the decimal mark.  If the formatted value does not have any decimals,
     ; no decimal mark is used either.
     ;;
    #_public
    (§ method #_"MonetaryFormat" (§ fn decimalMark) [#_"char" (§ name decimalMark)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars (§ not Character/isDigit(§ pars decimalMark))))
        (§ expr Preconditions/checkArgument(§ pars 0 < decimalMark))

        (§ return (§ quest (§ expr decimalMark == this.decimalMark) ? this :else (§ new #_"MonetaryFormat" (§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))))
    )

    ;;;
     ; Set minimum number of decimals to use for formatting.  If the value precision exceeds all decimals specified
     ; (including additional decimals specified by {@link #optionalDecimals(int...)} or {@link #repeatOptionalDecimals(int, int)}),
     ; the value will be rounded.  This configuration is not relevant for parsing.
     ;;
    #_public
    (§ method #_"MonetaryFormat" (§ fn minDecimals) [#_"int" (§ name minDecimals)])
    (§ block
        (§ return (§ quest (§ expr minDecimals == this.minDecimals) ? this :else (§ new #_"MonetaryFormat" (§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))))
    )

    ;;;
     ; Set additional groups of decimals to use after the minimum decimals, if they are useful for expressing precision.
     ; Each value is a number of decimals in that group.  If the value precision exceeds all decimals specified
     ; (including minimum decimals), the value will be rounded.  This configuration is not relevant for parsing.
     ;
     ; For example, if you pass <tt>4,2</tt> it will add four decimals to your formatted string if needed, and then add
     ; another two decimals if needed.  At this point, rather than adding further decimals the value will be rounded.
     ;
     ; @param groups Any number numbers of decimals, one for each group.
     ;;
    #_public
    (§ method #_"MonetaryFormat" (§ fn optionalDecimals) [#_"int..." (§ name groups)])
    (§ block
        (§ var #_"List<Integer>" (§ name decimalGroups) (§ new #_"ArrayList<>" (§ pars groups.length)))
        (§ for (§ var #_"int" (§ name group)) :for groups)
        (§ block
            (§ expr decimalGroups.add(§ pars group))
        )
        (§ return (§ new #_"MonetaryFormat" (§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed)))
    )

    ;;;
     ; Set repeated additional groups of decimals to use after the minimum decimals, if they are useful for expressing
     ; precision.  If the value precision exceeds all decimals specified (including minimum decimals), the value will be
     ; rounded.  This configuration is not relevant for parsing.
     ;
     ; For example, if you pass <tt>1,8</tt> it will up to eight decimals to your formatted string if needed.
     ; After these have been used up, rather than adding further decimals the value will be rounded.
     ;
     ; @param decimals Value of the group to be repeated.
     ; @param repetitions Number of repetitions.
     ;;
    #_public
    (§ method #_"MonetaryFormat" (§ fn repeatOptionalDecimals) [#_"int" (§ name decimals), #_"int" (§ name repetitions)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars 0 <= repetitions))

        (§ var #_"List<Integer>" (§ name decimalGroups) (§ new #_"ArrayList<>" (§ pars repetitions)))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < repetitions) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ expr decimalGroups.add(§ pars decimals))
        )
        (§ return (§ new #_"MonetaryFormat" (§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed)))
    )

    ;;;
     ; Set number of digits to shift the decimal separator to the right, coming from the standard BTC notation that was
     ; common pre-2014.  Note this will change the currency code if enabled.
     ;;
    #_public
    (§ method #_"MonetaryFormat" (§ fn shift) [#_"int" (§ name shift)])
    (§ block
        (§ return (§ quest (§ expr shift == this.shift) ? this :else (§ new #_"MonetaryFormat" (§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))))
    )

    ;;;
     ; Set rounding mode to use when it becomes necessary.
     ;;
    #_public
    (§ method #_"MonetaryFormat" (§ fn roundingMode) [#_"RoundingMode" (§ name roundingMode)])
    (§ block
        (§ return (§ quest (§ expr roundingMode == this.roundingMode) ? this :else (§ new #_"MonetaryFormat" (§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))))
    )

    ;;;
     ; Don't display currency code when formatting.  This configuration is not relevant for parsing.
     ;;
    #_public
    (§ method #_"MonetaryFormat" (§ fn noCode) [])
    (§ block
        (§ return (§ quest (§ expr codes == nil) ? this :else (§ new #_"MonetaryFormat" (§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, nil, codeSeparator, codePrefixed))))
    )

    ;;;
     ; Configure currency code for given decimal separator shift.  This configuration is not relevant for parsing.
     ;
     ; @param codeShift Decimal separator shift, see {@link #shift}.
     ; @param code Currency code.
     ;;
    #_public
    (§ method #_"MonetaryFormat" (§ fn code) [#_"int" (§ name codeShift), #_"String" (§ name code)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars 0 <= codeShift))

        #_final
        (§ var #_"String[]" (§ name codes) (§ quest (§ expr this.codes != nil) ? (§ expr Arrays/copyOf(§ pars this.codes, this.codes.length)) :else (§ new #_"String[]" (§ count MAX_DECIMALS))))

        (§ ass (§ name codes[codeShift]) code)
        (§ return (§ new #_"MonetaryFormat" (§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed)))
    )

    ;;;
     ; Separator between currency code and formatted value.  This configuration is not relevant for parsing.
     ;;
    #_public
    (§ method #_"MonetaryFormat" (§ fn codeSeparator) [#_"char" (§ name codeSeparator)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars (§ not Character/isDigit(§ pars codeSeparator))))
        (§ expr Preconditions/checkArgument(§ pars 0 < codeSeparator))

        (§ return (§ quest (§ expr codeSeparator == this.codeSeparator) ? this :else (§ new #_"MonetaryFormat" (§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed))))
    )

    ;;;
     ; Prefix formatted output by currency code.  This configuration is not relevant for parsing.
     ;;
    #_public
    (§ method #_"MonetaryFormat" (§ fn prefixCode) [])
    (§ block
        (§ return (§ quest codePrefixed ? this :else (§ new #_"MonetaryFormat" (§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, true))))
    )

    ;;;
     ; Postfix formatted output with currency code.  This configuration is not relevant for parsing.
     ;;
    #_public
    (§ method #_"MonetaryFormat" (§ fn postfixCode) [])
    (§ block
        (§ return (§ quest (§ not codePrefixed) ? this :else (§ new #_"MonetaryFormat" (§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, false))))
    )

    ;;;
     ; Configure this instance with values from a {@link Locale}.
     ;;
    #_public
    (§ method #_"MonetaryFormat" (§ fn withLocale) [#_"Locale" (§ name locale)])
    (§ block
        (§ var #_"DecimalFormatSymbols" (§ name dfs) (§ new #_"DecimalFormatSymbols" (§ pars locale)))
        (§ var #_"char" (§ name negativeSign) (§ expr dfs.getMinusSign(§ pars )))
        (§ var #_"char" (§ name zeroDigit) (§ expr dfs.getZeroDigit(§ pars )))
        (§ var #_"char" (§ name decimalMark) (§ expr dfs.getMonetaryDecimalSeparator(§ pars )))
        (§ return (§ new #_"MonetaryFormat" (§ pars negativeSign, positiveSign, zeroDigit, decimalMark, minDecimals, decimalGroups, shift, roundingMode, codes, codeSeparator, codePrefixed)))
    )

    #_public
    (§ constructor #_"MonetaryFormat" [])
    (§ block
        ;; defaults
        (§ ass (§ name this.negativeSign) (§ expr \-))
        (§ ass (§ name this.positiveSign) 0) ;; none
        (§ ass (§ name this.zeroDigit) (§ expr \0))
        (§ ass (§ name this.decimalMark) (§ expr \.))
        (§ ass (§ name this.minDecimals) 2)
        (§ ass (§ name this.decimalGroups) nil)
        (§ ass (§ name this.shift) 0)
        (§ ass (§ name this.roundingMode) (§ expr RoundingMode/HALF_UP))
        (§ ass (§ name this.codes) (§ new #_"String[]" (§ count MAX_DECIMALS)))
        (§ ass (§ name this.codes[0]) (§ expr CODE_BTC))
        (§ ass (§ name this.codes[3]) (§ expr CODE_MBTC))
        (§ ass (§ name this.codes[6]) (§ expr CODE_UBTC))
        (§ ass (§ name this.codeSeparator) (§ expr \space))
        (§ ass (§ name this.codePrefixed) true)
        (§ void this)
    )

    #_private
    (§ constructor #_"MonetaryFormat" [#_"char" (§ name negativeSign), #_"char" (§ name positiveSign), #_"char" (§ name zeroDigit), #_"char" (§ name decimalMark), #_"int" (§ name minDecimals), #_"List<Integer>" (§ name decimalGroups), #_"int" (§ name shift), #_"RoundingMode" (§ name roundingMode), #_"String[]" (§ name codes), #_"char" (§ name codeSeparator), #_"boolean" (§ name codePrefixed)])
    (§ block
        (§ ass (§ name this.negativeSign) negativeSign)
        (§ ass (§ name this.positiveSign) positiveSign)
        (§ ass (§ name this.zeroDigit) zeroDigit)
        (§ ass (§ name this.decimalMark) decimalMark)
        (§ ass (§ name this.minDecimals) minDecimals)
        (§ ass (§ name this.decimalGroups) decimalGroups)
        (§ ass (§ name this.shift) shift)
        (§ ass (§ name this.roundingMode) roundingMode)
        (§ ass (§ name this.codes) codes)
        (§ ass (§ name this.codeSeparator) codeSeparator)
        (§ ass (§ name this.codePrefixed) codePrefixed)
        (§ void this)
    )

    ;;;
     ; Format the given monetary value to a human readable form.
     ;;
    #_public
    (§ method #_"CharSequence" (§ fn format) [#_"Monetary" (§ name monetary)])
    (§ block
        ;; preparation
        (§ var #_"int" (§ name maxDecimals) minDecimals)
        (§ if (§ expr decimalGroups != nil))
        (§ block
            (§ for (§ var #_"int" (§ name group)) :for decimalGroups)
            (§ block
                (§ ass (§ name maxDecimals) (§ expr maxDecimals + group))
            )
        )
        (§ var #_"int" (§ name smallestUnitExponent) (§ expr monetary.smallestUnitExponent(§ pars )))
        (§ expr Preconditions/checkState(§ pars maxDecimals <= smallestUnitExponent, "The maximum possible number of decimals (%s) cannot exceed %s.", maxDecimals, smallestUnitExponent))

        ;; rounding
        (§ var #_"long" (§ name satoshis) (§ expr Math/abs(§ pars monetary.getValue(§ pars ))))
        (§ var #_"long" (§ name precisionDivisor) (§ expr checkedPow(§ pars 10, smallestUnitExponent - shift - maxDecimals)))
        (§ ass (§ name satoshis) (§ expr checkedMultiply(§ pars divide(§ pars satoshis, precisionDivisor, roundingMode), precisionDivisor)))

        ;; shifting
        (§ var #_"long" (§ name shiftDivisor) (§ expr checkedPow(§ pars 10, smallestUnitExponent - shift)))
        (§ var #_"long" (§ name numbers) (§ expr satoshis / shiftDivisor))
        (§ var #_"long" (§ name decimals) (§ expr satoshis % shiftDivisor))

        ;; formatting
        (§ var #_"String" (§ name decimalsStr) (§ expr String/format(§ pars Locale/US, "%0" + (§ expr smallestUnitExponent - shift) + "d", decimals)))
        (§ var #_"StringBuilder" (§ name sb) (§ new #_"StringBuilder" (§ pars decimalsStr)))
        (§ while (§ expr minDecimals < sb.length(§ pars ) && sb.charAt(§ pars sb.length(§ pars ) - 1) == \0))
        (§ block
            (§ expr sb.setLength(§ pars sb.length(§ pars ) - 1)) ;; trim trailing zero
        )
        (§ var #_"int" (§ name i) minDecimals)
        (§ if (§ expr decimalGroups != nil))
        (§ block
            (§ for (§ var #_"int" (§ name group)) :for decimalGroups)
            (§ block
                (§ if (§ expr i < sb.length(§ pars ) && sb.length(§ pars ) < i + group))
                (§ block
                    (§ while (§ expr sb.length(§ pars ) < i + group))
                    (§ block
                        (§ expr sb.append(§ pars "0"))
                    )
                    (§ break )
                )
                (§ ass (§ name i) (§ expr i + group))
            )
        )
        (§ if (§ expr 0 < sb.length(§ pars )))
        (§ block
            (§ expr sb.insert(§ pars 0, decimalMark))
        )
        (§ expr sb.insert(§ pars 0, numbers))
        (§ if (§ expr monetary.getValue(§ pars ) < 0))
        (§ block
            (§ expr sb.insert(§ pars 0, negativeSign))
        )
        (§ elseif (§ expr positiveSign != 0))
        (§ block
            (§ expr sb.insert(§ pars 0, positiveSign))
        )
        (§ if (§ expr codes != nil))
        (§ block
            (§ if codePrefixed)
            (§ block
                (§ expr sb.insert(§ pars 0, codeSeparator))
                (§ expr sb.insert(§ pars 0, code(§ pars )))
            )
            (§ else )
            (§ block
                (§ expr sb.append(§ pars codeSeparator))
                (§ expr sb.append(§ pars code(§ pars )))
            )
        )

        ;; Convert to non-arabic digits.
        (§ if (§ expr zeroDigit != \0))
        (§ block
            (§ var #_"int" (§ name offset) (§ expr zeroDigit - \0))
            (§ for (§ var #_"int" (§ name d) 0) :for (§ expr d < sb.length(§ pars )) :for (§ ass (§ name d) (§ expr d + 1)))
            (§ block
                (§ var #_"char" (§ name c) (§ expr sb.charAt(§ pars d)))
                (§ if (§ expr Character/isDigit(§ pars c)))
                (§ block
                    (§ expr sb.setCharAt(§ pars d, (§ cast #_"char" (§ expr c + offset))))
                )
            )
        )
        (§ return sb)
    )

    ;;;
     ; Parse a human readable coin value to a {@link org.bitcoinj.core.Coin} instance.
     ;
     ; @throws NumberFormatException if the string cannot be parsed for some reason.
     ;;
    #_public
    (§ method #_"Coin" (§ fn parse) [#_"String" (§ name str)])
        (§ throws #_"NumberFormatException")
    (§ block
        (§ return (§ expr Coin/valueOf(§ pars parseValue(§ pars str, Coin/SMALLEST_UNIT_EXPONENT))))
    )

    ;;;
     ; Parse a human readable fiat value to a {@link org.bitcoinj.utils.Fiat} instance.
     ;
     ; @throws NumberFormatException if the string cannot be parsed for some reason.
     ;;
    #_public
    (§ method #_"Fiat" (§ fn parseFiat) [#_"String" (§ name currencyCode), #_"String" (§ name str)])
        (§ throws #_"NumberFormatException")
    (§ block
        (§ return (§ expr Fiat/valueOf(§ pars currencyCode, parseValue(§ pars str, Fiat/SMALLEST_UNIT_EXPONENT))))
    )

    #_private
    (§ method #_"long" (§ fn parseValue) [#_"String" (§ name str), #_"int" (§ name smallestUnitExponent)])
    (§ block
        (§ expr Preconditions/checkState(§ pars smallestUnitExponent <= DECIMALS_PADDING.length(§ pars )))

        (§ if (§ expr str.isEmpty(§ pars )))
        (§ block
            (§ throw (§ new #_"NumberFormatException" (§ pars "empty string")))
        )

        (§ var #_"char" (§ name first) (§ expr str.charAt(§ pars 0)))
        (§ if (§ expr first == negativeSign || first == positiveSign))
        (§ block
            (§ ass (§ name str) (§ expr str.substring(§ pars 1)))
        )
        (§ var #_"String" (§ name numbers))
        (§ var #_"String" (§ name decimals))
        (§ var #_"int" (§ name decimalMarkIndex) (§ expr str.indexOf(§ pars decimalMark)))
        (§ if (§ expr decimalMarkIndex != -1))
        (§ block
            (§ ass (§ name numbers) (§ expr str.substring(§ pars 0, decimalMarkIndex)))
            (§ ass (§ name decimals) (§ dot (§ expr str + DECIMALS_PADDING).substring(§ pars decimalMarkIndex + 1)))
            (§ if (§ expr decimals.indexOf(§ pars decimalMark) != -1))
            (§ block
                (§ throw (§ new #_"NumberFormatException" (§ pars "more than one decimal mark")))
            )
        )
        (§ else )
        (§ block
            (§ ass (§ name numbers) str)
            (§ ass (§ name decimals) (§ expr DECIMALS_PADDING))
        )

        (§ var #_"String" (§ name satoshis) (§ expr numbers + decimals.substring(§ pars 0, smallestUnitExponent - shift)))
        (§ for (§ var #_"char" (§ name c)) :for (§ expr satoshis.toCharArray(§ pars )))
        (§ block
            (§ if (§ expr (§ not Character/isDigit(§ pars c))))
            (§ block
                (§ throw (§ new #_"NumberFormatException" (§ pars "illegal character: " + c)))
            )
        )

        ;; Non-arabic digits allowed here.
        (§ var #_"long" (§ name value) (§ expr Long/parseLong(§ pars satoshis)))
        (§ if (§ expr first == negativeSign))
        (§ block
            (§ ass (§ name value) (§ expr (§ neg value)))
        )
        (§ return value)
    )

    ;;;
     ; Get currency code that will be used for current shift.
     ;;
    #_public
    (§ method #_"String" (§ fn code) [])
    (§ block
        (§ if (§ expr codes == nil))
        (§ block
            (§ return nil)
        )
        (§ if (§ expr codes[shift] == nil))
        (§ block
            (§ throw (§ new #_"NumberFormatException" (§ pars "missing code for shift: " + shift)))
        )
        (§ return (§ expr codes[shift]))
    )
)

#_(ns org.bitcoinj.utils #_"Threading"
    (:import [java.util.concurrent *]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.util.concurrent CycleDetectingLockFactory ListeningExecutorService MoreExecutors Uninterruptibles]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]))

;;;
 ; Various threading related utilities.  Provides a wrapper around explicit lock creation that lets you control whether
 ; bitcoinj performs cycle detection or not.  Cycle detection is useful to detect bugs but comes with a small cost.
 ; Also provides a worker thread that is designed for event listeners to be dispatched on.
 ;;
#_public
(§ class #_"Threading"
    ;;;
     ; An executor with one thread that is intended for running event listeners on.  This ensures all event listener
     ; code runs without any locks being held.  It's intended for the API user to run things on.  Callbacks registered
     ; by bitcoinj internally shouldn't normally run here, although currently there are a few exceptions.
     ;;
    #_public
    #_static
    (§ field #_"Executor" (§ name USER_THREAD))

    ;;;
     ; A dummy executor that just invokes the runnable immediately.  Use this over
     ; {@link com.google.common.util.concurrent.MoreExecutors#sameThreadExecutor()} because the latter creates
     ; a new object each time in order to implement the more complex {@link ExecutorService} interface, which is
     ; overkill for our needs.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"Executor" (§ name SAME_THREAD))

    ;;;
     ; Put a dummy task into the queue and wait for it to be run.  Because it's single threaded, this means all
     ; tasks submitted before this point are now completed.  Usually you won't want to use this method - it's a
     ; convenience primarily used in unit testing.  If you want to wait for an event to be called the right thing
     ; to do is usually to create a {@link com.google.common.util.concurrent.SettableFuture} and then call set
     ; on it.  You can then either block on that future, compose it, add listeners to it and so on.
     ;;
    #_public
    #_static
    (§ method #_"void" (§ fn waitForUserCode) [])
    (§ block
        #_final
        (§ var #_"CountDownLatch" (§ name latch) (§ new #_"CountDownLatch" (§ pars 1)))
        (§ expr USER_THREAD.execute(§ pars (§ new #_"Runnable" (§ pars ))
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn run) [])
            (§ block
                (§ expr latch.countDown(§ pars ))
                (§ void nil)
            )
        )))
        (§ expr Uninterruptibles/awaitUninterruptibly(§ pars latch))
        (§ void nil)
    )

    ;;;
     ; An exception handler that will be invoked for any exceptions that occur in the user thread, and any unhandled
     ; exceptions that are caught whilst the framework is processing network traffic or doing other background tasks.
     ; The purpose of this is to allow you to report back unanticipated crashes from your users to a central collection
     ; center for analysis and debugging.  You should configure this <b>before</b> any bitcoinj library code is run,
     ; setting it after you started network traffic and other forms of processing may result in the change not taking effect.
     ;;
    #_nilable
    #_public
    #_static
    #_volatile
    (§ field #_"Thread.UncaughtExceptionHandler" (§ name uncaughtExceptionHandler))

    #_public
    #_static
    (§ class #_"UserThread" (§ extends #_"Thread") (§ implements #_"Executor")
        #_private
        #_static
        #_final
        (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"UserThread"))))

        ;; 10,000 pending tasks is entirely arbitrary and may or may not be appropriate for the device we're running on.
        #_public
        #_static
        (§ field #_"int" (§ name WARNING_THRESHOLD) 10000)

        #_private
        (§ field #_"LinkedBlockingQueue<Runnable>" (§ name tasks))

        #_public
        (§ constructor #_"UserThread" [])
        (§ block
            (§ super (§ pars "bitcoinj user thread"))

            (§ expr setDaemon(§ pars true))
            (§ ass (§ name tasks) (§ new #_"LinkedBlockingQueue<>" (§ pars )))
            (§ expr start(§ pars ))
            (§ void this)
        )

        #_suppress(§ opt "InfiniteLoopStatement")
        #_override
        #_public
        (§ method #_"void" (§ fn run) [])
        (§ block
            (§ while true)
            (§ block
                (§ var #_"Runnable" (§ name task) (§ expr Uninterruptibles/takeUninterruptibly(§ pars tasks)))
                (§ try )
                (§ block
                    (§ expr task.run(§ pars ))
                )
                (§ catch #_"Throwable" (§ name t))
                (§ block
                    (§ expr log.warn(§ pars "Exception in user thread", t))
                    (§ var #_"Thread.UncaughtExceptionHandler" (§ name handler) uncaughtExceptionHandler)
                    (§ if (§ expr handler != nil))
                    (§ block
                        (§ expr handler.uncaughtException(§ pars this, t))
                    )
                )
            )
            (§ void nil)
        )

        #_override
        #_public
        (§ method #_"void" (§ fn execute) [#_"Runnable" (§ name command)])
        (§ block
            #_final
            (§ var #_"int" (§ name size) (§ expr tasks.size(§ pars )))
            (§ if (§ expr size == WARNING_THRESHOLD))
            (§ block
                (§ expr log.warn(§ pars "User thread has {} pending tasks, memory exhaustion may occur.\n" + "If you see this message, check your memory consumption and see if it's problematic or excessively spikey.\n" + "If it is, check for deadlocked or slow event handlers. If it isn't, try adjusting the constant \n" + "Threading.UserThread.WARNING_THRESHOLD upwards until it's a suitable level for your app, or Integer.MAX_VALUE to disable." , size))
            )
            (§ expr Uninterruptibles/putUninterruptibly(§ pars tasks, command))
            (§ void nil)
        )
    )

    #_static
    (§ block
        ;; Default policy goes here.  If you want to change this, use one of the static methods before instantiating
        ;; any bitcoinj objects.  The policy change will take effect only on new objects from that point onwards.
        (§ expr throwOnLockCycles(§ pars ))

        (§ ass (§ name USER_THREAD) (§ new #_"UserThread" (§ pars )))
        (§ ass (§ name SAME_THREAD) (§ new #_"Executor" (§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn execute) [#_non-nil #_"Runnable" (§ name runnable)])
            (§ block
                (§ expr runnable.run(§ pars ))
                (§ void nil)
            )
        )))
    )

    #_private
    #_static
    (§ field #_"CycleDetectingLockFactory.Policy" (§ name policy))
    #_public
    #_static
    (§ field #_"CycleDetectingLockFactory" (§ name factory))

    #_public
    #_static
    (§ method #_"ReentrantLock" (§ fn lock) [#_"String" (§ name name)])
    (§ block
        (§ return (§ quest (§ expr Utils/isAndroidRuntime(§ pars )) ? (§ new #_"ReentrantLock" (§ pars true)) :else (§ expr factory.newReentrantLock(§ pars name))))
    )

    #_public
    #_static
    (§ method #_"void" (§ fn warnOnLockCycles) [])
    (§ block
        (§ expr setPolicy(§ pars CycleDetectingLockFactory/Policies/WARN))
        (§ void nil)
    )

    #_public
    #_static
    (§ method #_"void" (§ fn throwOnLockCycles) [])
    (§ block
        (§ expr setPolicy(§ pars CycleDetectingLockFactory/Policies/THROW))
        (§ void nil)
    )

    #_public
    #_static
    (§ method #_"void" (§ fn ignoreLockCycles) [])
    (§ block
        (§ expr setPolicy(§ pars CycleDetectingLockFactory/Policies/DISABLED))
        (§ void nil)
    )

    #_public
    #_static
    (§ method #_"void" (§ fn setPolicy) [#_"CycleDetectingLockFactory.Policy" (§ name policy)])
    (§ block
        (§ ass (§ name Threading.policy) policy)
        (§ ass (§ name factory) (§ expr CycleDetectingLockFactory/newInstance(§ pars policy)))
        (§ void nil)
    )

    #_public
    #_static
    (§ method #_"CycleDetectingLockFactory.Policy" (§ fn getPolicy) [])
    (§ block
        (§ return policy)
    )

    ;;; A caching thread pool that creates daemon threads, which won't keep the JVM alive waiting for more work. ;;
    #_public
    #_static
    (§ field #_"ListeningExecutorService" (§ name THREAD_POOL) (§ expr MoreExecutors/listeningDecorator(§ pars Executors/newCachedThreadPool(§ pars (§ new #_"ThreadFactory" (§ pars ))
        (§ anon
            #_override
            #_public
            (§ method #_"Thread" (§ fn newThread) [#_"Runnable" (§ name r)])
            (§ block
                (§ var #_"Thread" (§ name t) (§ new #_"Thread" (§ pars r)))
                (§ expr t.setName(§ pars "Threading.THREAD_POOL worker"))
                (§ expr t.setDaemon(§ pars true))
                (§ return t)
            )
        )))))
)

#_(ns org.bitcoinj.utils #_"VersionTally"
    (:import [java.util Stack])
   (:require [org.bitcoinj.core NetworkParameters StoredBlock]
             [org.bitcoinj.store BlockStore BlockStoreException]))

;;;
 ; Caching counter for the block versions within a moving window.  This class is NOT thread safe
 ; (as if two threads are trying to use it concurrently, there's risk of getting versions out of sequence).
 ;
 ; @see org.bitcoinj.core.NetworkParameters#getMajorityWindow()
 ; @see org.bitcoinj.core.NetworkParameters#getMajorityEnforceBlockUpgrade()
 ; @see org.bitcoinj.core.NetworkParameters#getMajorityRejectBlockOutdated()
 ;;
#_public
(§ class #_"VersionTally"
    ;;;
     ; Cache of version numbers.
     ;;
    #_private
    #_final
    (§ field #_"long[]" (§ name versionWindow))

    ;;;
     ; Offset within the version window at which the next version will be written.
     ;;
    #_private
    (§ field #_"int" (§ name versionWriteHead) 0)

    ;;;
     ; Number of versions written into the tally.  Until this matches the length
     ; of the version window, we do not have sufficient data to return values.
     ;;
    #_private
    (§ field #_"int" (§ name versionsStored) 0)

    #_public
    (§ constructor #_"VersionTally" [#_final #_"NetworkParameters" (§ name params)])
    (§ block
        (§ ass (§ name versionWindow) (§ new #_"long[]" (§ count params.getMajorityWindow(§ pars ))))
        (§ void this)
    )

    ;;;
     ; Add a new block version to the tally, and return the count for that version within the window.
     ;
     ; @param version The block version to add.
     ;;
    #_public
    (§ method #_"void" (§ fn add) [#_final #_"long" (§ name version)])
    (§ block
        (§ ass (§ name versionWindow[versionWriteHead]) version)
        (§ ass (§ name versionWriteHead) (§ expr versionWriteHead + 1))
        (§ if (§ expr versionWriteHead == versionWindow.length))
        (§ block
            (§ ass (§ name versionWriteHead) 0)
        )
        (§ ass (§ name versionsStored) (§ expr versionsStored + 1))
        (§ void nil)
    )

    ;;;
     ; Get the count of blocks at or above the given version, within the window.
     ;
     ; @param version The block version to query.
     ; @return the count for the block version, or null if the window is not yet full.
     ;;
    #_public
    (§ method #_"Integer" (§ fn getCountAtOrAbove) [#_final #_"long" (§ name version)])
    (§ block
        (§ if (§ expr versionsStored < versionWindow.length))
        (§ block
            (§ return nil)
        )

        (§ var #_"int" (§ name count) 0)
        (§ for (§ var #_"int" (§ name versionIdx) 0) :for (§ expr versionIdx < versionWindow.length) :for (§ ass (§ name versionIdx) (§ expr versionIdx + 1)))
        (§ block
            (§ if (§ expr version <= versionWindow[versionIdx]))
            (§ block
                (§ ass (§ name count) (§ expr count + 1))
            )
        )

        (§ return count)
    )

    ;;;
     ; Initialize the version tally from the block store.  Note this does not search backwards past
     ; the start of the block store, so if starting from a checkpoint this may not fill the window.
     ;
     ; @param blockStore Block store to load blocks from.
     ; @param chainHead Current chain tip.
     ;;
    #_public
    (§ method #_"void" (§ fn initialize) [#_final #_"BlockStore" (§ name blockStore), #_final #_"StoredBlock" (§ name chainHead)])
        (§ throws #_"BlockStoreException")
    (§ block
        (§ var #_"StoredBlock" (§ name versionBlock) chainHead)
        #_final
        (§ var #_"Stack<Long>" (§ name versions) (§ new #_"Stack<>" (§ pars )))

        ;; We don't know how many blocks back we can go, so load what we can first.
        (§ expr versions.push(§ pars versionBlock.getHeader(§ pars ).getVersion(§ pars )))
        (§ for (§ var #_"int" (§ name headOffset) 0) :for (§ expr headOffset < versionWindow.length) :for (§ ass (§ name headOffset) (§ expr headOffset + 1)))
        (§ block
            (§ ass (§ name versionBlock) (§ expr versionBlock.getPrev(§ pars blockStore)))
            (§ if (§ expr versionBlock == nil))
            (§ block
                (§ break )
            )
            (§ expr versions.push(§ pars versionBlock.getHeader(§ pars ).getVersion(§ pars )))
        )

        ;; Replay the versions into the tally.
        (§ while (§ expr (§ not versions.isEmpty(§ pars ))))
        (§ block
            (§ expr add(§ pars versions.pop(§ pars )))
        )
        (§ void nil)
    )

    ;;;
     ; Get the size of the version window.
     ;;
    #_public
    (§ method #_"int" (§ fn size) [])
    (§ block
        (§ return (§ expr versionWindow.length))
    )
)

#_(ns org.bitcoinj.wallet #_"AllRandomKeysRotating")

;;;
 ; Indicates that an attempt was made to upgrade a random wallet to deterministic, but there were no non-rotating
 ; random keys to use as source material for the seed.  Add a non-compromised key first!
 ;;
#_public
(§ class #_"AllRandomKeysRotating" (§ extends #_"RuntimeException"))

#_(ns org.bitcoinj.wallet #_"AllowUnconfirmedCoinSelector"
   (:require [org.bitcoinj.core Transaction]))

;;;
 ; This coin selector will select any transaction at all, regardless of where it came from or whether it was
 ; confirmed yet.  However immature coinbases will not be included (would be a protocol violation).
 ;;
#_public
(§ class #_"AllowUnconfirmedCoinSelector" (§ extends #_"DefaultCoinSelector")
    #_override
    #_protected
    (§ method #_"boolean" (§ fn shouldSelect) [#_"Transaction" (§ name tx)])
    (§ block
        (§ return true)
    )

    #_private
    #_static
    (§ field #_"AllowUnconfirmedCoinSelector" (§ name instance))

    ;;; Returns a global static instance of the selector. ;;
    #_public
    #_static
    (§ method #_"AllowUnconfirmedCoinSelector" (§ fn get) [])
    (§ block
        ;; This doesn't have to be thread safe as the object has no state, so discarded duplicates are harmless.
        (§ if (§ expr instance == nil))
        (§ block
            (§ ass (§ name instance) (§ new #_"AllowUnconfirmedCoinSelector" (§ pars )))
        )
        (§ return instance)
    )
)

#_(ns org.bitcoinj.wallet #_"BasicKeyChain"
    (:import [java.util *]
             [java.util.concurrent CopyOnWriteArrayList Executor]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect ImmutableList Lists]
             [com.google.protobuf ByteString]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core BloomFilter ECKey]
             [org.bitcoinj.crypto *]
             [org.bitcoinj.utils ListenerRegistration Threading]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

;;;
 ; A {@link KeyChain} that implements the simplest model possible: it can have keys imported into it, and just
 ; acts as a dumb bag of keys.  It will, left to its own devices, always return the same key for usage by the wallet,
 ; although it will automatically add one to itself if it's empty or if encryption is requested.
 ;;
#_public
(§ class #_"BasicKeyChain" (§ implements #_"EncryptableKeyChain")
    #_private
    #_final
    (§ field #_"ReentrantLock" (§ name lock) (§ expr Threading/lock(§ pars "BasicKeyChain")))

    ;; Maps used to let us quickly look up a key given data we find in transcations or the block chain.
    #_private
    #_final
    (§ field #_"LinkedHashMap<ByteString, ECKey>" (§ name hashToKeys))
    #_private
    #_final
    (§ field #_"LinkedHashMap<ByteString, ECKey>" (§ name pubkeyToKeys))
    #_nilable
    #_private
    #_final
    (§ field #_"KeyCrypter" (§ name keyCrypter))
    #_private
    (§ field #_"boolean" (§ name isWatching))

    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<KeyChainEventListener>>" (§ name listeners))

    #_public
    (§ constructor #_"BasicKeyChain" [])
    (§ block
        (§ this (§ pars nil))
        (§ void this)
    )

    #_public
    (§ constructor #_"BasicKeyChain" [#_nilable #_"KeyCrypter" (§ name crypter)])
    (§ block
        (§ ass (§ name this.keyCrypter) crypter)
        (§ ass (§ name hashToKeys) (§ new #_"LinkedHashMap<>" (§ pars )))
        (§ ass (§ name pubkeyToKeys) (§ new #_"LinkedHashMap<>" (§ pars )))
        (§ ass (§ name listeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
        (§ void this)
    )

    ;;; Returns the {@link KeyCrypter} in use or null if the key chain is not encrypted. ;;
    #_override
    #_nilable
    #_public
    (§ method #_"KeyCrypter" (§ fn getKeyCrypter) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return keyCrypter)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method #_"ECKey" (§ fn getKey) [#_nilable #_"KeyPurpose" (§ name ignored)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr hashToKeys.isEmpty(§ pars )))
            (§ block
                ;; We will refuse to encrypt an empty key chain.
                (§ expr Preconditions/checkState(§ pars keyCrypter == nil))

                #_final
                (§ var #_"ECKey" (§ name key) (§ new #_"ECKey" (§ pars )))
                (§ expr importKeyLocked(§ pars key))
                (§ expr queueOnKeysAdded(§ pars ImmutableList/of(§ pars key)))
            )
            (§ return (§ expr hashToKeys.values(§ pars ).iterator(§ pars ).next(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method #_"List<ECKey>" (§ fn getKeys) [#_nilable #_"KeyPurpose" (§ name purpose), #_"int" (§ name numberOfKeys)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars 0 < numberOfKeys))

        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr hashToKeys.size(§ pars ) < numberOfKeys))
            (§ block
                (§ expr Preconditions/checkState(§ pars keyCrypter == nil))

                (§ var #_"List<ECKey>" (§ name keys) (§ new #_"ArrayList<>" (§ pars )))
                (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numberOfKeys - hashToKeys.size(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
                (§ block
                    (§ expr keys.add(§ pars (§ new #_"ECKey" (§ pars ))))
                )

                (§ var #_"ImmutableList<ECKey>" (§ name immutableKeys) (§ expr ImmutableList/copyOf(§ pars keys)))
                (§ expr importKeysLocked(§ pars immutableKeys))
                (§ expr queueOnKeysAdded(§ pars immutableKeys))
            )

            (§ var #_"List<ECKey>" (§ name keysToReturn) (§ new #_"ArrayList<>" (§ pars )))
            (§ var #_"int" (§ name count) 0)
            (§ while (§ expr hashToKeys.values(§ pars ).iterator(§ pars ).hasNext(§ pars ) && numberOfKeys != count))
            (§ block
                (§ expr keysToReturn.add(§ pars hashToKeys.values(§ pars ).iterator(§ pars ).next(§ pars )))
                (§ ass (§ name count) (§ expr count + 1))
            )
            (§ return keysToReturn)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;; Returns a copy of the list of keys that this chain is managing. ;;
    #_public
    (§ method #_"List<ECKey>" (§ fn getKeys) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ new #_"ArrayList<>" (§ pars hashToKeys.values(§ pars ))))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_public
    (§ method #_"int" (§ fn importKeys) [#_"ECKey..." (§ name keys)])
    (§ block
        (§ return (§ expr importKeys(§ pars ImmutableList/copyOf(§ pars keys))))
    )

    #_public
    (§ method #_"int" (§ fn importKeys) [#_"List<? extends ECKey>" (§ name keys)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; Check that if we're encrypted, the keys are all encrypted, and if we're not, that none are.
            ;; We are NOT checking that the actual password matches here because we don't have access to the
            ;; password at this point: if you screw up and import keys with mismatched passwords, you lose!
            ;; So make sure the password is checked first.
            (§ for (§ var #_"ECKey" (§ name key)) :for keys)
            (§ block
                (§ expr checkKeyEncryptionStateMatches(§ pars key))
            )

            (§ var #_"List<ECKey>" (§ name actuallyAdded) (§ new #_"ArrayList<>" (§ pars keys.size(§ pars ))))
            (§ for (§ var #_final ECKey key) :for keys)
            (§ block
                (§ if (§ expr (§ not hasKey(§ pars key))))
                (§ block
                    (§ expr actuallyAdded.add(§ pars key))
                    (§ expr importKeyLocked(§ pars key))
                )
            )
            (§ if (§ expr 0 < actuallyAdded.size(§ pars )))
            (§ block
                (§ expr queueOnKeysAdded(§ pars actuallyAdded))
            )
            (§ return (§ expr actuallyAdded.size(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_private
    (§ method #_"void" (§ fn checkKeyEncryptionStateMatches) [#_"ECKey" (§ name key)])
    (§ block
        (§ if (§ expr keyCrypter == nil && key.isEncrypted(§ pars )))
        (§ block
            (§ throw (§ new #_"KeyCrypterException" (§ pars "Key is encrypted but chain is not")))
        )
        (§ if (§ expr keyCrypter != nil && (§ not key.isEncrypted(§ pars ))))
        (§ block
            (§ throw (§ new #_"KeyCrypterException" (§ pars "Key is not encrypted but chain is")))
        )
        (§ if (§ expr keyCrypter != nil && key.getKeyCrypter(§ pars ) != nil && (§ not (§ dot key.getKeyCrypter(§ pars ).equals(§ pars keyCrypter)))))
        (§ block
            (§ throw (§ new #_"KeyCrypterException" (§ pars "Key encrypted under different parameters to chain")))
        )
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn importKeyLocked) [#_"ECKey" (§ name key)])
    (§ block
        (§ if (§ expr hashToKeys.isEmpty(§ pars )))
        (§ block
            (§ ass (§ name isWatching) (§ expr key.isWatching(§ pars )))
        )
        (§ else )
        (§ block
            (§ if (§ expr key.isWatching(§ pars ) && (§ not isWatching)))
            (§ block
                (§ throw (§ new #_"IllegalArgumentException" (§ pars "Key is watching but chain is not")))
            )
            (§ if (§ expr (§ not key.isWatching(§ pars )) && isWatching))
            (§ block
                (§ throw (§ new #_"IllegalArgumentException" (§ pars "Key is not watching but chain is")))
            )
        )
        (§ var #_"ECKey" (§ name previousKey) (§ expr pubkeyToKeys.put(§ pars ByteString/copyFrom(§ pars key.getPubKey(§ pars )), key)))
        (§ expr hashToKeys.put(§ pars ByteString/copyFrom(§ pars key.getPubKeyHash(§ pars )), key))
        (§ expr Preconditions/checkState(§ pars previousKey == nil))
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn importKeysLocked) [#_"List<ECKey>" (§ name keys)])
    (§ block
        (§ for (§ var #_"ECKey" (§ name key)) :for keys)
        (§ block
            (§ expr importKeyLocked(§ pars key))
        )
        (§ void nil)
    )

    ;;;
     ; Imports a key to the key chain.  If key is present in the key chain, ignore it.
     ;;
    #_public
    (§ method #_"void" (§ fn importKey) [#_"ECKey" (§ name key)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr checkKeyEncryptionStateMatches(§ pars key))
            (§ if (§ expr hasKey(§ pars key)))
            (§ block
                (§ return nil)
            )

            (§ expr importKeyLocked(§ pars key))
            (§ expr queueOnKeysAdded(§ pars ImmutableList/of(§ pars key)))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    #_public
    (§ method #_"ECKey" (§ fn findKeyFromPubHash) [#_"byte[]" (§ name pubkeyHash)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr hashToKeys.get(§ pars ByteString/copyFrom(§ pars pubkeyHash))))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_public
    (§ method #_"ECKey" (§ fn findKeyFromPubKey) [#_"byte[]" (§ name pubkey)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr pubkeyToKeys.get(§ pars ByteString/copyFrom(§ pars pubkey))))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn hasKey) [#_"ECKey" (§ name key)])
    (§ block
        (§ return (§ expr findKeyFromPubKey(§ pars key.getPubKey(§ pars )) != nil))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn numKeys) [])
    (§ block
        (§ return (§ expr pubkeyToKeys.size(§ pars )))
    )

    ;;; Whether this basic key chain is empty, full of regular (usable for signing) keys, or full of watching keys. ;;
    #_public
    (§ enum #_"State"
        (§ item EMPTY)
        (§ item WATCHING)
        (§ item REGULAR)
    )

    ;;;
     ; Returns whether this chain consists of pubkey only (watching) keys, regular keys (usable for signing),
     ; or has no keys in it yet at all (thus we cannot tell).
     ;;
    #_public
    (§ method #_"State" (§ fn isWatching) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ quest (§ expr hashToKeys.isEmpty(§ pars )) ? (§ expr State/EMPTY) :else (§ quest isWatching ? (§ expr State/WATCHING) :else (§ expr State/REGULAR))))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Removes the given key from the keychain.  Be very careful with this - losing a private key
     ; <b>destroys the money associated with it</b>.
     ; @return whether the key was removed or not.
     ;;
    #_public
    (§ method #_"boolean" (§ fn removeKey) [#_"ECKey" (§ name key)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"boolean" (§ name a) (§ expr hashToKeys.remove(§ pars ByteString/copyFrom(§ pars key.getPubKeyHash(§ pars ))) != nil))
            (§ var #_"boolean" (§ name b) (§ expr pubkeyToKeys.remove(§ pars ByteString/copyFrom(§ pars key.getPubKey(§ pars ))) != nil))
            (§ expr Preconditions/checkState(§ pars a == b)) ;; Should be in both maps or neither.
            (§ return a)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method #_"long" (§ fn getEarliestKeyCreationTime) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"long" (§ name time) (§ expr Long/MAX_VALUE))
            (§ for (§ var #_"ECKey" (§ name key)) :for (§ expr hashToKeys.values(§ pars )))
            (§ block
                (§ ass (§ name time) (§ expr Math/min(§ pars key.getCreationTimeSeconds(§ pars ), time)))
            )
            (§ return time)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_public
    (§ method #_"List<ListenerRegistration<KeyChainEventListener>>" (§ fn getListeners) [])
    (§ block
        (§ return (§ new #_"ArrayList<>" (§ pars listeners)))
    )

    (§ method #_"Map<ECKey, Protos.Key.Builder>" (§ fn serializeToEditableProtobufs) [])
    (§ block
        (§ var #_"Map<ECKey, Protos.Key.Builder>" (§ name result) (§ new #_"LinkedHashMap<>" (§ pars )))
        (§ for (§ var #_"ECKey" (§ name ecKey)) :for (§ expr hashToKeys.values(§ pars )))
        (§ block
            (§ var #_"Protos.Key.Builder" (§ name protoKey) (§ expr serializeEncryptableItem(§ pars ecKey)))
            (§ expr protoKey.setPublicKey(§ pars ByteString/copyFrom(§ pars ecKey.getPubKey(§ pars ))))
            (§ expr result.put(§ pars ecKey, protoKey))
        )
        (§ return result)
    )

    #_override
    #_public
    (§ method #_"List<Protos.Key>" (§ fn serializeToProtobuf) [])
    (§ block
        (§ var #_"Collection<Protos.Key.Builder>" (§ name builders) (§ expr serializeToEditableProtobufs(§ pars ).values(§ pars )))
        (§ var #_"List<Protos.Key>" (§ name result) (§ new #_"ArrayList<>" (§ pars builders.size(§ pars ))))
        (§ for (§ var #_"Protos.Key.Builder" (§ name builder)) :for builders)
        (§ block
            (§ expr result.add(§ pars builder.build(§ pars )))
        )
        (§ return result)
    )

    #_static
    (§ method #_"Protos.Key.Builder" (§ fn serializeEncryptableItem) [#_"EncryptableItem" (§ name item)])
    (§ block
        (§ var #_"Protos.Key.Builder" (§ name proto) (§ expr Protos/Key.newBuilder(§ pars )))
        (§ expr proto.setCreationTimestamp(§ pars item.getCreationTimeSeconds(§ pars ) * 1000))
        (§ if (§ expr item.isEncrypted(§ pars ) && item.getEncryptedData(§ pars ) != nil))
        (§ block
            ;; The encrypted data can be missing for an "encrypted" key in the case of a deterministic wallet
            ;; for which the leaf keys chain to an encrypted parent and rederive their private keys on the fly.
            ;; In that case the caller in DeterministicKeyChain will take care of setting the type.
            (§ var #_"EncryptedData" (§ name data) (§ expr item.getEncryptedData(§ pars )))
            (§ expr proto.getEncryptedDataBuilder(§ pars ).setEncryptedPrivateKey(§ pars ByteString/copyFrom(§ pars data.encryptedBytes)).setInitialisationVector(§ pars ByteString/copyFrom(§ pars data.initialisationVector)))
            ;; We don't allow mixing of encryption types at the moment.
            (§ expr Preconditions/checkState(§ pars item.getEncryptionType(§ pars ) == Protos/Wallet/EncryptionType/ENCRYPTED_SCRYPT_AES))
            (§ expr proto.setType(§ pars Protos/Key/Type/ENCRYPTED_SCRYPT_AES))
        )
        (§ else )
        (§ block
            #_final
            (§ var #_"byte[]" (§ name secret) (§ expr item.getSecretBytes(§ pars )))
            ;; The secret might be missing in the case of a watching wallet, or a key for which the private key
            ;; is expected to be rederived on the fly from its parent.
            (§ if (§ expr secret != nil))
            (§ block
                (§ expr proto.setSecretBytes(§ pars ByteString/copyFrom(§ pars secret)))
            )
            (§ expr proto.setType(§ pars Protos/Key/Type/ORIGINAL))
        )
        (§ return proto)
    )

    ;;;
     ; Returns a new BasicKeyChain that contains all basic, ORIGINAL type keys extracted from the list.
     ; Unrecognised key types are ignored.
     ;;
    #_public
    #_static
    (§ method #_"BasicKeyChain" (§ fn fromProtobufUnencrypted) [#_"List<Protos.Key>" (§ name keys)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        (§ var #_"BasicKeyChain" (§ name chain) (§ new #_"BasicKeyChain" (§ pars )))
        (§ expr chain.deserializeFromProtobuf(§ pars keys))
        (§ return chain)
    )

    ;;;
     ; Returns a new BasicKeyChain that contains all basic, ORIGINAL type keys and also any encrypted keys
     ; extracted from the list.  Unrecognised key types are ignored.
     ; @throws org.bitcoinj.wallet.UnreadableWalletException.BadPassword if the password doesn't seem to match.
     ; @throws org.bitcoinj.wallet.UnreadableWalletException if the data structures are corrupted/inconsistent.
     ;;
    #_public
    #_static
    (§ method #_"BasicKeyChain" (§ fn fromProtobufEncrypted) [#_"List<Protos.Key>" (§ name keys), #_"KeyCrypter" (§ name crypter)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        (§ var #_"BasicKeyChain" (§ name chain) (§ new #_"BasicKeyChain" (§ pars Preconditions/checkNotNull(§ pars crypter))))
        (§ expr chain.deserializeFromProtobuf(§ pars keys))
        (§ return chain)
    )

    #_private
    (§ method #_"void" (§ fn deserializeFromProtobuf) [#_"List<Protos.Key>" (§ name keys)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr Preconditions/checkState(§ pars hashToKeys.isEmpty(§ pars ), "Tried to deserialize into a non-empty chain"))
            (§ for (§ var #_"Protos.Key" (§ name key)) :for keys)
            (§ block
                (§ if (§ expr key.getType(§ pars ) != Protos/Key/Type/ORIGINAL && key.getType(§ pars ) != Protos/Key/Type/ENCRYPTED_SCRYPT_AES))
                (§ block
                    (§ continue )
                )

                (§ var #_"boolean" (§ name encrypted) (§ expr key.getType(§ pars ) == Protos/Key/Type/ENCRYPTED_SCRYPT_AES))
                (§ var #_"byte[]" (§ name priv) (§ quest (§ expr key.hasSecretBytes(§ pars )) ? (§ dot key.getSecretBytes(§ pars ).toByteArray(§ pars )) :else nil))
                (§ if (§ expr (§ not key.hasPublicKey(§ pars ))))
                (§ block
                    (§ throw (§ new #_"UnreadableWalletException" (§ pars "Public key missing")))
                )

                (§ var #_"byte[]" (§ name pub) (§ expr key.getPublicKey(§ pars ).toByteArray(§ pars )))
                (§ var #_"ECKey" (§ name ecKey))
                (§ if encrypted)
                (§ block
                    (§ expr Preconditions/checkState(§ pars keyCrypter != nil, "This wallet is encrypted but encrypt() was not called prior to deserialization"))
                    (§ if (§ expr (§ not key.hasEncryptedData(§ pars ))))
                    (§ block
                        (§ throw (§ new #_"UnreadableWalletException" (§ pars "Encrypted private key data missing")))
                    )

                    (§ var #_"Protos.EncryptedData" (§ name proto) (§ expr key.getEncryptedData(§ pars )))
                    (§ var #_"EncryptedData" (§ name e) (§ new #_"EncryptedData" (§ pars proto.getInitialisationVector(§ pars ).toByteArray(§ pars ), proto.getEncryptedPrivateKey(§ pars ).toByteArray(§ pars ))))
                    (§ ass (§ name ecKey) (§ expr ECKey/fromEncrypted(§ pars e, keyCrypter, pub)))
                )
                (§ else )
                (§ block
                    (§ ass (§ name ecKey) (§ quest (§ expr priv != nil) ? (§ expr ECKey/fromPrivateAndPrecalculatedPublic(§ pars priv, pub)) :else (§ expr ECKey/fromPublicOnly(§ pars pub))))
                )
                (§ expr ecKey.setCreationTimeSeconds(§ pars key.getCreationTimestamp(§ pars ) / 1000))
                (§ expr importKeyLocked(§ pars ecKey))
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn addEventListener) [#_"KeyChainEventListener" (§ name listener)])
    (§ block
        (§ expr addEventListener(§ pars listener, Threading/USER_THREAD))
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn addEventListener) [#_"KeyChainEventListener" (§ name listener), #_"Executor" (§ name executor)])
    (§ block
        (§ expr listeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars listener, executor))))
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn removeEventListener) [#_"KeyChainEventListener" (§ name listener)])
    (§ block
        (§ return (§ expr ListenerRegistration/removeFromList(§ pars listener, listeners)))
    )

    #_private
    (§ method #_"void" (§ fn queueOnKeysAdded) [#_final #_"List<ECKey>" (§ name keys)])
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ for (§ var #_final ListenerRegistration<KeyChainEventListener> registration) :for listeners)
        (§ block
            (§ expr registration.executor.execute(§ pars (§ new #_"Runnable" (§ pars ))
            (§ anon
                #_override
                #_public
                (§ method #_"void" (§ fn run) [])
                (§ block
                    (§ expr registration.listener.onKeysAdded(§ pars keys))
                    (§ void nil)
                )
            )))
        )
        (§ void nil)
    )

    ;;;
     ; Convenience wrapper around {@link #toEncrypted(org.bitcoinj.crypto.KeyCrypter, org.spongycastle.crypto.params.KeyParameter)}
     ; which uses the default Scrypt key derivation algorithm and parameters, derives a key from the given password and returns
     ; the created key.
     ;;
    #_override
    #_public
    (§ method #_"BasicKeyChain" (§ fn toEncrypted) [#_"CharSequence" (§ name password)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars password))
        (§ expr Preconditions/checkArgument(§ pars 0 < password.length(§ pars )))

        (§ var #_"KeyCrypter" (§ name scrypt) (§ new #_"KeyCrypterScrypt" (§ pars )))
        (§ var #_"KeyParameter" (§ name derivedKey) (§ expr scrypt.deriveKey(§ pars password)))
        (§ return (§ expr toEncrypted(§ pars scrypt, derivedKey)))
    )

    ;;;
     ; Encrypt the wallet using the KeyCrypter and the AES key.  A good default KeyCrypter to use is
     ; {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @param keyCrypter The KeyCrypter that specifies how to encrypt/ decrypt a key.
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming
     ;               to create from a password).
     ; @throws KeyCrypterException if the wallet encryption fails.  If so, the wallet state is unchanged.
     ;;
    #_override
    #_public
    (§ method #_"BasicKeyChain" (§ fn toEncrypted) [#_"KeyCrypter" (§ name keyCrypter), #_"KeyParameter" (§ name aesKey)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr Preconditions/checkNotNull(§ pars keyCrypter))
            (§ expr Preconditions/checkState(§ pars this.keyCrypter == nil, "Key chain is already encrypted"))

            (§ var #_"BasicKeyChain" (§ name encrypted) (§ new #_"BasicKeyChain" (§ pars keyCrypter)))
            (§ for (§ var #_"ECKey" (§ name key)) :for (§ expr hashToKeys.values(§ pars )))
            (§ block
                (§ var #_"ECKey" (§ name encryptedKey) (§ expr key.encrypt(§ pars keyCrypter, aesKey)))
                ;; Check that the encrypted key can be successfully decrypted.
                ;; This is done as it is a critical failure if the private key cannot be decrypted successfully
                ;; (all bitcoin controlled by that private key is lost forever).
                ;; For a correctly constructed keyCrypter the encryption should always be reversible so it is just
                ;; being as cautious as possible.
                (§ if (§ expr (§ not ECKey/encryptionIsReversible(§ pars key, encryptedKey, keyCrypter, aesKey))))
                (§ block
                    (§ throw (§ new #_"KeyCrypterException" (§ pars "The key " + key + " cannot be successfully decrypted after encryption so aborting wallet encryption.")))
                )
                (§ expr encrypted.importKeyLocked(§ pars encryptedKey))
            )
            (§ return encrypted)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method #_"BasicKeyChain" (§ fn toDecrypted) [#_"CharSequence" (§ name password)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars keyCrypter, "Wallet is already decrypted"))

        (§ return (§ expr toDecrypted(§ pars keyCrypter.deriveKey(§ pars password))))
    )

    #_override
    #_public
    (§ method #_"BasicKeyChain" (§ fn toDecrypted) [#_"KeyParameter" (§ name aesKey)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr Preconditions/checkState(§ pars keyCrypter != nil, "Wallet is already decrypted"))

            ;; Do an up-front check.
            (§ if (§ expr 0 < numKeys(§ pars ) && (§ not checkAESKey(§ pars aesKey))))
            (§ block
                (§ throw (§ new #_"KeyCrypterException" (§ pars "Password/key was incorrect.")))
            )

            (§ var #_"BasicKeyChain" (§ name decrypted) (§ new #_"BasicKeyChain" (§ pars )))
            (§ for (§ var #_"ECKey" (§ name key)) :for (§ expr hashToKeys.values(§ pars )))
            (§ block
                (§ expr decrypted.importKeyLocked(§ pars key.decrypt(§ pars aesKey)))
            )
            (§ return decrypted)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns whether the given password is correct for this key chain.
     ; @throws IllegalStateException if the chain is not encrypted at all.
     ;;
    #_override
    #_public
    (§ method #_"boolean" (§ fn checkPassword) [#_"CharSequence" (§ name password)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars password))
        (§ expr Preconditions/checkState(§ pars keyCrypter != nil, "Key chain not encrypted"))

        (§ return (§ expr checkAESKey(§ pars keyCrypter.deriveKey(§ pars password))))
    )

    ;;;
     ; Check whether the AES key can decrypt the first encrypted key in the wallet.
     ;
     ; @return true if AES key supplied can decrypt the first encrypted private key in the wallet, false otherwise.
     ;;
    #_override
    #_public
    (§ method #_"boolean" (§ fn checkAESKey) [#_"KeyParameter" (§ name aesKey)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; If no keys then cannot decrypt.
            (§ if (§ expr hashToKeys.isEmpty(§ pars )))
            (§ block
                (§ return false)
            )

            (§ expr Preconditions/checkState(§ pars keyCrypter != nil, "Key chain is not encrypted"))

            ;; Find the first encrypted key in the wallet.
            (§ var #_"ECKey" (§ name first) nil)
            (§ for (§ var #_"ECKey" (§ name key)) :for (§ expr hashToKeys.values(§ pars )))
            (§ block
                (§ if (§ expr key.isEncrypted(§ pars )))
                (§ block
                    (§ ass (§ name first) key)
                    (§ break )
                )
            )
            (§ expr Preconditions/checkState(§ pars first != nil, "No encrypted keys in the wallet"))

            (§ try )
            (§ block
                (§ var #_"ECKey" (§ name rebornKey) (§ expr first.decrypt(§ pars aesKey)))
                (§ return (§ expr Arrays/equals(§ pars first.getPubKey(§ pars ), rebornKey.getPubKey(§ pars ))))
            )
            (§ catch #_"KeyCrypterException" (§ name _))
            (§ block
                ;; The AES key supplied is incorrect.
                (§ return false)
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method #_"BloomFilter" (§ fn getFilter) [#_"int" (§ name size), #_"double" (§ name falsePositiveRate), #_"long" (§ name tweak)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"BloomFilter" (§ name filter) (§ new #_"BloomFilter" (§ pars size, falsePositiveRate, tweak)))
            (§ for (§ var #_"ECKey" (§ name key)) :for (§ expr hashToKeys.values(§ pars )))
            (§ block
                (§ expr filter.insert(§ pars key))
            )
            (§ return filter)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method #_"int" (§ fn numBloomFilterEntries) [])
    (§ block
        (§ return (§ expr numKeys(§ pars ) * 2))
    )

    ;;; Returns the first ECKey created after the given UNIX time, or null if there is none. ;;
    #_nilable
    #_public
    (§ method #_"ECKey" (§ fn findOldestKeyAfter) [#_"long" (§ name timeSecs)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"ECKey" (§ name oldest) nil)
            (§ for (§ var #_"ECKey" (§ name key)) :for (§ expr hashToKeys.values(§ pars )))
            (§ block
                #_final
                (§ var #_"long" (§ name keyTime) (§ expr key.getCreationTimeSeconds(§ pars )))
                (§ if (§ expr timeSecs < keyTime && (§ expr oldest == nil || keyTime < oldest.getCreationTimeSeconds(§ pars ))))
                (§ block
                    (§ ass (§ name oldest) key)
                )
            )
            (§ return oldest)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;; Returns a list of all ECKeys created after the given UNIX time. ;;
    #_public
    (§ method #_"List<ECKey>" (§ fn findKeysBefore) [#_"long" (§ name timeSecs)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"List<ECKey>" (§ name results) (§ expr Lists/newLinkedList(§ pars )))
            (§ for (§ var #_"ECKey" (§ name key)) :for (§ expr hashToKeys.values(§ pars )))
            (§ block
                #_final
                (§ var #_"long" (§ name keyTime) (§ expr key.getCreationTimeSeconds(§ pars )))
                (§ if (§ expr keyTime < timeSecs))
                (§ block
                    (§ expr results.add(§ pars key))
                )
            )
            (§ return results)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )
)

#_(ns org.bitcoinj.wallet #_"CoinSelection"
    (:import [java.util Collection])
   (:require [org.bitcoinj.core Coin TransactionOutput]))

;;;
 ; Represents the results of a {@link CoinSelector#select(Coin, java.util.List)} operation.
 ; A coin selection represents a list of spendable transaction outputs that sum together to give valueGathered.
 ; Different coin selections could be produced by different coin selectors from the same input set, according
 ; to their varying policies.
 ;;
#_public
(§ class #_"CoinSelection"
    #_public
    (§ field #_"Coin" (§ name valueGathered))
    #_public
    (§ field #_"Collection<TransactionOutput>" (§ name gathered))

    #_public
    (§ constructor #_"CoinSelection" [#_"Coin" (§ name valueGathered), #_"Collection<TransactionOutput>" (§ name gathered)])
    (§ block
        (§ ass (§ name this.valueGathered) valueGathered)
        (§ ass (§ name this.gathered) gathered)
        (§ void this)
    )
)

#_(ns org.bitcoinj.wallet #_"CoinSelector"
    (:import [java.util List])
   (:require [org.bitcoinj.core Coin TransactionOutput]))

;;;
 ; A CoinSelector is responsible for picking some outputs to spend, from the list of all possible outputs.
 ; It allows you to customize the policies for creation of transactions to suit your needs.  The select operation
 ; may return a {@link CoinSelection} that has a valueGathered lower than the requested target, if there's not
 ; enough money in the wallet.
 ;;
#_public
(§ interface #_"CoinSelector"
    ;;;
     ; Creates a CoinSelection that tries to meet the target amount of value.  The candidates list is given to
     ; this call and can be edited freely.  See the docs for CoinSelection to learn more, or look a the implementation
     ; of {@link DefaultCoinSelector}.
     ;;
    (§ method #_"CoinSelection" (§ fn select) [#_"Coin" (§ name target), #_"List<TransactionOutput>" (§ name candidates)])
)

#_(ns org.bitcoinj.wallet #_"DecryptingKeyBag"
    (:import [java.util ArrayList List])
    (:import [com.google.common.base Preconditions]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core ECKey]))

;;;
 ; A DecryptingKeyBag filters a pre-existing key bag, decrypting keys as they are requested using the provided AES key.
 ; If the keys are encrypted and no AES key provided, {@link org.bitcoinj.core.ECKey.KeyIsEncryptedException} will be thrown.
 ;;
#_public
(§ class #_"DecryptingKeyBag" (§ implements #_"KeyBag")
    #_protected
    #_final
    (§ field #_"KeyBag" (§ name target))
    #_protected
    #_final
    (§ field #_"KeyParameter" (§ name aesKey))

    #_public
    (§ constructor #_"DecryptingKeyBag" [#_"KeyBag" (§ name target), #_nilable #_"KeyParameter" (§ name aesKey)])
    (§ block
        (§ ass (§ name this.target) (§ expr Preconditions/checkNotNull(§ pars target)))
        (§ ass (§ name this.aesKey) aesKey)
        (§ void this)
    )

    #_nilable
    #_private
    (§ method #_"ECKey" (§ fn maybeDecrypt) [#_"ECKey" (§ name key)])
    (§ block
        (§ if (§ expr key == nil))
        (§ block
            (§ return nil)
        )

        (§ if (§ expr key.isEncrypted(§ pars )))
        (§ block
            (§ if (§ expr aesKey == nil))
            (§ block
                (§ throw (§ new #_"ECKey.KeyIsEncryptedException" (§ pars )))
            )
            (§ return (§ expr key.decrypt(§ pars aesKey)))
        )

        (§ return key)
    )

    #_private
    (§ method #_"RedeemData" (§ fn maybeDecrypt) [#_"RedeemData" (§ name redeemData)])
    (§ block
        (§ var #_"List<ECKey>" (§ name decryptedKeys) (§ new #_"ArrayList<>" (§ pars )))
        (§ for (§ var #_"ECKey" (§ name key)) :for (§ expr redeemData.keys))
        (§ block
            (§ expr decryptedKeys.add(§ pars maybeDecrypt(§ pars key)))
        )
        (§ return (§ expr RedeemData/of(§ pars decryptedKeys, redeemData.redeemScript)))
    )

    #_nilable
    #_override
    #_public
    (§ method #_"ECKey" (§ fn findKeyFromPubHash) [#_"byte[]" (§ name pubkeyHash)])
    (§ block
        (§ return (§ expr maybeDecrypt(§ pars target.findKeyFromPubHash(§ pars pubkeyHash))))
    )

    #_nilable
    #_override
    #_public
    (§ method #_"ECKey" (§ fn findKeyFromPubKey) [#_"byte[]" (§ name pubkey)])
    (§ block
        (§ return (§ expr maybeDecrypt(§ pars target.findKeyFromPubKey(§ pars pubkey))))
    )

    #_nilable
    #_override
    #_public
    (§ method #_"RedeemData" (§ fn findRedeemDataFromScriptHash) [#_"byte[]" (§ name scriptHash)])
    (§ block
        (§ return (§ expr maybeDecrypt(§ pars target.findRedeemDataFromScriptHash(§ pars scriptHash))))
    )
)

#_(ns org.bitcoinj.wallet #_"DefaultCoinSelector"
    (:import [java.math BigInteger]
             [java.util *])
    (:import [com.google.common.annotations VisibleForTesting])
   (:require [org.bitcoinj.core Coin NetworkParameters Transaction TransactionConfidence TransactionOutput]))

;;;
 ; This class implements a {@link CoinSelector} which attempts to get the highest priority possible.
 ; This means that the transaction is the most likely to get confirmed.  Note that this means we may end up
 ; "spending" more priority than would be required to get the transaction we are creating confirmed.
 ;;
#_public
(§ class #_"DefaultCoinSelector" (§ implements #_"CoinSelector")
    #_override
    #_public
    (§ method #_"CoinSelection" (§ fn select) [#_"Coin" (§ name target), #_"List<TransactionOutput>" (§ name candidates)])
    (§ block
        (§ var #_"ArrayList<TransactionOutput>" (§ name selected) (§ new #_"ArrayList<>" (§ pars )))
        ;; Sort the inputs by age * value, so we get the highest "coindays" spent.
        ;; TODO: Consider changing the wallets internal format to track just outputs and keep them ordered.
        (§ var #_"ArrayList<TransactionOutput>" (§ name sortedOutputs) (§ new #_"ArrayList<>" (§ pars candidates)))
        ;; When calculating the wallet balance, we may be asked to select all possible coins, if so, avoid
        ;; sorting them in order to improve performance.
        ;; TODO: Take in network parameters when instanatiated, and then test against the current network.
        ;; Or just have a boolean parameter for "give me everything".
        (§ if (§ expr (§ not target.equals(§ pars NetworkParameters/MAX_MONEY))))
        (§ block
            (§ expr sortOutputs(§ pars sortedOutputs))
        )
        ;; Now iterate over the sorted outputs until we have got as close to the target as possible or
        ;; a little bit over (excessive value will be change).
        (§ var #_"long" (§ name total) 0)
        (§ for (§ var #_"TransactionOutput" (§ name output)) :for sortedOutputs)
        (§ block
            (§ if (§ expr target.value <= total))
            (§ block
                (§ break )
            )
            ;; Only pick chain-included transactions, or transactions that are ours and pending.
            (§ if (§ expr shouldSelect(§ pars output.getParentTransaction(§ pars ))))
            (§ block
                (§ expr selected.add(§ pars output))
                (§ ass (§ name total) (§ expr total + output.getValue(§ pars ).value))
            )
        )
        ;; Total may be lower than the target here if the given candidates were insufficient to create
        ;; the requested transaction.
        (§ return (§ new #_"CoinSelection" (§ pars Coin/valueOf(§ pars total), selected)))
    )

    #_testing
    #_static
    (§ method #_"void" (§ fn sortOutputs) [#_"ArrayList<TransactionOutput>" (§ name outputs)])
    (§ block
        (§ expr Collections/sort(§ pars outputs, new Comparator<TransactionOutput>(§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"int" (§ fn compare) [#_"TransactionOutput" (§ name a), #_"TransactionOutput" (§ name b)])
            (§ block
                (§ var #_"int" (§ name depth1) (§ expr a.getParentTransactionDepthInBlocks(§ pars )))
                (§ var #_"int" (§ name depth2) (§ expr b.getParentTransactionDepthInBlocks(§ pars )))
                (§ var #_"Coin" (§ name aValue) (§ expr a.getValue(§ pars )))
                (§ var #_"Coin" (§ name bValue) (§ expr b.getValue(§ pars )))
                (§ var #_"BigInteger" (§ name aCoinDepth) (§ expr BigInteger/valueOf(§ pars aValue.value).multiply(§ pars BigInteger/valueOf(§ pars depth1))))
                (§ var #_"BigInteger" (§ name bCoinDepth) (§ expr BigInteger/valueOf(§ pars bValue.value).multiply(§ pars BigInteger/valueOf(§ pars depth2))))
                (§ var #_"int" (§ name c1) (§ expr bCoinDepth.compareTo(§ pars aCoinDepth)))
                (§ if (§ expr c1 != 0))
                (§ block
                    (§ return c1)
                )

                ;; The "coin * days" destroyed are equal, sort by value alone to get the lowest transaction size.
                (§ var #_"int" (§ name c2) (§ expr bValue.compareTo(§ pars aValue)))
                (§ if (§ expr c2 != 0))
                (§ block
                    (§ return c2)
                )

                ;; They are entirely equivalent (possibly pending) so sort by hash to ensure a total ordering.
                (§ var #_"BigInteger" (§ name aHash) (§ expr a.getParentTransactionHash(§ pars ).toBigInteger(§ pars )))
                (§ var #_"BigInteger" (§ name bHash) (§ expr b.getParentTransactionHash(§ pars ).toBigInteger(§ pars )))
                (§ return (§ expr aHash.compareTo(§ pars bHash)))
            )
        )))
        (§ void nil)
    )

    ;;; Sub-classes can override this to just customize whether transactions are usable, but keep age sorting. ;;
    #_protected
    (§ method #_"boolean" (§ fn shouldSelect) [#_"Transaction" (§ name tx)])
    (§ block
        (§ return (§ quest (§ expr tx != nil) ? (§ expr isSelectable(§ pars tx)) :else true))
    )

    #_public
    #_static
    (§ method #_"boolean" (§ fn isSelectable) [#_"Transaction" (§ name tx)])
    (§ block
        ;; Only pick chain-included transactions, or transactions that are ours and pending.
        (§ var #_"TransactionConfidence" (§ name confidence) (§ expr tx.getConfidence(§ pars )))
        (§ var #_"TransactionConfidence.ConfidenceType" (§ name type) (§ expr confidence.getConfidenceType(§ pars )))
        ;; TODO: The value 1 below dates from a time when transactions we broadcast *to* were counted, set to 0.
        (§ return (§ expr type.equals(§ pars TransactionConfidence/ConfidenceType/BUILDING) || (§ expr type.equals(§ pars TransactionConfidence/ConfidenceType/PENDING) && confidence.getSource(§ pars ).equals(§ pars TransactionConfidence/Source/SELF) && 1 < confidence.numBroadcastPeers(§ pars ))))
    )
)

#_(ns org.bitcoinj.wallet #_"DefaultKeyChainFactory"
   (:require [org.bitcoinj.crypto *]))

;;;
 ; Default factory for creating keychains while de-serializing.
 ;;
#_public
(§ class #_"DefaultKeyChainFactory" (§ implements #_"KeyChainFactory")
    #_override
    #_public
    (§ method #_"DeterministicKeyChain" (§ fn makeKeyChain) [#_"Protos.Key" (§ name key), #_"Protos.Key" (§ name firstSubKey), #_"DeterministicSeed" (§ name seed), #_"KeyCrypter" (§ name crypter), #_"boolean" (§ name isMarried)])
    (§ block
        (§ return (§ quest isMarried ? (§ new #_"MarriedKeyChain" (§ pars seed, crypter)) :else (§ new #_"DeterministicKeyChain" (§ pars seed, crypter))))
    )

    #_override
    #_public
    (§ method #_"DeterministicKeyChain" (§ fn makeWatchingKeyChain) [#_"Protos.Key" (§ name key), #_"Protos.Key" (§ name firstSubKey), #_"DeterministicKey" (§ name accountKey), #_"boolean" (§ name isFollowingKey), #_"boolean" (§ name isMarried)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        (§ if (§ not (§ dot accountKey.getPath(§ pars ).equals(§ pars DeterministicKeyChain/ACCOUNT_ZERO_PATH))))
        (§ block
            (§ throw (§ new #_"UnreadableWalletException" (§ pars "Expecting account key but found key with path: " + HDUtils/formatPath(§ pars accountKey.getPath(§ pars )))))
        )

        (§ return (§ quest isMarried ? (§ new #_"MarriedKeyChain" (§ pars accountKey)) :else (§ new #_"DeterministicKeyChain" (§ pars accountKey, isFollowingKey))))
    )
)

#_(ns org.bitcoinj.wallet #_"DefaultRiskAnalysis"
    (:import [java.util List])
    (:import [com.google.common.base Preconditions]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core Coin ECKey]
             [org.bitcoinj.core.ECKey ECDSASignature]
             [org.bitcoinj.core NetworkParameters Transaction TransactionConfidence TransactionInput TransactionOutput]
             [org.bitcoinj.crypto TransactionSignature]
             [org.bitcoinj.script ScriptChunk]))

;;;
 ; <p>The default risk analysis.  Currently, it only is concerned with whether a tx/dependency is non-final or not,
 ; and whether a tx/dependency violates the dust rules.  Outside of specialised protocols you should not encounter
 ; non-final transactions.</p>
 ;;
#_public
(§ class #_"DefaultRiskAnalysis" (§ implements #_"RiskAnalysis")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"DefaultRiskAnalysis"))))

    ;;;
     ; Any standard output smaller than this value (in satoshis) will be considered risky, as it's most likely
     ; be rejected by the network.  This is usually the same as {@link Transaction#MIN_NONDUST_OUTPUT} but can
     ; be different when the fee is about to change in Bitcoin Core.
     ;;
    #_public
    #_static
    #_final
    (§ field #_"Coin" (§ name MIN_ANALYSIS_NONDUST_OUTPUT) (§ expr Transaction/MIN_NONDUST_OUTPUT))

    #_protected
    #_final
    (§ field #_"Transaction" (§ name tx))
    #_protected
    #_final
    (§ field #_"List<Transaction>" (§ name dependencies))
    #_nilable
    #_protected
    #_final
    (§ field #_"Wallet" (§ name wallet))

    #_private
    (§ field #_"Transaction" (§ name nonStandard))
    #_protected
    (§ field #_"Transaction" (§ name nonFinal))
    #_protected
    (§ field #_"boolean" (§ name analyzed))

    #_private
    (§ constructor #_"DefaultRiskAnalysis" [#_"Wallet" (§ name wallet), #_"Transaction" (§ name tx), #_"List<Transaction>" (§ name dependencies)])
    (§ block
        (§ ass (§ name this.tx) tx)
        (§ ass (§ name this.dependencies) dependencies)
        (§ ass (§ name this.wallet) wallet)
        (§ void this)
    )

    #_override
    #_public
    (§ method #_"Result" (§ fn analyze) [])
    (§ block
        (§ expr Preconditions/checkState(§ pars (§ not analyzed)))
        (§ ass (§ name analyzed) true)

        (§ var #_"Result" (§ name result) (§ expr analyzeIsFinal(§ pars )))
        (§ if (§ expr result != nil && result != Result/OK))
        (§ block
            (§ return result)
        )

        (§ return (§ expr analyzeIsStandard(§ pars )))
    )

    #_nilable
    #_private
    (§ method #_"Result" (§ fn analyzeIsFinal) [])
    (§ block
        ;; Transactions we create ourselves are, by definition, not at risk of double spending against us.
        (§ if (§ expr tx.getConfidence(§ pars ).getSource(§ pars ) == TransactionConfidence/Source/SELF))
        (§ block
            (§ return (§ expr Result/OK))
        )

        ;; We consider transactions that opt into replace-by-fee at risk of double spending.
        (§ if (§ expr tx.isOptInFullRBF(§ pars )))
        (§ block
            (§ ass (§ name nonFinal) tx)
            (§ return (§ expr Result/NON_FINAL))
        )

        (§ if (§ expr wallet == nil))
        (§ block
            (§ return nil)
        )

        #_final
        (§ var #_"int" (§ name height) (§ expr wallet.getLastBlockSeenHeight(§ pars )))
        #_final
        (§ var #_"long" (§ name time) (§ expr wallet.getLastBlockSeenTimeSecs(§ pars )))
        ;; If the transaction has a lock time specified in blocks, we consider that if the tx would become final
        ;; in the next block, it is not risky (as it would confirm normally).
        #_final
        (§ var #_"int" (§ name adjustedHeight) (§ expr height + 1))

        (§ if (§ expr (§ not tx.isFinal(§ pars adjustedHeight, time))))
        (§ block
            (§ ass (§ name nonFinal) tx)
            (§ return (§ expr Result/NON_FINAL))
        )

        (§ for (§ var #_"Transaction" (§ name dep)) :for dependencies)
        (§ block
            (§ if (§ expr (§ not dep.isFinal(§ pars adjustedHeight, time))))
            (§ block
                (§ ass (§ name nonFinal) dep)
                (§ return (§ expr Result/NON_FINAL))
            )
        )

        (§ return (§ expr Result/OK))
    )

    ;;;
     ; The reason a transaction is considered non-standard, returned by {@link #isStandard(org.bitcoinj.core.Transaction)}.
     ;;
    #_public
    (§ enum #_"RuleViolation"
        (§ item NONE)
        (§ item VERSION)
        (§ item DUST)
        (§ item SHORTEST_POSSIBLE_PUSHDATA)
        (§ item NONEMPTY_STACK) ;; Not yet implemented (for post 0.12)
        (§ item SIGNATURE_CANONICAL_ENCODING)
    )

    ;;;
     ; <p>Checks if a transaction is considered "standard" by Bitcoin Core's IsStandardTx and AreInputsStandard functions.</p>
     ;
     ; <p>Note that this method currently only implements a minimum of checks.  More to be added later.</p>
     ;;
    #_public
    #_static
    (§ method #_"RuleViolation" (§ fn isStandard) [#_"Transaction" (§ name tx)])
    (§ block
        ;; TODO: Finish this function off.
        (§ if (§ expr 1 < tx.getVersion(§ pars ) || tx.getVersion(§ pars ) < 1))
        (§ block
            (§ expr log.warn(§ pars "TX considered non-standard due to unknown version number {}", tx.getVersion(§ pars )))
            (§ return (§ expr RuleViolation/VERSION))
        )

        #_final
        (§ var #_"List<TransactionOutput>" (§ name outputs) (§ expr tx.getOutputs(§ pars )))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < outputs.size(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ var #_"TransactionOutput" (§ name output) (§ expr outputs.get(§ pars i)))
            (§ var #_"RuleViolation" (§ name violation) (§ expr isOutputStandard(§ pars output)))
            (§ if (§ expr violation != RuleViolation/NONE))
            (§ block
                (§ expr log.warn(§ pars "TX considered non-standard due to output {} violating rule {}", i, violation))
                (§ return violation)
            )
        )

        #_final
        (§ var #_"List<TransactionInput>" (§ name inputs) (§ expr tx.getInputs(§ pars )))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < inputs.size(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ var #_"TransactionInput" (§ name input) (§ expr inputs.get(§ pars i)))
            (§ var #_"RuleViolation" (§ name violation) (§ expr isInputStandard(§ pars input)))
            (§ if (§ expr violation != RuleViolation/NONE))
            (§ block
                (§ expr log.warn(§ pars "TX considered non-standard due to input {} violating rule {}", i, violation))
                (§ return violation)
            )
        )

        (§ return (§ expr RuleViolation/NONE))
    )

    ;;;
     ; Checks the output to see if the script violates a standardness rule.  Not complete.
     ;;
    #_public
    #_static
    (§ method #_"RuleViolation" (§ fn isOutputStandard) [#_"TransactionOutput" (§ name output)])
    (§ block
        (§ if (§ expr output.getValue(§ pars ).compareTo(§ pars MIN_ANALYSIS_NONDUST_OUTPUT) < 0))
        (§ block
            (§ return (§ expr RuleViolation/DUST))
        )

        (§ for (§ var #_"ScriptChunk" (§ name chunk)) :for (§ expr output.getScriptPubKey(§ pars ).getChunks(§ pars )))
        (§ block
            (§ if (§ expr chunk.isPushData(§ pars ) && (§ not chunk.isShortestPossiblePushData(§ pars ))))
            (§ block
                (§ return (§ expr RuleViolation/SHORTEST_POSSIBLE_PUSHDATA))
            )
        )

        (§ return (§ expr RuleViolation/NONE))
    )

    ;;; Checks if the given input passes some of the AreInputsStandard checks.  Not complete. ;;
    #_public
    #_static
    (§ method #_"RuleViolation" (§ fn isInputStandard) [#_"TransactionInput" (§ name input)])
    (§ block
        (§ for (§ var #_"ScriptChunk" (§ name chunk)) :for (§ expr input.getScriptSig(§ pars ).getChunks(§ pars )))
        (§ block
            (§ if (§ expr chunk.data != nil && (§ not chunk.isShortestPossiblePushData(§ pars ))))
            (§ block
                (§ return (§ expr RuleViolation/SHORTEST_POSSIBLE_PUSHDATA))
            )

            (§ if (§ expr chunk.isPushData(§ pars )))
            (§ block
                (§ var #_"ECDSASignature" (§ name signature))
                (§ try )
                (§ block
                    (§ ass (§ name signature) (§ expr ECKey/ECDSASignature.decodeFromDER(§ pars chunk.data)))
                )
                (§ catch #_"IllegalArgumentException" (§ name _))
                (§ block
                    ;; Doesn't look like a signature.
                    (§ ass (§ name signature) nil)
                )
                (§ if (§ expr signature != nil))
                (§ block
                    (§ if (§ expr (§ not TransactionSignature/isEncodingCanonical(§ pars chunk.data))))
                    (§ block
                        (§ return (§ expr RuleViolation/SIGNATURE_CANONICAL_ENCODING))
                    )
                    (§ if (§ expr (§ not signature.isCanonical(§ pars ))))
                    (§ block
                        (§ return (§ expr RuleViolation/SIGNATURE_CANONICAL_ENCODING))
                    )
                )
            )
        )
        (§ return (§ expr RuleViolation/NONE))
    )

    #_private
    (§ method #_"Result" (§ fn analyzeIsStandard) [])
    (§ block
        ;; The IsStandard rules don't apply on testnet, because they're just a safety mechanism and we don't
        ;; want to crush innovation with valueless test coins.
        (§ if (§ expr wallet != nil && (§ not (§ dot wallet.getNetworkParameters(§ pars ).getId(§ pars ).equals(§ pars NetworkParameters/ID_MAINNET)))))
        (§ block
            (§ return (§ expr Result/OK))
        )

        (§ var #_"RuleViolation" (§ name ruleViolation) (§ expr isStandard(§ pars tx)))
        (§ if (§ expr ruleViolation != RuleViolation/NONE))
        (§ block
            (§ ass (§ name nonStandard) tx)
            (§ return (§ expr Result/NON_STANDARD))
        )

        (§ for (§ var #_"Transaction" (§ name dep)) :for dependencies)
        (§ block
            (§ ass (§ name ruleViolation) (§ expr isStandard(§ pars dep)))
            (§ if (§ expr ruleViolation != RuleViolation/NONE))
            (§ block
                (§ ass (§ name nonStandard) dep)
                (§ return (§ expr Result/NON_STANDARD))
            )
        )

        (§ return (§ expr Result/OK))
    )

    ;;; Returns the transaction that was found to be non-standard, or null. ;;
    #_nilable
    #_public
    (§ method #_"Transaction" (§ fn getNonStandard) [])
    (§ block
        (§ return nonStandard)
    )

    ;;; Returns the transaction that was found to be non-final, or null. ;;
    #_nilable
    #_public
    (§ method #_"Transaction" (§ fn getNonFinal) [])
    (§ block
        (§ return nonFinal)
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ if (§ expr (§ not analyzed)))
        (§ block
            (§ return (§ expr "Pending risk analysis for " + tx.getHashAsString(§ pars )))
        )
        (§ if (§ expr nonFinal != nil))
        (§ block
            (§ return (§ expr "Risky due to non-finality of " + nonFinal.getHashAsString(§ pars )))
        )
        (§ if (§ expr nonStandard != nil))
        (§ block
            (§ return (§ expr "Risky due to non-standard tx " + nonStandard.getHashAsString(§ pars )))
        )

        (§ return (§ expr "Non-risky"))
    )

    #_public
    #_static
    (§ class #_"Analyzer" (§ implements #_"RiskAnalysis.Analyzer")
        #_override
        #_public
        (§ method #_"DefaultRiskAnalysis" (§ fn create) [#_"Wallet" (§ name wallet), #_"Transaction" (§ name tx), #_"List<Transaction>" (§ name dependencies)])
        (§ block
            (§ return (§ new #_"DefaultRiskAnalysis" (§ pars wallet, tx, dependencies)))
        )
    )

    #_public
    #_static
    (§ field #_"Analyzer" (§ name FACTORY) (§ new #_"Analyzer" (§ pars )))
)

#_(ns org.bitcoinj.wallet #_"DeterministicKeyChain"
    (:import [java.math BigInteger]
             [java.security SecureRandom]
             [java.util *]
             [java.util.concurrent Executor]
             [java.util.concurrent.locks ReentrantLock])
    (:import [com.google.common.base Preconditions Stopwatch]
             [com.google.common.collect ImmutableList Iterators]
             #_static [com.google.common.collect.Lists newArrayList]
             #_static [com.google.common.collect.Lists newLinkedList]
             [com.google.common.collect PeekingIterator]
             [com.google.protobuf ByteString]
             [org.slf4j Logger LoggerFactory]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core BloomFilter ECKey NetworkParameters Utils]
             [org.bitcoinj.crypto *]
             [org.bitcoinj.script Script]
             [org.bitcoinj.utils Threading]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

;;;
 ; <p>A deterministic key chain is a {@link KeyChain} that uses the
 ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP 32 standard</a>, as implemented by
 ; {@link org.bitcoinj.crypto.DeterministicHierarchy}, to derive all the keys in the keychain from a master seed.
 ; This type of wallet is extremely convenient and flexible.  Although backing up full wallet files is always a good
 ; idea, to recover money only the root seed needs to be preserved and that is a number small enough that it can be
 ; written down on paper or, when represented using a BIP 39 {@link org.bitcoinj.crypto.MnemonicCode},
 ; dictated over the phone (possibly even memorized).</p>
 ;
 ; <p>Deterministic key chains have other advantages: parts of the key tree can be selectively revealed to allow
 ; for auditing, and new public keys can be generated without access to the private keys, yielding a highly secure
 ; configuration for web servers which can accept payments into a wallet but not spend from them.  This does not work
 ; quite how you would expect due to a quirk of elliptic curve mathematics and the techniques used to deal with it.
 ; A watching wallet is not instantiated using the public part of the master key as you may imagine.  Instead, you
 ; need to take the account key (first child of the master key) and provide the public part of that to the watching
 ; wallet instead.  You can do this by calling {@link #getWatchingKey()} and then serializing it with
 ; {@link org.bitcoinj.crypto.DeterministicKey#serializePubB58(org.bitcoinj.core.NetworkParameters)}.  The resulting
 ; "xpub..." string encodes sufficient information about the account key to create a watching chain via
 ; {@link org.bitcoinj.crypto.DeterministicKey#deserializeB58(org.bitcoinj.crypto.DeterministicKey, String, org.bitcoinj.core.NetworkParameters)}
 ; (with null as the first parameter) and then
 ; {@link DeterministicKeyChain#DeterministicKeyChain(org.bitcoinj.crypto.DeterministicKey)}.</p>
 ;
 ; <p>This class builds on {@link org.bitcoinj.crypto.DeterministicHierarchy} and {@link org.bitcoinj.crypto.DeterministicKey}
 ; by adding support for serialization to and from protobufs, and encryption of parts of the key tree.  Internally it
 ; arranges itself as per the BIP 32 spec, with the seed being used to derive a master key, which is then used to derive
 ; an account key, the account key is used to derive two child keys called the <i>internal</i> and <i>external</i> parent
 ; keys (for change and handing out addresses respectively) and finally the actual leaf keys that users use hanging off
 ; the end.  The leaf keys are special in that they don't internally store the private part at all, instead choosing to
 ; rederive the private key from the parent when needed for signing.  This simplifies the design for encrypted key chains.</p>
 ;
 ; <p>The key chain manages a <i>lookahead zone</i>.  This zone is required because when scanning the chain, you don't
 ; know exactly which keys might receive payments.  The user may have handed out several addresses and received payments
 ; on them, but for latency reasons the block chain is requested from remote peers in bulk, meaning you must
 ; "look ahead" when calculating keys to put in the Bloom filter.  The default lookahead zone is 100 keys, meaning
 ; if the user hands out more than 100 addresses and receives payment on them before the chain is next scanned, some
 ; transactions might be missed.  100 is a reasonable choice for consumer wallets running on CPU constrained devices.
 ; For industrial wallets that are receiving keys all the time, a higher value is more appropriate.  Ideally DKC and
 ; the wallet would know how to adjust this value automatically, but that's not implemented at the moment.</p>
 ;
 ; <p>In fact the real size of the lookahead zone is larger than requested, by default, it's one third larger.  This
 ; is because the act of deriving new keys means recalculating the Bloom filters and this is an expensive operation.
 ; Thus, to ensure we don't have to recalculate on every single new key/address requested or seen we add more buffer
 ; space and only extend the lookahead zone when that buffer is exhausted.  For example with a lookahead zone of 100
 ; keys, you can request 33 keys before more keys will be calculated and the Bloom filter rebuilt and rebroadcast.
 ; But even when you are requesting the 33rd key, you will still be looking 100 keys ahead.</p>
 ;
 ; @author Andreas Schildbach
 ;;
#_suppress(§ opt "PublicStaticCollectionField")
#_public
(§ class #_"DeterministicKeyChain" (§ implements #_"EncryptableKeyChain")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"DeterministicKeyChain"))))
    #_public
    #_static
    #_final
    (§ field #_"String" (§ name DEFAULT_PASSPHRASE_FOR_MNEMONIC) (§ expr ""))

    #_protected
    #_final
    (§ field #_"ReentrantLock" (§ name lock) (§ expr Threading/lock(§ pars "DeterministicKeyChain")))

    #_private
    (§ field #_"DeterministicHierarchy" (§ name hierarchy))
    #_nilable
    #_private
    (§ field #_"DeterministicKey" (§ name rootKey))
    #_nilable
    #_private
    (§ field #_"DeterministicSeed" (§ name seed))

    ;; Paths through the key tree.  External keys are ones that are communicated to other parties.  Internal keys are
    ;; keys created for change addresses, coinbases, mixing, etc - anything that isn't communicated.  The distinction
    ;; is somewhat arbitrary but can be useful for audits.  The first number is the "account number" but we don't use
    ;; that feature yet.  In future we might hand out different accounts for cases where we wish to hand payers
    ;; a payment request that can generate lots of addresses independently.
    ;; The account path may be overridden by subclasses.
    #_public
    #_static
    #_final
    (§ field #_"ImmutableList<ChildNumber>" (§ name ACCOUNT_ZERO_PATH) (§ expr ImmutableList/of(§ pars ChildNumber/ZERO_HARDENED)))
    #_public
    #_static
    #_final
    (§ field #_"ImmutableList<ChildNumber>" (§ name EXTERNAL_SUBPATH) (§ expr ImmutableList/of(§ pars ChildNumber/ZERO)))
    #_public
    #_static
    #_final
    (§ field #_"ImmutableList<ChildNumber>" (§ name INTERNAL_SUBPATH) (§ expr ImmutableList/of(§ pars ChildNumber/ONE)))
    #_public
    #_static
    #_final
    (§ field #_"ImmutableList<ChildNumber>" (§ name EXTERNAL_PATH) (§ expr HDUtils/concat(§ pars ACCOUNT_ZERO_PATH, EXTERNAL_SUBPATH)))
    #_public
    #_static
    #_final
    (§ field #_"ImmutableList<ChildNumber>" (§ name INTERNAL_PATH) (§ expr HDUtils/concat(§ pars ACCOUNT_ZERO_PATH, INTERNAL_SUBPATH)))
    ;; m / 44' / 0' / 0'
    #_public
    #_static
    #_final
    (§ field #_"ImmutableList<ChildNumber>" (§ name BIP44_ACCOUNT_ZERO_PATH) (§ expr ImmutableList/of(§ pars (§ new #_"ChildNumber" (§ pars 44, true)), ChildNumber/ZERO_HARDENED, ChildNumber/ZERO_HARDENED)))

    ;; We try to ensure we have at least this many keys ready and waiting to be handed out via getKey().  See docs
    ;; for getLookaheadSize() for more info on what this is for.  The -1 value means it hasn't been calculated yet.
    ;; For new chains it's set to whatever the default is, unless overridden by setLookaheadSize.  For deserialized
    ;; chains, it will be calculated on demand from the number of loaded keys.
    #_private
    #_static
    #_final
    (§ field #_"int" (§ name LAZY_CALCULATE_LOOKAHEAD) -1)
    #_protected
    (§ field #_"int" (§ name lookaheadSize) 100)
    ;; The lookahead threshold causes us to batch up creation of new keys to minimize the frequency of Bloom filter
    ;; regenerations, which are expensive and will (in future) trigger chain download stalls/retries.  One third is
    ;; an efficiency tradeoff.
    #_protected
    (§ field #_"int" (§ name lookaheadThreshold) (§ expr calcDefaultLookaheadThreshold(§ pars )))

    #_private
    (§ method #_"int" (§ fn calcDefaultLookaheadThreshold) [])
    (§ block
        (§ return (§ expr lookaheadSize / 3))
    )

    ;; The parent keys for external keys (handed out to other people) and internal keys (used for change addresses).
    #_private
    (§ field #_"DeterministicKey" (§ name externalParentKey))
    #_private
    (§ field #_"DeterministicKey" (§ name internalParentKey))
    ;; How many keys on each path have actually been used.  This may be fewer than the number that have been
    ;; deserialized or held in memory, because of the lookahead zone.
    #_private
    (§ field #_"int" (§ name issuedExternalKeys))
    #_private
    (§ field #_"int" (§ name issuedInternalKeys))
    ;; A counter that is incremented each time a key in the lookahead threshold zone is marked as used and lookahead
    ;; is triggered.  The Wallet/KCG reads these counters and combines them so it can tell the Peer whether to throw
    ;; away the current block (and any future blocks in the same download batch) and restart chain sync once a new filter
    ;; has been calculated.  This field isn't persisted to the wallet as it's only relevant within a network session.
    #_private
    (§ field #_"int" (§ name keyLookaheadEpoch))

    ;; We simplify by wrapping a basic key chain and that way we get some functionality like key lookup and event
    ;; listeners "for free".  All keys in the key tree appear here, even if they aren't meant to be used for
    ;; receiving money.
    #_private
    #_final
    (§ field #_"BasicKeyChain" (§ name basicKeyChain))

    ;; If set this chain is following another chain in a married KeyChainGroup.
    #_private
    (§ field #_"boolean" (§ name isFollowing))

    ;; Holds a number of signatures required to spend.  It's the N from N-of-M CHECKMULTISIG script for P2SH transactions
    ;; and always 1 for other transaction types.
    #_protected
    (§ field #_"int" (§ name sigsRequiredToSpend) 1)

    #_public
    #_static
    (§ class #_"Builder<T extends Builder<T>>"
        #_protected
        (§ field #_"SecureRandom" (§ name random))
        #_protected
        (§ field #_"int" (§ name bits) 128)
        #_protected
        (§ field #_"String" (§ name passphrase))
        #_protected
        (§ field #_"long" (§ name seedCreationTimeSecs))
        #_protected
        (§ field #_"byte[]" (§ name entropy))
        #_protected
        (§ field #_"DeterministicSeed" (§ name seed))
        #_protected
        (§ field #_"DeterministicKey" (§ name watchingKey))

        #_protected
        (§ constructor #_"Builder" [])
        (§ block
            (§ void this)
        )

        #_suppress(§ opt "unchecked")
        #_protected
        (§ method #_"T" (§ fn self) [])
        (§ block
            (§ return (§ cast #_"T" this))
        )

        ;;;
         ; Creates a deterministic key chain starting from the given entropy.  All keys yielded by this chain will be the
         ; same if the starting entropy is the same.  You should provide the creation time in seconds since the UNIX epoch
         ; for the seed: this lets us know from what part of the chain we can expect to see derived keys appear.
         ;;
        #_public
        (§ method #_"T" (§ fn entropy) [#_"byte[]" (§ name entropy)])
        (§ block
            (§ ass (§ name this.entropy) entropy)
            (§ return (§ expr self(§ pars )))
        )

        ;;;
         ; Creates a deterministic key chain starting from the given seed.  All keys yielded by this chain will be the same
         ; if the starting seed is the same.
         ;;
        #_public
        (§ method #_"T" (§ fn seed) [#_"DeterministicSeed" (§ name seed)])
        (§ block
            (§ ass (§ name this.seed) seed)
            (§ return (§ expr self(§ pars )))
        )

        ;;;
         ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom} object
         ; and of the requested size in bits.  The derived seed is further protected with a user selected passphrase (see BIP 39).
         ; @param random The random number generator - use new SecureRandom().
         ; @param bits The number of bits of entropy to use when generating entropy.  Either 128 (default), 192 or 256.
         ;;
        #_public
        (§ method #_"T" (§ fn random) [#_"SecureRandom" (§ name random), #_"int" (§ name bits)])
        (§ block
            (§ ass (§ name this.random) random)
            (§ ass (§ name this.bits) bits)
            (§ return (§ expr self(§ pars )))
        )

        ;;;
         ; Generates a new key chain with 128 bits of entropy selected randomly from the given {@link java.security.SecureRandom}
         ; object.  The derived seed is further protected with a user selected passphrase (see BIP 39).
         ; @param random The random number generator - use new SecureRandom().
         ;;
        #_public
        (§ method #_"T" (§ fn random) [#_"SecureRandom" (§ name random)])
        (§ block
            (§ ass (§ name this.random) random)
            (§ return (§ expr self(§ pars )))
        )

        #_public
        (§ method #_"T" (§ fn watchingKey) [#_"DeterministicKey" (§ name watchingKey)])
        (§ block
            (§ ass (§ name this.watchingKey) watchingKey)
            (§ return (§ expr self(§ pars )))
        )

        #_public
        (§ method #_"T" (§ fn seedCreationTimeSecs) [#_"long" (§ name seedCreationTimeSecs)])
        (§ block
            (§ ass (§ name this.seedCreationTimeSecs) seedCreationTimeSecs)
            (§ return (§ expr self(§ pars )))
        )

        ;;;
         ; The passphrase to use with the generated mnemonic, or null if you would like to use the default empty string.
         ; Currently must be the empty string.
         ;;
        #_public
        (§ method #_"T" (§ fn passphrase) [#_"String" (§ name passphrase)])
        (§ block
            ;; FIXME support non-empty passphrase
            (§ ass (§ name this.passphrase) passphrase)
            (§ return (§ expr self(§ pars )))
        )

        #_public
        (§ method #_"DeterministicKeyChain" (§ fn build) [])
        (§ block
            (§ expr Preconditions/checkState(§ pars random != nil || entropy != nil || seed != nil || watchingKey!= nil, "Must provide either entropy or random or seed or watchingKey"))
            (§ expr Preconditions/checkState(§ pars passphrase == nil || seed == nil, "Passphrase must not be specified with seed"))

            ;; Default passphrase to "" if not specified.
            (§ if (§ expr random != nil))
            (§ block
                (§ return (§ new #_"DeterministicKeyChain" (§ pars random, bits, getPassphrase(§ pars ), seedCreationTimeSecs)))
            )

            (§ if (§ expr entropy != nil))
            (§ block
                (§ return (§ new #_"DeterministicKeyChain" (§ pars entropy, getPassphrase(§ pars ), seedCreationTimeSecs)))
            )

            (§ if (§ expr seed != nil))
            (§ block
                (§ expr seed.setCreationTimeSeconds(§ pars seedCreationTimeSecs))
                (§ return (§ new #_"DeterministicKeyChain" (§ pars seed)))
            )

            (§ expr watchingKey.setCreationTimeSeconds(§ pars seedCreationTimeSecs))
            (§ return (§ new #_"DeterministicKeyChain" (§ pars watchingKey)))
        )

        #_protected
        (§ method #_"String" (§ fn getPassphrase) [])
        (§ block
            (§ return (§ quest (§ expr passphrase != nil) ? passphrase :else (§ expr DEFAULT_PASSPHRASE_FOR_MNEMONIC)))
        )
    )

    #_public
    #_static
    (§ method #_"Builder<?>" (§ fn builder) [])
    (§ block
        (§ return (§ new #_"Builder" (§ pars )))
    )

    ;;;
     ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
     ; object and the default entropy size.
     ;;
    #_public
    (§ constructor #_"DeterministicKeyChain" [#_"SecureRandom" (§ name random)])
    (§ block
        (§ this (§ pars random, DeterministicSeed/DEFAULT_SEED_ENTROPY_BITS, DEFAULT_PASSPHRASE_FOR_MNEMONIC, Utils/currentTimeSeconds(§ pars )))
        (§ void this)
    )

    ;;;
     ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
     ; object and of the requested size in bits.
     ;;
    #_public
    (§ constructor #_"DeterministicKeyChain" [#_"SecureRandom" (§ name random), #_"int" (§ name bits)])
    (§ block
        (§ this (§ pars random, bits, DEFAULT_PASSPHRASE_FOR_MNEMONIC, Utils/currentTimeSeconds(§ pars )))
        (§ void this)
    )

    ;;;
     ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
     ; object and of the requested size in bits.  The derived seed is further protected with a user selected passphrase
     ; (see BIP 39).
     ;;
    #_public
    (§ constructor #_"DeterministicKeyChain" [#_"SecureRandom" (§ name random), #_"int" (§ name bits), #_"String" (§ name passphrase), #_"long" (§ name seedCreationTimeSecs)])
    (§ block
        (§ this (§ pars (§ new #_"DeterministicSeed" (§ pars random, bits, passphrase, seedCreationTimeSecs))))
        (§ void this)
    )

    ;;;
     ; Creates a deterministic key chain starting from the given entropy.  All keys yielded by this chain will be the
     ; same if the starting seed is the same.  You should provide the creation time in seconds since the UNIX epoch
     ; for the seed: this lets us know from what part of the chain we can expect to see derived keys appear.
     ;;
    #_public
    (§ constructor #_"DeterministicKeyChain" [#_"byte[]" (§ name entropy), #_"String" (§ name passphrase), #_"long" (§ name seedCreationTimeSecs)])
    (§ block
        (§ this (§ pars (§ new #_"DeterministicSeed" (§ pars entropy, passphrase, seedCreationTimeSecs))))
        (§ void this)
    )

    ;;;
     ; Creates a deterministic key chain starting from the given seed.  All keys yielded by this chain will be the
     ; same if the starting seed is the same.
     ;;
    #_protected
    (§ constructor #_"DeterministicKeyChain" [#_"DeterministicSeed" (§ name seed)])
    (§ block
        (§ this (§ pars seed, nil))
        (§ void this)
    )

    ;;;
     ; Creates a deterministic key chain that watches the given (public only) root key.  You can use this to calculate
     ; balances and generally follow along, but spending is not possible with such a chain.  Currently you can't use
     ; this method to watch an arbitrary fragment of some other tree, this limitation may be removed in future.
     ;;
    #_public
    (§ constructor #_"DeterministicKeyChain" [#_"DeterministicKey" (§ name watchingKey)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars watchingKey.isPubKeyOnly(§ pars ), "Private subtrees not currently supported: if you got this key from DKC.getWatchingKey() then use .dropPrivate().dropParent() on it first."))
        (§ expr Preconditions/checkArgument(§ pars watchingKey.getPath(§ pars ).size(§ pars ) == getAccountPath(§ pars ).size(§ pars ), "You can only watch an account key currently"))

        (§ ass (§ name basicKeyChain) (§ new #_"BasicKeyChain" (§ pars )))
        (§ ass (§ name this.seed) nil)
        (§ ass (§ name this.rootKey) nil)
        (§ expr basicKeyChain.importKey(§ pars watchingKey))
        (§ ass (§ name hierarchy) (§ new #_"DeterministicHierarchy" (§ pars watchingKey)))
        (§ expr initializeHierarchyUnencrypted(§ pars watchingKey))
        (§ void this)
    )

    ;;;
     ; <p>Creates a deterministic key chain with the given watch key.  If <code>isFollowing</code> flag is set then this
     ; keychain follows some other keychain.  In a married wallet following keychain represents "spouse's" keychain.</p>
     ; <p>Watch key has to be an account key.</p>
     ;;
    #_protected
    (§ constructor #_"DeterministicKeyChain" [#_"DeterministicKey" (§ name watchKey), #_"boolean" (§ name isFollowing)])
    (§ block
        (§ this (§ pars watchKey))
        (§ ass (§ name this.isFollowing) isFollowing)
        (§ void this)
    )

    ;;;
     ; Creates a deterministic key chain with the given watch key and that follows some other keychain.
     ; In a married wallet following keychain represents "spouse".
     ; Watch key has to be an account key.
     ;;
    #_public
    #_static
    (§ method #_"DeterministicKeyChain" (§ fn watchAndFollow) [#_"DeterministicKey" (§ name watchKey)])
    (§ block
        (§ return (§ new #_"DeterministicKeyChain" (§ pars watchKey, true)))
    )

    ;;;
     ; Creates a key chain that watches the given account key.
     ;;
    #_public
    #_static
    (§ method #_"DeterministicKeyChain" (§ fn watch) [#_"DeterministicKey" (§ name accountKey)])
    (§ block
        (§ return (§ new #_"DeterministicKeyChain" (§ pars accountKey)))
    )

    ;;;
     ; For use in {@link KeyChainFactory} during deserialization.
     ;;
    #_protected
    (§ constructor #_"DeterministicKeyChain" [#_"DeterministicSeed" (§ name seed), #_nilable #_"KeyCrypter" (§ name crypter)])
    (§ block
        (§ ass (§ name this.seed) seed)
        (§ ass (§ name basicKeyChain) (§ new #_"BasicKeyChain" (§ pars crypter)))
        (§ if (§ expr (§ not seed.isEncrypted(§ pars ))))
        (§ block
            (§ ass (§ name rootKey) (§ expr HDKeyDerivation/createMasterPrivateKey(§ pars Preconditions/checkNotNull(§ pars seed.getSeedBytes(§ pars )))))
            (§ expr rootKey.setCreationTimeSeconds(§ pars seed.getCreationTimeSeconds(§ pars )))
            (§ expr basicKeyChain.importKey(§ pars rootKey))
            (§ ass (§ name hierarchy) (§ new #_"DeterministicHierarchy" (§ pars rootKey)))
            (§ for (§ var #_"int" (§ name i) 1) :for (§ expr i <= getAccountPath(§ pars ).size(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
            (§ block
                (§ expr basicKeyChain.importKey(§ pars hierarchy.get(§ pars getAccountPath(§ pars ).subList(§ pars 0, i), false, true)))
            )
            (§ expr initializeHierarchyUnencrypted(§ pars rootKey))
        )
        ;; Else...
        ;; We can't initialize ourselves with just an encrypted seed, so we expected deserialization code
        ;; to do the rest of the setup (loading the root key).
        (§ void this)
    )

    ;;;
     ; For use in encryption when {@link #toEncrypted(KeyCrypter, KeyParameter)} is called,
     ; so that subclasses can override that method and create an instance of the right class.
     ;
     ; See also {@link #makeKeyChainFromSeed(DeterministicSeed)}.
     ;;
    #_protected
    (§ constructor #_"DeterministicKeyChain" [#_"KeyCrypter" (§ name crypter), #_"KeyParameter" (§ name aesKey), #_"DeterministicKeyChain" (§ name chain)])
    (§ block
        ;; Can't encrypt a watching chain.
        (§ expr Preconditions/checkNotNull(§ pars chain.rootKey))
        (§ expr Preconditions/checkNotNull(§ pars chain.seed))

        (§ expr Preconditions/checkArgument(§ pars (§ not chain.rootKey.isEncrypted(§ pars )), "Chain already encrypted"))

        (§ ass (§ name this.issuedExternalKeys) (§ expr chain.issuedExternalKeys))
        (§ ass (§ name this.issuedInternalKeys) (§ expr chain.issuedInternalKeys))

        (§ ass (§ name this.lookaheadSize) (§ expr chain.lookaheadSize))
        (§ ass (§ name this.lookaheadThreshold) (§ expr chain.lookaheadThreshold))

        (§ ass (§ name this.seed) (§ expr chain.seed.encrypt(§ pars crypter, aesKey)))
        (§ ass (§ name basicKeyChain) (§ new #_"BasicKeyChain" (§ pars crypter)))
        ;; The first number is the "account number" but we don't use that feature.
        (§ ass (§ name rootKey) (§ expr chain.rootKey.encrypt(§ pars crypter, aesKey, nil)))
        (§ ass (§ name hierarchy) (§ new #_"DeterministicHierarchy" (§ pars rootKey)))
        (§ expr basicKeyChain.importKey(§ pars rootKey))

        (§ for (§ var #_"int" (§ name i) 1) :for (§ expr i < getAccountPath(§ pars ).size(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ expr encryptNonLeaf(§ pars aesKey, chain, rootKey, getAccountPath(§ pars ).subList(§ pars 0, i)))
        )

        (§ var #_"DeterministicKey" (§ name account) (§ expr encryptNonLeaf(§ pars aesKey, chain, rootKey, getAccountPath(§ pars ))))
        (§ ass (§ name externalParentKey) (§ expr encryptNonLeaf(§ pars aesKey, chain, account, HDUtils/concat(§ pars getAccountPath(§ pars ), EXTERNAL_SUBPATH))))
        (§ ass (§ name internalParentKey) (§ expr encryptNonLeaf(§ pars aesKey, chain, account, HDUtils/concat(§ pars getAccountPath(§ pars ), INTERNAL_SUBPATH))))

        ;; Now copy the (pubkey only) leaf keys across to avoid rederiving them.  The private key bytes are missing
        ;; anyway so there's nothing to encrypt.
        (§ for (§ var #_"ECKey" (§ name eckey)) :for (§ expr chain.basicKeyChain.getKeys(§ pars )))
        (§ block
            (§ var #_"DeterministicKey" (§ name key) (§ expr (§ cast #_"DeterministicKey" eckey)))
            (§ if (§ expr key.getPath(§ pars ).size(§ pars ) != getAccountPath(§ pars ).size(§ pars ) + 2))
            (§ block
                (§ continue ) ;; Not a leaf key.
            )

            (§ var #_"DeterministicKey" (§ name parent) (§ expr hierarchy.get(§ pars Preconditions/checkNotNull(§ pars key.getParent(§ pars )).getPath(§ pars ), false, false)))
            ;; Clone the key to the new encrypted hierarchy.
            (§ ass (§ name key) (§ new #_"DeterministicKey" (§ pars key.dropPrivateBytes(§ pars ), parent)))
            (§ expr hierarchy.putKey(§ pars key))
            (§ expr basicKeyChain.importKey(§ pars key))
        )
        (§ void this)
    )

    ;;; Override in subclasses to use a different account derivation path. ;;
    #_protected
    (§ method #_"ImmutableList<ChildNumber>" (§ fn getAccountPath) [])
    (§ block
        (§ return (§ expr ACCOUNT_ZERO_PATH))
    )

    #_private
    (§ method #_"DeterministicKey" (§ fn encryptNonLeaf) [#_"KeyParameter" (§ name aesKey), #_"DeterministicKeyChain" (§ name chain), #_"DeterministicKey" (§ name parent), #_"ImmutableList<ChildNumber>" (§ name path)])
    (§ block
        (§ var #_"DeterministicKey" (§ name key) (§ expr chain.hierarchy.get(§ pars path, false, false)))
        (§ ass (§ name key) (§ expr key.encrypt(§ pars Preconditions/checkNotNull(§ pars basicKeyChain.getKeyCrypter(§ pars )), aesKey, parent)))
        (§ expr hierarchy.putKey(§ pars key))
        (§ expr basicKeyChain.importKey(§ pars key))
        (§ return key)
    )

    ;; Derives the account path keys and inserts them into the basic key chain.
    ;; This is important to preserve their order for serialization, amongst other things.
    #_private
    (§ method #_"void" (§ fn initializeHierarchyUnencrypted) [#_"DeterministicKey" (§ name baseKey)])
    (§ block
        (§ ass (§ name externalParentKey) (§ expr hierarchy.deriveChild(§ pars getAccountPath(§ pars ), false, false, ChildNumber/ZERO)))
        (§ ass (§ name internalParentKey) (§ expr hierarchy.deriveChild(§ pars getAccountPath(§ pars ), false, false, ChildNumber/ONE)))
        (§ expr basicKeyChain.importKey(§ pars externalParentKey))
        (§ expr basicKeyChain.importKey(§ pars internalParentKey))
        (§ void nil)
    )

    ;;; Returns a freshly derived key that has not been returned by this method before. ;;
    #_override
    #_public
    (§ method #_"DeterministicKey" (§ fn getKey) [#_"KeyPurpose" (§ name purpose)])
    (§ block
        (§ return (§ expr getKeys(§ pars purpose, 1).get(§ pars 0)))
    )

    ;;; Returns freshly derived key/s that have not been returned by this method before. ;;
    #_override
    #_public
    (§ method #_"List<DeterministicKey>" (§ fn getKeys) [#_"KeyPurpose" (§ name purpose), #_"int" (§ name numberOfKeys)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars 0 < numberOfKeys))
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"DeterministicKey" (§ name parentKey))
            (§ var #_"int" (§ name index))
            (§ switch purpose)
            (§ block
                ;; Map both REFUND and RECEIVE_KEYS to the same branch for now.  Refunds are a feature of the BIP 70
                ;; payment protocol.  Later we may wish to map it to a different branch (in a new wallet version?).
                ;; This would allow a watching wallet to only be able to see inbound payments, but not change
                ;; (i.e. spends) or refunds.  Might be useful for auditing ...
                (§ case RECEIVE_FUNDS)
                (§ case REFUND)
                (§ block
                    (§ ass (§ name issuedExternalKeys) (§ expr issuedExternalKeys + numberOfKeys))
                    (§ ass (§ name index) issuedExternalKeys)
                    (§ ass (§ name parentKey) externalParentKey)
                    (§ break )
                )
                (§ case AUTHENTICATION)
                (§ case CHANGE)
                (§ block
                    (§ ass (§ name issuedInternalKeys) (§ expr issuedInternalKeys + numberOfKeys))
                    (§ ass (§ name index) issuedInternalKeys)
                    (§ ass (§ name parentKey) internalParentKey)
                    (§ break )
                )
                (§ default )
                (§ block
                    (§ throw (§ new #_"UnsupportedOperationException" (§ pars )))
                )
            )
            ;; Optimization: potentially do a very quick key generation for just the number of keys we need if we
            ;; didn't already create them, ignoring the configured lookahead size.  This ensures we'll be able to
            ;; retrieve the keys in the following loop, but if we're totally fresh and didn't get a chance to
            ;; calculate the lookahead keys yet, this will not block waiting to calculate 100+ EC point multiplies.
            ;; On slow/crappy Android phones looking ahead 100 keys can take ~5 seconds but the OS will kill us
            ;; if we block for just one second on the UI thread.  Because UI threads may need an address in order
            ;; to render the screen, we need getKeys to be fast even if the wallet is totally brand new and lookahead
            ;; didn't happen yet.
            ;;
            ;; It's safe to do this because when a network thread tries to calculate a Bloom filter, we'll go ahead
            ;; and calculate the full lookahead zone there, so network requests will always use the right amount.
            (§ var #_"List<DeterministicKey>" (§ name lookahead) (§ expr maybeLookAhead(§ pars parentKey, index, 0, 0)))
            (§ expr basicKeyChain.importKeys(§ pars lookahead))
            (§ var #_"List<DeterministicKey>" (§ name keys) (§ new #_"ArrayList<>" (§ pars numberOfKeys)))
            (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numberOfKeys) :for (§ ass (§ name i) (§ expr i + 1)))
            (§ block
                (§ var #_"ImmutableList<ChildNumber>" (§ name path) (§ expr HDUtils/append(§ pars parentKey.getPath(§ pars ), new ChildNumber(§ pars index - numberOfKeys + i, false))))
                (§ var #_"DeterministicKey" (§ name k) (§ expr hierarchy.get(§ pars path, false, false)))
                ;; Just a last minute sanity check before we hand the key out to the app for usage.  This isn't
                ;; inspired by any real problem reports from bitcoinj users, but I've heard of cases via the grapevine
                ;; of places that lost money due to bitflips causing addresses to not match keys.  Of course in an
                ;; environment with flaky RAM there's no real way to always win: bitflips could be introduced at any
                ;; other layer.  But as we're potentially retrieving from long term storage here, check anyway.
                (§ expr checkForBitFlip(§ pars k))
                (§ expr keys.add(§ pars k))
            )
            (§ return keys)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_private
    (§ method #_"void" (§ fn checkForBitFlip) [#_"DeterministicKey" (§ name k)])
    (§ block
        (§ var #_"DeterministicKey" (§ name parent) (§ expr Preconditions/checkNotNull(§ pars k.getParent(§ pars ))))
        (§ var #_"byte[]" (§ name rederived) (§ expr HDKeyDerivation/deriveChildKeyBytesFromPublic(§ pars parent, k.getChildNumber(§ pars ), HDKeyDerivation/PublicDeriveMode/WITH_INVERSION).keyBytes))
        (§ var #_"byte[]" (§ name actual) (§ expr k.getPubKey(§ pars )))
        (§ if (§ expr (§ not Arrays/equals(§ pars rederived, actual))))
        (§ block
            (§ throw (§ new #_"IllegalStateException" (§ pars String/format(§ pars Locale/US, "Bit-flip check failed: %s vs %s", Arrays/toString(§ pars rederived), Arrays/toString(§ pars actual)))))
        )
        (§ void nil)
    )

    ;;;
     ; Mark the DeterministicKey as used.
     ; Also correct the issued{Internal|External}Keys counter, because all lower children seem to be requested already.
     ; If the counter was updated, we also might trigger lookahead.
     ;;
    #_public
    (§ method #_"DeterministicKey" (§ fn markKeyAsUsed) [#_"DeterministicKey" (§ name k)])
    (§ block
        (§ var #_"int" (§ name numChildren) (§ expr k.getChildNumber(§ pars ).i(§ pars ) + 1))

        (§ if (§ expr k.getParent(§ pars ) == internalParentKey))
        (§ block
            (§ if (§ expr issuedInternalKeys < numChildren))
            (§ block
                (§ ass (§ name issuedInternalKeys) numChildren)
                (§ expr maybeLookAhead(§ pars ))
            )
        )
        (§ elseif (§ expr k.getParent(§ pars ) == externalParentKey))
        (§ block
            (§ if (§ expr issuedExternalKeys < numChildren))
            (§ block
                (§ ass (§ name issuedExternalKeys) numChildren)
                (§ expr maybeLookAhead(§ pars ))
            )
        )
        (§ return k)
    )

    #_public
    (§ method #_"DeterministicKey" (§ fn findKeyFromPubHash) [#_"byte[]" (§ name pubkeyHash)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ cast #_"DeterministicKey" (§ expr basicKeyChain.findKeyFromPubHash(§ pars pubkeyHash))))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_public
    (§ method #_"DeterministicKey" (§ fn findKeyFromPubKey) [#_"byte[]" (§ name pubkey)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ cast #_"DeterministicKey" (§ expr basicKeyChain.findKeyFromPubKey(§ pars pubkey))))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkeyHash.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_nilable
    #_public
    (§ method #_"DeterministicKey" (§ fn markPubHashAsUsed) [#_"byte[]" (§ name pubkeyHash)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"DeterministicKey" (§ name k) (§ expr (§ cast #_"DeterministicKey" (§ expr basicKeyChain.findKeyFromPubHash(§ pars pubkeyHash)))))
            (§ if (§ expr k != nil))
            (§ block
                (§ expr markKeyAsUsed(§ pars k))
            )
            (§ return k)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkey.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_nilable
    #_public
    (§ method #_"DeterministicKey" (§ fn markPubKeyAsUsed) [#_"byte[]" (§ name pubkey)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"DeterministicKey" (§ name k) (§ expr (§ cast #_"DeterministicKey" (§ expr basicKeyChain.findKeyFromPubKey(§ pars pubkey)))))
            (§ if (§ expr k != nil))
            (§ block
                (§ expr markKeyAsUsed(§ pars k))
            )
            (§ return k)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn hasKey) [#_"ECKey" (§ name key)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr basicKeyChain.hasKey(§ pars key)))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;; Returns the deterministic key for the given absolute path in the hierarchy. ;;
    #_protected
    (§ method #_"DeterministicKey" (§ fn getKeyByPath) [#_"ChildNumber..." (§ name path)])
    (§ block
        (§ return (§ expr getKeyByPath(§ pars ImmutableList/copyOf(§ pars path))))
    )

    ;;; Returns the deterministic key for the given absolute path in the hierarchy. ;;
    #_protected
    (§ method #_"DeterministicKey" (§ fn getKeyByPath) [#_"List<ChildNumber>" (§ name path)])
    (§ block
        (§ return (§ expr getKeyByPath(§ pars path, false)))
    )

    ;;; Returns the deterministic key for the given absolute path in the hierarchy, optionally creating it. ;;
    #_public
    (§ method #_"DeterministicKey" (§ fn getKeyByPath) [#_"List<ChildNumber>" (§ name path), #_"boolean" (§ name create)])
    (§ block
        (§ return (§ expr hierarchy.get(§ pars path, false, create)))
    )

    ;;;
     ; <p>An alias for <code>getKeyByPath(getAccountPath())</code>.</p>
     ;
     ; <p>Use this when you would like to create a watching key chain that follows this one, but can't spend money from it.
     ; The returned key can be serialized and then passed into {@link #watch(org.bitcoinj.crypto.DeterministicKey)}
     ; on another system to watch the hierarchy.</p>
     ;
     ; <p>Note that the returned key is not pubkey only unless this key chain already is: the returned key can still
     ; be used for signing etc if the private key bytes are available.</p>
     ;;
    #_public
    (§ method #_"DeterministicKey" (§ fn getWatchingKey) [])
    (§ block
        (§ return (§ expr getKeyByPath(§ pars getAccountPath(§ pars ))))
    )

    ;;; Returns true if this chain is watch only, meaning it has public keys but no private key. ;;
    #_public
    (§ method #_"boolean" (§ fn isWatching) [])
    (§ block
        (§ return (§ expr getWatchingKey(§ pars ).isWatching(§ pars )))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn numKeys) [])
    (§ block
        ;; We need to return here the total number of keys including the lookahead zone, not the number
        ;; of keys we have issued via getKey/freshReceiveKey.
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr maybeLookAhead(§ pars ))
            (§ return (§ expr basicKeyChain.numKeys(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns number of leaf keys used including both internal and external paths.  This may be fewer
     ; than the number that have been deserialized or held in memory, because of the lookahead zone.
     ;;
    #_public
    (§ method #_"int" (§ fn numLeafKeysIssued) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr issuedExternalKeys + issuedInternalKeys))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method #_"long" (§ fn getEarliestKeyCreationTime) [])
    (§ block
        (§ return (§ quest (§ expr seed != nil) ? (§ expr seed.getCreationTimeSeconds(§ pars )) :else (§ dot getWatchingKey(§ pars ).getCreationTimeSeconds(§ pars ))))
    )

    #_override
    #_public
    (§ method #_"void" (§ fn addEventListener) [#_"KeyChainEventListener" (§ name listener)])
    (§ block
        (§ expr basicKeyChain.addEventListener(§ pars listener))
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn addEventListener) [#_"KeyChainEventListener" (§ name listener), #_"Executor" (§ name executor)])
    (§ block
        (§ expr basicKeyChain.addEventListener(§ pars listener, executor))
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn removeEventListener) [#_"KeyChainEventListener" (§ name listener)])
    (§ block
        (§ return (§ expr basicKeyChain.removeEventListener(§ pars listener)))
    )

    ;;; Returns a list of words that represent the seed or null if this chain is a watching chain. ;;
    #_nilable
    #_public
    (§ method #_"List<String>" (§ fn getMnemonicCode) [])
    (§ block
        (§ if (§ expr seed == nil))
        (§ block
            (§ return nil)
        )

        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr seed.getMnemonicCode(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Return true if this keychain is following another keychain.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isFollowing) [])
    (§ block
        (§ return isFollowing)
    )

    #_override
    #_public
    (§ method #_"List<Protos.Key>" (§ fn serializeToProtobuf) [])
    (§ block
        (§ var #_"List<Protos.Key>" (§ name result) (§ expr newArrayList(§ pars )))
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr result.addAll(§ pars serializeMyselfToProtobuf(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ return result)
    )

    #_protected
    (§ method #_"List<Protos.Key>" (§ fn serializeMyselfToProtobuf) [])
    (§ block
        ;; Most of the serialization work is delegated to the basic key chain, which will serialize the bulk of the
        ;; data (handling encryption along the way), and letting us patch it up with the extra data we care about.
        (§ var #_"LinkedList<Protos.Key>" (§ name entries) (§ expr newLinkedList(§ pars )))
        (§ if (§ expr seed != nil))
        (§ block
            (§ var #_"Protos.Key.Builder" (§ name mnemonicEntry) (§ expr BasicKeyChain/serializeEncryptableItem(§ pars seed)))
            (§ expr mnemonicEntry.setType(§ pars Protos/Key/Type/DETERMINISTIC_MNEMONIC))
            (§ expr serializeSeedEncryptableItem(§ pars seed, mnemonicEntry))
            (§ expr entries.add(§ pars mnemonicEntry.build(§ pars )))
        )
        (§ var #_"Map<ECKey, Protos.Key.Builder>" (§ name keys) (§ expr basicKeyChain.serializeToEditableProtobufs(§ pars )))
        (§ for (§ var #_"Map.Entry<ECKey, Protos.Key.Builder>" (§ name entry)) :for (§ expr keys.entrySet(§ pars )))
        (§ block
            (§ var #_"DeterministicKey" (§ name key) (§ expr (§ cast #_"DeterministicKey" (§ expr entry.getKey(§ pars )))))
            (§ var #_"Protos.Key.Builder" (§ name proto) (§ expr entry.getValue(§ pars )))
            (§ expr proto.setType(§ pars Protos/Key/Type/DETERMINISTIC_KEY))
            #_final
            (§ var #_"Protos.DeterministicKey.Builder" (§ name detKey) (§ expr proto.getDeterministicKeyBuilder(§ pars )))
            (§ expr detKey.setChainCode(§ pars ByteString/copyFrom(§ pars key.getChainCode(§ pars ))))
            (§ for (§ var #_"ChildNumber" (§ name num)) :for (§ expr key.getPath(§ pars )))
            (§ block
                (§ expr detKey.addPath(§ pars num.i(§ pars )))
            )
            (§ if (§ expr key.equals(§ pars externalParentKey)))
            (§ block
                (§ expr detKey.setIssuedSubkeys(§ pars issuedExternalKeys))
                (§ expr detKey.setLookaheadSize(§ pars lookaheadSize))
                (§ expr detKey.setSigsRequiredToSpend(§ pars getSigsRequiredToSpend(§ pars )))
            )
            (§ elseif (§ expr key.equals(§ pars internalParentKey)))
            (§ block
                (§ expr detKey.setIssuedSubkeys(§ pars issuedInternalKeys))
                (§ expr detKey.setLookaheadSize(§ pars lookaheadSize))
                (§ expr detKey.setSigsRequiredToSpend(§ pars getSigsRequiredToSpend(§ pars )))
            )
            ;; Flag the very first key of following keychain.
            (§ if (§ expr entries.isEmpty(§ pars ) && isFollowing(§ pars )))
            (§ block
                (§ expr detKey.setIsFollowing(§ pars true))
            )
            ;; HD keys inherit the timestamp of their parent if they have one, so no need to serialize it.
            (§ if (§ expr key.getParent(§ pars ) != nil))
            (§ block
                (§ expr proto.clearCreationTimestamp(§ pars ))
            )
            (§ expr entries.add(§ pars proto.build(§ pars )))
        )
        (§ return entries)
    )

    #_static
    (§ method #_"List<DeterministicKeyChain>" (§ fn fromProtobuf) [#_"List<Protos.Key>" (§ name keys), #_nilable #_"KeyCrypter" (§ name crypter)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        (§ return (§ expr fromProtobuf(§ pars keys, crypter, new DefaultKeyChainFactory(§ pars ))))
    )

    ;;;
     ; Returns all the key chains found in the given list of keys.  Typically there will only be one,
     ; but in the case of key rotation it can happen that there are multiple chains found.
     ;;
    #_public
    #_static
    (§ method #_"List<DeterministicKeyChain>" (§ fn fromProtobuf) [#_"List<Protos.Key>" (§ name keys), #_nilable #_"KeyCrypter" (§ name crypter), #_"KeyChainFactory" (§ name factory)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        (§ var #_"List<DeterministicKeyChain>" (§ name chains) (§ expr newLinkedList(§ pars )))
        (§ var #_"DeterministicSeed" (§ name seed) nil)
        (§ var #_"DeterministicKeyChain" (§ name chain) nil)

        (§ var #_"int" (§ name lookaheadSize) -1)
        (§ var #_"int" (§ name sigsRequiredToSpend) 1)

        (§ var #_"PeekingIterator<Protos.Key>" (§ name iter) (§ expr Iterators/peekingIterator(§ pars keys.iterator(§ pars ))))
        (§ while (§ expr iter.hasNext(§ pars )))
        (§ block
            (§ var #_"Protos.Key" (§ name key) (§ expr iter.next(§ pars )))
            #_final
            (§ var #_"Protos.Key.Type" (§ name t) (§ expr key.getType(§ pars )))
            (§ if (§ expr t == Protos/Key/Type/DETERMINISTIC_MNEMONIC))
            (§ block
                (§ if (§ expr chain != nil))
                (§ block
                    (§ expr Preconditions/checkState(§ pars 0 <= lookaheadSize))

                    (§ expr chain.setLookaheadSize(§ pars lookaheadSize))
                    (§ expr chain.setSigsRequiredToSpend(§ pars sigsRequiredToSpend))
                    (§ expr chain.maybeLookAhead(§ pars ))
                    (§ expr chains.add(§ pars chain))
                    (§ ass (§ name chain) nil)
                )
                (§ var #_"long" (§ name timestamp) (§ expr key.getCreationTimestamp(§ pars ) / 1000))
                (§ var #_"String" (§ name passphrase) (§ expr DEFAULT_PASSPHRASE_FOR_MNEMONIC)) ;; FIXME allow non-empty passphrase
                (§ if (§ expr key.hasSecretBytes(§ pars )))
                (§ block
                    (§ if (§ expr key.hasEncryptedDeterministicSeed(§ pars )))
                    (§ block
                        (§ throw (§ new #_"UnreadableWalletException" (§ pars "Malformed key proto: " + key)))
                    )

                    (§ var #_"byte[]" (§ name seedBytes) nil)
                    (§ if (§ expr key.hasDeterministicSeed(§ pars )))
                    (§ block
                        (§ ass (§ name seedBytes) (§ expr key.getDeterministicSeed(§ pars ).toByteArray(§ pars )))
                    )
                    (§ ass (§ name seed) (§ new #_"DeterministicSeed" (§ pars key.getSecretBytes(§ pars ).toStringUtf8(§ pars ), seedBytes, passphrase, timestamp)))
                )
                (§ elseif (§ expr key.hasEncryptedData(§ pars )))
                (§ block
                    (§ if (§ expr key.hasDeterministicSeed(§ pars )))
                    (§ block
                        (§ throw (§ new #_"UnreadableWalletException" (§ pars "Malformed key proto: " + key)))
                    )

                    (§ var #_"EncryptedData" (§ name data) (§ new #_"EncryptedData" (§ pars key.getEncryptedData(§ pars ).getInitialisationVector(§ pars ).toByteArray(§ pars ), key.getEncryptedData(§ pars ).getEncryptedPrivateKey(§ pars ).toByteArray(§ pars ))))
                    (§ var #_"EncryptedData" (§ name encryptedSeedBytes) nil)
                    (§ if (§ expr key.hasEncryptedDeterministicSeed(§ pars )))
                    (§ block
                        (§ var #_"Protos.EncryptedData" (§ name encryptedSeed) (§ expr key.getEncryptedDeterministicSeed(§ pars )))
                        (§ ass (§ name encryptedSeedBytes) (§ new #_"EncryptedData" (§ pars encryptedSeed.getInitialisationVector(§ pars ).toByteArray(§ pars ), encryptedSeed.getEncryptedPrivateKey(§ pars ).toByteArray(§ pars ))))
                    )
                    (§ ass (§ name seed) (§ new #_"DeterministicSeed" (§ pars data, encryptedSeedBytes, timestamp)))
                )
                (§ else )
                (§ block
                    (§ throw (§ new #_"UnreadableWalletException" (§ pars "Malformed key proto: " + key)))
                )

                (§ if (§ expr log.isDebugEnabled(§ pars )))
                (§ block
                    (§ expr log.debug(§ pars "Deserializing: DETERMINISTIC_MNEMONIC: {}", seed))
                )
            )
            (§ elseif (§ expr t == Protos/Key/Type/DETERMINISTIC_KEY))
            (§ block
                (§ if (§ expr (§ not key.hasDeterministicKey(§ pars ))))
                (§ block
                    (§ throw (§ new #_"UnreadableWalletException" (§ pars "Deterministic key missing extra data: " + key)))
                )

                (§ var #_"byte[]" (§ name chainCode) (§ expr key.getDeterministicKey(§ pars ).getChainCode(§ pars ).toByteArray(§ pars )))
                ;; Deserialize the path through the tree.
                (§ var #_"LinkedList<ChildNumber>" (§ name path) (§ expr newLinkedList(§ pars )))
                (§ for (§ var #_"int" (§ name i)) :for (§ expr key.getDeterministicKey(§ pars ).getPathList(§ pars )))
                (§ block
                    (§ expr path.add(§ pars (§ new #_"ChildNumber" (§ pars i))))
                )

                ;; Deserialize the public key and path.
                (§ var #_"LazyECPoint" (§ name pubkey) (§ new #_"LazyECPoint" (§ pars ECKey/CURVE.getCurve(§ pars ), key.getPublicKey(§ pars ).toByteArray(§ pars ))))
                #_final
                (§ var #_"ImmutableList<ChildNumber>" (§ name immutablePath) (§ expr ImmutableList/copyOf(§ pars path)))
                ;; Possibly create the chain, if we didn't already do so yet.
                (§ var #_"boolean" (§ name isWatchingAccountKey) false)
                (§ var #_"boolean" (§ name isFollowingKey) false)
                ;; Save previous chain if any if the key is marked as following.  Current key and the next ones
                ;; are to be placed in new following key chain.
                (§ if (§ expr key.getDeterministicKey(§ pars ).getIsFollowing(§ pars )))
                (§ block
                    (§ if (§ expr chain != nil))
                    (§ block
                        (§ expr Preconditions/checkState(§ pars 0 <= lookaheadSize))

                        (§ expr chain.setLookaheadSize(§ pars lookaheadSize))
                        (§ expr chain.setSigsRequiredToSpend(§ pars sigsRequiredToSpend))
                        (§ expr chain.maybeLookAhead(§ pars ))
                        (§ expr chains.add(§ pars chain))
                        (§ ass (§ name chain) nil)
                        (§ ass (§ name seed) nil)
                    )
                    (§ ass (§ name isFollowingKey) true)
                )

                (§ if (§ expr chain == nil))
                (§ block
                    ;; If this is not a following chain and previous was, this must be married.
                    (§ var #_"boolean" (§ name isMarried) (§ expr (§ not isFollowingKey) && (§ not chains.isEmpty(§ pars )) && chains.get(§ pars chains.size(§ pars ) - 1).isFollowing(§ pars )))
                    (§ if (§ expr seed == nil))
                    (§ block
                        (§ var #_"DeterministicKey" (§ name accountKey) (§ new #_"DeterministicKey" (§ pars immutablePath, chainCode, pubkey, nil, nil)))
                        (§ expr accountKey.setCreationTimeSeconds(§ pars key.getCreationTimestamp(§ pars ) / 1000))
                        (§ ass (§ name chain) (§ expr factory.makeWatchingKeyChain(§ pars key, iter.peek(§ pars ), accountKey, isFollowingKey, isMarried)))
                        (§ ass (§ name isWatchingAccountKey) true)
                    )
                    (§ else )
                    (§ block
                        (§ ass (§ name chain) (§ expr factory.makeKeyChain(§ pars key, iter.peek(§ pars ), seed, crypter, isMarried)))
                        (§ ass (§ name chain.lookaheadSize) (§ expr LAZY_CALCULATE_LOOKAHEAD))
                        ;; If the seed is encrypted, then the chain is incomplete at this point.  However, we will load
                        ;; it up below as we parse in the keys.  We just need to check at the end that we've loaded
                        ;; everything afterwards.
                    )
                )
                ;; Find the parent key assuming this is not the root key, and not an account key for a watching chain.
                (§ var #_"DeterministicKey" (§ name parent) nil)
                (§ if (§ expr (§ not path.isEmpty(§ pars )) && (§ not isWatchingAccountKey)))
                (§ block
                    (§ var #_"ChildNumber" (§ name index) (§ expr path.removeLast(§ pars )))
                    (§ ass (§ name parent) (§ expr chain.hierarchy.get(§ pars path, false, false)))
                    (§ expr path.add(§ pars index))
                )
                (§ var #_"DeterministicKey" (§ name detkey))
                (§ if (§ expr key.hasSecretBytes(§ pars )))
                (§ block
                    ;; Not encrypted: private key is available.
                    #_final
                    (§ var #_"BigInteger" (§ name priv) (§ new #_"BigInteger" (§ pars 1, key.getSecretBytes(§ pars ).toByteArray(§ pars ))))
                    (§ ass (§ name detkey) (§ new #_"DeterministicKey" (§ pars immutablePath, chainCode, pubkey, priv, parent)))
                )
                (§ else )
                (§ block
                    (§ if (§ expr key.hasEncryptedData(§ pars )))
                    (§ block
                        (§ var #_"Protos.EncryptedData" (§ name proto) (§ expr key.getEncryptedData(§ pars )))
                        (§ var #_"EncryptedData" (§ name data) (§ new #_"EncryptedData" (§ pars proto.getInitialisationVector(§ pars ).toByteArray(§ pars ), proto.getEncryptedPrivateKey(§ pars ).toByteArray(§ pars ))))
                        (§ expr Preconditions/checkNotNull(§ pars crypter, "Encountered an encrypted key but no key crypter provided"))
                        (§ ass (§ name detkey) (§ new #_"DeterministicKey" (§ pars immutablePath, chainCode, crypter, pubkey, data, parent)))
                    )
                    (§ else )
                    (§ block
                        ;; No secret key bytes and key is not encrypted: either a watching key or private key bytes
                        ;; will be rederived on the fly from the parent.
                        (§ ass (§ name detkey) (§ new #_"DeterministicKey" (§ pars immutablePath, chainCode, pubkey, nil, parent)))
                    )
                )
                (§ if (§ expr key.hasCreationTimestamp(§ pars )))
                (§ block
                    (§ expr detkey.setCreationTimeSeconds(§ pars key.getCreationTimestamp(§ pars ) / 1000))
                )
                (§ if (§ expr log.isDebugEnabled(§ pars )))
                (§ block
                    (§ expr log.debug(§ pars "Deserializing: DETERMINISTIC_KEY: {}", detkey))
                )
                (§ if (§ expr (§ not isWatchingAccountKey)))
                (§ block
                    ;; If the non-encrypted case, the non-leaf keys (account, internal, external) have already
                    ;; been rederived and inserted at this point.  In the encrypted case though, we can't
                    ;; rederive and we must reinsert, potentially building the heirarchy object if need be.
                    (§ if (§ expr path.size(§ pars ) == 0))
                    (§ block
                        ;; Master key.
                        (§ if (§ expr chain.rootKey == nil))
                        (§ block
                            (§ ass (§ name chain.rootKey) detkey)
                            (§ ass (§ name chain.hierarchy) (§ new #_"DeterministicHierarchy" (§ pars detkey)))
                        )
                    )
                    (§ elseif (§ expr path.size(§ pars ) == chain.getAccountPath(§ pars ).size(§ pars ) + 1))
                    (§ block
                        (§ if (§ expr detkey.getChildNumber(§ pars ).num(§ pars ) == 0))
                        (§ block
                            (§ ass (§ name chain.externalParentKey) detkey)
                            (§ ass (§ name chain.issuedExternalKeys) (§ expr key.getDeterministicKey(§ pars ).getIssuedSubkeys(§ pars )))
                            (§ ass (§ name lookaheadSize) (§ expr Math/max(§ pars lookaheadSize, key.getDeterministicKey(§ pars ).getLookaheadSize(§ pars ))))
                            (§ ass (§ name sigsRequiredToSpend) (§ expr key.getDeterministicKey(§ pars ).getSigsRequiredToSpend(§ pars )))
                        )
                        (§ elseif (§ expr detkey.getChildNumber(§ pars ).num(§ pars ) == 1))
                        (§ block
                            (§ ass (§ name chain.internalParentKey) detkey)
                            (§ ass (§ name chain.issuedInternalKeys) (§ expr key.getDeterministicKey(§ pars ).getIssuedSubkeys(§ pars )))
                        )
                    )
                )
                (§ expr chain.hierarchy.putKey(§ pars detkey))
                (§ expr chain.basicKeyChain.importKey(§ pars detkey))
            )
        )
        (§ if (§ expr chain != nil))
        (§ block
            (§ expr Preconditions/checkState(§ pars lookaheadSize >= 0))
            (§ expr chain.setLookaheadSize(§ pars lookaheadSize))
            (§ expr chain.setSigsRequiredToSpend(§ pars sigsRequiredToSpend))
            (§ expr chain.maybeLookAhead(§ pars ))
            (§ expr chains.add(§ pars chain))
        )
        (§ return chains)
    )

    #_override
    #_public
    (§ method #_"DeterministicKeyChain" (§ fn toEncrypted) [#_"CharSequence" (§ name password)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars password))
        (§ expr Preconditions/checkArgument(§ pars 0 < password.length(§ pars )))
        (§ expr Preconditions/checkState(§ pars seed != nil, "Attempt to encrypt a watching chain."))
        (§ expr Preconditions/checkState(§ pars (§ not seed.isEncrypted(§ pars ))))

        (§ var #_"KeyCrypter" (§ name scrypt) (§ new #_"KeyCrypterScrypt" (§ pars )))
        (§ var #_"KeyParameter" (§ name derivedKey) (§ expr scrypt.deriveKey(§ pars password)))
        (§ return (§ expr toEncrypted(§ pars scrypt, derivedKey)))
    )

    #_override
    #_public
    (§ method #_"DeterministicKeyChain" (§ fn toEncrypted) [#_"KeyCrypter" (§ name keyCrypter), #_"KeyParameter" (§ name aesKey)])
    (§ block
        (§ return (§ new #_"DeterministicKeyChain" (§ pars keyCrypter, aesKey, this)))
    )

    #_override
    #_public
    (§ method #_"DeterministicKeyChain" (§ fn toDecrypted) [#_"CharSequence" (§ name password)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars password))
        (§ expr Preconditions/checkArgument(§ pars 0 < password.length(§ pars )))

        (§ var #_"KeyCrypter" (§ name crypter) (§ expr getKeyCrypter(§ pars )))
        (§ expr Preconditions/checkState(§ pars crypter != nil, "Chain not encrypted"))
        (§ var #_"KeyParameter" (§ name derivedKey) (§ expr crypter.deriveKey(§ pars password)))
        (§ return (§ expr toDecrypted(§ pars derivedKey)))
    )

    #_override
    #_public
    (§ method #_"DeterministicKeyChain" (§ fn toDecrypted) [#_"KeyParameter" (§ name aesKey)])
    (§ block
        (§ expr Preconditions/checkState(§ pars getKeyCrypter(§ pars ) != nil, "Key chain not encrypted"))
        (§ expr Preconditions/checkState(§ pars seed != nil, "Can't decrypt a watching chain"))
        (§ expr Preconditions/checkState(§ pars seed.isEncrypted(§ pars )))

        (§ var #_"String" (§ name passphrase) (§ expr DEFAULT_PASSPHRASE_FOR_MNEMONIC)) ;; FIXME allow non-empty passphrase
        (§ var #_"DeterministicSeed" (§ name decSeed) (§ expr seed.decrypt(§ pars getKeyCrypter(§ pars ), passphrase, aesKey)))
        (§ var #_"DeterministicKeyChain" (§ name chain) (§ expr makeKeyChainFromSeed(§ pars decSeed)))
        ;; Now double check that the keys match to catch the case where the key is wrong but padding didn't catch it.
        (§ if (§ not (§ dot chain.getWatchingKey(§ pars ).getPubKeyPoint(§ pars ).equals(§ pars getWatchingKey(§ pars ).getPubKeyPoint(§ pars )))))
        (§ block
            (§ throw (§ new #_"KeyCrypterException" (§ pars "Provided AES key is wrong")))
        )

        (§ ass (§ name chain.lookaheadSize) lookaheadSize)
        ;; Now copy the (pubkey only) leaf keys across to avoid rederiving them.  The private key bytes are missing
        ;; anyway so there's nothing to decrypt.
        (§ for (§ var #_"ECKey" (§ name eckey)) :for (§ expr basicKeyChain.getKeys(§ pars )))
        (§ block
            (§ var #_"DeterministicKey" (§ name key) (§ expr (§ cast #_"DeterministicKey" eckey)))
            (§ if (§ expr key.getPath(§ pars ).size(§ pars ) != getAccountPath(§ pars ).size(§ pars ) + 2))
            (§ block
                (§ continue ) ;; Not a leaf key.
            )

            (§ expr Preconditions/checkState(§ pars key.isEncrypted(§ pars )))
            (§ var #_"DeterministicKey" (§ name parent) (§ expr chain.hierarchy.get(§ pars Preconditions/checkNotNull(§ pars key.getParent(§ pars )).getPath(§ pars ), false, false)))
            ;; Clone the key to the new decrypted hierarchy.
            (§ ass (§ name key) (§ new #_"DeterministicKey" (§ pars key.dropPrivateBytes(§ pars ), parent)))
            (§ expr chain.hierarchy.putKey(§ pars key))
            (§ expr chain.basicKeyChain.importKey(§ pars key))
        )
        (§ ass (§ name chain.issuedExternalKeys) issuedExternalKeys)
        (§ ass (§ name chain.issuedInternalKeys) issuedInternalKeys)
        (§ return chain)
    )

    ;;;
     ; Factory method to create a key chain from a seed.
     ; Subclasses should override this to create an instance of the subclass instead of a plain DKC.
     ; This is used in encryption/decryption.
     ;;
    #_protected
    (§ method #_"DeterministicKeyChain" (§ fn makeKeyChainFromSeed) [#_"DeterministicSeed" (§ name seed)])
    (§ block
        (§ return (§ new #_"DeterministicKeyChain" (§ pars seed)))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn checkPassword) [#_"CharSequence" (§ name password)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars password))
        (§ expr Preconditions/checkState(§ pars getKeyCrypter(§ pars ) != nil, "Key chain not encrypted"))

        (§ return (§ expr checkAESKey(§ pars getKeyCrypter(§ pars ).deriveKey(§ pars password))))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn checkAESKey) [#_"KeyParameter" (§ name aesKey)])
    (§ block
        (§ expr Preconditions/checkState(§ pars rootKey != nil, "Can't check password for a watching chain"))
        (§ expr Preconditions/checkNotNull(§ pars aesKey))
        (§ expr Preconditions/checkState(§ pars getKeyCrypter(§ pars ) != nil, "Key chain not encrypted"))

        (§ try )
        (§ block
            (§ return (§ expr rootKey.decrypt(§ pars aesKey).getPubKeyPoint(§ pars ).equals(§ pars rootKey.getPubKeyPoint(§ pars ))))
        )
        (§ catch #_"KeyCrypterException" (§ name _))
        (§ block
            (§ return false)
        )
    )

    #_nilable
    #_override
    #_public
    (§ method #_"KeyCrypter" (§ fn getKeyCrypter) [])
    (§ block
        (§ return (§ expr basicKeyChain.getKeyCrypter(§ pars )))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn numBloomFilterEntries) [])
    (§ block
        (§ return (§ expr numKeys(§ pars ) * 2))
    )

    #_override
    #_public
    (§ method #_"BloomFilter" (§ fn getFilter) [#_"int" (§ name size), #_"double" (§ name falsePositiveRate), #_"long" (§ name tweak)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr Preconditions/checkArgument(§ pars numBloomFilterEntries(§ pars ) <= size))
            (§ expr maybeLookAhead(§ pars ))
            (§ return (§ expr basicKeyChain.getFilter(§ pars size, falsePositiveRate, tweak)))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; <p>The number of public keys we should pre-generate on each path before they are requested by the app.  This is
     ; required so that when scanning through the chain given only a seed, we can give enough keys to the remote node
     ; via the Bloom filter such that we see transactions that are "from the future", for example transactions created
     ; by a different app that's sharing the same seed, or transactions we made before but we're replaying the chain
     ; given just the seed. The default is 100.</p>
     ;;
    #_public
    (§ method #_"int" (§ fn getLookaheadSize) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return lookaheadSize)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Sets a new lookahead size.  See {@link #getLookaheadSize()} for details on what this is.  Setting a new size
     ; that's larger than the current size will return immediately and the new size will only take effect next time
     ; a fresh filter is requested (e.g. due to a new peer being connected).  So you should set this before starting
     ; to sync the chain, if you want to modify it.  If you haven't modified the lookahead threshold manually then
     ; it will be automatically set to be a third of the new size.
     ;;
    #_public
    (§ method #_"void" (§ fn setLookaheadSize) [#_"int" (§ name lookaheadSize)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"boolean" (§ name readjustThreshold) (§ expr this.lookaheadThreshold == calcDefaultLookaheadThreshold(§ pars )))
            (§ ass (§ name this.lookaheadSize) lookaheadSize)
            (§ if readjustThreshold)
            (§ block
                (§ ass (§ name this.lookaheadThreshold) (§ expr calcDefaultLookaheadThreshold(§ pars )))
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Sets the threshold for the key pre-generation.  This is used to avoid adding new keys and thus re-calculating
     ; Bloom filters every time a new key is calculated.  Without a lookahead threshold, every time we received
     ; a relevant transaction, we'd extend the lookahead zone and generate a new filter, which is inefficient.
     ;;
    #_public
    (§ method #_"void" (§ fn setLookaheadThreshold) [#_"int" (§ name num)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr lookaheadSize <= num))
            (§ block
                (§ throw (§ new #_"IllegalArgumentException" (§ pars "Threshold larger or equal to the lookaheadSize")))
            )

            (§ ass (§ name this.lookaheadThreshold) num)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Gets the threshold for the key pre-generation.  See {@link #setLookaheadThreshold(int)} for details on what
     ; this is.  The default is a third of the lookahead size (100 / 3 == 33).  If you don't modify it explicitly,
     ; then this value will always be one third of the lookahead size.
     ;;
    #_public
    (§ method #_"int" (§ fn getLookaheadThreshold) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ quest (§ expr lookaheadThreshold < lookaheadSize) ? lookaheadThreshold :else 0))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Pre-generate enough keys to reach the lookahead size.  You can call this if you need to explicitly invoke
     ; the lookahead procedure, but it's normally unnecessary as it will be done automatically when needed.
     ;;
    #_public
    (§ method #_"void" (§ fn maybeLookAhead) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"List<DeterministicKey>" (§ name keys) (§ expr maybeLookAhead(§ pars externalParentKey, issuedExternalKeys)))
            (§ expr keys.addAll(§ pars maybeLookAhead(§ pars internalParentKey, issuedInternalKeys)))
            (§ if (§ expr keys.isEmpty(§ pars )))
            (§ block
                (§ return nil)
            )

            (§ ass (§ name keyLookaheadEpoch) (§ expr keyLookaheadEpoch + 1))
            ;; Batch add all keys at once so there's only one event listener invocation, as this will be listened to
            ;; by the wallet and used to rebuild/broadcast the Bloom filter.  That's expensive so we don't want to do
            ;; it more often than necessary.
            (§ expr basicKeyChain.importKeys(§ pars keys))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    #_private
    (§ method #_"List<DeterministicKey>" (§ fn maybeLookAhead) [#_"DeterministicKey" (§ name parent), #_"int" (§ name issued)])
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ return (§ expr maybeLookAhead(§ pars parent, issued, getLookaheadSize(§ pars ), getLookaheadThreshold(§ pars ))))
    )

    ;;;
     ; Pre-generate enough keys to reach the lookahead size, but only if there are more than the lookaheadThreshold
     ; to be generated, so that the Bloom filter does not have to be regenerated that often.
     ;
     ; The returned mutable list of keys must be inserted into the basic key chain.
     ;;
    #_private
    (§ method #_"List<DeterministicKey>" (§ fn maybeLookAhead) [#_"DeterministicKey" (§ name parent), #_"int" (§ name issued), #_"int" (§ name lookaheadSize), #_"int" (§ name lookaheadThreshold)])
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        #_final
        (§ var #_"int" (§ name numChildren) (§ expr hierarchy.getNumChildren(§ pars parent.getPath(§ pars ))))
        #_final
        (§ var #_"int" (§ name needed) (§ expr issued + lookaheadSize + lookaheadThreshold - numChildren))

        (§ if (§ expr needed <= lookaheadThreshold))
        (§ block
            (§ return (§ new #_"ArrayList<>" (§ pars )))
        )

        (§ expr log.info(§ pars "{} keys needed for {} = {} issued + {} lookahead size + {} lookahead threshold - {} num children", needed, parent.getPathAsString(§ pars ), issued, lookaheadSize, lookaheadThreshold, numChildren))

        (§ var #_"List<DeterministicKey>" (§ name result) (§ new #_"ArrayList<>" (§ pars needed)))
        #_final
        (§ var #_"Stopwatch" (§ name watch) (§ expr Stopwatch/createStarted(§ pars )))
        (§ var #_"int" (§ name nextChild) numChildren)
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < needed) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ var #_"DeterministicKey" (§ name key) (§ expr HDKeyDerivation/deriveThisOrNextChildKey(§ pars parent, nextChild)))
            (§ ass (§ name key) (§ expr key.dropPrivateBytes(§ pars )))
            (§ expr hierarchy.putKey(§ pars key))
            (§ expr result.add(§ pars key))
            (§ ass (§ name nextChild) (§ expr key.getChildNumber(§ pars ).num(§ pars ) + 1))
        )
        (§ expr watch.stop(§ pars ))
        (§ expr log.info(§ pars "Took {}", watch))
        (§ return result)
    )

    ;;; Housekeeping call to call when lookahead might be needed.  Normally called automatically by KeychainGroup. ;;
    #_public
    (§ method #_"void" (§ fn maybeLookAheadScripts) [])
    (§ block
        (§ void nil)
    )

    ;;;
     ; Returns number of keys used on external path.  This may be fewer than the number that have been deserialized
     ; or held in memory, because of the lookahead zone.
     ;;
    #_public
    (§ method #_"int" (§ fn getIssuedExternalKeys) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return issuedExternalKeys)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns number of keys used on internal path.  This may be fewer than the number that have been deserialized
     ; or held in memory, because of the lookahead zone.
     ;;
    #_public
    (§ method #_"int" (§ fn getIssuedInternalKeys) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return issuedInternalKeys)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;; Returns the seed or null if this chain is a watching chain. ;;
    #_nilable
    #_public
    (§ method #_"DeterministicSeed" (§ fn getSeed) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return seed)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;; For internal usage only.
    (§ method #_"List<ECKey>" (§ fn getKeys) [#_"boolean" (§ name includeLookahead), #_"boolean" (§ name includeParents)])
    (§ block
        (§ var #_"List<ECKey>" (§ name keys) (§ expr basicKeyChain.getKeys(§ pars )))
        (§ if (§ expr (§ not includeLookahead)))
        (§ block
            (§ var #_"int" (§ name treeSize) (§ expr internalParentKey.getPath(§ pars ).size(§ pars )))
            (§ var #_"List<ECKey>" (§ name issuedKeys) (§ new #_"LinkedList<>" (§ pars )))
            (§ for (§ var #_"ECKey" (§ name key)) :for keys)
            (§ block
                (§ var #_"DeterministicKey" (§ name detkey) (§ expr (§ cast #_"DeterministicKey" key)))
                (§ var #_"DeterministicKey" (§ name parent) (§ expr detkey.getParent(§ pars )))
                (§ if (§ expr (§ not includeParents) && parent == nil))
                (§ block
                    (§ continue )
                )
                (§ if (§ expr (§ not includeParents) && detkey.getPath(§ pars ).size(§ pars ) <= treeSize))
                (§ block
                    (§ continue )
                )
                (§ if (§ expr internalParentKey.equals(§ pars parent) && issuedInternalKeys <= detkey.getChildNumber(§ pars ).i(§ pars )))
                (§ block
                    (§ continue )
                )
                (§ if (§ expr externalParentKey.equals(§ pars parent) && issuedExternalKeys <= detkey.getChildNumber(§ pars ).i(§ pars )))
                (§ block
                    (§ continue )
                )
                (§ expr issuedKeys.add(§ pars detkey))
            )
            (§ return issuedKeys)
        )
        (§ return keys)
    )

    ;;;
     ; Returns only the external keys that have been issued by this chain, lookahead not included.
     ;;
    #_public
    (§ method #_"List<ECKey>" (§ fn getIssuedReceiveKeys) [])
    (§ block
        #_final
        (§ var #_"List<ECKey>" (§ name keys) (§ new #_"ArrayList<>" (§ pars getKeys(§ pars false, false))))
        (§ for (§ var #_"Iterator<ECKey>" (§ name i) (§ expr keys.iterator(§ pars ))) :for (§ expr i.hasNext(§ pars )) :for (§ expr ))
        (§ block
            (§ var #_"DeterministicKey" (§ name parent) (§ expr (§ expr (§ cast #_"DeterministicKey" (§ expr i.next(§ pars )))).getParent(§ pars )))
            (§ if (§ expr parent == nil || (§ not externalParentKey.equals(§ pars parent))))
            (§ block
                (§ expr i.remove(§ pars ))
            )
        )
        (§ return keys)
    )

    ;;;
     ; Returns leaf keys issued by this chain (including lookahead zone).
     ;;
    #_public
    (§ method #_"List<DeterministicKey>" (§ fn getLeafKeys) [])
    (§ block
        (§ var #_"ImmutableList.Builder<DeterministicKey>" (§ name keys) (§ expr ImmutableList/builder(§ pars )))
        (§ for (§ var #_"ECKey" (§ name key)) :for (§ expr getKeys(§ pars true, false)))
        (§ block
            (§ var #_"DeterministicKey" (§ name dKey) (§ expr (§ cast #_"DeterministicKey" key)))
            (§ if (§ expr dKey.getPath(§ pars ).size(§ pars ) == getAccountPath(§ pars ).size(§ pars ) + 2))
            (§ block
                (§ expr keys.add(§ pars dKey))
            )
        )
        (§ return (§ expr keys.build(§ pars )))
    )

    #_static
    (§ method #_"void" (§ fn serializeSeedEncryptableItem) [#_"DeterministicSeed" (§ name seed), #_"Protos.Key.Builder" (§ name proto)])
    (§ block
        ;; The seed can be missing if we have not derived it yet from the mnemonic.
        ;; This will not normally happen once all the wallets are on the latest code that caches the seed.
        (§ if (§ expr seed.isEncrypted(§ pars ) && seed.getEncryptedSeedData(§ pars ) != nil))
        (§ block
            (§ var #_"EncryptedData" (§ name data) (§ expr seed.getEncryptedSeedData(§ pars )))
            (§ expr proto.getEncryptedDeterministicSeedBuilder(§ pars ).setEncryptedPrivateKey(§ pars ByteString/copyFrom(§ pars data.encryptedBytes)).setInitialisationVector(§ pars ByteString/copyFrom(§ pars data.initialisationVector)))
            ;; We don't allow mixing of encryption types at the moment.
            (§ expr Preconditions/checkState(§ pars seed.getEncryptionType(§ pars ) == Protos/Wallet/EncryptionType/ENCRYPTED_SCRYPT_AES))
        )
        (§ else )
        (§ block
            #_final
            (§ var #_"byte[]" (§ name secret) (§ expr seed.getSeedBytes(§ pars )))
            (§ if (§ expr secret != nil))
            (§ block
                (§ expr proto.setDeterministicSeed(§ pars ByteString/copyFrom(§ pars secret)))
            )
        )
        (§ void nil)
    )

    ;;;
     ; Returns a counter that is incremented each time new keys are generated due to lookahead.
     ; Used by the network code to learn whether to discard the current block and await calculation
     ; of a new filter.
     ;;
    #_public
    (§ method #_"int" (§ fn getKeyLookaheadEpoch) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return keyLookaheadEpoch)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Whether the keychain is married.  A keychain is married when it vends P2SH addresses from
     ; multiple keychains in a multisig relationship.
     ; @see org.bitcoinj.wallet.MarriedKeyChain
     ;;
    #_public
    (§ method #_"boolean" (§ fn isMarried) [])
    (§ block
        (§ return false)
    )

    ;;; Get redeem data for a key.  Only applicable to married keychains. ;;
    #_public
    (§ method #_"RedeemData" (§ fn getRedeemData) [#_"DeterministicKey" (§ name followedKey)])
    (§ block
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars )))
    )

    ;;; Create a new key and return the matching output script.  Only applicable to married keychains. ;;
    #_public
    (§ method #_"Script" (§ fn freshOutputScript) [#_"KeyPurpose" (§ name purpose)])
    (§ block
        (§ throw (§ new #_"UnsupportedOperationException" (§ pars )))
    )

    #_public
    (§ method #_"String" (§ fn toString) [#_"boolean" (§ name includePrivateKeys), #_"NetworkParameters" (§ name params)])
    (§ block
        #_final
        (§ var #_"DeterministicKey" (§ name watchingKey) (§ expr getWatchingKey(§ pars )))
        #_final
        (§ var #_"StringBuilder" (§ name sb) (§ new #_"StringBuilder" (§ pars )))
        (§ if (§ expr seed != nil))
        (§ block
            (§ if (§ expr seed.isEncrypted(§ pars )))
            (§ block
                (§ expr sb.append(§ pars "Seed is encrypted\n"))
            )
            (§ elseif includePrivateKeys)
            (§ block
                #_final
                (§ var #_"List<String>" (§ name words) (§ expr seed.getMnemonicCode(§ pars )))
                (§ expr sb.append(§ pars "Seed as words: ").append(§ pars Utils/SPACE_JOINER.join(§ pars words)).append(§ pars "\n"))
                (§ expr sb.append(§ pars "Seed as hex:   ").append(§ pars seed.toHexString(§ pars )).append(§ pars "\n"))
            )
            (§ expr sb.append(§ pars "Seed birthday: ").append(§ pars seed.getCreationTimeSeconds(§ pars )).append(§ pars "  [").append(§ pars Utils/dateTimeFormat(§ pars seed.getCreationTimeSeconds(§ pars ) * 1000)).append(§ pars "]\n"))
        )
        (§ else )
        (§ block
            (§ expr sb.append(§ pars "Key birthday:  ").append(§ pars watchingKey.getCreationTimeSeconds(§ pars )).append(§ pars "  [").append(§ pars Utils/dateTimeFormat(§ pars watchingKey.getCreationTimeSeconds(§ pars ) * 1000)).append(§ pars "]\n"))
        )
        (§ expr sb.append(§ pars "Key to watch:  ").append(§ pars watchingKey.serializePubB58(§ pars params)).append(§ pars "\n"))
        (§ expr formatAddresses(§ pars includePrivateKeys, params, sb))
        (§ return (§ expr sb.toString(§ pars )))
    )

    #_protected
    (§ method #_"void" (§ fn formatAddresses) [#_"boolean" (§ name includePrivateKeys), #_"NetworkParameters" (§ name params), #_"StringBuilder" (§ name builder)])
    (§ block
        (§ for (§ var #_"ECKey" (§ name key)) :for (§ expr getKeys(§ pars false, true)))
        (§ block
            (§ expr key.formatKeyWithAddress(§ pars includePrivateKeys, builder, params))
        )
        (§ void nil)
    )

    ;;; The number of signatures required to spend coins received by this keychain. ;;
    #_public
    (§ method #_"void" (§ fn setSigsRequiredToSpend) [#_"int" (§ name sigsRequiredToSpend)])
    (§ block
        (§ ass (§ name this.sigsRequiredToSpend) sigsRequiredToSpend)
        (§ void nil)
    )

    ;;;
     ; Returns the number of signatures required to spend transactions for this KeyChain.
     ; It's the N from N-of-M CHECKMULTISIG script for P2SH transactions and always 1 for other transaction types.
     ;;
    #_public
    (§ method #_"int" (§ fn getSigsRequiredToSpend) [])
    (§ block
        (§ return sigsRequiredToSpend)
    )

    ;;; Returns the redeem script by its hash or null if this keychain did not generate the script. ;;
    #_nilable
    #_public
    (§ method #_"RedeemData" (§ fn findRedeemDataByScriptHash) [#_"ByteString" (§ name bytes)])
    (§ block
        (§ return nil)
    )
)

#_(ns org.bitcoinj.wallet #_"DeterministicSeed"
    (:import [java.security SecureRandom]
             [java.util List])
    (:import [com.google.common.base Charsets Objects Preconditions Splitter]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core Utils]
             #_static [org.bitcoinj.core.Utils HEX]
             [org.bitcoinj.crypto *]))

;;;
 ; Holds the seed bytes for the BIP32 deterministic wallet algorithm, inside a {@link DeterministicKeyChain}.
 ; The purpose of this wrapper is to simplify the encryption code.
 ;;
#_public
(§ class #_"DeterministicSeed" (§ implements #_"EncryptableItem")
    ;; It would take more than 10^12 years to brute-force a 128 bit seed using $1B worth of computing equipment.
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name DEFAULT_SEED_ENTROPY_BITS) 128)
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name MAX_SEED_ENTROPY_BITS) 512)

    #_nilable
    #_private
    #_final
    (§ field #_"byte[]" (§ name seed))
    #_nilable
    #_private
    #_final
    (§ field #_"List<String>" (§ name mnemonicCode)) ;; only one of mnemonicCode/encryptedMnemonicCode will be set
    #_nilable
    #_private
    #_final
    (§ field #_"EncryptedData" (§ name encryptedMnemonicCode))
    #_nilable
    #_private
    (§ field #_"EncryptedData" (§ name encryptedSeed))
    #_private
    (§ field #_"long" (§ name creationTimeSeconds))

    #_public
    (§ constructor #_"DeterministicSeed" [#_"String" (§ name mnemonicCode), #_"byte[]" (§ name seed), #_"String" (§ name passphrase), #_"long" (§ name creationTimeSeconds)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        (§ this (§ pars decodeMnemonicCode(§ pars mnemonicCode), seed, passphrase, creationTimeSeconds))
        (§ void this)
    )

    #_public
    (§ constructor #_"DeterministicSeed" [#_"byte[]" (§ name seed), #_"List<String>" (§ name mnemonic), #_"long" (§ name creationTimeSeconds)])
    (§ block
        (§ ass (§ name this.seed) (§ expr Preconditions/checkNotNull(§ pars seed)))
        (§ ass (§ name this.mnemonicCode) (§ expr Preconditions/checkNotNull(§ pars mnemonic)))
        (§ ass (§ name this.encryptedMnemonicCode) nil)
        (§ ass (§ name this.creationTimeSeconds) creationTimeSeconds)
        (§ void this)
    )

    #_public
    (§ constructor #_"DeterministicSeed" [#_"EncryptedData" (§ name encryptedMnemonic), #_nilable #_"EncryptedData" (§ name encryptedSeed), #_"long" (§ name creationTimeSeconds)])
    (§ block
        (§ ass (§ name this.seed) nil)
        (§ ass (§ name this.mnemonicCode) nil)
        (§ ass (§ name this.encryptedMnemonicCode) (§ expr Preconditions/checkNotNull(§ pars encryptedMnemonic)))
        (§ ass (§ name this.encryptedSeed) encryptedSeed)
        (§ ass (§ name this.creationTimeSeconds) creationTimeSeconds)
        (§ void this)
    )

    ;;;
     ; Constructs a seed from a BIP 39 mnemonic code.
     ; See {@link org.bitcoinj.crypto.MnemonicCode} for more details on this scheme.
     ; @param mnemonicCode A list of words.
     ; @param seed The derived seed, or pass null to derive it from mnemonicCode (slow).
     ; @param passphrase A user supplied passphrase, or an empty string if there is no passphrase.
     ; @param creationTimeSeconds When the seed was originally created, UNIX time.
     ;;
    #_public
    (§ constructor #_"DeterministicSeed" [#_"List<String>" (§ name mnemonicCode), #_nilable #_"byte[]" (§ name seed), #_"String" (§ name passphrase), #_"long" (§ name creationTimeSeconds)])
    (§ block
        (§ this (§ pars (§ quest (§ expr seed != nil) ? seed :else (§ expr MnemonicCode/toSeed(§ pars mnemonicCode, Preconditions/checkNotNull(§ pars passphrase)))), mnemonicCode, creationTimeSeconds))
        (§ void this)
    )

    ;;;
     ; Constructs a seed from a BIP 39 mnemonic code.
     ; See {@link org.bitcoinj.crypto.MnemonicCode} for more details on this scheme.
     ; @param random Entropy source.
     ; @param bits Number of bits, must be divisible by 32.
     ; @param passphrase A user supplied passphrase, or an empty string if there is no passphrase.
     ; @param creationTimeSeconds When the seed was originally created, UNIX time.
     ;;
    #_public
    (§ constructor #_"DeterministicSeed" [#_"SecureRandom" (§ name random), #_"int" (§ name bits), #_"String" (§ name passphrase), #_"long" (§ name creationTimeSeconds)])
    (§ block
        (§ this (§ pars getEntropy(§ pars random, bits), Preconditions/checkNotNull(§ pars passphrase), creationTimeSeconds))
        (§ void this)
    )

    ;;;
     ; Constructs a seed from a BIP 39 mnemonic code.
     ; See {@link org.bitcoinj.crypto.MnemonicCode} for more details on this scheme.
     ; @param entropy Entropy bits, length must be divisible by 32.
     ; @param passphrase A user supplied passphrase, or an empty string if there is no passphrase.
     ; @param creationTimeSeconds When the seed was originally created, UNIX time.
     ;;
    #_public
    (§ constructor #_"DeterministicSeed" [#_"byte[]" (§ name entropy), #_"String" (§ name passphrase), #_"long" (§ name creationTimeSeconds)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars entropy.length % 4 == 0, "entropy size in bits not divisible by 32"))
        (§ expr Preconditions/checkArgument(§ pars DEFAULT_SEED_ENTROPY_BITS <= entropy.length * 8, "entropy size too small"))
        (§ expr Preconditions/checkNotNull(§ pars passphrase))

        (§ try )
        (§ block
            (§ ass (§ name this.mnemonicCode) (§ expr MnemonicCode/INSTANCE.toMnemonic(§ pars entropy)))
        )
        (§ catch #_"MnemonicException.MnemonicLengthException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
        (§ ass (§ name this.seed) (§ expr MnemonicCode/toSeed(§ pars mnemonicCode, passphrase)))
        (§ ass (§ name this.encryptedMnemonicCode) nil)
        (§ ass (§ name this.creationTimeSeconds) creationTimeSeconds)
        (§ void this)
    )

    #_private
    #_static
    (§ method #_"byte[]" (§ fn getEntropy) [#_"SecureRandom" (§ name random), #_"int" (§ name bits)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars bits <= MAX_SEED_ENTROPY_BITS, "requested entropy size too large"))

        (§ var #_"byte[]" (§ name seed) (§ new #_"byte[]" (§ count bits / 8)))
        (§ expr random.nextBytes(§ pars seed))
        (§ return seed)
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn isEncrypted) [])
    (§ block
        (§ expr Preconditions/checkState(§ pars mnemonicCode != nil || encryptedMnemonicCode != nil))
        (§ return (§ expr encryptedMnemonicCode != nil))
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ quest (§ expr isEncrypted(§ pars )) ? (§ expr "DeterministicSeed [encrypted]") :else (§ str "DeterministicSeed " + (§ expr toHexString(§ pars )) + " " + (§ expr Utils/SPACE_JOINER.join(§ pars mnemonicCode)))))
    )

    ;;; Returns the seed as hex or null if encrypted. ;;
    #_nilable
    #_public
    (§ method #_"String" (§ fn toHexString) [])
    (§ block
        (§ return (§ quest (§ expr seed != nil) ? (§ expr HEX.encode(§ pars seed)) :else nil))
    )

    #_nilable
    #_override
    #_public
    (§ method #_"byte[]" (§ fn getSecretBytes) [])
    (§ block
        (§ return (§ expr getMnemonicAsBytes(§ pars )))
    )

    #_nilable
    #_public
    (§ method #_"byte[]" (§ fn getSeedBytes) [])
    (§ block
        (§ return seed)
    )

    #_nilable
    #_override
    #_public
    (§ method #_"EncryptedData" (§ fn getEncryptedData) [])
    (§ block
        (§ return encryptedMnemonicCode)
    )

    #_override
    #_public
    (§ method #_"Protos.Wallet.EncryptionType" (§ fn getEncryptionType) [])
    (§ block
        (§ return (§ expr Protos/Wallet/EncryptionType/ENCRYPTED_SCRYPT_AES))
    )

    #_nilable
    #_public
    (§ method #_"EncryptedData" (§ fn getEncryptedSeedData) [])
    (§ block
        (§ return encryptedSeed)
    )

    #_override
    #_public
    (§ method #_"long" (§ fn getCreationTimeSeconds) [])
    (§ block
        (§ return creationTimeSeconds)
    )

    #_public
    (§ method #_"void" (§ fn setCreationTimeSeconds) [#_"long" (§ name creationTimeSeconds)])
    (§ block
        (§ ass (§ name this.creationTimeSeconds) creationTimeSeconds)
        (§ void nil)
    )

    #_public
    (§ method #_"DeterministicSeed" (§ fn encrypt) [#_"KeyCrypter" (§ name keyCrypter), #_"KeyParameter" (§ name aesKey)])
    (§ block
        (§ expr Preconditions/checkState(§ pars encryptedMnemonicCode == nil, "Trying to encrypt seed twice"))
        (§ expr Preconditions/checkState(§ pars mnemonicCode != nil, "Mnemonic missing so cannot encrypt"))

        (§ var #_"EncryptedData" (§ name encryptedMnemonic) (§ expr keyCrypter.encrypt(§ pars getMnemonicAsBytes(§ pars ), aesKey)))
        (§ var #_"EncryptedData" (§ name encryptedSeed) (§ expr keyCrypter.encrypt(§ pars seed, aesKey)))
        (§ return (§ new #_"DeterministicSeed" (§ pars encryptedMnemonic, encryptedSeed, creationTimeSeconds)))
    )

    #_private
    (§ method #_"byte[]" (§ fn getMnemonicAsBytes) [])
    (§ block
        (§ return (§ expr Utils/SPACE_JOINER.join(§ pars mnemonicCode).getBytes(§ pars Charsets/UTF_8)))
    )

    #_public
    (§ method #_"DeterministicSeed" (§ fn decrypt) [#_"KeyCrypter" (§ name crypter), #_"String" (§ name passphrase), #_"KeyParameter" (§ name aesKey)])
    (§ block
        (§ expr Preconditions/checkState(§ pars isEncrypted(§ pars )))
        (§ expr Preconditions/checkNotNull(§ pars encryptedMnemonicCode))

        (§ var #_"List<String>" (§ name mnemonic) (§ expr decodeMnemonicCode(§ pars crypter.decrypt(§ pars encryptedMnemonicCode, aesKey))))
        (§ var #_"byte[]" (§ name seed) (§ quest (§ expr encryptedSeed != nil) ? (§ expr crypter.decrypt(§ pars encryptedSeed, aesKey)) :else nil))
        (§ return (§ new #_"DeterministicSeed" (§ pars mnemonic, seed, passphrase, creationTimeSeconds)))
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn equals) [#_"Object" (§ name o)])
    (§ block
        (§ if (§ expr this == o))
        (§ block
            (§ return true)
        )
        (§ if (§ expr o == nil || getClass(§ pars ) != o.getClass(§ pars )))
        (§ block
            (§ return false)
        )
        (§ var #_"DeterministicSeed" (§ name other) (§ expr (§ cast #_"DeterministicSeed" o)))
        (§ return (§ expr creationTimeSeconds == other.creationTimeSeconds && Objects/equal(§ pars encryptedMnemonicCode, other.encryptedMnemonicCode) && Objects/equal(§ pars mnemonicCode, other.mnemonicCode)))
    )

    #_override
    #_public
    (§ method #_"int" (§ fn hashCode) [])
    (§ block
        (§ return (§ expr Objects/hashCode(§ pars creationTimeSeconds, encryptedMnemonicCode, mnemonicCode)))
    )

    ;;;
     ; Check if our mnemonic is a valid mnemonic phrase for our word list.
     ; Does nothing if we are encrypted.
     ;
     ; @throws org.bitcoinj.crypto.MnemonicException if check fails.
     ;;
    #_public
    (§ method #_"void" (§ fn check) [])
        (§ throws #_"MnemonicException")
    (§ block
        (§ if (§ expr mnemonicCode != nil))
        (§ block
            (§ expr MnemonicCode/INSTANCE.check(§ pars mnemonicCode))
        )
        (§ void nil)
    )

    (§ method #_"byte[]" (§ fn getEntropyBytes) [])
        (§ throws #_"MnemonicException")
    (§ block
        (§ return (§ expr MnemonicCode/INSTANCE.toEntropy(§ pars mnemonicCode)))
    )

    ;;; Get the mnemonic code, or null if unknown. ;;
    #_nilable
    #_public
    (§ method #_"List<String>" (§ fn getMnemonicCode) [])
    (§ block
        (§ return mnemonicCode)
    )

    #_private
    #_static
    (§ method #_"List<String>" (§ fn decodeMnemonicCode) [#_"byte[]" (§ name mnemonicCode)])
    (§ block
        (§ return (§ expr decodeMnemonicCode(§ pars Utils/toString(§ pars mnemonicCode, "UTF-8"))))
    )

    #_private
    #_static
    (§ method #_"List<String>" (§ fn decodeMnemonicCode) [#_"String" (§ name mnemonicCode)])
    (§ block
        (§ return (§ expr Splitter/on(§ pars " ").splitToList(§ pars mnemonicCode)))
    )
)

#_(ns org.bitcoinj.wallet #_"DeterministicUpgradeRequiredException")

;;;
 ; Indicates that an attempt was made to use HD wallet features on a wallet that was deserialized from an old,
 ; pre-HD random wallet without calling upgradeToDeterministic() beforehand.
 ;;
#_public
(§ class #_"DeterministicUpgradeRequiredException" (§ extends #_"RuntimeException"))

#_(ns org.bitcoinj.wallet #_"DeterministicUpgradeRequiresPassword")

;;;
 ; Indicates that the pre-HD random wallet is encrypted, so you should try the upgrade again after getting the
 ; users password.  This is required because HD wallets are upgraded from random using the private key bytes of
 ; the oldest non-rotating key, in order to make the upgrade process itself deterministic.
 ;;
#_public
(§ class #_"DeterministicUpgradeRequiresPassword" (§ extends #_"RuntimeException"))

#_(ns org.bitcoinj.wallet #_"EncryptableKeyChain"
    (:import [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.crypto KeyCrypter KeyCrypterException]))

;;;
 ; An encryptable key chain is a key-chain that can be encrypted with a user-provided password or AES key.
 ;;
#_public
(§ interface #_"EncryptableKeyChain" (§ extends #_"KeyChain")
    ;;;
     ; Takes the given password, which should be strong, derives a key from it and then invokes
     ; {@link #toEncrypted(org.bitcoinj.crypto.KeyCrypter, org.spongycastle.crypto.params.KeyParameter)}
     ; with {@link org.bitcoinj.crypto.KeyCrypterScrypt} as the crypter.
     ;
     ; @return the derived key, in case you wish to cache it for future use.
     ;;
    (§ method #_"EncryptableKeyChain" (§ fn toEncrypted) [#_"CharSequence" (§ name password)])

    ;;;
     ; Returns a new keychain holding identical/cloned keys to this chain, but encrypted under the given key.
     ; Old keys and keychains remain valid and so you should ensure you don't accidentally hold references to them.
     ;;
    (§ method #_"EncryptableKeyChain" (§ fn toEncrypted) [#_"KeyCrypter" (§ name keyCrypter), #_"KeyParameter" (§ name aesKey)])

    ;;;
     ; Decrypts the key chain with the given password.
     ; See {@link #toDecrypted(org.spongycastle.crypto.params.KeyParameter)} for details.
     ;;
    (§ method #_"EncryptableKeyChain" (§ fn toDecrypted) [#_"CharSequence" (§ name password)])

    ;;;
     ; Decrypt the key chain with the given AES key and whatever {@link KeyCrypter} is already set.  Note that
     ; if you just want to spend money from an encrypted wallet, don't decrypt the whole thing first.  Instead,
     ; set the {@link org.bitcoinj.wallet.SendRequest#aesKey} field before asking the wallet to build the send.
     ;
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time
     ;               consuming to create from a password).
     ; @throws KeyCrypterException if the wallet decryption fails.  If so, the wallet state is unchanged.
     ;;
    (§ method #_"EncryptableKeyChain" (§ fn toDecrypted) [#_"KeyParameter" (§ name aesKey)])

    (§ method #_"boolean" (§ fn checkPassword) [#_"CharSequence" (§ name password)])
    (§ method #_"boolean" (§ fn checkAESKey) [#_"KeyParameter" (§ name aesKey)])

    ;;; Returns the key crypter used by this key chain, or null if it's not encrypted. ;;
    #_nilable
    (§ method #_"KeyCrypter" (§ fn getKeyCrypter) [])
)

#_(ns org.bitcoinj.wallet #_"FilteringCoinSelector"
    (:import [java.util HashSet Iterator List])
   (:require [org.bitcoinj.core *]))

;;;
 ; A filtering coin selector delegates to another coin selector, but won't select outputs spent by the given transactions.
 ;;
#_public
(§ class #_"FilteringCoinSelector" (§ implements #_"CoinSelector")
    #_protected
    (§ field #_"CoinSelector" (§ name delegate))
    #_protected
    (§ field #_"HashSet<TransactionOutPoint>" (§ name spent) (§ new #_"HashSet<>" (§ pars )))

    #_public
    (§ constructor #_"FilteringCoinSelector" [#_"CoinSelector" (§ name delegate)])
    (§ block
        (§ ass (§ name this.delegate) delegate)
        (§ void this)
    )

    #_public
    (§ method #_"void" (§ fn excludeOutputsSpentBy) [#_"Transaction" (§ name tx)])
    (§ block
        (§ for (§ var #_"TransactionInput" (§ name input)) :for (§ expr tx.getInputs(§ pars )))
        (§ block
            (§ expr spent.add(§ pars input.getOutpoint(§ pars )))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"CoinSelection" (§ fn select) [#_"Coin" (§ name target), #_"List<TransactionOutput>" (§ name candidates)])
    (§ block
        (§ var #_"Iterator<TransactionOutput>" (§ name iter) (§ expr candidates.iterator(§ pars )))
        (§ while (§ expr iter.hasNext(§ pars )))
        (§ block
            (§ var #_"TransactionOutput" (§ name output) (§ expr iter.next(§ pars )))
            (§ if (§ expr spent.contains(§ pars output.getOutPointFor(§ pars ))))
            (§ block
                (§ expr iter.remove(§ pars ))
            )
        )
        (§ return (§ expr delegate.select(§ pars target, candidates)))
    )
)

#_(ns org.bitcoinj.wallet #_"KeyBag"
   (:require [org.bitcoinj.core ECKey]))

;;;
 ; A KeyBag is simply an object that can map public keys, their 160-bit hashes and script hashes to ECKey
 ; and {@link RedeemData} objects.
 ;;
#_public
(§ interface #_"KeyBag"
    ;;;
     ; Locates a keypair from the keychain given the hash of the public key.  This is needed when finding out
     ; which key we need to use to redeem a transaction output.
     ;
     ; @return ECKey object or null if no such key was found.
     ;;
    #_nilable
    (§ method #_"ECKey" (§ fn findKeyFromPubHash) [#_"byte[]" (§ name pubkeyHash)])

    ;;;
     ; Locates a keypair from the keychain given the raw public key bytes.
     ;
     ; @return ECKey or null if no such key was found.
     ;;
    #_nilable
    (§ method #_"ECKey" (§ fn findKeyFromPubKey) [#_"byte[]" (§ name pubkey)])

    ;;;
     ; Locates a redeem data (redeem script and keys) from the keychain given the hash of the script.
     ; This is needed when finding out which key and script we need to use to locally sign a P2SH transaction input.
     ; It is assumed that wallet should not have more than one private key for a single P2SH tx for security reasons.
     ;
     ; @return RedeemData object or null if no such data was found.
     ;;
    #_nilable
    (§ method #_"RedeemData" (§ fn findRedeemDataFromScriptHash) [#_"byte[]" (§ name scriptHash)])
)

#_(ns org.bitcoinj.wallet #_"KeyChain"
    (:import [java.util List]
             [java.util.concurrent Executor])
   (:require [org.bitcoinj.core BloomFilter ECKey]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

;;;
 ; <p>A KeyChain is a class that stores a collection of keys for a {@link org.bitcoinj.wallet.Wallet}.  Key chains
 ; are expected to be able to look up keys given a hash (i.e. address) or pubkey bytes, and provide keys on request
 ; for a given purpose.  They can inform event listeners about new keys being added.</p>
 ;
 ; <p>However it is important to understand what this interface does <i>not</i> provide.  It cannot encrypt or decrypt
 ; keys, for instance you need an implementor of {@link EncryptableKeyChain}.  It cannot have keys imported into it,
 ; that you to use a method of a specific key chain instance, such as {@link BasicKeyChain}.  The reason for these
 ; restrictions is to support key chains that may be handled by external hardware or software, or which are derived
 ; deterministically from a seed (and thus the notion of importing a key is meaningless).</p>
 ;;
#_public
(§ interface #_"KeyChain"
    ;;; Returns true if the given key is in the chain. ;;
    (§ method #_"boolean" (§ fn hasKey) [#_"ECKey" (§ name key)])

    (§ enum #_"KeyPurpose"
        (§ item RECEIVE_FUNDS)
        (§ item CHANGE)
        (§ item REFUND)
        (§ item AUTHENTICATION)
    )

    ;;;
     ; Obtains a number of key/s intended for the given purpose.
     ; The chain may create new key/s, derive, or re-use an old one.
     ;;
    (§ method #_"List<? extends ECKey>" (§ fn getKeys) [#_"KeyPurpose" (§ name purpose), #_"int" (§ name numberOfKeys)])

    ;;;
     ; Obtains a key intended for the given purpose.
     ; The chain may create a new key, derive one, or re-use an old one.
     ;;
    (§ method #_"ECKey" (§ fn getKey) [#_"KeyPurpose" (§ name purpose)])

    ;;; Returns a list of keys serialized to the bitcoinj protobuf format. ;;
    (§ method #_"List<Protos.Key>" (§ fn serializeToProtobuf) [])

    ;;; Adds a listener for events that are run when keys are added, on the user thread. ;;
    (§ method #_"void" (§ fn addEventListener) [#_"KeyChainEventListener" (§ name listener)])

    ;;; Adds a listener for events that are run when keys are added, on the given executor. ;;
    (§ method #_"void" (§ fn addEventListener) [#_"KeyChainEventListener" (§ name listener), #_"Executor" (§ name executor)])

    ;;; Removes a listener for events that are run when keys are added. ;;
    (§ method #_"boolean" (§ fn removeEventListener) [#_"KeyChainEventListener" (§ name listener)])

    ;;; Returns the number of keys this key chain manages. ;;
    (§ method #_"int" (§ fn numKeys) [])

    ;;;
     ; Returns the number of elements this chain wishes to insert into the Bloom filter.
     ; The size passed to {@link #getFilter(int, double, long)} should be at least this large.
     ;;
    (§ method #_"int" (§ fn numBloomFilterEntries) [])

    ;;;
     ; Returns the earliest creation time of keys in this chain, in seconds since the epoch.  This can return
     ; zero if at least one key does not have that data (was created before key timestamping was implemented).
     ; If there are no keys in the wallet, {@link Long#MAX_VALUE} is returned.
     ;;
    (§ method #_"long" (§ fn getEarliestKeyCreationTime) [])

    ;;;
     ; <p>Gets a bloom filter that contains all of the public keys from this chain, and which will provide the given
     ; false-positive rate if it has size elements.  Keep in mind that you will get 2 elements in the bloom filter for
     ; each key in the key chain, for the public key and the hash of the public key (address form).  For this reason
     ; size should be <i>at least</i> 2x the result of {@link #numKeys()}.</p>
     ;
     ; <p>This is used to generate a {@link BloomFilter} which can be {@link BloomFilter#merge(BloomFilter)}d with
     ; another.  It could also be used if you have a specific target for the filter's size.</p>
     ;
     ; <p>See the docs for {@link org.bitcoinj.core.BloomFilter#BloomFilter(int, double, long)} for a brief
     ; explanation of anonymity when using bloom filters, and for the meaning of these parameters.</p>
     ;;
    (§ method #_"BloomFilter" (§ fn getFilter) [#_"int" (§ name size), #_"double" (§ name falsePositiveRate), #_"long" (§ name tweak)])
)

#_(ns org.bitcoinj.wallet #_"KeyChainFactory"
   (:require [org.bitcoinj.crypto DeterministicKey KeyCrypter]))

;;;
 ; Factory interface for creation keychains while de-serializing a wallet.
 ;;
#_public
(§ interface #_"KeyChainFactory"
    ;;;
     ; Make a keychain (but not a watching one).
     ;
     ; @param key The protobuf for the root key.
     ; @param firstSubKey The protobuf for the first child key (normally the parent of the external subchain).
     ; @param seed The seed.
     ; @param crypter The encrypted/decrypter.
     ; @param isMarried Whether the keychain is leading in a marriage.
     ;;
    (§ method #_"DeterministicKeyChain" (§ fn makeKeyChain) [#_"Protos.Key" (§ name key), #_"Protos.Key" (§ name firstSubKey), #_"DeterministicSeed" (§ name seed), #_"KeyCrypter" (§ name crypter), #_"boolean" (§ name isMarried)])

    ;;;
     ; Make a watching keychain.
     ;
     ; isMarried and isFollowingKey must not be true at the same time.
     ;
     ; @param key The protobuf for the account key.
     ; @param firstSubKey The protobuf for the first child key (normally the parent of the external subchain).
     ; @param accountKey The account extended public key.
     ; @param isFollowingKey Whether the keychain is following in a marriage.
     ; @param isMarried Whether the keychain is leading in a marriage.
     ;;
    (§ method #_"DeterministicKeyChain" (§ fn makeWatchingKeyChain) [#_"Protos.Key" (§ name key), #_"Protos.Key" (§ name firstSubKey), #_"DeterministicKey" (§ name accountKey), #_"boolean" (§ name isFollowingKey), #_"boolean" (§ name isMarried)])
        (§ throws #_"UnreadableWalletException")
)

#_(ns org.bitcoinj.wallet #_"KeyChainGroup"
    (:import [java.security *]
             [java.util *]
             [java.util.concurrent *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect *]
             [com.google.protobuf *]
             [org.slf4j *]
             [org.spongycastle.crypto.params *])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.crypto *]
             [org.bitcoinj.script *]
             [org.bitcoinj.utils *]
             [org.bitcoinj.wallet.listeners KeyChainEventListener]))

;;;
 ; <p>A KeyChainGroup is used by the {@link org.bitcoinj.wallet.Wallet} and manages: a {@link BasicKeyChain} object
 ; (which will normally be empty), and zero or more {@link DeterministicKeyChain}s.  A deterministic key chain will be
 ; created lazily/on demand when a fresh or current key is requested, possibly being initialized from the private key
 ; bytes of the earliest non rotating key in the basic key chain if one is available, or from a fresh random seed if not.</p>
 ;
 ; <p>If a key rotation time is set, it may be necessary to add a new DeterministicKeyChain with a fresh seed and
 ; also preserve the old one, so funds can be swept from the rotating keys.  In this case, there may be more than
 ; one deterministic chain.  The latest chain is called the active chain and is where new keys are served from.</p>
 ;
 ; <p>The wallet delegates most key management tasks to this class.  It is <b>not</b> thread safe and requires external
 ; locking, i.e. by the wallet lock.  The group then in turn delegates most operations to the key chain objects,
 ; combining their responses together when necessary.</p>
 ;
 ; <p>Deterministic key chains have a concept of a lookahead size and threshold.  Please see the discussion in the
 ; class docs for {@link DeterministicKeyChain} for more information on this topic.</p>
 ;;
#_public
(§ class #_"KeyChainGroup" (§ implements #_"KeyBag")
    #_static
    (§ block
        ;; Init proper random number generator, as some old Android installations have bugs that make it unsecure.
        (§ if (§ expr Utils/isAndroidRuntime(§ pars )))
        (§ block
            (§ expr (§ new #_"LinuxSecureRandom" (§ pars )))
        )
    )

    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"KeyChainGroup"))))

    #_private
    (§ field #_"BasicKeyChain" (§ name basic))
    #_private
    (§ field #_"NetworkParameters" (§ name params))
    #_protected
    #_final
    (§ field #_"LinkedList<DeterministicKeyChain>" (§ name chains))
    ;; currentKeys is used for normal, non-multisig/married wallets.
    ;; currentAddresses is used when we're handing out P2SH addresses.
    ;; They're mutually exclusive.
    #_private
    #_final
    (§ field #_"EnumMap<KeyChain.KeyPurpose, DeterministicKey>" (§ name currentKeys))
    #_private
    #_final
    (§ field #_"EnumMap<KeyChain.KeyPurpose, Address>" (§ name currentAddresses))

    #_nilable
    #_private
    (§ field #_"KeyCrypter" (§ name keyCrypter))
    #_private
    (§ field #_"int" (§ name lookaheadSize) -1)
    #_private
    (§ field #_"int" (§ name lookaheadThreshold) -1)

    ;;; Creates a keychain group with no basic chain, and a single, lazily created HD chain. ;;
    #_public
    (§ constructor #_"KeyChainGroup" [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ this (§ pars params, nil, new ArrayList<DeterministicKeyChain>(§ pars 1), nil, nil))
        (§ void this)
    )

    ;;; Creates a keychain group with no basic chain, and an HD chain initialized from the given seed. ;;
    #_public
    (§ constructor #_"KeyChainGroup" [#_"NetworkParameters" (§ name params), #_"DeterministicSeed" (§ name seed)])
    (§ block
        (§ this (§ pars params, nil, ImmutableList/of(§ pars (§ new #_"DeterministicKeyChain" (§ pars seed))), nil, nil))
        (§ void this)
    )

    ;;;
     ; Creates a keychain group with no basic chain, and an HD chain that is watching the given watching key.
     ; This HAS to be an account key as returned by {@link DeterministicKeyChain#getWatchingKey()}.
     ;;
    #_public
    (§ constructor #_"KeyChainGroup" [#_"NetworkParameters" (§ name params), #_"DeterministicKey" (§ name watchKey)])
    (§ block
        (§ this (§ pars params, nil, ImmutableList/of(§ pars DeterministicKeyChain/watch(§ pars watchKey)), nil, nil))
        (§ void this)
    )

    ;; Used for deserialization.
    #_private
    (§ constructor #_"KeyChainGroup" [#_"NetworkParameters" (§ name params), #_nilable #_"BasicKeyChain" (§ name basicKeyChain), #_"List<DeterministicKeyChain>" (§ name chains), #_nilable #_"EnumMap<KeyChain.KeyPurpose, DeterministicKey>" (§ name currentKeys), #_nilable #_"KeyCrypter" (§ name crypter)])
    (§ block
        (§ ass (§ name this.params) params)
        (§ ass (§ name this.basic) (§ quest (§ expr basicKeyChain == nil) ? (§ new #_"BasicKeyChain" (§ pars )) :else basicKeyChain))
        (§ ass (§ name this.chains) (§ new #_"LinkedList<>" (§ pars Preconditions/checkNotNull(§ pars chains))))
        (§ ass (§ name this.keyCrypter) crypter)
        (§ ass (§ name this.currentKeys) (§ quest (§ expr currentKeys == nil) ? (§ new #_"EnumMap<KeyChain.KeyPurpose, DeterministicKey>" (§ pars (§ klass #_"KeyChain.KeyPurpose"))) :else currentKeys))
        (§ ass (§ name this.currentAddresses) (§ new #_"EnumMap<>" (§ pars (§ klass #_"KeyChain.KeyPurpose"))))
        (§ expr maybeLookaheadScripts(§ pars ))

        (§ if (§ expr isMarried(§ pars )))
        (§ block
            (§ for (§ var #_"Map.Entry<KeyChain.KeyPurpose, DeterministicKey>" (§ name entry)) :for (§ expr this.currentKeys.entrySet(§ pars )))
            (§ block
                (§ var #_"Address" (§ name address) (§ expr makeP2SHOutputScript(§ pars entry.getValue(§ pars ), getActiveKeyChain(§ pars )).getToAddress(§ pars params)))
                (§ expr currentAddresses.put(§ pars entry.getKey(§ pars ), address))
            )
        )
        (§ void this)
    )

    ;; This keeps married redeem data in sync with the number of keys issued.
    #_private
    (§ method #_"void" (§ fn maybeLookaheadScripts) [])
    (§ block
        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
        (§ block
            (§ expr chain.maybeLookAheadScripts(§ pars ))
        )
        (§ void nil)
    )

    ;;; Adds a new HD chain to the chains list, and make it the default chain (from which keys are issued). ;;
    #_public
    (§ method #_"void" (§ fn createAndActivateNewHDChain) [])
    (§ block
        ;; We can't do auto upgrade here because we don't know the rotation time, if any.
        #_final
        (§ var #_"DeterministicKeyChain" (§ name chain) (§ new #_"DeterministicKeyChain" (§ pars (§ new #_"SecureRandom" (§ pars )))))
        (§ expr addAndActivateHDChain(§ pars chain))
        (§ void nil)
    )

    ;;;
     ; Adds an HD chain to the chains list, and make it the default chain (from which keys are issued).
     ; Useful for adding a complex pre-configured keychain, such as a married wallet.
     ;;
    #_public
    (§ method #_"void" (§ fn addAndActivateHDChain) [#_"DeterministicKeyChain" (§ name chain)])
    (§ block
        (§ expr log.info(§ pars "Creating and activating a new HD chain: {}", chain))
        (§ for (§ var #_"ListenerRegistration<KeyChainEventListener>" (§ name registration)) :for (§ expr basic.getListeners(§ pars )))
        (§ block
            (§ expr chain.addEventListener(§ pars registration.listener, registration.executor))
        )
        (§ if (§ expr 0 <= lookaheadSize))
        (§ block
            (§ expr chain.setLookaheadSize(§ pars lookaheadSize))
        )
        (§ if (§ expr 0 <= lookaheadThreshold))
        (§ block
            (§ expr chain.setLookaheadThreshold(§ pars lookaheadThreshold))
        )
        (§ expr chains.add(§ pars chain))
        (§ void nil)
    )

    ;;;
     ; Returns a key that hasn't been seen in a transaction yet, and which is suitable for displaying in a wallet
     ; user interface as "a convenient key to receive funds on" when the purpose parameter is
     ; {@link KeyChain.KeyPurpose#RECEIVE_FUNDS}.  The returned key is stable until it's actually seen in a pending
     ; or confirmed transaction, at which point this method will start returning a different key (for each purpose
     ; independently).
     ;
     ; <p>This method is not supposed to be used for married keychains and will throw UnsupportedOperationException
     ; if the active chain is married.
     ; For married keychains use {@link #currentAddress(KeyChain.KeyPurpose)} to get a proper P2SH address.</p>
     ;;
    #_public
    (§ method #_"DeterministicKey" (§ fn currentKey) [#_"KeyChain.KeyPurpose" (§ name purpose)])
    (§ block
        (§ var #_"DeterministicKeyChain" (§ name chain) (§ expr getActiveKeyChain(§ pars )))
        (§ if (§ expr chain.isMarried(§ pars )))
        (§ block
            (§ throw (§ new #_"UnsupportedOperationException" (§ pars "Key is not suitable to receive coins for married keychains. Use freshAddress to get P2SH address instead.")))
        )

        (§ var #_"DeterministicKey" (§ name current) (§ expr currentKeys.get(§ pars purpose)))
        (§ if (§ expr current == nil))
        (§ block
            (§ ass (§ name current) (§ expr freshKey(§ pars purpose)))
            (§ expr currentKeys.put(§ pars purpose, current))
        )
        (§ return current)
    )

    ;;;
     ; Returns address for a {@link #currentKey(KeyChain.KeyPurpose)}.
     ;;
    #_public
    (§ method #_"Address" (§ fn currentAddress) [#_"KeyChain.KeyPurpose" (§ name purpose)])
    (§ block
        (§ var #_"DeterministicKeyChain" (§ name chain) (§ expr getActiveKeyChain(§ pars )))
        (§ if (§ expr chain.isMarried(§ pars )))
        (§ block
            (§ var #_"Address" (§ name current) (§ expr currentAddresses.get(§ pars purpose)))
            (§ if (§ expr current == nil))
            (§ block
                (§ ass (§ name current) (§ expr freshAddress(§ pars purpose)))
                (§ expr currentAddresses.put(§ pars purpose, current))
            )
            (§ return current)
        )

        (§ return (§ expr currentKey(§ pars purpose).toAddress(§ pars params)))
    )

    ;;;
     ; Returns a key that has not been returned by this method before (fresh).  You can think of this as being a newly
     ; created key, although the notion of "create" is not really valid for a {@link DeterministicKeyChain}.  When the
     ; parameter is {@link KeyChain.KeyPurpose#RECEIVE_FUNDS}, the returned key is suitable for being put into a receive
     ; coins wizard type UI.  You should use this when the user is definitely going to hand this key out to someone who
     ; wishes to send money.
     ; <p>This method is not supposed to be used for married keychains and will throw UnsupportedOperationException if
     ; the active chain is married.
     ; For married keychains use {@link #freshAddress(KeyChain.KeyPurpose)} to get a proper P2SH address.</p>
     ;;
    #_public
    (§ method #_"DeterministicKey" (§ fn freshKey) [#_"KeyChain.KeyPurpose" (§ name purpose)])
    (§ block
        (§ return (§ expr freshKeys(§ pars purpose, 1).get(§ pars 0)))
    )

    ;;;
     ; Returns a key/s that have not been returned by this method before (fresh).  You can think of this as being newly
     ; created key/s, although the notion of "create" is not really valid for a {@link DeterministicKeyChain}.  When the
     ; parameter is {@link KeyChain.KeyPurpose#RECEIVE_FUNDS}, the returned key is suitable for being put into a receive
     ; coins wizard type UI.  You should use this when the user is definitely going to hand this key out to someone who
     ; wishes to send money.
     ; <p>This method is not supposed to be used for married keychains and will throw UnsupportedOperationException if
     ; the active chain is married.
     ; For married keychains use {@link #freshAddress(KeyChain.KeyPurpose)} to get a proper P2SH address.</p>
     ;;
    #_public
    (§ method #_"List<DeterministicKey>" (§ fn freshKeys) [#_"KeyChain.KeyPurpose" (§ name purpose), #_"int" (§ name numberOfKeys)])
    (§ block
        (§ var #_"DeterministicKeyChain" (§ name chain) (§ expr getActiveKeyChain(§ pars )))
        (§ if (§ expr chain.isMarried(§ pars )))
        (§ block
            (§ throw (§ new #_"UnsupportedOperationException" (§ pars "Key is not suitable to receive coins for married keychains. Use freshAddress to get P2SH address instead.")))
        )

        (§ return (§ expr chain.getKeys(§ pars purpose, numberOfKeys))) ;; Always returns the next key along the key chain.
    )

    ;;;
     ; Returns address for a {@link #freshKey(KeyChain.KeyPurpose)}.
     ;;
    #_public
    (§ method #_"Address" (§ fn freshAddress) [#_"KeyChain.KeyPurpose" (§ name purpose)])
    (§ block
        (§ var #_"DeterministicKeyChain" (§ name chain) (§ expr getActiveKeyChain(§ pars )))
        (§ if (§ expr chain.isMarried(§ pars )))
        (§ block
            (§ var #_"Script" (§ name outputScript) (§ expr chain.freshOutputScript(§ pars purpose)))
            (§ expr Preconditions/checkState(§ pars outputScript.isPayToScriptHash(§ pars ))) ;; Only handle P2SH for now.
            (§ var #_"Address" (§ name freshAddress) (§ expr Address/fromP2SHScript(§ pars params, outputScript)))
            (§ expr maybeLookaheadScripts(§ pars ))
            (§ expr currentAddresses.put(§ pars purpose, freshAddress))
            (§ return freshAddress)
        )

        (§ return (§ expr freshKey(§ pars purpose).toAddress(§ pars params)))
    )

    ;;; Returns the key chain that's used for generation of fresh/current keys.  This is always the newest HD chain. ;;
    #_public
    #_final
    (§ method #_"DeterministicKeyChain" (§ fn getActiveKeyChain) [])
    (§ block
        (§ if (§ expr chains.isEmpty(§ pars )))
        (§ block
            (§ if (§ expr 0 < basic.numKeys(§ pars )))
            (§ block
                (§ expr log.warn(§ pars "No HD chain present but random keys are: you probably deserialized an old wallet."))
                ;; If called from the wallet (most likely) it'll try to upgrade us, as it knows the rotation time but not the password.
                (§ throw (§ new #_"DeterministicUpgradeRequiredException" (§ pars )))
            )
            ;; Otherwise we have no HD chains and no random keys: we are a new born!  So a random seed is fine.
            (§ expr createAndActivateNewHDChain(§ pars ))
        )
        (§ return (§ expr chains.get(§ pars chains.size(§ pars ) - 1)))
    )

    ;;;
     ; Sets the lookahead buffer size for ALL deterministic key chains as well as for following key chains if any exist.
     ; See {@link DeterministicKeyChain#setLookaheadSize(int)} for more information.
     ;;
    #_public
    (§ method #_"void" (§ fn setLookaheadSize) [#_"int" (§ name lookaheadSize)])
    (§ block
        (§ ass (§ name this.lookaheadSize) lookaheadSize)
        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
        (§ block
            (§ expr chain.setLookaheadSize(§ pars lookaheadSize))
        )
        (§ void nil)
    )

    ;;;
     ; Gets the current lookahead size being used for ALL deterministic key chains.
     ; See {@link DeterministicKeyChain#setLookaheadSize(int)} for more information.
     ;;
    #_public
    (§ method #_"int" (§ fn getLookaheadSize) [])
    (§ block
        (§ return (§ quest (§ expr lookaheadSize == -1) ? (§ dot getActiveKeyChain(§ pars ).getLookaheadSize(§ pars )) :else lookaheadSize))
    )

    ;;;
     ; Sets the lookahead buffer threshold for ALL deterministic key chains.
     ; See {@link DeterministicKeyChain#setLookaheadThreshold(int)} for more information.
     ;;
    #_public
    (§ method #_"void" (§ fn setLookaheadThreshold) [#_"int" (§ name num)])
    (§ block
        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
        (§ block
            (§ expr chain.setLookaheadThreshold(§ pars num))
        )
        (§ void nil)
    )

    ;;;
     ; Gets the current lookahead threshold being used for ALL deterministic key chains.
     ; See {@link DeterministicKeyChain#setLookaheadThreshold(int)} for more information.
     ;;
    #_public
    (§ method #_"int" (§ fn getLookaheadThreshold) [])
    (§ block
        (§ return (§ quest (§ expr lookaheadThreshold == -1) ? (§ dot getActiveKeyChain(§ pars ).getLookaheadThreshold(§ pars )) :else lookaheadThreshold))
    )

    ;;; Imports the given keys into the basic chain, creating it if necessary. ;;
    #_public
    (§ method #_"int" (§ fn importKeys) [#_"List<ECKey>" (§ name keys)])
    (§ block
        (§ return (§ expr basic.importKeys(§ pars keys)))
    )

    ;;; Imports the given keys into the basic chain, creating it if necessary. ;;
    #_public
    (§ method #_"int" (§ fn importKeys) [#_"ECKey..." (§ name keys)])
    (§ block
        (§ return (§ expr importKeys(§ pars ImmutableList/copyOf(§ pars keys))))
    )

    #_public
    (§ method #_"boolean" (§ fn checkPassword) [#_"CharSequence" (§ name password)])
    (§ block
        (§ expr Preconditions/checkState(§ pars keyCrypter != nil, "Not encrypted"))

        (§ return (§ expr checkAESKey(§ pars keyCrypter.deriveKey(§ pars password))))
    )

    #_public
    (§ method #_"boolean" (§ fn checkAESKey) [#_"KeyParameter" (§ name aesKey)])
    (§ block
        (§ expr Preconditions/checkState(§ pars keyCrypter != nil, "Not encrypted"))

        (§ return (§ quest (§ expr 0 < basic.numKeys(§ pars )) ? (§ expr basic.checkAESKey(§ pars aesKey)) :else (§ expr getActiveKeyChain(§ pars ).checkAESKey(§ pars aesKey))))
    )

    ;;; Imports the given unencrypted keys into the basic chain, encrypting them along the way with the given key. ;;
    #_public
    (§ method #_"int" (§ fn importKeysAndEncrypt) [#_final #_"List<ECKey>" (§ name keys), #_"KeyParameter" (§ name aesKey)])
    (§ block
        ;; TODO: Firstly check if the aes key can decrypt any of the existing keys successfully.
        (§ expr Preconditions/checkState(§ pars keyCrypter != nil, "Not encrypted"))

        (§ var #_"LinkedList<ECKey>" (§ name encryptedKeys) (§ expr Lists/newLinkedList(§ pars )))
        (§ for (§ var #_"ECKey" (§ name key)) :for keys)
        (§ block
            (§ if (§ expr key.isEncrypted(§ pars )))
            (§ block
                (§ throw (§ new #_"IllegalArgumentException" (§ pars "Cannot provide already encrypted keys")))
            )

            (§ expr encryptedKeys.add(§ pars key.encrypt(§ pars keyCrypter, aesKey)))
        )
        (§ return (§ expr importKeys(§ pars encryptedKeys)))
    )

    #_override
    #_nilable
    #_public
    (§ method #_"RedeemData" (§ fn findRedeemDataFromScriptHash) [#_"byte[]" (§ name scriptHash)])
    (§ block
        ;; Iterate in reverse order, since the active keychain is the one most likely to have the hit.
        (§ for (§ var #_"Iterator<DeterministicKeyChain>" (§ name iter) (§ expr chains.descendingIterator(§ pars ))) :for (§ expr iter.hasNext(§ pars )) :for (§ expr ))
        (§ block
            (§ var #_"DeterministicKeyChain" (§ name chain) (§ expr iter.next(§ pars )))
            (§ var #_"RedeemData" (§ name redeemData) (§ expr chain.findRedeemDataByScriptHash(§ pars ByteString/copyFrom(§ pars scriptHash))))
            (§ if (§ expr redeemData != nil))
            (§ block
                (§ return redeemData)
            )
        )
        (§ return nil)
    )

    #_public
    (§ method #_"void" (§ fn markP2SHAddressAsUsed) [#_"Address" (§ name address)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars address.isP2SHAddress(§ pars )))

        (§ var #_"RedeemData" (§ name data) (§ expr findRedeemDataFromScriptHash(§ pars address.getHash160(§ pars ))))
        (§ if (§ expr data == nil))
        (§ block
            (§ return nil) ;; Not our P2SH address.
        )

        (§ for (§ var #_"ECKey" (§ name key)) :for (§ expr data.keys))
        (§ block
            (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
            (§ block
                (§ var #_"DeterministicKey" (§ name k) (§ expr chain.findKeyFromPubKey(§ pars key.getPubKey(§ pars ))))
                (§ if (§ expr k != nil))
                (§ block
                    (§ expr chain.markKeyAsUsed(§ pars k))
                    (§ expr maybeMarkCurrentAddressAsUsed(§ pars address))
                )
            )
        )
        (§ void nil)
    )

    #_nilable
    #_override
    #_public
    (§ method #_"ECKey" (§ fn findKeyFromPubHash) [#_"byte[]" (§ name pubkeyHash)])
    (§ block
        (§ var #_"ECKey" (§ name result) (§ expr basic.findKeyFromPubHash(§ pars pubkeyHash)))
        (§ if (§ expr result != nil))
        (§ block
            (§ return result)
        )

        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
        (§ block
            (§ ass (§ name result) (§ expr chain.findKeyFromPubHash(§ pars pubkeyHash)))
            (§ if (§ expr result != nil))
            (§ block
                (§ return result)
            )
        )

        (§ return nil)
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkeyHash.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_public
    (§ method #_"void" (§ fn markPubKeyHashAsUsed) [#_"byte[]" (§ name pubkeyHash)])
    (§ block
        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
        (§ block
            (§ var #_"DeterministicKey" (§ name key) (§ expr chain.markPubHashAsUsed(§ pars pubkeyHash)))
            (§ if (§ expr key != nil))
            (§ block
                (§ expr maybeMarkCurrentKeyAsUsed(§ pars key))
                (§ return nil)
            )
        )
        (§ void nil)
    )

    ;;; If the given P2SH address is "current", advance it to a new one. ;;
    #_private
    (§ method #_"void" (§ fn maybeMarkCurrentAddressAsUsed) [#_"Address" (§ name address)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars address.isP2SHAddress(§ pars )))

        (§ for (§ var #_"Map.Entry<KeyChain.KeyPurpose, Address>" (§ name entry)) :for (§ expr currentAddresses.entrySet(§ pars )))
        (§ block
            (§ if (§ expr entry.getValue(§ pars ) != nil && entry.getValue(§ pars ).equals(§ pars address)))
            (§ block
                (§ expr log.info(§ pars "Marking P2SH address as used: {}", address))
                (§ expr currentAddresses.put(§ pars entry.getKey(§ pars ), freshAddress(§ pars entry.getKey(§ pars ))))
                (§ return nil)
            )
        )
        (§ void nil)
    )

    ;;; If the given key is "current", advance the current key to a new one. ;;
    #_private
    (§ method #_"void" (§ fn maybeMarkCurrentKeyAsUsed) [#_"DeterministicKey" (§ name key)])
    (§ block
        ;; It's OK for currentKeys to be empty here: it means we're a married wallet and the key may be a part of a rotating chain.
        (§ for (§ var #_"Map.Entry<KeyChain.KeyPurpose, DeterministicKey>" (§ name entry)) :for (§ expr currentKeys.entrySet(§ pars )))
        (§ block
            (§ if (§ expr entry.getValue(§ pars ) != nil && entry.getValue(§ pars ).equals(§ pars key)))
            (§ block
                (§ expr log.info(§ pars "Marking key as used: {}", key))
                (§ expr currentKeys.put(§ pars entry.getKey(§ pars ), freshKey(§ pars entry.getKey(§ pars ))))
                (§ return nil)
            )
        )
        (§ void nil)
    )

    #_public
    (§ method #_"boolean" (§ fn hasKey) [#_"ECKey" (§ name key)])
    (§ block
        (§ if (§ expr basic.hasKey(§ pars key)))
        (§ block
            (§ return true)
        )
        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
        (§ block
            (§ if (§ expr chain.hasKey(§ pars key)))
            (§ block
                (§ return true)
            )
        )
        (§ return false)
    )

    #_nilable
    #_override
    #_public
    (§ method #_"ECKey" (§ fn findKeyFromPubKey) [#_"byte[]" (§ name pubkey)])
    (§ block
        (§ var #_"ECKey" (§ name result) (§ expr basic.findKeyFromPubKey(§ pars pubkey)))
        (§ if (§ expr result != nil))
        (§ block
            (§ return result)
        )

        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
        (§ block
            (§ ass (§ name result) (§ expr chain.findKeyFromPubKey(§ pars pubkey)))
            (§ if (§ expr result != nil))
            (§ block
                (§ return result)
            )
        )

        (§ return nil)
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkey.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_public
    (§ method #_"void" (§ fn markPubKeyAsUsed) [#_"byte[]" (§ name pubkey)])
    (§ block
        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
        (§ block
            (§ var #_"DeterministicKey" (§ name key) (§ expr chain.markPubKeyAsUsed(§ pars pubkey)))
            (§ if (§ expr key != nil))
            (§ block
                (§ expr maybeMarkCurrentKeyAsUsed(§ pars key))
                (§ return nil)
            )
        )
        (§ void nil)
    )

    ;;; Returns the number of keys managed by this group, including the lookahead buffers. ;;
    #_public
    (§ method #_"int" (§ fn numKeys) [])
    (§ block
        (§ var #_"int" (§ name result) (§ expr basic.numKeys(§ pars )))
        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
        (§ block
            (§ ass (§ name result) (§ expr result + chain.numKeys(§ pars )))
        )
        (§ return result)
    )

    ;;;
     ; Removes a key that was imported into the basic key chain.  You cannot remove deterministic keys.
     ; @throws java.lang.IllegalArgumentException if the key is deterministic.
     ;;
    #_public
    (§ method #_"boolean" (§ fn removeImportedKey) [#_"ECKey" (§ name key)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars key))
        (§ expr Preconditions/checkArgument(§ pars (§ not (§ insta key #_"DeterministicKey"))))

        (§ return (§ expr basic.removeKey(§ pars key)))
    )

    ;;;
     ; Whether the active keychain is married.  A keychain is married when it vends P2SH addresses
     ; from multiple keychains in a multisig relationship.
     ; @see org.bitcoinj.wallet.MarriedKeyChain
     ;;
    #_public
    #_final
    (§ method #_"boolean" (§ fn isMarried) [])
    (§ block
        (§ return (§ expr (§ not chains.isEmpty(§ pars )) && getActiveKeyChain(§ pars ).isMarried(§ pars )))
    )

    ;;;
     ; Encrypt the keys in the group using the KeyCrypter and the AES key.
     ; A good default KeyCrypter to use is {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @throws org.bitcoinj.crypto.KeyCrypterException if the wallet encryption fails for some reason,
     ;         leaving the group unchanged.
     ; @throws DeterministicUpgradeRequiredException if there are random keys but no HD chain.
     ;;
    #_public
    (§ method #_"void" (§ fn encrypt) [#_"KeyCrypter" (§ name keyCrypter), #_"KeyParameter" (§ name aesKey)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars keyCrypter))
        (§ expr Preconditions/checkNotNull(§ pars aesKey))

        ;; This code must be exception safe.
        (§ var #_"BasicKeyChain" (§ name newBasic) (§ expr basic.toEncrypted(§ pars keyCrypter, aesKey)))
        (§ var #_"List<DeterministicKeyChain>" (§ name newChains) (§ new #_"ArrayList<>" (§ pars chains.size(§ pars ))))
        (§ if (§ expr chains.isEmpty(§ pars ) && basic.numKeys(§ pars ) == 0))
        (§ block
            ;; No HD chains and no random keys: encrypting an entirely empty keychain group.
            ;; But we can't do that, we must have something to encrypt: so instantiate a new HD chain here.
            (§ expr createAndActivateNewHDChain(§ pars ))
        )
        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
        (§ block
            (§ expr newChains.add(§ pars chain.toEncrypted(§ pars keyCrypter, aesKey)))
        )
        (§ ass (§ name this.keyCrypter) keyCrypter)
        (§ ass (§ name basic) newBasic)
        (§ expr chains.clear(§ pars ))
        (§ expr chains.addAll(§ pars newChains))
        (§ void nil)
    )

    ;;;
     ; Decrypt the keys in the group using the previously given key crypter and the AES key.
     ; A good default KeyCrypter to use is {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @throws org.bitcoinj.crypto.KeyCrypterException if the wallet decryption fails for some reason, leaving the group unchanged.
     ;;
    #_public
    (§ method #_"void" (§ fn decrypt) [#_"KeyParameter" (§ name aesKey)])
    (§ block
        ;; This code must be exception safe.
        (§ expr Preconditions/checkNotNull(§ pars aesKey))

        (§ var #_"BasicKeyChain" (§ name newBasic) (§ expr basic.toDecrypted(§ pars aesKey)))
        (§ var #_"List<DeterministicKeyChain>" (§ name newChains) (§ new #_"ArrayList<>" (§ pars chains.size(§ pars ))))
        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
        (§ block
            (§ expr newChains.add(§ pars chain.toDecrypted(§ pars aesKey)))
        )

        (§ ass (§ name this.keyCrypter) nil)
        (§ ass (§ name basic) newBasic)
        (§ expr chains.clear(§ pars ))
        (§ expr chains.addAll(§ pars newChains))
        (§ void nil)
    )

    ;;; Returns true if the group is encrypted. ;;
    #_public
    (§ method #_"boolean" (§ fn isEncrypted) [])
    (§ block
        (§ return (§ expr keyCrypter != nil))
    )

    ;;;
     ; Returns whether this chain has only watching keys (unencrypted keys with no private part).
     ; Mixed chains are forbidden.
     ;
     ; @throws IllegalStateException if there are no keys, or if there is a mix between watching and non-watching keys.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isWatching) [])
    (§ block
        (§ var #_"BasicKeyChain.State" (§ name activeState) (§ expr BasicKeyChain/State/EMPTY))
        (§ if (§ expr (§ not chains.isEmpty(§ pars ))))
        (§ block
            (§ ass (§ name activeState) (§ quest (§ dot getActiveKeyChain(§ pars ).isWatching(§ pars )) ? (§ expr BasicKeyChain/State/WATCHING) :else (§ expr BasicKeyChain/State/REGULAR)))
        )

        (§ var #_"BasicKeyChain.State" (§ name basicState) (§ expr basic.isWatching(§ pars )))
        (§ if (§ expr basicState == BasicKeyChain/State/EMPTY))
        (§ block
            (§ if (§ expr activeState == BasicKeyChain/State/EMPTY))
            (§ block
                (§ throw (§ new #_"IllegalStateException" (§ pars "Empty key chain group: cannot answer isWatching() query")))
            )

            (§ return (§ expr activeState == BasicKeyChain/State/WATCHING))
        )

        (§ if (§ expr activeState == BasicKeyChain/State/EMPTY))
        (§ block
            (§ return (§ expr basicState == BasicKeyChain/State/WATCHING))
        )

        (§ if (§ expr activeState != basicState))
        (§ block
            (§ throw (§ new #_"IllegalStateException" (§ pars "Mix of watching and non-watching keys in wallet")))
        )

        (§ return (§ expr activeState == BasicKeyChain/State/WATCHING))
    )

    ;;; Returns the key crypter or null if the group is not encrypted. ;;
    #_nilable
    #_public
    (§ method #_"KeyCrypter" (§ fn getKeyCrypter) [])
    (§ block
        (§ return keyCrypter)
    )

    ;;;
     ; Returns a list of the non-deterministic keys that have been imported into the wallet, or the empty list if none.
     ;;
    #_public
    (§ method #_"List<ECKey>" (§ fn getImportedKeys) [])
    (§ block
        (§ return (§ expr basic.getKeys(§ pars )))
    )

    #_public
    (§ method #_"long" (§ fn getEarliestKeyCreationTime) [])
    (§ block
        (§ var #_"long" (§ name time) (§ expr basic.getEarliestKeyCreationTime(§ pars ))) ;; Long.MAX_VALUE if empty.
        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
        (§ block
            (§ ass (§ name time) (§ expr Math/min(§ pars time, chain.getEarliestKeyCreationTime(§ pars ))))
        )
        (§ return time)
    )

    #_public
    (§ method #_"int" (§ fn getBloomFilterElementCount) [])
    (§ block
        (§ var #_"int" (§ name result) (§ expr basic.numBloomFilterEntries(§ pars )))
        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
        (§ block
            (§ ass (§ name result) (§ expr result + chain.numBloomFilterEntries(§ pars )))
        )
        (§ return result)
    )

    #_public
    (§ method #_"BloomFilter" (§ fn getBloomFilter) [#_"int" (§ name size), #_"double" (§ name falsePositiveRate), #_"long" (§ name nTweak)])
    (§ block
        (§ var #_"BloomFilter" (§ name filter) (§ new #_"BloomFilter" (§ pars size, falsePositiveRate, nTweak)))
        (§ if (§ expr 0 < basic.numKeys(§ pars )))
        (§ block
            (§ expr filter.merge(§ pars basic.getFilter(§ pars size, falsePositiveRate, nTweak)))
        )

        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
        (§ block
            (§ expr filter.merge(§ pars chain.getFilter(§ pars size, falsePositiveRate, nTweak)))
        )
        (§ return filter)
    )

    #_private
    (§ method #_"Script" (§ fn makeP2SHOutputScript) [#_"DeterministicKey" (§ name followedKey), #_"DeterministicKeyChain" (§ name chain)])
    (§ block
        (§ return (§ expr ScriptBuilder/createP2SHOutputScript(§ pars chain.getRedeemData(§ pars followedKey).redeemScript)))
    )

    ;;; Adds a listener for events that are run when keys are added, on the user thread. ;;
    #_public
    (§ method #_"void" (§ fn addEventListener) [#_"KeyChainEventListener" (§ name listener)])
    (§ block
        (§ expr addEventListener(§ pars listener, Threading/USER_THREAD))
        (§ void nil)
    )

    ;;; Adds a listener for events that are run when keys are added, on the given executor. ;;
    #_public
    (§ method #_"void" (§ fn addEventListener) [#_"KeyChainEventListener" (§ name listener), #_"Executor" (§ name executor)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars listener))
        (§ expr Preconditions/checkNotNull(§ pars executor))

        (§ expr basic.addEventListener(§ pars listener, executor))
        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
        (§ block
            (§ expr chain.addEventListener(§ pars listener, executor))
        )
        (§ void nil)
    )

    ;;; Removes a listener for events that are run when keys are added. ;;
    #_public
    (§ method #_"boolean" (§ fn removeEventListener) [#_"KeyChainEventListener" (§ name listener)])
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars listener))

        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
        (§ block
            (§ expr chain.removeEventListener(§ pars listener))
        )
        (§ return (§ expr basic.removeEventListener(§ pars listener)))
    )

    ;;; Returns a list of key protobufs obtained by merging the chains. ;;
    #_public
    (§ method #_"List<Protos.Key>" (§ fn serializeToProtobuf) [])
    (§ block
        (§ var #_"List<Protos.Key>" (§ name result) (§ quest (§ expr basic != nil) ? (§ expr basic.serializeToProtobuf(§ pars )) :else (§ expr Lists/newArrayList(§ pars ))))

        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
        (§ block
            (§ var #_"List<Protos.Key>" (§ name protos) (§ expr chain.serializeToProtobuf(§ pars )))
            (§ expr result.addAll(§ pars protos))
        )
        (§ return result)
    )

    #_static
    (§ method #_"KeyChainGroup" (§ fn fromProtobufUnencrypted) [#_"NetworkParameters" (§ name params), #_"List<Protos.Key>" (§ name keys)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        (§ return (§ expr fromProtobufUnencrypted(§ pars params, keys, new DefaultKeyChainFactory(§ pars ))))
    )

    #_public
    #_static
    (§ method #_"KeyChainGroup" (§ fn fromProtobufUnencrypted) [#_"NetworkParameters" (§ name params), #_"List<Protos.Key>" (§ name keys), #_"KeyChainFactory" (§ name factory)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        (§ var #_"BasicKeyChain" (§ name basicKeyChain) (§ expr BasicKeyChain/fromProtobufUnencrypted(§ pars keys)))
        (§ var #_"List<DeterministicKeyChain>" (§ name chains) (§ expr DeterministicKeyChain/fromProtobuf(§ pars keys, nil, factory)))
        (§ var #_"EnumMap<KeyChain.KeyPurpose, DeterministicKey>" (§ name currentKeys) nil)
        (§ if (§ expr (§ not chains.isEmpty(§ pars ))))
        (§ block
            (§ ass (§ name currentKeys) (§ expr createCurrentKeysMap(§ pars chains)))
        )
        (§ expr extractFollowingKeychains(§ pars chains))
        (§ return (§ new #_"KeyChainGroup" (§ pars params, basicKeyChain, chains, currentKeys, nil)))
    )

    #_static
    (§ method #_"KeyChainGroup" (§ fn fromProtobufEncrypted) [#_"NetworkParameters" (§ name params), #_"List<Protos.Key>" (§ name keys), #_"KeyCrypter" (§ name crypter)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        (§ return (§ expr fromProtobufEncrypted(§ pars params, keys, crypter, new DefaultKeyChainFactory(§ pars ))))
    )

    #_public
    #_static
    (§ method #_"KeyChainGroup" (§ fn fromProtobufEncrypted) [#_"NetworkParameters" (§ name params), #_"List<Protos.Key>" (§ name keys), #_"KeyCrypter" (§ name crypter), #_"KeyChainFactory" (§ name factory)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        (§ expr Preconditions/checkNotNull(§ pars crypter))

        (§ var #_"BasicKeyChain" (§ name basicKeyChain) (§ expr BasicKeyChain/fromProtobufEncrypted(§ pars keys, crypter)))
        (§ var #_"List<DeterministicKeyChain>" (§ name chains) (§ expr DeterministicKeyChain/fromProtobuf(§ pars keys, crypter, factory)))
        (§ var #_"EnumMap<KeyChain.KeyPurpose, DeterministicKey>" (§ name currentKeys) nil)
        (§ if (§ expr (§ not chains.isEmpty(§ pars ))))
        (§ block
            (§ ass (§ name currentKeys) (§ expr createCurrentKeysMap(§ pars chains)))
        )
        (§ expr extractFollowingKeychains(§ pars chains))
        (§ return (§ new #_"KeyChainGroup" (§ pars params, basicKeyChain, chains, currentKeys, crypter)))
    )

    ;;;
     ; If the key chain contains only random keys and no deterministic key chains, this method will create a chain
     ; based on the oldest non-rotating private key (i.e. the seed is derived from the old wallet).
     ;
     ; @param keyRotationTimeSecs If non-zero, UNIX time for which keys created before this are assumed to be
     ;                            compromised or weak, those keys will not be used for deterministic upgrade.
     ; @param aesKey If non-null, the encryption key the keychain is encrypted under.  If the keychain is encrypted
     ;               and this is not supplied, an exception is thrown letting you know you should ask the user for
     ;               their password, turn it into a key, and then try again.
     ; @throws java.lang.IllegalStateException if there is already a deterministic key chain present or if there are
     ;                                         no random keys (i.e. this is not an upgrade scenario), or if aesKey is
     ;                                         provided but the wallet is not encrypted.
     ; @throws java.lang.IllegalArgumentException if the rotation time specified excludes all keys.
     ; @throws DeterministicUpgradeRequiresPassword if the key chain group is encrypted
     ;         and you should provide the users encryption key.
     ; @return the DeterministicKeyChain that was created by the upgrade.
     ;;
    #_public
    (§ method #_"DeterministicKeyChain" (§ fn upgradeToDeterministic) [#_"long" (§ name keyRotationTimeSecs), #_nilable #_"KeyParameter" (§ name aesKey)])
        (§ throws #_"DeterministicUpgradeRequiresPassword", #_"AllRandomKeysRotating")
    (§ block
        (§ expr Preconditions/checkState(§ pars 0 < basic.numKeys(§ pars )))
        (§ expr Preconditions/checkArgument(§ pars 0 <= keyRotationTimeSecs))

        ;; Subtract one because the key rotation time might have been set to the creation time of the first known
        ;; good key, in which case, that's the one we want to find.
        (§ var #_"ECKey" (§ name keyToUse) (§ expr basic.findOldestKeyAfter(§ pars keyRotationTimeSecs - 1)))
        (§ if (§ expr keyToUse == nil))
        (§ block
            (§ throw (§ new #_"AllRandomKeysRotating" (§ pars )))
        )

        (§ if (§ expr keyToUse.isEncrypted(§ pars )))
        (§ block
            (§ if (§ expr aesKey == nil))
            (§ block
                ;; We can't auto upgrade because we don't know the users password at this point.  We throw an exception
                ;; so the calling code knows to abort the load and ask the user for their password, they can then try
                ;; loading the wallet again passing in the AES key.
                ;;
                ;; There are a few different approaches we could have used here, but they all suck.  The most obvious
                ;; is to try and be as lazy as possible, running in the old random-wallet mode until the user enters
                ;; their password for some other reason and doing the upgrade then.  But this could result in strange
                ;; and unexpected UI flows for the user, as well as complicating the job of wallet developers who then
                ;; have to support both "old" and "new" UI modes simultaneously, switching them on the fly.  Given that
                ;; this is a one-off transition, it seems more reasonable to just ask the user for their password
                ;; on startup, and then the wallet app can have all the widgets for accessing seed words etc active
                ;; all the time.
                (§ throw (§ new #_"DeterministicUpgradeRequiresPassword" (§ pars )))
            )
            (§ ass (§ name keyToUse) (§ expr keyToUse.decrypt(§ pars aesKey)))
        )
        (§ elseif (§ expr aesKey != nil))
        (§ block
            (§ throw (§ new #_"IllegalStateException" (§ pars "AES Key was provided but wallet is not encrypted.")))
        )

        (§ if (§ expr chains.isEmpty(§ pars )))
        (§ block
            (§ expr log.info(§ pars "Auto-upgrading pre-HD wallet to HD!"))
        )
        (§ else )
        (§ block
            (§ expr log.info(§ pars "Wallet with existing HD chain is being re-upgraded due to change in key rotation time."))
        )

        (§ expr log.info(§ pars "Instantiating new HD chain using oldest non-rotating private key (address: {})", keyToUse.toAddress(§ pars params)))
        (§ var #_"byte[]" (§ name entropy) (§ expr Preconditions/checkNotNull(§ pars keyToUse.getSecretBytes(§ pars ))))
        ;; Private keys should be at least 128 bits long.
        (§ expr Preconditions/checkState(§ pars DeterministicSeed/DEFAULT_SEED_ENTROPY_BITS / 8 <= entropy.length))
        ;; We reduce the entropy here to 128 bits because people like to write their seeds down on paper,
        ;; and 128 bits should be sufficient forever unless the laws of the universe change or ECC is broken;
        ;; in either case we all have bigger problems.
        (§ ass (§ name entropy) (§ expr Arrays/copyOfRange(§ pars entropy, 0, DeterministicSeed/DEFAULT_SEED_ENTROPY_BITS / 8))) ;; Final argument is exclusive range.
        (§ expr Preconditions/checkState(§ pars entropy.length == DeterministicSeed/DEFAULT_SEED_ENTROPY_BITS / 8))
        (§ var #_"String" (§ name passphrase) (§ expr "")) ;; FIXME allow non-empty passphrase
        (§ var #_"DeterministicKeyChain" (§ name chain) (§ new #_"DeterministicKeyChain" (§ pars entropy, passphrase, keyToUse.getCreationTimeSeconds(§ pars ))))
        (§ if (§ expr aesKey != nil))
        (§ block
            (§ ass (§ name chain) (§ expr chain.toEncrypted(§ pars Preconditions/checkNotNull(§ pars basic.getKeyCrypter(§ pars )), aesKey)))
        )
        (§ expr chains.add(§ pars chain))
        (§ return chain)
    )

    ;;; Returns true if the group contains random keys but no HD chains. ;;
    #_public
    (§ method #_"boolean" (§ fn isDeterministicUpgradeRequired) [])
    (§ block
        (§ return (§ expr 0 < basic.numKeys(§ pars ) && chains.isEmpty(§ pars )))
    )

    #_private
    #_static
    (§ method #_"EnumMap<KeyChain.KeyPurpose, DeterministicKey>" (§ fn createCurrentKeysMap) [#_"List<DeterministicKeyChain>" (§ name chains)])
    (§ block
        (§ var #_"DeterministicKeyChain" (§ name activeChain) (§ expr chains.get(§ pars chains.size(§ pars ) - 1)))

        (§ var #_"EnumMap<KeyChain.KeyPurpose, DeterministicKey>" (§ name currentKeys) (§ new #_"EnumMap<>" (§ pars (§ klass #_"KeyChain.KeyPurpose"))))

        ;; Assuming that only RECEIVE and CHANGE keys are being used at the moment, we will treat the latest issued
        ;; external key as current RECEIVE key and latest issued internal key as CHANGE key.  This should be changed
        ;; as soon as other kinds of KeyPurpose are introduced.
        (§ if (§ expr 0 < activeChain.getIssuedExternalKeys(§ pars )))
        (§ block
            (§ var #_"DeterministicKey" (§ name currentExternalKey) (§ expr activeChain.getKeyByPath(§ pars HDUtils/append(§ pars HDUtils/concat(§ pars activeChain.getAccountPath(§ pars ), DeterministicKeyChain/EXTERNAL_SUBPATH), new ChildNumber(§ pars activeChain.getIssuedExternalKeys(§ pars ) - 1)))))
            (§ expr currentKeys.put(§ pars KeyChain/KeyPurpose/RECEIVE_FUNDS, currentExternalKey))
        )

        (§ if (§ expr 0 < activeChain.getIssuedInternalKeys(§ pars )))
        (§ block
            (§ var #_"DeterministicKey" (§ name currentInternalKey) (§ expr activeChain.getKeyByPath(§ pars HDUtils/append(§ pars HDUtils/concat(§ pars activeChain.getAccountPath(§ pars ), DeterministicKeyChain/INTERNAL_SUBPATH), new ChildNumber(§ pars activeChain.getIssuedInternalKeys(§ pars ) - 1)))))
            (§ expr currentKeys.put(§ pars KeyChain/KeyPurpose/CHANGE, currentInternalKey))
        )

        (§ return currentKeys)
    )

    #_private
    #_static
    (§ method #_"void" (§ fn extractFollowingKeychains) [#_"List<DeterministicKeyChain>" (§ name chains)])
    (§ block
        ;; Look for following key chains and map them to the watch keys of followed keychains.
        (§ var #_"List<DeterministicKeyChain>" (§ name followingChains) (§ expr Lists/newArrayList(§ pars )))
        (§ for (§ var #_"Iterator<DeterministicKeyChain>" (§ name it) (§ expr chains.iterator(§ pars ))) :for (§ expr it.hasNext(§ pars )) :for (§ expr ))
        (§ block
            (§ var #_"DeterministicKeyChain" (§ name chain) (§ expr it.next(§ pars )))
            (§ if (§ expr chain.isFollowing(§ pars )))
            (§ block
                (§ expr followingChains.add(§ pars chain))
                (§ expr it.remove(§ pars ))
            )
            (§ elseif (§ expr (§ not followingChains.isEmpty(§ pars ))))
            (§ block
                (§ if (§ expr (§ not (§ insta chain #_"MarriedKeyChain"))))
                (§ block
                    (§ throw (§ new #_"IllegalStateException" (§ pars )))
                )

                (§ expr (§ expr (§ cast #_"MarriedKeyChain" chain)).setFollowingKeyChains(§ pars followingChains))
                (§ ass (§ name followingChains) (§ expr Lists/newArrayList(§ pars )))
            )
        )
        (§ void nil)
    )

    #_public
    (§ method #_"String" (§ fn toString) [#_"boolean" (§ name includePrivateKeys)])
    (§ block
        #_final
        (§ var #_"StringBuilder" (§ name sb) (§ new #_"StringBuilder" (§ pars )))
        (§ if (§ expr basic != nil))
        (§ block
            (§ var #_"List<ECKey>" (§ name keys) (§ expr basic.getKeys(§ pars )))
            (§ expr Collections/sort(§ pars keys, ECKey/AGE_COMPARATOR))
            (§ for (§ var #_"ECKey" (§ name key)) :for keys)
            (§ block
                (§ expr key.formatKeyWithAddress(§ pars includePrivateKeys, sb, params))
            )
        )
        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
        (§ block
            (§ expr sb.append(§ pars chain.toString(§ pars includePrivateKeys, params)).append(§ pars "\n"))
        )
        (§ return (§ expr sb.toString(§ pars )))
    )

    ;;; Returns a copy of the current list of chains. ;;
    #_public
    (§ method #_"List<DeterministicKeyChain>" (§ fn getDeterministicKeyChains) [])
    (§ block
        (§ return (§ new #_"ArrayList<>" (§ pars chains)))
    )

    ;;;
     ; Returns a counter that increases (by an arbitrary amount) each time new keys have been calculated
     ; due to lookahead and thus the Bloom filter that was previously calculated has become stale.
     ;;
    #_public
    (§ method #_"int" (§ fn getCombinedKeyLookaheadEpochs) [])
    (§ block
        (§ var #_"int" (§ name epoch) 0)
        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for chains)
        (§ block
            (§ ass (§ name epoch) (§ expr epoch + chain.getKeyLookaheadEpoch(§ pars )))
        )
        (§ return epoch)
    )
)

#_(ns org.bitcoinj.wallet #_"KeyTimeCoinSelector"
    (:import [java.util LinkedList List])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.script Script]))

;;;
 ; A coin selector that takes all coins assigned to keys created before the given timestamp.
 ; Used as part of the implementation of {@link Wallet#setKeyRotationTime(java.util.Date)}.
 ;;
#_public
(§ class #_"KeyTimeCoinSelector" (§ implements #_"CoinSelector")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"KeyTimeCoinSelector"))))

    ;;; A number of inputs chosen to avoid hitting {@link org.bitcoinj.core.Transaction#MAX_STANDARD_TX_SIZE}. ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name MAX_SIMULTANEOUS_INPUTS) 600)

    #_private
    #_final
    (§ field #_"long" (§ name unixTimeSeconds))
    #_private
    #_final
    (§ field #_"Wallet" (§ name wallet))
    #_private
    #_final
    (§ field #_"boolean" (§ name ignorePending))

    #_public
    (§ constructor #_"KeyTimeCoinSelector" [#_"Wallet" (§ name wallet), #_"long" (§ name unixTimeSeconds), #_"boolean" (§ name ignorePending)])
    (§ block
        (§ ass (§ name this.unixTimeSeconds) unixTimeSeconds)
        (§ ass (§ name this.wallet) wallet)
        (§ ass (§ name this.ignorePending) ignorePending)
        (§ void this)
    )

    #_override
    #_public
    (§ method #_"CoinSelection" (§ fn select) [#_"Coin" (§ name target), #_"List<TransactionOutput>" (§ name candidates)])
    (§ block
        (§ try )
        (§ block
            (§ var #_"LinkedList<TransactionOutput>" (§ name gathered) (§ expr Lists/newLinkedList(§ pars )))
            (§ var #_"Coin" (§ name valueGathered) (§ expr Coin/ZERO))
            (§ for (§ var #_"TransactionOutput" (§ name output)) :for candidates)
            (§ block
                (§ if (§ expr ignorePending && (§ not isConfirmed(§ pars output))))
                (§ block
                    (§ continue )
                )

                ;; Find the key that controls output, assuming it's a regular pay-to-pubkey or pay-to-address output.
                ;; We ignore any other kind of exotic output on the assumption we can't spend it ourselves.
                #_final
                (§ var #_"Script" (§ name scriptPubKey) (§ expr output.getScriptPubKey(§ pars )))
                (§ var #_"ECKey" (§ name controllingKey))
                (§ if (§ expr scriptPubKey.isSentToRawPubKey(§ pars )))
                (§ block
                    (§ ass (§ name controllingKey) (§ expr wallet.findKeyFromPubKey(§ pars scriptPubKey.getPubKey(§ pars ))))
                )
                (§ elseif (§ expr scriptPubKey.isSentToAddress(§ pars )))
                (§ block
                    (§ ass (§ name controllingKey) (§ expr wallet.findKeyFromPubHash(§ pars scriptPubKey.getPubKeyHash(§ pars ))))
                )
                (§ else )
                (§ block
                    (§ expr log.info(§ pars "Skipping tx output {} because it's not of simple form.", output))
                    (§ continue )
                )

                (§ expr Preconditions/checkNotNull(§ pars controllingKey, "Coin selector given output as candidate for which we lack the key"))
                (§ if (§ expr unixTimeSeconds <= controllingKey.getCreationTimeSeconds(§ pars )))
                (§ block
                    (§ continue )
                )

                ;; It's older than the cutoff time so select.
                (§ ass (§ name valueGathered) (§ expr valueGathered.add(§ pars output.getValue(§ pars ))))
                (§ expr gathered.push(§ pars output))
                (§ if (§ expr MAX_SIMULTANEOUS_INPUTS <= gathered.size(§ pars )))
                (§ block
                    (§ expr log.warn(§ pars "Reached {} inputs, going further would yield a tx that is too large, stopping here.", gathered.size(§ pars )))
                    (§ break )
                )
            )
            (§ return (§ new #_"CoinSelection" (§ pars valueGathered, gathered)))
        )
        (§ catch #_"ScriptException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; We should never have problems understanding scripts in our wallet.
        )
    )

    #_private
    (§ method #_"boolean" (§ fn isConfirmed) [#_"TransactionOutput" (§ name output)])
    (§ block
        (§ return (§ expr output.getParentTransaction(§ pars ).getConfidence(§ pars ).getConfidenceType(§ pars ).equals(§ pars TransactionConfidence/ConfidenceType/BUILDING)))
    )
)

#_(ns org.bitcoinj.wallet #_"MarriedKeyChain"
    (:import [java.security SecureRandom]
             [java.util LinkedHashMap List Map])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect ImmutableList Lists]
             #_static [com.google.common.collect.Lists newArrayList]
             [com.google.protobuf ByteString])
   (:require [org.bitcoinj.core BloomFilter ECKey NetworkParameters Utils]
             [org.bitcoinj.crypto DeterministicKey KeyCrypter]
             [org.bitcoinj.script Script ScriptBuilder]))

;;;
 ; <p>A multi-signature keychain using synchronized HD keys (a.k.a HDM).</p>
 ;
 ; <p>This keychain keeps track of following keychains that follow the account key of this keychain.  You can get P2SH
 ; addresses to receive coins to from this chain.  The threshold - sigsRequiredToSpend specifies how many signatures
 ; required to spend transactions for this married keychain.  This value should not exceed the total number of keys
 ; involved (one followed key plus number of following keys), otherwise IllegalArgumentException will be thrown.</p>
 ;
 ; <p>IMPORTANT: As of Bitcoin Core 0.9 all multisig transactions which require more than 3 public keys are non-standard and
 ; such spends won't be processed by peers with default settings, essentially making such transactions almost nonspendable.</p>
 ;
 ; <p>This method will throw an IllegalStateException, if the keychain is already married or already has leaf keys issued.</p>
 ;;
#_public
(§ class #_"MarriedKeyChain" (§ extends #_"DeterministicKeyChain")
    ;; The map holds P2SH redeem script and corresponding ECKeys issued by this KeyChainGroup (including lookahead)
    ;; mapped to redeem script hashes.
    #_private
    (§ field #_"LinkedHashMap<ByteString, RedeemData>" (§ name marriedKeysRedeemData) (§ new #_"LinkedHashMap<>" (§ pars )))

    #_private
    (§ field #_"List<DeterministicKeyChain>" (§ name followingKeyChains))

    ;;; Builds a {@link MarriedKeyChain}. ;;
    #_public
    #_static
    (§ class #_"Builder<T extends Builder<T>>" (§ extends #_"DeterministicKeyChain.Builder<T>")
        #_private
        (§ field #_"List<DeterministicKey>" (§ name followingKeys))
        #_private
        (§ field #_"int" (§ name threshold))

        #_protected
        (§ constructor #_"Builder" [])
        (§ block
            (§ void this)
        )

        #_public
        (§ method #_"T" (§ fn followingKeys) [#_"List<DeterministicKey>" (§ name followingKeys)])
        (§ block
            (§ ass (§ name this.followingKeys) followingKeys)
            (§ return (§ expr self(§ pars )))
        )

        #_public
        (§ method #_"T" (§ fn followingKeys) [#_"DeterministicKey" (§ name followingKey), #_"DeterministicKey" (§ name ...followingKeys)])
        (§ block
            (§ ass (§ name this.followingKeys) (§ expr Lists/asList(§ pars followingKey, followingKeys)))
            (§ return (§ expr self(§ pars )))
        )

        ;;;
         ; Threshold, or <code>(followingKeys.size() + 1) / 2 + 1)</code> (majority) if unspecified.
         ;
         ; IMPORTANT: As of Bitcoin Core 0.9 all multisig transactions which require more than 3 public keys are non-standard and
         ; such spends won't be processed by peers with default settings, essentially making such transactions almost nonspendable.
         ;;
        #_public
        (§ method #_"T" (§ fn threshold) [#_"int" (§ name threshold)])
        (§ block
            (§ ass (§ name this.threshold) threshold)
            (§ return (§ expr self(§ pars )))
        )

        #_override
        #_public
        (§ method #_"MarriedKeyChain" (§ fn build) [])
        (§ block
            (§ expr Preconditions/checkState(§ pars random != nil || entropy != nil || seed != nil || watchingKey!= nil, "Must provide either entropy or random or seed or watchingKey"))
            (§ expr Preconditions/checkNotNull(§ pars followingKeys, "followingKeys must be provided"))

            (§ var #_"MarriedKeyChain" (§ name chain))
            (§ if (§ expr threshold == 0))
            (§ block
                (§ ass (§ name threshold) (§ expr (§ expr followingKeys.size(§ pars ) + 1) / 2 + 1))
            )

            (§ if (§ expr random != nil))
            (§ block
                (§ ass (§ name chain) (§ new #_"MarriedKeyChain" (§ pars random, bits, getPassphrase(§ pars ), seedCreationTimeSecs)))
            )
            (§ elseif (§ expr entropy != nil))
            (§ block
                (§ ass (§ name chain) (§ new #_"MarriedKeyChain" (§ pars entropy, getPassphrase(§ pars ), seedCreationTimeSecs)))
            )
            (§ elseif (§ expr seed != nil))
            (§ block
                (§ expr seed.setCreationTimeSeconds(§ pars seedCreationTimeSecs))
                (§ ass (§ name chain) (§ new #_"MarriedKeyChain" (§ pars seed)))
            )
            (§ else )
            (§ block
                (§ expr watchingKey.setCreationTimeSeconds(§ pars seedCreationTimeSecs))
                (§ ass (§ name chain) (§ new #_"MarriedKeyChain" (§ pars watchingKey)))
            )

            (§ expr chain.addFollowingAccountKeys(§ pars followingKeys, threshold))
            (§ return chain)
        )
    )

    #_public
    #_static
    (§ method #_"Builder<?>" (§ fn builder) [])
    (§ block
        (§ return (§ new #_"Builder" (§ pars )))
    )

    ;; Protobuf deserialization constructors.
    (§ constructor #_"MarriedKeyChain" [#_"DeterministicKey" (§ name accountKey)])
    (§ block
        (§ super (§ pars accountKey, false))
        (§ void this)
    )

    (§ constructor #_"MarriedKeyChain" [#_"DeterministicSeed" (§ name seed), #_"KeyCrypter" (§ name crypter)])
    (§ block
        (§ super (§ pars seed, crypter))
        (§ void this)
    )

    ;; Builder constructors.
    #_private
    (§ constructor #_"MarriedKeyChain" [#_"SecureRandom" (§ name random), #_"int" (§ name bits), #_"String" (§ name passphrase), #_"long" (§ name seedCreationTimeSecs)])
    (§ block
        (§ super (§ pars random, bits, passphrase, seedCreationTimeSecs))
        (§ void this)
    )

    #_private
    (§ constructor #_"MarriedKeyChain" [#_"byte[]" (§ name entropy), #_"String" (§ name passphrase), #_"long" (§ name seedCreationTimeSecs)])
    (§ block
        (§ super (§ pars entropy, passphrase, seedCreationTimeSecs))
        (§ void this)
    )

    #_private
    (§ constructor #_"MarriedKeyChain" [#_"DeterministicSeed" (§ name seed)])
    (§ block
        (§ super (§ pars seed))
        (§ void this)
    )

    (§ method #_"void" (§ fn setFollowingKeyChains) [#_"List<DeterministicKeyChain>" (§ name followingKeyChains)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars (§ not followingKeyChains.isEmpty(§ pars ))))
        (§ ass (§ name this.followingKeyChains) followingKeyChains)
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"boolean" (§ fn isMarried) [])
    (§ block
        (§ return true)
    )

    ;;; Create a new married key and return the matching output script. ;;
    #_override
    #_public
    (§ method #_"Script" (§ fn freshOutputScript) [#_"KeyPurpose" (§ name purpose)])
    (§ block
        (§ var #_"DeterministicKey" (§ name followedKey) (§ expr getKey(§ pars purpose)))
        (§ var #_"ImmutableList.Builder<ECKey>" (§ name keys) (§ expr ImmutableList.<ECKey>builder(§ pars ).add(§ pars followedKey)))
        (§ for (§ var #_"DeterministicKeyChain" (§ name keyChain)) :for followingKeyChains)
        (§ block
            (§ var #_"DeterministicKey" (§ name followingKey) (§ expr keyChain.getKey(§ pars purpose)))
            (§ expr Preconditions/checkState(§ pars followedKey.getChildNumber(§ pars ).equals(§ pars followingKey.getChildNumber(§ pars )), "Following keychains should be in sync"))
            (§ expr keys.add(§ pars followingKey))
        )
        (§ var #_"List<ECKey>" (§ name marriedKeys) (§ expr keys.build(§ pars )))
        (§ var #_"Script" (§ name redeemScript) (§ expr ScriptBuilder/createRedeemScript(§ pars sigsRequiredToSpend, marriedKeys)))
        (§ return (§ expr ScriptBuilder/createP2SHOutputScript(§ pars redeemScript)))
    )

    #_private
    (§ method #_"List<ECKey>" (§ fn getMarriedKeysWithFollowed) [#_"DeterministicKey" (§ name followedKey)])
    (§ block
        (§ var #_"ImmutableList.Builder<ECKey>" (§ name keys) (§ expr ImmutableList/builder(§ pars )))
        (§ for (§ var #_"DeterministicKeyChain" (§ name keyChain)) :for followingKeyChains)
        (§ block
            (§ expr keyChain.maybeLookAhead(§ pars ))
            (§ expr keys.add(§ pars keyChain.getKeyByPath(§ pars followedKey.getPath(§ pars ))))
        )
        (§ expr keys.add(§ pars followedKey))
        (§ return (§ expr keys.build(§ pars )))
    )

    ;;; Get the redeem data for a key in this married chain. ;;
    #_override
    #_public
    (§ method #_"RedeemData" (§ fn getRedeemData) [#_"DeterministicKey" (§ name followedKey)])
    (§ block
        (§ var #_"List<ECKey>" (§ name marriedKeys) (§ expr getMarriedKeysWithFollowed(§ pars followedKey)))
        (§ var #_"Script" (§ name redeemScript) (§ expr ScriptBuilder/createRedeemScript(§ pars sigsRequiredToSpend, marriedKeys)))
        (§ return (§ expr RedeemData/of(§ pars marriedKeys, redeemScript)))
    )

    #_private
    (§ method #_"void" (§ fn addFollowingAccountKeys) [#_"List<DeterministicKey>" (§ name followingAccountKeys), #_"int" (§ name sigsRequiredToSpend)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars sigsRequiredToSpend <= followingAccountKeys.size(§ pars ) + 1, "Multisig threshold can't exceed total number of keys"))
        (§ expr Preconditions/checkState(§ pars numLeafKeysIssued(§ pars ) == 0, "Active keychain already has keys in use"))
        (§ expr Preconditions/checkState(§ pars followingKeyChains == nil))

        (§ var #_"List<DeterministicKeyChain>" (§ name followingKeyChains) (§ expr Lists/newArrayList(§ pars )))

        (§ for (§ var #_"DeterministicKey" (§ name key)) :for followingAccountKeys)
        (§ block
            (§ expr Preconditions/checkArgument(§ pars key.getPath(§ pars ).size(§ pars ) == getAccountPath(§ pars ).size(§ pars ), "Following keys have to be account keys"))

            (§ var #_"DeterministicKeyChain" (§ name chain) (§ expr DeterministicKeyChain/watchAndFollow(§ pars key)))
            (§ if (§ expr 0 <= lookaheadSize))
            (§ block
                (§ expr chain.setLookaheadSize(§ pars lookaheadSize))
            )
            (§ if (§ expr 0 <= lookaheadThreshold))
            (§ block
                (§ expr chain.setLookaheadThreshold(§ pars lookaheadThreshold))
            )
            (§ expr followingKeyChains.add(§ pars chain))
        )

        (§ ass (§ name this.sigsRequiredToSpend) sigsRequiredToSpend)
        (§ ass (§ name this.followingKeyChains) followingKeyChains)
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn setLookaheadSize) [#_"int" (§ name lookaheadSize)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr super.setLookaheadSize(§ pars lookaheadSize))

            (§ if (§ expr followingKeyChains != nil))
            (§ block
                (§ for (§ var #_"DeterministicKeyChain" (§ name followingChain)) :for followingKeyChains)
                (§ block
                    (§ expr followingChain.setLookaheadSize(§ pars lookaheadSize))
                )
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"List<Protos.Key>" (§ fn serializeToProtobuf) [])
    (§ block
        (§ var #_"List<Protos.Key>" (§ name result) (§ expr newArrayList(§ pars )))
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for followingKeyChains)
            (§ block
                (§ expr result.addAll(§ pars chain.serializeMyselfToProtobuf(§ pars )))
            )
            (§ expr result.addAll(§ pars serializeMyselfToProtobuf(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ return result)
    )

    #_override
    #_protected
    (§ method #_"void" (§ fn formatAddresses) [#_"boolean" (§ name includePrivateKeys), #_"NetworkParameters" (§ name params), #_"StringBuilder" (§ name sb)])
    (§ block
        (§ for (§ var #_"DeterministicKeyChain" (§ name followingChain)) :for followingKeyChains)
        (§ block
            (§ expr sb.append(§ pars "Following chain:  ").append(§ pars followingChain.getWatchingKey(§ pars ).serializePubB58(§ pars params)).append(§ pars "\n"))
        )
        (§ expr sb.append(§ pars "\n"))
        (§ for (§ var #_"RedeemData" (§ name redeemData)) :for (§ expr marriedKeysRedeemData.values(§ pars )))
        (§ block
            (§ expr formatScript(§ pars ScriptBuilder/createP2SHOutputScript(§ pars redeemData.redeemScript), sb, params))
        )
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn formatScript) [#_"Script" (§ name script), #_"StringBuilder" (§ name sb), #_"NetworkParameters" (§ name params)])
    (§ block
        (§ expr sb.append(§ pars "  addr:").append(§ pars script.getToAddress(§ pars params)))
        (§ expr sb.append(§ pars "  hash160:").append(§ pars Utils/HEX.encode(§ pars script.getPubKeyHash(§ pars ))))
        (§ if (§ expr 0 < script.getCreationTimeSeconds(§ pars )))
        (§ block
            (§ expr sb.append(§ pars "  creationTimeSeconds:").append(§ pars script.getCreationTimeSeconds(§ pars )))
        )
        (§ expr sb.append(§ pars "\n"))
        (§ void nil)
    )

    #_override
    #_public
    (§ method #_"void" (§ fn maybeLookAheadScripts) [])
    (§ block
        (§ expr super.maybeLookAheadScripts(§ pars ))

        (§ var #_"int" (§ name numLeafKeys) (§ expr getLeafKeys(§ pars ).size(§ pars )))
        (§ expr Preconditions/checkState(§ pars marriedKeysRedeemData.size(§ pars ) <= numLeafKeys, "Number of scripts is greater than number of leaf keys"))

        (§ if (§ expr marriedKeysRedeemData.size(§ pars ) != numLeafKeys))
        (§ block
            (§ expr maybeLookAhead(§ pars ))
            (§ for (§ var #_"DeterministicKey" (§ name followedKey)) :for (§ expr getLeafKeys(§ pars )))
            (§ block
                (§ var #_"RedeemData" (§ name redeemData) (§ expr getRedeemData(§ pars followedKey)))
                (§ var #_"Script" (§ name scriptPubKey) (§ expr ScriptBuilder/createP2SHOutputScript(§ pars redeemData.redeemScript)))
                (§ expr marriedKeysRedeemData.put(§ pars ByteString/copyFrom(§ pars scriptPubKey.getPubKeyHash(§ pars )), redeemData))
            )
        )
        (§ void nil)
    )

    #_nilable
    #_override
    #_public
    (§ method #_"RedeemData" (§ fn findRedeemDataByScriptHash) [#_"ByteString" (§ name bytes)])
    (§ block
        (§ return (§ expr marriedKeysRedeemData.get(§ pars bytes)))
    )

    #_override
    #_public
    (§ method #_"BloomFilter" (§ fn getFilter) [#_"int" (§ name size), #_"double" (§ name falsePositiveRate), #_"long" (§ name tweak)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ var #_"BloomFilter" (§ name filter))
        (§ try )
        (§ block
            (§ ass (§ name filter) (§ new #_"BloomFilter" (§ pars size, falsePositiveRate, tweak)))
            (§ for (§ var #_"Map.Entry<ByteString, RedeemData>" (§ name entry)) :for (§ expr marriedKeysRedeemData.entrySet(§ pars )))
            (§ block
                (§ expr filter.insert(§ pars entry.getKey(§ pars ).toByteArray(§ pars )))
                (§ expr filter.insert(§ pars entry.getValue(§ pars ).redeemScript.getProgram(§ pars )))
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ return filter)
    )

    #_override
    #_public
    (§ method #_"int" (§ fn numBloomFilterEntries) [])
    (§ block
        (§ expr maybeLookAhead(§ pars ))
        (§ return (§ expr getLeafKeys(§ pars ).size(§ pars ) * 2))
    )
)

#_(ns org.bitcoinj.wallet #_"RedeemData"
    (:import [java.util ArrayList Collections List])
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.core ECKey]
             [org.bitcoinj.script Script]))

;;;
 ; This class aggregates data required to spend transaction output.
 ;
 ; For pay-to-address and pay-to-pubkey transactions it will have only a single key and CHECKSIG program as redeemScript.
 ; For multisignature transactions there will be multiple keys one of which will be a full key and the rest are watch only,
 ; redeem script will be a CHECKMULTISIG program.  Keys will be sorted in the same order they appear in
 ; a program (lexicographical order).
 ;;
#_public
(§ class #_"RedeemData"
    #_public
    #_final
    (§ field #_"Script" (§ name redeemScript))
    #_public
    #_final
    (§ field #_"List<ECKey>" (§ name keys))

    #_private
    (§ constructor #_"RedeemData" [#_"List<ECKey>" (§ name keys), #_"Script" (§ name redeemScript)])
    (§ block
        (§ ass (§ name this.redeemScript) redeemScript)
        (§ var #_"List<ECKey>" (§ name sortedKeys) (§ new #_"ArrayList<>" (§ pars keys)))
        (§ expr Collections/sort(§ pars sortedKeys, ECKey/PUBKEY_COMPARATOR))
        (§ ass (§ name this.keys) sortedKeys)
        (§ void this)
    )

    #_public
    #_static
    (§ method #_"RedeemData" (§ fn of) [#_"List<ECKey>" (§ name keys), #_"Script" (§ name redeemScript)])
    (§ block
        (§ return (§ new #_"RedeemData" (§ pars keys, redeemScript)))
    )

    ;;;
     ; Creates RedeemData for pay-to-address or pay-to-pubkey input.  Provided key is a single private key
     ; needed to spend such inputs and provided program should be a proper CHECKSIG program.
     ;;
    #_public
    #_static
    (§ method #_"RedeemData" (§ fn of) [#_"ECKey" (§ name key), #_"Script" (§ name program)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars program.isSentToAddress(§ pars ) || program.isSentToRawPubKey(§ pars )))

        (§ return (§ quest (§ expr key != nil) ? (§ new #_"RedeemData" (§ pars Collections/singletonList(§ pars key), program)) :else nil))
    )

    ;;;
     ; Returns the first key that has private bytes.
     ;;
    #_public
    (§ method #_"ECKey" (§ fn getFullKey) [])
    (§ block
        (§ for (§ var #_"ECKey" (§ name key)) :for keys)
        (§ block
            (§ if (§ expr key.hasPrivKey(§ pars )))
            (§ block
                (§ return key)
            )
        )
        (§ return nil)
    )
)

#_(ns org.bitcoinj.wallet #_"RiskAnalysis"
    (:import [java.util List])
   (:require [org.bitcoinj.core Transaction]))

;;;
 ; <p>A RiskAnalysis represents an analysis of how likely it is that a transaction (and its dependencies)
 ; represents a possible double spending attack.  The wallet will create these to decide whether or not to accept
 ; a pending transaction.  Look at {@link DefaultRiskAnalysis} to see what is currently considered risky.</p>
 ;
 ; <p>The intention here is that implementing classes can expose more information and detail about the result,
 ; for app developers.  The core code needs only to know whether it's OK or not.</p>
 ;
 ; <p>A factory interface is provided.  The wallet will use this to analyze new pending transactions.</p>
 ;;
#_public
(§ interface #_"RiskAnalysis"
    (§ enum #_"Result"
        (§ item OK)
        (§ item NON_FINAL)
        (§ item NON_STANDARD)
    )

    (§ method #_"Result" (§ fn analyze) [])

    (§ interface #_"Analyzer"
        (§ method #_"RiskAnalysis" (§ fn create) [#_"Wallet" (§ name wallet), #_"Transaction" (§ name tx), #_"List<Transaction>" (§ name dependencies)])
    )
)

#_(ns org.bitcoinj.wallet #_"SendRequest"
    (:import [java.math BigInteger]
             [java.util Date])
    (:import [com.google.common.base MoreObjects Preconditions]
             [org.spongycastle.crypto.params KeyParameter])
   (:require [org.bitcoinj.core Address Coin Context ECKey NetworkParameters Transaction TransactionOutput]
             [org.bitcoinj.script Script ScriptBuilder]
             [org.bitcoinj.utils ExchangeRate]
             [org.bitcoinj.wallet.KeyChain KeyPurpose]
             [org.bitcoinj.wallet.Wallet MissingSigsMode]))

;;;
 ; A SendRequest gives the wallet information about precisely how to send money to a recipient or set of recipients.
 ; Static methods are provided to help you create SendRequests and there are a few helper methods on the wallet that
 ; just simplify the most common use cases.  You may wish to customize a SendRequest if you want to attach a fee or
 ; modify the change address.
 ;;
#_public
(§ class #_"SendRequest"
    ;;;
     ; <p>A transaction, probably incomplete, that describes the outline of what you want to do.  This typically
     ; will mean it has some outputs to the intended destinations, but no inputs or change address (and therefore
     ; no fees) - the wallet will calculate all that for you and update tx later.</p>
     ;
     ; <p>Be careful when adding outputs that you check the min output value
     ; ({@link TransactionOutput#getMinNonDustValue(Coin)}) to avoid the whole transaction being rejected
     ; because one output is dust.</p>
     ;
     ; <p>If there are already inputs to the transaction, make sure their out point has a connected output,
     ; otherwise their value will be added to fee.  Also ensure they are either signed or are spendable by
     ; a wallet key, otherwise the behavior of {@link Wallet#completeTx(Wallet.SendRequest)} is undefined
     ; (likely RuntimeException).</p>
     ;;
    #_public
    (§ field #_"Transaction" (§ name tx))

    ;;;
     ; When emptyWallet is set, all coins selected by the coin selector are sent to the first output in tx
     ; (its value is ignored and set to {@link org.bitcoinj.wallet.Wallet#getBalance()} - the fees required
     ; for the transaction).  Any additional outputs are removed.
     ;;
    #_public
    (§ field #_"boolean" (§ name emptyWallet) false)

    ;;;
     ; "Change" means the difference between the value gathered by a transactions inputs (the size of which you
     ; don't really control as it depends on who sent you money), and the value being sent somewhere else.  The
     ; change address should be selected from this wallet, normally.  <b>If null this will be chosen for you.</b>
     ;;
    #_public
    (§ field #_"Address" (§ name changeAddress) nil)

    ;;;
     ; <p>A transaction can have a fee attached, which is defined as the difference between the input values
     ; and output values.  Any value taken in that is not provided to an output can be claimed by a miner.  This
     ; is how mining is incentivized in later years of the Bitcoin system when inflation drops.  It also provides
     ; a way for people to prioritize their transactions over others and is used as a way to make denial of service
     ; attacks expensive.</p>
     ;
     ; <p>This is a dynamic fee (in satoshis) which will be added to the transaction for each kilobyte in size
     ; including the first.  This is useful as as miners usually sort pending transactions by their fee per unit size
     ; when choosing which transactions to add to a block.  Note that, to keep this equivalent to Bitcoin Core
     ; definition, a kilobyte is defined as 1000 bytes, not 1024.</p>
     ;;
    #_public
    (§ field #_"Coin" (§ name feePerKb) (§ expr Context/get(§ pars ).getFeePerKb(§ pars )))

    ;;;
     ; <p>Requires that there be enough fee for a default Bitcoin Core to at least relay the transaction.
     ; (i.e. ensure the transaction will not be outright rejected by the network).  Defaults to true,
     ; you should only set this to false if you know what you're doing.</p>
     ;
     ; <p>Note that this does not enforce certain fee rules that only apply to transactions which are larger
     ; than 26,000 bytes.  If you get a transaction which is that large, you should set a feePerKb of at least
     ; {@link Transaction#REFERENCE_DEFAULT_MIN_TX_FEE}.</p>
     ;;
    #_public
    (§ field #_"boolean" (§ name ensureMinRequiredFee) (§ expr Context/get(§ pars ).isEnsureMinRequiredFee(§ pars )))

    ;;;
     ; If true (the default), the inputs will be signed.
     ;;
    #_public
    (§ field #_"boolean" (§ name signInputs) true)

    ;;;
     ; The AES key to use to decrypt the private keys before signing.
     ; If null then no decryption will be performed and if decryption is required an exception will be thrown.
     ; You can get this from a password by doing wallet.getKeyCrypter().deriveKey(password).
     ;;
    #_public
    (§ field #_"KeyParameter" (§ name aesKey) nil)

    ;;;
     ; If not null, the {@link org.bitcoinj.wallet.CoinSelector} to use instead of the wallets default.
     ; Coin selectors are responsible for choosing which transaction outputs (coins) in a wallet to use given
     ; the desired send value amount.
     ;;
    #_public
    (§ field #_"CoinSelector" (§ name coinSelector) nil)

    ;;;
     ; If true (the default), the outputs will be shuffled during completion to randomize the location
     ; of the change output, if any.  This is normally what you want for privacy reasons but in unit tests
     ; it can be annoying, so it can be disabled here.
     ;;
    #_public
    (§ field #_"boolean" (§ name shuffleOutputs) true)

    ;;;
     ; Specifies what to do with missing signatures left after completing this request.  Default strategy is
     ; to throw an exception on missing signature ({@link MissingSigsMode#THROW}).
     ; @see MissingSigsMode
     ;;
    #_public
    (§ field #_"MissingSigsMode" (§ name missingSigsMode) (§ expr MissingSigsMode/THROW))

    ;;;
     ; If not null, this exchange rate is recorded with the transaction during completion.
     ;;
    #_public
    (§ field #_"ExchangeRate" (§ name exchangeRate) nil)

    ;;;
     ; If not null, this memo is recorded with the transaction during completion.  It can be used to record
     ; the memo of the payment request that initiated the transaction.
     ;;
    #_public
    (§ field #_"String" (§ name memo) nil)

    ;;;
     ; If false (default value), tx fee is paid by the sender.  If true, tx fee is paid by the recipient/s.
     ; If there is more than one recipient, the tx fee is split equally between them regardless of output
     ; value and size.
     ;;
    #_public
    (§ field #_"boolean" (§ name recipientsPayFees) false)

    ;; Tracks if this has been passed to wallet.completeTx already: just a safety check.
    (§ field #_"boolean" (§ name completed))

    #_private
    (§ constructor #_"SendRequest" [])
    (§ block
        (§ void this)
    )

    ;;;
     ; <p>Creates a new SendRequest to the given address for the given value.</p>
     ;
     ; <p>Be very careful when value is smaller than {@link Transaction#MIN_NONDUST_OUTPUT} as the transaction
     ; will likely be rejected by the network in this case.</p>
     ;;
    #_public
    #_static
    (§ method #_"SendRequest" (§ fn to) [#_"Address" (§ name destination), #_"Coin" (§ name value)])
    (§ block
        (§ var #_"SendRequest" (§ name req) (§ new #_"SendRequest" (§ pars )))
        #_final
        (§ var #_"NetworkParameters" (§ name parameters) (§ expr destination.getParameters(§ pars )))

        (§ expr Preconditions/checkNotNull(§ pars parameters, "Address is for an unknown network"))

        (§ ass (§ name req.tx) (§ new #_"Transaction" (§ pars parameters)))
        (§ expr req.tx.addOutput(§ pars value, destination))
        (§ return req)
    )

    ;;;
     ; <p>Creates a new SendRequest to the given pubkey for the given value.</p>
     ;
     ; <p>Be careful to check the output's value is reasonable using
     ; {@link TransactionOutput#getMinNonDustValue(Coin)} afterwards or you risk having the transaction
     ; rejected by the network.  Note that using {@link SendRequest#to(Address, Coin)} will result
     ; in a smaller output, and thus the ability to use a smaller output value without rejection.</p>
     ;;
    #_public
    #_static
    (§ method #_"SendRequest" (§ fn to) [#_"NetworkParameters" (§ name params), #_"ECKey" (§ name destination), #_"Coin" (§ name value)])
    (§ block
        (§ var #_"SendRequest" (§ name req) (§ new #_"SendRequest" (§ pars )))
        (§ ass (§ name req.tx) (§ new #_"Transaction" (§ pars params)))
        (§ expr req.tx.addOutput(§ pars value, destination))
        (§ return req)
    )

    ;;; Simply wraps a pre-built incomplete transaction provided by you. ;;
    #_public
    #_static
    (§ method #_"SendRequest" (§ fn forTx) [#_"Transaction" (§ name tx)])
    (§ block
        (§ var #_"SendRequest" (§ name req) (§ new #_"SendRequest" (§ pars )))
        (§ ass (§ name req.tx) tx)
        (§ return req)
    )

    #_public
    #_static
    (§ method #_"SendRequest" (§ fn emptyWallet) [#_"Address" (§ name destination)])
    (§ block
        (§ var #_"SendRequest" (§ name req) (§ new #_"SendRequest" (§ pars )))
        #_final
        (§ var #_"NetworkParameters" (§ name parameters) (§ expr destination.getParameters(§ pars )))

        (§ expr Preconditions/checkNotNull(§ pars parameters, "Address is for an unknown network"))

        (§ ass (§ name req.tx) (§ new #_"Transaction" (§ pars parameters)))
        (§ expr req.tx.addOutput(§ pars Coin/ZERO, destination))
        (§ ass (§ name req.emptyWallet) true)
        (§ return req)
    )

    ;;;
     ; Construct a SendRequest for a CPFP (child-pays-for-parent) transaction.  The resulting transaction is
     ; already completed, so you should directly proceed to signing and broadcasting/committing the transaction.
     ; CPFP is currently only supported by a few miners, so use with care.
     ;;
    #_public
    #_static
    (§ method #_"SendRequest" (§ fn childPaysForParent) [#_"Wallet" (§ name wallet), #_"Transaction" (§ name parentTransaction), #_"Coin" (§ name feeRaise)])
    (§ block
        (§ var #_"TransactionOutput" (§ name outputToSpend) nil)
        (§ for (§ var #_final TransactionOutput output) :for (§ expr parentTransaction.getOutputs(§ pars )))
        (§ block
            (§ if (§ expr output.isMine(§ pars wallet) && output.isAvailableForSpending(§ pars ) && output.getValue(§ pars ).isGreaterThan(§ pars feeRaise)))
            (§ block
                (§ ass (§ name outputToSpend) output)
                (§ break )
            )
        )
        ;; TODO: Spend another confirmed output of own wallet if needed.
        (§ expr Preconditions/checkNotNull(§ pars outputToSpend, "Can't find adequately sized output that spends to us"))

        #_final
        (§ var #_"Transaction" (§ name tx) (§ new #_"Transaction" (§ pars parentTransaction.getParams(§ pars ))))
        (§ expr tx.addInput(§ pars outputToSpend))
        (§ expr tx.addOutput(§ pars outputToSpend.getValue(§ pars ).subtract(§ pars feeRaise), wallet.freshAddress(§ pars KeyPurpose/CHANGE)))
        (§ expr tx.setPurpose(§ pars Transaction/Purpose/RAISE_FEE))
        #_final
        (§ var #_"SendRequest" (§ name req) (§ expr forTx(§ pars tx)))
        (§ ass (§ name req.completed) true)
        (§ return req)
    )

    #_public
    #_static
    (§ method #_"SendRequest" (§ fn toCLTVPaymentChannel) [#_"NetworkParameters" (§ name params), #_"Date" (§ name releaseTime), #_"ECKey" (§ name from), #_"ECKey" (§ name to), #_"Coin" (§ name value)])
    (§ block
        (§ var #_"long" (§ name time) (§ expr releaseTime.getTime(§ pars ) / 1000))

        (§ expr Preconditions/checkArgument(§ pars Transaction/LOCKTIME_THRESHOLD <= time, "Release time was too small"))

        (§ return (§ expr toCLTVPaymentChannel(§ pars params, BigInteger/valueOf(§ pars time), from, to, value)))
    )

    #_public
    #_static
    (§ method #_"SendRequest" (§ fn toCLTVPaymentChannel) [#_"NetworkParameters" (§ name params), #_"int" (§ name releaseBlock), #_"ECKey" (§ name from), #_"ECKey" (§ name to), #_"Coin" (§ name value)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars 0 <= releaseBlock && releaseBlock < Transaction/LOCKTIME_THRESHOLD, "Block number was too large"))

        (§ return (§ expr toCLTVPaymentChannel(§ pars params, BigInteger/valueOf(§ pars releaseBlock), from, to, value)))
    )

    #_public
    #_static
    (§ method #_"SendRequest" (§ fn toCLTVPaymentChannel) [#_"NetworkParameters" (§ name params), #_"BigInteger" (§ name time), #_"ECKey" (§ name from), #_"ECKey" (§ name to), #_"Coin" (§ name value)])
    (§ block
        (§ var #_"SendRequest" (§ name req) (§ new #_"SendRequest" (§ pars )))
        (§ var #_"Script" (§ name output) (§ expr ScriptBuilder/createCLTVPaymentChannelOutput(§ pars time, from, to)))
        (§ ass (§ name req.tx) (§ new #_"Transaction" (§ pars params)))
        (§ expr req.tx.addOutput(§ pars value, output))
        (§ return req)
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        ;; Print only the user-settable fields.
        (§ var #_"MoreObjects.ToStringHelper" (§ name helper) (§ expr MoreObjects/toStringHelper(§ pars this).omitNullValues(§ pars )))
        (§ expr helper.add(§ pars "emptyWallet", emptyWallet))
        (§ expr helper.add(§ pars "changeAddress", changeAddress))
        (§ expr helper.add(§ pars "feePerKb", feePerKb))
        (§ expr helper.add(§ pars "ensureMinRequiredFee", ensureMinRequiredFee))
        (§ expr helper.add(§ pars "signInputs", signInputs))
        (§ expr helper.add(§ pars "aesKey", (§ quest (§ expr aesKey != nil) ? (§ expr "set") :else nil))) ;; Careful to not leak the key.
        (§ expr helper.add(§ pars "coinSelector", coinSelector))
        (§ expr helper.add(§ pars "shuffleOutputs", shuffleOutputs))
        (§ expr helper.add(§ pars "recipientsPayFees", recipientsPayFees))
        (§ return (§ expr helper.toString(§ pars )))
    )
)

#_(ns org.bitcoinj.wallet #_"UnreadableWalletException")

;;;
 ; Thrown by the {@link WalletProtobufSerializer} when the serialized protocol buffer is either corrupted,
 ; internally inconsistent or appears to be from the future.
 ;;
#_public
(§ class #_"UnreadableWalletException" (§ extends #_"Exception")
    #_public
    (§ constructor #_"UnreadableWalletException" [#_"String" (§ name s)])
    (§ block
        (§ super (§ pars s))
        (§ void this)
    )

    #_public
    (§ constructor #_"UnreadableWalletException" [#_"String" (§ name s), #_"Throwable" (§ name t)])
    (§ block
        (§ super (§ pars s, t))
        (§ void this)
    )

    #_public
    #_static
    (§ class #_"BadPassword" (§ extends #_"UnreadableWalletException")
        #_public
        (§ constructor #_"BadPassword" [])
        (§ block
            (§ super (§ pars "Password incorrect"))
            (§ void this)
        )
    )

    #_public
    #_static
    (§ class #_"FutureVersion" (§ extends #_"UnreadableWalletException")
        #_public
        (§ constructor #_"FutureVersion" [])
        (§ block
            (§ super (§ pars "Unknown wallet version from the future."))
            (§ void this)
        )
    )

    #_public
    #_static
    (§ class #_"WrongNetwork" (§ extends #_"UnreadableWalletException")
        #_public
        (§ constructor #_"WrongNetwork" [])
        (§ block
            (§ super (§ pars "Mismatched network ID"))
            (§ void this)
        )
    )
)

#_(ns org.bitcoinj.wallet #_"Wallet"
    (:import [java.io *]
             [java.math BigInteger]
             [java.util *]
             [java.util.concurrent *]
             [java.util.concurrent.atomic *]
             [java.util.concurrent.locks *])
    (:import [com.google.common.annotations *]
             [com.google.common.base *]
             [com.google.common.collect *]
             [com.google.common.primitives *]
             [com.google.common.util.concurrent *]
             [com.google.protobuf *]
             [net.jcip.annotations *]
             [org.slf4j *]
             [org.spongycastle.crypto.params *])
   (:require [org.bitcoinj.core AbstractBlockChain Address BlockChain BloomFilter Coin Context ECKey FilteredBlock InsufficientMoneyException Message NetworkParameters Peer PeerFilterProvider PeerGroup ScriptException Sha256Hash StoredBlock Transaction TransactionBag TransactionBroadcast TransactionBroadcaster TransactionConfidence TransactionInput TransactionOutPoint TransactionOutput UTXO Utils VarInt VerificationException]
             [org.bitcoinj.core.TransactionConfidence *]
             [org.bitcoinj.core.listeners *]
             [org.bitcoinj.crypto *]
             [org.bitcoinj.script *]
             [org.bitcoinj.signers *]
             [org.bitcoinj.utils *]
             [org.bitcoinj.wallet.Protos.Wallet *]
             [org.bitcoinj.wallet.WalletTransaction *]
             [org.bitcoinj.wallet.listeners KeyChainEventListener WalletChangeEventListener WalletCoinsReceivedEventListener WalletCoinsSentEventListener WalletReorganizeEventListener]))

;; To do list:
;;
;; - Take all wallet-relevant data out of Transaction and put it into WalletTransaction.  Make Transaction immutable.
;; - Only store relevant transaction outputs, don't bother storing the rest of the data.  Big RAM saving.
;; - Split block chain and tx output tracking into a superclass that doesn't have any key or spending related code.
;; - Simplify how transactions are tracked and stored: in particular, have the wallet maintain positioning information
;;   for transactions independent of the transactions themselves, so the timeline can be walked without having to
;;   process and sort every single transaction.
;; - Split data persistence out into a backend class and make the wallet transactional, so we can store a wallet
;;   in a database not just in RAM.
;; - Make clearing of transactions able to only rewind the wallet a certain distance instead of all blocks.
;; - Make it scale:
;;     - eliminate all the algorithms with quadratic complexity (or worse).
;;     - don't require everything to be held in RAM at once.
;;     - consider allowing eviction of no longer re-orgable transactions or keys that were used up.
;;
;; Finally, find more ways to break the class up and decompose it.  Currently every time we move code out, other code
;; fills up the lines saved!

;;;
 ; <p>A Wallet stores keys and a record of transactions that send and receive value from those keys.  Using these,
 ; it is able to create new transactions that spend the recorded transactions, and this is the fundamental operation
 ; of the Bitcoin protocol.</p>
 ;
 ; <p>To learn more about this class, read <b><a href="https://bitcoinj.github.io/working-with-the-wallet">working with the wallet.</a></b></p>
 ;
 ; <p>To fill up a Wallet with transactions, you need to use it in combination with a {@link BlockChain} and various
 ; other objects, see the <a href="https://bitcoinj.github.io/getting-started">Getting started</a> tutorial
 ; on the website to learn more about how to set everything up.</p>
 ;
 ; <p>Wallets can be serialized using protocol buffers.  You need to save the wallet whenever it changes, there is an
 ; auto-save feature that simplifies this for you although you're still responsible for manually triggering a save when
 ; your app is about to quit because the auto-save feature waits a moment before actually committing to disk to avoid IO
 ; thrashing when the wallet is changing very fast (e.g. due to a block chain sync).  See
 ; {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, org.bitcoinj.wallet.WalletFiles.Listener)}
 ; for more information about this.</p>
 ;;
#_public
(§ class #_"Wallet" (§ implements #_"NewBestBlockListener", #_"TransactionReceivedInBlockListener", #_"PeerFilterProvider", #_"KeyBag", #_"TransactionBag", #_"ReorganizeListener")
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"Wallet"))))
    #_private
    #_static
    #_final
    (§ field #_"int" (§ name MINIMUM_BLOOM_DATA_LENGTH) 8)

    ;; Ordering: lock > keyChainGroupLock.  KeyChainGroup is protected separately to allow fast querying of current receive
    ;; address even if the wallet itself is busy e.g. saving or processing a big reorg.  Useful for reducing UI latency.
    #_protected
    #_final
    (§ field #_"ReentrantLock" (§ name lock) (§ expr Threading/lock(§ pars "wallet")))
    #_protected
    #_final
    (§ field #_"ReentrantLock" (§ name keyChainGroupLock) (§ expr Threading/lock(§ pars "wallet-keychaingroup")))

    ;; The various pools below give quick access to wallet-relevant transactions by the state they're in:
    ;;
    ;; Pending:  Transactions that didn't make it into the best chain yet.  Pending transactions can be killed if a
    ;;           double spend against them appears in the best chain, in which case they move to the dead pool.
    ;;           If a double spend appears in the pending state as well, we update the confidence type
    ;;           of all txns in conflict to IN_CONFLICT and wait for the miners to resolve the race.
    ;; Unspent:  Transactions that appeared in the best chain and have outputs we can spend.  Note that we store the
    ;;           entire transaction in memory even though for spending purposes we only really need the outputs, the
    ;;           reason being that this simplifies handling of re-orgs.  It would be worth fixing this in future.
    ;; Spent:    Transactions that appeared in the best chain but don't have any spendable outputs.  They're stored
    ;;           here for history browsing/auditing reasons only and in future will probably be flushed out to some
    ;;           other kind of cold storage or just removed.
    ;; Dead:     Transactions that we believe will never confirm get moved here, out of pending.  Note that Bitcoin
    ;;           Core has no notion of dead-ness: the assumption is that double spends won't happen so there's no
    ;;           need to notify the user about them.  We take a more pessimistic approach and try to track the fact
    ;;           that transactions have been double spent so applications can do something intelligent (cancel orders,
    ;;           show to the user in the UI, etc).  A transaction can leave dead and move into spent/unspent if there
    ;;           is a re-org to a chain that doesn't include the double spend.

    #_private
    #_final
    (§ field #_"Map<Sha256Hash, Transaction>" (§ name pending))
    #_private
    #_final
    (§ field #_"Map<Sha256Hash, Transaction>" (§ name unspent))
    #_private
    #_final
    (§ field #_"Map<Sha256Hash, Transaction>" (§ name spent))
    #_private
    #_final
    (§ field #_"Map<Sha256Hash, Transaction>" (§ name dead))

    ;; All transactions together.
    #_protected
    #_final
    (§ field #_"Map<Sha256Hash, Transaction>" (§ name transactions))

    ;; All the TransactionOutput objects that we could spend (ignoring whether we have the private key or not).
    ;; Used to speed up various calculations.
    #_protected
    #_final
    (§ field #_"HashSet<TransactionOutput>" (§ name myUnspents) (§ expr Sets/newHashSet(§ pars )))

    ;; Transactions that were dropped by the risk analysis system.  These are not in any pools and not serialized
    ;; to disk.  We have to keep them around because if we ignore a tx because we think it will never confirm, but
    ;; then it actually does confirm and does so within the same network session, remote peers will not resend us
    ;; the tx data along with the Bloom filtered block, as they know we already received it once before
    ;; (so it would be wasteful to repeat).  Thus we keep them around here for a while.  If we drop our network
    ;; connections then the remote peers will forget that we were sent the tx data previously and send it again
    ;; when relaying a filtered merkleblock.
    #_private
    #_final
    (§ field #_"LinkedHashMap<Sha256Hash, Transaction>" (§ name riskDropped) (§ new #_"LinkedHashMap<Sha256Hash, Transaction>" (§ pars )
        (§ anon
            #_override
            #_protected
            (§ method #_"boolean" (§ fn removeEldestEntry) [#_"Map.Entry<Sha256Hash, Transaction>" (§ name eldest)])
            (§ block
                (§ return (§ expr 1000 < size(§ pars )))
            )
        )))

    ;; The key chain group is not thread safe, and generally the whole hierarchy of objects should not be mutated
    ;; outside the wallet lock.  So don't expose this object directly via any accessors!
    #_guarded-by(§ opt "keyChainGroupLock")
    #_private
    (§ field #_"KeyChainGroup" (§ name keyChainGroup))

    #_protected
    #_final
    (§ field #_"Context" (§ name context))
    #_protected
    #_final
    (§ field #_"NetworkParameters" (§ name params))

    #_nilable
    #_private
    (§ field #_"Sha256Hash" (§ name lastBlockSeenHash))
    #_private
    (§ field #_"int" (§ name lastBlockSeenHeight))
    #_private
    (§ field #_"long" (§ name lastBlockSeenTimeSecs))

    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<WalletChangeEventListener>>" (§ name changeListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<WalletCoinsReceivedEventListener>>" (§ name coinsReceivedListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<WalletCoinsSentEventListener>>" (§ name coinsSentListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<WalletReorganizeEventListener>>" (§ name reorganizeListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))
    #_private
    #_final
    (§ field #_"CopyOnWriteArrayList<ListenerRegistration<TransactionConfidenceEventListener>>" (§ name transactionConfidenceListeners) (§ new #_"CopyOnWriteArrayList<>" (§ pars )))

    ;; A listener that relays confidence changes from the transaction confidence object to the wallet event listener,
    ;; as a convenience to API users so they don't have to register on every transaction themselves.
    #_private
    (§ field #_"TransactionConfidence.Listener" (§ name txConfidenceListener))

    ;; If a TX hash appears in this set then notifyNewBestBlock will ignore it, as its confidence was already set up
    ;; in receive() via Transaction.setBlockAppearance().  As the BlockChain always calls notifyNewBestBlock even if
    ;; it sent transactions to the wallet, without this we'd double count.
    #_private
    (§ field #_"HashSet<Sha256Hash>" (§ name ignoreNextNewBlock))
    ;; Whether or not to ignore pending transactions that are considered risky by the configured risk analyzer.
    #_private
    (§ field #_"boolean" (§ name acceptRiskyTransactions))
    ;; Object that performs risk analysis of pending transactions.  We might reject transactions that seem like
    ;; a high risk of being a double spending attack.
    #_private
    (§ field #_"RiskAnalysis.Analyzer" (§ name riskAnalyzer) (§ expr DefaultRiskAnalysis/FACTORY))

    ;; Stuff for notifying transaction objects that we changed their confidences.  The purpose of this is to avoid
    ;; spuriously sending lots of repeated notifications to listeners that API users aren't really interested in as
    ;; a side effect of how the code is written (e.g. during re-orgs confidence data gets adjusted multiple times).
    #_private
    (§ field #_"int" (§ name onWalletChangedSuppressions))
    #_private
    (§ field #_"boolean" (§ name insideReorg))
    #_private
    (§ field #_"Map<Transaction, TransactionConfidence.Listener.ChangeReason>" (§ name confidenceChanged))
    #_protected
    #_volatile
    (§ field #_"WalletFiles" (§ name vFileManager))
    ;; Object that is used to send transactions asynchronously when the wallet requires it.
    #_protected
    #_volatile
    (§ field #_"TransactionBroadcaster" (§ name vTransactionBroadcaster))
    ;; UNIX time in seconds.  Money controlled by keys created before this time will be automatically respent to
    ;; a key that was created after it.  Useful when you believe some keys have been compromised.
    #_private
    #_volatile
    (§ field #_"long" (§ name vKeyRotationTimestamp))

    #_protected
    (§ field #_"CoinSelector" (§ name coinSelector) (§ new #_"DefaultCoinSelector" (§ pars )))

    ;; The wallet version.  This is an int that can be used to track breaking changes in the wallet format.
    ;; You can also use it to detect wallets that come from the future (i.e. they contain features you
    ;; do not know how to deal with).
    #_private
    (§ field #_"int" (§ name version))
    ;; User-provided description that may help people keep track of what a wallet is for.
    #_private
    (§ field #_"String" (§ name description))

    ;; Objects that perform transaction signing.  Applied subsequently one after another.
    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"List<TransactionSigner>" (§ name signers))

    ;;;
     ; Creates a new, empty wallet with a randomly chosen seed and no transactions.  Make sure to provide for
     ; sufficient backup!  Any keys will be derived from the seed.  If you want to restore a wallet from disk
     ; instead, see {@link #loadFromFile}.
     ;;
    #_public
    (§ constructor #_"Wallet" [#_"NetworkParameters" (§ name params)])
    (§ block
        (§ this (§ pars Context/getOrCreate(§ pars params)))
        (§ void this)
    )

    ;;;
     ; Creates a new, empty wallet with a randomly chosen seed and no transactions.  Make sure to provide for
     ; sufficient backup!  Any keys will be derived from the seed.  If you want to restore a wallet from disk
     ; instead, see {@link #loadFromFile}.
     ;;
    #_public
    (§ constructor #_"Wallet" [#_"Context" (§ name context)])
    (§ block
        (§ this (§ pars context, new KeyChainGroup(§ pars context.getParams(§ pars ))))
        (§ void this)
    )

    #_public
    #_static
    (§ method #_"Wallet" (§ fn fromSeed) [#_"NetworkParameters" (§ name params), #_"DeterministicSeed" (§ name seed)])
    (§ block
        (§ return (§ new #_"Wallet" (§ pars params, new KeyChainGroup(§ pars params, seed))))
    )

    ;;;
     ; Creates a wallet that tracks payments to and from the HD key hierarchy rooted by the given watching key.
     ; A watching key corresponds to account zero in the recommended BIP32 key hierarchy.
     ;;
    #_public
    #_static
    (§ method #_"Wallet" (§ fn fromWatchingKey) [#_"NetworkParameters" (§ name params), #_"DeterministicKey" (§ name watchKey)])
    (§ block
        (§ return (§ new #_"Wallet" (§ pars params, new KeyChainGroup(§ pars params, watchKey))))
    )

    ;;;
     ; Creates a wallet that tracks payments to and from the HD key hierarchy rooted by the given watching key.
     ; A watching key corresponds to account zero in the recommended BIP32 key hierarchy.  The key is specified
     ; in base58 notation and the creation time of the key.  If you don't know the creation time, you can pass
     ; {@link DeterministicHierarchy#BIP32_STANDARDISATION_TIME_SECS}.
     ;;
    #_public
    #_static
    (§ method #_"Wallet" (§ fn fromWatchingKeyB58) [#_"NetworkParameters" (§ name params), #_"String" (§ name watchKeyB58), #_"long" (§ name creationTimeSeconds)])
    (§ block
        #_final
        (§ var #_"DeterministicKey" (§ name watchKey) (§ expr DeterministicKey/deserializeB58(§ pars nil, watchKeyB58, params)))
        (§ expr watchKey.setCreationTimeSeconds(§ pars creationTimeSeconds))
        (§ return (§ expr fromWatchingKey(§ pars params, watchKey)))
    )

    ;;;
     ; Creates a wallet containing a given set of keys.  All further keys will be derived from the oldest key.
     ;;
    #_public
    #_static
    (§ method #_"Wallet" (§ fn fromKeys) [#_"NetworkParameters" (§ name params), #_"List<ECKey>" (§ name keys)])
    (§ block
        (§ for (§ var #_"ECKey" (§ name key)) :for keys)
        (§ block
            (§ expr Preconditions/checkArgument(§ pars (§ not (§ insta key #_"DeterministicKey"))))
        )

        (§ var #_"KeyChainGroup" (§ name group) (§ new #_"KeyChainGroup" (§ pars params)))
        (§ expr group.importKeys(§ pars keys))
        (§ return (§ new #_"Wallet" (§ pars params, group)))
    )

    #_public
    (§ constructor #_"Wallet" [#_"NetworkParameters" (§ name params), #_"KeyChainGroup" (§ name keyChainGroup)])
    (§ block
        (§ this (§ pars Context/getOrCreate(§ pars params), keyChainGroup))
        (§ void this)
    )

    #_private
    (§ constructor #_"Wallet" [#_"Context" (§ name context), #_"KeyChainGroup" (§ name keyChainGroup)])
    (§ block
        (§ ass (§ name this.context) context)
        (§ ass (§ name this.params) (§ expr context.getParams(§ pars )))
        (§ ass (§ name this.keyChainGroup) (§ expr Preconditions/checkNotNull(§ pars keyChainGroup)))
        (§ if (§ expr params.getId(§ pars ).equals(§ pars NetworkParameters/ID_UNITTESTNET)))
        (§ block
            (§ expr this.keyChainGroup.setLookaheadSize(§ pars 5)) ;; Cut down excess computation for unit tests.
        )
        ;; If this keyChainGroup was created fresh just now (new wallet), make HD so a backup can be made immediately
        ;; without having to call current/freshReceiveKey.  If there are already keys in the chain of any kind then
        ;; we're probably being deserialized so leave things alone: the API user can upgrade later.
        (§ if (§ expr this.keyChainGroup.numKeys(§ pars ) == 0))
        (§ block
            (§ expr this.keyChainGroup.createAndActivateNewHDChain(§ pars ))
        )
        (§ ass (§ name unspent) (§ new #_"HashMap<>" (§ pars )))
        (§ ass (§ name spent) (§ new #_"HashMap<>" (§ pars )))
        (§ ass (§ name pending) (§ new #_"HashMap<>" (§ pars )))
        (§ ass (§ name dead) (§ new #_"HashMap<>" (§ pars )))
        (§ ass (§ name transactions) (§ new #_"HashMap<>" (§ pars )))
        ;; Use a linked hash map to ensure ordering of event listeners is correct.
        (§ ass (§ name confidenceChanged) (§ new #_"LinkedHashMap<>" (§ pars )))
        (§ ass (§ name signers) (§ new #_"ArrayList<>" (§ pars )))
        (§ expr addTransactionSigner(§ pars (§ new #_"LocalTransactionSigner" (§ pars ))))
        (§ expr createTransientState(§ pars ))
        (§ void this)
    )

    #_private
    (§ method #_"void" (§ fn createTransientState) [])
    (§ block
        (§ ass (§ name ignoreNextNewBlock) (§ new #_"HashSet<>" (§ pars )))
        (§ ass (§ name txConfidenceListener) (§ new #_"TransactionConfidence.Listener" (§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"void" (§ fn onConfidenceChanged) [#_"TransactionConfidence" (§ name confidence), #_"TransactionConfidence.Listener.ChangeReason" (§ name reason)])
            (§ block
                ;; This will run on the user code thread so we shouldn't do anything too complicated here.
                ;; We only want to queue a wallet changed event and auto-save if the number of peers announcing
                ;; the transaction has changed, as that confidence change is made by the networking code which
                ;; doesn't necessarily know at that point which wallets contain which transactions, so it's up
                ;; to us to listen for that.  Other types of confidence changes (type, etc.) are triggered by us,
                ;; so we'll queue up a wallet change event in other parts of the code.
                (§ if (§ expr reason == ChangeReason/SEEN_PEERS))
                (§ block
                    (§ expr lock.lock(§ pars ))
                    (§ try )
                    (§ block
                        (§ expr checkBalanceFuturesLocked(§ pars nil))
                        (§ var #_"Transaction" (§ name tx) (§ expr getTransaction(§ pars confidence.getTransactionHash(§ pars ))))
                        (§ expr queueOnTransactionConfidenceChanged(§ pars tx))
                        (§ expr maybeQueueOnWalletChanged(§ pars ))
                    )
                    (§ finally )
                    (§ block
                        (§ expr lock.unlock(§ pars ))
                    )
                )
                (§ void nil)
            )
        )))
        (§ ass (§ name acceptRiskyTransactions) false)
        (§ void nil)
    )

    #_public
    (§ method #_"NetworkParameters" (§ fn getNetworkParameters) [])
    (§ block
        (§ return params)
    )

    ;;;
     ; Gets the active keychain via {@link KeyChainGroup#getActiveKeyChain()}.
     ;;
    #_public
    (§ method #_"DeterministicKeyChain" (§ fn getActiveKeyChain) [])
    (§ block
        (§ return (§ expr keyChainGroup.getActiveKeyChain(§ pars )))
    )

    ;;;
     ; <p>Adds given transaction signer to the list of signers.  It will be added to the end of the signers list,
     ; so if this wallet already has some signers added, given signer will be executed after all of them.</p>
     ; <p>Transaction signer should be fully initialized before adding to the wallet, otherwise
     ; {@link IllegalStateException} will be thrown</p>
     ;;
    #_public
    #_final
    (§ method #_"void" (§ fn addTransactionSigner) [#_"TransactionSigner" (§ name signer)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr signer.isReady(§ pars )))
            (§ block
                (§ expr signers.add(§ pars signer))
            )
            (§ else )
            (§ block
                (§ throw (§ new #_"IllegalStateException" (§ pars "Signer instance is not ready to be added into Wallet: " + signer.getClass(§ pars ))))
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    #_public
    (§ method #_"List<TransactionSigner>" (§ fn getTransactionSigners) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr ImmutableList/copyOf(§ pars signers)))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a key that hasn't been seen in a transaction yet, and which is suitable for displaying
     ; in a wallet user interface as "a convenient key to receive funds on" when the purpose parameter
     ; is {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS}.  The returned key is stable
     ; until it's actually seen in a pending or confirmed transaction, at which point this method will
     ; start returning a different key (for each purpose independently).
     ;;
    #_public
    (§ method #_"DeterministicKey" (§ fn currentKey) [#_"KeyChain.KeyPurpose" (§ name purpose)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr maybeUpgradeToHD(§ pars ))
            (§ return (§ expr keyChainGroup.currentKey(§ pars purpose)))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; An alias for calling {@link #currentKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
    #_public
    (§ method #_"DeterministicKey" (§ fn currentReceiveKey) [])
    (§ block
        (§ return (§ expr currentKey(§ pars KeyChain/KeyPurpose/RECEIVE_FUNDS)))
    )

    ;;;
     ; Returns address for a {@link #currentKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)}.
     ;;
    #_public
    (§ method #_"Address" (§ fn currentAddress) [#_"KeyChain.KeyPurpose" (§ name purpose)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr maybeUpgradeToHD(§ pars ))
            (§ return (§ expr keyChainGroup.currentAddress(§ pars purpose)))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; An alias for calling {@link #currentAddress(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
    #_public
    (§ method #_"Address" (§ fn currentReceiveAddress) [])
    (§ block
        (§ return (§ expr currentAddress(§ pars KeyChain/KeyPurpose/RECEIVE_FUNDS)))
    )

    ;;;
     ; Returns a key that has not been returned by this method before (fresh).  You can think of this
     ; as being a newly created key, although the notion of "create" is not really valid for a
     ; {@link org.bitcoinj.wallet.DeterministicKeyChain}.  When the parameter is
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} the returned key is suitable for
     ; being put into a receive coins wizard type UI.  You should use this when the user is definitely
     ; going to hand this key out to someone who wishes to send money.
     ;;
    #_public
    (§ method #_"DeterministicKey" (§ fn freshKey) [#_"KeyChain.KeyPurpose" (§ name purpose)])
    (§ block
        (§ return (§ expr freshKeys(§ pars purpose, 1).get(§ pars 0)))
    )

    ;;;
     ; Returns a key/s that has not been returned by this method before (fresh).  You can think of this
     ; as being a newly created key/s, although the notion of "create" is not really valid for a
     ; {@link org.bitcoinj.wallet.DeterministicKeyChain}.  When the parameter is
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} the returned key is suitable for
     ; being put into a receive coins wizard type UI. You should use this when the user is definitely
     ; going to hand this key/s out to someone who wishes to send money.
     ;;
    #_public
    (§ method #_"List<DeterministicKey>" (§ fn freshKeys) [#_"KeyChain.KeyPurpose" (§ name purpose), #_"int" (§ name numberOfKeys)])
    (§ block
        (§ var #_"List<DeterministicKey>" (§ name keys))
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr maybeUpgradeToHD(§ pars ))
            (§ ass (§ name keys) (§ expr keyChainGroup.freshKeys(§ pars purpose, numberOfKeys)))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
        ;; Do we really need an immediate hard save?  Arguably all this is doing is saving the 'current' key
        ;; and that's not quite so important, so we could coalesce for more performance.
        (§ expr saveNow(§ pars ))
        (§ return keys)
    )

    ;;;
     ; An alias for calling {@link #freshKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
    #_public
    (§ method #_"DeterministicKey" (§ fn freshReceiveKey) [])
    (§ block
        (§ return (§ expr freshKey(§ pars KeyChain/KeyPurpose/RECEIVE_FUNDS)))
    )

    ;;;
     ; Returns address for a {@link #freshKey(org.bitcoinj.wallet.KeyChain.KeyPurpose)}.
     ;;
    #_public
    (§ method #_"Address" (§ fn freshAddress) [#_"KeyChain.KeyPurpose" (§ name purpose)])
    (§ block
        (§ var #_"Address" (§ name key))
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name key) (§ expr keyChainGroup.freshAddress(§ pars purpose)))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
        (§ expr saveNow(§ pars ))
        (§ return key)
    )

    ;;;
     ; An alias for calling {@link #freshAddress(org.bitcoinj.wallet.KeyChain.KeyPurpose)} with
     ; {@link org.bitcoinj.wallet.KeyChain.KeyPurpose#RECEIVE_FUNDS} as the parameter.
     ;;
    #_public
    (§ method #_"Address" (§ fn freshReceiveAddress) [])
    (§ block
        (§ return (§ expr freshAddress(§ pars KeyChain/KeyPurpose/RECEIVE_FUNDS)))
    )

    ;;;
     ; Returns only the keys that have been issued by {@link #freshReceiveKey()}, {@link #freshReceiveAddress()},
     ; {@link #currentReceiveKey()} or {@link #currentReceiveAddress()}.
     ;;
    #_public
    (§ method #_"List<ECKey>" (§ fn getIssuedReceiveKeys) [])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr keyChainGroup.getActiveKeyChain(§ pars ).getIssuedReceiveKeys(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns only the addresses that have been issued by {@link #freshReceiveKey()}, {@link #freshReceiveAddress()},
     ; {@link #currentReceiveKey()} or {@link #currentReceiveAddress()}.
     ;;
    #_public
    (§ method #_"List<Address>" (§ fn getIssuedReceiveAddresses) [])
    (§ block
        #_final
        (§ var #_"List<ECKey>" (§ name keys) (§ expr getIssuedReceiveKeys(§ pars )))
        (§ var #_"List<Address>" (§ name addresses) (§ new #_"ArrayList<>" (§ pars keys.size(§ pars ))))
        (§ for (§ var #_"ECKey" (§ name key)) :for keys)
        (§ block
            (§ expr addresses.add(§ pars key.toAddress(§ pars getParams(§ pars ))))
        )
        (§ return addresses)
    )

    ;;;
     ; Upgrades the wallet to be deterministic (BIP32).  You should call this, possibly providing the users encryption
     ; key, after loading a wallet produced by previous versions of bitcoinj.  If the wallet is encrypted the key
     ; <b>must</b> be provided, due to the way the seed is derived deterministically from private key bytes: failing
     ; to do this will result in an exception being thrown.  For non-encrypted wallets, the upgrade will be done for
     ; you automatically the first time a new key is requested (this happens when spending due to the change address).
     ;;
    #_public
    (§ method #_"void" (§ fn upgradeToDeterministic) [#_nilable #_"KeyParameter" (§ name aesKey)])
        (§ throws #_"DeterministicUpgradeRequiresPassword")
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr keyChainGroup.upgradeToDeterministic(§ pars vKeyRotationTimestamp, aesKey))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Returns true if the wallet contains random keys and no HD chains, in which case you should call
     ; {@link #upgradeToDeterministic(org.spongycastle.crypto.params.KeyParameter)} before attempting
     ; to do anything that would require a new address or key.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isDeterministicUpgradeRequired) [])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr keyChainGroup.isDeterministicUpgradeRequired(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    #_private
    (§ method #_"void" (§ fn maybeUpgradeToHD) [])
        (§ throws #_"DeterministicUpgradeRequiresPassword")
    (§ block
        (§ expr maybeUpgradeToHD(§ pars nil))
        (§ void nil)
    )

    #_guarded-by(§ opt "keyChainGroupLock")
    #_private
    (§ method #_"void" (§ fn maybeUpgradeToHD) [#_nilable #_"KeyParameter" (§ name aesKey)])
        (§ throws #_"DeterministicUpgradeRequiresPassword")
    (§ block
        (§ expr Preconditions/checkState(§ pars keyChainGroupLock.isHeldByCurrentThread(§ pars )))
        (§ if (§ expr keyChainGroup.isDeterministicUpgradeRequired(§ pars )))
        (§ block
            (§ expr log.info(§ pars "Upgrade to HD wallets is required, attempting to do so."))
            (§ try )
            (§ block
                (§ expr upgradeToDeterministic(§ pars aesKey))
            )
            (§ catch #_"DeterministicUpgradeRequiresPassword" (§ name e))
            (§ block
                (§ expr log.error(§ pars "Failed to auto upgrade due to encryption. You should call wallet.upgradeToDeterministic with the users AES key to avoid this error."))
                (§ throw e)
            )
        )
        (§ void nil)
    )

    ;;;
     ; Removes the given key from the basicKeyChain.  Be very careful with this - losing a private key
     ; <b>destroys the money associated with it</b>.
     ; @return whether the key was removed or not.
     ;;
    #_public
    (§ method #_"boolean" (§ fn removeKey) [#_"ECKey" (§ name key)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr keyChainGroup.removeImportedKey(§ pars key)))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the number of keys in the key chain group, including lookahead keys.
     ;;
    #_public
    (§ method #_"int" (§ fn getKeyChainGroupSize) [])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr keyChainGroup.numKeys(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    #_testing
    #_public
    (§ method #_"int" (§ fn getKeyChainGroupCombinedKeyLookaheadEpochs) [])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr keyChainGroup.getCombinedKeyLookaheadEpochs(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a list of the non-deterministic keys that have been imported into the wallet, or the empty list if none.
     ;;
    #_public
    (§ method #_"List<ECKey>" (§ fn getImportedKeys) [])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr keyChainGroup.getImportedKeys(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; Returns the address used for change outputs.  Note: this will probably go away in future. ;;
    #_public
    (§ method #_"Address" (§ fn currentChangeAddress) [])
    (§ block
        (§ return (§ expr currentAddress(§ pars KeyChain/KeyPurpose/CHANGE)))
    )

    ;;;
     ; <p>Imports the given ECKey to the wallet.</p>
     ;
     ; <p>If the wallet is configured to auto save to a file, triggers a save immediately.  Runs the onKeysAdded event
     ; handler.  If the key already exists in the wallet, does nothing and returns false.</p>
     ;;
    #_public
    (§ method #_"boolean" (§ fn importKey) [#_"ECKey" (§ name key)])
    (§ block
        (§ return (§ expr importKeys(§ pars Lists/newArrayList(§ pars key)) == 1))
    )

    ;;;
     ; Imports the given keys to the wallet.
     ; If {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, org.bitcoinj.wallet.WalletFiles.Listener)}
     ; has been called, triggers an auto save bypassing the normal coalescing delay and event handlers.
     ; Returns the number of keys added, after duplicates are ignored.  The onKeyAdded event will be called
     ; for each key in the list that was not already present.
     ;;
    #_public
    (§ method #_"int" (§ fn importKeys) [#_final #_"List<ECKey>" (§ name keys)])
    (§ block
        ;; API usage check.
        (§ expr checkNoDeterministicKeys(§ pars keys))
        (§ var #_"int" (§ name result))
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name result) (§ expr keyChainGroup.importKeys(§ pars keys)))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
        (§ expr saveNow(§ pars ))
        (§ return result)
    )

    #_private
    (§ method #_"void" (§ fn checkNoDeterministicKeys) [#_"List<ECKey>" (§ name keys)])
    (§ block
        ;; Watch out for someone doing wallet.importKey(wallet.freshReceiveKey()); or equivalent: we never tested this.
        (§ for (§ var #_"ECKey" (§ name key)) :for keys)
        (§ block
            (§ if (§ insta key #_"DeterministicKey"))
            (§ block
                (§ throw (§ new #_"IllegalArgumentException" (§ pars "Cannot import HD keys back into the wallet")))
            )
        )
        (§ void nil)
    )

    ;;; Takes a list of keys and a password, then encrypts and imports them in one step using the current keycrypter. ;;
    #_public
    (§ method #_"int" (§ fn importKeysAndEncrypt) [#_final #_"List<ECKey>" (§ name keys), #_"CharSequence" (§ name password)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr Preconditions/checkNotNull(§ pars getKeyCrypter(§ pars ), "Wallet is not encrypted"))
            (§ return (§ expr importKeysAndEncrypt(§ pars keys, getKeyCrypter(§ pars ).deriveKey(§ pars password))))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; Takes a list of keys and an AES key, then encrypts and imports them in one step using the current keycrypter. ;;
    #_public
    (§ method #_"int" (§ fn importKeysAndEncrypt) [#_final #_"List<ECKey>" (§ name keys), #_"KeyParameter" (§ name aesKey)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr checkNoDeterministicKeys(§ pars keys))
            (§ return (§ expr keyChainGroup.importKeysAndEncrypt(§ pars keys, aesKey)))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Add a pre-configured keychain to the wallet.  Useful for setting up a complex keychain,
     ; such as for a married wallet.  For example:
     ; <pre>
     ; MarriedKeyChain chain = MarriedKeyChain.builder()
     ;     .random(new SecureRandom())
     ;     .followingKeys(followingKeys)
     ;     .threshold(2).build();
     ; wallet.addAndActivateHDChain(chain);
     ; </p>
     ;;
    #_public
    (§ method #_"void" (§ fn addAndActivateHDChain) [#_"DeterministicKeyChain" (§ name chain)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr keyChainGroup.addAndActivateHDChain(§ pars chain))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadSize(int)} for more info on this. ;;
    #_public
    (§ method #_"void" (§ fn setKeyChainGroupLookaheadSize) [#_"int" (§ name lookaheadSize)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr keyChainGroup.setLookaheadSize(§ pars lookaheadSize))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadSize(int)} for more info on this. ;;
    #_public
    (§ method #_"int" (§ fn getKeyChainGroupLookaheadSize) [])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr keyChainGroup.getLookaheadSize(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadThreshold(int)} for more info on this. ;;
    #_public
    (§ method #_"void" (§ fn setKeyChainGroupLookaheadThreshold) [#_"int" (§ name num)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr maybeUpgradeToHD(§ pars ))
            (§ expr keyChainGroup.setLookaheadThreshold(§ pars num))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;; See {@link org.bitcoinj.wallet.DeterministicKeyChain#setLookaheadThreshold(int)} for more info on this. ;;
    #_public
    (§ method #_"int" (§ fn getKeyChainGroupLookaheadThreshold) [])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr maybeUpgradeToHD(§ pars ))
            (§ return (§ expr keyChainGroup.getLookaheadThreshold(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a public-only DeterministicKey that can be used to set up a watching wallet: that is, a wallet that
     ; can import transactions from the block chain just as the normal wallet can, but which cannot spend.  Watching
     ; wallets are very useful for things like web servers that accept payments.  This key corresponds to the account
     ; zero key in the recommended BIP32 hierarchy.
     ;;
    #_public
    (§ method #_"DeterministicKey" (§ fn getWatchingKey) [])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr maybeUpgradeToHD(§ pars ))
            (§ return (§ expr keyChainGroup.getActiveKeyChain(§ pars ).getWatchingKey(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns whether this wallet consists entirely of watching keys (unencrypted keys with no private part).
     ; Mixed wallets are forbidden.
     ;
     ; @throws IllegalStateException if there are no keys, or if there is a mix between watching and non-watching keys.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isWatching) [])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr maybeUpgradeToHD(§ pars ))
            (§ return (§ expr keyChainGroup.isWatching(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Locates a keypair from the basicKeyChain given the hash of the public key.  This is needed when finding out
     ; which key we need to use to redeem a transaction output.
     ;
     ; @return ECKey object or null if no such key was found.
     ;;
    #_override
    #_nilable
    #_public
    (§ method #_"ECKey" (§ fn findKeyFromPubHash) [#_"byte[]" (§ name pubkeyHash)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr keyChainGroup.findKeyFromPubHash(§ pars pubkeyHash)))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; Returns true if the given key is in the wallet, false otherwise.  Currently an O(N) operation. ;;
    #_public
    (§ method #_"boolean" (§ fn hasKey) [#_"ECKey" (§ name key)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr keyChainGroup.hasKey(§ pars key)))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (§ method #_"boolean" (§ fn isPubKeyHashMine) [#_"byte[]" (§ name pubkeyHash)])
    (§ block
        (§ return (§ expr findKeyFromPubHash(§ pars pubkeyHash) != nil))
    )

    ;;;
     ; Locates a keypair from the basicKeyChain given the raw public key bytes.
     ; @return ECKey or null if no such key was found.
     ;;
    #_override
    #_nilable
    #_public
    (§ method #_"ECKey" (§ fn findKeyFromPubKey) [#_"byte[]" (§ name pubkey)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr keyChainGroup.findKeyFromPubKey(§ pars pubkey)))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (§ method #_"boolean" (§ fn isPubKeyMine) [#_"byte[]" (§ name pubkey)])
    (§ block
        (§ return (§ expr findKeyFromPubKey(§ pars pubkey) != nil))
    )

    ;;;
     ; Locates a redeem data (redeem script and keys) from the keyChainGroup given the hash of the script.
     ; @return RedeemData object or null if no such data was found.
     ;;
    #_nilable
    #_override
    #_public
    (§ method #_"RedeemData" (§ fn findRedeemDataFromScriptHash) [#_"byte[]" (§ name payToScriptHash)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr keyChainGroup.findRedeemDataFromScriptHash(§ pars payToScriptHash)))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (§ method #_"boolean" (§ fn isPayToScriptHashMine) [#_"byte[]" (§ name payToScriptHash)])
    (§ block
        (§ return (§ expr findRedeemDataFromScriptHash(§ pars payToScriptHash) != nil))
    )

    ;;;
     ; Marks all keys used in the transaction output as used in the wallet.
     ; See {@link org.bitcoinj.wallet.DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_private
    (§ method #_"void" (§ fn markKeysAsUsed) [#_"Transaction" (§ name tx)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ for (§ var #_"TransactionOutput" (§ name o)) :for (§ expr tx.getOutputs(§ pars )))
            (§ block
                (§ try )
                (§ block
                    (§ var #_"Script" (§ name script) (§ expr o.getScriptPubKey(§ pars )))
                    (§ if (§ expr script.isSentToRawPubKey(§ pars )))
                    (§ block
                        (§ var #_"byte[]" (§ name pubkey) (§ expr script.getPubKey(§ pars )))
                        (§ expr keyChainGroup.markPubKeyAsUsed(§ pars pubkey))
                    )
                    (§ elseif (§ expr script.isSentToAddress(§ pars )))
                    (§ block
                        (§ var #_"byte[]" (§ name pubkeyHash) (§ expr script.getPubKeyHash(§ pars )))
                        (§ expr keyChainGroup.markPubKeyHashAsUsed(§ pars pubkeyHash))
                    )
                    (§ elseif (§ expr script.isPayToScriptHash(§ pars )))
                    (§ block
                        (§ var #_"Address" (§ name a) (§ expr Address/fromP2SHScript(§ pars tx.getParams(§ pars ), script)))
                        (§ expr keyChainGroup.markP2SHAddressAsUsed(§ pars a))
                    )
                )
                (§ catch #_"ScriptException" (§ name e))
                (§ block
                    ;; Just means we didn't understand the output of this transaction: ignore it.
                    (§ expr log.warn(§ pars "Could not parse tx output script: {}", e.toString(§ pars )))
                )
            )
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Returns the immutable seed for the current active HD chain.
     ; @throws org.bitcoinj.core.ECKey.MissingPrivateKeyException if the seed is unavailable (watching wallet).
     ;;
    #_public
    (§ method #_"DeterministicSeed" (§ fn getKeyChainSeed) [])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"DeterministicSeed" (§ name seed) (§ expr keyChainGroup.getActiveKeyChain(§ pars ).getSeed(§ pars )))
            (§ if (§ expr seed == nil))
            (§ block
                (§ throw (§ new #_"ECKey.MissingPrivateKeyException" (§ pars )))
            )
            (§ return seed)
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a key for the given HD path, assuming it's already been derived.  You normally shouldn't use this:
     ; use currentReceiveKey/freshReceiveKey instead.
     ;;
    #_public
    (§ method #_"DeterministicKey" (§ fn getKeyByPath) [#_"List<ChildNumber>" (§ name path)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr maybeUpgradeToHD(§ pars ))
            (§ return (§ expr keyChainGroup.getActiveKeyChain(§ pars ).getKeyByPath(§ pars path, false)))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Convenience wrapper around
     ; {@link Wallet#encrypt(org.bitcoinj.crypto.KeyCrypter, org.spongycastle.crypto.params.KeyParameter)}
     ; which uses the default Scrypt key derivation algorithm and parameters to derive a key from the given password.
     ;;
    #_public
    (§ method #_"void" (§ fn encrypt) [#_"CharSequence" (§ name password)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            #_final
            (§ var #_"KeyCrypterScrypt" (§ name scrypt) (§ new #_"KeyCrypterScrypt" (§ pars )))
            (§ expr keyChainGroup.encrypt(§ pars scrypt, scrypt.deriveKey(§ pars password)))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
        (§ expr saveNow(§ pars ))
        (§ void nil)
    )

    ;;;
     ; Encrypt the wallet using the KeyCrypter and the AES key.
     ; A good default KeyCrypter to use is {@link org.bitcoinj.crypto.KeyCrypterScrypt}.
     ;
     ; @param keyCrypter The KeyCrypter that specifies how to encrypt/ decrypt a key.
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming to create from a password).
     ; @throws KeyCrypterException if the wallet encryption fails.  If so, the wallet state is unchanged.
     ;;
    #_public
    (§ method #_"void" (§ fn encrypt) [#_"KeyCrypter" (§ name keyCrypter), #_"KeyParameter" (§ name aesKey)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr keyChainGroup.encrypt(§ pars keyCrypter, aesKey))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
        (§ expr saveNow(§ pars ))
        (§ void nil)
    )

    ;;;
     ; Decrypt the wallet with the wallets keyCrypter and password.
     ; @throws KeyCrypterException if the wallet decryption fails.  If so, the wallet state is unchanged.
     ;;
    #_public
    (§ method #_"void" (§ fn decrypt) [#_"CharSequence" (§ name password)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            #_final
            (§ var #_"KeyCrypter" (§ name crypter) (§ expr keyChainGroup.getKeyCrypter(§ pars )))
            (§ expr Preconditions/checkState(§ pars crypter != nil, "Not encrypted"))
            (§ expr keyChainGroup.decrypt(§ pars crypter.deriveKey(§ pars password)))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
        (§ expr saveNow(§ pars ))
        (§ void nil)
    )

    ;;;
     ; Decrypt the wallet with the wallets keyCrypter and AES key.
     ;
     ; @param aesKey AES key to use (normally created using KeyCrypter#deriveKey and cached as it is time consuming to create from a password).
     ; @throws KeyCrypterException if the wallet decryption fails. If so, the wallet state is unchanged.
     ;;
    #_public
    (§ method #_"void" (§ fn decrypt) [#_"KeyParameter" (§ name aesKey)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr keyChainGroup.decrypt(§ pars aesKey))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
        (§ expr saveNow(§ pars ))
        (§ void nil)
    )

    ;;;
     ;  Check whether the password can decrypt the first key in the wallet.
     ;  This can be used to check the validity of an entered password.
     ;
     ;  @return true if the password supplied can decrypt the first private key in the wallet, false otherwise.
     ;  @throws IllegalStateException if the wallet is not encrypted.
     ;;
    #_public
    (§ method #_"boolean" (§ fn checkPassword) [#_"CharSequence" (§ name password)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr keyChainGroup.checkPassword(§ pars password)))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ;  Check whether the AES key can decrypt the first encrypted key in the wallet.
     ;
     ;  @return true if AES key supplied can decrypt the first encrypted private key in the wallet, false otherwise.
     ;;
    #_public
    (§ method #_"boolean" (§ fn checkAESKey) [#_"KeyParameter" (§ name aesKey)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr keyChainGroup.checkAESKey(§ pars aesKey)))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Get the wallet's KeyCrypter, or null if the wallet is not encrypted.
     ; (Used in encrypting/decrypting an ECKey).
     ;;
    #_nilable
    #_public
    (§ method #_"KeyCrypter" (§ fn getKeyCrypter) [])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr keyChainGroup.getKeyCrypter(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;;
     ; Get the type of encryption used for this wallet.
     ;
     ; (This is a convenience method - the encryption type is actually stored in the keyCrypter).
     ;;
    #_public
    (§ method #_"EncryptionType" (§ fn getEncryptionType) [])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"KeyCrypter" (§ name crypter) (§ expr keyChainGroup.getKeyCrypter(§ pars )))
            (§ return (§ quest (§ expr crypter != nil) ? (§ expr crypter.getUnderstoodEncryptionType(§ pars )) :else (§ expr EncryptionType/UNENCRYPTED)))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; Returns true if the wallet is encrypted using any scheme, false if not. ;;
    #_public
    (§ method #_"boolean" (§ fn isEncrypted) [])
    (§ block
        (§ return (§ expr getEncryptionType(§ pars ) != EncryptionType/UNENCRYPTED))
    )

    ;;; Changes wallet encryption password, this is atomic operation. ;;
    #_public
    (§ method #_"void" (§ fn changeEncryptionPassword) [#_"CharSequence" (§ name currentPassword), #_"CharSequence" (§ name newPassword)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr decrypt(§ pars currentPassword))
            (§ expr encrypt(§ pars newPassword))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;; Changes wallet AES encryption key, this is atomic operation. ;;
    #_public
    (§ method #_"void" (§ fn changeEncryptionKey) [#_"KeyCrypter" (§ name keyCrypter), #_"KeyParameter" (§ name currentAesKey), #_"KeyParameter" (§ name newAesKey)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr decrypt(§ pars currentAesKey))
            (§ expr encrypt(§ pars keyCrypter, newAesKey))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;; TODO: Make this package private once the classes finish moving around.
    ;;; Internal use only. ;;
    #_public
    (§ method #_"List<Protos.Key>" (§ fn serializeKeyChainGroupToProtobuf) [])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr keyChainGroup.serializeToProtobuf(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; Saves the wallet first to the given temp file, then renames to the dest file. ;;
    #_public
    (§ method #_"void" (§ fn saveToFile) [#_"File" (§ name temp), #_"File" (§ name destFile)])
        (§ throws #_"IOException")
    (§ block
        (§ var #_"FileOutputStream" (§ name stream) nil)
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name stream) (§ new #_"FileOutputStream" (§ pars temp)))
            (§ expr saveToFileStream(§ pars stream))
            ;; Attempt to force the bits to hit the disk.  In reality the OS or hard disk itself may still decide
            ;; to not write through to physical media for at least a few seconds, but this is the best we can do.
            (§ expr stream.flush(§ pars ))
            (§ expr stream.getFD(§ pars ).sync(§ pars ))
            (§ expr stream.close(§ pars ))
            (§ ass (§ name stream) nil)
            (§ if (§ expr Utils/isWindows(§ pars )))
            (§ block
                ;; Work around an issue on Windows whereby you can't rename over existing files.
                (§ var #_"File" (§ name canonical) (§ expr destFile.getCanonicalFile(§ pars )))
                (§ if (§ expr canonical.exists(§ pars ) && (§ not canonical.delete(§ pars ))))
                (§ block
                    (§ throw (§ new #_"IOException" (§ pars "Failed to delete canonical wallet file for replacement with autosave")))
                )
                (§ if (§ expr temp.renameTo(§ pars canonical)))
                (§ block
                    (§ return nil) ;; else fall through
                )
                (§ throw (§ new #_"IOException" (§ pars "Failed to rename " + temp + " to " + canonical)))
            )
            (§ elseif (§ expr (§ not temp.renameTo(§ pars destFile))))
            (§ block
                (§ throw (§ new #_"IOException" (§ pars "Failed to rename " + temp + " to " + destFile)))
            )
        )
        (§ catch #_"RuntimeException" (§ name e))
        (§ block
            (§ expr log.error(§ pars "Failed whilst saving wallet", e))
            (§ throw e)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
            (§ if (§ expr stream != nil))
            (§ block
                (§ expr stream.close(§ pars ))
            )
            (§ if (§ expr temp.exists(§ pars )))
            (§ block
                (§ expr log.warn(§ pars "Temp file still exists after failed save."))
            )
        )
        (§ void nil)
    )

    ;;;
     ; Uses protobuf serialization to save the wallet to the given file.  To learn more about this file format, see
     ; {@link WalletProtobufSerializer}.  Writes out first to a temporary file in the same directory and then renames
     ; once written.
     ;;
    #_public
    (§ method #_"void" (§ fn saveToFile) [#_"File" (§ name f)])
        (§ throws #_"IOException")
    (§ block
        (§ var #_"File" (§ name directory) (§ expr f.getAbsoluteFile(§ pars ).getParentFile(§ pars )))
        (§ var #_"File" (§ name temp) (§ expr File/createTempFile(§ pars "wallet", nil, directory)))
        (§ expr saveToFile(§ pars temp, f))
        (§ void nil)
    )

    ;;;
     ; <p>Whether or not the wallet will ignore pending transactions that fail the selected {@link RiskAnalysis}.
     ; By default, if a transaction is considered risky then it won't enter the wallet and won't trigger any event
     ; listeners.  If you set this property to true, then all transactions will be allowed in regardless of risk.
     ; For example, the {@link DefaultRiskAnalysis} checks for non-finality of transactions.</p>
     ;
     ; <p>Note that this property is not serialized.  You have to set it each time a Wallet object is constructed,
     ; even if it's loaded from a protocol buffer.</p>
     ;;
    #_public
    (§ method #_"void" (§ fn setAcceptRiskyTransactions) [#_"boolean" (§ name acceptRiskyTransactions)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name this.acceptRiskyTransactions) acceptRiskyTransactions)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; See {@link Wallet#setAcceptRiskyTransactions(boolean)} for an explanation of this property.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isAcceptRiskyTransactions) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return acceptRiskyTransactions)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Sets the {@link RiskAnalysis} implementation to use for deciding whether received pending transactions are
     ; risky or not.  If the analyzer says a transaction is risky, by default it will be dropped. You can customize
     ; this behaviour with {@link #setAcceptRiskyTransactions(boolean)}.
     ;;
    #_public
    (§ method #_"void" (§ fn setRiskAnalyzer) [#_"RiskAnalysis.Analyzer" (§ name analyzer)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name this.riskAnalyzer) (§ expr Preconditions/checkNotNull(§ pars analyzer)))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Gets the current {@link RiskAnalysis} implementation.  The default is {@link DefaultRiskAnalysis}.
     ;;
    #_public
    (§ method #_"RiskAnalysis.Analyzer" (§ fn getRiskAnalyzer) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return riskAnalyzer)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; <p>Sets up the wallet to auto-save itself to the given file, using temp files with atomic renames to ensure
     ; consistency.  After connecting to a file, you no longer need to save the wallet manually, it will do it
     ; whenever necessary.  Protocol buffer serialization will be used.</p>
     ;
     ; <p>If delayTime is set, a background thread will be created and the wallet will only be saved to disk
     ; every so many time units.  If no changes have occurred for the given time period, nothing will be written.
     ; In this way disk IO can be rate limited.  It's a good idea to set this as otherwise the wallet can change very
     ; frequently, e.g. if there are a lot of transactions in it or during block sync, and there will be a lot of redundant
     ; writes.  Note that when a new key is added, that always results in an immediate save regardless of delayTime.
     ; <b>You should still save the wallet manually when your program is about to shut down as the JVM will not
     ; wait for the background thread.</b></p>
     ;
     ; <p>An event listener can be provided.  If a delay >0 was specified, it will be called on a background thread
     ; with the wallet locked when an auto-save occurs.  If delay is zero or you do something that always triggers
     ; an immediate save, like adding a key, the event listener will be invoked on the calling threads.</p>
     ;
     ; @param f The destination file to save to.
     ; @param delayTime How many time units to wait until saving the wallet on a background thread.
     ; @param timeUnit The unit of measurement for delayTime.
     ; @param eventListener Callback to be informed when the auto-save thread does things, or null.
     ;;
    #_public
    (§ method #_"WalletFiles" (§ fn autosaveToFile) [#_"File" (§ name f), #_"long" (§ name delayTime), #_"TimeUnit" (§ name timeUnit), #_nilable #_"WalletFiles.Listener" (§ name eventListener)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr Preconditions/checkState(§ pars vFileManager == nil, "Already auto saving this wallet."))
            (§ var #_"WalletFiles" (§ name manager) (§ new #_"WalletFiles" (§ pars this, f, delayTime, timeUnit)))
            (§ if (§ expr eventListener != nil))
            (§ block
                (§ expr manager.setListener(§ pars eventListener))
            )
            (§ ass (§ name vFileManager) manager)
            (§ return manager)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Disables auto-saving, after it had been enabled with
     ; {@link Wallet#autosaveToFile(java.io.File, long, java.util.concurrent.TimeUnit, org.bitcoinj.wallet.WalletFiles.Listener)}
     ; before.  This method blocks until finished.
     ;;
    #_public
    (§ method #_"void" (§ fn shutdownAutosaveAndWait) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"WalletFiles" (§ name files) vFileManager)
            (§ ass (§ name vFileManager) nil)
            (§ expr Preconditions/checkState(§ pars files != nil, "Auto saving not enabled."))
            (§ expr files.shutdownAndWait(§ pars ))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;; Requests an asynchronous save on a background thread. ;;
    #_protected
    (§ method #_"void" (§ fn saveLater) [])
    (§ block
        (§ var #_"WalletFiles" (§ name files) vFileManager)
        (§ if (§ expr files != nil))
        (§ block
            (§ expr files.saveLater(§ pars ))
        )
        (§ void nil)
    )

    ;;; If auto saving is enabled, do an immediate sync write to disk ignoring any delays. ;;
    #_protected
    (§ method #_"void" (§ fn saveNow) [])
    (§ block
        (§ var #_"WalletFiles" (§ name files) vFileManager)
        (§ if (§ expr files != nil))
        (§ block
            (§ try )
            (§ block
                (§ expr files.saveNow(§ pars )) ;; This calls back into saveToFile().
            )
            (§ catch #_"IOException" (§ name e))
            (§ block
                ;; Can't really do much at this point, just let the API user know.
                (§ expr log.error(§ pars "Failed to save wallet to disk!", e))
                (§ var #_"Thread.UncaughtExceptionHandler" (§ name handler) (§ expr Threading.uncaughtExceptionHandler))
                (§ if (§ expr handler != nil))
                (§ block
                    (§ expr handler.uncaughtException(§ pars Thread/currentThread(§ pars ), e))
                )
            )
        )
        (§ void nil)
    )

    ;;;
     ; Uses protobuf serialization to save the wallet to the given file stream.
     ; To learn more about this file format, see {@link WalletProtobufSerializer}.
     ;;
    #_public
    (§ method #_"void" (§ fn saveToFileStream) [#_"OutputStream" (§ name f)])
        (§ throws #_"IOException")
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr (§ new #_"WalletProtobufSerializer" (§ pars )).writeWallet(§ pars this, f))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;; Returns the parameters this wallet was created with. ;;
    #_public
    (§ method #_"NetworkParameters" (§ fn getParams) [])
    (§ block
        (§ return params)
    )

    ;;; Returns the API context that this wallet was created with. ;;
    #_public
    (§ method #_"Context" (§ fn getContext) [])
    (§ block
        (§ return context)
    )

    ;;;
     ; Returns a wallet deserialized from the given file.
     ;
     ; @param file The wallet file to be read.
     ;;
    #_public
    #_static
    (§ method #_"Wallet" (§ fn loadFromFile) [#_"File" (§ name file)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        (§ try )
        (§ block
            (§ var #_"FileInputStream" (§ name stream) nil)
            (§ try )
            (§ block
                (§ ass (§ name stream) (§ new #_"FileInputStream" (§ pars file)))
                (§ return (§ expr loadFromFileStream(§ pars stream)))
            )
            (§ finally )
            (§ block
                (§ if (§ expr stream != nil))
                (§ block
                    (§ expr stream.close(§ pars ))
                )
            )
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"UnreadableWalletException" (§ pars "Could not open file", e)))
        )
    )

    ;;;
     ; Returns if this wallet is structurally consistent, so e.g. no duplicate transactions.
     ; First inconsistency and a dump of the wallet will be logged.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isConsistent) [])
    (§ block
        (§ try )
        (§ block
            (§ expr isConsistentOrThrow(§ pars ))
            (§ return true)
        )
        (§ catch #_"IllegalStateException" (§ name e1))
        (§ block
            (§ expr log.error(§ pars e1.getMessage(§ pars )))
            (§ try )
            (§ block
                (§ expr log.error(§ pars toString(§ pars )))
            )
            (§ catch #_"RuntimeException" (§ name e2))
            (§ block
                (§ expr log.error(§ pars "Printing inconsistent wallet failed", e2))
            )
            (§ return false)
        )
    )

    ;;;
     ; Variant of {@link Wallet#isConsistent()} that throws an {@link IllegalStateException} describing
     ; the first inconsistency.
     ;;
    #_public
    (§ method #_"void" (§ fn isConsistentOrThrow) [])
        (§ throws #_"IllegalStateException")
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"Set<Transaction>" (§ name transactions) (§ expr getTransactions(§ pars true)))

            (§ var #_"Set<Sha256Hash>" (§ name hashes) (§ new #_"HashSet<>" (§ pars )))
            (§ for (§ var #_"Transaction" (§ name tx)) :for transactions)
            (§ block
                (§ expr hashes.add(§ pars tx.getHash(§ pars )))
            )

            (§ var #_"int" (§ name size1) (§ expr transactions.size(§ pars )))
            (§ if (§ expr size1 != hashes.size(§ pars )))
            (§ block
                (§ throw (§ new #_"IllegalStateException" (§ pars "Two transactions with same hash")))
            )

            (§ var #_"int" (§ name size2) (§ expr unspent.size(§ pars ) + spent.size(§ pars ) + pending.size(§ pars ) + dead.size(§ pars )))
            (§ if (§ expr size1 != size2))
            (§ block
                (§ throw (§ new #_"IllegalStateException" (§ pars "Inconsistent wallet sizes: " + size1 + ", " + size2)))
            )

            (§ for (§ var #_"Transaction" (§ name tx)) :for (§ expr unspent.values(§ pars )))
            (§ block
                (§ if (§ expr (§ not isTxConsistent(§ pars tx, false))))
                (§ block
                    (§ throw (§ new #_"IllegalStateException" (§ pars "Inconsistent unspent tx: " + tx.getHashAsString(§ pars ))))
                )
            )

            (§ for (§ var #_"Transaction" (§ name tx)) :for (§ expr spent.values(§ pars )))
            (§ block
                (§ if (§ expr (§ not isTxConsistent(§ pars tx, true))))
                (§ block
                    (§ throw (§ new #_"IllegalStateException" (§ pars "Inconsistent spent tx: " + tx.getHashAsString(§ pars ))))
                )
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;; If isSpent, check that all my outputs spent, otherwise check that there at least one unspent.
    #_testing
    (§ method #_"boolean" (§ fn isTxConsistent) [#_final #_"Transaction" (§ name tx), #_final #_"boolean" (§ name isSpent)])
    (§ block
        (§ var #_"boolean" (§ name isActuallySpent) true)
        (§ for (§ var #_"TransactionOutput" (§ name o)) :for (§ expr tx.getOutputs(§ pars )))
        (§ block
            (§ if (§ expr o.isAvailableForSpending(§ pars )))
            (§ block
                (§ if (§ expr o.isMine(§ pars this)))
                (§ block
                    (§ ass (§ name isActuallySpent) false)
                )
                (§ if (§ expr o.getSpentBy(§ pars ) != nil))
                (§ block
                    (§ expr log.error(§ pars "isAvailableForSpending != spentBy"))
                    (§ return false)
                )
            )
            (§ else )
            (§ block
                (§ if (§ expr o.getSpentBy(§ pars ) == nil))
                (§ block
                    (§ expr log.error(§ pars "isAvailableForSpending != spentBy"))
                    (§ return false)
                )
            )
        )
        (§ return (§ expr isActuallySpent == isSpent))
    )

    ;;; Returns a wallet deserialized from the given input stream. ;;
    #_public
    #_static
    (§ method #_"Wallet" (§ fn loadFromFileStream) [#_"InputStream" (§ name stream)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        (§ var #_"Wallet" (§ name wallet) (§ expr (§ new #_"WalletProtobufSerializer" (§ pars )).readWallet(§ pars stream)))
        (§ if (§ expr (§ not wallet.isConsistent(§ pars ))))
        (§ block
            (§ expr log.error(§ pars "Loaded an inconsistent wallet"))
        )
        (§ return wallet)
    )

    ;;;
     ; Called by the {@link BlockChain} when we receive a new filtered block that contains a transactions previously
     ; received by a call to {@link #receivePending}.
     ;
     ; This is necessary for the internal book-keeping Wallet does.  When a transaction is received that sends us
     ; coins it is added to a pool so we can use it later to create spends.  When a transaction is received that
     ; consumes outputs they are marked as spent so they won't be used in future.
     ;
     ; A transaction that spends our own coins can be received either because a spend we created was accepted by
     ; the network and thus made it into a block, or because our keys are being shared between multiple instances
     ; and some other node spent the coins instead.  We still have to know about that to avoid accidentally trying
     ; to double spend.
     ;
     ; A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.  We must still record these transactions and the blocks they appear in because a future
     ; block might change which chain is best causing a reorganize.  A re-org can totally change our balance!
     ;;
    #_override
    #_public
    (§ method #_"boolean" (§ fn notifyTransactionIsInBlock) [#_"Sha256Hash" (§ name txHash), #_"StoredBlock" (§ name block), #_"BlockChain.NewBlockType" (§ name blockType), #_"int" (§ name relativityOffset)])
        (§ throws #_"VerificationException")
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"Transaction" (§ name tx) (§ expr transactions.get(§ pars txHash)))
            (§ if (§ expr tx == nil))
            (§ block
                (§ ass (§ name tx) (§ expr riskDropped.get(§ pars txHash)))
                (§ if (§ expr tx != nil))
                (§ block
                    ;; If this happens our risk analysis is probably wrong and should be improved.
                    (§ expr log.info(§ pars "Risk analysis dropped tx {} but was included in block anyway", tx.getHash(§ pars )))
                )
                (§ else )
                (§ block
                    ;; False positive that was broadcast to us and ignored by us because it was irrelevant to our keys.
                    (§ return false)
                )
            )
            (§ expr receive(§ pars tx, block, blockType, relativityOffset))
            (§ return true)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; <p>Called when we have found a transaction (via network broadcast or otherwise) that is relevant to this wallet
     ; and want to record it.  Note that we <b>cannot verify these transactions at all</b>, they may spend fictional
     ; coins or be otherwise invalid.  They are useful to inform the user about coins they can expect to receive soon,
     ; and if you trust the sender of the transaction you can choose to assume they are in fact valid and will not
     ; be double spent as an optimization.</p>
     ;
     ; <p>This is the same as {@link Wallet#receivePending(Transaction, java.util.List)} but allows you to override the
     ; {@link Wallet#isPendingTransactionRelevant(Transaction)} sanity-check to keep track of transactions that are not
     ; spendable or spend our coins.  This can be useful when you want to keep track of transaction confidence on
     ; arbitrary transactions.  Note that transactions added in this way will still be relayed to peers and appear in
     ; transaction lists like any other pending transaction (even when not relevant).</p>
     ;;
    #_public
    (§ method #_"void" (§ fn receivePending) [#_"Transaction" (§ name tx), #_nilable #_"List<Transaction>" (§ name dependencies), #_"boolean" (§ name overrideIsRelevant)])
        (§ throws #_"VerificationException")
    (§ block
        ;; Can run in a peer thread.  This method will only be called if a prior call to isPendingTransactionRelevant
        ;; returned true, so we already know by this point that it sends coins to or from our wallet, or is a double
        ;; spend against one of our other pending transactions.
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr tx.verify(§ pars ))
            ;; Ignore it if we already know about this transaction.  Receiving a pending transaction never moves it
            ;; between pools.
            (§ var #_"EnumSet<Pool>" (§ name containingPools) (§ expr getContainingPools(§ pars tx)))
            (§ if (§ expr (§ not containingPools.equals(§ pars EnumSet/noneOf(§ pars (§ klass #_"Pool"))))))
            (§ block
                (§ expr log.debug(§ pars "Received tx we already saw in a block or created ourselves: " + tx.getHashAsString(§ pars )))
                (§ return nil)
            )
            ;; Repeat the check of relevancy here, even though the caller may have already done so - this is to avoid
            ;; race conditions where receivePending may be being called in parallel.
            (§ if (§ expr (§ not overrideIsRelevant) && (§ not isPendingTransactionRelevant(§ pars tx))))
            (§ block
                (§ return nil)
            )

            (§ if (§ expr isTransactionRisky(§ pars tx, dependencies) && (§ not acceptRiskyTransactions)))
            (§ block
                ;; isTransactionRisky already logged the reason.
                (§ expr riskDropped.put(§ pars tx.getHash(§ pars ), tx))
                (§ expr log.warn(§ pars "There are now {} risk dropped transactions being kept in memory", riskDropped.size(§ pars )))
                (§ return nil)
            )

            (§ var #_"Coin" (§ name valueSentToMe) (§ expr tx.getValueSentToMe(§ pars this)))
            (§ var #_"Coin" (§ name valueSentFromMe) (§ expr tx.getValueSentFromMe(§ pars this)))
            (§ if (§ expr log.isInfoEnabled(§ pars )))
            (§ block
                (§ expr log.info(§ pars String/format(§ pars Locale/US, "Received a pending transaction %s that spends %s from our own wallet, and sends us %s", tx.getHashAsString(§ pars ), valueSentFromMe.toFriendlyString(§ pars ), valueSentToMe.toFriendlyString(§ pars ))))
            )
            (§ if (§ expr tx.getConfidence(§ pars ).getSource(§ pars ).equals(§ pars TransactionConfidence/Source/UNKNOWN)))
            (§ block
                (§ expr log.warn(§ pars "Wallet received transaction with an unknown source. Consider tagging it!"))
            )
            ;; If this tx spends any of our unspent outputs, mark them as spent now, then add to the pending pool.  This
            ;; ensures that if some other client that has our keys broadcasts a spend we stay in sync.  Also updates the
            ;; timestamp on the transaction and registers/runs event listeners.
            (§ expr commitTx(§ pars tx))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        ;; maybeRotateKeys() will ignore pending transactions, so we don't bother calling it here (see the comments
        ;; in that function for an explanation of why).
        (§ void nil)
    )

    ;;;
     ; Given a transaction and an optional list of dependencies (recursive/flattened), returns true if the given
     ; transaction would be rejected by the analyzer, or false otherwise.  The result of this call is independent
     ; of the value of {@link #isAcceptRiskyTransactions()}.  Risky transactions yield a logged warning.  If you
     ; want to know the reason why a transaction is risky, create an instance of the {@link RiskAnalysis} yourself
     ; using the factory returned by {@link #getRiskAnalyzer()} and use it directly.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isTransactionRisky) [#_"Transaction" (§ name tx), #_nilable #_"List<Transaction>" (§ name dependencies)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr dependencies == nil))
            (§ block
                (§ ass (§ name dependencies) (§ expr ImmutableList/of(§ pars )))
            )
            (§ var #_"RiskAnalysis" (§ name analysis) (§ expr riskAnalyzer.create(§ pars this, tx, dependencies)))
            (§ var #_"RiskAnalysis.Result" (§ name result) (§ expr analysis.analyze(§ pars )))
            (§ if (§ expr result != RiskAnalysis/Result/OK))
            (§ block
                (§ expr log.warn(§ pars "Pending transaction was considered risky: {}\n{}", analysis, tx))
                (§ return true)
            )
            (§ return false)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; <p>Called when we have found a transaction (via network broadcast or otherwise) that is relevant to this wallet
     ; and want to record it.  Note that we <b>cannot verify these transactions at all</b>, they may spend fictional
     ; coins or be otherwise invalid.  They are useful to inform the user about coins they can expect to receive soon,
     ; and if you trust the sender of the transaction you can choose to assume they are in fact valid and will not
     ; be double spent as an optimization.</p>
     ;
     ; <p>Before this method is called, {@link Wallet#isPendingTransactionRelevant(Transaction)} should have been
     ; called to decide whether the wallet cares about the transaction - if it does, then this method expects the
     ; transaction and any dependencies it has which are still in the memory pool.</p>
     ;;
    #_public
    (§ method #_"void" (§ fn receivePending) [#_"Transaction" (§ name tx), #_nilable #_"List<Transaction>" (§ name dependencies)])
        (§ throws #_"VerificationException")
    (§ block
        (§ expr receivePending(§ pars tx, dependencies, false))
        (§ void nil)
    )

    ;;;
     ; This method is used by a {@link Peer} to find out if a transaction that has been announced is interesting,
     ; that is, whether we should bother downloading its dependencies and exploring the transaction to decide how
     ; risky it is.  If this method returns true then {@link Wallet#receivePending(Transaction, java.util.List)}
     ; will soon be called with the transactions dependencies as well.
     ;;
    #_public
    (§ method #_"boolean" (§ fn isPendingTransactionRelevant) [#_"Transaction" (§ name tx)])
        (§ throws #_"ScriptException")
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; Ignore it if we already know about this transaction.  Receiving a pending transaction never moves it
            ;; between pools.
            (§ var #_"EnumSet<Pool>" (§ name containingPools) (§ expr getContainingPools(§ pars tx)))
            (§ if (§ expr (§ not containingPools.equals(§ pars EnumSet/noneOf(§ pars (§ klass #_"Pool"))))))
            (§ block
                (§ expr log.debug(§ pars "Received tx we already saw in a block or created ourselves: " + tx.getHashAsString(§ pars )))
                (§ return false)
            )

            ;; We only care about transactions that:
            ;;   - Send us coins.
            ;;   - Spend our coins.
            ;;   - Double spend a tx in our wallet.
            (§ if (§ expr (§ not isTransactionRelevant(§ pars tx))))
            (§ block
                (§ expr log.debug(§ pars "Received tx that isn't relevant to this wallet, discarding."))
                (§ return false)
            )
            (§ return true)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; <p>Returns true if the given transaction sends coins to any of our keys, or has inputs spending any of our outputs,
     ; and also returns true if tx has inputs that are spending outputs which are
     ; not ours but which are spent by pending transactions.</p>
     ;
     ; <p>Note that if the tx has inputs containing one of our keys, but the connected transaction is not in the wallet,
     ; it will not be considered relevant.</p>
     ;;
    #_public
    (§ method #_"boolean" (§ fn isTransactionRelevant) [#_"Transaction" (§ name tx)])
        (§ throws #_"ScriptException")
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr 0 < tx.getValueSentFromMe(§ pars this).signum(§ pars ) || 0 < tx.getValueSentToMe(§ pars this).signum(§ pars ) || (§ not (§ dot findDoubleSpendsAgainst(§ pars tx, transactions).isEmpty(§ pars )))))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Finds transactions in the specified candidates that double spend "tx".  Not a general check, but it can work even
     ; if the double spent inputs are not ours.
     ; @return the set of transactions that double spend "tx".
     ;;
    #_private
    (§ method #_"Set<Transaction>" (§ fn findDoubleSpendsAgainst) [#_"Transaction" (§ name tx), #_"Map<Sha256Hash, Transaction>" (§ name candidates)])
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ if (§ expr tx.isCoinBase(§ pars )))
        (§ block
            (§ return (§ expr Sets/newHashSet(§ pars )))
        )

        ;; Compile a set of outpoints that are spent by tx.
        (§ var #_"HashSet<TransactionOutPoint>" (§ name outpoints) (§ new #_"HashSet<>" (§ pars )))
        (§ for (§ var #_"TransactionInput" (§ name input)) :for (§ expr tx.getInputs(§ pars )))
        (§ block
            (§ expr outpoints.add(§ pars input.getOutpoint(§ pars )))
        )

        ;; Now for each pending transaction, see if it shares any outpoints with this tx.
        (§ var #_"Set<Transaction>" (§ name doubleSpendTxns) (§ expr Sets/newHashSet(§ pars )))
        (§ for (§ var #_"Transaction" (§ name p)) :for (§ expr candidates.values(§ pars )))
        (§ block
            (§ if (§ expr p.equals(§ pars tx)))
            (§ block
                (§ continue )
            )

            (§ for (§ var #_"TransactionInput" (§ name input)) :for (§ expr p.getInputs(§ pars )))
            (§ block
                ;; This relies on the fact that TransactionOutPoint equality is defined at the protocol not object
                ;; level - outpoints from two different inputs that point to the same output compare the same.
                (§ var #_"TransactionOutPoint" (§ name outpoint) (§ expr input.getOutpoint(§ pars )))
                ;; If does, it's a double spend against the candidates, which makes it relevant.
                (§ if (§ expr outpoints.contains(§ pars outpoint)))
                (§ block
                    (§ expr doubleSpendTxns.add(§ pars p))
                )
            )
        )
        (§ return doubleSpendTxns)
    )

    ;;;
     ; Adds to txSet all the txns in txPool spending outputs of txns in txSet,
     ; and all txns spending the outputs of those txns, recursively.
     ;;
    (§ method #_"void" (§ fn addTransactionsDependingOn) [#_"Set<Transaction>" (§ name txSet), #_"Set<Transaction>" (§ name txPool)])
    (§ block
        (§ var #_"Map<Sha256Hash, Transaction>" (§ name txQueue) (§ new #_"LinkedHashMap<>" (§ pars )))
        (§ for (§ var #_"Transaction" (§ name tx)) :for txSet)
        (§ block
            (§ expr txQueue.put(§ pars tx.getHash(§ pars ), tx))
        )

        (§ while (§ expr (§ not txQueue.isEmpty(§ pars ))))
        (§ block
            (§ var #_"Transaction" (§ name tx) (§ expr txQueue.remove(§ pars txQueue.keySet(§ pars ).iterator(§ pars ).next(§ pars ))))
            (§ for (§ var #_"Transaction" (§ name anotherTx)) :for txPool)
            (§ block
                (§ if (§ expr anotherTx.equals(§ pars tx)))
                (§ block
                    (§ continue )
                )

                (§ for (§ var #_"TransactionInput" (§ name input)) :for (§ expr anotherTx.getInputs(§ pars )))
                (§ block
                    (§ if (§ expr input.getOutpoint(§ pars ).getHash(§ pars ).equals(§ pars tx.getHash(§ pars ))))
                    (§ block
                        (§ if (§ expr txQueue.get(§ pars anotherTx.getHash(§ pars )) == nil))
                        (§ block
                            (§ expr txQueue.put(§ pars anotherTx.getHash(§ pars ), anotherTx))
                            (§ expr txSet.add(§ pars anotherTx))
                        )
                    )
                )
            )
        )
        (§ void nil)
    )

    ;;;
     ; Called by the {@link BlockChain} when we receive a new block that sends coins to one of our addresses or
     ; spends coins from one of our addresses (note that a single transaction can do both).
     ;
     ; This is necessary for the internal book-keeping Wallet does.  When a transaction is received that sends us
     ; coins it is added to a pool so we can use it later to create spends.  When a transaction is received that
     ; consumes outputs they are marked as spent so they won't be used in future.
     ;
     ; A transaction that spends our own coins can be received either because a spend we created was accepted by
     ; the network and thus made it into a block, or because our keys are being shared between multiple instances
     ; and some other node spent the coins instead.  We still have to know about that to avoid accidentally trying
     ; to double spend.
     ;
     ; A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.  We must still record these transactions and the blocks they appear in because a future
     ; block might change which chain is best causing a reorganize.  A re-org can totally change our balance!
     ;;
    #_override
    #_public
    (§ method #_"void" (§ fn receiveFromBlock) [#_"Transaction" (§ name tx), #_"StoredBlock" (§ name block), #_"BlockChain.NewBlockType" (§ name blockType), #_"int" (§ name relativityOffset)])
        (§ throws #_"VerificationException")
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr isTransactionRelevant(§ pars tx)))
            (§ block
                (§ expr receive(§ pars tx, block, blockType, relativityOffset))
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;; Whether to do a saveNow or saveLater when we are notified of the next best block.
    #_private
    (§ field #_"boolean" (§ name hardSaveOnNextBlock) false)

    #_private
    (§ method #_"void" (§ fn receive) [#_"Transaction" (§ name tx), #_"StoredBlock" (§ name block), #_"BlockChain.NewBlockType" (§ name blockType), #_"int" (§ name relativityOffset)])
        (§ throws #_"VerificationException")
    (§ block
        ;; Runs in a peer thread.
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ var #_"Coin" (§ name prevBalance) (§ expr getBalance(§ pars )))
        (§ var #_"Sha256Hash" (§ name txHash) (§ expr tx.getHash(§ pars )))
        (§ var #_"boolean" (§ name bestChain) (§ expr blockType == BlockChain/NewBlockType/BEST_CHAIN))
        (§ var #_"boolean" (§ name sideChain) (§ expr blockType == BlockChain/NewBlockType/SIDE_CHAIN))

        (§ var #_"Coin" (§ name valueSentFromMe) (§ expr tx.getValueSentFromMe(§ pars this)))
        (§ var #_"Coin" (§ name valueSentToMe) (§ expr tx.getValueSentToMe(§ pars this)))
        (§ var #_"Coin" (§ name valueDifference) (§ expr valueSentToMe.subtract(§ pars valueSentFromMe)))

        (§ expr log.info(§ pars "Received tx{} for {}: {} [{}] in block {}", (§ quest sideChain ? (§ expr " on a side chain") :else (§ expr "")), valueDifference.toFriendlyString(§ pars ), tx.getHashAsString(§ pars ), relativityOffset, (§ quest (§ expr block != nil) ? (§ dot block.getHeader(§ pars ).getHash(§ pars )) :else (§ expr "(unit test)"))))

        ;; Inform the key chains that the issued keys were observed in a transaction, so they know to
        ;; calculate more keys for the next Bloom filters.
        (§ expr markKeysAsUsed(§ pars tx))

        (§ ass (§ name onWalletChangedSuppressions) (§ expr onWalletChangedSuppressions + 1))

        ;; If this transaction is already in the wallet, we may need to move it into a different pool.
        ;; At the very least we need to ensure we're manipulating the canonical object rather than a duplicate.
        (§ block
            (§ var #_"Transaction" (§ name tmp) (§ expr transactions.get(§ pars tx.getHash(§ pars ))))
            (§ if (§ expr tmp != nil))
            (§ block
                (§ ass (§ name tx) tmp)
            )
        )

        (§ var #_"boolean" (§ name wasPending) (§ expr pending.remove(§ pars txHash) != nil))
        (§ if wasPending)
        (§ block
            (§ expr log.info(§ pars "  <-pending"))
        )

        (§ if bestChain)
        (§ block
            (§ var #_"boolean" (§ name wasDead) (§ expr dead.remove(§ pars txHash) != nil))
            (§ if wasDead)
            (§ block
                (§ expr log.info(§ pars "  <-dead"))
            )
            (§ if wasPending)
            (§ block
                ;; Was pending and is now confirmed.  Disconnect the outputs in case we spent any already:
                ;; they will be re-connected by processTxFromBestChain below.
                (§ for (§ var #_"TransactionOutput" (§ name output)) :for (§ expr tx.getOutputs(§ pars )))
                (§ block
                    #_final
                    (§ var #_"TransactionInput" (§ name spentBy) (§ expr output.getSpentBy(§ pars )))
                    (§ if (§ expr spentBy != nil))
                    (§ block
                        (§ expr Preconditions/checkState(§ pars myUnspents.add(§ pars output)))
                        (§ expr spentBy.disconnect(§ pars ))
                    )
                )
            )
            (§ expr processTxFromBestChain(§ pars tx, wasPending || wasDead))
        )
        (§ else )
        (§ block
            (§ expr Preconditions/checkState(§ pars sideChain))
            ;; Transactions that appear in a side chain will have that appearance recorded below - we assume
            ;; that some miners are also trying to include the transaction into the current best chain too,
            ;; so let's treat it as pending, except we don't need to do any risk analysis on it.
            (§ if wasPending)
            (§ block
                ;; Just put it back in without touching the connections or confidence.
                (§ expr addWalletTransaction(§ pars Pool/PENDING, tx))
                (§ expr log.info(§ pars "  ->pending"))
            )
            (§ else )
            (§ block
                ;; Ignore the case where a tx appears on a side chain at the same time as the best chain
                ;; (this is quite normal and expected).
                (§ var #_"Sha256Hash" (§ name hash) (§ expr tx.getHash(§ pars )))
                (§ if (§ expr (§ not unspent.containsKey(§ pars hash)) && (§ not spent.containsKey(§ pars hash)) && (§ not dead.containsKey(§ pars hash))))
                (§ block
                    ;; Otherwise put it (possibly back) into pending.
                    ;; Committing it updates the spent flags and inserts into the pool as well.
                    (§ expr commitTx(§ pars tx))
                )
            )
        )

        (§ if (§ expr block != nil))
        (§ block
            ;; Mark the tx as appearing in this block so we can find it later after a re-org.  This also tells
            ;; the tx confidence object about the block and sets its depth appropriately.
            (§ expr tx.setBlockAppearance(§ pars block, bestChain, relativityOffset))
            (§ if bestChain)
            (§ block
                ;; Don't notify this tx of work done in notifyNewBestBlock which will be called immediately
                ;; after this method has been called by BlockChain for all relevant transactions.  Otherwise
                ;; we'd double count.
                (§ expr ignoreNextNewBlock.add(§ pars txHash))

                ;; When a tx is received from the best chain, if other txns that spend this tx are IN_CONFLICT,
                ;; change its confidence to PENDING (Unless they are also spending other txns IN_CONFLICT).
                ;; Consider dependency chains.
                (§ var #_"Set<Transaction>" (§ name currentTxDependencies) (§ expr Sets/newHashSet(§ pars tx)))
                (§ expr addTransactionsDependingOn(§ pars currentTxDependencies, getTransactions(§ pars true)))
                (§ expr currentTxDependencies.remove(§ pars tx))
                (§ var #_"List<Transaction>" (§ name currentTxDependenciesSorted) (§ expr sortTxnsByDependency(§ pars currentTxDependencies)))
                (§ for (§ var #_"Transaction" (§ name txDependency)) :for currentTxDependenciesSorted)
                (§ block
                    (§ if (§ expr txDependency.getConfidence(§ pars ).getConfidenceType(§ pars ).equals(§ pars ConfidenceType/IN_CONFLICT)))
                    (§ block
                        (§ if (§ expr isNotSpendingTxnsInConfidenceType(§ pars txDependency, ConfidenceType/IN_CONFLICT)))
                        (§ block
                            (§ expr txDependency.getConfidence(§ pars ).setConfidenceType(§ pars ConfidenceType/PENDING))
                            (§ expr confidenceChanged.put(§ pars txDependency, TransactionConfidence/Listener/ChangeReason/TYPE))
                        )
                    )
                )
            )
        )

        (§ ass (§ name onWalletChangedSuppressions) (§ expr onWalletChangedSuppressions - 1))

        ;; Side chains don't affect confidence.
        (§ if bestChain)
        (§ block
            ;; notifyNewBestBlock will be invoked next and will then call maybeQueueOnWalletChanged for us.
            (§ expr confidenceChanged.put(§ pars tx, TransactionConfidence/Listener/ChangeReason/TYPE))
        )
        (§ else )
        (§ block
            (§ expr maybeQueueOnWalletChanged(§ pars ))
        )

        ;; Inform anyone interested that we have received or sent coins but only if:
        ;;  - This is not due to a re-org.
        ;;  - The coins appeared on the best chain.
        ;;  - We did in fact receive some new money.
        ;;  - We have not already informed the user about the coins when we received the tx broadcast,
        ;;    or for our own spends.  If users want to know when a broadcast tx becomes confirmed,
        ;;    they need to use tx confidence listeners.
        (§ if (§ expr (§ not insideReorg) && bestChain))
        (§ block
            (§ var #_"Coin" (§ name newBalance) (§ expr getBalance(§ pars ))) ;; This is slow.
            (§ expr log.info(§ pars "Balance is now: " + newBalance.toFriendlyString(§ pars )))
            (§ if (§ expr (§ not wasPending)))
            (§ block
                (§ var #_"int" (§ name diff) (§ expr valueDifference.signum(§ pars )))
                ;; We pick one callback based on the value difference, though a tx can of course both
                ;; send and receive coins from the wallet.
                (§ if (§ expr 0 < diff))
                (§ block
                    (§ expr queueOnCoinsReceived(§ pars tx, prevBalance, newBalance))
                )
                (§ elseif (§ expr diff < 0))
                (§ block
                    (§ expr queueOnCoinsSent(§ pars tx, prevBalance, newBalance))
                )
            )
            (§ expr checkBalanceFuturesLocked(§ pars newBalance))
        )

        (§ expr informConfidenceListenersIfNotReorganizing(§ pars ))
        (§ expr isConsistentOrThrow(§ pars ))
        ;; Optimization for the case where a block has tons of relevant transactions.
        (§ expr saveLater(§ pars ))
        (§ ass (§ name hardSaveOnNextBlock) true)
        (§ void nil)
    )

    ;;; Finds if tx is NOT spending other txns which are in the specified confidence type. ;;
    #_private
    (§ method #_"boolean" (§ fn isNotSpendingTxnsInConfidenceType) [#_"Transaction" (§ name tx), #_"ConfidenceType" (§ name confidenceType)])
    (§ block
        (§ for (§ var #_"TransactionInput" (§ name txInput)) :for (§ expr tx.getInputs(§ pars )))
        (§ block
            (§ var #_"Transaction" (§ name connectedTx) (§ expr this.getTransaction(§ pars txInput.getOutpoint(§ pars ).getHash(§ pars ))))
            (§ if (§ expr connectedTx != nil && connectedTx.getConfidence(§ pars ).getConfidenceType(§ pars ).equals(§ pars confidenceType)))
            (§ block
                (§ return false)
            )
        )
        (§ return true)
    )

    ;;;
     ; Creates and returns a new List with the same txns as inputSet, but txns are sorted by depencency
     ; (a topological sort).  If tx B spends tx A, then tx A should be before tx B on the returned List.
     ; Several invocations to this method with the same inputSet could result in lists with txns in different
     ; order, as there is no guarantee on the order of the returned txns besides what was already stated.
     ;;
    (§ method #_"List<Transaction>" (§ fn sortTxnsByDependency) [#_"Set<Transaction>" (§ name inputSet)])
    (§ block
        (§ var #_"ArrayList<Transaction>" (§ name result) (§ new #_"ArrayList<>" (§ pars inputSet)))
        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < result.size(§ pars ) - 1) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ var #_"boolean" (§ name txAtISpendsOtherTxInTheList))
            (§ do )
            (§ block
                (§ ass (§ name txAtISpendsOtherTxInTheList) false)
                (§ for (§ var #_"int" (§ name j) (§ expr i + 1)) :for (§ expr j < result.size(§ pars )) :for (§ ass (§ name j) (§ expr j + 1)))
                (§ block
                    (§ if (§ expr spends(§ pars result.get(§ pars i), result.get(§ pars j))))
                    (§ block
                        (§ var #_"Transaction" (§ name transactionAtI) (§ expr result.remove(§ pars i)))
                        (§ expr result.add(§ pars j, transactionAtI))
                        (§ ass (§ name txAtISpendsOtherTxInTheList) true)
                        (§ break )
                    )
                )
            )
            (§ again txAtISpendsOtherTxInTheList)
        )
        (§ return result)
    )

    ;;; Finds whether txA spends txB. ;;
    (§ method #_"boolean" (§ fn spends) [#_"Transaction" (§ name txA), #_"Transaction" (§ name txB)])
    (§ block
        (§ for (§ var #_"TransactionInput" (§ name txInput)) :for (§ expr txA.getInputs(§ pars )))
        (§ block
            (§ if (§ expr txInput.getOutpoint(§ pars ).getHash(§ pars ).equals(§ pars txB.getHash(§ pars ))))
            (§ block
                (§ return true)
            )
        )

        (§ return false)
    )

    #_private
    (§ method #_"void" (§ fn informConfidenceListenersIfNotReorganizing) [])
    (§ block
        (§ if insideReorg)
        (§ block
            (§ return nil)
        )

        (§ for (§ var #_"Map.Entry<Transaction, TransactionConfidence.Listener.ChangeReason>" (§ name entry)) :for (§ expr confidenceChanged.entrySet(§ pars )))
        (§ block
            #_final
            (§ var #_"Transaction" (§ name tx) (§ expr entry.getKey(§ pars )))
            (§ expr tx.getConfidence(§ pars ).queueListeners(§ pars entry.getValue(§ pars )))
            (§ expr queueOnTransactionConfidenceChanged(§ pars tx))
        )
        (§ expr confidenceChanged.clear(§ pars ))
        (§ void nil)
    )

    ;;;
     ; Called by the {@link BlockChain} when a new block on the best chain is seen, AFTER relevant wallet
     ; transactions are extracted and sent to us UNLESS the new block caused a re-org, in which case this will
     ; not be called (the {@link Wallet#reorganize(StoredBlock, java.util.List, java.util.List)} method will
     ; call this one in that case).
     ;
     ; Used to update confidence data in each transaction and last seen block hash.  Triggers auto saving.
     ; Invokes the onWalletChanged event listener if there were any affected transactions.
     ;;
    #_override
    #_public
    (§ method #_"void" (§ fn notifyNewBestBlock) [#_"StoredBlock" (§ name block)])
        (§ throws #_"VerificationException")
    (§ block
        ;; Check to see if this block has been seen before.
        (§ var #_"Sha256Hash" (§ name newBlockHash) (§ expr block.getHeader(§ pars ).getHash(§ pars )))
        (§ if (§ expr newBlockHash.equals(§ pars getLastBlockSeenHash(§ pars ))))
        (§ block
            (§ return nil)
        )

        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; Store the new block hash.
            (§ expr setLastBlockSeenHash(§ pars newBlockHash))
            (§ expr setLastBlockSeenHeight(§ pars block.getHeight(§ pars )))
            (§ expr setLastBlockSeenTimeSecs(§ pars block.getHeader(§ pars ).getTimeSeconds(§ pars )))
            ;; Notify all the BUILDING transactions of the new block.
            ;; This is so that they can update their depth.
            (§ var #_"Set<Transaction>" (§ name transactions) (§ expr getTransactions(§ pars true)))
            (§ for (§ var #_"Transaction" (§ name tx)) :for transactions)
            (§ block
                (§ if (§ expr ignoreNextNewBlock.contains(§ pars tx.getHash(§ pars ))))
                (§ block
                    ;; tx was already processed in receive() due to it appearing in this block, so we don't want
                    ;; to increment the tx confidence depth twice, it'd result in miscounting.
                    (§ expr ignoreNextNewBlock.remove(§ pars tx.getHash(§ pars )))
                )
                (§ else )
                (§ block
                    (§ var #_"TransactionConfidence" (§ name confidence) (§ expr tx.getConfidence(§ pars )))
                    (§ if (§ expr confidence.getConfidenceType(§ pars ) == ConfidenceType/BUILDING))
                    (§ block
                        ;; Erase the set of seen peers once the tx is so deep that it seems unlikely to ever go
                        ;; pending again.  We could clear this data the moment a tx is seen in the block chain,
                        ;; but in cases where the chain re-orgs, this would mean that wallets would perceive a
                        ;; newly pending tx has zero confidence at all, which would not be right: we expect it to
                        ;; be included once again.  We could have a separate was-in-chain-and-now-isn't confidence
                        ;; type, but this way is backwards compatible with existing software, and the new state
                        ;; probably wouldn't mean anything different to just remembering peers anyway.
                        (§ if (§ expr context.getEventHorizon(§ pars ) < confidence.incrementDepthInBlocks(§ pars )))
                        (§ block
                            (§ expr confidence.clearBroadcastBy(§ pars ))
                        )
                        (§ expr confidenceChanged.put(§ pars tx, TransactionConfidence/Listener/ChangeReason/DEPTH))
                    )
                )
            )

            (§ expr informConfidenceListenersIfNotReorganizing(§ pars ))
            (§ expr maybeQueueOnWalletChanged(§ pars ))

            (§ if hardSaveOnNextBlock)
            (§ block
                (§ expr saveNow(§ pars ))
                (§ ass (§ name hardSaveOnNextBlock) false)
            )
            (§ else )
            (§ block
                ;; Coalesce writes to avoid throttling on disk access when catching up with the chain.
                (§ expr saveLater(§ pars ))
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Handle when a transaction becomes newly active on the best chain, either due to receiving a new block or a
     ; re-org.  Places the tx into the right pool, handles coinbase transactions, handles double-spends and so on.
     ;;
    #_private
    (§ method #_"void" (§ fn processTxFromBestChain) [#_"Transaction" (§ name tx), #_"boolean" (§ name forceAddToPool)])
        (§ throws #_"VerificationException")
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ expr Preconditions/checkState(§ pars (§ not pending.containsKey(§ pars tx.getHash(§ pars )))))

        ;; This TX may spend our existing outputs even though it was not pending.  This can happen in unit tests,
        ;; if keys are moved between wallets, if we're catching up to the chain given only a set of keys,
        ;; or if a dead coinbase transaction has moved back onto the main chain.
        (§ var #_"boolean" (§ name isDeadCoinbase) (§ expr tx.isCoinBase(§ pars ) && dead.containsKey(§ pars tx.getHash(§ pars ))))
        (§ if isDeadCoinbase)
        (§ block
            ;; There is a dead coinbase tx being received on the best chain.  A coinbase tx is made dead when it moves
            ;; to a side chain but it can be switched back on a reorg and resurrected back to spent or unspent.
            ;; So take it out of the dead pool.  Note that we don't resurrect dependent transactions here, even though
            ;; we could.  Bitcoin Core nodes on the network have deleted the dependent transactions from their mempools
            ;; entirely by this point.  We could and maybe should rebroadcast them so the network remembers and tries
            ;; to confirm them again.  But this is a deeply unusual edge case that due to the maturity rule should never
            ;; happen in practice, thus for simplicities sake we ignore it here.
            (§ expr log.info(§ pars "  coinbase tx <-dead: confidence {}", tx.getHashAsString(§ pars ), tx.getConfidence(§ pars ).getConfidenceType(§ pars ).name(§ pars )))
            (§ expr dead.remove(§ pars tx.getHash(§ pars )))
        )

        ;; Update tx and other unspent/pending transactions by connecting inputs/outputs.
        (§ expr updateForSpends(§ pars tx, true))

        ;; Now make sure it ends up in the right pool.  Also, handle the case where this TX is double-spending
        ;; against our pending transactions.  Note that a tx may double spend our pending transactions and also
        ;; send us money/spend our money.
        (§ var #_"boolean" (§ name hasOutputsToMe) (§ expr 0 < tx.getValueSentToMe(§ pars this).signum(§ pars )))
        (§ var #_"boolean" (§ name hasOutputsFromMe) false)
        (§ if hasOutputsToMe)
        (§ block
            ;; Needs to go into either unspent or spent (if the outputs were already spent by a pending tx).
            (§ if (§ expr tx.isEveryOwnedOutputSpent(§ pars this)))
            (§ block
                (§ expr log.info(§ pars "  tx {} ->spent (by pending)", tx.getHashAsString(§ pars )))
                (§ expr addWalletTransaction(§ pars Pool/SPENT, tx))
            )
            (§ else )
            (§ block
                (§ expr log.info(§ pars "  tx {} ->unspent", tx.getHashAsString(§ pars )))
                (§ expr addWalletTransaction(§ pars Pool/UNSPENT, tx))
            )
        )
        (§ elseif (§ expr 0 < tx.getValueSentFromMe(§ pars this).signum(§ pars )))
        (§ block
            (§ ass (§ name hasOutputsFromMe) true)
            ;; Didn't send us any money, but did spend some.  Keep it around for record keeping purposes.
            (§ expr log.info(§ pars "  tx {} ->spent", tx.getHashAsString(§ pars )))
            (§ expr addWalletTransaction(§ pars Pool/SPENT, tx))
        )
        (§ elseif forceAddToPool)
        (§ block
            ;; Was manually added to pending, so we should keep it to notify the user of confidence information.
            (§ expr log.info(§ pars "  tx {} ->spent (manually added)", tx.getHashAsString(§ pars )))
            (§ expr addWalletTransaction(§ pars Pool/SPENT, tx))
        )

        ;; Kill txns in conflict with this tx.
        (§ var #_"Set<Transaction>" (§ name doubleSpendTxns) (§ expr findDoubleSpendsAgainst(§ pars tx, pending)))
        (§ if (§ expr (§ not doubleSpendTxns.isEmpty(§ pars ))))
        (§ block
            ;; No need to addTransactionsDependingOn(doubleSpendTxns), because killTxns() already kills dependencies.
            (§ expr killTxns(§ pars doubleSpendTxns, tx))
        )
        (§ if (§ expr (§ not hasOutputsToMe) && (§ not hasOutputsFromMe) && (§ not forceAddToPool) && (§ not (§ dot findDoubleSpendsAgainst(§ pars tx, transactions).isEmpty(§ pars )))))
        (§ block
            ;; Disconnect irrelevant inputs (otherwise might cause protobuf serialization issue).
            (§ for (§ var #_"TransactionInput" (§ name input)) :for (§ expr tx.getInputs(§ pars )))
            (§ block
                (§ var #_"TransactionOutput" (§ name output) (§ expr input.getConnectedOutput(§ pars )))
                (§ if (§ expr output != nil && (§ not output.isMine(§ pars this))))
                (§ block
                    (§ expr input.disconnect(§ pars ))
                )
            )
        )
        (§ void nil)
    )

    ;;;
     ; <p>Updates the wallet by checking if this TX spends any of our outputs, and marking them as spent if so.
     ; If fromChain is true, also checks to see if any pending transaction spends outputs of this transaction and marks
     ; the spent flags appropriately.</p>
     ;
     ; <p>It can be called in two contexts.  One is when we receive a transaction on the best chain but it wasn't pending,
     ; this most commonly happens when we have a set of keys but the wallet transactions were wiped and we are catching
     ; up with the block chain.  It can also happen if a block includes a transaction we never saw at broadcast time.
     ; If this tx double spends, it takes precedence over our pending transactions and the pending tx goes dead.</p>
     ;
     ; <p>The other context it can be called is from {@link Wallet#receivePending(Transaction, java.util.List)},
     ; i.e. we saw a tx be broadcast or one was submitted directly that spends our own coins.  If this tx double spends,
     ; it does NOT take precedence because the winner will be resolved by the miners - we assume that our version will
     ; win, if we are wrong then when a block appears the tx will go dead.</p>
     ;
     ; @param tx The transaction which is being updated.
     ; @param fromChain If true, the tx appeared on the current best chain, if false it was pending.
     ;;
    #_private
    (§ method #_"void" (§ fn updateForSpends) [#_"Transaction" (§ name tx), #_"boolean" (§ name fromChain)])
        (§ throws #_"VerificationException")
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ if fromChain)
        (§ block
            (§ expr Preconditions/checkState(§ pars (§ not pending.containsKey(§ pars tx.getHash(§ pars )))))
        )

        (§ for (§ var #_"TransactionInput" (§ name input)) :for (§ expr tx.getInputs(§ pars )))
        (§ block
            (§ var #_"TransactionInput.ConnectionResult" (§ name result) (§ expr input.connect(§ pars unspent, TransactionInput/ConnectMode/ABORT_ON_CONFLICT)))
            (§ if (§ expr result == TransactionInput/ConnectionResult/NO_SUCH_TX))
            (§ block
                ;; Not found in the unspent map.  Try again with the spent map.
                (§ ass (§ name result) (§ expr input.connect(§ pars spent, TransactionInput/ConnectMode/ABORT_ON_CONFLICT)))
                (§ if (§ expr result == TransactionInput/ConnectionResult/NO_SUCH_TX))
                (§ block
                    ;; Not found in the unspent and spent maps.  Try again with the pending map.
                    (§ ass (§ name result) (§ expr input.connect(§ pars pending, TransactionInput/ConnectMode/ABORT_ON_CONFLICT)))
                    (§ if (§ expr result == TransactionInput/ConnectionResult/NO_SUCH_TX))
                    (§ block
                        ;; Doesn't spend any of our outputs or is coinbase.
                        (§ continue )
                    )
                )
            )

            (§ var #_"TransactionOutput" (§ name output) (§ expr Preconditions/checkNotNull(§ pars input.getConnectedOutput(§ pars ))))
            (§ if (§ expr result == TransactionInput/ConnectionResult/ALREADY_SPENT))
            (§ block
                (§ if fromChain)
                (§ block
                    ;; Can be:
                    ;; (1) We already marked this output as spent when we saw the pending transaction (most likely).
                    ;;     Now it's being confirmed of course, we cannot mark it as spent again.
                    ;; (2) A double spend from chain: this will be handled later by findDoubleSpendsAgainst()/killTxns().
                    ;;
                    ;; In any case, nothing to do here.
                )
                (§ else )
                (§ block
                    ;; We saw two pending transactions that double spend each other.  We don't know which will win.
                    ;; This can happen in the case of bad network nodes that mutate transactions.  Do a hex dump
                    ;; so the exact nature of the mutation can be examined.
                    (§ expr log.warn(§ pars "Saw two pending transactions double spend each other"))
                    (§ expr log.warn(§ pars "  offending input is input {}", tx.getInputs(§ pars ).indexOf(§ pars input)))
                    (§ expr log.warn(§ pars "{}: {}", tx.getHash(§ pars ), Utils/HEX.encode(§ pars tx.unsafeBitcoinSerialize(§ pars ))))
                    (§ var #_"Transaction" (§ name other) (§ expr output.getSpentBy(§ pars ).getParentTransaction(§ pars )))
                    (§ expr log.warn(§ pars "{}: {}", other.getHash(§ pars ), Utils/HEX.encode(§ pars other.unsafeBitcoinSerialize(§ pars ))))
                )
            )
            (§ elseif (§ expr result == TransactionInput/ConnectionResult/SUCCESS))
            (§ block
                ;; Otherwise we saw a transaction spend our coins, but we didn't try and spend them ourselves yet.
                ;; The outputs are already marked as spent by the connect call above, so check if there are any more for
                ;; us to use.  Move if not.
                (§ var #_"Transaction" (§ name connected) (§ expr Preconditions/checkNotNull(§ pars input.getConnectedTransaction(§ pars ))))
                (§ expr log.info(§ pars "  marked {} as spent by {}", input.getOutpoint(§ pars ), tx.getHashAsString(§ pars )))
                (§ expr maybeMovePool(§ pars connected, "prevtx"))
                ;; Just because it's connected, doesn't mean it's actually ours: sometimes we have total visibility.
                (§ if (§ expr output.isMine(§ pars this)))
                (§ block
                    (§ expr Preconditions/checkState(§ pars myUnspents.remove(§ pars output)))
                )
            )
        )

        ;; Now check each output and see if there is a pending transaction which spends it.  This shouldn't normally
        ;; ever occur because we expect transactions to arrive in temporal order, but this assumption can be violated
        ;; when we receive a pending transaction from the mempool that is relevant to us, which spends coins that we
        ;; didn't see arrive on the best chain yet.  For instance, because of a chain replay or because of our keys were
        ;; used by another wallet somewhere else.  Also, unconfirmed transactions can arrive from the mempool in more
        ;; or less random order.
        (§ for (§ var #_"Transaction" (§ name pendingTx)) :for (§ expr pending.values(§ pars )))
        (§ block
            (§ for (§ var #_"TransactionInput" (§ name input)) :for (§ expr pendingTx.getInputs(§ pars )))
            (§ block
                (§ var #_"TransactionInput.ConnectionResult" (§ name result) (§ expr input.connect(§ pars tx, TransactionInput/ConnectMode/ABORT_ON_CONFLICT)))
                (§ if fromChain)
                (§ block
                    ;; This TX is supposed to have just appeared on the best chain, so its outputs should not be marked
                    ;; as spent yet.  If they are, it means something is happening out of order.
                    (§ expr Preconditions/checkState(§ pars result != TransactionInput/ConnectionResult/ALREADY_SPENT))
                )
                (§ if (§ expr result == TransactionInput/ConnectionResult/SUCCESS))
                (§ block
                    (§ expr log.info(§ pars "Connected pending tx input {}:{}", pendingTx.getHashAsString(§ pars ), pendingTx.getInputs(§ pars ).indexOf(§ pars input)))
                    ;; The unspents map might not have it if we never saw this tx until it was included in the chain
                    ;; and thus becomes spent the moment we become aware of it.
                    (§ if (§ expr myUnspents.remove(§ pars input.getConnectedOutput(§ pars ))))
                    (§ block
                        (§ expr log.info(§ pars "Removed from UNSPENTS: {}", input.getConnectedOutput(§ pars )))
                    )
                )
            )
        )
        (§ if (§ expr (§ not fromChain)))
        (§ block
            (§ expr maybeMovePool(§ pars tx, "pendingtx"))
        )
        (§ else )
        (§ block
            ;; If the transactions outputs are now all spent, it will be moved into the spent pool by the
            ;; processTxFromBestChain method.
        )
        (§ void nil)
    )

    ;; Updates the wallet when a double spend occurs.  overridingTx can be null for the case of coinbases.
    #_private
    (§ method #_"void" (§ fn killTxns) [#_"Set<Transaction>" (§ name txnsToKill), #_nilable #_"Transaction" (§ name overridingTx)])
    (§ block
        (§ var #_"LinkedList<Transaction>" (§ name work) (§ new #_"LinkedList<>" (§ pars txnsToKill)))
        (§ while (§ expr (§ not work.isEmpty(§ pars ))))
        (§ block
            #_final
            (§ var #_"Transaction" (§ name tx) (§ expr work.poll(§ pars )))
            (§ expr log.warn(§ pars "TX {} killed{}", tx.getHashAsString(§ pars ), (§ quest (§ expr overridingTx != nil) ? (§ str " by " + overridingTx.getHashAsString(§ pars )) :else (§ expr ""))))
            (§ expr log.warn(§ pars "Disconnecting each input and moving connected transactions."))
            ;; TX could be pending (finney attack), or in unspent/spent (coinbase killed by reorg).
            (§ expr pending.remove(§ pars tx.getHash(§ pars )))
            (§ expr unspent.remove(§ pars tx.getHash(§ pars )))
            (§ expr spent.remove(§ pars tx.getHash(§ pars )))
            (§ expr addWalletTransaction(§ pars Pool/DEAD, tx))
            (§ for (§ var #_"TransactionInput" (§ name deadInput)) :for (§ expr tx.getInputs(§ pars )))
            (§ block
                (§ var #_"Transaction" (§ name connected) (§ expr deadInput.getConnectedTransaction(§ pars )))
                (§ if (§ expr connected == nil))
                (§ block
                    (§ continue )
                )
                (§ if (§ expr connected.getConfidence(§ pars ).getConfidenceType(§ pars ) != ConfidenceType/DEAD && deadInput.getConnectedOutput(§ pars ).getSpentBy(§ pars ) != nil && deadInput.getConnectedOutput(§ pars ).getSpentBy(§ pars ).equals(§ pars deadInput)))
                (§ block
                    (§ expr Preconditions/checkState(§ pars myUnspents.add(§ pars deadInput.getConnectedOutput(§ pars ))))
                    (§ expr log.info(§ pars "Added to UNSPENTS: {} in {}", deadInput.getConnectedOutput(§ pars ), deadInput.getConnectedOutput(§ pars ).getParentTransaction(§ pars ).getHash(§ pars )))
                )
                (§ expr deadInput.disconnect(§ pars ))
                (§ expr maybeMovePool(§ pars connected, "kill"))
            )
            (§ expr tx.getConfidence(§ pars ).setOverridingTransaction(§ pars overridingTx))
            (§ expr confidenceChanged.put(§ pars tx, TransactionConfidence/Listener/ChangeReason/TYPE))
            ;; Now kill any transactions we have that depended on this one.
            (§ for (§ var #_"TransactionOutput" (§ name deadOutput)) :for (§ expr tx.getOutputs(§ pars )))
            (§ block
                (§ if (§ expr myUnspents.remove(§ pars deadOutput)))
                (§ block
                    (§ expr log.info(§ pars "XX Removed from UNSPENTS: {}", deadOutput))
                )
                (§ var #_"TransactionInput" (§ name connected) (§ expr deadOutput.getSpentBy(§ pars )))
                (§ if (§ expr connected == nil))
                (§ block
                    (§ continue )
                )
                #_final
                (§ var #_"Transaction" (§ name parentTransaction) (§ expr connected.getParentTransaction(§ pars )))
                (§ expr log.info(§ pars "This death invalidated dependent tx {}", parentTransaction.getHash(§ pars )))
                (§ expr work.push(§ pars parentTransaction))
            )
        )
        (§ if (§ expr overridingTx == nil))
        (§ block
            (§ return nil)
        )

        (§ expr log.warn(§ pars "Now attempting to connect the inputs of the overriding transaction."))
        (§ for (§ var #_"TransactionInput" (§ name input)) :for (§ expr overridingTx.getInputs(§ pars )))
        (§ block
            (§ var #_"TransactionInput.ConnectionResult" (§ name result) (§ expr input.connect(§ pars unspent, TransactionInput/ConnectMode/DISCONNECT_ON_CONFLICT)))
            (§ if (§ expr result == TransactionInput/ConnectionResult/SUCCESS))
            (§ block
                (§ expr maybeMovePool(§ pars input.getConnectedTransaction(§ pars ), "kill"))
                (§ expr myUnspents.remove(§ pars input.getConnectedOutput(§ pars )))
                (§ expr log.info(§ pars "Removing from UNSPENTS: {}", input.getConnectedOutput(§ pars )))
            )
            (§ else )
            (§ block
                (§ ass (§ name result) (§ expr input.connect(§ pars spent, TransactionInput/ConnectMode/DISCONNECT_ON_CONFLICT)))
                (§ if (§ expr result == TransactionInput/ConnectionResult/SUCCESS))
                (§ block
                    (§ expr maybeMovePool(§ pars input.getConnectedTransaction(§ pars ), "kill"))
                    (§ expr myUnspents.remove(§ pars input.getConnectedOutput(§ pars )))
                    (§ expr log.info(§ pars "Removing from UNSPENTS: {}", input.getConnectedOutput(§ pars )))
                )
            )
        )
        (§ void nil)
    )

    ;;;
     ; If the transactions outputs are all marked as spent, and it's in the unspent map, move it.
     ; If the owned transactions outputs are not all marked as spent, and it's in the spent map, move it.
     ;;
    #_private
    (§ method #_"void" (§ fn maybeMovePool) [#_"Transaction" (§ name tx), #_"String" (§ name context)])
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ if (§ expr tx.isEveryOwnedOutputSpent(§ pars this)))
        (§ block
            ;; There's nothing left I can spend in this transaction.
            (§ if (§ expr unspent.remove(§ pars tx.getHash(§ pars )) != nil))
            (§ block
                (§ if (§ expr log.isInfoEnabled(§ pars )))
                (§ block
                    (§ expr log.info(§ pars "  {} {} <-unspent ->spent", tx.getHashAsString(§ pars ), context))
                )
                (§ expr spent.put(§ pars tx.getHash(§ pars ), tx))
            )
        )
        (§ else )
        (§ block
            (§ if (§ expr spent.remove(§ pars tx.getHash(§ pars )) != nil))
            (§ block
                (§ if (§ expr log.isInfoEnabled(§ pars )))
                (§ block
                    (§ expr log.info(§ pars "  {} {} <-spent ->unspent", tx.getHashAsString(§ pars ), context))
                )
                (§ expr unspent.put(§ pars tx.getHash(§ pars ), tx))
            )
        )
        (§ void nil)
    )

    ;;;
     ; Calls {@link Wallet#commitTx} if tx is not already in the pending pool.
     ;
     ; @return true if the tx was added to the wallet, or false if it was already in the pending pool.
     ;;
    #_public
    (§ method #_"boolean" (§ fn maybeCommitTx) [#_"Transaction" (§ name tx)])
        (§ throws #_"VerificationException")
    (§ block
        (§ expr tx.verify(§ pars ))
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr pending.containsKey(§ pars tx.getHash(§ pars ))))
            (§ block
                (§ return false)
            )

            (§ expr log.info(§ pars "commitTx of {}", tx.getHashAsString(§ pars )))
            (§ var #_"Coin" (§ name balance) (§ expr getBalance(§ pars )))
            (§ expr tx.setUpdateTime(§ pars Utils/now(§ pars )))
            ;; Put any outputs that are sending money back to us into the unspents map, and calculate their total value.
            (§ var #_"Coin" (§ name valueSentToMe) (§ expr Coin/ZERO))
            (§ for (§ var #_"TransactionOutput" (§ name o)) :for (§ expr tx.getOutputs(§ pars )))
            (§ block
                (§ if (§ expr o.isMine(§ pars this)))
                (§ block
                    (§ ass (§ name valueSentToMe) (§ expr valueSentToMe.add(§ pars o.getValue(§ pars ))))
                )
            )
            ;; Mark the outputs we're spending as spent so we won't try and use them in future creations.  This will also
            ;; move any transactions that are now fully spent to the spent map so we can skip them when creating future
            ;; spends.
            (§ expr updateForSpends(§ pars tx, false))

            (§ var #_"Set<Transaction>" (§ name doubleSpendPendingTxns) (§ expr findDoubleSpendsAgainst(§ pars tx, pending)))
            (§ var #_"Set<Transaction>" (§ name doubleSpendUnspentTxns) (§ expr findDoubleSpendsAgainst(§ pars tx, unspent)))
            (§ var #_"Set<Transaction>" (§ name doubleSpendSpentTxns) (§ expr findDoubleSpendsAgainst(§ pars tx, spent)))

            (§ if (§ expr (§ not doubleSpendUnspentTxns.isEmpty(§ pars )) || (§ not doubleSpendSpentTxns.isEmpty(§ pars )) || (§ not isNotSpendingTxnsInConfidenceType(§ pars tx, ConfidenceType/DEAD))))
            (§ block
                ;; tx is a double spend against a tx already in the best chain or spends outputs of a DEAD tx.
                ;; Add tx to the dead pool and schedule confidence listener notifications.
                (§ expr log.info(§ pars "->dead: {}", tx.getHashAsString(§ pars )))
                (§ expr tx.getConfidence(§ pars ).setConfidenceType(§ pars ConfidenceType/DEAD))
                (§ expr confidenceChanged.put(§ pars tx, TransactionConfidence/Listener/ChangeReason/TYPE))
                (§ expr addWalletTransaction(§ pars Pool/DEAD, tx))
            )
            (§ elseif (§ expr (§ not doubleSpendPendingTxns.isEmpty(§ pars )) || (§ not isNotSpendingTxnsInConfidenceType(§ pars tx, ConfidenceType/IN_CONFLICT))))
            (§ block
                ;; tx is a double spend against a pending tx or spends outputs of a tx already IN_CONFLICT.
                ;; Add tx to the pending pool.  Update the confidence type of tx, the txns in conflict with tx
                ;; and all their dependencies to IN_CONFLICT and schedule confidence listener notifications.
                (§ expr log.info(§ pars "->pending (IN_CONFLICT): {}", tx.getHashAsString(§ pars )))
                (§ expr addWalletTransaction(§ pars Pool/PENDING, tx))
                (§ expr doubleSpendPendingTxns.add(§ pars tx))
                (§ expr addTransactionsDependingOn(§ pars doubleSpendPendingTxns, getTransactions(§ pars true)))
                (§ for (§ var #_"Transaction" (§ name doubleSpendTx)) :for doubleSpendPendingTxns)
                (§ block
                    (§ expr doubleSpendTx.getConfidence(§ pars ).setConfidenceType(§ pars ConfidenceType/IN_CONFLICT))
                    (§ expr confidenceChanged.put(§ pars doubleSpendTx, TransactionConfidence/Listener/ChangeReason/TYPE))
                )
            )
            (§ else )
            (§ block
                ;; No conflict detected.
                ;; Add to the pending pool and schedule confidence listener notifications.
                (§ expr log.info(§ pars "->pending: {}", tx.getHashAsString(§ pars )))
                (§ expr tx.getConfidence(§ pars ).setConfidenceType(§ pars ConfidenceType/PENDING))
                (§ expr confidenceChanged.put(§ pars tx, TransactionConfidence/Listener/ChangeReason/TYPE))
                (§ expr addWalletTransaction(§ pars Pool/PENDING, tx))
            )
            (§ if (§ expr log.isInfoEnabled(§ pars )))
            (§ block
                (§ expr log.info(§ pars "Estimated balance is now: {}", getBalance(§ pars BalanceType/ESTIMATED).toFriendlyString(§ pars )))
            )

            ;; Mark any keys used in the outputs as "used", this allows wallet UI's to auto-advance the current key
            ;; they are showing to the user in qr codes etc.
            (§ expr markKeysAsUsed(§ pars tx))
            (§ try )
            (§ block
                (§ var #_"Coin" (§ name valueSentFromMe) (§ expr tx.getValueSentFromMe(§ pars this)))
                (§ var #_"Coin" (§ name newBalance) (§ expr balance.add(§ pars valueSentToMe).subtract(§ pars valueSentFromMe)))
                (§ if (§ expr 0 < valueSentToMe.signum(§ pars )))
                (§ block
                    (§ expr checkBalanceFuturesLocked(§ pars nil))
                    (§ expr queueOnCoinsReceived(§ pars tx, balance, newBalance))
                )
                (§ if (§ expr 0 < valueSentFromMe.signum(§ pars )))
                (§ block
                    (§ expr queueOnCoinsSent(§ pars tx, balance, newBalance))
                )

                (§ expr maybeQueueOnWalletChanged(§ pars ))
            )
            (§ catch #_"ScriptException" (§ name e))
            (§ block
                ;; Cannot happen as we just created this transaction ourselves.
                (§ throw (§ new #_"RuntimeException" (§ pars e)))
            )

            (§ expr isConsistentOrThrow(§ pars ))
            (§ expr informConfidenceListenersIfNotReorganizing(§ pars ))
            (§ expr saveNow(§ pars ))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ return true)
    )

    ;;;
     ; <p>Updates the wallet with the given transaction: puts it into the pending pool, sets the spent flags
     ; and runs the onCoinsSent/onCoinsReceived event listener.  Used in two situations:</p>
     ;
     ; <ol>
     ;     <li>When we have just successfully transmitted the tx we created to the network.</li>
     ;     <li>When we receive a pending transaction that didn't appear in the chain yet, and we did not create it.</li>
     ; </ol>
     ;
     ; <p>Triggers an auto save.</p>
     ;;
    #_public
    (§ method #_"void" (§ fn commitTx) [#_"Transaction" (§ name tx)])
        (§ throws #_"VerificationException")
    (§ block
        (§ expr Preconditions/checkArgument(§ pars maybeCommitTx(§ pars tx), "commitTx called on the same transaction twice"))
        (§ void nil)
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  Runs the listener methods in the user thread.
     ;;
    #_public
    (§ method #_"void" (§ fn addChangeEventListener) [#_"WalletChangeEventListener" (§ name listener)])
    (§ block
        (§ expr addChangeEventListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  The listener is executed by the given executor.
     ;;
    #_public
    (§ method #_"void" (§ fn addChangeEventListener) [#_"Executor" (§ name executor), #_"WalletChangeEventListener" (§ name listener)])
    (§ block
        ;; This is thread safe, so we don't need to take the lock.
        (§ expr changeListeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars listener, executor))))
        (§ void nil)
    )

    ;;;
     ; Adds an event listener object called when coins are received.
     ; Runs the listener methods in the user thread.
     ;;
    #_public
    (§ method #_"void" (§ fn addCoinsReceivedEventListener) [#_"WalletCoinsReceivedEventListener" (§ name listener)])
    (§ block
        (§ expr addCoinsReceivedEventListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;;
     ; Adds an event listener object called when coins are received.
     ; The listener is executed by the given executor.
     ;;
    #_public
    (§ method #_"void" (§ fn addCoinsReceivedEventListener) [#_"Executor" (§ name executor), #_"WalletCoinsReceivedEventListener" (§ name listener)])
    (§ block
        ;; This is thread safe, so we don't need to take the lock.
        (§ expr coinsReceivedListeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars listener, executor))))
        (§ void nil)
    )

    ;;;
     ; Adds an event listener object called when coins are sent.
     ; Runs the listener methods in the user thread.
     ;;
    #_public
    (§ method #_"void" (§ fn addCoinsSentEventListener) [#_"WalletCoinsSentEventListener" (§ name listener)])
    (§ block
        (§ expr addCoinsSentEventListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;;
     ; Adds an event listener object called when coins are sent.
     ; The listener is executed by the given executor.
     ;;
    #_public
    (§ method #_"void" (§ fn addCoinsSentEventListener) [#_"Executor" (§ name executor), #_"WalletCoinsSentEventListener" (§ name listener)])
    (§ block
        ;; This is thread safe, so we don't need to take the lock.
        (§ expr coinsSentListeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars listener, executor))))
        (§ void nil)
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when keys are
     ; added.  The listener is executed in the user thread.
     ;;
    #_public
    (§ method #_"void" (§ fn addKeyChainEventListener) [#_"KeyChainEventListener" (§ name listener)])
    (§ block
        (§ expr keyChainGroup.addEventListener(§ pars listener, Threading/USER_THREAD))
        (§ void nil)
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when keys are
     ; added.  The listener is executed by the given executor.
     ;;
    #_public
    (§ method #_"void" (§ fn addKeyChainEventListener) [#_"Executor" (§ name executor), #_"KeyChainEventListener" (§ name listener)])
    (§ block
        (§ expr keyChainGroup.addEventListener(§ pars listener, executor))
        (§ void nil)
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  Runs the listener methods in the user thread.
     ;;
    #_public
    (§ method #_"void" (§ fn addReorganizeEventListener) [#_"WalletReorganizeEventListener" (§ name listener)])
    (§ block
        (§ expr addReorganizeEventListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when something interesting happens,
     ; like receiving money.  The listener is executed by the given executor.
     ;;
    #_public
    (§ method #_"void" (§ fn addReorganizeEventListener) [#_"Executor" (§ name executor), #_"WalletReorganizeEventListener" (§ name listener)])
    (§ block
        ;; This is thread safe, so we don't need to take the lock.
        (§ expr reorganizeListeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars listener, executor))))
        (§ void nil)
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when confidence
     ; of a transaction changes.  Runs the listener methods in the user thread.
     ;;
    #_public
    (§ method #_"void" (§ fn addTransactionConfidenceEventListener) [#_"TransactionConfidenceEventListener" (§ name listener)])
    (§ block
        (§ expr addTransactionConfidenceEventListener(§ pars Threading/USER_THREAD, listener))
        (§ void nil)
    )

    ;;;
     ; Adds an event listener object.  Methods on this object are called when confidence
     ; of a transaction changes.  The listener is executed by the given executor.
     ;;
    #_public
    (§ method #_"void" (§ fn addTransactionConfidenceEventListener) [#_"Executor" (§ name executor), #_"TransactionConfidenceEventListener" (§ name listener)])
    (§ block
        ;; This is thread safe, so we don't need to take the lock.
        (§ expr transactionConfidenceListeners.add(§ pars (§ new #_"ListenerRegistration<>" (§ pars listener, executor))))
        (§ void nil)
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (§ method #_"boolean" (§ fn removeChangeEventListener) [#_"WalletChangeEventListener" (§ name listener)])
    (§ block
        (§ return (§ expr ListenerRegistration/removeFromList(§ pars listener, changeListeners)))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (§ method #_"boolean" (§ fn removeCoinsReceivedEventListener) [#_"WalletCoinsReceivedEventListener" (§ name listener)])
    (§ block
        (§ return (§ expr ListenerRegistration/removeFromList(§ pars listener, coinsReceivedListeners)))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (§ method #_"boolean" (§ fn removeCoinsSentEventListener) [#_"WalletCoinsSentEventListener" (§ name listener)])
    (§ block
        (§ return (§ expr ListenerRegistration/removeFromList(§ pars listener, coinsSentListeners)))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (§ method #_"boolean" (§ fn removeKeyChainEventListener) [#_"KeyChainEventListener" (§ name listener)])
    (§ block
        (§ return (§ expr keyChainGroup.removeEventListener(§ pars listener)))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (§ method #_"boolean" (§ fn removeReorganizeEventListener) [#_"WalletReorganizeEventListener" (§ name listener)])
    (§ block
        (§ return (§ expr ListenerRegistration/removeFromList(§ pars listener, reorganizeListeners)))
    )

    ;;;
     ; Removes the given event listener object.  Returns true if the listener was removed,
     ; false if that listener was never added.
     ;;
    #_public
    (§ method #_"boolean" (§ fn removeTransactionConfidenceEventListener) [#_"TransactionConfidenceEventListener" (§ name listener)])
    (§ block
        (§ return (§ expr ListenerRegistration/removeFromList(§ pars listener, transactionConfidenceListeners)))
    )

    #_private
    (§ method #_"void" (§ fn queueOnTransactionConfidenceChanged) [#_final #_"Transaction" (§ name tx)])
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ for (§ var #_final ListenerRegistration<TransactionConfidenceEventListener> registration) :for transactionConfidenceListeners)
        (§ block
            (§ if (§ expr registration.executor == Threading/SAME_THREAD))
            (§ block
                (§ expr registration.listener.onTransactionConfidenceChanged(§ pars this, tx))
            )
            (§ else )
            (§ block
                (§ expr registration.executor.execute(§ pars (§ new #_"Runnable" (§ pars ))
                (§ anon
                    #_override
                    #_public
                    (§ method #_"void" (§ fn run) [])
                    (§ block
                        (§ expr registration.listener.onTransactionConfidenceChanged(§ pars (§ dhis Wallet), tx))
                        (§ void nil)
                    )
                )))
            )
        )
        (§ void nil)
    )

    #_protected
    (§ method #_"void" (§ fn maybeQueueOnWalletChanged) [])
    (§ block
        ;; Don't invoke the callback in some circumstances, e.g. whilst we are re-organizing or fiddling
        ;; with transactions due to a new block arriving.  It will be called later instead.
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ expr Preconditions/checkState(§ pars 0 <= onWalletChangedSuppressions))

        (§ if (§ expr 0 < onWalletChangedSuppressions))
        (§ block
            (§ return nil)
        )

        (§ for (§ var #_final ListenerRegistration<WalletChangeEventListener> registration) :for changeListeners)
        (§ block
            (§ expr registration.executor.execute(§ pars (§ new #_"Runnable" (§ pars ))
            (§ anon
                #_override
                #_public
                (§ method #_"void" (§ fn run) [])
                (§ block
                    (§ expr registration.listener.onWalletChanged(§ pars Wallet.this))
                    (§ void nil)
                )
            )))
        )
        (§ void nil)
    )

    #_protected
    (§ method #_"void" (§ fn queueOnCoinsReceived) [#_final #_"Transaction" (§ name tx), #_final #_"Coin" (§ name balance), #_final #_"Coin" (§ name newBalance)])
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ for (§ var #_final ListenerRegistration<WalletCoinsReceivedEventListener> registration) :for coinsReceivedListeners)
        (§ block
            (§ expr registration.executor.execute(§ pars (§ new #_"Runnable" (§ pars ))
            (§ anon
                #_override
                #_public
                (§ method #_"void" (§ fn run) [])
                (§ block
                    (§ expr registration.listener.onCoinsReceived(§ pars (§ dhis Wallet), tx, balance, newBalance))
                    (§ void nil)
                )
            )))
        )
        (§ void nil)
    )

    #_protected
    (§ method #_"void" (§ fn queueOnCoinsSent) [#_final #_"Transaction" (§ name tx), #_final #_"Coin" (§ name prevBalance), #_final #_"Coin" (§ name newBalance)])
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ for (§ var #_final ListenerRegistration<WalletCoinsSentEventListener> registration) :for coinsSentListeners)
        (§ block
            (§ expr registration.executor.execute(§ pars (§ new #_"Runnable" (§ pars ))
            (§ anon
                #_override
                #_public
                (§ method #_"void" (§ fn run) [])
                (§ block
                    (§ expr registration.listener.onCoinsSent(§ pars (§ dhis Wallet), tx, prevBalance, newBalance))
                    (§ void nil)
                )
            )))
        )
        (§ void nil)
    )

    #_protected
    (§ method #_"void" (§ fn queueOnReorganize) [])
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ expr Preconditions/checkState(§ pars insideReorg))

        (§ for (§ var #_final ListenerRegistration<WalletReorganizeEventListener> registration) :for reorganizeListeners)
        (§ block
            (§ expr registration.executor.execute(§ pars (§ new #_"Runnable" (§ pars ))
            (§ anon
                #_override
                #_public
                (§ method #_"void" (§ fn run) [])
                (§ block
                    (§ expr registration.listener.onReorganize(§ pars Wallet.this))
                    (§ void nil)
                )
            )))
        )
        (§ void nil)
    )

    ;;;
     ; Returns a set of all transactions in the wallet.
     ; @param includeDead If true, transactions that were overridden by a double spend are included.
     ;;
    #_public
    (§ method #_"Set<Transaction>" (§ fn getTransactions) [#_"boolean" (§ name includeDead)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"Set<Transaction>" (§ name all) (§ new #_"HashSet<>" (§ pars )))
            (§ expr all.addAll(§ pars unspent.values(§ pars )))
            (§ expr all.addAll(§ pars spent.values(§ pars )))
            (§ expr all.addAll(§ pars pending.values(§ pars )))
            (§ if includeDead)
            (§ block
                (§ expr all.addAll(§ pars dead.values(§ pars )))
            )
            (§ return all)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a set of all WalletTransactions in the wallet.
     ;;
    #_public
    (§ method #_"Iterable<WalletTransaction>" (§ fn getWalletTransactions) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"Set<WalletTransaction>" (§ name all) (§ new #_"HashSet<>" (§ pars )))
            (§ expr addWalletTransactionsToSet(§ pars all, Pool/UNSPENT, unspent.values(§ pars )))
            (§ expr addWalletTransactionsToSet(§ pars all, Pool/SPENT, spent.values(§ pars )))
            (§ expr addWalletTransactionsToSet(§ pars all, Pool/DEAD, dead.values(§ pars )))
            (§ expr addWalletTransactionsToSet(§ pars all, Pool/PENDING, pending.values(§ pars )))
            (§ return all)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_private
    #_static
    (§ method #_"void" (§ fn addWalletTransactionsToSet) [#_"Set<WalletTransaction>" (§ name txns), #_"Pool" (§ name poolType), #_"Collection<Transaction>" (§ name pool)])
    (§ block
        (§ for (§ var #_"Transaction" (§ name tx)) :for pool)
        (§ block
            (§ expr txns.add(§ pars (§ new #_"WalletTransaction" (§ pars poolType, tx))))
        )
        (§ void nil)
    )

    ;;;
     ; Adds a transaction that has been associated with a particular wallet pool.  This is intended for usage by
     ; deserialization code, such as the {@link WalletProtobufSerializer} class.  It isn't normally useful for
     ; applications.  It does not trigger auto saving.
     ;;
    #_public
    (§ method #_"void" (§ fn addWalletTransaction) [#_"WalletTransaction" (§ name wtx)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr addWalletTransaction(§ pars wtx.getPool(§ pars ), wtx.getTransaction(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Adds the given transaction to the given pools and registers a confidence change listener on it.
     ;;
    #_private
    (§ method #_"void" (§ fn addWalletTransaction) [#_"Pool" (§ name pool), #_"Transaction" (§ name tx)])
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        (§ expr transactions.put(§ pars tx.getHash(§ pars ), tx))
        (§ switch pool)
        (§ block
            (§ case UNSPENT)
            (§ block
                (§ expr Preconditions/checkState(§ pars unspent.put(§ pars tx.getHash(§ pars ), tx) == nil))
                (§ break )
            )
            (§ case SPENT)
            (§ block
                (§ expr Preconditions/checkState(§ pars spent.put(§ pars tx.getHash(§ pars ), tx) == nil))
                (§ break )
            )
            (§ case PENDING)
            (§ block
                (§ expr Preconditions/checkState(§ pars pending.put(§ pars tx.getHash(§ pars ), tx) == nil))
                (§ break )
            )
            (§ case DEAD)
            (§ block
                (§ expr Preconditions/checkState(§ pars dead.put(§ pars tx.getHash(§ pars ), tx) == nil))
                (§ break )
            )
            (§ default )
            (§ block
                (§ throw (§ new #_"RuntimeException" (§ pars "Unknown wallet transaction type " + pool)))
            )
        )

        (§ if (§ expr pool == Pool/UNSPENT || pool == Pool/PENDING))
        (§ block
            (§ for (§ var #_"TransactionOutput" (§ name output)) :for (§ expr tx.getOutputs(§ pars )))
            (§ block
                (§ if (§ expr output.isAvailableForSpending(§ pars ) && output.isMine(§ pars this)))
                (§ block
                    (§ expr myUnspents.add(§ pars output))
                )
            )
        )
        ;; This is safe even if the listener has been added before, as TransactionConfidence ignores duplicate
        ;; registration requests.  That makes the code in the wallet simpler.
        (§ expr tx.getConfidence(§ pars ).addEventListener(§ pars Threading/SAME_THREAD, txConfidenceListener))
        (§ void nil)
    )

    ;;;
     ; Returns all non-dead, active transactions ordered by recency.
     ;;
    #_public
    (§ method #_"List<Transaction>" (§ fn getTransactionsByTime) [])
    (§ block
        (§ return (§ expr getRecentTransactions(§ pars 0, false)))
    )

    ;;;
     ; Returns an list of N transactions, ordered by increasing age.  Transactions on side chains are not included.
     ; Dead transactions (overridden by double spends) are optionally included.
     ;
     ; Note: the current implementation is O(num transactions in wallet).  Regardless of how many transactions are
     ; requested, the cost is always the same.  In future, requesting smaller numbers of transactions may be faster
     ; depending on how the wallet is implemented (e.g. if backed by a database).
     ;;
    #_public
    (§ method #_"List<Transaction>" (§ fn getRecentTransactions) [#_"int" (§ name numTransactions), #_"boolean" (§ name includeDead)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr Preconditions/checkArgument(§ pars 0 <= numTransactions))

            ;; Firstly, put all transactions into an array.
            (§ var #_"int" (§ name size) (§ expr unspent.size(§ pars ) + spent.size(§ pars ) + pending.size(§ pars )))
            (§ if (§ expr size < numTransactions || numTransactions == 0))
            (§ block
                (§ ass (§ name numTransactions) size)
            )

            (§ var #_"ArrayList<Transaction>" (§ name all) (§ new #_"ArrayList<>" (§ pars getTransactions(§ pars includeDead))))
            ;; Order by update time.
            (§ expr Collections/sort(§ pars all, Transaction/SORT_TX_BY_UPDATE_TIME))
            (§ if (§ expr numTransactions == all.size(§ pars )))
            (§ block
                (§ return all)
            )

            (§ expr all.subList(§ pars numTransactions, all.size(§ pars )).clear(§ pars ))
            (§ return all)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a transaction object given its hash, if it exists in this wallet, or null otherwise.
     ;;
    #_nilable
    #_public
    (§ method #_"Transaction" (§ fn getTransaction) [#_"Sha256Hash" (§ name hash)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr transactions.get(§ pars hash)))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;; {@inheritDoc} ;;
    #_override
    #_public
    (§ method #_"Map<Sha256Hash, Transaction>" (§ fn getTransactionPool) [#_"Pool" (§ name pool)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ switch pool)
            (§ block
                (§ case UNSPENT)
                (§ block
                    (§ return unspent)
                )
                (§ case SPENT)
                (§ block
                    (§ return spent)
                )
                (§ case PENDING)
                (§ block
                    (§ return pending)
                )
                (§ case DEAD)
                (§ block
                    (§ return dead)
                )
                (§ default )
                (§ block
                    (§ throw (§ new #_"RuntimeException" (§ pars "Unknown wallet transaction type " + pool)))
                )
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Prepares the wallet for a blockchain replay.  Removes all transactions (as they would
     ; get in the way of the replay) and makes the wallet think it has never seen a block.
     ;;
    #_public
    (§ method #_"void" (§ fn reset) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr clearTransactions(§ pars ))
            (§ ass (§ name lastBlockSeenHash) nil)
            (§ ass (§ name lastBlockSeenHeight) -1) ;; Magic value for 'never'.
            (§ ass (§ name lastBlockSeenTimeSecs) 0)
            (§ expr saveLater(§ pars ))
            (§ expr maybeQueueOnWalletChanged(§ pars ))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Deletes transactions which appeared above the given block height from the wallet, but does not touch the keys.
     ; This is useful if you have some keys and wish to replay the block chain into the wallet in order to pick them up.
     ; Triggers auto saving.
     ;;
    #_public
    (§ method #_"void" (§ fn clearTransactions) [#_"int" (§ name fromHeight)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr fromHeight == 0))
            (§ block
                (§ expr clearTransactions(§ pars ))
                (§ expr saveLater(§ pars ))
            )
            (§ else )
            (§ block
                (§ throw (§ new #_"UnsupportedOperationException" (§ pars )))
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn clearTransactions) [])
    (§ block
        (§ expr unspent.clear(§ pars ))
        (§ expr spent.clear(§ pars ))
        (§ expr pending.clear(§ pars ))
        (§ expr dead.clear(§ pars ))
        (§ expr transactions.clear(§ pars ))
        (§ expr myUnspents.clear(§ pars ))
        (§ void nil)
    )

    ;;;
     ; Clean up the wallet.  Currently, it only removes risky pending transaction from the wallet and only
     ; if their outputs have not been spent.
     ;;
    #_public
    (§ method #_"void" (§ fn cleanup) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"boolean" (§ name dirty) false)
            (§ for (§ var #_"Iterator<Transaction>" (§ name i) (§ expr pending.values(§ pars ).iterator(§ pars ))) :for (§ expr i.hasNext(§ pars )) :for (§ expr ))
            (§ block
                (§ var #_"Transaction" (§ name tx) (§ expr i.next(§ pars )))
                (§ if (§ expr isTransactionRisky(§ pars tx, nil) && (§ not acceptRiskyTransactions)))
                (§ block
                    (§ expr log.debug(§ pars "Found risky transaction {} in wallet during cleanup.", tx.getHashAsString(§ pars )))
                    (§ if (§ expr (§ not tx.isAnyOutputSpent(§ pars ))))
                    (§ block
                        ;; Sync myUnspents with the change.
                        (§ for (§ var #_"TransactionInput" (§ name input)) :for (§ expr tx.getInputs(§ pars )))
                        (§ block
                            (§ var #_"TransactionOutput" (§ name output) (§ expr input.getConnectedOutput(§ pars )))
                            (§ if (§ expr output == nil))
                            (§ block
                                (§ continue )
                            )
                            (§ if (§ expr output.isMine(§ pars this)))
                            (§ block
                                (§ expr Preconditions/checkState(§ pars myUnspents.add(§ pars output)))
                            )
                            (§ expr input.disconnect(§ pars ))
                        )
                        (§ for (§ var #_"TransactionOutput" (§ name output)) :for (§ expr tx.getOutputs(§ pars )))
                        (§ block
                            (§ expr myUnspents.remove(§ pars output))
                        )

                        (§ expr i.remove(§ pars ))
                        (§ expr transactions.remove(§ pars tx.getHash(§ pars )))
                        (§ ass (§ name dirty) true)
                        (§ expr log.info(§ pars "Removed transaction {} from pending pool during cleanup.", tx.getHashAsString(§ pars )))
                    )
                    (§ else )
                    (§ block
                        (§ expr log.info(§ pars "Cannot remove transaction {} from pending pool during cleanup, as it's already spent partially.", tx.getHashAsString(§ pars )))
                    )
                )
            )
            (§ if dirty)
            (§ block
                (§ expr isConsistentOrThrow(§ pars ))
                (§ expr saveLater(§ pars ))
                (§ if (§ expr log.isInfoEnabled(§ pars )))
                (§ block
                    (§ expr log.info(§ pars "Estimated balance is now: {}", getBalance(§ pars BalanceType/ESTIMATED).toFriendlyString(§ pars )))
                )
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    (§ method #_"EnumSet<Pool>" (§ fn getContainingPools) [#_"Transaction" (§ name tx)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"EnumSet<Pool>" (§ name result) (§ expr EnumSet/noneOf(§ pars (§ klass #_"Pool"))))
            (§ var #_"Sha256Hash" (§ name txHash) (§ expr tx.getHash(§ pars )))
            (§ if (§ expr unspent.containsKey(§ pars txHash)))
            (§ block
                (§ expr result.add(§ pars Pool/UNSPENT))
            )
            (§ if (§ expr spent.containsKey(§ pars txHash)))
            (§ block
                (§ expr result.add(§ pars Pool/SPENT))
            )
            (§ if (§ expr pending.containsKey(§ pars txHash)))
            (§ block
                (§ expr result.add(§ pars Pool/PENDING))
            )
            (§ if (§ expr dead.containsKey(§ pars txHash)))
            (§ block
                (§ expr result.add(§ pars Pool/DEAD))
            )
            (§ return result)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_testing
    #_public
    (§ method #_"int" (§ fn getPoolSize) [#_"WalletTransaction.Pool" (§ name pool)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ switch pool)
            (§ block
                (§ case UNSPENT)
                (§ block
                    (§ return (§ expr unspent.size(§ pars )))
                )
                (§ case SPENT)
                (§ block
                    (§ return (§ expr spent.size(§ pars )))
                )
                (§ case PENDING)
                (§ block
                    (§ return (§ expr pending.size(§ pars )))
                )
                (§ case DEAD)
                (§ block
                    (§ return (§ expr dead.size(§ pars )))
                )
            )
            (§ throw (§ new #_"RuntimeException" (§ pars "Unreachable")))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_testing
    #_public
    (§ method #_"boolean" (§ fn poolContainsTxHash) [#_final #_"WalletTransaction.Pool" (§ name pool), #_final #_"Sha256Hash" (§ name txHash)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ switch pool)
            (§ block
                (§ case UNSPENT)
                (§ block
                    (§ return (§ expr unspent.containsKey(§ pars txHash)))
                )
                (§ case SPENT)
                (§ block
                    (§ return (§ expr spent.containsKey(§ pars txHash)))
                )
                (§ case PENDING)
                (§ block
                    (§ return (§ expr pending.containsKey(§ pars txHash)))
                )
                (§ case DEAD)
                (§ block
                    (§ return (§ expr dead.containsKey(§ pars txHash)))
                )
            )
            (§ throw (§ new #_"RuntimeException" (§ pars "Unreachable")))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;; Returns a copy of the internal unspent outputs list. ;;
    #_public
    (§ method #_"List<TransactionOutput>" (§ fn getUnspents) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ new #_"ArrayList<>" (§ pars myUnspents)))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_override
    #_public
    (§ method #_"String" (§ fn toString) [])
    (§ block
        (§ return (§ expr toString(§ pars false, true, nil)))
    )

    ;;;
     ; Formats the wallet as a human readable piece of text.  Intended for debugging, the format is
     ; not meant to be stable or human readable.
     ; @param includePrivateKeys Whether raw private key data should be included.
     ; @param includeTransactions Whether to print transaction data.
     ; @param chain If set, will be used to estimate lock times for block timelocked transactions.
     ;;
    #_public
    (§ method #_"String" (§ fn toString) [#_"boolean" (§ name includePrivateKeys), #_"boolean" (§ name includeTransactions), #_nilable #_"AbstractBlockChain" (§ name chain)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"StringBuilder" (§ name sb) (§ new #_"StringBuilder" (§ pars )))
            (§ var #_"Coin" (§ name estimatedBalance) (§ expr getBalance(§ pars BalanceType/ESTIMATED)))
            (§ var #_"Coin" (§ name availableBalance) (§ expr getBalance(§ pars BalanceType/AVAILABLE_SPENDABLE)))
            (§ expr sb.append(§ pars "Wallet containing ").append(§ pars estimatedBalance.toFriendlyString(§ pars )).append(§ pars " (spendable: ").append(§ pars availableBalance.toFriendlyString(§ pars )).append(§ pars ") in:\n"))
            (§ expr sb.append(§ pars "  ").append(§ pars pending.size(§ pars )).append(§ pars " pending transactions\n"))
            (§ expr sb.append(§ pars "  ").append(§ pars unspent.size(§ pars )).append(§ pars " unspent transactions\n"))
            (§ expr sb.append(§ pars "  ").append(§ pars spent.size(§ pars )).append(§ pars " spent transactions\n"))
            (§ expr sb.append(§ pars "  ").append(§ pars dead.size(§ pars )).append(§ pars " dead transactions\n"))
            #_final
            (§ var #_"Date" (§ name lastBlockSeenTime) (§ expr getLastBlockSeenTime(§ pars )))
            (§ expr sb.append(§ pars "Last seen best block: ").append(§ pars getLastBlockSeenHeight(§ pars )).append(§ pars " (").append(§ pars (§ quest (§ expr lastBlockSeenTime == nil) ? (§ expr "time unknown") :else (§ expr Utils/dateTimeFormat(§ pars lastBlockSeenTime)))).append(§ pars "): ").append(§ pars getLastBlockSeenHash(§ pars )).append(§ pars "\n"))
            #_final
            (§ var #_"KeyCrypter" (§ name crypter) (§ expr keyChainGroup.getKeyCrypter(§ pars )))
            (§ if (§ expr crypter != nil))
            (§ block
                (§ expr sb.append(§ pars "Encryption: ").append(§ pars crypter).append(§ pars "\n"))
            )
            (§ if (§ expr isWatching(§ pars )))
            (§ block
                (§ expr sb.append(§ pars "Wallet is watching.\n"))
            )

            ;; Do the keys.
            (§ expr sb.append(§ pars "\nKeys:\n"))
            (§ expr sb.append(§ pars "Earliest creation time: ").append(§ pars Utils/dateTimeFormat(§ pars getEarliestKeyCreationTime(§ pars ) * 1000)).append(§ pars "\n"))
            #_final
            (§ var #_"Date" (§ name keyRotationTime) (§ expr getKeyRotationTime(§ pars )))
            (§ if (§ expr keyRotationTime != nil))
            (§ block
                (§ expr sb.append(§ pars "Key rotation time:      ").append(§ pars Utils/dateTimeFormat(§ pars keyRotationTime)).append(§ pars "\n"))
            )
            (§ expr sb.append(§ pars keyChainGroup.toString(§ pars includePrivateKeys)))

            (§ if includeTransactions)
            (§ block
                ;; Print the transactions themselves.
                (§ if (§ expr 0 < pending.size(§ pars )))
                (§ block
                    (§ expr sb.append(§ pars "\n>>> PENDING:\n"))
                    (§ expr toStringHelper(§ pars sb, pending, chain, Transaction/SORT_TX_BY_UPDATE_TIME))
                )
                (§ if (§ expr 0 < unspent.size(§ pars )))
                (§ block
                    (§ expr sb.append(§ pars "\n>>> UNSPENT:\n"))
                    (§ expr toStringHelper(§ pars sb, unspent, chain, Transaction/SORT_TX_BY_HEIGHT))
                )
                (§ if (§ expr 0 < spent.size(§ pars )))
                (§ block
                    (§ expr sb.append(§ pars "\n>>> SPENT:\n"))
                    (§ expr toStringHelper(§ pars sb, spent, chain, Transaction/SORT_TX_BY_HEIGHT))
                )
                (§ if (§ expr 0 < dead.size(§ pars )))
                (§ block
                    (§ expr sb.append(§ pars "\n>>> DEAD:\n"))
                    (§ expr toStringHelper(§ pars sb, dead, chain, Transaction/SORT_TX_BY_UPDATE_TIME))
                )
            )
            (§ return (§ expr sb.toString(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_private
    (§ method #_"void" (§ fn toStringHelper) [#_"StringBuilder" (§ name sb), #_"Map<Sha256Hash, Transaction>" (§ name transactionMap), #_nilable #_"AbstractBlockChain" (§ name chain), #_nilable #_"Comparator<Transaction>" (§ name sortOrder)])
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        #_final
        (§ var #_"Collection<Transaction>" (§ name txns))
        (§ if (§ expr sortOrder != nil))
        (§ block
            (§ ass (§ name txns) (§ new #_"TreeSet<>" (§ pars sortOrder)))
            (§ expr txns.addAll(§ pars transactionMap.values(§ pars )))
        )
        (§ else )
        (§ block
            (§ ass (§ name txns) (§ expr transactionMap.values(§ pars )))
        )

        (§ for (§ var #_"Transaction" (§ name tx)) :for txns)
        (§ block
            (§ try )
            (§ block
                (§ expr sb.append(§ pars tx.getValue(§ pars this).toFriendlyString(§ pars )))
                (§ expr sb.append(§ pars " total value (sends "))
                (§ expr sb.append(§ pars tx.getValueSentFromMe(§ pars this).toFriendlyString(§ pars )))
                (§ expr sb.append(§ pars " and receives "))
                (§ expr sb.append(§ pars tx.getValueSentToMe(§ pars this).toFriendlyString(§ pars )))
                (§ expr sb.append(§ pars ")\n"))
            )
            (§ catch #_"ScriptException" (§ name _))
            (§ block
                ;; Ignore and don't print this line.
            )
            (§ if (§ expr tx.hasConfidence(§ pars )))
            (§ block
                (§ expr sb.append(§ pars "  confidence: ").append(§ pars tx.getConfidence(§ pars )).append(§ pars "\n"))
            )
            (§ expr sb.append(§ pars tx.toString(§ pars chain)))
        )
        (§ void nil)
    )

    ;;;
     ; Returns an immutable view of the transactions currently waiting for network confirmations.
     ;;
    #_public
    (§ method #_"Collection<Transaction>" (§ fn getPendingTransactions) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr Collections/unmodifiableCollection(§ pars pending.values(§ pars ))))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the earliest creation time of keys or watched scripts in this wallet, in seconds since the epoch,
     ; i.e. the min of {@link org.bitcoinj.core.ECKey#getCreationTimeSeconds()}.  This can return zero if at least
     ; one key does not have that data (was created before key timestamping was implemented).
     ;
     ; This method is most often used in conjunction with {@link PeerGroup#setFastCatchupTimeSecs(long)} in order to
     ; optimize chain download for new users of wallet apps.  Backwards compatibility notice: if you get zero from this
     ; method, you can instead use the time of the first release of your software, as it's guaranteed no users will
     ; have wallets pre-dating this time.
     ;
     ; If there are no keys in the wallet, the current time is returned.
     ;;
    #_override
    #_public
    (§ method #_"long" (§ fn getEarliestKeyCreationTime) [])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"long" (§ name earliestTime) (§ expr keyChainGroup.getEarliestKeyCreationTime(§ pars )))
            (§ return (§ quest (§ expr earliestTime == Long/MAX_VALUE) ? (§ expr Utils/currentTimeSeconds(§ pars )) :else earliestTime))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    ;;; Returns the hash of the last seen best-chain block, or null if the wallet is too old to store this data. ;;
    #_nilable
    #_public
    (§ method #_"Sha256Hash" (§ fn getLastBlockSeenHash) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return lastBlockSeenHash)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_public
    (§ method #_"void" (§ fn setLastBlockSeenHash) [#_nilable #_"Sha256Hash" (§ name lastBlockSeenHash)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name this.lastBlockSeenHash) lastBlockSeenHash)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    #_public
    (§ method #_"void" (§ fn setLastBlockSeenHeight) [#_"int" (§ name lastBlockSeenHeight)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name this.lastBlockSeenHeight) lastBlockSeenHeight)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    #_public
    (§ method #_"void" (§ fn setLastBlockSeenTimeSecs) [#_"long" (§ name timeSecs)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name lastBlockSeenTimeSecs) timeSecs)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Returns the UNIX time in seconds since the epoch extracted from the last best seen block header.  This timestamp
     ; is <b>not</b> the local time at which the block was first observed by this application but rather what the block
     ; (i.e. miner) self declares.  It is allowed to have some significant drift from the real time at which the block
     ; was found, although most miners do use accurate times.  If this wallet is old and does not have a recorded
     ; time then this method returns zero.
     ;;
    #_public
    (§ method #_"long" (§ fn getLastBlockSeenTimeSecs) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return lastBlockSeenTimeSecs)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns a {@link Date} representing the time extracted from the last best seen block header.  This timestamp
     ; is <b>not</b> the local time at which the block was first observed by this application but rather what the block
     ; (i.e. miner) self declares.  It is allowed to have some significant drift from the real time at which the block
     ; was found, although most miners do use accurate times.  If this wallet is old and does not have a recorded
     ; time then this method returns null.
     ;;
    #_nilable
    #_public
    (§ method #_"Date" (§ fn getLastBlockSeenTime) [])
    (§ block
        #_final
        (§ var #_"long" (§ name secs) (§ expr getLastBlockSeenTimeSecs(§ pars )))
        (§ return (§ quest (§ expr secs == 0) ? nil :else (§ new #_"Date" (§ pars secs * 1000))))
    )

    ;;;
     ; Returns the height of the last seen best-chain block.  Can be 0 if a wallet is brand new or -1 if the wallet
     ; is old and doesn't have that data.
     ;;
    #_public
    (§ method #_"int" (§ fn getLastBlockSeenHeight) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return lastBlockSeenHeight)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Get the version of the Wallet.
     ; This is an int you can use to indicate which versions of wallets your code understands,
     ; and which come from the future (and hence cannot be safely loaded).
     ;;
    #_public
    (§ method #_"int" (§ fn getVersion) [])
    (§ block
        (§ return version)
    )

    ;;;
     ; Set the version number of the wallet.  See {@link Wallet#getVersion()}.
     ;;
    #_public
    (§ method #_"void" (§ fn setVersion) [#_"int" (§ name version)])
    (§ block
        (§ ass (§ name this.version) version)
        (§ void nil)
    )

    ;;;
     ; Set the description of the wallet.
     ; This is a Unicode encoding string typically entered by the user as descriptive text for the wallet.
     ;;
    #_public
    (§ method #_"void" (§ fn setDescription) [#_"String" (§ name description)])
    (§ block
        (§ ass (§ name this.description) description)
        (§ void nil)
    )

    ;;;
     ; Get the description of the wallet.  See {@link Wallet#setDescription(String)}.
     ;;
    #_public
    (§ method #_"String" (§ fn getDescription) [])
    (§ block
        (§ return description)
    )

    ;;;
     ; <p>It's possible to calculate a wallets balance from multiple points of view.  This enum selects which
     ; {@link #getBalance(BalanceType)} should use.</p>
     ;
     ; <p>Consider a real-world example: you buy a snack costing $5 but you only have a $10 bill.  At the start
     ; you have $10 viewed from every possible angle.  After you order the snack you hand over your $10 bill.
     ; From the perspective of your wallet you have zero dollars (AVAILABLE).  But you know in a few seconds the
     ; shopkeeper will give you back $5 change so most people in practice would say they have $5 (ESTIMATED).</p>
     ;
     ; <p>The fact that the wallet can track transactions which are not spendable by itself ("watching wallets")
     ; adds another type of balance to the mix.  Although the wallet won't do this by default, advanced use cases
     ; that override the relevancy checks can end up with a mix of spendable and unspendable transactions.</p>
     ;;
    #_public
    (§ enum #_"BalanceType"
        ;;;
         ; Balance calculated assuming all pending transactions are in fact included into the best chain by miners.
         ; This includes the value of immature coinbase transactions.
         ;;
        (§ item ESTIMATED)

        ;;;
         ; Balance that could be safely used to create new spends, if we had all the needed private keys.  This is
         ; whatever the default coin selector would make available, which by default means transaction outputs with at
         ; least 1 confirmation and pending transactions created by our own wallet which have been propagated across
         ; the network.  Whether we <i>actually</i> have the private keys or not is irrelevant for this balance type.
         ;;
        (§ item AVAILABLE)

        ;;; Same as ESTIMATED but only for outputs we have the private keys for and can sign ourselves. ;;
        (§ item ESTIMATED_SPENDABLE)
        ;;; Same as AVAILABLE but only for outputs we have the private keys for and can sign ourselves. ;;
        (§ item AVAILABLE_SPENDABLE)
    )

    ;;;
     ; Returns the AVAILABLE balance of this wallet.
     ; See {@link BalanceType#AVAILABLE} for details on what this means.
     ;;
    #_public
    (§ method #_"Coin" (§ fn getBalance) [])
    (§ block
        (§ return (§ expr getBalance(§ pars BalanceType/AVAILABLE)))
    )

    ;;;
     ; Returns the balance of this wallet as calculated by the provided balanceType.
     ;;
    #_public
    (§ method #_"Coin" (§ fn getBalance) [#_"BalanceType" (§ name balanceType)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr balanceType == BalanceType/AVAILABLE || balanceType == BalanceType/AVAILABLE_SPENDABLE))
            (§ block
                (§ var #_"List<TransactionOutput>" (§ name candidates) (§ expr calculateAllSpendCandidates(§ pars true, balanceType == BalanceType/AVAILABLE_SPENDABLE)))
                (§ var #_"CoinSelection" (§ name selection) (§ expr coinSelector.select(§ pars NetworkParameters/MAX_MONEY, candidates)))
                (§ return (§ expr selection.valueGathered))
            )
            (§ elseif (§ expr balanceType == BalanceType/ESTIMATED || balanceType == BalanceType/ESTIMATED_SPENDABLE))
            (§ block
                (§ var #_"List<TransactionOutput>" (§ name all) (§ expr calculateAllSpendCandidates(§ pars false, balanceType == BalanceType/ESTIMATED_SPENDABLE)))
                (§ var #_"Coin" (§ name value) (§ expr Coin/ZERO))
                (§ for (§ var #_"TransactionOutput" (§ name out)) :for all)
                (§ block
                    (§ ass (§ name value) (§ expr value.add(§ pars out.getValue(§ pars ))))
                )
                (§ return value)
            )
            (§ else )
            (§ block
                (§ throw (§ new #_"AssertionError" (§ pars "Unknown balance type"))) ;; Unreachable.
            )
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns the balance that would be considered spendable by the given coin selector, including watched outputs
     ; (i.e. balance includes outputs we don't have the private keys for).  Just asks it to select as many coins as
     ; possible and returns the total.
     ;;
    #_public
    (§ method #_"Coin" (§ fn getBalance) [#_"CoinSelector" (§ name selector)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr Preconditions/checkNotNull(§ pars selector))

            (§ var #_"List<TransactionOutput>" (§ name candidates) (§ expr calculateAllSpendCandidates(§ pars true, false)))
            (§ var #_"CoinSelection" (§ name selection) (§ expr selector.select(§ pars params.getMaxMoney(§ pars ), candidates)))
            (§ return (§ expr selection.valueGathered))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    #_private
    #_static
    (§ class #_"BalanceFutureRequest"
        #_public
        (§ field #_"SettableFuture<Coin>" (§ name future))
        #_public
        (§ field #_"Coin" (§ name value))
        #_public
        (§ field #_"BalanceType" (§ name type))
    )
    #_guarded-by(§ opt "lock")
    #_private
    (§ field #_"List<BalanceFutureRequest>" (§ name balanceFutureRequests) (§ expr Lists/newLinkedList(§ pars )))

    ;;;
     ; <p>Returns a future that will complete when the balance of the given type has become equal or larger to the
     ; given value.  If the wallet already has a large enough balance the future is returned in a pre-completed state.
     ; Note that this method is not blocking, if you want to actually wait immediately, you have to call .get() on
     ; the result.</p>
     ;
     ; <p>Also note that by the time the future completes, the wallet may have changed yet again if something else
     ; is going on in parallel, so you should treat the returned balance as advisory and be prepared for sending
     ; money to fail!  Finally please be aware that any listeners on the future will run either on the calling thread
     ; if it completes immediately, or eventually on a background thread if the balance is not yet at the right
     ; level.  If you do something that means you know the balance should be sufficient to trigger the future,
     ; you can use {@link org.bitcoinj.utils.Threading#waitForUserCode()} to block until the future had a
     ; chance to be updated.</p>
     ;;
    #_public
    (§ method #_"ListenableFuture<Coin>" (§ fn getBalanceFuture) [#_final #_"Coin" (§ name value), #_final #_"BalanceType" (§ name type)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            #_final
            (§ var #_"SettableFuture<Coin>" (§ name future) (§ expr SettableFuture/create(§ pars )))
            #_final
            (§ var #_"Coin" (§ name current) (§ expr getBalance(§ pars type)))
            (§ if (§ expr 0 <= current.compareTo(§ pars value)))
            (§ block
                ;; Already have enough.
                (§ expr future.set(§ pars current))
            )
            (§ else )
            (§ block
                ;; Will be checked later in checkBalanceFutures.  We don't just add an event listener for ourselves
                ;; here so that running getBalanceFuture().get() in the user code thread works - generally we must
                ;; avoid giving the user back futures that require the user code thread to be free.
                (§ var #_"BalanceFutureRequest" (§ name req) (§ new #_"BalanceFutureRequest" (§ pars )))
                (§ ass (§ name req.future) future)
                (§ ass (§ name req.value) value)
                (§ ass (§ name req.type) type)
                (§ expr balanceFutureRequests.add(§ pars req))
            )
            (§ return future)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;; Runs any balance futures in the user code thread.
    #_suppress(§ opt "FieldAccessNotGuarded")
    #_private
    (§ method #_"void" (§ fn checkBalanceFuturesLocked) [#_nilable #_"Coin" (§ name avail)])
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))

        #_final
        (§ var #_"ListIterator<BalanceFutureRequest>" (§ name it) (§ expr balanceFutureRequests.listIterator(§ pars )))
        (§ while (§ expr it.hasNext(§ pars )))
        (§ block
            #_final
            (§ var #_"BalanceFutureRequest" (§ name req) (§ expr it.next(§ pars )))
            (§ var #_"Coin" (§ name val) (§ expr getBalance(§ pars req.type))) ;; This could be slow for lots of futures.
            (§ if (§ expr val.compareTo(§ pars req.value) < 0))
            (§ block
                (§ continue )
            )
            ;; Found one that's finished.
            (§ expr it.remove(§ pars ))
            #_final
            (§ var #_"Coin" (§ name v) val)
            ;; Don't run any user-provided future listeners with our lock held.
            (§ expr Threading/USER_THREAD.execute(§ pars (§ new #_"Runnable" (§ pars ))
            (§ anon
                #_override
                #_public
                (§ method #_"void" (§ fn run) [])
                (§ block
                    (§ expr req.future.set(§ pars v))
                    (§ void nil)
                )
            )))
        )
        (§ void nil)
    )

    ;;;
     ; Returns the amount of bitcoin ever received via output.  <b>This is not the balance!</b>  If an output
     ; spends from a transaction whose inputs are also to our wallet, the input amounts are deducted from the
     ; outputs contribution, with a minimum of zero contribution.  The idea behind this is we avoid double
     ; counting money sent to us.
     ; @return the total amount of satoshis received, regardless of whether it was spent or not.
     ;;
    #_public
    (§ method #_"Coin" (§ fn getTotalReceived) [])
    (§ block
        (§ var #_"Coin" (§ name total) (§ expr Coin/ZERO))

        ;; Include outputs to us if they were not just change outputs, i.e. the inputs to us summed to less
        ;; than the outputs to us.
        (§ for (§ var #_"Transaction" (§ name tx)) :for (§ expr transactions.values(§ pars )))
        (§ block
            (§ var #_"Coin" (§ name txTotal) (§ expr Coin/ZERO))
            (§ for (§ var #_"TransactionOutput" (§ name output)) :for (§ expr tx.getOutputs(§ pars )))
            (§ block
                (§ if (§ expr output.isMine(§ pars this)))
                (§ block
                    (§ ass (§ name txTotal) (§ expr txTotal.add(§ pars output.getValue(§ pars ))))
                )
            )
            (§ for (§ var #_"TransactionInput" (§ name in)) :for (§ expr tx.getInputs(§ pars )))
            (§ block
                (§ var #_"TransactionOutput" (§ name prevOut) (§ expr in.getConnectedOutput(§ pars )))
                (§ if (§ expr prevOut != nil && prevOut.isMine(§ pars this)))
                (§ block
                    (§ ass (§ name txTotal) (§ expr txTotal.subtract(§ pars prevOut.getValue(§ pars ))))
                )
            )
            (§ if (§ expr txTotal.isPositive(§ pars )))
            (§ block
                (§ ass (§ name total) (§ expr total.add(§ pars txTotal)))
            )
        )
        (§ return total)
    )

    ;;;
     ; Returns the amount of bitcoin ever sent via output.  If an output is sent to our own wallet, because of
     ; change or rotating keys or whatever, we do not count it.  If the wallet was involved in a shared transaction,
     ; i.e. there is some input to the transaction that we don't have the key for, then we multiply the sum of
     ; the output values by the proportion of satoshi coming in to our inputs.  Essentially we treat inputs as
     ; pooling into the transaction, becoming fungible and being equally distributed to all outputs.
     ; @return the total amount of satoshis sent by us.
     ;;
    #_public
    (§ method #_"Coin" (§ fn getTotalSent) [])
    (§ block
        (§ var #_"Coin" (§ name total) (§ expr Coin/ZERO))

        (§ for (§ var #_"Transaction" (§ name tx)) :for (§ expr transactions.values(§ pars )))
        (§ block
            ;; Count spent outputs to only if they were not to us.  This means we don't count change outputs.
            (§ var #_"Coin" (§ name txOutputTotal) (§ expr Coin/ZERO))
            (§ for (§ var #_"TransactionOutput" (§ name out)) :for (§ expr tx.getOutputs(§ pars )))
            (§ block
                (§ if (§ expr (§ not out.isMine(§ pars this))))
                (§ block
                    (§ ass (§ name txOutputTotal) (§ expr txOutputTotal.add(§ pars out.getValue(§ pars ))))
                )
            )

            ;; Count the input values to us
            (§ var #_"Coin" (§ name txOwnedInputsTotal) (§ expr Coin/ZERO))
            (§ for (§ var #_"TransactionInput" (§ name in)) :for (§ expr tx.getInputs(§ pars )))
            (§ block
                (§ var #_"TransactionOutput" (§ name prevOut) (§ expr in.getConnectedOutput(§ pars )))
                (§ if (§ expr prevOut != nil && prevOut.isMine(§ pars this)))
                (§ block
                    (§ ass (§ name txOwnedInputsTotal) (§ expr txOwnedInputsTotal.add(§ pars prevOut.getValue(§ pars ))))
                )
            )

            ;; If there is an input that isn't from us, i.e. this is a shared transaction.
            (§ var #_"Coin" (§ name txInputsTotal) (§ expr tx.getInputSum(§ pars )))
            (§ if (§ expr txOwnedInputsTotal != txInputsTotal))
            (§ block
                ;; Multiply our output total by the appropriate proportion to account for the inputs that we don't own.
                (§ var #_"BigInteger" (§ name txOutputTotalNum) (§ new #_"BigInteger" (§ pars txOutputTotal.toString(§ pars ))))
                (§ ass (§ name txOutputTotalNum) (§ expr txOutputTotalNum.multiply(§ pars (§ new #_"BigInteger" (§ pars txOwnedInputsTotal.toString(§ pars ))))))
                (§ ass (§ name txOutputTotalNum) (§ expr txOutputTotalNum.divide(§ pars (§ new #_"BigInteger" (§ pars txInputsTotal.toString(§ pars ))))))
                (§ ass (§ name txOutputTotal) (§ expr Coin/valueOf(§ pars txOutputTotalNum.longValue(§ pars ))))
            )
            (§ ass (§ name total) (§ expr total.add(§ pars txOutputTotal)))
        )
        (§ return total)
    )

    ;;; A SendResult is returned to you as part of sending coins to a recipient. ;;
    #_public
    #_static
    (§ class #_"SendResult"
        ;;; The Bitcoin transaction message that moves the money. ;;
        #_public
        (§ field #_"Transaction" (§ name tx))
        ;;;
         ; A future that will complete once the tx message has been successfully broadcast to the network.
         ; This is just the result of calling broadcast.future().
         ;;
        #_public
        (§ field #_"ListenableFuture<Transaction>" (§ name broadcastComplete))
        ;;; The broadcast object returned by the linked TransactionBroadcaster. ;;
        #_public
        (§ field #_"TransactionBroadcast" (§ name broadcast))
    )

    ;;;
     ; Enumerates possible resolutions for missing signatures.
     ;;
    #_public
    (§ enum #_"MissingSigsMode"
        ;;; Input script will have OP_0 instead of missing signatures. ;;
        (§ item USE_OP_ZERO)
        ;;;
         ; Missing signatures will be replaced by dummy sigs.  This is useful when you'd like to know the
         ; fee for a transaction without knowing the user's password, as fee depends on size.
         ;;
        (§ item USE_DUMMY_SIG)
        ;;;
         ; If signature is missing, {@link org.bitcoinj.signers.TransactionSigner.MissingSignatureException}
         ; will be thrown for P2SH and {@link ECKey.MissingPrivateKeyException} for other tx types.
         ;;
        (§ item THROW)
    )

    ;;;
     ; <p>Statelessly creates a transaction that sends the given value to address.  The change is sent to
     ; {@link Wallet#currentChangeAddress()}, so you must have added at least one key.</p>
     ;
     ; <p>If you just want to send money quickly, you probably want
     ; {@link Wallet#sendCoins(TransactionBroadcaster, Address, Coin)} instead.  That will create the sending
     ; transaction, commit to the wallet and broadcast it to the network all in one go.  This method is lower
     ; level and lets you see the proposed transaction before anything is done with it.</p>
     ;
     ; <p>This is a helper method that is equivalent to using {@link SendRequest#to(Address, Coin)}
     ; followed by {@link Wallet#completeTx(Wallet.SendRequest)} and returning the requests transaction object.
     ; Note that this means a fee may be automatically added if required, if you want more control over the process,
     ; just do those two steps yourself.</p>
     ;
     ; <p>IMPORTANT: This method does NOT update the wallet.  If you call createSend again you may get two transactions
     ; that spend the same coins.  You have to call {@link Wallet#commitTx(Transaction)} on the created transaction to
     ; prevent this, but that should only occur once the transaction has been accepted by the network.  This implies
     ; you cannot have more than one outstanding sending tx at once.</p>
     ;
     ; <p>You MUST ensure that the value is not smaller than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction
     ; will almost certainly be rejected by the network as dust.</p>
     ;
     ; @param address The Bitcoin address to send the money to.
     ; @param value How much currency to send.
     ; @return either the created Transaction or null if there are insufficient coins.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method #_"Transaction" (§ fn createSend) [#_"Address" (§ name address), #_"Coin" (§ name value)])
        (§ throws #_"InsufficientMoneyException")
    (§ block
        (§ var #_"SendRequest" (§ name req) (§ expr SendRequest/to(§ pars address, value)))
        (§ if (§ expr params.getId(§ pars ).equals(§ pars NetworkParameters/ID_UNITTESTNET)))
        (§ block
            (§ ass (§ name req.shuffleOutputs) false)
        )
        (§ expr completeTx(§ pars req))
        (§ return (§ expr req.tx))
    )

    ;;;
     ; Sends coins to the given address but does not broadcast the resulting pending transaction.  It is still
     ; stored in the wallet, so when the wallet is added to a {@link PeerGroup} or {@link Peer} the transaction
     ; will be announced to the network.  The given {@link SendRequest} is completed first using
     ; {@link Wallet#completeTx(Wallet.SendRequest)} to make it valid.
     ;
     ; @return the Transaction that was created.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method #_"Transaction" (§ fn sendCoinsOffline) [#_"SendRequest" (§ name request)])
        (§ throws #_"InsufficientMoneyException")
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr completeTx(§ pars request))
            (§ expr commitTx(§ pars request.tx))
            (§ return (§ expr request.tx))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; <p>Sends coins to the given address, via the given {@link PeerGroup}.  Change is returned to
     ; {@link Wallet#currentChangeAddress()}.  Note that a fee may be automatically added if one may be required
     ; for the transaction to be confirmed.</p>
     ;
     ; <p>The returned object provides both the transaction, and a future that can be used to learn when the broadcast
     ; is complete.  Complete means, if the PeerGroup is limited to only one connection, when it was written out to
     ; the socket.  Otherwise when the transaction is written out and we heard it back from a different peer.</p>
     ;
     ; <p>Note that the sending transaction is committed to the wallet immediately, not when the transaction is
     ; successfully broadcast.  This means that even if the network hasn't heard about your transaction you won't be
     ; able to spend those same coins again.</p>
     ;
     ; <p>You MUST ensure that value is not smaller than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction will
     ; almost certainly be rejected by the network as dust.</p>
     ;
     ; @param broadcaster A {@link TransactionBroadcaster} to use to send the transactions out.
     ; @param to Which address to send coins to.
     ; @param value How much value to send.
     ; @return an object containing the transaction that was created, and a future for the broadcast of it.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method #_"SendResult" (§ fn sendCoins) [#_"TransactionBroadcaster" (§ name broadcaster), #_"Address" (§ name to), #_"Coin" (§ name value)])
        (§ throws #_"InsufficientMoneyException")
    (§ block
        (§ var #_"SendRequest" (§ name request) (§ expr SendRequest/to(§ pars to, value)))
        (§ return (§ expr sendCoins(§ pars broadcaster, request)))
    )

    ;;;
     ; <p>Sends coins according to the given request, via the given {@link TransactionBroadcaster}.</p>
     ;
     ; <p>The returned object provides both the transaction, and a future that can be used to learn when the broadcast
     ; is complete.  Complete means, if the PeerGroup is limited to only one connection, when it was written out to
     ; the socket.  Otherwise when the transaction is written out and we heard it back from a different peer.</p>
     ;
     ; <p>Note that the sending transaction is committed to the wallet immediately, not when the transaction is
     ; successfully broadcast.  This means that even if the network hasn't heard about your transaction you won't be
     ; able to spend those same coins again.</p>
     ;
     ; @param broadcaster The target to use for broadcast.
     ; @param request The SendRequest that describes what to do, get one using static methods on SendRequest itself.
     ; @return an object containing the transaction that was created, and a future for the broadcast of it.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method #_"SendResult" (§ fn sendCoins) [#_"TransactionBroadcaster" (§ name broadcaster), #_"SendRequest" (§ name request)])
        (§ throws #_"InsufficientMoneyException")
    (§ block
        ;; Should not be locked here, as we're going to call into the broadcaster and that might want to hold its
        ;; own lock.  sendCoinsOffline handles everything that needs to be locked.
        (§ expr Preconditions/checkState(§ pars (§ not lock.isHeldByCurrentThread(§ pars ))))

        ;; Commit the TX to the wallet immediately so the spent coins won't be reused.
        ;; TODO: We should probably allow the request to specify tx commit only after the network has accepted it.
        (§ var #_"Transaction" (§ name tx) (§ expr sendCoinsOffline(§ pars request)))
        (§ var #_"SendResult" (§ name result) (§ new #_"SendResult" (§ pars )))
        (§ ass (§ name result.tx) tx)
        ;; The tx has been committed to the pending pool by this point (via sendCoinsOffline -> commitTx), so it has
        ;; a txConfidenceListener registered.  Once the tx is broadcast the peers will update the memory pool with the
        ;; count of seen peers, the memory pool will update the transaction confidence object, that will invoke the
        ;; txConfidenceListener which will in turn invoke the wallets event listener onTransactionConfidenceChanged
        ;; method.
        (§ ass (§ name result.broadcast) (§ expr broadcaster.broadcastTransaction(§ pars tx)))
        (§ ass (§ name result.broadcastComplete) (§ expr result.broadcast.future(§ pars )))
        (§ return result)
    )

    ;;;
     ; Satisfies the given {@link SendRequest} using the default transaction broadcaster configured either via
     ; {@link PeerGroup#addWallet(Wallet)} or directly with {@link #setTransactionBroadcaster(TransactionBroadcaster)}.
     ;
     ; @param request The SendRequest that describes what to do, get one using static methods on SendRequest itself.
     ; @return an object containing the transaction that was created, and a future for the broadcast of it.
     ; @throws IllegalStateException if no transaction broadcaster has been configured.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method #_"SendResult" (§ fn sendCoins) [#_"SendRequest" (§ name request)])
        (§ throws #_"InsufficientMoneyException")
    (§ block
        (§ var #_"TransactionBroadcaster" (§ name broadcaster) vTransactionBroadcaster)
        (§ expr Preconditions/checkState(§ pars broadcaster != nil, "No transaction broadcaster is configured"))
        (§ return (§ expr sendCoins(§ pars broadcaster, request)))
    )

    ;;;
     ; Sends coins to the given address, via the given {@link Peer}.  Change is returned to {@link Wallet#currentChangeAddress()}.
     ; If an exception is thrown by {@link Peer#sendMessage(Message)} the transaction is still committed, so the pending
     ; transaction must be broadcast <b>by you</b> at some other time.  Note that a fee may be automatically added
     ; if one may be required for the transaction to be confirmed.
     ;
     ; @return the {@link Transaction} that was created or null if there was insufficient balance to send the coins.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method #_"Transaction" (§ fn sendCoins) [#_"Peer" (§ name peer), #_"SendRequest" (§ name request)])
        (§ throws #_"InsufficientMoneyException")
    (§ block
        (§ var #_"Transaction" (§ name tx) (§ expr sendCoinsOffline(§ pars request)))
        (§ expr peer.sendMessage(§ pars tx))
        (§ return tx)
    )

    ;;;
     ; Class of exceptions thrown in {@link Wallet#completeTx(SendRequest)}.
     ;;
    #_public
    #_static
    (§ class #_"CompletionException" (§ extends #_"RuntimeException"))

    ;;;
     ; Thrown if the resultant transaction would violate the dust rules (an output that's too small to be worthwhile).
     ;;
    #_public
    #_static
    (§ class #_"DustySendRequested" (§ extends #_"CompletionException"))

    ;;;
     ; Thrown if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    #_static
    (§ class #_"MultipleOpReturnRequested" (§ extends #_"CompletionException"))

    ;;;
     ; Thrown when we were trying to empty the wallet, and the total amount of money we were trying to empty after
     ; being reduced for the fee was smaller than the min payment.
     ; Note that the missing field will be null in this case.
     ;;
    #_public
    #_static
    (§ class #_"CouldNotAdjustDownwards" (§ extends #_"CompletionException"))

    ;;;
     ; Thrown if the resultant transaction is too big for Bitcoin to process.  Try breaking up the amounts of value.
     ;;
    #_public
    #_static
    (§ class #_"ExceededMaxTransactionSize" (§ extends #_"CompletionException"))

    ;;;
     ; Given a spend request containing an incomplete transaction, makes it valid by adding outputs and signed inputs
     ; according to the instructions in the request.  The transaction in the request is modified by this method.
     ;
     ; @param req A SendRequest that contains the incomplete transaction and details for how to make it valid.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_public
    (§ method #_"void" (§ fn completeTx) [#_"SendRequest" (§ name req)])
        (§ throws #_"InsufficientMoneyException")
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ expr Preconditions/checkArgument(§ pars (§ not req).completed, "Given SendRequest has already been completed."))

            ;; Calculate the amount of value we need to import.
            (§ var #_"Coin" (§ name value) (§ expr Coin/ZERO))
            (§ for (§ var #_"TransactionOutput" (§ name output)) :for (§ expr req.tx.getOutputs(§ pars )))
            (§ block
                (§ ass (§ name value) (§ expr value.add(§ pars output.getValue(§ pars ))))
            )

            (§ expr log.info(§ pars "Completing send tx with {} outputs totalling {} and a fee of {}/kB", req.tx.getOutputs(§ pars ).size(§ pars ), value.toFriendlyString(§ pars ), req.feePerKb.toFriendlyString(§ pars )))

            ;; If any inputs have already been added, we don't need to get their value from wallet.
            (§ var #_"Coin" (§ name totalInput) (§ expr Coin/ZERO))
            (§ for (§ var #_"TransactionInput" (§ name input)) :for (§ expr req.tx.getInputs(§ pars )))
            (§ block
                (§ if (§ expr input.getConnectedOutput(§ pars ) != nil))
                (§ block
                    (§ ass (§ name totalInput) (§ expr totalInput.add(§ pars input.getConnectedOutput(§ pars ).getValue(§ pars ))))
                )
                (§ else )
                (§ block
                    (§ expr log.warn(§ pars "SendRequest transaction already has inputs but we don't know how much they are worth - they will be added to fee."))
                )
            )
            (§ ass (§ name value) (§ expr value.subtract(§ pars totalInput)))

            (§ var #_"List<TransactionInput>" (§ name originalInputs) (§ new #_"ArrayList<>" (§ pars req.tx.getInputs(§ pars ))))

            ;; Check for dusty sends and the OP_RETURN limit.
            (§ if (§ expr req.ensureMinRequiredFee && (§ not (§ expr req.emptyWallet)))) ;; Min fee checking is handled later for emptyWallet.
            (§ block
                (§ var #_"int" (§ name opReturnCount) 0)
                (§ for (§ var #_"TransactionOutput" (§ name output)) :for (§ expr req.tx.getOutputs(§ pars )))
                (§ block
                    (§ if (§ expr output.isDust(§ pars )))
                    (§ block
                        (§ throw (§ new #_"DustySendRequested" (§ pars )))
                    )
                    (§ if (§ expr output.getScriptPubKey(§ pars ).isOpReturn(§ pars )))
                    (§ block
                        (§ ass (§ name opReturnCount) (§ expr opReturnCount + 1))
                    )
                )
                (§ if (§ expr 1 < opReturnCount)) ;; Only 1 OP_RETURN per transaction allowed.
                (§ block
                    (§ throw (§ new #_"MultipleOpReturnRequested" (§ pars )))
                )
            )

            ;; Calculate a list of ALL potential candidates for spending and then ask a coin selector to provide us
            ;; with the actual outputs that'll be used to gather the required amount of value.  In this way, users
            ;; can customize coin selection policies.  The call below will ignore immature coinbases and outputs
            ;; we don't have the keys for.
            (§ var #_"List<TransactionOutput>" (§ name candidates) (§ expr calculateAllSpendCandidates(§ pars true, req.missingSigsMode == MissingSigsMode/THROW)))

            (§ var #_"CoinSelection" (§ name bestCoinSelection))
            (§ var #_"TransactionOutput" (§ name bestChangeOutput) nil)
            (§ var #_"List<Coin>" (§ name updatedOutputValues) nil)
            (§ if (§ expr (§ not req.emptyWallet)))
            (§ block
                ;; This can throw InsufficientMoneyException.
                (§ var #_"FeeCalculation" (§ name feeCalculation) (§ expr calculateFee(§ pars req, value, originalInputs, req.ensureMinRequiredFee, candidates)))
                (§ ass (§ name bestCoinSelection) (§ expr feeCalculation.bestCoinSelection))
                (§ ass (§ name bestChangeOutput) (§ expr feeCalculation.bestChangeOutput))
                (§ ass (§ name updatedOutputValues) (§ expr feeCalculation.updatedOutputValues))
            )
            (§ else )
            (§ block
                ;; We're being asked to empty the wallet.  What this means is ensuring "tx" has only a single output
                ;; of the total value we can currently spend as determined by the selector, and then subtracting the fee.
                (§ expr Preconditions/checkState(§ pars req.tx.getOutputs(§ pars ).size(§ pars ) == 1, "Empty wallet TX must have a single output only."))

                (§ var #_"CoinSelector" (§ name selector) (§ quest (§ expr req.coinSelector == nil) ? coinSelector :else (§ expr req.coinSelector)))
                (§ ass (§ name bestCoinSelection) (§ expr selector.select(§ pars params.getMaxMoney(§ pars ), candidates)))
                (§ ass (§ name candidates) nil) ;; Selector took ownership and might have changed candidates.  Don't access again.
                (§ expr req.tx.getOutput(§ pars 0).setValue(§ pars bestCoinSelection.valueGathered))
                (§ expr log.info(§ pars "  emptying {}", bestCoinSelection.valueGathered.toFriendlyString(§ pars )))
            )

            (§ for (§ var #_"TransactionOutput" (§ name output)) :for (§ expr bestCoinSelection.gathered))
            (§ block
                (§ expr req.tx.addInput(§ pars output))
            )

            (§ if (§ expr req.emptyWallet))
            (§ block
                #_final
                (§ var #_"Coin" (§ name feePerKb) (§ quest (§ expr req.feePerKb == nil) ? (§ expr Coin/ZERO) :else (§ expr req.feePerKb)))
                (§ if (§ expr (§ not adjustOutputDownwardsForFee(§ pars req.tx, bestCoinSelection, feePerKb, req.ensureMinRequiredFee))))
                (§ block
                    (§ throw (§ new #_"CouldNotAdjustDownwards" (§ pars )))
                )
            )

            (§ if (§ expr updatedOutputValues != nil))
            (§ block
                (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < updatedOutputValues.size(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
                (§ block
                    (§ expr req.tx.getOutput(§ pars i).setValue(§ pars updatedOutputValues.get(§ pars i)))
                )
            )

            (§ if (§ expr bestChangeOutput != nil))
            (§ block
                (§ expr req.tx.addOutput(§ pars bestChangeOutput))
                (§ expr log.info(§ pars "  with {} change", bestChangeOutput.getValue(§ pars ).toFriendlyString(§ pars )))
            )

            ;; Now shuffle the outputs to obfuscate which is the change.
            (§ if (§ expr req.shuffleOutputs))
            (§ block
                (§ expr req.tx.shuffleOutputs(§ pars ))
            )

            ;; Now sign the inputs, thus proving that we are entitled to redeem the connected outputs.
            (§ if (§ expr req.signInputs))
            (§ block
                (§ expr signTransaction(§ pars req))
            )

            ;; Check size.
            #_final
            (§ var #_"int" (§ name size) (§ expr req.tx.unsafeBitcoinSerialize(§ pars ).length))
            (§ if (§ expr Transaction/MAX_STANDARD_TX_SIZE < size))
            (§ block
                (§ throw (§ new #_"ExceededMaxTransactionSize" (§ pars )))
            )

            ;; Label the transaction as being self created.  We can use this later to spend its change output even before
            ;; the transaction is confirmed.  We deliberately won't bother notifying listeners here as there's not much
            ;; point - the user isn't interested in a confidence transition they made themselves.
            (§ expr req.tx.getConfidence(§ pars ).setSource(§ pars TransactionConfidence/Source/SELF))
            ;; Label the transaction as being a user requested payment.  This can be used to render GUI wallet
            ;; transaction lists more appropriately, especially when the wallet starts to generate transactions itself
            ;; for internal purposes.
            (§ expr req.tx.setPurpose(§ pars Transaction/Purpose/USER_PAYMENT))
            ;; Record the exchange rate that was valid when the transaction was completed.
            (§ expr req.tx.setExchangeRate(§ pars req.exchangeRate))
            (§ expr req.tx.setMemo(§ pars req.memo))
            (§ ass (§ name req.completed) true)
            (§ expr log.info(§ pars "  completed: {}", req.tx))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; <p>Given a send request containing transaction, attempts to sign it's inputs.  This method expects
     ; the transaction to have all necessary inputs connected or they will be ignored.</p>
     ; <p>Actual signing is done by pluggable {@link #signers} and it's not guaranteed that
     ; the transaction will be complete in the end.</p>
     ;;
    #_public
    (§ method #_"void" (§ fn signTransaction) [#_"SendRequest" (§ name req)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"Transaction" (§ name tx) (§ expr req.tx))
            (§ var #_"List<TransactionInput>" (§ name inputs) (§ expr tx.getInputs(§ pars )))
            (§ var #_"List<TransactionOutput>" (§ name outputs) (§ expr tx.getOutputs(§ pars )))
            (§ expr Preconditions/checkState(§ pars 0 < inputs.size(§ pars )))
            (§ expr Preconditions/checkState(§ pars 0 < outputs.size(§ pars )))

            (§ var #_"KeyBag" (§ name maybeDecryptingKeyBag) (§ new #_"DecryptingKeyBag" (§ pars this, req.aesKey)))

            (§ var #_"int" (§ name numInputs) (§ expr tx.getInputs(§ pars ).size(§ pars )))
            (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < numInputs) :for (§ ass (§ name i) (§ expr i + 1)))
            (§ block
                (§ var #_"TransactionInput" (§ name txIn) (§ expr tx.getInput(§ pars i)))
                ;; Missing connected output, assuming already signed.
                (§ if (§ expr txIn.getConnectedOutput(§ pars ) == nil))
                (§ block
                    (§ continue )
                )

                (§ try )
                (§ block
                    ;; We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                    ;; we sign missing pieces (to check this would require either assuming any signatures are signing
                    ;; standard output types or a way to get processed signatures out of script execution).
                    (§ expr txIn.getScriptSig(§ pars ).correctlySpends(§ pars tx, i, txIn.getConnectedOutput(§ pars ).getScriptPubKey(§ pars )))
                    (§ expr log.warn(§ pars "Input {} already correctly spends output, assuming SIGHASH type used will be safe and skipping signing.", i))
                    (§ continue )
                )
                (§ catch #_"ScriptException" (§ name e))
                (§ block
                    (§ expr log.debug(§ pars "Input contained an incorrect signature", e))
                    ;; Expected.
                )

                (§ var #_"Script" (§ name scriptPubKey) (§ expr txIn.getConnectedOutput(§ pars ).getScriptPubKey(§ pars )))
                (§ var #_"RedeemData" (§ name redeemData) (§ expr txIn.getConnectedRedeemData(§ pars maybeDecryptingKeyBag)))
                (§ expr Preconditions/checkNotNull(§ pars redeemData, "Transaction exists in wallet that we cannot redeem: %s", txIn.getOutpoint(§ pars ).getHash(§ pars )))
                (§ expr txIn.setScriptSig(§ pars scriptPubKey.createEmptyInputScript(§ pars redeemData.keys.get(§ pars 0), redeemData.redeemScript)))
            )

            (§ var #_"TransactionSigner.ProposedTransaction" (§ name proposal) (§ new #_"TransactionSigner.ProposedTransaction" (§ pars tx)))
            (§ for (§ var #_"TransactionSigner" (§ name signer)) :for signers)
            (§ block
                (§ if (§ expr (§ not signer.signInputs(§ pars proposal, maybeDecryptingKeyBag))))
                (§ block
                    (§ expr log.info(§ pars "{} returned false for the tx", signer.getClass(§ pars ).getName(§ pars )))
                )
            )

            ;; Resolve missing sigs if any.
            (§ expr (§ new #_"MissingSigResolutionSigner" (§ pars req.missingSigsMode)).signInputs(§ pars proposal, maybeDecryptingKeyBag))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;; Reduce the value of the first output of a transaction to pay the given feePerKb as appropriate for its size. ;;
    #_private
    (§ method #_"boolean" (§ fn adjustOutputDownwardsForFee) [#_"Transaction" (§ name tx), #_"CoinSelection" (§ name coinSelection), #_"Coin" (§ name feePerKb), #_"boolean" (§ name ensureMinRequiredFee)])
    (§ block
        #_final
        (§ var #_"int" (§ name size) (§ expr tx.unsafeBitcoinSerialize(§ pars ).length + estimateBytesForSigning(§ pars coinSelection)))
        (§ var #_"Coin" (§ name fee) (§ expr feePerKb.multiply(§ pars size).divide(§ pars 1000)))
        (§ if (§ expr ensureMinRequiredFee && fee.compareTo(§ pars Transaction/REFERENCE_DEFAULT_MIN_TX_FEE) < 0))
        (§ block
            (§ ass (§ name fee) (§ expr Transaction/REFERENCE_DEFAULT_MIN_TX_FEE))
        )
        (§ var #_"TransactionOutput" (§ name output) (§ expr tx.getOutput(§ pars 0)))
        (§ expr output.setValue(§ pars output.getValue(§ pars ).subtract(§ pars fee)))
        (§ return (§ expr (§ not output.isDust(§ pars ))))
    )

    ;;;
     ; Returns a list of the outputs that can potentially be spent, i.e. that we have the keys for and are unspent
     ; according to our knowledge of the block chain.
     ;;
    #_public
    (§ method #_"List<TransactionOutput>" (§ fn calculateAllSpendCandidates) [])
    (§ block
        (§ return (§ expr calculateAllSpendCandidates(§ pars true, true)))
    )

    ;;;
     ; Returns a list of all outputs that are being tracked by this wallet taking into account the flags.
     ;
     ; @param excludeImmatureCoinbases Whether to ignore coinbase outputs that we will be able to spend in future once they mature.
     ; @param excludeUnsignable Whether to ignore outputs that we are tracking but don't have the keys to sign for.
     ;;
    #_public
    (§ method #_"List<TransactionOutput>" (§ fn calculateAllSpendCandidates) [#_"boolean" (§ name excludeImmatureCoinbases), #_"boolean" (§ name excludeUnsignable)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"List<TransactionOutput>" (§ name candidates) (§ new #_"ArrayList<>" (§ pars myUnspents.size(§ pars ))))
            (§ for (§ var #_"TransactionOutput" (§ name output)) :for myUnspents)
            (§ block
                (§ if (§ expr excludeUnsignable && (§ not canSignFor(§ pars output.getScriptPubKey(§ pars )))))
                (§ block
                    (§ continue )
                )
                (§ var #_"Transaction" (§ name transaction) (§ expr Preconditions/checkNotNull(§ pars output.getParentTransaction(§ pars ))))
                (§ if (§ expr excludeImmatureCoinbases && (§ not transaction.isMature(§ pars ))))
                (§ block
                    (§ continue )
                )
                (§ expr candidates.add(§ pars output))
            )
            (§ return candidates)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; Returns true if this wallet has at least one of the private keys needed to sign for this scriptPubKey.
     ; Returns false if the form of the script is not known or if the script is OP_RETURN.
     ;;
    #_public
    (§ method #_"boolean" (§ fn canSignFor) [#_"Script" (§ name script)])
    (§ block
        (§ if (§ expr script.isSentToRawPubKey(§ pars )))
        (§ block
            (§ var #_"byte[]" (§ name pubkey) (§ expr script.getPubKey(§ pars )))
            (§ var #_"ECKey" (§ name key) (§ expr findKeyFromPubKey(§ pars pubkey)))
            (§ return (§ expr key != nil && (§ expr key.isEncrypted(§ pars ) || key.hasPrivKey(§ pars ))))
        )

        (§ if (§ expr script.isPayToScriptHash(§ pars )))
        (§ block
            (§ var #_"RedeemData" (§ name data) (§ expr findRedeemDataFromScriptHash(§ pars script.getPubKeyHash(§ pars ))))
            (§ return (§ expr data != nil && canSignFor(§ pars data.redeemScript)))
        )

        (§ if (§ expr script.isSentToAddress(§ pars )))
        (§ block
            (§ var #_"ECKey" (§ name key) (§ expr findKeyFromPubHash(§ pars script.getPubKeyHash(§ pars ))))
            (§ return (§ expr key != nil && (§ expr key.isEncrypted(§ pars ) || key.hasPrivKey(§ pars ))))
        )

        (§ if (§ expr script.isSentToMultiSig(§ pars )))
        (§ block
            (§ for (§ var #_"ECKey" (§ name pubkey)) :for (§ expr script.getPubKeys(§ pars )))
            (§ block
                (§ var #_"ECKey" (§ name key) (§ expr findKeyFromPubKey(§ pars pubkey.getPubKey(§ pars ))))
                (§ if (§ expr key != nil && (§ expr key.isEncrypted(§ pars ) || key.hasPrivKey(§ pars ))))
                (§ block
                    (§ return true)
                )
            )
        )
        (§ elseif (§ expr script.isSentToCLTVPaymentChannel(§ pars )))
        (§ block
            ;; Any script for which we are the recipient or sender counts.
            (§ var #_"byte[]" (§ name sender) (§ expr script.getCLTVPaymentChannelSenderPubKey(§ pars )))
            (§ var #_"ECKey" (§ name senderKey) (§ expr findKeyFromPubKey(§ pars sender)))
            (§ if (§ expr senderKey != nil && (§ expr senderKey.isEncrypted(§ pars ) || senderKey.hasPrivKey(§ pars ))))
            (§ block
                (§ return true)
            )

            (§ var #_"byte[]" (§ name recipient) (§ expr script.getCLTVPaymentChannelRecipientPubKey(§ pars )))
            (§ var #_"ECKey" (§ name recipientKey) (§ expr findKeyFromPubKey(§ pars sender)))
            (§ if (§ expr recipientKey != nil && (§ expr recipientKey.isEncrypted(§ pars ) || recipientKey.hasPrivKey(§ pars ))))
            (§ block
                (§ return true)
            )
        )
        (§ return false)
    )

    ;;; Returns the {@link CoinSelector} object which controls which outputs can be spent by this wallet. ;;
    #_public
    (§ method #_"CoinSelector" (§ fn getCoinSelector) [])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ return coinSelector)
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )

    ;;;
     ; A coin selector is responsible for choosing which outputs to spend when creating transactions.  The default
     ; selector implements a policy of spending transactions that appeared in the best chain and pending transactions
     ; that were created by this wallet, but not others.  You can override the coin selector for any given send
     ; operation by changing {@link SendRequest#coinSelector}.
     ;;
    #_public
    (§ method #_"void" (§ fn setCoinSelector) [#_"CoinSelector" (§ name coinSelector)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name this.coinSelector) (§ expr Preconditions/checkNotNull(§ pars coinSelector)))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Convenience wrapper for <tt>setCoinSelector(Wallet.AllowUnconfirmedCoinSelector.get())</tt>.  If this method
     ; is called on the wallet then transactions will be used for spending regardless of their confidence.  This can
     ; be dangerous - only use this if you absolutely know what you're doing!
     ;;
    #_public
    (§ method #_"void" (§ fn allowSpendingUnconfirmedTransactions) [])
    (§ block
        (§ expr setCoinSelector(§ pars AllowUnconfirmedCoinSelector/get(§ pars )))
        (§ void nil)
    )

    ;;;
     ; A custom {@link TransactionOutput} that is free standing.  This contains all the information
     ; required for spending without actually having all the linked data (i.e parent tx).
     ;
     ;;
    #_private
    (§ class #_"FreeStandingTransactionOutput" (§ extends #_"TransactionOutput")
        #_private
        (§ field #_"UTXO" (§ name output))
        #_private
        (§ field #_"int" (§ name chainHeight))

        ;;;
         ; Construct a free standing Transaction Output.
         ; @param params The network parameters.
         ; @param output The stored output (free standing).
         ;;
        #_public
        (§ constructor #_"FreeStandingTransactionOutput" [#_"NetworkParameters" (§ name params), #_"UTXO" (§ name output), #_"int" (§ name chainHeight)])
        (§ block
            (§ super (§ pars params, nil, output.getValue(§ pars ), output.getScript(§ pars ).getProgram(§ pars )))

            (§ ass (§ name this.output) output)
            (§ ass (§ name this.chainHeight) chainHeight)
            (§ void this)
        )

        ;;;
         ; Get the {@link UTXO}.
         ; @return the stored output.
         ;;
        #_public
        (§ method #_"UTXO" (§ fn getUTXO) [])
        (§ block
            (§ return output)
        )

        ;;;
         ; Get the depth within the chain of the parent tx, depth is 1 if the output height is the height
         ; of the latest block.
         ; @return the depth.
         ;;
        #_override
        #_public
        (§ method #_"int" (§ fn getParentTransactionDepthInBlocks) [])
        (§ block
            (§ return (§ expr chainHeight - output.getHeight(§ pars ) + 1))
        )

        #_override
        #_public
        (§ method #_"int" (§ fn getIndex) [])
        (§ block
            (§ return (§ expr (§ cast #_"int" (§ expr output.getIndex(§ pars )))))
        )

        #_override
        #_public
        (§ method #_"Sha256Hash" (§ fn getParentTransactionHash) [])
        (§ block
            (§ return (§ expr output.getHash(§ pars )))
        )
    )

    #_private
    #_static
    (§ class #_"TxOffsetPair" (§ implements #_"Comparable<TxOffsetPair>")
        #_public
        #_final
        (§ field #_"Transaction" (§ name tx))
        #_public
        #_final
        (§ field #_"int" (§ name offset))

        #_public
        (§ constructor #_"TxOffsetPair" [#_"Transaction" (§ name tx), #_"int" (§ name offset)])
        (§ block
            (§ ass (§ name this.tx) tx)
            (§ ass (§ name this.offset) offset)
            (§ void this)
        )

        #_override
        #_public
        (§ method #_"int" (§ fn compareTo) [#_"TxOffsetPair" (§ name o)])
        (§ block
            ;; Note that in this implementation compareTo() is not consistent with equals().
            (§ return (§ expr Ints/compare(§ pars offset, o.offset)))
        )
    )

    ;;;
     ; <p>Don't call this directly.  It's not intended for API users.</p>
     ;
     ; <p>Called by the {@link BlockChain} when the best chain (representing total work done) has changed.
     ; This can cause the number of confirmations of a transaction to go higher, lower, drop to zero and
     ; can even result in a transaction going dead (will never confirm) due to a double spend.</p>
     ;
     ; <p>The oldBlocks/newBlocks lists are ordered height-wise from top first to bottom last.</p>
     ;;
    #_override
    #_public
    (§ method #_"void" (§ fn reorganize) [#_"StoredBlock" (§ name splitPoint), #_"List<StoredBlock>" (§ name oldBlocks), #_"List<StoredBlock>" (§ name newBlocks)])
        (§ throws #_"VerificationException")
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; This runs on any peer thread with the block chain locked.
            ;;
            ;; The reorganize functionality of the wallet is tested in ChainSplitTest.java
            ;;
            ;; receive() has been called on the block that is triggering the re-org before this is called,
            ;; with type of SIDE_CHAIN.
            ;;
            ;; Note that this code assumes blocks are not invalid - if blocks contain duplicated transactions,
            ;; transactions that double spend etc then we can calculate the incorrect result.  This could open up
            ;; obscure DoS attacks if someone successfully mines a throwaway invalid block and feeds it to us, just
            ;; to try and corrupt the internal data structures.  We should try harder to avoid this but it's tricky
            ;; because there are so many ways the block can be invalid.

            ;; Avoid spuriously informing the user of wallet/tx confidence changes whilst we're re-organizing.
            (§ expr Preconditions/checkState(§ pars confidenceChanged.size(§ pars ) == 0))
            (§ expr Preconditions/checkState(§ pars (§ not insideReorg)))
            (§ ass (§ name insideReorg) true)
            (§ expr Preconditions/checkState(§ pars onWalletChangedSuppressions == 0))
            (§ ass (§ name onWalletChangedSuppressions) (§ expr onWalletChangedSuppressions + 1))

            ;; Map block hash to transactions that appear in it.  We ensure that the map values are sorted according
            ;; to their relative position within those blocks.
            (§ var #_"ArrayListMultimap<Sha256Hash, TxOffsetPair>" (§ name mapBlockTx) (§ expr ArrayListMultimap/create(§ pars )))
            (§ for (§ var #_"Transaction" (§ name tx)) :for (§ expr getTransactions(§ pars true)))
            (§ block
                (§ var #_"Map<Sha256Hash, Integer>" (§ name appearsIn) (§ expr tx.getAppearsInHashes(§ pars )))
                (§ if (§ expr appearsIn == nil))
                (§ block
                    (§ continue ) ;; Pending.
                )
                (§ for (§ var #_"Map.Entry<Sha256Hash, Integer>" (§ name block)) :for (§ expr appearsIn.entrySet(§ pars )))
                (§ block
                    (§ expr mapBlockTx.put(§ pars block.getKey(§ pars ), new TxOffsetPair(§ pars tx, block.getValue(§ pars ))))
                )
            )
            (§ for (§ var #_"Sha256Hash" (§ name blockHash)) :for (§ expr mapBlockTx.keySet(§ pars )))
            (§ block
                (§ expr Collections/sort(§ pars mapBlockTx.get(§ pars blockHash)))
            )

            (§ var #_"List<Sha256Hash>" (§ name oldBlockHashes) (§ new #_"ArrayList<>" (§ pars oldBlocks.size(§ pars ))))
            (§ expr log.info(§ pars "Old part of chain (top to bottom):"))
            (§ for (§ var #_"StoredBlock" (§ name b)) :for oldBlocks)
            (§ block
                (§ expr log.info(§ pars "  {}", b.getHeader(§ pars ).getHashAsString(§ pars )))
                (§ expr oldBlockHashes.add(§ pars b.getHeader(§ pars ).getHash(§ pars )))
            )
            (§ expr log.info(§ pars "New part of chain (top to bottom):"))
            (§ for (§ var #_"StoredBlock" (§ name b)) :for newBlocks)
            (§ block
                (§ expr log.info(§ pars "  {}", b.getHeader(§ pars ).getHashAsString(§ pars )))
            )

            (§ expr Collections/reverse(§ pars newBlocks)) ;; Need bottom-to-top but we get top-to-bottom.

            ;; For each block in the old chain, disconnect the transactions in reverse order.
            (§ var #_"LinkedList<Transaction>" (§ name oldChainTxns) (§ expr Lists/newLinkedList(§ pars )))
            (§ for (§ var #_"Sha256Hash" (§ name blockHash)) :for oldBlockHashes)
            (§ block
                (§ for (§ var #_"TxOffsetPair" (§ name pair)) :for (§ expr mapBlockTx.get(§ pars blockHash)))
                (§ block
                    (§ var #_"Transaction" (§ name tx) (§ expr pair.tx))
                    #_final
                    (§ var #_"Sha256Hash" (§ name txHash) (§ expr tx.getHash(§ pars )))
                    (§ if (§ expr tx.isCoinBase(§ pars )))
                    (§ block
                        ;; All the transactions that we have in our wallet which spent this coinbase are now invalid
                        ;; and will never confirm.  Hopefully this should never happen - that's the point of the maturity
                        ;; rule that forbids spending of coinbase transactions for 100 blocks.
                        ;;
                        ;; This could be recursive, although of course because we don't have the full transaction
                        ;; graph we can never reliably kill all transactions we might have that were rooted in
                        ;; this coinbase tx.  Some can just go pending forever, like the Bitcoin Core.  However we
                        ;; can do our best.
                        (§ expr log.warn(§ pars "Coinbase killed by re-org: {}", tx.getHashAsString(§ pars )))
                        (§ expr killTxns(§ pars ImmutableSet/of(§ pars tx), nil))
                    )
                    (§ else )
                    (§ block
                        (§ for (§ var #_"TransactionOutput" (§ name output)) :for (§ expr tx.getOutputs(§ pars )))
                        (§ block
                            (§ var #_"TransactionInput" (§ name input) (§ expr output.getSpentBy(§ pars )))
                            (§ if (§ expr input != nil))
                            (§ block
                                (§ if (§ expr output.isMine(§ pars this)))
                                (§ block
                                    (§ expr Preconditions/checkState(§ pars myUnspents.add(§ pars output)))
                                )
                                (§ expr input.disconnect(§ pars ))
                            )
                        )
                        (§ expr oldChainTxns.add(§ pars tx))
                        (§ expr unspent.remove(§ pars txHash))
                        (§ expr spent.remove(§ pars txHash))
                        (§ expr Preconditions/checkState(§ pars (§ not pending.containsKey(§ pars txHash))))
                        (§ expr Preconditions/checkState(§ pars (§ not dead.containsKey(§ pars txHash))))
                    )
                )
            )

            ;; Put all the disconnected transactions back into the pending pool and re-connect them.
            (§ for (§ var #_"Transaction" (§ name tx)) :for oldChainTxns)
            (§ block
                ;; Coinbase transactions on the old part of the chain are dead for good and won't come back unless
                ;; there's another re-org.
                (§ if (§ expr tx.isCoinBase(§ pars )))
                (§ block
                    (§ continue )
                )
                (§ expr log.info(§ pars "  ->pending {}", tx.getHash(§ pars )))

                (§ expr tx.getConfidence(§ pars ).setConfidenceType(§ pars ConfidenceType/PENDING)) ;; Wipe height/depth/work data.
                (§ expr confidenceChanged.put(§ pars tx, TransactionConfidence/Listener/ChangeReason/TYPE))
                (§ expr addWalletTransaction(§ pars Pool/PENDING, tx))
                (§ expr updateForSpends(§ pars tx, false))
            )

            ;; Note that dead transactions stay dead.  Consider a chain that Finney attacks T1 and replaces it with
            ;; T2, so we move T1 into the dead pool.  If there's now a re-org to a chain that doesn't include T2, it
            ;; doesn't matter - the miners deleted T1 from their mempool, will resurrect T2 and put that into the
            ;; mempool and so T1 is still seen as a losing double spend.

            ;; The old blocks have contributed to the depth for all the transactions in the
            ;; wallet that are in blocks up to and including the chain split block.
            ;; The total depth is calculated here and then subtracted from the appropriate transactions.
            (§ var #_"int" (§ name depthToSubtract) (§ expr oldBlocks.size(§ pars )))
            (§ expr log.info(§ pars "depthToSubtract = " + depthToSubtract))
            ;; Remove depthToSubtract from all transactions in the wallet except for pending.
            (§ expr subtractDepth(§ pars depthToSubtract, spent.values(§ pars )))
            (§ expr subtractDepth(§ pars depthToSubtract, unspent.values(§ pars )))
            (§ expr subtractDepth(§ pars depthToSubtract, dead.values(§ pars )))

            ;; The effective last seen block is now the split point so set the lastSeenBlockHash.
            (§ expr setLastBlockSeenHash(§ pars splitPoint.getHeader(§ pars ).getHash(§ pars )))

            ;; For each block in the new chain, work forwards calling receive() and notifyNewBestBlock().
            ;; This will pull them back out of the pending pool, or if the tx didn't appear in the old chain
            ;; and does appear in the new chain, will treat it as such and possibly kill pending transactions
            ;; that conflict.
            (§ for (§ var #_"StoredBlock" (§ name block)) :for newBlocks)
            (§ block
                (§ expr log.info(§ pars "Replaying block {}", block.getHeader(§ pars ).getHashAsString(§ pars )))
                (§ for (§ var #_"TxOffsetPair" (§ name pair)) :for (§ expr mapBlockTx.get(§ pars block.getHeader(§ pars ).getHash(§ pars ))))
                (§ block
                    (§ expr log.info(§ pars "  tx {}", pair.tx.getHash(§ pars )))
                    (§ try )
                    (§ block
                        (§ expr receive(§ pars pair.tx, block, BlockChain/NewBlockType/BEST_CHAIN, pair.offset))
                    )
                    (§ catch #_"ScriptException" (§ name e))
                    (§ block
                        (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen as these blocks were already verified.
                    )
                )
                (§ expr notifyNewBestBlock(§ pars block))
            )
            (§ expr isConsistentOrThrow(§ pars ))
            #_final
            (§ var #_"Coin" (§ name balance) (§ expr getBalance(§ pars )))
            (§ expr log.info(§ pars "post-reorg balance is {}", balance.toFriendlyString(§ pars )))
            ;; Inform event listeners that a re-org took place.
            (§ expr queueOnReorganize(§ pars ))
            (§ ass (§ name insideReorg) false)
            (§ ass (§ name onWalletChangedSuppressions) (§ expr onWalletChangedSuppressions - 1))
            (§ expr maybeQueueOnWalletChanged(§ pars ))
            (§ expr checkBalanceFuturesLocked(§ pars balance))
            (§ expr informConfidenceListenersIfNotReorganizing(§ pars ))
            (§ expr saveLater(§ pars ))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        (§ void nil)
    )

    ;;;
     ; Subtract the supplied depth from the given transactions.
     ;;
    #_private
    (§ method #_"void" (§ fn subtractDepth) [#_"int" (§ name depthToSubtract), #_"Collection<Transaction>" (§ name transactions)])
    (§ block
        (§ for (§ var #_"Transaction" (§ name tx)) :for transactions)
        (§ block
            (§ if (§ expr tx.getConfidence(§ pars ).getConfidenceType(§ pars ) == ConfidenceType/BUILDING))
            (§ block
                (§ expr tx.getConfidence(§ pars ).setDepthInBlocks(§ pars tx.getConfidence(§ pars ).getDepthInBlocks(§ pars ) - depthToSubtract))
                (§ expr confidenceChanged.put(§ pars tx, TransactionConfidence/Listener/ChangeReason/DEPTH))
            )
        )
        (§ void nil)
    )

    #_private
    #_final
    (§ field #_"ArrayList<TransactionOutPoint>" (§ name bloomOutPoints) (§ expr Lists/newArrayList(§ pars )))
    ;; Used to track whether we must automatically begin/end a filter calculation and calc outpoints/take the locks.
    #_private
    #_final
    (§ field #_"AtomicInteger" (§ name bloomFilterGuard) (§ new #_"AtomicInteger" (§ pars 0)))

    #_override
    #_public
    (§ method #_"void" (§ fn beginBloomFilterCalculation) [])
    (§ block
        (§ if (§ expr 1 < bloomFilterGuard.incrementAndGet(§ pars )))
        (§ block
            (§ return nil)
        )

        (§ expr lock.lock(§ pars ))
        (§ expr keyChainGroupLock.lock(§ pars ))
        ;; noinspection FieldAccessNotGuarded
        (§ expr calcBloomOutPointsLocked(§ pars ))
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn calcBloomOutPointsLocked) [])
    (§ block
        ;; TODO: This could be done once and then kept up to date.
        (§ expr bloomOutPoints.clear(§ pars ))
        (§ var #_"Set<Transaction>" (§ name all) (§ new #_"HashSet<>" (§ pars )))
        (§ expr all.addAll(§ pars unspent.values(§ pars )))
        (§ expr all.addAll(§ pars spent.values(§ pars )))
        (§ expr all.addAll(§ pars pending.values(§ pars )))

        (§ for (§ var #_"Transaction" (§ name tx)) :for all)
        (§ block
            (§ for (§ var #_"TransactionOutput" (§ name out)) :for (§ expr tx.getOutputs(§ pars )))
            (§ block
                (§ try )
                (§ block
                    (§ if (§ expr isTxOutputBloomFilterable(§ pars out)))
                    (§ block
                        (§ expr bloomOutPoints.add(§ pars out.getOutPointFor(§ pars )))
                    )
                )
                (§ catch #_"ScriptException" (§ name e))
                (§ block
                    ;; If it is ours, we parsed the script correctly, so this shouldn't happen.
                    (§ throw (§ new #_"RuntimeException" (§ pars e)))
                )
            )
        )
        (§ void nil)
    )

    #_override
    #_guarded-by(§ opt "keyChainGroupLock")
    #_public
    (§ method #_"void" (§ fn endBloomFilterCalculation) [])
    (§ block
        (§ if (§ expr 0 < bloomFilterGuard.decrementAndGet(§ pars )))
        (§ block
            (§ return nil)
        )

        (§ expr bloomOutPoints.clear(§ pars ))
        (§ expr keyChainGroupLock.unlock(§ pars ))
        (§ expr lock.unlock(§ pars ))
        (§ void nil)
    )

    ;;;
     ; Returns the number of distinct data items (note: NOT keys) that will be inserted into a bloom filter,
     ; when it is constructed.
     ;;
    #_override
    #_public
    (§ method #_"int" (§ fn getBloomFilterElementCount) [])
    (§ block
        (§ expr beginBloomFilterCalculation(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr bloomOutPoints.size(§ pars ) + keyChainGroup.getBloomFilterElementCount(§ pars )))
        )
        (§ finally )
        (§ block
            (§ expr endBloomFilterCalculation(§ pars ))
        )
    )

    ;;;
     ; Gets a bloom filter that contains all of the public keys from this wallet, and which will provide the given
     ; false-positive rate.  See the docs for {@link BloomFilter} for a brief explanation of anonymity when using filters.
     ;;
    #_public
    (§ method #_"BloomFilter" (§ fn getBloomFilter) [#_"double" (§ name falsePositiveRate)])
    (§ block
        (§ expr beginBloomFilterCalculation(§ pars ))
        (§ try )
        (§ block
            (§ return (§ expr getBloomFilter(§ pars getBloomFilterElementCount(§ pars ), falsePositiveRate, (§ cast #_"long" (§ expr Math/random(§ pars ) * Long/MAX_VALUE)))))
        )
        (§ finally )
        (§ block
            (§ expr endBloomFilterCalculation(§ pars ))
        )
    )

    ;;;
     ; <p>Gets a bloom filter that contains all of the public keys from this wallet, and which will provide the given
     ; false-positive rate if it has size elements.  Keep in mind that you will get 2 elements in the bloom filter for
     ; each key in the wallet, for the public key and the hash of the public key (address form).</p>
     ;
     ; <p>This is used to generate a BloomFilter which can be {@link BloomFilter#merge(BloomFilter)}d with another.
     ; It could also be used if you have a specific target for the filter's size.</p>
     ;
     ; <p>See the docs for {@link BloomFilter(int, double)} for a brief explanation of anonymity when using bloom
     ; filters.</p>
     ;;
    #_override
    #_guarded-by(§ opt "keyChainGroupLock")
    #_public
    (§ method #_"BloomFilter" (§ fn getBloomFilter) [#_"int" (§ name size), #_"double" (§ name falsePositiveRate), #_"long" (§ name nTweak)])
    (§ block
        (§ expr beginBloomFilterCalculation(§ pars ))
        (§ try )
        (§ block
            (§ var #_"BloomFilter" (§ name filter) (§ expr keyChainGroup.getBloomFilter(§ pars size, falsePositiveRate, nTweak)))
            (§ for (§ var #_"TransactionOutPoint" (§ name point)) :for bloomOutPoints)
            (§ block
                (§ expr filter.insert(§ pars point.unsafeBitcoinSerialize(§ pars )))
            )
            (§ return filter)
        )
        (§ finally )
        (§ block
            (§ expr endBloomFilterCalculation(§ pars ))
        )
    )

    ;; Returns true if the output is one that won't be selected by a data element matching in the scriptSig.
    #_private
    (§ method #_"boolean" (§ fn isTxOutputBloomFilterable) [#_"TransactionOutput" (§ name out)])
    (§ block
        (§ var #_"Script" (§ name script) (§ expr out.getScriptPubKey(§ pars )))
        (§ var #_"boolean" (§ name isScriptTypeSupported) (§ expr script.isSentToRawPubKey(§ pars ) || script.isPayToScriptHash(§ pars )))
        (§ return (§ expr isScriptTypeSupported && myUnspents.contains(§ pars out)))
    )

    ;;;
     ; Used by {@link Peer} to decide whether or not to discard this block and any blocks building upon it, in case
     ; the Bloom filter used to request them may be exhausted, that is, not have sufficient keys in the deterministic
     ; sequence within it to reliably find relevant transactions.
     ;;
    #_public
    (§ method #_"boolean" (§ fn checkForFilterExhaustion) [#_"FilteredBlock" (§ name block)])
    (§ block
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ var #_"int" (§ name epoch) (§ expr keyChainGroup.getCombinedKeyLookaheadEpochs(§ pars )))
            (§ for (§ var #_"Transaction" (§ name tx)) :for (§ expr block.getAssociatedTransactions(§ pars ).values(§ pars )))
            (§ block
                (§ expr markKeysAsUsed(§ pars tx))
            )
            (§ var #_"int" (§ name newEpoch) (§ expr keyChainGroup.getCombinedKeyLookaheadEpochs(§ pars )))
            (§ expr Preconditions/checkState(§ pars epoch <= newEpoch))
            ;; If the key lookahead epoch has advanced, there was a call to importKeys and the PeerGroup already has a
            ;; pending request to recalculate the filter queued up on another thread.  The calling Peer should abandon
            ;; block at this point and await a new filter before restarting the download.
            (§ return (§ expr epoch < newEpoch))
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
        )
    )

    #_private
    #_static
    (§ class #_"FeeCalculation"
        ;; Selected UTXOs to spend.
        #_public
        (§ field #_"CoinSelection" (§ name bestCoinSelection))
        ;; Change output (may be null if no change).
        #_public
        (§ field #_"TransactionOutput" (§ name bestChangeOutput))
        ;; List of output values adjusted downwards when recipients pay fees (may be null if no adjustment needed).
        #_public
        (§ field #_"List<Coin>" (§ name updatedOutputValues))
    )

    #_private
    (§ method #_"FeeCalculation" (§ fn calculateFee) [#_"SendRequest" (§ name req), #_"Coin" (§ name value), #_"List<TransactionInput>" (§ name originalInputs), #_"boolean" (§ name needAtLeastReferenceFee), #_"List<TransactionOutput>" (§ name candidates)])
        (§ throws #_"InsufficientMoneyException")
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ var #_"FeeCalculation" (§ name result))
        (§ var #_"Coin" (§ name fee) (§ expr Coin/ZERO))
        (§ while true)
        (§ block
            (§ ass (§ name result) (§ new #_"FeeCalculation" (§ pars )))
            (§ var #_"Transaction" (§ name tx) (§ new #_"Transaction" (§ pars params)))
            (§ expr addSuppliedInputs(§ pars tx, req.tx.getInputs(§ pars )))

            (§ var #_"Coin" (§ name valueNeeded) value)
            (§ if (§ expr (§ not req.recipientsPayFees)))
            (§ block
                (§ ass (§ name valueNeeded) (§ expr valueNeeded.add(§ pars fee)))
            )
            (§ if (§ expr req.recipientsPayFees))
            (§ block
                (§ ass (§ name result.updatedOutputValues) (§ new #_"ArrayList<Coin>" (§ pars )))
            )

            (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < req.tx.getOutputs(§ pars ).size(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
            (§ block
                (§ var #_"TransactionOutput" (§ name output) (§ new #_"TransactionOutput" (§ pars params, tx, req.tx.getOutputs(§ pars ).get(§ pars i).bitcoinSerialize(§ pars ), 0)))
                (§ if (§ expr req.recipientsPayFees))
                (§ block
                    ;; Subtract fee equally from each selected recipient.
                    (§ expr output.setValue(§ pars output.getValue(§ pars ).subtract(§ pars fee.divide(§ pars req.tx.getOutputs(§ pars ).size(§ pars )))))
                    ;; First receiver pays the remainder not divisible by output count.
                    (§ if (§ expr i == 0))
                    (§ block
                        ;; Subtract fee equally from each selected recipient.
                        (§ expr output.setValue(§ pars output.getValue(§ pars ).subtract(§ pars fee.divideAndRemainder(§ pars req.tx.getOutputs(§ pars ).size(§ pars ))[1])))
                    )
                    (§ expr result.updatedOutputValues.add(§ pars output.getValue(§ pars )))
                    (§ if (§ expr output.getMinNonDustValue(§ pars ).isGreaterThan(§ pars output.getValue(§ pars ))))
                    (§ block
                        (§ throw (§ new #_"CouldNotAdjustDownwards" (§ pars )))
                    )
                )
                (§ expr tx.addOutput(§ pars output))
            )

            (§ var #_"CoinSelector" (§ name selector) (§ quest (§ expr req.coinSelector == nil) ? coinSelector :else (§ expr req.coinSelector)))
            ;; selector is allowed to modify candidates list.
            (§ var #_"CoinSelection" (§ name selection) (§ expr selector.select(§ pars valueNeeded, new LinkedList<>(§ pars candidates))))
            (§ ass (§ name result.bestCoinSelection) selection)
            ;; Can we afford this?
            (§ if (§ expr selection.valueGathered.compareTo(§ pars valueNeeded) < 0))
            (§ block
                (§ var #_"Coin" (§ name valueMissing) (§ expr valueNeeded.subtract(§ pars selection.valueGathered)))
                (§ throw (§ new #_"InsufficientMoneyException" (§ pars valueMissing)))
            )

            (§ var #_"Coin" (§ name change) (§ expr selection.valueGathered.subtract(§ pars valueNeeded)))
            (§ if (§ expr change.isGreaterThan(§ pars Coin/ZERO)))
            (§ block
                ;; The value of the inputs is greater than what we want to send.  Just like in real life then,
                ;; we need to take back some coins ... this is called "change".  Add another output that sends the change
                ;; back to us.  The address comes either from the request or currentChangeAddress() as a default.
                (§ var #_"Address" (§ name changeAddress) (§ expr req.changeAddress))
                (§ if (§ expr changeAddress == nil))
                (§ block
                    (§ ass (§ name changeAddress) (§ expr currentChangeAddress(§ pars )))
                )

                (§ var #_"TransactionOutput" (§ name changeOutput) (§ new #_"TransactionOutput" (§ pars params, tx, change, changeAddress)))
                (§ if (§ expr req.recipientsPayFees && changeOutput.isDust(§ pars )))
                (§ block
                    ;; We do not move dust-change to fees, because the sender would end up paying more than requested.
                    ;; This would be against the purpose of the all-inclusive feature.
                    ;; So instead we raise the change and deduct from the first recipient.
                    (§ var #_"Coin" (§ name missingToNotBeDust) (§ expr changeOutput.getMinNonDustValue(§ pars ).subtract(§ pars changeOutput.getValue(§ pars ))))
                    (§ expr changeOutput.setValue(§ pars changeOutput.getValue(§ pars ).add(§ pars missingToNotBeDust)))
                    (§ var #_"TransactionOutput" (§ name firstOutput) (§ expr tx.getOutputs(§ pars ).get(§ pars 0)))
                    (§ expr firstOutput.setValue(§ pars firstOutput.getValue(§ pars ).subtract(§ pars missingToNotBeDust)))
                    (§ expr result.updatedOutputValues.set(§ pars 0, firstOutput.getValue(§ pars )))
                    (§ if (§ expr firstOutput.isDust(§ pars )))
                    (§ block
                        (§ throw (§ new #_"CouldNotAdjustDownwards" (§ pars )))
                    )
                )

                (§ if (§ expr changeOutput.isDust(§ pars )))
                (§ block
                    ;; Never create dust outputs; if we would, just add the dust to the fee.
                    ;; Oscar comment: This seems like a way to make the condition below "if (!fee.isLessThan(feeNeeded))" to become true.
                    ;; This is a non-easy to understand way to do that.
                    ;; Maybe there are other effects I am missing.
                    (§ ass (§ name fee) (§ expr fee.add(§ pars changeOutput.getValue(§ pars ))))
                )
                (§ else )
                (§ block
                    (§ expr tx.addOutput(§ pars changeOutput))
                    (§ ass (§ name result.bestChangeOutput) changeOutput)
                )
            )

            (§ for (§ var #_"TransactionOutput" (§ name selectedOutput)) :for (§ expr selection.gathered))
            (§ block
                (§ var #_"TransactionInput" (§ name input) (§ expr tx.addInput(§ pars selectedOutput)))
                ;; If the scriptBytes don't default to none, our size calculations will be thrown off.
                (§ expr Preconditions/checkState(§ pars input.getScriptBytes(§ pars ).length == 0))
            )

            (§ var #_"int" (§ name size) (§ expr tx.unsafeBitcoinSerialize(§ pars ).length))
            (§ ass (§ name size) (§ expr size + estimateBytesForSigning(§ pars selection)))

            (§ var #_"Coin" (§ name feePerKb) (§ expr req.feePerKb))
            (§ if (§ expr needAtLeastReferenceFee && feePerKb.compareTo(§ pars Transaction/REFERENCE_DEFAULT_MIN_TX_FEE) < 0))
            (§ block
                (§ ass (§ name feePerKb) (§ expr Transaction/REFERENCE_DEFAULT_MIN_TX_FEE))
            )

            (§ var #_"Coin" (§ name feeNeeded) (§ expr feePerKb.multiply(§ pars size).divide(§ pars 1000)))

            (§ if (§ expr (§ not fee.isLessThan(§ pars feeNeeded))))
            (§ block
                ;; Done, enough fee included.
                (§ break )
            )

            ;; Include more fee and try again.
            (§ ass (§ name fee) feeNeeded)
        )
        (§ return result)
    )

    #_private
    (§ method #_"void" (§ fn addSuppliedInputs) [#_"Transaction" (§ name tx), #_"List<TransactionInput>" (§ name originalInputs)])
    (§ block
        (§ for (§ var #_"TransactionInput" (§ name input)) :for originalInputs)
        (§ block
            (§ expr tx.addInput(§ pars (§ new #_"TransactionInput" (§ pars params, tx, input.bitcoinSerialize(§ pars )))))
        )
        (§ void nil)
    )

    #_private
    (§ method #_"int" (§ fn estimateBytesForSigning) [#_"CoinSelection" (§ name selection)])
    (§ block
        (§ var #_"int" (§ name size) 0)
        (§ for (§ var #_"TransactionOutput" (§ name output)) :for (§ expr selection.gathered))
        (§ block
            (§ try )
            (§ block
                (§ var #_"Script" (§ name script) (§ expr output.getScriptPubKey(§ pars )))
                (§ var #_"ECKey" (§ name key) nil)
                (§ var #_"Script" (§ name redeemScript) nil)
                (§ if (§ expr script.isSentToAddress(§ pars )))
                (§ block
                    (§ ass (§ name key) (§ expr findKeyFromPubHash(§ pars script.getPubKeyHash(§ pars ))))
                    (§ expr Preconditions/checkNotNull(§ pars key, "Coin selection includes unspendable outputs"))
                )
                (§ elseif (§ expr script.isPayToScriptHash(§ pars )))
                (§ block
                    (§ ass (§ name redeemScript) (§ expr findRedeemDataFromScriptHash(§ pars script.getPubKeyHash(§ pars )).redeemScript))
                    (§ expr Preconditions/checkNotNull(§ pars redeemScript, "Coin selection includes unspendable outputs"))
                )
                (§ ass (§ name size) (§ expr size + script.getNumberOfBytesRequiredToSpend(§ pars key, redeemScript)))
            )
            (§ catch #_"ScriptException" (§ name e))
            (§ block
                ;; If this happens it means an output script in a wallet tx could not be understood.  That
                ;; should never happen, if it does it means the wallet has got into an inconsistent state.
                (§ throw (§ new #_"IllegalStateException" (§ pars e)))
            )
        )
        (§ return size)
    )

    ;; Wallet maintenance transactions.  These transactions may not be directly connected to a payment the user is
    ;; making.  They may be instead key rotation transactions for when old keys are suspected to be compromised,
    ;; de/re-fragmentation transactions for when our output sizes are inappropriate or suboptimal, privacy transactions
    ;; and so on.  Because these transactions may require user intervention in some way (e.g. entering their password)
    ;; the wallet application is expected to poll the Wallet class to get SendRequests.  Ideally security systems like
    ;; hardware wallets or risk analysis providers are programmed to auto-approve transactions that send from our own
    ;; keys back to our own keys.

    ;;;
     ; <p>Specifies that the given {@link TransactionBroadcaster}, typically a {@link PeerGroup}, should be used for
     ; sending transactions to the Bitcoin network by default.  Some sendCoins methods let you specify a broadcaster
     ; explicitly, in that case, they don't use this broadcaster.  If null is specified then the wallet won't attempt
     ; to broadcast transactions itself.</p>
     ;
     ; <p>You don't normally need to call this.  A {@link PeerGroup} will automatically set itself as the wallets
     ; broadcaster when you use {@link PeerGroup#addWallet(Wallet)}.  A wallet can use the broadcaster when you ask
     ; it to send money, but in future also at other times to implement various features that may require asynchronous
     ; re-organisation of the wallet contents on the block chain.  For instance, in future the wallet may choose to
     ; optimise itself to reduce fees or improve privacy.</p>
     ;;
    #_public
    (§ method #_"void" (§ fn setTransactionBroadcaster) [#_nilable #_"org.bitcoinj.core.TransactionBroadcaster" (§ name broadcaster)])
    (§ block
        (§ var #_"Transaction[]" (§ name toBroadcast) (§ coll ))
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            (§ if (§ expr vTransactionBroadcaster == broadcaster))
            (§ block
                (§ return nil)
            )
            (§ ass (§ name vTransactionBroadcaster) broadcaster)
            (§ if (§ expr broadcaster == nil))
            (§ block
                (§ return nil)
            )
            (§ ass (§ name toBroadcast) (§ expr pending.values(§ pars ).toArray(§ pars toBroadcast)))
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
        ;; Now use it to upload any pending transactions we have that are marked as not being seen by any peers yet.
        ;; Don't hold the wallet lock whilst doing this, so if the broadcaster accesses the wallet at some point there
        ;; is no inversion.
        (§ for (§ var #_"Transaction" (§ name tx)) :for toBroadcast)
        (§ block
            (§ var #_"ConfidenceType" (§ name confidenceType) (§ expr tx.getConfidence(§ pars ).getConfidenceType(§ pars )))
            (§ expr Preconditions/checkState(§ pars confidenceType == ConfidenceType/PENDING || confidenceType == ConfidenceType/IN_CONFLICT, "Expected PENDING or IN_CONFLICT, was %s.", confidenceType))
            ;; Re-broadcast even if it's marked as already seen for two reasons:
            ;; 1. Old wallets may have transactions marked as broadcast by 1 peer when
            ;;    in reality the network never saw it, due to bugs.
            ;; 2. It can't really hurt.
            (§ expr log.info(§ pars "New broadcaster so uploading waiting tx {}", tx.getHash(§ pars )))
            (§ expr broadcaster.broadcastTransaction(§ pars tx))
        )
        (§ void nil)
    )

    ;;;
     ; When a key rotation time is set, and money controlled by keys created before the given timestamp T will be
     ; automatically respent to any key that was created after T.  This can be used to recover from a situation where
     ; a set of keys is believed to be compromised.  Once the time is set transactions will be created and broadcast
     ; immediately.  New coins that come in after calling this method will be automatically respent immediately.
     ; The rotation time is persisted to the wallet. You can stop key rotation by calling this method again with zero
     ; as the argument.
     ;;
    #_public
    (§ method #_"void" (§ fn setKeyRotationTime) [#_"Date" (§ name time)])
    (§ block
        (§ expr setKeyRotationTime(§ pars time.getTime(§ pars ) / 1000))
        (§ void nil)
    )

    ;;;
     ; Returns the key rotation time, or null if unconfigured.
     ; See {@link #setKeyRotationTime(Date)} for a description of the field.
     ;;
    #_public
    #_nilable
    (§ method #_"Date" (§ fn getKeyRotationTime) [])
    (§ block
        #_final
        (§ var #_"long" (§ name keyRotationTimestamp) vKeyRotationTimestamp)
        (§ return (§ quest (§ expr keyRotationTimestamp != 0) ? (§ new #_"Date" (§ pars keyRotationTimestamp * 1000)) :else nil))
    )

    ;;;
     ; <p>When a key rotation time is set, any money controlled by keys created before the given timestamp T will be
     ; automatically respent to any key that was created after T.  This can be used to recover from a situation where
     ; a set of keys is believed to be compromised.  You can stop key rotation by calling this method again with zero
     ; as the argument.  Once set up, calling {@link #doMaintenance(org.spongycastle.crypto.params.KeyParameter, boolean)}
     ; will create and possibly send rotation transactions: but it won't be done automatically (because you might have
     ; to ask for the users password).</p>
     ;
     ; <p>The given time cannot be in the future.</p>
     ;;
    #_public
    (§ method #_"void" (§ fn setKeyRotationTime) [#_"long" (§ name unixTimeSeconds)])
    (§ block
        (§ expr Preconditions/checkArgument(§ pars unixTimeSeconds <= Utils/currentTimeSeconds(§ pars ), "Given time (%s) cannot be in the future.", Utils/dateTimeFormat(§ pars unixTimeSeconds * 1000)))
        (§ ass (§ name vKeyRotationTimestamp) unixTimeSeconds)
        (§ expr saveNow(§ pars ))
        (§ void nil)
    )

    ;;; Returns whether the keys creation time is before the key rotation time, if one was set. ;;
    #_public
    (§ method #_"boolean" (§ fn isKeyRotating) [#_"ECKey" (§ name key)])
    (§ block
        (§ var #_"long" (§ name time) vKeyRotationTimestamp)
        (§ return (§ expr time != 0 && key.getCreationTimeSeconds(§ pars ) < time))
    )

    ;;;
     ; A wallet app should call this from time to time in order to let the wallet craft and send transactions needed
     ; to re-organise coins internally.  A good time to call this would be after receiving coins for an unencrypted
     ; wallet, or after sending money for an encrypted wallet.  If you have an encrypted wallet and just want to know
     ; if some maintenance needs doing, call this method with andSend set to false and look at the returned list of
     ; transactions.  Maintenance might also include internal changes that involve some processing or work but
     ; which don't require making transactions - these will happen automatically unless the password is required
     ; in which case an exception will be thrown.
     ;
     ; @param aesKey The users password, if any.
     ; @param signAndSend If true, send the transactions via the tx broadcaster and return them, if false just return them.
     ; @return a list of transactions that the wallet just made/will make for internal maintenance.  Might be empty.
     ; @throws org.bitcoinj.wallet.DeterministicUpgradeRequiresPassword if key rotation requires the users password.
     ;;
    #_public
    (§ method #_"ListenableFuture<List<Transaction>>" (§ fn doMaintenance) [#_nilable #_"KeyParameter" (§ name aesKey), #_"boolean" (§ name signAndSend)])
        (§ throws #_"DeterministicUpgradeRequiresPassword")
    (§ block
        (§ var #_"List<Transaction>" (§ name txns))
        (§ expr lock.lock(§ pars ))
        (§ expr keyChainGroupLock.lock(§ pars ))
        (§ try )
        (§ block
            (§ ass (§ name txns) (§ expr maybeRotateKeys(§ pars aesKey, signAndSend)))
            (§ if (§ expr (§ not signAndSend)))
            (§ block
                (§ return (§ expr Futures/immediateFuture(§ pars txns)))
            )
        )
        (§ finally )
        (§ block
            (§ expr keyChainGroupLock.unlock(§ pars ))
            (§ expr lock.unlock(§ pars ))
        )
        (§ expr Preconditions/checkState(§ pars (§ not lock.isHeldByCurrentThread(§ pars ))))
        (§ var #_"ArrayList<ListenableFuture<Transaction>>" (§ name futures) (§ new #_"ArrayList<>" (§ pars txns.size(§ pars ))))
        (§ var #_"TransactionBroadcaster" (§ name broadcaster) vTransactionBroadcaster)
        (§ for (§ var #_"Transaction" (§ name tx)) :for txns)
        (§ block
            (§ try )
            (§ block
                #_final
                (§ var #_"ListenableFuture<Transaction>" (§ name future) (§ expr broadcaster.broadcastTransaction(§ pars tx).future(§ pars )))
                (§ expr futures.add(§ pars future))
                (§ expr Futures/addCallback(§ pars future, new FutureCallback<Transaction>(§ pars )
                (§ anon
                    #_override
                    #_public
                    (§ method #_"void" (§ fn onSuccess) [#_"Transaction" (§ name transaction)])
                    (§ block
                        (§ expr log.info(§ pars "Successfully broadcast key rotation tx: {}", transaction))
                        (§ void nil)
                    )

                    #_override
                    #_public
                    (§ method #_"void" (§ fn onFailure) [#_"Throwable" (§ name throwable)])
                    (§ block
                        (§ expr log.error(§ pars "Failed to broadcast key rotation tx", throwable))
                        (§ void nil)
                    )
                )))
            )
            (§ catch #_"Exception" (§ name e))
            (§ block
                (§ expr log.error(§ pars "Failed to broadcast rekey tx", e))
            )
        )
        (§ return (§ expr Futures/allAsList(§ pars futures)))
    )

    ;; Checks to see if any coins are controlled by rotating keys and if so, spends them.
    #_guarded-by(§ opt "keyChainGroupLock")
    #_private
    (§ method #_"List<Transaction>" (§ fn maybeRotateKeys) [#_nilable #_"KeyParameter" (§ name aesKey), #_"boolean" (§ name sign)])
        (§ throws #_"DeterministicUpgradeRequiresPassword")
    (§ block
        (§ expr Preconditions/checkState(§ pars lock.isHeldByCurrentThread(§ pars )))
        (§ expr Preconditions/checkState(§ pars keyChainGroupLock.isHeldByCurrentThread(§ pars )))

        (§ var #_"List<Transaction>" (§ name results) (§ expr Lists/newLinkedList(§ pars )))
        ;; TODO: Handle chain replays here.
        #_final
        (§ var #_"long" (§ name keyRotationTimestamp) vKeyRotationTimestamp)
        (§ if (§ expr keyRotationTimestamp == 0))
        (§ block
            (§ return results) ;; Nothing to do.
        )

        ;; We might have to create a new HD hierarchy if the previous ones are now rotating.
        (§ var #_"boolean" (§ name allChainsRotating) true)
        (§ for (§ var #_"DeterministicKeyChain" (§ name chain)) :for (§ expr keyChainGroup.getDeterministicKeyChains(§ pars )))
        (§ block
            (§ if (§ expr keyRotationTimestamp <= chain.getEarliestKeyCreationTime(§ pars )))
            (§ block
                (§ ass (§ name allChainsRotating) false)
                (§ break )
            )
        )
        (§ if allChainsRotating)
        (§ block
            (§ try )
            (§ block
                (§ if (§ expr keyChainGroup.getImportedKeys(§ pars ).isEmpty(§ pars )))
                (§ block
                    (§ expr log.info(§ pars "All HD chains are currently rotating and we have no random keys, creating fresh HD chain ..."))
                    (§ expr keyChainGroup.createAndActivateNewHDChain(§ pars ))
                )
                (§ else )
                (§ block
                    (§ expr log.info(§ pars "All HD chains are currently rotating, attempting to create a new one from the next oldest non-rotating key material ..."))
                    (§ expr keyChainGroup.upgradeToDeterministic(§ pars keyRotationTimestamp, aesKey))
                    (§ expr log.info(§ pars " ... upgraded to HD again, based on next best oldest key."))
                )
            )
            (§ catch #_"AllRandomKeysRotating" (§ name _))
            (§ block
                (§ expr log.info(§ pars " ... no non-rotating random keys available, generating entirely new HD tree: backup required after this."))
                (§ expr keyChainGroup.createAndActivateNewHDChain(§ pars ))
            )
            (§ expr saveNow(§ pars ))
        )

        ;; Because transactions are size limited, we might not be able to re-key the entire wallet in one go.  So loop
        ;; around here until we no longer produce transactions with the max number of inputs.  That means we're fully
        ;; done, at least for now (we may still get more transactions later and this method will be reinvoked).
        (§ var #_"Transaction" (§ name tx))
        (§ do )
        (§ block
            (§ ass (§ name tx) (§ expr rekeyOneBatch(§ pars keyRotationTimestamp, aesKey, results, sign)))
            (§ if (§ expr tx != nil))
            (§ block
                (§ expr results.add(§ pars tx))
            )
        )
        (§ again (§ expr tx != nil && tx.getInputs(§ pars ).size(§ pars ) == KeyTimeCoinSelector/MAX_SIMULTANEOUS_INPUTS))

        (§ return results)
    )

    #_nilable
    #_private
    (§ method #_"Transaction" (§ fn rekeyOneBatch) [#_"long" (§ name timeSecs), #_nilable #_"KeyParameter" (§ name aesKey), #_"List<Transaction>" (§ name others), #_"boolean" (§ name sign)])
    (§ block
        (§ expr lock.lock(§ pars ))
        (§ try )
        (§ block
            ;; Build the transaction using some custom logic for our special needs.  Last parameter to
            ;; KeyTimeCoinSelector is whether to ignore pending transactions or not.
            ;;
            ;; We ignore pending outputs because trying to rotate these is basically racing an attacker, and
            ;; we're quite likely to lose and create stuck double spends.  Also, some users who have 0.9 wallets
            ;; have already got stuck double spends in their wallet due to the Bloom-filtering block reordering
            ;; bug that was fixed in 0.10, thus, making a re-key transaction depend on those would cause it to
            ;; never confirm at all.
            (§ var #_"CoinSelector" (§ name keyTimeSelector) (§ new #_"KeyTimeCoinSelector" (§ pars this, timeSecs, true)))
            (§ var #_"FilteringCoinSelector" (§ name selector) (§ new #_"FilteringCoinSelector" (§ pars keyTimeSelector)))
            (§ for (§ var #_"Transaction" (§ name other)) :for others)
            (§ block
                (§ expr selector.excludeOutputsSpentBy(§ pars other))
            )
            ;; TODO: Make this use the standard SendRequest.
            (§ var #_"CoinSelection" (§ name toMove) (§ expr selector.select(§ pars Coin/ZERO, calculateAllSpendCandidates(§ pars ))))
            (§ if (§ expr toMove.valueGathered.equals(§ pars Coin/ZERO)))
            (§ block
                (§ return nil) ;; Nothing to do.
            )

            (§ expr maybeUpgradeToHD(§ pars aesKey))
            (§ var #_"Transaction" (§ name rekeyTx) (§ new #_"Transaction" (§ pars params)))
            (§ for (§ var #_"TransactionOutput" (§ name output)) :for (§ expr toMove.gathered))
            (§ block
                (§ expr rekeyTx.addInput(§ pars output))
            )
            ;; When not signing, don't waste addresses.
            (§ expr rekeyTx.addOutput(§ pars toMove.valueGathered, (§ quest sign ? (§ expr freshReceiveAddress(§ pars )) :else (§ expr currentReceiveAddress(§ pars )))))
            (§ if (§ expr (§ not adjustOutputDownwardsForFee(§ pars rekeyTx, toMove, Transaction/DEFAULT_TX_FEE, true))))
            (§ block
                (§ expr log.error(§ pars "Failed to adjust rekey tx for fees."))
                (§ return nil)
            )

            (§ expr rekeyTx.getConfidence(§ pars ).setSource(§ pars TransactionConfidence/Source/SELF))
            (§ expr rekeyTx.setPurpose(§ pars Transaction/Purpose/KEY_ROTATION))
            (§ var #_"SendRequest" (§ name req) (§ expr SendRequest/forTx(§ pars rekeyTx)))
            (§ ass (§ name req.aesKey) aesKey)
            (§ if sign)
            (§ block
                (§ expr signTransaction(§ pars req))
            )
            ;; KeyTimeCoinSelector should never select enough inputs to push us oversize.
            (§ expr Preconditions/checkState(§ pars rekeyTx.unsafeBitcoinSerialize(§ pars ).length < Transaction/MAX_STANDARD_TX_SIZE))
            (§ return rekeyTx)
        )
        (§ catch #_"VerificationException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e))) ;; Cannot happen.
        )
        (§ finally )
        (§ block
            (§ expr lock.unlock(§ pars ))
        )
    )
)

#_(ns org.bitcoinj.wallet #_"WalletFiles"
    (:import [java.io *]
             [java.util Date]
             [java.util.concurrent *]
             [java.util.concurrent.atomic *])
    (:import [com.google.common.base Preconditions Stopwatch]
             [org.slf4j *])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.utils *]))

;;;
 ; A class that handles atomic and optionally delayed writing of the wallet file to disk.  In future: backups too.
 ; It can be useful to delay writing of a wallet file to disk on slow devices where disk and serialization overhead
 ; can come to dominate the chain processing speed, i.e. on Android phones.  By coalescing writes and doing
 ; serialization and disk IO on a background thread performance can be improved.
 ;;
#_public
(§ class #_"WalletFiles"
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"WalletFiles"))))

    #_private
    #_final
    (§ field #_"Wallet" (§ name wallet))
    #_private
    #_final
    (§ field #_"ScheduledThreadPoolExecutor" (§ name executor))
    #_private
    #_final
    (§ field #_"File" (§ name file))
    #_private
    #_final
    (§ field #_"AtomicBoolean" (§ name savePending))
    #_private
    #_final
    (§ field #_"long" (§ name delay))
    #_private
    #_final
    (§ field #_"TimeUnit" (§ name delayTimeUnit))
    #_private
    #_final
    (§ field #_"Callable<Void>" (§ name saver))

    #_private
    #_volatile
    (§ field #_"Listener" (§ name vListener))

    ;;;
     ; Implementors can do pre/post treatment of the wallet file.  Useful for adjusting permissions and other things.
     ;;
    #_public
    (§ interface #_"Listener"
        ;;;
         ; Called on the auto-save thread when a new temporary file is created but before the wallet data is saved
         ; to it.  If you want to do something here like adjust permissions, go ahead and do so.
         ;;
        (§ method #_"void" (§ fn onBeforeAutoSave) [#_"File" (§ name tempFile)])

        ;;;
         ; Called on the auto-save thread after the newly created temporary file has been filled with data and renamed.
         ;;
        (§ method #_"void" (§ fn onAfterAutoSave) [#_"File" (§ name newlySavedFile)])
    )

    ;;;
     ; Initialize atomic and optionally delayed writing of the wallet file to disk.  Note the initial wallet state isn't
     ; saved automatically.  The {@link Wallet} calls {@link #saveNow()} or {@link #saveLater()} as wallet state changes,
     ; depending on the urgency of the changes.
     ;;
    #_public
    (§ constructor #_"WalletFiles" [#_final #_"Wallet" (§ name wallet), #_"File" (§ name file), #_"long" (§ name delay), #_"TimeUnit" (§ name delayTimeUnit)])
    (§ block
        ;; An executor that starts up threads when needed and shuts them down later.
        (§ ass (§ name this.executor) (§ new #_"ScheduledThreadPoolExecutor" (§ pars 1, new ContextPropagatingThreadFactory(§ pars "Wallet autosave thread", Thread/MIN_PRIORITY))))
        (§ expr this.executor.setKeepAliveTime(§ pars 5, TimeUnit/SECONDS))
        (§ expr this.executor.allowCoreThreadTimeOut(§ pars true))
        (§ expr this.executor.setExecuteExistingDelayedTasksAfterShutdownPolicy(§ pars false))
        (§ ass (§ name this.wallet) (§ expr Preconditions/checkNotNull(§ pars wallet)))
        ;; File must only be accessed from the auto-save executor from now on, to avoid simultaneous access.
        (§ ass (§ name this.file) (§ expr Preconditions/checkNotNull(§ pars file)))
        (§ ass (§ name this.savePending) (§ new #_"AtomicBoolean" (§ pars )))
        (§ ass (§ name this.delay) delay)
        (§ ass (§ name this.delayTimeUnit) (§ expr Preconditions/checkNotNull(§ pars delayTimeUnit)))

        (§ ass (§ name this.saver) (§ new #_"Callable<Void>" (§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"Void" (§ fn call) [])
                (§ throws #_"Exception")
            (§ block
                ;; Runs in an auto save thread.
                (§ if (§ expr (§ not savePending.getAndSet(§ pars false))))
                (§ block
                    ;; Some other scheduled request already beat us to it.
                    (§ return nil)
                )
                (§ var #_"Date" (§ name lastBlockSeenTime) (§ expr wallet.getLastBlockSeenTime(§ pars )))
                (§ expr log.info(§ pars "Background saving wallet; last seen block is height {}, date {}, hash {}", wallet.getLastBlockSeenHeight(§ pars ), (§ quest (§ expr lastBlockSeenTime != nil) ? (§ expr Utils/dateTimeFormat(§ pars lastBlockSeenTime)) :else (§ expr "unknown")), wallet.getLastBlockSeenHash(§ pars )))
                (§ expr saveNowInternal(§ pars ))
                (§ return nil)
            )
        )))
        (§ void this)
    )

    ;;;
     ; The given listener will be called on the autosave thread before and after the wallet is saved to disk.
     ;;
    #_public
    (§ method #_"void" (§ fn setListener) [#_non-nil #_"Listener" (§ name listener)])
    (§ block
        (§ ass (§ name this.vListener) (§ expr Preconditions/checkNotNull(§ pars listener)))
        (§ void nil)
    )

    ;;; Actually write the wallet file to disk, using an atomic rename when possible.  Runs on the current thread. ;;
    #_public
    (§ method #_"void" (§ fn saveNow) [])
        (§ throws #_"IOException")
    (§ block
        ;; Can be called by any thread. However the wallet is locked whilst saving, so we can have two saves
        ;; in flight, but they will serialize (using different temp files).
        (§ var #_"Date" (§ name lastBlockSeenTime) (§ expr wallet.getLastBlockSeenTime(§ pars )))
        (§ expr log.info(§ pars "Saving wallet; last seen block is height {}, date {}, hash {}", wallet.getLastBlockSeenHeight(§ pars ), (§ quest (§ expr lastBlockSeenTime != nil) ? (§ expr Utils/dateTimeFormat(§ pars lastBlockSeenTime)) :else (§ expr "unknown")), wallet.getLastBlockSeenHash(§ pars )))
        (§ expr saveNowInternal(§ pars ))
        (§ void nil)
    )

    #_private
    (§ method #_"void" (§ fn saveNowInternal) [])
        (§ throws #_"IOException")
    (§ block
        #_final
        (§ var #_"Stopwatch" (§ name watch) (§ expr Stopwatch/createStarted(§ pars )))
        (§ var #_"File" (§ name directory) (§ expr file.getAbsoluteFile(§ pars ).getParentFile(§ pars )))
        (§ var #_"File" (§ name temp) (§ expr File/createTempFile(§ pars "wallet", nil, directory)))
        #_final
        (§ var #_"Listener" (§ name listener) vListener)
        (§ if (§ expr listener != nil))
        (§ block
            (§ expr listener.onBeforeAutoSave(§ pars temp))
        )
        (§ expr wallet.saveToFile(§ pars temp, file))
        (§ if (§ expr listener != nil))
        (§ block
            (§ expr listener.onAfterAutoSave(§ pars file))
        )
        (§ expr watch.stop(§ pars ))
        (§ expr log.info(§ pars "Save completed in {}", watch))
        (§ void nil)
    )

    ;;; Queues up a save in the background.  Useful for not very important wallet changes. ;;
    #_public
    (§ method #_"void" (§ fn saveLater) [])
    (§ block
        (§ if (§ expr savePending.getAndSet(§ pars true)))
        (§ block
            (§ return nil) ;; Already pending.
        )

        (§ expr executor.schedule(§ pars saver, delay, delayTimeUnit))
        (§ void nil)
    )

    ;;; Shut down auto-saving. ;;
    #_public
    (§ method #_"void" (§ fn shutdownAndWait) [])
    (§ block
        (§ expr executor.shutdown(§ pars ))
        (§ try )
        (§ block
            (§ expr executor.awaitTermination(§ pars Long/MAX_VALUE, TimeUnit/DAYS)) ;; forever
        )
        (§ catch #_"InterruptedException" (§ name e))
        (§ block
            (§ throw (§ new #_"RuntimeException" (§ pars e)))
        )
        (§ void nil)
    )
)

#_(ns org.bitcoinj.wallet #_"WalletProtobufSerializer"
    (:import [java.io IOException InputStream OutputStream]
             [java.math BigInteger]
             [java.net InetAddress UnknownHostException]
             [java.util *])
    (:import [com.google.common.base Preconditions]
             [com.google.common.collect Lists]
             [com.google.protobuf ByteString CodedInputStream CodedOutputStream TextFormat WireFormat]
             [org.slf4j Logger LoggerFactory])
   (:require [org.bitcoinj.core *]
             [org.bitcoinj.core.TransactionConfidence ConfidenceType]
             [org.bitcoinj.crypto KeyCrypter KeyCrypterScrypt]
             [org.bitcoinj.script Script]
             [org.bitcoinj.signers LocalTransactionSigner TransactionSigner]
             [org.bitcoinj.utils ExchangeRate Fiat]
             [org.bitcoinj.wallet.Protos.Wallet EncryptionType]))

;;;
 ; Serialize and de-serialize a wallet to a byte stream containing a
 ; <a href="https://developers.google.com/protocol-buffers/docs/overview">protocol buffer</a>.  Protocol buffers are
 ; a data interchange format developed by Google with an efficient binary representation, a type safe specification
 ; language and compilers that generate code to work with those data structures for many languages.  Protocol buffers
 ; can have their format evolved over time: conceptually they represent data using (tag, length, value) tuples.  The
 ; format is defined by the <tt>wallet.proto</tt> file in the bitcoinj source distribution.
 ;
 ; This class is used through its static methods.  The most common operations are writeWallet and readWallet, which do
 ; the obvious operations on Output/InputStreams.  You can use a {@link java.io.ByteArrayInputStream} and equivalent
 ; {@link java.io.ByteArrayOutputStream} if you'd like byte arrays instead.  The protocol buffer can also be manipulated
 ; in its object form if you'd like to modify the flattened data structure before serialization to binary.
 ;
 ; You can extend the wallet format with additional fields specific to your application if you want, but make sure
 ; to either put the extra data in the provided extension areas, or select tag numbers that are unlikely to be used
 ; by anyone else.
 ;
 ; @author Miron Cuperman
 ; @author Andreas Schildbach
 ;;
#_public
(§ class #_"WalletProtobufSerializer"
    #_private
    #_static
    #_final
    (§ field #_"Logger" (§ name log) (§ expr LoggerFactory/getLogger(§ pars (§ klass #_"WalletProtobufSerializer"))))

    ;;; Current version used for serializing wallets.  A version higher than this is considered from the future. ;;
    #_public
    #_static
    #_final
    (§ field #_"int" (§ name CURRENT_WALLET_VERSION) (§ expr Protos/Wallet.getDefaultInstance(§ pars ).getVersion(§ pars )))
    ;; 512 MB
    #_private
    #_static
    #_final
    (§ field #_"int" (§ name WALLET_SIZE_LIMIT) (§ expr 512 * 1024 * 1024))
    ;; Used for de-serialization.
    #_protected
    (§ field #_"Map<ByteString, Transaction>" (§ name txMap))

    #_private
    (§ field #_"int" (§ name walletWriteBufferSize) (§ expr CodedOutputStream/DEFAULT_BUFFER_SIZE))

    #_public
    (§ interface #_"WalletFactory"
        (§ method #_"Wallet" (§ fn create) [#_"NetworkParameters" (§ name params), #_"KeyChainGroup" (§ name keyChainGroup)])
    )

    #_private
    #_final
    (§ field #_"WalletFactory" (§ name factory))
    #_private
    (§ field #_"KeyChainFactory" (§ name keyChainFactory))

    #_public
    (§ constructor #_"WalletProtobufSerializer" [])
    (§ block
        (§ this (§ pars (§ new #_"WalletFactory" (§ pars )
        (§ anon
            #_override
            #_public
            (§ method #_"Wallet" (§ fn create) [#_"NetworkParameters" (§ name params), #_"KeyChainGroup" (§ name keyChainGroup)])
            (§ block
                (§ return (§ new #_"Wallet" (§ pars params, keyChainGroup)))
            )
        ))))
        (§ void this)
    )

    #_public
    (§ constructor #_"WalletProtobufSerializer" [#_"WalletFactory" (§ name factory)])
    (§ block
        (§ ass (§ name txMap) (§ new #_"HashMap<>" (§ pars )))
        (§ ass (§ name this.factory) factory)
        (§ ass (§ name this.keyChainFactory) (§ new #_"DefaultKeyChainFactory" (§ pars )))
        (§ void this)
    )

    #_public
    (§ method #_"void" (§ fn setKeyChainFactory) [#_"KeyChainFactory" (§ name keyChainFactory)])
    (§ block
        (§ ass (§ name this.keyChainFactory) keyChainFactory)
        (§ void nil)
    )

    ;;;
     ; Change buffer size for writing wallet to output stream.
     ; Default is {@link com.google.protobuf.CodedOutputStream.DEFAULT_BUFFER_SIZE}.
     ; @param walletWriteBufferSize Buffer size in bytes.
     ;;
    #_public
    (§ method #_"void" (§ fn setWalletWriteBufferSize) [#_"int" (§ name walletWriteBufferSize)])
    (§ block
        (§ ass (§ name this.walletWriteBufferSize) walletWriteBufferSize)
        (§ void nil)
    )

    ;;;
     ; Formats the given wallet (transactions and keys) to the given output stream in protocol buffer format.
     ;
     ; Equivalent to <tt>walletToProto(wallet).writeTo(output)</tt>.
     ;;
    #_public
    (§ method #_"void" (§ fn writeWallet) [#_"Wallet" (§ name wallet), #_"OutputStream" (§ name output)])
        (§ throws #_"IOException")
    (§ block
        (§ var #_"Protos.Wallet" (§ name walletProto) (§ expr walletToProto(§ pars wallet)))
        #_final
        (§ var #_"CodedOutputStream" (§ name codedOutput) (§ expr CodedOutputStream/newInstance(§ pars output, this.walletWriteBufferSize)))
        (§ expr walletProto.writeTo(§ pars codedOutput))
        (§ expr codedOutput.flush(§ pars ))
        (§ void nil)
    )

    ;;;
     ; Returns the given wallet formatted as text.  The text format is that used by protocol buffers and although
     ; it can also be parsed using {@link TextFormat#merge(CharSequence, com.google.protobuf.Message.Builder)},
     ; it is designed more for debugging than storage.  It is not well specified and wallets are largely binary data
     ; structures anyway, consisting as they do of keys (large random numbers) and {@link Transaction}s which also
     ; mostly contain keys and hashes.
     ;;
    #_public
    (§ method #_"String" (§ fn walletToText) [#_"Wallet" (§ name wallet)])
    (§ block
        (§ var #_"Protos.Wallet" (§ name walletProto) (§ expr walletToProto(§ pars wallet)))
        (§ return (§ expr TextFormat/printToString(§ pars walletProto)))
    )

    ;;;
     ; Converts the given wallet to the object representation of the protocol buffers.  This can be modified, or
     ; additional data fields set, before serialization takes place.
     ;;
    #_public
    (§ method #_"Protos.Wallet" (§ fn walletToProto) [#_"Wallet" (§ name wallet)])
    (§ block
        (§ var #_"Protos.Wallet.Builder" (§ name walletBuilder) (§ expr Protos/Wallet.newBuilder(§ pars )))
        (§ expr walletBuilder.setNetworkIdentifier(§ pars wallet.getNetworkParameters(§ pars ).getId(§ pars )))
        (§ if (§ expr wallet.getDescription(§ pars ) != nil))
        (§ block
            (§ expr walletBuilder.setDescription(§ pars wallet.getDescription(§ pars )))
        )

        (§ for (§ var #_"WalletTransaction" (§ name wtx)) :for (§ expr wallet.getWalletTransactions(§ pars )))
        (§ block
            (§ var #_"Protos.Transaction" (§ name txProto) (§ expr makeTxProto(§ pars wtx)))
            (§ expr walletBuilder.addTransaction(§ pars txProto))
        )

        (§ expr walletBuilder.addAllKey(§ pars wallet.serializeKeyChainGroupToProtobuf(§ pars )))

        ;; Populate the lastSeenBlockHash field.
        (§ var #_"Sha256Hash" (§ name lastSeenBlockHash) (§ expr wallet.getLastBlockSeenHash(§ pars )))
        (§ if (§ expr lastSeenBlockHash != nil))
        (§ block
            (§ expr walletBuilder.setLastSeenBlockHash(§ pars hashToByteString(§ pars lastSeenBlockHash)))
            (§ expr walletBuilder.setLastSeenBlockHeight(§ pars wallet.getLastBlockSeenHeight(§ pars )))
        )
        (§ if (§ expr 0 < wallet.getLastBlockSeenTimeSecs(§ pars )))
        (§ block
            (§ expr walletBuilder.setLastSeenBlockTimeSecs(§ pars wallet.getLastBlockSeenTimeSecs(§ pars )))
        )

        ;; Populate the scrypt parameters.
        (§ var #_"KeyCrypter" (§ name keyCrypter) (§ expr wallet.getKeyCrypter(§ pars )))
        (§ if (§ expr keyCrypter == nil))
        (§ block
            ;; The wallet is unencrypted.
            (§ expr walletBuilder.setEncryptionType(§ pars EncryptionType/UNENCRYPTED))
        )
        (§ else )
        (§ block
            ;; The wallet is encrypted.
            (§ expr walletBuilder.setEncryptionType(§ pars keyCrypter.getUnderstoodEncryptionType(§ pars )))
            (§ if (§ insta keyCrypter #_"KeyCrypterScrypt"))
            (§ block
                (§ var #_"KeyCrypterScrypt" (§ name keyCrypterScrypt) (§ expr (§ cast #_"KeyCrypterScrypt" keyCrypter)))
                (§ expr walletBuilder.setEncryptionParameters(§ pars keyCrypterScrypt.getScryptParameters(§ pars )))
            )
            (§ else )
            (§ block
                ;; Some other form of encryption has been specified that we do not know how to persist.
                (§ throw (§ new #_"RuntimeException" (§ pars "The wallet has encryption of type '" + keyCrypter.getUnderstoodEncryptionType(§ pars ) + "' but this WalletProtobufSerializer does not know how to persist this.")))
            )
        )

        (§ if (§ expr wallet.getKeyRotationTime(§ pars ) != nil))
        (§ block
            (§ var #_"long" (§ name timeSecs) (§ expr wallet.getKeyRotationTime(§ pars ).getTime(§ pars ) / 1000))
            (§ expr walletBuilder.setKeyRotationTime(§ pars timeSecs))
        )

        (§ for (§ var #_"TransactionSigner" (§ name signer)) :for (§ expr wallet.getTransactionSigners(§ pars )))
        (§ block
            ;; Do not serialize LocalTransactionSigner as it's being added implicitly.
            (§ if (§ insta signer #_"LocalTransactionSigner"))
            (§ block
                (§ continue )
            )

            (§ var #_"Protos.TransactionSigner.Builder" (§ name protoSigner) (§ expr Protos/TransactionSigner.newBuilder(§ pars )))
            (§ expr protoSigner.setClassName(§ pars signer.getClass(§ pars ).getName(§ pars )))
            (§ expr protoSigner.setData(§ pars ByteString/copyFrom(§ pars signer.serialize(§ pars ))))
            (§ expr walletBuilder.addTransactionSigners(§ pars protoSigner))
        )

        ;; Populate the wallet version.
        (§ expr walletBuilder.setVersion(§ pars wallet.getVersion(§ pars )))

        (§ return (§ expr walletBuilder.build(§ pars )))
    )

    #_private
    #_static
    (§ method #_"Protos.Transaction" (§ fn makeTxProto) [#_"WalletTransaction" (§ name wtx)])
    (§ block
        (§ var #_"Transaction" (§ name tx) (§ expr wtx.getTransaction(§ pars )))
        (§ var #_"Protos.Transaction.Builder" (§ name txBuilder) (§ expr Protos/Transaction.newBuilder(§ pars )))

        (§ expr txBuilder.setPool(§ pars getProtoPool(§ pars wtx)).setHash(§ pars hashToByteString(§ pars tx.getHash(§ pars ))).setVersion(§ pars (§ cast #_"int" (§ expr tx.getVersion(§ pars )))))

        (§ if (§ expr tx.getUpdateTime(§ pars ) != nil))
        (§ block
            (§ expr txBuilder.setUpdatedAt(§ pars tx.getUpdateTime(§ pars ).getTime(§ pars )))
        )

        (§ if (§ expr 0 < tx.getLockTime(§ pars )))
        (§ block
            (§ expr txBuilder.setLockTime(§ pars (§ cast #_"int" (§ expr tx.getLockTime(§ pars )))))
        )

        ;; Handle inputs.
        (§ for (§ var #_"TransactionInput" (§ name input)) :for (§ expr tx.getInputs(§ pars )))
        (§ block
            (§ var #_"Protos.TransactionInput.Builder" (§ name inputBuilder) (§ expr Protos/TransactionInput.newBuilder(§ pars ).setScriptBytes(§ pars ByteString/copyFrom(§ pars input.getScriptBytes(§ pars ))).setTransactionOutPointHash(§ pars hashToByteString(§ pars input.getOutpoint(§ pars ).getHash(§ pars ))).setTransactionOutPointIndex(§ pars (§ cast #_"int" (§ dot input.getOutpoint(§ pars ).getIndex(§ pars ))))))
            (§ if (§ expr input.hasSequence(§ pars )))
            (§ block
                (§ expr inputBuilder.setSequence(§ pars (§ cast #_"int" (§ expr input.getSequenceNumber(§ pars )))))
            )
            (§ if (§ expr input.getValue(§ pars ) != nil))
            (§ block
                (§ expr inputBuilder.setValue(§ pars input.getValue(§ pars ).value))
            )
            (§ expr txBuilder.addTransactionInput(§ pars inputBuilder))
        )

        ;; Handle outputs.
        (§ for (§ var #_"TransactionOutput" (§ name output)) :for (§ expr tx.getOutputs(§ pars )))
        (§ block
            (§ var #_"Protos.TransactionOutput.Builder" (§ name outputBuilder) (§ expr Protos/TransactionOutput.newBuilder(§ pars ).setScriptBytes(§ pars ByteString/copyFrom(§ pars output.getScriptBytes(§ pars ))).setValue(§ pars output.getValue(§ pars ).value)))
            #_final
            (§ var #_"TransactionInput" (§ name spentBy) (§ expr output.getSpentBy(§ pars )))
            (§ if (§ expr spentBy != nil))
            (§ block
                (§ var #_"Sha256Hash" (§ name spendingHash) (§ expr spentBy.getParentTransaction(§ pars ).getHash(§ pars )))
                (§ var #_"int" (§ name spentByTransactionIndex) (§ expr spentBy.getParentTransaction(§ pars ).getInputs(§ pars ).indexOf(§ pars spentBy)))
                (§ expr outputBuilder.setSpentByTransactionHash(§ pars hashToByteString(§ pars spendingHash)).setSpentByTransactionIndex(§ pars spentByTransactionIndex))
            )
            (§ expr txBuilder.addTransactionOutput(§ pars outputBuilder))
        )

        ;; Handle which blocks tx was seen in.
        #_final
        (§ var #_"Map<Sha256Hash, Integer>" (§ name appearsInHashes) (§ expr tx.getAppearsInHashes(§ pars )))
        (§ if (§ expr appearsInHashes != nil))
        (§ block
            (§ for (§ var #_"Map.Entry<Sha256Hash, Integer>" (§ name entry)) :for (§ expr appearsInHashes.entrySet(§ pars )))
            (§ block
                (§ expr txBuilder.addBlockHash(§ pars hashToByteString(§ pars entry.getKey(§ pars ))))
                (§ expr txBuilder.addBlockRelativityOffsets(§ pars entry.getValue(§ pars )))
            )
        )

        (§ if (§ expr tx.hasConfidence(§ pars )))
        (§ block
            (§ var #_"TransactionConfidence" (§ name confidence) (§ expr tx.getConfidence(§ pars )))
            (§ var #_"Protos.TransactionConfidence.Builder" (§ name confidenceBuilder) (§ expr Protos/TransactionConfidence.newBuilder(§ pars )))
            (§ expr writeConfidence(§ pars txBuilder, confidence, confidenceBuilder))
        )

        (§ var #_"Protos.Transaction.Purpose" (§ name purpose))
        (§ switch (§ expr tx.getPurpose(§ pars )))
        (§ block
            (§ case UNKNOWN)
            (§ block
                (§ ass (§ name purpose) (§ expr Protos/Transaction/Purpose/UNKNOWN))
                (§ break )
            )
            (§ case USER_PAYMENT)
            (§ block
                (§ ass (§ name purpose) (§ expr Protos/Transaction/Purpose/USER_PAYMENT))
                (§ break )
            )
            (§ case KEY_ROTATION)
            (§ block
                (§ ass (§ name purpose) (§ expr Protos/Transaction/Purpose/KEY_ROTATION))
                (§ break )
            )
            (§ case ASSURANCE_CONTRACT_CLAIM)
            (§ block
                (§ ass (§ name purpose) (§ expr Protos/Transaction/Purpose/ASSURANCE_CONTRACT_CLAIM))
                (§ break )
            )
            (§ case ASSURANCE_CONTRACT_PLEDGE)
            (§ block
                (§ ass (§ name purpose) (§ expr Protos/Transaction/Purpose/ASSURANCE_CONTRACT_PLEDGE))
                (§ break )
            )
            (§ case ASSURANCE_CONTRACT_STUB)
            (§ block
                (§ ass (§ name purpose) (§ expr Protos/Transaction/Purpose/ASSURANCE_CONTRACT_STUB))
                (§ break )
            )
            (§ case RAISE_FEE)
            (§ block
                (§ ass (§ name purpose) (§ expr Protos/Transaction/Purpose/RAISE_FEE))
                (§ break )
            )
            (§ default )
            (§ block
                (§ throw (§ new #_"RuntimeException" (§ pars "New tx purpose serialization not implemented.")))
            )
        )
        (§ expr txBuilder.setPurpose(§ pars purpose))

        (§ var #_"ExchangeRate" (§ name exchangeRate) (§ expr tx.getExchangeRate(§ pars )))
        (§ if (§ expr exchangeRate != nil))
        (§ block
            (§ var #_"Protos.ExchangeRate.Builder" (§ name exchangeRateBuilder) (§ expr Protos/ExchangeRate.newBuilder(§ pars ).setCoinValue(§ pars exchangeRate.coin.value).setFiatValue(§ pars exchangeRate.fiat.value).setFiatCurrencyCode(§ pars exchangeRate.fiat.currencyCode)))
            (§ expr txBuilder.setExchangeRate(§ pars exchangeRateBuilder))
        )

        (§ if (§ expr tx.getMemo(§ pars ) != nil))
        (§ block
            (§ expr txBuilder.setMemo(§ pars tx.getMemo(§ pars )))
        )

        (§ return (§ expr txBuilder.build(§ pars )))
    )

    #_private
    #_static
    (§ method #_"Protos.Transaction.Pool" (§ fn getProtoPool) [#_"WalletTransaction" (§ name wtx)])
    (§ block
        (§ switch (§ expr wtx.getPool(§ pars )))
        (§ block
            (§ case UNSPENT)
            (§ block
                (§ return (§ expr Protos/Transaction/Pool/UNSPENT))
            )
            (§ case SPENT)
            (§ block
                (§ return (§ expr Protos/Transaction/Pool/SPENT))
            )
            (§ case DEAD)
            (§ block
                (§ return (§ expr Protos/Transaction/Pool/DEAD))
            )
            (§ case PENDING)
            (§ block
                (§ return (§ expr Protos/Transaction/Pool/PENDING))
            )
            (§ default )
            (§ block
                (§ throw (§ new #_"RuntimeException" (§ pars "Unreachable")))
            )
        )
    )

    #_private
    #_static
    (§ method #_"void" (§ fn writeConfidence) [#_"Protos.Transaction.Builder" (§ name txBuilder), #_"TransactionConfidence" (§ name confidence), #_"Protos.TransactionConfidence.Builder" (§ name confidenceBuilder)])
    (§ block
        (§ sync confidence)
        (§ block
            (§ expr confidenceBuilder.setType(§ pars Protos/TransactionConfidence/Type.valueOf(§ pars confidence.getConfidenceType(§ pars ).getValue(§ pars ))))
            (§ if (§ expr confidence.getConfidenceType(§ pars ) == ConfidenceType/BUILDING))
            (§ block
                (§ expr confidenceBuilder.setAppearedAtHeight(§ pars confidence.getAppearedAtChainHeight(§ pars )))
                (§ expr confidenceBuilder.setDepth(§ pars confidence.getDepthInBlocks(§ pars )))
            )
            (§ if (§ expr confidence.getConfidenceType(§ pars ) == ConfidenceType/DEAD))
            (§ block
                ;; Copy in the overriding transaction, if available.
                ;; (A dead coinbase transaction has no overriding transaction).
                (§ if (§ expr confidence.getOverridingTransaction(§ pars ) != nil))
                (§ block
                    (§ var #_"Sha256Hash" (§ name overridingHash) (§ expr confidence.getOverridingTransaction(§ pars ).getHash(§ pars )))
                    (§ expr confidenceBuilder.setOverridingTransaction(§ pars hashToByteString(§ pars overridingHash)))
                )
            )
            (§ var #_"TransactionConfidence.Source" (§ name source) (§ expr confidence.getSource(§ pars )))
            (§ switch source)
            (§ block
                (§ case SELF)
                (§ block
                    (§ expr confidenceBuilder.setSource(§ pars Protos/TransactionConfidence/Source/SOURCE_SELF))
                    (§ break )
                )
                (§ case NETWORK)
                (§ block
                    (§ expr confidenceBuilder.setSource(§ pars Protos/TransactionConfidence/Source/SOURCE_NETWORK))
                    (§ break )
                )
                (§ case UNKNOWN)
                (§ block
                    ;; Fall through.
                )
                (§ default )
                (§ block
                    (§ expr confidenceBuilder.setSource(§ pars Protos/TransactionConfidence/Source/SOURCE_UNKNOWN))
                    (§ break )
                )
            )
        )

        (§ for (§ var #_"PeerAddress" (§ name address)) :for (§ expr confidence.getBroadcastBy(§ pars )))
        (§ block
            (§ var #_"Protos.PeerAddress" (§ name proto) (§ expr Protos/PeerAddress.newBuilder(§ pars ).setIpAddress(§ pars ByteString/copyFrom(§ pars address.getAddr(§ pars ).getAddress(§ pars ))).setPort(§ pars address.getPort(§ pars )).setServices(§ pars address.getServices(§ pars ).longValue(§ pars )).build(§ pars )))
            (§ expr confidenceBuilder.addBroadcastBy(§ pars proto))
        )
        (§ var #_"Date" (§ name lastBroadcastedAt) (§ expr confidence.getLastBroadcastedAt(§ pars )))
        (§ if (§ expr lastBroadcastedAt != nil))
        (§ block
            (§ expr confidenceBuilder.setLastBroadcastedAt(§ pars lastBroadcastedAt.getTime(§ pars )))
        )
        (§ expr txBuilder.setConfidence(§ pars confidenceBuilder))
        (§ void nil)
    )

    #_public
    #_static
    (§ method #_"ByteString" (§ fn hashToByteString) [#_"Sha256Hash" (§ name hash)])
    (§ block
        (§ return (§ expr ByteString/copyFrom(§ pars hash.getBytes(§ pars ))))
    )

    #_public
    #_static
    (§ method #_"Sha256Hash" (§ fn byteStringToHash) [#_"ByteString" (§ name bs)])
    (§ block
        (§ return (§ expr Sha256Hash/wrap(§ pars bs.toByteArray(§ pars ))))
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails the provided Wallet object may be in an indeterminate state and should be thrown away.</p>
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt data,
     ; internally inconsistent data and so on.  You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
    #_public
    (§ method #_"Wallet" (§ fn readWallet) [#_"InputStream" (§ name input)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        (§ return (§ expr readWallet(§ pars input, false)))
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails the provided Wallet object may be in an indeterminate state and should be thrown away.  Do not
     ; simply call this method again on the same Wallet object with {@code forceReset} set {@code true}.
     ; It won't work.</p>
     ;
     ; <p>If {@code forceReset} is {@code true}, then no transactions are loaded from the wallet, and
     ; it is configured to replay transactions from the blockchain (as if the wallet had been loaded and
     ; {@link Wallet.reset} had been called immediately thereafter).
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt data,
     ; internally inconsistent data and so on. You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
    #_public
    (§ method #_"Wallet" (§ fn readWallet) [#_"InputStream" (§ name input), #_"boolean" (§ name forceReset)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        (§ try )
        (§ block
            (§ var #_"Protos.Wallet" (§ name walletProto) (§ expr parseToProto(§ pars input)))
            #_final
            (§ var #_"String" (§ name paramsID) (§ expr walletProto.getNetworkIdentifier(§ pars )))
            (§ var #_"NetworkParameters" (§ name params) (§ expr NetworkParameters/fromID(§ pars paramsID)))
            (§ if (§ expr params == nil))
            (§ block
                (§ throw (§ new #_"UnreadableWalletException" (§ pars "Unknown network parameters ID " + paramsID)))
            )

            (§ return (§ expr readWallet(§ pars params, walletProto, forceReset)))
        )
        (§ catch #_"IOException" (§ name e))
        (§ block
            (§ throw (§ new #_"UnreadableWalletException" (§ pars "Could not parse input stream to protobuf", e)))
        )
        (§ catch #_"IllegalStateException" (§ name e))
        (§ block
            (§ throw (§ new #_"UnreadableWalletException" (§ pars "Could not parse input stream to protobuf", e)))
        )
        (§ catch #_"IllegalArgumentException" (§ name e))
        (§ block
            (§ throw (§ new #_"UnreadableWalletException" (§ pars "Could not parse input stream to protobuf", e)))
        )
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails, the provided Wallet object may be in an indeterminate state and should be thrown away.</p>
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt
     ; data, internally inconsistent data and so on.  You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
    #_public
    (§ method #_"Wallet" (§ fn readWallet) [#_"NetworkParameters" (§ name params), #_"Protos.Wallet" (§ name walletProto)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        (§ return (§ expr readWallet(§ pars params, walletProto, false)))
    )

    ;;;
     ; <p>Loads wallet data from the given protocol buffer and inserts it into the given Wallet object.
     ; This is primarily useful when you wish to pre-register extension objects.  Note that if loading
     ; fails, the provided Wallet object may be in an indeterminate state and should be thrown away.  Do not
     ; simply call this method again on the same Wallet object with {@code forceReset} set {@code true}.
     ; It won't work.</p>
     ;
     ; <p>If {@code forceReset} is {@code true}, then no transactions are loaded from the wallet, and it is
     ; configured to replay transactions from the blockchain (as if the wallet had been loaded and
     ; {@link Wallet.reset} had been called immediately thereafter).
     ;
     ; <p>A wallet can be unreadable for various reasons, such as inability to open the file, corrupt data,
     ; internally inconsistent data and so on.  You should always handle
     ; {@link UnreadableWalletException} and communicate failure to the user in an appropriate manner.</p>
     ;
     ; @throws UnreadableWalletException in various error conditions (see description).
     ;;
    #_public
    (§ method #_"Wallet" (§ fn readWallet) [#_"NetworkParameters" (§ name params), #_"Protos.Wallet" (§ name walletProto), #_"boolean" (§ name forceReset)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        (§ if (§ expr CURRENT_WALLET_VERSION < walletProto.getVersion(§ pars )))
        (§ block
            (§ throw (§ new #_"UnreadableWalletException.FutureVersion" (§ pars )))
        )
        (§ if (§ not (§ dot walletProto.getNetworkIdentifier(§ pars ).equals(§ pars params.getId(§ pars )))))
        (§ block
            (§ throw (§ new #_"UnreadableWalletException.WrongNetwork" (§ pars )))
        )

        ;; Read the scrypt parameters that specify how encryption and decryption is performed.
        (§ var #_"KeyChainGroup" (§ name keyChainGroup))
        (§ if (§ expr walletProto.hasEncryptionParameters(§ pars )))
        (§ block
            (§ var #_"Protos.ScryptParameters" (§ name encryptionParameters) (§ expr walletProto.getEncryptionParameters(§ pars )))
            #_final
            (§ var #_"KeyCrypterScrypt" (§ name keyCrypter) (§ new #_"KeyCrypterScrypt" (§ pars encryptionParameters)))
            (§ ass (§ name keyChainGroup) (§ expr KeyChainGroup/fromProtobufEncrypted(§ pars params, walletProto.getKeyList(§ pars ), keyCrypter, keyChainFactory)))
        )
        (§ else )
        (§ block
            (§ ass (§ name keyChainGroup) (§ expr KeyChainGroup/fromProtobufUnencrypted(§ pars params, walletProto.getKeyList(§ pars ), keyChainFactory)))
        )

        (§ var #_"Wallet" (§ name wallet) (§ expr factory.create(§ pars params, keyChainGroup)))
        (§ if (§ expr walletProto.hasDescription(§ pars )))
        (§ block
            (§ expr wallet.setDescription(§ pars walletProto.getDescription(§ pars )))
        )

        (§ if forceReset)
        (§ block
            ;; Should mirror Wallet.reset().
            (§ expr wallet.setLastBlockSeenHash(§ pars nil))
            (§ expr wallet.setLastBlockSeenHeight(§ pars -1))
            (§ expr wallet.setLastBlockSeenTimeSecs(§ pars 0))
        )
        (§ else )
        (§ block
            ;; Read all transactions and insert into the txMap.
            (§ for (§ var #_"Protos.Transaction" (§ name txProto)) :for (§ expr walletProto.getTransactionList(§ pars )))
            (§ block
                (§ expr readTransaction(§ pars txProto, wallet.getParams(§ pars )))
            )

            ;; Update transaction outputs to point to inputs that spend them.
            (§ for (§ var #_"Protos.Transaction" (§ name txProto)) :for (§ expr walletProto.getTransactionList(§ pars )))
            (§ block
                (§ var #_"WalletTransaction" (§ name wtx) (§ expr connectTransactionOutputs(§ pars params, txProto)))
                (§ expr wallet.addWalletTransaction(§ pars wtx))
            )

            ;; Update the lastBlockSeenHash.
            (§ if (§ expr (§ not walletProto.hasLastSeenBlockHash(§ pars ))))
            (§ block
                (§ expr wallet.setLastBlockSeenHash(§ pars nil))
            )
            (§ else )
            (§ block
                (§ expr wallet.setLastBlockSeenHash(§ pars byteStringToHash(§ pars walletProto.getLastSeenBlockHash(§ pars ))))
            )

            (§ if (§ expr (§ not walletProto.hasLastSeenBlockHeight(§ pars ))))
            (§ block
                (§ expr wallet.setLastBlockSeenHeight(§ pars -1))
            )
            (§ else )
            (§ block
                (§ expr wallet.setLastBlockSeenHeight(§ pars walletProto.getLastSeenBlockHeight(§ pars )))
            )

            ;; Will default to zero if not present.
            (§ expr wallet.setLastBlockSeenTimeSecs(§ pars walletProto.getLastSeenBlockTimeSecs(§ pars )))

            (§ if (§ expr walletProto.hasKeyRotationTime(§ pars )))
            (§ block
                (§ expr wallet.setKeyRotationTime(§ pars (§ new #_"Date" (§ pars walletProto.getKeyRotationTime(§ pars ) * 1000))))
            )
        )

        (§ for (§ var #_"Protos.TransactionSigner" (§ name signerProto)) :for (§ expr walletProto.getTransactionSignersList(§ pars )))
        (§ block
            (§ try )
            (§ block
                (§ var #_"Class" (§ name signerClass) (§ expr Class/forName(§ pars signerProto.getClassName(§ pars ))))
                (§ var #_"TransactionSigner" (§ name signer) (§ expr (§ cast #_"TransactionSigner" (§ expr signerClass.newInstance(§ pars )))))
                (§ expr signer.deserialize(§ pars signerProto.getData(§ pars ).toByteArray(§ pars )))
                (§ expr wallet.addTransactionSigner(§ pars signer))
            )
            (§ catch #_"Exception" (§ name e))
            (§ block
                (§ throw (§ new #_"UnreadableWalletException" (§ pars "Unable to deserialize TransactionSigner instance: " + signerProto.getClassName(§ pars ), e)))
            )
        )

        (§ if (§ expr walletProto.hasVersion(§ pars )))
        (§ block
            (§ expr wallet.setVersion(§ pars walletProto.getVersion(§ pars )))
        )

        ;; Make sure the object can be re-used to read another wallet without corruption.
        (§ expr txMap.clear(§ pars ))

        (§ return wallet)
    )

    ;;;
     ; Returns the loaded protocol buffer from the given byte stream.  You normally want
     ; {@link Wallet#loadFromFile(java.io.File)} instead - this method is designed for
     ; low level work involving the wallet file format itself.
     ;;
    #_public
    #_static
    (§ method #_"Protos.Wallet" (§ fn parseToProto) [#_"InputStream" (§ name input)])
        (§ throws #_"IOException")
    (§ block
        (§ var #_"CodedInputStream" (§ name codedInput) (§ expr CodedInputStream/newInstance(§ pars input)))
        (§ expr codedInput.setSizeLimit(§ pars WALLET_SIZE_LIMIT))
        (§ return (§ expr Protos/Wallet.parseFrom(§ pars codedInput)))
    )

    #_private
    (§ method #_"void" (§ fn readTransaction) [#_"Protos.Transaction" (§ name txProto), #_"NetworkParameters" (§ name params)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        (§ var #_"Transaction" (§ name tx) (§ new #_"Transaction" (§ pars params)))

        (§ expr tx.setVersion(§ pars txProto.getVersion(§ pars )))

        (§ if (§ expr txProto.hasUpdatedAt(§ pars )))
        (§ block
            (§ expr tx.setUpdateTime(§ pars (§ new #_"Date" (§ pars txProto.getUpdatedAt(§ pars )))))
        )

        (§ for (§ var #_"Protos.TransactionOutput" (§ name outputProto)) :for (§ expr txProto.getTransactionOutputList(§ pars )))
        (§ block
            (§ var #_"Coin" (§ name value) (§ expr Coin/valueOf(§ pars outputProto.getValue(§ pars ))))
            (§ var #_"byte[]" (§ name scriptBytes) (§ expr outputProto.getScriptBytes(§ pars ).toByteArray(§ pars )))
            (§ var #_"TransactionOutput" (§ name output) (§ new #_"TransactionOutput" (§ pars params, tx, value, scriptBytes)))
            (§ expr tx.addOutput(§ pars output))
        )

        (§ for (§ var #_"Protos.TransactionInput" (§ name inputProto)) :for (§ expr txProto.getTransactionInputList(§ pars )))
        (§ block
            (§ var #_"byte[]" (§ name scriptBytes) (§ expr inputProto.getScriptBytes(§ pars ).toByteArray(§ pars )))
            (§ var #_"TransactionOutPoint" (§ name outpoint) (§ new #_"TransactionOutPoint" (§ pars params, inputProto.getTransactionOutPointIndex(§ pars ) & 0xffffffff, byteStringToHash(§ pars inputProto.getTransactionOutPointHash(§ pars )))))
            (§ var #_"Coin" (§ name value) (§ quest (§ expr inputProto.hasValue(§ pars )) ? (§ expr Coin/valueOf(§ pars inputProto.getValue(§ pars ))) :else nil))
            (§ var #_"TransactionInput" (§ name input) (§ new #_"TransactionInput" (§ pars params, tx, scriptBytes, outpoint, value)))
            (§ if (§ expr inputProto.hasSequence(§ pars )))
            (§ block
                (§ expr input.setSequenceNumber(§ pars 0xffffffff & inputProto.getSequence(§ pars )))
            )
            (§ expr tx.addInput(§ pars input))
        )

        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < txProto.getBlockHashCount(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ var #_"ByteString" (§ name blockHash) (§ expr txProto.getBlockHash(§ pars i)))
            (§ var #_"int" (§ name relativityOffset) 0)
            (§ if (§ expr 0 < txProto.getBlockRelativityOffsetsCount(§ pars )))
            (§ block
                (§ ass (§ name relativityOffset) (§ expr txProto.getBlockRelativityOffsets(§ pars i)))
            )
            (§ expr tx.addBlockAppearance(§ pars byteStringToHash(§ pars blockHash), relativityOffset))
        )

        (§ if (§ expr txProto.hasLockTime(§ pars )))
        (§ block
            (§ expr tx.setLockTime(§ pars 0xffffffff & txProto.getLockTime(§ pars )))
        )

        (§ if (§ expr txProto.hasPurpose(§ pars )))
        (§ block
            (§ switch (§ expr txProto.getPurpose(§ pars )))
            (§ block
                (§ case UNKNOWN)
                (§ block
                    (§ expr tx.setPurpose(§ pars Transaction/Purpose/UNKNOWN))
                    (§ break )
                )
                (§ case USER_PAYMENT)
                (§ block
                    (§ expr tx.setPurpose(§ pars Transaction/Purpose/USER_PAYMENT))
                    (§ break )
                )
                (§ case KEY_ROTATION)
                (§ block
                    (§ expr tx.setPurpose(§ pars Transaction/Purpose/KEY_ROTATION))
                    (§ break )
                )
                (§ case ASSURANCE_CONTRACT_CLAIM)
                (§ block
                    (§ expr tx.setPurpose(§ pars Transaction/Purpose/ASSURANCE_CONTRACT_CLAIM))
                    (§ break )
                )
                (§ case ASSURANCE_CONTRACT_PLEDGE)
                (§ block
                    (§ expr tx.setPurpose(§ pars Transaction/Purpose/ASSURANCE_CONTRACT_PLEDGE))
                    (§ break )
                )
                (§ case ASSURANCE_CONTRACT_STUB)
                (§ block
                    (§ expr tx.setPurpose(§ pars Transaction/Purpose/ASSURANCE_CONTRACT_STUB))
                    (§ break )
                )
                (§ case RAISE_FEE)
                (§ block
                    (§ expr tx.setPurpose(§ pars Transaction/Purpose/RAISE_FEE))
                    (§ break )
                )
                (§ default )
                (§ block
                    (§ throw (§ new #_"RuntimeException" (§ pars "New purpose serialization not implemented")))
                )
            )
        )
        (§ else )
        (§ block
            ;; Old wallet: assume a user payment as that's the only reason a new tx would have been created back then.
            (§ expr tx.setPurpose(§ pars Transaction/Purpose/USER_PAYMENT))
        )

        (§ if (§ expr txProto.hasExchangeRate(§ pars )))
        (§ block
            (§ var #_"Protos.ExchangeRate" (§ name exchangeRateProto) (§ expr txProto.getExchangeRate(§ pars )))
            (§ expr tx.setExchangeRate(§ pars (§ new #_"ExchangeRate" (§ pars Coin/valueOf(§ pars exchangeRateProto.getCoinValue(§ pars )), Fiat/valueOf(§ pars exchangeRateProto.getFiatCurrencyCode(§ pars ), exchangeRateProto.getFiatValue(§ pars ))))))
        )

        (§ if (§ expr txProto.hasMemo(§ pars )))
        (§ block
            (§ expr tx.setMemo(§ pars txProto.getMemo(§ pars )))
        )

        ;; Transaction should now be complete.
        (§ var #_"Sha256Hash" (§ name protoHash) (§ expr byteStringToHash(§ pars txProto.getHash(§ pars ))))
        (§ if (§ not (§ dot tx.getHash(§ pars ).equals(§ pars protoHash))))
        (§ block
            (§ throw (§ new #_"UnreadableWalletException" (§ pars String/format(§ pars Locale/US, "Transaction did not deserialize completely: %s vs %s", tx.getHash(§ pars ), protoHash))))
        )
        (§ if (§ expr txMap.containsKey(§ pars txProto.getHash(§ pars ))))
        (§ block
            (§ throw (§ new #_"UnreadableWalletException" (§ pars "Wallet contained duplicate transaction " + byteStringToHash(§ pars txProto.getHash(§ pars )))))
        )
        (§ expr txMap.put(§ pars txProto.getHash(§ pars ), tx))
        (§ void nil)
    )

    #_private
    (§ method #_"WalletTransaction" (§ fn connectTransactionOutputs) [#_final #_"NetworkParameters" (§ name params), #_final #_"org.bitcoinj.wallet.Protos.Transaction" (§ name txProto)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        (§ var #_"Transaction" (§ name tx) (§ expr txMap.get(§ pars txProto.getHash(§ pars ))))
        #_final
        (§ var #_"WalletTransaction.Pool" (§ name pool))
        (§ switch (§ expr txProto.getPool(§ pars )))
        (§ block
            (§ case DEAD)
            (§ block
                (§ ass (§ name pool) (§ expr WalletTransaction/Pool/DEAD))
                (§ break )
            )
            (§ case PENDING)
            (§ block
                (§ ass (§ name pool) (§ expr WalletTransaction/Pool/PENDING))
                (§ break )
            )
            (§ case SPENT)
            (§ block
                (§ ass (§ name pool) (§ expr WalletTransaction/Pool/SPENT))
                (§ break )
            )
            (§ case UNSPENT)
            (§ block
                (§ ass (§ name pool) (§ expr WalletTransaction/Pool/UNSPENT))
                (§ break )
            )
            ;; Upgrade old wallets: inactive pool has been merged with the pending pool.
            ;; Remove this some time after 0.9 is old and everyone has upgraded.
            ;; There should not be any spent outputs in this tx as old wallets would not allow them to be spent in this state.
            (§ case INACTIVE)
            (§ case PENDING_INACTIVE)
            (§ block
                (§ ass (§ name pool) (§ expr WalletTransaction/Pool/PENDING))
                (§ break )
            )
            (§ default )
            (§ block
                (§ throw (§ new #_"UnreadableWalletException" (§ pars "Unknown transaction pool: " + txProto.getPool(§ pars ))))
            )
        )

        (§ for (§ var #_"int" (§ name i) 0) :for (§ expr i < tx.getOutputs(§ pars ).size(§ pars )) :for (§ ass (§ name i) (§ expr i + 1)))
        (§ block
            (§ var #_"TransactionOutput" (§ name output) (§ expr tx.getOutputs(§ pars ).get(§ pars i)))
            #_final
            (§ var #_"Protos.TransactionOutput" (§ name transactionOutput) (§ expr txProto.getTransactionOutput(§ pars i)))
            (§ if (§ expr transactionOutput.hasSpentByTransactionHash(§ pars )))
            (§ block
                #_final
                (§ var #_"ByteString" (§ name spentByTransactionHash) (§ expr transactionOutput.getSpentByTransactionHash(§ pars )))
                (§ var #_"Transaction" (§ name spendingTx) (§ expr txMap.get(§ pars spentByTransactionHash)))
                (§ if (§ expr spendingTx == nil))
                (§ block
                    (§ throw (§ new #_"UnreadableWalletException" (§ pars String/format(§ pars Locale/US, "Could not connect %s to %s", tx.getHashAsString(§ pars ), byteStringToHash(§ pars spentByTransactionHash)))))
                )

                #_final
                (§ var #_"int" (§ name spendingIndex) (§ expr transactionOutput.getSpentByTransactionIndex(§ pars )))
                (§ var #_"TransactionInput" (§ name input) (§ expr Preconditions/checkNotNull(§ pars spendingTx.getInput(§ pars spendingIndex))))
                (§ expr input.connect(§ pars output))
            )
        )

        (§ if (§ expr txProto.hasConfidence(§ pars )))
        (§ block
            (§ var #_"Protos.TransactionConfidence" (§ name confidenceProto) (§ expr txProto.getConfidence(§ pars )))
            (§ var #_"TransactionConfidence" (§ name confidence) (§ expr tx.getConfidence(§ pars )))
            (§ expr readConfidence(§ pars params, tx, confidenceProto, confidence))
        )

        (§ return (§ new #_"WalletTransaction" (§ pars pool, tx)))
    )

    #_private
    (§ method #_"void" (§ fn readConfidence) [#_final #_"NetworkParameters" (§ name params), #_final #_"Transaction" (§ name tx), #_final #_"Protos.TransactionConfidence" (§ name confidenceProto), #_final #_"TransactionConfidence" (§ name confidence)])
        (§ throws #_"UnreadableWalletException")
    (§ block
        ;; We are lenient here because tx confidence is not an essential part of the wallet.
        ;; If the tx has an unknown type of confidence, ignore.
        (§ if (§ expr (§ not confidenceProto.hasType(§ pars ))))
        (§ block
            (§ expr log.warn(§ pars "Unknown confidence type for tx {}", tx.getHashAsString(§ pars )))
            (§ return nil)
        )

        (§ var #_"ConfidenceType" (§ name confidenceType))
        (§ switch (§ expr confidenceProto.getType(§ pars )))
        (§ block
            (§ case BUILDING)
            (§ block
                (§ ass (§ name confidenceType) (§ expr ConfidenceType/BUILDING))
                (§ break )
            )
            (§ case DEAD)
            (§ block
                (§ ass (§ name confidenceType) (§ expr ConfidenceType/DEAD))
                (§ break )
            )
            ;; These two are equivalent (must be able to read old wallets).
            (§ case NOT_IN_BEST_CHAIN)
            (§ block
                (§ ass (§ name confidenceType) (§ expr ConfidenceType/PENDING))
                (§ break )
            )
            (§ case PENDING)
            (§ block
                (§ ass (§ name confidenceType) (§ expr ConfidenceType/PENDING))
                (§ break )
            )
            (§ case IN_CONFLICT)
            (§ block
                (§ ass (§ name confidenceType) (§ expr ConfidenceType/IN_CONFLICT))
                (§ break )
            )
            (§ case UNKNOWN)
            (§ block
                ;; Fall through.
            )
            (§ default )
            (§ block
                (§ ass (§ name confidenceType) (§ expr ConfidenceType/UNKNOWN))
                (§ break )
            )
        )
        (§ expr confidence.setConfidenceType(§ pars confidenceType))
        (§ if (§ expr confidenceProto.hasAppearedAtHeight(§ pars )))
        (§ block
            (§ if (§ expr confidence.getConfidenceType(§ pars ) != ConfidenceType/BUILDING))
            (§ block
                (§ expr log.warn(§ pars "Have appearedAtHeight but not BUILDING for tx {}", tx.getHashAsString(§ pars )))
                (§ return nil)
            )
            (§ expr confidence.setAppearedAtChainHeight(§ pars confidenceProto.getAppearedAtHeight(§ pars )))
        )

        (§ if (§ expr confidenceProto.hasDepth(§ pars )))
        (§ block
            (§ if (§ expr confidence.getConfidenceType(§ pars ) != ConfidenceType/BUILDING))
            (§ block
                (§ expr log.warn(§ pars "Have depth but not BUILDING for tx {}", tx.getHashAsString(§ pars )))
                (§ return nil)
            )
            (§ expr confidence.setDepthInBlocks(§ pars confidenceProto.getDepth(§ pars )))
        )

        (§ if (§ expr confidenceProto.hasOverridingTransaction(§ pars )))
        (§ block
            (§ if (§ expr confidence.getConfidenceType(§ pars ) != ConfidenceType/DEAD))
            (§ block
                (§ expr log.warn(§ pars "Have overridingTransaction but not OVERRIDDEN for tx {}", tx.getHashAsString(§ pars )))
                (§ return nil)
            )
            (§ var #_"Transaction" (§ name overridingTransaction) (§ expr txMap.get(§ pars confidenceProto.getOverridingTransaction(§ pars ))))
            (§ if (§ expr overridingTransaction == nil))
            (§ block
                (§ expr log.warn(§ pars "Have overridingTransaction that is not in wallet for tx {}", tx.getHashAsString(§ pars )))
                (§ return nil)
            )
            (§ expr confidence.setOverridingTransaction(§ pars overridingTransaction))
        )

        (§ for (§ var #_"Protos.PeerAddress" (§ name proto)) :for (§ expr confidenceProto.getBroadcastByList(§ pars )))
        (§ block
            (§ var #_"InetAddress" (§ name ip))
            (§ try )
            (§ block
                (§ ass (§ name ip) (§ expr InetAddress/getByAddress(§ pars proto.getIpAddress(§ pars ).toByteArray(§ pars ))))
            )
            (§ catch #_"UnknownHostException" (§ name e))
            (§ block
                (§ throw (§ new #_"UnreadableWalletException" (§ pars "Peer IP address does not have the right length", e)))
            )

            (§ var #_"int" (§ name port) (§ expr proto.getPort(§ pars )))
            (§ var #_"int" (§ name protocolVersion) (§ expr params.getProtocolVersionNum(§ pars NetworkParameters/ProtocolVersion/CURRENT)))
            (§ var #_"BigInteger" (§ name services) (§ expr BigInteger/valueOf(§ pars proto.getServices(§ pars ))))
            (§ var #_"PeerAddress" (§ name address) (§ new #_"PeerAddress" (§ pars params, ip, port, protocolVersion, services)))
            (§ expr confidence.markBroadcastBy(§ pars address))
        )

        (§ if (§ expr confidenceProto.hasLastBroadcastedAt(§ pars )))
        (§ block
            (§ expr confidence.setLastBroadcastedAt(§ pars (§ new #_"Date" (§ pars confidenceProto.getLastBroadcastedAt(§ pars )))))
        )

        (§ switch (§ expr confidenceProto.getSource(§ pars )))
        (§ block
            (§ case SOURCE_SELF)
            (§ block
                (§ expr confidence.setSource(§ pars TransactionConfidence/Source/SELF))
                (§ break )
            )
            (§ case SOURCE_NETWORK)
            (§ block
                (§ expr confidence.setSource(§ pars TransactionConfidence/Source/NETWORK))
                (§ break )
            )
            (§ case SOURCE_UNKNOWN)
            (§ block
                ;; Fall through.
            )
            (§ default )
            (§ block
                (§ expr confidence.setSource(§ pars TransactionConfidence/Source/UNKNOWN))
                (§ break )
            )
        )
        (§ void nil)
    )

    ;;;
     ; Cheap test to see if input stream is a wallet.  This checks for a magic value at the beginning of the stream.
     ;
     ; @param is Input stream to test.
     ; @return true if input stream is a wallet.
     ;;
    #_public
    #_static
    (§ method #_"boolean" (§ fn isWallet) [#_"InputStream" (§ name is)])
    (§ block
        (§ try )
        (§ block
            #_final
            (§ var #_"CodedInputStream" (§ name cis) (§ expr CodedInputStream/newInstance(§ pars is)))
            #_final
            (§ var #_"int" (§ name tag) (§ expr cis.readTag(§ pars )))
            #_final
            (§ var #_"int" (§ name field) (§ expr WireFormat/getTagFieldNumber(§ pars tag)))
            (§ if (§ expr field != 1)) ;; network_identifier
            (§ block
                (§ return false)
            )

            #_final
            (§ var #_"String" (§ name network) (§ expr cis.readString(§ pars )))
            (§ return (§ expr NetworkParameters/fromID(§ pars network) != nil))
        )
        (§ catch #_"IOException" (§ name _))
        (§ block
            (§ return false)
        )
    )
)

#_(ns org.bitcoinj.wallet #_"WalletTransaction"
    (:import [com.google.common.base Preconditions])
   (:require [org.bitcoinj.core Transaction]))

;;;
 ; Stores data about a transaction that is only relevant to the {@link org.bitcoinj.wallet.Wallet} class.
 ;;
#_public
(§ class #_"WalletTransaction"
    #_public
    (§ enum #_"Pool"
        (§ item UNSPENT) ;; unspent in best chain
        (§ item SPENT) ;; spent in best chain
        (§ item DEAD) ;; double-spend in alt chain
        (§ item PENDING) ;; a pending tx we would like to go into the best chain
    )
    #_private
    #_final
    (§ field #_"Transaction" (§ name transaction))
    #_private
    #_final
    (§ field #_"Pool" (§ name pool))

    #_public
    (§ constructor #_"WalletTransaction" [#_"Pool" (§ name pool), #_"Transaction" (§ name transaction)])
    (§ block
        (§ ass (§ name this.pool) (§ expr Preconditions/checkNotNull(§ pars pool)))
        (§ ass (§ name this.transaction) transaction)
        (§ void this)
    )

    #_public
    (§ method #_"Transaction" (§ fn getTransaction) [])
    (§ block
        (§ return transaction)
    )

    #_public
    (§ method #_"Pool" (§ fn getPool) [])
    (§ block
        (§ return pool)
    )
)

#_(ns org.bitcoinj.wallet.listeners #_"KeyChainEventListener"
    (:import [java.util List])
   (:require [org.bitcoinj.core ECKey]
             [org.bitcoinj.wallet KeyChain]))

#_public
(§ interface #_"KeyChainEventListener"
    ;;;
     ; Called whenever a new key is added to the key chain, whether that be via an explicit addition or due to some
     ; other automatic derivation.  See the documentation for your {@link KeyChain} implementation for details on
     ; what can trigger this event.
     ;;
    (§ method #_"void" (§ fn onKeysAdded) [#_"List<ECKey>" (§ name keys)])
)

#_(ns org.bitcoinj.wallet.listeners #_"WalletChangeEventListener"
   (:require [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when the contents of the wallet changes, for instance due to receiving/sending money
 ; or a block chain re-organize.</p>
 ;;
#_public
(§ interface #_"WalletChangeEventListener"
    ;;;
     ; <p>Designed for GUI applications to refresh their transaction lists.  This callback is invoked in the following
     ; situations:</p>
     ;
     ; <ol>
     ;     <li>A new block is received (and thus building transactions got more confidence).</li>
     ;     <li>A pending transaction is received.</li>
     ;     <li>A pending transaction changes confidence due to some non-new-block related event,
     ;     such as being announced by more peers or by  a double-spend conflict being observed.</li>
     ;     <li>A re-organize occurs. Call occurs only if the re-org modified any of our transactions.</li>
     ;     <li>A new spend is committed to the wallet.</li>
     ;     <li>The wallet is reset and all transactions removed.<li>
     ; </ol>
     ;
     ; <p>When this is called you can refresh the UI contents from the wallet contents.  It's more efficient to use
     ; this rather than onTransactionConfidenceChanged() + onReorganize() because you only get one callback per block
     ; rather than one per transaction per block.  Note that this is <b>not</b> called when a key is added.</p>
     ;;
    (§ method #_"void" (§ fn onWalletChanged) [#_"Wallet" (§ name wallet)])
)

#_(ns org.bitcoinj.wallet.listeners #_"WalletCoinsReceivedEventListener"
   (:require [org.bitcoinj.core Coin Transaction]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when the contents of the wallet changes, for instance due to receiving/sending money
 ; or a block chain re-organize.</p>
 ;;
#_public
(§ interface #_"WalletCoinsReceivedEventListener"
    ;;;
     ; This is called when a transaction is seen that sends coins <b>to</b> this wallet, either because it was
     ; broadcast across the network or because a block was received.  If a transaction is seen when it was broadcast,
     ; onCoinsReceived won't be called again when a block containing it is received.  If you want to know when such
     ; a transaction receives its first confirmation, register a {@link TransactionConfidence} event listener using
     ; the object retrieved via {@link org.bitcoinj.core.Transaction#getConfidence()}.  It's safe to modify the
     ; wallet in this callback, for example, by spending the transaction just received.
     ;
     ; @param wallet The wallet object that received the coins.
     ; @param tx The transaction which sent us the coins.
     ; @param prevBalance Balance before the coins were received.
     ; @param newBalance This is the 'estimated' balance.
     ;;
    (§ method #_"void" (§ fn onCoinsReceived) [#_"Wallet" (§ name wallet), #_"Transaction" (§ name tx), #_"Coin" (§ name prevBalance), #_"Coin" (§ name newBalance)])
)

#_(ns org.bitcoinj.wallet.listeners #_"WalletCoinsSentEventListener"
   (:require [org.bitcoinj.core Coin Transaction]
             [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when the contents of the wallet changes, for instance due to receiving/sending money
 ; or a block chain re-organize.</p>
 ;;
#_public
(§ interface #_"WalletCoinsSentEventListener"
    ;;;
     ; This is called when a transaction is seen that sends coins <b>from</b> this wallet, either because it
     ; was broadcast across the network or because a block was received.  This may at first glance seem useless,
     ; because in the common case you already know about such transactions because you created them with the
     ; Wallets createSend/sendCoins methods.  However when you have a wallet containing only keys, and you wish
     ; to replay the block chain to fill it with transactions, it's useful to find out when a transaction is
     ; discovered that sends coins from the wallet.
     ;
     ; It's safe to modify the wallet from inside this callback, but if you're replaying the block chain you should
     ; be careful to avoid such modifications.  Otherwise your changes may be overridden by new data from the chain.
     ;
     ; @param wallet The wallet object that this callback relates to (that sent the coins).
     ; @param tx The transaction that sent the coins to someone else.
     ; @param prevBalance The wallets balance before this transaction was seen.
     ; @param newBalance The wallets balance after this transaction was seen.  This is the 'estimated' balance.
     ;;
    (§ method #_"void" (§ fn onCoinsSent) [#_"Wallet" (§ name wallet), #_"Transaction" (§ name tx), #_"Coin" (§ name prevBalance), #_"Coin" (§ name newBalance)])
)

#_(ns org.bitcoinj.wallet.listeners #_"WalletReorganizeEventListener"
   (:require [org.bitcoinj.wallet Wallet]))

;;;
 ; <p>Implementors are called when the wallet is reorganized.</p>
 ;;
#_public
(§ interface #_"WalletReorganizeEventListener"
    ;; TODO: Finish onReorganize to be more useful.
    ;;;
     ; <p>This is called when a block is received that triggers a block chain re-organization.</p>
     ;
     ; <p>A re-organize means that the consensus (chain) of the network has diverged and now changed from
     ; what we believed it was previously.  Usually this won't matter because the new consensus will include
     ; all our old transactions assuming we are playing by the rules.  However it's theoretically possible
     ; for our balance to change in arbitrary ways, most likely, we could lose some money we thought we had.</p>
     ;
     ; <p>It is safe to use methods of wallet whilst inside this callback.</p>
     ;;
    (§ method #_"void" (§ fn onReorganize) [#_"Wallet" (§ name wallet)])
)
