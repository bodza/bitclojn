(ns bitclojn.slang
    (:refer-clojure :exclude [ensure subvec sync vec vector vector-of when when-not])
    (:require [clojure.core rrb-vector]))

(defmacro ยง [& _])
(defmacro ร [& _])

(defmacro def-
    ([s] `(def ~(vary-meta s assoc :private true)))
    ([s i] `(def ~(vary-meta s assoc :private true) ~i)))

(defmacro any
    ([f x y] `(~f ~x ~y))
    ([f x y & z] `(let [f# ~f x# ~x _# (any f# x# ~y)] (if _# _# (any f# x# ~@z)))))
(defn =?
    ([x y] (if (sequential? x) (if (seq x) (or (=? (first x) y) (recur (rest x) y)) false) (if (sequential? y) (recur y x) (= x y))))
    ([x y & z] (=? x (cons y z))))

(letfn [(w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))]
    (defmacro     when       [y & w] (let [[_ & w] (w' w)]            `(if     ~y (do ~@w) ~_)))
    (defmacro     when-not   [y & w] (let [[_ & w] (w' w)]            `(if-not ~y (do ~@w) ~_)))
    (defmacro let-when     [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if     ~y (do ~@w) ~_))))
    (defmacro let-when-not [x y & w] (let [[_ & w] (w' w)] `(let [~@x] (if-not ~y (do ~@w) ~_)))))

(letfn [(z' [z] (cond (vector? z) `((recur ~@z)) (some? z) `((recur ~z))))
        (w' [w] (if (= '=> (first w)) (rest w) (cons nil w)))
        (l' [x y z w] (let [x (cond (vector? x) x (symbol? x) [x x] :else [`_# x]) z (z' z) [_ & w] (w' w)] `(loop [~@x] (if ~y (do ~@w ~@z) ~_))))]
    (defmacro loop-when [x y & w] (l' x y nil w))
    (defmacro loop-when-recur [x y z & w] (l' x y z w)))

(letfn [(z' [z] (cond (vector? z) `(recur ~@z) (some? z) `(recur ~z)))
        (w' [w] (if (= '=> (first w)) (second w)))]
    (defmacro recur-if [y z & w] (let [z (z' z) _ (w' w)] `(if ~y ~z ~_))))

(doseq [v '(catvec subvec vec vector vector-of)] (intern *ns* v (find-var (symbol "clojure.core.rrb-vector" (name v)))))

(letfn [(e' [v] (or (empty v) (vector)))]
    (defn append* [m k & a]                            (update m k #(apply conj (or % (vector)) a)))
    (defn update* [m k f & a] (let [f' #(apply f % a)] (update m k #(into (e' %) (map f' %)))))
    (defn remove* [m k f & a] (let [f' #(apply f % a)] (update m k #(into (e' %) (remove f' %))))))

(defmacro assert-argument [a & m]
    (when *assert* `(when-not ~a (throw (IllegalArgumentException. ~(if (seq m) `(pr-str ~@m) `(pr-str '~a)))))))
(defmacro assert-state [a & m]
    (when *assert* `(when-not ~a (throw (IllegalStateException. ~(if (seq m) `(pr-str ~@m) `(pr-str '~a)))))))
(defmacro ensure [f a & m]
    (if *assert* `(if-not (~f ~a) (throw (RuntimeException. ~(if (seq m) `(pr-str ~@m) `(pr-str '(~f ~a))))) ~a) a))

(def & bit-and)
(def | bit-or)
(def << bit-shift-left)
(def >> bit-shift-right)
(def >>> unsigned-bit-shift-right)

(defmacro cast' [_ x] (ensure symbol? _) `(do ~x))

(defmacro class-ns [name & _] (ensure symbol? name) `(do ~@_))

(defmacro sync [lock & _] `(do (ensure some? ~lock) ~@_))

(class-ns RuntimeException
    (defn #_"RuntimeException" RuntimeException'new
        ([] (RuntimeException'new nil))
        ([#_"String" message]
            (hash-map
                #_"String" :message message
            )
        )
    )
)

(class-ns IllegalArgumentException (ยง extends RuntimeException)
    (defn #_"IllegalArgumentException" IllegalArgumentException'new [#_"String" message]
        (RuntimeException'new message)
    )
)

(ns bitclojn.core
    (:refer-clojure :exclude [ensure subvec sync vec vector vector-of when when-not])
    (:import [com.google.common.base Stopwatch Throwables]
             [com.google.common.collect ArrayListMultimap ImmutableList ImmutableSet]
             [com.google.common.hash HashCode Hasher Hashing]
             [com.google.common.io BaseEncoding]
             [com.google.common.math LongMath]
             [com.google.common.primitives UnsignedBytes]
             [com.google.common.util.concurrent AbstractExecutionThreadService AbstractIdleService FutureCallback Futures ListenableFuture ListeningExecutorService MoreExecutors Runnables Service SettableFuture Uninterruptibles]
           #_[com.google.protobuf ByteString]
             [java.io ByteArrayInputStream ByteArrayOutputStream File IOException RandomAccessFile]
             [java.lang.ref ReferenceQueue WeakReference]
             [java.math BigDecimal BigInteger RoundingMode]
             [java.net ConnectException Inet6Address InetAddress InetSocketAddress NoRouteToHostException Socket SocketAddress UnknownHostException]
             [java.nio BufferUnderflowException ByteBuffer ByteOrder]
             [java.nio.channels CancelledKeyException ClosedChannelException FileChannel FileChannel$MapMode NotYetConnectedException SelectionKey ServerSocketChannel SocketChannel]
             [java.nio.channels.spi SelectorProvider]
             [java.nio.charset Charset]
             [java.security MessageDigest NoSuchAlgorithmException SecureRandom SignatureException]
             [java.text DateFormat SimpleDateFormat]
             [java.util ArrayList Arrays Collection Collections Comparator Date HashMap HashSet Iterator LinkedHashMap LinkedList List ListIterator Locale Map Objects PriorityQueue Random Set Timer TimerTask TimeZone TreeMap TreeSet]
             [java.util.concurrent CountDownLatch ExecutionException Executor Executors FutureTask LinkedBlockingQueue RejectedExecutionException ScheduledThreadPoolExecutor ThreadFactory TimeUnit]
             [java.util.concurrent.atomic AtomicInteger]
             [java.util.function Function]
             [javax.crypto Mac]
             [javax.crypto.spec SecretKeySpec]
             [org.spongycastle.asn1 ASN1InputStream ASN1Integer DERSequenceGenerator DLSequence]
             [org.spongycastle.asn1.x9 X9ECParameters X9IntegerConverter]
             [org.spongycastle.crypto AsymmetricCipherKeyPair]
             [org.spongycastle.crypto.digests RIPEMD160Digest SHA256Digest SHA512Digest]
             [org.spongycastle.crypto.ec CustomNamedCurves]
             [org.spongycastle.crypto.generators ECKeyPairGenerator]
             [org.spongycastle.crypto.macs HMac]
             [org.spongycastle.crypto.params ECDomainParameters ECKeyGenerationParameters ECPrivateKeyParameters ECPublicKeyParameters KeyParameter]
             [org.spongycastle.crypto.signers ECDSASigner HMacDSAKCalculator]
             [org.spongycastle.math.ec ECAlgorithms ECCurve ECFieldElement ECPoint FixedPointCombMultiplier FixedPointUtil]
             [org.spongycastle.math.ec.custom.sec SecP256K1Curve]
             [org.spongycastle.util.encoders Base64]
    )
    (:require [clojure set]
              [clojure.tools.logging :as log]
              [flatland.ordered #_map set])
    (:use [slingshot slingshot]
          [bitclojn slang])
)

(declare AbstractExecutionThreadService'''executor AbstractExecutionThreadService'''triggerShutdown)
(declare AbstractIdleService'''shutDown AbstractIdleService'''startUp)
(declare AbstractTimeoutHandler'''timeout-occurred AbstractTimeoutHandler''reset-timeout AbstractTimeoutHandler''set-socket-timeout AbstractTimeoutHandler''set-timeout-enabled AbstractTimeoutHandler'TIMEOUT_TIMER AbstractTimeoutHandler'new)
(declare Address''is-p2sh-address Address'LENGTH Address'from-base58 Address'from-p2sh-script Address'init Address'is-acceptable-version Address'from-hash160)
(declare AddressFormatException'new)
(declare AddressMessage''add-address AddressMessage''remove-address AddressMessage'MAX_ADDRESSES AddressMessage'from-wire AddressMessage''to-wire)
(declare BackoffParams'new)
(declare BalanceFutureRequest'new)
(declare BalanceType'enum-set)
(declare Base58'ALPHABET Base58'ENCODED_ZERO Base58'INDEXES Base58'decode Base58'decode-checked Base58'decode-to-big-integer Base58'divmod Base58'encode)
(declare BasicKeyChain''find-key-from-pub-hash BasicKeyChain''find-key-from-pub-key BasicKeyChain''get-keys BasicKeyChain''import-key BasicKeyChain''import-key-locked BasicKeyChain''import-keys BasicKeyChain''is-watching BasicKeyChain''queue-on-keys-added BasicKeyChain'new)
(declare BitcoinPacketHeader'HEADER_LENGTH BitcoinPacketHeader'new)
(declare Wire'deserialize Wire'deserialize-payload Wire'make-message Wire'seek-past-magic-bytes Wire'serialize-3 Wire'serialize-4 Wire'COMMAND_LEN)
(declare Block''add-transaction Block''build-merkle-tree Block''calculate-hash Block''calculate-merkle-root Block''check-proof-of-work Block''check-sig-ops Block''check-timestamp Block''check-transactions Block''clone-as-header Block''get-block-inflation Block''get-difficulty-target-as-integer Block''get-hash Block''get-hash-as-base16 Block''get-work Block''is-bip34 Block''is-bip65 Block''is-bip66 Block''solve Block''verify Block''verify-header Block''verify-transactions Block''write-header Block''write-transactions Block'ALLOWED_TIME_DRIFT Block'BLOCK_HEIGHT_GENESIS Block'BLOCK_HEIGHT_UNKNOWN Block'BLOCK_VERSION_BIP34 Block'BLOCK_VERSION_BIP65 Block'BLOCK_VERSION_BIP66 Block'BLOCK_VERSION_GENESIS Block'EASIEST_DIFFICULTY_TARGET Block'HEADER_SIZE Block'LARGEST_HASH Block'MAX_BLOCK_SIGOPS Block'MAX_BLOCK_SIZE Block'init Block'new-genesis Block'from-wire Block''to-wire Block'new)
(declare BlockChain'''add-filtered-block BlockChain'''add-to-block-store-3 BlockChain'''add-to-block-store-4 BlockChain'''connect-transactions-2 BlockChain'''connect-transactions-3 BlockChain'''disconnect-transactions BlockChain'''do-set-chain-head BlockChain'''get-stored-block-in-current-scope BlockChain'''not-setting-chain-head BlockChain'''rollback-block-store BlockChain'''should-verify-transactions BlockChain''add-5 BlockChain''add-block BlockChain''add-new-best-block-listener BlockChain''add-reorganize-listener BlockChain''add-transaction-received-listener BlockChain''add-wallet BlockChain''connect-block BlockChain''drain-orphan-blocks BlockChain''estimate-block-time BlockChain''get-best-chain-height BlockChain''get-chain-head BlockChain''get-orphan-root BlockChain''handle-new-best-chain BlockChain''inform-listeners-for-new-block BlockChain''is-orphan BlockChain''remove-new-best-block-listener BlockChain''remove-reorganize-listener BlockChain''remove-transaction-received-listener BlockChain''remove-wallet BlockChain''reset-false-positive-estimate BlockChain''set-chain-head BlockChain''track-false-positives BlockChain''track-filtered-transactions BlockChain''try-connecting-orphans BlockChain'FP_ESTIMATOR_ALPHA BlockChain'FP_ESTIMATOR_BETA BlockChain'find-split BlockChain'get-median-timestamp-of-recent-blocks BlockChain'get-partial-chain BlockChain'inform-listener-for-new-transactions BlockChain'new BlockChain'send-transactions-to-listener)
(declare BlockStore'''close BlockStore'''get BlockStore'''get-chain-head BlockStore'''put BlockStore'''set-chain-head)
(declare BlockStoreException'new)
(declare BlockVerifyFlag'enum-set)
(declare BlocksDownloadedEventListener'''on-blocks-downloaded)
(declare BloomFilter''apply-and-update-b BloomFilter''apply-and-update-t BloomFilter''contains BloomFilter''get-false-positive-rate BloomFilter''get-update-flag BloomFilter''insert-data BloomFilter''insert-key BloomFilter''matches-all BloomFilter''merge BloomFilter''set-match-all BloomFilter'MAX_FILTER_SIZE BloomFilter'MAX_HASH_FUNCS BloomFilter'init BloomFilter'murmur-hash3 BloomFilter'from-wire BloomFilter''to-wire BloomFilter'new)
(declare BloomUpdate'enum-map BloomUpdate'for-code)
(declare ChainDownloadStartedEventListener'''on-chain-download-started)
(declare ChainFileLockedException'new)
(declare CheckpointManager''get-checkpoint-before CheckpointManager''read-textual CheckpointManager'BASE64 CheckpointManager'checkpoint CheckpointManager'new)
(declare ChildNumber''i ChildNumber''is-hardened ChildNumber''num ChildNumber'HARDENED_BIT ChildNumber'ONE ChildNumber'ZERO ChildNumber'ZERO_HARDENED ChildNumber'has-hardened-bit ChildNumber'new ChildNumber'compose)
(declare ClientConnectionManager'''close-connections ClientConnectionManager'''get-connected-client-count ClientConnectionManager'''open-connection)
(declare Coin''signum Coin''add Coin''remainder Coin''divide Coin''greater-than? Coin''less-than? Coin''negative? Coin''positive? Coin''zero? Coin''multiply Coin''negate Coin''shift-left Coin''shift-right Coin''subtract Coin''to-friendly-string Coin''to-plain-string Coin'CENT Coin'COIN Coin'COIN_VALUE Coin'FIFTY_COINS Coin'FRIENDLY_FORMAT Coin'MICROCOIN Coin'MILLICOIN Coin'NEGATIVE_SATOSHI Coin'PLAIN_FORMAT Coin'SATOSHI Coin'SMALLEST_UNIT_EXPONENT Coin'ZERO Coin'new Coin'parse-coin Coin'parse-coin-inexact Coin'value-of)
(declare CoinSelection'new)
(declare CoinSelector'''select)
(declare CompletionException'new)
(declare ConfidenceChange'new)
(declare ConfidenceChangeReason'enum-set)
(declare ConfidenceSource'enum-set)
(declare ConfidenceType'enum-set)
(declare ConnectionHandler''connection-closed ConnectionHandler''set-write-ops ConnectionHandler''try-write-bytes ConnectionHandler'BUFFER_SIZE_LOWER_BOUND ConnectionHandler'BUFFER_SIZE_UPPER_BOUND ConnectionHandler'OUTBOUND_BUFFER_BYTE_COUNT ConnectionHandler'handle-key ConnectionHandler'new-2c ConnectionHandler'new-2f ConnectionHandler'new-3)
(declare ConnectionMode'enum-set)
(declare ConnectionResult'enum-set)
(declare CouldNotAdjustDownwards'new)
(declare CustomTransactionSigner'''get-signature CustomTransactionSigner'new)
(declare DaemonThreadFactory'new)
(declare DefaultCoinSelector''should-select DefaultCoinSelector'is-selectable DefaultCoinSelector'new DefaultCoinSelector'sort-outputs)
(declare DeterministicHierarchy''derive-child-3 DeterministicHierarchy''derive-child-5 DeterministicHierarchy''derive-next-child DeterministicHierarchy''get-4 DeterministicHierarchy''get-next-child-number-to-derive DeterministicHierarchy''get-num-children DeterministicHierarchy''get-root-key DeterministicHierarchy''put-key DeterministicHierarchy'BIP32_STANDARDISATION_TIME_SECS DeterministicHierarchy'new)
(declare DeterministicKey''derive DeterministicKey''derive-private-key-downwards DeterministicKey''drop-parent DeterministicKey''drop-private-bytes DeterministicKey''find-or-derive-private-key DeterministicKey''find-parent-with-priv-key DeterministicKey''get-child-number DeterministicKey''get-fingerprint DeterministicKey''get-identifier DeterministicKey''get-path-as-string DeterministicKey''get-priv-key-bytes33 DeterministicKey''serialize DeterministicKey''serialize-priv-base58 DeterministicKey''serialize-private DeterministicKey''serialize-pub-base58 DeterministicKey''serialize-public DeterministicKey'compare-by-child-number DeterministicKey'add-checksum DeterministicKey'ascertain-parent-fingerprint DeterministicKey'deserialize DeterministicKey'deserialize-base58-2 DeterministicKey'deserialize-base58-3 DeterministicKey'init DeterministicKey'new-4 DeterministicKey'new-5 DeterministicKey'new-6p DeterministicKey'new-6i DeterministicKey'to-base58 DeterministicKey''set-creation-time-seconds)
(declare DeterministicKeyChain'''find-redeem-data-by-script-hash DeterministicKeyChain'''format-addresses DeterministicKeyChain'''fresh-output-script DeterministicKeyChain'''get-redeem-data DeterministicKeyChain'''is-married DeterministicKeyChain'''maybe-look-ahead-scripts DeterministicKeyChain'''set-lookahead-size DeterministicKeyChain''calc-default-lookahead-threshold DeterministicKeyChain''check-for-bit-flip DeterministicKeyChain''find-key-from-pub-hash DeterministicKeyChain''find-key-from-pub-key DeterministicKeyChain''get-issued-receive-keys DeterministicKeyChain''get-key-by-path-2 DeterministicKeyChain''get-key-by-path-3 DeterministicKeyChain''get-keys-3b DeterministicKeyChain''get-leaf-keys DeterministicKeyChain''get-lookahead-threshold DeterministicKeyChain''get-mnemonic-code DeterministicKeyChain''get-seed DeterministicKeyChain''get-watching-key DeterministicKeyChain''initialize-hierarchy DeterministicKeyChain''is-watching DeterministicKeyChain''mark-key-as-used DeterministicKeyChain''mark-pub-hash-as-used DeterministicKeyChain''mark-pub-key-as-used DeterministicKeyChain''maybe-look-ahead-1 DeterministicKeyChain''maybe-look-ahead-3 DeterministicKeyChain''maybe-look-ahead-5 DeterministicKeyChain''num-leaf-keys-issued DeterministicKeyChain''set-lookahead-threshold DeterministicKeyChain''to-string DeterministicKeyChain'ACCOUNT_ZERO_PATH DeterministicKeyChain'BIP44_ACCOUNT_ZERO_PATH DeterministicKeyChain'DEFAULT_PASSPHRASE_FOR_MNEMONIC DeterministicKeyChain'EXTERNAL_PATH DeterministicKeyChain'EXTERNAL_SUBPATH DeterministicKeyChain'INTERNAL_PATH DeterministicKeyChain'INTERNAL_SUBPATH DeterministicKeyChain'init DeterministicKeyChain'from-seed DeterministicKeyChain'from-entropy DeterministicKeyChain'from-random DeterministicKeyChain'watch DeterministicKeyChain'watch-and-follow)
(declare DeterministicSeed''to-base16 DeterministicSeed'DEFAULT_SEED_ENTROPY_BITS DeterministicSeed'MAX_SEED_ENTROPY_BITS DeterministicSeed'next-entropy DeterministicSeed'from-entropy DeterministicSeed'from-random DeterministicSeed'new)
(declare DnsDiscovery'new)
(declare DnsSeedDiscovery'new)
(declare DownloadProgressTracker''await DownloadProgressTracker''done-download DownloadProgressTracker''progress DownloadProgressTracker''start-download DownloadProgressTracker'new)
(declare DustySendRequested'new)
(declare ECDSASignature'''to-canonicalised ECDSASignature''der-byte-stream ECDSASignature''encode-to-der ECDSASignature''is-canonical ECDSASignature'decode-from-der ECDSASignature'new)
(declare ECKey'''format-key-with-address ECKey'''get-creation-time-seconds ECKey'''get-priv-key ECKey'''has-priv-key ECKey'''is-pub-key-only ECKey''set-creation-time-seconds ECKey'''sign ECKey''decompress ECKey''do-sign ECKey''get-priv-key-bytes ECKey''get-pub-key ECKey''calculate-pub-key-hash160 ECKey''is-compressed ECKey''is-watching ECKey''sign-message ECKey''to-address ECKey''to-string ECKey''verify-3s ECKey''verify-message ECKey'CURVE ECKey'CURVE_PARAMS ECKey'HALF_CURVE_ORDER ECKey'compare-by-pub-key ECKey'SECURE_RANDOM ECKey'compress-point ECKey'decompress-key ECKey'decompress-point ECKey'from-private ECKey'from-private-bytes ECKey'from-private-and-precalculated-public ECKey'from-private-and-precalculated-public-bytes ECKey'from-public-only ECKey'from-public-only-bytes ECKey'get-point-with-compression ECKey'init ECKey'is-pub-key-canonical ECKey'new ECKey'from-random ECKey'compose ECKey'public-key-from-private ECKey'public-point-from-private ECKey'recover-from-signature ECKey'signed-message-to-key ECKey'verify-3e)
(declare ExceededMaxTransactionSize'new)
(declare ExchangeRate''coin-to-fiat ExchangeRate''fiat-to-coin ExchangeRate'new)
(declare ExponentialBackoff''track-failure ExponentialBackoff''track-success ExponentialBackoff'new ExponentialBackoff'compare)
(declare FeeCalculation'new)
(declare Fiat''signum Fiat''add Fiat''remainder Fiat''divide Fiat''greater-than? Fiat''less-than? Fiat''negative? Fiat''positive? Fiat''zero? Fiat''multiply Fiat''negate Fiat''subtract Fiat''to-friendly-string Fiat''to-plain-string Fiat'FRIENDLY_FORMAT Fiat'PLAIN_FORMAT Fiat'SMALLEST_UNIT_EXPONENT Fiat'new Fiat'parse-fiat Fiat'parse-fiat-inexact)
(declare FilterMerger'new FilterMerger''calculate)
(declare FilterRecalculateMode'enum-set)
(declare FilteredBlock''get-block-header FilteredBlock''get-hash FilteredBlock''get-transaction-count FilteredBlock''get-transaction-hashes FilteredBlock''provide-transaction FilteredBlock'from-wire FilteredBlock''to-wire FilteredBlock'new)
(declare FilteringCoinSelector''exclude-outputs-spent-by FilteringCoinSelector'new)
(declare FreeStandingTransactionOutput''get-utxo FreeStandingTransactionOutput'init FreeStandingTransactionOutput'new)
(declare FullPrunedBlockChain''get-script FullPrunedBlockChain''get-script-address FullPrunedBlockChain'new)
(declare FullPrunedBlockStore'''abort-database-batch-write FullPrunedBlockStore'''add-unspent-transaction-output FullPrunedBlockStore'''begin-database-batch-write FullPrunedBlockStore'''commit-database-batch-write FullPrunedBlockStore'''get-once-undoable-stored-block FullPrunedBlockStore'''get-transaction-output FullPrunedBlockStore'''get-undo-block FullPrunedBlockStore'''get-verified-chain-head FullPrunedBlockStore'''has-unspent-outputs FullPrunedBlockStore'''put-3 FullPrunedBlockStore'''remove-unspent-transaction-output FullPrunedBlockStore'''set-verified-chain-head)
(declare FullPrunedVerifier'new)
(declare GetAddrMessage'new GetAddrMessage''to-wire)
(declare GetBlocksMessage'from-wire GetBlocksMessage''to-wire GetBlocksMessage'new)
(declare GetDataEventListener'''get-data)
(declare GetDataMessage''add-block GetDataMessage''add-filtered-block GetDataMessage''add-transaction GetDataMessage''get-hash-of GetDataMessage'new GetDataMessage'from-wire GetDataMessage''to-wire)
(declare GetDataRequest'new)
(declare GetHeadersMessage'from-wire GetHeadersMessage''to-wire GetHeadersMessage'new)
(declare HDDerivationException'new)
(declare HDKeyDerivation'MAX_CHILD_DERIVATION_ATTEMPTS HDKeyDerivation'RAND_INT HDKeyDerivation'assert-less-than-n HDKeyDerivation'assert-non-infinity HDKeyDerivation'assert-non-zero HDKeyDerivation'create-master-priv-key-from-bytes HDKeyDerivation'create-master-private-key HDKeyDerivation'create-master-pub-key-from-bytes HDKeyDerivation'derive-child-key-2c HDKeyDerivation'derive-child-key-2i HDKeyDerivation'derive-child-key-bytes-from-private HDKeyDerivation'derive-child-key-bytes-from-public HDKeyDerivation'derive-this-or-next-child-key)
(declare HDUtils'create-hmac-sha512-digest HDUtils'hmac-sha512-2 HDUtils'hmac-sha512-2-bytes)
(declare HeadersMessage'MAX_HEADERS HeadersMessage'new HeadersMessage'from-wire HeadersMessage''to-wire)
(declare InsufficientMoneyException'new)
(declare InventoryItem'new)
(declare InventoryItemType'enum-map InventoryItemType'for-code)
(declare InventoryMessage''add-block InventoryMessage''add-transaction InventoryMessage'MAX_INV_SIZE InventoryMessage'new InventoryMessage'from-wire InventoryMessage''to-wire)
(declare KeyBag'''find-key-from-pub-hash KeyBag'''find-key-from-pub-key KeyBag'''find-redeem-data-from-script-hash)
(declare BasicKeyChain''add-event-listener DeterministicKeyChain''add-event-listener DeterministicKeyChain''get-earliest-key-creation-time BasicKeyChain''create-bloom-filter DeterministicKeyChain'''create-bloom-filter DeterministicKeyChain''get-key DeterministicKeyChain''get-keys BasicKeyChain''has-key DeterministicKeyChain''has-key DeterministicKeyChain'''count-bloom-filter-elements BasicKeyChain''num-keys DeterministicKeyChain''num-keys BasicKeyChain''remove-event-listener DeterministicKeyChain''remove-event-listener)
(declare KeyChainEventListener'''on-keys-added)
(declare KeyChainGroup''add-and-activate-hd-chain KeyChainGroup''add-event-listener KeyChainGroup''create-and-activate-new-hd-chain KeyChainGroup''current-address KeyChainGroup''current-key KeyChainGroup''fresh-address KeyChainGroup''fresh-key KeyChainGroup''fresh-keys KeyChainGroup''get-active-key-chain KeyChainGroup''create-bloom-filter KeyChainGroup''count-bloom-filter-elements KeyChainGroup''get-combined-key-lookahead-epochs KeyChainGroup''get-earliest-key-creation-time KeyChainGroup''get-lookahead-size KeyChainGroup''get-lookahead-threshold KeyChainGroup''has-key KeyChainGroup''is-married KeyChainGroup''is-watching KeyChainGroup''make-p2sh-output-script KeyChainGroup''mark-p2sh-address-as-used KeyChainGroup''mark-pub-key-as-used KeyChainGroup''mark-pub-key-hash-as-used KeyChainGroup''maybe-lookahead-scripts KeyChainGroup''maybe-mark-current-address-as-used KeyChainGroup''maybe-mark-current-key-as-used KeyChainGroup''num-keys KeyChainGroup''remove-event-listener KeyChainGroup''set-lookahead-size KeyChainGroup''set-lookahead-threshold KeyChainGroup''to-string KeyChainGroup'create-current-keys-map KeyChainGroup'extract-following-keychains KeyChainGroup'watch KeyChainGroup'from-seed KeyChainGroup'new)
(declare KeyChainState'enum-set)
(declare KeyPurpose'enum-set)
(declare KeyTimeCoinSelector''is-confirmed KeyTimeCoinSelector'MAX_SIMULTANEOUS_INPUTS KeyTimeCoinSelector'new)
(declare ListMessage''add-item ListMessage''remove-item ListMessage'MAX_INVENTORY_ITEMS ListMessage'new ListMessage'from-wire ListMessage''to-wire)
(declare LocalTransactionSigner'MINIMUM_VERIFY_FLAGS LocalTransactionSigner'new)
(declare LoopbackCheckState'enum-set)
(declare MainLedger'INSTANCE MainLedger'TEXTUAL_CHECKPOINTS MainLedger'new)
(declare MarriedKeyChain''add-following-account-keys MarriedKeyChain''get-married-keys-with-followed MarriedKeyChain''set-following-key-chains MarriedKeyChain'init MarriedKeyChain'watch MarriedKeyChain'from-seed MarriedKeyChain'from-entropy MarriedKeyChain'from-random)
(declare MemoryBlockStore'new)
(declare MemoryFullPrunedBlockStore'new)
(declare MemoryPoolMessage'new MemoryPoolMessage''to-wire)
(declare Message'MAX_SIZE Message'new Message''to-bytes Wire'read-uint32 Wire'write-uint32 Wire'read-int64 Wire'write-int64 Wire'read-uint64 Wire'write-uint64 Wire'read-var-int Wire'read-byte Wire'read-bytes Wire'read-byte-array Wire'write-byte-array Wire'read-string Wire'write-string Wire'read-hash Wire'write-hash)
(declare MessageWriteTarget'''close-connection MessageWriteTarget'''write-bytes)
(declare MissingPrivateKeyException'new)
(declare MissingSigResolutionSigner'new)
(declare MissingSignatureException'new)
(declare MissingSigsMode'enum-set)
(declare MnemonicChecksumException'new)
(declare MnemonicCode''to-entropy MnemonicCode''to-mnemonic MnemonicCode'BIP39_ENGLISH_SHA256 MnemonicCode'BIP39_ENGLISH_WORDS MnemonicCode'BIP39_STANDARDISATION_TIME_SECS MnemonicCode'INSTANCE MnemonicCode'PBKDF2_ROUNDS MnemonicCode'bytes-to-bits MnemonicCode'new MnemonicCode'to-seed)
(declare MnemonicException'new)
(declare MnemonicLengthException'new)
(declare MnemonicWordException'new)
(declare Monetary'''smallest-unit-exponent)
(declare MonetaryFormat''code-1 MonetaryFormat''code-3 MonetaryFormat''code-separator MonetaryFormat''decimal-mark MonetaryFormat''digits MonetaryFormat''format MonetaryFormat''min-decimals MonetaryFormat''negative-sign MonetaryFormat''no-code MonetaryFormat''optional-decimals MonetaryFormat''parse-coin MonetaryFormat''parse-fiat MonetaryFormat''parse-value MonetaryFormat''positive-sign MonetaryFormat''postfix-code MonetaryFormat''prefix-code MonetaryFormat''repeat-optional-decimals MonetaryFormat''rounding-mode MonetaryFormat''shift MonetaryFormat'BTC MonetaryFormat'CODE_BTC MonetaryFormat'CODE_MBTC MonetaryFormat'CODE_UBTC MonetaryFormat'DECIMALS_PADDING MonetaryFormat'FIAT MonetaryFormat'MAX_DECIMALS MonetaryFormat'MBTC MonetaryFormat'UBTC MonetaryFormat'new)
(declare MultipleOpReturnRequested'new)
(declare MultiplexingDiscovery'''create-executor MultiplexingDiscovery'for-services MultiplexingDiscovery'new)
(declare Ledger'''check-difficulty-transitions Ledger''allow-empty-peer-chain Ledger''get-block-verification-flags Ledger''get-max-money Ledger''get-min-non-dust-output Ledger''get-transaction-verification-flags Ledger''has-max-money Ledger''is-checkpoint Ledger''is-difficulty-transition-point Ledger''is-reward-halving-point Ledger''passes-checkpoint Ledger'BIP16_ENFORCE_TIME Ledger'INTERVAL Ledger'MAX_COINS Ledger'MAX_MONEY Ledger'REWARD_HALVING_INTERVAL Ledger'TARGET_SPACING Ledger'TARGET_TIMESPAN Ledger'create-genesis Ledger'new)
(declare Networks'NETWORKS)
(declare NewBestBlockListener'''notify-new-best-block)
(declare NewBlockType'enum-set)
(declare NioClient'new)
(declare NioClientHandler'new)
(declare NioClientManager''handle-key NioClientManager'new)
(declare NioServer''handle-key NioServer'new)
(declare NotFoundMessage'MIN_PROTOCOL_VERSION NotFoundMessage'new NotFoundMessage'from-wire NotFoundMessage''to-wire)
(declare OrphanBlock'new)
(declare PBKDF2SHA512'f PBKDF2SHA512'derive)
(declare PartialMerkleTree''get-txn-hash-and-merkle-root PartialMerkleTree''recursive-extract-hashes PartialMerkleTree'build-from-leaves PartialMerkleTree'calc-hash PartialMerkleTree'combine-left-right PartialMerkleTree'get-tree-width PartialMerkleTree'from-wire PartialMerkleTree''to-wire PartialMerkleTree'new PartialMerkleTree'traverse-and-build)
(declare Peer''add-blocks-downloaded-event-listener Peer''add-chain-download-started-event-listener Peer''add-connected-event-listener Peer''add-disconnected-event-listener Peer''add-get-data-event-listener Peer''add-on-transaction-broadcast-listener Peer''add-ping-time-data Peer''add-pre-message-received-event-listener Peer''add-wallet Peer''block-chain-download-locked Peer''check-for-filter-exhaustion Peer''download-dependencies Peer''download-dependencies-internal Peer''end-filtered-block Peer''get-addr Peer''get-best-height Peer''get-block Peer''get-last-ping-time Peer''get-peer-block-height-difference Peer''get-peer-mempool-transaction Peer''get-average-ping-time Peer''invoke-on-blocks-downloaded Peer''is-download-tx-dependencies Peer''is-not-found-message-supported Peer''maybe-handle-requested-data Peer''maybe-restart-chain-download Peer''ping-1 Peer''ping-2 Peer''process-address-message Peer''process-block Peer''process-get-data Peer''process-headers Peer''process-inv Peer''process-not-found-message Peer''process-ping Peer''process-pong Peer''process-transaction Peer''process-version-ack Peer''process-version-message Peer''remove-blocks-downloaded-event-listener Peer''remove-chain-download-started-event-listener Peer''remove-connected-event-listener Peer''remove-disconnected-event-listener Peer''remove-get-data-event-listener Peer''remove-on-transaction-broadcast-listener Peer''remove-pre-message-received-event-listener Peer''remove-wallet Peer''send-single-get-data Peer''set-bloom-filter Peer''set-download-parameters Peer''set-download-tx-dependencies-b Peer''set-min-protocol-version Peer''start-block-chain-download Peer''start-filtered-block Peer''version-handshake-complete Peer'PING_MOVING_AVERAGE_WINDOW Peer'RESEND_BLOOM_FILTER_BLOCK_COUNT Peer'new Peer''to-string)
(declare PeerAddress''to-socket-address PeerAddress'new PeerAddress'loopback PeerAddress'from-socket-address PeerAddress'from-inet-port PeerAddress'from-wire PeerAddress''to-wire PeerAddress''to-string)
(declare PeerConnectedEventListener'''on-peer-connected)
(declare PeerDisconnectedEventListener'''on-peer-disconnected)
(declare PeerDiscovery'''get-peers PeerDiscovery'''shutdown)
(declare PeerDiscoveryException'new)
(declare Wallet''lock-bloom-filter-calculation Wallet''bloom-filter-outpoints-locked Wallet''unlock-bloom-filter-calculation Wallet''create-bloom-filter-locked Wallet''get-earliest-key-creation-time)
(declare PeerGroup''add-address-i PeerGroup''add-address-p PeerGroup''add-blocks-downloaded-event-listener PeerGroup''add-chain-download-started-event-listener PeerGroup''add-connected-event-listener PeerGroup''add-disconnected-event-listener PeerGroup''add-discovered-event-listener PeerGroup''add-get-data-event-listener PeerGroup''add-inactive PeerGroup''add-on-transaction-broadcast-listener PeerGroup''add-peer-discovery PeerGroup''add-pre-message-received-event-listener PeerGroup''add-wallet PeerGroup''await-running PeerGroup''await-terminated PeerGroup''broadcast-transaction-3 PeerGroup''connect-to-socket-address PeerGroup''connect-to-peer-address PeerGroup''connect-to-loopback PeerGroup''count-connected-and-pending-peers PeerGroup''create-peer PeerGroup''create-private-executor PeerGroup''discover-peers PeerGroup''download-block-chain PeerGroup''find-peers-of-at-least-version PeerGroup''find-peers-with-service-mask PeerGroup''get-download-peer PeerGroup''get-min-broadcast-connections PeerGroup''handle-get-data PeerGroup''handle-new-peer PeerGroup''handle-peer-death PeerGroup''maybe-check-for-loopback-peer PeerGroup''recalculate-fast-catchup-and-filter PeerGroup''remove-blocks-downloaded-event-listener PeerGroup''remove-chain-download-started-event-listener PeerGroup''remove-connected-event-listener PeerGroup''remove-disconnected-event-listener PeerGroup''remove-discovered-event-listener PeerGroup''remove-get-data-event-listener PeerGroup''remove-on-transaction-broadcast-listener PeerGroup''remove-pre-message-received-event-listener PeerGroup''remove-wallet Peer'select-download-peer PeerGroup''set-bloom-filter-false-positive-rate PeerGroup''set-download-peer PeerGroup''set-fast-catchup-time-secs PeerGroup''set-max-connections PeerGroup''set-ping-interval-msec PeerGroup''set-required-services PeerGroup''set-stall-threshold PeerGroup''setup-pinging PeerGroup''start PeerGroup''start-async PeerGroup''start-block-chain-download PeerGroup''start-block-chain-download-from-peer PeerGroup''stop PeerGroup''stop-async PeerGroup''trigger-connections PeerGroup''update-version-message-relay-txes-before-filter PeerGroup''wait-for-job-queue PeerGroup''wait-for-peers PeerGroup''wait-for-peers-of-version PeerGroup''wait-for-peers-with-service-mask PeerGroup'DEFAULT_BLOOM_FILTER_FP_RATE PeerGroup'DEFAULT_CONNECTIONS PeerGroup'DEFAULT_CONNECT_TIMEOUT_MILLIS PeerGroup'DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS PeerGroup'DEFAULT_PING_INTERVAL_MSEC PeerGroup'MAX_FP_RATE_INCREASE PeerGroup'MIN_PEER_DISCOVERY_INTERVAL PeerGroup'add-data-event-listener-to-peer Peer'max-of-most-freq Peer'most-common-chain-height PeerGroup'new PeerGroup'remove-data-event-listener-from-peer)
(declare PeerListener'new)
(declare Peer''process-message Peer''close Peer''send-message)
(declare PendingConnection'new)
(declare PendingPing''complete PendingPing'new)
(declare Ping'new Ping'from-wire Ping''to-wire)
(declare Pong'new Pong'from-wire Pong''to-wire)
(declare PoolType'enum-set)
(declare PreMessageReceivedEventListener'''on-pre-message-received)
(declare ProposedTransaction'new)
(declare ProtocolException'new)
(declare ProtocolVersion'BLOOM_FILTER ProtocolVersion'CURRENT ProtocolVersion'MINIMUM ProtocolVersion'PONG)
(declare PrunedException'new)
(declare PublicDerivationMode'enum-set)
(declare RawKeyBytes'new)
(declare RedeemData''get-full-key RedeemData'new RedeemData'of)
(declare RejectCode'enum-map RejectCode'for-code)
(declare RejectMessage'from-wire RejectMessage''to-wire RejectMessage'new)
(declare RejectedTransactionException'new)
(declare ReorganizeListener'''reorganize)
(declare RiskAnalysis''analyze RiskAnalysis''analyze-is-final RiskAnalysis''analyze-is-standard RiskAnalysis'MIN_ANALYSIS_NONDUST_OUTPUT RiskAnalysis'is-input-standard RiskAnalysis'is-output-standard RiskAnalysis'is-standard RiskAnalysis'new)
(declare RiskAnalysisResult'enum-set)
(declare RuleViolation'enum-set)
(declare SPVBlockChain'new)
(declare SPVBlockStore''get-ring-cursor SPVBlockStore''init-store SPVBlockStore''set-ring-cursor SPVBlockStore'DEFAULT_CAPACITY SPVBlockStore'FILE_PROLOGUE_BYTES SPVBlockStore'HEADER_MAGIC SPVBlockStore'NOT_FOUND_MARKER SPVBlockStore'RECORD_SIZE SPVBlockStore'get-file-size SPVBlockStore'new)
(declare Script''correctly-spends Script''create-empty-input-script Script''find-key-in-redeem Script''find-sig-in-redeem Script''get-cltv-payment-channel-expiry Script''get-cltv-payment-channel-recipient-pub-key Script''get-cltv-payment-channel-sender-pub-key Script''get-from-address Script''get-number-of-bytes-required-to-spend Script''get-number-of-signatures-required-to-spend Script''to-bytes Script''get-pub-key Script''get-pub-key-hash Script''get-pub-keys Script''get-quick-program Script''get-script-sig-with-signature Script''get-script-type Script''get-sig-insertion-index Script''get-to-address-2 Script''get-to-address-3 Script''is-op-return Script''is-pay-to-script-hash Script''is-sent-to-address Script''is-sent-to-cltv-payment-channel Script''is-sent-to-multi-sig Script''is-sent-to-raw-pub-key Script'parse Script'ALL_VERIFY_FLAGS Script'MAX_OPS_PER_SCRIPT Script'MAX_P2SH_SIGOPS Script'MAX_PUBKEYS_PER_MULTISIG Script'MAX_SCRIPT_ELEMENT_SIZE Script'MAX_SCRIPT_SIZE Script'MAX_STACK_SIZE Script'SIG_SIZE Script'cast-to-big-integer-2 Script'cast-to-big-integer-3 Script'cast-to-bool Script'check-sequence Script'decode-from-op-n Script'encode-to-op-n Script'equals-range Script'execute-check-lock-time-verify Script'execute-check-sequence-verify Script'execute-check-sig Script'execute-multi-sig Script'execute-script-5 Script'get-p2sh-sig-op-count Script'get-sig-op-count-1 Script'get-sig-op-count-2 Script'new Script'remove-all-instances-of Script'remove-all-instances-of-op Script'write-bytes Script''to-string)
(declare ScriptBuilder'new ScriptBuilder''append ScriptBuilder''to-script ScriptBuilder''data ScriptBuilder''num ScriptBuilder''op Script'create-cltv-payment-channel-input-2 Script'create-cltv-payment-channel-input-2-bytes Script'create-cltv-payment-channel-output Script'create-cltv-payment-channel-p2sh-input Script'create-cltv-payment-channel-p2sh-refund Script'create-cltv-payment-channel-refund Script'create-input-script-1 Script'create-input-script-2 Script'create-multi-sig-input-script Script'create-multi-sig-input-script-bytes-1 Script'create-multi-sig-input-script-bytes-2 Script'create-multi-sig-output-script Script'create-op-return-script Script'create-output-script-1a Script'create-output-script-1e Script'create-p2sh-multi-sig-input-script Script'create-p2sh-output-script-1 Script'create-p2sh-output-script-1-bytes Script'create-p2sh-output-script-2 Script'create-redeem-script Script'update-script-with-signature)
(declare ScriptChunk''decode-op-n ScriptChunk''equals-op-code ScriptChunk''is-op-code ScriptChunk''is-push-data ScriptChunk''is-shortest-possible-push-data ScriptChunk''write-chunk ScriptChunk'new)
(declare ScriptError'enum-set)
(declare ScriptException'new)
(declare Script'OP_0 Script'OP_0NOTEQUAL Script'OP_1 Script'OP_10 Script'OP_11 Script'OP_12 Script'OP_13 Script'OP_14 Script'OP_15 Script'OP_16 Script'OP_1ADD Script'OP_1NEGATE Script'OP_1SUB Script'OP_2 Script'OP_2DIV Script'OP_2DROP Script'OP_2DUP Script'OP_2MUL Script'OP_2OVER Script'OP_2ROT Script'OP_2SWAP Script'OP_3 Script'OP_3DUP Script'OP_4 Script'OP_5 Script'OP_6 Script'OP_7 Script'OP_8 Script'OP_9 Script'OP_ABS Script'OP_ADD Script'OP_AND Script'OP_BOOLAND Script'OP_BOOLOR Script'OP_CAT Script'OP_CHECKLOCKTIMEVERIFY Script'OP_CHECKMULTISIG Script'OP_CHECKMULTISIGVERIFY Script'OP_CHECKSEQUENCEVERIFY Script'OP_CHECKSIG Script'OP_CHECKSIGVERIFY Script'OP_CODESEPARATOR Script'OP_CODE_MAP Script'OP_NAME_MAP Script'OP_DEPTH Script'OP_DIV Script'OP_DROP Script'OP_DUP Script'OP_ELSE Script'OP_ENDIF Script'OP_EQUAL Script'OP_EQUALVERIFY Script'OP_FALSE Script'OP_FROMALTSTACK Script'OP_GREATERTHAN Script'OP_GREATERTHANOREQUAL Script'OP_HASH160 Script'OP_HASH256 Script'OP_IF Script'OP_IFDUP Script'OP_INVALIDOPCODE Script'OP_INVERT Script'OP_LEFT Script'OP_LESSTHAN Script'OP_LESSTHANOREQUAL Script'OP_LSHIFT Script'OP_MAX Script'OP_MIN Script'OP_MOD Script'OP_MUL Script'OP_NEGATE Script'OP_NIP Script'OP_NOP Script'OP_NOP1 Script'OP_NOP10 Script'OP_NOP2 Script'OP_NOP3 Script'OP_NOP4 Script'OP_NOP5 Script'OP_NOP6 Script'OP_NOP7 Script'OP_NOP8 Script'OP_NOP9 Script'OP_NOT Script'OP_NOTIF Script'OP_NUMEQUAL Script'OP_NUMEQUALVERIFY Script'OP_NUMNOTEQUAL Script'OP_OR Script'OP_OVER Script'OP_PICK Script'OP_PUSHDATA1 Script'OP_PUSHDATA2 Script'OP_PUSHDATA4 Script'OP_RESERVED Script'OP_RESERVED1 Script'OP_RESERVED2 Script'OP_RETURN Script'OP_RIGHT Script'OP_RIPEMD160 Script'OP_ROLL Script'OP_ROT Script'OP_RSHIFT Script'OP_SHA1 Script'OP_SHA256 Script'OP_SIZE Script'OP_SUB Script'OP_SUBSTR Script'OP_SWAP Script'OP_TOALTSTACK Script'OP_TRUE Script'OP_TUCK Script'OP_VER Script'OP_VERIF Script'OP_VERIFY Script'OP_VERNOTIF Script'OP_WITHIN Script'OP_XOR ScriptOpCodes'get-op-code ScriptOpCodes'get-op-code-name ScriptOpCodes'get-push-data-name)
(declare ScriptType'enum-set)
(declare ScriptVerifyFlag'enum-set)
(declare SeedPeers''all-peers SeedPeers'convert-address SeedPeers''get-peer SeedPeers''next-peer SeedPeers'new)
(declare SendRequest'child-pays-for-parent SendRequest'empty-wallet SendRequest'for-tx SendRequest'new SendRequest'to-address SendRequest'to-pubkey SendRequest'to-cltv-payment-channel-5bi SendRequest'to-cltv-payment-channel-5d SendRequest'to-cltv-payment-channel-5i)
(declare SendResult'new)
(declare Sha256Hash''to-big-integer Sha256Hash'LENGTH Sha256Hash'ZERO_HASH Sha256Hash'create-digest Sha256Hash'hash Sha256Hash'hash-twice Sha256Hash'hash-twins-twice Sha256Hash'of Sha256Hash'twice-of Sha256Hash'wrap-base16 Sha256Hash'wrap Sha256Hash''to-base16)
(declare SigHash'ALL SigHash'ANYONECANPAY SigHash'ANYONECANPAY_ALL SigHash'ANYONECANPAY_NONE SigHash'ANYONECANPAY_SINGLE SigHash'NONE SigHash'SINGLE SigHash'UNSET)
(declare SignatureAndKey'new)
(declare StoredBlock''build StoredBlock''get-prev StoredBlock''more-work-than StoredBlock''serialize-compact StoredBlock'CHAIN_WORK_BYTES StoredBlock'COMPACT_SERIALIZED_SIZE StoredBlock'EMPTY_BYTES StoredBlock'deserialize-compact StoredBlock'new)
(declare StoredBlockAndWasUndoableFlag'new)
(declare StoredTransactionOutPoint'new)
(declare StoredUndoableBlock'init StoredUndoableBlock'from-changes StoredUndoableBlock'from-transactions)
(declare StreamConnection'''connection-closed StreamConnection'''connection-opened StreamConnection'''get-max-message-size StreamConnection'''receive-bytes StreamConnection'''set-write-target)
(declare TestLedger'INSTANCE TestLedger'TESTNET_DIFF_DATE TestLedger'TEXTUAL_CHECKPOINTS TestLedger'new)
(declare ThreadFactory'''newThread)
(declare Threading'SAME_THREAD Threading'THREAD_POOL Threading'USER_THREAD Threading'wait-for-user-code)
(declare Transaction''add-block-appearance Transaction''add-input Transaction''add-input-o Transaction''add-input-s Transaction''add-output-ca Transaction''add-output-ce Transaction''add-output-cs Transaction''add-output Transaction''add-signed-input Transaction''calculate-signature-b Transaction''calculate-signature-s Transaction''check-coin-base-height Transaction''estimate-lock-time Transaction''get-confidence Transaction''get-fee Transaction''get-hash Transaction''get-input-sum Transaction''get-output-sum Transaction''get-sig-op-count Transaction''get-value Transaction''get-value-sent-from-me Transaction''get-value-sent-to-me Transaction''get-wallet-outputs Transaction''has-confidence Transaction''hash-for-signature-4b Transaction''hash-for-signature-5b Transaction''hash-for-signature-5s Transaction''is-any-output-spent Transaction''is-coin-base Transaction''is-every-owned-output-spent Transaction''is-final Transaction''is-mature Transaction''is-opt-in-full-rbf Transaction''is-pending Transaction''is-time-locked Transaction''set-block-appearance Transaction''set-lock-time Transaction''shuffle-outputs Transaction''to-string Transaction''verify Transaction'DEFAULT_TX_FEE Transaction'LOCKTIME_THRESHOLD Transaction'LOCKTIME_THRESHOLD_BIG Transaction'MAX_STANDARD_TX_SIZE Transaction'MIN_NONDUST_OUTPUT Transaction'REFERENCE_DEFAULT_MIN_TX_FEE Transaction'SEQUENCE_LOCKTIME_DISABLE_FLAG Transaction'SEQUENCE_LOCKTIME_MASK Transaction'SEQUENCE_LOCKTIME_TYPE_FLAG Transaction'compare-by-chain-height Transaction'compare-by-update-time Transaction'init Transaction'new Transaction'from-wire Transaction''to-wire)
(declare Wallet''get-transaction-pool Wallet''is-pay-to-script-hash-mine Wallet''is-pub-key-hash-mine Wallet''is-pub-key-mine)
(declare TransactionBroadcast''broadcast TransactionBroadcast''invoke-and-record TransactionBroadcast''invoke-progress-callback TransactionBroadcast''set-progress-callback TransactionBroadcast'RANDOM TransactionBroadcast'new)
(declare TransactionBroadcaster'''broadcast-transaction-2)
(declare TransactionConfidence''add-event-listener TransactionConfidence''clear-broadcast-by TransactionConfidence''get-appeared-at-chain-height TransactionConfidence''get-depth-future TransactionConfidence''get-overriding-transaction TransactionConfidence''mark-broadcast-by TransactionConfidence''queue-listeners TransactionConfidence''remove-event-listener TransactionConfidence''set-appeared-at-chain-height TransactionConfidence''set-confidence-type TransactionConfidence''set-overriding-transaction TransactionConfidence''was-broadcast-by TransactionConfidence'PINNED_CONFIDENCE_OBJECTS TransactionConfidence'new)
(declare TransactionConfidenceListener'''on-confidence-changed)
(declare TransactionInput''clear-script-bytes TransactionInput''connect-3m TransactionInput''connect-3t TransactionInput''connect-output TransactionInput''disconnect TransactionInput''get-connected-output TransactionInput''get-connected-output-2 TransactionInput''get-connected-transaction TransactionInput''get-from-address TransactionInput''get-script-sig TransactionInput''has-sequence TransactionInput''is-coin-base TransactionInput''is-opt-in-full-rbf TransactionInput''is-standard TransactionInput''set-script-bytes TransactionInput''set-script-sig TransactionInput''verify-1 TransactionInput''verify-2 TransactionInput'NO_SEQUENCE TransactionInput'UNCONNECTED TransactionInput'new TransactionInput'new-unconnected TransactionInput'for-output TransactionInput'for-outpoint TransactionInput'from-wire TransactionInput''to-wire)
(declare TransactionOutPoint''get-connected-key TransactionOutPoint''get-connected-output TransactionOutPoint''get-connected-pub-key-script TransactionOutPoint''get-connected-redeem-data TransactionOutPoint'new TransactionOutPoint'for-output TransactionOutPoint'for-hash TransactionOutPoint'for-transaction TransactionOutPoint'from-wire TransactionOutPoint''to-wire)
(declare TransactionOutput''get-index TransactionOutput''get-parent-transaction-depth-in-blocks TransactionOutput''get-parent-transaction-hash TransactionOutput''get-address-from-p2pkh-script TransactionOutput''get-address-from-p2sh TransactionOutput''get-min-non-dust-value-1 TransactionOutput''get-min-non-dust-value-2 TransactionOutput''get-outpoint-for TransactionOutput''parse-script-pub-key TransactionOutput''is-available-for-spending TransactionOutput''is-dust TransactionOutput''is-mine TransactionOutput''mark-as-spent TransactionOutput''mark-as-unspent TransactionOutput''set-value TransactionOutput'new TransactionOutput'for-address TransactionOutput'for-script TransactionOutput'for-pubkey TransactionOutput'from-wire TransactionOutput''to-wire)
(declare TransactionOutputChanges'new)
(declare TransactionPurpose'enum-set)
(declare TransactionReceivedInBlockListener'''notify-transaction-is-in-block TransactionReceivedInBlockListener'''receive-from-block)
(declare TransactionSignature''anyone-can-pay TransactionSignature''encode-to-bitcoin TransactionSignature''sig-hash-mode TransactionSignature'calc-sig-hash-value TransactionSignature'decode-from-bitcoin TransactionSignature'dummy TransactionSignature'init TransactionSignature'is-encoding-canonical TransactionSignature'new TransactionSignature'from-ecdsa)
(declare TransactionSigner'''sign-inputs)
(declare TransactionalHashMap''abort-database-batch-write TransactionalHashMap''begin-database-batch-write TransactionalHashMap''commit-database-batch-write TransactionalHashMap''get TransactionalHashMap''put TransactionalHashMap''remove TransactionalHashMap''values TransactionalHashMap'new)
(declare TransactionalMultiKeyHashMap''abort-transaction TransactionalMultiKeyHashMap''begin-transaction TransactionalMultiKeyHashMap''commit-transaction TransactionalMultiKeyHashMap''get TransactionalMultiKeyHashMap''put TransactionalMultiKeyHashMap''remove-by-multi-key TransactionalMultiKeyHashMap''remove-by-unique-key TransactionalMultiKeyHashMap'new)
(declare TxConfidenceTable''clean-table TxConfidenceTable''get TxConfidenceTable''get-or-create TxConfidenceTable''num-broadcast-peers TxConfidenceTable''seen TxConfidenceTable'MAX_SIZE TxConfidenceTable'new TxConfidenceTable'INSTANCE)
(declare TxOffsetPair'new)
(declare UTXO'new)
(declare UnknownMessage'from-wire)
(declare UserThread'WARNING_THRESHOLD UserThread'new)
(declare Wire'bget-uint16 Wire'bget-uint32 Wire'bget-int64 Wire'bget-uint16be Wire'bget-uint32be Wire'bset-uint32be Wire'bset-uint32 Wire'bset-uint64 Utils'big-integer-to-bytes Wire'reverse-bytes Utils'sha256hash160 Wire'decode-mpi Wire'encode-mpi Utils'decode-compact-bits Utils'encode-compact-bits Time'now Time'seconds Time'UTC Time'format Time'format-seconds Time'sleep Utils'parse-as-hex-or-base58 Utils'BITCOIN_SIGNED_MESSAGE_HEADER Utils'BITCOIN_SIGNED_MESSAGE_HEADER_BYTES Utils'format-message-for-signing Utils'BIT_MASK Utils'check-bit-le Utils'set-bit-le)
(declare ValuesUsed'new)
(declare VarInt''encode VarInt'init VarInt'new VarInt'parse VarInt'from-wire VarInt'size-of)
(declare VerificationException'new)
(declare VersionAck'new VersionAck''to-wire)
(declare VersionMessage''has-block-chain VersionMessage''is-bloom-filtering-supported VersionMessage''is-ping-pong-supported VersionMessage'NODE_NETWORK VersionMessage'init VersionMessage'new VersionMessage'from-wire VersionMessage''to-wire)
(declare VersionTally''add VersionTally''get-count-at-or-above VersionTally'from-store VersionTally'new)
(declare Wallet'DEFAULT_EVENT_HORIZON Wallet''add-and-activate-hd-chain Wallet''add-change-event-listener Wallet''add-coins-received-event-listener Wallet''add-coins-sent-event-listener Wallet''add-key-chain-event-listener Wallet''add-reorganize-event-listener Wallet''add-supplied-inputs Wallet''add-transaction-confidence-event-listener Wallet''add-transaction-signer Wallet''add-transactions-depending-on Wallet''add-wallet-transaction Wallet''adjust-output-downwards-for-fee Wallet''calculate-all-spend-candidates-1 Wallet''calculate-all-spend-candidates-3 Wallet''calculate-fee Wallet''can-sign-for Wallet''check-balance-futures-locked Wallet''check-for-filter-exhaustion Wallet''cleanup Wallet''clear-transactions-1 Wallet''clear-transactions-2 Wallet''commit-tx Wallet''complete-tx Wallet''create-send Wallet''create-transient-state Wallet''current-address Wallet''current-change-address Wallet''current-key Wallet''current-receive-address Wallet''current-receive-key Wallet''do-maintenance Wallet''estimate-bytes-for-signing Wallet''find-double-spends-against Wallet''fresh-address Wallet''fresh-key Wallet''fresh-keys Wallet''fresh-receive-address Wallet''fresh-receive-key Wallet''get-active-key-chain Wallet''get-balance-2s Wallet''get-balance-2t Wallet''get-balance-future Wallet''create-bloom-filter Wallet''get-coin-selector Wallet''get-containing-pools Wallet''get-issued-receive-addresses Wallet''get-issued-receive-keys Wallet''get-key-by-path-2 Wallet''get-key-chain-group-combined-key-lookahead-epochs Wallet''get-key-chain-group-lookahead-size Wallet''get-key-chain-group-lookahead-threshold Wallet''get-key-chain-group-size Wallet''get-key-chain-seed Wallet''get-key-rotation-time Wallet''get-last-block-seen-hash Wallet''get-last-block-seen-time Wallet''get-pending-transactions Wallet''get-recent-transactions Wallet''get-total-received Wallet''get-total-sent Wallet''get-transaction Wallet''get-transaction-signers Wallet''get-transactions Wallet''get-transactions-by-time Wallet''get-unspents Wallet''get-watching-key Wallet''has-key Wallet''inform-confidence-listeners-if-not-reorganizing Wallet''is-consistent Wallet''is-consistent-or-throw Wallet''is-key-rotating Wallet''is-spending-txns-in-confidence-type Wallet''is-pending-transaction-relevant Wallet''is-transaction-relevant Wallet''is-transaction-risky Wallet''is-tx-consistent Wallet''is-tx-output-bloom-filterable Wallet''is-watching Wallet''kill-txns Wallet''mark-keys-as-used Wallet''maybe-commit-tx Wallet''maybe-move-pool Wallet''maybe-queue-on-wallet-changed Wallet''maybe-rotate-keys Wallet''process-tx-from-best-chain Wallet''queue-on-coins-received Wallet''queue-on-coins-sent Wallet''queue-on-reorganize Wallet''queue-on-transaction-confidence-changed Wallet''receive Wallet''receive-pending-3 Wallet''receive-pending-4 Wallet''rekey-one-batch Wallet''remove-change-event-listener Wallet''remove-coins-received-event-listener Wallet''remove-coins-sent-event-listener Wallet''remove-key-chain-event-listener Wallet''remove-reorganize-event-listener Wallet''remove-transaction-confidence-event-listener Wallet''reset Wallet''save Wallet''save-later Wallet''save-now Wallet''send-coins-2 Wallet''send-coins-3b Wallet''send-coins-3p Wallet''send-coins-4 Wallet''send-coins-offline Wallet''set-coin-selector Wallet''set-key-chain-group-lookahead-size Wallet''set-key-chain-group-lookahead-threshold Wallet''set-key-rotation-time-d Wallet''set-key-rotation-time-l Wallet''set-transaction-broadcaster Wallet''sign-transaction Wallet''sort-txns-by-dependency Wallet''spends Wallet''subtract-depth Wallet''to-string Wallet''to-string-helper Wallet''update-for-spends Wallet'from-seed Wallet'from-watching-key Wallet'from-watching-key-base58 Wallet'new)
(declare WalletAppKit''chain WalletAppKit''connect-to-loopback WalletAppKit''create-peer-group WalletAppKit''create-wallet WalletAppKit''install-shutdown-hook WalletAppKit''on-setup-completed WalletAppKit''peer-group WalletAppKit''provide-block-store WalletAppKit''set-checkpoints WalletAppKit''set-peer-nodes WalletAppKit''store WalletAppKit''wallet WalletAppKit'new)
(declare WalletCoinsReceivedEventListener'''on-coins-received)
(declare WeakConfidenceReference'new)
(declare WrongNetworkException'new)

(ยง ns bitclojn.base-listeners
    (:refer-clojure :exclude [ensure subvec sync vec vector vector-of when when-not])
    (:use [bitclojn slang])
)

;;;
 ; Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.
 ;;
(defprotocol BlocksDownloadedEventListener
    ;; TODO: Fix the Block/FilteredBlock type hierarchy so we can avoid the stupid typeless API here.
    ;;;
     ; Called on a Peer thread when a block is received.
     ;
     ; The block may be a Block object that contains transactions, a Block object that is only a header when
     ; fast catchup is being used.  If set, filteredBlock can be used to retrieve the list of associated transactions.
     ;
     ; @param peer The peer receiving the block.
     ; @param block The downloaded block.
     ; @param filteredBlock If non-null, the object that wraps the block header passed as the block param.
     ; @param blocksLeft The number of blocks left to download.
     ;;
    #_abstract
    (#_"BlocksDownloadedEventListener" BlocksDownloadedEventListener'''on-blocks-downloaded [#_"BlocksDownloadedEventListener" this, #_"Peer" peer, #_"Block" block, #_"FilteredBlock" filtered, #_"int" __blocksLeft])
)

;;;
 ; Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.
 ;;
(defprotocol ChainDownloadStartedEventListener
    ;;;
     ; Called when a download is started with the initial number of blocks to be downloaded.
     ;
     ; @param peer The peer receiving the block.
     ; @param blocksLeft The number of blocks left to download.
     ;;
    #_abstract
    (#_"ChainDownloadStartedEventListener" ChainDownloadStartedEventListener'''on-chain-download-started [#_"ChainDownloadStartedEventListener" this, #_"Peer" peer, #_"int" __blocksLeft])
)

;;;
 ; Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.
 ;;
(defprotocol GetDataEventListener
    ;;;
     ; Called when a peer receives a getdata message, usually in response to an "inv" being broadcast.  Return as many
     ; items as possible which appear in the {@link GetDataMessage}, or null if you're not interested in responding.
     ;
     ; Note that this will never be called if registered with any executor other than {@link Threading#SAME_THREAD}.
     ;;
    #_abstract
    (#_"List<Transaction>" GetDataEventListener'''get-data [#_"GetDataEventListener" this, #_"Peer" peer, #_"GetDataMessage" m])
)

;;;
 ; Listener interface for when a new block on the best chain is seen.
 ;;
(defprotocol NewBestBlockListener
    ;;;
     ; Called when a new block on the best chain is seen, after relevant transactions are extracted and sent to us via either
     ; {@link TransactionReceivedInBlockListener#receiveFromBlock(Transaction, StoredBlock, SPVBlockChain.NewBlockType, int relativityOffset)}
     ; or {@link TransactionReceivedInBlockListener#notifyTransactionIsInBlock(Sha256Hash, StoredBlock, SPVBlockChain.NewBlockType, int)}.
     ;
     ; If this block is causing a re-organise to a new chain, this method is NOT called even though
     ; the block may be the new best block: your reorganize implementation is expected to do whatever
     ; would normally be done do for a new best block in this case.
     ;;
    #_throws #_[ "VerificationException" ]
    #_abstract
    (#_"NewBestBlockListener" NewBestBlockListener'''notify-new-best-block [#_"NewBestBlockListener" this, #_"StoredBlock" block])
)

;;;
 ; Called when a new transaction is broadcast over the network.
 ;;
(defprotocol OnTransactionBroadcastListener
    ;;;
     ; Called when a new transaction is broadcast over the network.
     ;;
    #_abstract
    (#_"void" OnTransactionBroadcastListener'''on-transaction [#_"OnTransactionBroadcastListener" this, #_"Peer" peer, #_"Transaction" t])
)

;;;
 ; Implementors can listen to events indicating a new peer connecting.
 ;;
(defprotocol PeerConnectedEventListener
    ;;;
     ; Called when a peer is connected.
     ;;
    #_abstract
    (#_"PeerConnectedEventListener" PeerConnectedEventListener'''on-peer-connected [#_"PeerConnectedEventListener" this, #_"Peer" peer])
)

;;;
 ; Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are processed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.
 ;;
(defprotocol PeerDataEventListener #_(ยง extends BlocksDownloadedEventListener, ChainDownloadStartedEventListener, GetDataEventListener, PreMessageReceivedEventListener)
)

;;;
 ; Implementors can listen to events indicating a peer disconnecting.
 ;;
(defprotocol PeerDisconnectedEventListener
    ;;;
     ; Called when a peer is disconnected.  Note that this won't be called if the listener is registered on
     ; a {@link PeerGroup} and the group is in the process of shutting down.  This handler can be called
     ; without a corresponding invocation of onPeerConnected if the initial connection is never successful.
     ;;
    #_abstract
    (#_"PeerDisconnectedEventListener" PeerDisconnectedEventListener'''on-peer-disconnected [#_"PeerDisconnectedEventListener" this, #_"Peer" peer])
)

;;;
 ; Implementors can listen to events for peers being discovered.
 ;;
(defprotocol PeerDiscoveredEventListener
    ;;;
     ; Called when peers are discovered, this happens at startup of {@link PeerGroup}
     ; or if we run out of suitable {@link Peer}s to connect to.
     ;
     ; @param peerAddresses The set of discovered {@link PeerAddress}es.
     ;;
    #_abstract
    (#_"void" PeerDiscoveredEventListener'''on-peers-discovered [#_"PeerDiscoveredEventListener" this, #_"Set<PeerAddress>" __peerAddresses])
)

;;;
 ; Implementors can listen to events like blocks being downloaded/transactions being broadcast/connect/disconnects,
 ; they can pre-filter messages before they are procesesed by a {@link Peer} or {@link PeerGroup}, and they can
 ; provide transactions to remote peers when they ask for them.
 ;;
(defprotocol PreMessageReceivedEventListener
    ;;;
     ; Called when a message is received by a peer, before the message is processed.  The returned message is
     ; processed instead.  Returning null will cause the message to be ignored by the Peer returning the same message
     ; object allows you to see the messages received but not change them.  The result from one event listeners
     ; callback is passed as "m" to the next, forming a chain.
     ;
     ; Note that this will never be called if registered with any executor other than {@link Threading#SAME_THREAD}.
     ;;
    #_abstract
    (#_"Message" PreMessageReceivedEventListener'''on-pre-message-received [#_"PreMessageReceivedEventListener" this, #_"Peer" peer, #_"Message" m])
)

;;;
 ; Listener interface for when the best chain has changed.
 ;;
(defprotocol ReorganizeListener
    ;;;
     ; Called by the {@link SPVBlockChain} when the best chain (representing total work done)
     ; has changed.  In this case, we need to go through our transactions and find out if any have become invalid.
     ; It's possible for our balance to go down in this case: money we thought we had can suddenly vanish
     ; if the rest of the network agrees it should be so.
     ;
     ; The oldBlocks/newBlocks lists are ordered height-wise from top first to bottom last (i.e. newest blocks first).
     ;;
    #_throws #_[ "VerificationException" ]
    #_abstract
    (#_"ReorganizeListener" ReorganizeListener'''reorganize [#_"ReorganizeListener" this, #_"StoredBlock" __splitPoint, #_"List<StoredBlock>" __oldBlocks, #_"List<StoredBlock>" __newBlocks])
)

;;;
 ; Implementors are called when confidence of a transaction changes.
 ;;
(defprotocol TransactionConfidenceEventListener
    ;;;
     ; Called when a transaction changes its confidence level.  You can also attach event listeners to
     ; the individual transactions, if you don't care about all of them.  Usually you would save the wallet to disk
     ; after receiving this callback unless you already set up autosaving.
     ;
     ; You should pay attention to this callback in case a transaction becomes <i>dead</i>, that is, a transaction
     ; you believed to be active (send or receive) becomes overridden by the network.  This can happen if
     ;
     ; <ol>
     ;     <li>You are sharing keys between wallets and accidentally create/broadcast a double spend.</li>
     ;     <li>Somebody is attacking the network and reversing transactions, i.e. the user is a victim of fraud.</li>
     ;     <li>A bug: for example you create a transaction, broadcast it but fail to commit it.
     ;     The {@link Wallet} will then re-use the same outputs when creating the next spend.</li>
     ; </ol>
     ;
     ; To find if the transaction is dead, you can use <tt>tx.getConfidence().getConfidenceType() ==
     ; TransactionConfidence.ConfidenceType.DEAD</tt>.  If it is, you should notify the user in some way
     ; so they know the thing they bought may not arrive/the thing they sold should not be dispatched.
     ;
     ; Note that this callback will be invoked for every transaction in the wallet, for every new block that is
     ; received (because the depth has changed).  <b>If you want to update a UI view from the contents of the wallet
     ; it is more efficient to use onWalletChanged instead.</b>
     ;;
    #_abstract
    (#_"void" TransactionConfidenceEventListener'''on-transaction-confidence-changed [#_"TransactionConfidenceEventListener" this, #_"Wallet" wallet, #_"Transaction" tx])
)

;;;
 ; Listener interface for when we receive a new block that contains a relevant transaction.
 ;;
(defprotocol TransactionReceivedInBlockListener
    ;;;
     ; Called by the {@link SPVBlockChain} when we receive a new block that contains a relevant transaction.
     ;
     ; A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.
     ;
     ; The relativityOffset parameter is an arbitrary number used to establish an ordering between transactions
     ; within the same block.  In the case where full blocks are being downloaded, it is simply the index of the
     ; transaction within that block.  When Bloom filtering is in use, we don't find out the exact offset into a block
     ; that a transaction occurred at, so the relativity count is not reflective of anything in an absolute sense but
     ; rather exists only to order the transaction relative to the others.
     ;;
    #_throws #_[ "VerificationException" ]
    #_abstract
    (#_"TransactionReceivedInBlockListener" TransactionReceivedInBlockListener'''receive-from-block [#_"TransactionReceivedInBlockListener" this, #_"Transaction" tx, #_"StoredBlock" block, #_"NewBlockType" type, #_"int" offset])

    ;;;
     ; Called by the {@link SPVBlockChain} when we receive a new {@link FilteredBlock} that contains the given
     ; transaction hash in its merkle tree.
     ;
     ; A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.
     ;
     ; The relativityOffset parameter in this case is an arbitrary (meaningless) number, that is useful only when
     ; compared to the relativity count of another transaction received inside the same block.  It is used to establish
     ; an ordering of transactions relative to one another.
     ;
     ; This method should return false if the given tx hash isn't known about, e.g. because the the transaction was
     ; a Bloom false positive.  If it was known about and stored, it should return true.  The caller may need to know
     ; this to calculate the effective FP rate.
     ;
     ; @return whether the transaction is known about i.e. was considered relevant previously.
     ;;
    #_throws #_[ "VerificationException" ]
    #_abstract
    (#_"boolean" TransactionReceivedInBlockListener'''notify-transaction-is-in-block [#_"TransactionReceivedInBlockListener" this, #_"Sha256Hash" __txHash, #_"StoredBlock" block, #_"NewBlockType" type, #_"int" offset])
)

;;;
 ; An implementation of {@link AbstractPeerDataEventListener} that listens to chain download events and tracks
 ; progress as a percentage.  The default implementation prints progress to stdout, but you can subclass it and
 ; override the progress method to update a GUI instead.
 ;;
(class-ns DownloadProgressTracker (ยง implements PeerDataEventListener)
    (defn #_"DownloadProgressTracker" DownloadProgressTracker'new []
        (hash-map
            #_"int" :original-blocks-left -1
            #_"int" :last-percent 0
            ;;;
             ; A listenable future that completes with the height of the best chain (as reported by the peer)
             ; once chain download seems to be finished.
             ;;
            #_"SettableFuture<Long>" :future (SettableFuture/create)
            #_"boolean" :caught-up false
        )
    )

    #_override
    (defn #_"Message" PreMessageReceivedEventListener'''on-pre-message-received [#_"DownloadProgressTracker" __, #_"Peer" peer, #_"Message" m]
        ;; Just pass the message right through for further processing.
        m
    )

    #_override
    (defn #_"List<Transaction>" GetDataEventListener'''get-data [#_"DownloadProgressTracker" __, #_"Peer" peer, #_"GetDataMessage" m]
        nil
    )

    #_override
    (defn #_"DownloadProgressTracker" ChainDownloadStartedEventListener'''on-chain-download-started [#_"DownloadProgressTracker" this, #_"Peer" peer, #_"int" __blocksLeft]
        (when (and (pos? __blocksLeft) (= (:original-blocks-left this) -1))
            (DownloadProgressTracker''start-download this, __blocksLeft)
        )
        ;; Only mark this the first time, because this method can be called more than once during a chain download
        ;; if we switch peers during it.
        (let [this
                (if (= (:original-blocks-left this) -1)
                    (assoc this :original-blocks-left __blocksLeft)
                    (do (log/info (str "Chain download switched to " peer)) this)
                )]
            (when (zero? __blocksLeft)
                (DownloadProgressTracker''done-download this)
                (.set (:future this), (Peer''get-best-height peer))
            )
            this
        )
    )

    #_override
    (defn #_"DownloadProgressTracker" BlocksDownloadedEventListener'''on-blocks-downloaded [#_"DownloadProgressTracker" this, #_"Peer" peer, #_"Block" block, #_"FilteredBlock" filtered, #_"int" __blocksLeft]
        (when-not (:caught-up this) => this
            (let [this
                    (when (zero? __blocksLeft) => this
                        (let [this (assoc this :caught-up true)]
                            (DownloadProgressTracker''done-download this)
                            (.set (:future this), (Peer''get-best-height peer))
                            this
                        )
                    )]
                (when (and (not (neg? __blocksLeft)) (pos? (:original-blocks-left this))) => this
                    (let [#_"double" pct (- 100.0 (* 100.0 (/ __blocksLeft (double (:original-blocks-left this)))))]
                        (when-not (= (int pct) (:last-percent this)) => this
                            (DownloadProgressTracker''progress this, pct, __blocksLeft, (:time-seconds block))
                            (assoc this :last-percent (int pct))
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Called when download progress is made.
     ;
     ; @param pct The percentage of chain downloaded, estimated.
     ; @param date The date of the last block downloaded.
     ;;
    #_method
    (defn #_"void" DownloadProgressTracker''progress [#_"DownloadProgressTracker" __, #_"double" pct, #_"int" __blocksSoFar, #_"long" secs]
        (log/info (str "Chain download " (int pct) "% done with " __blocksSoFar " blocks to go, block date " (Time'format-seconds secs)))
        nil
    )

    ;;;
     ; Called when download is initiated.
     ;
     ; @param blocks The number of blocks to download, estimated.
     ;;
    #_method
    (defn #_"void" DownloadProgressTracker''start-download [#_"DownloadProgressTracker" __, #_"int" blocks]
        (log/info (str "Downloading block chain of size " blocks ". " (if (< 1000 blocks) "This may take a while." "")))
        nil
    )

    ;;;
     ; Called when we are done downloading the block chain.
     ;;
    #_method
    (defn #_"void" DownloadProgressTracker''done-download [#_"DownloadProgressTracker" __]
        nil
    )

    ;;;
     ; Wait for the chain to be downloaded.
     ;;
    #_throws #_[ "InterruptedException" ]
    #_method
    (defn #_"void" DownloadProgressTracker''await [#_"DownloadProgressTracker" this]
        (try
            (.get (:future this))
            (catch ExecutionException e
                (throw (RuntimeException. e))
            )
        )
        nil
    )
)

(ยง ns bitclojn.base
    (:refer-clojure :exclude [ensure subvec sync vec vector vector-of when when-not])
    (:use [bitclojn slang])
)

;;;
 ; A collection of various utility methods that are helpful for working with the Bitcoin protocol.
 ;;
#_stateless
(class-ns Utils
    (def #_"Charset" Charset'US-ASCII (Charset/forName "US-ASCII"))
    (def #_"Charset" Charset'UTF-8    (Charset/forName "UTF-8"))

    ;;; Parse 2 bytes from the byte array (starting at the offset) as unsigned 16-bit integer in little endian format. ;;
    (defn #_"int" Wire'bget-uint16 [#_"byte[]" bytes, #_"int" offset]
        (| (& 0xff (nth bytes offset))
       (<< (& 0xff (nth bytes (inc offset))) 8))
    )

    ;;; Parse 4 bytes from the byte array (starting at the offset) as unsigned 32-bit integer in little endian format. ;;
    (defn #_"long" Wire'bget-uint32 [#_"byte[]" bytes, #_"int" offset]
        (| (& 0xff (nth bytes offset))
       (<< (& 0xff (nth bytes (inc offset))) 8)
       (<< (& 0xff (nth bytes (+ offset 2))) 16)
       (<< (& 0xff (nth bytes (+ offset 3))) 24))
    )

    ;;; Parse 8 bytes from the byte array (starting at the offset) as signed 64-bit integer in little endian format. ;;
    (defn #_"long" Wire'bget-int64 [#_"byte[]" bytes, #_"int" offset]
        (| (& 0xff (nth bytes offset))
       (<< (& 0xff (nth bytes (inc offset))) 8)
       (<< (& 0xff (nth bytes (+ offset 2))) 16)
       (<< (& 0xff (nth bytes (+ offset 3))) 24)
       (<< (& 0xff (nth bytes (+ offset 4))) 32)
       (<< (& 0xff (nth bytes (+ offset 5))) 40)
       (<< (& 0xff (nth bytes (+ offset 6))) 48)
       (<< (& 0xff (nth bytes (+ offset 7))) 56))
    )

    ;;; Parse 2 bytes from the byte array (starting at the offset) as unsigned 16-bit integer in big endian format. ;;
    (defn #_"int" Wire'bget-uint16be [#_"byte[]" bytes, #_"int" offset]
        (| (<< (& 0xff (nth bytes offset)) 8)
               (& 0xff (nth bytes (inc offset))))
    )

    ;;; Parse 4 bytes from the byte array (starting at the offset) as unsigned 32-bit integer in big endian format. ;;
    (defn #_"long" Wire'bget-uint32be [#_"byte[]" bytes, #_"int" offset]
        (| (<< (& 0xff (nth bytes offset)) 24)
           (<< (& 0xff (nth bytes (inc offset))) 16)
           (<< (& 0xff (nth bytes (+ offset 2))) 8)
               (& 0xff (nth bytes (+ offset 3))))
    )

    (defn #_"void" Wire'bset-uint32be [#_"long" val, #_"byte[]" out, #_"int" offset]
        (aset out offset (byte (& 0xff (>> val 24))))
        (aset out (inc offset) (byte (& 0xff (>> val 16))))
        (aset out (+ offset 2) (byte (& 0xff (>> val 8))))
        (aset out (+ offset 3) (byte (& 0xff val)))
        nil
    )

    (defn #_"void" Wire'bset-uint32 [#_"long" val, #_"byte[]" out, #_"int" offset]
        (aset out offset (byte (& 0xff val)))
        (aset out (inc offset) (byte (& 0xff (>> val 8))))
        (aset out (+ offset 2) (byte (& 0xff (>> val 16))))
        (aset out (+ offset 3) (byte (& 0xff (>> val 24))))
        nil
    )

    (defn #_"void" Wire'bset-uint64 [#_"long" val, #_"byte[]" out, #_"int" offset]
        (aset out offset (byte (& 0xff val)))
        (aset out (inc offset) (byte (& 0xff (>> val 8))))
        (aset out (+ offset 2) (byte (& 0xff (>> val 16))))
        (aset out (+ offset 3) (byte (& 0xff (>> val 24))))
        (aset out (+ offset 4) (byte (& 0xff (>> val 32))))
        (aset out (+ offset 5) (byte (& 0xff (>> val 40))))
        (aset out (+ offset 6) (byte (& 0xff (>> val 48))))
        (aset out (+ offset 7) (byte (& 0xff (>> val 56))))
        nil
    )

    ;;;
     ; The regular {@link java.math.BigInteger#toByteArray()} includes the sign bit of the number and might result
     ; in an extra byte addition.  This method removes this extra byte.
     ;
     ; Assuming only positive numbers, it's possible to discriminate if an extra byte is added by checking if the
     ; first element of the array is 0 (0000_0000).  Due to the minimal representation provided by BigInteger, it means
     ; that the bit sign is the least significant bit 0000_000<b>0</b>.  Otherwise the representation is not minimal.
     ; For example, if the sign bit is 0000_00<b>0</b>0, then the representation is not minimal due to the rightmost zero.
     ;
     ; @param i The integer to format into a byte array.
     ; @param numBytes The desired size of the resulting byte array.
     ; @return numBytes byte long array.
     ;;
    (defn #_"byte[]" Utils'big-integer-to-bytes [#_"BigInteger" i, #_"int" m]
        (assert-argument (<= 0 (.signum i)), "i must be positive or zero")
        (assert-argument (< 0 m), "numBytes must be positive")

        (let [#_"byte[]" a (.toByteArray i)
              #_"boolean" sign? (zero? (nth a 0))
              #_"int" n (- (count a) (if sign? 1 0))]
            (assert-argument (<= n m), (str "The given number does not fit in " m))

            (let [#_"byte[]" bytes (byte-array m)]
                (System/arraycopy a, (if sign? 1 0), bytes, (- m n), n)
                bytes
            )
        )
    )

    ;;;
     ; Returns a copy of the given byte array in reverse order.
     ;;
    (defn #_"byte[]" Wire'reverse-bytes [#_"byte[]" bytes]
        ;; We could use the XOR trick here, but it's easier to understand if we don't.
        ;; If we find this is really a performance issue, the matter can be revisited.
        (let [#_"int" n (count bytes) #_"byte[]" reverse (byte-array n)]
            (dotimes [#_"int" i n]
                (aset reverse i (nth bytes (- n (inc i))))
            )
            reverse
        )
    )

    ;;;
     ; Calculates RIPEMD160(SHA256(input)).  This is used in Address calculations.
     ;;
    (defn #_"byte[]" Utils'sha256hash160 [#_"byte[]" input]
        (let [#_"byte[]" sha256 (Sha256Hash'hash input) #_"RIPEMD160Digest" digest (RIPEMD160Digest.)]
            (.update digest, sha256, 0, (count sha256))
            (let [#_"byte[]" output (byte-array 20)]
                (.doFinal digest, output, 0)
                output
            )
        )
    )

    ;;;
     ; MPI encoded numbers are produced by the OpenSSL BN_bn2mpi function.  They consist of
     ; a 4 byte big endian length field, followed by the stated number of bytes representing
     ; the number in big endian format (with a sign bit).
     ;
     ; @param hasLength can be set to false if the given array is missing the 4 byte length field.
     ;;
    (defn #_"BigInteger" Wire'decode-mpi [#_"byte[]" mpi, #_"boolean" len?]
        (let [#_"byte[]" bytes
                (when len? => mpi
                    (let [#_"int" n (int (Wire'bget-uint32be mpi, 0))
                          bytes (byte-array n) _ (System/arraycopy mpi, 4, bytes, 0, n)]
                        bytes
                    )
                )]
            (if (zero? (count bytes))
                BigInteger/ZERO
                (let [#_"boolean" negative? (= (& (nth bytes 0) 0x80) 0x80)]
                    (when negative?
                        (aset bytes 0 (& (nth bytes 0) 0x7f))
                    )
                    (let [#_"BigInteger" i (BigInteger. bytes)]
                        (if negative? (.negate i) i)
                    )
                )
            )
        )
    )

    ;;;
     ; MPI encoded numbers are produced by the OpenSSL BN_bn2mpi function.  They consist of
     ; a 4 byte big endian length field, followed by the stated number of bytes representing
     ; the number in big endian format (with a sign bit).
     ;
     ; @param includeLength indicates whether the 4 byte length field should be included.
     ;;
    (defn #_"byte[]" Wire'encode-mpi [#_"BigInteger" i, #_"boolean" len?]
        (when-not (= i BigInteger/ZERO) => (byte-array (if len? 4 0))
            (let [#_"byte[]" array (.toByteArray (.abs i)) #_"int" m (count array)
                  #_"int" n (if (= (& (nth array 0) 0x80) 0x80) (inc m) m)]
                (if len?
                    (let [#_"byte[]" bytes (byte-array (+ n 4))]
                        (System/arraycopy array, 0, bytes, (+ (- n m) 3), m)
                        (Wire'bset-uint32be n, bytes, 0)
                        (when (neg? i)
                            (aset bytes 4 (| (nth bytes 4) 0x80))
                        )
                        bytes
                    )
                    (let [#_"byte[]" bytes
                            (when-not (= n m) => array
                                (let [bytes (byte-array n)]
                                    (System/arraycopy array, 0, bytes, 1, m)
                                    bytes
                                )
                            )]
                        (when (neg? i)
                            (aset bytes 0 (| (nth bytes 0) 0x80))
                        )
                        bytes
                    )
                )
            )
        )
    )

    ;;;
     ; The "compact" format is a representation of a whole number N using an unsigned 32 bit number similar to
     ; a floating point format.  The most significant 8 bits are the unsigned exponent of base 256.  This exponent
     ; can be thought of as "number of bytes of N".  The lower 23 bits are the mantissa.  Bit number 24 (0x800000)
     ; represents the sign of N.  Therefore, N = (-1^sign) * mantissa * 256^(exponent-3).
     ;
     ; Satoshi's original implementation used BN_bn2mpi() and BN_mpi2bn().  MPI uses the most significant bit of
     ; the first byte as sign.  Thus 0x1234560000 is compact 0x05123456 and 0xc0de000000 is compact 0x0600c0de.
     ; Compact 0x05c0de00 would be -0x40de000000.
     ;
     ; Bitcoin only uses this "compact" format for encoding difficulty targets, which are unsigned 256bit quantities.
     ; Thus, all the complexities of the sign bit and using base 256 are probably an implementation accident.
     ;;
    (defn #_"BigInteger" Utils'decode-compact-bits [#_"long" compact]
        (let [#_"int" size (& (int (>> compact 24)) 0xff)
              #_"byte[]" bytes (byte-array (+ 4 size))]
            (aset bytes 3 (byte size))
            (when (<= 1 size)
                (aset bytes 4 (byte (& (>> compact 16) 0xff)))
            )
            (when (<= 2 size)
                (aset bytes 5 (byte (& (>> compact 8) 0xff)))
            )
            (when (<= 3 size)
                (aset bytes 6 (byte (& compact 0xff)))
            )
            (Wire'decode-mpi bytes, true)
        )
    )

    ;;;
     ; @see Utils#decodeCompactBits(long)
     ;;
    (defn #_"long" Utils'encode-compact-bits [#_"BigInteger" value]
        (let [#_"int" size (count (.toByteArray value))
              #_"long" result (if (<= size 3) (<< (.longValue value) (* 8 (- 3 size))) (.longValue (.shiftRight value, (* 8 (- size 3)))))
              ;; The 0x00800000 bit denotes the sign.
              ;; Thus, if it is already set, divide the mantissa by 256 and increase the exponent.
              [result size] (if (not= (& result 0x00800000) 0) [(>> result 8) (inc size)] [result size])]
            (| result (<< size 24) (if (neg? value) 0x00800000 0))
        )
    )

    ;;;
     ; Returns the current time in milliseconds since the epoch.
     ;;
    (defn #_"long" Time'now []
        (System/currentTimeMillis)
    )

    ;;;
     ; Returns the current time in seconds since the epoch.
     ;;
    (defn #_"long" Time'seconds []
        (quot (Time'now) 1000)
    )

    (def- #_"TimeZone" Time'UTC (TimeZone/getTimeZone "UTC"))

    ;;;
     ; Formats a given unix time (ms) value to an ISO 8601 string.
     ;;
    (defn #_"String" Time'format [#_"long" time]
        (let [#_"DateFormat" iso8601 (SimpleDateFormat. "yyyy-MM-dd'T'HH:mm:ss'Z'", Locale/US)]
            (.setTimeZone iso8601, Time'UTC)
            (.format iso8601, time)
        )
    )

    ;;;
     ; Formats a given time seconds value to an ISO 8601 string.
     ;;
    (defn #_"String" Time'format-seconds [#_"long" time]
        (Time'format (* time 1000))
    )

    ;;;
     ; Sleep for a span of time.
     ;;
    (defn #_"void" Time'sleep [#_"long" millis]
        (Uninterruptibles/sleepUninterruptibly millis, TimeUnit/MILLISECONDS)
        nil
    )

    ;;;
     ; Hex encoding used throughout the framework.
     ;;
    (def- #_"BaseEncoding" Utils'HEX (.lowerCase (BaseEncoding/base16)))

    (defn #_"String" Base16'encode [#_"byte[]" data]
        (.encode Utils'HEX, data)
    )

    (defn #_"byte[]" Base16'decode [#_"CharSequence" data]
        (.decode Utils'HEX, data)
    )

    ;;;
     ; Attempts to parse the given string as arbitrary-length hex or base58 and then return the results,
     ; or null if neither parse was successful.
     ;;
    (defn #_"byte[]" Utils'parse-as-hex-or-base58 [#_"String" data]
        (try
            (Base16'decode data)
            (catch Exception _
                ;; Didn't decode as hex, try base58.
                (try+
                    (Base58'decode-checked data)
                    (ยง catch AddressFormatException _
                        nil
                    )
                )
            )
        )
    )

    ;;;
     ; The string that prefixes all text messages signed using Bitcoin keys.
     ;;
    (def #_"String" Utils'BITCOIN_SIGNED_MESSAGE_HEADER "Bitcoin Signed Message:\n")
    (def #_"byte[]" Utils'BITCOIN_SIGNED_MESSAGE_HEADER_BYTES (.getBytes Utils'BITCOIN_SIGNED_MESSAGE_HEADER, Charset'UTF-8))

    ;;;
     ; Given a textual message, returns a byte buffer formatted as follows:
     ;
     ; <tt>[24] "Bitcoin Signed Message:\n" [message.length as a varint] message</tt>.
     ;;
    (defn #_"byte[]" Utils'format-message-for-signing [#_"String" message]
        (let [#_"ByteArrayOutputStream" baos (ByteArrayOutputStream.)]
            (.write baos, (count Utils'BITCOIN_SIGNED_MESSAGE_HEADER_BYTES))
            (.write baos, Utils'BITCOIN_SIGNED_MESSAGE_HEADER_BYTES)
            (Wire'write-string message, baos)
            (.toByteArray baos)
        )
    )

    ;; 00000001, 00000010, 00000100, 00001000, ...
    (def- #_"[int]" Utils'BIT_MASK [ 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 ])

    ;;; Checks if the given bit is set in data, using little endian (not the same as Java native big endian). ;;
    (defn #_"boolean" Utils'check-bit-le [#_"byte[]" data, #_"int" index]
        (not= (& (nth data (>>> index 3)) (nth Utils'BIT_MASK (& 7 index))) 0)
    )

    ;;; Sets the given bit in data to one, using little endian (not the same as Java native big endian). ;;
    (defn #_"void" Utils'set-bit-le [#_"byte[]" data, #_"int" index]
        (aset data (>>> index 3) (| (nth data (>>> index 3)) (nth Utils'BIT_MASK (& 7 index))))
        nil
    )
)

;;;
 ; Utility for formatting and parsing coin values to and from human readable form.
 ;
 ; MonetaryFormat instances are immutable.  Invoking a configuration method has no effect on the receiving instance;
 ; you must store and use the new instance it returns, instead.  Instances are thread safe, so they may be stored safely
 ; as static constants.
 ;;
(class-ns MonetaryFormat
    ;;; Currency code for base 1 Bitcoin. ;;
    (def #_"String" MonetaryFormat'CODE_BTC "BTC")
    ;;; Currency code for base 1/1000 Bitcoin. ;;
    (def #_"String" MonetaryFormat'CODE_MBTC "mBTC")
    ;;; Currency code for base 1/1000000 Bitcoin. ;;
    (def #_"String" MonetaryFormat'CODE_UBTC "ยตBTC")

    (def #_"int" MonetaryFormat'MAX_DECIMALS 8)

    (def- #_"String[]" MonetaryFormat'DEFAULT_CODES
        (let [codes (make-array String MonetaryFormat'MAX_DECIMALS)]
            (aset codes 0 MonetaryFormat'CODE_BTC)
            (aset codes 3 MonetaryFormat'CODE_MBTC)
            (aset codes 6 MonetaryFormat'CODE_UBTC)
            codes
        )
    )

    (def- #_"String" MonetaryFormat'DECIMALS_PADDING "0000000000000000") ;; a few more than necessary for Bitcoin

    (defn- #_"MonetaryFormat" MonetaryFormat'new
        ([] (MonetaryFormat'new \- 0 \0 \. 2 nil 0 RoundingMode/HALF_UP MonetaryFormat'DEFAULT_CODES \space true)) ;; defaults ;; plus none
        ([minus plus zero dot __minDecimals groups shift rounding codes space prefixed?]
            (hash-map
                #_"char" :negative-sign minus
                #_"char" :positive-sign plus
                #_"char" :zero-digit zero
                #_"char" :decimal-mark dot
                #_"int" :min-decimals __minDecimals
                #_"List<Integer>" :decimal-groups groups
                #_"int" :shift shift
                #_"RoundingMode" :rounding-mode rounding
                #_"String[]" :codes codes
                #_"char" :code-separator space
                #_"boolean" :code-prefixed prefixed?
            )
        )
    )

    ;;;
     ; Set character to prefix negative values.
     ;;
    #_method
    (defn #_"MonetaryFormat" MonetaryFormat''negative-sign [#_"MonetaryFormat" this, #_"char" minus]
        (assert-argument (not (Character/isDigit minus)))
        (assert-argument (< 0 minus))

        (assoc this :negative-sign minus)
    )

    ;;;
     ; Set character to prefix positive values.  A zero value means no sign is used in this case.
     ; For parsing, a missing sign will always be interpreted as if the positive sign was used.
     ;;
    #_method
    (defn #_"MonetaryFormat" MonetaryFormat''positive-sign [#_"MonetaryFormat" this, #_"char" plus]
        (assert-argument (not (Character/isDigit plus)))

        (assoc this :positive-sign plus)
    )

    ;;;
     ; Set character range to use for representing digits.  It starts with the specified character representing zero.
     ;;
    #_method
    (defn #_"MonetaryFormat" MonetaryFormat''digits [#_"MonetaryFormat" this, #_"char" zero]
        (assoc this :zero-digit zero)
    )

    ;;;
     ; Set character to use as the decimal mark.  If the formatted value does not have any decimals,
     ; no decimal mark is used either.
     ;;
    #_method
    (defn #_"MonetaryFormat" MonetaryFormat''decimal-mark [#_"MonetaryFormat" this, #_"char" dot]
        (assert-argument (not (Character/isDigit dot)))
        (assert-argument (< 0 dot))

        (assoc this :decimal-mark dot)
    )

    ;;;
     ; Set minimum number of decimals to use for formatting.  If the value precision exceeds all decimals specified
     ; (including additional decimals specified by {@link #optionalDecimals(int...)} or {@link #repeatOptionalDecimals(int, int)}),
     ; the value will be rounded.  This configuration is not relevant for parsing.
     ;;
    #_method
    (defn #_"MonetaryFormat" MonetaryFormat''min-decimals [#_"MonetaryFormat" this, #_"int" __minDecimals]
        (assoc this :min-decimals __minDecimals)
    )

    ;;;
     ; Set additional groups of decimals to use after the minimum decimals, if they are useful for expressing precision.
     ; Each value is a number of decimals in that group.  If the value precision exceeds all decimals specified
     ; (including minimum decimals), the value will be rounded.  This configuration is not relevant for parsing.
     ;
     ; For example, if you pass <tt>4,2</tt> it will add four decimals to your formatted string if needed, and then add
     ; another two decimals if needed.  At this point, rather than adding further decimals the value will be rounded.
     ;
     ; @param groups Any number numbers of decimals, one for each group.
     ;;
    #_method
    (defn #_"MonetaryFormat" MonetaryFormat''optional-decimals [#_"MonetaryFormat" this & #_"int..." groups]
        (assoc this :decimal-groups (apply list groups))
    )

    ;;;
     ; Set repeated additional groups of decimals to use after the minimum decimals, if they are useful for expressing
     ; precision.  If the value precision exceeds all decimals specified (including minimum decimals), the value will be
     ; rounded.  This configuration is not relevant for parsing.
     ;
     ; For example, if you pass <tt>1,8</tt> it will up to eight decimals to your formatted string if needed.
     ; After these have been used up, rather than adding further decimals the value will be rounded.
     ;
     ; @param decimals Value of the group to be repeated.
     ; @param repetitions Number of repetitions.
     ;;
    #_method
    (defn #_"MonetaryFormat" MonetaryFormat''repeat-optional-decimals [#_"MonetaryFormat" this, #_"int" decimals, #_"int" repetitions]
        (assoc this :decimal-groups (repeat repetitions decimals))
    )

    ;;;
     ; Set number of digits to shift the decimal separator to the right, coming from the standard BTC notation that was
     ; common pre-2014.  Note this will change the currency code if enabled.
     ;;
    #_method
    (defn #_"MonetaryFormat" MonetaryFormat''shift [#_"MonetaryFormat" this, #_"int" shift]
        (assoc this :shift shift)
    )

    ;;;
     ; Set rounding mode to use when it becomes necessary.
     ;;
    #_method
    (defn #_"MonetaryFormat" MonetaryFormat''rounding-mode [#_"MonetaryFormat" this, #_"RoundingMode" rounding]
        (assoc this :rounding-mode rounding)
    )

    ;;;
     ; Don't display currency code when formatting.  This configuration is not relevant for parsing.
     ;;
    #_method
    (defn #_"MonetaryFormat" MonetaryFormat''no-code [#_"MonetaryFormat" this]
        (assoc this :codes nil)
    )

    ;;;
     ; Configure currency code for given decimal separator shift.  This configuration is not relevant for parsing.
     ;
     ; @param codeShift Decimal separator shift, see {@link #shift}.
     ; @param code Currency code.
     ;;
    #_method
    (defn #_"MonetaryFormat" MonetaryFormat''code-3 [#_"MonetaryFormat" this, #_"int" i, #_"String" code]
        (assert-argument (< -1 i MonetaryFormat'MAX_DECIMALS))

        (let [#_"String[]" codes (if (some? (:codes this)) (Arrays/copyOf (:codes this), (count (:codes this))) (make-array String MonetaryFormat'MAX_DECIMALS))]
            (aset codes i code)
            (assoc this :codes codes)
        )
    )

    ;;;
     ; Separator between currency code and formatted value.  This configuration is not relevant for parsing.
     ;;
    #_method
    (defn #_"MonetaryFormat" MonetaryFormat''code-separator [#_"MonetaryFormat" this, #_"char" space]
        (assert-argument (not (Character/isDigit space)))
        (assert-argument (< 0 space))

        (assoc this :code-separator space)
    )

    ;;;
     ; Prefix formatted output by currency code.  This configuration is not relevant for parsing.
     ;;
    #_method
    (defn #_"MonetaryFormat" MonetaryFormat''prefix-code [#_"MonetaryFormat" this]
        (assoc this :code-prefixed true)
    )

    ;;;
     ; Postfix formatted output with currency code.  This configuration is not relevant for parsing.
     ;;
    #_method
    (defn #_"MonetaryFormat" MonetaryFormat''postfix-code [#_"MonetaryFormat" this]
        (assoc this :code-prefixed false)
    )

    ;;; Standard format for the BTC denomination. ;;
    (def #_"MonetaryFormat" MonetaryFormat'BTC (-> (MonetaryFormat'new) (MonetaryFormat''shift 0) (MonetaryFormat''min-decimals 2) (MonetaryFormat''repeat-optional-decimals 2, 3)))
    ;;; Standard format for the mBTC denomination. ;;
    (def #_"MonetaryFormat" MonetaryFormat'MBTC (-> (MonetaryFormat'new) (MonetaryFormat''shift 3) (MonetaryFormat''min-decimals 2) (MonetaryFormat''optional-decimals 2)))
    ;;; Standard format for the ยตBTC denomination. ;;
    (def #_"MonetaryFormat" MonetaryFormat'UBTC (-> (MonetaryFormat'new) (MonetaryFormat''shift 6) (MonetaryFormat''min-decimals 0) (MonetaryFormat''optional-decimals 2)))
    ;;; Standard format for fiat amounts. ;;
    (def #_"MonetaryFormat" MonetaryFormat'FIAT (-> (MonetaryFormat'new) (MonetaryFormat''shift 0) (MonetaryFormat''min-decimals 2) (MonetaryFormat''repeat-optional-decimals 2, 1)))

    ;;;
     ; Format the given monetary value to a human readable form.
     ;;
    #_method
    (defn #_"CharSequence" MonetaryFormat''format [#_"MonetaryFormat" this, #_"Monetary" monetary]
        ;; preparation
        (let [#_"int" __maxDecimals (reduce + (:min-decimals this) (:decimal-groups this))
              #_"int" sue (Monetary'''smallest-unit-exponent monetary)]
            (assert-state (<= __maxDecimals sue), (str "The maximum possible number of decimals (" __maxDecimals ") cannot exceed " sue "."))

            ;; rounding
            (let [#_"long" satoshis (Math/abs (:value monetary))
                  #_"long" __precisionDivisor (LongMath/checkedPow 10, (- sue (:shift this) __maxDecimals))
                  satoshis (* (LongMath/divide satoshis, __precisionDivisor, (:rounding-mode this)), __precisionDivisor)]

                ;; shifting
                (let [#_"long" __shiftDivisor (LongMath/checkedPow 10, (- sue (:shift this)))
                      #_"long" numbers (quot satoshis __shiftDivisor) #_"long" decimals (rem satoshis __shiftDivisor)]

                    ;; formatting
                    (let [#_"StringBuilder" sb (StringBuilder. (format (str "%0" (- sue (:shift this)) "d"), decimals))]
                        (while (and (< (:min-decimals this) (.length sb)) (= (.charAt sb, (dec (.length sb))) \0))
                            (.setLength sb, (dec (.length sb))) ;; trim trailing zero
                        )
                        (loop-when [#_"int" i (:min-decimals this) #_"int*" groups (:decimal-groups this)] (seq groups)
                            (let [#_"int" group (first groups)]
                                (when (< i (.length sb) (+ i group)) => (recur (+ i group) (next groups))
                                    (while (< (.length sb) (+ i group))
                                        (.append sb, "0")
                                    )
                                )
                            )
                        )
                        (when (< 0 (.length sb))
                            (.insert sb, 0, (:decimal-mark this))
                        )
                        (.insert sb, (int 0), numbers)
                        (cond
                            (neg? (:value monetary))       (.insert sb, 0, (:negative-sign this))
                            (not= (:positive-sign this) 0) (.insert sb, 0, (:positive-sign this))
                        )
                        (when (some? (:codes this))
                            (if (:code-prefixed this)
                                (.. sb (insert 0, (:code-separator this)) (insert 0, (MonetaryFormat''code-1 this)))
                                (.. sb (append (:code-separator this)) (append (MonetaryFormat''code-1 this)))
                            )
                        )

                        ;; Convert to non-arabic digits.
                        (when-not (= (:zero-digit this) \0)
                            (let [#_"int" offset (- (:zero-digit this) \0)]
                                (dotimes [#_"int" i (.length sb)]
                                    (let [#_"char" c (.charAt sb, i)]
                                        (when (Character/isDigit c)
                                            (.setCharAt sb, i, (char (+ c offset)))
                                        )
                                    )
                                )
                            )
                        )
                        sb
                    )
                )
            )
        )
    )

    ;;;
     ; Parse a human readable coin value to a {@link Coin} instance.
     ;
     ; @throws NumberFormatException if the string cannot be parsed for some reason.
     ;;
    #_throws #_[ "NumberFormatException" ]
    #_method
    (defn #_"Coin" MonetaryFormat''parse-coin [#_"MonetaryFormat" this, #_"String" s]
        (Coin'new (MonetaryFormat''parse-value this, s, Coin'SMALLEST_UNIT_EXPONENT))
    )

    ;;;
     ; Parse a human readable fiat value to a {@link Fiat} instance.
     ;
     ; @throws NumberFormatException if the string cannot be parsed for some reason.
     ;;
    #_throws #_[ "NumberFormatException" ]
    #_method
    (defn #_"Fiat" MonetaryFormat''parse-fiat [#_"MonetaryFormat" this, #_"String" code, #_"String" s]
        (Fiat'new code, (MonetaryFormat''parse-value this, s, Fiat'SMALLEST_UNIT_EXPONENT))
    )

    #_method
    (defn- #_"long" MonetaryFormat''parse-value [#_"MonetaryFormat" this, #_"String" s, #_"int" sue]
        (assert-argument (<= sue (.length MonetaryFormat'DECIMALS_PADDING)))

        (when (empty? s)
            (throw (NumberFormatException. "empty string"))
        )

        (let [#_"char" s0 (.charAt s, 0) s (if (any = s0 (:negative-sign this) (:positive-sign this)) (.substring s, 1) s)
              #_"int" i (.indexOf s, (:decimal-mark this))
              [#_"String" numbers #_"String" decimals]
                (when-not (= i -1) => [s MonetaryFormat'DECIMALS_PADDING]
                    (let [numbers (.substring s, 0, i) decimals (.substring (str s MonetaryFormat'DECIMALS_PADDING), (inc i))]
                        (when-not (= (.indexOf decimals, (:decimal-mark this)) -1)
                            (throw (NumberFormatException. "more than one decimal mark"))
                        )
                        [numbers decimals]
                    )
                )
              #_"String" satoshis (+ numbers (.substring decimals, 0, (- sue (:shift this))))]

            (doseq [#_"char" c (.toCharArray satoshis)]
                (when-not (Character/isDigit c)
                    (throw (NumberFormatException. (str "illegal character: " c)))
                )
            )

            ;; Non-arabic digits allowed here.
            (let [#_"long" value (Long/parseLong satoshis)]
                (if (= s0 (:negative-sign this)) (- value) value)
            )
        )
    )

    ;;;
     ; Get currency code that will be used for current shift.
     ;;
    #_method
    (defn #_"String" MonetaryFormat''code-1 [#_"MonetaryFormat" this]
        (when (some? (:codes this))
            (or (nth (:codes this) (:shift this)) (throw (NumberFormatException. (str "missing code for shift: " (:shift this)))))
        )
    )
)

;;;
 ; Classes implementing this interface represent a monetary value, such as a Bitcoin or fiat amount.
 ;;
(defprotocol Monetary
    ;;;
     ; Returns the absolute value of exponent of the value of a "smallest unit" in scientific notation.
     ; For Bitcoin, a satoshi is worth 1E-8 so this would be 8.
     ;;
    #_abstract
    (#_"int" Monetary'''smallest-unit-exponent [#_"Monetary" this])
)

;;;
 ; Represents a monetary Bitcoin value.  This class is immutable.
 ;;
(class-ns Coin (ยง implements Monetary)
    ;;;
     ; Number of decimals for one Bitcoin.  This constant is useful for quick adapting to other coins
     ; because a lot of constants derive from it.
     ;;
    (def #_"int" Coin'SMALLEST_UNIT_EXPONENT 8)

    #_override
    (defn #_"int" Monetary'''smallest-unit-exponent [#_"Coin" __]
        Coin'SMALLEST_UNIT_EXPONENT
    )

    ;;;
     ; The number of satoshis equal to one bitcoin.
     ;;
    (def- #_"long" Coin'COIN_VALUE (LongMath/pow 10, Coin'SMALLEST_UNIT_EXPONENT))

    (defn- #_"Coin" Coin'new [#_"long" satoshis]
        (hash-map
            ;;;
             ; The number of satoshis of this monetary value.
             ;;
            #_"long" :value satoshis
        )
    )

    ;;;
     ; Convert an amount expressed in the way humans are used to into satoshis.
     ;;
    (defn #_"Coin" Coin'value-of [#_"int" coins, #_"int" cents]
        (assert-argument (and (<= 0 coins) (<= 0 cents) (< cents 100)))

        (Coin''add (Coin''multiply Coin'COIN, coins), (Coin''multiply Coin'CENT, cents))
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify fractional satoshis, or a value out of range.
     ;;
    (defn #_"Coin" Coin'parse-coin [#_"String" s]
        (try
            (let [#_"long" satoshis (.longValueExact (.movePointRight (BigDecimal. s), Coin'SMALLEST_UNIT_EXPONENT))]
                (Coin'new satoshis)
            )
            (catch ArithmeticException e
                (throw (IllegalArgumentException. e)) ;; Repackage exception to honor method contract.
            )
        )
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.  The amount is cut to satoshi precision.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify a value out of range.
     ;;
    (defn #_"Coin" Coin'parse-coin-inexact [#_"String" s]
        (try
            (let [#_"long" satoshis (.longValue (.movePointRight (BigDecimal. s), Coin'SMALLEST_UNIT_EXPONENT))]
                (Coin'new satoshis)
            )
            (catch ArithmeticException e
                (throw (IllegalArgumentException. e)) ;; Repackage exception to honor method contract.
            )
        )
    )

    #_method
    (defn #_"Coin" Coin''add [#_"Coin" this, #_"Coin" value]
        (Coin'new (+ (:value this), (:value value)))
    )

    #_method
    (defn #_"Coin" Coin''subtract [#_"Coin" this, #_"Coin" value]
        (Coin'new (- (:value this), (:value value)))
    )

    #_method
    (defn #_"Coin" Coin''negate [#_"Coin" this]
        (Coin'new (- (:value this)))
    )

    #_method
    (defn #_"Coin" Coin''multiply [#_"Coin" this, #_"long" factor]
        (Coin'new (* (:value this), factor))
    )

    #_method
    (defn #_"Coin" Coin''divide [#_"Coin" this, #_"long" divisor]
        (Coin'new (quot (:value this) divisor))
    )

    #_method
    (defn #_"Coin" Coin''remainder [#_"Coin" this, #_"long" divisor]
        (Coin'new (rem (:value this) divisor))
    )

    #_method
    (defn #_"Coin" Coin''shift-left [#_"Coin" this, #_"int" n]
        (Coin'new (<< (:value this) n))
    )

    #_method
    (defn #_"Coin" Coin''shift-right [#_"Coin" this, #_"int" n]
        (Coin'new (>> (:value this) n))
    )

    #_method
    (defn #_"int" Coin''signum [#_"Coin" this]
        (if (pos? (:value this)) 1 (if (neg? (:value this)) -1 0))
    )

    #_method
    (defn #_"boolean" Coin''positive? [#_"Coin" this]
        (pos? (:value this))
    )

    #_method
    (defn #_"boolean" Coin''negative? [#_"Coin" this]
        (neg? (:value this))
    )

    #_method
    (defn #_"boolean" Coin''zero? [#_"Coin" this]
        (zero? (:value this))
    )

    (defn #_"int" Coin'compare [#_"Coin" this, #_"Coin" that]
        (compare (:value this) (:value that))
    )

    #_method
    (defn #_"boolean" Coin''greater-than? [#_"Coin" this, #_"Coin" that]
        (> (:value this) (:value that))
    )

    #_method
    (defn #_"boolean" Coin''less-than? [#_"Coin" this, #_"Coin" that]
        (< (:value this) (:value that))
    )

    (def- #_"MonetaryFormat" Coin'FRIENDLY_FORMAT (-> MonetaryFormat'BTC (MonetaryFormat''min-decimals 2) (MonetaryFormat''repeat-optional-decimals 1, 6) (MonetaryFormat''postfix-code)))

    ;;;
     ; Returns the value as a 0.12 type string.  More digits after the decimal place will be used
     ; if necessary, but two will always be present.
     ;;
    #_method
    (defn #_"String" Coin''to-friendly-string [#_"Coin" this]
        (.toString (MonetaryFormat''format Coin'FRIENDLY_FORMAT, this))
    )

    (def- #_"MonetaryFormat" Coin'PLAIN_FORMAT (-> MonetaryFormat'BTC (MonetaryFormat''min-decimals 0) (MonetaryFormat''repeat-optional-decimals 1, 8) (MonetaryFormat''no-code)))

    ;;;
     ; Returns the value as a plain string denominated in BTC.
     ; The result is unformatted with no trailing zeroes.
     ; For instance, a value of 150000 satoshis gives an output string of "0.0015" BTC.
     ;;
    #_method
    (defn #_"String" Coin''to-plain-string [#_"Coin" this]
        (.toString (MonetaryFormat''format Coin'PLAIN_FORMAT, this))
    )

    #_method
    (defn #_"String" Coin''to-string [#_"Coin" this]
        (Long/toString (:value this))
    )

    ;;;
     ; Zero Bitcoins.
     ;;
    (def #_"Coin" Coin'ZERO (Coin'new 0))

    ;;;
     ; One Bitcoin.
     ;;
    (def #_"Coin" Coin'COIN (Coin'new Coin'COIN_VALUE))

    ;;;
     ; 0.01 Bitcoins.  This unit is not really used much.
     ;;
    (def #_"Coin" Coin'CENT (Coin''divide Coin'COIN, 100))

    ;;;
     ; 0.001 Bitcoins, also known as 1 mBTC.
     ;;
    (def #_"Coin" Coin'MILLICOIN (Coin''divide Coin'COIN, 1000))

    ;;;
     ; 0.000001 Bitcoins, also known as 1 ยตBTC or 1 uBTC.
     ;;
    (def #_"Coin" Coin'MICROCOIN (Coin''divide Coin'MILLICOIN, 1000))

    ;;;
     ; A satoshi is the smallest unit that can be transferred.  100 million of them fit into a Bitcoin.
     ;;
    (def #_"Coin" Coin'SATOSHI (Coin'new 1))

    (def #_"Coin" Coin'FIFTY_COINS (Coin''multiply Coin'COIN, 50))

    ;;;
     ; Represents a monetary value of minus one satoshi.
     ;;
    (def #_"Coin" Coin'NEGATIVE_SATOSHI (Coin'new -1))
)

;;;
 ; Represents a monetary fiat value.  It was decided to not fold this into {@link Coin}
 ; because of type safety.  Fiat values always come with an attached currency code.
 ;
 ; This class is immutable.
 ;;
(class-ns Fiat (ยง implements Monetary)
    ;;;
     ; The absolute value of exponent of the value of a "smallest unit" in scientific notation.
     ; We picked 4 rather than 2, because in financial applications it's common to use sub-cent precision.
     ;;
    (def #_"int" Fiat'SMALLEST_UNIT_EXPONENT 4)

    #_override
    (defn #_"int" Monetary'''smallest-unit-exponent [#_"Fiat" __]
        Fiat'SMALLEST_UNIT_EXPONENT
    )

    (defn- #_"Fiat" Fiat'new [#_"String" code, #_"long" value]
        (hash-map
            ;;;
             ; The number of "smallest units" of this monetary value.
             ;;
            #_"long" :value value
            #_"String" :code code
        )
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify more than 4 digits after the comma, or a value out of range.
     ;;
    (defn #_"Fiat" Fiat'parse-fiat [#_"String" code, #_"String" s]
        (try
            (let [#_"long" val (.longValueExact (.movePointRight (BigDecimal. s), Fiat'SMALLEST_UNIT_EXPONENT))]
                (Fiat'new code, val)
            )
            (catch ArithmeticException e
                (throw (IllegalArgumentException. e))
            )
        )
    )

    ;;;
     ; Parses an amount expressed in the way humans are used to.  The amount is cut to 4 digits after the comma.
     ;
     ; This takes string in a format understood by {@link BigDecimal#BigDecimal(String)},
     ; for example "0", "1", "0.10", "1.23E3", "1234.5E-5".
     ;
     ; @throws IllegalArgumentException if you try to specify a value out of range.
     ;;
    (defn #_"Fiat" Fiat'parse-fiat-inexact [#_"String" code, #_"String" s]
        (try
            (let [#_"long" val (.longValue (.movePointRight (BigDecimal. s), Fiat'SMALLEST_UNIT_EXPONENT))]
                (Fiat'new code, val)
            )
            (catch ArithmeticException e
                (throw (IllegalArgumentException. e))
            )
        )
    )

    #_method
    (defn #_"Fiat" Fiat''add [#_"Fiat" this, #_"Fiat" value]
        (assert-argument (= (:code value) (:code this)))

        (Fiat'new (:code this), (+ (:value this), (:value value)))
    )

    #_method
    (defn #_"Fiat" Fiat''subtract [#_"Fiat" this, #_"Fiat" value]
        (assert-argument (= (:code value) (:code this)))

        (Fiat'new (:code this), (- (:value this), (:value value)))
    )

    #_method
    (defn #_"Fiat" Fiat''negate [#_"Fiat" this]
        (Fiat'new (:code this), (- (:value this)))
    )

    #_method
    (defn #_"Fiat" Fiat''multiply [#_"Fiat" this, #_"long" factor]
        (Fiat'new (:code this), (* (:value this), factor))
    )

    #_method
    (defn #_"Fiat" Fiat''divide [#_"Fiat" this, #_"long" divisor]
        (Fiat'new (:code this), (quot (:value this) divisor))
    )

    #_method
    (defn #_"Fiat" Fiat''remainder [#_"Fiat" this, #_"long" divisor]
        (Fiat'new (:code this), (rem (:value this) divisor))
    )

    #_method
    (defn #_"int" Fiat''signum [#_"Fiat" this]
        (if (pos? (:value this)) 1 (if (neg? (:value this)) -1 0))
    )

    #_method
    (defn #_"boolean" Fiat''positive? [#_"Fiat" this]
        (pos? (:value this))
    )

    #_method
    (defn #_"boolean" Fiat''negative? [#_"Fiat" this]
        (neg? (:value this))
    )

    #_method
    (defn #_"boolean" Fiat''zero? [#_"Fiat" this]
        (zero? (:value this))
    )

    (defn #_"int" Fiat'compare [#_"Fiat" this, #_"Fiat" that]
        (if (= (:code this) (:code that)) (compare (:value this) (:value that)) (compare (:code this) (:code that)))
    )

    #_method
    (defn #_"boolean" Fiat''greater-than? [#_"Fiat" this, #_"Fiat" that]
        (> (:value this) (:value that))
    )

    #_method
    (defn #_"boolean" Fiat''less-than? [#_"Fiat" this, #_"Fiat" that]
        (< (:value this) (:value that))
    )

    (def- #_"MonetaryFormat" Fiat'FRIENDLY_FORMAT (-> MonetaryFormat'FIAT (MonetaryFormat''postfix-code)))

    ;;;
     ; Returns the value as a 0.12 type string.
     ; More digits after the decimal place will be used if necessary, but two will always be present.
     ;;
    #_method
    (defn #_"String" Fiat''to-friendly-string [#_"Fiat" this]
        (.toString (MonetaryFormat''format (MonetaryFormat''code-3 Fiat'FRIENDLY_FORMAT, 0, (:code this)), this))
    )

    (def- #_"MonetaryFormat" Fiat'PLAIN_FORMAT (-> MonetaryFormat'FIAT (MonetaryFormat''min-decimals 0) (MonetaryFormat''repeat-optional-decimals 1, 4) (MonetaryFormat''no-code)))

    ;;;
     ; Returns the value as a plain string.  The result is unformatted with no trailing zeroes.
     ; For instance, a value of 150000 "smallest units" gives an output string of "0.0015".
     ;;
    #_method
    (defn #_"String" Fiat''to-plain-string [#_"Fiat" this]
        (.toString (MonetaryFormat''format Fiat'PLAIN_FORMAT, this))
    )

    #_method
    (defn #_"String" Fiat''to-string [#_"Fiat" this]
        (Long/toString (:value this))
    )
)

(def NewBlockType'enum-set
    (hash-set
        :NewBlockType'BEST_CHAIN
        :NewBlockType'SIDE_CHAIN
    )
)

;;;
 ; An OrphanBlock holds a block header and, optionally, a list of tx hashes or block's transactions.
 ;;
(class-ns OrphanBlock
    (defn #_"OrphanBlock" OrphanBlock'new [#_"Block" block, #_"List<Sha256Hash>" hashes, #_"Map<Sha256Hash, Transaction>" txn]
        (let [#_"boolean" filtered? (and (some? hashes) (some? txn))]
            (assert-argument (or (and (nil? (:transactions block)) filtered?) (and (some? (:transactions block)) (not filtered?))))

            (hash-map
                #_"Block" :block block
                #_"List<Sha256Hash>" :filtered-tx-hashes hashes
                #_"Map<Sha256Hash, Transaction>" :filtered-txn txn
            )
        )
    )
)

;;;
 ; A BlockChain holds a series of {@link Block} objects, links them together, and knows how to verify that
 ; the chain follows the rules of the {@link Ledger}.
 ;
 ; It can be connected to a {@link Wallet}, and also {@link TransactionReceivedInBlockListener}s that can receive
 ; transactions and notifications of re-organizations.
 ;
 ; A BlockChain implementation must be connected to a {@link BlockStore} implementation.  The chain object
 ; by itself doesn't store any data, that's delegated to the store.  Which store you use is a decision best made by
 ; reading the getting started guide, but briefly, fully validating block chains need fully validating stores.
 ; In the lightweight SPV mode, a {@link SPVBlockStore} is the right choice.
 ;
 ; This class implements an abstract class which makes it simple to create a SPVBlockChain that does/doesn't do
 ; full verification.  It verifies headers and is implements most of what is required to implement SPV mode, but
 ; also provides callback hooks which can be used to do full verification.
 ;
 ; There are two subclasses of BlockChain that are useful: {@link SPVBlockChain}, which is the simplest
 ; class and implements <i>simplified payment verification</i>.  This is a lightweight and efficient mode that
 ; does not verify the contents of blocks, just their headers.  A {@link FullPrunedBlockChain} paired with a
 ; {@link H2FullPrunedBlockStore} implements full verification, which is equivalent to Bitcoin Core.
 ;
 ; To learn more about the alternative security models, please consult the articles on the website.
 ;
 ; <b>Theory</b>
 ;
 ; The 'chain' is actually a tree although in normal operation it operates mostly as a list of {@link Block}s.
 ; When multiple new head blocks are found simultaneously, there are multiple stories of the economy competing to become
 ; the one true consensus.  This can happen naturally when two miners solve a block within a few seconds of each other,
 ; or it can happen when the chain is under attack.
 ;
 ; A reference to the head block of the best known chain is stored.  If you can reach the genesis block by repeatedly
 ; walking through the prevBlock pointers, then we say this is a full chain.  If you cannot reach the genesis block
 ; we say it is an orphan chain.  Orphan chains can occur when blocks are solved and received during the initial block
 ; chain download, or if we connect to a peer that doesn't send us blocks in order.
 ;
 ; A reorganize occurs when the blocks that make up the best known chain changes.  Note that simply adding a
 ; new block to the top of the best chain isn't as reorganize, but that a reorganize is always triggered by adding
 ; a new block that connects to some other (non best head) block.  By "best" we mean the chain representing the largest
 ; amount of work done.
 ;
 ; Every so often the block chain passes a difficulty transition point.  At that time, all the blocks in the last
 ; 2016 blocks are examined and a new difficulty target is calculated from them.
 ;;
#_abstract
(class-ns BlockChain
    ;;; False positive estimation uses a double exponential moving average. ;;
    (def #_"double" BlockChain'FP_ESTIMATOR_ALPHA 0.0001)
    ;;; False positive estimation uses a double exponential moving average. ;;
    (def #_"double" BlockChain'FP_ESTIMATOR_BETA 0.01)

    ;;;
     ; Constructs a SPVBlockChain connected to the given list of listeners (e.g. wallets) and a store.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (defn #_"BlockChain" BlockChain'new [#_"Ledger" ledger, #_"BlockStore" store, #_"List<Wallet>" wallets]
        (let [this
                (hash-map
                    #_"Ledger" :ledger ledger
                    ;;;
                     ; Keeps a map of block hashes to StoredBlocks.
                     ;;
                    #_"BlockStore" :block-store store

                    #_"Object" :blockchain-lock (Object.)

                    ;;;
                     ; Tracks the top of the best known chain.
                     ;
                     ; Following this one down to the genesis block produces the story of the economy from the creation of Bitcoin
                     ; until the present day.  The chain head can change if a new set of blocks is received that results in a chain of
                     ; greater work than the one obtained by following this one down.  In that case a reorganize is triggered,
                     ; potentially invalidating transactions in our wallet.
                     ;;
                    #_"StoredBlock" :chain-head (BlockStore'''get-chain-head store)

                    ;; TODO: Scrap this and use a proper read/write for all of the block chain objects.
                    ;; The chainHead field is read/written synchronized with this object rather than SPVBlockChain.  However writing is
                    ;; also guaranteed to happen whilst SPVBlockChain is synchronized (see setChainHead).  The goal of this is to let
                    ;; clients quickly access the chain head even whilst the block chain is downloading and thus the SPVBlockChain is
                    ;; locked most of the time.
                    #_"Object" :chain-head-lock (Object.)

                    #_"[NewBestBlockListener]" :new-best-block-listeners (vector)
                    #_"[ReorganizeListener]" :reorganize-listeners (vector)
                    #_"[TransactionReceivedInBlockListener]" :transaction-received-listeners (vector)

                    ;; Holds blocks that we have received but can't plug into the chain yet, e.g. because they were created whilst we
                    ;; were downloading the block chain.
                    #_"LinkedHashMap<Sha256Hash, OrphanBlock>" :orphan-blocks (LinkedHashMap.)

                    ;;;
                     ; The false positive rate is the average over all blockchain transactions of:
                     ;
                     ;  1.0 if the transaction was false-positive (was irrelevant to all listeners)
                     ;  0.0 if the transaction was relevant or filtered out
                     ;;
                    #_"double" :false-positive-rate 0.0
                    #_"double" :false-positive-trend 0.0
                    #_"double" :previous-false-positive-rate 0.0

                    #_"VersionTally" :version-tally nil
                )]

            (log/info (str "chain head is at height " (:stored-height (:chain-head this)) ":\n" (:stored-header (:chain-head this))))

            (let [this (reduce BlockChain''add-new-best-block-listener       this wallets)
                  this (reduce BlockChain''add-reorganize-listener           this wallets)
                  this (reduce BlockChain''add-transaction-received-listener this wallets)]

                (assoc this :version-tally (VersionTally'from-store ledger, store, (:chain-head this)))
            )
        )
    )

    ;;;
     ; Add a wallet to the SPVBlockChain.  Note that the wallet will be unaffected by any blocks received while it
     ; was not part of this SPVBlockChain.  This method is useful if the wallet has just been created, and its keys
     ; have never been in use, or if the wallet has been loaded along with the SPVBlockChain.  Note that adding
     ; multiple wallets is not well tested!
     ;;
    #_method
    (defn #_"BlockChain" BlockChain''add-wallet [#_"BlockChain" this, #_"Wallet" wallet]
        (let [this
                (-> this
                    (BlockChain''add-new-best-block-listener       wallet)
                    (BlockChain''add-reorganize-listener           wallet)
                    (BlockChain''add-transaction-received-listener wallet)
                )
              #_"int" n (:last-block-seen-height wallet) #_"int" m (BlockChain''get-best-chain-height this)]

            (when-not (= n m) => this
                (log/warn (str "Wallet/chain height mismatch: " n " vs " m))
                (log/warn (str "Hashes: " (Wallet''get-last-block-seen-hash wallet) " vs " (Block''get-hash (:stored-header (BlockChain''get-chain-head this)))))

                ;; This special case happens when the VM crashes because of a transaction received.  It causes the updated
                ;; block store to persist, but not the wallet.  In order to fix the issue, we roll back the block store to
                ;; the wallet height to make it look like as if the block has never been received.
                (when (< 0 n m) => this
                    (try+
                        (let [this (BlockChain'''rollback-block-store this, n)]
                            (log/info (str "Rolled back block store to height " n))
                            this
                        )
                        (ยง catch BlockStoreException _
                            (log/warn "Rollback of block store failed, continuing with mismatched heights.  This can happen due to a replay.")
                            this
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Removes a wallet from the chain.
     ;;
    #_method
    (defn #_"BlockChain" BlockChain''remove-wallet [#_"BlockChain" this, #_"Wallet" wallet]
        (-> this
            (BlockChain''remove-new-best-block-listener       wallet)
            (BlockChain''remove-reorganize-listener           wallet)
            (BlockChain''remove-transaction-received-listener wallet)
        )
    )

    #_method
    (defn #_"BlockChain" BlockChain''add-new-best-block-listener [#_"BlockChain" this, #_"NewBestBlockListener" listener]
        (append* this :new-best-block-listeners listener)
    )

    #_method
    (defn #_"BlockChain" BlockChain''add-reorganize-listener [#_"BlockChain" this, #_"ReorganizeListener" listener]
        (append* this :reorganize-listeners listener)
    )

    #_method
    (defn #_"BlockChain" BlockChain''add-transaction-received-listener [#_"BlockChain" this, #_"TransactionReceivedInBlockListener" listener]
        (append* this :transaction-received-listeners listener)
    )

    #_method
    (defn #_"BlockChain" BlockChain''remove-new-best-block-listener [#_"BlockChain" this, #_"NewBestBlockListener" listener]
        (remove* this :new-best-block-listeners = listener)
    )

    #_method
    (defn #_"BlockChain" BlockChain''remove-reorganize-listener [#_"BlockChain" this, #_"ReorganizeListener" listener]
        (remove* this :reorganize-listeners = listener)
    )

    #_method
    (defn #_"BlockChain" BlockChain''remove-transaction-received-listener [#_"BlockChain" this, #_"TransactionReceivedInBlockListener" listener]
        (remove* this :transaction-received-listeners = listener)
    )

    ;;;
     ; Adds/updates the given {@link Block} with the block store.
     ; This version is used when the transactions have not been verified.
     ;
     ; @param storedPrev The {@link StoredBlock} which immediately precedes block.
     ; @param block The {@link Block} to add/update.
     ; @return the newly created {@link StoredBlock}
     ;;
    #_throws #_[ "BlockStoreException", "VerificationException" ]
    #_abstract
    (defn #_"StoredBlock" BlockChain'''add-to-block-store-3 [#_"BlockChain" this, #_"StoredBlock" prior, #_"Block" block])

    ;;;
     ; Adds/updates the given {@link StoredBlock} with the block store.
     ; This version is used when the transactions have already been verified to properly spend txOutputChanges.
     ;
     ; @param storedPrev The {@link StoredBlock} which immediately precedes block.
     ; @param header The {@link StoredBlock} to add/update.
     ; @param txOutputChanges The total sum of all changes made by this block to the set of open transaction outputs
     ;                        (from a call to connectTransactions), if in fully verifying mode (null otherwise).
     ; @return the newly created {@link StoredBlock}
     ;;
    #_throws #_[ "BlockStoreException", "VerificationException" ]
    #_abstract
    (defn #_"StoredBlock" BlockChain'''add-to-block-store-4 [#_"BlockChain" this, #_"StoredBlock" prior, #_"Block" header, #_"TransactionOutputChanges" changes])

    ;;;
     ; Rollback the block store to a given height.  This is currently only supported by {@link SPVBlockChain} instances.
     ;
     ; @throws BlockStoreException if the operation fails or is unsupported.
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (defn #_"BlockChain" BlockChain'''rollback-block-store [#_"BlockChain" this, #_"int" height])

    ;;;
     ; Called before setting chain head in memory.
     ; Should write the new head to block store and then commit any database transactions
     ; that were started by disconnectTransactions/connectTransactions.
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (defn #_"BlockChain" BlockChain'''do-set-chain-head [#_"BlockChain" this, #_"StoredBlock" head])

    ;;;
     ; Called if we (possibly) previously called disconnectTransaction/connectTransactions,
     ; but will not be calling preSetChainHead as a block failed verification.
     ; Can be used to abort database transactions that were started by
     ; disconnectTransactions/connectTransactions.
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (defn #_"void" BlockChain'''not-setting-chain-head [#_"BlockChain" this])

    ;;;
     ; For a standard SPVBlockChain, this should return blockStore.get(hash),
     ; for a FullPrunedBlockChain blockStore.getOnceUndoableStoredBlock(hash)
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (defn #_"StoredBlock" BlockChain'''get-stored-block-in-current-scope [#_"BlockChain" this, #_"Sha256Hash" hash])

    ;;;
     ; Processes a received block and tries to add it to the chain.  If there's something wrong with the block an
     ; exception is thrown.  If the block is OK but cannot be connected to the chain at this time, returns false.
     ; If the block can be connected to the chain, returns true.
     ; Accessing block's transactions in another thread while this method runs may result in undefined behavior.
     ;;
    #_throws #_[ "BlockStoreException", "VerificationException", "PrunedException" ]
    #_method
    (defn #_"[BlockChain boolean]" BlockChain''add-block [#_"BlockChain" this, #_"Block" block]
        (try+
            (BlockChain''add-5 this, block, true, nil, nil)
            (ยง catch VerificationException e
                (BlockChain'''not-setting-chain-head this)
                (throw+ (VerificationException'new (str "Could not verify block:\n" block)) e)
            )
        )
    )

    ;;;
     ; Processes a received block and tries to add it to the chain.  If there's something wrong with the block an
     ; exception is thrown.  If the block is OK but cannot be connected to the chain at this time, returns false.
     ; If the block can be connected to the chain, returns true.
     ;;
    #_throws #_[ "BlockStoreException", "VerificationException", "PrunedException" ]
    #_abstract
    (defn #_"[BlockChain boolean]" BlockChain'''add-filtered-block [#_"BlockChain" this, #_"FilteredBlock" filtered]
        (try+
            ;; The block has a list of hashes of transactions that matched the Bloom filter, and a list of associated
            ;; Transaction objects.  There may be fewer Transaction objects than hashes, this is expected.  It can happen
            ;; in the case where we were already around to witness the initial broadcast, so we downloaded the
            ;; transaction and sent it to the wallet before this point (the wallet may have thrown it away if it was
            ;; a false positive, as expected in any Bloom filtering scheme).  The filteredTxn list here will usually
            ;; only be full of data when we are catching up to the head of the chain and thus haven't witnessed any
            ;; of the transactions.
            (BlockChain''add-5 this, (FilteredBlock''get-block-header filtered), true, (FilteredBlock''get-transaction-hashes filtered), (:associated-transactions filtered))
            (ยง catch VerificationException e
                (BlockChain'''not-setting-chain-head this)
                (throw+ (VerificationException'new (str "Could not verify block " (FilteredBlock''get-hash filtered) "\n" filtered)) e)
            )
        )
    )

    ;;;
     ; Whether or not we are maintaining a set of unspent outputs and are verifying all transactions.
     ; Also indicates that all calls to add() should provide a block containing transactions
     ;;
    #_abstract
    (defn #_"boolean" BlockChain'''should-verify-transactions [#_"BlockChain" this])

    ;;;
     ; Connect each transaction in block.transactions, verifying them as we go and removing spent outputs
     ; If an error is encountered in a transaction, no changes should be made to the underlying BlockStore
     ; and a VerificationException should be thrown.
     ; Only called if shouldVerifyTransactions().
     ;
     ; @throws VerificationException if an attempt was made to spend an already-spent output, or if a transaction incorrectly solved an output script.
     ; @throws BlockStoreException if the block store had an underlying error.
     ; @return The full set of all changes made to the set of open transaction outputs.
     ;;
    #_throws #_[ "VerificationException", "BlockStoreException" ]
    #_abstract
    (defn #_"TransactionOutputChanges" BlockChain'''connect-transactions-3 [#_"BlockChain" this, #_"int" height, #_"Block" block])

    ;;;
     ; Load newBlock from BlockStore and connect its transactions, returning changes to the set of unspent transactions.
     ; If an error is encountered in a transaction, no changes should be made to the underlying BlockStore.
     ; Only called if shouldVerifyTransactions().
     ;
     ; @throws PrunedException if newBlock does not exist as a {@link StoredUndoableBlock} in the block store.
     ; @throws VerificationException if an attempt was made to spend an already-spent output, or if a transaction incorrectly solved an output script.
     ; @throws BlockStoreException if the block store had an underlying error or newBlock does not exist in the block store at all.
     ; @return The full set of all changes made to the set of open transaction outputs.
     ;;
    #_throws #_[ "VerificationException", "BlockStoreException", "PrunedException" ]
    #_abstract
    (defn #_"TransactionOutputChanges" BlockChain'''connect-transactions-2 [#_"BlockChain" this, #_"StoredBlock" stored])

    ;; filteredTxHashList contains all transactions, filteredTxn just a subset
    #_throws #_[ "BlockStoreException", "VerificationException", "PrunedException" ]
    #_method
    (defn- #_"[BlockChain boolean]" BlockChain''add-5 [#_"BlockChain" this, #_"Block" block, #_"boolean" __tryConnecting, #_"List<Sha256Hash>" __filteredTxHashList, #_"Map<Sha256Hash, Transaction>" __filteredTxn]
        (sync (:blockchain-lock this)
            (cond
                ;; Quick check for duplicates to avoid an expensive check further down (in findSplit).
                ;; This can happen a lot when connecting orphan transactions due to the dumb brute force algorithm we use.
                (.equals block, (:stored-header (BlockChain''get-chain-head this)))
                    [this true]
                (and __tryConnecting (contains? (:orphan-blocks this) (Block''get-hash block)))
                    [this false]
                ;; If we want to verify transactions (i.e. we are running with full blocks), verify that block has transactions.
                (and (BlockChain'''should-verify-transactions this) (nil? (:transactions block)))
                    (throw+ (VerificationException'new "Got a block header while running in full-block mode"))
                ;; Check for already-seen block, but only for full pruned mode, where the DB is
                ;; more likely able to handle these queries quickly.
                (and (BlockChain'''should-verify-transactions this) (some? (BlockStore'''get (:block-store this), (Block''get-hash block))))
                    [this true]
                :else
                ;; Prove the block is internally valid: hash is lower than target, etc.  This only checks the block contents
                ;; if there is a tx sending or receiving coins using an address in one of our wallets.  And those transactions
                ;; are only lightly verified: presence in a valid connecting block is taken as proof of validity.  See the
                ;; article here for more details: https://bitcoinj.github.io/security-model
                (let [#_"StoredBlock" prior
                        (try+
                            (Block''verify-header block)
                            (let [prior (BlockChain'''get-stored-block-in-current-scope this, (:prev-block-hash block))]
                                (when (BlockChain'''should-verify-transactions this)
                                    (let [#_"int" height (if (some? prior) (inc (:stored-height prior)) Block'BLOCK_HEIGHT_UNKNOWN)
                                          #_"{BlockVerifyFlag}" flags (Ledger''get-block-verification-flags (:ledger this), block, (:version-tally this))]
                                        (Block''verify-transactions block, height, flags)
                                    )
                                )
                                prior
                            )
                            (ยง catch VerificationException e
                                (log/error e, (str "Failed to verify block: " (Block''get-hash block)))
                                (throw+)
                            )
                        )]
                    ;; Try linking it to a place in the currently known blocks.
                    (if (some? prior)
                        (do
                            (assert-state (.isHeldByCurrentThread (:blockchain-lock this)))
                            ;; It connects to somewhere on the chain.  Not necessarily the top of the best known chain.
                            (Ledger'''check-difficulty-transitions (:ledger this), prior, block, (:block-store this))
                            (let [this (BlockChain''connect-block this, block, prior, (BlockChain'''should-verify-transactions this), __filteredTxHashList, __filteredTxn)]
                                (when __tryConnecting
                                    (BlockChain''try-connecting-orphans this)
                                )
                                [this true]
                            )
                        )
                        (do
                            (assert-state __tryConnecting, "bug in tryConnectingOrphans")
                            ;; We can't find the previous block.  Probably we are still in the process of downloading the chain and
                            ;; a block was solved whilst we were doing it.  We put it to one side and try to connect it later when
                            ;; we have more blocks.
                            (log/warn (str "Block does not connect: " (Block''get-hash block) " prev " (:prev-block-hash block)))
                            (ยง ass this (update this :orphan-blocks assoc (Block''get-hash block) (OrphanBlock'new block, __filteredTxHashList, __filteredTxn)))
                            [this false]
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Returns the hashes of the currently stored orphan blocks and then deletes them from this objects storage.
     ; Used by Peer when a filter exhaustion event has occurred and thus any orphan blocks that have been downloaded
     ; might be inaccurate/incomplete.
     ;;
    #_method
    (defn #_"Set<Sha256Hash>" BlockChain''drain-orphan-blocks [#_"BlockChain" this]
        (sync (:blockchain-lock this)
            (let [#_"Set<Sha256Hash>" hashes (HashSet. (.keySet (:orphan-blocks this)))]
                (ยง ass this (update this :orphan-blocks empty))
                hashes
            )
        )
    )

    ;; expensiveChecks enables checks that require looking at blocks further back in the chain
    ;; than the previous one when connecting (e.g. median timestamp check)
    ;; It could be exposed, but for now we just set it to shouldVerifyTransactions()
    #_throws #_[ "BlockStoreException", "VerificationException", "PrunedException" ]
    #_method
    (defn- #_"BlockChain" BlockChain''connect-block [#_"BlockChain" this, #_"Block" block, #_"StoredBlock" prior, #_"boolean" expensive?, #_"List<Sha256Hash>" __filteredTxHashList, #_"Map<Sha256Hash, Transaction>" __filteredTxn]
        (assert-state (.isHeldByCurrentThread (:blockchain-lock this)))

        (let [#_"boolean" filtered? (and (some? __filteredTxHashList) (some? __filteredTxn))]
            ;; Check that we aren't connecting a block that fails a checkpoint check.
            (when-not (Ledger''passes-checkpoint (:ledger this), (inc (:stored-height prior)), (Block''get-hash block))
                (throw+ (VerificationException'new (str "Block failed checkpoint lockin at " (inc (:stored-height prior)))))
            )
            (when (BlockChain'''should-verify-transactions this)
                (doseq [#_"Transaction" tx (ensure some? (:transactions block))]
                    (when-not (Transaction''is-final tx, (inc (:stored-height prior)), (:time-seconds block))
                        (throw+ (VerificationException'new "Block contains non-final transaction"))
                    )
                )
            )

            (let [#_"StoredBlock" head (BlockChain''get-chain-head this)]
                (cond (.equals prior, head)
                    (do
                        (when (and filtered? (seq __filteredTxn))
                            (log/debug (str "Block " (Block''get-hash block) " connects to top of best chain with " (count __filteredTxHashList) " transaction(s) of which we were sent " (count __filteredTxn)))
                            (doseq [#_"Sha256Hash" hash __filteredTxHashList]
                                (log/debug (str "  matched tx " hash))
                            )
                        )
                        (when (and expensive? (<= (:time-seconds block) (BlockChain'get-median-timestamp-of-recent-blocks head, (:block-store this))))
                            (throw+ (VerificationException'new "Block's timestamp is too early"))
                        )

                        ;; BIP 66 & 65: Enforce block version 3/4 once they are a supermajority of blocks.
                        ;; NOTE: This requires 1,000 blocks since the last checkpoint (on main net, less on test) in order to be applied.
                        ;; It is also limited to stopping addition of new v2/3 blocks to the tip of the chain.
                        (when (any = (:version block) Block'BLOCK_VERSION_BIP34 Block'BLOCK_VERSION_BIP66)
                            (let [#_"Integer" n (VersionTally''get-count-at-or-above (:version-tally this), (inc (:version block)))]
                                (when (and (some? n) (<= (-> this :ledger :majority-reject-block-outdated) n))
                                    (throw+ (VerificationException'new (str "Block version #" (:version block) " is outdated.")))
                                )
                            )
                        )

                        ;; This block connects to the best known block, it is a normal continuation of the system.
                        (let [#_"TransactionOutputChanges" changes (when (BlockChain'''should-verify-transactions this) (BlockChain'''connect-transactions-3 this, (inc (:stored-height prior)), block))
                              #_"StoredBlock" __newStoredBlock (BlockChain'''add-to-block-store-4 this, prior, (if (some? (:transactions block)) (Block''clone-as-header block) block), changes)
                              this (update this :version-tally VersionTally''add (:version block))
                              this (BlockChain''set-chain-head this, __newStoredBlock)]
                            (log/debug (str "Chain is now " (:stored-height __newStoredBlock) " blocks high, running listeners"))
                            (BlockChain''inform-listeners-for-new-block this, block, :NewBlockType'BEST_CHAIN, __filteredTxHashList, __filteredTxn, __newStoredBlock)
                        )
                    )
                    :else
                    ;; This block connects to somewhere other than the top of the best known chain.  We treat these differently.
                    ;;
                    ;; Note that we send the transactions to the wallet FIRST, even if we're about to re-organize this block
                    ;; to become the new best chain head.  This simplifies handling of the re-org in the Wallet class.
                    (let [#_"StoredBlock" __newBlock (StoredBlock''build prior, block)
                          #_"boolean" reorg? (StoredBlock''more-work-than __newBlock, head)
                          #_"boolean" abort?
                            (when-not reorg? => false
                                (let [#_"StoredBlock" __splitPoint (BlockChain'find-split __newBlock, head, (:block-store this))]
                                    (cond (and (some? __splitPoint) (.equals __splitPoint, __newBlock))
                                        (do
                                            ;; newStoredBlock is a part of the same chain, there's no fork.  This happens when we receive a block
                                            ;; that we already saw and linked into the chain previously, which isn't the chain head.
                                            ;; Re-processing it is confusing for the wallet so just skip.
                                            (log/warn (str "Saw duplicated block in main chain at height " (:stored-height __newBlock) ": " (Block''get-hash (:stored-header __newBlock))))
                                            true
                                        )
                                        (some? __splitPoint)
                                        (do
                                            ;; We aren't actually spending any transactions (yet) because we are on a fork.
                                            (BlockChain'''add-to-block-store-3 this, prior, block)
                                            (log/info (str "Block forks the chain at height " (:stored-height __splitPoint) "/block " (Block''get-hash (:stored-header __splitPoint)) ", but it did not cause a reorganize:\n" (Block''get-hash (:stored-header __newBlock))))
                                            false
                                        )
                                        :else
                                        (do
                                            ;; This should absolutely never happen.
                                            (throw+ (VerificationException'new "Block forks the chain but splitPoint is nil"))
                                        )
                                    )
                                )
                            )]

                        (when-not abort? => this
                            ;; We may not have any transactions if we received only a header, which can happen during fast catchup.
                            ;; If we do, send them to the wallet but state that they are on a side chain so it knows not to try and
                            ;; spend them until they become activated.
                            (let [this
                                    (when (or (some? (:transactions block)) filtered?) => this
                                        (BlockChain''inform-listeners-for-new-block this, block, :NewBlockType'SIDE_CHAIN, __filteredTxHashList, __filteredTxn, __newBlock)
                                    )]
                                (when reorg? => this
                                    (log/info "Block is causing a re-organize")
                                    (BlockChain''handle-new-best-chain this, prior, __newBlock, block, expensive?)
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_throws #_[ "VerificationException" ]
    (defn- #_"void" BlockChain'send-transactions-to-listener [#_"StoredBlock" block, #_"NewBlockType" type, #_"TransactionReceivedInBlockListener" listener, #_"int" offset, #_"List<Transaction>" transactions, #_"Set<Sha256Hash>" __falsePositives]
        (loop-when [#_"int" i offset #_"Transaction*" s transactions] (seq s)
            (let [#_"Transaction" tx (first s)
                  i (try+
                        (ยง ass __falsePositives (.remove __falsePositives, (Transaction''get-hash tx)))
                        (let [tx (when (ยง false clone?) => tx
                                    (Transaction'from-wire (:ledger tx), (ByteBuffer/wrap (Message''to-bytes tx, Transaction''to-wire)))
                                )]
                            (ยง ass listener (TransactionReceivedInBlockListener'''receive-from-block listener, tx, block, type, i))
                            (inc i)
                        )
                        (ยง catch ScriptException e
                            ;; We don't want scripts we don't understand to break the block chain,
                            ;; so just note that this tx was not scanned here and continue.
                            (log/warn (str "Failed to parse a script: " e))
                            i
                        )
                    )]
                (recur i (next s))
            )
        )
        nil
    )

    #_throws #_[ "VerificationException" ]
    (defn- #_"void" BlockChain'inform-listener-for-new-transactions [#_"Block" block, #_"NewBlockType" type, #_"List<Sha256Hash>" __filteredTxHashList, #_"Map<Sha256Hash, Transaction>" __filteredTxn, #_"StoredBlock" stored, #_"TransactionReceivedInBlockListener" listener, #_"Set<Sha256Hash>" __falsePositives]
        (cond (some? (:transactions block))
            (do
                ;; If this is not the first wallet, ask for the transactions to be duplicated before being given
                ;; to the wallet when relevant.  This ensures that if we have two connected wallets and a tx that
                ;; is relevant to both of them, they don't end up accidentally sharing the same object (which can
                ;; result in temporary in-memory corruption during re-orgs).  See bug 257.  We only duplicate in
                ;; the case of multiple wallets to avoid an unnecessary efficiency hit in the common case.
                (BlockChain'send-transactions-to-listener stored, type, listener, 0, (:transactions block), __falsePositives)
            )
            (some? __filteredTxHashList)
            (do
                (ensure some? __filteredTxn)
                ;; We must send transactions to listeners in the order they appeared in the block - thus we iterate over the
                ;; set of hashes and call sendTransactionsToListener with individual txn when they have not already been
                ;; seen in loose broadcasts - otherwise notifyTransactionIsInBlock on the hash.
                (loop-when-recur [#_"int" offset 0 #_"Sha256Hash*" s __filteredTxHashList] (seq s) [(inc offset) (next s)]
                    (let [#_"Sha256Hash" hash (first s) #_"Transaction" tx (get __filteredTxn hash)]
                        (if (some? tx)
                            (BlockChain'send-transactions-to-listener stored, type, listener, offset, (Collections/singletonList tx), __falsePositives)
                            (when (TransactionReceivedInBlockListener'''notify-transaction-is-in-block listener, hash, stored, type, offset)
                                (ยง ass __falsePositives (.remove __falsePositives, hash))
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    #_throws #_[ "VerificationException" ]
    #_method
    (defn- #_"BlockChain" BlockChain''inform-listeners-for-new-block [#_"BlockChain" this, #_"Block" block, #_"NewBlockType" type, #_"List<Sha256Hash>" __filteredTxHashList, #_"Map<Sha256Hash, Transaction>" __filteredTxn, #_"StoredBlock" stored]
        ;; Notify the listeners of the new block, so the depth and workDone of stored transactions can be updated
        ;; (in the case of the listener being a wallet).  Wallets need to know how deep each transaction is, so
        ;; coinbases aren't used before maturity.
        (let [#_"Set<Sha256Hash>" __falsePositives (HashSet.) _ (when (some? __filteredTxHashList) (ยง ass __falsePositives (.addAll __falsePositives, __filteredTxHashList)))]

            (doseq [#_"TransactionReceivedInBlockListener" l (:transaction-received-listeners this)]
                (ยง async?
                    (BlockChain'inform-listener-for-new-transactions block, type, __filteredTxHashList, __filteredTxn, stored, l, __falsePositives)
                )
            )

            (when (= type :NewBlockType'BEST_CHAIN)
                (doseq [#_"NewBestBlockListener" l (:new-best-block-listeners this)]
                    (ยง async?
                        (ยง ass l (NewBestBlockListener'''notify-new-best-block l, stored))
                    )
                )
            )

            (BlockChain''track-false-positives this, (count __falsePositives))
        )
    )

    ;;;
     ; Gets the median timestamp of the last 11 blocks.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (defn- #_"long" BlockChain'get-median-timestamp-of-recent-blocks [#_"StoredBlock" block, #_"BlockStore" store]
        (let [#_"long*" times
                (->>
                    (iterate #(StoredBlock''get-prev %, store) block)
                    (take-while some?)
                    (take 11)
                    (map #(:time-seconds (:stored-header %)))
                    (sort)
                )]
            (nth times (dec (quot (inc (count times)) 2)))
        )
    )

    ;;;
     ; Disconnect each transaction in the block (after reading it from the block store).
     ; Only called if shouldVerifyTransactions().
     ;
     ; @throws PrunedException if block does not exist as a {@link StoredUndoableBlock} in the block store.
     ; @throws BlockStoreException if the block store had an underlying error or block does not exist in the block store at all.
     ;;
    #_throws #_[ "PrunedException", "BlockStoreException" ]
    #_abstract
    (defn #_"void" BlockChain'''disconnect-transactions [#_"BlockChain" this, #_"StoredBlock" block])

    ;;;
     ; Called as part of connecting a block when the new block results in a different chain having higher total work.
     ;
     ; if shouldVerifyTransactions()
     ;     either newChainHead needs to be in the block store as a FullStoredBlock, or (block != null && block.transactions != null)
     ;;
    #_throws #_[ "BlockStoreException", "VerificationException", "PrunedException" ]
    #_method
    (defn- #_"BlockChain" BlockChain''handle-new-best-chain [#_"BlockChain" this, #_"StoredBlock" prior, #_"StoredBlock" __newChainHead, #_"Block" block, #_"boolean" expensive?]
        (assert-state (.isHeldByCurrentThread (:blockchain-lock this)))

        ;; This chain has overtaken the one we currently believe is best.  Reorganize is required.
        ;;
        ;; Firstly, calculate the block at which the chain diverged.  We only need to examine the
        ;; chain from beyond this block to find differences.

        (let [#_"StoredBlock" head (BlockChain''get-chain-head this)
              #_"StoredBlock" __splitPoint (BlockChain'find-split __newChainHead, head, (:block-store this))]
            (log/info (str "Re-organize after split at height " (:stored-height __splitPoint)))
            (log/info (str "Old chain head: " (Block''get-hash (:stored-header head))))
            (log/info (str "New chain head: " (Block''get-hash (:stored-header __newChainHead))))
            (log/info (str "Split at block: " (Block''get-hash (:stored-header __splitPoint))))

            ;; Then build a list of all blocks in the old part of the chain and the new part.
            (let [#_"LinkedList<StoredBlock>" __oldBlocks (BlockChain'get-partial-chain head, __splitPoint, (:block-store this))
                  #_"LinkedList<StoredBlock>" __newBlocks (BlockChain'get-partial-chain __newChainHead, __splitPoint, (:block-store this))
                  ;; Disconnect each transaction in the previous main chain that is no longer in the new main chain.
                  #_"StoredBlock" __storedNewHead
                    (if (BlockChain'''should-verify-transactions this)
                        (do
                            (doseq [#_"StoredBlock" __oldBlock __oldBlocks]
                                (try+
                                    (BlockChain'''disconnect-transactions this, __oldBlock)
                                    (ยง catch PrunedException _
                                        ;; We threw away the data we need to re-org this deep!  We need to go back to a peer with full
                                        ;; block contents and ask them for the relevant data then rebuild the indexs.  Or we could just
                                        ;; give up and ask the human operator to help get us unstuck (e.g. rescan from the genesis block).
                                        ;; TODO: retry adding this block when we get a block with hash e.getHash()
                                        (throw+)
                                    )
                                )
                            )
                            ;; Walk in ascending chronological order.
                            (let [#_"Iterator<StoredBlock>" it (.descendingIterator __newBlocks)]
                                (loop-when [__storedNewHead __splitPoint] (.hasNext it) => __storedNewHead
                                    (let [#_"StoredBlock" cursor (.next it)]
                                        (when (and expensive? (<= (:time-seconds (:stored-header cursor)) (BlockChain'get-median-timestamp-of-recent-blocks (StoredBlock''get-prev cursor, (:block-store this)), (:block-store this))))
                                            (throw+ (VerificationException'new "Block's timestamp is too early during reorg"))
                                        )
                                        (let [#_"TransactionOutputChanges" changes
                                                (if (and (= cursor __newChainHead) (some? block))
                                                    (BlockChain'''connect-transactions-3 this, (:stored-height __newChainHead), block)
                                                    (BlockChain'''connect-transactions-2 this, cursor)
                                                )]
                                            (recur (BlockChain'''add-to-block-store-4 this, __storedNewHead, (Block''clone-as-header (:stored-header cursor)), changes))
                                        )
                                    )
                                )
                            )
                        )
                        ;; (Finally) write block to block store.
                        (BlockChain'''add-to-block-store-3 this, prior, (:stored-header __newChainHead))
                    )]

                ;; Now inform the listeners.  This is necessary so the set of currently active transactions (that we can spend)
                ;; can be updated to take into account the re-organize.  We might also have received new coins we didn't have
                ;; before and our previous spends might have been undone.
                (doseq [#_"ReorganizeListener" l (:reorganize-listeners this)]
                    (ยง async?
                        (ยง ass l (ReorganizeListener'''reorganize l, __splitPoint, __oldBlocks, __newBlocks))
                    )
                )

                ;; Update the pointer to the best known block.
                (BlockChain''set-chain-head this, __storedNewHead)
            )
        )
    )

    ;;;
     ; Returns the set of contiguous blocks between 'higher' and 'lower'.  Higher is included, lower is not.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (defn- #_"LinkedList<StoredBlock>" BlockChain'get-partial-chain [#_"StoredBlock" higher, #_"StoredBlock" lower, #_"BlockStore" store]
        (assert-argument (< (:stored-height lower) (:stored-height higher)), "higher and lower are reversed")

        (let [#_"List<StoredBlock>" blocks (LinkedList.)]
            (loop [#_"StoredBlock" cursor higher]
                (ยง ass blocks (.add blocks, cursor))
                (let [cursor (ensure some? (StoredBlock''get-prev cursor, store), "Ran off the end of the chain")]
                    (when-not (.equals cursor, lower)
                        (recur cursor)
                    )
                )
            )
            blocks
        )
    )

    ;;;
     ; Locates the point in the chain at which newStoredBlock and chainHead diverge.  Returns null if no split point was
     ; found (i.e. they are not part of the same chain).  Returns newChainHead or chainHead if they don't actually diverge
     ; but are part of the same chain.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (defn- #_"StoredBlock" BlockChain'find-split [#_"StoredBlock" __newChainHead, #_"StoredBlock" __oldChainHead, #_"BlockStore" store]
        ;; Loop until we find the block both chains have in common.  Example:
        ;;
        ;;    A -> B -> C -> D
        ;;         \--> E -> F -> G
        ;;
        ;; findSplit will return block B.  oldChainHead = D and newChainHead = G.
        (loop-when [#_"StoredBlock" x __oldChainHead #_"StoredBlock" y __newChainHead] (not (.equals x, y)) => x
            (if (< (:stored-height y) (:stored-height x))
                (let [x (StoredBlock''get-prev x, store)] (ensure some? x, "Attempt to follow an orphan chain") (recur x y))
                (let [y (StoredBlock''get-prev y, store)] (ensure some? y, "Attempt to follow an orphan chain") (recur x y))
            )
        )
    )

    ;;;
     ; @return the height of the best known chain, convenience for <tt>getChainHead().getHeight()</tt>
     ;;
    #_method
    (defn #_"int" BlockChain''get-best-chain-height [#_"BlockChain" this]
        (:stored-height (BlockChain''get-chain-head this))
    )

    #_throws #_[ "BlockStoreException" ]
    #_method
    (defn #_"BlockChain" BlockChain''set-chain-head [#_"BlockChain" this, #_"StoredBlock" head]
        (let [this (BlockChain'''do-set-chain-head this, head)]
            (sync (:chain-head-lock this)
                (assoc this :chain-head head)
            )
        )
    )

    ;;;
     ; For each block in orphanBlocks, see if we can now fit it on top of the chain and if so, do so.
     ;;
    #_throws #_[ "VerificationException", "BlockStoreException", "PrunedException" ]
    #_method
    (defn- #_"void" BlockChain''try-connecting-orphans [#_"BlockChain" this]
        (assert-state (.isHeldByCurrentThread (:blockchain-lock this)))

        ;; For each block in our orphan list, try and fit it onto the head of the chain.  If we succeed remove it
        ;; from the list and keep going.  If we changed the head of the list at the end of the round try again until
        ;; we can't fit anything else on the top.
        ;;
        ;; This algorithm is kind of crappy, we should do a topo-sort then just connect them in order, but for small
        ;; numbers of orphan blocks it does OK.

        (loop []
            (let [#_"int" n
                    (loop-when [n 0 #_"Iterator<OrphanBlock>" it (.iterator (.values (:orphan-blocks this)))] (.hasNext it) => n
                        (let [#_"OrphanBlock" orphan (.next it)]
                            (if (nil? (BlockChain'''get-stored-block-in-current-scope this, (:prev-block-hash (:block orphan))))
                                (do
                                    ;; This is still an unconnected/orphan block.
                                    (log/debug (str "Orphan block " (Block''get-hash (:block orphan)) " is not connectable right now"))
                                    (recur n it)
                                )
                                (do
                                    ;; Otherwise we can connect it now.
                                    ;; False here ensures we don't recurse infinitely downwards when connecting huge chains.
                                    (log/info (str "Connected orphan " (Block''get-hash (:block orphan))))
                                    (ยง ass [this _] (BlockChain''add-5 this, (:block orphan), false, (:filtered-tx-hashes orphan), (:filtered-txn orphan)))
                                    (.remove it)
                                    (recur (inc n) it)
                                )
                            )
                        )
                    )]
                (when (pos? n)
                    (log/info (str "Connected " n " orphan blocks."))
                    (recur)
                )
            )
        )
        nil
    )

    ;;;
     ; Returns the block at the head of the current best chain.  This is the block which represents the greatest
     ; amount of cumulative work done.
     ;;
    #_method
    (defn #_"StoredBlock" BlockChain''get-chain-head [#_"BlockChain" this]
        (sync (:chain-head-lock this)
            (:chain-head this)
        )
    )

    ;;;
     ; An orphan block is one that does not connect to the chain anywhere (i.e. we can't find its parent, therefore
     ; it's an orphan).  Typically this occurs when we are downloading the chain and didn't reach the head yet, and/or
     ; if a block is solved whilst we are downloading.  It's possible that we see a small amount of orphan blocks which
     ; chain together, this method tries walking backwards through the known orphan blocks to find the bottom-most.
     ;
     ; @return from or one of from's parents, or null if "from" does not identify an orphan block
     ;;
    #_method
    (defn #_"Block" BlockChain''get-orphan-root [#_"BlockChain" this, #_"Sha256Hash" from]
        (sync (:blockchain-lock this)
            (let [#_"OrphanBlock" cursor (get (:orphan-blocks this) from)]
                (when (some? cursor)
                    (loop [cursor cursor]
                        (let [#_"Block" block (:block cursor) cursor (get (:orphan-blocks this) (:prev-block-hash block))]
                            (recur-if (some? cursor) cursor => block)
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Returns true if the given block is currently in the orphan blocks list.
     ;;
    #_method
    (defn #_"boolean" BlockChain''is-orphan [#_"BlockChain" this, #_"Sha256Hash" hash]
        (sync (:blockchain-lock this)
            (contains? (:orphan-blocks this) hash)
        )
    )

    ;;;
     ; Returns an estimate of when the given block will be reached, assuming a perfect 10 minute average for each
     ; block.  This is useful for turning transaction lock times into human readable times.  Note that a height in
     ; the past will still be estimated, even though the time of solving is actually known (we won't scan backwards
     ; through the chain to obtain the right answer).
     ;;
    #_method
    (defn #_"Date" BlockChain''estimate-block-time [#_"BlockChain" this, #_"int" height]
        (sync (:chain-head-lock this)
            (let [#_"long" offset (- height (:stored-height (:chain-head this)))
                  #_"long" time (:time-seconds (:stored-header (:chain-head this)))
                  #_"long" estimated (+ (* time 1000) (* 1000 60 10 offset))]
                (Date. estimated)
            )
        )
    )

    ;;;
     ; We completed handling of a filtered block.  Update false-positive estimate based
     ; on the total number of transactions in the original block.
     ;
     ; n includes filtered transactions, transactions that were passed in and were relevant
     ; and transactions that were false positives (i.e. includes all transactions in the block).
     ;;
    #_method
    (defn #_"BlockChain" BlockChain''track-filtered-transactions [#_"BlockChain" this, #_"int" n]
        ;; Track non-false-positives in batch.  Each non-false-positive counts as 0.0 towards the estimate.
        ;;
        ;; This is slightly off because we are applying false positive tracking before non-FP tracking,
        ;; which counts FP as if they came at the beginning of the block.  Assuming uniform FP
        ;; spread in a block, this will somewhat underestimate the FP rate (5% for 1000 tx block).
        (let [                                                   #_"double" alpha' (Math/pow (- 1 BlockChain'FP_ESTIMATOR_ALPHA), n)
              #_"double" beta (* BlockChain'FP_ESTIMATOR_BETA n) #_"double" beta' (Math/pow (- 1 BlockChain'FP_ESTIMATOR_BETA), n)
              ;; new_rate = alpha_decay * new_rate
              #_"double" rate (* alpha' (:false-positive-rate this))
              ;; trend = beta * (new_rate - old_rate) + beta_decay * trend
              #_"double" trend (+ (* beta (- rate (:previous-false-positive-rate this))) (* beta' (:false-positive-trend this)))
              ;; new_rate += alpha_decay * trend
              rate (+ rate (* alpha' trend))]
            ;; stash new_rate in old_rate
            (assoc this :false-positive-rate rate, :false-positive-trend trend, :previous-false-positive-rate rate)
        )
    )

    ;;;
     ; Irrelevant transactions were received.  Update false-positive estimate.
     ;;
    #_method
    (defn #_"BlockChain" BlockChain''track-false-positives [#_"BlockChain" this, #_"int" n]
        ;; Track false positives in batch by adding alpha to the false positive estimate once per count.
        ;; Each false positive counts as 1.0 towards the estimate.
        (let [this (update this :false-positive-rate + (* BlockChain'FP_ESTIMATOR_ALPHA n))]
            (when (pos? n)
                (log/debug (str n " false positives, current rate = " (:false-positive-rate this) " trend = " (:false-positive-trend this)))
            )
            this
        )
    )

    ;;;
     ; Resets estimates of false positives.  Used when the filter is sent to the peer.
     ;;
    #_method
    (defn #_"BlockChain" BlockChain''reset-false-positive-estimate [#_"BlockChain" this]
        (assoc this :false-positive-rate 0.0, :false-positive-trend 0.0, :previous-false-positive-rate 0.0)
    )
)

;;;
 ; A Message is a data structure that can be serialized/deserialized using the Bitcoin serialization format.
 ; Specific types of messages that are used both in the block chain, and on the wire, are derived from this class.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
#_abstract
(class-ns Message
    (def #_"int" Message'MAX_SIZE 0x02000000) ;; 32MB

    (defn #_"Message" Message'new [#_"Ledger" ledger]
        (hash-map
            #_"Ledger" :ledger ledger
        )
    )

    ;;;
     ; Serialize this message to a byte array that conforms to the bitcoin wire protocol.
     ;;
    #_method
    (defn #_"byte[]" Message''to-bytes [#_"Message" this, f'to-wire]
        (let [#_"ByteArrayOutputStream" baos (ByteArrayOutputStream. (<< 1 8))]
            (f'to-wire this, baos)
            (.toByteArray baos)
        )
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"long" Wire'read-uint32 [#_"ByteBuffer" payload]
        (try
            (let [#_"byte[]" bytes (byte-array 4) _ (.get payload, bytes)]
                (Wire'bget-uint32 bytes, 0)
            )
            (catch BufferUnderflowException e
                (throw+ (ProtocolException'new) e)
            )
        )
    )

    (defn #_"void" Wire'write-uint32 [#_"long" val, #_"ByteArrayOutputStream" baos]
        (.write baos, (int (& 0xff val)))
        (.write baos, (int (& 0xff (>> val 8))))
        (.write baos, (int (& 0xff (>> val 16))))
        (.write baos, (int (& 0xff (>> val 24))))
        nil
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"long" Wire'read-int64 [#_"ByteBuffer" payload]
        (try
            (let [#_"byte[]" bytes (byte-array 8) _ (.get payload, bytes)]
                (Wire'bget-int64 bytes, 0)
            )
            (catch BufferUnderflowException e
                (throw+ (ProtocolException'new) e)
            )
        )
    )

    (defn #_"void" Wire'write-int64 [#_"long" val, #_"ByteArrayOutputStream" baos]
        (.write baos, (int (& 0xff val)))
        (.write baos, (int (& 0xff (>> val 8))))
        (.write baos, (int (& 0xff (>> val 16))))
        (.write baos, (int (& 0xff (>> val 24))))
        (.write baos, (int (& 0xff (>> val 32))))
        (.write baos, (int (& 0xff (>> val 40))))
        (.write baos, (int (& 0xff (>> val 48))))
        (.write baos, (int (& 0xff (>> val 56))))
        nil
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"BigInteger" Wire'read-uint64 [#_"ByteBuffer" payload]
        ;; Java does not have an unsigned 64 bit type. So scrape it off the wire then flip.
        (BigInteger. (Wire'reverse-bytes (Wire'read-bytes payload, 8)))
    )

    (defn #_"void" Wire'write-uint64 [#_"BigInteger" val, #_"ByteArrayOutputStream" baos]
        (let [#_"byte[]" bytes (.toByteArray val)]
            (when (< 8 (count bytes))
                (throw (RuntimeException. "Input too large to encode into a uint64"))
            )
            (let [bytes (Wire'reverse-bytes bytes)]
                (.write baos, bytes)
                (when (< (count bytes) 8)
                    (dotimes [_ (- 8 (count bytes))]
                        (.write baos, 0)
                    )
                )
            )
        )
        nil
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"long" Wire'read-var-int [#_"ByteBuffer" payload]
        (try
            (let [#_"VarInt" varint (VarInt'from-wire payload)]
                (:value varint)
            )
            (catch BufferUnderflowException e
                (throw+ (ProtocolException'new) e)
            )
        )
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"byte" Wire'read-byte [#_"ByteBuffer" payload]
        (try
            (.get payload)
            (catch BufferUnderflowException e
                (throw+ (ProtocolException'new) e)
            )
        )
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"byte[]" Wire'read-bytes [#_"ByteBuffer" payload, #_"int" n]
        (when (< Message'MAX_SIZE n)
            (throw+ (ProtocolException'new (str "Claimed value length too large: " n)))
        )

        (try
            (let [#_"byte[]" bytes (byte-array n) _ (.get payload, bytes)]
                bytes
            )
            (catch BufferUnderflowException e
                (throw+ (ProtocolException'new) e)
            )
        )
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"byte[]" Wire'read-byte-array [#_"ByteBuffer" payload]
        (Wire'read-bytes payload, (int (Wire'read-var-int payload)))
    )

    (defn #_"void" Wire'write-byte-array [#_"byte[]" bytes, #_"ByteArrayOutputStream" baos]
        (.write baos, (VarInt''encode (VarInt'new (count bytes))))
        (.write baos, bytes)
        nil
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"String" Wire'read-string [#_"ByteBuffer" payload]
        (String. (Wire'read-byte-array payload), Charset'UTF-8)
    )

    (defn #_"void" Wire'write-string [#_"String" string, #_"ByteArrayOutputStream" baos]
        (Wire'write-byte-array (.getBytes string, Charset'UTF-8), baos)
        nil
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"Sha256Hash" Wire'read-hash [#_"ByteBuffer" payload]
        ;; We have to flip it around, as it's been read off the wire in little endian.
        ;; Not the most efficient way to do this but the clearest.
        (Sha256Hash'wrap (Wire'reverse-bytes (Wire'read-bytes payload, 32)))
    )

    (defn #_"void" Wire'write-hash [#_"Sha256Hash" hash, #_"ByteArrayOutputStream" baos]
        (.write baos, (Wire'reverse-bytes (:hash-bytes hash)))
        nil
    )
)

;;;
 ; Abstract superclass of classes with list based payload, i.e. InventoryMessage and GetDataMessage.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
#_abstract
(class-ns ListMessage (ยง extends Message)
    (def #_"long" ListMessage'MAX_INVENTORY_ITEMS 50000)

    (defn #_"ListMessage" ListMessage'new
        ([#_"Ledger" ledger] (ListMessage'new ledger, (ArrayList.)))
        ([#_"Ledger" ledger, #_"List<InventoryItem>" items]
            (merge (Message'new ledger)
                (hash-map
                    #_"List<InventoryItem>" :items items
                )
            )
        )
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"ListMessage" ListMessage'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload]
        (let [#_"List<InventoryItem>" items
                (let [#_"long" n (Wire'read-var-int payload)]
                    (when (< ListMessage'MAX_INVENTORY_ITEMS n)
                        (throw+ (ProtocolException'new (str "Too many items in INV message: " n)))
                    )
                    (let [items (ArrayList. n)]
                        (dotimes [_ n]
                            (let [#_"int" code (int (Wire'read-uint32 payload)) #_"InventoryItemType" type (InventoryItemType'for-code code)]
                                (when (nil? type)
                                    (throw+ (ProtocolException'new (str "Unknown CInv type: " code)))
                                )
                                (ยง ass items (.add items, (InventoryItem'new type, (Wire'read-hash payload))))
                            )
                        )
                        items
                    )
                )]

            (ListMessage'new ledger, items)
        )
    )

    #_method
    (defn ListMessage''to-wire
        (#_"String" [] nil)
        (#_"void" [#_"ListMessage" this, #_"ByteArrayOutputStream" baos]
            (.write baos, (VarInt''encode (VarInt'new (count (:items this)))))
            (doseq [#_"InventoryItem" item (:items this)]
                ;; Write out the type code.
                (Wire'write-uint32 (InventoryItemType'enum-map (:item-type item)), baos)
                ;; And now the hash.
                (.write baos, (Wire'reverse-bytes (:hash-bytes (:item-hash item))))
            )
            nil
        )
    )

    #_method
    (defn #_"ListMessage" ListMessage''add-item [#_"ListMessage" this, #_"InventoryItem" item]
        (append* this :items item)
    )

    #_method
    (defn #_"ListMessage" ListMessage''remove-item [#_"ListMessage" this, #_"int" index]
        (ยง ass this (update this :items .remove index))
        this
    )
)

;;;
 ; In Bitcoin the following format is often used to represent some type of key:
 ;
 ; <pre>[one version byte] [data bytes] [4 checksum bytes]</pre>
 ;
 ; and the result is then Base58 encoded.
 ;;

;;;
 ; A Bitcoin address looks like 1MsScoe2fTJoq4ZPdQgqyhgWeoNamYPevy and is derived from an elliptic curve public key
 ; plus a set of network parameters.  Not to be confused with a {@link PeerAddress} or {@link AddressMessage}
 ; which are about network (TCP) addresses.
 ;
 ; A standard address is built by taking the RIPE-MD160 hash of the public key bytes, with a version prefix and
 ; a checksum suffix, then encoding it textually as base58.  The version prefix is used to both denote the network
 ; for which the address is valid (see {@link Ledger}, and also to indicate how the bytes inside the address should
 ; be interpreted.  Whilst almost all addresses today are hashes of public keys, another (currently unsupported
 ; type) can contain a hash of a script instead.
 ;;
(class-ns Address
    ;;;
     ; An address is a RIPEMD160 hash of a public key, therefore is always 160 bits or 20 bytes.
     ;;
    (def #_"int" Address'LENGTH 20)

    (defn- #_"Address" Address'init [#_"Ledger" ledger, #_"int" version, #_"byte[]" bytes]
        (assert-argument (<= 0 version 255))

        (hash-map
            #_"Ledger" :ledger ledger
            ;;;
             ; The "version" or "header" byte is the first byte of the data.  This is used to disambiguate
             ; what the contents apply to, for example, which network the key or address is valid on.
             ;;
            #_"int" :version version
            ;;;
             ; The (big endian) 20 byte hash that is the core of a Bitcoin address.
             ;;
            #_"byte[]" :addr-bytes bytes
        )
    )

    ;;;
     ; Construct an address for the given ledger from the hash160 form.
     ;;
    (defn #_"Address" Address'from-hash160 [#_"Ledger" ledger, #_"byte[]" hash160]
        (assert-argument (= (count hash160) 20), "Addresses are 160-bit hashes, so you must provide 20 bytes")

        (Address'init (ensure some? ledger), (:address-header ledger), hash160)
    )

    ;;;
     ; Construct an address that represents the script hash extracted from the given scriptPubKey.
     ;;
    (defn #_"Address" Address'from-p2sh-script [#_"Ledger" ledger, #_"Script" __scriptPubKey]
        (assert-argument (Script''is-pay-to-script-hash __scriptPubKey), "Not a P2SH script")

        (let [#_"byte[]" hash160 (Script''get-pub-key-hash __scriptPubKey)]
            (assert-argument (= (count hash160) 20), "Addresses are 160-bit hashes, so you must provide 20 bytes")

            (Address'init (ensure some? ledger), (:p2sh-header ledger), hash160)
        )
    )

    ;;;
     ; Check if an address version is valid for the given ledger.
     ;;
    (defn- #_"boolean" Address'is-acceptable-version [#_"Ledger" ledger, #_"int" version]
        (boolean (some #(= % version) (:acceptable-address-codes ledger)))
    )

    ;;;
     ; Construct an address from its base58 representation.
     ;
     ; @param base58 The textual form of the address, such as "17kzeh4N8g49GFvdDzSf8PjaPfyoD1MndL".
     ;
     ; @throws AddressFormatException if the given base58 doesn't parse or the checksum is invalid.
     ;;
    #_throws #_[ "AddressFormatException" ]
    (defn #_"Address" Address'from-base58 [#_"String" base58]
        (let [#_"byte[]" bytes (Base58'decode-checked base58) #_"int" n (dec (count bytes))
              _ (assert-argument (= n 20), "Addresses are 160-bit hashes, so you must provide 20 bytes")
              #_"byte[]" hash160 (byte-array n) _ (System/arraycopy bytes, 1, hash160, 0, n)
              #_"int" version (& (nth bytes 0) 0xff)
              #_"Ledger" ledger (first (filter #(Address'is-acceptable-version %, version) Networks'NETWORKS))]

            (when (some? ledger) => (throw+ (AddressFormatException'new (str "No network found for " base58)))
                (Address'init ledger, version, hash160)
            )
        )
    )

    ;;;
     ; Returns the base58 encoded representation of this address including version and checksum bytes.
     ;;
    #_method
    (defn #_"String" Address''to-base58 [#_"Address" this]
        ;; 1 byte version + data bytes + 4 bytes check code (a truncated hash)
        (let [#_"int" n (count (:addr-bytes this)) #_"byte[]" bytes (byte-array (+ 1 n 4))]
            (aset bytes 0 (byte (:version this)))
            (System/arraycopy (:addr-bytes this), 0, bytes, 1, n)
            (let [#_"byte[]" checksum (Sha256Hash'hash-twice bytes, 0, (inc n))]
                (System/arraycopy checksum, 0, bytes, (inc n), 4)
                (Base58'encode bytes)
            )
        )
    )

    ;;;
     ; Returns true if this address is a Pay-To-Script-Hash (P2SH) address.
     ; See also https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki "Address Format for pay-to-script-hash".
     ;;
    #_method
    (defn #_"boolean" Address''is-p2sh-address [#_"Address" this]
        (= (:version this) (-> this :ledger :p2sh-header))
    )

    (defn #_"int" Address'compare [#_"Address" this, #_"Address" that]
        (let [#_"int" cmp (compare (:version this) (:version that))]
            (if (not= cmp 0) cmp (.compare (UnsignedBytes/lexicographicalComparator), (:addr-bytes this), (:addr-bytes that)))
        )
    )

    #_method
    (defn #_"String" Address''to-string [#_"Address" this]
        (Address''to-base58 this)
    )
)

(class-ns AddressFormatException (ยง extends IllegalArgumentException)
    (defn #_"AddressFormatException" AddressFormatException'new [#_"String" message]
        (IllegalArgumentException'new message)
    )
)

;;;
 ; Represents an "addr" message on the P2P network, which contains broadcast IP addresses of other peers.  This is
 ; one of the ways peers can find each other without using the DNS or IRC discovery mechanisms.  However storing and
 ; using addr messages is not presently implemented.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns AddressMessage (ยง extends Message)
    (def- #_"long" AddressMessage'MAX_ADDRESSES 1024)

    (defn- #_"AddressMessage" AddressMessage'new [#_"Ledger" ledger, #_"List<PeerAddress>" addrs]
        (merge (Message'new ledger)
            (hash-map
                #_"List<PeerAddress>" :addresses addrs
            )
        )
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"AddressMessage" AddressMessage'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload]
        (let [#_"List<PeerAddress>" addrs
                (let [#_"long" n (Wire'read-var-int payload)]
                    ;; Guard against ultra large messages that will crash us.
                    (when (< AddressMessage'MAX_ADDRESSES n)
                        (throw+ (ProtocolException'new "Address message too large."))
                    )
                    (let [addrs (ArrayList. n)]
                        (dotimes [_ n]
                            (let [#_"PeerAddress" addr (PeerAddress'from-wire ledger, payload)]
                                (ยง ass addrs (.add addrs, addr))
                            )
                        )
                        addrs
                    )
                )]

            (AddressMessage'new ledger, addrs)
        )
    )

    #_method
    (defn AddressMessage''to-wire
        (#_"String" [] "addr")
        (#_"void" [#_"AddressMessage" this, #_"ByteArrayOutputStream" baos]
            (when (some? (:addresses this))
                (.write baos, (VarInt''encode (VarInt'new (count (:addresses this)))))
                (doseq [#_"PeerAddress" addr (:addresses this)]
                    (PeerAddress''to-wire addr, baos)
                )
            )
            nil
        )
    )

    #_method
    (defn #_"AddressMessage" AddressMessage''add-address [#_"AddressMessage" this, #_"PeerAddress" address]
        (append* this :addresses address)
    )

    #_method
    (defn #_"AddressMessage" AddressMessage''remove-address [#_"AddressMessage" this, #_"int" index]
        (ยง ass this (update this :addresses .remove index))
        this
    )
)

;;;
 ; Base58 is a way to encode Bitcoin addresses (or arbitrary data) as alphanumeric strings.
 ;
 ; Note that this is not the same base58 as used by Flickr, which you may find referenced around the Internet.
 ;
 ; Satoshi explains: why base-58 instead of standard base-64 encoding?
 ; <ul>
 ; <li>Don't want 0OIl characters that look the same in some fonts and
 ;     could be used to create visually identical looking account numbers.</li>
 ; <li>A string with non-alphanumeric characters is not as easily accepted as an account number.</li>
 ; <li>E-mail usually won't line-break if there's no punctuation to break at.</li>
 ; <li>Doubleclicking selects the whole number as one word if it's all alphanumeric.</li>
 ; </ul>
 ;
 ; However, note that the encoding/decoding runs in O(n&sup2;) time, so it is not useful for large data.
 ;
 ; The basic idea of the encoding is to treat the data bytes as a large number represented using
 ; base-256 digits, convert the number to be represented using base-58 digits, preserve the exact
 ; number of leading zeros (which are otherwise lost during the mathematical operations on the
 ; numbers), and finally represent the resulting base-58 digits as alphanumeric ASCII characters.
 ;;
#_stateless
(class-ns Base58
    (def #_"char[]" Base58'ALPHABET (.toCharArray "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"))
    (def- #_"char" Base58'ENCODED_ZERO (nth Base58'ALPHABET 0))
    (def- #_"int[]" Base58'INDEXES (let [a (int-array 128)] (Arrays/fill a, -1) (loop-when-recur [i 0] (< i (count Base58'ALPHABET)) [(inc i)] (aset a (nth Base58'ALPHABET i) i)) a))

    ;;;
     ; Encodes the given bytes as a base58 string (no checksum is appended).
     ;
     ; @param input the bytes to encode
     ; @return the base58-encoded string
     ;;
    (defn #_"String" Base58'encode [#_"byte[]" input]
        (let-when [m (count input)] (pos? m) => ""
            ;; Count leading zeros.
            (let [zeros (loop-when-recur [i 0] (and (< i m) (zero? (nth input i))) [(inc i)] => i)
                  input (Arrays/copyOf input, m) ;; since divmod modifies it in-place
                  encoded (char-array (* m 2)) m' (count encoded) ;; upper bound
                  ;; Convert base-256 digits to base-58 digits (plus conversion to ASCII characters).
                  n (loop-when [n m' i zeros] (< i m) => n
                        (let [n (dec n)]
                            (aset encoded n (nth Base58'ALPHABET (Base58'divmod input, i, 256, 58)))
                            (recur n (if (zero? (nth input i)) (inc i) i))
                        )
                    )
                  ;; Preserve exactly as many leading encoded zeros in output as there were leading zeros in input.
                  n (loop-when-recur n (and (< n m') (= (nth encoded n) Base58'ENCODED_ZERO)) (inc n) => n)
                  n (loop-when [n n i zeros] (< 0 i) => n
                        (let [n (dec n)]
                            (aset encoded n Base58'ENCODED_ZERO)
                            (recur n (dec i))
                        )
                    )]
                ;; Return encoded string (including encoded leading zeros).
                (String. encoded, n, (- m' n))
            )
        )
    )

    ;;;
     ; Decodes the given base58 string into the original data bytes.
     ;
     ; @param input the base58-encoded string to decode
     ; @return the decoded data bytes
     ; @throws AddressFormatException if the given string is not a valid base58 string
     ;;
    #_throws #_[ "AddressFormatException" ]
    (defn #_"byte[]" Base58'decode [#_"String" input]
        (let-when [m (.length input)] (pos? m) => (byte-array 0)
            ;; Convert the base58-encoded ASCII chars to a base58 byte sequence (base58 digits).
            (let [input58 (byte-array m)]
                (dotimes [i m]
                    (let [c (.charAt input, i) digit (if (< c 128) (nth Base58'INDEXES c) -1)]
                        (if (< digit 0)
                            (throw+ (AddressFormatException'new (str "Illegal character " c " at position " i)))
                            (aset input58 i (byte digit))
                        )
                    )
                )
                ;; Count leading zeros.
                (let [zeros (loop-when-recur [i 0] (and (< i m) (zero? (nth input58 i))) [(inc i)] => i)
                      decoded (byte-array m)
                      ;; Convert base-58 digits to base-256 digits.
                      n (loop-when [n m i zeros] (< i m) => n
                            (let [n (dec n)]
                                (aset decoded n (Base58'divmod input58, i, 58, 256))
                                (recur n (if (zero? (nth input58 i)) (inc i) i))
                            )
                        )
                      ;; Ignore extra leading zeroes that were added during the calculation.
                      n (loop-when-recur n (and (< n m) (zero? (nth decoded n))) (inc n) => n)]
                    ;; Return decoded data (including original number of leading zeros).
                    (Arrays/copyOfRange decoded, (- n zeros), m)
                )
            )
        )
    )

    #_throws #_[ "AddressFormatException" ]
    (defn #_"BigInteger" Base58'decode-to-big-integer [#_"String" input]
        (BigInteger. 1, (Base58'decode input))
    )

    ;;;
     ; Decodes the given base58 string into the original data bytes, using the checksum in the
     ; last 4 bytes of the decoded data to verify that the rest are correct.  The checksum is
     ; removed from the returned data.
     ;
     ; @param input the base58-encoded string to decode (which should include the checksum)
     ; @throws AddressFormatException if the input is not base 58 or the checksum does not validate
     ;;
    #_throws #_[ "AddressFormatException" ]
    (defn #_"byte[]" Base58'decode-checked [#_"String" input]
        (let [#_"byte[]" decoded (Base58'decode input) #_"int" n (count decoded)]
            (when (< n 4)
                (throw+ (AddressFormatException'new "Input too short"))
            )
            (let [#_"byte[]" data (Arrays/copyOfRange decoded, 0, (- n 4))
                  #_"byte[]" checksum (Arrays/copyOfRange decoded, (- n 4), n)
                  #_"byte[]" expected (Arrays/copyOfRange (Sha256Hash'hash-twice data), 0, 4)]
                (when-not (Arrays/equals checksum, expected)
                    (throw+ (AddressFormatException'new "Checksum does not validate"))
                )
                data
            )
        )
    )

    ;;;
     ; Divides a number, represented as an array of bytes each containing a single digit
     ; in the specified base, by the given divisor.  The given number is modified in-place
     ; to contain the quotient, and the return value is the remainder.
     ;
     ; @param number the number to divide
     ; @param firstDigit the index within the array of the first non-zero digit
     ;        (this is used for optimization by skipping the leading zeros)
     ; @param base the base in which the number's digits are represented (up to 256)
     ; @param divisor the number to divide by (up to 256)
     ; @return the remainder of the division operation
     ;;
    (defn- #_"byte" Base58'divmod [#_"byte[]" number, #_"int" __firstDigit, #_"int" base, #_"int" divisor]
        ;; This is just long division which accounts for the base of the input digits.
        (loop-when [#_"int" remainder 0 #_"int" i __firstDigit] (< i (count number)) => (byte remainder)
            (let [#_"int" digit (& (int (nth number i)) 0xff) #_"int" temp (+ (* remainder base) digit)]
                (aset number i (byte (quot temp divisor)))
                (recur (rem temp divisor) (inc i))
            )
        )
    )
)

(class-ns BitcoinPacketHeader
    ;;;
     ; The largest number of bytes that a header can represent.
     ;;
    (ยง def #_"int" BitcoinPacketHeader'HEADER_LENGTH (+ Wire'COMMAND_LEN 4 4))

    #_throws #_[ "ProtocolException", "BufferUnderflowException" ]
    (defn #_"BitcoinPacketHeader" BitcoinPacketHeader'new [#_"ByteBuffer" in]
        (let [#_"int" n BitcoinPacketHeader'HEADER_LENGTH #_"byte[]" header (byte-array n) _ (.get in, header)
              ;; The command is a NUL terminated string, unless the command fills all twelve bytes, in which case the termination is implicit.
              #_"int" n Wire'COMMAND_LEN #_"int" i (loop-when-recur [i 0] (and (< i n) (not= (nth header i) 0)) [(inc i)] => i)
              #_"byte[]" command (byte-array i) _ (System/arraycopy header, 0, command, 0, i)
              #_"int" size (int (Wire'bget-uint32 header, n))]
            (when-not (<= 0 size Message'MAX_SIZE)
                (throw+ (ProtocolException'new (str "Message size too large: " size)))
            )
            ;; Old clients don't send the checksum.
            ;; Note that the size read above includes the checksum bytes.
            (let [#_"byte[]" checksum (byte-array 4) _ (System/arraycopy header, (+ n 4), checksum, 0, 4)]
                (hash-map
                    #_"String" :command (String. command, Charset'US-ASCII)
                    #_"int" :size size
                    #_"byte[]" :checksum checksum
                )
            )
        )
    )
)

;;;
 ; Serialize and de-serialize messages to the Bitcoin network format as defined in
 ; <a href="https://en.bitcoin.it/wiki/Protocol_specification">the protocol specification</a>.
 ;;
#_stateless
(class-ns Wire
    (def- #_"int" Wire'COMMAND_LEN 12)

    ;;;
     ; Writes message to the output stream.
     ;;
    (defn #_"void" Wire'serialize-4 [#_"Ledger" ledger, #_"String" name, #_"byte[]" message, #_"ByteArrayOutputStream" baos]
        (let [#_"byte[]" header (byte-array (+ 4 Wire'COMMAND_LEN 4 4))] ;; checksum
            (Wire'bset-uint32be (:packet-magic ledger), header, 0)

            ;; The header array is initialized to zero by Java so we don't have to worry
            ;; about NULL terminating the string here.
            (loop-when-recur [#_"int" i 0] (and (< i (.length name)) (< i Wire'COMMAND_LEN)) [(inc i)]
                (aset header (+ 4 i) (byte (& (.codePointAt name, i) 0xff)))
            )

            (Wire'bset-uint32 (count message), header, (+ 4 Wire'COMMAND_LEN))

            (let [#_"byte[]" hash (Sha256Hash'hash-twice message)]
                (System/arraycopy hash, 0, header, (+ 4 Wire'COMMAND_LEN 4), 4)
                (.write baos, header)
                (.write baos, message)
            )
        )
        nil
    )

    ;;;
     ; Writes message to the output stream.
     ;;
    (defn #_"void" Wire'serialize-3 [#_"Ledger" ledger, #_"Message" message, f'to-wire, #_"ByteArrayOutputStream" baos]
        (let [#_"String" name (f'to-wire)]
            (if (some? name)
                (Wire'serialize-4 ledger, name, (Message''to-bytes message, f'to-wire), baos)
                (throw (RuntimeException. (str "Wire doesn't currently know how to serialize " message)))
            )
        )
        nil
    )

    #_throws #_[ "BufferUnderflowException" ]
    (defn #_"void" Wire'seek-past-magic-bytes [#_"Ledger" ledger, #_"ByteBuffer" in]
        ;; We're looking for a run of bytes that is the same as the packet magic but we want to ignore
        ;; incomplete patterns, so we keep track of where we're up to with 'i.
        (let [#_"long" magic (:packet-magic ledger)]
            (loop [i 3]
                (if (= (.get in) (byte (& 0xff (>>> magic (<< i 3)))))
                    (recur-if (< 0 i) (dec i)) ;; Else we found the magic sequence.
                    (recur 3)
                )
            )
        )
        nil
    )

    #_throws #_[ "ProtocolException" ]
    (defn- #_"Message" Wire'make-message [#_"Ledger" ledger, #_"String" command, #_"ByteBuffer" payload]
        (case command
            "version"     (VersionMessage'from-wire ledger, payload)
            "inv"         (InventoryMessage'from-wire ledger, payload)
            "block"       (Block'from-wire ledger, payload)
            "merkleblock" (FilteredBlock'from-wire ledger, payload)
            "getdata"     (GetDataMessage'from-wire ledger, payload)
            "getblocks"   (GetBlocksMessage'from-wire ledger, payload)
            "getheaders"  (GetHeadersMessage'from-wire ledger, payload)
            "tx"          (Transaction'from-wire ledger, payload)
            "addr"        (AddressMessage'from-wire ledger, payload)
            "ping"        (Ping'from-wire ledger, payload)
            "pong"        (Pong'from-wire ledger, payload)
            "verack"      (VersionAck'new ledger)
            "headers"     (HeadersMessage'from-wire ledger, payload)
            "filterload"  (BloomFilter'from-wire ledger, payload)
            "notfound"    (NotFoundMessage'from-wire ledger, payload)
            "mempool"     (MemoryPoolMessage'new ledger)
            "reject"      (RejectMessage'from-wire ledger, payload)
                      (do
                          (log/warn (str "No support for deserializing message with name " command))
                          (UnknownMessage'from-wire ledger, payload, command)
                      )
        )
    )

    ;;;
     ; Deserialize payload only.  You must provide a header, typically obtained by calling
     ; {@link Wire#deserializeHeader}.
     ;;
    #_throws #_[ "ProtocolException", "BufferUnderflowException" ]
    (defn #_"Message" Wire'deserialize-payload [#_"Ledger" ledger, #_"BitcoinPacketHeader" header, #_"ByteBuffer" in]
        (let [#_"byte[]" payload (byte-array (:size header)) _ (.get in, payload)
              #_"byte[]" hash (Sha256Hash'hash-twice payload) #_"byte[]" checksum (:checksum header)]
            ;; Verify the checksum.
            (when-not (and (= (nth checksum 0) (nth hash 0)) (= (nth checksum 1) (nth hash 1)) (= (nth checksum 2) (nth hash 2)) (= (nth checksum 3) (nth hash 3)))
                (throw+ (ProtocolException'new (str "Checksum failed to verify, actual " (Base16'encode hash) " vs " (Base16'encode checksum))))
            )

            (try
                (Wire'make-message ledger, (:command header), (ByteBuffer/wrap payload))
                (catch Exception e
                    (throw+ (ProtocolException'new (str "Error deserializing message " (Base16'encode payload) "\n")) e)
                )
            )
        )
    )

    ;;;
     ; Reads a message from the given ByteBuffer and returns it.
     ;;
    #_throws #_[ "ProtocolException", "IOException" ]
    (defn #_"Message" Wire'deserialize [#_"Ledger" ledger, #_"ByteBuffer" in]
        ;; A Bitcoin protocol message has the following format:
        ;;
        ;;   - 4 byte magic number: 0xfabfb5da for the testnet or 0xf9beb4d9 for production
        ;;   - 12 byte command in ASCII
        ;;   - 4 byte payload size
        ;;   - 4 byte checksum
        ;;   - Payload data
        ;;
        ;; The checksum is the first 4 bytes of a SHA256 hash of the message payload. It isn't
        ;; present for all messages, notably, the first one on a connection.
        ;;
        ;; Bitcoin Core ignores garbage before the magic header bytes. We have to do the same because
        ;; sometimes it sends us stuff that isn't part of any message.
        (Wire'seek-past-magic-bytes ledger, in)
        ;; Now try to read the whole message.
        (Wire'deserialize-payload ledger, (BitcoinPacketHeader'new in), in)
    )
)

;;;
 ; Flags used to control which elements of block validation are done on received blocks.
 ;;
(def BlockVerifyFlag'enum-set
    (hash-set
        ;;; Check that block height is in coinbase transaction (BIP 34). ;;
        :BlockVerifyFlag'HEIGHT_IN_COINBASE
    )
)

;;;
 ; A block is a group of transactions, and is one of the fundamental data structures of the Bitcoin system.
 ; It records a set of {@link Transaction}s together with some data that links it into a place in the global block chain,
 ; and proves that a difficult calculation was done over its contents.
 ; See <a href="http://www.bitcoin.org/bitcoin.pdf">the Bitcoin technical paper</a> for more detail on blocks.
 ;
 ; To get a block, you can either build one from the raw bytes you can get from another implementation, or request one
 ; specifically using {@link Peer#getBlock(Sha256Hash)}, or grab one from a downloaded {@link SPVBlockChain}.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns Block (ยง extends Message)
    ;;; How many bytes are required to represent a block header WITHOUT the trailing 00 length byte. ;;
    (def #_"int" Block'HEADER_SIZE 80)

    (def #_"long" Block'ALLOWED_TIME_DRIFT (* 2 60 60)) ;; Same value as Bitcoin Core.

    ;;;
     ; A constant shared by the entire network: how large in bytes a block is allowed to be.  One day we may have to
     ; upgrade everyone to change this, so Bitcoin can continue to grow.  For now it exists as an anti-DoS measure to
     ; avoid somebody creating a titanically huge but valid block and forcing everyone to download/store it forever.
     ;;
    (def #_"int" Block'MAX_BLOCK_SIZE (* 1 1000 1000))
    ;;;
     ; A "sigop" is a signature verification operation.  Because they're expensive, we also impose a separate limit on
     ; the number in a block to prevent somebody mining a huge block that has way more sigops than normal, so is very
     ; expensive/slow to verify.
     ;;
    (def #_"int" Block'MAX_BLOCK_SIGOPS (quot Block'MAX_BLOCK_SIZE 50))

    ;;; A value for difficultyTarget (nBits) that allows half of all possible hash solutions. ;;
    (def #_"long" Block'EASIEST_DIFFICULTY_TARGET 0x207fffff)

    ;;; Value to use if the block height is unknown. ;;
    (def #_"int" Block'BLOCK_HEIGHT_UNKNOWN -1)
    ;;; Height of the first block. ;;
    (def #_"int" Block'BLOCK_HEIGHT_GENESIS 0)

    (def #_"long" Block'BLOCK_VERSION_GENESIS 1)
    ;;; Block version introduced in BIP 34: Height in coinbase. ;;
    (def #_"long" Block'BLOCK_VERSION_BIP34 2)
    ;;; Block version introduced in BIP 66: Strict DER signatures. ;;
    (def #_"long" Block'BLOCK_VERSION_BIP66 3)
    ;;; Block version introduced in BIP 65: OP_CHECKLOCKTIMEVERIFY ;;
    (def #_"long" Block'BLOCK_VERSION_BIP65 4)

    (defn- #_"Block" Block'init []
        (hash-map
            ;;;
             ; The version of the block data structure.
             ;;
            #_"long" :version 0
            ;;;
             ; The hash of the previous block in the chain.
             ;;
            #_"Sha256Hash" :prev-block-hash nil
            ;;;
             ; The time at which the block was solved and broadcast according to the clock of the solving node.
             ; This is measured in seconds since the UNIX epoch (midnight Jan 1st 1970).
             ;;
            #_"long" :time-seconds 0
            ;;;
             ; The difficulty of the proof of work that this block should meet (encoded in <b>compact form</b>).
             ; The block chain verifies that this is not too easy by looking at the length of the chain when the block is added.
             ; To find the actual value the hash should be compared against, use {@link Block#getDifficultyTargetAsInteger()}.
             ; Note that this is <b>not</b> the same as the difficulty value reported by the Bitcoin "getdifficulty" RPC
             ; that you may see on various block explorers.
             ; That number is the result of applying a formula to the underlying difficulty to normalize the minimum to 1.
             ; Calculating the difficulty that way is currently unsupported.
             ;;
            #_"long" :difficulty-target 0 ;; "nBits"
            ;;;
             ; The nonce, an arbitrary value that exists only to make the hash of the block header fall below the difficulty target.
             ;;
            #_"long" :nonce 0
            ;;;
             ; If null, it means this object holds only the headers.
             ;;
            #_"List<Transaction>" :transactions nil
        )
    )

    ;;;
     ; Special case constructor, used for the genesis node, cloneAsHeader and unit tests.
     ;;
    (defn #_"Block" Block'new-genesis [#_"Ledger" ledger, #_"long" version]
        (let [this (merge (Message'new ledger) (Block'init))

              ;; Set up a few basic things.  We are not complete after this though.
              this (assoc this :version version)
              this (assoc this :prev-block-hash Sha256Hash'ZERO_HASH)
              this (assoc this :time-seconds (Time'seconds))
              this (assoc this :difficulty-target 0x1d07fff8)]
            this
        )
    )

    ;;;
     ; Construct a block initialized with all the given fields.
     ;
     ; @param ledger Which network the block is for.
     ; @param version This should usually be set to 1 or 2, depending on if the height is in the coinbase input.
     ; @param prevBlockHash Reference to previous block in the chain or {@link Sha256Hash#ZERO_HASH} if genesis.
     ; @param time UNIX time when the block was mined.
     ; @param difficultyTarget Number which this block hashes lower than.
     ; @param nonce Arbitrary number to make the block hash lower than the target.
     ; @param transactions List of transactions including the coinbase.
     ;;
    (defn #_"Block" Block'new [#_"Ledger" ledger, #_"long" version, #_"Sha256Hash" prior, #_"long" time, #_"long" difficulty, #_"long" nonce, #_"List<Transaction>" transactions]
        (let [this (merge (Message'new ledger) (Block'init))

              this (assoc this :version version)
              this (assoc this :prev-block-hash prior)
              this (assoc this :time-seconds time)
              this (assoc this :difficulty-target difficulty)
              this (assoc this :nonce nonce)
              this (assoc this :transactions (LinkedList.)) _ (ยง ass this (update this :transactions .addAll transactions))]
            this
        )
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"Block" Block'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload]
        (let [this (merge (Message'new ledger) (Block'init))]

            ;; header
            (let [this (assoc this :version (Wire'read-uint32 payload))
                  this (assoc this :prev-block-hash (Wire'read-hash payload))
                  _ (Wire'read-hash payload) ;; merkle root
                  this (assoc this :time-seconds (Wire'read-uint32 payload))
                  this (assoc this :difficulty-target (Wire'read-uint32 payload))
                  this (assoc this :nonce (Wire'read-uint32 payload))]

                ;; transactions
                (when (.hasRemaining payload) => this
                    (let [#_"int" n (int (Wire'read-var-int payload)) #_"List<Transaction>" txns (ArrayList. n)]
                        (dotimes [_ n]
                            (let [#_"Transaction" tx (Transaction'from-wire ledger, payload)]
                                ;; Label the transaction as coming from the P2P network, so code that cares where we first saw it knows.
                                (ยง ass (Transaction''get-confidence tx) (assoc (Transaction''get-confidence tx) :confidence-source :ConfidenceSource'NETWORK))
                                (ยง ass txns (.add txns, tx))
                            )
                        )
                        (assoc this :transactions txns)
                    )
                )
            )
        )
    )

    #_method
    (defn- #_"void" Block''write-header [#_"Block" this, #_"ByteArrayOutputStream" baos]
        (Wire'write-uint32 (:version this), baos)
        (.write baos, (Wire'reverse-bytes (:hash-bytes (:prev-block-hash this))))
        (.write baos, (Wire'reverse-bytes (:hash-bytes (Block''calculate-merkle-root this))))
        (Wire'write-uint32 (:time-seconds this), baos)
        (Wire'write-uint32 (:difficulty-target this), baos)
        (Wire'write-uint32 (:nonce this), baos)
        nil
    )

    #_method
    (defn- #_"void" Block''write-transactions [#_"Block" this, #_"ByteArrayOutputStream" baos]
        (when-let [#_"List<Transaction>" transactions (:transactions this)]
            (.write baos, (VarInt''encode (VarInt'new (count transactions))))
            (doseq [#_"Transaction" tx transactions]
                (Transaction''to-wire tx, baos)
            )
        )
        nil
    )

    #_method
    (defn Block''to-wire
        (#_"String" [] "block")
        (#_"void" [#_"Block" this, #_"ByteArrayOutputStream" baos]
            (Block''write-header this, baos)
            ;; We may only have enough data to write the header.
            (Block''write-transactions this, baos)
            nil
        )
    )

    ;;;
     ; A utility method that calculates how much new Bitcoin would be created by the block at the given height.
     ; The inflation of Bitcoin is predictable and drops roughly every 4 years (210,000 blocks).  At the dawn of
     ; the system it was 50 coins per block, in late 2012 it went to 25 coins per block, and so on.  The size of
     ; a coinbase transaction is inflation plus fees.
     ;
     ; The half-life is controlled by {@link Ledger#getSubsidyDecreaseBlockCount()}.
     ;;
    #_method
    (defn #_"Coin" Block''get-block-inflation [#_"Block" this, #_"int" height]
        (Coin''shift-right Coin'FIFTY_COINS, (quot height (-> this :ledger :subsidy-decrease-block-count)))
    )

    ;;;
     ; Calculates the block hash by serializing the block and hashing the resulting bytes.
     ;;
    #_method
    (defn- #_"Sha256Hash" Block''calculate-hash [#_"Block" this]
        (let [#_"ByteArrayOutputStream" baos (ByteArrayOutputStream. Block'HEADER_SIZE)]
            (Block''write-header this, baos)
            (Sha256Hash'wrap (Wire'reverse-bytes (Sha256Hash'hash-twice (.toByteArray baos))))
        )
    )

    ;;;
     ; Returns the hash of the block (which for a valid, solved block should be below the target).  Big endian.
     ;;
    #_method
    (defn #_"Sha256Hash" Block''get-hash [#_"Block" this]
        (Block''calculate-hash this)
    )

    ;;;
     ; Returns the hash of the block (which for a valid, solved block should be below the target)
     ; in the form seen on the block explorer.  If you call this on block 1 in the mainnet chain,
     ; you will get "00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048".
     ;;
    #_method
    (defn #_"String" Block''get-hash-as-base16 [#_"Block" this]
        (Sha256Hash''to-base16 (Block''get-hash this))
    )

    ;;;
     ; The number that is one greater than the largest representable SHA-256 hash.
     ;;
    (def- #_"BigInteger" Block'LARGEST_HASH (.shiftLeft BigInteger/ONE, 256))

    ;;;
     ; Returns the work represented by this block.
     ;
     ; Work is defined as the number of tries needed to solve a block in the
     ; average case.  Consider a difficulty target that covers 5% of all possible
     ; hash values.  Then the work of the block will be 20.  As the target gets
     ; lower, the amount of work goes up.
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn #_"BigInteger" Block''get-work [#_"Block" this]
        (let [#_"BigInteger" target (Block''get-difficulty-target-as-integer this)]
            (.divide Block'LARGEST_HASH, (.add target, BigInteger/ONE))
        )
    )

    ;;; Returns a copy of the block, but without any transactions. ;;
    #_method
    (defn #_"Block" Block''clone-as-header [#_"Block" this]
        (assoc (Block'new-genesis (:ledger this), Block'BLOCK_VERSION_GENESIS)
            :nonce (:nonce this),
            :prev-block-hash (:prev-block-hash this),
            :version (:version this),
            :time-seconds (:time-seconds this),
            :difficulty-target (:difficulty-target this),
            :transactions nil
        )
    )

    ;;;
     ; Finds a value of nonce that makes the blocks hash lower than the difficulty target.
     ; This is called mining, but solve() is far too slow to do real mining with.
     ;
     ; This can loop forever if a solution cannot be found solely by incrementing nonce.
     ; It doesn't change extraNonce.
     ;;
    #_method
    (defn #_"Block" Block''solve [#_"Block" this]
        (while
            ;; Is our proof of work valid yet?
            (if (Block''check-proof-of-work this, false)
                false
                (do
                    ;; No, so increment the nonce and try again.
                    (ยง ass this (update this :nonce inc))
                    true
                )
            )
        )
        this
    )

    ;;;
     ; Returns the difficulty target as a 256 bit value that can be compared to a SHA-256 hash.  Inside a block the
     ; target is represented using a compact form.  If this form decodes to a value that is out of bounds, an exception
     ; is thrown.
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn #_"BigInteger" Block''get-difficulty-target-as-integer [#_"Block" this]
        (let [#_"BigInteger" target (Utils'decode-compact-bits (:difficulty-target this))]
            (when-not (and (pos? (.signum target)) (<= target (-> this :ledger :max-target)))
                (throw+ (VerificationException'new (str "Difficulty target is bad: " target)))
            )
            target
        )
    )

    ;;;
     ; Returns true if the hash of the block is not higher than the difficulty target.
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn #_"boolean" Block''check-proof-of-work [#_"Block" this, #_"boolean" throw?]
        ;; This part is key - it is what proves the block was as difficult to make as it claims
        ;; to be.  Note however that in the context of this function, the block can claim to be
        ;; as difficult as it wants to be .... if somebody was able to take control of our network
        ;; connection and fork us onto a different chain, they could send us valid blocks with
        ;; ridiculously easy difficulty and this function would accept them.
        ;;
        ;; To prevent this attack from being possible, elsewhere we check that the difficultyTarget
        ;; field is of the right value.  This requires us to have the preceeding blocks.
        (let [#_"BigInteger" target (Block''get-difficulty-target-as-integer this) #_"Sha256Hash" hash (Block''get-hash this)]
            (when (< target (Sha256Hash''to-big-integer hash)) => true
                ;; Proof of work check failed!
                (when throw? => false
                    (throw+ (VerificationException'new (str "Hash is higher than the target: " hash " vs " (.toString target, 16))))
                )
            )
        )
    )

    #_throws #_[ "VerificationException" ]
    #_method
    (defn- #_"void" Block''check-timestamp [#_"Block" this]
        (let [#_"long" drift (+ (Time'seconds) Block'ALLOWED_TIME_DRIFT)]
            (when (< drift (:time-seconds this))
                (throw+ (VerificationException'new (str "Block too far in future: " (Time'format-seconds (:time-seconds this)) " (" (:time-seconds this) ") vs allowed " (Time'format-seconds drift) " (" drift ")")))
            )
        )
        nil
    )

    #_throws #_[ "VerificationException" ]
    #_method
    (defn- #_"void" Block''check-sig-ops [#_"Block" this]
        ;; Ensure that there aren't too many signature verifications in the block.
        ;; This is an anti-DoS measure, see the comments for MAX_BLOCK_SIGOPS.
        (when (< Block'MAX_BLOCK_SIGOPS (reduce + (map Transaction''get-sig-op-count (:transactions this))))
            (throw+ (VerificationException'new "Block had too many Signature Operations"))
        )
        nil
    )

    ;; The Merkle root is based on a tree of hashes calculated from the transactions:
    ;;
    ;;     root
    ;;     /  \
    ;;   A      B
    ;;  / \    / \
    ;; t1 t2  t3 t4
    ;;
    ;; The tree is represented as a list: (t1 t2 t3 t4 A B root), where each entry is a hash.
    ;;
    ;; The hashing algorithm is double SHA-256.  The leaves are a hash of the serialized contents of the transaction.
    ;; The interior nodes are hashes of the concenation of the two child hashes.
    ;;
    ;; This structure allows the creation of proof that a transaction was included into a block without having to
    ;; provide the full block contents.  Instead, you can provide only a Merkle branch.  For example to prove tx2 was
    ;; in a block you can just provide tx2, the hash(tx1) and B.  Now the other party has everything they need to
    ;; derive the root, which can be checked against the block header.  These proofs aren't used right now but
    ;; will be helpful later when we want to download partial block contents.
    ;;
    ;; Note that if the number of transactions is not even, the last tx is repeated to make it so (see tx3 above).
    ;; A tree with 5 transactions would look like this:
    ;;
    ;;          root
    ;;        /      \
    ;;      1          5
    ;;    /   \       / \
    ;;   2     3     4   4
    ;;  / \   / \   / \
    ;; t1 t2 t3 t4 t5 t5

    #_method
    (defn- #_"List<byte[]>" Block''build-merkle-tree [#_"Block" this]
        (let [#_"List<byte[]>" tree (ArrayList.)]
            ;; Start by adding all the hashes of the transactions as leaves of the tree.
            (doseq [#_"Transaction" tx (:transactions this)]
                (ยง ass tree (.add tree, (:hash-bytes (Transaction''get-hash tx))))
            )
            ;; Offset in the list is where the currently processed level starts.
            ;; Step through each level, stopping when we reach the root (size == 1).                  ;; Move to the next level.
            (loop-when-recur [#_"int" offset 0 #_"int" size (count (:transactions this))] (< 1 size) [(+ offset size) (quot (inc size) 2)]
                ;; For each pair of nodes on that level:
                (loop-when-recur [#_"int" left 0] (< left size) [(+ left 2)]
                    ;; The right hand node can be the same as the left hand, in the case where we don't have enough transactions.
                    (let [#_"int" right (min (inc left), (dec size))
                          #_"byte[]" __leftBytes (Wire'reverse-bytes (nth tree (+ offset left)))
                          #_"byte[]" __rightBytes (Wire'reverse-bytes (nth tree (+ offset right)))]
                        (ยง ass tree (.add tree, (Wire'reverse-bytes (Sha256Hash'hash-twins-twice __leftBytes, 0, 32, __rightBytes, 0, 32))))
                    )
                )
            )
            tree
        )
    )

    ;;;
     ; Calculates the merkle root in big endian form from transactions.
     ;;
    #_method
    (defn- #_"Sha256Hash" Block''calculate-merkle-root [#_"Block" this]
        (let [#_"List<byte[]>" tree (Block''build-merkle-tree this)]
            (Sha256Hash'wrap (nth tree (dec (count tree))))
        )
    )

    ;;;
     ; Verify the transactions on a block.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;               If provided, used to validate the coinbase input script of v2 and above blocks.
     ; @throws VerificationException if there was an error verifying the block.
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn- #_"void" Block''check-transactions [#_"Block" this, #_"int" height, #_"{BlockVerifyFlag}" flags]
        ;; The first transaction in a block must always be a coinbase transaction.
        (when-not (Transaction''is-coin-base (nth (:transactions this) 0))
            (throw+ (VerificationException'new "First tx is not coinbase"))
        )

        (when (and (contains? flags :BlockVerifyFlag'HEIGHT_IN_COINBASE) (<= Block'BLOCK_HEIGHT_GENESIS height))
            (Transaction''check-coin-base-height (nth (:transactions this) 0), height)
        )

        ;; The rest must not be.
        (loop-when-recur [#_"int" i 1] (< i (count (:transactions this))) [(inc i)]
            (when (Transaction''is-coin-base (nth (:transactions this) i))
                (throw+ (VerificationException'new (str "TX " i " is coinbase when it should not be.")))
            )
        )
        nil
    )

    ;;;
     ; Checks the block data to ensure it follows the rules laid out in the network parameters.  Specifically,
     ; throws an exception if the proof of work is invalid, or if the timestamp is too far from what it should be.
     ; This is <b>not</b> everything that is required for a block to be valid, only what is checkable independent
     ; of the chain and without a transaction index.
     ;
     ; @throws VerificationException
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn #_"void" Block''verify-header [#_"Block" this]
        ;; Prove that this block is OK.  It might seem that we can just ignore most of these checks given that the
        ;; network is also verifying the blocks, but we cannot as it'd open us to a variety of obscure attacks.
        ;;
        ;; Firstly we need to ensure this block does in fact represent real work done.  If the difficulty is high
        ;; enough, it's probably been done by the network.
        (Block''check-proof-of-work this, true)
        (Block''check-timestamp this)
        nil
    )

    ;;;
     ; Checks the block contents.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ;               If valid, used to validate the coinbase input script of v2 and above blocks.
     ; @param flags Flags to indicate which tests should be applied (i.e. whether to test for height in the coinbase transaction).
     ; @throws VerificationException if there was an error verifying the block.
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn #_"void" Block''verify-transactions [#_"Block" this, #_"int" height, #_"{BlockVerifyFlag}" flags]
        ;; Now we need to check that the body of the block actually matches the headers.  The network won't generate
        ;; an invalid block, but if we didn't validate this then an untrusted man-in-the-middle could obtain the next
        ;; valid block from the network and simply replace the transactions in it with their own fictional
        ;; transactions that reference spent or non-existant inputs.
        (when (empty? (:transactions this))
            (throw+ (VerificationException'new "Block had no transactions"))
        )
        (Block''check-transactions this, height, flags)
        (Block''check-sig-ops this)
        (doseq [#_"Transaction" tx (:transactions this)]
            (Transaction''verify tx)
        )
        nil
    )

    ;;;
     ; Verifies both the header and that the transactions hash to the merkle root.
     ;
     ; @param height Block height, if known, or -1 otherwise.
     ; @param flags Flags to indicate which tests should be applied (i.e. whether to test for height in the coinbase transaction).
     ; @throws VerificationException if there was an error verifying the block.
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn #_"void" Block''verify [#_"Block" this, #_"int" height, #_"{BlockVerifyFlag}" flags]
        (Block''verify-header this)
        (Block''verify-transactions this, height, flags)
        nil
    )

    ;;;
     ; Adds a transaction to this block.  The nonce and merkle root are invalid after this.
     ;;
    #_method
    (defn #_"Block" Block''add-transaction [#_"Block" this, #_"Transaction" tx]
        (let [#_"List<Transaction>" txns (or (:transactions this) (ArrayList.))]
            (when (and (not (seq txns)) (not (Transaction''is-coin-base tx)))
                (throw (RuntimeException. (str "Attempted to add a non-coinbase transaction as the first transaction: " tx)))
            )
            (when (and (seq txns) (Transaction''is-coin-base tx))
                (throw (RuntimeException. (str "Attempted to add a coinbase transaction when there already is one: " tx)))
            )
            (ยง ass txns (.add txns, tx))
            (assoc this :transactions txns)
        )
    )

    ;;;
     ; Returns whether this block conforms to
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0034.mediawiki">BIP34: Height in Coinbase</a>.
     ;;
    #_method
    (defn #_"boolean" Block''is-bip34 [#_"Block" this]
        (<= Block'BLOCK_VERSION_BIP34 (:version this))
    )

    ;;;
     ; Returns whether this block conforms to
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki">BIP66: Strict DER signatures</a>.
     ;;
    #_method
    (defn #_"boolean" Block''is-bip66 [#_"Block" this]
        (<= Block'BLOCK_VERSION_BIP66 (:version this))
    )

    ;;;
     ; Returns whether this block conforms to
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki">BIP65: OP_CHECKLOCKTIMEVERIFY</a>.
     ;;
    #_method
    (defn #_"boolean" Block''is-bip65 [#_"Block" this]
        (<= Block'BLOCK_VERSION_BIP65 (:version this))
    )

    #_foreign
    #_override
    (defn #_"boolean" Object'''equals [#_"Block" this, #_"Object" o]
        (cond
            (= this o) true
            (or (nil? o) (not= (.getClass this) (.getClass o))) false
            :else (= (Block''get-hash this) (Block''get-hash (cast' Block o)))
        )
    )

    #_foreign
    #_override
    (defn #_"int" Object'''hashCode [#_"Block" this]
        (.hashCode (Block''get-hash this))
    )

    ;;;
     ; Returns a multi-line string containing a description of the contents of the block.
     ; Use for debugging purposes only.
     ;;
    #_method
    (defn #_"String" Block''to-string [#_"Block" this]
        (let [#_"StringBuilder" sb (StringBuilder. (<< 1 8))]
            (.. sb (append " block: \n"))
            (.. sb (append "   hash: ") (append (Block''get-hash this)) (append "\n"))
            (.. sb (append "   version: ") (append (:version this)))
            (let [#_"String" bips
                    (apply str (interpose ", " (filter some?
                        [(when (Block''is-bip34 this) "BIP34"), (when (Block''is-bip66 this) "BIP66"), (when (Block''is-bip65 this) "BIP65")]))
                    )]
                (when (seq bips)
                    (.. sb (append " (") (append bips) (append ")"))
                )
            )
            (.. sb (append "\n"))
            (.. sb (append "   previous block: ") (append (:prev-block-hash this)) (append "\n"))
            (.. sb (append "   merkle root: ") (append (Block''calculate-merkle-root this)) (append "\n"))
            (.. sb (append "   time: ") (append (:time-seconds this)) (append " (") (append (Time'format-seconds (:time-seconds this))) (append ")\n"))
            (.. sb (append "   difficulty target (nBits): ") (append (:difficulty-target this)) (append "\n"))
            (.. sb (append "   nonce: ") (append (:nonce this)) (append "\n"))
            (when (seq (:transactions this))
                (.. sb (append "   with ") (append (count (:transactions this))) (append " transaction(s):\n"))
                (doseq [#_"Transaction" tx (:transactions this)]
                    (.. sb (append tx))
                )
            )
            (.toString sb)
        )
    )
)

;;;
 ; A SPVBlockChain implements the <i>simplified payment verification</i> mode of the Bitcoin protocol.  It is the right
 ; choice to use for programs that have limited resources as it won't verify transactions signatures or attempt to store
 ; all of the block chain.
 ;;
(class-ns SPVBlockChain (ยง extends BlockChain)
    ;;;
     ; Constructs a block chain connected to any wallets and a store.
     ;
     ; Having no wallets at all might be helpful when you don't actually care about sending
     ; and receiving coins but rather, just want to explore the network data structures.
     ;
     ; For the store, you should use {@link SPVBlockStore} or you could also try a {@link MemoryBlockStore}
     ; if you want to hold all headers in RAM and don't care about disk serialization (this is rare).
     ;;
    #_throws #_[ "BlockStoreException" ]
    (defn #_"SPVBlockChain" SPVBlockChain'new [#_"Ledger" ledger, #_"BlockStore" store & #_"Wallet..." wallets]
        (merge (BlockChain'new ledger, store, wallets)
            (hash-map
                ;;;
                 ; Keeps a map of block hashes to StoredBlocks.
                 ;;
                #_"BlockStore" :block-store store
            )
        )
    )

    #_throws #_[ "BlockStoreException", "VerificationException" ]
    #_override
    (defn #_"StoredBlock" BlockChain'''add-to-block-store-3 [#_"SPVBlockChain" this, #_"StoredBlock" prior, #_"Block" block]
        (let [#_"StoredBlock" stored (StoredBlock''build prior, block)]
            (ยง ass this (update this :block-store BlockStore'''put stored))
            stored
        )
    )

    #_throws #_[ "BlockStoreException", "VerificationException" ]
    #_override
    (defn #_"StoredBlock" BlockChain'''add-to-block-store-4 [#_"SPVBlockChain" this, #_"StoredBlock" prior, #_"Block" header, #_"TransactionOutputChanges" changes]
        (let [#_"StoredBlock" stored (StoredBlock''build prior, header)]
            (ยง ass this (update this :block-store BlockStore'''put stored))
            stored
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"SPVBlockChain" BlockChain'''rollback-block-store [#_"SPVBlockChain" this, #_"int" height]
        (sync (:blockchain-lock this)
            (let [#_"int" best (BlockChain''get-best-chain-height this)]
                (assert-argument (<= 0 height best), (str "Bad height: " height))

                (when-not (= height best) => this
                    ;; Look for the block we want to be the new chain head.
                    (let [#_"StoredBlock" head
                            (loop-when [head (BlockStore'''get-chain-head (:block-store this))] (< height (:stored-height head)) => head
                                (let [head (StoredBlock''get-prev head, (:block-store this))]
                                    (recur-if (some? head) head => (throw+ (BlockStoreException'new "Unreachable height")))
                                )
                            )
                          ;; Modify store directly.
                          this (update this :block-store BlockStore'''put head)]
                        (BlockChain''set-chain-head this, head)
                    )
                )
            )
        )
    )

    #_override
    (defn #_"boolean" BlockChain'''should-verify-transactions [#_"SPVBlockChain" __]
        false
    )

    #_override
    (defn #_"TransactionOutputChanges" BlockChain'''connect-transactions-3 [#_"SPVBlockChain" this, #_"int" height, #_"Block" block]
        ;; Don't have to do anything as this is only called if shouldVerifyTransactions().
        (throw (UnsupportedOperationException.))
    )

    #_override
    (defn #_"TransactionOutputChanges" BlockChain'''connect-transactions-2 [#_"SPVBlockChain" this, #_"StoredBlock" stored]
        ;; Don't have to do anything as this is only called if shouldVerifyTransactions().
        (throw (UnsupportedOperationException.))
    )

    #_override
    (defn #_"void" BlockChain'''disconnect-transactions [#_"SPVBlockChain" this, #_"StoredBlock" block]
        ;; Don't have to do anything as this is only called if shouldVerifyTransactions().
        (throw (UnsupportedOperationException.))
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"SPVBlockChain" BlockChain'''do-set-chain-head [#_"SPVBlockChain" this, #_"StoredBlock" head]
        (update this :block-store BlockStore'''set-chain-head head)
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"void" BlockChain'''not-setting-chain-head [#_"SPVBlockChain" __]
        ;; We don't use DB transactions here, so we don't need to do anything.
        nil
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"StoredBlock" BlockChain'''get-stored-block-in-current-scope [#_"SPVBlockChain" this, #_"Sha256Hash" hash]
        (BlockStore'''get (:block-store this), hash)
    )

    #_throws #_[ "VerificationException", "PrunedException" ]
    #_override
    (defn #_"[SPVBlockChain boolean]" BlockChain'''add-filtered-block [#_"SPVBlockChain" this, #_"FilteredBlock" filtered]
        (let [[this success?] (BlockChain'''add-filtered-block (ยง this super), filtered)
              this
                (when success? => this
                    (BlockChain''track-filtered-transactions this, (FilteredBlock''get-transaction-count filtered))
                )]
            [this success?]
        )
    )
)

;;;
 ; The BLOOM_UPDATE_* constants control when the bloom filter is auto-updated by the peer using
 ; it as a filter, either never, for all outputs or only for pay-2-pubkey outputs (default).
 ;;
(def BloomUpdate'enum-map
    (hash-map
        :BloomUpdate'UPDATE_NONE          0,
        :BloomUpdate'UPDATE_ALL           1,
        ;;; Only adds outpoints to the filter if the output is a pay-to-pubkey/pay-to-multisig script. ;;
        :BloomUpdate'UPDATE_P2PUBKEY_ONLY 2,
    )
)

(def BloomUpdate'for-code (clojure.set/map-invert BloomUpdate'enum-map))

;;;
 ; A Bloom filter is a probabilistic data structure which can be sent to another client so that it can avoid
 ; sending us transactions that aren't relevant to our set of keys.  This allows for significantly more efficient
 ; use of available network bandwidth and CPU time.
 ;
 ; Because a Bloom filter is probabilistic, it has a configurable false positive rate.  So the filter will sometimes
 ; match transactions that weren't inserted into it, but it will never fail to match transactions that were.  This is
 ; a useful privacy feature - if you have spare bandwidth the false positive rate can be increased so the remote peer
 ; gets a noisy picture of what transactions are relevant to your wallet.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns BloomFilter (ยง extends Message)
    ;; Same value as of Bitcoin Core.
    ;; A filter of 20,000 items and a false positive rate of 0.1% or one of 10,000 items and 0.0001% is just under 36,000 bytes.
    (def- #_"long" BloomFilter'MAX_FILTER_SIZE 36000)
    ;; There is little reason to ever have more hash functions than 50 given a limit of 36,000 bytes.
    (def- #_"int" BloomFilter'MAX_HASH_FUNCS 50)

    (defn- #_"BloomFilter" BloomFilter'init []
        (hash-map
            #_"byte[]" :bloom-bits nil
            #_"long" :hash-funcs 0
            #_"long" :bloom-tweak 0
            #_"byte" :update-code 0
        )
    )

    ;;;
     ; Constructs a new Bloom Filter which will provide approximately the given false positive rate when the given
     ; number of elements have been inserted.  If the filter would otherwise be larger than the maximum allowed size,
     ; it will be automatically downsized to the maximum size.
     ;
     ; To check the theoretical false positive rate of a given filter, use {@link BloomFilter#getFalsePositiveRate(int)}.
     ;
     ; The anonymity of which coins are yours to any peer which you send a BloomFilter to is controlled by the
     ; false positive rate.  For reference, as of block 187,000, the total number of addresses used in the chain was
     ; roughly 4.5 million.  Thus, if you use a false positive rate of 0.001 (0.1%), there will be, on average, 4,500
     ; distinct public keys/addresses which will be thought to be yours by nodes which have your bloom filter, but
     ; which are not actually yours.  Keep in mind that a remote node can do a pretty good job estimating the order of
     ; magnitude of the false positive rate of a given filter you provide it when considering the anonymity of a given
     ; filter.
     ;
     ; In order for filtered block download to function efficiently, the number of matched transactions in any given
     ; block should be less than (with some headroom) the maximum size of the MemoryPool used by the Peer
     ; doing the downloading (default is {@link TxConfidenceTable#MAX_SIZE}).
     ; See the comment in processBlock(FilteredBlock) for more information on this restriction.
     ;
     ; randomNonce is a tweak for the hash function used to prevent some theoretical DoS attacks.
     ; It should be a random value, however secureness of the random value is of no great consequence.
     ;
     ; updateFlag is used to control filter behaviour on the server (remote node) side when it encounters a hit.
     ; See {@link BloomFilter.BloomUpdate} for a brief description of each mode.  The purpose of this flag
     ; is to reduce network round-tripping and avoid over-dirtying the filter for the most common
     ; wallet configurations.
     ;;
    (defn #_"BloomFilter" BloomFilter'new [#_"Ledger" ledger, #_"int" size, #_"double" rate, #_"long" tweak, #_"BloomUpdate" flag]
        (let [this (merge (Message'new ledger) (BloomFilter'init))]

            ;; The following formulas were stolen from Wikipedia's page on Bloom Filters (with the addition of min(..., MAX_...)).
            ;; Size required for a given number of elements and false-positive rate.
            (let [#_"int" n (int (* (/ -1 (Math/pow (Math/log 2), 2)) size (Math/log rate)))
                  n (max 1 (quot (min n (* (int BloomFilter'MAX_FILTER_SIZE) 8)) 8))
                  ;; Optimal number of hash functions for a given filter size and element count.
                  #_"int" m (int (* (/ (* n 8) (double size)) (Math/log 2)))
                  m (max 1 (min m BloomFilter'MAX_HASH_FUNCS))]

                (-> this
                    (assoc :bloom-bits (byte-array n))
                    (assoc :hash-funcs m)
                    (assoc :bloom-tweak tweak)
                    (assoc :update-code (byte (& 0xff (BloomUpdate'enum-map flag))))
                )
            )
        )
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"BloomFilter" BloomFilter'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload]
        (let [this (merge (Message'new ledger) (BloomFilter'init))
              this
                (-> this
                    (assoc :bloom-bits (Wire'read-byte-array payload))
                    (assoc :hash-funcs (Wire'read-uint32 payload))
                    (assoc :bloom-tweak (Wire'read-uint32 payload))
                    (assoc :update-code (Wire'read-byte payload))
                )]
            (when (< BloomFilter'MAX_FILTER_SIZE (count (:bloom-bits this)))
                (throw+ (ProtocolException'new "Bloom filter out of size range."))
            )
            (when (< BloomFilter'MAX_HASH_FUNCS (:hash-funcs this))
                (throw+ (ProtocolException'new "Bloom filter hash function count out of range."))
            )
            this
        )
    )

    #_method
    (defn BloomFilter''to-wire
        (#_"String" [] "filterload")
        (#_"void" [#_"BloomFilter" this, #_"ByteArrayOutputStream" baos]
            (Wire'write-byte-array (:bloom-bits this), baos)
            (Wire'write-uint32 (:hash-funcs this), baos)
            (Wire'write-uint32 (:bloom-tweak this), baos)
            (.write baos, (:update-code this))
            nil
        )
    )

    ;;;
     ; Returns the theoretical false positive rate of this filter if were to contain the given number of elements.
     ;;
    #_method
    (defn #_"double" BloomFilter''get-false-positive-rate [#_"BloomFilter" this, #_"int" elements]
        (Math/pow (- 1 (Math/pow Math/E, (/ (* -1.0 (:hash-funcs this) elements) (* (count (:bloom-bits this)) 8)))), (:hash-funcs this))
    )

    ;;;
     ; Applies the MurmurHash3 (x86_32) algorithm to the given data.
     ; See <a href="https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp">this C++ code</a> for the original.
     ;;
    (defn #_"int" BloomFilter'murmur-hash3 [#_"int" l, #_"long" tweak, #_"int" h, #_"byte[]" data]
        (ยง let [#_"int" m (& (count data) (bit-not 3)) #_"int" n (& (count data) 3)
              read- #_"int" (fn [#_"byte[]" data, #_"int" i] (| (& 0xff (nth data i))
                                                            (<< (& 0xff (nth data (inc i))) 8)
                                                            (<< (& 0xff (nth data (+ i 2))) 16)
                                                            (<< (& 0xff (nth data (+ i 3))) 24)))
              swap- #_"int" (fn [#_"int" x, #_"int" r] (| (<< x r) (>>> x (- 32 r))))
              h (loop-when [h (-> h (* 0xfba4c795) (+ tweak) (int)) #_"int" i 0] (< i m) => h
                    (let [#_"int" k (-> (read- data, i) (* 0xcc9e2d51) (swap- 15) (* 0x1b873593))]
                        (recur (-> h (bit-xor k) (swap- 13) (* 5) (+ 0xe6546b64)) (+ i 4))
                    )
                )
              h (when (< 0 n) => h
                    (let [#_"int" k 0
                          k (if (< 2 n) (bit-xor k (<< (& 0xff (nth data (+ m 2))) 16)) k)
                          k (if (< 1 n) (bit-xor k (<< (& 0xff (nth data (inc m))) 8)) k)
                          k (-> k (bit-xor (& 0xff (nth data m))) (* 0xcc9e2d51) (swap- 15) (* 0x1b873593))]
                        (bit-xor h k)
                    )
                )
              h (bit-xor h (count data))
              h (bit-xor h (>>> h 16))
              h (* h 0x85ebca6b)
              h (bit-xor h (>>> h 13))
              h (* h 0xc2b2ae35)
              h (bit-xor h (>>> h 16))]

            (int (rem (& h 0xffffffff) (<< l 3)))
        )
    )

    ;;;
     ; Returns true if the given data matches the filter either because it was inserted, or because we have a false-positive.
     ;;
    #_method
    (defn #_"boolean" BloomFilter''contains [#_"BloomFilter" this, #_"byte[]" data]
        (sync this
            (loop-when [#_"int" i 0] (< i (:hash-funcs this)) => true
                (recur-if (Utils'check-bit-le (:bloom-bits this), (BloomFilter'murmur-hash3 (count (:bloom-bits this)), (:bloom-tweak this), i, data)) [(inc i)] => false)
            )
        )
    )

    ;;;
     ; Inserts the given arbitrary data into the filter.
     ;;
    #_method
    (defn #_"BloomFilter" BloomFilter''insert-data [#_"BloomFilter" this, #_"byte[]" data]
        (sync this
            (loop-when-recur [#_"int" i 0] (< i (:hash-funcs this)) [(inc i)]
                (Utils'set-bit-le (:bloom-bits this), (BloomFilter'murmur-hash3 (count (:bloom-bits this)), (:bloom-tweak this), i, data))
            )
            this
        )
    )

    ;;;
     ; Inserts the given key and equivalent hashed form (for the address).
     ;;
    #_method
    (defn #_"BloomFilter" BloomFilter''insert-key [#_"BloomFilter" this, #_"ECKey" key]
        (sync this
            (-> this
                (BloomFilter''insert-data (ECKey''get-pub-key key))
                (BloomFilter''insert-data (ECKey''calculate-pub-key-hash160 key))
            )
        )
    )

    ;;;
     ; Sets this filter to match all objects.  A Bloom filter which matches everything may seem pointless, however,
     ; it is useful in order to reduce steady state bandwidth usage when you want full blocks.  Instead of receiving
     ; all transaction data twice, you will receive the vast majority of all transactions just once, at broadcast time.
     ; Solved blocks will then be send just as Merkle trees of tx hashes, meaning a constant 32 bytes of data for each
     ; transaction instead of 100-300 bytes as per usual.
     ;;
    #_method
    (defn #_"BloomFilter" BloomFilter''set-match-all [#_"BloomFilter" this]
        (sync this
            (assoc this :bloom-bits (byte-array [ (byte 0xff) ]))
        )
    )

    ;;;
     ; Copies filter into this.  Filter must have the same size, hash function count and nTweak or
     ; an IllegalArgumentException will be thrown.
     ;;
    #_method
    (defn #_"BloomFilter" BloomFilter''merge [#_"BloomFilter" this, #_"BloomFilter" that]
        (sync this
            (when-not (or (BloomFilter''matches-all this) (BloomFilter''matches-all that)) => (BloomFilter''set-match-all this)
                (assert-argument (and (= (count (:bloom-bits that)) (count (:bloom-bits this)))
                                      (= (:hash-funcs that) (:hash-funcs this))
                                      (= (:bloom-tweak that) (:bloom-tweak this))))

                (dotimes [#_"int" i (count (:bloom-bits this))]
                    (aset (:bloom-bits this) i (| (nth (:bloom-bits this) i) (nth (:bloom-bits that) i)))
                )
                this
            )
        )
    )

    ;;;
     ; Returns true if this filter will match anything.  See {@link BloomFilter#setMatchAll()} for
     ; when this can be a useful thing to do.
     ;;
    #_method
    (defn #_"boolean" BloomFilter''matches-all [#_"BloomFilter" this]
        (sync this
            (every? #(= % (byte 0xff)) (:bloom-bits this))
        )
    )

    ;;;
     ; The update flag controls how application of the filter to a block modifies the filter.  See
     ; the enum javadocs for information on what occurs and when.
     ;;
    #_method
    (defn #_"BloomUpdate" BloomFilter''get-update-flag [#_"BloomFilter" this]
        (sync this
            (BloomUpdate'for-code (:update-code this), (throw (IllegalStateException. (str "Unknown update flag: " (:update-code this)))))
        )
    )

    ;;;
     ; Creates a new FilteredBlock from the given Block, using this filter to select transactions.  Matches
     ; can cause the filter to be updated with the matched element, this ensures that when a filter is applied
     ; to a block, spends of matched transactions are also matched.  However it means this filter can be mutated
     ; by the operation.  The returned filtered block already has the matched transactions associated with it.
     ;;
    #_method
    (defn #_"FilteredBlock" BloomFilter''apply-and-update-b [#_"BloomFilter" this, #_"Block" block]
        (sync this
            (let [#_"List<Transaction>" txns (:transactions block)
                  #_"List<Sha256Hash>" hashes (ArrayList. (count txns))
                  #_"List<Transaction>" matched (ArrayList.)
                  #_"byte[]" bits (byte-array (int (Math/ceil (/ (count txns) 8.0))))]
                (dotimes [#_"int" i (count txns)]
                    (let [#_"Transaction" tx (nth txns i)]
                        (ยง ass hashes (.add hashes, (Transaction''get-hash tx)))
                        (when (BloomFilter''apply-and-update-t this, tx)
                            (Utils'set-bit-le bits, i)
                            (ยง ass matched (.add matched, tx))
                        )
                    )
                )
                (let [#_"PartialMerkleTree" merkle (PartialMerkleTree'build-from-leaves (:ledger block), bits, hashes)
                      #_"FilteredBlock" filtered (FilteredBlock'new (:ledger block), (Block''clone-as-header block), merkle)]
                    (doseq [#_"Transaction" tx matched]
                        (FilteredBlock''provide-transaction filtered, tx)
                    )
                    filtered
                )
            )
        )
    )

    #_method
    (defn #_"boolean" BloomFilter''apply-and-update-t [#_"BloomFilter" this, #_"Transaction" tx]
        (letfn [#_"boolean" (chunk-found? [#_"ScriptChunk" %] (and (ScriptChunk''is-push-data %) (BloomFilter''contains this, (:data %))))
                #_"boolean" (input-found? [#_"TransactionInput" %]
                    (or (BloomFilter''contains this, (Message''to-bytes (:outpoint %), TransactionOutPoint''to-wire))
                        (some chunk-found? (:chunks (TransactionInput''get-script-sig %)))
                    )
                )]
            (sync this
                (or (BloomFilter''contains this, (:hash-bytes (Transaction''get-hash tx)))
                    (let [#_"BloomUpdate" flag (BloomFilter''get-update-flag this)
                          #_"boolean'" found? (atom false)]
                        (doseq [#_"TransactionOutput" output (:outputs tx)]
                            (let [#_"Script" script (TransactionOutput''parse-script-pub-key output)]
                                (when (some chunk-found? (:chunks script))
                                    (when (or (= flag :BloomUpdate'UPDATE_ALL) (and (= flag :BloomUpdate'UPDATE_P2PUBKEY_ONLY) (or (Script''is-sent-to-raw-pub-key script) (Script''is-sent-to-multi-sig script))))
                                        (ยง ass this (BloomFilter''insert-data this, (Message''to-bytes (TransactionOutput''get-outpoint-for output), TransactionOutPoint''to-wire)))
                                    )
                                    (reset! found? true)
                                )
                            )
                        )
                        (or @found? (some input-found? (:inputs tx)))
                    )
                )
            )
        )
    )

    (defn #_"boolean" BloomFilter'= [#_"BloomFilter" this, #_"BloomFilter" that]
        (sync this
            (and (= (:hash-funcs this) (:hash-funcs that)) (= (:bloom-tweak this) (:bloom-tweak that)) (Arrays/equals (:bloom-bits this), (:bloom-bits that)))
        )
    )

    #_method
    (defn #_"String" BloomFilter''to-string [#_"BloomFilter" this]
        (str "Bloom Filter of size " (count (:bloom-bits this)) " with " (:hash-funcs this) " hash functions.")
    )
)

;;;
 ; Vends hard-coded {@link StoredBlock}s for blocks throughout the chain.  Checkpoints serve two purposes:
 ; <ol>
 ;    <li>They act as a safety mechanism against huge re-orgs that could rewrite large chunks of history, thus
 ;    constraining the block chain to be a consensus mechanism only for recent parts of the timeline.</li>
 ;    <li>They allow synchronization to the head of the chain for new wallets/users much faster than syncing all
 ;    headers from the genesis block.</li>
 ; </ol>
 ;
 ; Checkpoints are used by the {@link SPVBlockChain} to initialize fresh {@link SPVBlockStore}s.
 ; They are not used by fully validating mode, which instead has a different concept of checkpoints that are used
 ; to hard-code the validity of blocks that violate BIP30 (duplicate coinbase transactions).
 ; Those "checkpoints" can be found in Ledger.
 ;
 ; The file format consists of the string "CHECKPOINTS 1", followed by a uint32 containing the number of signatures
 ; to read.  The value may not be larger than 256 (so it could have been a byte but isn't for historical reasons).
 ; If the number of signatures is larger than zero, each 65 byte ECDSA secp256k1 signature then follows.  The signatures
 ; sign the hash of all bytes that follow the last signature.
 ;
 ; After the signatures come an int32 containing the number of checkpoints in the file.  Then each checkpoint follows
 ; one after the other.  A checkpoint is 12 bytes for the total work done field, 4 bytes for the height, 80 bytes
 ; for the block header and then 1 zero byte at the end (i.e. number of transactions in the block: always zero).
 ;;
(class-ns CheckpointManager
    ;;;
     ; Loads the checkpoints from the given seq.
     ;;
    #_throws #_[ "IOException" ]
    (defn #_"CheckpointManager" CheckpointManager'new [#_"Ledger" ledger, #_"String*" checkpoints]
        (ensure some? ledger)
        (let [checkpoints (or checkpoints (:textual-checkpoints ledger))]
            (ensure some? checkpoints)
            (let [this
                    (hash-map
                        #_"Ledger" :ledger ledger
                        ;;; Map of block header time to data. ;;
                        #_"TreeMap<Long, StoredBlock>" :checkpoints (TreeMap.)
                        ;;; Hash of the concatenated checkpoint data. ;;
                        #_"Sha256Hash" :data-hash nil
                    )]
                (assoc this :data-hash (CheckpointManager''read-textual this, checkpoints))
            )
        )
    )

    (def #_"BaseEncoding" CheckpointManager'BASE64 (.omitPadding (BaseEncoding/base64)))

    #_throws #_[ "IOException" ]
    #_method
    (defn- #_"Sha256Hash" CheckpointManager''read-textual [#_"CheckpointManager" this, #_"String*" checkpoints]
        (assert-state (seq checkpoints))

        (let [#_"Hasher" hasher (.newHasher (Hashing/sha256))]
            (.putBytes hasher, (.array (.putInt (.order (ByteBuffer/allocate 4), ByteOrder/BIG_ENDIAN), (count checkpoints))))
            (let [#_"ByteBuffer" buffer (ByteBuffer/allocate StoredBlock'COMPACT_SERIALIZED_SIZE)]
                (doseq [#_"String" checkpoint checkpoints]
                    (let [#_"byte[]" bytes (.decode CheckpointManager'BASE64, checkpoint)]
                        (.putBytes hasher, bytes)
                        (.position buffer, 0)
                        (.put buffer, bytes)
                        (.position buffer, 0)
                        (let [#_"StoredBlock" block (StoredBlock'deserialize-compact (:ledger this), buffer)]
                            (ยง ass this (update this :checkpoints assoc (:time-seconds (:stored-header block)) block))
                        )
                    )
                )
                (let [#_"HashCode" hash (.hash hasher)]
                    (log/info (str "Read " (count (:checkpoints this)) " checkpoints, hash is " hash))
                    (Sha256Hash'wrap (.asBytes hash))
                )
            )
        )
    )

    ;;;
     ; Returns a {@link StoredBlock} representing the last checkpoint before the given time, for example, normally
     ; you would want to know the checkpoint before the earliest wallet birthday.
     ;;
    #_method
    (defn #_"StoredBlock" CheckpointManager''get-checkpoint-before [#_"CheckpointManager" this, #_"long" time]
        (assert-argument (< (:time-seconds (-> this :ledger :genesis-block)) time))

        ;; This is thread safe because the map never changes after creation.
        (let [#_"Map.Entry<Long, StoredBlock>" entry (.floorEntry (:checkpoints this), time)]
            (if (some? entry)
                (.getValue entry)
                (let [#_"Block" genesis (Block''clone-as-header (-> this :ledger :genesis-block))]
                    (StoredBlock'new genesis, (Block''get-work genesis), 0)
                )
            )
        )
    )

    ;;;
     ; Convenience method that creates a CheckpointManager, loads the given data, gets the checkpoint for the given
     ; time, then inserts it into the store and sets that to be the chain head.  Useful when you have just created
     ; a new store from scratch and want to use configure it all in one go.
     ;
     ; Note that time is adjusted backwards by a week to account for possible clock drift in the block headers.
     ;;
    #_throws #_[ "IOException", "BlockStoreException" ]
    (defn #_"void" CheckpointManager'checkpoint [#_"Ledger" ledger, #_"String*" checkpoints, #_"BlockStore" store, #_"long" time]
        (ensure some? ledger)
        (ensure some? store)
        (assert-argument (not (ยง instance? FullPrunedBlockStore store)), "You cannot use checkpointing with a full store.")

        (let [time (- time (* 86400 7))]
            (assert-argument (pos? time))

            (log/info (str "Attempting to initialize a new block store with a checkpoint for time " time " (" (Time'format-seconds time) ")"))

            (let [#_"StoredBlock" checkpoint (CheckpointManager''get-checkpoint-before (CheckpointManager'new ledger, checkpoints), time)]
                (ยง ass store (BlockStore'''put store, checkpoint))
                (ยง ass store (BlockStore'''set-chain-head store, checkpoint))
            )
        )
        nil
    )
)

;;;
 ; Groups the two components that make up a signature, and provides a way to encode to DER form, which is
 ; how ECDSA signatures are represented when embedded in other data structures in the Bitcoin protocol.
 ; The raw components can be useful for doing further EC maths on them.
 ;;
(class-ns ECDSASignature
    ;;;
     ; Constructs a signature with the given components.  Does NOT automatically canonicalise the signature.
     ;;
    (defn #_"ECDSASignature" ECDSASignature'new [#_"BigInteger" r, #_"BigInteger" s]
        (hash-map
            ;;; The two components of the signature. ;;
            #_"BigInteger" :r r
            #_"BigInteger" :s s
        )
    )

    ;;;
     ; Returns true if the S component is "low", that means it is below {@link ECKey#HALF_CURVE_ORDER}.  See
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki#Low_S_values_in_signatures">BIP62</a>.
     ;;
    #_method
    (defn #_"boolean" ECDSASignature''is-canonical [#_"ECDSASignature" this]
        (<= (:s this) ECKey'HALF_CURVE_ORDER)
    )

    ;;;
     ; Will automatically adjust the S component to be less than or equal to half the curve order, if necessary.
     ; This is required because for every signature (r, s) the signature (r, -s (mod N)) is a valid signature of
     ; the same message.  However, we dislike the ability to modify the bits of a Bitcoin transaction after it's
     ; been signed, as that violates various assumed invariants.  Thus in future only one of those forms will be
     ; considered legal and the other will be banned.
     ;;
    #_abstract
    (defn #_"ECDSASignature" ECDSASignature'''to-canonicalised [#_"ECDSASignature" this]
        ;; The order of the curve is the number of valid points that exist on that curve.  If S is in the upper
        ;; half of the number of valid points, then bring it back to the lower half.  Otherwise, imagine that
        ;;    N = 10
        ;;    s = 8, so (-8 % 10 == 2) thus both (r, 8) and (r, 2) are valid solutions.
        ;;    10 - 8 == 2, giving us always the latter solution, which is canonical.
        (if (ECDSASignature''is-canonical this) this (ECDSASignature'new (:r this), (.subtract (.getN ECKey'CURVE), (:s this))))
    )

    ;;;
     ; DER is an international standard for serializing data structures which is widely used in cryptography.
     ; It's somewhat like protocol buffers but less convenient.  This method returns a standard DER encoding
     ; of the signature, as recognized by OpenSSL and other libraries.
     ;;
    #_method
    (defn #_"byte[]" ECDSASignature''encode-to-der [#_"ECDSASignature" this]
        (.toByteArray (ECDSASignature''der-byte-stream this))
    )

    #_throws #_[ "IllegalArgumentException" ]
    (defn #_"ECDSASignature" ECDSASignature'decode-from-der [#_"byte[]" bytes]
        (let [#_"ASN1InputStream" decoder (ASN1InputStream. bytes)]
            (try
                (let [#_"DLSequence" seq (cast DLSequence (.readObject decoder))]
                    (when (nil? seq)
                        (throw (IllegalArgumentException. "Reached past end of ASN.1 stream."))
                    )

                    (let [[#_"ASN1Integer" r #_"ASN1Integer" s]
                            (try
                                [(cast ASN1Integer (.getObjectAt seq, 0)) (cast ASN1Integer (.getObjectAt seq, 1))]
                                (catch ClassCastException e
                                    (throw (IllegalArgumentException. e))
                                )
                            )]
                        ;; OpenSSL deviates from the DER spec by interpreting these values as unsigned, though they should not be.
                        ;; Thus, we always use the positive versions.  See http://r6.ca/blog/20111119T211504Z.html
                        (ECDSASignature'new (.getPositiveValue r), (.getPositiveValue s))
                    )
                )
                (catch IOException e
                    (throw (IllegalArgumentException. e))
                )
                (finally
                    (try
                        (.close decoder)
                        (catch IOException _
                        )
                    )
                )
            )
        )
    )

    #_method
    (defn #_"ByteArrayOutputStream" ECDSASignature''der-byte-stream [#_"ECDSASignature" this]
        ;; Usually 70-72 bytes.
        (let [#_"ByteArrayOutputStream" baos (ByteArrayOutputStream. 72) #_"DERSequenceGenerator" seq (DERSequenceGenerator. baos)]
            (.addObject seq, (ASN1Integer. (:r this)))
            (.addObject seq, (ASN1Integer. (:s this)))
            (.close seq)
            baos
        )
    )
)

(class-ns MissingPrivateKeyException (ยง extends RuntimeException)
    (defn #_"MissingPrivateKeyException" MissingPrivateKeyException'new []
        (RuntimeException'new)
    )
)

;;;
 ; Represents an elliptic curve public and (optionally) private key, usable for digital signatures but not encryption.
 ; Creating a new ECKey with the empty constructor will generate a new random keypair.  Other static methods can be used
 ; when you already have the public or private parts.  If you create a key with only the public part, you can check
 ; signatures but not create them.
 ;
 ; ECKey also provides access to Bitcoin Core compatible text message signing, as accessible via the UI or JSON-RPC.
 ; This is slightly different to signing raw bytes - if you want to sign your own data and it won't be exposed as
 ; text to people, you don't want to use this.  If in doubt, ask on the mailing list.
 ;
 ; The ECDSA algorithm supports <i>key recovery</i> in which a signature plus a couple of discriminator bits can
 ; be reversed to find the public key used to calculate it.  This can be convenient when you have a message and a
 ; signature and want to find out who signed it, rather than requiring the user to provide the expected identity.
 ;
 ; This class supports a variety of serialization forms.  The methods that accept/return byte arrays serialize
 ; private keys as raw byte arrays and public keys using the SEC standard byte encoding for public keys.  Signatures
 ; are encoded using ASN.1/DER inside the Bitcoin protocol.
 ;
 ; A key can be <i>compressed</i> or <i>uncompressed</i>.  This refers to whether the public key is represented
 ; when encoded into bytes as an (x, y) coordinate on the elliptic curve, or whether it's represented as just an X
 ; co-ordinate and an extra byte that carries a sign bit.  With the latter form the Y coordinate can be calculated
 ; dynamically, however, <b>because the binary serialization is different the address of a key changes if its
 ; compression status is changed</b>.  If you deviate from the defaults it's important to understand this: money sent
 ; to a compressed version of the key will have a different address to the same key in uncompressed form.  Whether
 ; a public key is compressed or not is recorded in the SEC binary serialisation format, and preserved in a flag in
 ; this class so round-tripping preserves state.  Unless you're working with old software or doing unusual things,
 ; you can usually ignore the compressed/uncompressed distinction.
 ;;
(class-ns ECKey
    ;; The parameters of the secp256k1 curve that Bitcoin uses.
    (def- #_"X9ECParameters" ECKey'CURVE_PARAMS
        (let [#_"X9ECParameters" secp256k1 (CustomNamedCurves/getByName "secp256k1")]
            ;; Tell Bouncy Castle to precompute data that's needed during secp256k1 calculations.  Increasing the
            ;; width number makes calculations faster, but at a cost of extra memory usage and with decreasing returns.
            (FixedPointUtil/precompute (.getG secp256k1), 12) ;; 12 was picked after consulting with the BC team.
            secp256k1
        )
    )

    ;;; The parameters of the secp256k1 curve that Bitcoin uses. ;;
    (def #_"ECDomainParameters" ECKey'CURVE (ECDomainParameters. (.getCurve ECKey'CURVE_PARAMS), (.getG ECKey'CURVE_PARAMS), (.getN ECKey'CURVE_PARAMS), (.getH ECKey'CURVE_PARAMS)))

    ;;;
     ; Equal to CURVE.getN().shiftRight(1), used for canonicalising the S value of a signature.
     ; If you aren't sure what this is about, you can ignore it.
     ;;
    (def #_"BigInteger" ECKey'HALF_CURVE_ORDER (.shiftRight (.getN ECKey'CURVE_PARAMS), 1))

    (def- #_"SecureRandom" ECKey'SECURE_RANDOM (SecureRandom.))

    (defn- #_"ECKey" ECKey'init [#_"BigInteger" priv, #_"ECPoint" pub, #_"long" secs]
        (hash-map
            ;; The two parts of the key.  If "priv" is set, "pub" can always be calculated.
            ;; If "pub" is set, but not "priv", we can only verify signatures, not make them.
            #_"BigInteger" :priv priv ;; A field element.
            ;;;
             ; The public key in the form of an elliptic curve point object from Bouncy Castle.
             ;;
            #_"ECPoint" :pub pub

            ;; Creation time of the key in seconds since the epoch, or zero if the key was
            ;; deserialized from a version that did not have this field.
            #_"long" :creation-time-seconds secs
        )
    )

    ;;;
     ; Generates an entirely new keypair.  Point compression is used so the resulting public key will be 33 bytes
     ; (32 for the co-ordinate and 1 byte to represent the y bit).
     ;;
    (defn #_"ECKey" ECKey'new []
        (ECKey'from-random ECKey'SECURE_RANDOM)
    )

    ;;;
     ; Generates an entirely new keypair with the given {@link SecureRandom} object.  Point compression is used so
     ; the resulting public key will be 33 bytes (32 for the co-ordinate and 1 byte to represent the y bit).
     ;;
    (defn #_"ECKey" ECKey'from-random [#_"SecureRandom" random]
        (let [#_"ECKeyPairGenerator" generator (ECKeyPairGenerator.) _ (.init generator, (ECKeyGenerationParameters. ECKey'CURVE, random))
              #_"AsymmetricCipherKeyPair" keypair (.generateKeyPair generator)
              #_"BigInteger" priv (.getD (cast ECPrivateKeyParameters (.getPrivate keypair)))
              #_"ECPoint" pub (.decodePoint (.getCurve ECKey'CURVE), (.getEncoded (.getQ (cast ECPublicKeyParameters (.getPublic keypair))), true))]
            (ECKey'init priv, pub, (Time'seconds))
        )
    )

    (defn- #_"ECKey" ECKey'compose [#_"BigInteger" priv, #_"ECPoint" pub]
        (when (some? priv)
            (assert-argument (<= (.bitLength priv) (<< 32 3)), (str "private key exceeds 32 bytes: " (.bitLength priv) " bits"))
            ;; Try and catch buggy callers or bad key imports, etc.  Zero and one are special because these are often
            ;; used as sentinel values and because scripting languages have a habit of auto-casting true and false to
            ;; 1 and 0 or vice-versa.  Type confusion bugs could therefore result in private keys with these values.
            (assert-argument (not (= priv BigInteger/ZERO)))
            (assert-argument (not (= priv BigInteger/ONE)))
        )
        (ECKey'init priv, (ensure some? pub), 0)
    )

    ;;;
     ; Utility for compressing an elliptic curve point.  Returns the same point if it's already compressed.
     ; See the ECKey class docs for a discussion of point compression.
     ;;
    (defn #_"ECPoint" ECKey'compress-point [#_"ECPoint" point]
        (ECKey'get-point-with-compression point, true)
    )

    ;;;
     ; Utility for decompressing an elliptic curve point.  Returns the same point if it's already compressed.
     ; See the ECKey class docs for a discussion of point compression.
     ;;
    (defn #_"ECPoint" ECKey'decompress-point [#_"ECPoint" point]
        (ECKey'get-point-with-compression point, false)
    )

    (defn- #_"ECPoint" ECKey'get-point-with-compression [#_"ECPoint" point, #_"boolean" compressed?]
        (if (= (.isCompressed point) compressed?)
            point
            (let [point (.normalize point)
                  #_"BigInteger" x (Sha256Hash''to-big-integer (.getAffineXCoord point))
                  #_"BigInteger" y (Sha256Hash''to-big-integer (.getAffineYCoord point))]
                (.createPoint (.getCurve ECKey'CURVE), x, y, compressed?)
            )
        )
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow).
     ;;
    (defn #_"ECKey" ECKey'from-private [#_"BigInteger" priv, #_"boolean" compressed?]
        (let [#_"ECPoint" point (ECKey'public-point-from-private priv)]
            (ECKey'compose priv, (ECKey'get-point-with-compression point, compressed?))
        )
    )

    ;;;
     ; Creates an ECKey given the private key only.  The public key is calculated from it (this is slow).
     ;;
    (defn #_"ECKey" ECKey'from-private-bytes [#_"byte[]" bytes, #_"boolean" compressed?]
        (ECKey'from-private (BigInteger. 1, bytes), compressed?)
    )

    ;;;
     ; Creates an ECKey that simply trusts the caller to ensure that point is really the result of multiplying the
     ; generator point by the private key.  This is used to speed things up when you know you have the right values
     ; already.  The compression state of pub will be preserved.
     ;;
    (defn #_"ECKey" ECKey'from-private-and-precalculated-public [#_"BigInteger" priv, #_"ECPoint" pub]
        (ECKey'compose priv, pub)
    )

    ;;;
     ; Creates an ECKey that simply trusts the caller to ensure that point is really the result of multiplying the
     ; generator point by the private key.  This is used to speed things up when you know you have the right values
     ; already.  The compression state of the point will be preserved.
     ;;
    (defn #_"ECKey" ECKey'from-private-and-precalculated-public-bytes [#_"byte[]" priv, #_"byte[]" pub]
        (ensure some? priv)
        (ensure some? pub)
        (ECKey'compose (BigInteger. 1, priv), (.decodePoint (.getCurve ECKey'CURVE), pub))
    )

    ;;;
     ; Creates an ECKey that cannot be used for signing, only verifying signatures, from the given point.
     ; The compression state of pub will be preserved.
     ;;
    (defn #_"ECKey" ECKey'from-public-only [#_"ECPoint" pub]
        (ECKey'compose nil, pub)
    )

    ;;;
     ; Creates an ECKey that cannot be used for signing, only verifying signatures, from the given encoded point.
     ; The compression state of pub will be preserved.
     ;;
    (defn #_"ECKey" ECKey'from-public-only-bytes [#_"byte[]" pub]
        (ECKey'compose nil, (.decodePoint (.getCurve ECKey'CURVE), pub))
    )

    ;;;
     ; Returns whether this key is using the compressed form or not.  Compressed pubkeys are only 33 bytes, not 64.
     ;;
    #_method
    (defn #_"boolean" ECKey''is-compressed [#_"ECKey" this]
        (.isCompressed (:pub this))
    )

    ;;;
     ; Returns a copy of this key, but with the public point represented in uncompressed form.  Normally you would
     ; never need this: it's for specialised scenarios or when backwards compatibility in encoded form is necessary.
     ;;
    #_method
    (defn #_"ECKey" ECKey''decompress [#_"ECKey" this]
        (if (.isCompressed (:pub this)) (ECKey'compose (:priv this), (ECKey'decompress-point (:pub this))) this)
    )

    ;;;
     ; Returns true if this key doesn't have unencrypted access to private key bytes.  This may be because
     ; it was never given any private key bytes to begin with (a watching key), or because the key is encrypted.
     ; You can use {@link #isEncrypted()} to tell the cases apart.
     ;;
    #_abstract
    (defn #_"boolean" ECKey'''is-pub-key-only [#_"ECKey" this]
        (nil? (:priv this))
    )

    ;;;
     ; Returns true if this key has unencrypted access to private key bytes.
     ; Does the opposite of {@link #isPubKeyOnly()}.
     ;;
    #_abstract
    (defn #_"boolean" ECKey'''has-priv-key [#_"ECKey" this]
        (some? (:priv this))
    )

    ;;;
     ; Returns true if this key is watch only, meaning it has a public key but no private key.
     ;;
    #_method
    (defn #_"boolean" ECKey''is-watching [#_"ECKey" this]
        (ECKey'''is-pub-key-only this)
    )

    ;;;
     ; Returns public key bytes from the given private key.  To convert a byte array into a BigInteger, use <tt>new BigInteger(1, bytes)</tt>.
     ;;
    (defn #_"byte[]" ECKey'public-key-from-private [#_"BigInteger" priv, #_"boolean" compressed?]
        (.getEncoded (ECKey'public-point-from-private priv), compressed?)
    )

    ;;;
     ; Returns public key point from the given private key.  To convert a byte array into a BigInteger, use <tt>new BigInteger(1, bytes)</tt>.
     ;;
    (defn #_"ECPoint" ECKey'public-point-from-private [#_"BigInteger" priv]
        ;; TODO: FixedPointCombMultiplier currently doesn't support scalars longer than the group order,
        ;; but that could change in future versions.
        (let [priv (if (< (.bitLength (.getN ECKey'CURVE)) (.bitLength priv)) (.mod priv, (.getN ECKey'CURVE)) priv)]
            (.multiply (FixedPointCombMultiplier.), (.getG ECKey'CURVE), priv)
        )
    )

    ;;;
     ; Calculates the hash160 form of the public key (as seen in addresses).
     ;;
    #_method
    (defn #_"byte[]" ECKey''calculate-pub-key-hash160 [#_"ECKey" this]
        (Utils'sha256hash160 (ECKey''get-pub-key this))
    )

    ;;;
     ; Gets the raw public key value.  This appears in transaction scriptSigs.  Note that this is <b>not</b>
     ; the same as the pubKeyHash/address.
     ;;
    #_method
    (defn #_"byte[]" ECKey''get-pub-key [#_"ECKey" this]
        (.getEncoded (:pub this))
    )

    ;;;
     ; Gets the private key in the form of an integer field element.  The public key is derived by performing
     ; EC point addition this number of times (i.e. point multiplying).
     ;
     ; @throws IllegalStateException if the private key bytes are not available.
     ;;
    #_abstract
    (defn #_"BigInteger" ECKey'''get-priv-key [#_"ECKey" this]
        (or (:priv this) (throw+ (MissingPrivateKeyException'new)))
    )

    (defn #_"int" ECKey'compare-by-pub-key [#_"ECKey" this, #_"ECKey" that]
        (.compare (UnsignedBytes/lexicographicalComparator), (ECKey''get-pub-key this), (ECKey''get-pub-key that))
    )

    ;;;
     ; Returns the address that corresponds to the public part of this ECKey.  Note that an address is derived from
     ; the RIPEMD-160 hash of the public key and is not the public key itself (which is too large to be convenient).
     ;;
    #_method
    (defn #_"Address" ECKey''to-address [#_"ECKey" this, #_"Ledger" ledger]
        (Address'from-hash160 ledger, (ECKey''calculate-pub-key-hash160 this))
    )

    ;;;
     ; Signs the given hash and returns the R and S components as BigIntegers.  In the Bitcoin protocol
     ; usually encoded using DER format, so you want {@link ECKey.ECDSASignature#encodeToDER()} instead.
     ; However sometimes the independent components can be useful, for instance, if you're going to do
     ; further EC maths on them.
     ;
     ; @throws ECKey.MissingPrivateKeyException if this key doesn't have a private part.
     ;;
    #_abstract
    (defn #_"ECDSASignature" ECKey'''sign [#_"ECKey" this, #_"Sha256Hash" hash]
        (when (some? (:priv this)) => (throw+ (MissingPrivateKeyException'new))
            (ECKey''do-sign this, hash, (:priv this))
        )
    )

    #_method
    (defn #_"ECDSASignature" ECKey''do-sign [#_"ECKey" __, #_"Sha256Hash" hash, #_"BigInteger" priv]
        (ensure some? priv)

        (let [#_"ECDSASigner" signer (ECDSASigner. (HMacDSAKCalculator. (SHA256Digest.)))]
            (.init signer, true, (ECPrivateKeyParameters. priv, ECKey'CURVE))
            (let [#_"BigInteger[]" rs (.generateSignature signer, (:hash-bytes hash))]
                (ECDSASignature'''to-canonicalised (ECDSASignature'new (nth rs 0), (nth rs 1)))
            )
        )
    )

    ;;;
     ; Verifies the given ECDSA signature against the message bytes using the public key bytes.
     ;
     ; When using native ECDSA verification, data must be 32 bytes, and no element may be
     ; larger than 520 bytes.
     ;
     ; @param data Hash of the data to verify.
     ; @param sig ASN.1 encoded signature.
     ; @param pub The public key bytes to use.
     ;;
    (defn #_"boolean" ECKey'verify-3e [#_"byte[]" data, #_"ECDSASignature" sig, #_"byte[]" pub]
        (let [#_"ECDSASigner" signer (ECDSASigner.)]
            (.init signer, false, (ECPublicKeyParameters. (.decodePoint (.getCurve ECKey'CURVE), pub), ECKey'CURVE))
            (try
                (.verifySignature signer, data, (:r sig), (:s sig))
                (catch NullPointerException e
                    ;; Bouncy Castle contains a bug that can cause NPEs given specially crafted signatures.  Those signatures
                    ;; are inherently invalid/attack sigs so we just fail them here rather than crash the thread.
                    (log/error e, "Caught NPE inside bouncy castle")
                    false
                )
            )
        )
    )

    ;;;
     ; Verifies the given R/S pair (signature) against a hash using the public key.
     ;;
    #_method
    (defn #_"boolean" ECKey''verify-3s [#_"ECKey" this, #_"Sha256Hash" hash, #_"ECDSASignature" sig]
        (ECKey'verify-3e (:hash-bytes hash), sig, (ECKey''get-pub-key this))
    )

    ;;;
     ; Returns true if the given pubkey is canonical, i.e. the correct length taking into account compression.
     ;;
    (defn #_"boolean" ECKey'is-pub-key-canonical [#_"byte[]" pubkey]
        (cond
            (< (count pubkey) 33)            false
            (= (nth pubkey 0) 0x04)          (= (count pubkey) 65) ;; Uncompressed pubkey.
            (any = (nth pubkey 0) 0x02 0x03) (= (count pubkey) 33) ;; Compressed pubkey.
            :else                            false
        )
    )

    ;;;
     ; Signs a text message using the standard Bitcoin messaging signing format and returns the signature as
     ; a base64 encoded string.
     ;
     ; @throws IllegalStateException if this ECKey does not have the private part.
     ;;
    #_method
    (defn #_"String" ECKey''sign-message [#_"ECKey" this, #_"String" message]
        (let [#_"Sha256Hash" hash (Sha256Hash'twice-of (Utils'format-message-for-signing message))
              #_"ECDSASignature" sig (ECKey'''sign this, hash)
              #_"int" id ;; Now we have to work backwards to figure out the recId needed to recover the signature.
                (loop-when [#_"int" i 0] (< i 4) => (throw (RuntimeException. "Could not construct a recoverable key.  Should never happen."))
                    (let [#_"ECKey" key (ECKey'recover-from-signature i, sig, hash, (ECKey''is-compressed this))]
                        (if (and (some? key) (.equals (:pub key), (:pub this))) i (recur (inc i)))
                    )
                )
                #_"byte[]" bytes (byte-array 65)] ;; 1 header + 32 bytes for R + 32 bytes for S
            (aset bytes 0 (byte (+ id 27 (if (ECKey''is-compressed this) 4 0))))
            (System/arraycopy (Utils'big-integer-to-bytes (:r sig), 32), 0, bytes, 1, 32)
            (System/arraycopy (Utils'big-integer-to-bytes (:s sig), 32), 0, bytes, 33, 32)
            (String. (Base64/encode bytes), Charset'UTF-8)
        )
    )

    ;;;
     ; Given an arbitrary piece of text and a Bitcoin-format message signature encoded in base64, returns an ECKey
     ; containing the public key that was used to sign it.  This can then be compared to the expected public key to
     ; determine if the signature was correct.  These sorts of signatures are compatible with the Bitcoin-Qt/bitcoind
     ; format generated by signmessage/verifymessage RPCs and GUI menu options.  They are intended for humans to verify
     ; their communications with each other, hence the base64 format and the fact that the input is text.
     ;
     ; @param message Some piece of human readable text.
     ; @param signatureBase64 The Bitcoin-format message signature in base64.
     ; @throws SignatureException if the public key could not be recovered or if there was a signature format error.
     ;;
    #_throws #_[ "SignatureException" ]
    (defn #_"ECKey" ECKey'signed-message-to-key [#_"String" message, #_"String" sig64]
        (let [#_"byte[]" bytes
                (try
                    (Base64/decode sig64)
                    (catch RuntimeException e ;; This is what you get back from Bouncy Castle if base64 doesn't decode :( ;; )
                        (throw (SignatureException. "Could not decode base64", e))
                    )
                )]
            ;; Parse the signature bytes into r/s and the selector value.
            (when (< (count bytes) 65)
                (throw (SignatureException. (str "Signature truncated, expected 65 bytes and got " (count bytes))))
            )

            ;; The header byte: 0x1B = first key with even y, 0x1C = first key with odd y,
            ;;                  0x1D = second key with even y, 0x1E = second key with odd y.
            (let-when [#_"int" header (& 0xff (nth bytes 0))] (<= 27 header 34) => (throw (SignatureException. (str "Header byte out of range: " header)))
                (let [#_"BigInteger" r (BigInteger. 1, (Arrays/copyOfRange bytes, 1, 33))
                      #_"BigInteger" s (BigInteger. 1, (Arrays/copyOfRange bytes, 33, 65))
                      #_"ECDSASignature" sig (ECDSASignature'new r, s)
                      ;; Note that the C++ code doesn't actually seem to specify any character encoding.
                      ;; Presumably it's whatever JSON-SPIRIT hands back.  Assume UTF-8 for now.
                      #_"Sha256Hash" hash (Sha256Hash'twice-of (Utils'format-message-for-signing message))
                      #_"boolean" compressed? (<= 31 header) header (if compressed? (- header 4) header)
                      #_"ECKey" key (ECKey'recover-from-signature (- header 27), sig, hash, compressed?)]
                    (or key (throw (SignatureException. "Could not recover public key from signature")))
                )
            )
        )
    )

    ;;;
     ; Convenience wrapper around {@link ECKey#signedMessageToKey(String, String)}.
     ; If the key derived from the signature is not the same as this one, throws a SignatureException.
     ;;
    #_throws #_[ "SignatureException" ]
    #_method
    (defn #_"void" ECKey''verify-message [#_"ECKey" this, #_"String" message, #_"String" sig64]
        (let [#_"ECKey" key (ECKey'signed-message-to-key message, sig64)]
            (when-not (.equals (:pub key), (:pub this))
                (throw (SignatureException. "Signature did not match for message"))
            )
        )
        nil
    )

    ;;;
     ; Given the components of a signature and a selector value, recover and return the public key
     ; that generated the signature according to the algorithm in SEC1v2 section 4.1.6.
     ;
     ; The recId is an index from 0 to 3 which indicates which of the 4 possible keys is the correct one.  Because
     ; the key recovery operation yields multiple potential keys, the correct key must either be stored alongside the
     ; signature, or you must be willing to try each recId in turn until you find one that outputs the key you are
     ; expecting.
     ;
     ; If this method returns null it means recovery was not possible and recId should be iterated.
     ;
     ; Given the above two points, a correct usage of this method is inside a for loop from 0 to 3, and if the
     ; output is null OR a key that is not the one you expect, you try again with the next recId.
     ;
     ; @param recId Which possible key to recover.
     ; @param sig The R and S components of the signature, wrapped.
     ; @param message Hash of the data that was signed.
     ; @param compressed Whether or not the original pubkey was compressed.
     ; @return An ECKey containing only the public part, or null if recovery wasn't possible.
     ;;
    (defn #_"ECKey" ECKey'recover-from-signature [#_"int" __recId, #_"ECDSASignature" sig, #_"Sha256Hash" message, #_"boolean" compressed?]
        (assert-argument (<= 0 __recId), "recId must be positive")
        (assert-argument (<= 0 (.signum (:r sig))), "r must be positive")
        (assert-argument (<= 0 (.signum (:s sig))), "s must be positive")
        (ensure some? message)
                            ;; 1.0 For j from 0 to h   (h == recId here and the loop is outside this function)
                            ;;   1.1 Let x = r + jn
        (let [#_"BigInteger" n (.getN ECKey'CURVE) ;; Curve order.
              #_"BigInteger" i (BigInteger/valueOf (quot (long __recId) 2))
              #_"BigInteger" x (.add (:r sig), (.multiply i, n))
                            ;;   1.2 Convert the integer x to an octet string X of length mlen using the conversion routine
                            ;;       specified in Section 2.3.7, where mlen = โ(log2 p)/8โ or mlen = โm/8โ.
                            ;;   1.3 Convert the octet string (16 set binary digits)||X to an elliptic curve point R using the
                            ;;       conversion routine specified in Section 2.3.4.  If this conversion routine outputs โinvalidโ,
                            ;;       then do another iteration of Step 1.
                            ;;
                            ;; More concisely, what these points mean is to use X as a compressed public key.
              #_"BigInteger" prime SecP256K1Curve/q]
                            ;; Cannot have point co-ordinates larger than this as everything takes place modulo Q.
            (when (< x prime)
                            ;; Compressed keys require you to know an extra bit of data about the y-coord as there are two possibilities.
                            ;; So it's encoded in the recId.
                (let [#_"ECPoint" __R (ECKey'decompress-key x, (= (& __recId 1) 1))]
                            ;;   1.4 If nR != point at infinity, then do another iteration of Step 1 (callers responsibility).
                    (when (.isInfinity (.multiply __R, n))
                            ;;   1.5 Compute e from M using Steps 2 and 3 of ECDSA signature verification.
                        (let [#_"BigInteger" e (Sha256Hash''to-big-integer message)]
                            ;;   1.6 For k from 1 to 2 do the following.   (loop is outside this function via iterating recId)
                            ;;   1.6.1 Compute a candidate public key as:
                            ;;               Q = mi(r) * (sR - eG)
                            ;;
                            ;; Where mi(x) is the modular multiplicative inverse.  We transform this into the following:
                            ;;               Q = (mi(r) * s ** R) + (mi(r) * -e ** G)
                            ;; Where -e is the modular additive inverse of e, that is z such that z + e = 0 (mod n).
                            ;; In the above equation ** is point multiplication and + is point addition (the EC group operator).
                            ;;
                            ;; We can find the additive inverse by subtracting e from zero then taking the mod.  For example
                            ;; the additive inverse of 3 modulo 11 is 8 because 3 + 8 mod 11 = 0, and -3 mod 11 = 8.
                            (let [#_"BigInteger" e' (.mod (.subtract BigInteger/ZERO, e), n)
                                  #_"BigInteger" r' (.modInverse (:r sig), n)
                                  #_"BigInteger" sr' (.mod (.multiply r', (:s sig)), n)
                                  #_"BigInteger" e'r' (.mod (.multiply r', e'), n)
                                  #_"ECPoint" q (ECAlgorithms/sumOfTwoMultiplies (.getG ECKey'CURVE), e'r', __R, sr')]
                                (ECKey'from-public-only-bytes (.getEncoded q, compressed?))
                            )
                        )
                    )
                )
            )
        )
    )

    ;;; Decompress a compressed public key (x co-ord and low-bit of y-coord). ;;
    (defn- #_"ECPoint" ECKey'decompress-key [#_"BigInteger" __xBN, #_"boolean" __yBit]
        (let [#_"X9IntegerConverter" x9 (X9IntegerConverter.)
              #_"byte[]" bytes (.integerToBytes x9, __xBN, (inc (.getByteLength x9, (.getCurve ECKey'CURVE))))]
            (aset bytes 0 (byte (if __yBit 0x03 0x02)))
            (.decodePoint (.getCurve ECKey'CURVE), bytes)
        )
    )

    ;;;
     ; Returns a 32 byte array containing the private key.
     ;
     ; @throws ECKey.MissingPrivateKeyException if the private key bytes are missing/encrypted.
     ;;
    #_method
    (defn #_"byte[]" ECKey''get-priv-key-bytes [#_"ECKey" this]
        (Utils'big-integer-to-bytes (ECKey'''get-priv-key this), 32)
    )

    ;;;
     ; Returns the creation time of this key or zero if the key was deserialized from a version that did not store
     ; that data.
     ;;
    #_abstract
    (defn #_"long" ECKey'''get-creation-time-seconds [#_"ECKey" this]
        (:creation-time-seconds this)
    )

    ;;;
     ; Sets the creation time of this key.  Zero is a convention to mean "unavailable".  This method can be useful when
     ; you have a raw key you are importing from somewhere else.
     ;;
    #_method
    (defn #_"ECKey" ECKey''set-creation-time-seconds [#_"ECKey" this, #_"long" secs]
        (when (neg? secs)
            (throw (IllegalArgumentException. (str "Cannot set creation time to negative value: " secs)))
        )
        (assoc this :creation-time-seconds secs)
    )

    #_method
    (defn #_"String" ECKey''to-string [#_"ECKey" this]
        (let [#_"StringBuilder" sb (StringBuilder. (<< 1 7))]
            (.. sb (append "{ "))
            (do
                (.. sb               (append "pub")                     (append "=") (append (Base16'encode (ECKey''get-pub-key this))))
                (when (pos? (:creation-time-seconds this))
                    (.. sb (append ", ") (append "creationTimeSeconds") (append "=") (append (:creation-time-seconds this)))
                )
                (.. sb (append ", ") (append "isPubKeyOnly")            (append "=") (append (ECKey'''is-pub-key-only this)))
            )
            (.. sb (append " }"))
            (.toString sb)
        )
    )

    #_abstract
    (defn #_"void" ECKey'''format-key-with-address [#_"ECKey" this, #_"Ledger" ledger, #_"StringBuilder" sb]
        (let [#_"Address" address (ECKey''to-address this, ledger)]
            (.. sb (append "  addr:") (append address))
            (.. sb (append "  hash160:") (append (Base16'encode (ECKey''calculate-pub-key-hash160 this))))
            (when (pos? (:creation-time-seconds this))
                (.. sb (append "  creationTimeSeconds:") (append (:creation-time-seconds this)))
            )
            (.. sb (append "\n"))
            (.. sb (append "  ") (append (ECKey''to-string this)) (append "\n"))
        )
        nil
    )
)

;;;
 ; A FilteredBlock is used to relay a block with its transactions filtered using a {@link BloomFilter}.  It consists
 ; of the block header and a {@link PartialMerkleTree} which contains the transactions which matched the filter.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns FilteredBlock (ยง extends Message)
    (defn #_"FilteredBlock" FilteredBlock'new [#_"Ledger" ledger, #_"Block" header, #_"PartialMerkleTree" merkle]
        (merge (Message'new ledger)
            (hash-map
                #_"Block" :filtered-header header
                ;;;
                 ; The {@link PartialMerkleTree} that provides the mathematical proof of transaction inclusion in the block.
                 ;;
                #_"PartialMerkleTree" :merkle-tree merkle

                ;; A set of transactions whose hashes are a subset of getTransactionHashes().
                ;; These were relayed as a part of the filteredblock getdata, i.e. likely weren't previously received as loose transactions.
                #_"Map<Sha256Hash, Transaction>" :associated-transactions (HashMap.)
            )
        )
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"FilteredBlock" FilteredBlock'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload]
        (FilteredBlock'new ledger, (Block'from-wire ledger, payload), (PartialMerkleTree'from-wire ledger, payload))
    )

    #_method
    (defn FilteredBlock''to-wire
        (#_"String" [] "merkleblock")
        (#_"void" [#_"FilteredBlock" this, #_"ByteArrayOutputStream" baos]
            (if (nil? (-> this :filtered-header :transactions))
                (Block''to-wire (:filtered-header this), baos)
                (Block''to-wire (Block''clone-as-header (:filtered-header this)), baos)
            )
            (PartialMerkleTree''to-wire (:merkle-tree this), baos)
            nil
        )
    )

    ;;;
     ; Gets a list of leaf hashes which are contained in the partial merkle tree in this filtered block.
     ;
     ; @throws ProtocolException if the partial merkle block is invalid or the merkle root of the partial merkle block doesnt match the block header.
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn #_"List<Sha256Hash>" FilteredBlock''get-transaction-hashes [#_"FilteredBlock" this]
        (let [[#_"Sha256Hash" root #_"List<Sha256Hash>" matches] (PartialMerkleTree''get-txn-hash-and-merkle-root (:merkle-tree this))]
            (if (= root (Block''calculate-merkle-root (:filtered-header this)))
                matches
                (throw+ (VerificationException'new "Merkle root of block header does not match merkle root of partial merkle tree."))
            )
        )
    )

    ;;;
     ; Gets a copy of the block header.
     ;;
    #_method
    (defn #_"Block" FilteredBlock''get-block-header [#_"FilteredBlock" this]
        (Block''clone-as-header (:filtered-header this))
    )

    ;;;
     ; Gets the hash of the block represented in this FilteredBlock.
     ;;
    #_method
    (defn #_"Sha256Hash" FilteredBlock''get-hash [#_"FilteredBlock" this]
        (Block''get-hash (:filtered-header this))
    )

    ;;;
     ; Provide this FilteredBlock with a transaction which is in its Merkle tree.
     ;
     ; @return false if the tx is not relevant to this FilteredBlock.
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn #_"boolean" FilteredBlock''provide-transaction [#_"FilteredBlock" this, #_"Transaction" tx]
        (let [#_"Sha256Hash" hash (Transaction''get-hash tx)]
            (when (.contains (FilteredBlock''get-transaction-hashes this), hash) => false
                (ยง ass this (update this :associated-transactions assoc hash tx))
                true
            )
        )
    )

    ;;;
     ; Number of transactions in this block, before it was filtered.
     ;;
    #_method
    (defn #_"int" FilteredBlock''get-transaction-count [#_"FilteredBlock" this]
        (:transaction-count (:merkle-tree this))
    )

    #_method
    (defn #_"String" FilteredBlock''to-string [#_"FilteredBlock" this]
        (str "FilteredBlock{" "merkleTree=" (:merkle-tree this) ", header=" (:filtered-header this) "}")
    )
)

;;;
 ; A job submitted to the executor which verifies signatures.
 ;;
(class-ns FullPrunedVerifier (ยง implements Callable #_"<VerificationException>")
    (defn #_"FullPrunedVerifier" FullPrunedVerifier'new [#_"Transaction" tx, #_"List<Script>" scripts, #_"{ScriptVerifyFlag}" flags]
        (hash-map
            #_"Transaction" :tx tx
            #_"List<Script>" :prev-out-scripts scripts
            #_"{ScriptVerifyFlag}" :verify-flags flags
        )
    )

    #_throws #_[ "Exception" ]
    #_foreign
    #_override
    (defn #_"VerificationException" Callable'''call [#_"FullPrunedVerifier" this]
        (try+
            (let [#_"ListIterator<Script>" it (.listIterator (:prev-out-scripts this))]
                (dotimes [#_"int" i (count (:inputs (:tx this)))]
                    (Script''correctly-spends (TransactionInput''get-script-sig (nth (:inputs (:tx this)) i)), (:tx this), i, (.next it), (:verify-flags this))
                )
                nil
            )
            (ยง catch VerificationException e
                e
            )
        )
    )
)

;;;
 ; A FullPrunedBlockChain works in conjunction with a {@link FullPrunedBlockStore} to verify all the rules of the
 ; Bitcoin system, with the downside being a large cost in system resources.  Fully verifying means all unspent
 ; transaction outputs are stored.  Once a transaction output is spent and that spend is buried deep enough, the data
 ; related to it is deleted to ensure disk space usage doesn't grow forever.  For this reason a pruning node cannot
 ; serve the full block chain to other clients, but it nevertheless provides the same security guarantees as Bitcoin
 ; Core does.
 ;;
(class-ns FullPrunedBlockChain (ยง extends BlockChain)
    ;;;
     ; Constructs a block chain connected to any wallets and a store.
     ;
     ; Having no wallets at all might be helpful when you don't actually care about sending
     ; and receiving coins but rather, just want to explore the network data structures.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (defn #_"FullPrunedBlockChain" FullPrunedBlockChain'new [#_"Ledger" ledger, #_"FullPrunedBlockStore" store & #_"Wallet..." wallets]
        (let [this
                (merge (BlockChain'new ledger, store, wallets)
                    (hash-map
                        ;;;
                         ; Keeps a map of block hashes to StoredBlocks.
                         ;;
                        #_"FullPrunedBlockStore" :block-store store

                        ;;;
                         ; Whether or not to execute scriptPubKeys before accepting a transaction (i.e. checking signatures).
                         ;
                         ; If you're accepting data from an untrusted node, such as one found via the P2P network, this should be set
                         ; to true (which is the default).  If you're downloading a chain from a node you control, script execution
                         ; is redundant because you know the connected node won't relay bad data to you.  In that case it's safe to set
                         ; this to false and obtain a significant speedup.
                         ;;
                        #_"boolean" :run-scripts true

                        ;; TODO: Execute in order of largest transaction (by input count) first.
                        #_"ExecutorService" :script-verification-executor (Executors/newFixedThreadPool (.availableProcessors (Runtime/getRuntime)), (DaemonThreadFactory'new "Script verification"))
                    )
                )]
            ;; Ignore upgrading for now.
            (assoc this :chain-head (FullPrunedBlockStore'''get-verified-chain-head store))
        )
    )

    #_throws #_[ "BlockStoreException", "VerificationException" ]
    #_override
    (defn #_"StoredBlock" BlockChain'''add-to-block-store-3 [#_"FullPrunedBlockChain" this, #_"StoredBlock" prior, #_"Block" block]
        (let [#_"StoredBlock" stored (StoredBlock''build prior, block)]
            (ยง ass this (update this :block-store FullPrunedBlockStore'''put-3 stored, (StoredUndoableBlock'from-transactions (Block''get-hash (:stored-header stored)), (:transactions block))))
            stored
        )
    )

    #_throws #_[ "BlockStoreException", "VerificationException" ]
    #_override
    (defn #_"StoredBlock" BlockChain'''add-to-block-store-4 [#_"FullPrunedBlockChain" this, #_"StoredBlock" prior, #_"Block" header, #_"TransactionOutputChanges" changes]
        (let [#_"StoredBlock" stored (StoredBlock''build prior, header)]
            (ยง ass this (update this :block-store FullPrunedBlockStore'''put-3 stored, (StoredUndoableBlock'from-changes (Block''get-hash (:stored-header stored)), changes)))
            stored
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"FullPrunedBlockChain" BlockChain'''rollback-block-store [#_"FullPrunedBlockChain" __, #_"int" height]
        (throw+ (BlockStoreException'new "Unsupported"))
    )

    #_override
    (defn #_"boolean" BlockChain'''should-verify-transactions [#_"FullPrunedBlockChain" __]
        true
    )

    ;;;
     ; Get the {@link Script} from the script bytes or return Script of empty byte array.
     ;;
    #_method
    (defn- #_"Script" FullPrunedBlockChain''get-script [#_"FullPrunedBlockChain" this, #_"byte[]" bytes]
        (try+
            (Script'parse bytes)
            (ยง catch ScriptException _
                (Script'parse (byte-array 0))
            )
        )
    )

    ;;;
     ; Get the address from the {@link Script} if it exists, otherwise return empty string "".
     ;;
    #_method
    (defn- #_"String" FullPrunedBlockChain''get-script-address [#_"FullPrunedBlockChain" this, #_"Script" script]
        (let [#_"StringBuilder" sb (StringBuilder. (<< 1 7))]
            (try
                (when (some? script)
                    (.append sb, (Script''get-to-address-3 script, (:ledger this), true))
                )
                (catch Exception _
                )
            )
            (.toString sb)
        )
    )

    #_throws #_[ "VerificationException", "BlockStoreException" ]
    #_override
    (defn #_"TransactionOutputChanges" BlockChain'''connect-transactions-3 [#_"FullPrunedBlockChain" this, #_"int" height, #_"Block" block]
        (assert-state (.isHeldByCurrentThread (:blockchain-lock this)))

        (when (nil? (:transactions block))
            (throw (RuntimeException. "connectTransactions called with Block that didn't have transactions!"))
        )
        (when-not (Ledger''passes-checkpoint (:ledger this), height, (Block''get-hash block))
            (throw+ (VerificationException'new (str "Block failed checkpoint lockin at " height)))
        )

        (FullPrunedBlockStore'''begin-database-batch-write (:block-store this))

        (when (.isShutdown (:script-verification-executor this))
            (ยง ass this (assoc this :script-verification-executor (Executors/newFixedThreadPool (.availableProcessors (Runtime/getRuntime)))))
        )

        (let [#_"LinkedList<UTXO>" __txOutsCreated (LinkedList.) #_"LinkedList<UTXO>" __txOutsSpent (LinkedList.)]
            (try+
                (let [#_"long" ops
                        (when-not (Ledger''is-checkpoint (:ledger this), height) => 0
                            ;; BIP30 violator blocks are ones that contain a duplicated transaction.  They are all in the checkpoints list
                            ;; and we therefore only check non-checkpoints for duplicated transactions here.  See the BIP30 document
                            ;; for more details on this: https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki
                            (loop-when [ops 0 #_"Transaction*" s (:transactions block)] (seq s) => ops
                                (let [#_"Transaction" tx (first s)
                                      #_"{ScriptVerifyFlag}" flags (Ledger''get-transaction-verification-flags (:ledger this), block, tx, (:version-tally this))]
                                    ;; If we already have unspent outputs for this hash, we saw the tx already.
                                    ;; Either the block is being added twice (bug) or the block is a BIP30 violator.
                                    (when (FullPrunedBlockStore'''has-unspent-outputs (:block-store this), (Transaction''get-hash tx), (count (:outputs tx)))
                                        (throw+ (VerificationException'new "Block failed BIP30 test!"))
                                    )
                                    ;; We already check non-BIP16 sigops in Block.verifyTransactions(true).
                                    (recur (+ ops (if (contains? flags :ScriptVerifyFlag'P2SH) (Transaction''get-sig-op-count tx) 0)) (next s))
                                )
                            )
                        )
                      #_"List<Future<VerificationException>>" results (ArrayList. (count (:transactions block)))
                      [#_"Coin" fees #_"Coin" __coinbaseValue]
                        (loop-when [ops ops fees Coin'ZERO __coinbaseValue nil #_"Transaction*" s (:transactions block)] (seq s) => [fees __coinbaseValue]
                            (let [#_"Transaction" tx (first s)
                                  #_"{ScriptVerifyFlag}" flags (Ledger''get-transaction-verification-flags (:ledger this), block, tx, (:version-tally this))
                                  #_"boolean" coinbase? (Transaction''is-coin-base tx)
                                  #_"List<Script>" scripts (LinkedList.)
                                  [ops #_"Coin" __valueIn]
                                    (when-not coinbase? => [ops Coin'ZERO]
                                        ;; For each input of the transaction remove the corresponding output from the set of unspent outputs.
                                        (loop-when [ops ops __valueIn Coin'ZERO #_"TransactionInput*" inputs (:inputs tx)] (seq inputs) => [ops __valueIn]
                                            (let [#_"TransactionInput" input (first inputs)
                                                  #_"UTXO" out (FullPrunedBlockStore'''get-transaction-output (:block-store this), (:from-tx-hash (:outpoint input)), (:index (:outpoint input)))]
                                                (when (nil? out)
                                                    (throw+ (VerificationException'new "Attempted spend of a non-existent or already spent output!"))
                                                )
                                                ;; Coinbases can't be spent until they mature, to avoid re-orgs destroying entire transaction chains.
                                                ;; The assumption is there will ~never be re-orgs deeper than the spendable coinbase chain depth.
                                                (when (:coinbase? out)
                                                    (let-when [#_"int" depth (- height (:utxo-height out))] (< depth (-> this :ledger :spendable-coinbase-depth))
                                                        (throw+ (VerificationException'new (str "Tried to spend coinbase at depth " depth)))
                                                    )
                                                )
                                                ;; TODO: Check we're not spending the genesis transaction here. Bitcoin Core won't allow it.
                                                (let [__valueIn (Coin''add __valueIn, (:utxo-value out))
                                                      ops
                                                        (when (contains? flags :ScriptVerifyFlag'P2SH) => ops
                                                            (let [ops
                                                                    (when (Script''is-pay-to-script-hash (:script out)) => ops
                                                                        (+ ops (Script'get-p2sh-sig-op-count (:script-bytes input)))
                                                                    )]
                                                                (when (< Block'MAX_BLOCK_SIGOPS ops)
                                                                    (throw+ (VerificationException'new "Too many P2SH SigOps in block"))
                                                                )
                                                                ops
                                                            )
                                                        )]
                                                    (ยง ass scripts (.add scripts, (:script out)))
                                                    (FullPrunedBlockStore'''remove-unspent-transaction-output (:block-store this), out)
                                                    (ยง ass __txOutsSpent (.add __txOutsSpent, out))
                                                    (recur ops __valueIn (next inputs))
                                                )
                                            )
                                        )
                                    )]
                                (let [#_"Sha256Hash" hash (Transaction''get-hash tx)
                                      #_"Coin" __valueOut
                                        (loop-when [__valueOut Coin'ZERO #_"TransactionOutput*" outputs (:outputs tx)] (seq outputs) => __valueOut
                                            (let [#_"TransactionOutput" output (first outputs)
                                                  __valueOut (Coin''add __valueOut, (:coin-value output))
                                                  ;; For each output, add it to the set of unspent outputs so it can be consumed in future.
                                                  #_"Script" script (FullPrunedBlockChain''get-script this, (:script-bytes output))
                                                  #_"UTXO" out (UTXO'new hash, (TransactionOutput''get-index output), (:coin-value output), height, coinbase?, script, (FullPrunedBlockChain''get-script-address this, script))]
                                                (FullPrunedBlockStore'''add-unspent-transaction-output (:block-store this), out)
                                                (ยง ass __txOutsCreated (.add __txOutsCreated, out))
                                                (recur __valueOut (next outputs))
                                            )
                                        )]
                                    ;; All values were already checked for being non-negative (as it is verified in Transaction.verify()),
                                    ;; but we check again here just for defence in depth.  Transactions with zero output value are OK.
                                    (when (or (Coin''negative? __valueOut) (Coin''greater-than? __valueOut, (Ledger''get-max-money (:ledger this))))
                                        (throw+ (VerificationException'new "Transaction output value out of range"))
                                    )
                                    (let [[fees __coinbaseValue]
                                            (when-not coinbase? => [fees __valueOut]
                                                (when (or (Coin''less-than? __valueIn, __valueOut) (Coin''greater-than? __valueIn, (Ledger''get-max-money (:ledger this))))
                                                    (throw+ (VerificationException'new "Transaction input value out of range"))
                                                )
                                                [(Coin''add fees, (Coin''subtract __valueIn, __valueOut)) __coinbaseValue]
                                            )]
                                        (when (and (not coinbase?) (:run-scripts this))
                                            ;; Because correctlySpends modifies transactions, this must come after we are done with tx.
                                            (let [#_"FutureTask<VerificationException>" future (FutureTask. (FullPrunedVerifier'new tx, scripts, flags))]
                                                (.execute (:script-verification-executor this), future)
                                                (ยง ass results (.add results, future))
                                            )
                                        )
                                        (recur ops fees __coinbaseValue (next s))
                                    )
                                )
                            )
                        )]

                    (when (or (Coin''greater-than? fees, (Ledger''get-max-money (:ledger this))) (Coin''less-than? (Coin''add (Block''get-block-inflation block, height), fees), __coinbaseValue))
                        (throw+ (VerificationException'new "Transaction fees out of range"))
                    )

                    (doseq [#_"Future<VerificationException>" future results]
                        (let [#_"VerificationException" e
                                (try
                                    (.get future)
                                    (catch InterruptedException ie
                                        (throw (RuntimeException. ie)) ;; Shouldn't happen.
                                    )
                                    (catch ExecutionException ee
                                        (log/error (.getCause ee), "Script.correctlySpends threw an unexpected exception")
                                        (throw+ (VerificationException'new "Bug in Script.correctlySpends, likely script malformed in some new and interesting way.") ee)
                                    )
                                )]
                            (when (some? e)
                                (throw e)
                            )
                        )
                    )
                )
                (ยง catch VerificationException _
                    (.shutdownNow (:script-verification-executor this))
                    (FullPrunedBlockStore'''abort-database-batch-write (:block-store this))
                    (throw+)
                )
                (ยง catch BlockStoreException _
                    (.shutdownNow (:script-verification-executor this))
                    (FullPrunedBlockStore'''abort-database-batch-write (:block-store this))
                    (throw+)
                )
            )

            (TransactionOutputChanges'new __txOutsCreated, __txOutsSpent)
        )
    )

    ;;;
     ; Used during reorgs to connect a block previously on a fork.
     ;;
    #_throws #_[ "VerificationException", "BlockStoreException", "PrunedException" ]
    #_override
    (defn #_"TransactionOutputChanges" BlockChain'''connect-transactions-2 [#_"FullPrunedBlockChain" this, #_"StoredBlock" stored]
        (sync this
            (assert-state (.isHeldByCurrentThread (:blockchain-lock this)))
            (when-not (Ledger''passes-checkpoint (:ledger this), (:stored-height stored), (Block''get-hash (:stored-header stored)))
                (throw+ (VerificationException'new (str "Block failed checkpoint lockin at " (:stored-height stored))))
            )

            (FullPrunedBlockStore'''begin-database-batch-write (:block-store this))
            (let [#_"StoredUndoableBlock" block (FullPrunedBlockStore'''get-undo-block (:block-store this), (Block''get-hash (:stored-header stored)))]
                (when (nil? block)
                    ;; We're trying to re-org too deep and the data needed has been deleted.
                    (FullPrunedBlockStore'''abort-database-batch-write (:block-store this))
                    (throw+ (PrunedException'new (Block''get-hash (:stored-header stored))))
                )

                (try+
                    (cond (some? (:transactions block))
                        (do
                            (when-not (Ledger''is-checkpoint (:ledger this), (:stored-height stored))
                                (doseq [#_"Transaction" tx (:transactions block)]
                                    (when (FullPrunedBlockStore'''has-unspent-outputs (:block-store this), (Transaction''get-hash tx), (count (:outputs tx)))
                                        (throw+ (VerificationException'new "Block failed BIP30 test!"))
                                    )
                                )
                            )

                            (when (.isShutdown (:script-verification-executor this))
                                (ยง ass this (assoc this :script-verification-executor (Executors/newFixedThreadPool (.availableProcessors (Runtime/getRuntime)))))
                            )

                            (let [#_"LinkedList<UTXO>" __txOutsCreated (LinkedList.) #_"LinkedList<UTXO>" __txOutsSpent (LinkedList.)
                                  #_"List<Future<VerificationException>>" results (ArrayList. (count (:transactions block)))
                                  [#_"Coin" fees #_"Coin" __coinbaseValue]
                                    (loop-when [#_"long" ops 0 fees Coin'ZERO __coinbaseValue nil #_"Transaction*" s (:transactions this)] (seq s) => [fees __coinbaseValue]
                                        (let [#_"Transaction" tx (first s)
                                              #_"{ScriptVerifyFlag}" flags (Ledger''get-transaction-verification-flags (:ledger this), (:stored-header stored), tx, (:version-tally this))
                                              #_"boolean" coinbase? (Transaction''is-coin-base tx)
                                              #_"List<Script>" _scripts (LinkedList.)
                                              [ops #_"Coin" __valueIn]
                                                (when-not coinbase? => [ops Coin'ZERO]
                                                    (loop-when [ops ops __valueIn Coin'ZERO #_"TransactionInput*" inputs (:inputs tx)] (seq inputs) => [ops __valueIn]
                                                        (let [#_"TransactionInput" input (first inputs)
                                                              #_"UTXO" out (FullPrunedBlockStore'''get-transaction-output (:block-store this), (:from-tx-hash (:outpoint input)), (:index (:outpoint input)))]
                                                            (when (nil? out)
                                                                (throw+ (VerificationException'new "Attempted spend of a non-existent or already spent output!"))
                                                            )
                                                            (when (:coinbase? out)
                                                                (let-when [#_"int" depth (- (:stored-height stored) (:utxo-height out))] (< depth (-> this :ledger :spendable-coinbase-depth))
                                                                    (throw+ (VerificationException'new (str "Tried to spend coinbase at depth " depth)))
                                                                )
                                                            )
                                                            (let [__valueIn (Coin''add __valueIn, (:utxo-value out))
                                                                  ops
                                                                    (when (contains? flags :ScriptVerifyFlag'P2SH) => ops
                                                                        (let [ops
                                                                                (when (Script''is-pay-to-script-hash (:script out)) => ops
                                                                                    (+ ops (Script'get-p2sh-sig-op-count (:script-bytes input)))
                                                                                )]
                                                                            (when (< Block'MAX_BLOCK_SIGOPS ops)
                                                                                (throw+ (VerificationException'new "Too many P2SH SigOps in block"))
                                                                            )
                                                                            ops
                                                                        )
                                                                    )]
                                                                ;; TODO: Enforce DER signature format.
                                                                (ยง ass _scripts (.add _scripts, (:script out)))
                                                                (FullPrunedBlockStore'''remove-unspent-transaction-output (:block-store this), out)
                                                                (ยง ass __txOutsSpent (.add __txOutsSpent, out))
                                                                (recur ops __valueIn (next inputs))
                                                            )
                                                        )
                                                    )
                                                )]
                                            (let [#_"Sha256Hash" hash (Transaction''get-hash tx)
                                                  #_"Coin" __valueOut
                                                    (loop-when [__valueOut Coin'ZERO #_"TransactionOutput*" outputs (:outputs tx)] (seq outputs) => __valueOut
                                                        (let [#_"TransactionOutput" output (first outputs)
                                                              __valueOut (Coin''add __valueOut, (:coin-value output))
                                                              #_"Script" script (FullPrunedBlockChain''get-script this, (:script-bytes output))
                                                              #_"UTXO" out (UTXO'new hash, (TransactionOutput''get-index output), (:coin-value output), (:stored-height stored), coinbase?, script, (FullPrunedBlockChain''get-script-address this, script))]
                                                            (FullPrunedBlockStore'''add-unspent-transaction-output (:block-store this), out)
                                                            (ยง ass __txOutsCreated (.add __txOutsCreated, out))
                                                            (recur __valueOut (next outputs))
                                                        )
                                                    )]
                                                ;; All values were already checked for being non-negative (as it is verified in Transaction.verify())
                                                ;; but we check again here just for defence in depth.  Transactions with zero output value are OK.
                                                (when (or (Coin''negative? __valueOut) (Coin''greater-than? __valueOut, (Ledger''get-max-money (:ledger this))))
                                                    (throw+ (VerificationException'new "Transaction output value out of range"))
                                                )
                                                (let [[fees __coinbaseValue]
                                                        (when-not coinbase? => [fees __valueOut]
                                                            (when (or (Coin''less-than? __valueIn, __valueOut) (Coin''greater-than? __valueIn, (Ledger''get-max-money (:ledger this))))
                                                                (throw+ (VerificationException'new "Transaction input value out of range"))
                                                            )
                                                            [(Coin''add fees, (Coin''subtract __valueIn, __valueOut)) __coinbaseValue]
                                                        )]
                                                    (when-not coinbase?
                                                        ;; Because correctlySpends modifies transactions, this must come after we are done with tx.
                                                        (let [#_"FutureTask<VerificationException>" future (FutureTask. (FullPrunedVerifier'new tx, (:prev-out-scripts this), flags))]
                                                            (.execute (:script-verification-executor this), future)
                                                            (ยง ass results (.add results, future))
                                                        )
                                                    )
                                                    (recur ops fees __coinbaseValue (next s))
                                                )
                                            )
                                        )
                                    )]

                                (when (or (Coin''greater-than? fees, (Ledger''get-max-money (:ledger this))) (Coin''less-than? (Coin''add (Block''get-block-inflation (:stored-header stored), (:stored-height stored)), fees), __coinbaseValue))
                                    (throw+ (VerificationException'new "Transaction fees out of range"))
                                )

                                (doseq [#_"Future<VerificationException>" future results]
                                    (let [#_"VerificationException" e
                                            (try
                                                (.get future)
                                                (catch InterruptedException ie
                                                    (throw (RuntimeException. ie)) ;; Shouldn't happen.
                                                )
                                                (catch ExecutionException ee
                                                    (log/error (.getCause ee), "Script.correctlySpends threw an unexpected exception")
                                                    (throw+ (VerificationException'new "Bug in Script.correctlySpends, likely script malformed in some new and interesting way.") ee)
                                                )
                                            )]
                                        (when (some? e)
                                            (throw e)
                                        )
                                    )
                                )

                                (TransactionOutputChanges'new __txOutsCreated, __txOutsSpent)
                            )
                        )
                        :else
                        (do
                            (ensure some? (:tx-out-changes block))

                            (let [#_"TransactionOutputChanges" changes (:tx-out-changes block)]
                                (when-not (Ledger''is-checkpoint (:ledger this), (:stored-height stored))
                                    (doseq [#_"UTXO" out (:tx-outs-created changes)]
                                        (when (some? (FullPrunedBlockStore'''get-transaction-output (:block-store this), (:utxo-hash out), (:utxo-index out)))
                                            (throw+ (VerificationException'new "Block failed BIP30 test!"))
                                        )
                                    )
                                )
                                (doseq [#_"UTXO" out (:tx-outs-created changes)]
                                    (FullPrunedBlockStore'''add-unspent-transaction-output (:block-store this), out)
                                )
                                (doseq [#_"UTXO" out (:tx-outs-spent changes)]
                                    (FullPrunedBlockStore'''remove-unspent-transaction-output (:block-store this), out)
                                )
                                changes
                            )
                        )
                    )
                    (ยง catch VerificationException _
                        (.shutdownNow (:script-verification-executor this))
                        (FullPrunedBlockStore'''abort-database-batch-write (:block-store this))
                        (throw+)
                    )
                    (ยง catch BlockStoreException _
                        (.shutdownNow (:script-verification-executor this))
                        (FullPrunedBlockStore'''abort-database-batch-write (:block-store this))
                        (throw+)
                    )
                )
            )
        )
    )

    ;;;
     ; This is broken for blocks that do not pass BIP30, so all BIP30-failing blocks which are allowed to fail BIP30
     ; must be checkpointed.
     ;;
    #_throws #_[ "PrunedException", "BlockStoreException" ]
    #_override
    (defn #_"void" BlockChain'''disconnect-transactions [#_"FullPrunedBlockChain" this, #_"StoredBlock" __oldBlock]
        (assert-state (.isHeldByCurrentThread (:blockchain-lock this)))

        (FullPrunedBlockStore'''begin-database-batch-write (:block-store this))
        (try+
            (let [#_"StoredUndoableBlock" __undoBlock (FullPrunedBlockStore'''get-undo-block (:block-store this), (Block''get-hash (:stored-header __oldBlock)))]
                (when (nil? __undoBlock)
                    (throw+ (PrunedException'new (Block''get-hash (:stored-header __oldBlock))))
                )

                (let [#_"TransactionOutputChanges" changes (:tx-out-changes __undoBlock)]
                    (doseq [#_"UTXO" out (:tx-outs-spent changes)]
                        (FullPrunedBlockStore'''add-unspent-transaction-output (:block-store this), out)
                    )
                    (doseq [#_"UTXO" out (:tx-outs-created changes)]
                        (FullPrunedBlockStore'''remove-unspent-transaction-output (:block-store this), out)
                    )
                )
            )
            (ยง catch PrunedException _
                (FullPrunedBlockStore'''abort-database-batch-write (:block-store this))
                (throw+)
            )
            (ยง catch BlockStoreException _
                (FullPrunedBlockStore'''abort-database-batch-write (:block-store this))
                (throw+)
            )
        )
        nil
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"FullPrunedBlockChain" BlockChain'''do-set-chain-head [#_"FullPrunedBlockChain" this, #_"StoredBlock" head]
        (assert-state (.isHeldByCurrentThread (:blockchain-lock this)))

        (let [this (update this :block-store FullPrunedBlockStore'''set-verified-chain-head head)]
            (FullPrunedBlockStore'''commit-database-batch-write (:block-store this))
            this
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"void" BlockChain'''not-setting-chain-head [#_"FullPrunedBlockChain" this]
        (FullPrunedBlockStore'''abort-database-batch-write (:block-store this))
        nil
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"StoredBlock" BlockChain'''get-stored-block-in-current-scope [#_"FullPrunedBlockChain" this, #_"Sha256Hash" hash]
        (assert-state (.isHeldByCurrentThread (:blockchain-lock this)))

        (FullPrunedBlockStore'''get-once-undoable-stored-block (:block-store this), hash)
    )
)

;;;
 ; Represents the "getaddr" P2P protocol message, which requests network {@link AddressMessage}s from a peer.
 ; Not to be confused with {@link Address} which is sort of like an account number.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns GetAddrMessage (ยง extends Message)
    (defn #_"GetAddrMessage" GetAddrMessage'new [#_"Ledger" ledger]
        (Message'new ledger)
    )

    #_method
    (defn GetAddrMessage''to-wire
        (#_"String" [] "getaddr")
        (#_"void" [#_"GetAddrMessage" __, #_"ByteArrayOutputStream" _baos]
            nil
        )
    )
)

;;;
 ; Represents the "getblocks" P2P network message, which requests the hashes of the parts of the block chain we're missing.
 ; Those blocks can then be downloaded with a {@link GetDataMessage}.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns GetBlocksMessage (ยง extends Message)
    (def- #_"long" GetBlocksMessage'MAX_BLOCKS 500)

    (defn #_"GetBlocksMessage" GetBlocksMessage'new
        ([#_"Ledger" ledger, #_"List<Sha256Hash>" locator, #_"Sha256Hash" stop]
            (GetBlocksMessage'new ledger, ProtocolVersion'CURRENT, locator, stop))
        ([#_"Ledger" ledger, #_"long" version, #_"List<Sha256Hash>" locator, #_"Sha256Hash" stop]
            (merge (Message'new ledger)
                (hash-map
                    #_"long" :version version
                    #_"List<Sha256Hash>" :locator locator
                    #_"Sha256Hash" :stop-hash stop
                )
            )
        )
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"GetBlocksMessage" GetBlocksMessage'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload]
        (let [#_"long" version (Wire'read-uint32 payload)
              #_"List<Sha256Hash>" locator
                (let [#_"int" n (int (Wire'read-var-int payload))]
                    (when (< GetBlocksMessage'MAX_BLOCKS n)
                        (throw+ (ProtocolException'new (str "Number of locators cannot be > " GetBlocksMessage'MAX_BLOCKS ", received: " n)))
                    )
                    (let [locator (ArrayList. n)]
                        (dotimes [_ n]
                            (ยง ass locator (.add locator, (Wire'read-hash payload)))
                        )
                        locator
                    )
                )
              #_"Sha256Hash" stop (Wire'read-hash payload)]

            (GetBlocksMessage'new ledger, version, locator, stop)
        )
    )

    #_method
    (defn GetBlocksMessage''to-wire
        (#_"String" [] "getblocks")
        (#_"void" [#_"GetBlocksMessage" this, #_"ByteArrayOutputStream" baos]
            ;; Version, for some reason.
            (Wire'write-uint32 ProtocolVersion'CURRENT, baos)
            ;; Then a vector of block hashes.  This is actually a "block locator", a set of block
            ;; identifiers that spans the entire chain with exponentially increasing gaps between
            ;; them, until we end up at the genesis block.  See CBlockLocator::Set().
            (.write baos, (VarInt''encode (VarInt'new (count (:locator this)))))
            (doseq [#_"Sha256Hash" hash (:locator this)]
                ;; Have to reverse as wire format is little endian.
                (.write baos, (Wire'reverse-bytes (:hash-bytes hash)))
            )
            ;; Next, a block ID to stop at.
            (.write baos, (Wire'reverse-bytes (:hash-bytes (:stop-hash this))))
            nil
        )
    )

    #_foreign
    #_override
    (defn #_"boolean" Object'''equals [#_"GetBlocksMessage" this, #_"Object" o]
        (cond
            (= this o) true
            (or (nil? o) (not= (.getClass this) (.getClass o))) false
            :else (let [#_"GetBlocksMessage" that (cast' GetBlocksMessage o)]
                (and (= (:version this) (:version that)) (= (:stop-hash this) (:stop-hash that)) (= (count (:locator this)) (count (:locator that))) (.containsAll (:locator this), (:locator that))) ;; ignores locator ordering
            )
        )
    )

    #_foreign
    #_override
    (defn #_"int" Object'''hashCode [#_"GetBlocksMessage" this]
        (let [#_"int" hash (bit-xor (int (:version this)) (.hashCode "getblocks") (.hashCode (:stop-hash this)))]
            (reduce bit-xor hash (map #(.hashCode %) (:locator this))) ;; ignores locator ordering
        )
    )

    #_method
    (defn #_"String" GetBlocksMessage''to-string [#_"GetBlocksMessage" this]
        (apply str "getblocks: " (interpose " " (:locator this)))
    )
)

;;;
 ; Represents the "getdata" P2P network message, which requests the contents of blocks or transactions given their hashes.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns GetDataMessage (ยง extends ListMessage)
    (defn #_"GetDataMessage" GetDataMessage'new [#_"Ledger" ledger]
        (ListMessage'new ledger)
    )

    ;;;
     ; Deserializes a 'getdata' message.
     ;;
    #_throws #_[ "ProtocolException" ]
    (defn #_"GetDataMessage" GetDataMessage'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload]
        (ListMessage'from-wire ledger, payload)
    )

    #_method
    (defn GetDataMessage''to-wire
        (#_"String" [] "getdata")
        (#_"void" [#_"GetDataMessage" this, #_"ByteArrayOutputStream" baos]
            (ListMessage''to-wire this, baos)
            nil
        )
    )

    #_method
    (defn #_"GetDataMessage" GetDataMessage''add-transaction [#_"GetDataMessage" this, #_"Sha256Hash" hash]
        (ListMessage''add-item this, (InventoryItem'new :InventoryItemType'TRANSACTION, hash))
    )

    #_method
    (defn #_"GetDataMessage" GetDataMessage''add-block [#_"GetDataMessage" this, #_"Sha256Hash" hash]
        (ListMessage''add-item this, (InventoryItem'new :InventoryItemType'BLOCK, hash))
    )

    #_method
    (defn #_"GetDataMessage" GetDataMessage''add-filtered-block [#_"GetDataMessage" this, #_"Sha256Hash" hash]
        (ListMessage''add-item this, (InventoryItem'new :InventoryItemType'FILTERED_BLOCK, hash))
    )

    #_method
    (defn #_"Sha256Hash" GetDataMessage''get-hash-of [#_"GetDataMessage" this, #_"int" i]
        (:item-hash (nth (:items this) i))
    )
)

;;;
 ; The "getheaders" command is structurally identical to "getblocks", but has different meaning.  On receiving this
 ; message a Bitcoin node returns matching blocks up to the limit, but without the bodies.  It is useful as an
 ; optimization: when your wallet does not contain any keys created before a particular time, you don't have to download
 ; the bodies for those blocks because you know there are no relevant transactions.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns GetHeadersMessage (ยง extends GetBlocksMessage)
    (defn #_"GetHeadersMessage" GetHeadersMessage'new [#_"Ledger" ledger, #_"List<Sha256Hash>" locator, #_"Sha256Hash" stop]
        (GetBlocksMessage'new ledger, locator, stop)
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"GetHeadersMessage" GetHeadersMessage'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload]
        (GetBlocksMessage'from-wire ledger, payload)
    )

    #_method
    (defn GetHeadersMessage''to-wire
        (#_"String" [] "getheaders")
        (#_"void" [#_"GetHeadersMessage" this, #_"ByteArrayOutputStream" baos]
            (GetBlocksMessage''to-wire this, baos)
            nil
        )
    )

    ;;;
     ; Compares two getheaders messages.  Note that even though they are structurally identical a GetHeadersMessage
     ; will not compare equal to a GetBlocksMessage containing the same data.
     ;;
    #_foreign
    #_override
    (defn #_"boolean" Object'''equals [#_"GetHeadersMessage" this, #_"Object" o]
        (cond
            (= this o) true
            (or (nil? o) (not= (.getClass this) (.getClass o))) false
            :else (let [#_"GetHeadersMessage" that (cast' GetHeadersMessage o)]
                (and (= (:version this) (:version that)) (= (:stop-hash this) (:stop-hash that)) (= (count (:locator this)) (count (:locator that))) (.containsAll (:locator this), (:locator that))) ;; ignores locator ordering
            )
        )
    )

    #_foreign
    #_override
    (defn #_"int" Object'''hashCode [#_"GetHeadersMessage" this]
        (let [#_"int" hash (bit-xor (int (:version this)) (.hashCode "getheaders") (.hashCode (:stop-hash this)))]
            (reduce bit-xor hash (map #(.hashCode %) (:locator this))) ;; ignores locator ordering
        )
    )

    #_method
    (defn #_"String" GetHeadersMessage''to-string [#_"GetHeadersMessage" this]
        (apply str "getheaders: " (interpose " " (:locator this)))
    )
)

;;;
 ; A protocol message that contains a repeated series of block headers, sent in response to the "getheaders" command.
 ; This is useful when you want to traverse the chain but know you don't care about the block contents, for example,
 ; because you have a freshly created wallet with no keys.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns HeadersMessage (ยง extends Message)
    ;; The main client will never send us more than this number of headers.
    (def #_"int" HeadersMessage'MAX_HEADERS 2000)

    (defn #_"HeadersMessage" HeadersMessage'new [#_"Ledger" ledger, #_"List<Block>" headers]
        (merge (Message'new ledger)
            (hash-map
                #_"List<Block>" :block-headers headers
            )
        )
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"HeadersMessage" HeadersMessage'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload]
        (let [#_"List<Block>" headers
                (let [#_"long" n (Wire'read-var-int payload)]
                    (when (< HeadersMessage'MAX_HEADERS n)
                        (throw+ (ProtocolException'new (str "Too many headers: " n " vs " HeadersMessage'MAX_HEADERS)))
                    )
                    (let [headers (ArrayList. n)]
                        (dotimes [_ n]
                            (let [#_"Block" header (Block'from-wire ledger, payload)]
                                (when (seq (:transactions header))
                                    (throw+ (ProtocolException'new "Block header does not end with a nil byte"))
                                )
                                (ยง ass headers (.add headers, header))
                            )
                        )
                        headers
                    )
                )]

            (HeadersMessage'new ledger, headers)
        )
    )

    #_method
    (defn HeadersMessage''to-wire
        (#_"String" [] "headers")
        (#_"void" [#_"HeadersMessage" this, #_"ByteArrayOutputStream" baos]
            (.write baos, (VarInt''encode (VarInt'new (count (:block-headers this)))))
            (doseq [#_"Block" header (:block-headers this)]
                (Block''to-wire (Block''clone-as-header header), baos)
                (.write baos, 0)
            )
            nil
        )
    )
)

;;;
 ; Thrown to indicate that you don't have enough money available to perform the requested operation.
 ;;
(class-ns InsufficientMoneyException (ยง extends RuntimeException)
    (defn #_"InsufficientMoneyException" InsufficientMoneyException'new [#_"Coin" missing]
        (ensure some? missing)

        (merge (RuntimeException'new (str "Insufficient money, missing " (Coin''to-friendly-string missing)))
            (hash-map
                ;;;
                 ; Contains the number of satoshis that would have been required to complete the operation.
                 ;;
                #_"Coin" :missing missing
            )
        )
    )
)

(def InventoryItemType'enum-map
    (hash-map
        :InventoryItemType'ERROR          0,
        :InventoryItemType'TRANSACTION    1,
        :InventoryItemType'BLOCK          2,
        :InventoryItemType'FILTERED_BLOCK 3,
    )
)

(def InventoryItemType'for-code (clojure.set/map-invert InventoryItemType'enum-map))

(class-ns InventoryItem
    (defn #_"InventoryItem" InventoryItem'new [#_"InventoryItemType" type, #_"Sha256Hash" hash]
        (hash-map
            #_"InventoryItemType" :item-type type
            #_"Sha256Hash" :item-hash hash
        )
    )
)

;;;
 ; Represents the "inv" P2P network message.  An inv contains a list of hashes of either blocks or transactions.
 ; It's a bandwidth optimization - on receiving some data, a (fully validating) peer sends every connected peer an inv
 ; containing the hash of what it saw.  It'll only transmit the full thing if a peer asks for it with a
 ; {@link GetDataMessage}.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns InventoryMessage (ยง extends ListMessage)
    ;;;
     ; A hard coded constant in the protocol.
     ;;
    (def #_"int" InventoryMessage'MAX_INV_SIZE 50000)

    (defn #_"InventoryMessage" InventoryMessage'new [#_"Ledger" ledger]
        (ListMessage'new ledger)
    )

    ;;;
     ; Deserializes an 'inv' message.
     ;;
    #_throws #_[ "ProtocolException" ]
    (defn #_"InventoryMessage" InventoryMessage'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload]
        (ListMessage'from-wire ledger, payload)
    )

    #_method
    (defn InventoryMessage''to-wire
        (#_"String" [] "inv")
        (#_"void" [#_"InventoryMessage" this, #_"ByteArrayOutputStream" baos]
            (ListMessage''to-wire this, baos)
            nil
        )
    )

    #_method
    (defn #_"InventoryMessage" InventoryMessage''add-block [#_"InventoryMessage" this, #_"Block" block]
        (ListMessage''add-item this, (InventoryItem'new :InventoryItemType'BLOCK, (Block''get-hash block)))
    )

    #_method
    (defn #_"InventoryMessage" InventoryMessage''add-transaction [#_"InventoryMessage" this, #_"Transaction" tx]
        (ListMessage''add-item this, (InventoryItem'new :InventoryItemType'TRANSACTION, (Transaction''get-hash tx)))
    )
)

;;;
 ; The "mempool" message asks a remote peer to announce all transactions in its memory pool, possibly restricted by
 ; any Bloom filter set on the connection.  The list of transaction hashes comes back in an inv message.  Note that
 ; this is different to the {@link TxConfidenceTable} object which doesn't try to keep track of all pending transactions,
 ; it's just a holding area for transactions that a part of the app may find interesting.  The mempool message has
 ; no fields.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns MemoryPoolMessage (ยง extends Message)
    (defn #_"MemoryPoolMessage" MemoryPoolMessage'new [#_"Ledger" ledger]
        (Message'new ledger)
    )

    #_method
    (defn MemoryPoolMessage''to-wire
        (#_"String" [] "mempool")
        (#_"void" [#_"MemoryPoolMessage" __, #_"ByteArrayOutputStream" _baos]
            nil
        )
    )
)

(def #_"int" ProtocolVersion'PONG         60001)
(def #_"int" ProtocolVersion'BLOOM_FILTER 70000)
(def #_"int" ProtocolVersion'MINIMUM      ProtocolVersion'BLOOM_FILTER)
(def #_"int" ProtocolVersion'CURRENT      70001)

;;;
 ; Ledger contains the data needed for working with an instantiation of a Bitcoin chain.
 ;
 ; This is an abstract class, concrete instantiations can be found in the params package:
 ; one for the main network ({@link MainLedger}), and one for the public test network.
 ;;
#_abstract
(class-ns Ledger
    (defn- #_"Block" Ledger'create-genesis [#_"Ledger" param]
        (let [#_"Transaction" tx (Transaction'new param)
              ;; A script containing the difficulty bits and the following message: "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks".
              #_"byte[]" bytes (Base16'decode "04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73")]
            (Transaction''add-input tx, (TransactionInput'new-unconnected param, tx, bytes))
            (let [#_"ByteArrayOutputStream" baos (ByteArrayOutputStream.)]
                (Script'write-bytes baos, (Base16'decode "04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f"))
                (.write baos, Script'OP_CHECKSIG)
                (Transaction''add-output tx, (TransactionOutput'for-script param, tx, Coin'FIFTY_COINS, (.toByteArray baos)))
                (let [#_"Block" genesis (Block'new-genesis param, Block'BLOCK_VERSION_GENESIS)]
                    (Block''add-transaction genesis, tx)
                )
            )
        )
    )

    (defn #_"Ledger" Ledger'new []
        (let [this
                (hash-map
                    ;;;
                     ; Genesis block for this chain.
                     ;
                     ; The first block in every chain is a well known constant shared between all Bitcoin implemenetations.
                     ; For a block to be valid, it must be eventually possible to work backwards to the genesis block by following
                     ; the prevBlockHash pointers in the block headers.
                     ;
                     ; The genesis blocks for both test and main networks contain the timestamp of when they were created,
                     ; and a message in the coinbase transaction.  It says,
                     ; <i>"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"</i>.
                     ;;
                    #_"Block" :genesis-block nil
                    ;;;
                     ; Maximum target represents the easiest allowable proof of work.
                     ;;
                    #_"BigInteger" :max-target nil
                    ;;;
                     ; Default TCP port on which to connect to nodes.
                     ;;
                    #_"int" :port 0
                    ;;;
                     ; The header bytes that identify the start of a packet on this network.
                     ; Indicates message origin network and is used to seek to the next message when stream state is unknown.
                     ;;
                    #_"long" :packet-magic 0
                    ;;;
                     ; First byte of a base58 encoded address.  See {@link Address}.
                     ; This is the same as acceptableAddressCodes[0] and is the one used for "normal" addresses.
                     ; Other types of address may be encountered with version codes found in the acceptableAddressCodes array.
                     ;;
                    #_"int" :address-header 0
                    ;;;
                     ; First byte of a base58 encoded P2SH address.  P2SH addresses are defined as part of BIP0013.
                     ;;
                    #_"int" :p2sh-header 0
                    ;;;
                     ; How many blocks pass between difficulty adjustment periods.  Bitcoin standardises this to be 2016.
                     ;;
                    #_"int" :interval 0
                    ;;;
                     ; How much time in seconds is supposed to pass between "interval" blocks.  If the actual elapsed time is
                     ; significantly different from this value, the network difficulty formula will produce a different value.
                     ; Both test and main Bitcoin networks use 2 weeks (1209600 seconds).
                     ;;
                    #_"int" :target-timespan 0
                    ;;;
                     ; 4 byte header for BIP32 (HD) wallet - public key part.
                     ;;
                    #_"int" :bip32-header-pub 0
                    ;;;
                     ; 4 byte header for BIP32 (HD) wallet - private key part.
                     ;;
                    #_"int" :bip32-header-priv 0

                    ;;; Used to check majorities for block version upgrade. ;;

                    ;;;
                     ; The number of blocks in the last {@link getMajorityWindow()} blocks at which to trigger a notice
                     ; to the user to upgrade their client, where the client does not understand those blocks.
                     ;;
                    #_"int" :majority-enforce-block-upgrade 0
                    ;;;
                     ; The number of blocks in the last {@link getMajorityWindow()} blocks at which to enforce the requirement
                     ; that all new blocks are of the newer type (i.e. outdated blocks are rejected).
                     ;;
                    #_"int" :majority-reject-block-outdated 0
                    ;;;
                     ; The sampling window from which the version numbers of blocks are taken
                     ; in order to determine if a new block version is now the majority.
                     ;;
                    #_"int" :majority-window 0
                    ;;;
                     ; The depth of blocks required for a coinbase transaction to be spendable.
                     ;;
                    #_"int" :spendable-coinbase-depth 0
                    #_"int" :subsidy-decrease-block-count 0
                    ;;;
                     ; The version codes that prefix addresses which are acceptable on this network.  Although Satoshi intended these
                     ; to be used for "versioning", in fact they are today used to discriminate what kind of data is contained in the
                     ; address and to prevent accidentally sending coins across chains which would destroy them.
                     ;;
                    #_"int*" :acceptable-address-codes nil
                    ;;;
                     ; DNS names that when resolved, give IP addresses of active peers.
                     ;;
                    #_"String*" :dns-seeds nil
                    ;;;
                     ; IP address of active peers.
                     ;;
                    #_"int*" :addr-seeds nil

                    #_"String*" :textual-checkpoints nil
                    #_"{int Sha256Hash}" :checkpoints (hash-map)

                    #_"boolean" :is-test false
                )]

            (assoc this :genesis-block (Ledger'create-genesis this))
        )
    )

    (def #_"int" Ledger'TARGET_TIMESPAN (* 14 24 60 60)) ;; 2 weeks per difficulty cycle, on average.
    (def #_"int" Ledger'TARGET_SPACING (* 10 60)) ;; 10 minutes per block.
    (def #_"int" Ledger'INTERVAL (quot Ledger'TARGET_TIMESPAN Ledger'TARGET_SPACING))

    (def #_"int" Ledger'REWARD_HALVING_INTERVAL 210000)

    ;;;
     ; Blocks with a timestamp after this should enforce BIP 16, aka "Pay to script hash".  This BIP changed
     ; the network rules in a soft-forking manner, that is, blocks that don't follow the rules are accepted
     ; but not mined upon and thus will be quickly re-orged out as long as the majority are enforcing the rule.
     ;;
    (def #_"int" Ledger'BIP16_ENFORCE_TIME 1333238400)

    ;;;
     ; The maximum number of coins to be generated.
     ;;
    (def #_"long" Ledger'MAX_COINS 21000000)

    ;;;
     ; The maximum money to be generated.
     ;;
    (def #_"Coin" Ledger'MAX_MONEY (Coin''multiply Coin'COIN, Ledger'MAX_COINS))

    ;;;
     ; Checks if we are at a reward halving point.
     ;
     ; @param height The height of the previous stored block.
     ; @return if this is a reward halving point.
     ;;
    #_method
    (defn #_"boolean" Ledger''is-reward-halving-point [#_"Ledger" __, #_"int" height]
        (zero? (rem (inc height) Ledger'REWARD_HALVING_INTERVAL))
    )

    ;;;
     ; Checks if we are at a difficulty transition point.
     ;
     ; @param height The height of the previous stored block.
     ; @return if this is a difficulty transition point.
     ;;
    #_method
    (defn #_"boolean" Ledger''is-difficulty-transition-point [#_"Ledger" this, #_"int" height]
        (zero? (rem (inc height) (:interval this)))
    )

    ;;;
     ; Throws an exception if the block's difficulty is not correct.
     ;
     ; @throws VerificationException if the block's difficulty is not correct.
     ;;
    #_throws #_[ "VerificationException", "BlockStoreException" ]
    #_abstract
    (defn #_"void" Ledger'''check-difficulty-transitions [#_"Ledger" this, #_"StoredBlock" prior, #_"Block" __nextBlock, #_"BlockStore" store]
        ;; Is this supposed to be a difficulty transition point?
        (if-not (Ledger''is-difficulty-transition-point this, (:stored-height prior))
            ;; No ... so check the difficulty didn't actually change.
            (when-not (= (:difficulty-target __nextBlock) (:difficulty-target (:stored-header prior)))
                (throw+ (VerificationException'new (str "Unexpected change in difficulty at height " (:stored-height prior) ": " (Long/toHexString (:difficulty-target __nextBlock)) " vs " (Long/toHexString (:difficulty-target (:stored-header prior))))))
            )
            ;; We need to find a block far back in the chain.  It's OK that this is expensive because it only occurs every
            ;; two weeks after the initial block chain download.
            (let [#_"Stopwatch" watch (Stopwatch/createStarted)
                  [#_"StoredBlock" cursor #_"Sha256Hash" hash]
                    (loop-when [cursor nil hash (Block''get-hash (:stored-header prior)) #_"int" i 0] (< i (:interval this)) => [cursor hash]
                        (let [cursor (BlockStore'''get store, hash)]
                            (recur-if (some? cursor) [cursor (:prev-block-hash (:stored-header cursor)) (inc i)]
                                ;; This should never happen.  If it does, it means we are following an incorrect or busted chain.
                                => (throw+ (VerificationException'new (str "Difficulty transition point, but we did not find a way back to the last transition point.  Not found: " hash)))
                            )
                        )
                    )]
                (assert-state (and (some? cursor) (Ledger''is-difficulty-transition-point this, (dec (:stored-height cursor)))), "Didn't arrive at a transition point.")
                (.stop watch)
                (when (< 50 (.elapsed watch, TimeUnit/MILLISECONDS))
                    (log/info (str "Difficulty transition traversal took " watch))
                )
                (let [#_"int" timespan (int (- (:time-seconds (:stored-header prior)) (:time-seconds (:stored-header cursor))))
                      ;; Limit the adjustment step.
                      #_"int" tts (:target-timespan this) timespan (min (max (quot tts 4) timespan) (* tts 4))
                      #_"BigInteger" __newTarget (.divide (.multiply (Utils'decode-compact-bits (:difficulty-target (:stored-header prior))), (BigInteger/valueOf timespan)), (BigInteger/valueOf tts))
                      __newTarget
                        (when (< (:max-target this) __newTarget) => __newTarget
                            (log/info (str "Difficulty hit proof of work limit: " (.toString __newTarget, 16)))
                            (:max-target this)
                        )
                      #_"long" __receivedTargetCompact (:difficulty-target __nextBlock)
                      #_"int" accuracy (- (int (>>> __receivedTargetCompact 24)) 3)
                      ;; The calculated difficulty is to a higher precision than received, so reduce here.
                      __newTarget (.and __newTarget, (.shiftLeft (BigInteger/valueOf 0xffffff), (* accuracy 8)))
                      #_"long" __newTargetCompact (Utils'encode-compact-bits __newTarget)]
                    (when-not (= __newTargetCompact __receivedTargetCompact)
                        (throw+ (VerificationException'new (str "Network provided difficulty bits do not match what was calculated: " (Long/toHexString __newTargetCompact) " vs " (Long/toHexString __receivedTargetCompact))))
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Returns true if the block height is either not a checkpoint, or is a checkpoint and the hash matches.
     ;;
    #_method
    (defn #_"boolean" Ledger''passes-checkpoint [#_"Ledger" this, #_"int" height, #_"Sha256Hash" hash]
        (let [#_"Sha256Hash" h (get (:checkpoints this) height)]
            (or (nil? h) (= h hash))
        )
    )

    ;;;
     ; Returns true if the given height has a recorded checkpoint.
     ;;
    #_method
    (defn #_"boolean" Ledger''is-checkpoint [#_"Ledger" this, #_"int" height]
        (let [#_"Sha256Hash" h (get (:checkpoints this) height)]
            (some? h)
        )
    )

    ;;;
     ; If we are running in testnet-in-a-box mode, we allow connections to nodes with 0 non-genesis blocks.
     ;;
    #_method
    (defn #_"boolean" Ledger''allow-empty-peer-chain [#_"Ledger" __]
        true
    )

    ;;;
     ; Returns the number of coins that will be produced in total, on this network.
     ; Where not applicable, a very large number of coins is returned
     ; instead (i.e. the main coin issue for Dogecoin).
     ;;
    #_method
    (defn #_"Coin" Ledger''get-max-money [#_"Ledger" __]
        Ledger'MAX_MONEY
    )

    ;;;
     ; Any standard (i.e. pay-to-address) output smaller than this value will
     ; most likely be rejected by the network.
     ;;
    #_method
    (defn #_"Coin" Ledger''get-min-non-dust-output [#_"Ledger" __]
        Transaction'MIN_NONDUST_OUTPUT
    )

    ;;;
     ; Returns whether this network has a maximum number of coins (finite supply) or not.
     ; Always returns true for Bitcoin, but exists to be overridden for other networks.
     ;;
    #_method
    (defn #_"boolean" Ledger''has-max-money [#_"Ledger" __]
        true
    )
    ;;;
     ; The flags indicating which block validation tests should be applied to
     ; the given block.  Enables support for alternative blockchains which enable
     ; tests based on different criteria.
     ;
     ; @param block Block to determine flags for.
     ;;
    #_method
    (defn #_"{BlockVerifyFlag}" Ledger''get-block-verification-flags [#_"Ledger" this, #_"Block" block, #_"VersionTally" tally]
        (let [#_"{BlockVerifyFlag}" flags (hash-set)]
            (when (Block''is-bip34 block) => flags
                (let [#_"Integer" n (VersionTally''get-count-at-or-above tally, Block'BLOCK_VERSION_BIP34)]
                    (when (and (some? n) (<= (:majority-enforce-block-upgrade this) n)) => flags
                        (conj flags :BlockVerifyFlag'HEIGHT_IN_COINBASE)
                    )
                )
            )
        )
    )

    ;;;
     ; The flags indicating which script validation tests should be applied to
     ; the given transaction.  Enables support for alternative blockchains which enable
     ; tests based on different criteria.
     ;
     ; @param block Block the transaction belongs to.
     ; @param transaction to determine flags for.
     ;;
    #_method
    (defn #_"{ScriptVerifyFlag}" Ledger''get-transaction-verification-flags [#_"Ledger" this, #_"Block" block, #_"Transaction" _tx, #_"VersionTally" tally]
        (let [#_"{ScriptVerifyFlag}" flags (hash-set)
              flags
                (when (<= Ledger'BIP16_ENFORCE_TIME (:time-seconds block)) => flags
                    (conj flags :ScriptVerifyFlag'P2SH)
                )]
            ;; Start enforcing CHECKLOCKTIMEVERIFY (BIP65) for block.nVersion=4 blocks,
            ;; when 75% of the network has been upgraded:
            (when (and (<= Block'BLOCK_VERSION_BIP65 (:version block)) (< (:majority-enforce-block-upgrade this) (VersionTally''get-count-at-or-above tally, Block'BLOCK_VERSION_BIP65))) => flags
                (conj flags :ScriptVerifyFlag'CHECKLOCKTIMEVERIFY)
            )
        )
    )
)

;;;
 ; Sent by a peer when a getdata request doesn't find the requested data in the mempool.  It has the same format
 ; as an inventory message and lists the hashes of the missing items.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns NotFoundMessage (ยง extends InventoryMessage)
    (def #_"int" NotFoundMessage'MIN_PROTOCOL_VERSION 70001)

    (defn #_"NotFoundMessage" NotFoundMessage'new [#_"Ledger" ledger]
        (InventoryMessage'new ledger)
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"NotFoundMessage" NotFoundMessage'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload]
        (InventoryMessage'from-wire ledger, payload)
    )

    #_method
    (defn NotFoundMessage''to-wire
        (#_"String" [] "notfound")
        (#_"void" [#_"NotFoundMessage" this, #_"ByteArrayOutputStream" baos]
            (InventoryMessage''to-wire this, baos)
            nil
        )
    )
)

(class-ns ValuesUsed
    (defn- #_"ValuesUsed" ValuesUsed'new []
        (hash-map
            #_"int" :bits-used 0
            #_"int" :hashes-used 0
        )
    )
)

;;;
 ; A data structure that contains proofs of block inclusion for one or more transactions, in an efficient manner.
 ;
 ; The encoding works as follows: we traverse the tree in depth-first order, storing a bit for each traversed node,
 ; signifying whether the node is the parent of at least one matched leaf txid (or a matched txid itself).  In case we
 ; are at the leaf level, or this bit is 0, its merkle node hash is stored, and its children are not explored further.
 ; Otherwise, no hash is stored, but we recurse into both (or the only) child branch.  During decoding, the same
 ; depth-first traversal is performed, consuming bits and hashes as they were written during encoding.
 ;
 ; The serialization is fixed and provides a hard guarantee about the encoded size,
 ; SIZE <= 10 + ceil(32.25 * N) where N represents the number of leaf nodes of the partial tree.
 ; N itself is bounded by:
 ;
 ; N <= total_transactions
 ; N <= 1 + matched_transactions * tree_height
 ;
 ; The serialization format:
 ;  - uint32     total_transactions (4 bytes)
 ;  - varint     number of hashes (1-3 bytes)
 ;  - uint256[]  hashes in depth-first order (<= 32*N bytes)
 ;  - varint     number of bytes of flag bits (1-3 bytes)
 ;  - byte[]     flag bits, packed per 8 in a byte, least significant bit first (<= 2*N-1 bits)
 ; The size constraints follow from this.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns PartialMerkleTree (ยง extends Message)
    ;;;
     ; Constructs a new PMT with the given bit set (little endian) and the raw list of hashes including internal hashes,
     ; taking ownership of the list.
     ;;
    (defn #_"PartialMerkleTree" PartialMerkleTree'new [#_"Ledger" ledger, #_"byte[]" bits, #_"List<Sha256Hash>" hashes, #_"int" cnt]
        (merge (Message'new ledger)
            (hash-map
                ;; the total number of transactions in the block
                #_"int" :transaction-count cnt

                ;; txids and internal hashes
                #_"List<Sha256Hash>" :hashes hashes

                ;; node-is-parent-of-matched-txid bits
                #_"byte[]" :matched-child-bits bits
            )
        )
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"PartialMerkleTree" PartialMerkleTree'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload]
        (let [#_"int" cnt (int (Wire'read-uint32 payload))
              #_"List<Sha256Hash>" hashes
                (let [#_"int" n (int (Wire'read-var-int payload)) hashes (ArrayList. n)]
                    (dotimes [_ n]
                        (ยง ass hashes (.add hashes, (Wire'read-hash payload)))
                    )
                    hashes
                )
              #_"byte[]" bits (Wire'read-byte-array payload)]

            (PartialMerkleTree'new ledger, bits, hashes, cnt)
        )
    )

    #_method
    (defn PartialMerkleTree''to-wire
        (#_"String" [] nil)
        (#_"void" [#_"PartialMerkleTree" this, #_"ByteArrayOutputStream" baos]
            (Wire'write-uint32 (:transaction-count this), baos)
            (.write baos, (VarInt''encode (VarInt'new (count (:hashes this)))))
            (doseq [#_"Sha256Hash" hash (:hashes this)]
                (.write baos, (Wire'reverse-bytes (:hash-bytes hash)))
            )
            (Wire'write-byte-array (:matched-child-bits this), baos)
            nil
        )
    )

    ;;;
     ; Calculates a PMT given the list of leaf hashes and which leaves need to be included.  The relevant interior hashes
     ; are calculated and a new PMT returned.
     ;;
    (defn #_"PartialMerkleTree" PartialMerkleTree'build-from-leaves [#_"Ledger" ledger, #_"byte[]" __includeBits, #_"List<Sha256Hash>" leaves]
        ;; Calculate height of the tree.
        (let [#_"int" height (loop-when-recur [h 0] (< 1 (PartialMerkleTree'get-tree-width (count leaves), h)) [(inc h)] => h)
              #_"List<Boolean>" __bitList (ArrayList.) #_"List<Sha256Hash>" hashes (ArrayList.)]
            (PartialMerkleTree'traverse-and-build height, 0, leaves, __includeBits, __bitList, hashes)
            (let [#_"int" n (count __bitList) #_"byte[]" bits (byte-array (int (Math/ceil (/ n 8.0))))]
                (dotimes [#_"int" i n]
                    (when (nth __bitList i)
                        (Utils'set-bit-le bits, i)
                    )
                )
                (PartialMerkleTree'new ledger, bits, hashes, (count leaves))
            )
        )
    )

    (defn- #_"void" PartialMerkleTree'traverse-and-build [#_"int" height, #_"int" pos, #_"List<Sha256Hash>" leaves, #_"byte[]" __includeBits, #_"List<Boolean>" __bitList, #_"List<Sha256Hash>" hashes]
        ;; Is this node a parent of at least one matched hash?
        (let [#_"boolean" parent?
                (loop-when [#_"int" p (<< pos height)] (and (< p (<< (inc pos) height)) (< p (count leaves))) => false
                    (or (Utils'check-bit-le __includeBits, p) (recur (inc p)))
                )]
            ;; Store as a flag bit.
            (ยง ass __bitList (.add __bitList, parent?))
            (if (or (zero? height) (not parent?))
                ;; If at height 0, or nothing interesting below, store hash and stop.
                (ยง ass hashes (.add hashes, (PartialMerkleTree'calc-hash height, pos, leaves)))
                ;; Otherwise descend into the subtrees.
                (let [#_"int" h (dec height) #_"int" p (* pos 2)]
                    (PartialMerkleTree'traverse-and-build h, p, leaves, __includeBits, __bitList, hashes)
                    (when (< (inc p) (PartialMerkleTree'get-tree-width (count leaves), h))
                        (PartialMerkleTree'traverse-and-build h, (inc p), leaves, __includeBits, __bitList, hashes)
                    )
                )
            )
        )
        nil
    )

    ;; Helper function to efficiently calculate the number of nodes at given height in the merkle tree.
    (defn- #_"int" PartialMerkleTree'get-tree-width [#_"int" __transactionCount, #_"int" height]
        (>> (dec (+ __transactionCount (<< 1 height))) height)
    )

    (defn- #_"Sha256Hash" PartialMerkleTree'combine-left-right [#_"byte[]" left, #_"byte[]" right]
        (Sha256Hash'wrap (Wire'reverse-bytes (Sha256Hash'hash-twins-twice (Wire'reverse-bytes left), 0, 32, (Wire'reverse-bytes right), 0, 32)))
    )

    (defn- #_"Sha256Hash" PartialMerkleTree'calc-hash [#_"int" height, #_"int" pos, #_"List<Sha256Hash>" hashes]
        ;; Hash at height 0 is just the regular tx hash itself.
        (if (zero? height)
            (nth hashes pos)
            (let [#_"int" h (dec height) #_"int" p (* pos 2)
                  #_"Sha256Hash" l (PartialMerkleTree'calc-hash h, p, hashes)
                  ;; Calculate right hash if not beyond the end of the array - copy left hash otherwise.
                  #_"Sha256Hash" r (if (< (inc p) (PartialMerkleTree'get-tree-width (count hashes), h)) (PartialMerkleTree'calc-hash h, (inc p), hashes) l)]
                (PartialMerkleTree'combine-left-right (:hash-bytes l), (:hash-bytes r))
            )
        )
    )

    ;; Recursive function that traverses tree nodes, consuming the bits and hashes produced by TraverseAndBuild.
    ;; It returns the hash of the respective node.
    #_throws #_[ "VerificationException" ]
    #_method
    (defn- #_"Sha256Hash" PartialMerkleTree''recursive-extract-hashes [#_"PartialMerkleTree" this, #_"int" height, #_"int" pos, #_"ValuesUsed" used, #_"List<Sha256Hash>" hashes]
        ;; overflowed bits array - failure
        (when (<= (<< (count (:matched-child-bits this)) 3) (:bits-used used))
            (throw+ (VerificationException'new "PartialMerkleTree overflowed its bits array"))
        )
        (let [#_"boolean" parent? (Utils'check-bit-le (:matched-child-bits this), (:bits-used used))]
            (ยง ass used (update used :bits-used inc))
            ;; if at height 0, or nothing interesting below, use stored hash and do not descend
            (if (or (zero? height) (not parent?))
                (do
                    ;; overflowed hash array - failure
                    (when (<= (count (:hashes this)) (:hashes-used used))
                        (throw+ (VerificationException'new "PartialMerkleTree overflowed its hash array"))
                    )
                    (let [#_"Sha256Hash" hash (get (:hashes this) (:hashes-used used))]
                        (ยง ass used (update used :hashes-used inc))
                        ;; in case of height 0, we have a matched txid
                        (when (and (zero? height) parent?)
                            (ยง ass hashes (.add hashes, hash))
                        )
                        hash
                    )
                )
                ;; otherwise, descend into the subtrees to extract matched txids and hashes
                (let [#_"int" h (dec height) #_"int" p (* pos 2)
                      #_"byte[]" left (:hash-bytes (PartialMerkleTree''recursive-extract-hashes this, h, p, used, hashes))
                      #_"byte[]" right
                        (if (< (inc p) (PartialMerkleTree'get-tree-width (:transaction-count this), h))
                            (let [right (:hash-bytes (PartialMerkleTree''recursive-extract-hashes this, h, (inc p), used, hashes))]
                                (when (Arrays/equals right, left)
                                    (throw+ (VerificationException'new "Invalid merkle tree with duplicated left/right branches"))
                                )
                                right
                            )
                            left
                        )]
                    ;; and combine them before returning
                    (PartialMerkleTree'combine-left-right left, right)
                )
            )
        )
    )

    ;;;
     ; Extracts tx hashes that are in this merkle tree and returns the merkle root of this tree.
     ;
     ; The returned root should be checked against the merkle root contained in the block header for security.
     ;
     ; @param matches A list which will contain the matched txn (will be cleared).
     ; @return the merkle root of this merkle tree.
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn #_"[Sha256Hash List<Sha256Hash>]" PartialMerkleTree''get-txn-hash-and-merkle-root [#_"PartialMerkleTree" this]
        ;; an empty set will not work
        (when (zero? (:transaction-count this))
            (throw+ (VerificationException'new "Got a PartialMerkleTree with 0 transactions"))
        )
        ;; check for excessively high numbers of transactions
        (when (< (quot Block'MAX_BLOCK_SIZE 60) (:transaction-count this)) ;; 60 is the lower bound for the size of a serialized CTransaction
            (throw+ (VerificationException'new "Got a PartialMerkleTree with more transactions than is possible"))
        )
        ;; there can never be more hashes provided than one for every txid
        (when (< (:transaction-count this) (count (:hashes this)))
            (throw+ (VerificationException'new "Got a PartialMerkleTree with more hashes than transactions"))
        )
        ;; there must be at least one bit per node in the partial tree, and at least one node per hash
        (when (< (<< (count (:matched-child-bits this)) 3) (count (:hashes this)))
            (throw+ (VerificationException'new "Got a PartialMerkleTree with fewer matched bits than hashes"))
        )

        ;; calculate height of tree
        (let [#_"int" height (loop-when-recur [h 0] (< 1 (PartialMerkleTree'get-tree-width (:transaction-count this), h)) [(inc h)] => h)
              ;; traverse the partial tree
              #_"ValuesUsed" used (ValuesUsed'new)
              #_"List<Sha256Hash>" matches (LinkedList.)
              #_"Sha256Hash" root (PartialMerkleTree''recursive-extract-hashes this, height, 0, used, matches)]
            ;; verify that all bits were consumed (except for the padding caused by serializing it as a byte sequence)
            ;; verify that all hashes were consumed
            (when-not (and (= (quot (+ (:bits-used used) 7) 8) (count (:matched-child-bits this))) (= (:hashes-used used) (count (:hashes this))))
                (throw+ (VerificationException'new "Got a PartialMerkleTree that didn't need all the data it provided"))
            )
            [root matches]
        )
    )

    #_method
    (defn #_"String" PartialMerkleTree''to-string [#_"PartialMerkleTree" this]
        (str "PartialMerkleTree{" "transactionCount=" (:transaction-count this) ", matchedChildBits=" (vec (:matched-child-bits this)) ", hashes=" (:hashes this) "}")
    )
)

(class-ns GetDataRequest
    (defn #_"GetDataRequest" GetDataRequest'new [#_"Sha256Hash" hash, #_"SettableFuture" future]
        (hash-map
            #_"Sha256Hash" :request-hash hash
            #_"SettableFuture" :future future
        )
    )
)

(class-ns PendingPing
    (defn #_"PendingPing" PendingPing'new [#_"Peer" peer, #_"long" nonce]
        (hash-map
            #_"Peer" :peer (ensure some? peer)
            ;; The future that will be invoked when the pong is heard back.
            #_"SettableFuture<Long>" :future (SettableFuture/create)
            ;; The random nonce that lets us tell apart overlapping pings/pongs.
            #_"long" :nonce nonce
            ;; Measurement of the time elapsed.
            #_"long" :start-time-msec (Time'now)
        )
    )

    #_method
    (defn #_"PendingPing" PendingPing''complete [#_"PendingPing" this]
        (when-not (.isDone (:future this)) => this
            (let [#_"Long" elapsed (- (Time'now) (:start-time-msec this)) this (update this :peer Peer''add-ping-time-data elapsed)]
                (log/debug (str (:peer this) ": ping time is " elapsed " msec"))
                (.set (:future this), elapsed)
                this
            )
        )
    )
)

;;;
 ; A generic handler which is used in {@link NioServer} and {@link NioClient} to handle incoming data streams.
 ;;
(defprotocol StreamConnection
    ;;; Called when the connection socket is closed. ;;
    #_abstract
    (#_"StreamConnection" StreamConnection'''connection-closed [#_"StreamConnection" this])

    ;;; Called when the connection socket is first opened. ;;
    #_abstract
    (#_"StreamConnection" StreamConnection'''connection-opened [#_"StreamConnection" this])

    ;;;
     ; Called when new bytes are available from the remote end.  This should only ever be called by the single
     ; writeTarget associated with any given StreamConnection, multiple callers will likely confuse implementations.
     ;
     ; Implementers/callers must follow the following conventions exactly:
     ; <ul>
     ; <li>buff will start with its limit set to the position we can read to and its position set to the location we
     ;     will start reading at (always 0).</li>
     ; <li>May read more than one message (recursively) if there are enough bytes available.</li>
     ; <li>Uses some internal buffering to store message which are larger (incl. their length prefix) than buff's
     ;     capacity(), i.e. it is up to this method to ensure we dont run out of buffer space to decode the next message.</li>
     ; <li>buff will end with its limit the same as it was previously, and its position set to the position up to which
     ;     bytes have been read (the same as its return value).</li>
     ; <li>buff must be at least the size of a Bitcoin header (incl. magic bytes).</li>
     ; </ul>
     ;
     ; @return the amount of bytes consumed which should not be provided again.
     ;;
    #_throws #_[ "Exception" ]
    #_abstract
    (#_"int" StreamConnection'''receive-bytes [#_"StreamConnection" this, #_"ByteBuffer" buff])

    ;;;
     ; Called when this connection is attached to an upstream write target (i.e. a low-level connection handler).
     ; This writeTarget should be stored and used to close the connection or write data to the socket.
     ;;
    #_abstract
    (#_"StreamConnection" StreamConnection'''set-write-target [#_"StreamConnection" this, #_"MessageWriteTarget" target])

    ;;;
     ; Returns the maximum message size of a message on the socket. This is used in calculating size of buffers
     ; to allocate.
     ;;
    #_abstract
    (#_"int" StreamConnection'''get-max-message-size [#_"StreamConnection" this])
)

;;;
 ; A factory which generates new {@link StreamConnection}s when a new connection is opened.
 ;;
(defprotocol StreamConnectionFactory
    ;;;
     ; Returns a new handler or null to have the connection close.
     ;
     ; @param inetAddress The client's (IP) address.
     ; @param port The remote port on the client side.
     ;;
    #_abstract
    (#_"StreamConnection" StreamConnectionFactory'''get-new-connection [#_"StreamConnectionFactory" this, #_"InetAddress" __inetAddress, #_"int" port])
)

;;;
 ; A Peer handles the high level communication with a Bitcoin node, extending a {@link PeerSocketHandler}
 ; which handles low-level message (de)serialization.
 ;
 ; Note that timeouts are handled by the extended {@link AbstractTimeoutHandler} and timeout is automatically
 ; disabled (using {@link AbstractTimeoutHandler#setTimeoutEnabled(boolean)}) once the version handshake completes.
 ;;
(class-ns Peer (ยง extends AbstractTimeoutHandler) (ยง implements StreamConnection)
    ;; How frequently to refresh the filter.  This should become dynamic in future and calculated depending on
    ;; the actual false positive rate.  For now a good value was determined empirically around January 2013.
    (def- #_"int" Peer'RESEND_BLOOM_FILTER_BLOCK_COUNT 25000)

    (def- #_"int" Peer'PING_MOVING_AVERAGE_WINDOW 20)

    ;;;
     ; Construct a peer that reads/writes from the given block chain.  Transactions stored in a {@link TxConfidenceTable}
     ; will have their confidence levels updated when a peer announces it, to reflect the greater likelyhood that
     ; the transaction is valid.
     ;
     ; Note that this does <b>NOT</b> make a connection to the given remoteAddress, it only creates a handler
     ; for a connection.  If you want to create a one-off connection, create a Peer and pass it to
     ; {@link NioClientManager#openConnection(java.net.SocketAddress, StreamConnection)}
     ; or
     ; {@link NioClient#NioClient(java.net.SocketAddress, StreamConnection, int)}.
     ;
     ; The remoteAddress provided should match the remote address of the peer which is being connected to,
     ; and is used to keep track of which peers relayed transactions and offer more descriptive logging.
     ;;
    (defn #_"Peer" Peer'new
        ([#_"Ledger" ledger, #_"VersionMessage" ver, #_"PeerAddress" address, #_"BlockChain" chain]
            (Peer'new ledger, ver, address, chain, Integer/MAX_VALUE))
        ([#_"Ledger" ledger, #_"VersionMessage" ver, #_"PeerAddress" address, #_"BlockChain" chain, #_"int" depth]
            (let [this
                    (merge (AbstractTimeoutHandler'new)
                        (hash-map
                            #_"Object" :peer-lock (Object.)

                            #_"Ledger" :ledger (ensure some? ledger)
                            ;;;
                             ; The version data to announce to the other side of the connections we make.
                             ;;
                            #_"VersionMessage" :version-message (ensure some? ver)
                            #_"PeerAddress" :peer-address (ensure some? address)
                            #_"BlockChain" :block-chain chain ;; Allowed to be nil.

                            #_"Object" :peersocket-lock (Object.)

                            ;; If we close() before we know our writeTarget, set this to true to call writeTarget.closeConnection() right away.
                            #_"boolean" :close-pending false
                            ;; writeTarget will be thread-safe, and may call into PeerGroup, which calls us, so we should call it unlocked.
                            #_testing
                            #_"MessageWriteTarget" :write-target nil

                            #_"[BlocksDownloadedEventListener]" :blocks-downloaded-event-listeners (vector)
                            #_"[ChainDownloadStartedEventListener]" :chain-download-started-event-listeners (vector)
                            #_"[PeerConnectedEventListener]" :connected-event-listeners (vector)
                            #_"[PeerDisconnectedEventListener]" :disconnected-event-listeners (vector)
                            #_"[GetDataEventListener]" :get-data-event-listeners (vector)
                            #_"[PreMessageReceivedEventListener]" :pre-message-received-event-listeners (vector)
                            #_"[OnTransactionBroadcastListener]" :on-transaction-event-listeners (vector)

                            ;;;
                             ; Whether to try downloading blocks and transactions from this peer.  Set to false by PeerGroup if not the
                             ; primary peer.  This is to avoid redundant work and concurrency problems with downloading the same chain
                             ; in parallel.  Changing this value from false to true may trigger a request to the remote peer
                             ; for the contents of its memory pool, if Bloom filtering is active.
                             ;;
                            #_volatile
                            #_"boolean" :v-download-data (some? chain)
                            ;;;
                             ; Maximum depth up to which pending transaction dependencies are downloaded, or 0 for disabled.
                             ;
                             ; If enabled, this peer will use getdata/notfound messages to walk backwards through transaction dependencies
                             ; before handing the transaction off to the wallet.  The wallet can do risk analysis on pending/recent transactions
                             ; to try and discover if a pending tx might be at risk of double spending.
                             ;;
                            #_volatile
                            #_"int" :v-download-tx-dependency-depth (if (some? chain) depth 0)
                            ;; How many block messages the peer has announced to us.  Peers only announce blocks that attach to their best chain,
                            ;; so we can use this to calculate the height of the peers chain, by adding it to the initial height in the version
                            ;; message.  This method can go wrong if the peer re-orgs onto a shorter (but harder) chain, however, this is rare.
                            #_"AtomicInteger" :blocks-announced (AtomicInteger. 0)
                            ;; Each wallet added to the peer will be notified of downloaded transaction data.
                            #_"[Wallet]" :wallets (vector)
                            ;; A time before which we only download block headers, after that point we download block bodies.
                            #_"long" :fast-catchup-time-secs (:time-seconds (:genesis-block ledger))
                            ;; Whether we are currently downloading headers only or block bodies.  Starts at true.  If the fast catchup time is
                            ;; set AND our best block is before that date, switch to false until block headers beyond that point have been
                            ;; received at which point it gets set to true again.  This isn't relevant unless vDownloadData is true.
                            #_"boolean" :download-block-bodies true
                            ;; Whether to request filtered blocks instead of full blocks if the protocol version allows for them.
                            #_"boolean" :use-filtered-blocks false
                            ;;;
                             ; The last {@link BloomFilter} set by {@link Peer#setBloomFilter(BloomFilter)}.
                             ; Bloom filters tell the remote node what transactions to send us, in a compact manner.
                             ;;
                            #_volatile
                            #_"BloomFilter" :v-bloom-filter nil
                            ;; The last filtered block we received, we're waiting to fill it out with transactions.
                            #_"FilteredBlock" :current-filtered-block nil
                            ;; How many filtered blocks have been received during the lifetime of this connection.  Used to decide when to
                            ;; refresh the server-side side filter by sending a new one (it degrades over time as false positives are added
                            ;; on the remote side, see BIP 37 for a discussion of this).
                            ;; TODO: Is this still needed?  It should not be since the auto FP tracking logic was added.
                            #_"int" :filtered-blocks-received 0
                            ;; If non-null, we should discard incoming filtered blocks because we ran out of keys and are awaiting a new filter
                            ;; to be calculated by the PeerGroup.  The discarded block hashes should be added here so we can re-request them
                            ;; once we've recalculated and resent a new filter.
                            #_"List<Sha256Hash>" :awaiting-fresh-filter nil
                            ;; Keeps track of things we requested internally with getdata but didn't receive yet, so we can avoid re-requests.
                            ;; It's not quite the same as getDataFutures, as this is used only for getdatas done as part of downloading
                            ;; the chain and so is lighter weight (we just keep a bunch of hashes not futures).
                            ;;
                            ;; It is important to avoid a nasty edge case where we can end up with parallel chain downloads proceeding
                            ;; simultaneously if we were to receive a newly solved block whilst parts of the chain are streaming to us.
                            #_"HashSet<Sha256Hash>" :pending-block-downloads (HashSet.)
                            ;; Keep references to TransactionConfidence objects for transactions that were announced by a remote peer,
                            ;; but which we haven't downloaded yet.  These objects are de-duplicated by the TxConfidenceTable class.
                            ;; Once the tx is downloaded (by some peer), the Transaction object that is created will have a reference to
                            ;; the confidence object held inside it, and it's then up to the event listeners that receive the Transaction
                            ;; to keep it pinned to the root set if they care about this data.
                            #_"HashSet<TransactionConfidence>" :pending-tx-downloads (HashSet.)
                            ;; The lowest version number we're willing to accept.  Lower than this will result in an immediate disconnect.
                            #_volatile
                            #_"int" :v-min-protocol-version ProtocolVersion'PONG
                            ;; When an API user explicitly requests a block or transaction from a peer, the InventoryItem is put here
                            ;; whilst waiting for the response.  Is not used for downloads Peer generates itself.
                            ;; TODO: The types/locking should be rationalised a bit.
                            #_"[GetDataRequest]" :get-data-futures (vector)
                            #_"LinkedList<SettableFuture<AddressMessage>>" :get-addr-futures (LinkedList.)

                            ;; Outstanding pings against this peer and how long the last one took to complete.
                            #_"Object" :lastping-lock (Object.)
                            #_"[long]" :last-ping-times (vector-of :long)
                            #_"[PendingPing]" :pending-pings (vector)

                            ;;;
                             ; Version data announced by the remote peer.
                             ;;
                            #_volatile
                            #_"VersionMessage" :v-peer-version-message nil

                            ;;;
                             ; Provides a ListenableFuture that can be used to wait for the socket to connect.
                             ; A socket connection does not mean that protocol handshake has occurred.
                             ;;
                            #_"SettableFuture<Peer>" :connection-open-future (SettableFuture/create)
                            #_"SettableFuture<Peer>" :outgoing-version-handshake-future (SettableFuture/create)
                            #_"SettableFuture<Peer>" :incoming-version-handshake-future (SettableFuture/create)
                            #_"ListenableFuture<Peer>" :version-handshake-future nil

                            ;; Keep track of the last request we made to the peer in blockChainDownloadLocked so we can avoid redundant
                            ;; and harmful getblocks requests.
                            #_"Sha256Hash" :last-get-blocks-begin nil
                            #_"Sha256Hash" :last-get-blocks-end nil
                        )
                    )
                  this
                    (assoc this :version-handshake-future
                        (Futures/transform (Futures/allAsList (object-array [ (:outgoing-version-handshake-future this), (:incoming-version-handshake-future this) ])),
                            (reify Function #_"<List<Peer>, Peer>"
                                #_foreign
                                #_override
                                (#_"Peer" apply [#_"Function" __, #_"List<Peer>" peers]
                                    (ensure some? peers)
                                    (assert-state (and (= (count peers) 2) (= (nth peers 0) (nth peers 1))))
                                    (nth peers 0)
                                )
                            )
                        )
                    )]

                (.addListener (:version-handshake-future this), #(ยง non-void Peer''version-handshake-complete this), Threading'SAME_THREAD)
                this
            )
        )
    )

    ;;; Registers a listener that is invoked when new blocks are downloaded. ;;
    #_method
    (defn #_"Peer" Peer''add-blocks-downloaded-event-listener [#_"Peer" this, #_"BlocksDownloadedEventListener" listener]
        (append* this :blocks-downloaded-event-listeners listener)
    )

    ;;; Registers a listener that is invoked when a blockchain download starts. ;;
    #_method
    (defn #_"Peer" Peer''add-chain-download-started-event-listener [#_"Peer" this, #_"ChainDownloadStartedEventListener" listener]
        (append* this :chain-download-started-event-listeners listener)
    )

    ;;; Registers a listener that is invoked when a peer is connected. ;;
    #_method
    (defn #_"Peer" Peer''add-connected-event-listener [#_"Peer" this, #_"PeerConnectedEventListener" listener]
        (append* this :connected-event-listeners listener)
    )

    ;;; Registers a listener that is invoked when a peer is disconnected. ;;
    #_method
    (defn #_"Peer" Peer''add-disconnected-event-listener [#_"Peer" this, #_"PeerDisconnectedEventListener" listener]
        (append* this :disconnected-event-listeners listener)
    )

    ;;; Registers a listener that is called when messages are received. ;;
    #_method
    (defn #_"Peer" Peer''add-get-data-event-listener [#_"Peer" this, #_"GetDataEventListener" listener]
        (append* this :get-data-event-listeners listener)
    )

    ;;; Registers a listener that is called when a transaction is broadcast across the network. ;;
    #_method
    (defn #_"Peer" Peer''add-on-transaction-broadcast-listener [#_"Peer" this, #_"OnTransactionBroadcastListener" listener]
        (append* this :on-transaction-event-listeners listener)
    )

    ;;; Registers a listener that is called immediately before a message is received. ;;
    #_method
    (defn #_"Peer" Peer''add-pre-message-received-event-listener [#_"Peer" this, #_"PreMessageReceivedEventListener" listener]
        (append* this :pre-message-received-event-listeners listener)
    )

    #_method
    (defn #_"Peer" Peer''remove-blocks-downloaded-event-listener [#_"Peer" this, #_"BlocksDownloadedEventListener" listener]
        (remove* this :blocks-downloaded-event-listeners = listener)
    )

    #_method
    (defn #_"Peer" Peer''remove-chain-download-started-event-listener [#_"Peer" this, #_"ChainDownloadStartedEventListener" listener]
        (remove* this :chain-download-started-event-listeners = listener)
    )

    #_method
    (defn #_"Peer" Peer''remove-connected-event-listener [#_"Peer" this, #_"PeerConnectedEventListener" listener]
        (remove* this :connected-event-listeners = listener)
    )

    #_method
    (defn #_"Peer" Peer''remove-disconnected-event-listener [#_"Peer" this, #_"PeerDisconnectedEventListener" listener]
        (remove* this :disconnected-event-listeners = listener)
    )

    #_method
    (defn #_"Peer" Peer''remove-get-data-event-listener [#_"Peer" this, #_"GetDataEventListener" listener]
        (remove* this :get-data-event-listeners = listener)
    )

    #_method
    (defn #_"Peer" Peer''remove-on-transaction-broadcast-listener [#_"Peer" this, #_"OnTransactionBroadcastListener" listener]
        (remove* this :on-transaction-event-listeners = listener)
    )

    #_method
    (defn #_"Peer" Peer''remove-pre-message-received-event-listener [#_"Peer" this, #_"PreMessageReceivedEventListener" listener]
        (remove* this :pre-message-received-event-listeners = listener)
    )

    ;;;
     ; Sends the given message to the peer.  Due to the asynchronousness of network programming, there is no guarantee
     ; the peer will have received it.  Throws NotYetConnectedException if we are not yet connected to the remote peer.
     ; TODO: Maybe use something other than the unchecked NotYetConnectedException here.
     ;;
    #_throws #_[ "NotYetConnectedException" ]
    #_method
    (defn #_"Peer" Peer''send-message [#_"Peer" this, #_"Message" message, f'to-wire]
        (sync (:peersocket-lock this)
            (or (:write-target this) (throw (NotYetConnectedException.)))
        )
        ;; TODO: Some round-tripping could be avoided here.
        (let [#_"ByteArrayOutputStream" baos (ByteArrayOutputStream.)]
            (Wire'serialize-3 (:ledger this), message, f'to-wire, baos)
            (update this :write-target MessageWriteTarget'''write-bytes (.toByteArray baos))
        )
    )

    ;;;
     ; Closes the connection to the peer if one exists, or immediately closes the connection as soon as it opens.
     ;;
    #_method
    (defn #_"Peer" Peer''close [#_"Peer" this]
        (let [[this close?]
                (sync (:peersocket-lock this)
                    (if (some? (:write-target this)) [this true] [(assoc this :close-pending true) false])
                )]
            (when close? => this
                (update this :write-target MessageWriteTarget'''close-connection)
            )
        )
    )

    #_override
    (defn #_"Peer" AbstractTimeoutHandler'''timeout-occurred [#_"Peer" this]
        (log/info (str (:peer-address this) ": Timed out"))
        (let [this (Peer''close this)]
            (when-not (.isDone (:connection-open-future this)) => this
                ;; Invoke the event handlers to tell listeners (e.g. PeerGroup) that we never managed to connect.
                (StreamConnection'''connection-closed this)
            )
        )
    )

    #_override
    (defn #_"Peer" StreamConnection'''connection-closed [#_"Peer" this]
        (doseq [#_"PeerDisconnectedEventListener" l (:disconnected-event-listeners this)]
            (ยง async?
                (ยง ass l (PeerDisconnectedEventListener'''on-peer-disconnected l, this))
            )
        )
        this
    )

    #_override
    (defn #_"Peer" StreamConnection'''connection-opened [#_"Peer" this]
        ;; Announce ourselves.  This has to come first to connect to clients beyond v0.3.20.2 which wait to hear
        ;; from us until they send their version message back.
        (let [#_"PeerAddress" address (:peer-address this)]
            (log/info (str "Announcing to " (if (some? address) (PeerAddress''to-socket-address address) "Peer")))
            (let [this (Peer''send-message this, (:version-message this), VersionMessage''to-wire)]
                (.set (:connection-open-future this), this)
                ;; When connecting, the remote peer sends us a version message with various bits of useful data in it.
                ;; We need to know the peer protocol version before we can talk to it.
                this
            )
        )
    )

    #_override
    (defn #_"int" StreamConnection'''receive-bytes [#_"Peer" this, #_"ByteBuffer" wire]
        (assert-argument (and (zero? (.position wire)) (<= (+ BitcoinPacketHeader'HEADER_LENGTH 4) (.capacity wire))))

        (try
            ;; Repeatedly try to deserialize messages until we hit a BufferUnderflowException.
            (loop [#_"boolean" first? true]
                (let [#_"int" mark (.position wire)
                      #_"Message" message
                        (try
                            (Wire'deserialize (:ledger this), wire)
                            (catch BufferUnderflowException _
                                ;; If we went through the whole buffer without a full message, we might need to use a larger buffer.
                                (when (and first? (= (.limit wire) (.capacity wire)))
                                    (throw+ (ProtocolException'new (str "Fat packet does not fit in " (.capacity wire) " bytes")))
                                )
                                ;; Reposition the buffer to its original position, which saves us from skipping messages by
                                ;; seeking past part of the magic bytes before all of them are in the buffer.
                                (.position wire, mark)
                                nil
                            )
                        )]
                    (when (some? message) => (.position wire)
                        ;; Process our freshly deserialized message.
                        (ยง ass this (Peer''process-message this, message))
                        (recur false)
                    )
                )
            )
            (catch Exception e
                (let [#_"PeerAddress" address (:peer-address this)
                      #_"String" s (if (some? address) (PeerAddress''to-string address) "?")]
                    (if (instance? IOException e)
                        (log/info (str s " - " (.getMessage e)))
                        (log/warn e, s)
                    )
                    (ยง ass this (Peer''close this))
                    ;; Returning -1 also throws an IllegalStateException upstream and kills the connection.
                    -1
                )
            )
        )
    )

    ;;;
     ; Sets the {@link MessageWriteTarget} used to write messages to the peer.  This should almost never be called,
     ; it is called automatically by {@link NioClient} or {@link NioClientManager} once the socket finishes initialization.
     ;;
    #_override
    (defn #_"Peer" StreamConnection'''set-write-target [#_"Peer" this, #_"MessageWriteTarget" target]
        (assert-argument (some? target))

        (let [[this close?]
                (sync (:peersocket-lock this)
                    (assert-argument (nil? (:write-target this)))

                    [(assoc this :write-target target) (:close-pending this)]
                )]
            (when close?
                (ยง ass target (MessageWriteTarget'''close-connection target))
            )
            this
        )
    )

    #_override
    (defn #_"int" StreamConnection'''get-max-message-size [#_"Peer" __]
        Message'MAX_SIZE
    )

    ;;;
     ; Called every time a message is received from the network.
     ;;
    #_throws #_[ "Exception" ]
    #_method
    (defn #_"Peer" Peer''process-message [#_"Peer" this, #_"Message" m]
        ;; Allow event listeners to filter the message stream.  Listeners are allowed to drop messages by returning null.
        (let [m (loop-when [m m #_"PreMessageReceivedEventListener*" s (:pre-message-received-event-listeners this)] (seq s) => m
                    (let [#_"PreMessageReceivedEventListener" l (first s)]
                        ;; Skip any listeners that are supposed to run in another thread as we don't want to block waiting for it,
                        ;; which might cause circular deadlock.
                        (ยง async-
                            (let [m (PreMessageReceivedEventListener'''on-pre-message-received l, this, m)]
                                (recur-if (some? m) [m (next s)] => m)
                            )
                        )
                    )
                )]
            (when (some? m) => this
                ;; If we are in the middle of receiving transactions as part of a filtered block push from the remote node,
                ;; and we receive something that's not a transaction, then we're done.
                (let [this
                        (when (and (some? (:current-filtered-block this)) (not (ยง instance? Transaction m))) => this
                            (let [this (Peer''end-filtered-block this, (:current-filtered-block this))]
                                (assoc this :current-filtered-block nil)
                            )
                        )]

                    ;; No further communication is possible until version handshake is complete.
                    (when-not (or (ยง instance? VersionMessage m) (ยง instance? VersionAck m) (and (.isDone (:version-handshake-future this)) (not (.isCancelled (:version-handshake-future this)))))
                        (throw+ (ProtocolException'new (str "Received " (.getSimpleName (.getClass m)) " before version handshake is complete.")))
                    )

                    (condp instance? m
                        (ยง Ping)             (Peer''process-ping this, (cast' Ping m))
                        (ยง Pong)             (Peer''process-pong this, (cast' Pong m))
                        ;; This is sent to us when we did a getdata on some transactions that aren't in the peers memory pool.
                        ;; Because NotFoundMessage is a subclass of InventoryMessage, the test for it must come before the next.
                        (ยง NotFoundMessage)  (Peer''process-not-found-message this, (cast' NotFoundMessage m))
                        (ยง InventoryMessage) (Peer''process-inv this, (cast' InventoryMessage m))
                        (ยง Block)            (Peer''process-block this, (cast' Block m))
                        (ยง FilteredBlock)    (Peer''start-filtered-block this, (cast' FilteredBlock m))
                        (ยง Transaction)      (Peer''process-transaction this, (cast' Transaction m))
                        (ยง GetDataMessage)   (Peer''process-get-data this, (cast' GetDataMessage m))
                        ;; We don't care about addresses of the network right now.  But in future, we should save them
                        ;; in the wallet so we don't put too much load on the seed nodes and can properly explore the network.
                        (ยง AddressMessage)   (Peer''process-address-message this, (cast' AddressMessage m))
                        (ยง HeadersMessage)   (Peer''process-headers this, (cast' HeadersMessage m))
                        (ยง VersionMessage)   (Peer''process-version-message this, (cast' VersionMessage m))
                        (ยง VersionAck)       (Peer''process-version-ack this, (cast' VersionAck m))
                        (ยง RejectMessage)    (do (log/error (str this ": Received " m)) this)
                                             (do (log/warn (str this ": Received unhandled message: " m)) this)
                    )
                )
            )
        )
    )

    #_method
    (defn- #_"Peer" Peer''process-address-message [#_"Peer" this, #_"AddressMessage" m]
        (let [#_"SettableFuture<AddressMessage>" future
                (sync (:get-addr-futures this)
                    (.poll (:get-addr-futures this))
                )]
            (when (some? future) ;; Else not an addr message we are waiting for.
                (.set future, m)
            )
        )
        this
    )

    #_throws #_[ "ProtocolException" ]
    #_method
    (defn- #_"Peer" Peer''process-version-message [#_"Peer" this, #_"VersionMessage" m]
        (when (some? (:v-peer-version-message this))
            (throw+ (ProtocolException'new "Got two version messages from peer"))
        )
        (let [this (assoc this :v-peer-version-message m) #_"long" time (* (:time-seconds m) 1000)]
            (log/info (str this ": Got version=" (:client-version m) ", services=" (:local-services m) ", time=" (format "%tF %tT", time, time) ", blocks=" (:best-height m)))
            ;; bitcoinj is a client mode implementation.  That means there's not much point in us talking to other client mode
            ;; nodes because we can't download the data from them we need to find/verify transactions.  Some bogus implementations
            ;; claim to have a block chain in their services field but then report a height of zero, filter them out here.
            (if (or (not (VersionMessage''has-block-chain m)) (and (not (Ledger''allow-empty-peer-chain (:ledger this))) (zero? (:best-height m))))
                (do
                    ;; Shut down the channel gracefully.
                    (log/info (str this ": Peer does not have a copy of the block chain."))
                    (Peer''close this)
                )
                (do
                    (when (neg? (:best-height m)) ;; In this case, it's a protocol violation.
                        (throw+ (ProtocolException'new (str "Peer reports invalid best height: " (:best-height m))))
                    )
                    ;; Now it's our turn ...
                    ;; Send an ACK message stating we accept the peers protocol version.
                    (let [this (Peer''send-message this, (VersionAck'new (:ledger this)), VersionAck''to-wire)]
                        (log/debug (str this ": Incoming version handshake complete."))
                        (.set (:incoming-version-handshake-future this), this)
                        this
                    )
                )
            )
        )
    )

    #_throws #_[ "ProtocolException" ]
    #_method
    (defn- #_"Peer" Peer''process-version-ack [#_"Peer" this, #_"VersionAck" m]
        (when (nil? (:v-peer-version-message this))
            (throw+ (ProtocolException'new "got a version ack before version"))
        )
        (when (.isDone (:outgoing-version-handshake-future this))
            (throw+ (ProtocolException'new "got more than one version ack"))
        )
        (log/debug (str this ": Outgoing version handshake complete."))
        (.set (:outgoing-version-handshake-future this), this)
        this
    )

    #_method
    (defn- #_"Peer" Peer''version-handshake-complete [#_"Peer" this]
        (log/debug (str this ": Handshake complete."))
        (let [this (AbstractTimeoutHandler''set-timeout-enabled this, false)]
            (doseq [#_"PeerConnectedEventListener" l (:connected-event-listeners this)]
                (ยง async?
                    (ยง ass l (PeerConnectedEventListener'''on-peer-connected l, this))
                )
            )
            ;; We check min version after onPeerConnected as channel.close() will
            ;; call onPeerDisconnected, and we should probably call onPeerConnected first.
            (let [#_"int" needed (:v-min-protocol-version this) #_"int" client (-> this :v-peer-version-message :client-version)]
                (when (< client needed) => this
                    (log/warn (str "Connected to a peer speaking protocol version " client " but need " needed ", closing"))
                    (Peer''close this)
                )
            )
        )
    )

    #_method
    (defn #_"Peer" Peer''start-filtered-block [#_"Peer" this, #_"FilteredBlock" m]
        ;; Filtered blocks come before the data that they refer to, so stash it here and then fill it out as
        ;; messages stream in.  We'll call endFilteredBlock when a non-tx message arrives (e.g. another
        ;; FilteredBlock) or when a tx that isn't needed by that block is found.  A ping message is sent after
        ;; a getblocks, to force the non-tx message path.
        (let [this (assoc this :current-filtered-block m)
              ;; Potentially refresh the server side filter.  Because the remote node adds hits back into the filter
              ;; to save round-tripping back through us, the filter degrades over time as false positives get added,
              ;; triggering yet more false positives.  We refresh it every so often to get the FP rate back down.
              this (update this :filtered-blocks-received inc)]
            (when (= (rem (:filtered-blocks-received this) Peer'RESEND_BLOOM_FILTER_BLOCK_COUNT) (dec Peer'RESEND_BLOOM_FILTER_BLOCK_COUNT)) => this
                (Peer''send-message this, (:v-bloom-filter this), BloomFilter''to-wire)
            )
        )
    )

    #_method
    (defn #_"Peer" Peer''process-not-found-message [#_"Peer" this, #_"NotFoundMessage" m]
        ;; This is received when we previously did a getdata, but the peer couldn't find what we requested in it's
        ;; memory pool.  Typically, because we are downloading dependencies of a relevant transaction and reached
        ;; the bottom of the dependency tree (where the unconfirmed transactions connect to transactions that are
        ;; in the chain).
        ;;
        ;; We go through and cancel the pending getdata futures for the items we were told weren't found.
        (letfn [(#_"boolean" cancelled- [#_"GetDataRequest" req]
                    (let-when [#_"Sha256Hash" hash (:request-hash req)] (some #(= (:item-hash %) hash) (:items m)) => false
                        (log/info (str this ": Bottomed out dep tree at " hash))
                        (.cancel (:future req), true)
                        true
                    )
                )]
            (remove* this :get-data-futures cancelled-)
        )
    )

    #_throws #_[ "ProtocolException" ]
    #_method
    (defn #_"Peer" Peer''process-headers [#_"Peer" this, #_"HeadersMessage" m]
        ;; Runs in network loop thread for this peer.
        ;;
        ;; This method can run if a peer just randomly sends us a "headers" message (should never happen), or more
        ;; likely when we've requested them as part of chain download using fast catchup.  We need to add each block to
        ;; the chain if it pre-dates the fast catchup time.  If we go past it, we can stop processing the headers and
        ;; request the full blocks from that point on instead.
        (let-when [[#_"boolean" __downloadBlockBodies #_"long" __fastCatchupTimeSecs :as _]
                (sync (:peer-lock this)
                    (when (nil? (:block-chain this)) => [(:download-block-bodies this) (:fast-catchup-time-secs this)]
                        ;; Can happen if we are receiving unrequested data, or due to programmer error.
                        (log/warn "Received headers when Peer is not configured with a chain.")
                        nil
                    )
                )] (some? _) => this

            (try+
                (assert-state (not __downloadBlockBodies), (Peer''to-string this))

                (let [[this done?]
                        (loop-when [this this #_"int" i 0] (< i (count (:block-headers m))) => [this false]
                            (let [#_"Block" header (nth (:block-headers m) i) #_"int" best (BlockChain''get-best-chain-height (:block-chain this))]
                                ;; Process headers until we pass the fast catchup time, or are about to catch up with the head
                                ;; of the chain - always process the last block as a full/filtered block to kick us out of the
                                ;; fast catchup mode (in which we ignore new blocks).
                                (cond (or (<= __fastCatchupTimeSecs (:time-seconds header)) (<= (-> this :v-peer-version-message :best-height) best))
                                    (do
                                        (sync (:peer-lock this)
                                            (log/info (str "Passed the fast catchup time (" (Time'format-seconds __fastCatchupTimeSecs) ") at height " (inc best) ", discarding " (- (count (:block-headers m)) i) " headers and requesting full blocks"))
                                            (let [this (assoc this :download-block-bodies true)
                                                  ;; Prevent this request being seen as a duplicate.
                                                  this (assoc this :last-get-blocks-begin Sha256Hash'ZERO_HASH)]
                                                [(Peer''block-chain-download-locked this, Sha256Hash'ZERO_HASH) true]
                                            )
                                        )
                                    )
                                    (not (:v-download-data this))
                                    (do
                                        ;; Not download peer anymore, some other peer probably became better.
                                        (log/info "Lost download peer status, throwing away downloaded headers.")
                                        [this true]
                                    )
                                    :else
                                    (let [[_ success?] (BlockChain''add-block (:block-chain this), header) this (assoc this :block-chain _)]
                                        (if success?
                                            (do
                                                ;; The block was successfully linked into the chain. Notify the user of our progress.
                                                (Peer''invoke-on-blocks-downloaded this, header, nil)
                                                (recur this (inc i))
                                            )
                                            (do
                                                ;; This block is unconnected - we don't know how to get from it back to the genesis block yet.
                                                ;; That must mean that the peer is buggy or malicious because we specifically requested for
                                                ;; headers that are part of the best chain.
                                                (throw+ (ProtocolException'new (str "Got unconnected header from peer: " (Block''get-hash header))))
                                            )
                                        )
                                    )
                                )
                            )
                        )]

                    ;; We added all headers in the message to the chain.
                    ;; Request some more if we got up to the limit, otherwise we are at the end of the chain.
                    (when-not (or done? (< (count (:block-headers m)) HeadersMessage'MAX_HEADERS)) => this
                        (sync (:peer-lock this)
                            (Peer''block-chain-download-locked this, Sha256Hash'ZERO_HASH)
                        )
                    )
                )
                (ยง catch VerificationException e
                    (log/warn e, "Block header verification failed")
                    this
                )
            )
        )
    )

    #_method
    (defn #_"Peer" Peer''process-get-data [#_"Peer" this, #_"GetDataMessage" getdata]
        (log/info (str (:peer-address this) ": Received getdata message: " getdata))
        (let [#_"List<Transaction>" items (ArrayList.)]
            (doseq [#_"GetDataEventListener" l (:get-data-event-listeners this)]
                (ยง async-
                    (when-let [#_"Transaction*" item* (GetDataEventListener'''get-data l, this, getdata)]
                        (ยง ass items (.addAll items, item*))
                    )
                )
            )
            (when (seq items) => this
                (log/info (str (:peer-address this) ": Sending " (count items) " items gathered from listeners to peer"))
                (reduce #(Peer''send-message %1, %2, Transaction''to-wire) this items)
            )
        )
    )

    #_throws #_[ "VerificationException" ]
    #_method
    (defn #_"Peer" Peer''process-transaction [#_"Peer" this, #_"Transaction" tx]
        ;; Check a few basic syntax issues to ensure the received TX isn't nonsense.
        (Transaction''verify tx)
        (let [[this bcast?]
                (sync (:peer-lock this)
                    (log/debug (str (:peer-address this) ": Received tx " (Transaction''get-hash tx)))
                    ;; Label the transaction as coming in from the P2P network (as opposed to being created by us, direct import,
                    ;; etc).  This helps the wallet decide how to risk analyze it later.
                    ;;
                    ;; Additionally, by invoking tx.getConfidence(), this tx now pins the confidence data into the heap, meaning
                    ;; we can stop holding a reference to the confidence object ourselves.  It's up to event listeners on the
                    ;; Peer to stash the tx object somewhere if they want to keep receiving updates about network propagation
                    ;; and so on.
                    (let [#_"TransactionConfidence" confidence (Transaction''get-confidence tx)
                          _ (ยง ass confidence (assoc confidence :confidence-source :ConfidenceSource'NETWORK))
                          _ (ยง ass this (update this :pending-tx-downloads .remove confidence))
                          [this ?] (Peer''maybe-handle-requested-data this, tx, Transaction''get-hash)]
                        (cond ?
                            (do
                                [this false]
                            )
                            (some? (:current-filtered-block this))
                            (do
                                (let [this
                                        (when-not (FilteredBlock''provide-transaction (:current-filtered-block this), tx) => this
                                            ;; Got a tx that didn't fit into the filtered block, so we must have received everything.
                                            (let [this (Peer''end-filtered-block this, (:current-filtered-block this))]
                                                (assoc this :current-filtered-block nil)
                                            )
                                        )]
                                    ;; Don't tell wallets or listeners about this tx as they'll learn about it when the filtered block is
                                    ;; fully downloaded instead.
                                    [this false]
                                )
                            )
                            :else
                            (do
                                ;; It's a broadcast transaction.  Tell all wallets about this tx so they can check if it's relevant or not.
                                (doseq [#_"Wallet" wallet (:wallets this)]
                                    (try+
                                        (when (Wallet''is-pending-transaction-relevant wallet, tx)
                                            (if (pos? (:v-download-tx-dependency-depth this))
                                                ;; This transaction seems interesting to us, so let's download its dependencies.  This has
                                                ;; several purposes: we can check that the sender isn't attacking us by engaging in protocol
                                                ;; abuse games, like depending on a time-locked transaction that will never confirm, or
                                                ;; building huge chains of unconfirmed transactions (again - so they don't confirm and the
                                                ;; money can be taken back with a Finney attack).  Knowing the dependencies also lets us
                                                ;; store them in a serialized wallet so we always have enough data to re-announce to the
                                                ;; network and get the payment into the chain, in case the sender goes away and the network
                                                ;; starts to forget.
                                                ;;
                                                ;; TODO: Not all the above things are implemented.
                                                ;;
                                                ;; Note that downloading of dependencies can end up walking around 15 minutes back even
                                                ;; through transactions that have confirmed, as getdata on the remote peer also checks
                                                ;; relay memory not only the mempool.  Unfortunately we have no way to know that here.
                                                ;; In practice it should not matter much.
                                                (Futures/addCallback (Peer''download-dependencies this, tx),
                                                    (reify FutureCallback #_"<List<Transaction>>"
                                                        #_foreign
                                                        #_override
                                                        (#_"void" onSuccess [#_"FutureCallback" __, #_"List<Transaction>" dependencies]
                                                            (try+
                                                                (log/info (str (:peer-address this) ": Dependency download complete!"))
                                                                (Wallet''receive-pending-3 wallet, tx, dependencies)
                                                                (ยง catch VerificationException e
                                                                    (log/error e, (str (:peer-address this) ": Wallet failed to process pending transaction " (Transaction''get-hash tx)))
                                                                    ;; Not much more we can do at this point.
                                                                )
                                                            )
                                                            nil
                                                        )

                                                        #_foreign
                                                        #_override
                                                        (#_"void" onFailure [#_"FutureCallback" __, #_"Throwable" throwable]
                                                            (log/error throwable, (str "Could not download dependencies of tx " (Transaction''get-hash tx)))
                                                            ;; Not much more we can do at this point.
                                                            nil
                                                        )
                                                    )
                                                )
                                                (Wallet''receive-pending-3 wallet, tx, nil)
                                            )
                                        )
                                        (ยง catch VerificationException e
                                            (log/error e, "Wallet failed to verify tx")
                                            ;; Carry on, listeners may still want to know.
                                        )
                                    )
                                )
                                [this true]
                            )
                        )
                    )
                )]

            (when bcast?
                ;; Tell all listeners about this tx so they can decide whether to keep it or not.  If no listener keeps a
                ;; reference around then the memory pool will forget about it after a while too because it uses weak references.
                (doseq [#_"OnTransactionBroadcastListener" l (:on-transaction-event-listeners this)]
                    (ยง async?
                        (OnTransactionBroadcastListener'''on-transaction l, this, tx)
                    )
                )
            )
            this
        )
    )

    ;;;
     ; Returns a future that wraps a list of all transactions that the given transaction depends on, recursively.
     ; Only transactions in peers memory pools are included; the recursion stops at transactions that are in the
     ; current best chain.  So it doesn't make much sense to provide a tx that was already in the best chain and
     ; a precondition checks this.
     ;
     ; For example, if tx has 2 inputs that connect to transactions A and B, and transaction B is unconfirmed and
     ; has one input connecting to transaction C that is unconfirmed, and transaction C connects to transaction D
     ; that is in the chain, then this method will return either {B, C} or {C, B}.  No ordering is guaranteed.
     ;
     ; This method is useful for apps that want to learn about how long an unconfirmed transaction might take
     ; to confirm, by checking for unexpectedly time locked transactions, unusually deep dependency trees or
     ; fee-paying transactions that depend on unconfirmed free transactions.
     ;
     ; Note that dependencies downloaded this way will not trigger the onTransaction method of event listeners.
     ;;
    #_method
    (defn #_"ListenableFuture<List<Transaction>>" Peer''download-dependencies [#_"Peer" this, #_"Transaction" tx]
        (assert-argument (not= (:confidence-type (Transaction''get-confidence tx)) :ConfidenceType'BUILDING))

        (log/info (str (:peer-address this) ": Downloading dependencies of " (Transaction''get-hash tx)))
        (let [#_"List<Transaction>" results (LinkedList.)
              ;; future will be invoked when the entire dependency tree has been walked and the results compiled.
              #_"ListenableFuture<Object>" future (Peer''download-dependencies-internal this, (:v-download-tx-dependency-depth this), 0, tx, (Object.), results)
              #_"SettableFuture<List<Transaction>>" __resultFuture (SettableFuture/create)]
            (Futures/addCallback future,
                (reify FutureCallback #_"<Object>"
                    #_foreign
                    #_override
                    (#_"void" onSuccess [#_"FutureCallback" __, #_"Object" _ignored]
                        (.set __resultFuture, results)
                        nil
                    )

                    #_foreign
                    #_override
                    (#_"void" onFailure [#_"FutureCallback" __, #_"Throwable" throwable]
                        (.setException __resultFuture, throwable)
                        nil
                    )
                )
            )
            __resultFuture
        )
    )

    ;; The marker object in the future returned is the same as the parameter.  It is arbitrary and can be anything.
    #_method
    (defn #_"ListenableFuture<Object>" Peer''download-dependencies-internal [#_"Peer" this, #_"int" __maxDepth, #_"int" depth, #_"Transaction" tx, #_"Object" marker, #_"List<Transaction>" results]
        (let [#_"SettableFuture<Object>" __resultFuture (SettableFuture/create)
              #_"Sha256Hash" __rootTxHash (Transaction''get-hash tx)
              ;; We want to recursively grab its dependencies.  This is so listeners can learn important information like
              ;; whether a transaction is dependent on a timelocked transaction or has an unexpectedly deep dependency tree
              ;; or depends on a no-fee transaction.

              ;; We may end up requesting transactions that we've already downloaded and thrown away here.
              ;; There may be multiple inputs that connect to the same transaction.
              #_"{Sha256Hash}" needed (into (flatland.ordered.set/ordered-set) (map #(:from-tx-hash (:outpoint %)) (:inputs tx)))]

            (sync (:peer-lock this)
                (try
                    ;; Build the request for the missing dependencies.
                    (let [#_"List<ListenableFuture<Transaction>>" futures (ArrayList.)
                          #_"GetDataMessage" getdata (GetDataMessage'new (:ledger this))]

                        (let-when [#_"int" n (count needed)] (< 1 n)
                            (log/info (str (:peer-address this) ": Requesting " n " transactions for depth " (inc depth) " dep resolution"))
                        )

                        (doseq [#_"Sha256Hash" hash needed]
                            (ยง ass getdata (GetDataMessage''add-transaction getdata, hash))
                            (let [#_"GetDataRequest" req (GetDataRequest'new hash, (SettableFuture/create))]
                                (ยง ass futures (.add futures, (:future req)))
                                (ยง ass this (append* this :get-data-futures req))
                            )
                        )

                        (let [#_"ListenableFuture<List<Transaction>>" successful (Futures/successfulAsList futures)]
                            (Futures/addCallback successful,
                                (reify FutureCallback #_"<List<Transaction>>"
                                    #_foreign
                                    #_override
                                    (#_"void" onSuccess [#_"FutureCallback" __, #_"List<Transaction>" transactions]
                                        ;; Once all transactions either were received, or we know there are no more to come, ...
                                        ;; Note that transactions will contain "null" for any positions that weren't successful.
                                        (let [#_"List<ListenableFuture<Object>>" __childFutures (LinkedList.)]
                                            (doseq [#_"Transaction" tx transactions]
                                                (when (some? tx)
                                                    (log/info (str (:peer-address this) ": Downloaded dependency of " __rootTxHash ": " (Transaction''get-hash tx)))
                                                    (ยง ass results (.add results, tx))
                                                    ;; Now recurse into the dependencies of this transaction too.
                                                    (when (< (inc depth) __maxDepth)
                                                        (ยง ass __childFutures (.add __childFutures, (Peer''download-dependencies-internal this, __maxDepth, (inc depth), tx, marker, results)))
                                                    )
                                                )
                                            )
                                            (if (zero? (count __childFutures))
                                                ;; Short-circuit: we're at the bottom of this part of the tree.
                                                (.set __resultFuture, marker)
                                                ;; There are some children to download.  Wait until it's done (and their children,
                                                ;; and their children, ...) to inform the caller that we're finished.
                                                (Futures/addCallback (Futures/successfulAsList __childFutures),
                                                    (reify FutureCallback #_"<List<Object>>"
                                                        #_foreign
                                                        #_override
                                                        (#_"void" onSuccess [#_"FutureCallback" __, #_"List<Object>" _objects]
                                                            (.set __resultFuture, marker)
                                                            nil
                                                        )

                                                        #_foreign
                                                        #_override
                                                        (#_"void" onFailure [#_"FutureCallback" __, #_"Throwable" throwable]
                                                            (.setException __resultFuture, throwable)
                                                            nil
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                        nil
                                    )

                                    #_foreign
                                    #_override
                                    (#_"void" onFailure [#_"FutureCallback" __, #_"Throwable" throwable]
                                        (.setException __resultFuture, throwable)
                                        nil
                                    )
                                )
                            )

                            ;; Start the operation.
                            (ยง ass this (Peer''send-message this, getdata, GetDataMessage''to-wire))
                        )
                    )
                    (catch Exception e
                        (log/error e, (str this ": Couldn't send getdata in downloadDependencies(" (Transaction''get-hash tx) ")"))
                        (.setException __resultFuture, e)
                    )
                )
            )

            __resultFuture
        )
    )

    #_method
    (defn #_"Peer" Peer''process-block [#_"Peer" this, #_"Block" m]
        ;; Was this block requested by getBlock()?
        (let [[this ?] (Peer''maybe-handle-requested-data this, m, Block''get-hash)]
            (cond ?
                (do
                    this
                )
                (nil? (:block-chain this))
                (do
                    (log/debug "Received block but was not configured with a BlockChain")
                    this
                )
                ;; Did we lose download peer status after requesting block data?
                (not (:v-download-data this))
                (do
                    (log/debug (str (:peer-address this) ": Received block we did not ask for: " (Block''get-hash m)))
                    this
                )
                :else
                (do
                    (ยง ass this (update this :pending-block-downloads .remove (Block''get-hash m)))

                    (try+
                        ;; Otherwise it's a block sent to us because the peer thought we needed it, so add it to the block chain.
                        (let [[_ success?] (BlockChain''add-block (:block-chain this), m) this (assoc this :block-chain _)]
                            (if success?
                                ;; The block was successfully linked into the chain.  Notify the user of our progress.
                                (do
                                    (Peer''invoke-on-blocks-downloaded this, m, nil)
                                    this
                                )
                                ;; This block is an orphan - we don't know how to get from it back to the genesis block yet.  That
                                ;; must mean that there are blocks we are missing, so do another getblocks with a new block locator
                                ;; to ask the peer to send them to us.  This can happen during the initial block chain download where
                                ;; the peer will only send us 500 at a time and then sends us the head block expecting us to request
                                ;; the others.
                                ;;
                                ;; We must do two things here:
                                ;; (1) Request from current top of chain to the oldest ancestor of the received block in the orphan set.
                                ;; (2) Filter out duplicate getblock requests (done in blockChainDownloadLocked).
                                ;;
                                ;; The reason for (1) is that otherwise if new blocks were solved during the middle of chain download
                                ;; we'd do a blockChainDownloadLocked() on the new best chain head, which would cause us to try and grab
                                ;; the chain twice (or more!) on the same connection!  The block chain would filter out the duplicates
                                ;; but only at a huge speed penalty.  By finding the orphan root we ensure every getblocks looks the
                                ;; same no matter how many blocks are solved, and therefore that the (2) duplicate filtering can work.
                                ;;
                                ;; We only do this if we are not currently downloading headers.  If we are then we don't want to kick
                                ;; off a request for lots more headers in parallel.
                                (sync (:peer-lock this)
                                    (if (:download-block-bodies this)
                                        (let [#_"Block" root (ensure some? (BlockChain''get-orphan-root (:block-chain this), (Block''get-hash m)))]
                                            (Peer''block-chain-download-locked this, (Block''get-hash root))
                                        )
                                        (do
                                            (log/info "Did not start chain download on solved block due to in-flight header download.")
                                            this
                                        )
                                    )
                                )
                            )
                        )
                        (ยง catch VerificationException e
                            ;; We don't want verification failures to kill the thread.
                            (log/warn e, (str (:peer-address this) ": Block verification failed"))
                            this
                        )
                    )
                )
            )
        )
    )

    ;; TODO: Fix this duplication.
    #_method
    (defn #_"Peer" Peer''end-filtered-block [#_"Peer" this, #_"FilteredBlock" m]
        (cond
            (not (:v-download-data this))
            (do
                (log/debug (str (:peer-address this) ": Received block we did not ask for: " (FilteredBlock''get-hash m)))
                this
            )
            (nil? (:block-chain this))
            (do
                (log/debug "Received filtered block but was not configured with a BlockChain")
                this
            )
            :else
            (do
                ;; Note that we currently do nothing about peers which maliciously do not include transactions which
                ;; actually match our filter or which simply do not send us all the transactions we need: it can be fixed
                ;; by cross-checking peers against each other.
                (ยง ass this (update this :pending-block-downloads .remove (Block''get-hash (FilteredBlock''get-block-header m))))

                (try+
                    (let [[this done?]
                            ;; It's a block sent to us because the peer thought we needed it, so maybe add it to the block chain.
                            ;; The FilteredBlock m here contains a list of hashes, and may contain Transaction objects for a subset
                            ;; of the hashes (those that were sent to us by the remote peer).  Any hashes that haven't had a tx
                            ;; provided in processTransaction are ones that were announced to us previously via an 'inv' so the
                            ;; assumption is we have already downloaded them and either put them in the wallet, or threw them away
                            ;; for being false positives.
                            ;;
                            ;; TODO: Fix the following protocol race.
                            ;; It is possible for this code to go wrong such that we miss a confirmation.  If the remote peer announces
                            ;; a relevant transaction via an 'inv' and then it immediately announces the block that confirms
                            ;; the tx before we had a chance to download it+its dependencies and provide them to the wallet, then we
                            ;; will add the block to the chain here without the tx being in the wallet and thus it will miss its
                            ;; confirmation and become stuck forever.  The fix is to notice that there's a pending getdata for a tx
                            ;; that appeared in this block and delay processing until it arrived ... it's complicated by the fact that
                            ;; the data may be requested by a different peer to this one.

                            ;; Ask each wallet attached to the peer/blockchain if this block exhausts the list of data items
                            ;; (keys/addresses) that were used to calculate the previous filter.  If so, then it's possible this block
                            ;; is only partial.  Check for discarding first so we don't check for exhaustion on blocks we already know
                            ;; we're going to discard, otherwise redundant filters might end up being queued and calculated.
                            (sync (:peer-lock this)
                                (cond (some? (:awaiting-fresh-filter this))
                                    (let [#_"Sha256Hash" hash (FilteredBlock''get-hash m)]
                                        (log/info (str "Discarding block " hash " because we're still waiting for a fresh filter"))
                                        ;; We must record the hashes of blocks we discard because you cannot do getblocks twice on the same
                                        ;; range of blocks and get an inv both times, due to the codepath in Bitcoin Core hitting
                                        ;; CPeer::PushInventory() which checks CPeer::setInventoryKnown and thus deduplicates.
                                        (ยง ass this (update this :awaiting-fresh-filter .add hash))

                                        ;; Chain download process is restarted via a call to setBloomFilter.
                                        [this true]
                                    )
                                    (Peer''check-for-filter-exhaustion this, m)
                                    (let [#_"Sha256Hash" hash (FilteredBlock''get-hash m)]
                                        (log/info (str "Bloom filter exhausted whilst processing block " hash ", discarding"))
                                        ;; Yes, so we must abandon the attempt to process this block and any further blocks we receive,
                                        ;; then wait for the Bloom filter to be recalculated, sent to this peer and for the peer to acknowledge
                                        ;; that the new filter is now in use (which we have to simulate with a ping/pong), and then we can
                                        ;; safely restart the chain download with the new filter that contains a new set of lookahead keys.
                                        (let [#_"List<Sha256Hash>" hashes (LinkedList.)]
                                            (ยง ass hashes (.add hashes, hash))
                                            (ยง ass hashes (.addAll hashes, (BlockChain''drain-orphan-blocks (:block-chain this))))

                                            ;; Chain download process is restarted via a call to setBloomFilter.
                                            [(assoc this :awaiting-fresh-filter hashes) true]
                                        )
                                    )
                                    :else
                                    (do
                                        [this false]
                                    )
                                )
                            )]

                        (when-not done? => this
                            (let [[_ success?] (BlockChain'''add-filtered-block (:block-chain this), m) this (assoc this :block-chain _)]
                                (if success?
                                    ;; The block was successfully linked into the chain.  Notify the user of our progress.
                                    (do
                                        (Peer''invoke-on-blocks-downloaded this, (FilteredBlock''get-block-header m), m)
                                        this
                                    )
                                    ;; This block is an orphan - we don't know how to get from it back to the genesis block yet.  That
                                    ;; must mean that there are blocks we are missing, so do another getblocks with a new block locator
                                    ;; to ask the peer to send them to us.  This can happen during the initial block chain download where
                                    ;; the peer will only send us 500 at a time and then sends us the head block expecting us to request
                                    ;; the others.
                                    ;;
                                    ;; We must do two things here:
                                    ;; (1) Request from current top of chain to the oldest ancestor of the received block in the orphan set.
                                    ;; (2) Filter out duplicate getblock requests (done in blockChainDownloadLocked).
                                    ;;
                                    ;; The reason for (1) is that otherwise if new blocks were solved during the middle of chain download
                                    ;; we'd do a blockChainDownloadLocked() on the new best chain head, which would cause us to try and grab the
                                    ;; chain twice (or more!) on the same connection!  The block chain would filter out the duplicates but
                                    ;; only at a huge speed penalty.  By finding the orphan root we ensure every getblocks looks the same
                                    ;; no matter how many blocks are solved, and therefore that the (2) duplicate filtering can work.
                                    (sync (:peer-lock this)
                                        (let [#_"Block" root (ensure some? (BlockChain''get-orphan-root (:block-chain this), (FilteredBlock''get-hash m)))]
                                            (Peer''block-chain-download-locked this, (Block''get-hash root))
                                        )
                                    )
                                )
                            )
                        )
                    )
                    (ยง catch VerificationException e
                        ;; We don't want verification failures to kill the thread.
                        (log/warn e, (str (:peer-address this) ": FilteredBlock verification failed"))
                        this
                    )
                    (ยง catch PrunedException _
                        ;; We pruned away some of the data we need to properly handle this block.  We need to
                        ;; request the needed data from the remote peer and fix things.  Or just give up.
                        ;; TODO: Request e.getHash() and submit it to the block store before any other blocks.
                        (throw+)
                    )
                )
            )
        )
    )

    #_method
    (defn- #_"boolean" Peer''check-for-filter-exhaustion [#_"Peer" this, #_"FilteredBlock" filtered]
        (reduce #(or %1 %2) false (map #(Wallet''check-for-filter-exhaustion %, filtered) (:wallets this)))
    )

    #_method
    (defn- #_"[Peer boolean]" Peer''maybe-handle-requested-data [#_"Peer" this, #_"Message" m, f'get-hash]
        (let [#_"Sha256Hash" hash (f'get-hash m)
              #_"GetDataRequest*" found (keep #(when (= (:request-hash %) hash) (.set (:future %), m) %) (:get-data-futures this))]
            (when (seq found) => [this false]
                [(apply remove* this :get-data-futures =? found) true]
            )
        )
    )

    #_method
    (defn- #_"void" Peer''invoke-on-blocks-downloaded [#_"Peer" this, #_"Block" block, #_"FilteredBlock" filtered]
        ;; It is possible for the peer block height difference to be negative when blocks have been solved and broadcast
        ;; since the time we first connected to the peer.  However, it's weird and unexpected to receive a callback
        ;; with negative "blocks left" in this case, so we clamp to zero so the API user doesn't have to think about it.
        (let [#_"int" n (max 0 (- (int (-> this :v-peer-version-message :best-height)) (BlockChain''get-best-chain-height (ensure some? (:block-chain this)))))]
            (doseq [#_"BlocksDownloadedEventListener" l (:blocks-downloaded-event-listeners this)]
                (ยง async?
                    (ยง ass l (BlocksDownloadedEventListener'''on-blocks-downloaded l, this, block, filtered, n))
                )
            )
        )
        nil
    )

    #_method
    (defn #_"Peer" Peer''process-inv [#_"Peer" this, #_"InventoryMessage" inv]
        ;; Separate out the blocks and transactions, we'll handle them differently.
        (let [#_"List<InventoryItem>" transactions (LinkedList.) #_"List<InventoryItem>" blocks (LinkedList.)]

            (doseq [#_"InventoryItem" item (:items inv)]
                (condp = (:item-type item)
                    :InventoryItemType'TRANSACTION (ยง ass transactions (.add transactions, item))
                    :InventoryItemType'BLOCK       (ยง ass blocks (.add blocks, item))
                    (throw (IllegalStateException. (str "Not implemented: " (:item-type item))))
                )
            )

            (let [#_"boolean" download? (:v-download-data this)]

                (when (and (= (count transactions) 0) (= (count blocks) 1))
                    ;; Single block announcement.  If we're downloading the chain this is just a tickle to make us continue
                    ;; (the block chain download protocol is very implicit and not well thought out).  If we're not downloading
                    ;; the chain then this probably means a new block was solved and the peer believes it connects to the best
                    ;; chain, so count it.  This way getBestChainHeight() can be accurate.
                    (if (and download? (some? (:block-chain this)))
                        (when-not (BlockChain''is-orphan (:block-chain this), (:item-hash (nth blocks 0)))
                            (.incrementAndGet (:blocks-announced this))
                        )
                        (.incrementAndGet (:blocks-announced this))
                    )
                )

                (let [#_"GetDataMessage" getdata (GetDataMessage'new (:ledger this))]

                    (loop-when-recur [#_"Iterator<InventoryItem>" it (.iterator transactions)] (.hasNext it) [it]
                        (let [#_"InventoryItem" item (.next it)
                              ;; Only download the transaction if we are the first peer that saw it be advertised.  Other peers will also
                              ;; see it be advertised in inv packets asynchronously, they co-ordinate via the memory pool.  We could
                              ;; potentially download transactions faster by always asking every peer for a tx when advertised, as remote
                              ;; peers run at different speeds.  However to conserve bandwidth on mobile devices we try to only download a
                              ;; transaction once.  This means we can miss broadcasts if the peer disconnects between sending us an inv and
                              ;; sending us the transaction: currently we'll never try to re-fetch after a timeout.
                              ;;
                              ;; The line below can trigger confidence listeners.
                              #_"TransactionConfidence" conf (TxConfidenceTable''seen TxConfidenceTable'INSTANCE, (:item-hash item), (:peer-address this))]
                            (cond (< 1 (count (:broadcast-by conf)))
                                (do
                                    ;; Some other peer already announced this so don't download.
                                    (.remove it)
                                )
                                (= (:confidence-source conf) :ConfidenceSource'SELF)
                                (do
                                    ;; We created this transaction ourselves, so don't download.
                                    (.remove it)
                                )
                                :else
                                (do
                                    (log/debug (str (:peer-address this) ": getdata on tx " (:item-hash item)))
                                    (ยง ass getdata (ListMessage''add-item getdata, item))
                                    ;; Register with the garbage collector that we care about the confidence data for a while.
                                    (ยง ass this (update this :pending-tx-downloads .add conf))
                                )
                            )
                        )
                    )

                    ;; If we are requesting filteredblocks, we have to send a ping after the getdata so that we have a clear
                    ;; end to the final FilteredBlock's transactions (in the form of a pong) sent to us.
                    (let [[this #_"boolean" ping?]
                            (sync (:peer-lock this)
                                (when (and (seq blocks) download? (some? (:block-chain this))) => [this false]
                                    ;; Ideally, we'd only ask for the data here if we actually needed it.  However that can imply a lot of
                                    ;; disk IO to figure out what we've got.  Normally peers will not send us inv for things we already have
                                    ;; so we just re-request it here, and if we get duplicates the block chain / wallet will filter them out.
                                    (loop-when [this this ping? false blocks blocks] (seq blocks) => [this ping?]
                                        (let [#_"InventoryItem" item (first blocks)
                                              [this ping?]
                                                (if (and (BlockChain''is-orphan (:block-chain this), (:item-hash item)) (:download-block-bodies this))
                                                    ;; If an orphan was re-advertised, ask for more blocks unless we are not currently downloading
                                                    ;; full block data because we have a getheaders outstanding.
                                                    (let [#_"Block" root (ensure some? (BlockChain''get-orphan-root (:block-chain this), (:item-hash item)))]
                                                        [(Peer''block-chain-download-locked this, (Block''get-hash root)) ping?]
                                                    )
                                                    ;; Don't re-request blocks we already requested.  Normally this should not happen.  However there is
                                                    ;; an edge case: if a block is solved and we complete the inv<->getdata<->block<->getblocks cycle
                                                    ;; whilst other parts of the chain are streaming in, then the new getblocks request won't match the
                                                    ;; previous one: whilst the stopHash is the same (because we use the orphan root), the start hash
                                                    ;; will be different and so the getblocks req won't be dropped as a duplicate.  We'll end up
                                                    ;; requesting a subset of what we already requested, which can lead to parallel chain downloads
                                                    ;; and other nastyness.  So we just do a quick removal of redundant getdatas here too.
                                                    ;;
                                                    ;; Note that as of June 2012 Bitcoin Core won't actually ever interleave blocks pushed as
                                                    ;; part of chain download with newly announced blocks, so it should always be taken care of by
                                                    ;; the duplicate check in blockChainDownloadLocked().  But Bitcoin Core may change in future so
                                                    ;; it's better to be safe here.
                                                    (when-not (contains? (:pending-block-downloads this) (:item-hash item)) => [this ping?]
                                                        (let [ping?
                                                                (if (and (VersionMessage''is-bloom-filtering-supported (:v-peer-version-message this)) (:use-filtered-blocks this))
                                                                    (do
                                                                        (ยง ass getdata (GetDataMessage''add-filtered-block getdata, (:item-hash item)))
                                                                        true
                                                                    )
                                                                    (do
                                                                        (ยง ass getdata (ListMessage''add-item getdata, item))
                                                                        ping?
                                                                    )
                                                                )]
                                                            (ยง ass this (update this :pending-block-downloads .add (:item-hash item)))
                                                            [this ping?]
                                                        )
                                                    )
                                                )]
                                            (recur this ping? (next blocks))
                                        )
                                    )
                                    ;; If we're downloading the chain, doing a getdata on the last block we were told about will cause the
                                    ;; peer to advertize the head block to us in a single-item inv.  When we download THAT, it will be an
                                    ;; orphan block, meaning we'll re-enter blockChainDownloadLocked() to trigger another getblocks between the
                                    ;; current best block we have and the orphan block.  If more blocks arrive in the meantime they'll also
                                    ;; become orphan.
                                )
                            )
                          this
                            (when (seq (:items getdata)) => this
                                ;; This will cause us to receive a bunch of block or tx messages.
                                (Peer''send-message this, getdata, GetDataMessage''to-wire)
                            )]
                        (when ping? => this
                            (Peer''send-message this, (Ping'new (:ledger this), (long (* (Math/random) Long/MAX_VALUE))), Ping''to-wire)
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Asks the connected peer for the block of the given hash, and returns a future representing the answer.
     ; If you want the block right away and don't mind waiting for it, just call .get() on the result.  Your thread
     ; will block until the peer answers.
     ;;
    #_method
    (defn #_"ListenableFuture<Block>" Peer''get-block [#_"Peer" this, #_"Sha256Hash" hash]
        ;; This does not need to be locked.
        (log/info (str "Request to fetch block " hash))
        (let [#_"GetDataMessage" getdata (GetDataMessage'new (:ledger this))]
            (ยง ass getdata (GetDataMessage''add-block getdata, hash))
            (Peer''send-single-get-data this, getdata)
        )
    )

    ;;;
     ; Asks the connected peer for the given transaction from its memory pool.  Transactions in the chain cannot be
     ; retrieved this way because peers don't have a transaction ID to transaction-pos-on-disk index, and besides,
     ; in future many peers will delete old transaction data they don't need.
     ;;
    #_method
    (defn #_"ListenableFuture<Transaction>" Peer''get-peer-mempool-transaction [#_"Peer" this, #_"Sha256Hash" hash]
        ;; This does not need to be locked.
        (log/info (str "Request to fetch peer mempool tx  " hash))
        (let [#_"GetDataMessage" getdata (GetDataMessage'new (:ledger this))]
            (ยง ass getdata (GetDataMessage''add-transaction getdata, hash))
            (Peer''send-single-get-data this, getdata)
        )
    )

    ;;;
     ; Sends a getdata with a single item in it.
     ;;
    #_method
    (defn- #_"ListenableFuture" Peer''send-single-get-data [#_"Peer" this, #_"GetDataMessage" getdata]
        ;; This does not need to be locked.
        (assert-argument (= (count (:items getdata)) 1))

        (let [#_"GetDataRequest" req (GetDataRequest'new (:item-hash (first (:items getdata))), (SettableFuture/create))]
            (ยง ass this (append* this :get-data-futures req))
            (ยง ass this (Peer''send-message this, getdata, GetDataMessage''to-wire))
            (:future req)
        )
    )

    ;;;
     ; Sends a getaddr request to the peer and returns a future that completes with the answer once the peer has replied.
     ;;
    #_method
    (defn #_"ListenableFuture<AddressMessage>" Peer''get-addr [#_"Peer" this]
        (let [#_"SettableFuture<AddressMessage>" future (SettableFuture/create)]
            (sync (:get-addr-futures this)
                (ยง ass this (update this :get-addr-futures .add future))
            )
            (ยง ass this (Peer''send-message this, (GetAddrMessage'new (:ledger this)), GetAddrMessage''to-wire))
            future
        )
    )

    ;;;
     ; When downloading the block chain, the bodies will be skipped for blocks created before the given date.
     ; Any transactions relevant to the wallet will therefore not be found, but if you know your wallet has no such
     ; transactions it doesn't matter and can save a lot of bandwidth and processing time.  Note that the times of blocks
     ; isn't known until their headers are available and they are requested in chunks, so some headers may be downloaded
     ; twice using this scheme, but this optimization can still be a large win for newly created wallets.
     ;
     ; @param secondsSinceEpoch Time in seconds since the epoch or 0 to reset to always downloading block bodies.
     ;;
    #_method
    (defn #_"Peer" Peer''set-download-parameters [#_"Peer" this, #_"long" secs, #_"boolean" use?]
        (sync (:peer-lock this)
            (-> (if (zero? secs)
                    (let [this (assoc this :fast-catchup-time-secs (-> this :ledger :genesis-block :time-seconds))]
                        (assoc this :download-block-bodies true)
                    )
                    (let [this (assoc this :fast-catchup-time-secs secs) #_"BlockChain" chain (:block-chain this)]
                        ;; If the given time is before the current chain's head block time,
                        ;; then this has no effect (we already downloaded everything we need).
                        (when (and (some? chain) (< (-> (BlockChain''get-chain-head chain) :stored-header :time-seconds) secs)) => this
                            (assoc this :download-block-bodies false)
                        )
                    )
                )
                (assoc :use-filtered-blocks use?)
            )
        )
    )

    ;;;
     ; Links the given wallet to this peer.  If you have multiple peers, you should use a {@link PeerGroup} to manage
     ; them and use the {@link PeerGroup#addWallet(Wallet)} method instead of registering the wallet with each peer
     ; independently, otherwise the wallet will receive duplicate notifications.
     ;;
    #_method
    (defn #_"Peer" Peer''add-wallet [#_"Peer" this, #_"Wallet" wallet]
        (append* this :wallets wallet)
    )

    ;;;
     ; Unlinks the given wallet from peer.  See {@link Peer#addWallet(Wallet)}.
     ;;
    #_method
    (defn #_"Peer" Peer''remove-wallet [#_"Peer" this, #_"Wallet" wallet]
        (remove* this :wallets = wallet)
    )

    #_method
    (defn- #_"Peer" Peer''block-chain-download-locked [#_"Peer" this, #_"Sha256Hash" __toHash]
        (assert-state (.isHeldByCurrentThread (:peer-lock this)))

        ;; The block chain download process is a bit complicated.  Basically, we start with one or more blocks in a
        ;; chain that we have from a previous session.  We want to catch up to the head of the chain BUT we don't know
        ;; where that chain is up to or even if the top block we have is even still in the chain - we
        ;; might have got ourselves onto a fork that was later resolved by the network.
        ;;
        ;; To solve this, we send the peer a block locator which is just a list of block hashes.  It contains the
        ;; blocks we know about, but not all of them, just enough of them so the peer can figure out if we did end up
        ;; on a fork and if so, what the earliest still valid block we know about is likely to be.
        ;;
        ;; Once it has decided which blocks we need, it will send us an inv with up to 500 block messages.  We may
        ;; have some of them already if we already have a block chain and just need to catch up.  Once we request the
        ;; last block, if there are still more to come it sends us an "inv" containing only the hash of the head
        ;; block.
        ;;
        ;; That causes us to download the head block but then we find (in processBlock) that we can't connect
        ;; it to the chain yet because we don't have the intermediate blocks.  So we rerun this function building a
        ;; new block locator describing where we're up to.
        ;;
        ;; The getblocks with the new locator gets us another inv with another bunch of blocks.  We download them once
        ;; again.  This time when the peer sends us an inv with the head block, we already have it so we won't download
        ;; it again - but we recognize this case as special and call back into blockChainDownloadLocked to continue the
        ;; process.
        ;;
        ;; So this is a complicated process but it has the advantage that we can download a chain of enormous length
        ;; in a relatively stateless manner and with constant memory usage.
        ;;
        ;; All this is made more complicated by the desire to skip downloading the bodies of blocks that pre-date the
        ;; 'fast catchup time', which is usually set to the creation date of the earliest key in the wallet.  Because
        ;; we know there are no transactions using our keys before that date, we need only the headers.  To do that we
        ;; use the "getheaders" command.  Once we find we've gone past the target date, we throw away the downloaded
        ;; headers and then request the blocks from that point onwards.  "getheaders" does not send us an inv, it just
        ;; sends us the data we requested in a "headers" message.
        ;;
        ;; For now, we don't do the exponential thinning as suggested here:
        ;;
        ;;   https://en.bitcoin.it/wiki/Protocol_specification#getblocks
        ;;
        ;; This is because it requires scanning all the block chain headers, which is very slow.  Instead we add the
        ;; top 100 block headers.  If there is a re-org deeper than that, we'll end up downloading the entire chain.
        ;; We must always put the genesis block as the first entry.

        (let [#_"StoredBlock" head (BlockChain''get-chain-head (ensure some? (:block-chain this)))
              #_"Sha256Hash" __chainHeadHash (Block''get-hash (:stored-header head))]

            ;; Did we already make this request?  If so, don't do it again.
            (if (and (Objects/equals (:last-get-blocks-begin this), __chainHeadHash) (Objects/equals (:last-get-blocks-end this), __toHash))
                (do
                    (log/info (str "blockChainDownloadLocked(" __toHash "): ignoring duplicated request: " __chainHeadHash))
                    (doseq [#_"Sha256Hash" hash (:pending-block-downloads this)]
                        (log/info (str "Pending block download: " hash))
                    )
                    this
                )
                ;; TODO: Block locators should be abstracted out rather than special cased here.
                (let [#_"List<Sha256Hash>" locator (ArrayList. 51)
                      #_"BlockStore" store (:block-store (:block-chain this))
                      #_"StoredBlock" cursor
                        (loop-when [cursor head #_"int" n 100] (and (some? cursor) (pos? n)) => cursor
                            (ยง ass locator (.add locator, (Block''get-hash (:stored-header cursor))))
                            (let [cursor
                                    (try+
                                        (StoredBlock''get-prev cursor, store)
                                        (ยง catch BlockStoreException _
                                            (log/error "Failed to walk the block chain whilst constructing a locator")
                                            (throw+)
                                        )
                                    )]
                                (recur cursor (dec n))
                            )
                        )]

                    ;; Only add the locator if we didn't already do so.  If the chain is < 50 blocks we already reached it.
                    (when (some? cursor)
                        (ยง ass locator (.add locator, (Block''get-hash (-> this :ledger :genesis-block))))
                    )

                    ;; Record that we requested this range of blocks so we can filter out duplicate requests in the event
                    ;; of a block being solved during chain download.
                    (let [this (assoc this :last-get-blocks-begin __chainHeadHash, :last-get-blocks-end __toHash)]
                        (if (:download-block-bodies this)
                            (let [#_"GetBlocksMessage" message (GetBlocksMessage'new (:ledger this), locator, __toHash)]
                                (Peer''send-message this, message, GetBlocksMessage''to-wire)
                            )
                            ;; Downloading headers for a while instead of full blocks.
                            (let [#_"GetHeadersMessage" message (GetHeadersMessage'new (:ledger this), locator, __toHash)]
                                (Peer''send-message this, message, GetHeadersMessage''to-wire)
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Starts an asynchronous download of the block chain.  The chain download is deemed to be complete once we've
     ; downloaded the same number of blocks that the peer advertised having in its version handshake message.
     ;;
    #_method
    (defn #_"Peer" Peer''start-block-chain-download [#_"Peer" this]
        (let [this (assoc this :v-download-data true)]
            ;; TODO: Peer might still have blocks that we don't have, and even have a heavier chain even if the chain block count is lower.
            (let-when [#_"int" n (Peer''get-peer-block-height-difference this)] (<= 0 n) => this
                (doseq [#_"ChainDownloadStartedEventListener" l (:chain-download-started-event-listeners this)]
                    (ยง async?
                        (ยง ass l (ChainDownloadStartedEventListener'''on-chain-download-started l, this, n))
                    )
                )
                ;; When we just want as many blocks as possible, we can set the target hash to zero.
                (sync (:peer-lock this)
                    (Peer''block-chain-download-locked this, Sha256Hash'ZERO_HASH)
                )
            )
        )
    )

    ;;;
     ; Adds a ping time sample to the averaging window.
     ;;
    #_method
    (defn- #_"Peer" Peer''add-ping-time-data [#_"Peer" this, #_"long" sample]
        (sync (:lastping-lock this)
            (update this :last-ping-times #(conj (if (< (count %) Peer'PING_MOVING_AVERAGE_WINDOW) % (subvec % 1)) sample))
        )
    )

    ;;;
     ; Sends the peer a ping message and returns a future that will be invoked when the pong is received back.
     ; The future provides a number which is the number of milliseconds elapsed between the ping and the pong.
     ; Once the pong is received the value returned by {@link Peer#getLastPingTime()} is updated.
     ;
     ; @throws ProtocolException if the peer version is too low to support measurable pings.
     ;;
    #_throws #_[ "ProtocolException" ]
    #_method
    (defn #_"ListenableFuture<Long>" Peer''ping-1 [#_"Peer" this]
        (Peer''ping-2 this, (long (* (Math/random) Long/MAX_VALUE)))
    )

    #_throws #_[ "ProtocolException" ]
    #_method
    (defn #_"ListenableFuture<Long>" Peer''ping-2 [#_"Peer" this, #_"long" nonce]
        (let [#_"VersionMessage" ver (:v-peer-version-message this)]
            (when-not (VersionMessage''is-ping-pong-supported ver)
                (throw+ (ProtocolException'new (str "Peer version is too low for measurable pings: " ver)))
            )

            (let [#_"PendingPing" pending (PendingPing'new this, nonce)]
                (ยง ass this (append* this :pending-pings pending))
                (ยง ass this (Peer''send-message this, (Ping'new (:ledger this), (:nonce pending)), Ping''to-wire))

                (:future pending)
            )
        )
    )

    ;;;
     ; Returns the elapsed time of the last ping/pong cycle.  If {@link Peer#ping()} has never
     ; been called or we did not hear back the "pong" message yet, returns {@link Long#MAX_VALUE}.
     ;;
    #_method
    (defn #_"long" Peer''get-last-ping-time [#_"Peer" this]
        (sync (:lastping-lock this)
            (or (peek (:last-ping-times this)) Long/MAX_VALUE)
        )
    )

    ;;;
     ; Returns a moving average of the last N ping/pong cycles.  If {@link Peer#ping()} has never
     ; been called or we did not hear back the "pong" message yet, returns {@link Long#MAX_VALUE}.
     ; The moving average window is 5 buckets.
     ;;
    #_method
    (defn #_"long" Peer''get-average-ping-time [#_"Peer" this]
        (sync (:lastping-lock this)
            (let [#_"long*" times (:last-ping-times this)]
                (if (seq times) (long (/ (double (reduce + times)) (count times))) Long/MAX_VALUE)
            )
        )
    )

    #_method
    (defn- #_"Peer" Peer''process-ping [#_"Peer" this, #_"Ping" m]
        (when (some? (:nonce m)) => this
            (Peer''send-message this, (Pong'new (:ledger this), (:nonce m)), Pong''to-wire)
        )
    )

    #_method
    (defn #_"Peer" Peer''process-pong [#_"Peer" this, #_"Pong" m]
        ;; Iterates over a snapshot of the list, so we can run unlocked here.
        (when-let [#_"PendingPing" ping (first (filter #(= (:nonce %) (:nonce m)) (:pending-pings this)))]
            (ยง ass this (remove* this :pending-pings = ping))
            ;; This line may trigger an event listener that re-runs ping().
            (ยง ass ping (PendingPing''complete ping))
        )
        this
    )

    ;;;
     ; Returns the difference between our best chain height and the peers, which can either be
     ; positive if we are behind the peer, or negative if the peer is ahead of us.
     ;;
    #_method
    (defn #_"int" Peer''get-peer-block-height-difference [#_"Peer" this]
        (ensure some? (:block-chain this), "No block chain configured")

        ;; Chain will overflow signed int blocks in ~41,000 years.
        (let [#_"int" height (int (Peer''get-best-height this))]
            ;; chainHeight should not be zero/negative because we shouldn't have given the user a Peer that is to another
            ;; client-mode node, nor should it be unconnected.  If that happens it means the user overrode us somewhere or
            ;; there is a bug in the peer management code.
            (assert-state (or (Ledger''allow-empty-peer-chain (:ledger this)) (pos? height)), "Connected to peer with zero/negative chain height", height)
            (- height (BlockChain''get-best-chain-height (:block-chain this)))
        )
    )

    #_method
    (defn- #_"boolean" Peer''is-not-found-message-supported [#_"Peer" this]
        (<= NotFoundMessage'MIN_PROTOCOL_VERSION (-> this :v-peer-version-message :client-version))
    )

    ;;;
     ; @return the height of the best chain as claimed by peer: sum of its ver announcement and blocks announced since.
     ;;
    #_method
    (defn #_"long" Peer''get-best-height [#_"Peer" this]
        (+ (-> this :v-peer-version-message :best-height) (.get (:blocks-announced this)))
    )

    ;;;
     ; The minimum P2P protocol version that is accepted.
     ; If the peer speaks a protocol version lower than this, it will be disconnected.
     ;
     ; @return true if the peer was disconnected as a result.
     ;;
    #_method
    (defn #_"[Peer boolean]" Peer''set-min-protocol-version [#_"Peer" this, #_"int" m]
        (let [this (assoc this :v-min-protocol-version m)]
            (let-when [#_"VersionMessage" v (:v-peer-version-message this)] (and (some? v) (< (:client-version v) m)) => [this false]
                (log/warn (str this ": Disconnecting due to new min protocol version " m ", got: " (:client-version v)))
                [(Peer''close this) true]
            )
        )
    )

    ;;;
     ; Sets a Bloom filter on this connection.  This will cause the given {@link BloomFilter} object to be sent
     ; to the remote peer and if requested, a {@link MemoryPoolMessage} is sent as well to trigger downloading of
     ; any pending transactions that may be relevant.
     ;
     ; The Peer does not automatically request filters from any wallets added using {@link Peer#addWallet(Wallet)}.
     ; This is to allow callers to avoid redundantly recalculating the same filter repeatedly when using multiple
     ; peers and multiple wallets together.
     ;
     ; Therefore, you should not use this method if your app uses a {@link PeerGroup}.  It is called for you.
     ;
     ; If the remote peer doesn't support Bloom filtering, then this call is ignored.  Once set you presently
     ; cannot unset a filter, though the underlying p2p protocol does support it.
     ;;
    #_method
    (defn #_"Peer" Peer''set-bloom-filter [#_"Peer" this, #_"BloomFilter" filter, #_"boolean" query?]
        (ensure some? filter, "Clearing filters is not currently supported")

        (let [#_"VersionMessage" ver (:v-peer-version-message this)]
            (when (and (some? ver) (VersionMessage''is-bloom-filtering-supported ver)) => this
                (let [this (assoc this :v-bloom-filter filter)]
                    (log/debug (str this ": Sending Bloom filter" (if query? " and querying mempool" "")))
                    (let [this (Peer''send-message this, filter, BloomFilter''to-wire)
                          this
                            (when query? => this
                                (Peer''send-message this, (MemoryPoolMessage'new (:ledger this)), MemoryPoolMessage''to-wire)
                            )]
                        (Peer''maybe-restart-chain-download this)
                    )
                )
            )
        )
    )

    #_method
    (defn- #_"Peer" Peer''maybe-restart-chain-download [#_"Peer" this]
        (sync (:peer-lock this)
            (when (some? (:awaiting-fresh-filter this)) => this
                (if (not (:v-download-data this))
                    ;; This branch should be harmless but I want to know how often it happens in reality.
                    (log/warn "Lost download peer status whilst awaiting fresh filter.")
                    ;; Ping/pong to wait for blocks that are still being streamed to us to finish being downloaded and discarded.
                    (.addListener (Peer''ping-1 this),
                        #(do
                            (.lock (:peer-lock this))
                            (ensure some? (:awaiting-fresh-filter this))
                            (let [#_"GetDataMessage" getdata (GetDataMessage'new (:ledger this))]
                                (doseq [#_"Sha256Hash" hash (:awaiting-fresh-filter this)]
                                    (ยง ass getdata (GetDataMessage''add-filtered-block getdata, hash))
                                )
                                (ยง ass this (assoc this :awaiting-fresh-filter nil))
                                (.unlock (:peer-lock this))

                                (log/info "Restarting chain download")
                                (ยง ass this (Peer''send-message this, getdata, GetDataMessage''to-wire))
                                ;; TODO: This bizarre ping-after-getdata hack probably isn't necessary.
                                ;; It's to ensure we know when the end of a filtered block stream of txns is, but we should just be
                                ;; able to match txns with the merkleblock.  Ask Matt why it's written this way.
                                (ยง ass this (Peer''send-message this, (Ping'new (:ledger this), (long (* (Math/random) Long/MAX_VALUE))), Ping''to-wire))
                            )
                        ), Threading'SAME_THREAD
                    )
                )
                this
            )
        )
    )

    ;;;
     ; Returns true if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     ; before handing the transaction off to the wallet.  The wallet can do risk analysis on pending/recent transactions
     ; to try and discover if a pending tx might be at risk of double spending.
     ;;
    #_method
    (defn #_"boolean" Peer''is-download-tx-dependencies [#_"Peer" this]
        (pos? (:v-download-tx-dependency-depth this))
    )

    ;;;
     ; Sets if this peer will use getdata/notfound messages to walk backwards through transaction dependencies
     ; before handing the transaction off to the wallet.  The wallet can do risk analysis on pending/recent transactions
     ; to try and discover if a pending tx might be at risk of double spending.
     ;;
    #_method
    (defn #_"Peer" Peer''set-download-tx-dependencies-b [#_"Peer" this, #_"boolean" enable?]
        (assoc this :v-download-tx-dependency-depth (if enable? Integer/MAX_VALUE 0))
    )

    #_method
    (defn #_"String" Peer''to-string [#_"Peer" this]
        (let [#_"PeerAddress" addr (:peer-address this)]
            ;; if null, it's a user-provided NetworkConnection object
            (if (some? addr) (PeerAddress''to-string addr) "Peer()")
        )
    )
)

;;;
 ; A PeerAddress holds an IP address and port number representing the network location of
 ; a peer in the Bitcoin P2P network.  It exists primarily for serialization purposes.
 ;;
(class-ns PeerAddress (ยง extends Message)
    (defn #_"PeerAddress" PeerAddress'new [#_"Ledger" ledger, #_"long" stamp, #_"BigInteger" services, #_"InetAddress" address, #_"int" port]
        (merge (Message'new ledger)
            (hash-map
                #_"long" :timestamp stamp
                #_"BigInteger" :services services
                #_"InetAddress" :inet-addr address
                #_"int" :port port
            )
        )
    )

    ;;;
     ; Constructs a peer address from the given IP address and port.
     ;;
    (defn #_"PeerAddress" PeerAddress'from-inet-port [#_"Ledger" ledger, #_"InetAddress" address, #_"int" port]
        (PeerAddress'new ledger, 0, BigInteger/ZERO, (ensure some? address), port)
    )

    (defn #_"PeerAddress" PeerAddress'loopback [#_"Ledger" ledger]
        (PeerAddress'from-inet-port ledger, (InetAddress/getLoopbackAddress), (:port ledger))
    )

    ;;;
     ; Constructs a peer address from an {@link InetSocketAddress}.  An InetSocketAddress can take in as parameters an
     ; InetAddress or a String hostname.  If you want to connect to a .onion, set the hostname to the .onion address.
     ;;
    (defn #_"PeerAddress" PeerAddress'from-socket-address [#_"Ledger" ledger, #_"InetSocketAddress" address]
        (PeerAddress'from-inet-port ledger, (.getAddress address), (.getPort address))
    )

    ;;;
     ; Construct a peer address from a serialized payload.
     ;;
    #_throws #_[ "ProtocolException" ]
    (defn #_"PeerAddress" PeerAddress'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload]
        ;; Format of a serialized address:
        ;;   uint32 timestamp
        ;;   uint64 services (flags determining what the node can do)
        ;;   16 bytes ip address
        ;;   2 bytes port num
        (let [#_"long" stamp (Wire'read-uint32 payload)
              #_"BigInteger" services (Wire'read-uint64 payload)
              #_"InetAddress" address
                (let [#_"byte[]" bytes (Wire'read-bytes payload, 16)]
                    (try
                        (InetAddress/getByAddress bytes)
                        (catch UnknownHostException e
                            (throw (RuntimeException. e)) ;; Cannot happen.
                        )
                    )
                )
              #_"int" port (| (<< (& 0xff (.get payload)) 8) (& 0xff (.get payload)))]

            (PeerAddress'new ledger, stamp, services, address, port)
        )
    )

    #_method
    (defn PeerAddress''to-wire
        (#_"String" [] nil)
        (#_"void" [#_"PeerAddress" this, #_"ByteArrayOutputStream" baos]
            ;; TODO: This appears to be dynamic because the client only ever sends out it's own address so assumes itself
            ;; to be up.  For a fuller implementation this needs to be dynamic only if the address refers to this client.
            (Wire'write-uint32 (int (Time'seconds)), baos)
            (Wire'write-uint64 (:services this), baos)
            ;; Java does not provide any utility to map an IPv4 address into IPv6 space, so we have to do it by hand.
            (let [#_"byte[]" bytes (.getAddress (:inet-addr this))
                  bytes (when (= (count bytes) 4) => bytes
                        (let [#_"byte[]" a6 (byte-array 16) _ (System/arraycopy bytes, 0, a6, 12, 4)]
                            (aset a6 10 (byte 0xff))
                            (aset a6 11 (byte 0xff))
                            a6
                        )
                    )]
                (.write baos, bytes)
                ;; And write out the port.  Unlike the rest of the protocol, address and port is in big endian byte order.
                (.write baos, (byte (& 0xff (>> (:port this) 8))))
                (.write baos, (byte (& 0xff (:port this))))
            )
            nil
        )
    )

    #_method
    (defn #_"InetSocketAddress" PeerAddress''to-socket-address [#_"PeerAddress" this]
        (InetSocketAddress. (:inet-addr this), (:port this))
    )

    #_method
    (defn #_"String" PeerAddress''to-string [#_"PeerAddress" this]
        (str (.getHostAddress (:inet-addr this)) ":" (:port this))
    )
)

(def LoopbackCheckState'enum-set
    (hash-set
        :LoopbackCheckState'NOT_TRIED
        :LoopbackCheckState'FOUND
        :LoopbackCheckState'FOUND_AND_CONNECTED
        :LoopbackCheckState'NOT_THERE
    )
)

(def FilterRecalculateMode'enum-set
    (hash-set
        :FilterRecalculateMode'SEND_IF_CHANGED
        :FilterRecalculateMode'FORCE_SEND_FOR_REFRESH
        :FilterRecalculateMode'DONT_SEND
    )
)

#_non-static #_"PeerGroup"
(class-ns PeerListener (ยง implements GetDataEventListener, BlocksDownloadedEventListener)
    (defn #_"PeerListener" PeerListener'new []
        (hash-map)
    )

    #_override
    (defn #_"List<Transaction>" GetDataEventListener'''get-data [#_"PeerListener" this, #_"Peer" peer, #_"GetDataMessage" m]
        (PeerGroup''handle-get-data this, m)
    )

    #_override
    (defn #_"PeerListener" BlocksDownloadedEventListener'''on-blocks-downloaded [#_"PeerListener" this, #_"Peer" peer, #_"Block" block, #_"FilteredBlock" filtered, #_"int" __blocksLeft]
        (when (some? (:chain this))
            (let [#_"double" rate (:false-positive-rate (:chain this))
                  #_"double" target (* (-> this :bloom-filter-merger :v-merger-fp-rate) PeerGroup'MAX_FP_RATE_INCREASE)]
                (when (< target rate)
                    ;; TODO: Avoid hitting this path if the remote peer didn't acknowledge applying a new filter yet.
                    (log/debug (str "Force update Bloom filter due to high false positive rate (" rate " vs " target ")"))

                    (PeerGroup''recalculate-fast-catchup-and-filter this, :FilterRecalculateMode'FORCE_SEND_FOR_REFRESH)
                )
            )
        )
        this
    )
)

;;;
 ; A general interface which declares the ability to broadcast transactions.
 ; This is implemented by {@link PeerGroup}.
 ;;
(defprotocol TransactionBroadcaster
    ;;; Broadcast the given transaction on the network. ;;
    #_abstract
    (#_"TransactionBroadcast" TransactionBroadcaster'''broadcast-transaction-2 [#_"TransactionBroadcaster" this, #_"Transaction" tx])
)

;;;
 ; Runs a set of connections to the P2P network, brings up connections to replace disconnected nodes and manages
 ; the interaction between them all.  Most applications will want to use one of these.
 ;
 ; PeerGroup tries to maintain a constant number of connections to a set of distinct peers.
 ; Each peer runs a network listener in its own thread.  When a connection is lost, a new peer
 ; will be tried after a delay as long as the number of connections less than the maximum.
 ;
 ; Connections are made to addresses from a provided list.  When that list is exhausted,
 ; we start again from the head of the list.
 ;
 ; The PeerGroup can broadcast a transaction to the currently connected set of peers.  It can
 ; also handle download of the blockchain from peers, restarting the process when peers die.
 ;
 ; A PeerGroup won't do anything until you call the {@link PeerGroup#start()} method which
 ; will block until peer discovery is completed and some outbound connections have been
 ; initiated (it will return before handshaking is done, however).
 ; You should call {@link PeerGroup#stop()} when finished.  Note that not all methods
 ; of PeerGroup are safe to call from a UI thread as some may do network IO,
 ; but starting and stopping the service should be fine.
 ;;
(class-ns PeerGroup (ยง implements PeerConnectedEventListener, PeerDisconnectedEventListener, TransactionBroadcaster)
    ;;;
     ; The default number of connections to the p2p network the library will try to build.  This is set to 12 empirically.
     ; It used to be 4, but because we divide the connection pool in two for broadcasting transactions, that meant we
     ; were only sending transactions to two peers and sometimes this wasn't reliable enough: transactions wouldn't
     ; get through.
     ;;
    (def #_"int" PeerGroup'DEFAULT_CONNECTIONS 12)

    (def- #_"long" PeerGroup'DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS 5000)

    ;;; How many milliseconds to wait after receiving a pong before sending another ping. ;;
    (def #_"long" PeerGroup'DEFAULT_PING_INTERVAL_MSEC 2000)

    ;;;
     ; The default Bloom filter false positive rate, which is selected to be extremely low such that you hardly ever
     ; download false positives.  This provides maximum performance.  Although this default can be overridden to push
     ; the FP rate higher, due to <a href="https://groups.google.com/forum/#!msg/bitcoinj/Ys13qkTwcNg/9qxnhwnkeoIJ">
     ; various complexities</a> there are still ways a remote peer can deanonymize the users wallet.  This is why the
     ; FP rate is chosen for performance rather than privacy.  If a future version of bitcoinj fixes the known
     ; de-anonymization attacks this FP rate may rise again (or more likely, become expressed as a bandwidth allowance).
     ;;
    (def #_"double" PeerGroup'DEFAULT_BLOOM_FILTER_FP_RATE 0.00001)
    ;;; Maximum increase in FP rate before forced refresh of the bloom filter. ;;
    (def #_"double" PeerGroup'MAX_FP_RATE_INCREASE 10.0)

    ;;; The default timeout between when a connection attempt begins and version message exchange completes. ;;
    (def #_"int" PeerGroup'DEFAULT_CONNECT_TIMEOUT_MILLIS 5000)

    (def- #_"long" PeerGroup'MIN_PEER_DISCOVERY_INTERVAL 1000)

    #_method
    (defn- #_"PeerGroup" PeerGroup''go-connect [#_"PeerGroup" this, #_"Runnable" self]
        (when (:v-running this) => this
            (let-when [#_"long" now (Time'now)
                  [this #_"boolean" discover?]
                    (sync (:peergroup-lock this)
                        ;; First run: try and use a local node if there is one, for the additional security it can provide.
                        (let [[this loopback?]
                                (when (:use-loopback-peer-when-possible this) => [this false]
                                    (PeerGroup''maybe-check-for-loopback-peer this)
                                )]
                            (if (and loopback? (:first-run this))
                                (let [_ (log/info "Loopback peer detected, trying to use it instead of P2P discovery")
                                      [this _] (PeerGroup''connect-to-loopback (assoc this :max-connections 0))]
                                    [(assoc this :first-run false) nil]
                                )
                                (let [#_"boolean" more? (and (seq (:inactives this)) (<= (:retry-time (get (:backoff-map this) (.peek (:inactives this)))) now))]
                                    [(assoc this :first-run false) (not more?)]
                                )
                            )
                        )
                    )
            ] (some? discover?) => this

                ;; Don't hold the lock across discovery as this process can be very slow.
                (let [#_"boolean" success?
                        (when discover? => false
                            (try+
                                (pos? (PeerGroup''discover-peers this))
                                (ยง catch PeerDiscoveryException e
                                    (log/error e, "Peer discovery failure")
                                    false
                                )
                            )
                        )
                      [this ?]
                        (sync (:peergroup-lock this)
                            (let [this
                                    (when discover? => this
                                        ;; Require that we have enough connections, to consider this a success, or we just constantly test for new peers.
                                        (if (and success? (<= (:max-connections this) (PeerGroup''count-connected-and-pending-peers this)))
                                            (update this :group-backoff ExponentialBackoff''track-success)
                                            (update this :group-backoff ExponentialBackoff''track-failure)
                                        )
                                    )]

                                ;; Inactives is sorted by backoffMap time.
                                (cond (seq (:inactives this))
                                    (let [#_"PeerAddress" addr
                                            (loop []
                                                (let [addr (.poll (:inactives this))]
                                                    (recur-if (and (:ipv6-unreachable this) (instance? Inet6Address (:inet-addr addr))) [] => addr)
                                                )
                                            )
                                        #_"long" retry (max (:retry-time (get (:backoff-map this) addr)) (:retry-time (:group-backoff this)))]
                                        (if (< now retry)
                                            (let [#_"long" delay (- retry now)]
                                                (log/info (str "Waiting " delay " msec before next connect attempt" (if (some? addr) (str " to " addr) "")))
                                                (ยง ass this (update this :inactives .add addr))
                                                (.schedule (:executor this), self, delay, TimeUnit/MILLISECONDS)
                                                [this nil]
                                            )
                                            (let [[this _] (PeerGroup''connect-to-peer-address this, addr, false, (:v-connect-timeout-millis this))]
                                                [this :try-next-peer-immediately]
                                            )
                                        )
                                    )
                                    (< (PeerGroup''count-connected-and-pending-peers this) (:max-connections this))
                                    (let [#_"long" interval (max (- (:retry-time (:group-backoff this)) now), PeerGroup'MIN_PEER_DISCOVERY_INTERVAL)]
                                        (log/info (str "Peer discovery didn't provide us any more peers, will try again in " interval "ms."))
                                        (.schedule (:executor this), self, interval, TimeUnit/MILLISECONDS)
                                        [this nil]
                                    )
                                    :else
                                    (do
                                        ;; We have enough peers and discovery provided no more, so just settle down.
                                        ;; Most likely we were given a fixed set of addresses in some test scenario.
                                        [this nil]
                                    )
                                )
                            )
                        )]

                    (when (and ? (< (PeerGroup''count-connected-and-pending-peers this) (:max-connections this)))
                        (.execute (:executor this), self) ;; Try next peer immediately.
                    )
                    this
                )
            )
        )
    )

    ;;;
     ; Creates a PeerGroup.  No chain is provided, so this node will report its chain height as zero to other peers.
     ; This constructor is useful if you just want to explore the network, but aren't interested in downloading block data.
     ;
     ; Creates a PeerGroup for the given chain.  Blocks will be passed to the chain as they are broadcast and downloaded.
     ; This is probably the constructor you want to use.
     ;
     ; Creates a new PeerGroup allowing you to specify the {@link ClientConnectionManager} which is used to create new
     ; connections and keep track of existing ones.
     ;;
    (defn- #_"PeerGroup" PeerGroup'new
        ([#_"Ledger" ledger] (PeerGroup'new ledger, nil))
        ([#_"Ledger" ledger, #_"BlockChain" chain] (PeerGroup'new ledger, chain, nil))
        ([#_"Ledger" ledger, #_"BlockChain" chain, #_"ClientConnectionManager" manager]
            (ensure some? ledger)

            (let [#_"int" height (if (some? chain) (BlockChain''get-best-chain-height chain) 0)
                  this
                    (hash-map
                        #_"Object" :peergroup-lock (Object.)

                        #_"Ledger" :ledger ledger
                        #_"BlockChain" :chain chain
                        #_"ClientConnectionManager" :channels (or manager (NioClientManager'new))

                        ;; By default we don't require any services because any peer will do.
                        #_"long" :required-services 0

                        ;;;
                         ; The maximum number of {@link Peer}s to discover.
                         ; This maximum is checked after each {@link PeerDiscovery}, so this max number can be surpassed.
                         ;;
                        #_volatile
                        #_"int" :v-max-peers-to-discover-count 100
                        ;;;
                         ; This is how many milliseconds we wait for peer discoveries to return their results.
                         ;;
                        #_volatile
                        #_"long" :v-peer-discovery-timeout-millis PeerGroup'DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS

                        ;; This executor is used to queue up jobs: it's used when we don't want to use locks for mutual exclusion,
                        ;; typically because the job might call in to user provided code that needs/wants the freedom to use the API
                        ;; however it wants, or because a job needs to be ordered relative to other jobs like that.
                        #_"ListeningScheduledExecutorService" :executor nil

                        ;; Whether the peer group is currently running.  Once shut down it cannot be restarted.
                        #_volatile
                        #_"boolean" :v-running false
                        ;; Whether the peer group has been started or not.  An unstarted PG does not try to access the network.
                        #_volatile
                        #_"boolean" :v-used-up false

                        ;; Addresses to try to connect to, excluding active peers.
                        #_"PriorityQueue<PeerAddress>" :inactives nil
                        #_"Map<PeerAddress, ExponentialBackoff>" :backoff-map (HashMap.)

                        ;; Currently active peers.  This is an ordered list rather than a set to make unit tests predictable.
                        ;;;
                         ; Currently connected peers.  To be informed when this list changes,
                         ; register a {@link PeerConnectedEventListener}/{@link PeerDisconnectedEventListener}
                         ; and use the onPeerConnected/onPeerDisconnected methods.
                         ;;
                        #_"[Peer]" :connected-peers (vector)
                        ;; Currently connecting peers.
                        #_"[Peer]" :pending-peers (vector)

                        ;; The peer that has been selected for the purposes of downloading announced data.
                        #_"Peer" :download-peer nil
                        ;; Callback for events related to chain download.
                        #_"PeerDataEventListener" :download-listener nil

                        #_"[BlocksDownloadedEventListener]" :peers-blocks-downloaded-event-listeners (vector)
                        #_"[ChainDownloadStartedEventListener]" :peers-chain-download-started-event-listeners (vector)
                        ;;; Callbacks for events related to peers connecting. ;;
                        #_"[PeerConnectedEventListener]" :peer-connected-event-listeners (vector)
                        ;;; Callbacks for events related to peer connection/disconnection. ;;
                        #_"[PeerDiscoveredEventListener]" :peer-discovered-event-listeners (vector)
                        ;;; Callbacks for events related to peers disconnecting. ;;
                        #_"[PeerDisconnectedEventListener]" :peer-disconnected-event-listeners (vector)
                        ;;; Callbacks for events related to peer data being received. ;;
                        #_"[GetDataEventListener]" :peer-get-data-event-listeners (vector)
                        #_"[PreMessageReceivedEventListener]" :peers-pre-message-received-event-listeners (vector)
                        #_"[OnTransactionBroadcastListener]" :peers-transaction-broadast-event-listeners (vector)

                        ;; Peer discovery sources, will be polled occasionally if there aren't enough inactives.
                        #_"{PeerDiscovery}" :peer-discoveries (flatland.ordered.set/ordered-set)

                        ;; The version message to use for new connections.
                        #_"VersionMessage" :version-message (VersionMessage'new ledger, height)

                        ;; Maximum depth up to which pending transaction dependencies are downloaded, or 0 for disabled.
                        #_"int" :download-tx-dependency-depth Integer/MAX_VALUE

                        ;; How many connections we want to have open at the current time.
                        ;; If we lose connections, we'll try opening more until we reach this count.
                        ;;
                        ;; This default sentinel value will be overridden by one of two actions:
                        ;;   - adding a peer discovery source sets it to the default.
                        ;;   - using connectTo() will increment it by one.
                        #_"int" :max-connections 0

                        ;;;
                         ; The minimum protocol version required: defaults to the version required for Bloom filtering.
                         ;
                         ; If a peer is connected to that claims to speak a protocol version lower than the given version,
                         ; it will be disconnected and another one will be tried instead.
                         ;;
                        #_volatile
                        #_"int" :v-min-required-protocol-version ProtocolVersion'BLOOM_FILTER

                        ;;;
                         ; The period between pings for an individual peer.  Setting this lower means more accurate and
                         ; timely ping times are available via {@link Peer#getLastPingTime()} but it increases load on
                         ; the remote node.  It defaults to {@link PeerGroup#DEFAULT_PING_INTERVAL_MSEC}.
                         ;;
                        #_"long" :ping-interval-msec PeerGroup'DEFAULT_PING_INTERVAL_MSEC

                        ;;;
                         ; When true (the default), PeerGroup will attempt to connect to a Bitcoin node running on loopback before
                         ; attempting to use the P2P network.  If successful, only loopback will be used.  This makes for a simple
                         ; and easy way for a user to upgrade a bitcoinj based app running in SPV mode to fully validating security.
                         ;;
                        #_"boolean" :use-loopback-peer-when-possible true
                        #_"boolean" :ipv6-unreachable false

                        ;;;
                         ; The current fast catchup time.  The contents of blocks before this time won't be downloaded as
                         ; they cannot contain any interesting transactions.  If you use {@link PeerGroup#addWallet(Wallet)}
                         ; this just returns the min of the wallets earliest key times.
                         ;;
                        #_"long" :fast-catchup-time-secs (:time-seconds (:genesis-block ledger))
                        #_"[Wallet]" :wallets (vector)

                        ;; This event listener is added to every peer.
                        ;; It's here so when we announce transactions via an "inv", every peer can fetch them.
                        #_"PeerListener" :peer-listener (PeerListener'new)

                        #_"int" :min-broadcast-connections 0

                        #_"KeyChainEventListener" :wallet-key-event-listener nil

                        #_"WalletCoinsReceivedEventListener" :wallet-coins-received-event-listener nil

                        ;; Exponential backoff for peers starts at 1 second and maxes at 10 minutes.
                        #_"BackoffParams" :peer-backoff-params (BackoffParams'new 1000, 1.5, (* 10 60 1000))
                        ;; Tracks failures globally in case of a network failure.
                        #_"ExponentialBackoff" :group-backoff (ExponentialBackoff'new (BackoffParams'new 1000, 1.5, (* 10 1000)))

                        ;; This is a synchronized set, so it locks on itself.  We use it to prevent TransactionBroadcast objects from
                        ;; being garbage collected if nothing in the apps code holds on to them transitively.  See the discussion
                        ;; in broadcastTransaction.
                        #_"Set<TransactionBroadcast>" :running-broadcasts (Collections/synchronizedSet (HashSet. #_"<TransactionBroadcast>"))

                        ;; An object that calculates bloom filters given a list of filter providers, whilst tracking some state useful
                        ;; for privacy purposes.
                        #_"FilterMerger" :bloom-filter-merger (FilterMerger'new ledger, PeerGroup'DEFAULT_BLOOM_FILTER_FP_RATE)

                        ;;;
                         ; The timeout between when a connection attempt to a peer begins and when the version message exchange completes.
                         ; This does not apply to currently pending peers.
                         ;;
                        #_volatile
                        #_"int" :v-connect-timeout-millis PeerGroup'DEFAULT_CONNECT_TIMEOUT_MILLIS

                        ;;;
                         ; Whether bloom filter support is enabled when using a non FullPrunedBlockchain.
                         ;
                         ; Can be used to disable Bloom filtering entirely, even in SPV mode.  You are very unlikely to need this, it is
                         ; an optimisation for rare cases when full validation is not required but it's still more efficient to download
                         ; full blocks than filtered blocks.
                         ;;
                        #_volatile
                        #_"boolean" :v-bloom-filtering-enabled true

                        #_"CountDownLatch" :executor-startup-latch (CountDownLatch. 1)

                        #_"Runnable" :trigger-connections-job nil

                        #_"LoopbackCheckState" :loopback-check-state :LoopbackCheckState'NOT_TRIED

                        #_"Map<FilterRecalculateMode, SettableFuture<BloomFilter>>" :in-flight-recalculations (HashMap.)

                        #_volatile
                        #_"ListenableScheduledFuture<?>" :v-ping-task nil

                        #_"int" :stall-period-seconds 10
                        #_"int" :stall-min-speed-bytes-sec (* Block'HEADER_SIZE 20)
                    )
                  this
                    (assoc this :wallet-key-event-listener
                        (ยง reify KeyChainEventListener
                            #_override
                            (#_"void" KeyChainEventListener'''on-keys-added [#_"KeyChainEventListener" __, #_"List<ECKey>" keys]
                                (PeerGroup''recalculate-fast-catchup-and-filter this, :FilterRecalculateMode'SEND_IF_CHANGED)
                                nil
                            )
                        )
                    )
                  this
                    (assoc this :wallet-coins-received-event-listener
                        (ยง reify WalletCoinsReceivedEventListener
                            #_override
                            (#_"void" WalletCoinsReceivedEventListener'''on-coins-received [#_"WalletCoinsReceivedEventListener" __, #_"Wallet" wallet, #_"Transaction" tx, #_"Coin" _before, #_"Coin" _after]
                                ;; We received a relevant transaction.  We MAY need to recalculate and resend the Bloom filter, but only
                                ;; if we have received a transaction that includes a relevant pay-to-pubkey output.
                                ;;
                                ;; The reason is that pay-to-pubkey outputs, when spent, will not repeat any data we can predict in their
                                ;; inputs.  So a remote peer will update the Bloom filter for us when such an output is seen matching the
                                ;; existing filter, so that it includes the tx hash in which the pay-to-pubkey output was observed.  Thus
                                ;; the spending transaction will always match (due to the outpoint structure).
                                ;;
                                ;; Unfortunately, whilst this is required for correct sync of the chain in blocks, there are two edge cases.
                                ;;
                                ;; (1) If a wallet receives a relevant, confirmed p2pubkey output that was not broadcast across the network,
                                ;; for example in a coinbase transaction, then the node that's serving us the chain will update its filter
                                ;; but the rest will not.  If another transaction then spends it, the other nodes won't match/relay it.
                                ;;
                                ;; (2) If we receive a p2pubkey output broadcast across the network, all currently connected nodes will see
                                ;; it and update their filter themselves, but any newly connected nodes will receive the last filter we
                                ;; calculated, which would not include this transaction.
                                ;;
                                ;; For this reason we check if the transaction contained any relevant pay to pubkeys and force a recalc
                                ;; and possibly retransmit if so.  The recalculation process will end up including the tx hash into the
                                ;; filter.  In case (1), we need to retransmit the filter to the connected peers.  In case (2), we don't
                                ;; and shouldn't, we should just recalculate and cache the new filter for next time.
                                (when (seq (filter #(and (Script''is-sent-to-raw-pub-key (TransactionOutput''parse-script-pub-key %)) (TransactionOutput''is-mine %, wallet)) (:outputs tx)))
                                    (PeerGroup''recalculate-fast-catchup-and-filter this, (if (= (:confidence-type (Transaction''get-confidence tx)) :ConfidenceType'BUILDING) :FilterRecalculateMode'SEND_IF_CHANGED :FilterRecalculateMode'DONT_SEND))
                                )
                                nil
                            )
                        )
                    )
                  this
                    (assoc this :trigger-connections-job
                        (ยง reify Runnable
                            (ยง field #_"boolean" :first-run true)

                            #_foreign
                            #_override
                            (#_"void" run [#_"Runnable" self]
                                (try
                                    (ยง ass this (PeerGroup''go-connect this, self))
                                    (catch Throwable e
                                        (log/error e, "Exception when trying to build connections") ;; The executor swallows exceptions :( ;; )
                                    )
                                )
                                nil
                            )
                        )
                    )
                  this
                    (assoc this :executor (PeerGroup''create-private-executor this))
                  this
                    (assoc this :inactives (PriorityQueue. 1,
                        (#_"int" fn [#_"PeerAddress" a, #_"PeerAddress" b]
                            (assert-state (.isHeldByCurrentThread (:peergroup-lock this)))

                            (let [#_"int" cmp (ExponentialBackoff'compare (get (:backoff-map this) a), (get (:backoff-map this) b))]
                                ;; Sort by port if otherwise equals - for testing.
                                (if (= cmp 0) (compare (:port a) (:port b)) cmp)
                            )
                        )
                    ))]

                this
            )
        )
    )

    #_method
    (defn #_"ListeningScheduledExecutorService" PeerGroup''create-private-executor [#_"PeerGroup" this]
        (let [#_"ListeningScheduledExecutorService" x (MoreExecutors/listeningDecorator (ScheduledThreadPoolExecutor. 1, (DaemonThreadFactory'new "PeerGroup Thread")))]
            ;; Hack: jam the executor so jobs just queue up until the user calls start() on us.  For example, adding a wallet
            ;; results in a bloom filter recalc being queued, but we don't want to do that until we're actually started.
            (.execute x, #(Uninterruptibles/awaitUninterruptibly (:executor-startup-latch this)))
            x
        )
    )

    ;;;
     ; Adjusts the desired number of connections that we will create to peers.  Note that if there are already peers
     ; open and the new value is lower than the current number of peers, those connections will be terminated.
     ; Likewise if there aren't enough current connections to meet the new requested max size, some will be added.
     ;;
    #_method
    (defn #_"PeerGroup" PeerGroup''set-max-connections [#_"PeerGroup" this, #_"int" n]
        (let [[this ?]
                (sync (:peergroup-lock this)
                    [(assoc this :max-connections n) (not (:v-running this))]
                )]
            (when-not ?
                ;; We may now have too many or too few open connections.  Add more or drop some to get to the right amount.
                (let [#_"int" m (- n (ClientConnectionManager'''get-connected-client-count (:channels this)))]
                    (cond
                        (pos? m) (PeerGroup''trigger-connections this)
                        (neg? m) (ClientConnectionManager'''close-connections (:channels this), (- m))
                    )
                )
            )
            this
        )
    )

    #_method
    (defn- #_"void" PeerGroup''trigger-connections [#_"PeerGroup" this]
        ;; Run on a background thread due to the need to potentially retry and back off in the background.
        (when-not (.isShutdown (:executor this))
            (.execute (:executor this), (:trigger-connections-job this))
        )
        nil
    )

    #_method
    (defn- #_"List<Transaction>" PeerGroup''handle-get-data [#_"PeerGroup" this, #_"GetDataMessage" m]
        ;; Scans the wallets and memory pool for transactions in the getdata message and returns them.
        ;; Runs on peer threads.
        (sync (:peergroup-lock this)
            (let [#_"List<Transaction>" transactions (LinkedList.)
                  #_"List<InventoryItem>" items (LinkedList. (:items m))]
                (loop-when-recur [#_"Iterator<InventoryItem>" it (.iterator items)] (.hasNext it) [it]
                    (let [#_"InventoryItem" item (.next it)]
                        ;; Check the wallets.
                        (loop-when [#_"Wallet*" wallets (:wallets this)] (seq wallets)
                            (let [#_"Wallet" w (first wallets)
                                  #_"Transaction" tx (Wallet''get-transaction w, (:item-hash item))]
                                (when (some? tx) => (recur (next wallets))
                                    (ยง ass transactions (.add transactions, tx))
                                    (.remove it)
                                )
                            )
                        )
                    )
                )
                transactions
            )
        )
    )

    ;;;
     ; Adds a listener that will be notified on the given executor when
     ; blocks are downloaded by the download peer.
     ;
     ; @see Peer#addBlocksDownloadedEventListener(Executor, BlocksDownloadedEventListener)
     ;;
    #_method
    (defn #_"PeerGroup" PeerGroup''add-blocks-downloaded-event-listener [#_"PeerGroup" this, #_"BlocksDownloadedEventListener" listener]
        (-> this
            (append* :peers-blocks-downloaded-event-listeners listener)
            (update* :connected-peers Peer''add-blocks-downloaded-event-listener listener)
            (update* :pending-peers Peer''add-blocks-downloaded-event-listener listener)
        )
    )

    ;;;
     ; Adds a listener that will be notified on the given executor when
     ; chain download starts.
     ;;
    #_method
    (defn #_"PeerGroup" PeerGroup''add-chain-download-started-event-listener [#_"PeerGroup" this, #_"ChainDownloadStartedEventListener" listener]
        (-> this
            (append* :peers-chain-download-started-event-listeners listener)
            (update* :connected-peers Peer''add-chain-download-started-event-listener listener)
            (update* :pending-peers Peer''add-chain-download-started-event-listener listener)
        )
    )

    ;;;
     ; Adds a listener that will be notified on the given executor when
     ; new peers are connected to.
     ;;
    #_method
    (defn #_"PeerGroup" PeerGroup''add-connected-event-listener [#_"PeerGroup" this, #_"PeerConnectedEventListener" listener]
        (-> this
            (append* :peer-connected-event-listeners listener)
            (update* :connected-peers Peer''add-connected-event-listener listener)
            (update* :pending-peers Peer''add-connected-event-listener listener)
        )
    )

    ;;;
     ; Adds a listener that will be notified on the given executor when
     ; peers are disconnected from.
     ;;
    #_method
    (defn #_"PeerGroup" PeerGroup''add-disconnected-event-listener [#_"PeerGroup" this, #_"PeerDisconnectedEventListener" listener]
        (-> this
            (append* :peer-disconnected-event-listeners listener)
            (update* :connected-peers Peer''add-disconnected-event-listener listener)
            (update* :pending-peers Peer''add-disconnected-event-listener listener)
        )
    )

    ;;;
     ; Adds a listener that will be notified on the given executor when new
     ; peers are discovered.
     ;;
    #_method
    (defn #_"PeerGroup" PeerGroup''add-discovered-event-listener [#_"PeerGroup" this, #_"PeerDiscoveredEventListener" listener]
        (append* this :peer-discovered-event-listeners listener)
    )

    #_method
    (defn #_"PeerGroup" PeerGroup''add-get-data-event-listener [#_"PeerGroup" this, #_"GetDataEventListener" listener]
        (-> this
            (append* :peer-get-data-event-listeners listener)
            (update* :connected-peers Peer''add-get-data-event-listener listener)
            (update* :pending-peers Peer''add-get-data-event-listener listener)
        )
    )

    #_method
    (defn #_"PeerGroup" PeerGroup''add-on-transaction-broadcast-listener [#_"PeerGroup" this, #_"OnTransactionBroadcastListener" listener]
        (-> this
            (append* :peers-transaction-broadast-event-listeners listener)
            (update* :connected-peers Peer''add-on-transaction-broadcast-listener listener)
            (update* :pending-peers Peer''add-on-transaction-broadcast-listener listener)
        )
    )

    #_method
    (defn #_"PeerGroup" PeerGroup''add-pre-message-received-event-listener [#_"PeerGroup" this, #_"PreMessageReceivedEventListener" listener]
        (-> this
            (append* :peers-pre-message-received-event-listeners listener)
            (update* :connected-peers Peer''add-pre-message-received-event-listener listener)
            (update* :pending-peers Peer''add-pre-message-received-event-listener listener)
        )
    )

    #_method
    (defn #_"PeerGroup" PeerGroup''remove-blocks-downloaded-event-listener [#_"PeerGroup" this, #_"BlocksDownloadedEventListener" listener]
        (-> this
            (remove* :peers-blocks-downloaded-event-listeners = listener)
            (update* :connected-peers Peer''remove-blocks-downloaded-event-listener listener)
            (update* :pending-peers Peer''remove-blocks-downloaded-event-listener listener)
        )
    )

    #_method
    (defn #_"PeerGroup" PeerGroup''remove-chain-download-started-event-listener [#_"PeerGroup" this, #_"ChainDownloadStartedEventListener" listener]
        (-> this
            (remove* :peers-chain-download-started-event-listeners = listener)
            (update* :connected-peers Peer''remove-chain-download-started-event-listener listener)
            (update* :pending-peers Peer''remove-chain-download-started-event-listener listener)
        )
    )

    #_method
    (defn #_"PeerGroup" PeerGroup''remove-connected-event-listener [#_"PeerGroup" this, #_"PeerConnectedEventListener" listener]
        (-> this
            (remove* :peer-connected-event-listeners = listener)
            (update* :connected-peers Peer''remove-connected-event-listener listener)
            (update* :pending-peers Peer''remove-connected-event-listener listener)
        )
    )

    #_method
    (defn #_"PeerGroup" PeerGroup''remove-disconnected-event-listener [#_"PeerGroup" this, #_"PeerDisconnectedEventListener" listener]
        (-> this
            (remove* :peer-disconnected-event-listeners = listener)
            (update* :connected-peers Peer''remove-disconnected-event-listener listener)
            (update* :pending-peers Peer''remove-disconnected-event-listener listener)
        )
    )

    #_method
    (defn #_"PeerGroup" PeerGroup''remove-discovered-event-listener [#_"PeerGroup" this, #_"PeerDiscoveredEventListener" listener]
        (remove* this :peer-discovered-event-listeners = listener)
    )

    #_method
    (defn #_"PeerGroup" PeerGroup''remove-get-data-event-listener [#_"PeerGroup" this, #_"GetDataEventListener" listener]
        (-> this
            (remove* :peer-get-data-event-listeners = listener)
            (update* :connected-peers Peer''remove-get-data-event-listener listener)
            (update* :pending-peers Peer''remove-get-data-event-listener listener)
        )
    )

    #_method
    (defn #_"PeerGroup" PeerGroup''remove-on-transaction-broadcast-listener [#_"PeerGroup" this, #_"OnTransactionBroadcastListener" listener]
        (-> this
            (remove* :peers-transaction-broadast-event-listeners = listener)
            (update* :connected-peers Peer''remove-on-transaction-broadcast-listener listener)
            (update* :pending-peers Peer''remove-on-transaction-broadcast-listener listener)
        )
    )

    #_method
    (defn #_"PeerGroup" PeerGroup''remove-pre-message-received-event-listener [#_"PeerGroup" this, #_"PreMessageReceivedEventListener" listener]
        (-> this
            (remove* :peers-pre-message-received-event-listeners = listener)
            (update* :connected-peers Peer''remove-pre-message-received-event-listener listener)
            (update* :pending-peers Peer''remove-pre-message-received-event-listener listener)
        )
    )

    ;;;
     ; Add an address to the list of potential peers to connect to.  It won't necessarily be used unless there's a need
     ; to build new connections to reach the max connection count.
     ;
     ; @param peerAddress IP/port to use.
     ;;
    #_method
    (defn #_"PeerGroup" PeerGroup''add-address-p [#_"PeerGroup" this, #_"PeerAddress" addr]
        (let [#_"int" n
                (sync (:peergroup-lock this)
                    (ยง ass this (PeerGroup''add-inactive this, addr))
                    (inc (:max-connections this))
                )]
            (PeerGroup''set-max-connections this, n)
        )
    )

    #_method
    (defn- #_"PeerGroup" PeerGroup''add-inactive [#_"PeerGroup" this, #_"PeerAddress" addr]
        (sync (:peergroup-lock this)
            ;; Deduplicate.
            (when-not (contains? (:backoff-map this) addr)
                (ยง ass this (update this :backoff-map assoc addr (ExponentialBackoff'new (:peer-backoff-params this))))
                (.offer (:inactives this), addr)
            )
        )
        this
    )

    ;;;
     ; Convenience for connecting only to peers that can serve specific services.
     ; It will configure suitable peer discoveries.
     ;
     ; @param requiredServices Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     ;;
    #_method
    (defn #_"PeerGroup" PeerGroup''set-required-services [#_"PeerGroup" this, #_"long" services]
        (sync (:peergroup-lock this)
            (let [this (-> this (assoc :required-services services) (update :peer-discoveries empty))]
                (PeerGroup''add-peer-discovery this, (MultiplexingDiscovery'for-services (:ledger this), services))
            )
        )
    )

    ;;;
     ; Convenience method for addAddress(new PeerAddress(address, ledger.port)).
     ;;
    #_method
    (defn #_"PeerGroup" PeerGroup''add-address-i [#_"PeerGroup" this, #_"InetAddress" address]
        (PeerGroup''add-address-p this, (PeerAddress'from-inet-port (:ledger this), address, (-> this :ledger :port)))
    )

    ;;;
     ; Add addresses from a discovery source to the list of potential peers to connect to.
     ; If max connections has not been configured, or set to zero, then it's set to the default at this point.
     ;;
    #_method
    (defn #_"PeerGroup" PeerGroup''add-peer-discovery [#_"PeerGroup" this, #_"PeerDiscovery" discovery]
        (sync (:peergroup-lock this)
            (let [this
                    (when (zero? (:max-connections this)) => this
                        (PeerGroup''set-max-connections this, PeerGroup'DEFAULT_CONNECTIONS)
                    )]
                (append* this :peer-discoveries discovery)
            )
        )
    )

    ;;;
     ; Returns the number of discovered peers.
     ;;
    #_throws #_[ "PeerDiscoveryException" ]
    #_method
    (defn #_"int" PeerGroup''discover-peers [#_"PeerGroup" this]
        ;; Don't hold the lock whilst doing peer discovery: it can take a long time and cause high API latency.
        (assert-state (not (.isHeldByCurrentThread (:peergroup-lock this))))

        (let [#_"int" n (:v-max-peers-to-discover-count this)
              #_"long" timeout (:v-peer-discovery-timeout-millis this)
              #_"Stopwatch" watch (Stopwatch/createStarted)
              #_"List<PeerAddress>" addresses (LinkedList.)]

            (loop-when [#_"PeerDiscovery*" s (:peer-discoveries this)] (seq s)
                (let [#_"PeerDiscovery" discovery (first s)]
                    (doseq [#_"InetSocketAddress" address (PeerDiscovery'''get-peers discovery, (:required-services this), timeout, TimeUnit/MILLISECONDS)]
                        (ยง ass addresses (.add addresses, (PeerAddress'from-socket-address (:ledger this), address)))
                    )
                    (recur-if (< (count addresses) n) [(next s)])
                )
            )

            (when (seq addresses)
                (doseq [#_"PeerAddress" address addresses]
                    (ยง ass this (PeerGroup''add-inactive this, address))
                )

                (doseq [#_"PeerDiscoveredEventListener" l (:peer-discovered-event-listeners this)]
                    (ยง async?
                        (PeerDiscoveredEventListener'''on-peers-discovered l, addresses)
                    )
                )
            )
            (.stop watch)
            (log/info (str "Peer discovery took " watch " and returned " (count addresses) " items"))
            (count addresses)
        )
    )

    #_testing
    #_method
    (defn #_"void" PeerGroup''wait-for-job-queue [#_"PeerGroup" this]
        (Futures/getUnchecked (.submit (:executor this), (Runnables/doNothing)))
        nil
    )

    #_method
    (defn- #_"int" PeerGroup''count-connected-and-pending-peers [#_"PeerGroup" this]
        (sync (:peergroup-lock this)
            (+ (count (:connected-peers this)) (count (:pending-peers this)))
        )
    )

    #_method
    (defn- #_"[PeerGroup boolean]" PeerGroup''maybe-check-for-loopback-peer [#_"PeerGroup" this]
        (assert-state (.isHeldByCurrentThread (:peergroup-lock this)))

        (when (= (:loopback-check-state this) :LoopbackCheckState'NOT_TRIED) => [this false]
            ;; Do a fast blocking connect to see if anything is listening.
            (let [#_"Socket" socket (Socket.)]
                (try
                    (.connect socket, (InetSocketAddress. (InetAddress/getLoopbackAddress), (-> this :ledger :port)), (:v-connect-timeout-millis this))
                    [(assoc this :loopback-check-state :LoopbackCheckState'FOUND) true]
                    (catch IOException e
                        (log/info "Loopback peer not detected.")
                        [(assoc this :loopback-check-state :LoopbackCheckState'NOT_THERE) false]
                    )
                    (finally
                        (try
                            (.close socket)
                            (catch IOException _
                                ;; Ignore.
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Starts the PeerGroup and begins network activity.
     ;
     ; @return A future that completes when first connection activity has been triggered (note: not first connection made).
     ;;
    #_method
    (defn #_"ListenableFuture" PeerGroup''start-async [#_"PeerGroup" this]
        ;; This is run in a background thread by the Service implementation.
        (when (nil? (:chain this))
            ;; Just try to help catch what might be a programming error.
            (log/warn "Starting up with no attached block chain.  Did you forget to pass one to the constructor?")
        )
        (assert-state (not (:v-used-up this)), "Cannot start a peer group twice")

        (ยง ass this (assoc this :v-running true, :v-used-up true))
        (.countDown (:executor-startup-latch this))

        ;; We do blocking waits during startup, so run on the executor thread.
        (.submit (:executor this),
            #(try
                (log/info "Starting ...")
                (PeerGroup''start-async (:channels this))
                (PeerGroup''await-running (:channels this))
                (PeerGroup''trigger-connections this)
                (ยง ass this (PeerGroup''setup-pinging this))
                (catch Throwable e
                    (log/error e, "Exception when starting up") ;; The executor swallows exceptions :( ;; )
                )
            )
        )
    )

    ;;; Does a blocking startup. ;;
    #_method
    (defn #_"void" PeerGroup''start [#_"PeerGroup" this]
        (Futures/getUnchecked (PeerGroup''start-async this))
        nil
    )

    ;;; Can just use start() for a blocking start here instead of startAsync/awaitRunning: PeerGroup is no longer a Guava service. ;;
    #_deprecated
    #_method
    (defn #_"void" PeerGroup''await-running [#_"PeerGroup" this]
        (PeerGroup''wait-for-job-queue this)
        nil
    )

    #_method
    (defn #_"ListenableFuture" PeerGroup''stop-async [#_"PeerGroup" this]
        (assert-state (:v-running this))
        (ยง ass this (assoc this :v-running false))
        (let [#_"ListenableFuture" future (.submit (:executor this),
                    #(try
                        (log/info "Stopping ...")
                        ;; Blocking close of all sockets.
                        (PeerGroup''stop-async (:channels this))
                        (PeerGroup''await-terminated (:channels this))
                        (doseq [#_"PeerDiscovery" discovery (:peer-discoveries this)]
                            (PeerDiscovery'''shutdown discovery)
                        )
                        (ยง ass this (assoc this :v-running false))
                        (log/info "Stopped.")
                        (catch Throwable e
                            (log/error e, "Exception when shutting down") ;; The executor swallows exceptions :( ;; )
                        )
                    )
                )]
            (.shutdown (:executor this))
            (:future this)
        )
    )

    ;;; Does a blocking stop. ;;
    #_method
    (defn #_"void" PeerGroup''stop [#_"PeerGroup" this]
        (try
            (PeerGroup''stop-async this)
            (log/info "Awaiting PeerGroup shutdown ...")
            (.awaitTermination (:executor this), Long/MAX_VALUE, TimeUnit/SECONDS)
            (catch InterruptedException e
                (throw (RuntimeException. e))
            )
        )
        nil
    )

    ;;; Can just use stop() here instead of stopAsync/awaitTerminated: PeerGroup is no longer a Guava service. ;;
    #_deprecated
    #_method
    (defn #_"void" PeerGroup''await-terminated [#_"PeerGroup" this]
        (try
            (.awaitTermination (:executor this), Long/MAX_VALUE, TimeUnit/SECONDS)
            (catch InterruptedException e
                (throw (RuntimeException. e))
            )
        )
        nil
    )

    ;; Updates the relayTxesBeforeFilter flag of ver.
    #_method
    (defn- #_"PeerGroup" PeerGroup''update-version-message-relay-txes-before-filter [#_"PeerGroup" this]
        ;; We will provide the remote node with a bloom filter (i.e. they shouldn't relay yet)
        ;; if chain == null || !chain.shouldVerifyTransactions() and a wallet is added and bloom filters are enabled.
        ;; Note that the default here means that no tx invs will be received if no wallet is ever added.
        (sync (:peergroup-lock this)
            (let [#_"boolean" __spvMode (and (some? (:chain this)) (not (BlockChain'''should-verify-transactions (:chain this))))
                  #_"boolean" __willSendFilter (and __spvMode (seq (:wallets this)) (:v-bloom-filtering-enabled this))]
                (assoc-in this [:version-message :relay-txes-before-filter] (not __willSendFilter))
            )
        )
    )

    ;;;
     ; Link the given wallet to this PeerGroup.  This is used for three purposes:
     ;
     ; <ol>
     ;   <li>So the wallet receives broadcast transactions.</li>
     ;   <li>Announcing pending transactions that didn't get into the chain yet to our peers.</li>
     ;   <li>Set the fast catchup time using {@link PeerGroup#setFastCatchupTimeSecs(long)} to optimize chain download.</li>
     ; </ol>
     ;
     ; Note that this should be done before chain download commences because if you add a wallet with keys earlier
     ; than the current chain head, the relevant parts of the chain won't be redownloaded for you.
     ;
     ; The Wallet will have an event listener registered on it, so to avoid leaks remember to use
     ; {@link PeerGroup#removeWallet(Wallet)} on it if you wish to keep the Wallet but lose the PeerGroup.
     ;;
    #_method
    (defn #_"PeerGroup" PeerGroup''add-wallet [#_"PeerGroup" this, #_"Wallet" wallet]
        (ensure some? wallet)

        (sync (:peergroup-lock this)
            (assert-state (not (.contains (:wallets this), wallet)))

            (ยง ass wallet (Wallet''set-transaction-broadcaster wallet, this))
            (ยง ass wallet (Wallet''add-coins-received-event-listener wallet, (:wallet-coins-received-event-listener this)))
            (ยง ass wallet (Wallet''add-key-chain-event-listener wallet, (:wallet-key-event-listener this)))

            (ยง ass this (append* this :wallets wallet))

            ;; Don't bother downloading block bodies before the oldest keys in all our wallets.  Make sure we recalculate
            ;; if a key is added.  Of course, by then we may have downloaded the chain already.  Ideally adding keys would
            ;; automatically rewind the block chain and redownload the blocks to find transactions relevant to those keys,
            ;; all transparently and in the background.  But we are a long way from that yet.
            (let [_ (PeerGroup''recalculate-fast-catchup-and-filter this, :FilterRecalculateMode'SEND_IF_CHANGED)
                  this (PeerGroup''update-version-message-relay-txes-before-filter this)]
                (update* this :connected-peers Peer''add-wallet wallet)
            )
        )
    )

    ;;;
     ; Unlinks the given wallet so it no longer receives broadcast transactions or has its transactions announced.
     ;;
    #_method
    (defn #_"PeerGroup" PeerGroup''remove-wallet [#_"PeerGroup" this, #_"Wallet" wallet]
        (ensure some? wallet)

        (ยง ass wallet (Wallet''remove-coins-received-event-listener wallet, (:wallet-coins-received-event-listener this)))
        (ยง ass wallet (Wallet''remove-key-chain-event-listener wallet, (:wallet-key-event-listener this)))
        (ยง ass wallet (Wallet''set-transaction-broadcaster wallet, nil))

        (-> this (remove* :wallets = wallet) (update* :connected-peers Peer''remove-wallet wallet))
    )

    #_method
    (defn- #_"PeerGroup" PeerGroup''go-recalculate [#_"PeerGroup" this, #_"FilterRecalculateMode" mode, #_"SettableFuture<BloomFilter>" future]
        (assert-state (not (.isHeldByCurrentThread (:peergroup-lock this))))

        ;; Fully verifying mode doesn't use this optimization (it can't as it needs to see all transactions).
        (when-not (or (and (some? (:chain this)) (BlockChain'''should-verify-transactions (:chain this))) (not (:v-bloom-filtering-enabled this))) => this
            ;; We only ever call bloomFilterMerger.calculate on jobQueue, so we cannot be calculating two filters at once.
            (let [#_"FilterMerger" m' (:bloom-filter-merger this) this (update this :bloom-filter-merger FilterMerger''calculate (:wallets this))
                  #_"FilterMerger" m (:bloom-filter-merger this)
                  #_"boolean" send?
                    (condp = mode
                        :FilterRecalculateMode'SEND_IF_CHANGED        (not (BloomFilter'= (:merged-filter m), (:merged-filter m')))
                        :FilterRecalculateMode'DONT_SEND              false
                        :FilterRecalculateMode'FORCE_SEND_FOR_REFRESH true
                        (throw (UnsupportedOperationException.))
                    )
                  this
                    (when send? => this
                        ;; Only query the mempool if this recalculation request is not in order to lower the observed FP
                        ;; rate.  There's no point querying the mempool when doing this because the FP rate can only go
                        ;; down, and we will have seen all the relevant txns before: it's pointless to ask for them again.
                        (let [#_"boolean" query? (not= mode :FilterRecalculateMode'FORCE_SEND_FOR_REFRESH)
                              this (update* this :connected-peers Peer''set-bloom-filter (:merged-filter m), query?)]
                            ;; Reset the false positive estimate so that we don't send a flood of filter updates
                            ;; if the estimate temporarily overshoots our threshold.
                            (when (some? (:chain this)) => this
                                (update this :chain BlockChain''reset-false-positive-estimate)
                            )
                        )
                    )
                  ;; Do this last so that bloomFilter is already set when it gets called.
                  this (PeerGroup''set-fast-catchup-time-secs this, (:earliest-key-time-secs m))]
                (sync (:in-flight-recalculations this)
                    (ยง ass this (update this :in-flight-recalculations assoc mode nil))
                )
                (.set future, (:merged-filter m))
                this
            )
        )
    )

    ;;;
     ; Recalculates the bloom filter given to peers as well as the timestamp after which full blocks are downloaded
     ; (instead of only headers).  Note that calls made one after another may return the same future, if the request
     ; wasn't processed yet (i.e. calls are deduplicated).
     ;
     ; @param mode In what situations to send the filter to connected peers.
     ; @return A future that completes once the filter has been calculated (note: this does not mean acknowledged by remote peers).
     ;;
    #_method
    (defn #_"ListenableFuture<BloomFilter>" PeerGroup''recalculate-fast-catchup-and-filter [#_"PeerGroup" this, #_"FilterRecalculateMode" mode]
        (let [[#_"SettableFuture<BloomFilter>" past #_"SettableFuture<BloomFilter>" future]
                (sync (:in-flight-recalculations this)
                    (let-when [past (get (:in-flight-recalculations this) mode)] (nil? past) => [past nil]
                        (let [future (SettableFuture/create)]
                            (ยง ass this (update this :in-flight-recalculations assoc mode future))
                            [nil future]
                        )
                    )
                )]
            (when (some? future) => past
                (try
                    (.execute (:executor this),
                        #(try
                            (ยง ass this (PeerGroup''go-recalculate this, mode, future))
                            (catch Throwable e
                                (log/error e, "Exception when trying to recalculate Bloom filter") ;; The executor swallows exceptions :( ;; )
                            )
                        )
                    )
                    (catch RejectedExecutionException _
                        ;; Can happen during shutdown.
                    )
                )
                future
            )
        )
    )

    ;;;
     ; Sets the false positive rate of bloom filters given to peers.  The default is {@link #DEFAULT_BLOOM_FILTER_FP_RATE}.
     ;
     ; Be careful regenerating the bloom filter too often, as it decreases anonymity because remote nodes can
     ; compare transactions against both the new and old filters to significantly decrease the false positive rate.
     ;
     ; See the docs for {@link BloomFilter#BloomFilter(int, double, long, BloomFilter.BloomUpdate)} for a brief
     ; explanation of anonymity when using bloom filters.
     ;;
    #_method
    (defn #_"PeerGroup" PeerGroup''set-bloom-filter-false-positive-rate [#_"PeerGroup" this, #_"double" rate]
        (sync (:peergroup-lock this)
            (let [this (assoc-in this [:bloom-filter-merger :v-merger-fp-rate] rate)]
                (PeerGroup''recalculate-fast-catchup-and-filter this, :FilterRecalculateMode'SEND_IF_CHANGED)
                this
            )
        )
    )

    ;;;
     ; Connect to a peer by creating a channel to the destination address.  This should not be
     ; used normally - let the PeerGroup manage connections through {@link #start()}.
     ;
     ; @param address Destination IP and port.
     ; @return The newly created Peer object or null if the peer could not be connected.
     ;         Use {@link Peer#getConnectionOpenFuture()} if you
     ;         want a future which completes when the connection is open.
     ;;
    #_method
    (defn #_"[PeerGroup Peer]" PeerGroup''connect-to-socket-address [#_"PeerGroup" this, #_"InetSocketAddress" address]
        (sync (:peergroup-lock this)
            (let [#_"PeerAddress" __peerAddress (PeerAddress'from-socket-address (:ledger this), address)]
                (ยง ass this (update this :backoff-map assoc __peerAddress (ExponentialBackoff'new (:peer-backoff-params this))))
                (PeerGroup''connect-to-peer-address this, __peerAddress, true, (:v-connect-timeout-millis this))
            )
        )
    )

    ;;;
     ; Helper for forcing a connection to loopback.  Useful when using test mode.  Returns the peer object.
     ;;
    #_method
    (defn #_"[PeerGroup Peer]" PeerGroup''connect-to-loopback [#_"PeerGroup" this]
        (sync (:peergroup-lock this)
            (let [#_"PeerAddress" loopback (PeerAddress'loopback (:ledger this))]
                (ยง ass this (update this :backoff-map assoc loopback (ExponentialBackoff'new (:peer-backoff-params this))))
                (PeerGroup''connect-to-peer-address this, loopback, true, (:v-connect-timeout-millis this))
            )
        )
    )

    ;;;
     ; Creates a version message to send, constructs a Peer object and attempts to connect it.
     ; Returns the peer on success or null on failure.
     ;
     ; @param address Remote network address.
     ; @param increment? Whether to consider this connection an attempt to fill our quota, or something explicitly requested.
     ;;
    #_method
    (defn #_"[PeerGroup Peer]" PeerGroup''connect-to-peer-address [#_"PeerGroup" this, #_"PeerAddress" address, #_"boolean" increment?, #_"int" timeout]
        (assert-state (.isHeldByCurrentThread (:peergroup-lock this)))

        (let [this (update this :version-message assoc :best-height (if (some? (:chain this)) (BlockChain''get-best-chain-height (:chain this)) 0), :time-seconds (Time'seconds))
              #_"Peer" peer (PeerGroup''create-peer this, address, (:version-message this))
              peer (Peer''add-connected-event-listener peer, this)
              peer (Peer''add-disconnected-event-listener peer, this)
              [peer _] (Peer''set-min-protocol-version peer, (:v-min-required-protocol-version this))
              this (append* this :pending-peers peer)
              [this abort?]
                (try
                    (log/info (str "Attempting connection to " address "     (" (count (:connected-peers this)) " connected, " (count (:pending-peers this)) " pending, " (:max-connections this) " max)"))
                    (let [#_"ListenableFuture<SocketAddress>" future (ClientConnectionManager'''open-connection (:channels this), (PeerAddress''to-socket-address address), peer)]
                        (when (.isDone future)
                            (Uninterruptibles/getUninterruptibly future)
                        )
                        [this false]
                    )
                    (catch ExecutionException e
                        (let [#_"Throwable" cause (Throwables/getRootCause e)]
                            (log/warn (str "Failed to connect to " address ": " (.getMessage cause)))
                            [(PeerGroup''handle-peer-death this, peer, cause) true]
                        )
                    )
                )]

            (when-not abort? => [this nil]
                ;; When the channel has connected and version negotiated successfully,
                ;; handleNewPeer will end up being called on a worker thread.
                (let [this
                        (when increment? => this
                            ;; We don't use setMaxConnections here as that would trigger
                            ;; a recursive attempt to establish a new outbound connection.
                            (update this :max-connections inc)
                        )]
                    [this (ร AbstractTimeoutHandler''set-socket-timeout peer, timeout)]
                )
            )
        )
    )

    #_method
    (defn #_"Peer" PeerGroup''create-peer [#_"PeerGroup" this, #_"PeerAddress" address, #_"VersionMessage" ver]
        (Peer'new (:ledger this), ver, address, (:chain this), (:download-tx-dependency-depth this))
    )

    ;;;
     ; Start downloading the blockchain from the first available peer.
     ;
     ; If no peers are currently connected, the download will be started once a peer starts.
     ; If the peer dies, the download will resume with another peer.
     ;
     ; @param listener A listener for chain download events, may not be null.
     ;;
    #_method
    (defn #_"PeerGroup" PeerGroup''start-block-chain-download [#_"PeerGroup" this, #_"PeerDataEventListener" listener]
        (sync (:peergroup-lock this)
            (let [this
                    (when (some? (:download-peer this)) => this
                        (let [this
                                (when (some? (:download-listener this)) => this
                                    (update this :download-peer PeerGroup'remove-data-event-listener-from-peer (:download-listener this))
                                )]
                            (when (some? listener) => this
                                (update this :download-peer PeerGroup'add-data-event-listener-to-peer (ยง async! listener))
                            )
                        )
                    )
                  this (assoc this :download-listener listener)]
                ;; TODO: Be more nuanced about which peer to download from.  Try downloading from multiple peers
                ;; and handle the case when a new peer comes along with a longer chain after we thought we were done.
                (when (seq (:connected-peers this)) => this
                    ;; Will add the new download listener.
                    (PeerGroup''start-block-chain-download-from-peer this, (first (:connected-peers this)))
                )
            )
        )
    )

    ;;;
     ; Register a data event listener against a single peer (i.e. for blockchain download).
     ; Handling registration/deregistration on peer death/add is outside the scope of these methods.
     ;;
    (defn- #_"Peer" PeerGroup'add-data-event-listener-to-peer [#_"Peer" peer, #_"PeerDataEventListener" listener]
        (-> peer
            (Peer''add-blocks-downloaded-event-listener listener)
            (Peer''add-chain-download-started-event-listener listener)
            (Peer''add-get-data-event-listener listener)
            (Peer''add-pre-message-received-event-listener listener)
        )
    )

    ;;;
     ; Remove a registered data event listener against a single peer (i.e. for blockchain download).
     ; Handling registration/deregistration on peer death/add is outside the scope of these methods.
     ;;
    (defn- #_"Peer" PeerGroup'remove-data-event-listener-from-peer [#_"Peer" peer, #_"PeerDataEventListener" listener]
        (-> peer
            (Peer''remove-blocks-downloaded-event-listener listener)
            (Peer''remove-chain-download-started-event-listener listener)
            (Peer''remove-get-data-event-listener listener)
            (Peer''remove-pre-message-received-event-listener listener)
        )
    )

    ;;;
     ; Download the blockchain from peers.  Convenience that uses a {@link DownloadProgressTracker} for you.
     ;
     ; This method waits until the download is complete.  "Complete" is defined as downloading
     ; from at least one peer all the blocks that are in that peer's inventory.
     ;;
    #_method
    (defn #_"PeerGroup" PeerGroup''download-block-chain [#_"PeerGroup" this]
        (let [#_"DownloadProgressTracker" listener (DownloadProgressTracker'new) this (PeerGroup''start-block-chain-download this, listener)]
            (try
                (DownloadProgressTracker''await listener)
                (catch InterruptedException e
                    (throw (RuntimeException. e))
                )
            )
            this
        )
    )

    #_method
    (defn #_"PeerGroup" PeerGroup''handle-new-peer [#_"PeerGroup" this, #_"Peer" peer]
        (let [this
                (sync (:peergroup-lock this)
                    (let [this (remove* this :pending-peers = peer)
                          #_"PeerAddress" address (:peer-address peer)
                          this (update this :group-backoff ExponentialBackoff''track-success)
                          this (update-in this [:backoff-map address] ExponentialBackoff''track-success)
                          ;; Give the peer a filter that can be used to probabilistically drop transactions that
                          ;; aren't relevant to our wallet.  We may still receive some false positives, which is
                          ;; OK because it helps improve wallet privacy.  Old nodes will just ignore the message.
                          peer
                            (let-when [#_"BloomFilter" filter (:merged-filter (:bloom-filter-merger this))] (some? filter) => peer
                                (Peer''set-bloom-filter peer, filter, true)
                            )
                          peer (assoc peer :v-download-data false)
                          ;; TODO: The peer should calculate the fast catchup time from the added wallets here.
                          peer (reduce Peer''add-wallet peer (:wallets this))
                          this (append* this :connected-peers peer)]

                        (log/info (str address ": New peer      (" (count (:connected-peers this)) " connected, " (count (:pending-peers this)) " pending, " (:max-connections this) " max)"))

                        (let [this
                                (when (nil? (:download-peer this)) => this
                                    ;; Kick off chain download if we aren't already doing it.
                                    (let [this (PeerGroup''set-download-peer this, (Peer'select-download-peer (:connected-peers this)))]
                                        (when (and (some? (:download-listener this)) (some? (:chain this))) => this
                                            (PeerGroup''start-block-chain-download-from-peer this, (:download-peer this))
                                        )
                                    )
                                )]

                            ;; Make sure the peer knows how to upload transactions that are requested from us.
                            (ยง ass peer (Peer''add-blocks-downloaded-event-listener peer, (:peer-listener this)))
                            (ยง ass peer (Peer''add-get-data-event-listener peer, (:peer-listener this)))

                            ;; And set up event listeners for clients.  This will allow them to find out about new transactions and blocks.
                            (ยง ass peer (reduce Peer''add-blocks-downloaded-event-listener peer (:peers-blocks-downloaded-event-listeners this)))
                            (ยง ass peer (reduce Peer''add-chain-download-started-event-listener peer (:peers-chain-download-started-event-listeners this)))
                            (ยง ass peer (reduce Peer''add-connected-event-listener peer (:peer-connected-event-listeners this)))

                            ;; We intentionally do not add disconnect listeners to peers.
                            (ยง ass peer (reduce Peer''add-get-data-event-listener peer (:peer-get-data-event-listeners this)))
                            (ยง ass peer (reduce Peer''add-on-transaction-broadcast-listener peer (:peers-transaction-broadast-event-listeners this)))
                            (ยง ass peer (reduce Peer''add-pre-message-received-event-listener peer (:peers-pre-message-received-event-listeners this)))

                            this
                        )
                    )
                )]

            (doseq [#_"PeerConnectedEventListener" l (:peer-connected-event-listeners this)]
                (ยง async?
                    (ยง ass l (PeerConnectedEventListener'''on-peer-connected l, peer))
                )
            )
            this
        )
    )

    #_method
    (defn- #_"PeerGroup" PeerGroup''setup-pinging [#_"PeerGroup" this]
        (when (pos? (:ping-interval-msec this)) => this ;; Disabled.
            (assoc this :v-ping-task (.scheduleAtFixedRate (:executor this),
                #(try
                    (if-not (pos? (:ping-interval-msec this)) ;; Disabled.
                        (let [#_"ListenableScheduledFuture<?>" task (:v-ping-task this)]
                            (when (some? task)
                                (.cancel task, false)
                                (ยง ass this (assoc this :v-ping-task nil))
                            )
                        )
                        (doseq [#_"Peer" peer (:connected-peers this)]
                            (when (VersionMessage''is-ping-pong-supported (:v-peer-version-message peer))
                                (Peer''ping-1 peer)
                            )
                        )
                    )
                    (catch Throwable e
                        (log/error e, "Exception in ping loop") ;; The executor swallows exceptions :( ;; )
                    )
                ), (:ping-interval-msec this), (:ping-interval-msec this), TimeUnit/MILLISECONDS)
            )
        )
    )

    #_method
    (defn- #_"PeerGroup" PeerGroup''set-download-peer [#_"PeerGroup" this, #_"Peer" peer]
        (sync (:peergroup-lock this)
            (when-not (= (:download-peer this) peer) => this
                (let [this
                        (when (some? (:download-peer this)) => this
                            (log/info (str "Unsetting download peer: " (:download-peer this)))
                            (let [this
                                    (when (some? (:download-listener this)) => this
                                        (update this :download-peer PeerGroup'remove-data-event-listener-from-peer (:download-listener this))
                                    )]
                                (update this :download-peer assoc :v-download-data false)
                            )
                        )
                      this (assoc this :download-peer peer)]

                    (when (some? (:download-peer this)) => this
                        (log/info (str "Setting download peer: " (:download-peer this)))
                        (when (some? (:download-listener this))
                            (ยง ass peer (PeerGroup'add-data-event-listener-to-peer peer, (:download-listener this)))
                        )
                        (let [this (update this :download-peer assoc :v-download-data true)]
                            (when (some? (:chain this)) => this
                                (update this :download-peer Peer''set-download-parameters (:fast-catchup-time-secs this), (some? (:merged-filter (:bloom-filter-merger this))))
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Tells the PeerGroup to download only block headers before a certain time and bodies after that.
     ; Call this before starting block chain download.
     ; Do not use a time > NOW - 1 block, as it will break some block download logic.
     ;;
    #_method
    (defn #_"PeerGroup" PeerGroup''set-fast-catchup-time-secs [#_"PeerGroup" this, #_"long" secs]
        (sync (:peergroup-lock this)
            (assert-state (or (nil? (:chain this)) (not (BlockChain'''should-verify-transactions (:chain this)))), "Fast catchup is incompatible with fully verifying")

            (let [this (assoc this :fast-catchup-time-secs secs)]
                (when (some? (:download-peer this)) => this
                    (update this :download-peer Peer''set-download-parameters secs, (some? (:merged-filter (:bloom-filter-merger this))))
                )
            )
        )
    )

    #_method
    (defn #_"PeerGroup" PeerGroup''handle-peer-death [#_"PeerGroup" this, #_"Peer" peer, #_"Throwable" e]
        ;; Peer deaths can occur during startup if a connect attempt after peer discovery aborts immediately.
        (when (:v-running this) => this
            (let [this
                    (sync (:peergroup-lock this)
                        (let [this (-> this (remove* :pending-peers = peer) (remove* :connected-peers = peer))
                              #_"PeerAddress" address (:peer-address peer)]

                            (log/info (str address ": Peer died      (" (count (:connected-peers this)) " connected, " (count (:pending-peers this)) " pending, " (:max-connections this) " max)"))

                            (let [this
                                    (when (= peer (:download-peer this)) => this
                                        (log/info "Download peer died.  Picking a new one.")
                                        (let [this (PeerGroup''set-download-peer this, nil)
                                              ;; Pick a new one and possibly tell it to download the chain.
                                              #_"Peer" p (Peer'select-download-peer (:connected-peers this))]
                                            (when (some? p) => this
                                                (let [this (PeerGroup''set-download-peer this, p)]
                                                    (when (some? (:download-listener this)) => this
                                                        (PeerGroup''start-block-chain-download-from-peer this, p)
                                                    )
                                                )
                                            )
                                        )
                                    )
                                  this (update this :group-backoff ExponentialBackoff''track-failure)
                                  this
                                    (if (instance? NoRouteToHostException e)
                                        (when (and (instance? Inet6Address (:inet-addr address)) (not (:ipv6-unreachable this))) => this
                                            (log/warn "IPv6 peer connect failed due to routing failure, ignoring IPv6 addresses from now on.")
                                            (assoc this :ipv6-unreachable true)
                                        )
                                        (let [this (update-in this [:backoff-map address] ExponentialBackoff''track-failure)]
                                            ;; Put back on inactive list.
                                            (.offer (:inactives this), address)
                                            this
                                        )
                                    )]
                                (when (< (PeerGroup''count-connected-and-pending-peers this) (:max-connections this))
                                    (PeerGroup''trigger-connections this)
                                )
                                this
                            )
                        )
                    )]

                (ยง ass peer (Peer''remove-blocks-downloaded-event-listener peer, (:peer-listener this)))
                (ยง ass peer (Peer''remove-get-data-event-listener peer, (:peer-listener this)))
                (ยง ass peer (reduce Peer''remove-wallet peer (:wallets this)))

                (ยง ass peer (reduce Peer''remove-blocks-downloaded-event-listener peer (:peers-blocks-downloaded-event-listeners this)))
                (ยง ass peer (reduce Peer''remove-chain-download-started-event-listener peer (:peers-chain-download-started-event-listeners this)))
                (ยง ass peer (reduce Peer''remove-get-data-event-listener peer (:peer-get-data-event-listeners this)))
                (ยง ass peer (reduce Peer''remove-pre-message-received-event-listener peer (:peers-pre-message-received-event-listeners this)))
                (ยง ass peer (reduce Peer''remove-on-transaction-broadcast-listener peer (:peers-transaction-broadast-event-listeners this)))

                (doseq [#_"PeerDisconnectedEventListener" l (:peer-disconnected-event-listeners this)]
                    (ยง async?
                        (ยง ass l (PeerDisconnectedEventListener'''on-peer-disconnected l, peer))
                    )
                    (ยง ass peer (Peer''remove-disconnected-event-listener peer, l))
                )

                this
            )
        )
    )

    #_override
    (defn #_"PeerGroup" PeerConnectedEventListener'''on-peer-connected [#_"PeerGroup" this, #_"Peer" peer]
        (PeerGroup''handle-new-peer this, peer)
    )

    #_override
    (defn #_"PeerGroup" PeerDisconnectedEventListener'''on-peer-disconnected [#_"PeerGroup" this, #_"Peer" peer]
        ;; The channel will be automatically removed from channels.
        (PeerGroup''handle-peer-death this, peer, nil)
    )

    ;;;
     ; Configures the stall speed: the speed at which a peer is considered to be serving us the block chain
     ; unacceptably slowly.  Once a peer has served us data slower than the given data rate for the given
     ; number of seconds, it is considered stalled and will be disconnected, forcing the chain download to continue
     ; from a different peer.  The defaults are chosen conservatively, but if you are running on a platform that is
     ; CPU constrained or on a very slow network e.g. EDGE, the default settings may need adjustment to
     ; avoid false stalls.
     ;
     ; @param periodSecs How many seconds the download speed must be below blocksPerSec, defaults to 10.
     ; @param bytesPerSecond Download speed (only blocks/txns count) must be consistently below this for a stall,
     ;                       defaults to the bandwidth required for 20 block headers per second.
     ;;
    #_method
    (defn #_"PeerGroup" PeerGroup''set-stall-threshold [#_"PeerGroup" this, #_"int" secs, #_"int" __bytesPerSecond]
        (sync (:peergroup-lock this)
            (assoc this :stall-period-seconds secs, :stall-min-speed-bytes-sec __bytesPerSecond)
        )
    )

    #_method
    (defn- #_"PeerGroup" PeerGroup''start-block-chain-download-from-peer [#_"PeerGroup" this, #_"Peer" peer]
        (sync (:peergroup-lock this)
            (let [this (PeerGroup''set-download-peer this, peer)]
                (ยง ass peer (Peer''start-block-chain-download peer))
                this
            )
        )
    )

    ;;;
     ; Returns a future that is triggered when the number of connected peers is equal to the given number of peers.
     ; By using this with {@link PeerGroup#getMaxConnections()} you can wait until the network is fully online.
     ; To block immediately, just call get() on the result.  Just calls {@link #waitForPeersOfVersion(int, long)}
     ; with zero as the protocol version.
     ;
     ; @param numPeers How many peers to wait for.
     ; @return a future that will be triggered when the number of connected peers >= numPeers.
     ;;
    #_method
    (defn #_"ListenableFuture<List<Peer>>" PeerGroup''wait-for-peers [#_"PeerGroup" this, #_"int" __numPeers]
        (PeerGroup''wait-for-peers-of-version this, __numPeers, 0)
    )

    ;;;
     ; Returns a future that is triggered when there are at least the requested number of connected peers that support
     ; the given protocol version or higher.  To block immediately, just call get() on the result.
     ;
     ; @param numPeers How many peers to wait for.
     ; @param protocolVersion The protocol version the awaited peers must implement (or better).
     ; @return a future that will be triggered when the number of connected peers implementing protocolVersion or higher >= numPeers.
     ;;
    #_method
    (defn #_"ListenableFuture<List<Peer>>" PeerGroup''wait-for-peers-of-version [#_"PeerGroup" this, #_"int" n, #_"long" version]
        (let [#_"List<Peer>" peers (ArrayList. (PeerGroup''find-peers-of-at-least-version this, version))]
            (if (<= n (count peers))
                (Futures/immediateFuture peers)
                (let [#_"SettableFuture<List<Peer>>" future (SettableFuture/create)]
                    (ยง ass this (PeerGroup''add-connected-event-listener this,
                        (ยง async!
                            (ยง reify PeerConnectedEventListener
                                #_override
                                (ยง non-void #_"PeerConnectedEventListener" PeerConnectedEventListener'''on-peer-connected [#_"PeerConnectedEventListener" self, #_"Peer" _peer]
                                    (let [#_"List<Peer>" peers (ArrayList. (PeerGroup''find-peers-of-at-least-version this, version))]
                                        (when (<= n (count peers))
                                            (.set future, peers)
                                            (ยง ass this (PeerGroup''remove-connected-event-listener this, self))
                                        )
                                    )
                                    this
                                )
                            )
                        )
                    ))
                    future
                )
            )
        )
    )

    ;;;
     ; Returns a seq of peers that implement the given protocol version or better.
     ;;
    #_method
    (defn #_"Peer*" PeerGroup''find-peers-of-at-least-version [#_"PeerGroup" this, #_"long" version]
        (sync (:peergroup-lock this)
            (filter #(<= version (:client-version (:v-peer-version-message %))) (:connected-peers this))
        )
    )

    ;;;
     ; Returns a future that is triggered when there are at least the requested number of connected peers that support
     ; the given protocol version or higher.  To block immediately, just call get() on the result.
     ;
     ; @param numPeers How many peers to wait for.
     ; @param mask An integer representing a bit mask that will be ANDed with the peers advertised service masks.
     ; @return a future that will be triggered when the number of connected peers implementing protocolVersion or higher >= numPeers.
     ;;
    #_method
    (defn #_"ListenableFuture<List<Peer>>" PeerGroup''wait-for-peers-with-service-mask [#_"PeerGroup" this, #_"int" n, #_"int" mask]
        (sync (:peergroup-lock this)
            (let [#_"List<Peer>" peers (ArrayList. (PeerGroup''find-peers-with-service-mask this, mask))]
                (if (<= n (count peers))
                    (Futures/immediateFuture peers)
                    (let [#_"SettableFuture<List<Peer>>" future (SettableFuture/create)]
                        (ยง ass this (PeerGroup''add-connected-event-listener this,
                            (ยง async!
                                (ยง reify PeerConnectedEventListener
                                    #_override
                                    (ยง non-void #_"PeerConnectedEventListener" PeerConnectedEventListener'''on-peer-connected [#_"PeerConnectedEventListener" self, #_"Peer" _peer]
                                        (let [#_"List<Peer>" peers (ArrayList. (PeerGroup''find-peers-with-service-mask this, mask))]
                                            (when (<= n (count peers))
                                                (.set future, peers)
                                                (ยง ass this (PeerGroup''remove-connected-event-listener this, self))
                                            )
                                        )
                                        this
                                    )
                                )
                            )
                        ))
                        future
                    )
                )
            )
        )
    )

    ;;;
     ; Returns a seq of peers that match the requested service bit mask.
     ;;
    #_method
    (defn #_"Peer*" PeerGroup''find-peers-with-service-mask [#_"PeerGroup" this, #_"int" mask]
        (sync (:peergroup-lock this)
            (filter #(= (& (:local-services (:v-peer-version-message %)) mask) mask) (:connected-peers this))
        )
    )

    ;;;
     ; Returns the number of connections that are required before transactions will be broadcast.  If there aren't
     ; enough, {@link PeerGroup#broadcastTransaction(Transaction)} will wait until the minimum number is reached so
     ; propagation across the network can be observed.  If no value has been set using
     ; {@link PeerGroup#setMinBroadcastConnections(int)} a default of 80% of whatever
     ; {@link PeerGroup#getMaxConnections()} returns is used.
     ;;
    #_method
    (defn #_"int" PeerGroup''get-min-broadcast-connections [#_"PeerGroup" this]
        (sync (:peergroup-lock this)
            (if (zero? (:min-broadcast-connections this))
                (let [#_"int" m (:max-connections this)]
                    (if (<= m 1) m (int (Math/round (* m 0.8))))
                )
                (:min-broadcast-connections this)
            )
        )
    )

    ;;;
     ; Calls {@link PeerGroup#broadcastTransaction(Transaction, int)} with getMinBroadcastConnections() as the number
     ; of connections to wait for before commencing broadcast.
     ;;
    #_override
    (defn #_"TransactionBroadcast" TransactionBroadcaster'''broadcast-transaction-2 [#_"PeerGroup" this, #_"Transaction" tx]
        (PeerGroup''broadcast-transaction-3 this, tx, (max 1, (PeerGroup''get-min-broadcast-connections this)))
    )

    ;;;
     ; Given a transaction, sends it un-announced to one peer and then waits for it to be received back from
     ; other peers.  Once all connected peers have announced the transaction, the future available via the
     ; {@link TransactionBroadcast#future()} method will be completed.  If anything goes wrong, the exception
     ; will be thrown when get() is called, or you can receive it via a callback on the {@link ListenableFuture}.
     ; This method returns immediately, so if you want it to block just call get() on the result.
     ;
     ; Note that if the PeerGroup is limited to only one connection (discovery is not activated) then the future
     ; will complete as soon as the transaction was successfully written to that peer.
     ;
     ; The transaction won't be sent until there are at least minConnections active connections available.
     ; A good choice for proportion would be between 0.5 and 0.8 but if you want faster transmission during initial
     ; bringup of the peer group you can lower it.
     ;
     ; The returned {@link TransactionBroadcast} object can be used to get progress feedback,
     ; which is calculated by watching the transaction propagate across the network and be announced by peers.
     ;;
    #_method
    (defn #_"TransactionBroadcast" PeerGroup''broadcast-transaction-3 [#_"PeerGroup" this, #_"Transaction" tx, #_"int" __minConnections]
        ;; If we don't have a record of where this tx came from already, set it to be ourselves so Peer doesn't end up
        ;; redownloading it from the network redundantly.
        (when (= (:confidence-source (Transaction''get-confidence tx)) :ConfidenceSource'UNKNOWN)
            (log/info (str "Transaction source unknown, setting to SELF: " (Transaction''get-hash tx)))
            (ยง ass (Transaction''get-confidence tx) (assoc (Transaction''get-confidence tx) :confidence-source :ConfidenceSource'SELF))
        )
        (let [#_"TransactionBroadcast" broadcast (TransactionBroadcast'new this, tx)]
            (ยง ass broadcast (assoc broadcast :min-connections __minConnections))
            ;; Send the TX to the wallet once we have a successful broadcast.
            (Futures/addCallback (:future broadcast),
                (reify FutureCallback #_"<Transaction>"
                    #_foreign
                    #_override
                    (#_"void" onSuccess [#_"FutureCallback" __, #_"Transaction" tx]
                        (ยง ass this (update this :running-broadcasts .remove broadcast))
                        ;; OK, now tell the wallet about the transaction.  If the wallet created the transaction,
                        ;; then it already knows and will ignore this.  If it's a transaction we received from
                        ;; somebody else via a side channel and are now broadcasting, this will put it into the
                        ;; wallet now we know it's valid.
                        (doseq [#_"Wallet" wallet (:wallets this)]
                            ;; Assumption here is there are no dependencies of the created transaction.
                            ;; We may end up with two threads trying to do this in parallel - the wallet will
                            ;; ignore whichever one loses the race.
                            (Wallet''receive-pending-3 wallet, tx, nil)
                        )
                        nil
                    )

                    #_foreign
                    #_override
                    (#_"void" onFailure [#_"FutureCallback" __, #_"Throwable" _th]
                        ;; This can happen if we get a reject message from a peer.
                        (ยง ass this (update this :running-broadcasts .remove broadcast))
                        nil
                    )
                )
            )
            ;; Keep a reference to the TransactionBroadcast object.  This is important because otherwise, the entire tree
            ;; of objects we just created would become garbage if the user doesn't hold on to the returned future, and
            ;; eventually be collected.  This in turn could result in the transaction not being committed to the wallet
            ;; at all.
            (ยง ass this (update this :running-broadcasts .add broadcast))
            (TransactionBroadcast''broadcast broadcast)
            broadcast
        )
    )

    ;;;
     ; Sets the period between pings for an individual peer.  Setting this lower means more accurate and timely
     ; ping times are available via {@link Peer#getLastPingTime()} but it increases load on the
     ; remote node.  It defaults to {@link PeerGroup#DEFAULT_PING_INTERVAL_MSEC}.
     ; Setting the value to be <= 0 disables pinging entirely, although you can still request one yourself
     ; using {@link Peer#ping()}.
     ;;
    #_method
    (defn #_"PeerGroup" PeerGroup''set-ping-interval-msec [#_"PeerGroup" this, #_"long" msec]
        (sync (:peergroup-lock this)
            (let [this (assoc this :ping-interval-msec msec) #_"ListenableScheduledFuture<?>" task (:v-ping-task this)]
                (when (some? task)
                    (.cancel task, false)
                )
                (PeerGroup''setup-pinging this)
            )
        )
    )

    (defn- #_"long" Peer'max-of-most-freq [#_"long*" items]
        (when (seq items) => 0
            ;; Pick the max of the most frequent items.
            (let [#_"{long long}" pairs (sort-by second (comp - compare) (frequencies items)) #_"long" m (second (first pairs))]
                (reduce max (first (first pairs)) (map first (take-while #(= (second %) m) (rest pairs))))
            )
        )
    )

    ;;;
     ; Returns the most commonly reported chain height from the given seq of {@link Peer}s.
     ; If multiple heights are tied, the highest is returned.  If no peers are connected, returns zero.
     ;;
    (defn #_"long" Peer'most-common-chain-height [#_"Peer*" peers]
        (when (seq peers) => 0
            (Peer'max-of-most-freq (map Peer''get-best-height peers))
        )
    )

    ;;;
     ; Given a seq of Peers, return a Peer to be used as the download peer.
     ;;
    (defn #_"Peer" Peer'select-download-peer [#_"Peer*" peers]
        ;; Characteristics to select for in order of importance:
        ;;  - Chain height is reasonable (majority of nodes).
        ;;  - High enough protocol version for the features we want (but we'll settle for less).
        ;;  - Randomly, to try and spread the load.
        (when (seq peers)
            ;; Make sure we don't select a peer that is behind/synchronizing itself.
            (let [#_"long" common (Peer'most-common-chain-height peers) peers (filter #(= (Peer''get-best-height %) common) peers)
                  ;; Of the candidates, find the peers that meet the minimum protocol version we want to target.  We could select
                  ;; the highest version we've seen on the assumption that newer versions are always better but we don't want to
                  ;; zap peers if they upgrade early.  If we can't find any peers that have our preferred protocol version or
                  ;; better then we'll settle for the highest we found instead.
                  #_"long" highest (reduce max 0 (map #(:client-version (:v-peer-version-message %)) peers))
                  #_"long" height (min highest ProtocolVersion'BLOOM_FILTER)]
                (rand-nth (filter #(<= height (:client-version (:v-peer-version-message %))) peers))
            )
        )
    )

    ;;;
     ; Returns the currently selected download peer.  Bear in mind that it may have changed as soon
     ; as this method returns.  Can return null if no peer was selected.
     ;;
    #_method
    (defn #_"Peer" PeerGroup''get-download-peer [#_"PeerGroup" this]
        (sync (:peergroup-lock this)
            (:download-peer this)
        )
    )
)

;;;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns Ping (ยง extends Message)
    ;;;
     ; Create a Ping without (protocol version <= 60000) or with (protocol version > 60000) a nonce value.
     ;;
    (defn #_"Ping" Ping'new [#_"Ledger" ledger, #_"long" nonce]
        (merge (Message'new ledger)
            (hash-map
                #_"long" :nonce nonce
            )
        )
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"Ping" Ping'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload]
        (Ping'new ledger (when (.hasRemaining payload) (Wire'read-int64 payload)))
    )

    #_method
    (defn Ping''to-wire
        (#_"String" [] "ping")
        (#_"void" [#_"Ping" this, #_"ByteArrayOutputStream" baos]
            (when (some? (:nonce this))
                (Wire'write-int64 (:nonce this), baos)
            )
            nil
        )
    )
)

;;;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns Pong (ยง extends Message)
    ;;;
     ; Create a Pong with a nonce value.
     ; Only use this if the remote node has a protocol version > 60000.
     ;;
    (defn #_"Pong" Pong'new [#_"Ledger" ledger, #_"long" nonce]
        (merge (Message'new ledger)
            (hash-map
                ;;;
                 ; The nonce sent by the remote peer.
                 ;;
                #_"long" :nonce nonce
            )
        )
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"Pong" Pong'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload]
        (Pong'new ledger, (Wire'read-int64 payload))
    )

    #_method
    (defn Pong''to-wire
        (#_"String" [] "pong")
        (#_"void" [#_"Pong" this, #_"ByteArrayOutputStream" baos]
            (Wire'write-int64 (:nonce this), baos)
            nil
        )
    )
)

(class-ns ProtocolException (ยง extends VerificationException)
    (defn #_"ProtocolException" ProtocolException'new
        ([] (ProtocolException'new nil))
        ([#_"String" message]
            (VerificationException'new message))
    )
)

;; TODO: Rename PrunedException to something like RequiredDataWasPrunedException.

;;;
 ; PrunedException is thrown in cases where a fully verifying node has deleted (pruned) old block data that turned
 ; out to be necessary for handling a re-org.  Normally this should never happen unless you're playing with the testnet
 ; as the pruning parameters should be set very conservatively, such that an absolutely enormous re-org would be
 ; required to trigger it.
 ;;
(class-ns PrunedException (ยง extends RuntimeException)
    (defn #_"PrunedException" PrunedException'new [#_"Sha256Hash" hash]
        (merge (RuntimeException'new (Sha256Hash''to-base16 hash))
            (hash-map
                #_"Sha256Hash" :pruned-hash hash
            )
        )
    )
)

(def RejectCode'enum-map
    (hash-map
        ;;; The message was not able to be parsed. ;;
        :RejectCode'MALFORMED       0x01,
        ;;; The message described an invalid object. ;;
        :RejectCode'INVALID         0x10,
        ;;;
         ; The message was obsolete or described an object which is obsolete (e.g. unsupported, old version, v1 block).
         ;;
        :RejectCode'OBSOLETE        0x11,
        ;;;
         ; The message was relayed multiple times or described an object which is in conflict with another.
         ; This message can describe errors in protocol implementation or the presence of an attempt to DOUBLE SPEND.
         ;;
        :RejectCode'DUPLICATE       0x12,
        ;;;
         ; The message described an object was not standard and was thus not accepted.
         ; Bitcoin Core has a concept of standard transaction forms, which describe scripts and encodings which
         ; it is willing to relay further.  Other transactions are neither relayed nor mined, though they are considered
         ; valid if they appear in a block.
         ;;
        :RejectCode'NONSTANDARD     0x40,
        ;;;
         ; This refers to a specific form of NONSTANDARD transactions, which have an output smaller than some constant
         ; defining them as dust (this is no longer used).
         ;;
        :RejectCode'DUST            0x41,
        ;;; The messages described an object which did not have sufficient fee to be relayed further. ;;
        :RejectCode'INSUFFICIENTFEE 0x42,
        ;;; The message described a block which was invalid according to hard-coded checkpoint blocks. ;;
        :RejectCode'CHECKPOINT      0x43,
        :RejectCode'OTHER           0xff,
    )
)

(def RejectCode'for-code (clojure.set/map-invert RejectCode'enum-map))

;;;
 ; A message sent by nodes when a message we sent was rejected (i.e. a transaction had too little fee/was invalid/etc).
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns RejectMessage (ยง extends Message)
    ;;;
     ; Constructs a reject message that fingers the object with the given hash as rejected for the given reason.
     ;;
    (defn #_"RejectMessage" RejectMessage'new [#_"Ledger" ledger, #_"String" type, #_"RejectCode" code, #_"String" reason, #_"Sha256Hash" hash]
        (merge (Message'new ledger)
            (hash-map
                ;;;
                 ; Provides the type of message which was rejected by the peer.
                 ; Note that this is ENTIRELY UNTRUSTED and should be sanity-checked before it is printed or processed.
                 ;;
                #_"String" :reject-type type
                ;;;
                 ; The reason code given for why the peer rejected the message.
                 ;;
                #_"RejectCode" :reject-code code
                ;;;
                 ; The reason message given for rejection.
                 ; Note that this is ENTIRELY UNTRUSTED and should be sanity-checked before it is printed or processed.
                 ;;
                #_"String" :reject-reason reason
                ;;;
                 ; Provides the hash of the rejected object (if getRejectedMessage() is either "tx" or "block"), otherwise null.
                 ;;
                #_"Sha256Hash" :reject-hash hash
            )
        )
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"RejectMessage" RejectMessage'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload]
        (let [#_"String" type (Wire'read-string payload)
              #_"RejectCode" code (RejectCode'for-code (Wire'read-byte payload), :RejectCode'OTHER)
              #_"String" reason (Wire'read-string payload)
              #_"Sha256Hash" hash (when (any = type "block" "tx") (Wire'read-hash payload))]

            (RejectMessage'new ledger, type, code, reason, hash)
        )
    )

    #_method
    (defn RejectMessage''to-wire
        (#_"String" [] "reject")
        (#_"void" [#_"RejectMessage" this, #_"ByteArrayOutputStream" baos]
            (Wire'write-string (:reject-type this), baos)
            (.write baos, (RejectCode'enum-map (:reject-code this)))
            (Wire'write-string (:reject-reason this), baos)
            (when (any = (:reject-type this) "block" "tx")
                (Wire'write-hash (:reject-hash this), baos)
            )
            nil
        )
    )

    ;;;
     ; A String representation of the relevant details of this reject message.
     ; Be aware that the value returned by this method includes the value returned by
     ; {@link #getReasonString() getReasonString}, which is taken from the reject message unchecked.
     ; Through malice or otherwise, it might contain control characters or other harmful content.
     ;;
    #_method
    (defn #_"String" RejectMessage''to-string [#_"RejectMessage" this]
        (let [#_"Sha256Hash" hash (:reject-hash this)]
            (str "Reject: " (:reject-type this) (if (some? hash) (str " " (Sha256Hash''to-base16 hash)) "") " for reason '" (:reject-reason this) "' (" (RejectCode'enum-map (:reject-code this)) ")")
        )
    )
)

;;;
 ; This exception is used by the TransactionBroadcast class to indicate that a broadcast
 ; Transaction has been rejected by the network, for example because it violates a
 ; protocol rule.  Note that not all invalid transactions generate a reject message, and
 ; some peers may never do so.
 ;;
(class-ns RejectedTransactionException (ยง extends RuntimeException)
    (defn #_"RejectedTransactionException" RejectedTransactionException'new [#_"Transaction" tx, #_"RejectMessage" reject]
        (merge (RuntimeException'new (RejectMessage''to-string reject))
            (hash-map
                ;;; The original Transaction object whose broadcast was rejected. ;;
                #_"Transaction" :tx tx
                ;;; The RejectMessage object representing the broadcast rejection. ;;
                #_"RejectMessage" :reject-message reject
            )
        )
    )
)

(class-ns ScriptException (ยง extends VerificationException)
    (defn #_"ScriptException" ScriptException'new [#_"ScriptError" error, #_"String" message]
        (merge (VerificationException'new message)
            (hash-map
                #_"ScriptError" :error error
            )
        )
    )
)

;;;
 ; A Sha256Hash just wraps a byte[] so that equals and hashcode work correctly,
 ; allowing it to be used as keys in a map.
 ; It also checks that the length is correct and provides a bit more type safety.
 ;;
(class-ns Sha256Hash
    (def #_"int" Sha256Hash'LENGTH 32) ;; 256 bits = 32 bytes

    ;;;
     ; Creates a new instance that wraps the given hash value.
     ;
     ; @param bytes The raw hash bytes to wrap.
     ; @return a new instance.
     ; @throws IllegalArgumentException if the given array length is not exactly 32.
     ;;
    (defn #_"Sha256Hash" Sha256Hash'wrap [#_"byte[]" bytes]
        (assert-argument (= (count bytes) Sha256Hash'LENGTH))

        (hash-map
            #_"byte[]" :hash-bytes bytes
        )
    )

    ;;;
     ; Creates a new instance that wraps the given hash value (represented as a hex string).
     ;
     ; @param hex A hash value represented as a hex string.
     ; @return a new instance.
     ; @throws IllegalArgumentException if the given string is not a valid hex string, or if it does not represent exactly 32 bytes.
     ;;
    (defn #_"Sha256Hash" Sha256Hash'wrap-base16 [#_"String" hex]
        (Sha256Hash'wrap (Base16'decode hex))
    )

    ;;;
     ; Creates a new instance containing the calculated (one-time) hash of the given bytes.
     ;
     ; @param contents The bytes on which the hash value is calculated.
     ; @return a new instance containing the calculated (one-time) hash.
     ;;
    (defn #_"Sha256Hash" Sha256Hash'of [#_"byte[]" contents]
        (Sha256Hash'wrap (Sha256Hash'hash contents))
    )

    ;;;
     ; Creates a new instance containing the hash of the calculated hash of the given bytes.
     ;
     ; @param contents The bytes on which the hash value is calculated.
     ; @return a new instance containing the calculated (two-time) hash.
     ;;
    (defn #_"Sha256Hash" Sha256Hash'twice-of [#_"byte[]" contents]
        (Sha256Hash'wrap (Sha256Hash'hash-twice contents))
    )

    ;;;
     ; Returns a new SHA-256 MessageDigest instance.
     ;
     ; This is a convenience method which wraps the checked
     ; exception that can never occur with a RuntimeException.
     ;
     ; @return a new SHA-256 MessageDigest instance.
     ;;
    (defn #_"MessageDigest" Sha256Hash'create-digest []
        (try
            (MessageDigest/getInstance "SHA-256")
            (catch NoSuchAlgorithmException e
                (throw (RuntimeException. e)) ;; Can't happen.
            )
        )
    )

    ;;;
     ; Calculates the SHA-256 hash of the given bytes.
     ;
     ; @param input The array containing the bytes to hash.
     ; @param offset The offset within the array of the bytes to hash.
     ; @param length The number of bytes to hash.
     ; @return the hash (in big-endian order).
     ;;
    (defn #_"byte[]" Sha256Hash'hash
        ([#_"byte[]" input] (Sha256Hash'hash input, 0, (count input)))
        ([#_"byte[]" input, #_"int" offset, #_"int" length]
            (let [#_"MessageDigest" digest (Sha256Hash'create-digest)]
                (.update digest, input, offset, length)
                (.digest digest)
            )
        )
    )

    ;;;
     ; Calculates the SHA-256 hash of the given bytes,
     ; and then hashes the resulting hash again.
     ;
     ; @param input The array containing the bytes to hash.
     ; @param offset The offset within the array of the bytes to hash.
     ; @param length The number of bytes to hash.
     ; @return the double-hash (in big-endian order).
     ;;
    (defn #_"byte[]" Sha256Hash'hash-twice
        ([#_"byte[]" input] (Sha256Hash'hash-twice input, 0, (count input)))
        ([#_"byte[]" input, #_"int" offset, #_"int" length]
            (let [#_"MessageDigest" digest (Sha256Hash'create-digest)]
                (.update digest, input, offset, length)
                (.digest digest, (.digest digest))
            )
        )
    )

    ;;;
     ; Calculates the hash of hash on the given byte ranges.  This is equivalent to
     ; concatenating the two ranges and then passing the result to {@link #hashTwice(byte[])}.
     ;;
    (defn #_"byte[]" Sha256Hash'hash-twins-twice [#_"byte[]" input1, #_"int" offset1, #_"int" length1, #_"byte[]" input2, #_"int" offset2, #_"int" length2]
        (let [#_"MessageDigest" digest (Sha256Hash'create-digest)]
            (.update digest, input1, offset1, length1)
            (.update digest, input2, offset2, length2)
            (.digest digest, (.digest digest))
        )
    )

    (def #_"Sha256Hash" Sha256Hash'ZERO_HASH (Sha256Hash'wrap (byte-array Sha256Hash'LENGTH)))

    ;;;
     ; Returns the bytes interpreted as a positive integer.
     ;;
    #_method
    (defn #_"BigInteger" Sha256Hash''to-big-integer [#_"Sha256Hash" this]
        (BigInteger. 1, (:hash-bytes this))
    )

    (defn #_"int" Sha256Hash'compare [#_"Sha256Hash" this, #_"Sha256Hash" that]
        (loop-when [#_"int" i (dec Sha256Hash'LENGTH)] (<= 0 i) => 0
            (let [#_"int" b0 (& 0xff (nth (:hash-bytes this) i)) #_"int" b1 (& 0xff (nth (:hash-bytes that) i))]
                (cond (> b0 b1) 1 (< b0 b1) -1 :else (recur (dec i)))
            )
        )
    )

    #_method
    (defn #_"String" Sha256Hash''to-base16 [#_"Sha256Hash" this]
        (Base16'encode (:hash-bytes this))
    )
)

;;;
 ; Wraps a {@link Block} object with extra data that can be derived from the block chain but is slow or inconvenient
 ; to calculate.  By storing it alongside the block header we reduce the amount of work required significantly.
 ; Recalculation is slow because the fields are cumulative - to find the chainWork you have to iterate over every
 ; block in the chain back to the genesis block, which involves lots of seeking/loading etc.  So we just keep a
 ; running total: it's a disk space vs cpu/io tradeoff.
 ;
 ; StoredBlocks are put inside a {@link BlockStore} which saves them to memory or disk.
 ;;
(class-ns StoredBlock
    ;; A BigInteger representing the total amount of work done so far on this chain.  As of May 2011 it takes
    ;; 8 bytes to represent this field, so 12 bytes should be plenty for now.
    (def #_"int" StoredBlock'CHAIN_WORK_BYTES 12)
    (def #_"byte[]" StoredBlock'EMPTY_BYTES (byte-array StoredBlock'CHAIN_WORK_BYTES))
    (def #_"int" StoredBlock'COMPACT_SERIALIZED_SIZE (+ Block'HEADER_SIZE StoredBlock'CHAIN_WORK_BYTES 4)) ;; for height

    (defn #_"StoredBlock" StoredBlock'new [#_"Block" header, #_"BigInteger" work, #_"int" height]
        (hash-map
            ;;;
             ; The block header this object wraps.  The referenced block object must not have any transactions in it.
             ;;
            #_"Block" :stored-header header
            ;;;
             ; The total sum of work done in this block, and all the blocks below it in the chain.  Work is a measure of
             ; how many tries are needed to solve a block.  If the target is set to cover 10% of the total hash value space,
             ; then the work represented by a block is 10.
             ;;
            #_"BigInteger" :stored-work work
            ;;;
             ; Position in the chain for this block.  The genesis block has a height of zero.
             ;;
            #_"int" :stored-height height
        )
    )

    ;;; Returns true if this objects chainWork is higher than the others. ;;
    #_method
    (defn #_"boolean" StoredBlock''more-work-than [#_"StoredBlock" this, #_"StoredBlock" that]
        (< (:stored-work that) (:stored-work this))
    )

    ;;;
     ; Creates a new StoredBlock, calculating the additional fields by adding to the values in this block.
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn #_"StoredBlock" StoredBlock''build [#_"StoredBlock" this, #_"Block" block]
        ;; Stored blocks track total work done in this chain, because the canonical chain is the one that represents
        ;; the largest amount of work done not the tallest.
        (let [#_"BigInteger" work (.add (:stored-work this) (Block''get-work block)) #_"int" height (inc (:stored-height this))]
            (StoredBlock'new block, work, height)
        )
    )

    ;;;
     ; Given a block store, looks up the previous block in this chain.  Convenience method for doing
     ; <tt>store.get(this.getHeader().getPrevBlockHash())</tt>.
     ;
     ; @return the previous block in the chain or null if it was not found in the store.
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_method
    (defn #_"StoredBlock" StoredBlock''get-prev [#_"StoredBlock" this, #_"BlockStore" store]
        (BlockStore'''get store, (:prev-block-hash (:stored-header this)))
    )

    ;;; Serializes the stored block to a custom packed format.  Used by {@link CheckpointManager}. ;;
    #_method
    (defn #_"void" StoredBlock''serialize-compact [#_"StoredBlock" this, #_"ByteBuffer" buffer]
        (let [#_"byte[]" bytes (.toByteArray (:stored-work this)) #_"int" n (count bytes)]
            (assert-state (<= n StoredBlock'CHAIN_WORK_BYTES), "Ran out of space to store chain work!")
            (when (< n StoredBlock'CHAIN_WORK_BYTES)
                ;; Pad to the right size.
                (.put buffer, StoredBlock'EMPTY_BYTES, 0, (- StoredBlock'CHAIN_WORK_BYTES n))
            )
            (.put buffer, bytes)
        )
        (.putInt buffer, (:stored-height this))
        ;; Using unsafeBitcoinSerialize here can give us direct access to the same bytes we read off the wire,
        ;; avoiding serialization round-trips.
        (let [#_"byte[]" bytes (Message''to-bytes (:stored-header this), Block''to-wire)]
            (.put buffer, bytes, 0, Block'HEADER_SIZE) ;; Trim the trailing 00 byte (zero transactions).
        )
        nil
    )

    ;;; De-serializes the stored block from a custom packed format.  Used by {@link CheckpointManager}. ;;
    #_throws #_[ "ProtocolException" ]
    (defn #_"StoredBlock" StoredBlock'deserialize-compact [#_"Ledger" ledger, #_"ByteBuffer" buffer]
        (let [#_"byte[]" bytes (byte-array StoredBlock'CHAIN_WORK_BYTES) _ (.get buffer, bytes)
              #_"BigInteger" work (BigInteger. 1, bytes)
              #_"int" height (.getInt buffer) ;; +4 bytes
              ;; Extra byte for the 00 transactions length.
              #_"byte[]" header (byte-array (inc Block'HEADER_SIZE)) _ (.get buffer, header, 0, Block'HEADER_SIZE)]
            (StoredBlock'new (Block'from-wire ledger, (ByteBuffer/wrap header)), work, height)
        )
    )

    #_method
    (defn #_"String" StoredBlock''to-string [#_"StoredBlock" this]
        (str "Block " (Block''get-hash (:stored-header this)) " at height " (:stored-height this) ": " (:stored-header this))
    )
)

;;;
 ; Contains minimal data neccessary to disconnect/connect the transactions in the stored block at will.
 ; Can either store the full set of transactions (if the inputs for the block have not been tested to work)
 ; or the set of transaction outputs created/destroyed when the block is connected.
 ;;
(class-ns StoredUndoableBlock
    (defn- #_"StoredUndoableBlock" StoredUndoableBlock'init [#_"Sha256Hash" hash, #_"TransactionOutputChanges" changes, #_"List<Transaction>" transactions]
        (hash-map
            ;;;
             ; Hash of the represented block.
             ;;
            #_"Sha256Hash" :block-hash hash

            ;; Only one of either :tx-out-changes or :transactions will be set.

            ;;;
             ; The transaction output changes if they have been calculated.
             ;;
            #_"TransactionOutputChanges" :tx-out-changes changes
            ;;;
             ; The full list of transactions if it is stored.
             ;;
            #_"List<Transaction>" :transactions transactions
        )
    )

    (defn #_"StoredUndoableBlock" StoredUndoableBlock'from-changes [#_"Sha256Hash" hash, #_"TransactionOutputChanges" changes]
        (StoredUndoableBlock'init hash, changes, nil)
    )

    (defn #_"StoredUndoableBlock" StoredUndoableBlock'from-transactions [#_"Sha256Hash" hash, #_"List<Transaction>" transactions]
        (StoredUndoableBlock'init hash, nil, transactions)
    )

    #_foreign
    #_override
    (defn #_"boolean" Object'''equals [#_"StoredUndoableBlock" this, #_"Object" o]
        (cond
            (= this o) true
            (or (nil? o) (not= (.getClass this) (.getClass o))) false
            :else (= (:block-hash this) (:block-hash (cast' StoredUndoableBlock o)))
        )
    )

    #_foreign
    #_override
    (defn #_"int" Object'''hashCode [#_"StoredUndoableBlock" this]
        (.hashCode (:block-hash this))
    )

    #_method
    (defn #_"String" StoredUndoableBlock''to-string [#_"StoredUndoableBlock" this]
        (str "Undoable Block " (:block-hash this))
    )
)

;;;
 ; This enum describes the underlying reason the transaction was created.  It's useful for rendering wallet GUIs
 ; more appropriately.
 ;;
(def TransactionPurpose'enum-set
    (hash-set
        ;;; Used when the purpose of a transaction is genuinely unknown. ;;
        :TransactionPurpose'UNKNOWN
        ;;; Transaction created to satisfy a user payment request. ;;
        :TransactionPurpose'USER_PAYMENT
        ;;; Transaction automatically created and broadcast in order to reallocate money from old to new keys. ;;
        :TransactionPurpose'KEY_ROTATION
        ;;; Transaction that uses up pledges to an assurance contract. ;;
        :TransactionPurpose'ASSURANCE_CONTRACT_CLAIM
        ;;; Transaction that makes a pledge to an assurance contract. ;;
        :TransactionPurpose'ASSURANCE_CONTRACT_PLEDGE
        ;;; Send-to-self transaction that exists just to create an output of the right size we can pledge. ;;
        :TransactionPurpose'ASSURANCE_CONTRACT_STUB
        ;;; Raise fee, e.g. child-pays-for-parent. ;;
        :TransactionPurpose'RAISE_FEE
        ;; In future: de/refragmentation, privacy boosting/mixing, etc.
    )
)

;;;
 ; These constants are a part of a scriptSig signature on the inputs.  They define the details of how a
 ; transaction can be redeemed, specifically, they control how the hash of the transaction is calculated.
 ;;
(def #_"int" SigHash'UNSET               0) ;; Caution: Using this type in isolation is non-standard.  Treated similar to ALL.
(def #_"int" SigHash'ALL                 1)
(def #_"int" SigHash'NONE                2)
(def #_"int" SigHash'SINGLE              3)

(def #_"int" SigHash'ANYONECANPAY        0x80) ;; Caution: Using this type in isolation is non-standard.  Treated similar to ANYONECANPAY_ALL.
(def #_"int" SigHash'ANYONECANPAY_ALL    0x81)
(def #_"int" SigHash'ANYONECANPAY_NONE   0x82)
(def #_"int" SigHash'ANYONECANPAY_SINGLE 0x83)

;;;
 ; A transaction represents the movement of coins from some addresses to some other addresses.  It can also represent
 ; the minting of new coins.  A Transaction object corresponds to the equivalent in the Bitcoin C++ implementation.
 ;
 ; Transactions are the fundamental atoms of Bitcoin and have many powerful features.  Read
 ; <a href="https://bitcoinj.github.io/working-with-transactions">"Working with transactions"</a> in the
 ; documentation to learn more about how to use this class.
 ;
 ; All Bitcoin transactions are at risk of being reversed, though the risk is much less than with traditional payment
 ; systems.  Transactions have <i>confidence levels</i>, which help you decide whether to trust a transaction or not.
 ; Whether to trust a transaction is something that needs to be decided on a case by case basis - a rule that makes
 ; sense for selling MP3s might not make sense for selling cars, or accepting payments from a family member.  If you
 ; are building a wallet, how to present confidence to your users is something to consider carefully.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns Transaction (ยง extends Message)
    ;;;
     ; Threshold for lockTime: below this value it is interpreted as block number, otherwise as timestamp.
     ;;
    (def #_"int" Transaction'LOCKTIME_THRESHOLD 500000000) ;; Tue Nov  5 00:53:20 1985 UTC
    ;;;
     ; Same, but as a BigInteger for CHECKLOCKTIMEVERIFY.
     ;;
    (def #_"BigInteger" Transaction'LOCKTIME_THRESHOLD_BIG (BigInteger/valueOf Transaction'LOCKTIME_THRESHOLD))

    ;;;
     ; How many bytes a transaction can be before it won't be relayed anymore.  Currently 100kb.
     ;;
    (def #_"int" Transaction'MAX_STANDARD_TX_SIZE 100000)

    ;;;
     ; If feePerKb is lower than this, Bitcoin Core will treat it as if there were no fee.
     ;;
    (def #_"Coin" Transaction'REFERENCE_DEFAULT_MIN_TX_FEE (Coin'new 5000)) ;; 0.05 mBTC

    ;;;
     ; If using this feePerKb, transactions will get confirmed within the next couple of blocks.
     ; This should be adjusted from time to time.  Last adjustment: February 2017.
     ;;
    (def #_"Coin" Transaction'DEFAULT_TX_FEE (Coin'new 100000)) ;; 1 mBTC

    ;;;
     ; Any standard (i.e. pay-to-address) output smaller than this value (in satoshis) will most likely be rejected
     ; by the network.  This is calculated by assuming a standard output will be 34 bytes, and then using the formula
     ; used in {@link TransactionOutput#getMinNonDustValue(Coin)}.
     ;;
    (def #_"Coin" Transaction'MIN_NONDUST_OUTPUT (Coin'new 2730)) ;; satoshis

    ;; Below flags apply in the context of BIP 68.
     ; If this flag set, CTxIn::nSequence is NOT interpreted as a relative lock-time.
     ;;
    (def #_"long" Transaction'SEQUENCE_LOCKTIME_DISABLE_FLAG (<< 1 31))

    ;; If CTxIn::nSequence encodes a relative lock-time and this flag
     ; is set, the relative lock-time has units of 512 seconds,
     ; otherwise it specifies blocks with a granularity of 1.
     ;;
    (def #_"long" Transaction'SEQUENCE_LOCKTIME_TYPE_FLAG (<< 1 22))

    ;; If CTxIn::nSequence encodes a relative lock-time, this mask is
     ; applied to extract that lock-time from the sequence field.
     ;;
    (def #_"long" Transaction'SEQUENCE_LOCKTIME_MASK 0x0000ffff)

    (defn- #_"Transaction" Transaction'init []
        (hash-map
            ;; These are bitcoin serialized.
            #_"long" :version 0
            #_"ArrayList<TransactionInput>" :inputs nil
            #_"ArrayList<TransactionOutput>" :outputs nil
            #_"long" :lock-time 0

            ;; This is either the time the transaction was broadcast as measured from the local clock, or the time from the
            ;; block in which it was included.  Note that this can be changed by re-orgs so the wallet may update this field.
            ;; Old serialized transactions don't have this field, thus null is valid.  It is used for returning an ordered
            ;; list of transactions from a wallet, which is helpful for presenting to users.
            #_"long" :update-time nil

            ;; Records a map of which blocks the transaction has appeared in (keys) to an index within that block (values).
            ;; The "index" is not a real index, instead the values are only meaningful relative to each other.  For example,
            ;; consider two transactions that appear in the same block, t1 and t2, where t2 spends an output of t1.  Both
            ;; will have the same block hash as a key in their appearsInHashes, but the counter would be 1 and 2 respectively
            ;; regardless of where they actually appeared in the block.
            ;;
            ;; If this transaction is not stored in the wallet, appearsInHashes is null.
            #_"Map<Sha256Hash, Integer>" :appears-in-hashes nil

            ;;;
             ; The purpose for which this transaction was created.
             ;;
            #_"TransactionPurpose" :purpose :TransactionPurpose'UNKNOWN

            ;;;
             ; This field can be used by applications to record the exchange rate that was valid when the transaction happened.
             ; It's optional.
             ;;
            #_"ExchangeRate" :exchange-rate nil

            ;;;
             ; This field can be used to record the memo of the payment request that initiated the transaction.
             ; It's optional.
             ;;
            #_"String" :memo nil
        )
    )

    (defn #_"Transaction" Transaction'new [#_"Ledger" ledger]
        (let [this (merge (Message'new ledger) (Transaction'init))

              this (assoc this :version 1)
              this (assoc this :inputs (ArrayList.))
              this (assoc this :outputs (ArrayList.))]
            ;; We don't initialize appearsIn deliberately as it's only useful for transactions stored in the wallet.
            this
        )
    )

    ;;;
     ; Creates a transaction by reading payload.
     ;;
    #_throws #_[ "ProtocolException" ]
    (defn #_"Transaction" Transaction'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload]
        (let [this (merge (Message'new ledger) (Transaction'init))

              this (assoc this :version (Wire'read-uint32 payload))
              this
                (let [#_"long" n (Wire'read-var-int payload) #_"ArrayList<TransactionInput>" inputs (ArrayList. n)]
                    (dotimes [_ n]
                        (let [#_"TransactionInput" input (TransactionInput'from-wire ledger, payload, (ยง this))]
                            (ยง ass inputs (.add inputs, input))
                        )
                    )
                    (assoc this :inputs inputs)
                )
              this
                (let [#_"long" n (Wire'read-var-int payload) #_"ArrayList<TransactionOutput>" outputs (ArrayList. n)]
                    (dotimes [_ n]
                        (let [#_"TransactionOutput" output (TransactionOutput'from-wire ledger, payload, (ยง this))]
                            (ยง ass outputs (.add outputs, output))
                        )
                    )
                    (assoc this :outputs outputs)
                )
              this (assoc this :lock-time (Wire'read-uint32 payload))]
            this
        )
    )

    #_method
    (defn Transaction''to-wire
        (#_"String" [] "tx")
        (#_"void" [#_"Transaction" this, #_"ByteArrayOutputStream" baos]
            (Wire'write-uint32 (:version this), baos)
            (.write baos, (VarInt''encode (VarInt'new (count (:inputs this)))))
            (doseq [#_"TransactionInput" input (:inputs this)]
                (TransactionInput''to-wire input, baos)
            )
            (.write baos, (VarInt''encode (VarInt'new (count (:outputs this)))))
            (doseq [#_"TransactionOutput" output (:outputs this)]
                (TransactionOutput''to-wire output, baos)
            )
            (Wire'write-uint32 (:lock-time this), baos)
            nil
        )
    )

    ;;;
     ; Returns the transaction hash as you see them in the block explorer.
     ;;
    #_method
    (defn #_"Sha256Hash" Transaction''get-hash [#_"Transaction" this]
        (Sha256Hash'wrap (Wire'reverse-bytes (Sha256Hash'hash-twice (Message''to-bytes this, Transaction''to-wire))))
    )

    ;;;
     ; A comparator that can be used to sort transactions by their updateTime field.
     ; The ordering goes from most recent into the past.
     ;;
    (defn #_"int" Transaction'compare-by-update-time [#_"Transaction" this, #_"Transaction" that]
        (let [#_"int" cmp (- (compare (or (:update-time this) 0) (or (:update-time that) 0)))]
            ;; If time1 == time2, compare by tx hash to make comparator consistent with equals.
            (if (not= cmp 0) cmp (Sha256Hash'compare (Transaction''get-hash this), (Transaction''get-hash that)))
        )
    )

    ;;;
     ; A comparator that can be used to sort transactions by their chain height.
     ;;
    (defn #_"int" Transaction'compare-by-chain-height [#_"Transaction" this, #_"Transaction" that]
        (let [#_"TransactionConfidence" cf1 (Transaction''get-confidence this)
              #_"int" height1 (if (= (:confidence-type cf1) :ConfidenceType'BUILDING) (TransactionConfidence''get-appeared-at-chain-height cf1) Block'BLOCK_HEIGHT_UNKNOWN)
              #_"TransactionConfidence" cf2 (Transaction''get-confidence that)
              #_"int" height2 (if (= (:confidence-type cf2) :ConfidenceType'BUILDING) (TransactionConfidence''get-appeared-at-chain-height cf2) Block'BLOCK_HEIGHT_UNKNOWN)
              #_"int" cmp (- (compare height1 height2))]
            ;; If height1 == height2, compare by tx hash to make comparator consistent with equals.
            (if (not= cmp 0) cmp (Sha256Hash'compare (Transaction''get-hash this), (Transaction''get-hash that)))
        )
    )

    ;;;
     ; Gets the sum of the inputs, regardless of who owns them.
     ;;
    #_method
    (defn #_"Coin" Transaction''get-input-sum [#_"Transaction" this]
        (reduce Coin''add Coin'ZERO (filter some? (map :coin-value (:inputs this))))
    )

    ;;;
     ; Calculates the sum of the outputs that are sending coins to a key in the wallet.
     ;;
    #_method
    (defn #_"Coin" Transaction''get-value-sent-to-me [#_"Transaction" this, #_"Wallet" wallet]
        (reduce Coin''add Coin'ZERO (map :coin-value (filter #(TransactionOutput''is-mine %, wallet) (:outputs this))))
    )

    ;;;
     ; Convenience wrapper around getConfidence().getConfidenceType().
     ;
     ; @return true if this transaction hasn't been seen in any block yet.
     ;;
    #_method
    (defn #_"boolean" Transaction''is-pending [#_"Transaction" this]
        (= (:confidence-type (Transaction''get-confidence this)) :ConfidenceType'PENDING)
    )

    ;;;
     ; Puts the given block in the internal set of blocks in which this transaction appears.  This is
     ; used by the wallet to ensure transactions that appear on side chains are recorded properly even though
     ; the block stores do not save the transaction data at all.
     ;
     ; If there is a re-org this will be called once for each block that was previously seen, to update which block
     ; is the best chain.  The best chain block is guaranteed to be called last. So this must be idempotent.
     ;
     ; Sets updatedAt to be the earliest valid block time where this tx was seen.
     ;
     ; @param block     The {@link StoredBlock} in which the transaction has appeared.
     ; @param bestChain Whether to set the updatedAt timestamp from the block header (only if not already set).
     ; @param relativityOffset A number that disambiguates the order of transactions within a block.
     ;;
    #_method
    (defn #_"Transaction" Transaction''set-block-appearance [#_"Transaction" this, #_"StoredBlock" block, #_"boolean" best?, #_"int" offset]
        (let [#_"long" time (* (:time-seconds (:stored-header block)) 1000)
              this
                (when (and best? (let [#_"long" at (:update-time this)] (or (nil? at) (zero? at) (< time at)))) => this
                    (assoc this :update-time time)
                )
              this (Transaction''add-block-appearance this, (Block''get-hash (:stored-header block)), offset)]

            (when best? => this
                ;; This sets type to BUILDING and depth to one.
                (ยง ass (Transaction''get-confidence this) (TransactionConfidence''set-appeared-at-chain-height (Transaction''get-confidence this), (:stored-height block)))
                this
            )
        )
    )

    #_method
    (defn #_"Transaction" Transaction''add-block-appearance [#_"Transaction" this, #_"Sha256Hash" hash, #_"int" offset]
        ;; TODO: This could be a lot more memory efficient as we'll typically only store one element.
        (let [this
                (when (nil? (:appears-in-hashes this)) => this
                    (assoc this :appears-in-hashes (HashMap.))
                )]
            (ยง ass this (update this :appears-in-hashes assoc hash offset))
            this
        )
    )

    ;;;
     ; Calculates the sum of the inputs that are spending coins with keys in the wallet.  This requires the
     ; transactions sending coins to those keys to be in the wallet.  This method will not attempt to download
     ; the blocks containing the input transactions if the key is in the wallet but the transactions are not.
     ;
     ; @return sum of the inputs that are spending coins with keys in the wallet.
     ;;
    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"Coin" Transaction''get-value-sent-from-me [#_"Transaction" this, #_"Wallet" wallet]
        (loop-when [#_"Coin" v Coin'ZERO #_"TransactionInput*" inputs (:inputs this)] (seq inputs) => v
            (let [#_"TransactionInput" input (first inputs)
                  ;; This input is taking value from a transaction in our wallet.
                  ;; To discover the value, we must find the connected transaction.
                  #_"TransactionOutput" output
                    (or (TransactionInput''get-connected-output-2 input, (Wallet''get-transaction-pool wallet, :PoolType'UNSPENT))
                        (TransactionInput''get-connected-output-2 input, (Wallet''get-transaction-pool wallet, :PoolType'SPENT))
                        (TransactionInput''get-connected-output-2 input, (Wallet''get-transaction-pool wallet, :PoolType'PENDING))
                    )
                  ;; The connected output may be the change to the sender of a previous input sent to this wallet.
                  ;; In this case we ignore it.
                  v (when (and (some? output) (TransactionOutput''is-mine output, wallet)) => v
                        (Coin''add v, (:coin-value output))
                    )]
                (recur v (next inputs))
            )
        )
    )

    ;;;
     ; Gets the sum of the outputs of the transaction.  If the outputs are less than the inputs, it does not count the fee.
     ;
     ; @return the sum of the outputs regardless of who owns them.
     ;;
    #_method
    (defn #_"Coin" Transaction''get-output-sum [#_"Transaction" this]
        (reduce Coin''add Coin'ZERO (map :coin-value (:outputs this)))
    )

    ;;;
     ; Returns the difference of {@link Transaction#getValueSentToMe(Wallet)} and {@link Transaction#getValueSentFromMe(Wallet)}.
     ;;
    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"Coin" Transaction''get-value [#_"Transaction" this, #_"Wallet" wallet]
        (Coin''subtract (Transaction''get-value-sent-to-me this, wallet), (Transaction''get-value-sent-from-me this, wallet))
    )

    ;;;
     ; The transaction fee is the difference of the value of all inputs and the value of all outputs.
     ; Currently, the fee can only be determined for transactions created by us.
     ;
     ; @return fee, or null if it cannot be determined.
     ;;
    #_method
    (defn #_"Coin" Transaction''get-fee [#_"Transaction" this]
        (when (and (seq (:inputs this)) (seq (:outputs this))) ;; Else incomplete transaction.
            (let [#_"Coin" fee
                    (loop-when [fee Coin'ZERO #_"TransactionInput*" inputs (:inputs this)] (seq inputs) => fee
                        (when-let [#_"Coin" value (:coin-value (first inputs))]
                            (recur (Coin''add fee, value) (next inputs))
                        )
                    )]
                (when (some? fee)
                    (reduce Coin''subtract fee (map :coin-value (:outputs this)))
                )
            )
        )
    )

    ;;;
     ; Returns true if any of the outputs is marked as spent.
     ;;
    #_method
    (defn #_"boolean" Transaction''is-any-output-spent [#_"Transaction" this]
        (not (every? #(TransactionOutput''is-available-for-spending %) (:outputs this)))
    )

    ;;;
     ; Returns false if this transaction has at least one output that is owned by the given wallet and unspent,
     ; true otherwise.
     ;;
    #_method
    (defn #_"boolean" Transaction''is-every-owned-output-spent [#_"Transaction" this, #_"Wallet" wallet]
        (not (some #(and (TransactionOutput''is-available-for-spending %) (TransactionOutput''is-mine %, wallet)) (:outputs this)))
    )

    ;;;
     ; A coinbase transaction is one that creates a new coin.  They are the first transaction in each block and their
     ; value is determined by a formula that all implementations of Bitcoin share.  In 2011 the value of a coinbase
     ; transaction is 50 coins, but in future it will be less.  A coinbase transaction is defined not only by its
     ; position in a block but by the data in the inputs.
     ;;
    #_method
    (defn #_"boolean" Transaction''is-coin-base [#_"Transaction" this]
        (and (= (count (:inputs this)) 1) (TransactionInput''is-coin-base (nth (:inputs this) 0)))
    )

    ;;;
     ; A transaction is mature if it is either a building coinbase tx that is as deep or deeper than the required coinbase depth, or a non-coinbase tx.
     ;;
    #_method
    (defn #_"boolean" Transaction''is-mature [#_"Transaction" this]
        (cond
            (not (Transaction''is-coin-base this)) true
            (not= (:confidence-type (Transaction''get-confidence this)) :ConfidenceType'BUILDING) false
            :else (<= (-> this :ledger :spendable-coinbase-depth) (:depth-in-blocks (Transaction''get-confidence this)))
        )
    )

    ;;;
     ; Adds an input to this transaction that imports value from the given output.  Note that this input is <i>not</i>
     ; complete and after every input is added with {@link #addInput()} and every output is added with {@link #addOutput()},
     ; a {@link TransactionSigner} must be used to finalize the transaction and finish the inputs off.
     ; Otherwise it won't be accepted by the network.
     ;
     ; @return the newly created input.
     ;;
    #_method
    (defn #_"TransactionInput" Transaction''add-input-o [#_"Transaction" this, #_"TransactionOutput" from]
        (Transaction''add-input this, (TransactionInput'for-output (:ledger this), this, from))
    )

    ;;;
     ; Adds an input directly, with no checking that it's valid.
     ;
     ; @return the new input.
     ;;
    #_method
    (defn #_"TransactionInput" Transaction''add-input [#_"Transaction" this, #_"TransactionInput" input]
        (ยง ass input (assoc input :parent-tx this))
        (ยง ass this (update this :inputs .add input))
        input
    )

    ;;;
     ; Creates and adds an input to this transaction, with no checking that it's valid.
     ;
     ; @return the newly created input.
     ;;
    #_method
    (defn #_"TransactionInput" Transaction''add-input-s [#_"Transaction" this, #_"Sha256Hash" __spendTxHash, #_"long" index, #_"Script" script]
        (Transaction''add-input this, (TransactionInput'for-outpoint (:ledger this), this, (TransactionOutPoint'for-hash (:ledger this), __spendTxHash, index), (Script''to-bytes script)))
    )

    ;;;
     ; Adds a new and fully signed input for the given parameters.  Note that this method is <b>not</b> thread safe
     ; and requires external synchronization.  Please refer to general documentation on Bitcoin scripting and contracts
     ; to understand the values of sigHash and anyoneCanPay: otherwise you can use the other form of this method
     ; that sets them to typical defaults.
     ;
     ; @throws ScriptException if the scriptPubKey is not a pay to address or pay to pubkey script.
     ;;
    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"TransactionInput" Transaction''add-signed-input
        ([#_"Transaction" this, #_"TransactionOutPoint" outpoint, #_"Script" __scriptPubKey, #_"ECKey" __sigKey]
            (Transaction''add-signed-input this, outpoint, __scriptPubKey, __sigKey, SigHash'ALL, false))
        ([#_"Transaction" this, #_"TransactionOutPoint" outpoint, #_"Script" __scriptPubKey, #_"ECKey" __sigKey, #_"SigHash" mode, #_"boolean" anyone?]
            ;; Verify the API user didn't try to do operations out of order.
            (assert-state (seq (:outputs this)), "Attempting to sign tx without outputs.")

            (let [#_"TransactionInput" input (TransactionInput'for-outpoint (:ledger this), this, outpoint, (byte-array 0))]
                (Transaction''add-input this, input)
                (let [#_"Sha256Hash" hash (Transaction''hash-for-signature-5s this, (dec (count (:inputs this))), __scriptPubKey, mode, anyone?)
                      #_"TransactionSignature" __txSig (TransactionSignature'from-ecdsa (ECKey'''sign __sigKey, hash), mode, anyone?)]
                    (cond
                        (Script''is-sent-to-raw-pub-key __scriptPubKey)
                            (ยง ass input (TransactionInput''set-script-sig input, (Script'create-input-script-1 __txSig)))
                        (Script''is-sent-to-address __scriptPubKey)
                            (ยง ass input (TransactionInput''set-script-sig input, (Script'create-input-script-2 __txSig, __sigKey)))
                        :else
                            (throw+ (ScriptException'new :ScriptError'UNKNOWN_ERROR, (str "Don't know how to sign for this kind of scriptPubKey: " __scriptPubKey)))
                    )
                    input
                )
            )
        )
    )

    ;;;
     ; Adds the given output to this transaction.  The output must be completely initialized.  Returns the given output.
     ;;
    #_method
    (defn #_"TransactionOutput" Transaction''add-output [#_"Transaction" this, #_"TransactionOutput" output]
        (ยง ass output (assoc output :parent-tx this))
        (ยง ass this (update this :outputs .add output))
        output
    )

    ;;;
     ; Creates an output based on the given address and value, adds it to this transaction, and returns the new output.
     ;;
    #_method
    (defn #_"TransactionOutput" Transaction''add-output-ca [#_"Transaction" this, #_"Coin" value, #_"Address" address]
        (Transaction''add-output this, (TransactionOutput'for-address (:ledger this), this, value, address))
    )

    ;;;
     ; Creates an output that pays to the given pubkey directly (no address) with the given value, adds it to this
     ; transaction, and returns the new output.
     ;;
    #_method
    (defn #_"TransactionOutput" Transaction''add-output-ce [#_"Transaction" this, #_"Coin" value, #_"ECKey" pubkey]
        (Transaction''add-output this, (TransactionOutput'for-pubkey (:ledger this), this, value, pubkey))
    )

    ;;;
     ; Creates an output that pays to the given script.  The address and key forms are specialisations of this method,
     ; you won't normally need to use it unless you're doing unusual things.
     ;;
    #_method
    (defn #_"TransactionOutput" Transaction''add-output-cs [#_"Transaction" this, #_"Coin" value, #_"Script" script]
        (Transaction''add-output this, (TransactionOutput'for-script (:ledger this), this, value, (Script''to-bytes script)))
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.  The key
     ; must be usable for signing as-is: if the key is encrypted it must be decrypted first external to this method.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param redeemScript Byte-exact contents of the scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
    #_method
    (defn #_"TransactionSignature" Transaction''calculate-signature-b [#_"Transaction" this, #_"int" index, #_"ECKey" key, #_"byte[]" redeem, #_"SigHash" type, #_"boolean" anyone?]
        (let [#_"Sha256Hash" hash (Transaction''hash-for-signature-5b this, index, redeem, type, anyone?)]
            (TransactionSignature'from-ecdsa (ECKey'''sign key, hash), type, anyone?)
        )
    )

    ;;;
     ; Calculates a signature that is valid for being inserted into the input at the given position.  This is simply
     ; a wrapper around calling {@link Transaction#hashForSignature(int, byte[], Transaction.SigHash, boolean)}
     ; followed by {@link ECKey#sign(Sha256Hash)} and then returning a new {@link TransactionSignature}.
     ;
     ; @param inputIndex Which input to calculate the signature for, as an index.
     ; @param key The private key used to calculate the signature.
     ; @param redeemScript The scriptPubKey that is being satisified, or the P2SH redeem script.
     ; @param hashType Signing mode, see the enum for documentation.
     ; @param anyoneCanPay Signing mode, see the SigHash enum for documentation.
     ; @return A newly calculated signature object that wraps the r, s and sighash components.
     ;;
    #_method
    (defn #_"TransactionSignature" Transaction''calculate-signature-s [#_"Transaction" this, #_"int" index, #_"ECKey" key, #_"Script" redeem, #_"SigHash" type, #_"boolean" anyone?]
        (let [#_"Sha256Hash" hash (Transaction''hash-for-signature-5b this, index, (Script''to-bytes redeem), type, anyone?)]
            (TransactionSignature'from-ecdsa (ECKey'''sign key, hash), type, anyone?)
        )
    )

    ;;;
     ; Calculates a signature hash, that is, a hash of a simplified form of the transaction.  How exactly the transaction
     ; is simplified is specified by the type and anyoneCanPay parameters.
     ;
     ; This is a low level API and when using the regular {@link Wallet} class you don't have to call this yourself.
     ; When working with more complex transaction types and contracts, it can be necessary.  When signing a P2SH output
     ; the redeemScript should be the script encoded into the scriptSig field, for normal transactions, it's the
     ; scriptPubKey of the output you're signing for.
     ;
     ; @param inputIndex Input the signature is being calculated for.  Tx signatures are always relative to an input.
     ; @param redeemScript The bytes that should be in the given input during signing.
     ; @param type Should be SigHash.ALL.
     ; @param anyoneCanPay Should be false.
     ;;
    #_method
    (defn #_"Sha256Hash" Transaction''hash-for-signature-5b [#_"Transaction" this, #_"int" index, #_"byte[]" redeem, #_"SigHash" type, #_"boolean" anyone?]
        (let [#_"SigHash" mode (TransactionSignature'calc-sig-hash-value type, anyone?)]
            (Transaction''hash-for-signature-4b this, index, redeem, mode)
        )
    )

    ;;;
     ; Calculates a signature hash, that is, a hash of a simplified form of the transaction.  How exactly the transaction
     ; is simplified is specified by the type and anyoneCanPay parameters.
     ;
     ; This is a low level API and when using the regular {@link Wallet} class you don't have to call this yourself.
     ; When working with more complex transaction types and contracts, it can be necessary.  When signing a P2SH output
     ; the redeemScript should be the script encoded into the scriptSig field, for normal transactions, it's the
     ; scriptPubKey of the output you're signing for.
     ;
     ; @param inputIndex Input the signature is being calculated for.  Tx signatures are always relative to an input.
     ; @param redeemScript The script that should be in the given input during signing.
     ; @param type Should be SigHash.ALL.
     ; @param anyoneCanPay Should be false.
     ;;
    #_method
    (defn #_"Sha256Hash" Transaction''hash-for-signature-5s [#_"Transaction" this, #_"int" index, #_"Script" redeem, #_"SigHash" type, #_"boolean" anyone?]
        (let [#_"SigHash" mode (TransactionSignature'calc-sig-hash-value type, anyone?)]
            (Transaction''hash-for-signature-4b this, index, (Script''to-bytes redeem), mode)
        )
    )

    ;;;
     ; This is required for signatures which use a sigHashType which cannot be represented using SigHash and anyoneCanPay.
     ; See transaction c99c49da4c38af669dea436d3e73780dfdb6c1ecf9958baa52960e8baee30e73, which has sigHashType 0.
     ;;
    #_method
    (defn #_"Sha256Hash" Transaction''hash-for-signature-4b [#_"Transaction" this, #_"int" index, #_"byte[]" script, #_"SigHash" mode]
        ;; The SIGHASH flags are used in the design of contracts, please see this page for a further understanding of
        ;; the purposes of the code in this method:
        ;;
        ;;   https://en.bitcoin.it/wiki/Contracts

        ;; Create a copy of this transaction to operate upon because we need make changes to the inputs and outputs.
        ;; It would not be thread-safe to change the attributes of the transaction object itself.
        (let [#_"Transaction" tx (Transaction'from-wire (:ledger this), (ByteBuffer/wrap (Message''to-bytes this, Transaction''to-wire)))]

            ;; Clear input scripts in preparation for signing.  If we're signing a fresh transaction that step isn't very
            ;; helpful, but it doesn't add much cost relative to the actual EC math so we'll do it anyway.
            (dotimes [#_"int" i (count (:inputs tx))]
                (ยง ass (nth (:inputs tx) i) (TransactionInput''clear-script-bytes (nth (:inputs tx) i)))
            )

            ;; This step has no purpose beyond being synchronized with Bitcoin Core's bugs.  OP_CODESEPARATOR
            ;; is a legacy holdover from a previous, broken design of executing scripts that shipped in Bitcoin 0.1.
            ;; It was seriously flawed and would have let anyone take anyone elses money.  Later versions switched to
            ;; the design we use today where scripts are executed independently but share a stack.  This left the
            ;; OP_CODESEPARATOR instruction having no purpose as it was only meant to be used internally, not actually
            ;; ever put into scripts.  Deleting OP_CODESEPARATOR is a step that should never be required but if we don't
            ;; do it, we could split off the main chain.
            (let [script (Script'remove-all-instances-of-op script, Script'OP_CODESEPARATOR)]

                ;; Set the input to the script of its output.  Bitcoin Core does this but the step has no obvious purpose as
                ;; the signature covers the hash of the prevout transaction which obviously includes the output script
                ;; already.  Perhaps it felt safer to him in some way, or is another leftover from how the code was written.
                (let [#_"TransactionInput" input (nth (:inputs tx) index)]
                    (ยง ass input (TransactionInput''set-script-bytes input, script))

                    (let-when [#_"Sha256Hash" hash
                            (condp = (& mode 0x1f)
                                SigHash'NONE ;; means no outputs are signed at all - the signature is effectively for a "blank cheque".
                                (do
                                    (ยง ass tx (assoc tx :outputs (ArrayList. 0)))
                                    ;; The signature isn't broken by new versions of the transaction issued by other parties.
                                    (dotimes [#_"int" i (count (:inputs tx))]
                                        (when-not (= i index)
                                            (ยง ass (nth (:inputs tx) i) (assoc (nth (:inputs tx) i) :sequence 0))
                                        )
                                    )
                                    nil
                                )
                                SigHash'SINGLE ;; means only sign the output at the same index as the input (i.e. my output).
                                (if (< index (count (:outputs tx)))
                                    (do
                                        ;; In SIGHASH_SINGLE the outputs after the matching input index are deleted, and the outputs before
                                        ;; that position are "nulled out".  Unintuitively, the value in a "null" transaction is set to -1.
                                        (ยง ass tx (assoc tx :outputs (ArrayList. (.subList (:outputs tx), 0, (inc index)))))
                                        (dotimes [#_"int" i index]
                                            (.set (:outputs tx), i, (TransactionOutput'for-script (:ledger tx), tx, Coin'NEGATIVE_SATOSHI, (byte-array 0)))
                                        )
                                        ;; The signature isn't broken by new versions of the transaction issued by other parties.
                                        (dotimes [#_"int" i (count (:inputs tx))]
                                            (when-not (= i index)
                                                (ยง ass (nth (:inputs tx) i) (assoc (nth (:inputs tx) i) :sequence 0))
                                            )
                                        )
                                        nil
                                    )
                                    ;; The input index is beyond the number of outputs, it's a buggy signature made by a broken
                                    ;; Bitcoin implementation.  Bitcoin Core also contains a bug in handling this case:
                                    ;; any transaction output that is signed in this case will result in both the signed output
                                    ;; and any future outputs to this public key being steal-able by anyone who has
                                    ;; the resulting signature and the public key (both of which are part of the signed tx input).

                                    ;; Bitcoin Core's bug is that SignatureHash was supposed to return a hash and on this codepath it
                                    ;; actually returns the constant "1" to indicate an error, which is never checked for.  Oops.
                                    (Sha256Hash'wrap-base16 "0100000000000000000000000000000000000000000000000000000000000000")
                                )
                                nil
                            )
                    ] (nil? hash) => hash

                        (when (= (& mode SigHash'ANYONECANPAY) SigHash'ANYONECANPAY)
                            ;; SIGHASH_ANYONECANPAY means the signature in the input is not broken by changes/additions/removals
                            ;; of other inputs.  For example, this is useful for building assurance contracts.
                            (ยง ass tx (assoc tx :inputs (ArrayList. #_"<TransactionInput>")))
                            (ยง ass (:inputs tx) (.add (:inputs tx), input))
                        )

                        (let [#_"ByteArrayOutputStream" baos (ByteArrayOutputStream. (<< 1 8))]
                            (Transaction''to-wire tx, baos)
                            ;; We also have to write a hash type (sigHashType is actually an unsigned char).
                            (Wire'write-uint32 (& 0x000000ff mode), baos)
                            ;; Note that this is NOT reversed to ensure it will be signed correctly.  If it were to be printed out
                            ;; however then we would expect that it is IS reversed.
                            (Sha256Hash'twice-of (.toByteArray baos))
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Transactions can have an associated lock time, specified either as a block height or in seconds since the
     ; UNIX epoch.  A transaction is not allowed to be confirmed by miners until the lock time is reached, and
     ; since Bitcoin 0.8+ a transaction that did not end its lock period (non final) is considered to be non
     ; standard and won't be relayed or included in the memory pool either.
     ;;
    #_method
    (defn #_"Transaction" Transaction''set-lock-time [#_"Transaction" this, #_"long" time]
        (when-not (or (zero? time) (some #(not= (:sequence %) TransactionInput'NO_SEQUENCE) (:inputs this)))
            ;; At least one input must have a non-default sequence number for lock times to have any effect.
            ;; For instance one of them can be set to zero to make this feature work.
            (log/warn "Setting the lock time on a transaction when none of the inputs have non-default sequence numbers will not do what you expect!")
        )
        (assoc this :lock-time time)
    )

    ;;;
     ; Returns the list of transacion outputs, whether spent or unspent, that match a wallet by address or that are
     ; watched by a wallet, i.e. transaction outputs whose script's address is controlled by the wallet and transaction
     ; outputs whose script is watched by the wallet.
     ;
     ; @param wallet The wallet that controls addresses and watches scripts.
     ; @return seq of outputs relevant to the wallet in this transaction.
     ;;
    #_method
    (defn #_"TransactionOutput*" Transaction''get-wallet-outputs [#_"Transaction" this, #_"Wallet" wallet]
        (filter #(TransactionOutput''is-mine %, wallet) (:outputs this))
    )

    ;;;
     ; Randomly re-orders the transaction outputs: good for privacy.
     ;;
    #_method
    (defn #_"Transaction" Transaction''shuffle-outputs [#_"Transaction" this]
        (Collections/shuffle (:outputs this))
        this
    )

    ;;;
     ; Returns the confidence object for this transaction from the {@link TxConfidenceTable}.
     ;;
    #_method
    (defn #_"TransactionConfidence" Transaction''get-confidence [#_"Transaction" this]
        (TxConfidenceTable''get-or-create TxConfidenceTable'INSTANCE, (Transaction''get-hash this))
    )

    ;;;
     ; Check if the transaction has a known confidence.
     ;;
    #_method
    (defn #_"boolean" Transaction''has-confidence [#_"Transaction" this]
        (not= (:confidence-type (Transaction''get-confidence this)) :ConfidenceType'UNKNOWN)
    )

    ;;;
     ; Gets the count of regular SigOps in this transactions.
     ;;
    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"int" Transaction''get-sig-op-count [#_"Transaction" this]
        (reduce + (map Script'get-sig-op-count-1 (map :script-bytes (concat (:inputs this) (:outputs this)))))
    )

    ;;;
     ; Check block height is in coinbase input script, for use after BIP 34 enforcement is enabled.
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn #_"void" Transaction''check-coin-base-height [#_"Transaction" this, #_"int" height]
        (assert-argument (<= Block'BLOCK_HEIGHT_GENESIS height))
        (assert-state (Transaction''is-coin-base this))

        ;; Check block height is in coinbase input script.
        (let [#_"byte[]" expected (-> (ScriptBuilder'new) (ScriptBuilder''num height) (ScriptBuilder''to-script) (Script''to-bytes))
              #_"byte[]" actual (:script-bytes (nth (:inputs this) 0))]
            (when (< (count actual) (count expected))
                (throw+ (VerificationException'new "Block height mismatch in coinbase."))
            )

            (dotimes [#_"int" i (count expected)]
                (when-not (= (nth actual i) (nth expected i))
                    (throw+ (VerificationException'new "Block height mismatch in coinbase."))
                )
            )
        )
        nil
    )

    ;;;
     ; Checks the transaction contents for sanity, in ways that can be done in a standalone manner.
     ; Does <b>not</b> perform all checks on a transaction such as whether the inputs are already spent.
     ; Specifically this method verifies:
     ;
     ; <ul>
     ;     <li>That there is at least one input and output.</li>
     ;     <li>That the serialized size is not larger than the max block size.</li>
     ;     <li>That no outputs have negative value.</li>
     ;     <li>That the outputs do not sum to larger than the max allowed quantity of coin in the system.</li>
     ;     <li>If the tx is a coinbase tx, the coinbase scriptSig size is within range.  Otherwise that
     ;     there are no coinbase inputs in the tx.</li>
     ; </ul>
     ;
     ; @throws VerificationException
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn #_"void" Transaction''verify [#_"Transaction" this]
        (when-not (and (seq (:inputs this)) (seq (:outputs this)))
            (throw+ (VerificationException'new "Transaction had no inputs or no outputs."))
        )

        (let [#_"HashSet<TransactionOutPoint>" outpoints (HashSet.)]
            (doseq [#_"TransactionInput" input (:inputs this)]
                (when (contains? outpoints (:outpoint input))
                    (throw+ (VerificationException'new "Duplicated outpoint"))
                )
                (ยง ass outpoints (.add outpoints, (:outpoint input)))
            )
        )

        (try
            (loop-when [#_"Coin" value Coin'ZERO #_"TransactionOutput*" outputs (:outputs this)] (seq outputs)
                (let [#_"TransactionOutput" output (first outputs)]
                    (when (Coin''negative? (:coin-value output))
                        (throw+ (VerificationException'new "Transaction output negative"))
                    )
                    (let [value (Coin''add value, (:coin-value output))]
                        (when (and (Ledger''has-max-money (:ledger this)) (Coin''greater-than? value, (Ledger''get-max-money (:ledger this))))
                            (throw (IllegalArgumentException.))
                        )
                        (recur value (next outputs))
                    )
                )
            )
            (catch IllegalStateException _
                (throw+ (VerificationException'new "Total transaction output value greater than possible"))
            )
            (catch IllegalArgumentException _
                (throw+ (VerificationException'new "Total transaction output value greater than possible"))
            )
        )

        (if (Transaction''is-coin-base this)
            (let [#_"int" n (count (:script-bytes (nth (:inputs this) 0)))]
                (when-not (<= 2 n 100)
                    (throw+ (VerificationException'new "Coinbase script size out of range"))
                )
            )
            (doseq [#_"TransactionInput" input (:inputs this)]
                (when (TransactionInput''is-coin-base input)
                    (throw+ (VerificationException'new "Coinbase input as input in non-coinbase transaction"))
                )
            )
        )
        nil
    )

    ;;;
     ; A transaction is time locked if at least one of its inputs is non-final and it has a lock time.
     ;
     ; To check if this transaction is final at a given height and time, see {@link Transaction#isFinal(int, long)}.
     ;;
    #_method
    (defn #_"boolean" Transaction''is-time-locked [#_"Transaction" this]
        (and (not= (:lock-time this) 0) (some #(TransactionInput''has-sequence %) (:inputs this)))
    )

    ;;;
     ; Returns whether this transaction will opt into the
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki">full replace-by-fee</a> semantics.
     ;;
    #_method
    (defn #_"boolean" Transaction''is-opt-in-full-rbf [#_"Transaction" this]
        (boolean (some #(TransactionInput''is-opt-in-full-rbf %) (:inputs this)))
    )

    ;;;
     ; Returns true if this transaction is considered finalized and can be placed in a block.  Non-finalized
     ; transactions won't be included by miners and can be replaced with newer versions using sequence numbers.
     ; This is useful in certain types of <a href="http://en.bitcoin.it/wiki/Contracts">contracts</a>, such as
     ; micropayment channels.
     ;
     ; Note that currently the replacement feature is disabled in Bitcoin Core and will need to be
     ; re-activated before this functionality is useful.
     ;;
    #_method
    (defn #_"boolean" Transaction''is-final [#_"Transaction" this, #_"int" height, #_"long" secs]
        (let [#_"long" time (:lock-time this)]
            (or (< time (if (< time Transaction'LOCKTIME_THRESHOLD) height secs)) (not (Transaction''is-time-locked this)))
        )
    )

    ;;;
     ; Returns either the lock time as a date, if it was specified in seconds, or an estimate based on the time in
     ; the current head block if it was specified as a block time.
     ;;
    #_method
    (defn #_"Date" Transaction''estimate-lock-time [#_"Transaction" this, #_"BlockChain" chain]
        (if (< (:lock-time this) Transaction'LOCKTIME_THRESHOLD)
            (BlockChain''estimate-block-time chain, (int (:lock-time this)))
            (Date. (* (:lock-time this) 1000))
        )
    )

    #_foreign
    #_override
    (defn #_"boolean" Object'''equals [#_"Transaction" this, #_"Object" o]
        (cond
            (= this o) true
            (or (nil? o) (not= (.getClass this) (.getClass o))) false
            :else (= (Transaction''get-hash this) (Transaction''get-hash (cast' Transaction o)))
        )
    )

    #_foreign
    #_override
    (defn #_"int" Object'''hashCode [#_"Transaction" this]
        (.hashCode (Transaction''get-hash this))
    )

    ;;;
     ; A human readable version of the transaction useful for debugging.  The format is not guaranteed to be stable.
     ;
     ; @param chain If provided, will be used to estimate lock times (if set).  Can be null.
     ;;
    #_method
    (defn #_"String" Transaction''to-string
        ([#_"Transaction" this] (Transaction''to-string this, nil))
        ([#_"Transaction" this, #_"BlockChain" chain]
            (let [#_"StringBuilder" sb (StringBuilder. (<< 1 8))]
                (.. sb (append "  ") (append (Transaction''get-hash this)) (append "\n"))
                (when (some? (:update-time this))
                    (.. sb (append "  updated: ") (append (Time'format (:update-time this))) (append "\n"))
                )
                (when-not (= (:version this) 1)
                    (.. sb (append "  version ") (append (:version this)) (append "\n"))
                )
                (when (Transaction''is-time-locked this)
                    (.. sb (append "  time locked until "))
                    (if (< (:lock-time this) Transaction'LOCKTIME_THRESHOLD)
                        (do
                            (.. sb (append "block ") (append (:lock-time this)))
                            (when (some? chain)
                                (.. sb (append " (estimated to be reached at ") (append (Time'format (.getTime (BlockChain''estimate-block-time chain, (int (:lock-time this)))))) (append ")"))
                            )
                        )
                        (.. sb (append (Time'format-seconds (:lock-time this))))
                    )
                    (.. sb (append "\n"))
                )
                (when (Transaction''is-opt-in-full-rbf this)
                    (.. sb (append "  opts into full replace-by-fee\n"))
                )
                (if (Transaction''is-coin-base this)
                    (let [[#_"Script" script1 #_"Script" script2]
                            (try+
                                [(TransactionInput''get-script-sig (nth (:inputs this) 0)) (TransactionOutput''parse-script-pub-key (nth (:outputs this) 0))]
                                (ยง catch ScriptException _
                                    ["???" "???"]
                                )
                            )]
                        (.. sb (append "     == COINBASE TXN (scriptSig ") (append script1) (append ")  (scriptPubKey ") (append script2) (append ")\n"))
                        (.toString sb)
                    )
                    (do
                        (when (seq (:inputs this)) => (.. sb (append "     INCOMPLETE: No inputs!\n"))
                            (doseq [#_"TransactionInput" in (:inputs this)]
                                (.. sb (append "     in   "))
                                (try
                                    (let [#_"String" s (Script''to-string (TransactionInput''get-script-sig in))]
                                        (.. sb (append (if (seq s) s "<no scriptSig>")))
                                        (let [#_"Coin" value (:coin-value in)]
                                            (when (some? value)
                                                (.. sb (append " ") (append (Coin''to-friendly-string value)))
                                            )
                                            (.. sb (append "\n          outpoint:"))
                                            (let [#_"TransactionOutPoint" outpoint (:outpoint in)]
                                                (.. sb (append outpoint))
                                                (let [#_"TransactionOutput" __connectedOutput (TransactionOutPoint''get-connected-output outpoint)]
                                                    (when (some? __connectedOutput)
                                                        (let [#_"Script" __scriptPubKey (TransactionOutput''parse-script-pub-key __connectedOutput)]
                                                            (when (or (Script''is-sent-to-address __scriptPubKey) (Script''is-pay-to-script-hash __scriptPubKey))
                                                                (.. sb (append " hash160:") (append (Base16'encode (Script''get-pub-key-hash __scriptPubKey))))
                                                            )
                                                        )
                                                    )
                                                    (when (TransactionInput''has-sequence in)
                                                        (.. sb (append "\n          sequence:") (append (Long/toHexString (:sequence in))))
                                                        (when (TransactionInput''is-opt-in-full-rbf in)
                                                            (.. sb (append ", opts into full RBF"))
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (catch Exception e
                                        (.. sb (append "[exception: ") (append (.getMessage e)) (append "]"))
                                    )
                                )
                                (.. sb (append "\n"))
                            )
                        )
                        (doseq [#_"TransactionOutput" out (:outputs this)]
                            (.. sb (append "     out  "))
                            (try
                                (let [#_"String" s (Script''to-string (TransactionOutput''parse-script-pub-key out))]
                                    (.. sb (append (if (seq s) s "<no scriptPubKey>")) (append " ") (append (Coin''to-friendly-string (:coin-value out))))
                                    (when-not (TransactionOutput''is-available-for-spending out)
                                        (.. sb (append " Spent"))
                                    )
                                    (let [#_"TransactionInput" __spentBy (:spent-by out)]
                                        (when (some? __spentBy)
                                            (.. sb (append " by ") (append (Transaction''get-hash (:parent-tx __spentBy))))
                                        )
                                    )
                                )
                                (catch Exception e
                                    (.. sb (append "[exception: ") (append (.getMessage e)) (append "]"))
                                )
                            )
                            (.. sb (append "\n"))
                        )
                        (let [#_"Coin" fee (Transaction''get-fee this)]
                            (when (some? fee)
                                (let [#_"int" size (count (Message''to-bytes this, Transaction''to-wire))]
                                    (.. sb (append "     fee  ") (append (Coin''to-friendly-string (Coin''divide (Coin''multiply fee, 1000), size))) (append "/kB, ") (append (Coin''to-friendly-string fee)) (append " for ") (append size) (append " bytes\n"))
                                )
                            )
                            (when (some? (:purpose this))
                                (.. sb (append "     prps ") (append (:purpose this)) (append "\n"))
                            )
                        )
                        (.toString sb)
                    )
                )
            )
        )
    )
)

;;; An interface for receiving progress information on the propagation of the tx, from 0.0 to 1.0 ;;
(defprotocol ProgressCallback
    ;;;
     ; onBroadcastProgress will be invoked on the provided executor when the progress of the transaction
     ; broadcast has changed, because the transaction has been announced by another peer or because the transaction
     ; was found inside a mined block (in this case progress will go to 1.0 immediately).  Any exceptions thrown
     ; by this callback will be logged and ignored.
     ;;
    #_abstract
    (#_"void" ProgressCallback'''on-broadcast-progress [#_"ProgressCallback" this, #_"double" progress])
)

;;;
 ; A confidence listener is informed when the level of {@link TransactionConfidence} is updated by something, like
 ; for example a {@link Wallet}.  You can add listeners to update your user interface or manage your order tracking
 ; system when confidence levels pass a certain threshold.  <b>Note that confidence can go down as well as up.</b>
 ; For example, this can happen if somebody is doing a double-spend attack against you.  Whilst it's unlikely, your
 ; code should be able to handle that in order to be correct.
 ;
 ; During listener execution, it's safe to remove the current listener but not others.
 ;;
(defprotocol TransactionConfidenceListener
    #_abstract
    (#_"void" TransactionConfidenceListener'''on-confidence-changed [#_"TransactionConfidenceListener" this, #_"TransactionConfidence" confidence, #_"ConfidenceChangeReason" reason])
)

#_non-static #_"TransactionBroadcast"
(class-ns ConfidenceChange (ยง implements TransactionConfidenceListener)
    (defn- #_"ConfidenceChange" ConfidenceChange'new []
        (hash-map)
    )

    #_override
    (defn #_"void" TransactionConfidenceListener'''on-confidence-changed [#_"ConfidenceChange" self, #_"TransactionConfidence" conf, #_"ConfidenceChangeReason" reason]
        ;; The number of peers that announced this tx has gone up.
        (let [#_"int" seen (+ (count (:broadcast-by conf)) (count (:rejects (ยง this))))
              #_"boolean" mined? (some? (:appears-in-hashes (:tx (ยง this))))]
            (log/info (str "broadcastTransaction: " reason ":  TX " (Transaction''get-hash (:tx (ยง this))) " seen by " seen " peers" (if mined? " and mined" "")))

            ;; Progress callback on the requested thread.
            (ยง ass (ยง this) (TransactionBroadcast''invoke-and-record (ยง this), seen, mined?))

            (when (or (<= (:num-waiting-for (ยง this)) seen) mined?)
                ;; We've seen the min required number of peers announce the transaction, or it was included
                ;; in a block.  Normally we'd expect to see it fully propagate before it gets mined, but
                ;; it can be that a block is solved very soon after broadcast, and it's also possible that
                ;; due to version skew and changes in the relay rules our transaction is not going to
                ;; fully propagate yet can get mined anyway.
                ;;
                ;; Note that we can't wait for the current number of connected peers right now because we
                ;; could have added more peers after the broadcast took place, which means they won't
                ;; have seen the transaction.  In future when peers sync up their memory pools after they
                ;; connect we could come back and change this.
                ;;
                ;; We're done!  It's important that the PeerGroup lock is not held (by this thread) at this
                ;; point to avoid triggering inversions when the Future completes.
                (log/info (str "broadcastTransaction: " (Transaction''get-hash (:tx (ยง this))) " complete"))
                (ยง ass (:peer-group (ยง this)) (PeerGroup''remove-pre-message-received-event-listener (:peer-group (ยง this)), (:rejection-listener (ยง this))))
                (ยง ass conf (TransactionConfidence''remove-event-listener conf, self))
                (.set (:future (ยง this)), (:tx (ยง this))) ;; RE-ENTRANCY POINT
            )
        )
        nil
    )
)

;;;
 ; Represents a single transaction broadcast that we are performing.  A broadcast occurs after a new transaction
 ; is created (typically by a {@link Wallet}) and needs to be sent to the network.  A broadcast can succeed or fail.
 ; A success is defined as seeing the transaction be announced by peers via inv messages, thus indicating their acceptance.
 ; A failure is defined as not reaching acceptance within a timeout period, or getting an explicit reject message from
 ; a peer indicating that the transaction was not acceptable.
 ;;
(class-ns TransactionBroadcast
    ;;; Used for shuffling the peers before broadcast: unit tests can replace this to make themselves deterministic. ;;
    #_testing
    (def #_"Random" TransactionBroadcast'RANDOM (Random.))

    (defn #_"TransactionBroadcast" TransactionBroadcast'new [#_"PeerGroup" group, #_"Transaction" tx]
        (hash-map
            #_"SettableFuture<Transaction>" :future (SettableFuture/create)
            #_"PeerGroup" :peer-group group
            #_"Transaction" :tx tx
            #_"int" :min-connections (max 1 (PeerGroup''get-min-broadcast-connections group))
            #_"int" :num-waiting-for 0

            ;; Tracks which nodes sent us a reject message about this broadcast, if any.  Useful for debugging.
            #_"Map<Peer, RejectMessage>" :rejects (Collections/synchronizedMap (HashMap. #_"<Peer, RejectMessage>"))

            #_"PreMessageReceivedEventListener" :rejection-listener
                (reify PreMessageReceivedEventListener
                    #_override
                    (#_"Message" PreMessageReceivedEventListener'''on-pre-message-received [#_"PreMessageReceivedEventListener" self, #_"Peer" peer, #_"Message" m]
                        (when (ยง instance? RejectMessage m)
                            (let [#_"RejectMessage" reject (cast' RejectMessage m)]
                                (when (= (Transaction''get-hash (:tx (ยง this))) (:reject-hash reject))
                                    (ยง ass (ยง this) (update (ยง this) :rejects assoc peer reject))
                                    (let [#_"int" size (count (:rejects (ยง this)))
                                          #_"long" threshold (Math/round (/ (:num-waiting-for (ยง this)) 2.0))]
                                        (when (< threshold size)
                                            (log/warn (str "Threshold for considering broadcast rejected has been reached (" size "/" threshold ")"))
                                            (.setException (:future (ยง this)), (RejectedTransactionException'new (:tx (ยง this)), reject))
                                            (ยง ass (ยง this) (update (ยง this) :peer-group PeerGroup''remove-pre-message-received-event-listener self))
                                        )
                                    )
                                )
                            )
                        )
                        m
                    )
                )

            #_"int" :num-seem-peers 0
            #_"boolean" :mined false

            #_"ProgressCallback" :callback nil
            #_"Executor" :progress-callback-executor nil
        )
    )

    #_method
    (defn- #_"TransactionBroadcast" TransactionBroadcast''enough-available-peers [#_"TransactionBroadcast" this]
        ;; We now have enough connected peers to send the transaction.
        ;; This can be called immediately if we already have enough.  Otherwise it'll be called from a peer thread.

        ;; We will send the tx simultaneously to half the connected peers and wait to hear back from at least half
        ;; of the other half, i.e. with 4 peers connected we will send the tx to 2 randomly chosen peers, and then
        ;; wait for it to show up on one of the other two.  This will be taken as sign of network acceptance.  As can
        ;; be seen, 4 peers is probably too little - it doesn't taken many broken peers for tx propagation to have
        ;; a big effect.
        (let [#_"List<Peer>" peers (ร :connected-peers (:peer-group this))] ;; snapshots
            ;; Prepare to send the transaction by adding a listener that'll be called when confidence changes.
            ;; Only bother with this if we might actually hear back:
            (when (< 1 (:min-connections this))
                (ยง ass (Transaction''get-confidence (:tx this)) (TransactionConfidence''add-event-listener (Transaction''get-confidence (:tx this)), (ยง async! (ConfidenceChange'new))))
            )
            ;; Bitcoin Core sends an inv in this case and then lets the peer request the tx data.  We just
            ;; blast out the TX here for a couple of reasons.  Firstly it's simpler: in the case where we have
            ;; just a single connection we don't have to wait for getdata to be received and handled before
            ;; completing the future in the code immediately below.  Secondly, it's faster.  The reason the
            ;; Bitcoin Core sends an inv is privacy - it means you can't tell if the peer originated the
            ;; transaction or not.  However, we are not a fully validating node and this is advertised in
            ;; our version message, as SPV nodes cannot relay it doesn't give away any additional information
            ;; to skip the inv here - we wouldn't send invs anyway.
            (let [#_"int" n (count peers) #_"int" m (max 1 (int (Math/round (Math/ceil (/ n 2.0)))))
                  this (assoc this :num-waiting-for (int (Math/ceil (/ (- n m) 2.0))))
                  _ (Collections/shuffle peers, TransactionBroadcast'RANDOM)
                  peers (subvec peers 0 m)]

                (log/info (str "broadcastTransaction: We have " n " peers, adding " (Transaction''get-hash (:tx this)) " to the memory pool"))
                (log/info (apply str "Sending to " m " peers, will wait for " (:num-waiting-for this) ", sending to: " (interpose "," peers)))
                (doseq [#_"Peer" peer peers]
                    (try
                        (ยง ass peer (Peer''send-message peer, (:tx this), Transaction''to-wire))
                        ;; We don't record the peer as having seen the tx in the memory pool because we want
                        ;; to track only how many peers announced to us.
                        (catch Exception e
                            (log/error e, (str "Caught exception sending to " peer))
                        )
                    )
                )
                ;; If we've been limited to talk to only one peer, we can't wait to hear back because the
                ;; remote peer won't tell us about transactions we just announced to it for obvious reasons.
                ;; So we just have to assume we're done, at that point.  This happens when we're not given
                ;; any peer discovery source and the user just calls connectTo() once.
                (when (= (:min-connections this) 1)
                    (ยง ass this (update this :peer-group PeerGroup''remove-pre-message-received-event-listener (:rejection-listener this)))
                    (.set (:future this), (:tx this))
                )
                this
            )
        )
    )

    #_method
    (defn #_"ListenableFuture<Transaction>" TransactionBroadcast''broadcast [#_"TransactionBroadcast" this]
        (ยง ass this (update this :peer-group PeerGroup''add-pre-message-received-event-listener (:rejection-listener this)))
        (log/info (str "Waiting for " (:min-connections this) " peers required for broadcast, we have " (count (:connected-peers (:peer-group this))) " ..."))
        (.addListener (PeerGroup''wait-for-peers (:peer-group this), (:min-connections this)), #(ยง non-void TransactionBroadcast''enough-available-peers this), Threading'SAME_THREAD)
        (:future this)
    )

    #_method
    (defn- #_"TransactionBroadcast" TransactionBroadcast''invoke-and-record [#_"TransactionBroadcast" this, #_"int" seen, #_"boolean" mined?]
        (let [this
                (sync this
                    (assoc this :num-seem-peers seen, :mined mined?)
                )]
            (TransactionBroadcast''invoke-progress-callback this, seen, mined?)
            this
        )
    )

    #_method
    (defn- #_"void" TransactionBroadcast''invoke-progress-callback [#_"TransactionBroadcast" this, #_"int" seen, #_"boolean" mined?]
        (let [[#_"ProgressCallback" callback #_"Executor" executor]
                (sync this
                    [(:callback this) (:progress-callback-executor this)]
                )]
            (when (some? callback)
                (let [#_"double" progress (min 1.0 (if mined? 1.0 (/ seen (double (:num-waiting-for this)))))]
                    (assert-state (<= 0.0 progress 1.0), progress)
                    (try
                        (when (some? executor) => (ProgressCallback'''on-broadcast-progress callback, progress)
                            (.execute executor, #(ProgressCallback'''on-broadcast-progress callback, progress))
                        )
                        (catch Throwable e
                            (log/error e, "Exception during progress callback")
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Sets the given callback for receiving progress values, which will run on the given executor.  If the executor
     ; is null, then the callback will run on a network thread and may be invoked multiple times in parallel.  You
     ; probably want to provide your UI thread or Threading.USER_THREAD for the second parameter.  If the broadcast
     ; has already started, then the callback will be invoked immediately with the current progress.
     ;;
    #_method
    (defn #_"TransactionBroadcast" TransactionBroadcast''set-progress-callback [#_"TransactionBroadcast" this, #_"ProgressCallback" callback, #_"Executor" executor]
        (let [[this #_"int" seen #_"boolean" mined? #_"boolean" invoke?]
                (sync this
                    (let [this (assoc this :callback callback, :progress-callback-executor executor)]
                        [this (:num-seem-peers this) (:mined this) (pos? (:num-waiting-for this))]
                    )
                )]
            (when invoke?
                (TransactionBroadcast''invoke-progress-callback this, seen, mined?)
            )
            this
        )
    )
)

;; TODO: Modify the getDepthInBlocks method to require the chain height to be specified, in preparation for ceasing to touch every tx on every block.

;;;
 ; Information about where the transaction was first seen (network, sent direct from peer, created by ourselves).
 ; Useful for risk analyzing pending transactions.  Probably not that useful after a tx is included in the chain,
 ; unless re-org double spends start happening frequently.
 ;;
(def ConfidenceSource'enum-set
    (hash-set
        ;;; We don't know where the transaction came from. ;;
        :ConfidenceSource'UNKNOWN
        ;;; We got this transaction from a network peer. ;;
        :ConfidenceSource'NETWORK
        ;;; This transaction was created by our own wallet, so we know it's not a double spend. ;;
        :ConfidenceSource'SELF
    )
)

;;;
 ; An enum that describes why a transaction confidence listener is being invoked (i.e. the class of change).
 ;;
(def ConfidenceChangeReason'enum-set
    (hash-set
        ;;;
         ; Occurs when the type returned by {@link TransactionConfidence#getConfidenceType()} has changed.
         ; For example, if a PENDING transaction changes to BUILDING or DEAD, then this reason will be given.
         ; It's a high level summary.
         ;;
        :ConfidenceChangeReason'TYPE
        ;;;
         ; Occurs when a transaction that is in the best known block chain gets buried by another block.  If you're
         ; waiting for a certain number of confirmations, this is the reason to watch out for.
         ;;
        :ConfidenceChangeReason'DEPTH
        ;;;
         ; Occurs when a pending transaction (not in the chain) was announced by another connected peers.  By
         ; watching the number of peers that announced a transaction go up, you can see whether it's being
         ; accepted by the network or not.  If all your peers announce, it's a pretty good bet the transaction
         ; is considered relayable and has thus reached the miners.
         ;;
        :ConfidenceChangeReason'SEEN_PEERS
    )
)

;;;
 ; Describes the state of the transaction in general terms.  Properties can be read to learn specifics.
 ;;
(def ConfidenceType'enum-set
    (hash-set
        ;;;
         ; If a transaction hasn't been broadcast yet, or there's no record of it, its confidence is UNKNOWN.
         ;;
        :ConfidenceType'UNKNOWN
        ;;;
         ; If BUILDING, then the transaction is included in the best chain and your confidence in it is increasing.
         ;;
        :ConfidenceType'BUILDING
        ;;;
         ; If PENDING, then the transaction is unconfirmed and should be included shortly, as long as it is being
         ; announced and is considered valid by the network.  A pending transaction will be announced if the containing
         ; wallet has been attached to a live {@link PeerGroup} using {@link PeerGroup#addWallet(Wallet)}.
         ; You can estimate how likely the transaction is to be included by connecting to a bunch of nodes then measuring
         ; how many announce it, using {@link TransactionConfidence#numBroadcastPeers()}.
         ; Or if you saw it from a trusted peer, you can assume it's valid and will get mined sooner or later as well.
         ;;
        :ConfidenceType'PENDING
        ;;;
         ; If DEAD, then it means the transaction won't confirm unless there is another re-org,
         ; because some other transaction is spending one of its inputs.  Such transactions should be alerted to the user
         ; so they can take action, e.g. suspending shipment of goods if they are a merchant.
         ; It can also mean that a coinbase transaction has been made dead from it being moved onto a side chain.
         ;;
        :ConfidenceType'DEAD
        ;;;
         ; If IN_CONFLICT, then it means there is another transaction (or several other transactions) spending one
         ; (or several) of its inputs but nor this transaction nor the other/s transaction/s are included in the best chain.
         ; The other/s transaction/s should be IN_CONFLICT too.
         ; IN_CONFLICT can be thought as an intermediary state between a. PENDING and BUILDING or b. PENDING and DEAD.
         ; Another common name for this situation is "double spend".
         ;;
        :ConfidenceType'IN_CONFLICT
    )
)

;;;
 ; A TransactionConfidence object tracks data you can use to make a confidence decision about a transaction.
 ; It also contains some pre-canned rules for common scenarios: if you aren't really sure what level of confidence
 ; you need, these should prove useful.  You can get a confidence object using {@link Transaction#getConfidence()}.
 ; They cannot be constructed directly.
 ;
 ; Confidence in a transaction can come in multiple ways:
 ;
 ; <ul>
 ; <li>Because you created it yourself and only you have the necessary keys.</li>
 ; <li>Receiving it from a fully validating peer you know is trustworthy, for instance, because it's run by yourself.</li>
 ; <li>Receiving it from a peer on the network you randomly chose.  If your network connection is not being
 ;     intercepted, you have a pretty good chance of connecting to a node that is following the rules.</li>
 ; <li>Receiving it from multiple peers on the network.  If your network connection is not being intercepted,
 ;     hearing about a transaction from multiple peers indicates the network has accepted the transaction and
 ;     thus miners likely have too (miners have the final say in whether a transaction becomes valid or not).</li>
 ; <li>Seeing the transaction appear appear in a block on the main chain.  Your confidence increases as the transaction
 ;     becomes further buried under work.  Work can be measured either in blocks (roughly, units of time), or
 ;     amount of work done.</li>
 ; </ul>
 ;
 ; Alternatively, you may know that the transaction is "dead", that is, one or more of its inputs have
 ; been double spent and will never confirm unless there is another re-org.
 ;
 ; TransactionConfidence is updated via the {@link TransactionConfidence#incrementDepthInBlocks()}
 ; method to ensure the block depth is up to date.
 ; To make a copy that won't be changed, use {@link TransactionConfidence#duplicate()}.
 ;;
(class-ns TransactionConfidence
    (defn #_"TransactionConfidence" TransactionConfidence'new [#_"Sha256Hash" hash]
        (hash-map
            ;;;
             ; The Transaction that this confidence object is associated with.
             ;;
            #_"Sha256Hash" :transaction-hash hash
            ;;;
             ; The peers that have announced the transaction to us.  Network nodes don't have stable identities,
             ; so we use IP address as an approximation.  It's obviously vulnerable to being gamed if we allow
             ; arbitrary people to connect to us, so only peers we explicitly connected to should go here.
             ;;
            #_"{PeerAddress}" :broadcast-by (hash-set)
            ;;;
             ; The time the transaction was last announced to us.
             ;;
            #_"long" :last-broadcasted-at nil

            ;; Lazily created listeners array.
            #_"[TransactionConfidenceListener]" :confidence-listeners (vector)

            ;;;
             ; The depth of the transaction on the best chain in blocks.  An unconfirmed block has depth 0.
             ;;
            ;;;
             ; Depth in the chain is an approximation of how much time has elapsed since the transaction has been confirmed.
             ; On average there is supposed to be a new block every 10 minutes, but the actual rate may vary.  Bitcoin Core
             ; considers a transaction impractical to reverse after 6 blocks, but as of EOY 2011 network
             ; security is high enough that often only one block is considered enough even for high value transactions.
             ; For low value transactions like songs, or other cheap items, no blocks at all may be necessary.
             ;
             ; If the transaction appears in the top block, the depth is one.  If it's anything else (pending, dead, unknown)
             ; the depth is zero.
             ;;
            ;;;
             ; Having one block confirmation is a depth of one.
             ;;
            #_"int" :depth-in-blocks 0

            ;;;
             ; A general statement of the level of confidence you can have in this transaction.
             ;;
            #_"ConfidenceType" :confidence-type :ConfidenceType'UNKNOWN
            #_"int" :appeared-at-chain-height -1
            ;; The transaction that double spent this one, if any.
            #_"Transaction" :overriding-transaction nil

            ;;;
             ; The source of a transaction tries to identify where it came from originally.  For instance, did we download it
             ; from the peer to peer network, or make it ourselves, or receive it via Bluetooth, or import it from another app,
             ; and so on.  This information is useful for {@link CoinSelector} implementations to risk analyze
             ; transactions and decide when to spend them.
             ;;
            #_"ConfidenceSource" :confidence-source :ConfidenceSource'UNKNOWN
        )
    )

    ;; This is used to ensure that confidence objects which aren't referenced from anywhere but which have an event
    ;; listener set on them don't become eligible for garbage collection.  Otherwise the TxConfidenceTable, which only
    ;; has weak references to these objects, would not be enough to keep the event listeners working as transactions
    ;; propagate around the network - it cannot know directly if the API user is interested in the object, so it uses
    ;; heap reachability as a proxy for interest.
    ;;
    ;; We add ourselves to this set when a listener is added and remove ourselves when the listener list is empty.
    (def- #_"{TransactionConfidence}'" TransactionConfidence'PINNED_CONFIDENCE_OBJECTS (atom (hash-set)))

    ;;;
     ; Adds an event listener that will be run when this confidence object is updated.  The listener will be locked
     ; and is likely to be invoked on a peer thread.
     ;
     ; Note that this is NOT called when every block arrives.  Instead it is called when the transaction
     ; transitions between confidence states, i.e. from not being seen in the chain to being seen (not necessarily in
     ; the best chain).  If you want to know when the transaction gets buried under another block, consider using
     ; a future from {@link #getDepthFuture(int)}.
     ;;
    #_method
    (defn #_"TransactionConfidence" TransactionConfidence''add-event-listener [#_"TransactionConfidence" this, #_"TransactionConfidenceListener" listener]
        (let [#_"TransactionConfidenceListener" l listener]
            (when-not (.contains (:confidence-listeners this), l) => this
                (swap! TransactionConfidence'PINNED_CONFIDENCE_OBJECTS conj this)
                (append* this :confidence-listeners l)
            )
        )
    )

    #_method
    (defn #_"TransactionConfidence" TransactionConfidence''remove-event-listener [#_"TransactionConfidence" this, #_"TransactionConfidenceListener" listener]
        (let [this (remove* this :confidence-listeners = listener)]
            (when (empty? (:confidence-listeners this))
                (swap! TransactionConfidence'PINNED_CONFIDENCE_OBJECTS disj this)
            )
            this
        )
    )

    ;;;
     ; Returns the chain height at which the transaction appeared if confidence type is BUILDING.
     ;
     ; @throws IllegalStateException if the confidence type is not BUILDING.
     ;;
    #_method
    (defn #_"int" TransactionConfidence''get-appeared-at-chain-height [#_"TransactionConfidence" this]
        (sync this
            (when-not (= (:confidence-type this) :ConfidenceType'BUILDING)
                (throw (IllegalStateException. (str "Confidence type is " (:confidence-type this) ", not BUILDING")))
            )
            (:appeared-at-chain-height this)
        )
    )

    ;;;
     ; The chain height at which the transaction appeared, if it has been seen in the best chain.
     ; Automatically sets the current type to {@link ConfidenceType#BUILDING} and depth to one.
     ;;
    #_method
    (defn #_"TransactionConfidence" TransactionConfidence''set-appeared-at-chain-height [#_"TransactionConfidence" this, #_"int" height]
        (when (neg? height)
            (throw (IllegalArgumentException. "appearedAtChainHeight out of range"))
        )
        (sync this
            (let [this (assoc this :appeared-at-chain-height height, :depth-in-blocks 1)]
                (TransactionConfidence''set-confidence-type this, :ConfidenceType'BUILDING)
            )
        )
    )

    ;;;
     ; Called by other objects in the system, like a {@link Wallet}, when new information about the confidence
     ; of a transaction becomes available.
     ;;
    #_method
    (defn #_"TransactionConfidence" TransactionConfidence''set-confidence-type [#_"TransactionConfidence" this, #_"ConfidenceType" type]
        (sync this
            (when-not (= type (:confidence-type this)) => this
                (let [this (assoc this :confidence-type type)
                      this
                        (when-not (= type :ConfidenceType'DEAD) => this
                            (assoc this :overriding-transaction nil)
                        )]
                    (when (any = type :ConfidenceType'PENDING :ConfidenceType'IN_CONFLICT) => this
                        (assoc this :depth-in-blocks 0, :appeared-at-chain-height -1)
                    )
                )
            )
        )
    )

    ;;;
     ; Called by a {@link Peer} when a transaction is pending and announced by a peer.  The more peers announce
     ; the transaction, the more peers have validated it (assuming your internet connection is not being intercepted).
     ; If confidence is currently unknown, sets it to {@link ConfidenceType#PENDING}.  Does not run listeners.
     ;
     ; @param address IP address of the peer, used as a proxy for identity.
     ; @return true if marked, false if this address was already seen.
     ;;
    #_method
    (defn #_"[TransactionConfidence boolean]" TransactionConfidence''mark-broadcast-by [#_"TransactionConfidence" this, #_"PeerAddress" address]
        (let [this (assoc this :last-broadcasted-at (Time'now))]
            (when-not (TransactionConfidence''was-broadcast-by this, address) => [this false] ;; Duplicate.
                (let [this (update this :broadcast-by conj address)]
                    (sync this
                        (when (= (:confidence-type this) :ConfidenceType'UNKNOWN) => [this true]
                            [(assoc this :confidence-type :ConfidenceType'PENDING) true]
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Returns true if the given address has been seen via markBroadcastBy().
     ;;
    #_method
    (defn #_"boolean" TransactionConfidence''was-broadcast-by [#_"TransactionConfidence" this, #_"PeerAddress" address]
        (contains? (:broadcast-by this), address)
    )

    ;;;
     ; Erases the set of broadcast/seen peers.  This cannot be called whilst the confidence is PENDING.  It is useful
     ; for saving memory and wallet space once a tx is buried so deep it doesn't seem likely to go pending again.
     ;;
    #_method
    (defn #_"TransactionConfidence" TransactionConfidence''clear-broadcast-by [#_"TransactionConfidence" this]
        (assert-state (not= (:confidence-type this) :ConfidenceType'PENDING))

        (-> this (update :broadcast-by empty) (assoc :last-broadcasted-at nil))
    )

    ;;;
     ; If this transaction has been overridden by a double spend (is dead), this call returns the overriding transaction.
     ; Note that this call <b>can return null</b> if you have migrated an old wallet, as pre-Jan 2012 wallets did not
     ; store this information.
     ;
     ; @return the transaction that double spent this one.
     ; @throws IllegalStateException if confidence type is not DEAD.
     ;;
    #_method
    (defn #_"Transaction" TransactionConfidence''get-overriding-transaction [#_"TransactionConfidence" this]
        (sync this
            (when-not (= (:confidence-type this) :ConfidenceType'DEAD)
                (throw (IllegalStateException. (str "Confidence type is " (:confidence-type this) ", not DEAD")))
            )
            (:overriding-transaction this)
        )
    )

    ;;;
     ; Called when the transaction becomes newly dead, that is, we learn that one of its inputs has already been spent
     ; in such a way that the double-spending transaction takes precedence over this one.  It will not become valid now
     ; unless there is a re-org.  Automatically sets the confidence type to DEAD.  The overriding transaction may not
     ; directly double spend this one, but could also have double spent a dependency of this tx.
     ;;
    #_method
    (defn #_"TransactionConfidence" TransactionConfidence''set-overriding-transaction [#_"TransactionConfidence" this, #_"Transaction" tx]
        (sync this
            (let [this (assoc this :overriding-transaction tx)]
                (TransactionConfidence''set-confidence-type this, :ConfidenceType'DEAD)
            )
        )
    )

    ;;;
     ; Call this after adjusting the confidence, for cases where listeners should be notified.  This has to be done
     ; explicitly rather than being done automatically because sometimes complex changes to transaction states can
     ; result in a series of confidence changes that are not really useful to see separately.  By invoking listeners
     ; explicitly, more precise control is available.  Note that this will run the listeners on the user code thread.
     ;;
    #_method
    (defn #_"void" TransactionConfidence''queue-listeners [#_"TransactionConfidence" this, #_"ConfidenceChangeReason" reason]
        (doseq [#_"TransactionConfidenceListener" l (:confidence-listeners this)]
            (ยง async?
                (TransactionConfidenceListener'''on-confidence-changed l, this, reason)
            )
        )
        nil
    )

    ;;;
     ; Returns a future that completes when the transaction has been confirmed by "depth" blocks.  For instance setting
     ; depth to one will wait until it appears in a block on the best chain, and zero will wait until it has been seen
     ; on the network.
     ;;
    #_method
    (defn #_"ListenableFuture<TransactionConfidence>" TransactionConfidence''get-depth-future [#_"TransactionConfidence" this, #_"int" depth]
        (sync this
            (let [#_"SettableFuture<TransactionConfidence>" future (SettableFuture/create)]
                (when (<= depth (:depth-in-blocks this))
                    (.set future, this)
                )
                (ยง ass this (TransactionConfidence''add-event-listener this,
                    (ยง async?
                        (reify TransactionConfidenceListener
                            #_override
                            (#_"void" TransactionConfidenceListener'''on-confidence-changed [#_"TransactionConfidenceListener" self, #_"TransactionConfidence" confidence, #_"ConfidenceChangeReason" reason]
                                (when (<= depth (:depth-in-blocks this))
                                    (ยง ass this (TransactionConfidence''remove-event-listener this, self))
                                    (.set future, confidence)
                                )
                                nil
                            )
                        )
                    )
                ))
                future
            )
        )
    )

    #_method
    (defn #_"String" TransactionConfidence''to-string [#_"TransactionConfidence" this]
        (sync this
            (let [#_"StringBuilder" sb (StringBuilder. (<< 1 7))
                  #_"int" peers (count (:broadcast-by this))]
                (when (< 0 peers)
                    (.. sb (append "Seen by ") (append peers) (append (if (< 1 peers) " peers" " peer")))
                    (when-let [#_"long" time (:last-broadcasted-at this)]
                        (.. sb (append " (most recently: ") (append (Time'format time)) (append ")"))
                    )
                    (.. sb (append ". "))
                )
                (condp = (:confidence-type this)
                    :ConfidenceType'UNKNOWN     (.. sb (append "Unknown confidence level."))
                    :ConfidenceType'DEAD        (.. sb (append "Dead: overridden by double spend and will not confirm."))
                    :ConfidenceType'PENDING     (.. sb (append "Pending/unconfirmed."))
                    :ConfidenceType'IN_CONFLICT (.. sb (append "In conflict."))
                    :ConfidenceType'BUILDING    (.. sb (append "Appeared in best chain at height ") (append (TransactionConfidence''get-appeared-at-chain-height this)) (append ", depth ") (append (:depth-in-blocks this)) (append "."))
                )
                (when-not (= (:confidence-source this) :ConfidenceSource'UNKNOWN)
                    (.. sb (append " Source: ") (append (:confidence-source this)))
                )
                (.toString sb)
            )
        )
    )
)

(def ConnectionResult'enum-set
    (hash-set
        :ConnectionResult'NO_SUCH_TX
        :ConnectionResult'ALREADY_SPENT
        :ConnectionResult'SUCCESS
    )
)

(def ConnectionMode'enum-set
    (hash-set
        :ConnectionMode'DISCONNECT_ON_CONFLICT
        :ConnectionMode'ABORT_ON_CONFLICT
    )
)

;;;
 ; A transfer of coins from one address to another creates a transaction in which the outputs
 ; can be claimed by the recipient in the input of another transaction.  You can imagine a
 ; transaction as being a module which is wired up to others, the inputs of one have to be wired
 ; to the outputs of another.  The exceptions are coinbase transactions, which create new coins.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns TransactionInput (ยง extends Message)
    ;;; Magic sequence number that indicates there is no sequence number. ;;
    (def #_"long" TransactionInput'NO_SEQUENCE 0xffffffff)
    ;; Magic outpoint index that indicates the input is in fact unconnected.
    (def- #_"long" TransactionInput'UNCONNECTED 0xffffffff)

    (defn- #_"TransactionInput" TransactionInput'new [#_"Ledger" ledger, #_"Transaction" parent, #_"long" sequence, #_"TransactionOutPoint" outpoint, #_"byte[]" script, #_"Coin" value]
        (merge (Message'new ledger)
            (hash-map
                #_"Transaction" :parent-tx parent
                ;;;
                 ; Allows for altering transactions after they were broadcast.  Values below NO_SEQUENCE-1 mean it can be altered.
                 ;
                 ; Sequence numbers allow participants in a multi-party transaction signing protocol to create new versions of the
                 ; transaction independently of each other.  Newer versions of a transaction can replace an existing version that's
                 ; in node's memory pools if the existing version is time locked.  See the Contracts page on the Bitcoin wiki for
                 ; examples of how you can use this feature to build contract protocols.
                 ;;
                #_"long" :sequence sequence
                ;;;
                 ; The previous output transaction reference, as an OutPoint structure.  This contains the
                 ; data needed to connect to the output of the transaction we're gathering coins from.
                 ;;
                #_"TransactionOutPoint" :outpoint outpoint
                ;;;
                 ; The "script bytes" might not actually be a script.  In coinbase transactions where new coins are minted there
                 ; is no input transaction, so instead the scriptBytes contains some extra stuff (like a rollover nonce) that we
                 ; don't care about much.  The bytes are turned into a Script object (cached below) on demand via a getter.
                 ;;
                #_"byte[]" :script-bytes script
                ;;;
                 ; The Script object obtained from parsing scriptBytes.  Only filled in on demand and if the transaction is not coinbase.
                 ;;
                #_"WeakReference<Script>" :script-sig nil
                ;;;
                 ; Value of the output connected to the input, if known.  This field does not participate in equals()/hashCode().
                 ;;
                #_"Coin" :coin-value value
            )
        )
    )

    (defn #_"TransactionInput" TransactionInput'for-outpoint [#_"Ledger" ledger, #_"Transaction" parent, #_"TransactionOutPoint" outpoint, #_"byte[]" script]
        (TransactionInput'new ledger, parent, TransactionInput'NO_SEQUENCE, outpoint, script, nil)
    )

    ;;;
     ; Creates an input that connects to nothing - used only in creation of coinbase transactions.
     ;;
    (defn #_"TransactionInput" TransactionInput'new-unconnected [#_"Ledger" ledger, #_"Transaction" parent, #_"byte[]" script]
        (TransactionInput'for-outpoint ledger, parent, (TransactionOutPoint'for-transaction ledger, nil, TransactionInput'UNCONNECTED), script)
    )

    ;;;
     ; Creates an UNSIGNED input that links to the given output.
     ;;
    (defn #_"TransactionInput" TransactionInput'for-output [#_"Ledger" ledger, #_"Transaction" parent, #_"TransactionOutput" output]
        (let [#_"TransactionOutPoint" outpoint
                (if (some? (:parent-tx output))
                    (TransactionOutPoint'for-transaction ledger, (:parent-tx output), (TransactionOutput''get-index output))
                    (TransactionOutPoint'for-output ledger, output)
                )]
            (TransactionInput'new ledger, parent, TransactionInput'NO_SEQUENCE, outpoint, (byte-array 0), (:coin-value output))
        )
    )

    ;;;
     ; Deserializes an input message.  This is usually part of a transaction message.
     ;;
    #_throws #_[ "ProtocolException" ]
    (defn #_"TransactionInput" TransactionInput'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload, #_"Transaction" parent]
        (let [#_"TransactionOutPoint" outpoint (TransactionOutPoint'from-wire ledger, payload)
              #_"byte[]" script (Wire'read-byte-array payload)
              #_"long" sequence (Wire'read-uint32 payload)]

            (TransactionInput'new ledger, parent, sequence, outpoint, script, nil)
        )
    )

    #_method
    (defn TransactionInput''to-wire
        (#_"String" [] nil)
        (#_"void" [#_"TransactionInput" this, #_"ByteArrayOutputStream" baos]
            (TransactionOutPoint''to-wire (:outpoint this), baos)
            (Wire'write-byte-array (:script-bytes this), baos)
            (Wire'write-uint32 (:sequence this), baos)
            nil
        )
    )

    ;;;
     ; Coinbase transactions have special inputs with hashes of zero.  If this is such an input, returns true.
     ;;
    #_method
    (defn #_"boolean" TransactionInput''is-coin-base [#_"TransactionInput" this]
        (and (= (:from-tx-hash (:outpoint this)) Sha256Hash'ZERO_HASH) (= (& (:index (:outpoint this)) 0xffffffff) 0xffffffff)) ;; -1 but all is serialized to the wire as unsigned int.
    )

    ;;;
     ; Returns the script that is fed to the referenced output (scriptPubKey) script in order to satisfy it: usually
     ; contains signatures and maybe keys, but can contain arbitrary data if the output script accepts it.
     ;;
    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"Script" TransactionInput''get-script-sig [#_"TransactionInput" this]
        ;; Transactions that generate new coins don't actually have a script.
        ;; Instead this parameter is overloaded to be something totally different.
        (let [#_"Script" script (when (some? (:script-sig this)) (.get (:script-sig this)))]
            (or script
                (let [script (Script'parse (:script-bytes this))]
                    (ยง ass this (assoc this :script-sig (WeakReference. script)))
                    script
                )
            )
        )
    )

    ;;; Set the given program as the scriptSig that is supposed to satisfy the connected output script. ;;
    #_method
    (defn #_"TransactionInput" TransactionInput''set-script-sig [#_"TransactionInput" this, #_"Script" script]
        (let [this (assoc this :script-sig (WeakReference. (ensure some? script)))]
            ;; TODO: This should all be cleaned up so we have a consistent internal representation.
            (TransactionInput''set-script-bytes this, (Script''to-bytes script))
        )
    )

    ;;;
     ; Convenience method that returns the from address of this input by parsing the scriptSig.  The concept of
     ; a "from address" is not well defined in Bitcoin and you should not assume that senders of a transaction can
     ; actually receive coins on the same address they used to sign (e.g. this is not true for shared wallets).
     ;;
    #_deprecated
    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"Address" TransactionInput''get-from-address [#_"TransactionInput" this]
        (when (TransactionInput''is-coin-base this)
            (throw+ (ScriptException'new :ScriptError'UNKNOWN_ERROR, "This is a coinbase transaction which generates new coins.  It does not have a from address."))
        )

        (Script''get-from-address (TransactionInput''get-script-sig this), (:ledger this))
    )

    ;;;
     ; Clear input scripts, e.g. in preparation for signing.
     ;;
    #_method
    (defn #_"TransactionInput" TransactionInput''clear-script-bytes [#_"TransactionInput" this]
        (TransactionInput''set-script-bytes this, (byte-array 0))
    )

    #_method
    (defn #_"TransactionInput" TransactionInput''set-script-bytes [#_"TransactionInput" this, #_"byte[]" bytes]
        (assoc this :script-sig nil, :script-bytes bytes)
    )

    ;; TODO: Clean all this up once TransactionOutPoint disappears.

    ;;;
     ; Locates the referenced output from the given pool of transactions.
     ;
     ; @return the TransactionOutput (or null) if the transaction's map doesn't contain the referenced tx.
     ;;
    #_method
    (defn #_"TransactionOutput" TransactionInput''get-connected-output-2 [#_"TransactionInput" this, #_"Map<Sha256Hash, Transaction>" transactions]
        (let [#_"Transaction" tx (get transactions (:from-tx-hash (:outpoint this)))]
            (when (some? tx) (nth (:outputs tx) (:index (:outpoint this))))
        )
    )

    ;;;
     ; Connects this input to the relevant output of the referenced transaction if it's in the given map.
     ; Connecting means updating the internal pointers and spent flags.  If the mode is to ABORT_ON_CONFLICT,
     ; then the spent output won't be changed, but the outpoint.fromTx pointer will still be updated.
     ;
     ; @param transactions Map of txhash->transaction.
     ; @param mode Whether to abort if there's a pre-existing connection or not.
     ; @return NO_SUCH_TX if the prevtx wasn't found, ALREADY_SPENT if there was a conflict, SUCCESS if not.
     ;;
    #_method
    (defn #_"ConnectionResult" TransactionInput''connect-3m [#_"TransactionInput" this, #_"Map<Sha256Hash, Transaction>" transactions, #_"ConnectionMode" mode]
        (let [#_"Transaction" tx (get transactions (:from-tx-hash (:outpoint this)))]
            (if (some? tx) (TransactionInput''connect-3t this, tx, mode) :ConnectionResult'NO_SUCH_TX)
        )
    )

    ;;;
     ; Internal use only: connects this TransactionInput to the given output (updates pointers and spent flags).
     ;;
    #_method
    (defn- #_"TransactionInput" TransactionInput''connect-output [#_"TransactionInput" this, #_"TransactionOutput" output]
        (let [this (assoc-in this [:outpoint :from-tx] (:parent-tx output))]
            (ยง ass output (TransactionOutput''mark-as-spent output, this))
            (assoc this :coin-value (:coin-value output))
        )
    )

    ;;;
     ; Connects this input to the relevant output of the referenced transaction.
     ; Connecting means updating the internal pointers and spent flags.  If the mode is to ABORT_ON_CONFLICT,
     ; then the spent output won't be changed, but the outpoint.fromTx pointer will still be updated.
     ;
     ; @param transaction The transaction to try.
     ; @param mode Whether to abort if there's a pre-existing connection or not.
     ; @return NO_SUCH_TX if transaction is not the prevtx, ALREADY_SPENT if there was a conflict, SUCCESS if not.
     ;;
    #_method
    (defn #_"ConnectionResult" TransactionInput''connect-3t [#_"TransactionInput" this, #_"Transaction" tx, #_"ConnectionMode" mode]
        (when (= (Transaction''get-hash tx) (:from-tx-hash (:outpoint this))) => :ConnectionResult'NO_SUCH_TX
            (assert-state (< -1 (:index (:outpoint this)) (count (:outputs tx))), "Corrupt transaction")

            (let [#_"TransactionOutput" output (nth (:outputs tx) (:index (:outpoint this)))
                  #_"ConnectionResult" result
                    (when-not (TransactionOutput''is-available-for-spending output)
                        (cond (.equals (:parent-tx this), (-> this :outpoint :from-tx))
                            (do
                                ;; Already connected.
                                :ConnectionResult'SUCCESS
                            )
                            (= mode :ConnectionMode'DISCONNECT_ON_CONFLICT)
                            (do
                                (ยง ass output (TransactionOutput''mark-as-unspent output))
                                nil
                            )
                            (= mode :ConnectionMode'ABORT_ON_CONFLICT)
                            (do
                                (ยง ass this (assoc-in this [:outpoint :from-tx] (:parent-tx output)))
                                :ConnectionResult'ALREADY_SPENT
                            )
                        )
                    )]
                (when (nil? result) => result
                    (ยง ass this (TransactionInput''connect-output this, output))
                    :ConnectionResult'SUCCESS
                )
            )
        )
    )

    ;;;
     ; If this input is connected, check the output is connected back to this input and release it if so, making
     ; it spendable once again.
     ;
     ; @return true if the disconnection took place, false if it was not connected.
     ;;
    #_method
    (defn #_"boolean" TransactionInput''disconnect [#_"TransactionInput" this]
        (let [#_"TransactionOutput" output
                (cond
                    (some? (-> this :outpoint :from-tx))
                        ;; The outpoint is connected using a "standard" wallet, disconnect it.
                        (let [output (nth (-> this :outpoint :from-tx :outputs) (:index (:outpoint this)))]
                            (ยง ass this (assoc-in this [:outpoint :from-tx] nil))
                            output
                        )
                    (some? (-> this :outpoint :connected-output))
                        ;; The outpoint is connected using a UTXO based wallet, disconnect it.
                        (let [output (-> this :outpoint :connected-output)]
                            (ยง ass this (assoc-in this [:outpoint :connected-output] nil))
                            output
                        )
                )]

            (when (and (some? output) (= (:spent-by output) this)) => false
                ;; The outpoint was connected to an output, disconnect the output.
                (ยง ass output (TransactionOutput''mark-as-unspent output))
                true
            )
        )
    )

    ;;;
     ; @return true if this transaction's sequence number is set (i.e. it may be a part of a time-locked transaction).
     ;;
    #_method
    (defn #_"boolean" TransactionInput''has-sequence [#_"TransactionInput" this]
        (not= (:sequence this) TransactionInput'NO_SEQUENCE)
    )

    ;;;
     ; Returns whether this input will cause a transaction to opt into the
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki">full replace-by-fee</a> semantics.
     ;;
    #_method
    (defn #_"boolean" TransactionInput''is-opt-in-full-rbf [#_"TransactionInput" this]
        (< (:sequence this) (dec TransactionInput'NO_SEQUENCE))
    )

    ;;;
     ; For a connected transaction, runs the script against the connected pubkey and verifies they are correct.
     ;
     ; @throws ScriptException if the script did not verify.
     ; @throws VerificationException if the outpoint doesn't match the given output.
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn #_"void" TransactionInput''verify-1 [#_"TransactionInput" this]
        (let [#_"Transaction" tx (-> this :outpoint :from-tx)]
            (ensure some? tx, "Not connected")

            (let [#_"TransactionOutput" output (nth (:outputs tx) (:index (:outpoint this)))]
                (TransactionInput''verify-2 this, output)
            )
        )
        nil
    )

    ;;;
     ; Verifies that this input can spend the given output.  Note that this input must be a part of a transaction.
     ; Also note that the consistency of the outpoint will be checked, even if this input has not been connected.
     ;
     ; @param output The output that this input is supposed to spend.
     ; @throws ScriptException if the script doesn't verify.
     ; @throws VerificationException if the outpoint doesn't match the given output.
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn #_"void" TransactionInput''verify-2 [#_"TransactionInput" this, #_"TransactionOutput" output]
        (when (some? (:parent-tx output))
            (when-not (= (:from-tx-hash (:outpoint this)) (Transaction''get-hash (:parent-tx output)))
                (throw+ (VerificationException'new "This input does not refer to the tx containing the output."))
            )
            (when-not (= (:index (:outpoint this)) (TransactionOutput''get-index output))
                (throw+ (VerificationException'new "This input refers to a different output on the given tx."))
            )
        )
        (let [#_"Script" __pubKey (TransactionOutput''parse-script-pub-key output)
              #_"int" index (.indexOf (:inputs (:parent-tx this)), this)]
            (Script''correctly-spends (TransactionInput''get-script-sig this), (:parent-tx this), index, __pubKey, Script'ALL_VERIFY_FLAGS)
        )
        nil
    )

    ;;;
     ; Returns the connected output, assuming the input was connected with
     ; {@link TransactionInput#connect(TransactionOutput)} or variants at some point.
     ; If it wasn't connected, then this method returns null.
     ;;
    #_method
    (defn #_"TransactionOutput" TransactionInput''get-connected-output [#_"TransactionInput" this]
        (TransactionOutPoint''get-connected-output (:outpoint this))
    )

    ;;;
     ; Returns the connected transaction, assuming the input was connected with
     ; {@link TransactionInput#connect(TransactionOutput)} or variants at some point.
     ; If it wasn't connected, then this method returns null.
     ;;
    #_method
    (defn #_"Transaction" TransactionInput''get-connected-transaction [#_"TransactionInput" this]
        (-> this :outpoint :from-tx)
    )

    ;;;
     ; Returns either RuleViolation.NONE if the input is standard, or which rule makes it non-standard if so.
     ; The "IsStandard" rules control whether the default Bitcoin Core client blocks relay of a tx / refuses to mine it,
     ; however, non-standard transactions can still be included in blocks and will be accepted as valid if so.
     ;
     ; This method simply calls <tt>RiskAnalysis.isInputStandard(this)</tt>.
     ;;
    #_method
    (defn #_"RuleViolation" TransactionInput''is-standard [#_"TransactionInput" this]
        (RiskAnalysis'is-input-standard this)
    )

    #_foreign
    #_override
    (defn #_"boolean" Object'''equals [#_"TransactionInput" this, #_"Object" o]
        (cond
            (= this o) true
            (or (nil? o) (not= (.getClass this) (.getClass o))) false
            :else (let [#_"TransactionInput" that (cast' TransactionInput o)]
                (and (= (:sequence this) (:sequence that)) (= (:parent-tx this) (:parent-tx that)) (.equals (:outpoint this), (:outpoint that)) (Arrays/equals (:script-bytes this), (:script-bytes that)))
            )
        )
    )

    #_foreign
    #_override
    (defn #_"int" Object'''hashCode [#_"TransactionInput" this]
        (Objects/hash (object-array [ (:sequence this), (:outpoint this), (Arrays/hashCode (:script-bytes this)) ]))
    )

    #_method
    (defn #_"String" TransactionInput''to-string [#_"TransactionInput" this]
        (let [#_"StringBuilder" sb (.. (StringBuilder. (<< 1 7)) (append "TxIn"))]
            (if (TransactionInput''is-coin-base this)
                (.. sb (append ": COINBASE"))
                (do
                    (.. sb (append " for [") (append (:outpoint this)) (append "]: ") (append (TransactionInput''get-script-sig this)))
                    (let [#_"String" flags
                            (apply str (interpose ", " (filter some?
                                [(when (TransactionInput''has-sequence this) (str "sequence: " (Long/toHexString (:sequence this)))),
                                 (when (TransactionInput''is-opt-in-full-rbf this) "opts into full RBF")]))
                            )]
                        (when (seq flags)
                            (.. sb (append " (") (append flags) (append ")"))
                        )
                    )
                )
            )
            (.toString sb)
        )
    )
)

;;;
 ; This message is a reference or pointer to an output of a different transaction.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns TransactionOutPoint (ยง extends Message)
    (defn- #_"TransactionOutPoint" TransactionOutPoint'new [#_"Ledger" ledger, #_"Sha256Hash" hash, #_"long" index]
        (merge (Message'new ledger)
            (hash-map
                ;;; Hash of the transaction to which we refer. ;;
                #_"Sha256Hash" :from-tx-hash hash
                ;;; Which output of that transaction we are talking about. ;;
                #_"long" :index index

                ;; This is not part of bitcoin serialization.  It points to the connected transaction.
                #_"Transaction" :from-tx nil

                ;; The connected output.
                #_"TransactionOutput" :connected-output nil
            )
        )
    )

    (defn #_"TransactionOutPoint" TransactionOutPoint'for-hash [#_"Ledger" ledger, #_"Sha256Hash" hash, #_"long" index]
        (TransactionOutPoint'new ledger, hash, index)
    )

    (defn #_"TransactionOutPoint" TransactionOutPoint'for-transaction [#_"Ledger" ledger, #_"Transaction" tx, #_"long" index]
        ;; ZERO_HASH happens when constructing the genesis block.
        (let [#_"Sha256Hash" hash (if (some? tx) (Transaction''get-hash tx) Sha256Hash'ZERO_HASH)]
            (-> (TransactionOutPoint'for-hash ledger, hash, index) (assoc :from-tx tx))
        )
    )

    (defn #_"TransactionOutPoint" TransactionOutPoint'for-output [#_"Ledger" ledger, #_"TransactionOutput" output]
        (let [#_"Sha256Hash" hash (TransactionOutput''get-parent-transaction-hash output) #_"long" index (TransactionOutput''get-index output)]
            (-> (TransactionOutPoint'for-hash ledger, hash, index) (assoc :connected-output output))
        )
    )

    ;;;
     ; Deserializes the message.  This is usually part of a transaction message.
     ;;
    #_throws #_[ "ProtocolException" ]
    (defn #_"TransactionOutPoint" TransactionOutPoint'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload]
        (TransactionOutPoint'new ledger, (Wire'read-hash payload), (Wire'read-uint32 payload))
    )

    #_method
    (defn TransactionOutPoint''to-wire
        (#_"String" [] nil)
        (#_"void" [#_"TransactionOutPoint" this, #_"ByteArrayOutputStream" baos]
            (.write baos, (Wire'reverse-bytes (:hash-bytes (:from-tx-hash this))))
            (Wire'write-uint32 (:index this), baos)
            nil
        )
    )

    ;;;
     ; An outpoint is a part of a transaction input that points to the output of another transaction.  If we have both
     ; sides in memory, and they have been linked together, this returns a pointer to the connected output, or null
     ; if there is no such connection.
     ;;
    #_method
    (defn #_"TransactionOutput" TransactionOutPoint''get-connected-output [#_"TransactionOutPoint" this]
        (if (some? (:from-tx this)) (nth (:outputs (:from-tx this)) (:index this)) (:connected-output this))
    )

    ;;;
     ; Returns the pubkey script from the connected output.
     ;
     ; @throws NullPointerException if there is no connected output.
     ;;
    #_method
    (defn #_"byte[]" TransactionOutPoint''get-connected-pub-key-script [#_"TransactionOutPoint" this]
        (let [#_"byte[]" bytes (:script-bytes (ensure some? (TransactionOutPoint''get-connected-output this)))]
            (assert-state (pos? (count bytes)))
            bytes
        )
    )

    ;;;
     ; Returns the ECKey identified in the connected output, for either pay-to-address scripts or pay-to-key scripts.
     ; For P2SH scripts you can use {@link #getConnectedRedeemData(KeyBag)} and then get the key from RedeemData.
     ; If the script form cannot be understood, throws ScriptException.
     ;
     ; @return an ECKey or null if the connected key cannot be found in the wallet.
     ;;
    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"ECKey" TransactionOutPoint''get-connected-key [#_"TransactionOutPoint" this, #_"KeyBag" bag]
        (let [#_"TransactionOutput" output (ensure some? (TransactionOutPoint''get-connected-output this), "Input is not connected, so cannot retrieve key")
              #_"Script" script (TransactionOutput''parse-script-pub-key output)]
            (cond
                (Script''is-sent-to-address script)     (KeyBag'''find-key-from-pub-hash bag, (Script''get-pub-key-hash script))
                (Script''is-sent-to-raw-pub-key script) (KeyBag'''find-key-from-pub-key bag, (Script''get-pub-key script))
                :else
                    (throw+ (ScriptException'new :ScriptError'UNKNOWN_ERROR, (str "Could not understand form of connected output script: " script)))
            )
        )
    )

    ;;;
     ; Returns the RedeemData identified in the connected output, for either pay-to-address scripts, pay-to-key or P2SH scripts.
     ; If the script forms cannot be understood, throws ScriptException.
     ;
     ; @return a RedeemData or null if the connected data cannot be found in the wallet.
     ;;
    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"RedeemData" TransactionOutPoint''get-connected-redeem-data [#_"TransactionOutPoint" this, #_"KeyBag" bag]
        (let [#_"TransactionOutput" output (ensure some? (TransactionOutPoint''get-connected-output this), "Input is not connected, so cannot retrieve key")
              #_"Script" script (TransactionOutput''parse-script-pub-key output)]
            (cond
                (Script''is-sent-to-address script)     (RedeemData'of script, (KeyBag'''find-key-from-pub-hash bag, (Script''get-pub-key-hash script)))
                (Script''is-sent-to-raw-pub-key script) (RedeemData'of script, (KeyBag'''find-key-from-pub-key bag, (Script''get-pub-key script)))
                (Script''is-pay-to-script-hash script)  (KeyBag'''find-redeem-data-from-script-hash bag, (Script''get-pub-key-hash script))
                :else
                    (throw+ (ScriptException'new :ScriptError'UNKNOWN_ERROR, (str "Could not understand form of connected output script: " script)))
            )
        )
    )

    #_foreign
    #_override
    (defn #_"boolean" Object'''equals [#_"TransactionOutPoint" this, #_"Object" o]
        (cond
            (= this o) true
            (or (nil? o) (not= (.getClass this) (.getClass o))) false
            :else (let [#_"TransactionOutPoint" that (cast' TransactionOutPoint o)]
                (and (= (:index this) (:index that)) (= (:from-tx-hash this) (:from-tx-hash that)))
            )
        )
    )

    #_foreign
    #_override
    (defn #_"int" Object'''hashCode [#_"TransactionOutPoint" this]
        (Objects/hash (object-array [ (:index this), (:from-tx-hash this) ]))
    )
)

;;;
 ; A TransactionOutput message contains a scriptPubKey that controls who is able to spend its value.
 ; It is a sub-part of the Transaction message.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns TransactionOutput (ยง extends Message)
    (defn- #_"TransactionOutput" TransactionOutput'new [#_"Ledger" ledger, #_"Transaction" parent, #_"Coin" value, #_"byte[]" script]
        (merge (Message'new ledger)
            (hash-map
                #_"Transaction" :parent-tx parent
                ;;;
                 ; The value of this output.
                 ; The amount of currency that the destination address receives.
                 ;;
                #_"Coin" :coin-value value

                ;; A transaction output has a script used for authenticating that the redeemer is allowed to spend this output.
                #_"byte[]" :script-bytes script

                ;; These fields are not Bitcoin serialized.  They are used for tracking purposes in our wallet only.
                ;; If set to true, this output is counted towards our balance.  If false and spentBy is null, the tx
                ;; output was owned by us and was sent to somebody else.  If false and spentBy is set, this output
                ;; was owned by us and used in one of our own transactions (e.g. because it is a change output).
                #_"boolean" :available-for-spending true
                #_"TransactionInput" :spent-by nil
            )
        )
    )

    (defn #_"TransactionOutput" TransactionOutput'for-script [#_"Ledger" ledger, #_"Transaction" parent, #_"Coin" value, #_"byte[]" script]
        ;; Negative values obviously make no sense, except for -1 which is used as a sentinel value when calculating
        ;; SIGHASH_SINGLE signatures, so unfortunately we have to allow that here.
        (assert-argument (or (not (Coin''negative? value)) (= value Coin'NEGATIVE_SATOSHI)), "Negative values not allowed")
        (assert-argument (not (and (Ledger''has-max-money ledger) (Coin''greater-than? value, (Ledger''get-max-money ledger)))), "Values larger than MAX_MONEY not allowed")

        (TransactionOutput'new ledger, parent, value, script)
    )

    ;;;
     ; Creates an output that sends 'value' to the given address (public key hash).  The amount should be
     ; created with something like {@link Coin#valueOf(int, int)}.  Typically you would use
     ; {@link Transaction#addOutput(Coin, Address)} instead of creating a TransactionOutput directly.
     ;;
    (defn #_"TransactionOutput" TransactionOutput'for-address [#_"Ledger" ledger, #_"Transaction" parent, #_"Coin" value, #_"Address" to]
        (TransactionOutput'for-script ledger, parent, value, (Script''to-bytes (Script'create-output-script-1a to)))
    )

    ;;;
     ; Creates an output that sends 'value' to the given public key using a simple CHECKSIG script (no addresses).
     ; The amount should be created with something like {@link Coin#valueOf(int, int)}.  Typically you would use
     ; {@link Transaction#addOutput(Coin, ECKey)} instead of creating an output directly.
     ;;
    (defn #_"TransactionOutput" TransactionOutput'for-pubkey [#_"Ledger" ledger, #_"Transaction" parent, #_"Coin" value, #_"ECKey" to]
        (TransactionOutput'for-script ledger, parent, value, (Script''to-bytes (Script'create-output-script-1e to)))
    )

    ;;;
     ; Deserializes a transaction output message.  This is usually part of a transaction message.
     ;;
    #_throws #_[ "ProtocolException" ]
    (defn #_"TransactionOutput" TransactionOutput'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload, #_"Transaction" parent]
        (let [#_"long" value (Wire'read-int64 payload)
              #_"byte[]" script (Wire'read-byte-array payload)]

            (TransactionOutput'new ledger, parent, (Coin'new value), script)
        )
    )

    #_method
    (defn TransactionOutput''to-wire
        (#_"String" [] nil)
        (#_"void" [#_"TransactionOutput" this, #_"ByteArrayOutputStream" baos]
            (ensure some? (:script-bytes this))

            (Wire'write-int64 (-> this :coin-value :value), baos)
            (Wire'write-byte-array (:script-bytes this), baos)
            nil
        )
    )

    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"Script" TransactionOutput''parse-script-pub-key [#_"TransactionOutput" this]
        (Script'parse (:script-bytes this))
    )

    ;;;
     ; If the output script pays to an address as in <a href="https://bitcoin.org/en/developer-guide#term-p2pkh">P2PKH</a>,
     ; return the address of the receiver, i.e. a base58 encoded hash of the public key in the script.
     ;
     ; @param ledger Needed to specify an address.
     ; @return null, if the output script is not the form <i>OP_DUP OP_HASH160 <PubkeyHash> OP_EQUALVERIFY OP_CHECKSIG</i>, i.e. not P2PKH.
     ; @return an address made out of the public key hash.
     ;;
    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"Address" TransactionOutput''get-address-from-p2pkh-script [#_"TransactionOutput" this, #_"Ledger" ledger]
        (let [#_"Script" script (TransactionOutput''parse-script-pub-key this)]
            (when (Script''is-sent-to-address script)
                (Script''get-to-address-2 script, ledger)
            )
        )
    )

    ;;;
     ; If the output script pays to a redeem script, return the address of the redeem script as described by,
     ; i.e. a base58 encoding of [one-byte version][20-byte hash][4-byte checksum], where the 20-byte hash refers to
     ; the redeem script.
     ;
     ; P2SH is described by <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP 16</a> and
     ; <a href="https://bitcoin.org/en/developer-guide#p2sh-scripts">documented in the Bitcoin Developer Guide</a>.
     ;
     ; @param ledger Needed to specify an address.
     ; @return null if the output script does not pay to a script hash.
     ; @return an address that belongs to the redeem script.
     ;;
    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"Address" TransactionOutput''get-address-from-p2sh [#_"TransactionOutput" this, #_"Ledger" ledger]
        (let [#_"Script" script (TransactionOutput''parse-script-pub-key this)]
            (when (Script''is-pay-to-script-hash script)
                (Script''get-to-address-2 script, ledger)
            )
        )
    )

    ;;;
     ; Sets the value of this output.
     ;;
    #_method
    (defn #_"TransactionOutput" TransactionOutput''set-value [#_"TransactionOutput" this, #_"Coin" value]
        (ensure some? value)

        (assoc this :coin-value value)
    )

    ;;;
     ; Gets the index of this output in the parent transaction, or throws if this output is free standing.
     ; Iterates over the parents list to discover this.
     ;;
    #_method
    (defn #_"int" TransactionOutput''get-index [#_"TransactionOutput" this]
        (let [#_"List<TransactionOutput>" outputs (:outputs (:parent-tx this))]
            (loop-when [#_"int" i 0] (< i (count outputs)) => (throw (IllegalStateException. "Output linked to wrong parent transaction?"))
                (if (= (nth outputs i) this)
                    i
                    (recur (inc i))
                )
            )
        )
    )

    ;;;
     ; Will this transaction be relayable and mined by default miners?
     ;;
    #_method
    (defn #_"boolean" TransactionOutput''is-dust [#_"TransactionOutput" this]
        ;; Transactions that are OP_RETURN can't be dust regardless of their value.
        (if (Script''is-op-return (TransactionOutput''parse-script-pub-key this))
            false
            (Coin''less-than? (:coin-value this), (TransactionOutput''get-min-non-dust-value-1 this))
        )
    )

    ;;;
     ; Gets the minimum value for a txout of this size to be considered non-dust by Bitcoin Core (and thus relayed).
     ; See CTxOut::IsDust() in Bitcoin Core.  The assumption is that any output that would consume more than a third
     ; of its value in fees is not something the Bitcoin system wants to deal with right now, so we call them "dust outputs"
     ; and they're made non standard.  The choice of one third is somewhat arbitrary and may change in future.
     ;
     ; You probably should use {@link TransactionOutput#getMinNonDustValue()} which uses a safe fee-per-kb by default.
     ;
     ; @param feePerKb The fee required per kilobyte.  Note that this is the same as Bitcoin Core's -minrelaytxfee * 3.
     ;;
    #_method
    (defn #_"Coin" TransactionOutput''get-min-non-dust-value-2 [#_"TransactionOutput" this, #_"Coin" __feePerKb]
        ;; A typical output is 33 bytes (pubkey hash + opcodes) and requires an input of 148 bytes to spend so we add
        ;; that together to find out the total amount of data used to transfer this amount of value.  Note that this
        ;; formula is wrong for anything that's not a pay-to-address output, unfortunately, we must follow Bitcoin Core's
        ;; wrongness in order to ensure we're considered standard.  A better formula would either estimate the
        ;; size of data needed to satisfy all different script types, or just hard code 33 below.
        (let [#_"long" size (+ (count (Message''to-bytes this, TransactionOutput''to-wire)) 148)]
            (Coin''divide (Coin''multiply __feePerKb, size), 1000)
        )
    )

    ;;;
     ; Returns the minimum value for this output to be considered "not dust", i.e. the transaction will be relayable
     ; and mined by default miners.  For normal pay to address outputs, this is 2730 satoshis, the same as
     ; {@link Transaction#MIN_NONDUST_OUTPUT}.
     ;;
    #_method
    (defn #_"Coin" TransactionOutput''get-min-non-dust-value-1 [#_"TransactionOutput" this]
        (TransactionOutput''get-min-non-dust-value-2 this, (Coin''multiply Transaction'REFERENCE_DEFAULT_MIN_TX_FEE, 3))
    )

    ;;;
     ; Sets this objects availableForSpending flag to false and the spentBy pointer to the given input.
     ; If the input is null, it means this output was signed over to somebody else rather than one of our own keys.
     ;
     ; @throws IllegalStateException if the transaction was already marked as spent.
     ;;
    #_method
    (defn #_"TransactionOutput" TransactionOutput''mark-as-spent [#_"TransactionOutput" this, #_"TransactionInput" input]
        (assert-state (:available-for-spending this))

        (assoc this :available-for-spending false, :spent-by input)
    )

    ;;;
     ; Resets the spent pointer / availableForSpending flag to null.
     ;;
    #_method
    (defn #_"TransactionOutput" TransactionOutput''mark-as-unspent [#_"TransactionOutput" this]
        (assoc this :available-for-spending true, :spent-by nil)
    )

    ;;;
     ; Returns whether {@link TransactionOutput#markAsSpent(TransactionInput)} has been called on this class.
     ; A {@link Wallet} will mark a transaction output as spent once it sees a transaction input that is connected to it.
     ; Note that this flag can be false when an output has in fact been spent according to the rest of the network if
     ; the spending transaction wasn't downloaded yet, and it can be marked as spent when in reality the rest of the
     ; network believes it to be unspent if the signature or script connecting to it was not actually valid.
     ;;
    #_method
    (defn #_"boolean" TransactionOutput''is-available-for-spending [#_"TransactionOutput" this]
        (:available-for-spending this)
    )

    ;;;
     ; Returns true if this output is to a key, or an address we have the keys for, in the wallet.
     ;;
    #_method
    (defn #_"boolean" TransactionOutput''is-mine [#_"TransactionOutput" this, #_"Wallet" wallet]
        (try+
            (let [#_"Script" script (TransactionOutput''parse-script-pub-key this)]
                (cond
                    (Script''is-sent-to-raw-pub-key script) (Wallet''is-pub-key-mine wallet, (Script''get-pub-key script))
                    (Script''is-pay-to-script-hash script)  (Wallet''is-pay-to-script-hash-mine wallet, (Script''get-pub-key-hash script))
                    :else                                   (Wallet''is-pub-key-hash-mine wallet, (Script''get-pub-key-hash script))
                )
            )
            (ยง catch ScriptException e
                ;; Just means we didn't understand the output of this transaction: ignore it.
                (log/debug e, (str "Could not parse tx " (or (TransactionOutput''get-parent-transaction-hash this) "(no parent)") " output script"))
                false
            )
        )
    )

    ;;;
     ; Returns the transaction hash that owns this output.
     ;;
    #_method
    (defn #_"Sha256Hash" TransactionOutput''get-parent-transaction-hash [#_"TransactionOutput" this]
        (when (some? (:parent-tx this)) (Transaction''get-hash (:parent-tx this)))
    )

    ;;;
     ; Returns the depth in blocks of the parent tx.
     ;
     ; If the transaction appears in the top block, the depth is one.
     ; If it's anything else (pending, dead, unknown), then -1.
     ;
     ; @return the tx depth or -1.
     ;;
    #_method
    (defn #_"int" TransactionOutput''get-parent-transaction-depth-in-blocks [#_"TransactionOutput" this]
        (let-when [#_"Transaction" tx (:parent-tx this)] (some? tx) => -1
            (let [#_"TransactionConfidence" confidence (Transaction''get-confidence tx)]
                (when (= (:confidence-type confidence) :ConfidenceType'BUILDING) => -1
                    (:depth-in-blocks confidence)
                )
            )
        )
    )

    ;;;
     ; Returns a new {@link TransactionOutPoint}, which is essentially a structure pointing to this output.
     ; Requires that this output is not detached.
     ;;
    #_method
    (defn #_"TransactionOutPoint" TransactionOutput''get-outpoint-for [#_"TransactionOutput" this]
        (TransactionOutPoint'for-transaction (:ledger this), (:parent-tx this), (TransactionOutput''get-index this))
    )

    #_foreign
    #_override
    (defn #_"boolean" Object'''equals [#_"TransactionOutput" this, #_"Object" o]
        (cond
            (= this o) true
            (or (nil? o) (not= (.getClass this) (.getClass o))) false
            :else (let [#_"TransactionOutput" that (cast' TransactionOutput o)]
                (and (= (:coin-value this) (:coin-value that)) (or (nil? (:parent-tx this)) (and (= (:parent-tx this) (:parent-tx that)) (= (TransactionOutput''get-index this) (TransactionOutput''get-index that)))) (Arrays/equals (:script-bytes this), (:script-bytes that)))
            )
        )
    )

    #_foreign
    #_override
    (defn #_"int" Object'''hashCode [#_"TransactionOutput" this]
        (Objects/hash (object-array [ (:coin-value this), (:parent-tx this), (Arrays/hashCode (:script-bytes this)) ]))
    )

    #_method
    (defn #_"String" TransactionOutput''to-string [#_"TransactionOutput" this]
        (let [#_"Script" script (TransactionOutput''parse-script-pub-key this)
              #_"StringBuilder" sb (.. (StringBuilder. (<< 1 7)) (append "TxOut of "))]
            (.. sb (append (Coin''to-friendly-string (:coin-value this))))
            (cond
                (or (Script''is-sent-to-address script) (Script''is-pay-to-script-hash script))
                    (.. sb (append " to ") (append (Script''get-to-address-2 script, (:ledger this))))
                (Script''is-sent-to-raw-pub-key script)
                    (.. sb (append " to pubkey ") (append (Base16'encode (Script''get-pub-key script))))
                (Script''is-sent-to-multi-sig script)
                    (.. sb (append " to multisig"))
                :else
                    (.. sb (append " (unknown type)"))
            )
            (.. sb (append " script:") (append script))
            (.toString sb)
        )
    )
)

;;;
 ; TransactionOutputChanges represents a delta to the set of unspent outputs.  It used as a return value for
 ; {@link BlockChain#connectTransactions(int, Block)}.  It contains the full list of transaction outputs created
 ; and spent in a block.  It DOES contain outputs created that were spent later in the block, as those are needed for
 ; BIP30 (no duplicate txid creation if the previous one was not fully spent prior to this block) verification.
 ;;
(class-ns TransactionOutputChanges
    (defn #_"TransactionOutputChanges" TransactionOutputChanges'new [#_"List<UTXO>" created, #_"List<UTXO>" spent]
        (hash-map
            #_"List<UTXO>" :tx-outs-created created
            #_"List<UTXO>" :tx-outs-spent spent
        )
    )
)

(class-ns WeakConfidenceReference (ยง extends WeakReference #_"<TransactionConfidence>")
    (defn #_"WeakConfidenceReference" WeakConfidenceReference'new [#_"TransactionConfidence" confidence, #_"ReferenceQueue<TransactionConfidence>" queue]
        (merge (ยง super WeakReference'new confidence, queue)
            (hash-map
                #_"Sha256Hash" :weak-hash (:transaction-hash confidence)
            )
        )
    )
)

;;;
 ; Tracks transactions that are being announced across the network.  Typically one is created for you by a
 ; {@link PeerGroup} and then given to each Peer to update.  The current purpose is to let Peers update the confidence
 ; (number of peers broadcasting).  It helps address an attack scenario in which a malicious remote peer (or several)
 ; feeds you invalid transactions, e.g. ones that spend coins which don't exist.  If you don't see most of the peers
 ; announce the transaction within a reasonable time, it may be that the TX is not valid.  Alternatively, an attacker
 ; may control your entire internet connection: in this scenario counting broadcasting peers does not help you.
 ;
 ; It is <b>not</b> at this time directly equivalent to the Bitcoin Core memory pool, which tracks
 ; all transactions not currently included in the best chain - it's simply a cache.
 ;;
(class-ns TxConfidenceTable
    ;;; The max size of a table created with the no-args constructor. ;;
    (def #_"int" TxConfidenceTable'MAX_SIZE 1000)

    ;;;
     ; Creates a table that will track at most the given number of transactions (allowing you to bound memory usage).
     ;
     ; @param size Max number of transactions to track.  The table will fill up to this size, then stop growing.
     ;;
    (defn #_"TxConfidenceTable" TxConfidenceTable'new
        ([] (TxConfidenceTable'new TxConfidenceTable'MAX_SIZE))
        ([#_"int" size]
            (hash-map
                #_"Object" :confidence-lock (Object.)

                #_"LinkedHashMap<Sha256Hash, WeakConfidenceReference>" :table
                    (proxy [LinkedHashMap #_"<Sha256Hash, WeakConfidenceReference>"] []
                        #_foreign
                        #_override
                        (#_"boolean" removeEldestEntry [#_"LinkedHashMap" #_this, #_"Map.Entry<Sha256Hash, WeakConfidenceReference>" _eldest]
                            ;; An arbitrary choice to stop the memory used by tracked transactions getting too huge in the event
                            ;; of some kind of DoS attack.
                            (< size (.size this))
                        )
                    )

                ;; This ReferenceQueue gets entries added to it when they are only weakly reachable, i.e. the TxConfidenceTable is
                ;; the only thing that is tracking the confidence data anymore.  We check it from time to time and delete table entries
                ;; corresponding to expired transactions.  In this way memory usage of the system is in line with however many
                ;; transactions you actually care to track the confidence of.  We can still end up with lots of hashes being stored
                ;; if our peers flood us with invs but the MAX_SIZE param caps this.
                #_"ReferenceQueue<TransactionConfidence>" :reference-queue (ReferenceQueue.)
            )
        )
    )

    (def #_"TxConfidenceTable" TxConfidenceTable'INSTANCE (TxConfidenceTable'new))

    ;;;
     ; If any transactions have expired due to being only weakly reachable through us, go ahead and delete their
     ; table entries - it means we downloaded the transaction and sent it to various event listeners, none of
     ; which bothered to keep a reference.  Typically, this is because the transaction does not involve any keys
     ; that are relevant to any of our wallets.
     ;;
    #_method
    (defn- #_"void" TxConfidenceTable''clean-table [#_"TxConfidenceTable" this]
        (sync (:confidence-lock this)
            (loop [] ;; Find which transaction got deleted by the GC,
                (when-let [#_"Reference<TransactionConfidence>" ref (.poll (:reference-queue this))]
                    ;; and remove the associated map entry, so the other bits of memory can also be reclaimed.
                    (ยง ass this (update this :table .remove (:weak-hash (cast' WeakConfidenceReference ref))))
                    (recur)
                )
            )
        )
        nil
    )

    ;;;
     ; Returns the number of peers that have seen the given hash recently.
     ;;
    #_method
    (defn #_"int" TxConfidenceTable''num-broadcast-peers [#_"TxConfidenceTable" this, #_"Sha256Hash" hash]
        (sync (:confidence-lock this)
            (TxConfidenceTable''clean-table this)
            (let-when [#_"WeakConfidenceReference" ref (get (:table this) hash)] (some? ref) => 0 ;; No such TX known.
                (let-when [#_"TransactionConfidence" confidence (.get ref)] (nil? confidence) => (count (:broadcast-by confidence))
                    ;; Such a TX hash was seen, but nothing seemed to care, so we ended up throwing away the data.
                    (ยง ass this (update this :table .remove hash))
                    0
                )
            )
        )
    )

    ;;;
     ; Called by peers when they see a transaction advertised in an "inv" message.  It passes the data on to the relevant
     ; {@link TransactionConfidence} object, creating it if needed.
     ;
     ; @return the number of peers that have now announced this hash (including the caller).
     ;;
    #_method
    (defn #_"TransactionConfidence" TxConfidenceTable''seen [#_"TxConfidenceTable" this, #_"Sha256Hash" hash, #_"PeerAddress" __byPeer]
        (let [[#_"TransactionConfidence" confidence #_"boolean" fresh?]
                (sync (:confidence-lock this)
                    (TxConfidenceTable''clean-table this)
                    (TransactionConfidence''mark-broadcast-by (TxConfidenceTable''get-or-create this, hash), __byPeer)
                )]
            (when fresh?
                (TransactionConfidence''queue-listeners confidence, :ConfidenceChangeReason'SEEN_PEERS)
            )
            confidence
        )
    )

    ;;;
     ; Returns the {@link TransactionConfidence} for the given hash if we have downloaded it, or null if that tx hash
     ; is unknown to the system at this time.
     ;;
    #_method
    (defn #_"TransactionConfidence" TxConfidenceTable''get-or-create [#_"TxConfidenceTable" this, #_"Sha256Hash" hash]
        (ensure some? hash)

        (sync (:confidence-lock this)
            (let [#_"WeakConfidenceReference" ref (get (:table this) hash)
                  #_"TransactionConfidence" confidence (when (some? ref) (.get ref))]
                (when (nil? confidence) => confidence
                    (let [confidence (TransactionConfidence'new hash)]
                        (ยง ass this (update this :table assoc hash (WeakConfidenceReference'new confidence, (:reference-queue this))))
                        confidence
                    )
                )
            )
        )
    )

    ;;;
     ; Returns the {@link TransactionConfidence} for the given hash if we have downloaded it, or null if that tx hash
     ; is unknown to the system at this time.
     ;;
    #_method
    (defn #_"TransactionConfidence" TxConfidenceTable''get [#_"TxConfidenceTable" this, #_"Sha256Hash" hash]
        (sync (:confidence-lock this)
            (let [#_"WeakConfidenceReference" ref (get (:table this) hash)]
                (when (some? ref) (.get ref))
            )
        )
    )
)

;; TODO: Fix this class: should not talk about addresses, height should be optional/support mempool height etc.

;;;
 ; A UTXO message contains the information necessary to check a spending transaction.
 ; It avoids having to store the entire parentTransaction just to get the hash and index.
 ; Useful when working with free standing outputs.
 ;;
(class-ns UTXO
    ;;;
     ; Creates a stored transaction output.
     ;;
    (defn #_"UTXO" UTXO'new [#_"Sha256Hash" hash, #_"long" index, #_"Coin" value, #_"int" height, #_"boolean" coinbase?, #_"Script" script, #_"String" address]
        (hash-map
            ;;; The hash of the transaction which holds this output. ;;
            #_"Sha256Hash" :utxo-hash hash
            ;;; The index of this output in the transaction which holds it. ;;
            #_"long" :utxo-index index

            ;;; The value which this Transaction output holds. ;;
            #_"Coin" :utxo-value value
            ;;; The height of the block that created this output. ;;
            #_"int" :utxo-height height
            ;;; Whether this was created by a coinbase tx. ;;
            #_"boolean" :coinbase? coinbase?
            ;;; The Script object which you can use to get address, script bytes or script type. ;;
            #_"Script" :script script
            ;;; The address of this output, can be the empty string if none was provided at construction time or was deserialized. ;;
            #_"String" :address address
        )
    )

    #_foreign
    #_override
    (defn #_"boolean" Object'''equals [#_"UTXO" this, #_"Object" o]
        (cond
            (= this o) true
            (or (nil? o) (not= (.getClass this) (.getClass o))) false
            :else (let [#_"UTXO" that (cast' UTXO o)]
                (and (= (:utxo-index this) (:utxo-index that)) (= (:utxo-hash this) (:utxo-hash that)))
            )
        )
    )

    #_foreign
    #_override
    (defn #_"int" Object'''hashCode [#_"UTXO" this]
        (Objects/hash (object-array [ (:utxo-index this), (:utxo-hash this) ]))
    )

    #_method
    (defn #_"String" UTXO''to-string [#_"UTXO" this]
        (str "Stored TxOut of " (Coin''to-friendly-string (:utxo-value this)) " (" (:utxo-hash this) ":" (:utxo-index this) ")")
    )
)

;;;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns UnknownMessage (ยง extends Message)
    #_throws #_[ "ProtocolException" ]
    (defn #_"UnknownMessage" UnknownMessage'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload, #_"String" command]
        (merge (Message'new ledger)
            (hash-map
                #_"String" :command command
                ;; The raw message payload bytes themselves.
                #_"byte[]" :payload (.array payload)
            )
        )
    )

    #_method
    (defn #_"String" UnknownMessage''to-string [#_"UnknownMessage" this]
        (str "Unknown message [" (:command this) "]: " (Base16'encode (:payload this)))
    )
)

;;;
 ; A variable-length encoded unsigned integer using Satoshi's encoding (a.k.a. "CompactSize").
 ;;
(class-ns VarInt
    (defn- #_"VarInt" VarInt'init [#_"long" value, #_"int" size]
        (hash-map
            #_"long" :value value
            ;;;
             ; The original number of bytes used to encode the value if it was deserialized
             ; from a byte array, or the minimum encoded size if it was not.
             ;;
            #_"int" :encoded-size size
        )
    )

    ;;;
     ; Constructs a new VarInt with the given unsigned long value.
     ;
     ; @param value the unsigned long value (beware widening conversion of negatives!)
     ;;
    (defn #_"VarInt" VarInt'new [#_"long" value]
        (VarInt'init value, (VarInt'size-of value))
    )

    ;;;
     ; Constructs a new VarInt with the value parsed from the given bytes.
     ;;
    #_throws #_[ "IndexOutOfBoundsException" ]
    (defn #_"VarInt" VarInt'parse [#_"byte[]" bytes]
        (let [#_"int" i (& 0xff (nth bytes 0))]
            (cond
                (< i 253) (VarInt'new i)
                (= i 253) (VarInt'new (Wire'bget-uint16 bytes, 1))
                (= i 254) (VarInt'new (Wire'bget-uint32 bytes, 1))
                :else     (VarInt'new (Wire'bget-int64 bytes, 1))
            )
        )
    )

    ;;;
     ; Constructs a new VarInt with the value parsed from the given buffer.
     ;;
    #_throws #_[ "BufferUnderflowException" ]
    (defn #_"VarInt" VarInt'from-wire [#_"ByteBuffer" payload]
        (let [#_"int" i (& 0xff (.get payload)) read- #(let [#_"byte[]" bytes (byte-array %)] (.get payload, bytes) bytes)]
            (cond
                (< i 253) (VarInt'new i)
                (= i 253) (VarInt'new (Wire'bget-uint16 (read- 2), 1))
                (= i 254) (VarInt'new (Wire'bget-uint32 (read- 4), 1))
                :else     (VarInt'new (Wire'bget-int64 (read- 8), 1))
            )
        )
    )

    ;;;
     ; Returns the minimum encoded size of the given unsigned long value.
     ;
     ; @param value the unsigned long value (beware widening conversion of negatives!)
     ;;
    (defn #_"int" VarInt'size-of [#_"long" value]
        (cond
            (< value 0)           9 ;; negative is actually a very large unsigned long value
            (< value 253)         1 ;; 1 data byte (8 bits)
            (<= value 0xffff)     3 ;; 1 marker + 2 data bytes (16 bits)
            (<= value 0xffffffff) 5 ;; 1 marker + 4 data bytes (32 bits)
            :else                 9 ;; 1 marker + 8 data bytes (64 bits)
        )
    )

    ;;;
     ; Encodes the value into its minimal representation.
     ;
     ; @return the minimal encoded bytes of the value.
     ;;
    #_method
    (defn #_"byte[]" VarInt''encode [#_"VarInt" this]
        (case (VarInt'size-of (:value this))
            1 (byte-array [ (byte (:value this)) ])
            3 (byte-array [ (byte 253), (byte (:value this)), (byte (>> (:value this) 8)) ])
            5 (let [#_"byte[]" bytes (byte-array 5)]
                    (aset bytes 0 (byte 254))
                    (Wire'bset-uint32 (:value this), bytes, 1)
                    bytes)
              (let [#_"byte[]" bytes (byte-array 9)]
                    (aset bytes 0 (byte 255))
                    (Wire'bset-uint64 (:value this), bytes, 1)
                    bytes)
        )
    )
)

(class-ns VerificationException (ยง extends RuntimeException)
    (defn #_"VerificationException" VerificationException'new [#_"String" message]
        (RuntimeException'new message)
    )
)

;;;
 ; The verack message, sent by a client accepting the version message they received from their peer.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns VersionAck (ยง extends Message)
    (defn #_"VersionAck" VersionAck'new [#_"Ledger" ledger]
        (Message'new ledger)
    )

    #_method
    (defn VersionAck''to-wire
        (#_"String" [] "verack")
        (#_"void" [#_"VersionAck" __, #_"ByteArrayOutputStream" _baos]
            nil
        )
    )
)

;;;
 ; A VersionMessage holds information exchanged during connection setup with another peer.  Most of the fields are
 ; not particularly interesting.  The subVer field, since BIP 14, acts as a User-Agent string would.  You can and should
 ; append to or change the subVer for your own software so other implementations can identify it, and you can look at
 ; the subVer field received from other nodes to see what they are running.
 ;
 ; After creating yourself a VersionMessage, you can pass it to {@link PeerGroup#setVersionMessage(VersionMessage)}
 ; to ensure it will be used for each new connection.
 ;
 ; Instances of this class are not safe for use by multiple threads.
 ;;
(class-ns VersionMessage (ยง extends Message)
    ;;; A services flag that denotes whether the peer has a copy of the block chain or not. ;;
    (def #_"int" VersionMessage'NODE_NETWORK 1)

    (defn- #_"VersionMessage" VersionMessage'init []
        (hash-map
            ;;;
             ; The version number of the protocol spoken.
             ;;
            #_"int" :client-version ProtocolVersion'CURRENT
            ;;;
             ; Flags defining what optional services are supported.
             ;;
            #_"long" :local-services 0
            ;;;
             ; What the other side believes the current time to be, in seconds.
             ;;
            #_"long" :time-seconds (Time'seconds)
            ;;;
             ; How many blocks are in the chain, according to the other side.
             ;;
            #_"long" :best-height 0
            ;;;
             ; Whether or not to relay tx invs before a filter is received.
             ; See <a href="https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki#extensions-to-existing-messages">BIP 37</a>.
             ;;
            #_"boolean" :relay-txes-before-filter true
        )
    )

    (defn #_"VersionMessage" VersionMessage'new [#_"Ledger" ledger, #_"int" height]
        (let [this (merge (Message'new ledger) (VersionMessage'init))]

            (assoc this :best-height height)
        )
    )

    #_throws #_[ "ProtocolException" ]
    (defn #_"VersionMessage" VersionMessage'from-wire [#_"Ledger" ledger, #_"ByteBuffer" payload]
        (let [this (merge (Message'new ledger) (VersionMessage'init))

              this (assoc this :client-version (int (Wire'read-uint32 payload)))
              this (assoc this :local-services (.longValue (Wire'read-uint64 payload)))
              this (assoc this :time-seconds (.longValue (Wire'read-uint64 payload)))
              _ (PeerAddress'from-wire ledger, payload) ;; my address
              _ (PeerAddress'from-wire ledger, payload) ;; their address
              ;; uint64 localHostNonce (random data)
              ;; We don't care about the localhost nonce.  It's used to detect connecting back to yourself in cases where
              ;; there are NATs and proxies in the way.  However we don't listen for inbound connections so it's irrelevant.
              _ (Wire'read-uint64 payload)]
            ;; The rest of the flags may not be sent by old nodes.
            (when (.hasRemaining payload) => this
                (Wire'read-string payload) ;; user agent
                (when (.hasRemaining payload) => this
                    ;; int bestHeight (size of known block chain)
                    (let [this (assoc this :best-height (Wire'read-uint32 payload))]
                        (when (.hasRemaining payload) => this
                            (assoc this :relay-txes-before-filter (not= (Wire'read-byte payload) 0))
                        )
                    )
                )
            )
        )
    )

    #_method
    (defn VersionMessage''to-wire
        (#_"String" [] "version")
        (#_"void" [#_"VersionMessage" this, #_"ByteArrayOutputStream" baos]
            (Wire'write-uint32 (:client-version this), baos)
            (Wire'write-uint32 (:local-services this), baos)
            (Wire'write-uint32 (>> (:local-services this) 32), baos)
            (Wire'write-uint32 (:time-seconds this), baos)
            (Wire'write-uint32 (>> (:time-seconds this) 32), baos)
            ;; Note that Bitcoin Core doesn't do anything with these, and finding out our own external
            ;; IP address is kind of tricky anyway, so we just put nonsense here for now.
            (PeerAddress''to-wire (PeerAddress'loopback (:ledger this)), baos)
            (PeerAddress''to-wire (PeerAddress'loopback (:ledger this)), baos)
            ;; Next up is the "local host nonce", this is to detect the case of connecting back to yourself.
            ;; We don't care about this as we won't be accepting inbound connections.
            (Wire'write-uint32 0, baos)
            (Wire'write-uint32 0, baos)
            ;; Now comes subVer.
            (.write baos, (VarInt''encode (VarInt'new 0)))
            ;; Size of known block chain.
            (Wire'write-uint32 (:best-height this), baos)
            (.write baos, (if (:relay-txes-before-filter this) 1 0))
            nil
        )
    )

    ;;;
     ; Returns true if the version message indicates the sender has a full copy of the block chain,
     ; or if it's running in client mode (only has the headers).
     ;;
    #_method
    (defn #_"boolean" VersionMessage''has-block-chain [#_"VersionMessage" this]
        (= (& (:local-services this) VersionMessage'NODE_NETWORK) VersionMessage'NODE_NETWORK)
    )

    ;;;
     ; Returns true if the clientVersion field is >= Pong.MIN_PROTOCOL_VERSION.  If it is then ping() is usable.
     ;;
    #_method
    (defn #_"boolean" VersionMessage''is-ping-pong-supported [#_"VersionMessage" this]
        (<= ProtocolVersion'PONG (:client-version this))
    )

    ;;;
     ; Returns true if the clientVersion field is >= FilteredBlock.MIN_PROTOCOL_VERSION.  If it is then Bloom filtering
     ; is available and the memory pool of the remote peer will be queried when the downloadData property is true.
     ;;
    #_method
    (defn #_"boolean" VersionMessage''is-bloom-filtering-supported [#_"VersionMessage" this]
        (<= ProtocolVersion'BLOOM_FILTER (:client-version this))
    )

    #_method
    (defn #_"String" VersionMessage''to-string [#_"VersionMessage" this]
        (let [#_"StringBuilder" sb (StringBuilder. (<< 1 7))]
            (.. sb (append "\n"))
            (.. sb (append "client version: ") (append (:client-version this)) (append "\n"))
            (.. sb (append "local services: ") (append (:local-services this)) (append "\n"))
            (.. sb (append "time:           ") (append (:time-seconds this)) (append "\n"))
            (.. sb (append "best height:    ") (append (:best-height this)) (append "\n"))
            (.. sb (append "delay tx relay: ") (append (not (:relay-txes-before-filter this))) (append "\n"))
            (.toString sb)
        )
    )
)

;;;
 ; This exception is thrown by the Address class when you try and decode an address with a version code that isn't
 ; used by that network.  You shouldn't allow the user to proceed in this case as they are trying to send money across
 ; different chains, an operation that is guaranteed to destroy the money.
 ;;
(class-ns WrongNetworkException (ยง extends AddressFormatException)
    (defn #_"WrongNetworkException" WrongNetworkException'new [#_"int" code, #_"int*" versions]
        (merge (AddressFormatException'new (str "Version code of address did not match acceptable versions for network: " code " not in " versions))
            (hash-map
                ;;; The version code that was provided in the address. ;;
                #_"int" :version-code code
                ;;; The list of acceptable versions that were expected given the addresses network parameters. ;;
                #_"int*" :acceptable-versions versions
            )
        )
    )
)

(ยง ns bitclojn.crypto
    (:refer-clojure :exclude [ensure subvec sync vec vector vector-of when when-not])
    (:use [bitclojn slang])
)

;;;
 ; This is just a wrapper for the i (child number) as per BIP 32 with a boolean getter for the most significant bit
 ; and a getter for the actual 0-based child number.  A {@link java.util.List} of these forms a <i>path</i> through a
 ; {@link DeterministicHierarchy}.  This class is immutable.
 ;;
(class-ns ChildNumber
    ;;;
     ; The bit that's set in the child number to indicate whether this key is "hardened".  Given a hardened key, it is
     ; not possible to derive a child public key if you know only the hardened public key.  With a non-hardened key this
     ; is possible, so you can derive trees of public keys given only a public parent, but the downside is that it's
     ; possible to leak private keys if you disclose a parent public key and a child private key (elliptic curve maths
     ; allows you to work upwards).
     ;;
    (def #_"int" ChildNumber'HARDENED_BIT 0x80000000)

    (defn #_"ChildNumber" ChildNumber'new [#_"int" i]
        (hash-map
            ;;; Integer i as per BIP 32 spec, including the MSB denoting derivation type (0 = public, 1 = private). ;;
            #_"int" :i i
        )
    )

    (defn #_"ChildNumber" ChildNumber'compose [#_"int" i, #_"boolean" hardened?]
        (when (ChildNumber'has-hardened-bit i)
            (throw (IllegalArgumentException. (str "Most significant bit is reserved and shouldn't be set: " i)))
        )
        (ChildNumber'new (if hardened? (| i ChildNumber'HARDENED_BIT) i))
    )

    ;;; Returns the uint32 encoded form of the path element, including the most significant bit. ;;
    #_method
    (defn #_"int" ChildNumber''i [#_"ChildNumber" this]
        (:i this)
    )

    #_method
    (defn #_"boolean" ChildNumber''is-hardened [#_"ChildNumber" this]
        (ChildNumber'has-hardened-bit (:i this))
    )

    (defn- #_"boolean" ChildNumber'has-hardened-bit [#_"int" i]
        (not= (& i ChildNumber'HARDENED_BIT) 0)
    )

    ;;; Returns the child number without the hardening bit set (i.e. index in that part of the tree). ;;
    #_method
    (defn #_"int" ChildNumber''num [#_"ChildNumber" this]
        (& (:i this) (bit-not ChildNumber'HARDENED_BIT))
    )

    (def #_"ChildNumber" ChildNumber'ZERO (ChildNumber'new 0))
    (def #_"ChildNumber" ChildNumber'ONE (ChildNumber'new 1))
    (def #_"ChildNumber" ChildNumber'ZERO_HARDENED (ChildNumber'compose 0, true))

    (defn #_"int" ChildNumber'compare [#_"ChildNumber" this, #_"ChildNumber" that]
        ;; Note that in this implementation compareTo() is not consistent with equals().
        (compare (ChildNumber''num this) (ChildNumber''num that))
    )

    #_method
    (defn #_"String" ChildNumber''to-string [#_"ChildNumber" this]
        (str (ChildNumber''num this) (if (ChildNumber''is-hardened this) "H" ""))
    )
)

;; TODO: This whole API feels a bit object heavy.  Do we really need ChildNumber and so many maps, etc?
;; TODO: Should we be representing this using an actual tree arrangement in memory instead of a bunch of hashmaps?

;;;
 ; A DeterministicHierarchy calculates and keeps a whole tree (hierarchy) of keys originating from a single
 ; root key.  This implements part of the BIP 32 specification.  A deterministic key tree is useful because
 ; Bitcoin's privacy system require new keys to be created for each transaction, but managing all these
 ; keys quickly becomes unwieldy.  In particular it becomes hard to back up and distribute them.  By having
 ; a way to derive random-looking but deterministic keys we can make wallet backup simpler and gain the
 ; ability to hand out {@link DeterministicKey}s to other people who can then create new addresses
 ; on the fly, without having to contact us.
 ;
 ; The hierarchy is started from a single root key, and a location in the tree is given by a path which
 ; is a list of {@link ChildNumber}s.
 ;;
(class-ns DeterministicHierarchy
    (def #_"int" DeterministicHierarchy'BIP32_STANDARDISATION_TIME_SECS 1369267200)

    ;;;
     ; Constructs a new hierarchy rooted at the given key.  Note that this does not have to be the top of the tree.
     ; You can construct a DeterministicHierarchy for a subtree of a larger tree that you may not own.
     ;;
    (defn #_"DeterministicHierarchy" DeterministicHierarchy'new [#_"DeterministicKey" root]
        (let [this
                (hash-map
                    #_"{[ChildNumber] DeterministicKey}" :keys (hash-map)
                    #_"[ChildNumber]" :root-path nil
                    ;; Keep track of how many child keys each node has.  This is kind of weak.
                    #_"{[ChildNumber] ChildNumber}" :last-child-numbers (hash-map)
                )]
            (DeterministicHierarchy''put-key this, root)
            (assoc this :root-path (:child-number-path root))
        )
    )

    ;;;
     ; Inserts a key into the heirarchy.  Used during deserialization: you normally don't need this.  Keys must be
     ; inserted in order.
     ;;
    #_method
    (defn #_"void" DeterministicHierarchy''put-key [#_"DeterministicHierarchy" this, #_"DeterministicKey" key]
        (let [#_"[ChildNumber]" path (:child-number-path key)
              ;; Update our tracking of what the next child in each branch of the tree should be.
              ;; Just assume that keys are inserted in order here.
              #_"DeterministicKey" parent (:parent-key key)]
            (when (some? parent)
                (ยง ass this (update this :last-child-numbers assoc (:child-number-path parent) (DeterministicKey''get-child-number key)))
            )
            (ยง ass this (update this :keys assoc path key))
        )
        nil
    )

    ;;;
     ; Returns a key for the given path, optionally creating it.
     ;
     ; @param path The path to the key.
     ; @param relativePath Whether the path is relative to the root path.
     ; @param create Whether the key corresponding to path should be created (with any necessary ancestors) if it doesn't exist already.
     ; @return next newly created key using the child derivation function.
     ; @throws IllegalArgumentException if create is false and the path was not found.
     ;;
    #_method
    (defn #_"DeterministicKey" DeterministicHierarchy''get-4 [#_"DeterministicHierarchy" this, #_"[ChildNumber]" path, #_"boolean" relative?, #_"boolean" create?]
        (let [#_"[ChildNumber]" abs (if relative? (catvec (:root-path this) path) path)]
            (when-not (contains? (:keys this) abs)
                (when-not create?
                    (throw (IllegalArgumentException. (apply str "No key found for " (if relative? "relative" "absolute") " path " (interpose "/" (cons "M" path)))))
                )
                (assert-argument (seq abs), "Can't derive the master key: nothing to derive from.")
                (let [#_"DeterministicKey" parent (DeterministicHierarchy''get-4 this, (pop abs), false, true)]
                    (DeterministicHierarchy''put-key this, (HDKeyDerivation'derive-child-key-2c parent, (peek abs)))
                )
            )
            (get (:keys this) abs)
        )
    )

    ;;;
     ; Extends the tree by calculating the next key that hangs off the given parent path.  For example, if you pass
     ; a path of 1/2 here and there are already keys 1/2/1 and 1/2/2 then it will derive 1/2/3.
     ;
     ; @param parentPath The path to the parent.
     ; @param relative Whether the path is relative to the root path.
     ; @param createParent Whether the parent corresponding to path should be created (with any necessary ancestors) if it doesn't exist already.
     ; @param privateDerivation Whether to use private or public derivation.
     ; @return next newly created key using the child derivation funtcion.
     ; @throws IllegalArgumentException if the parent doesn't exist and createParent is false.
     ;;
    #_method
    (defn #_"DeterministicKey" DeterministicHierarchy''derive-next-child [#_"DeterministicHierarchy" this, #_"[ChildNumber]" path, #_"boolean" relative?, #_"boolean" create?, #_"boolean" private?]
        (let [#_"DeterministicKey" parent (DeterministicHierarchy''get-4 this, path, relative?, create?)]
            (loop-when [#_"int" i 0] (< i HDKeyDerivation'MAX_CHILD_DERIVATION_ATTEMPTS) => (throw+ (HDDerivationException'new "Maximum number of child derivation attempts reached, this is probably an indication of a bug."))
                (try+
                    (let [#_"ChildNumber" child (DeterministicHierarchy''get-next-child-number-to-derive this, (:child-number-path parent), private?)]
                        (DeterministicHierarchy''derive-child-3 this, parent, child)
                    )
                    (ยง catch HDDerivationException _
                        (recur (inc i))
                    )
                )
            )
        )
    )

    #_method
    (defn- #_"ChildNumber" DeterministicHierarchy''get-next-child-number-to-derive [#_"DeterministicHierarchy" this, #_"[ChildNumber]" path, #_"boolean" private?]
        (let [#_"ChildNumber" last (get (:last-child-numbers this) path)
              #_"ChildNumber" next (ChildNumber'compose (if (some? last) (inc (ChildNumber''num last)) 0), private?)]
            (ยง ass this (update this :last-child-numbers assoc path next))
            next
        )
    )

    #_method
    (defn #_"int" DeterministicHierarchy''get-num-children [#_"DeterministicHierarchy" this, #_"[ChildNumber]" path]
        (let [#_"ChildNumber" child (get (:last-child-numbers this) path)]
            ;; Children start with zero based childnumbers.
            (if (some? child) (inc (ChildNumber''num child)) 0)
        )
    )

    ;;;
     ; Extends the tree by calculating the requested child for the given path.  For example, to get the key at position
     ; 1/2/3 you would pass 1/2 as the parent path and 3 as the child number.
     ;
     ; @param parentPath The path to the parent.
     ; @param relative Whether the path is relative to the root path.
     ; @param createParent Whether the parent corresponding to path should be created (with any necessary ancestors) if it doesn't exist already.
     ; @return the requested key.
     ; @throws IllegalArgumentException if the parent doesn't exist and createParent is false.
     ;;
    #_method
    (defn #_"DeterministicKey" DeterministicHierarchy''derive-child-5 [#_"DeterministicHierarchy" this, #_"[ChildNumber]" path, #_"boolean" relative?, #_"boolean" create?, #_"ChildNumber" child]
        (DeterministicHierarchy''derive-child-3 this, (DeterministicHierarchy''get-4 this, path, relative?, create?), child)
    )

    #_method
    (defn- #_"DeterministicKey" DeterministicHierarchy''derive-child-3 [#_"DeterministicHierarchy" this, #_"DeterministicKey" parent, #_"ChildNumber" child]
        (let [#_"DeterministicKey" key (HDKeyDerivation'derive-child-key-2c parent, child)]
            (DeterministicHierarchy''put-key this, key)
            key
        )
    )

    ;;;
     ; Returns the root key that the {@link DeterministicHierarchy} was created with.
     ;;
    #_method
    (defn #_"DeterministicKey" DeterministicHierarchy''get-root-key [#_"DeterministicHierarchy" this]
        (DeterministicHierarchy''get-4 this, (:root-path this), false, false)
    )
)

;;;
 ; A deterministic key is a node in a {@link DeterministicHierarchy}.  As per
 ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">the BIP 32 specification</a> it is a pair
 ; (key, chaincode).  If you know its path in the tree and its chain code you can derive more keys from this.
 ; To obtain one of these, you can call {@link HDKeyDerivation#createMasterPrivateKey(byte[])}.
 ;;
(class-ns DeterministicKey (ยง extends ECKey)
    (defn- #_"DeterministicKey" DeterministicKey'init []
        (hash-map
            #_"DeterministicKey" :parent-key nil
            ;;;
             ; The path through some {@link DeterministicHierarchy} which reaches this keys position in the tree.
             ; A path can be written as 1/2/1 which means the first child of the root, the second child of that node,
             ; then the first child of that node.
             ;;
            #_"[ChildNumber]" :child-number-path nil
            ;;;
             ; This key's depth in the hierarchy, where the root node is at depth zero.
             ; This may be different than the number of segments in the path if this key was
             ; deserialized without access to its parent.
             ;;
            #_"int" :depth 0
            ;;;
             ; If this is a child key, the fingerprint of the key from which this key was derived,
             ; otherwise an array of four zero-value bytes.
             ;;
            #_"int" :parent-fingerprint 0 ;; 0 if this key is root node of key hierarchy
            ;;;
             ; The chain code associated with this key.
             ;;
            #_"byte[]" :chain-code nil ;; 32 bytes
        )
    )

    ;;; Constructs a key from its components.  This is not normally something you should use. ;;
    (defn #_"DeterministicKey" DeterministicKey'new-5 [#_"[ChildNumber]" path, #_"byte[]" code, #_"ECPoint" __publicAsPoint, #_"BigInteger" priv, #_"DeterministicKey" parent]
        (assert-argument (= (count code) 32))

        (-> (merge (ECKey'compose priv, (ECKey'compress-point (ensure some? __publicAsPoint))) (DeterministicKey'init))
            (assoc :parent-key parent)
            (assoc :child-number-path (ensure some? path))
            (assoc :chain-code (Arrays/copyOf code, (count code)))
            (assoc :depth (if (some? parent) (inc (:depth parent)) 0))
            (assoc :parent-fingerprint (if (some? parent) (DeterministicKey''get-fingerprint parent) 0))
        )
    )

    ;;; Constructs a key from its components.  This is not normally something you should use. ;;
    (defn #_"DeterministicKey" DeterministicKey'new-4 [#_"[ChildNumber]" path, #_"byte[]" code, #_"BigInteger" priv, #_"DeterministicKey" parent]
        (assert-argument (= (count code) 32))

        (-> (merge (ECKey'compose priv, (ECKey'compress-point (ECKey'public-point-from-private priv))) (DeterministicKey'init))
            (assoc :parent-key parent)
            (assoc :child-number-path (ensure some? path))
            (assoc :chain-code (Arrays/copyOf code, (count code)))
            (assoc :depth (if (some? parent) (inc (:depth parent)) 0))
            (assoc :parent-fingerprint (if (some? parent) (DeterministicKey''get-fingerprint parent) 0))
        )
    )

    ;;;
     ; Return the fingerprint of this key's parent as an int value, or zero if this key is the
     ; root node of the key hierarchy.  Raise an exception if the arguments are inconsistent.
     ; This method exists to avoid code repetition in the constructors.
     ;;
    #_throws #_[ "IllegalArgumentException" ]
    (defn- #_"int" DeterministicKey'ascertain-parent-fingerprint [#_"DeterministicKey" parent, #_"int" fing]
        (when (and (some? parent) (not= fing 0))
            (assert-argument (= (DeterministicKey''get-fingerprint parent) fing), "parent fingerprint mismatch", (Integer/toHexString (DeterministicKey''get-fingerprint parent)), (Integer/toHexString fing))
        )
        fing
    )

    ;;;
     ; Constructs a key from its components, including its public key data and possibly-redundant
     ; information about its parent key.  Invoked when deserializing, but otherwise not something
     ; that you normally should use.
     ;;
    (defn #_"DeterministicKey" DeterministicKey'new-6p [#_"[ChildNumber]" path, #_"byte[]" code, #_"ECPoint" __publicAsPoint, #_"DeterministicKey" parent, #_"int" depth, #_"int" fing]
        (assert-argument (= (count code) 32))

        (-> (merge (ECKey'compose nil, (ECKey'compress-point (ensure some? __publicAsPoint))) (DeterministicKey'init))
            (assoc :parent-key parent)
            (assoc :child-number-path (ensure some? path))
            (assoc :chain-code (Arrays/copyOf code, (count code)))
            (assoc :depth depth)
            (assoc :parent-fingerprint (DeterministicKey'ascertain-parent-fingerprint parent, fing))
        )
    )

    ;;;
     ; Constructs a key from its components, including its private key data and possibly-redundant
     ; information about its parent key.  Invoked when deserializing, but otherwise not something
     ; that you normally should use.
     ;;
    (defn #_"DeterministicKey" DeterministicKey'new-6i [#_"[ChildNumber]" path, #_"byte[]" code, #_"BigInteger" priv, #_"DeterministicKey" parent, #_"int" depth, #_"int" fing]
        (assert-argument (= (count code) 32))

        (-> (merge (ECKey'compose priv, (ECKey'compress-point (ECKey'public-point-from-private priv))) (DeterministicKey'init))
            (assoc :parent-key parent)
            (assoc :child-number-path (ensure some? path))
            (assoc :chain-code (Arrays/copyOf code, (count code)))
            (assoc :depth depth)
            (assoc :parent-fingerprint (DeterministicKey'ascertain-parent-fingerprint parent, fing))
        )
    )

    ;;;
     ; Returns the path of this key as a human readable string starting with M to indicate the master key.
     ;;
    #_method
    (defn #_"String" DeterministicKey''get-path-as-string [#_"DeterministicKey" this]
        (apply str (interpose "/" (cons "M" (:child-number-path this))))
    )

    ;;;
     ; Returns the last element of the path returned by {@link DeterministicKey#getPath()}.
     ;;
    #_method
    (defn #_"ChildNumber" DeterministicKey''get-child-number [#_"DeterministicKey" this]
        (or (peek (:child-number-path this)) ChildNumber'ZERO)
    )

    ;;;
     ; Compares deterministic keys in the order of their child number.  That's <i>usually</i> the order used to derive them.
     ;;
    (defn #_"int" DeterministicKey'compare-by-child-number [#_"DeterministicKey" this, #_"DeterministicKey" that]
        (ChildNumber'compare (DeterministicKey''get-child-number this), (DeterministicKey''get-child-number that))
    )

    ;;;
     ; Returns RIPE-MD160(SHA256(pub key bytes)).
     ;;
    #_method
    (defn #_"byte[]" DeterministicKey''get-identifier [#_"DeterministicKey" this]
        (Utils'sha256hash160 (ECKey''get-pub-key this))
    )

    ;;;
     ; Returns the first 32 bits of the result of {@link #getIdentifier()}.
     ;;
    #_method
    (defn #_"int" DeterministicKey''get-fingerprint [#_"DeterministicKey" this]
        ;; TODO: Why is this different than armory's fingerprint?  BIP 32: "The first 32 bits of the identifier are called the fingerprint."
        (.getInt (ByteBuffer/wrap (Arrays/copyOfRange (DeterministicKey''get-identifier this), 0, 4)))
    )

    ;;;
     ; Returns private key bytes, padded with zeros to 33 bytes.
     ;
     ; @throws IllegalStateException if the private key bytes are missing.
     ;;
    #_method
    (defn #_"byte[]" DeterministicKey''get-priv-key-bytes33 [#_"DeterministicKey" this]
        (let [#_"byte[]" bytes33 (byte-array 33)
              #_"byte[]" priv (ECKey''get-priv-key-bytes this) #_"int" n (count priv)]
            (System/arraycopy priv, 0, bytes33, (- 33 n), n)
            bytes33
        )
    )

    ;;;
     ; Returns the same key with the private bytes removed.  May return the same instance.  The purpose of this is to
     ; save memory: the private key can always be very efficiently rederived from a parent that a private key, so storing
     ; all the private keys in RAM is a poor tradeoff especially on constrained devices.  This means that the returned
     ; key may still be usable for signing and so on, so don't expect it to be a true pubkey-only object!  If you want
     ; that then you should follow this call with a call to {@link #dropParent()}.
     ;;
    #_method
    (defn #_"DeterministicKey" DeterministicKey''drop-private-bytes [#_"DeterministicKey" this]
        (when-not (ECKey'''is-pub-key-only this) => this
            (DeterministicKey'new-5 (:child-number-path this), (:chain-code this), (:pub this), nil, (:parent-key this))
        )
    )

    ;;;
     ; Returns the same key with the parent pointer removed (it still knows its own path and the parent fingerprint).
     ;
     ; If this key doesn't have private key bytes stored/cached itself, but could rederive them from the parent, then
     ; the new key returned by this method won't be able to do that.  Thus, using dropPrivateBytes().dropParent() on
     ; a regular DeterministicKey will yield a new DeterministicKey that cannot sign or do other things involving the
     ; private key at all.
     ;;
    #_method
    (defn #_"DeterministicKey" DeterministicKey''drop-parent [#_"DeterministicKey" this]
        (let [#_"DeterministicKey" key (DeterministicKey'new-5 (:child-number-path this), (:chain-code this), (:pub this), (:priv this), nil)]
            (assoc key :parent-fingerprint (:parent-fingerprint this))
        )
    )

    (defn #_"byte[]" DeterministicKey'add-checksum [#_"byte[]" input]
        (let [#_"byte[]" checksum (Sha256Hash'hash-twice input)
              #_"int" n (count input)
              #_"byte[]" bytes (byte-array (+ n 4)) _ (System/arraycopy input, 0, bytes, 0, n) _ (System/arraycopy checksum, 0, bytes, n, 4)]
            bytes
        )
    )

    ;;;
     ; A deterministic key is considered to be 'public key only' if it hasn't got a private key part and it cannot be
     ; rederived.  If the hierarchy is encrypted this returns true.
     ;;
    #_override
    (defn #_"boolean" ECKey'''is-pub-key-only [#_"DeterministicKey" this]
        (and (ECKey'''is-pub-key-only (ยง this super)) (or (nil? (:parent-key this)) (ECKey'''is-pub-key-only (:parent-key this))))
    )

    #_override
    (defn #_"boolean" ECKey'''has-priv-key [#_"DeterministicKey" this]
        (some? (DeterministicKey''find-parent-with-priv-key this))
    )

    #_override
    (defn #_"ECDSASignature" ECKey'''sign [#_"DeterministicKey" this, #_"Sha256Hash" input]
        ;; Else this key is a part of a public-key only heirarchy and cannot be used for signing.
        (let-when [#_"BigInteger" priv (DeterministicKey''find-or-derive-private-key this)] (some? priv) => (throw+ (MissingPrivateKeyException'new))
            (ECKey''do-sign (ยง this super), input, priv)
        )
    )

    #_method
    (defn- #_"DeterministicKey" DeterministicKey''find-parent-with-priv-key [#_"DeterministicKey" this]
        (loop-when-recur [#_"DeterministicKey" key this] (and (some? key) (nil? (:priv key))) [(:parent-key key)] => key)
    )

    #_method
    (defn- #_"BigInteger" DeterministicKey''find-or-derive-private-key [#_"DeterministicKey" this]
        (when-let [#_"DeterministicKey" cursor (DeterministicKey''find-parent-with-priv-key this)]
            (DeterministicKey''derive-private-key-downwards this, cursor, (.toByteArray (:priv cursor)))
        )
    )

    #_method
    (defn- #_"BigInteger" DeterministicKey''derive-private-key-downwards [#_"DeterministicKey" this, #_"DeterministicKey" key, #_"byte[]" bytes]
        ;; We have to rederive the keys along the path back to ourselves.
        ;; That path can be found by just truncating our path with the length of the parents path.
        (let [#_"BigInteger" priv (BigInteger. 1, bytes)
              key (reduce HDKeyDerivation'derive-child-key-2c
                    (DeterministicKey'new-5 (:child-number-path key), (:chain-code key), (:pub key), priv, (:parent-key key))
                    (drop (count (:child-number-path key)) (:child-number-path this)))]
            ;; downCursor is now the same key as us, but with private key bytes.
            ;; If it's not, it means we tried decrypting with an invalid password and earlier checks e.g. for padding didn't catch it.
            (when-not (.equals (:pub key), (:pub this))
                (throw (RuntimeException. "Could not decrypt bytes"))
            )

            (ensure some? (:priv key))
        )
    )

    ;;;
     ; Derives a child at the given index using hardened derivation.  Note: <code>index</code>
     ; is not the "i" value.  If you want the softened derivation, then use instead
     ; <code>HDKeyDerivation.deriveChildKey(this, new ChildNumber(child, false))</code>.
     ;;
    #_method
    (defn #_"DeterministicKey" DeterministicKey''derive [#_"DeterministicKey" this, #_"int" child]
        (HDKeyDerivation'derive-child-key-2c this, (ChildNumber'compose child, true))
    )

    ;;;
     ; Returns the private key of this deterministic key.  Even if this object isn't storing the private key,
     ; it can be re-derived by walking up to the parents if necessary and this is what will happen.
     ;
     ; @throws IllegalStateException if the parents are encrypted or a watching chain.
     ;;
    #_override
    (defn #_"BigInteger" ECKey'''get-priv-key [#_"DeterministicKey" this]
        (let [#_"BigInteger" key (DeterministicKey''find-or-derive-private-key this)]
            (assert-state (some? key), "Private key bytes not available")
            key
        )
    )

    #_method
    (defn #_"byte[]" DeterministicKey''serialize-public [#_"DeterministicKey" this, #_"Ledger" ledger]
        (DeterministicKey''serialize this, ledger, true)
    )

    #_method
    (defn #_"byte[]" DeterministicKey''serialize-private [#_"DeterministicKey" this, #_"Ledger" ledger]
        (DeterministicKey''serialize this, ledger, false)
    )

    #_method
    (defn- #_"byte[]" DeterministicKey''serialize [#_"DeterministicKey" this, #_"Ledger" ledger, #_"boolean" pub?]
        (let [#_"ByteBuffer" buff (ByteBuffer/allocate 78)]
            (.putInt buff, (if pub? (:bip32-header-pub ledger) (:bip32-header-priv ledger)))
            (.put buff, (byte (:depth this)))
            (.putInt buff, (:parent-fingerprint this))
            (.putInt buff, (ChildNumber''i (DeterministicKey''get-child-number this)))
            (.put buff, (:chain-code this))
            (.put buff, (if pub? (ECKey''get-pub-key this) (DeterministicKey''get-priv-key-bytes33 this)))
            (assert-state (= (.position buff) 78))
            (.array buff)
        )
    )

    #_method
    (defn #_"String" DeterministicKey''serialize-pub-base58 [#_"DeterministicKey" this, #_"Ledger" ledger]
        (DeterministicKey'to-base58 (DeterministicKey''serialize this, ledger, true))
    )

    #_method
    (defn #_"String" DeterministicKey''serialize-priv-base58 [#_"DeterministicKey" this, #_"Ledger" ledger]
        (DeterministicKey'to-base58 (DeterministicKey''serialize this, ledger, false))
    )

    (defn #_"String" DeterministicKey'to-base58 [#_"byte[]" bytes]
        (Base58'encode (DeterministicKey'add-checksum bytes))
    )

    ;;;
     ; Deserialize a base-58-encoded HD Key with no parent.
     ;;
    (defn #_"DeterministicKey" DeterministicKey'deserialize-base58-2 [#_"String" base58, #_"Ledger" ledger]
        (DeterministicKey'deserialize-base58-3 nil, base58, ledger)
    )

    ;;;
     ; Deserialize a base-58-encoded HD Key.
     ;
     ; @param parent The parent node in the given key's deterministic hierarchy.
     ; @throws IllegalArgumentException if the base58 encoded key could not be parsed.
     ;;
    (defn #_"DeterministicKey" DeterministicKey'deserialize-base58-3 [#_"DeterministicKey" parent, #_"String" base58, #_"Ledger" ledger]
        (DeterministicKey'deserialize ledger, (Base58'decode-checked base58), parent)
    )

    ;;;
     ; Deserialize an HD Key.
     ;
     ; @param parent The parent node in the given key's deterministic hierarchy.
     ;;
    (defn #_"DeterministicKey" DeterministicKey'deserialize
        ([#_"Ledger" ledger, #_"byte[]" __serializedKey] (DeterministicKey'deserialize ledger, __serializedKey, nil))
        ([#_"Ledger" ledger, #_"byte[]" __serializedKey, #_"DeterministicKey" parent]
            (let [#_"ByteBuffer" buffer (ByteBuffer/wrap __serializedKey)
                  #_"int" header (.getInt buffer)]
                (when-not (any = header (:bip32-header-priv ledger) (:bip32-header-pub ledger))
                    (throw (IllegalArgumentException. (str "Unknown header bytes: " (.substring (DeterministicKey'to-base58 __serializedKey), 0, 4))))
                )

                (let [#_"boolean" pub? (= header (:bip32-header-pub ledger))
                      #_"int" depth (& (.get buffer) 0xff) ;; convert signed byte to positive int since depth cannot be negative
                      #_"int" fing (.getInt buffer)
                      #_"ChildNumber" child (ChildNumber'new (.getInt buffer))
                      #_"[ChildNumber]" path
                        (if (some? parent)
                            (do
                                (when (zero? fing)
                                    (throw (IllegalArgumentException. "Parent was provided but this key doesn't have one"))
                                )
                                (when-not (= (DeterministicKey''get-fingerprint parent) fing)
                                    (throw (IllegalArgumentException. "Parent fingerprints don't match"))
                                )
                                (let [path (conj (:child-number-path parent) child)]
                                    (when-not (= (count path) depth)
                                        (throw (IllegalArgumentException. "Depth does not match"))
                                    )
                                    path
                                )
                            )
                            ;; We have been given a key that is not a root key, yet we lack the object representing the parent.
                            ;; This can happen when deserializing an account key for a watching wallet.  In this case, we assume
                            ;; that the client wants to conceal the key's position in the hierarchy.  The path is truncated at
                            ;; the parent's node.
                            (if (<= 1 depth) (ImmutableList/of child) (ImmutableList/of))
                        )]

                    (let [#_"byte[]" code (byte-array 32) _ (.get buffer, code)
                          #_"byte[]" data (byte-array 33) _ (.get buffer, data)]
                        (assert-argument (not (.hasRemaining buffer)), "Found unexpected data in key")
                        (if pub?
                            (DeterministicKey'new-6p path, code, (.decodePoint (.getCurve ECKey'CURVE), data), parent, depth, fing)
                            (DeterministicKey'new-6i path, code, (BigInteger. 1, data), parent, depth, fing)
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; The creation time of a deterministic key is equal to that of its parent, unless this key is the root of a tree
     ; in which case the time is stored alongside the key as per normal, see {@link ECKey#getCreationTimeSeconds()}.
     ;;
    #_override
    (defn #_"long" ECKey'''get-creation-time-seconds [#_"DeterministicKey" this]
        (if (some? (:parent-key this)) (ECKey'''get-creation-time-seconds (:parent-key this)) (ECKey'''get-creation-time-seconds (ยง this super)))
    )

    ;;;
     ; The creation time of a deterministic key is equal to that of its parent, unless this key is the root of a tree.
     ; Thus, setting the creation time on a leaf is forbidden.
     ;;
    #_method
    (defn #_"DeterministicKey" DeterministicKey''set-creation-time-seconds [#_"DeterministicKey" this, #_"long" secs]
        (if (some? (:parent-key this))
            (throw (IllegalStateException. "Creation time can only be set on root keys."))
            (ECKey''set-creation-time-seconds this, secs)
        )
    )

    #_override
    (defn #_"void" ECKey'''format-key-with-address [#_"DeterministicKey" this, #_"Ledger" ledger, #_"StringBuilder" sb]
        (let [#_"Address" address (ECKey''to-address this, ledger)]
            (.. sb (append "  addr:") (append address))
            (.. sb (append "  hash160:") (append (Base16'encode (ECKey''calculate-pub-key-hash160 this))))
            (.. sb (append "  (") (append (DeterministicKey''get-path-as-string this)) (append ")"))
            (.. sb (append "\n"))
            (.. sb (append "  ") (append (ECKey''to-string this)) (append "\n"))
        )
        nil
    )

    ;;;
     ; Verifies equality of all fields but NOT the parent pointer, thus the same key derived in two separate heirarchy
     ; objects will equal each other.
     ;;
    #_foreign
    #_override
    (defn #_"boolean" Object'''equals [#_"DeterministicKey" this, #_"Object" o]
        (cond
            (= this o) true
            (or (nil? o) (not= (.getClass this) (.getClass o))) false
            :else (let [#_"DeterministicKey" that (cast' DeterministicKey o)]
                (and (.equals (ยง this super), that) (Arrays/equals (:chain-code this), (:chain-code that)) (Objects/equals (:child-number-path this), (:child-number-path that)))
            )
        )
    )

    #_foreign
    #_override
    (defn #_"int" Object'''hashCode [#_"DeterministicKey" this]
        (Objects/hash (object-array [ (.hashCode (ยง this super)), (Arrays/hashCode (:chain-code this)), (:child-number-path this) ]))
    )

    #_method
    (defn #_"String" DeterministicKey''to-string [#_"DeterministicKey" this]
        (let [#_"StringBuilder" sb (StringBuilder. (<< 1 7))]
            (.. sb (append "{ "))
            (do
                (.. sb               (append "pub")                     (append "=") (append (Base16'encode (ECKey''get-pub-key this))))
                (.. sb (append ", ") (append "chainCode")               (append "=") (append (Base16'encode (:chain-code this))))
                (.. sb (append ", ") (append "path")                    (append "=") (append (DeterministicKey''get-path-as-string this)))
                (when (pos? (:creation-time-seconds this))
                    (.. sb (append ", ") (append "creationTimeSeconds") (append "=") (append (:creation-time-seconds this)))
                )
                (.. sb (append ", ") (append "isPubKeyOnly")            (append "=") (append (ECKey'''is-pub-key-only this)))
            )
            (.. sb (append " }"))
            (.toString sb)
        )
    )
)

(class-ns HDDerivationException (ยง extends RuntimeException)
    (defn #_"HDDerivationException" HDDerivationException'new [#_"String" message]
        (RuntimeException'new message)
    )
)

(def PublicDerivationMode'enum-set
    (hash-set
        :PublicDerivationMode'NORMAL
        :PublicDerivationMode'WITH_INVERSION
    )
)

(class-ns RawKeyBytes
    (defn #_"RawKeyBytes" RawKeyBytes'new [#_"byte[]" bytes, #_"byte[]" code]
        (hash-map
            #_"byte[]" :key-bytes bytes
            #_"byte[]" :chain-code code
        )
    )
)

;;;
 ; Implementation of the <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP 32</a>
 ; deterministic wallet child key generation algorithm.
 ;;
#_stateless
(class-ns HDKeyDerivation
    ;; Some arbitrary random number.  Doesn't matter what it is.
    (def- #_"BigInteger" HDKeyDerivation'RAND_INT (BigInteger. 256, (SecureRandom.)))

    ;;;
     ; Child derivation may fail (although with extremely low probability); in such case it is re-attempted.
     ; This is the maximum number of re-attempts (to avoid an infinite loop in case of bugs etc.)
     ;;
    (def #_"int" HDKeyDerivation'MAX_CHILD_DERIVATION_ATTEMPTS 100)

    ;;;
     ; Generates a new deterministic key from the given seed, which can be any arbitrary byte array.
     ; However resist the temptation to use a string as the seed - any key derived from a password
     ; is likely to be weak and easily broken by attackers (this is not theoretical, people have had
     ; money stolen that way).  This method checks that the given seed is at least 64 bits long.
     ;
     ; @throws HDDerivationException if generated master key is invalid (private key 0 or >= n).
     ; @throws IllegalArgumentException if the seed is less than 8 bytes and could be brute forced.
     ;;
    #_throws #_[ "HDDerivationException" ]
    (defn #_"DeterministicKey" HDKeyDerivation'create-master-private-key [#_"byte[]" seed]
        (assert-argument (< 8 (count seed)), "Seed is too short and could be brute forced")

        ;; Calculate I = HMAC-SHA512(key="Bitcoin seed", msg=S).
        (let [#_"byte[]" i (HDUtils'hmac-sha512-2 (HDUtils'create-hmac-sha512-digest (.getBytes "Bitcoin seed", Charset'UTF-8)), seed)]
            ;; Split I into two 32-byte sequences, Il and Ir.
            ;; Use Il as master secret key, and Ir as master chain code.
            (assert-state (= (count i) 64))

            (let [#_"byte[]" il (Arrays/copyOfRange i, 0, 32)
                  #_"byte[]" ir (Arrays/copyOfRange i, 32, 64)]
                (Arrays/fill i, (byte 0))
                (let [#_"DeterministicKey" master (HDKeyDerivation'create-master-priv-key-from-bytes il, ir)]
                    (Arrays/fill il, (byte 0))
                    (Arrays/fill ir, (byte 0))

                    ;; Child deterministic keys will chain up to their parents to find the keys.
                    (DeterministicKey''set-creation-time-seconds master, (Time'seconds))
                )
            )
        )
    )

    ;;;
     ; @throws HDDerivationException if privKeyBytes is invalid (0 or >= n).
     ;;
    #_throws #_[ "HDDerivationException" ]
    (defn #_"DeterministicKey" HDKeyDerivation'create-master-priv-key-from-bytes [#_"byte[]" bytes, #_"byte[]" code]
        (let [#_"BigInteger" priv (BigInteger. 1, bytes)]
            (HDKeyDerivation'assert-non-zero priv, "Generated master key is invalid.")
            (HDKeyDerivation'assert-less-than-n priv, "Generated master key is invalid.")
            (DeterministicKey'new-4 (ImmutableList/of #_"[ChildNumber]"), code, priv, nil)
        )
    )

    (defn #_"DeterministicKey" HDKeyDerivation'create-master-pub-key-from-bytes [#_"byte[]" bytes, #_"byte[]" code]
        (DeterministicKey'new-5 (ImmutableList/of #_"[ChildNumber]"), code, (.decodePoint (.getCurve ECKey'CURVE), bytes), nil, nil)
    )

    ;;;
     ; Derives a key given the "extended" child number, i.e. the 0x80000000 bit of the value that you
     ; pass for <code>childNumber</code> will determine whether to use hardened derivation or not.
     ; Consider whether your code would benefit from the clarity of the equivalent, but explicit, form
     ; of this method that takes a <code>ChildNumber</code> rather than an <code>int</code>, for example:
     ; <code>deriveChildKey(parent, new ChildNumber(childNumber, true))</code>
     ; where the value of the hardened bit of <code>childNumber</code> is zero.
     ;;
    (defn #_"DeterministicKey" HDKeyDerivation'derive-child-key-2i [#_"DeterministicKey" parent, #_"int" i]
        (HDKeyDerivation'derive-child-key-2c parent, (ChildNumber'new i))
    )

    ;;;
     ; Derives a key of the "extended" child number, i.e. with the 0x80000000 bit specifying whether
     ; to use hardened derivation or not.  If derivation fails, tries a next child.
     ;;
    (defn #_"DeterministicKey" HDKeyDerivation'derive-this-or-next-child-key [#_"DeterministicKey" parent, #_"int" i]
        (let [#_"ChildNumber" child (ChildNumber'new i) #_"int" n (ChildNumber''num child) #_"boolean" hardened? (ChildNumber''is-hardened child)]
            (loop-when [#_"int" i 0] (< i HDKeyDerivation'MAX_CHILD_DERIVATION_ATTEMPTS) => (throw+ (HDDerivationException'new "Maximum number of child derivation attempts reached, this is probably an indication of a bug."))
                (try+
                    (HDKeyDerivation'derive-child-key-2c parent, (ChildNumber'compose (+ n i), hardened?))
                    (ยง catch HDDerivationException _
                        (recur (inc i))
                    )
                )
            )
        )
    )

    ;;;
     ; @throws HDDerivationException if private derivation is attempted for a public-only parent key, or
     ; if the resulting derived key is invalid (e.g. private key == 0).
     ;;
    #_throws #_[ "HDDerivationException" ]
    (defn #_"DeterministicKey" HDKeyDerivation'derive-child-key-2c [#_"DeterministicKey" parent, #_"ChildNumber" child]
        (let [#_"[ChildNumber]" path (:child-number-path parent)]
            (if (not (ECKey'''has-priv-key parent))
                (let [#_"RawKeyBytes" raw (HDKeyDerivation'derive-child-key-bytes-from-public parent, child, :PublicDerivationMode'NORMAL)]
                    (DeterministicKey'new-5 (conj path child), (:chain-code raw), (.decodePoint (.getCurve ECKey'CURVE), (:key-bytes raw)), nil, parent)
                )
                (let [#_"RawKeyBytes" raw (HDKeyDerivation'derive-child-key-bytes-from-private parent, child)]
                    (DeterministicKey'new-4 (conj path child), (:chain-code raw), (BigInteger. 1, (:key-bytes raw)), parent)
                )
            )
        )
    )

    #_throws #_[ "HDDerivationException" ]
    (defn #_"RawKeyBytes" HDKeyDerivation'derive-child-key-bytes-from-private [#_"DeterministicKey" parent, #_"ChildNumber" child]
        (assert-argument (ECKey'''has-priv-key parent), "Parent key must have private key bytes for this method.")

        (let [#_"byte[]" __parentPublicKey (.getEncoded (:pub parent), true)]
            (assert-state (= (count __parentPublicKey) 33), (str "Parent pubkey must be 33 bytes, but is " (count __parentPublicKey)))

            (let [#_"ByteBuffer" buff (ByteBuffer/allocate 37)]
                (.put buff, (if (ChildNumber''is-hardened child) (DeterministicKey''get-priv-key-bytes33 parent) __parentPublicKey))
                (.putInt buff, (ChildNumber''i child))

                (let [#_"byte[]" bytes (HDUtils'hmac-sha512-2-bytes (:chain-code parent), (.array buff))]
                    (assert-state (= (count bytes) 64))

                    (let [#_"BigInteger" i (BigInteger. 1, (Arrays/copyOfRange bytes, 0, 32))]
                        (HDKeyDerivation'assert-less-than-n i, "Illegal derived key: I_L >= n")

                        (let [#_"BigInteger" priv (ECKey'''get-priv-key parent)
                              #_"BigInteger" ki (.mod (.add priv, i), (.getN ECKey'CURVE))]
                            (HDKeyDerivation'assert-non-zero ki, "Illegal derived key: derived private key equals 0.")

                            (RawKeyBytes'new (.toByteArray ki), (Arrays/copyOfRange bytes, 32, 64))
                        )
                    )
                )
            )
        )
    )

    #_throws #_[ "HDDerivationException" ]
    (defn #_"RawKeyBytes" HDKeyDerivation'derive-child-key-bytes-from-public [#_"DeterministicKey" parent, #_"ChildNumber" child, #_"PublicDerivationMode" mode]
        (assert-argument (not (ChildNumber''is-hardened child)), "Can't use private derivation with public keys only.")

        (let [#_"byte[]" __parentPublicKey (.getEncoded (:pub parent), true)]
            (assert-state (= (count __parentPublicKey) 33), (str "Parent pubkey must be 33 bytes, but is " (count __parentPublicKey)))

            (let [#_"ByteBuffer" buff (ByteBuffer/allocate 37)]
                (.put buff, __parentPublicKey)
                (.putInt buff, (ChildNumber''i child))

                (let [#_"byte[]" bytes (HDUtils'hmac-sha512-2-bytes (:chain-code parent), (.array buff))]
                    (assert-state (= (count bytes) 64))

                    (let [#_"BigInteger" i (BigInteger. 1, (Arrays/copyOfRange bytes, 0, 32))]
                        (HDKeyDerivation'assert-less-than-n i, "Illegal derived key: I_L >= n")

                        (let [#_"BigInteger" n (.getN ECKey'CURVE)
                              #_"ECPoint" ki
                                (case mode
                                    :PublicDerivationMode'NORMAL
                                        (.add (ECKey'public-point-from-private i), (:pub parent))
                                    :PublicDerivationMode'WITH_INVERSION
                                        ;; This trick comes from Gregory Maxwell.  Check the homomorphic properties of our curve hold.  The
                                        ;; below calculations should be redundant and give the same result as NORMAL but if the precalculated
                                        ;; tables have taken a bit flip will yield a different answer.  This mode is used when vending a key
                                        ;; to perform a last-ditch sanity check trying to catch bad RAM.
                                        (-> (ECKey'public-point-from-private (.mod (.add i, HDKeyDerivation'RAND_INT), n))
                                            (.add (ECKey'public-point-from-private (.mod (.negate HDKeyDerivation'RAND_INT), n)))
                                            (.add (:pub parent)))
                                )]
                            (HDKeyDerivation'assert-non-infinity ki, "Illegal derived key: derived public key equals infinity.")

                            (RawKeyBytes'new (.getEncoded ki, true), (Arrays/copyOfRange bytes, 32, 64))
                        )
                    )
                )
            )
        )
    )

    (defn- #_"void" HDKeyDerivation'assert-non-zero [#_"BigInteger" i, #_"String" message]
        (when (= i BigInteger/ZERO)
            (throw+ (HDDerivationException'new message))
        )
        nil
    )

    (defn- #_"void" HDKeyDerivation'assert-non-infinity [#_"ECPoint" point, #_"String" message]
        (when (.equals point, (.getInfinity (.getCurve ECKey'CURVE)))
            (throw+ (HDDerivationException'new message))
        )
        nil
    )

    (defn- #_"void" HDKeyDerivation'assert-less-than-n [#_"BigInteger" i, #_"String" message]
        (when (<= (.getN ECKey'CURVE) i)
            (throw+ (HDDerivationException'new message))
        )
        nil
    )
)

;;;
 ; Static utilities used in BIP 32 Hierarchical Deterministic Wallets (HDW).
 ;;
#_stateless
(class-ns HDUtils
    (defn #_"HMac" HDUtils'create-hmac-sha512-digest [#_"byte[]" key]
        (let [#_"HMac" hmac (HMac. (SHA512Digest.))]
            (.init hmac, (KeyParameter. key))
            hmac
        )
    )

    (defn #_"byte[]" HDUtils'hmac-sha512-2 [#_"HMac" hmac, #_"byte[]" input]
        (.reset hmac)
        (.update hmac, input, 0, (count input))
        (let [#_"byte[]" output (byte-array 64)]
            (.doFinal hmac, output, 0)
            output
        )
    )

    (defn #_"byte[]" HDUtils'hmac-sha512-2-bytes [#_"byte[]" key, #_"byte[]" data]
        (HDUtils'hmac-sha512-2 (HDUtils'create-hmac-sha512-digest key), data)
    )
)

;;;
 ; This is a clean-room implementation of PBKDF2 using RFC 2898 as a reference.
 ;
 ; RFC 2898: http://tools.ietf.org/html/rfc2898#section-5.2
 ;
 ; This code passes all RFC 6070 test vectors: http://tools.ietf.org/html/rfc6070
 ;
 ; http://cryptofreek.org/2012/11/29/pbkdf2-pure-java-implementation/
 ; Modified to use SHA-512 - Ken Sedgwick ken@bonsai.com
 ;;
#_stateless
(class-ns PBKDF2SHA512
    #_throws #_[ "Exception" ]
    (defn- #_"byte[]" PBKDF2SHA512'f [#_"String" p, #_"String" s, #_"int" c, #_"int" i]
        (let [#_"SecretKeySpec" key (SecretKeySpec. (.getBytes p, Charset'UTF-8), "HmacSHA512")
              #_"Mac" mac (Mac/getInstance (.getAlgorithm key)) _ (.init mac, key)]

            (loop-when [#_"byte[]" xor' nil #_"byte[]" xor nil #_"int" j 0] (< j c) => xor
                (if (zero? j)
                    (let [#_"byte[]" s* (.getBytes s, Charset'UTF-8)
                          #_"byte[]" i* (let [#_"ByteBuffer" b* (ByteBuffer/allocate 4)] (.order b*, ByteOrder/BIG_ENDIAN) (.putInt b*, i) (.array b*))
                          #_"byte[]" u* (byte-array (+ (count s*) (count i*)))]

                        (System/arraycopy s*, 0, u*, 0, (count s*))
                        (System/arraycopy i*, 0, u*, (count s*), (count i*))

                        (let [xor (.doFinal mac, u*) _ (.reset mac)]
                            (recur xor xor (inc j))
                        )
                    )
                    (let [#_"byte[]" u* (.doFinal mac, xor') _ (.reset mac)]

                        (ยง dotimes [#_"int" k (count xor)]
                            (aset xor k (byte (bit-xor (nth xor k) (nth u* k))))
                        )

                        (recur u* xor (inc j))
                    )
                )
            )
        )
    )

    (defn #_"byte[]" PBKDF2SHA512'derive [#_"String" p, #_"String" s, #_"int" c, #_"int" n]
        (let [#_"int" h 20]
            (when (< (* (dec (Math/pow 2, 32)) h) n)
                (throw (IllegalArgumentException. "derived key too long"))
            )

            (let [#_"ByteArrayOutputStream" baos (ByteArrayOutputStream.)]
                (try
                    (dotimes [#_"int" i (int (Math/ceil (/ (double n) (double h))))]
                        (.write baos, (PBKDF2SHA512'f p, s, c, (inc i)))
                    )
                    (catch Exception e
                        (throw (RuntimeException. e))
                    )
                )
                (let [#_"byte[]" bytes (byte-array n)]
                    (System/arraycopy (.toByteArray baos), 0, bytes, 0, n)
                    bytes
                )
            )
        )
    )
)

;;;
 ; Exceptions thrown by the MnemonicCode module.
 ;;
(class-ns MnemonicException (ยง extends RuntimeException)
    (defn #_"MnemonicException" MnemonicException'new
        ([] (MnemonicException'new nil))
        ([#_"String" message]
            (RuntimeException'new message)
        )
    )
)

;;;
 ; Thrown when an argument to MnemonicCode is the wrong length.
 ;;
(class-ns MnemonicLengthException (ยง extends MnemonicException)
    (defn #_"MnemonicLengthException" MnemonicLengthException'new [#_"String" message]
        (MnemonicException'new message)
    )
)

;;;
 ; Thrown when a list of MnemonicCode words fails the checksum check.
 ;;
(class-ns MnemonicChecksumException (ยง extends MnemonicException)
    (defn #_"MnemonicChecksumException" MnemonicChecksumException'new []
        (MnemonicException'new)
    )
)

;;;
 ; Thrown when a word is encountered which is not in the MnemonicCode's word list.
 ;;
(class-ns MnemonicWordException (ยง extends MnemonicException)
    (defn #_"MnemonicWordException" MnemonicWordException'new [#_"String" word]
        (merge (MnemonicException'new)
            (hash-map
                ;;;
                 ; Contains the word that was not found in the word list.
                 ;;
                #_"String" :bad-word word
            )
        )
    )
)

;;;
 ; MnemonicCode may be used to convert between binary seed values and lists of words per
 ; the BIP 39 specification [https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki].
 ;;

(class-ns MnemonicCode
    (def- #_"[String]" MnemonicCode'BIP39_ENGLISH_WORDS
        (vector
            "abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract",
            "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid",
            "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual",
            "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance",
            "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent",
            "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album",
            "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone",
            "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among",
            "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry",
            "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique",
            "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april",
            "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor",
            "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact",
            "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume",
            "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction",
            "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado",
            "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis",
            "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball",
            "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base",
            "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become",
            "beef", "before", "begin", "behave", "behind", "believe", "below", "belt",
            "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle",
            "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black",
            "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood",
            "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body",
            "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring",
            "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain",
            "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief",
            "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother",
            "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb",
            "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus",
            "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable",
            "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can",
            "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable",
            "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry",
            "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog",
            "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling",
            "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk",
            "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap",
            "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child",
            "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar",
            "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify",
            "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff",
            "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud",
            "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut",
            "code", "coffee", "coil", "coin", "collect", "color", "column", "combine",
            "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm",
            "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper",
            "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch",
            "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle",
            "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream",
            "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop",
            "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch",
            "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious",
            "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad",
            "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn",
            "day", "deal", "debate", "debris", "decade", "december", "decide", "decline",
            "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay",
            "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend",
            "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk",
            "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram",
            "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital",
            "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover",
            "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide",
            "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain",
            "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft",
            "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill",
            "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb",
            "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager",
            "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo",
            "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight",
            "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator",
            "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ",
            "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy",
            "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough",
            "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode",
            "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt",
            "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil",
            "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude",
            "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit",
            "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend",
            "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint",
            "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy",
            "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault",
            "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female",
            "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field",
            "figure", "file", "film", "filter", "final", "find", "fine", "finger",
            "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness",
            "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight",
            "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly",
            "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot",
            "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil",
            "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend",
            "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel",
            "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy",
            "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment",
            "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius",
            "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle",
            "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass",
            "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue",
            "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip",
            "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass",
            "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group",
            "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun",
            "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy",
            "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard",
            "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet",
            "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip",
            "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow",
            "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital",
            "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble",
            "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband",
            "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill",
            "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose",
            "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate",
            "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial",
            "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane",
            "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest",
            "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory",
            "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel",
            "job", "join", "joke", "journey", "joy", "judge", "juice", "jump",
            "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup",
            "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit",
            "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know",
            "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language",
            "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law",
            "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave",
            "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend",
            "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty",
            "library", "license", "life", "lift", "light", "like", "limb", "limit",
            "link", "lion", "liquid", "list", "little", "live", "lizard", "load",
            "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop",
            "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber",
            "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet",
            "maid", "mail", "main", "major", "make", "mammal", "man", "manage",
            "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin",
            "marine", "market", "marriage", "mask", "mass", "master", "match", "material",
            "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure",
            "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory",
            "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message",
            "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind",
            "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake",
            "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment",
            "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning",
            "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie",
            "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music",
            "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin",
            "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative",
            "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral",
            "never", "news", "next", "nice", "night", "noble", "noise", "nominee",
            "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice",
            "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey",
            "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean",
            "october", "odor", "off", "offer", "office", "often", "oil", "okay",
            "old", "olive", "olympic", "omit", "once", "one", "onion", "online",
            "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit",
            "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich",
            "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over",
            "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page",
            "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper",
            "parade", "parent", "park", "parrot", "party", "pass", "patch", "path",
            "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut",
            "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper",
            "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical",
            "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot",
            "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet",
            "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge",
            "poem", "poet", "point", "polar", "pole", "police", "pond", "pony",
            "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery",
            "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare",
            "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority",
            "prison", "private", "prize", "problem", "process", "produce", "profit", "program",
            "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide",
            "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil",
            "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle",
            "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz",
            "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail",
            "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid",
            "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real",
            "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle",
            "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject",
            "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove",
            "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report",
            "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire",
            "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib",
            "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid",
            "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road",
            "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room",
            "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude",
            "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness",
            "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same",
            "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say",
            "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science",
            "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea",
            "search", "season", "seat", "second", "secret", "section", "security", "seed",
            "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence",
            "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft",
            "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine",
            "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder",
            "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side",
            "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar",
            "simple", "since", "sing", "siren", "sister", "situate", "six", "size",
            "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab",
            "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan",
            "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth",
            "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social",
            "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve",
            "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup",
            "source", "south", "space", "spare", "spatial", "spawn", "speak", "special",
            "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin",
            "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray",
            "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium",
            "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay",
            "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting",
            "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street",
            "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject",
            "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest",
            "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme",
            "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain",
            "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim",
            "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table",
            "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target",
            "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten",
            "tenant", "tennis", "tent", "term", "test", "text", "thank", "that",
            "theme", "then", "theory", "there", "they", "thing", "this", "thought",
            "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger",
            "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title",
            "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token",
            "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top",
            "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist",
            "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic",
            "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree",
            "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy",
            "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try",
            "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle",
            "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical",
            "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo",
            "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown",
            "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon",
            "upper", "upset", "urban", "urge", "usage", "use", "used", "useful",
            "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley",
            "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle",
            "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very",
            "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view",
            "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual",
            "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote",
            "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want",
            "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave",
            "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding",
            "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat",
            "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife",
            "wild", "will", "win", "window", "wine", "wing", "wink", "winner",
            "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman",
            "wonder", "wood", "wool", "word", "work", "world", "worry", "worth",
            "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year",
            "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo",
        )
    )
    (def- #_"String" MnemonicCode'BIP39_ENGLISH_SHA256 "ad90bf3beb7b0eb7e5acd74727dc0da96e0a280a258354e7293fb7e211ac03db")

    ;;;
     ; Creates a MnemonicCode from the given words.  If a digest is supplied, the words will be checked.
     ;;
    (defn #_"MnemonicCode" MnemonicCode'new [#_"String*" words, #_"String" digest]
        (let [words (vec words)]
            (when-not (= (count words) 2048)
                (throw (IllegalArgumentException. "BIP39 requires exactly 2048 words"))
            )
            (when (some? digest)
                (let [#_"MessageDigest" md (Sha256Hash'create-digest)]
                    (doseq [#_"String" word words]
                        (.update md, (.getBytes word, Charset'UTF-8))
                    )
                    (when-not (= (Base16'encode (.digest md)) digest)
                        (throw (IllegalArgumentException. "words' digest mismatch"))
                    )
                )
            )
            (hash-map
                #_"[String]" :words words
            )
        )
    )

    (def #_"MnemonicCode" MnemonicCode'INSTANCE (MnemonicCode'new MnemonicCode'BIP39_ENGLISH_WORDS, MnemonicCode'BIP39_ENGLISH_SHA256))

    ;;;
     ; UNIX time for when the BIP39 standard was finalised.  This can be used as a default seed birthday.
     ;;
    (def #_"long" MnemonicCode'BIP39_STANDARDISATION_TIME_SECS 1381276800)

    (def- #_"int" MnemonicCode'PBKDF2_ROUNDS 2048)

    ;;;
     ; Convert mnemonic word list to seed.
     ;;
    (defn #_"byte[]" MnemonicCode'to-seed [#_"String*" words, #_"String" passphrase]
        ;; To create binary seed from mnemonic, we use PBKDF2 function with mnemonic sentence (in UTF-8) used as a password
        ;; and string "mnemonic" + passphrase (again in UTF-8) used as a salt.  Iteration count is set to 4096 and HMAC-SHA512
        ;; is used as a pseudo-random function.  Desired length of the derived key is 512 bits (= 64 bytes).

        (let [#_"String" pass (apply str (interpose " " words)) #_"String" salt (str "mnemonic" passphrase)
              #_"Stopwatch" watch (Stopwatch/createStarted)
              #_"byte[]" seed (PBKDF2SHA512'derive pass, salt, MnemonicCode'PBKDF2_ROUNDS, 64)]
            (.stop watch)
            (log/info (str "PBKDF2 took " watch))
            seed
        )
    )

    (defn- #_"[boolean]" MnemonicCode'bytes-to-bits [#_"byte*" bytes]
        (into (vector-of :boolean) (for [#_"byte" b bytes #_"int" i (range 8)] (bit-test b (- 7 i))))
    )

    ;;;
     ; Convert mnemonic word list to original entropy value.
     ;;
    #_throws #_[ "MnemonicLengthException", "MnemonicWordException", "MnemonicChecksumException" ]
    #_method
    (defn #_"byte[]" MnemonicCode''to-entropy [#_"MnemonicCode" this, #_"String*" words]
        (when-not (seq words)
            (throw+ (MnemonicLengthException'new "Word list is empty."))
        )
        (when-not (zero? (rem (count words) 3))
            (throw+ (MnemonicLengthException'new "Word list size must be multiple of three words."))
        )

        ;; Look up all the words in the list and construct the concatenation of the original entropy and the checksum.

        (let [#_"[boolean]" bits
                (loop-when [bits (transient (vector-of :boolean)) words words] (seq words) => (persistent! bits)
                    ;; Find the word's index in the wordlist.
                    (let [#_"String" word (first words) #_"int" at (Collections/binarySearch (:words this), word)]
                        (when (neg? at)
                            (throw+ (MnemonicWordException'new word))
                        )
                        ;; Set the next 11 bits to the value of the index.
                        (recur (reduce conj! bits (map #(bit-test at (- 10 %)) (range 11))) (next words))
                    )
                )
              #_"int" blen (count bits) #_"int" clen (quot blen 33) #_"int" elen (- blen clen)]

            ;; Extract original entropy as bytes.
            (let [#_"byte[]" entropy (byte-array (quot elen 8))]
                (dotimes [#_"int" i (count entropy)]
                    (dotimes [#_"int" j 8]
                        (when (nth bits (+ (* i 8) j))
                            (aset entropy i (| (nth entropy i) (<< 1 (- 7 j))))
                        )
                    )
                )

                ;; Take the digest of the entropy.
                (let [#_"[boolean]" hash (MnemonicCode'bytes-to-bits (Sha256Hash'hash entropy))]

                    ;; Check all the checksum bits.
                    (dotimes [#_"int" i clen]
                        (when-not (= (nth bits (+ elen i)) (nth hash i))
                            (throw+ (MnemonicChecksumException'new))
                        )
                    )

                    entropy
                )
            )
        )
    )

    ;;;
     ; Convert entropy data to mnemonic word list.
     ;;
    #_throws #_[ "MnemonicLengthException" ]
    #_method
    (defn #_"String*" MnemonicCode''to-mnemonic [#_"MnemonicCode" this, #_"byte[]" entropy]
        (when (zero? (count entropy))
            (throw+ (MnemonicLengthException'new "Entropy is empty."))
        )
        (when-not (zero? (rem (count entropy) 4))
            (throw+ (MnemonicLengthException'new "Entropy length not multiple of 32 bits."))
        )

        ;; We take initial entropy of ENT bits and compute its checksum by taking first ENT / 32 bits of its SHA256 hash.

        (let [#_"[boolean]" ents (MnemonicCode'bytes-to-bits entropy)
              #_"[boolean]" hash (MnemonicCode'bytes-to-bits (Sha256Hash'hash entropy))
              ;; We append these bits to the end of the initial entropy.
              #_"[boolean]" bits (catvec ents (subvec hash 0 (quot (count ents) 32)))]

            ;; Next we take these concatenated bits and split them into groups of 11 bits.  Each group encodes number from 0-2047
            ;; which is a position in a wordlist.  We convert numbers into words and use joined words as mnemonic sentence.

            (for [#_"int" i (range (quot (count bits) 11))]
                (nth (:words this) (loop-when-recur [#_"int" x 0 #_"int" j 0] (< j 11) [(| (<< x 1) (if (nth bits (+ (* i 11) j)) 1 0)) (inc j)] => x))
            )
        )
    )
)

;;;
 ; A TransactionSignature wraps an {@link ECKey.ECDSASignature} and adds methods for handling
 ; the additional SIGHASH mode byte that is used.
 ;;
(class-ns TransactionSignature (ยง extends ECDSASignature)
    (defn- #_"TransactionSignature" TransactionSignature'init [#_"int" flags]
        (hash-map
            ;;;
             ; A byte that controls which parts of a transaction are signed.  This is exposed because signatures
             ; parsed off the wire may have sighash flags that aren't "normal" serializations of the enum values.
             ; Because Bitcoin Core works via bit testing, we must not lose the exact value when round-tripping
             ; otherwise we'll fail to verify signature hashes.
             ;;
            #_"int" :sighash-flags flags
        )
    )

    ;;; Constructs a signature with the given components and raw sighash flag bytes (needed for rule compatibility). ;;
    (defn #_"TransactionSignature" TransactionSignature'new
        ([#_"BigInteger" r, #_"BigInteger" s] (TransactionSignature'new r, s, SigHash'ALL))
        ([#_"BigInteger" r, #_"BigInteger" s, #_"int" flags]
            (merge (ECDSASignature'new r, s) (TransactionSignature'init flags))
        )
    )

    ;;; Constructs a transaction signature based on the ECDSA signature. ;;
    (defn #_"TransactionSignature" TransactionSignature'from-ecdsa [#_"ECDSASignature" signature, #_"SigHash" mode, #_"boolean" anyone?]
        (merge (ECDSASignature'new (:r signature), (:s signature)) (TransactionSignature'init (TransactionSignature'calc-sig-hash-value mode, anyone?)))
    )

    ;;;
     ; Returns a dummy invalid signature whose R/S values are set such that they will take up the same number of
     ; encoded bytes as a real signature.  This can be useful when you want to fill out a transaction to be of
     ; the right size (e.g. for fee calculations) but don't have the requisite signing key yet and will fill out
     ; the real signature later.
     ;;
    (defn #_"TransactionSignature" TransactionSignature'dummy []
        (let [#_"BigInteger" i ECKey'HALF_CURVE_ORDER]
            (TransactionSignature'new i, i)
        )
    )

    ;;; Calculates the byte used in the protocol to represent the combination of mode and anyoneCanPay. ;;
    (defn #_"SigHash" TransactionSignature'calc-sig-hash-value [#_"SigHash" mode, #_"boolean" anyone?]
        ;; Enforce compatibility since this code was made before the SigHash enum was updated.
        (assert-argument (any = mode SigHash'ALL SigHash'NONE SigHash'SINGLE))

        (if anyone? (| mode SigHash'ANYONECANPAY) mode)
    )

    ;;;
     ; Returns true if the given signature is has canonical encoding, and will thus be accepted as standard by
     ; Bitcoin Core.  DER and the SIGHASH encoding allow for quite some flexibility in how the same structures
     ; are encoded, and this can open up novel attacks in which a man in the middle takes a transaction and then
     ; changes its signature such that the transaction hash is different but it's still valid.  This can confuse
     ; wallets and generally violates people's mental model of how Bitcoin should work, thus non-canonical
     ; signatures are now not relayed by default.
     ;;
    (defn #_"boolean" TransactionSignature'is-encoding-canonical [#_"byte[]" sig]
        ;; See Bitcoin Core's IsCanonicalSignature, https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623
        ;; A canonical signature exists of: <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>
        ;; Where R and S are not negative (their first byte has its highest bit not set), and not
        ;; excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,
        ;; in which case a single 0 byte is necessary and even required).
        (let [#_"int" len (count sig)]
            (and (<= 9 len 73)
                ;; mask the byte to prevent sign-extension hurting us
                (let [#_"int" mode (& (& (nth sig (dec len)) 0xff) (bit-not SigHash'ANYONECANPAY))]
                    (and (<= SigHash'ALL mode SigHash'SINGLE)
                        ;; "wrong type"                "wrong length marker"
                        (= (& 0xff (nth sig 0)) 0x30) (= (& 0xff (nth sig 1)) (- len 3))
                        (let [#_"int" __lenR (& 0xff (nth sig 3))]
                            (and (< (+ 5 __lenR) len) (not= __lenR 0)
                                (let [#_"int" __lenS (& 0xff (nth sig (+ 5 __lenR)))]
                                    (and (= (+ __lenR __lenS 7) len) (not= __lenS 0)
                                        ;; R value type mismatch    R value negative
                                        (= (nth sig (- 4 2)) 0x02) (not= (& 0x80 (nth sig 4)) 0x80)
                                        ;; R value excessively padded
                                        (or (<= __lenR 1) (not= (nth sig 4) 0x00) (= (& 0x80 (nth sig (+ 4 1))) 0x80))
                                        ;; S value type mismatch            S value negative
                                        (= (nth sig (+ 6 __lenR -2)) 0x02) (not= (& 0x80 (nth sig (+ 6 __lenR))) 0x80)
                                        ;; S value excessively padded
                                        (or (<= __lenS 1) (not= (nth sig (+ 6 __lenR)) 0x00) (= (& 0x80 (nth sig (+ 6 __lenR 1))) 0x80))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (defn #_"boolean" TransactionSignature''anyone-can-pay [#_"TransactionSignature" this]
        (not= (& (:sighash-flags this) SigHash'ANYONECANPAY) 0)
    )

    #_method
    (defn #_"SigHash" TransactionSignature''sig-hash-mode [#_"TransactionSignature" this]
        (let [#_"int" mode (& (:sighash-flags this) 0x1f)]
            (condp = mode SigHash'NONE mode SigHash'SINGLE mode SigHash'ALL)
        )
    )

    ;;;
     ; What we get back from the signer are the two components of a signature, r and s.  To get a flat byte stream
     ; of the type used by Bitcoin we have to encode them using DER encoding, which is just a way to pack the two
     ; components into a structure, and then we append a byte to the end for the sighash flags.
     ;;
    #_method
    (defn #_"byte[]" TransactionSignature''encode-to-bitcoin [#_"TransactionSignature" this]
        (let [#_"ByteArrayOutputStream" baos (ECDSASignature''der-byte-stream this)]
            (.write baos, (:sighash-flags this))
            (.toByteArray baos)
        )
    )

    #_override
    (defn #_"ECDSASignature" ECDSASignature'''to-canonicalised [#_"TransactionSignature" this]
        (TransactionSignature'from-ecdsa (ECDSASignature'''to-canonicalised (ยง this super)), (TransactionSignature''sig-hash-mode this), (TransactionSignature''anyone-can-pay this))
    )

    ;;;
     ; Returns a decoded signature.
     ;
     ; @param requireCanonicalEncoding if the encoding of the signature must be canonical.
     ; @param requireCanonicalSValue if the S-value must be canonical (below half the order of the curve).
     ; @throws RuntimeException if the signature is invalid or unparseable in some way.
     ;;
    #_throws #_[ "VerificationException" ]
    (defn #_"TransactionSignature" TransactionSignature'decode-from-bitcoin [#_"byte[]" bytes, #_"boolean" canon?, #_"boolean" canon-s?]
        ;; Bitcoin encoding is DER signature + sighash byte.
        (when (and canon? (not (TransactionSignature'is-encoding-canonical bytes)))
            (throw+ (VerificationException'new "Signature encoding is not canonical."))
        )

        (let [#_"ECDSASignature" sig
                (try
                    (ECDSASignature'decode-from-der bytes)
                    (catch IllegalArgumentException e
                        (throw+ (VerificationException'new "Could not decode DER") e)
                    )
                )]
            (when (and canon-s? (not (ECDSASignature''is-canonical sig)))
                (throw+ (VerificationException'new "S-value is not canonical."))
            )

            ;; In Bitcoin, any value of the final byte is valid, but not necessarily canonical.  See javadocs
            ;; for isEncodingCanonical to learn more about this.  So we must store the exact byte found.
            (TransactionSignature'new (:r sig), (:s sig), (nth bytes (dec (count bytes))))
        )
    )
)

(ยง ns bitclojn.kits
    (:refer-clojure :exclude [ensure subvec sync vec vector vector-of when when-not])
    (:use [bitclojn slang])
)

;;;
 ; Utility class that wraps the boilerplate needed to set up a new SPV bitcoinj app.  Instantiate it with a directory
 ; and file prefix, optionally configure a few things, then use startAsync and optionally awaitRunning.  The object will
 ; construct and configure a {@link SPVBlockChain}, {@link SPVBlockStore}, {@link Wallet} and {@link PeerGroup}.  Depending
 ; on the value of the blockingStartup property, startup will be considered complete once the block chain has fully
 ; synchronized, so it can take a while.
 ;
 ; To add listeners and modify the objects that are constructed, you can either do that by overriding the
 ; {@link #onSetupCompleted()} method (which will run on a background thread) and make your changes there,
 ; or by waiting for the service to start and then accessing the objects from wherever you want.  However, you cannot
 ; access the objects this class creates until startup is complete.
 ;
 ; The asynchronous design of this class may seem puzzling (just use {@link #awaitRunning()} if you don't want that).
 ; It is to make it easier to fit bitcoinj into GUI apps, which require a high degree of responsiveness on their main
 ; thread which handles all the animation and user interaction.  Even when blockingStart is false, initializing bitcoinj
 ; means doing potentially blocking file IO, generating keys and other potentially intensive operations.  By running it
 ; on a background thread, there's no risk of accidentally causing UI lag.
 ;
 ; Note that {@link #awaitRunning()} can throw an unchecked {@link IllegalStateException}
 ; if anything goes wrong during startup - you should probably handle it and use {@link Exception#getCause()} to figure
 ; out what went wrong more precisely.  Same thing if you just use the {@link #startAsync()} method.
 ;;
(class-ns WalletAppKit (ยง extends AbstractIdleService)
    ;;;
     ; Creates a new WalletAppKit.
     ;;
    (defn #_"WalletAppKit" WalletAppKit'new [#_"Ledger" ledger, #_"File" directory, #_"String" prefix]
        (merge (ยง super AbstractIdleService'new)
            (hash-map
                #_"Ledger" :ledger (ensure some? ledger)

                #_"File" :directory (ensure some? directory)
                #_"String" :file-prefix (ensure some? prefix)

                #_volatile
                #_"SPVBlockChain" :v-chain nil
                #_volatile
                #_"BlockStore" :v-store nil
                #_volatile
                #_"Wallet" :v-wallet nil
                #_volatile
                #_"PeerGroup" :v-peer-group nil

                #_"PeerAddress[]" :peer-addresses nil
                ;;;
                 ; If you want to learn about the sync process, you can provide a listener here.
                 ; For instance, a {@link DownloadProgressTracker} is a good choice.  This has no effect unless
                 ; setBlockingStartup(false) has been called too, due to some missing implementation code.
                 ;;
                #_"DownloadProgressTracker" :download-listener nil
                ;;;
                 ; If true, will register a shutdown hook to stop the library.
                 ;;
                #_"boolean" :auto-stop true
                #_"String*" :textual-checkpoints nil
                ;;;
                 ; If true, the startup of this service won't be considered complete until the network has been
                 ; brought up, peer connections established and the block chain synchronised.  Therefore 'await-running
                 ; can potentially take a very long time.  If false, startup is considered complete once
                 ; the network activity begins and peer connections/block chain sync will continue in the background.
                 ;;
                #_"boolean" :blocking-startup true
                ;;;
                 ; The peer discovery to use.  If none is provided, DNS is used, which is a reasonable default.
                 ;;
                #_"PeerDiscovery" :discovery nil
            )
        )
    )

    ;;;
     ; Will only connect to the given addresses.  Cannot be called after startup.
     ;;
    #_method
    (defn #_"WalletAppKit" WalletAppKit''set-peer-nodes [#_"WalletAppKit" this & #_"PeerAddress..." addresses]
        (assert-state (= (.state this) :KeyChainState'NEW), "Cannot call after startup")

        (assoc this :peer-addresses addresses)
    )

    ;;;
     ; Will only connect to loopback.  Cannot be called after startup.
     ;;
    #_method
    (defn #_"WalletAppKit" WalletAppKit''connect-to-loopback [#_"WalletAppKit" this]
        (try
            (let [#_"InetAddress" loopback (InetAddress/getLoopbackAddress)]
                (WalletAppKit''set-peer-nodes this, (PeerAddress'from-inet-port (:ledger this), loopback, (-> this :ledger :port)))
            )
            (catch UnknownHostException e
                ;; Borked machine with no loopback adapter configured properly.
                (throw (RuntimeException. e))
            )
        )
    )

    ;;;
     ; If set, the file is expected to contain a checkpoints file calculated with BuildCheckpoints.
     ; It makes initial block sync faster for new users - please refer to the documentation on the
     ; bitcoinj website (https://bitcoinj.github.io/speeding-up-chain-sync) for further details.
     ;;
    #_method
    (defn #_"WalletAppKit" WalletAppKit''set-checkpoints [#_"WalletAppKit" this, #_"String*" checkpoints]
        (assoc this :textual-checkpoints (ensure some? checkpoints))
    )

    ;;;
     ; Override this to use a {@link BlockStore} that isn't the default of {@link SPVBlockStore}.
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_method
    (defn #_"BlockStore" WalletAppKit''provide-block-store [#_"WalletAppKit" this, #_"File" file]
        (SPVBlockStore'new (:ledger this), file)
    )

    ;;;
     ; This method is invoked on a background thread after all objects are initialised, but before the peer group
     ; or block chain download is started.  You can tweak the objects configuration here.
     ;;
    #_method
    (defn #_"void" WalletAppKit''on-setup-completed [#_"WalletAppKit" __]
        nil
    )

    #_throws #_[ "Exception" ]
    #_foreign
    #_override
    (defn #_"void" AbstractIdleService'''startUp [#_"WalletAppKit" this]
        (when (and (not (.exists (:directory this))) (not (.mkdirs (:directory this))))
            (throw (IOException. (str "Could not create directory " (.getAbsolutePath (:directory this)))))
        )

        (log/info (str "Starting up with directory = " (:directory this)))
        ;; Runs in a separate thread.
        (try+
            (let [#_"File" __chainFile (File. (:directory this), (str (:file-prefix this) ".spvchain"))
                  #_"boolean" __chainFileExists (.exists __chainFile)
                  #_"Wallet" wallet (WalletAppKit''create-wallet this)
                  _ (Wallet''fresh-receive-key wallet)
                  this (assoc this :v-wallet wallet)
                  ;; Initiate Bitcoin network objects (block store, blockchain and peer group).
                  this (assoc this :v-store (WalletAppKit''provide-block-store this, __chainFile))
                  this
                    (when-not __chainFileExists => this
                        (let [this
                                (when (nil? (:textual-checkpoints this)) => this
                                    (assoc this :textual-checkpoints (-> this :ledger :textual-checkpoints))
                                )]
                            (cond (some? (:textual-checkpoints this))
                                ;; Initialize the chain file with a checkpoint to speed up first-run sync.
                                (let [#_"long" time (Wallet''get-earliest-key-creation-time (:v-wallet this))]
                                    (if (pos? time)
                                        (CheckpointManager'checkpoint (:ledger this), (:textual-checkpoints this), (:v-store this), time)
                                        (log/warn "Creating a new uncheckpointed block store due to a wallet with a creation time of zero: this will result in a very slow chain sync.")
                                    )
                                    this
                                )
                                __chainFileExists
                                (let [this (update this :v-store BlockStore'''close)]
                                    (log/info "Deleting the chain file in preparation from restore.")
                                    (when-not (.delete __chainFile)
                                        (throw (IOException. "Failed to delete chain file in preparation for restore."))
                                    )
                                    (assoc this :v-store (SPVBlockStore'new (:ledger this), __chainFile))
                                )
                                :else
                                (do
                                    this
                                )
                            )
                        )
                    )
                  this (assoc this :v-chain (SPVBlockChain'new (:ledger this), (:v-store this)))
                  this (assoc this :v-peer-group (WalletAppKit''create-peer-group this))
                  ;; Set up peer addresses or discovery first, so if wallet extensions try to broadcast a transaction
                  ;; before we're actually connected the broadcast waits for an appropriate number of connections.
                  this
                    (if (some? (:peer-addresses this))
                        (let [this (update this :v-peer-group #(reduce PeerGroup''add-address-p % (:peer-addresses this)))
                              this (update this :v-peer-group PeerGroup''set-max-connections (count (:peer-addresses this)))]
                            (assoc this :peer-addresses nil)
                        )
                        (update this :v-peer-group PeerGroup''add-peer-discovery (or (:discovery this) (DnsDiscovery'new (:ledger this))))
                    )
                  this (update this :v-chain BlockChain''add-wallet (:v-wallet this))
                  this (update this :v-peer-group PeerGroup''add-wallet (:v-wallet this))]

                (WalletAppKit''on-setup-completed this)

                (if (:blocking-startup this)
                    (do
                        (PeerGroup''start (:v-peer-group this))
                        ;; Make sure we shut down cleanly.
                        (WalletAppKit''install-shutdown-hook this)

                        ;; TODO: Be able to use the provided download listener when doing a blocking startup.
                        (let [#_"DownloadProgressTracker" tracker (DownloadProgressTracker'new)]
                            (ยง ass this (update this :v-peer-group PeerGroup''start-block-chain-download tracker))
                            (DownloadProgressTracker''await tracker)
                        )
                    )
                    (Futures/addCallback (PeerGroup''start-async (:v-peer-group this)),
                        (reify FutureCallback
                            #_foreign
                            #_override
                            (#_"void" onSuccess [#_"FutureCallback" __, #_"Object" _result]
                                (let [#_"DownloadProgressTracker" listener (or (:download-listener this) (DownloadProgressTracker'new))]
                                    (ยง ass this (update this :v-peer-group PeerGroup''start-block-chain-download listener))
                                )
                                nil
                            )

                            #_foreign
                            #_override
                            (#_"void" onFailure [#_"FutureCallback" __, #_"Throwable" t]
                                (throw (RuntimeException. t))
                            )
                        )
                    )
                )
                (ยง non-void this)
            )
            (ยง catch BlockStoreException e
                (throw (IOException. e))
            )
        )
        nil
    )

    #_method
    (defn #_"Wallet" WalletAppKit''create-wallet [#_"WalletAppKit" this]
        (Wallet'new (:ledger this))
    )

    #_throws #_[ "TimeoutException" ]
    #_method
    (defn #_"PeerGroup" WalletAppKit''create-peer-group [#_"WalletAppKit" this]
        (PeerGroup'new (:ledger this), (:v-chain this))
    )

    #_method
    (defn- #_"void" WalletAppKit''install-shutdown-hook [#_"WalletAppKit" this]
        (when (:auto-stop this)
            (.addShutdownHook (Runtime/getRuntime),
                (Thread.
                    #(try
                        (PeerGroup''stop-async this)
                        (PeerGroup''await-terminated this)
                        (catch Exception e
                            (throw (RuntimeException. e))
                        )
                    )
                )
            )
        )
        nil
    )

    #_throws #_[ "Exception" ]
    #_foreign
    #_override
    (defn #_"void" AbstractIdleService'''shutDown [#_"WalletAppKit" this]
        ;; Runs in a separate thread.
        (try+
            (PeerGroup''stop (:v-peer-group this))
            (Wallet''save (:v-wallet this))
            (let [this (update this :v-store BlockStore'''close)]
                (ยง non-void (assoc this :v-peer-group nil, :v-wallet nil, :v-store nil, :v-chain nil))
            )
            (ยง catch BlockStoreException e
                (throw (IOException. e))
            )
        )
        nil
    )

    #_method
    (defn #_"SPVBlockChain" WalletAppKit''chain [#_"WalletAppKit" this]
        (assert-state (any = (.state this) :KeyChainState'STARTING :KeyChainState'RUNNING), "Cannot call until startup is complete")
        (:v-chain this)
    )

    #_method
    (defn #_"BlockStore" WalletAppKit''store [#_"WalletAppKit" this]
        (assert-state (any = (.state this) :KeyChainState'STARTING :KeyChainState'RUNNING), "Cannot call until startup is complete")
        (:v-store this)
    )

    #_method
    (defn #_"Wallet" WalletAppKit''wallet [#_"WalletAppKit" this]
        (assert-state (any = (.state this) :KeyChainState'STARTING :KeyChainState'RUNNING), "Cannot call until startup is complete")
        (:v-wallet this)
    )

    #_method
    (defn #_"PeerGroup" WalletAppKit''peer-group [#_"WalletAppKit" this]
        (assert-state (any = (.state this) :KeyChainState'STARTING :KeyChainState'RUNNING), "Cannot call until startup is complete")
        (:v-peer-group this)
    )
)

(ยง ns bitclojn.net
    (:refer-clojure :exclude [ensure subvec sync vec vector vector-of when when-not])
    (:use [bitclojn slang])
)

;;;
 ; A generic interface for an object which keeps track of a set of open client connections, creates new ones and
 ; ensures they are serviced properly.
 ;
 ; When the service is {@link com.google.common.util.concurrent.Service#stop()}ed, all connections will be closed
 ; and the appropriate connectionClosed() calls must be made.
 ;;
(defprotocol ClientConnectionManager #_(ยง extends Service)
    ;;;
     ; Creates a new connection to the given address, with the given connection used to handle incoming data.  Any errors
     ; that occur during connection will be returned in the given future, including errors that can occur immediately.
     ;;
    #_abstract
    (#_"ListenableFuture<SocketAddress>" ClientConnectionManager'''open-connection [#_"ClientConnectionManager" this, #_"SocketAddress" __serverAddress, #_"StreamConnection" connection])

    ;;; Gets the number of connected peers. ;;
    #_abstract
    (#_"int" ClientConnectionManager'''get-connected-client-count [#_"ClientConnectionManager" this])

    ;;; Closes n peer connections. ;;
    #_abstract
    (#_"void" ClientConnectionManager'''close-connections [#_"ClientConnectionManager" this, #_"int" n])
)

;;;
 ; A target to which messages can be written/connection can be closed.
 ;;
(defprotocol MessageWriteTarget
    ;;;
     ; Writes the given bytes to the remote server.
     ;;
    #_throws #_[ "IOException" ]
    #_abstract
    (#_"MessageWriteTarget" MessageWriteTarget'''write-bytes [#_"MessageWriteTarget" this, #_"byte[]" message])
    ;;;
     ; Closes the connection to the server, triggering the {@link StreamConnection#connectionClosed()}
     ; event on the network-handling thread where all callbacks occur.
     ;;
    #_abstract
    (#_"MessageWriteTarget" MessageWriteTarget'''close-connection [#_"MessageWriteTarget" this])
)

;;;
 ; A base class which provides basic support for socket timeouts.  It is used instead of integrating timeouts into the
 ; NIO select thread both for simplicity and to keep code shared between NIO and blocking sockets as much as possible.
 ;;
#_abstract
(class-ns AbstractTimeoutHandler
    ;; A timer which manages expiring channels as their timeouts occur (if configured).
    (def- #_"Timer" AbstractTimeoutHandler'TIMEOUT_TIMER (Timer. "AbstractTimeoutHandler timeouts", true))

    (defn #_"AbstractTimeoutHandler" AbstractTimeoutHandler'new []
        (hash-map
            ;; TimerTask and timeout value which are added to a timer to kill the connection on timeout.
            #_"TimerTask" :timeout-task nil
            #_"long" :timeout-millis 0
            #_"boolean" :timeout-enabled true
        )
    )

    ;;;
     ; Enables or disables the timeout entirely.  This may be useful if you want to store the timeout value
     ; but wish to temporarily disable/enable timeouts.
     ;
     ; The default is for timeoutEnabled to be true but timeoutMillis to be set to 0 (i.e. disabled).
     ;
     ; This call will reset the current progress towards the timeout.
     ;;
    #_method
    (defn #_"AbstractTimeoutHandler" AbstractTimeoutHandler''set-timeout-enabled [#_"AbstractTimeoutHandler" this, #_"boolean" enabled?]
        (sync this
            (let [this (assoc this :timeout-enabled enabled?)]
                (AbstractTimeoutHandler''reset-timeout this)
            )
        )
    )

    ;;;
     ; Sets the receive timeout to the given number of milliseconds, automatically killing the connection
     ; if no messages are received for this long.
     ;
     ; A timeout of 0 is interpreted as no timeout.
     ;
     ; The default is for timeoutEnabled to be true but timeoutMillis to be set to 0 (i.e. disabled).
     ;
     ; This call will reset the current progress towards the timeout.
     ;;
    #_method
    (defn #_"AbstractTimeoutHandler" AbstractTimeoutHandler''set-socket-timeout [#_"AbstractTimeoutHandler" this, #_"int" millis]
        (sync this
            (let [this (assoc this :timeout-millis millis)]
                (AbstractTimeoutHandler''reset-timeout this)
            )
        )
    )

    ;;;
     ; Resets the current progress towards timeout to 0.
     ;;
    #_method
    (defn #_"AbstractTimeoutHandler" AbstractTimeoutHandler''reset-timeout [#_"AbstractTimeoutHandler" this]
        (sync this
            (when (some? (:timeout-task this))
                (.cancel (:timeout-task this))
            )
            (when (and (not= (:timeout-millis this) 0) (:timeout-enabled this)) => this
                (let [this
                        (assoc this :timeout-task
                            (ยง reify TimerTask
                                #_foreign
                                #_override
                                (#_"void" run [#_"TimerTask" __]
                                    (ยง ass this (AbstractTimeoutHandler'''timeout-occurred this))
                                    nil
                                )
                            )
                        )]
                    (.schedule AbstractTimeoutHandler'TIMEOUT_TIMER, (:timeout-task this), (:timeout-millis this))
                    this
                )
            )
        )
    )

    #_abstract
    (defn #_"AbstractTimeoutHandler" AbstractTimeoutHandler'''timeout-occurred [#_"AbstractTimeoutHandler" this])
)

;; TODO: The locking in all this class is horrible and not really necessary.  We should just run all network stuff on one thread.

;;;
 ; A simple NIO MessageWriteTarget which handles all the business logic of a connection (reading+writing bytes).
 ; Used only by the NioClient and NioServer classes.
 ;;
(class-ns ConnectionHandler (ยง implements MessageWriteTarget)
    (def- #_"int" ConnectionHandler'BUFFER_SIZE_LOWER_BOUND 4096)
    (def- #_"int" ConnectionHandler'BUFFER_SIZE_UPPER_BOUND 65536)

    (def- #_"int" ConnectionHandler'OUTBOUND_BUFFER_BYTE_COUNT (+ Message'MAX_SIZE 24)) ;; 24 byte message header

    (defn- #_"ConnectionHandler" ConnectionHandler'new-2c [#_"StreamConnection" connection, #_"SelectionKey" key]
        (let [this
                (hash-map
                    ;; We lock when touching local flags and when writing data, but NEVER when calling any methods
                    ;; which leave this class into non-Java classes.
                    #_"Object" :connection-lock (Object.)

                    #_"SelectionKey" :key key
                    #_"SocketChannel" :channel (ensure some? (cast SocketChannel (.channel key)))

                    #_"StreamConnection" :connection nil
                    #_"ByteBuffer" :read-buff nil

                    #_"boolean" :close-called false
                    #_"long" :bytes-to-write-remaining 0
                    #_"LinkedList<ByteBuffer>" :bytes-to-write (LinkedList.)

                    #_"Set<ConnectionHandler>" :connected-handlers nil
                )]

            (when (some? connection) => this
                (let [#_"int" size (min (max ConnectionHandler'BUFFER_SIZE_LOWER_BOUND (StreamConnection'''get-max-message-size connection)) ConnectionHandler'BUFFER_SIZE_UPPER_BOUND)
                      this (assoc this :connection connection, :read-buff (ByteBuffer/allocateDirect size))]
                    (ยง ass connection (StreamConnection'''set-write-target connection, this)) ;; May callback into us (e.g. closeConnection() now).
                    (assoc this :connected-handlers nil)
                )
            )
        )
    )

    #_throws #_[ "IOException" ]
    (defn #_"ConnectionHandler" ConnectionHandler'new-2f [#_"StreamConnectionFactory" factory, #_"SelectionKey" key]
        (let [#_"Socket" socket (.socket (cast SocketChannel (.channel key)))
              this (ConnectionHandler'new-2c (StreamConnectionFactory'''get-new-connection factory, (.getInetAddress socket), (.getPort socket)), key)]
            (when (nil? (:connection this))
                (throw (IOException. "Parser factory.getNewConnection returned nil"))
            )
            this
        )
    )

    (defn #_"ConnectionHandler" ConnectionHandler'new-3 [#_"StreamConnection" connection, #_"SelectionKey" key, #_"Set<ConnectionHandler>" handlers]
        (let [this (ConnectionHandler'new-2c (ensure some? connection), key)]

            ;; closeConnection() may have already happened because we invoked the other c'tor above, which called
            ;; connection.setWriteTarget() which might have re-entered already.  In this case we shouldn't add ourselves
            ;; to the connectedHandlers set.
            (sync (:connection-lock this)
                (let [this (assoc this :connected-handlers handlers)]
                    (when-not (:close-called this) => this
                        (let [? (ยง ass this (update this :connected-handlers .add this))]
                            (assert-state ?)
                            this
                        )
                    )
                )
            )
        )
    )

    #_method
    (defn- #_"void" ConnectionHandler''set-write-ops [#_"ConnectionHandler" this]
        ;; Make sure we are registered to get updated when writing is available again.
        (.interestOps (:key this), (| (.interestOps (:key this)) SelectionKey/OP_WRITE))
        ;; Refresh the selector to make sure it gets the new interestOps.
        (.wakeup (.selector (:key this)))
        nil
    )

    ;; Tries to write any outstanding write bytes, runs in any thread (possibly unlocked).
    #_throws #_[ "IOException" ]
    #_method
    (defn- #_"ConnectionHandler" ConnectionHandler''try-write-bytes [#_"ConnectionHandler" this]
        (sync (:connection-lock this)
            ;; Iterate through the outbound ByteBuff queue, pushing as much as possible into the OS' network buffer.
            (loop-when [#_"Iterator<ByteBuffer>" it (.iterator (:bytes-to-write this))] (.hasNext it)
                (let [#_"ByteBuffer" buff (.next it)]
                    (ยง ass this (assoc this :bytes-to-write-remaining (- (:bytes-to-write-remaining this) (.write (:channel this), buff))))
                    (when-not (.hasRemaining buff) => (ConnectionHandler''set-write-ops this)
                        (.remove it)
                        (recur it)
                    )
                )
            )
            ;; If we are done writing, clear the OP_WRITE interestOps.
            (when (empty? (:bytes-to-write this))
                (.interestOps (:key this), (& (.interestOps (:key this)) (bit-not SelectionKey/OP_WRITE)))
            )
            ;; Don't bother waking up the selector here, since we're just removing an op, not adding.
            this
        )
    )

    #_throws #_[ "IOException" ]
    #_override
    (defn #_"ConnectionHandler" MessageWriteTarget'''write-bytes [#_"ConnectionHandler" this, #_"byte[]" message]
        (let [#_"boolean'" unlock? (atom true)]
            (.lock (:connection-lock this))
            (try
                ;; Network buffers are not unlimited (and are often smaller than some messages we may wish to send), and
                ;; thus we have to buffer outbound messages sometimes.  To do this, we use a queue of ByteBuffers and just
                ;; append to it when we want to send a message.  We then let tryWriteBytes() either send the message or
                ;; register our SelectionKey to wakeup when we have free outbound buffer space available.
                (when (< ConnectionHandler'OUTBOUND_BUFFER_BYTE_COUNT (+ (:bytes-to-write-remaining this) (count message)))
                    (throw (IOException. "Outbound buffer overflowed"))
                )

                ;; Just dump the message onto the write buffer and call tryWriteBytes.
                ;; TODO: Kill the needless message duplication when the write completes right away.
                (.offer (:bytes-to-write this), (ByteBuffer/wrap (Arrays/copyOf message, (count message))))
                (let [this (update this :bytes-to-write-remaining + (count message))]
                    (ConnectionHandler''set-write-ops this)
                    this
                )
                (catch IOException e
                    (.unlock (:connection-lock this))
                    (reset! unlock? false)
                    (log/warn e, "Error writing message to connection, closing connection")
                    (ยง ass this (MessageWriteTarget'''close-connection this))
                    (throw e)
                )
                (catch CancelledKeyException e
                    (.unlock (:connection-lock this))
                    (reset! unlock? false)
                    (log/warn e, "Error writing message to connection, closing connection")
                    (ยง ass this (MessageWriteTarget'''close-connection this))
                    (throw (IOException. e))
                )
                (finally
                    (when @unlock?
                        (.unlock (:connection-lock this))
                    )
                )
            )
        )
    )

    ;; May NOT be called with lock held.
    #_override
    (defn #_"ConnectionHandler" MessageWriteTarget'''close-connection [#_"ConnectionHandler" this]
        (assert-state (not (.isHeldByCurrentThread (:connection-lock this))))
        (try
            (.close (:channel this))
            (catch IOException e
                (throw (RuntimeException. e))
            )
        )
        (ConnectionHandler''connection-closed this)
    )

    #_method
    (defn- #_"ConnectionHandler" ConnectionHandler''connection-closed [#_"ConnectionHandler" this]
        (let [[this #_"boolean" called?]
                (sync (:connection-lock this)
                    (let [called? (:close-called this)]
                        [(assoc this :close-called true) called?]
                    )
                )]
            (when-not called? => this
                (let [#_"boolean" removed? (or (nil? (:connected-handlers this)) (ยง ass this (update this :connected-handlers .remove this)))]
                    (assert-state removed?)
                    (update this :connection StreamConnection'''connection-closed)
                )
            )
        )
    )

    ;; Handle a SelectionKey which was selected.
    ;; Runs unlocked as the caller is single-threaded (or if not, should enforce that handleKey is only called
    ;; atomically for a given ConnectionHandler).
    (defn #_"void" ConnectionHandler'handle-key [#_"SelectionKey" key]
        (when-let [#_"ConnectionHandler" handler (cast' ConnectionHandler (.attachment key))]
            (try
                ;; Else the key has been cancelled, make sure the socket gets closed.
                (when (.isValid key) => (ยง ass handler (MessageWriteTarget'''close-connection handler))
                    (or
                        (when (.isReadable key)
                            ;; Do a socket read and invoke the connection's receiveBytes message.
                            (let [#_"int" n (.read (:channel handler), (:read-buff handler))]
                                (condp = n
                                    0 ;; Was probably waiting on a write.
                                        :abort
                                    -1 ;; Socket was closed.
                                    (do
                                        (.cancel key)
                                        (ยง ass handler (MessageWriteTarget'''close-connection handler))
                                        :abort
                                    )
                                    (do
                                        (.flip (:read-buff handler))
                                        ;; Use connection.receiveBytes's return value as a check that it stopped reading at the right location.
                                        (let [#_"int" m (StreamConnection'''receive-bytes (ensure some? (:connection handler)), (:read-buff handler))]
                                            (assert-state (= (.position (:read-buff handler)) m))
                                            ;; Now drop the bytes which were read by compacting readBuff (resetting limit and keeping relative position).
                                            (.compact (:read-buff handler))
                                        )
                                        nil
                                    )
                                )
                            )
                        )
                        (when (.isWritable key)
                            (ยง ass handler (ConnectionHandler''try-write-bytes handler))
                        )
                    )
                )
                (catch Exception e
                    ;; This can happen e.g. if the channel closes while the thread is about to get killed
                    ;; (ClosedByInterruptException), or if handler.connection.receiveBytes throws something.
                    (log/warn e, (str "Error handling SelectionKey: " (Throwables/getRootCause e)))
                    (ยง ass handler (MessageWriteTarget'''close-connection handler))
                )
            )
        )
        nil
    )
)

;;;
 ; A reusable object that will calculate, given a list of {@link PeerFilterProvider}s, a merged {@link BloomFilter}
 ; and earliest key time for all of them.  Used by the {@link PeerGroup} class internally.
 ;
 ; Thread safety: threading here can be complicated.  Each filter provider is given a begin event, which may acquire
 ; a lock (and is guaranteed to receive an end event).  This class is mostly thread unsafe and is meant to be used from
 ; a single thread only, PeerGroup ensures this by only accessing it from the dedicated PeerGroup thread.  PeerGroup
 ; does not hold any locks whilst this object is used, relying on the single thread to prevent multiple filters being
 ; calculated in parallel, thus a filter provider can do things like make blocking calls into PeerGroup from a separate
 ; thread.  However the bloomFilterFPRate property IS thread safe, for convenience.
 ;;
(class-ns FilterMerger
    (defn #_"FilterMerger" FilterMerger'new [#_"Ledger" ledger, #_"double" rate]
        (hash-map
            #_"Ledger" :ledger ledger

            ;; We use a constant tweak to avoid giving up privacy when we regenerate our filter with new keys.
            #_"long" :merger-tweak (long (* (Math/random) Long/MAX_VALUE))

            #_volatile
            #_"double" :v-merger-fp-rate rate

            #_transient
            #_"long" :earliest-key-time-secs nil

            #_"int" :merger-size 0
            #_"BloomFilter" :merged-filter nil
        )
    )

    #_method
    (defn #_"FilterMerger" FilterMerger''calculate [#_"FilterMerger" this, #_"Wallet*" wallets]
        (let [#_"List<Wallet>" __begunWallets (LinkedList.)]
            (try
                ;; All providers must be in a consistent, unchanging state because the filter is a merged one that's
                ;; large enough for all providers elements: if a provider were to get more elements in the middle of the
                ;; calculation, we might assert or calculate the filter wrongly.  Most providers use a lock here but
                ;; snapshotting required state is also a legitimate strategy.
                (doseq [#_"Wallet" wallet wallets]
                    (Wallet''lock-bloom-filter-calculation wallet)
                    (ยง ass __begunWallets (.add __begunWallets, wallet))
                )
                (let [[#_"long" earliest #_"int" elements]
                        (reduce (fn [[earliest elements] wallet]
                                [(min earliest (Wallet''get-earliest-key-creation-time wallet))
                                 (+   elements (KeyChainGroup''count-bloom-filter-elements (:key-chain-group wallet)) (count (Wallet''bloom-filter-outpoints-locked wallet)))])
                            [Long/MAX_VALUE 0] wallets)
                      ;; Adjust the earliest key time backwards by a week to handle the case of clock drift.  This can occur
                      ;; both in block header timestamps and if the users clock was out of sync when the key was first created
                      ;; (to within a small amount of tolerance).
                      this (assoc this :earliest-key-time-secs (- earliest (* 7 24 60 60)))]
                    (when (pos? elements) => this
                        ;; We stair-step our element count so that we avoid creating a filter with different parameters
                        ;; as much as possible as that results in a loss of privacy.
                        ;; The constant 100 here is somewhat arbitrary, but makes sense for small to medium wallets -
                        ;; it will likely mean we never need to create a filter with different parameters.
                        (let [this (update this :merger-size #(if (< % elements) (+ elements 100) %))
                              #_"int" size (:merger-size this)
                              #_"double" rate (:v-merger-fp-rate this)
                              #_"long" tweak (:merger-tweak this)
                              #_"BloomFilter" filter (BloomFilter'new (:ledger this), size, rate, tweak, :BloomUpdate'UPDATE_P2PUBKEY_ONLY)
                              filter (reduce BloomFilter''merge filter (map #(Wallet''create-bloom-filter-locked %, size, rate, tweak) wallets))]
                            (assoc this :merged-filter filter)
                        )
                    )
                )
                (finally
                    (doseq [#_"Wallet" wallet __begunWallets]
                        (Wallet''unlock-bloom-filter-calculation wallet)
                    )
                )
            )
        )
    )
)

#_non-static #_"NioClient"
(class-ns NioClientHandler (ยง extends AbstractTimeoutHandler) (ยง implements StreamConnection)
    (defn #_"NioClientHandler" NioClientHandler'new [#_"StreamConnection" upstream, #_"int" timeout]
        (let [this
                (merge (AbstractTimeoutHandler'new)
                    (hash-map
                        #_"StreamConnection" :upstream-connection upstream
                        #_"MessageWriteTarget" :write-target nil
                        #_"boolean" :close-on-open false
                        #_"boolean" :close-called false
                    )
                )]
            (-> this (AbstractTimeoutHandler''set-socket-timeout timeout) (AbstractTimeoutHandler''set-timeout-enabled true))
        )
    )

    #_override
    (defn #_"NioClientHandler" AbstractTimeoutHandler'''timeout-occurred [#_"NioClientHandler" this]
        (sync this
            (let [this (assoc this :close-on-open true)]
                (StreamConnection'''connection-closed this)
            )
        )
    )

    #_override
    (defn #_"NioClientHandler" StreamConnection'''connection-closed [#_"NioClientHandler" this]
        (sync this
            (PeerGroup''stop-async (:manager this))
            (when-not (:close-called this) => this
                (let [this (assoc this :close-called true)]
                    (update this :upstream-connection StreamConnection'''connection-closed)
                )
            )
        )
    )

    #_override
    (defn #_"NioClientHandler" StreamConnection'''connection-opened [#_"NioClientHandler" this]
        (sync this
            (when-not (:close-on-open this) => this
                (update this :upstream-connection StreamConnection'''connection-opened)
            )
        )
    )

    #_throws #_[ "Exception" ]
    #_override
    (defn #_"int" StreamConnection'''receive-bytes [#_"NioClientHandler" this, #_"ByteBuffer" buff]
        (StreamConnection'''receive-bytes (:upstream-connection this), buff)
    )

    #_override
    (defn #_"NioClientHandler" StreamConnection'''set-write-target [#_"NioClientHandler" this, #_"MessageWriteTarget" target]
        (sync this
            (if (:close-on-open this)
                (do
                    (ยง ass target (MessageWriteTarget'''close-connection target))
                    this
                )
                (-> this
                    (AbstractTimeoutHandler''set-timeout-enabled false)
                    (assoc :write-target target)
                    (update :upstream-connection StreamConnection'''set-write-target target)
                )
            )
        )
    )

    #_override
    (defn #_"int" StreamConnection'''get-max-message-size [#_"NioClientHandler" this]
        (StreamConnection'''get-max-message-size (:upstream-connection this))
    )
)

;;;
 ; Creates a simple connection to a server using a {@link StreamConnection} to process data.
 ;;
(class-ns NioClient (ยง implements MessageWriteTarget)
    ;;;
     ; Creates a new client to the given server address using the given {@link StreamConnection} to decode the data.
     ; The given connection <b>MUST</b> be unique to this object.  This does not block while waiting for the connection
     ; to open, but will call either the {@link StreamConnection#connectionOpened()} or
     ; {@link StreamConnection#connectionClosed()} callback on the created network event processing thread.
     ;
     ; @param connectTimeoutMillis The connect timeout set on the connection (in milliseconds).
     ;                             0 is interpreted as no timeout.
     ;;
    #_throws #_[ "IOException" ]
    (defn #_"NioClient" NioClient'new [#_"SocketAddress" server, #_"StreamConnection" parser, #_"int" timeout]
        (let [#_"NioClientManager" manager (NioClientManager'new) _ (PeerGroup''start-async manager) _ (PeerGroup''await-running manager)
              #_"NioClientHandler" handler (NioClientHandler'new parser, timeout)]
            (Futures/addCallback (ClientConnectionManager'''open-connection manager, server, handler),
                (reify FutureCallback #_"<SocketAddress>"
                    #_foreign
                    #_override
                    (#_"void" onSuccess [#_"FutureCallback" __, #_"SocketAddress" _address]
                        nil
                    )

                    #_foreign
                    #_override
                    (#_"void" onFailure [#_"FutureCallback" __, #_"Throwable" t]
                        (log/error (str "Connect to " server " failed: " (Throwables/getRootCause t)))
                        nil
                    )
                )
            )
            (hash-map
                #_"NioClientManager" :manager manager
                #_"NioClientHandler" :handler handler
            )
        )
    )

    #_override
    (defn #_"NioClient" MessageWriteTarget'''close-connection [#_"NioClient" this]
        (update-in this [:handler :write-target] MessageWriteTarget'''close-connection)
    )

    #_throws #_[ "IOException" ]
    #_override
    (defn #_"NioClient" MessageWriteTarget'''write-bytes [#_"NioClient" this, #_"byte[]" message]
        (sync this
            (MessageWriteTarget'''write-bytes (-> this :handler :write-target), message)
        )
    )
)

(class-ns PendingConnection
    (defn #_"PendingConnection" PendingConnection'new [#_"SocketChannel" sc, #_"StreamConnection" connection, #_"SocketAddress" address]
        (hash-map
            #_"SocketChannel" :sc sc
            #_"StreamConnection" :connection connection
            #_"SocketAddress" :address address

            #_"SettableFuture<SocketAddress>" :future (SettableFuture/create)
        )
    )
)

;;;
 ; A class which manages a set of client connections.  Uses Java NIO to select network events and processes them
 ; in a single network processing thread.
 ;;
(class-ns NioClientManager (ยง extends AbstractExecutionThreadService) (ยง implements ClientConnectionManager)
    ;;;
     ; Creates a new client manager which uses Java NIO for socket management.
     ; Uses a single thread to handle all select calls.
     ;;
    (defn #_"NioClientManager" NioClientManager'new []
        (merge (ยง super AbstractExecutionThreadService'new)
            (let [#_"Selector" selector
                    (try
                        (.openSelector (SelectorProvider/provider))
                        (catch IOException e
                            (throw (RuntimeException. e)) ;; Shouldn't ever happen.
                        )
                    )]
                (hash-map
                    #_"Selector" :selector selector
                    #_"Queue<PendingConnection>" :new-connection-channels (LinkedBlockingQueue.)
                    ;; Added to/removed from by the individual ConnectionHandler's, thus must by synchronized on its own.
                    #_"Set<ConnectionHandler>" :connected-handlers (Collections/synchronizedSet (HashSet. #_"<ConnectionHandler>"))
                )
            )
        )
    )

    ;; Handle a SelectionKey which was selected.
    #_throws #_[ "IOException" ]
    #_method
    (defn- #_"void" NioClientManager''handle-key [#_"NioClientManager" this, #_"SelectionKey" key]
        ;; We could have a !isValid() key here if the connection is already closed at this point,
        ;; i.e. a client connection which has finished the initial connect process.
        (when (and (.isValid key) (.isConnectable key)) => (ConnectionHandler'handle-key key) ;; Process bytes read.
            ;; Create a ConnectionHandler and hook everything together.
            (let [#_"PendingConnection" data (cast' PendingConnection (.attachment key))
                  #_"StreamConnection" connection (:connection data)
                  #_"SocketChannel" sc (cast SocketChannel (.channel key))
                  #_"ConnectionHandler" handler (ConnectionHandler'new-3 connection, key, (:connected-handlers this))]
                (try
                    (cond (.finishConnect sc)
                        (do
                            (log/info (str "Connected to " (.getRemoteSocketAddress (.socket sc))))
                            (.attach (.interestOps key, (& (| (.interestOps key) SelectionKey/OP_READ) (bit-not SelectionKey/OP_CONNECT))), handler)
                            (ยง ass connection (StreamConnection'''connection-opened connection))
                            (.set (:future data), (:address data))
                        )
                        :else
                        (do
                            (log/warn (str "Failed to connect to " (.getRemoteSocketAddress (.socket sc))))
                            (ยง ass handler (MessageWriteTarget'''close-connection handler)) ;; Failed to connect for some reason.
                            (.setException (:future data), (ConnectException. "Unknown reason"))
                            (ยง ass data (assoc data :future nil))
                        )
                    )
                    (catch Exception e
                        ;; If e is a CancelledKeyException, there is a race to get to interestOps after finishConnect() which
                        ;; may cause this.  Otherwise it may be any arbitrary kind of connection failure.
                        ;; Calling sc.socket().getRemoteSocketAddress() here throws an exception, so we can only log the error itself.
                        (let [#_"Throwable" cause (Throwables/getRootCause e)]
                            (log/warn e, (str "Failed to connect with exception: " (.getName (.getClass cause)) ": " (.getMessage cause)))
                            (ยง ass handler (MessageWriteTarget'''close-connection handler))
                            (.setException (:future data), cause)
                            (ยง ass data (assoc data :future nil))
                        )
                    )
                )
            )
        )
        nil
    )

    #_foreign
    #_override
    (defn #_"void" Runnable'''run [#_"NioClientManager" this]
        (try
            (.setPriority (Thread/currentThread), Thread/MIN_PRIORITY)

            (while (:v-running this)
                (loop []
                    (when-let [#_"PendingConnection" conn (.poll (:new-connection-channels this))]
                        (try
                            (let [#_"SelectionKey" key (.register (:sc conn), (:selector this), SelectionKey/OP_CONNECT)]
                                (.attach key, conn)
                            )
                            (catch ClosedChannelException _
                                (log/warn "SocketChannel was closed before it could be registered")
                            )
                        )
                        (recur)
                    )
                )

                (CoinSelector'''select (:selector this))

                (loop-when-recur [#_"Iterator<SelectionKey>" it (.iterator (.selectedKeys (:selector this)))] (.hasNext it) [it]
                    (let [#_"SelectionKey" key (.next it)]
                        (.remove it)
                        (ConnectionHandler'handle-key key)
                    )
                )
            )
            (catch Exception e
                (log/warn e, "Error trying to open/read from connection")
            )
            (finally
                ;; Go through and close everything, without letting IOExceptions get in our way.
                (doseq [#_"SelectionKey" key (.keys (:selector this))]
                    (try
                        (.close (.channel key))
                        (catch IOException e
                            (log/warn e, "Error closing channel")
                        )
                    )
                    (.cancel key)
                    (when (ยง instance? ConnectionHandler (.attachment key))
                        (ConnectionHandler'handle-key key) ;; Close connection if relevant.
                    )
                )
                (try
                    (.close (:selector this))
                    (catch IOException e
                        (log/warn e, "Error closing client manager selector")
                    )
                )
            )
        )
        nil
    )

    #_override
    (defn #_"ListenableFuture<SocketAddress>" ClientConnectionManager'''open-connection [#_"NioClientManager" this, #_"SocketAddress" server, #_"StreamConnection" connection]
        (when-not (:v-running this)
            (throw (IllegalStateException.))
        )

        ;; Create a new connection, give it a connection as an attachment.
        (try
            (let [#_"SocketChannel" channel (SocketChannel/open)]
                (.configureBlocking channel, false)
                (.connect channel, server)
                (let [#_"PendingConnection" pending (PendingConnection'new channel, connection, server)]
                    (.offer (:new-connection-channels this), pending)
                    (.wakeup (:selector this))
                    (:future pending)
                )
            )
            (catch Throwable e
                (Futures/immediateFailedFuture e)
            )
        )
    )

    #_foreign
    #_override
    (defn #_"void" AbstractExecutionThreadService'''triggerShutdown [#_"NioClientManager" this]
        (.wakeup (:selector this))
        nil
    )

    #_override
    (defn #_"int" ClientConnectionManager'''get-connected-client-count [#_"NioClientManager" this]
        (count (:connected-handlers this))
    )

    #_override
    (defn #_"void" ClientConnectionManager'''close-connections [#_"NioClientManager" this, #_"int" n]
        (dotimes [_ n]
            (let [#_"ConnectionHandler" handler
                    (sync (:connected-handlers this)
                        (.next (.iterator (:connected-handlers this)))
                    )]
                (when (some? handler)
                    (ยง ass handler (MessageWriteTarget'''close-connection handler)) ;; Removes handler from connectedHandlers before returning.
                )
            )
        )
        nil
    )

    #_foreign
    #_override
    (defn #_"Executor" AbstractExecutionThreadService'''executor [#_"NioClientManager" __]
        (reify Executor
            #_foreign
            #_override
            (#_"void" execute [#_"Executor" __, #_"Runnable" runnable]
                (.start (.newThread (DaemonThreadFactory'new "NioClientManager"), runnable))
                nil
            )
        )
    )
)

;;;
 ; Creates a simple server listener which listens for incoming client connections and uses a {@link StreamConnection}
 ; to process data.
 ;;
(class-ns NioServer (ยง extends AbstractExecutionThreadService)
    ;;;
     ; Creates a new server which is capable of listening for incoming connections and processing client provided data
     ; using {@link StreamConnection}s created by the given {@link StreamConnectionFactory}.
     ;
     ; @throws IOException if there is an issue opening the server socket or binding fails for some reason.
     ;;
    #_throws #_[ "IOException" ]
    (defn #_"NioServer" NioServer'new [#_"StreamConnectionFactory" factory, #_"InetSocketAddress" __bindAddress]
        (merge (ยง super AbstractExecutionThreadService'new)
            (let [#_"ServerSocketChannel" sc (ServerSocketChannel/open) _ (.configureBlocking sc, false) _ (.bind (.socket sc), __bindAddress)
                  #_"Selector" selector (.openSelector (SelectorProvider/provider)) _ (.register sc, selector, SelectionKey/OP_ACCEPT)]
                (hash-map
                    #_"StreamConnectionFactory" :connection-factory factory
                    #_"ServerSocketChannel" :sc sc
                    #_testing
                    #_"Selector" :selector selector
                )
            )
        )
    )

    ;; Handle a SelectionKey which was selected.
    #_throws #_[ "IOException" ]
    #_method
    (defn- #_"void" NioServer''handle-key [#_"NioServer" this, #_"Selector" selector, #_"SelectionKey" key]
        ;; Else got a closing channel or a channel to a client connection.
        (when (and (.isValid key) (.isAcceptable key)) => (ConnectionHandler'handle-key key)
            ;; Accept a new connection, give it a stream connection as an attachment.
            (let [#_"SocketChannel" channel (.accept (:sc this)) _ (.configureBlocking channel, false)
                  #_"SelectionKey" key (.register channel, selector, SelectionKey/OP_READ)]
                (try
                    (let [#_"ConnectionHandler" handler (ConnectionHandler'new-2f (:connection-factory this), key)]
                        (.attach key, handler)
                        (ยง ass handler (update handler :connection StreamConnection'''connection-opened))
                    )
                    (catch IOException e
                        ;; This can happen if ConnectionHandler's call to get a new handler returned null.
                        (log/error (Throwables/getRootCause e), "Error handling new connection")
                        (.close (.channel key))
                    )
                )
            )
        )
        nil
    )

    #_throws #_[ "Exception" ]
    #_foreign
    #_override
    (defn #_"void" Runnable'''run [#_"NioServer" this]
        (try
            (while (:v-running this)
                (CoinSelector'''select (:selector this))

                (loop-when-recur [#_"Iterator<SelectionKey>" it (.iterator (.selectedKeys (:selector this)))] (.hasNext it) [it]
                    (let [#_"SelectionKey" key (.next it)]
                        (.remove it)
                        (.handleKey (:selector this), key)
                    )
                )
            )
            (catch Exception e
                (log/error e, "Error trying to open/read from connection")
            )
            (finally
                ;; Go through and close everything, without letting IOExceptions get in our way.
                (doseq [#_"SelectionKey" key (.keys (:selector this))]
                    (try
                        (.close (.channel key))
                        (catch IOException e
                            (log/error e, "Error closing channel")
                        )
                    )
                    (try
                        (.cancel key)
                        (.handleKey (:selector this), key)
                        (catch IOException e
                            (log/error e, "Error closing selection key")
                        )
                    )
                )
                (try
                    (.close (:selector this))
                    (catch IOException e
                        (log/error e, "Error closing server selector")
                    )
                )
                (try
                    (.close (:sc this))
                    (catch IOException e
                        (log/error e, "Error closing server channel")
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Invoked by the Execution service when it's time to stop.
     ; Calling this method directly will NOT stop the service, call
     ; {@link com.google.common.util.concurrent.AbstractExecutionThreadService#stop()} instead.
     ;;
    #_foreign
    #_override
    (defn #_"void" AbstractExecutionThreadService'''triggerShutdown [#_"NioServer" this]
        ;; Wake up the selector and let the selection thread break its loop as the ExecutionService !isRunning().
        (.wakeup (:selector this))
        nil
    )
)

(ยง ns bitclojn.net-discovery
    (:refer-clojure :exclude [ensure subvec sync vec vector vector-of when when-not])
    (:use [bitclojn slang])
)

;;;
 ; A PeerDiscovery object is responsible for finding addresses of other nodes in the Bitcoin P2P network.
 ; Note that the addresses returned may or may not be accepting connections.
 ;;
(defprotocol PeerDiscovery
    ;;;
     ; Returns an array of addresses.  This method may block.
     ;
     ; @param services Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     ;;
    #_throws #_[ "PeerDiscoveryException" ]
    #_abstract
    (#_"InetSocketAddress*" PeerDiscovery'''get-peers [#_"PeerDiscovery" this, #_"long" services, #_"long" timeout, #_"TimeUnit" unit])

    ;;;
     ; Stops any discovery in progress when we want to shut down quickly.
     ;;
    #_abstract
    (#_"void" PeerDiscovery'''shutdown [#_"PeerDiscovery" this])
)

;;;
 ; Implements discovery from a single DNS host.
 ;;
(class-ns DnsSeedDiscovery (ยง implements PeerDiscovery)
    (defn #_"DnsSeedDiscovery" DnsSeedDiscovery'new [#_"Ledger" ledger, #_"String" hostname]
        (hash-map
            #_"Ledger" :ledger ledger
            #_"String" :hostname hostname
        )
    )

    #_throws #_[ "PeerDiscoveryException" ]
    #_override
    (defn #_"InetSocketAddress*" PeerDiscovery'''get-peers [#_"DnsSeedDiscovery" this, #_"long" services, #_"long" _timeout, #_"TimeUnit" _unit]
        (when-not (zero? services)
            (throw+ (PeerDiscoveryException'new (str "DNS seeds cannot filter by services: " services)))
        )
        (try
            (let [#_"int" port (-> this :ledger :port)]
                (map #(InetSocketAddress. %, port) (InetAddress/getAllByName (:hostname this)))
            )
            (catch UnknownHostException e
                (throw+ (PeerDiscoveryException'new) e)
            )
        )
    )

    #_override
    (defn #_"void" PeerDiscovery'''shutdown [#_"DnsSeedDiscovery" __]
        nil
    )

    #_method
    (defn #_"String" DnsSeedDiscovery''to-string [#_"DnsSeedDiscovery" this]
        (:hostname this)
    )
)

;;;
 ; Supports peer discovery through DNS.
 ;
 ; Failure to resolve individual host names will not cause an Exception to be thrown.
 ; However, if all hosts passed fail to resolve a PeerDiscoveryException will be thrown during getPeers().
 ;
 ; DNS seeds do not attempt to enumerate every peer on the network.
 ; {@link DnsDiscovery#getPeers(long, java.util.concurrent.TimeUnit)} will return up to 30 random peers
 ; from the set of those returned within the timeout period.  If you want more peers to connect to,
 ; you need to discover them via other means (like addr broadcasts).
 ;;
(class-ns DnsDiscovery (ยง extends MultiplexingDiscovery)
    ;;;
     ; Supports finding peers through DNS A records.
     ; Without seeds, community run DNS entry points will be used.
     ;
     ; @param seeds Host names to be examined for seed addresses.
     ; @param ledger Network parameters to be used for port information.
     ;;
    (defn #_"DnsDiscovery" DnsDiscovery'new
        ([#_"Ledger" ledger] (DnsDiscovery'new ledger, (:dns-seeds ledger)))
        ([#_"Ledger" ledger, #_"String*" seeds]
            (merge (MultiplexingDiscovery'new ledger, (map #(DnsSeedDiscovery'new ledger, %) seeds))
                (hash-map)
            )
        )
    )

    #_override
    (defn #_"ExecutorService" MultiplexingDiscovery'''create-executor [#_"DnsDiscovery" this]
        (Executors/newFixedThreadPool (count (:seeds this)), (DaemonThreadFactory'new "DNS seed lookups"))
    )
)

;;;
 ; MultiplexingDiscovery queries multiple PeerDiscovery objects, shuffles their responses and then returns the results,
 ; thus selecting randomly between them and reducing the influence of any particular seed.  Any that don't respond
 ; within the timeout are ignored.  Backends are queried in parallel.  Backends may block.
 ;;
(class-ns MultiplexingDiscovery (ยง implements PeerDiscovery)
    ;;;
     ; Will query the given seeds in parallel before producing a merged response.
     ;;
    (defn #_"MultiplexingDiscovery" MultiplexingDiscovery'new [#_"Ledger" ledger, #_"List<PeerDiscovery>" seeds]
        (assert-argument (seq seeds))

        (hash-map
            #_"List<PeerDiscovery>" :seeds seeds

            #_volatile
            #_"ExecutorService" :v-thread-pool nil
        )
    )

    ;;;
     ; Builds a suitable set of peer discoveries.  Will query them in parallel before producing a merged response.
     ; If specific services are required, DNS is not used as the protocol can't handle it.
     ;
     ; @param services Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     ;;
    (defn #_"MultiplexingDiscovery" MultiplexingDiscovery'for-services [#_"Ledger" ledger, #_"long" services]
        (let [#_"List<PeerDiscovery>" discoveries (ArrayList.)]
            ;; Also use DNS seeds if there is no specific service requirement.
            (when (zero? services)
                (doseq [#_"String" seed (:dns-seeds ledger)]
                    (ยง ass discoveries (.add discoveries, (DnsSeedDiscovery'new ledger, seed)))
                )
            )
            (MultiplexingDiscovery'new ledger, discoveries)
        )
    )

    #_throws #_[ "PeerDiscoveryException" ]
    #_override
    (defn #_"InetSocketAddress*" PeerDiscovery'''get-peers [#_"MultiplexingDiscovery" this, #_"long" services, #_"long" timeout, #_"TimeUnit" unit]
        (ยง ass this (assoc this :v-thread-pool (MultiplexingDiscovery'''create-executor this)))
        (try
            (let [#_"List<Callable<InetSocketAddress*>>" tasks (ArrayList.)]
                (doseq [#_"PeerDiscovery" seed (:seeds this)]
                    (ยง ass tasks (.add tasks,
                        (reify Callable #_"<InetSocketAddress*>"
                            #_throws #_[ "Exception" ]
                            #_foreign
                            #_override
                            (#_"InetSocketAddress*" call [#_"Callable" __]
                                (PeerDiscovery'''get-peers seed, services, timeout, unit)
                            )
                        )
                    ))
                )
                (let [#_"List<Future<InetSocketAddress*>>" futures (.invokeAll (:v-thread-pool this), tasks, timeout, unit)
                      #_"List<InetSocketAddress>" addrs (ArrayList.)]
                    (dotimes [#_"int" i (count futures)]
                        (let [#_"Future<InetSocketAddress*>" future (nth futures i)]
                            (if (.isCancelled future)
                                (log/warn (str "Seed " (nth (:seeds this) i) ": timed out"))
                                (try
                                    (Collections/addAll addrs, (.get future))
                                    (catch ExecutionException e
                                        (log/warn (str "Seed " (nth (:seeds this) i) ": failed to look up: " (.getMessage e)))
                                    )
                                )
                            )
                        )
                    )
                    (when (zero? (count addrs))
                        (throw+ (PeerDiscoveryException'new (str "No peer discovery returned any results in " (.toMillis unit, timeout) "ms.  Check internet connection?")))
                    )

                    (.shutdownNow (:v-thread-pool this))
                    (shuffle addrs)
                )
            )
            (catch InterruptedException e
                (throw+ (PeerDiscoveryException'new) e)
            )
            (finally
                (.shutdown (:v-thread-pool this))
            )
        )
    )

    #_abstract
    (defn #_"ExecutorService" MultiplexingDiscovery'''create-executor [#_"MultiplexingDiscovery" this]
        (Executors/newFixedThreadPool (count (:seeds this)), (DaemonThreadFactory'new "Multiplexing discovery"))
    )

    #_override
    (defn #_"void" PeerDiscovery'''shutdown [#_"MultiplexingDiscovery" this]
        (when-let [#_"ExecutorService" threads (:v-thread-pool this)]
            (.shutdown threads)
        )
        nil
    )
)

(class-ns PeerDiscoveryException (ยง extends RuntimeException)
    (defn #_"PeerDiscoveryException" PeerDiscoveryException'new
        ([] (PeerDiscoveryException'new nil))
        ([#_"String" message]
            (RuntimeException'new message)
        )
    )
)

;;;
 ; SeedPeers stores a pre-determined list of Bitcoin node addresses.  These nodes are selected based on
 ; being active on the network for a long period of time.  The intention is to be a last resort way of finding
 ; a connection to the network, in case IRC and DNS fail.  The list comes from the Bitcoin C++ source code.
 ;;
(class-ns SeedPeers (ยง implements PeerDiscovery)
    ;;;
     ; Supports finding peers by IP addresses.
     ;
     ; @param ledger Network parameters to be used for port information.
     ; @param seeds IP addresses for seed addresses.
     ;;
    (defn #_"SeedPeers" SeedPeers'new
        ([#_"Ledger" ledger] (SeedPeers'new ledger, (:addr-seeds ledger)))
        ([#_"Ledger" ledger, #_"int*" seeds]
            (hash-map
                #_"Ledger" :ledger ledger
                #_"int*" :seeds seeds
            )
        )
    )

    (defn- #_"InetAddress" SeedPeers'convert-address [#_"int" seed]
        (let [#_"byte[]" a4 (byte-array 4)]
            (aset a4 0 (byte (& 0xff seed)))
            (aset a4 1 (byte (& 0xff (>> seed 8))))
            (aset a4 2 (byte (& 0xff (>> seed 16))))
            (aset a4 3 (byte (& 0xff (>> seed 24))))
            (InetAddress/getByAddress a4)
        )
    )

    #_throws #_[ "UnknownHostException" ]
    #_method
    (defn- #_"InetSocketAddress" SeedPeers''next-peer [#_"SeedPeers" this]
        (when-let [#_"int" seed (first (:seeds this))]
            (ยง ass this (update this :seeds next))
            (InetSocketAddress. (SeedPeers'convert-address seed), (-> this :ledger :port))
        )
    )

    #_throws #_[ "UnknownHostException" ]
    #_method
    (defn- #_"InetSocketAddress*" SeedPeers''all-peers [#_"SeedPeers" this]
        (let [#_"int" port (-> this :ledger :port)]
            (map #(InetSocketAddress. (SeedPeers'convert-address %), port) (:seeds this))
        )
    )

    ;;;
     ; Acts as an iterator, returning the address of each node in the list sequentially.
     ; Once all the list has been iterated, null will be returned for each subsequent query.
     ;;
    #_throws #_[ "PeerDiscoveryException" ]
    #_method
    (defn #_"InetSocketAddress" SeedPeers''get-peer [#_"SeedPeers" this]
        (try
            (SeedPeers''next-peer this)
            (catch UnknownHostException e
                (throw+ (PeerDiscoveryException'new) e)
            )
        )
    )

    ;;;
     ; Returns an array containing all the Bitcoin nodes within the list.
     ;;
    #_throws #_[ "PeerDiscoveryException" ]
    #_override
    (defn #_"InetSocketAddress*" PeerDiscovery'''get-peers [#_"SeedPeers" this, #_"long" services, #_"long" _timeout, #_"TimeUnit" _unit]
        (when-not (zero? services)
            (throw+ (PeerDiscoveryException'new (str "Pre-determined peers cannot be filtered by services: " services)))
        )
        (try
            (SeedPeers''all-peers this)
            (catch UnknownHostException e
                (throw+ (PeerDiscoveryException'new) e)
            )
        )
    )

    #_override
    (defn #_"void" PeerDiscovery'''shutdown [#_"SeedPeers" __]
        nil
    )
)

(ยง ns bitclojn.params
    (:refer-clojure :exclude [ensure subvec sync vec vector vector-of when when-not])
    (:use [bitclojn slang])
)

;;;
 ; Parameters for the main production network on which people trade goods and services.
 ;;
(class-ns MainLedger (ยง extends Ledger)
    (defn #_"MainLedger" MainLedger'new []
        (let [this (Ledger'new)

              this (assoc this :is-test false)

              this (assoc this :interval Ledger'INTERVAL)
              this (assoc this :target-timespan Ledger'TARGET_TIMESPAN)
              this (assoc this :max-target (Utils'decode-compact-bits 0x1d00ffff))
              this (assoc this :address-header 0)
              this (assoc this :p2sh-header 5)
              this (assoc this :acceptable-address-codes [ (:address-header this), (:p2sh-header this) ])
              this (assoc this :port 8333)
              this (assoc this :packet-magic 0xf9beb4d9)
              this (assoc this :bip32-header-pub 0x0488b21e) ;; 4 byte header that serializes in base58 to "xpub"
              this (assoc this :bip32-header-priv 0x0488ade4) ;; 4 byte header that serializes in base58 to "xprv"

              this (assoc this :majority-enforce-block-upgrade 750)
              this (assoc this :majority-reject-block-outdated 950)
              this (assoc this :majority-window 1000)

              this (update this :genesis-block assoc :time-seconds 1231006505, :difficulty-target 0x1d00ffff, :nonce 2083236893)

              this (assoc this :subsidy-decrease-block-count 210000)
              this (assoc this :spendable-coinbase-depth 100)

              this (assoc this :dns-seeds
                [
                    "seed.bitcoin.sipa.be",          ;; Pieter Wuille
                    "dnsseed.bluematt.me",           ;; Matt Corallo
                    "dnsseed.bitcoin.dashjr.org",    ;; Luke Dashjr
                    "seed.bitcoinstats.com",         ;; Chris Decker
                    "seed.bitnodes.io",              ;; Addy Yeow
                    "bitseed.xf2.org",               ;; Jeff Garzik
                    "seed.bitcoin.jonasschnelli.ch", ;; Jonas Schnelli
                ])

              this (assoc this :addr-seeds
                [
                    0x1ddb1032, 0x6242ce40, 0x52d6a445, 0x2dd7a445, 0x8a53cd47, 0x73263750, 0xda23c257, 0xecd4ed57,
                    0x0a40ec59, 0x75dce160, 0x7df76791, 0x89370bad, 0xa4f214ad, 0x767700ae, 0x638b0418, 0x868a1018,
                    0xcd9f332e, 0x0129653e, 0xcc92dc3e, 0x96671640, 0x56487e40, 0x5b66f440, 0xb1d01f41, 0xf1dc6041,
                    0xc1d12b42, 0x86ba1243, 0x6be4df43, 0x6d4cef43, 0xd18e0644, 0x1ab0b344, 0x6584a345, 0xe7c1a445,
                    0x58cea445, 0xc5daa445, 0x21dda445, 0x3d3b5346, 0x13e55347, 0x1080d24a, 0x8e611e4b, 0x81518e4b,
                    0x6c839e4b, 0xe2ad0a4c, 0xfbbc0a4c, 0x7f5b6e4c, 0x7244224e, 0x1300554e, 0x20690652, 0x5a48b652,
                    0x75c5c752, 0x4335cc54, 0x340fd154, 0x87c07455, 0x087b2b56, 0x8a133a57, 0xac23c257, 0x70374959,
                    0xfb63d45b, 0xb9a1685c, 0x180d765c, 0x674f645d, 0x04d3495e, 0x1de44b5e, 0x4ee8a362, 0x0ded1b63,
                    0xc1b04b6d, 0x8d921581, 0x97b7ea82, 0x1cf83a8e, 0x91490bad, 0x09dc75ae, 0x9a6d79ae, 0xa26d79ae,
                    0x0fd08fae, 0x0f3e3fb2, 0x4f944fb2, 0xcca448b8, 0x3ecd6ab8, 0xa9d5a5bc, 0x8d0119c1, 0x045997d5,
                    0xca019dd9, 0x0d526c4d, 0xabf1ba44, 0x66b1ab55, 0x1165f462, 0x3ed7cbad, 0xa38fae6e, 0x3bd2cbad,
                    0xd36f0547, 0x20df7840, 0x7a337742, 0x549f8e4b, 0x9062365c, 0xd399f562, 0x2b5274a1, 0x8edfa153,
                    0x3bffb347, 0x7074bf58, 0xb74fcbad, 0x5b5a795b, 0x02fa29ce, 0x5a6738d4, 0xe8a1d23e, 0xef98c445,
                    0x4b0f494c, 0xa2bc1e56, 0x7694ad63, 0xa4a800c3, 0x05fda6cd, 0x9f22175e, 0x364a795b, 0x536285d5,
                    0xac44c9d4, 0x0b06254d, 0x150c2fd4, 0x32a50dcc, 0xfd79ce48, 0xf15cfa53, 0x66c01e60, 0x6bc26661,
                    0xc03b47ae, 0x4dda1b81, 0x3285a4c1, 0x883ca96d, 0x35d60a4c, 0xdae09744, 0x2e314d61, 0x84e247cf,
                    0x6c814552, 0x3a1cc658, 0x98d8f382, 0xe584cb5b, 0x15e86057, 0x7b01504e, 0xd852dd48, 0x56382f56,
                    0x0a5df454, 0xa0d18d18, 0x2e89b148, 0xa79c114c, 0xcbdcd054, 0x5523bc43, 0xa9832640, 0x8a066144,
                    0x3894c3bc, 0xab76bf58, 0x6a018ac1, 0xfebf4f43, 0x2f26c658, 0x31102f4e, 0x85e929d5, 0x2a1c175e,
                    0xfc6c2cd1, 0x27b04b6d, 0xdf024650, 0x161748b8, 0x28be6580, 0x57be6580, 0x1cee677a, 0xaa6bb742,
                    0x9a53964b, 0x0a5a2d4d, 0x2434c658, 0x9a494f57, 0x1ebb0e48, 0xf610b85d, 0x077ecf44, 0x085128bc,
                    0x5ba17a18, 0x27ca1b42, 0xf8a00b56, 0xfcd4c257, 0xcf2fc15e, 0xd897e052, 0x4cada04f, 0x2f35f6d5,
                    0x382ce8c9, 0xe523984b, 0x3f946846, 0x60c8be43, 0x41da6257, 0xde0be142, 0xae8a544b, 0xeff0c254,
                    0x1e0f795b, 0xaeb28890, 0xca16acd9, 0x1e47ddd8, 0x8c8c4829, 0xd27dc747, 0xd53b1663, 0x4096b163,
                    0x9c8dd958, 0xcb12f860, 0x9e79305c, 0x40c1a445, 0x4a90c2bc, 0x2c3a464d, 0x2727f23c, 0x30b04b6d,
                    0x59024cb8, 0xa091e6ad, 0x31b04b6d, 0xc29d46a6, 0x63934fb2, 0xd9224dbe, 0x9f5910d8, 0x7f530a6b,
                    0x752e9c95, 0x65453548, 0xa484be46, 0xce5a1b59, 0x710e0718, 0x46a13d18, 0xdaaf5318, 0xc4a8ff53,
                    0x87abaa52, 0xb764cf51, 0xb2025d4a, 0x6d351e41, 0xc035c33e, 0xa432c162, 0x61ef34ae, 0xd16fddbc,
                    0x0870e8c1, 0x3070e8c1, 0x9c71e8c1, 0xa4992363, 0x85a1f663, 0x4184e559, 0x18d96ed8, 0x17b8dbd5,
                    0x60e7cd18, 0xe5ee104c, 0xab17ac62, 0x1e786e1b, 0x5d23b762, 0xf2388fae, 0x88270360, 0x9e5b3d80,
                    0x7da518b2, 0xb5613b45, 0x1ad41f3e, 0xd550854a, 0x8617e9a9, 0x925b229c, 0xf2e92542, 0x47af0544,
                    0x73b5a843, 0xb9b7a0ad, 0x03a748d0, 0x0a6ff862, 0x6694df62, 0x3bfac948, 0x8e098f4f, 0x746916c3,
                    0x02f38e4f, 0x40bb1243, 0x6a54d162, 0x6008414b, 0xa513794c, 0x514aa343, 0x63781747, 0xdbb6795b,
                    0xed065058, 0x42d24b46, 0x1518794c, 0x9b271681, 0x73e4ffad, 0x0654784f, 0x438dc945, 0x641846a6,
                    0x2d1b0944, 0x94b59148, 0x8d369558, 0xa5a97662, 0x8b705b42, 0xce9204ae, 0x8d584450, 0x2df61555,
                    0xeebff943, 0x2e75fb4d, 0x3ef8fc57, 0x9921135e, 0x8e31042e, 0xb5afad43, 0x89ecedd1, 0x9cfcc047,
                    0x8fcd0f4c, 0xbe49f5ad, 0x146a8d45, 0x98669ab8, 0x98d9175e, 0xd1a8e46d, 0x839a3ab8, 0x40a0016c,
                    0x6d27c257, 0x977fffad, 0x7baa5d5d, 0x1213be43, 0xb167e5a9, 0x640fe8ca, 0xbc9ea655, 0x0f820a4c,
                    0x0f097059, 0x69ac957c, 0x366d8453, 0xb1ba2844, 0x8857f081, 0x70b5be63, 0xc545454b, 0xaf36ded1,
                    0xb5a4b052, 0x21f062d1, 0x72ab89b2, 0x74a45318, 0x8312e6bc, 0xb916965f, 0x8aa7c858, 0xfe7effad,
                ])]

            (assert-state (= (Block''get-hash-as-base16 (:genesis-block this)) "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f"))

            ;; This contains (at a minimum) the blocks which are not BIP30 compliant.  BIP30 changed how duplicate
            ;; transactions are handled.  Duplicated transactions could occur in the case where a coinbase had the same
            ;; extraNonce and the same outputs but appeared at different heights, and greatly complicated re-org handling.
            ;; Having these here simplifies block connection logic considerably.
            (let [this
                    (update this :checkpoints assoc
                        91722 (Sha256Hash'wrap-base16 "00000000000271a2dc26e7667f8419f2e15416dc6955e5a6c6cdf3f2574dd08e"),
                        91812 (Sha256Hash'wrap-base16 "00000000000af0aed4792b1acee3d966af36cf5def14935db8de83d6f9306f2f"),
                        91842 (Sha256Hash'wrap-base16 "00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec"),
                        91880 (Sha256Hash'wrap-base16 "00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721"),
                       200000 (Sha256Hash'wrap-base16 "000000000000034a7dedef4a161fa058a2d67a173a90155f3a2fe6fc132e0ebf"),
                    )]
                (assoc this :textual-checkpoints MainLedger'TEXTUAL_CHECKPOINTS)
            )
        )
    )

    (def #_"[String]" MainLedger'TEXTUAL_CHECKPOINTS
        (vector
            "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",
        )
    )

    (ยง def- #_"MainLedger" MainLedger'INSTANCE (MainLedger'new))
)

;;;
 ; Parameters for the testnet, a separate public instance of Bitcoin that has relaxed rules suitable for development
 ; and testing of applications and new Bitcoin versions.
 ;;
(class-ns TestLedger (ยง extends Ledger)
    (defn #_"TestLedger" TestLedger'new []
        (let [this (Ledger'new)

              this (assoc this :is-test true)

              this (assoc this :packet-magic 0x0b110907)
              this (assoc this :interval Ledger'INTERVAL)
              this (assoc this :target-timespan Ledger'TARGET_TIMESPAN)
              this (assoc this :max-target (Utils'decode-compact-bits 0x1d00ffff))
              this (assoc this :port 18333)
              this (assoc this :address-header 111)
              this (assoc this :p2sh-header 196)
              this (assoc this :acceptable-address-codes [ (:address-header this), (:p2sh-header this) ])

              this (update this :genesis-block assoc :time-seconds 1296688602, :difficulty-target 0x1d00ffff, :nonce 414098458)

              this (assoc this :spendable-coinbase-depth 100)
              this (assoc this :subsidy-decrease-block-count 210000)

              this (assoc this :dns-seeds
                [
                    "testnet-seed.bitcoin.jonasschnelli.ch", ;; Jonas Schnelli
                    "testnet-seed.bluematt.me",              ;; Matt Corallo
                    "testnet-seed.bitcoin.petertodd.org",    ;; Peter Todd
                    "testnet-seed.bitcoin.schildbach.de",    ;; Andreas Schildbach
                ])
              this (assoc this :addr-seeds nil)
              this (assoc this :bip32-header-pub 0x043587cf)
              this (assoc this :bip32-header-priv 0x04358394)

              this (assoc this :majority-enforce-block-upgrade 51)
              this (assoc this :majority-reject-block-outdated 75)
              this (assoc this :majority-window 100)]

            (assert-state (= (Block''get-hash-as-base16 (:genesis-block this)) "000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943"))

            (assoc this :textual-checkpoints TestLedger'TEXTUAL_CHECKPOINTS)
        )
    )

    (def #_"[String]" TestLedger'TEXTUAL_CHECKPOINTS
        (vector
            "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",
        )
    )

    (def- #_"Date" TestLedger'TESTNET_DIFF_DATE (Date. 1329264000000)) ;; February 16th 2012

    #_throws #_[ "VerificationException", "BlockStoreException" ]
    #_override
    (defn #_"void" Ledger'''check-difficulty-transitions [#_"TestLedger" this, #_"StoredBlock" prior, #_"Block" __nextBlock, #_"BlockStore" store]
        (let [#_"boolean" transition? (Ledger''is-difficulty-transition-point this, (:stored-height prior))]
            (if (and (not transition?) (.after (Date. (* (:time-seconds __nextBlock) 1000)), TestLedger'TESTNET_DIFF_DATE))
                ;; After 15th February 2012 the rules on the testnet change to avoid people running up the difficulty
                ;; and then leaving, making it too hard to mine a block.  On non-difficulty transition points, easy
                ;; blocks are allowed if there has been a span of 20 minutes without one.
                (let [#_"long" delta (- (:time-seconds __nextBlock) (:time-seconds (:stored-header prior)))]
                    ;; There is an integer underflow bug in bitcoin-qt that means mindiff blocks are accepted when time
                    ;; goes backwards.
                    (when (<= 0 delta (* 2 Ledger'TARGET_SPACING))
                        ;; Walk backwards until we find a block that doesn't have the easiest proof of work, then check
                        ;; that difficulty is equal to that one.
                        (let [#_"StoredBlock" cursor
                                (loop-when-recur [cursor prior]
                                                 (and (not (.equals (:stored-header cursor), (:genesis-block this)))
                                                      (not (zero? (rem (:stored-height cursor) (:interval this))))
                                                      (= (Block''get-difficulty-target-as-integer (:stored-header cursor)) (:max-target this)))
                                                 [(StoredBlock''get-prev cursor, store)]
                                              => cursor)
                              #_"BigInteger" __cursorTarget (Block''get-difficulty-target-as-integer (:stored-header cursor))
                              #_"BigInteger" __newTarget (Block''get-difficulty-target-as-integer __nextBlock)]
                            (when-not (= __cursorTarget __newTarget)
                                (throw+ (VerificationException'new (str "Testnet block transition that is not allowed: " (Long/toHexString (:difficulty-target (:stored-header cursor))) " vs " (Long/toHexString (:difficulty-target __nextBlock)))))
                            )
                        )
                    )
                )
                (Ledger'''check-difficulty-transitions (ยง this super), prior, __nextBlock, store)
            )
        )
        nil
    )

    (ยง def- #_"TestLedger" TestLedger'INSTANCE (TestLedger'new))
)

;;;
 ; Utility class that holds all the registered Ledger types used for Address auto discovery.
 ; By default only MainLedger and TestLedger are used.
 ;;
#_stateless
(class-ns Networks
    ;;; Registered networks. ;;
    (def #_"Ledger*" Networks'NETWORKS [ MainLedger'INSTANCE TestLedger'INSTANCE ])
)

(ยง ns bitclojn.script
    (:refer-clojure :exclude [ensure subvec sync vec vector vector-of when when-not])
    (:use [bitclojn slang])
)

;;;
 ; Enumeration to encapsulate the type of a script.
 ;;
(def ScriptType'enum-set
    (hash-set
        ;; Do NOT change the ordering of the following definitions because their ordinals are stored in databases.
        :ScriptType'NO_TYPE
        :ScriptType'P2PKH
        :ScriptType'PUB_KEY
        :ScriptType'P2SH
    )
)

;;;
 ; Flags to pass to {@link Script#correctlySpends(Transaction, long, Script, Set)}.
 ; Note currently only P2SH, DERSIG and NULLDUMMY are actually supported.
 ;;
(def ScriptVerifyFlag'enum-set
    (hash-set
        :ScriptVerifyFlag'P2SH ;; Enable BIP16-style subscript evaluation.
        :ScriptVerifyFlag'STRICTENC ;; Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.
        :ScriptVerifyFlag'DERSIG ;; Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP66 rule 1).
        :ScriptVerifyFlag'LOW_S ;; Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure.
        :ScriptVerifyFlag'NULLDUMMY ;; Verify dummy stack item consumed by CHECKMULTISIG is of zero-length.
        :ScriptVerifyFlag'SIGPUSHONLY ;; Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).
        :ScriptVerifyFlag'MINIMALDATA ;; Require minimal encodings for all push operations.
        :ScriptVerifyFlag'DISCOURAGE_UPGRADABLE_NOPS ;; Discourage use of NOPs reserved for upgrades (NOP1-10).
        :ScriptVerifyFlag'CLEANSTACK ;; Require that only a single stack element remains after evaluation.
        :ScriptVerifyFlag'CHECKLOCKTIMEVERIFY ;; Enable CHECKLOCKTIMEVERIFY operation.
        :ScriptVerifyFlag'CHECKSEQUENCEVERIFY ;; Enable CHECKSEQUENCEVERIFY operation.
    )
)

(def ScriptError'enum-set
    (hash-set
        :ScriptError'OK
        :ScriptError'UNKNOWN_ERROR
        :ScriptError'EVAL_FALSE
        :ScriptError'OP_RETURN

        ;;; max sizes ;;
        :ScriptError'SCRIPT_SIZE
        :ScriptError'PUSH_SIZE
        :ScriptError'OP_COUNT
        :ScriptError'STACK_SIZE
        :ScriptError'SIG_COUNT
        :ScriptError'PUBKEY_COUNT

        ;;; failed verify operations ;;
        :ScriptError'VERIFY
        :ScriptError'EQUALVERIFY
        :ScriptError'CHECKMULTISIGVERIFY
        :ScriptError'CHECKSIGVERIFY
        :ScriptError'NUMEQUALVERIFY

        ;;; logical/format/canonical errors ;;
        :ScriptError'BAD_OPCODE
        :ScriptError'DISABLED_OPCODE
        :ScriptError'INVALID_STACK_OPERATION
        :ScriptError'INVALID_ALTSTACK_OPERATION
        :ScriptError'UNBALANCED_CONDITIONAL

        ;;; CHECKLOCKTIMEVERIFY and CHECKSEQUENCEVERIFY ;;
        :ScriptError'NEGATIVE_LOCKTIME
        :ScriptError'UNSATISFIED_LOCKTIME

        ;;; malleability ;;
        :ScriptError'SIG_HASHTYPE
        :ScriptError'SIG_DER
        :ScriptError'MINIMALDATA
        :ScriptError'SIG_PUSHONLY
        :ScriptError'SIG_HIGH_S
        :ScriptError'SIG_NULLDUMMY
        :ScriptError'PUBKEYTYPE
        :ScriptError'CLEANSTACK
        :ScriptError'MINIMALIF
        :ScriptError'SIG_NULLFAIL

        ;;; softfork safeness ;;
        :ScriptError'DISCOURAGE_UPGRADABLE_NOPS
        :ScriptError'DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM

        ;;; segregated witness ;;
        :ScriptError'WITNESS_PROGRAM_WRONG_LENGTH
        :ScriptError'WITNESS_PROGRAM_WITNESS_EMPTY
        :ScriptError'WITNESS_PROGRAM_MISMATCH
        :ScriptError'WITNESS_MALLEATED
        :ScriptError'WITNESS_MALLEATED_P2SH
        :ScriptError'WITNESS_UNEXPECTED
        :ScriptError'WITNESS_PUBKEYTYPE
    )
)

;;;
 ; Various constants that define the assembly-like scripting language that forms part of the Bitcoin protocol.
 ; See {@link Script} for details.  Also provides a method to convert them to a string.
 ;;
#_stateless
(class-ns ScriptOpCodes
    ;; push value
    (def #_"int" Script'OP_0 0x00) ;; push empty vector
    (def #_"int" Script'OP_FALSE Script'OP_0)
    (def #_"int" Script'OP_PUSHDATA1 0x4c)
    (def #_"int" Script'OP_PUSHDATA2 0x4d)
    (def #_"int" Script'OP_PUSHDATA4 0x4e)
    (def #_"int" Script'OP_1NEGATE 0x4f)
    (def #_"int" Script'OP_RESERVED 0x50)
    (def #_"int" Script'OP_1 0x51)
    (def #_"int" Script'OP_TRUE Script'OP_1)
    (def #_"int" Script'OP_2 0x52)
    (def #_"int" Script'OP_3 0x53)
    (def #_"int" Script'OP_4 0x54)
    (def #_"int" Script'OP_5 0x55)
    (def #_"int" Script'OP_6 0x56)
    (def #_"int" Script'OP_7 0x57)
    (def #_"int" Script'OP_8 0x58)
    (def #_"int" Script'OP_9 0x59)
    (def #_"int" Script'OP_10 0x5a)
    (def #_"int" Script'OP_11 0x5b)
    (def #_"int" Script'OP_12 0x5c)
    (def #_"int" Script'OP_13 0x5d)
    (def #_"int" Script'OP_14 0x5e)
    (def #_"int" Script'OP_15 0x5f)
    (def #_"int" Script'OP_16 0x60)

    ;; control
    (def #_"int" Script'OP_NOP 0x61)
    (def #_"int" Script'OP_VER 0x62)
    (def #_"int" Script'OP_IF 0x63)
    (def #_"int" Script'OP_NOTIF 0x64)
    (def #_"int" Script'OP_VERIF 0x65)
    (def #_"int" Script'OP_VERNOTIF 0x66)
    (def #_"int" Script'OP_ELSE 0x67)
    (def #_"int" Script'OP_ENDIF 0x68)
    (def #_"int" Script'OP_VERIFY 0x69)
    (def #_"int" Script'OP_RETURN 0x6a)

    ;; stack ops
    (def #_"int" Script'OP_TOALTSTACK 0x6b)
    (def #_"int" Script'OP_FROMALTSTACK 0x6c)
    (def #_"int" Script'OP_2DROP 0x6d)
    (def #_"int" Script'OP_2DUP 0x6e)
    (def #_"int" Script'OP_3DUP 0x6f)
    (def #_"int" Script'OP_2OVER 0x70)
    (def #_"int" Script'OP_2ROT 0x71)
    (def #_"int" Script'OP_2SWAP 0x72)
    (def #_"int" Script'OP_IFDUP 0x73)
    (def #_"int" Script'OP_DEPTH 0x74)
    (def #_"int" Script'OP_DROP 0x75)
    (def #_"int" Script'OP_DUP 0x76)
    (def #_"int" Script'OP_NIP 0x77)
    (def #_"int" Script'OP_OVER 0x78)
    (def #_"int" Script'OP_PICK 0x79)
    (def #_"int" Script'OP_ROLL 0x7a)
    (def #_"int" Script'OP_ROT 0x7b)
    (def #_"int" Script'OP_SWAP 0x7c)
    (def #_"int" Script'OP_TUCK 0x7d)

    ;; splice ops
    (def #_"int" Script'OP_CAT 0x7e)
    (def #_"int" Script'OP_SUBSTR 0x7f)
    (def #_"int" Script'OP_LEFT 0x80)
    (def #_"int" Script'OP_RIGHT 0x81)
    (def #_"int" Script'OP_SIZE 0x82)

    ;; bit logic
    (def #_"int" Script'OP_INVERT 0x83)
    (def #_"int" Script'OP_AND 0x84)
    (def #_"int" Script'OP_OR 0x85)
    (def #_"int" Script'OP_XOR 0x86)
    (def #_"int" Script'OP_EQUAL 0x87)
    (def #_"int" Script'OP_EQUALVERIFY 0x88)
    (def #_"int" Script'OP_RESERVED1 0x89)
    (def #_"int" Script'OP_RESERVED2 0x8a)

    ;; numeric
    (def #_"int" Script'OP_1ADD 0x8b)
    (def #_"int" Script'OP_1SUB 0x8c)
    (def #_"int" Script'OP_2MUL 0x8d)
    (def #_"int" Script'OP_2DIV 0x8e)
    (def #_"int" Script'OP_NEGATE 0x8f)
    (def #_"int" Script'OP_ABS 0x90)
    (def #_"int" Script'OP_NOT 0x91)
    (def #_"int" Script'OP_0NOTEQUAL 0x92)
    (def #_"int" Script'OP_ADD 0x93)
    (def #_"int" Script'OP_SUB 0x94)
    (def #_"int" Script'OP_MUL 0x95)
    (def #_"int" Script'OP_DIV 0x96)
    (def #_"int" Script'OP_MOD 0x97)
    (def #_"int" Script'OP_LSHIFT 0x98)
    (def #_"int" Script'OP_RSHIFT 0x99)
    (def #_"int" Script'OP_BOOLAND 0x9a)
    (def #_"int" Script'OP_BOOLOR 0x9b)
    (def #_"int" Script'OP_NUMEQUAL 0x9c)
    (def #_"int" Script'OP_NUMEQUALVERIFY 0x9d)
    (def #_"int" Script'OP_NUMNOTEQUAL 0x9e)
    (def #_"int" Script'OP_LESSTHAN 0x9f)
    (def #_"int" Script'OP_GREATERTHAN 0xa0)
    (def #_"int" Script'OP_LESSTHANOREQUAL 0xa1)
    (def #_"int" Script'OP_GREATERTHANOREQUAL 0xa2)
    (def #_"int" Script'OP_MIN 0xa3)
    (def #_"int" Script'OP_MAX 0xa4)
    (def #_"int" Script'OP_WITHIN 0xa5)

    ;; crypto
    (def #_"int" Script'OP_RIPEMD160 0xa6)
    (def #_"int" Script'OP_SHA1 0xa7)
    (def #_"int" Script'OP_SHA256 0xa8)
    (def #_"int" Script'OP_HASH160 0xa9)
    (def #_"int" Script'OP_HASH256 0xaa)
    (def #_"int" Script'OP_CODESEPARATOR 0xab)
    (def #_"int" Script'OP_CHECKSIG 0xac)
    (def #_"int" Script'OP_CHECKSIGVERIFY 0xad)
    (def #_"int" Script'OP_CHECKMULTISIG 0xae)
    (def #_"int" Script'OP_CHECKMULTISIGVERIFY 0xaf)

    ;; block state
    ;;; Check lock time of the block.  Introduced in BIP 65, replacing OP_NOP2 ;;
    (def #_"int" Script'OP_CHECKLOCKTIMEVERIFY 0xb1)
    (def #_"int" Script'OP_CHECKSEQUENCEVERIFY 0xb2)

    ;; expansion
    (def #_"int" Script'OP_NOP1 0xb0)
    ;;; Deprecated by BIP 65 ;;
    #_deprecated
    (def #_"int" Script'OP_NOP2 Script'OP_CHECKLOCKTIMEVERIFY)
    ;;; Deprecated by BIP 112 ;;
    #_deprecated
    (def #_"int" Script'OP_NOP3 Script'OP_CHECKSEQUENCEVERIFY)
    (def #_"int" Script'OP_NOP4 0xb3)
    (def #_"int" Script'OP_NOP5 0xb4)
    (def #_"int" Script'OP_NOP6 0xb5)
    (def #_"int" Script'OP_NOP7 0xb6)
    (def #_"int" Script'OP_NOP8 0xb7)
    (def #_"int" Script'OP_NOP9 0xb8)
    (def #_"int" Script'OP_NOP10 0xb9)
    (def #_"int" Script'OP_INVALIDOPCODE 0xff)

    (def- #_"Map<Integer, String>" Script'OP_CODE_MAP
    {
        Script'OP_0 "0",
        Script'OP_PUSHDATA1 "PUSHDATA1",
        Script'OP_PUSHDATA2 "PUSHDATA2",
        Script'OP_PUSHDATA4 "PUSHDATA4",
        Script'OP_1NEGATE "1NEGATE",
        Script'OP_RESERVED "RESERVED",
        Script'OP_1 "1",
        Script'OP_2 "2",
        Script'OP_3 "3",
        Script'OP_4 "4",
        Script'OP_5 "5",
        Script'OP_6 "6",
        Script'OP_7 "7",
        Script'OP_8 "8",
        Script'OP_9 "9",
        Script'OP_10 "10",
        Script'OP_11 "11",
        Script'OP_12 "12",
        Script'OP_13 "13",
        Script'OP_14 "14",
        Script'OP_15 "15",
        Script'OP_16 "16",
        Script'OP_NOP "NOP",
        Script'OP_VER "VER",
        Script'OP_IF "IF",
        Script'OP_NOTIF "NOTIF",
        Script'OP_VERIF "VERIF",
        Script'OP_VERNOTIF "VERNOTIF",
        Script'OP_ELSE "ELSE",
        Script'OP_ENDIF "ENDIF",
        Script'OP_VERIFY "VERIFY",
        Script'OP_RETURN "RETURN",
        Script'OP_TOALTSTACK "TOALTSTACK",
        Script'OP_FROMALTSTACK "FROMALTSTACK",
        Script'OP_2DROP "2DROP",
        Script'OP_2DUP "2DUP",
        Script'OP_3DUP "3DUP",
        Script'OP_2OVER "2OVER",
        Script'OP_2ROT "2ROT",
        Script'OP_2SWAP "2SWAP",
        Script'OP_IFDUP "IFDUP",
        Script'OP_DEPTH "DEPTH",
        Script'OP_DROP "DROP",
        Script'OP_DUP "DUP",
        Script'OP_NIP "NIP",
        Script'OP_OVER "OVER",
        Script'OP_PICK "PICK",
        Script'OP_ROLL "ROLL",
        Script'OP_ROT "ROT",
        Script'OP_SWAP "SWAP",
        Script'OP_TUCK "TUCK",
        Script'OP_CAT "CAT",
        Script'OP_SUBSTR "SUBSTR",
        Script'OP_LEFT "LEFT",
        Script'OP_RIGHT "RIGHT",
        Script'OP_SIZE "SIZE",
        Script'OP_INVERT "INVERT",
        Script'OP_AND "AND",
        Script'OP_OR "OR",
        Script'OP_XOR "XOR",
        Script'OP_EQUAL "EQUAL",
        Script'OP_EQUALVERIFY "EQUALVERIFY",
        Script'OP_RESERVED1 "RESERVED1",
        Script'OP_RESERVED2 "RESERVED2",
        Script'OP_1ADD "1ADD",
        Script'OP_1SUB "1SUB",
        Script'OP_2MUL "2MUL",
        Script'OP_2DIV "2DIV",
        Script'OP_NEGATE "NEGATE",
        Script'OP_ABS "ABS",
        Script'OP_NOT "NOT",
        Script'OP_0NOTEQUAL "0NOTEQUAL",
        Script'OP_ADD "ADD",
        Script'OP_SUB "SUB",
        Script'OP_MUL "MUL",
        Script'OP_DIV "DIV",
        Script'OP_MOD "MOD",
        Script'OP_LSHIFT "LSHIFT",
        Script'OP_RSHIFT "RSHIFT",
        Script'OP_BOOLAND "BOOLAND",
        Script'OP_BOOLOR "BOOLOR",
        Script'OP_NUMEQUAL "NUMEQUAL",
        Script'OP_NUMEQUALVERIFY "NUMEQUALVERIFY",
        Script'OP_NUMNOTEQUAL "NUMNOTEQUAL",
        Script'OP_LESSTHAN "LESSTHAN",
        Script'OP_GREATERTHAN "GREATERTHAN",
        Script'OP_LESSTHANOREQUAL "LESSTHANOREQUAL",
        Script'OP_GREATERTHANOREQUAL "GREATERTHANOREQUAL",
        Script'OP_MIN "MIN",
        Script'OP_MAX "MAX",
        Script'OP_WITHIN "WITHIN",
        Script'OP_RIPEMD160 "RIPEMD160",
        Script'OP_SHA1 "SHA1",
        Script'OP_SHA256 "SHA256",
        Script'OP_HASH160 "HASH160",
        Script'OP_HASH256 "HASH256",
        Script'OP_CODESEPARATOR "CODESEPARATOR",
        Script'OP_CHECKSIG "CHECKSIG",
        Script'OP_CHECKSIGVERIFY "CHECKSIGVERIFY",
        Script'OP_CHECKMULTISIG "CHECKMULTISIG",
        Script'OP_CHECKMULTISIGVERIFY "CHECKMULTISIGVERIFY",
        Script'OP_NOP1 "NOP1",
        Script'OP_CHECKLOCKTIMEVERIFY "CHECKLOCKTIMEVERIFY",
        Script'OP_CHECKSEQUENCEVERIFY "CHECKSEQUENCEVERIFY",
        Script'OP_NOP4 "NOP4",
        Script'OP_NOP5 "NOP5",
        Script'OP_NOP6 "NOP6",
        Script'OP_NOP7 "NOP7",
        Script'OP_NOP8 "NOP8",
        Script'OP_NOP9 "NOP9",
        Script'OP_NOP10 "NOP10",
    })

    (def- #_"Map<String, Integer>" Script'OP_NAME_MAP
    {
        "0" Script'OP_0,
        "PUSHDATA1" Script'OP_PUSHDATA1,
        "PUSHDATA2" Script'OP_PUSHDATA2,
        "PUSHDATA4" Script'OP_PUSHDATA4,
        "1NEGATE" Script'OP_1NEGATE,
        "RESERVED" Script'OP_RESERVED,
        "1" Script'OP_1,
        "2" Script'OP_2,
        "3" Script'OP_3,
        "4" Script'OP_4,
        "5" Script'OP_5,
        "6" Script'OP_6,
        "7" Script'OP_7,
        "8" Script'OP_8,
        "9" Script'OP_9,
        "10" Script'OP_10,
        "11" Script'OP_11,
        "12" Script'OP_12,
        "13" Script'OP_13,
        "14" Script'OP_14,
        "15" Script'OP_15,
        "16" Script'OP_16,
        "NOP" Script'OP_NOP,
        "VER" Script'OP_VER,
        "IF" Script'OP_IF,
        "NOTIF" Script'OP_NOTIF,
        "VERIF" Script'OP_VERIF,
        "VERNOTIF" Script'OP_VERNOTIF,
        "ELSE" Script'OP_ELSE,
        "ENDIF" Script'OP_ENDIF,
        "VERIFY" Script'OP_VERIFY,
        "RETURN" Script'OP_RETURN,
        "TOALTSTACK" Script'OP_TOALTSTACK,
        "FROMALTSTACK" Script'OP_FROMALTSTACK,
        "2DROP" Script'OP_2DROP,
        "2DUP" Script'OP_2DUP,
        "3DUP" Script'OP_3DUP,
        "2OVER" Script'OP_2OVER,
        "2ROT" Script'OP_2ROT,
        "2SWAP" Script'OP_2SWAP,
        "IFDUP" Script'OP_IFDUP,
        "DEPTH" Script'OP_DEPTH,
        "DROP" Script'OP_DROP,
        "DUP" Script'OP_DUP,
        "NIP" Script'OP_NIP,
        "OVER" Script'OP_OVER,
        "PICK" Script'OP_PICK,
        "ROLL" Script'OP_ROLL,
        "ROT" Script'OP_ROT,
        "SWAP" Script'OP_SWAP,
        "TUCK" Script'OP_TUCK,
        "CAT" Script'OP_CAT,
        "SUBSTR" Script'OP_SUBSTR,
        "LEFT" Script'OP_LEFT,
        "RIGHT" Script'OP_RIGHT,
        "SIZE" Script'OP_SIZE,
        "INVERT" Script'OP_INVERT,
        "AND" Script'OP_AND,
        "OR" Script'OP_OR,
        "XOR" Script'OP_XOR,
        "EQUAL" Script'OP_EQUAL,
        "EQUALVERIFY" Script'OP_EQUALVERIFY,
        "RESERVED1" Script'OP_RESERVED1,
        "RESERVED2" Script'OP_RESERVED2,
        "1ADD" Script'OP_1ADD,
        "1SUB" Script'OP_1SUB,
        "2MUL" Script'OP_2MUL,
        "2DIV" Script'OP_2DIV,
        "NEGATE" Script'OP_NEGATE,
        "ABS" Script'OP_ABS,
        "NOT" Script'OP_NOT,
        "0NOTEQUAL" Script'OP_0NOTEQUAL,
        "ADD" Script'OP_ADD,
        "SUB" Script'OP_SUB,
        "MUL" Script'OP_MUL,
        "DIV" Script'OP_DIV,
        "MOD" Script'OP_MOD,
        "LSHIFT" Script'OP_LSHIFT,
        "RSHIFT" Script'OP_RSHIFT,
        "BOOLAND" Script'OP_BOOLAND,
        "BOOLOR" Script'OP_BOOLOR,
        "NUMEQUAL" Script'OP_NUMEQUAL,
        "NUMEQUALVERIFY" Script'OP_NUMEQUALVERIFY,
        "NUMNOTEQUAL" Script'OP_NUMNOTEQUAL,
        "LESSTHAN" Script'OP_LESSTHAN,
        "GREATERTHAN" Script'OP_GREATERTHAN,
        "LESSTHANOREQUAL" Script'OP_LESSTHANOREQUAL,
        "GREATERTHANOREQUAL" Script'OP_GREATERTHANOREQUAL,
        "MIN" Script'OP_MIN,
        "MAX" Script'OP_MAX,
        "WITHIN" Script'OP_WITHIN,
        "RIPEMD160" Script'OP_RIPEMD160,
        "SHA1" Script'OP_SHA1,
        "SHA256" Script'OP_SHA256,
        "HASH160" Script'OP_HASH160,
        "HASH256" Script'OP_HASH256,
        "CODESEPARATOR" Script'OP_CODESEPARATOR,
        "CHECKSIG" Script'OP_CHECKSIG,
        "CHECKSIGVERIFY" Script'OP_CHECKSIGVERIFY,
        "CHECKMULTISIG" Script'OP_CHECKMULTISIG,
        "CHECKMULTISIGVERIFY" Script'OP_CHECKMULTISIGVERIFY,
        "NOP1" Script'OP_NOP1,
        "CHECKLOCKTIMEVERIFY" Script'OP_CHECKLOCKTIMEVERIFY,
        "CHECKSEQUENCEVERIFY" Script'OP_CHECKSEQUENCEVERIFY,
        "NOP2" Script'OP_NOP2,
        "NOP3" Script'OP_NOP3,
        "NOP4" Script'OP_NOP4,
        "NOP5" Script'OP_NOP5,
        "NOP6" Script'OP_NOP6,
        "NOP7" Script'OP_NOP7,
        "NOP8" Script'OP_NOP8,
        "NOP9" Script'OP_NOP9,
        "NOP10" Script'OP_NOP10,
    })

    ;;;
     ; Converts the given opcode into a string (e.g. "0", "PUSHDATA", or "NON_OP(10)")
     ;;
    (defn #_"String" ScriptOpCodes'get-op-code-name [#_"int" code]
        (get Script'OP_CODE_MAP code (str "NON_OP(" code ")"))
    )

    ;;;
     ; Converts the given pushdata opcode into a string (e.g. "PUSHDATA2", or "PUSHDATA(23)")
     ;;
    (defn #_"String" ScriptOpCodes'get-push-data-name [#_"int" code]
        (get Script'OP_CODE_MAP code (str "PUSHDATA(" code ")"))
    )

    ;;;
     ; Converts the given opcode name into an int.
     ;;
    (defn #_"int" ScriptOpCodes'get-op-code [#_"String" name]
        (get Script'OP_NAME_MAP name Script'OP_INVALIDOPCODE)
    )
)

;;;
 ; A script element that is either a data push (signature, pubkey, etc.) or a non-push (logic, numeric, etc.) operation.
 ;;
(class-ns ScriptChunk
    (defn #_"ScriptChunk" ScriptChunk'new [#_"int" opcode, #_"byte[]" data]
        (hash-map
            ;;;
             ; Operation to be executed.  Opcodes are defined in {@link ScriptOpCodes}.
             ;;
            #_"int" :opcode opcode
            ;;;
             ; For push operations, this is the vector to be pushed on the stack.
             ; For {@link OP_0}, the vector is empty.
             ; Null for non-push operations.
             ;;
            #_"byte[]" :data data
        )
    )

    #_method
    (defn #_"boolean" ScriptChunk''equals-op-code [#_"ScriptChunk" this, #_"int" opcode]
        (= opcode (:opcode this))
    )

    ;;;
     ; Whether this chunk is a single byte of non-pushdata content (could be OP_RESERVED or some invalid opcode).
     ;;
    #_method
    (defn #_"boolean" ScriptChunk''is-op-code [#_"ScriptChunk" this]
        (< Script'OP_PUSHDATA4 (:opcode this))
    )

    ;;;
     ; Returns true if this chunk is pushdata content, even single-byte.
     ;;
    #_method
    (defn #_"boolean" ScriptChunk''is-push-data [#_"ScriptChunk" this]
        (<= (:opcode this) Script'OP_16)
    )

    ;;;
     ; If this chunk is an OP_N opcode, returns the equivalent integer value.
     ;;
    #_method
    (defn #_"int" ScriptChunk''decode-op-n [#_"ScriptChunk" this]
        (assert-state (ScriptChunk''is-op-code this))

        (Script'decode-from-op-n (:opcode this))
    )

    ;;;
     ; Called on a pushdata chunk, returns true if it uses the smallest possible way (according to BIP62) to push the data.
     ;;
    #_method
    (defn #_"boolean" ScriptChunk''is-shortest-possible-push-data [#_"ScriptChunk" this]
        (assert-state (ScriptChunk''is-push-data this))

        (or (nil? (:data this)) ;; OP_N
            (let [op (:opcode this) al (count (:data this))]
                (cond
                    (= al 0)
                        (= op Script'OP_0)
                    (= al 1)
                        (let [#_"byte" b (nth (:data this) 0)]
                            (cond
                                (<= 0x01 b 0x10) (= op (dec (+ Script'OP_1 b)))
                                (= (& b 0xff) 0x81) (= op Script'OP_1NEGATE)
                                :else false
                            )
                        )
                    (< al Script'OP_PUSHDATA1)
                        (= op al)
                    (< al 256)
                        (= op Script'OP_PUSHDATA1)
                    (< al 65536)
                        (= op Script'OP_PUSHDATA2)
                    :else
                        ;; Can never be used, but implemented for completeness.
                        (= op Script'OP_PUSHDATA4)
                )
            )
        )
    )

    #_method
    (defn #_"void" ScriptChunk''write-chunk [#_"ScriptChunk" this, #_"ByteArrayOutputStream" baos]
        (cond (ScriptChunk''is-op-code this)
            (do
                (assert-state (nil? (:data this)))
                (.write baos, (:opcode this))
            )
            (some? (:data this))
            (do
                (cond (< (:opcode this) Script'OP_PUSHDATA1)
                    (do
                        (assert-state (= (count (:data this)) (:opcode this)))
                        (.write baos, (:opcode this))
                    )
                    (= (:opcode this) Script'OP_PUSHDATA1)
                    (do
                        (assert-state (<= (count (:data this)) 0xff))
                        (.write baos, Script'OP_PUSHDATA1)
                        (.write baos, (count (:data this)))
                    )
                    (= (:opcode this) Script'OP_PUSHDATA2)
                    (do
                        (assert-state (<= (count (:data this)) 0xffff))
                        (.write baos, Script'OP_PUSHDATA2)
                        (.write baos, (& 0xff (count (:data this))))
                        (.write baos, (& 0xff (>> (count (:data this)) 8)))
                    )
                    (= (:opcode this) Script'OP_PUSHDATA4)
                    (do
                        (assert-state (<= (count (:data this)) Script'MAX_SCRIPT_ELEMENT_SIZE))
                        (.write baos, Script'OP_PUSHDATA4)
                        (Wire'write-uint32 (count (:data this)), baos)
                    )
                    :else
                    (do
                        (throw (RuntimeException. "Unimplemented"))
                    )
                )
                (.write baos, (:data this))
            )
            :else
            (do
                (.write baos, (:opcode this))
            )
        )
        nil
    )

    #_method
    (defn #_"String" ScriptChunk''to-string [#_"ScriptChunk" this]
        (cond (ScriptChunk''is-op-code this)
                (str (ScriptOpCodes'get-op-code-name (:opcode this)))
            (some? (:data this))
                (str (ScriptOpCodes'get-push-data-name (:opcode this)) "[" (Base16'encode (:data this)) "]")
            :else
                (str (Script'decode-from-op-n (:opcode this)))
        )
    )
)

;;;
 ; Tools for the construction of commonly used script types.  You don't normally need this as it's hidden
 ; behind convenience methods on {@link Transaction}, but they are useful when working with the protocol
 ; at a lower level.
 ;;
#_stateless
(class-ns ScriptBuilder
    ;;;
     ; Creates a fresh ScriptBuilder with an empty program.
     ;;
    (defn #_"ScriptBuilder" ScriptBuilder'new []
        (transient
            #_"[ScriptChunk]" (vector)
        )
    )

    ;;;
     ; Adds the given chunk to the end of the program.
     ;;
    #_method
    (defn #_"ScriptBuilder" ScriptBuilder''append [#_"ScriptBuilder" this, #_"ScriptChunk" chunk]
        (conj! this (ensure some? chunk))
    )

    ;;;
     ; Adds the given opcode to the end of the program.
     ;;
    #_method
    (defn #_"ScriptBuilder" ScriptBuilder''op [#_"ScriptBuilder" this, #_"int" opcode]
        (assert-argument (< Script'OP_PUSHDATA4 opcode))

        (ScriptBuilder''append this, (ScriptChunk'new opcode, nil))
    )

    ;;;
     ; Adds the given number to the end of the program.
     ; Automatically uses shortest encoding possible.
     ;;
    #_method
    (defn #_"ScriptBuilder" ScriptBuilder''num [#_"ScriptBuilder" this, #_"long" num]
        (if (<= 0 num 16)
            ;; Adds the given number as a OP_N opcode to the end of the program.
            ;; Only handles values 0-16 inclusive.
            (ScriptBuilder''append this, (ScriptChunk'new (Script'encode-to-op-n num), nil))
            ;; Adds the given number as a push data chunk.
            ;; This is intended to use for negative numbers or values > 16, and although
            ;; it will accept numbers in the range 0-16 inclusive, the encoding would be
            ;; considered non-standard.
            (let [#_"[byte]" data (->> (Math/abs num) (iterate #(>> % 8)) (take-while pos?) (map #(& % 0xff)) (into (vector)))
                  data
                    (cond
                        ;; The most significant byte is >= 0x80, so push an extra byte
                        ;; that contains just the sign of the value.
                        (= (& (peek data) 0x80) 0x80) (conj data (if (neg? num) 0x80 0))
                        ;; The most significant byte is < 0x80 and the value is negative,
                        ;; set the sign bit so it is subtracted and interpreted as a
                        ;; negative when converting back to an integral.
                        (neg? num)                    (conj (pop data) (| (peek data) 0x80))
                        :else                         data
                    )]
                ;; At most the encoded value could take up to 8 bytes, so we don't need
                ;; to use OP_PUSHDATA opcodes.
                (ScriptBuilder''append this, (ScriptChunk'new (count data), (byte-array data)))
            )
        )
    )

    ;;;
     ; Adds a copy of the given byte array as a data element (i.e. PUSHDATA) at the end of the program.
     ;;
    #_method
    (defn #_"ScriptBuilder" ScriptBuilder''data [#_"ScriptBuilder" this, #_"byte[]" data]
        ;; implements BIP62
        (let [data (or data (byte-array 0)) #_"int" n (count data)
              #_"int" opcode
                (cond
                    (= n 0)     Script'OP_0
                    (= n 1)     (let [#_"byte" b (nth data 0)] (if (<= 1 b 16) (Script'encode-to-op-n b) 1))
                    (< n Script'OP_PUSHDATA1) n
                    (< n 256)   Script'OP_PUSHDATA1
                    (< n 65536) Script'OP_PUSHDATA2
                    :else (throw (RuntimeException. "Unimplemented"))
                )]
            (ScriptBuilder''append this, (ScriptChunk'new opcode, (Arrays/copyOf data, n)))
        )
    )

    ;;;
     ; Creates a new immutable Script based on the state of the builder.
     ;;
    #_method
    (defn #_"Script" ScriptBuilder''to-script [#_"ScriptBuilder" this]
        (Script'new (persistent! this), nil)
    )

    ;;;
     ; Creates a scriptPubKey that encodes payment to the given address.
     ;;
    (defn #_"Script" Script'create-output-script-1a [#_"Address" to]
        (if (Address''is-p2sh-address to)
            ;; OP_HASH160 <scriptHash> OP_EQUAL
            (-> (ScriptBuilder'new)
                (ScriptBuilder''op Script'OP_HASH160)
                (ScriptBuilder''data (:addr-bytes to))
                (ScriptBuilder''op Script'OP_EQUAL)
                (ScriptBuilder''to-script)
            )
            ;; OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
            (-> (ScriptBuilder'new)
                (ScriptBuilder''op Script'OP_DUP)
                (ScriptBuilder''op Script'OP_HASH160)
                (ScriptBuilder''data (:addr-bytes to))
                (ScriptBuilder''op Script'OP_EQUALVERIFY)
                (ScriptBuilder''op Script'OP_CHECKSIG)
                (ScriptBuilder''to-script)
            )
        )
    )

    ;;;
     ; Creates a scriptPubKey that encodes payment to the given raw public key.
     ;;
    (defn #_"Script" Script'create-output-script-1e [#_"ECKey" key]
        (-> (ScriptBuilder'new)
            (ScriptBuilder''data (ECKey''get-pub-key key))
            (ScriptBuilder''op Script'OP_CHECKSIG)
            (ScriptBuilder''to-script)
        )
    )

    ;;;
     ; Creates a scriptSig that can redeem a pay-to-pubkey output.
     ; If given signature is null, incomplete scriptSig will be created with OP_0 instead of signature.
     ;;
    (defn #_"Script" Script'create-input-script-1 [#_"TransactionSignature" sig]
        (-> (ScriptBuilder'new)
            (ScriptBuilder''data (when (some? sig) (TransactionSignature''encode-to-bitcoin sig)))
            (ScriptBuilder''to-script)
        )
    )

    ;;;
     ; Creates a scriptSig that can redeem a pay-to-address output.
     ; If given signature is null, incomplete scriptSig will be created with OP_0 instead of signature.
     ;;
    (defn #_"Script" Script'create-input-script-2 [#_"TransactionSignature" sig, #_"ECKey" key]
        (-> (ScriptBuilder'new)
            (ScriptBuilder''data (when (some? sig) (TransactionSignature''encode-to-bitcoin sig)))
            (ScriptBuilder''data (ECKey''get-pub-key key))
            (ScriptBuilder''to-script)
        )
    )

    ;;;
     ; Creates a program that requires at least N of the given keys to sign, using OP_CHECKMULTISIG.
     ;;
    (defn #_"Script" Script'create-multi-sig-output-script [#_"int" threshold, #_"ECKey*" keys]
        (let [#_"int" n (count keys)]
            (assert-argument (<= 1 threshold n 16)) ;; That's the max we can represent with a single opcode.

            (when (< 3 n)
                (log/warn (str "Creating a multi-signature output that is non-standard: " n " pubkeys, should be <= 3"))
            )

            (-> (ScriptBuilder'new)
                (ScriptBuilder''num threshold)
                (#(reduce ScriptBuilder''data % (map ECKey''get-pub-key keys)))
                (ScriptBuilder''num n)
                (ScriptBuilder''op Script'OP_CHECKMULTISIG)
                (ScriptBuilder''to-script)
            )
        )
    )

    ;;;
     ; Create a program that satisfies an OP_CHECKMULTISIG program.
     ;;
    (defn #_"Script" Script'create-multi-sig-input-script [#_"List<TransactionSignature>" signatures]
        (let [#_"List<byte[]>" sigs (ArrayList. (count signatures))]
            (doseq [#_"TransactionSignature" signature signatures]
                (ยง ass sigs (.add sigs, (TransactionSignature''encode-to-bitcoin signature)))
            )
            (Script'create-multi-sig-input-script-bytes-2 sigs, nil)
        )
    )

    ;;;
     ; Create a program that satisfies an OP_CHECKMULTISIG program, using pre-encoded signatures.
     ;;
    (defn #_"Script" Script'create-multi-sig-input-script-bytes-1 [#_"List<byte[]>" signatures]
        (Script'create-multi-sig-input-script-bytes-2 signatures, nil)
    )

    ;;;
     ; Create a program that satisfies a pay-to-script hashed OP_CHECKMULTISIG program.
     ; If given signature list is null, incomplete scriptSig will be created with OP_0 instead of signatures.
     ;;
    (defn #_"Script" Script'create-p2sh-multi-sig-input-script [#_"List<TransactionSignature>" signatures, #_"Script" script]
        (let [#_"List<byte[]>" sigs (ArrayList.)]
            (if (some? signatures)
                (doseq [#_"TransactionSignature" signature signatures]
                    (ยง ass sigs (.add sigs, (TransactionSignature''encode-to-bitcoin signature)))
                )
                ;; Create correct number of empty signatures.
                (dotimes [_ (Script''get-number-of-signatures-required-to-spend script)]
                    (ยง ass sigs (.add sigs, (byte-array 0)))
                )
            )
            (Script'create-multi-sig-input-script-bytes-2 sigs, (Script''to-bytes script))
        )
    )

    ;;;
     ; Create a program that satisfies an OP_CHECKMULTISIG program, using pre-encoded signatures.
     ; Optionally, appends the script program bytes if spending a P2SH output.
     ;;
    (defn #_"Script" Script'create-multi-sig-input-script-bytes-2 [#_"List<byte[]>" sigs, #_"byte[]" program]
        (assert-argument (<= (count sigs) 16))

        (-> (ScriptBuilder'new)
            (ScriptBuilder''num 0) ;; Work around a bug in CHECKMULTISIG that is now a required part of the protocol.
            (#(reduce ScriptBuilder''data % sigs))
            (#(if (some? program) (ScriptBuilder''data %, program) %))
            (ScriptBuilder''to-script)
        )
    )

    ;;;
     ; Returns a copy of the given scriptSig with the signature inserted in the given position.
     ;
     ; This function assumes that any missing sigs have OP_0 placeholders.  If given scriptSig
     ; already has all the signatures in place, IllegalArgumentException will be thrown.
     ;
     ; @param targetIndex Where to insert the signature.
     ; @param sigsPrefixCount How many items to copy verbatim (e.g. initial OP_0 for multisig).
     ; @param sigsSuffixCount How many items to copy verbatim at end (e.g. redeemScript for P2SH).
     ;;
    (defn #_"Script" Script'update-script-with-signature [#_"Script" script, #_"byte[]" sig, #_"int" target, #_"int" prefix, #_"int" suffix]
        (let [#_"[ScriptChunk]" chunks (:chunks script) #_"int" m (count chunks)
              ;; Check if we have a place to insert, otherwise just return given scriptSig unchanged.
              ;; We assume here that OP_0 placeholders always go after the sigs, so
              ;; to find if we have sigs missing, we can just check the chunk in latest sig position.
              #_"boolean" missing? (ScriptChunk''equals-op-code (nth chunks (- m suffix 1)), Script'OP_0)]
            (assert-argument missing?, "ScriptSig is already filled with signatures")

            (let [#_"ScriptBuilder" sb (ScriptBuilder'new)
                  ;; Copy the prefix.
                  sb (reduce ScriptBuilder''append sb (subvec chunks 0 prefix))
                  ;; Copy the sigs.
                  [sb #_"int" i #_"boolean" done?]
                    (loop-when [sb sb i 0 done? false #_"ScriptChunk*" s (subvec chunks prefix (- m suffix))] (seq s) => [sb i done?]
                        (let [#_"ScriptChunk" chunk (first s)
                              [sb i done?]
                                (when (= i target) => [sb i done?]
                                    [(ScriptBuilder''data sb, sig) (inc i) true]
                                )
                              [sb i]
                                (when-not (ScriptChunk''equals-op-code chunk, Script'OP_0) => [sb i]
                                    [(ScriptBuilder''append sb, chunk) (inc i)]
                                )]
                            (recur sb i done? (next s))
                        )
                    )
                  ;; Add OP_0's if needed, since we skipped them in the previous loop.
                  [sb i done?]
                    (loop-when [sb sb i i done? done?] (< i (- m prefix suffix)) => [sb i done?]
                        (let [[sb done?]
                                (if (= i target)
                                    [(ScriptBuilder''data sb, sig) true]
                                    [(ScriptBuilder''append sb, (ScriptChunk'new Script'OP_0, nil)) done?]
                                )]
                            (recur sb (inc i) done?)
                        )
                    )
                  ;; Copy the suffix.
                  sb (reduce ScriptBuilder''append sb (subvec chunks (- m suffix) m))]
                (assert-state done?)

                (ScriptBuilder''to-script sb)
            )
        )
    )

    ;;;
     ; Creates a scriptPubKey that sends to the given script hash.  Read
     ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP 16</a>
     ; to learn more about this kind of script.
     ;;
    (defn #_"Script" Script'create-p2sh-output-script-1-bytes [#_"byte[]" hash]
        (assert-argument (= (count hash) 20))

        (-> (ScriptBuilder'new)
            (ScriptBuilder''op Script'OP_HASH160)
            (ScriptBuilder''data hash)
            (ScriptBuilder''op Script'OP_EQUAL)
            (ScriptBuilder''to-script)
        )
    )

    ;;;
     ; Creates a scriptPubKey for the given redeem script.
     ;;
    (defn #_"Script" Script'create-p2sh-output-script-1 [#_"Script" redeem]
        (let [#_"byte[]" hash (Utils'sha256hash160 (Script''to-bytes redeem))]
            (Script'create-p2sh-output-script-1-bytes hash)
        )
    )

    ;;;
     ; Creates a P2SH output script with given public keys and threshold.
     ; Given public keys will be placed in redeem script in the lexicographical sorting order.
     ;;
    (defn #_"Script" Script'create-p2sh-output-script-2 [#_"int" threshold, #_"List<ECKey>" keys]
        (let [#_"Script" redeem (Script'create-redeem-script threshold, keys)]
            (Script'create-p2sh-output-script-1 redeem)
        )
    )

    ;;;
     ; Creates redeem script with given public keys and threshold.
     ; Given public keys will be placed in redeem script in the lexicographical sorting order.
     ;;
    (defn #_"Script" Script'create-redeem-script [#_"int" threshold, #_"List<ECKey>" keys]
        (Script'create-multi-sig-output-script threshold, (sort ECKey'compare-by-pub-key keys))
    )

    ;;;
     ; Creates a script of the form OP_RETURN [data].  This feature allows you to attach
     ; a small piece of data (like a hash of something stored elsewhere) to a zero valued
     ; output which can never be spent and thus does not pollute the ledger.
     ;;
    (defn #_"Script" Script'create-op-return-script [#_"byte[]" data]
        (assert-argument (<= (count data) 80))

        (-> (ScriptBuilder'new)
            (ScriptBuilder''op Script'OP_RETURN)
            (ScriptBuilder''data data)
            (ScriptBuilder''to-script)
        )
    )

    (defn #_"Script" Script'create-cltv-payment-channel-output [#_"BigInteger" time, #_"ECKey" from, #_"ECKey" to]
        (let [#_"byte[]" bytes (Wire'reverse-bytes (Wire'encode-mpi time, false))]
            (when-not (< 5 (count bytes)) => (throw (RuntimeException. "Time too large to encode as 5-byte int"))
                (-> (ScriptBuilder'new)
                    (ScriptBuilder''op Script'OP_IF)
                    (ScriptBuilder''data (ECKey''get-pub-key to))
                    (ScriptBuilder''op Script'OP_CHECKSIGVERIFY)
                    (ScriptBuilder''op Script'OP_ELSE)
                    (ScriptBuilder''data bytes)
                    (ScriptBuilder''op Script'OP_CHECKLOCKTIMEVERIFY)
                    (ScriptBuilder''op Script'OP_DROP)
                    (ScriptBuilder''op Script'OP_ENDIF)
                    (ScriptBuilder''data (ECKey''get-pub-key from))
                    (ScriptBuilder''op Script'OP_CHECKSIG)
                    (ScriptBuilder''to-script)
                )
            )
        )
    )

    (defn #_"Script" Script'create-cltv-payment-channel-refund [#_"TransactionSignature" sig]
        (-> (ScriptBuilder'new)
            (ScriptBuilder''data (TransactionSignature''encode-to-bitcoin sig))
            (ScriptBuilder''data (byte-array [ 0 ])) ;; Use the CHECKLOCKTIMEVERIFY if branch.
            (ScriptBuilder''to-script)
        )
    )

    (defn #_"Script" Script'create-cltv-payment-channel-p2sh-refund [#_"TransactionSignature" sig, #_"Script" redeem]
        (-> (ScriptBuilder'new)
            (ScriptBuilder''data (TransactionSignature''encode-to-bitcoin sig))
            (ScriptBuilder''data (byte-array [ 0 ])) ;; Use the CHECKLOCKTIMEVERIFY if branch.
            (ScriptBuilder''data (Script''to-bytes redeem))
            (ScriptBuilder''to-script)
        )
    )

    (defn #_"Script" Script'create-cltv-payment-channel-p2sh-input [#_"byte[]" from, #_"byte[]" to, #_"Script" redeem]
        (-> (ScriptBuilder'new)
            (ScriptBuilder''data from)
            (ScriptBuilder''data to)
            (ScriptBuilder''num 1) ;; Use the CHECKLOCKTIMEVERIFY if branch.
            (ScriptBuilder''data (Script''to-bytes redeem))
            (ScriptBuilder''to-script)
        )
    )

    (defn #_"Script" Script'create-cltv-payment-channel-input-2 [#_"TransactionSignature" from, #_"TransactionSignature" to]
        (Script'create-cltv-payment-channel-input-2-bytes (TransactionSignature''encode-to-bitcoin from), (TransactionSignature''encode-to-bitcoin to))
    )

    (defn #_"Script" Script'create-cltv-payment-channel-input-2-bytes [#_"byte[]" from, #_"byte[]" to]
        (-> (ScriptBuilder'new)
            (ScriptBuilder''data from)
            (ScriptBuilder''data to)
            (ScriptBuilder''num 1) ;; Use the CHECKLOCKTIMEVERIFY if branch.
            (ScriptBuilder''to-script)
        )
    )
)

;;;
 ; Programs embedded inside transactions that control redemption of payments.
 ;
 ; Bitcoin transactions don't specify what they do directly.  Instead
 ; <a href="https://en.bitcoin.it/wiki/Script">a small binary stack language</a> is used to define programs that
 ; when evaluated, return whether the transaction "accepts" or rejects the other transactions connected to it.
 ;
 ; In SPV mode, scripts are not run, because that would require all transactions to be available and lightweight
 ; clients don't have that data.  In full mode, this class is used to run the interpreted language.  It also has
 ; static methods for building scripts.
 ;;
(class-ns Script
    (def #_"{ScriptVerifyFlag}" Script'ALL_VERIFY_FLAGS ScriptVerifyFlag'enum-set)

    (def #_"long" Script'MAX_SCRIPT_ELEMENT_SIZE 520) ;; bytes
    (def- #_"int" Script'MAX_OPS_PER_SCRIPT 201)
    (def- #_"int" Script'MAX_STACK_SIZE 1000)
    (def- #_"int" Script'MAX_PUBKEYS_PER_MULTISIG 20)
    (def- #_"int" Script'MAX_SCRIPT_SIZE 10000)
    (def #_"int" Script'SIG_SIZE 75)
    ;;;
     ; Max number of sigops allowed in a standard p2sh redeem script.
     ;;
    (def #_"int" Script'MAX_P2SH_SIGOPS 15)

    (defn- #_"Script" Script'new [#_"ScriptChunk*" chunks, #_"byte[]" program]
        (hash-map
            ;; The program is a set of chunks where each element is either [opcode] or [data, data, data ...].
            #_"[ScriptChunk]" :chunks (vec chunks)
            ;; Unfortunately, scripts are not ever re-serialized or canonicalized when used in signature hashing.
            ;; Thus we must preserve the exact bytes that we read off the wire, along with the parsed form.
            #_"byte[]" :program program
        )
    )

    ;;;
     ; To run a script, first we parse it which breaks it up into chunks representing pushes of data
     ; or logical opcodes.  Then we can run the parsed chunks.
     ;
     ; The reason for this split, instead of just interpreting directly, is to make it easier
     ; to reach into a programs structure and pull out bits of data without having to run it.
     ; This is necessary to render the to/from addresses of transactions in a user interface.
     ; Bitcoin Core does something similar.
     ;;
    #_throws #_[ "ScriptException" ]
    (defn #_"Script" Script'parse [#_"byte[]" bytes]
        (let [#_"Script" this (Script'new nil, bytes)
              #_"ByteArrayInputStream" bais (ByteArrayInputStream. bytes)]
            (while (pos? (.available bais))
                (let [#_"int" opcode (.read bais)
                      #_"long" n
                        (cond (< -1 opcode Script'OP_PUSHDATA1)
                            (do
                                ;; Read some bytes of data, where how many is the opcode value itself.
                                opcode
                            )
                            (= opcode Script'OP_PUSHDATA1)
                            (do
                                (when (< (.available bais) 1)
                                    (throw+ (ScriptException'new :ScriptError'UNKNOWN_ERROR, "Unexpected end of script"))
                                )
                                (.read bais)
                            )
                            (= opcode Script'OP_PUSHDATA2)
                            (do
                                ;; Read a short, then read that many bytes of data.
                                (when (< (.available bais) 2)
                                    (throw+ (ScriptException'new :ScriptError'UNKNOWN_ERROR, "Unexpected end of script"))
                                )
                                (| (.read bais) (<< (.read bais) 8))
                            )
                            (= opcode Script'OP_PUSHDATA4)
                            (do
                                ;; Read a uint32, then read that many bytes of data.
                                ;; Though this is allowed, because its value cannot be > 520, it should never actually be used.
                                (when (< (.available bais) 4)
                                    (throw+ (ScriptException'new :ScriptError'UNKNOWN_ERROR, "Unexpected end of script"))
                                )
                                (| (long (.read bais)) (<< (long (.read bais)) 8) (<< (long (.read bais)) 16) (<< (long (.read bais)) 24))
                            )
                        )
                      #_"ScriptChunk" chunk
                        (when (some? n) => (ScriptChunk'new opcode, nil)
                            (when (< (.available bais) n)
                                (throw+ (ScriptException'new :ScriptError'BAD_OPCODE, "Push of data element that is larger than remaining data"))
                            )
                            (let [#_"byte[]" data (byte-array n) #_"int" m (.read bais, data)]
                                (assert-state (= m n))
                                (ScriptChunk'new opcode, data)
                            )
                        )]

                    (ยง ass this (append* this :chunks chunk))
                )
            )
            this
        )
    )

    ;;;
     ; Returns the serialized program as a newly created byte array.
     ;;
    #_method
    (defn #_"byte[]" Script''to-bytes [#_"Script" this]
        ;; Don't round-trip as Bitcoin Core doesn't and it would introduce a mismatch.
        (when (nil? (:program this)) => (Arrays/copyOf (:program this), (count (:program this)))
            (let [#_"ByteArrayOutputStream" baos (ByteArrayOutputStream.)]
                (doseq [#_"ScriptChunk" chunk (:chunks this)]
                    (ScriptChunk''write-chunk chunk, baos)
                )
                (ยง ass this (assoc this :program (.toByteArray baos)))
                (:program this)
            )
        )
    )

    ;;;
     ; Returns true if this script is of the form <pubkey> OP_CHECKSIG.  This form was originally intended for
     ; transactions where the peers talked to each other directly via TCP/IP, but has fallen out of favor with time
     ; due to that mode of operation being susceptible to man-in-the-middle attacks.  It is still used in coinbase
     ; outputs and can be useful more exotic types of transaction, but today most payments are to addresses.
     ;;
    #_method
    (defn #_"boolean" Script''is-sent-to-raw-pub-key [#_"Script" this]
        (let [#_"[ScriptChunk]" chunks (:chunks this)]
            (and (= (count chunks) 2)
                (ScriptChunk''equals-op-code (nth chunks 1), Script'OP_CHECKSIG)
                (not (ScriptChunk''is-op-code (nth chunks 0)))
                (< 1 (count (:data (nth chunks 0))))
            )
        )
    )

    ;;;
     ; Returns true if this script is of the form DUP HASH160 <pubkey hash> EQUALVERIFY CHECKSIG, i.e. payment to an
     ; address like 1VayNert3x1KzbpzMGt2qdqrAThiRovi8.  This form was originally intended for the case where you wish
     ; to send somebody money with a written code because their node is offline, but over time has become the standard
     ; way to make payments due to the short and recognizable base58 form addresses come in.
     ;;
    #_method
    (defn #_"boolean" Script''is-sent-to-address [#_"Script" this]
        (let [#_"[ScriptChunk]" chunks (:chunks this)]
            (and (= (count chunks) 5)
                (ScriptChunk''equals-op-code (nth chunks 0), Script'OP_DUP)
                (ScriptChunk''equals-op-code (nth chunks 1), Script'OP_HASH160)
                            (= (count (:data (nth chunks 2))) Address'LENGTH)
                (ScriptChunk''equals-op-code (nth chunks 3), Script'OP_EQUALVERIFY)
                (ScriptChunk''equals-op-code (nth chunks 4), Script'OP_CHECKSIG)
            )
        )
    )

    ;;;
     ; If a program matches the standard template DUP HASH160 <pubkey hash> EQUALVERIFY CHECKSIG,
     ; then this function retrieves the third element.
     ; In this case, this is useful for fetching the destination address of a transaction.
     ;
     ; If a program matches the standard template HASH160 <script hash> EQUAL,
     ; then this function retrieves the second element.
     ; In this case, this is useful for fetching the hash of the redeem script of a transaction.
     ;
     ; Otherwise it throws a ScriptException.
     ;
     ;;
    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"byte[]" Script''get-pub-key-hash [#_"Script" this]
        (cond
            (Script''is-sent-to-address this)    (:data (nth (:chunks this) 2))
            (Script''is-pay-to-script-hash this) (:data (nth (:chunks this) 1))
            :else (throw+ (ScriptException'new :ScriptError'UNKNOWN_ERROR, "Script not in the standard scriptPubKey form"))
        )
    )

    ;;;
     ; Returns the public key in this script.  If a script contains two constants and nothing else, it is assumed
     ; to be a scriptSig (input) for a pay-to-address output and the second constant is returned (the first is the
     ; signature).  If a script contains a constant and an OP_CHECKSIG opcode, the constant is returned as it is
     ; assumed to be a direct pay-to-key scriptPubKey (output) and the first constant is the public key.
     ;
     ; @throws ScriptException if the script is none of the named forms.
     ;;
    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"byte[]" Script''get-pub-key [#_"Script" this]
        (when-not (= (count (:chunks this)) 2)
            (throw+ (ScriptException'new :ScriptError'UNKNOWN_ERROR, (str "Script not of right size, expecting 2 but got " (count (:chunks this)))))
        )

        (let [#_"ScriptChunk" chunk0 (nth (:chunks this) 0) #_"byte[]" data0 (:data chunk0)
              #_"ScriptChunk" chunk1 (nth (:chunks this) 1) #_"byte[]" data1 (:data chunk1)]
            (cond
                ;; If we have two large constants assume the input to a pay-to-address output.
                (and (some? data0) (< 2 (count data0)) (some? data1) (< 2 (count data1))) data1
                ;; A large constant followed by an OP_CHECKSIG is the key.
                (and (ScriptChunk''equals-op-code chunk1, Script'OP_CHECKSIG) (some? data0) (< 2 (count data0))) data0
                :else (throw+ (ScriptException'new :ScriptError'UNKNOWN_ERROR, (str "Script did not match expected form: " this)))
            )
        )
    )

    ;;;
     ; Retrieves the sender public key from a LOCKTIMEVERIFY transaction.
     ;
     ; @throws ScriptException
     ;;
    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"byte[]" Script''get-cltv-payment-channel-sender-pub-key [#_"Script" this]
        (if (Script''is-sent-to-cltv-payment-channel this)
            (:data (nth (:chunks this) 8))
            (throw+ (ScriptException'new :ScriptError'UNKNOWN_ERROR, (str "Script not a standard CHECKLOCKTIMVERIFY transaction: " this)))
        )
    )

    ;;;
     ; Retrieves the recipient public key from a LOCKTIMEVERIFY transaction.
     ;
     ; @throws ScriptException
     ;;
    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"byte[]" Script''get-cltv-payment-channel-recipient-pub-key [#_"Script" this]
        (if (Script''is-sent-to-cltv-payment-channel this)
            (:data (nth (:chunks this) 1))
            (throw+ (ScriptException'new :ScriptError'UNKNOWN_ERROR, (str "Script not a standard CHECKLOCKTIMVERIFY transaction: " this)))
        )
    )

    #_method
    (defn #_"BigInteger" Script''get-cltv-payment-channel-expiry [#_"Script" this]
        (if (Script''is-sent-to-cltv-payment-channel this)
            (Script'cast-to-big-integer-3 (:data (nth (:chunks this) 4)), 5, false)
            (throw+ (ScriptException'new :ScriptError'UNKNOWN_ERROR, (str "Script not a standard CHECKLOCKTIMEVERIFY transaction: " this)))
        )
    )

    ;;;
     ; For 2-element [input] scripts assumes that the paid-to-address can be derived from the public key.
     ; The concept of a "from address" isn't well defined in Bitcoin and you should not assume the sender
     ; of a transaction can actually receive coins on it. This method may be removed in future.
     ;;
    #_deprecated
    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"Address" Script''get-from-address [#_"Script" this, #_"Ledger" ledger]
        (Address'from-hash160 ledger, (Utils'sha256hash160 (Script''get-pub-key this)))
    )

    ;;;
     ; Gets the destination address from this script, if it's in the required form (see getPubKey).
     ;;
    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"Address" Script''get-to-address-2 [#_"Script" this, #_"Ledger" ledger]
        (Script''get-to-address-3 this, ledger, false)
    )

    ;;;
     ; Gets the destination address from this script, if it's in the required form (see getPubKey).
     ;
     ; @param forcePayToPubKey If true, allow payToPubKey to be casted to the corresponding address.
     ;                         This is useful if you prefer showing addresses rather than pubkeys.
     ;;
    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"Address" Script''get-to-address-3 [#_"Script" this, #_"Ledger" ledger, #_"boolean" force?]
        (cond
            (Script''is-sent-to-address this)                  (Address'from-hash160 ledger, (Script''get-pub-key-hash this))
            (Script''is-pay-to-script-hash this)               (Address'from-p2sh-script ledger, this)
            (and force? (Script''is-sent-to-raw-pub-key this)) (ECKey''to-address (ECKey'from-public-only-bytes (Script''get-pub-key this)), ledger)
            :else (throw+ (ScriptException'new :ScriptError'UNKNOWN_ERROR, "Cannot cast this script to a pay-to-address type"))
        )
    )

    ;;;
     ; Writes out the given byte buffer to the output stream with the correct opcode prefix.
     ; To write an integer call writeBytes(stream, Utils.reverseBytes(Utils.encodeMPI(val, false))).
     ;;
    (defn #_"void" Script'write-bytes [#_"ByteArrayOutputStream" baos, #_"byte[]" bytes]
        (let [#_"int" n (count bytes)]
            (cond
                (< n Script'OP_PUSHDATA1)
                (do
                    (.write baos, n)
                    (.write baos, bytes)
                )
                (< n 256)
                (do
                    (.write baos, Script'OP_PUSHDATA1)
                    (.write baos, n)
                    (.write baos, bytes)
                )
                (< n 65536)
                (do
                    (.write baos, Script'OP_PUSHDATA2)
                    (.write baos, (& 0xff n))
                    (.write baos, (& 0xff (>> n 8)))
                    (.write baos, bytes)
                )
                :else
                (do
                    (throw (RuntimeException. "Unimplemented"))
                )
            )
        )
        nil
    )

    ;;;
     ; Creates an incomplete scriptSig that, once filled with signatures, can redeem output containing this scriptPubKey.
     ; Instead of the signatures resulting script has OP_0.
     ; Having incomplete input script allows to pass around partially signed tx.
     ; It is expected that this program later on will be updated with proper signatures.
     ;;
    #_method
    (defn #_"Script" Script''create-empty-input-script [#_"Script" this, #_"ECKey" key, #_"Script" redeem]
        (cond
            (Script''is-sent-to-address this)
            (do
                (assert-argument (some? key), "Key required to create pay-to-address input script")
                (Script'create-input-script-2 nil, key)
            )
            (Script''is-sent-to-raw-pub-key this)
                (Script'create-input-script-1 nil)
            (Script''is-pay-to-script-hash this)
            (do
                (assert-argument (some? redeem), "Redeem script required to create P2SH input script")
                (Script'create-p2sh-multi-sig-input-script nil, redeem)
            )
            :else
                (throw+ (ScriptException'new :ScriptError'UNKNOWN_ERROR, (str "Do not understand script type: " this)))
        )
    )

    ;;;
     ; Returns a copy of the given scriptSig with the signature inserted in the given position.
     ;;
    #_method
    (defn #_"Script" Script''get-script-sig-with-signature [#_"Script" this, #_"Script" script, #_"byte[]" bytes, #_"int" index]
        (let [[#_"int" prefix #_"int" suffix]
                (cond
                    (Script''is-pay-to-script-hash this) [1 1] ;; OP_0 <sig>* <redeemScript>
                    (Script''is-sent-to-multi-sig this)  [1 0] ;; OP_0 <sig>*
                    (Script''is-sent-to-address this)    [0 1] ;; <sig> <pubkey>
                    :else                                [0 0]
                )]
            (Script'update-script-with-signature script, bytes, index, prefix, suffix)
        )
    )

    ;;;
     ; Returns the index where a signature by the key should be inserted.
     ; Only applicable to a P2SH scriptSig.
     ;;
    #_method
    (defn #_"int" Script''get-sig-insertion-index [#_"Script" this, #_"Sha256Hash" hash, #_"ECKey" key]
        ;; Iterate over existing signatures, skipping the initial OP_0, the final redeem script and any placeholder OP_0 sigs.
        (let [#_"int" n (dec (count (:chunks this)))
              #_"Script" redeem (Script'parse (ensure some? (:data (nth (:chunks this) n))))
              #_"int" m (Script''find-key-in-redeem redeem, key)]
            (loop-when [#_"int" i 0 #_"ScriptChunk*" chunks (subvec (:chunks this) 1 n)] (seq chunks) => i
                (let [#_"ScriptChunk" chunk (first chunks)]
                    (when-not (= (:opcode chunk) Script'OP_0) => (recur i (next chunks))
                        (if (< m (Script''find-sig-in-redeem redeem, (ensure some? (:data chunk)), hash))
                            i
                            (recur (inc i) (next chunks))
                        )
                    )
                )
            )
        )
    )

    #_method
    (defn- #_"int" Script''find-key-in-redeem [#_"Script" this, #_"ECKey" key]
        (assert-argument (ScriptChunk''is-op-code (nth (:chunks this) 0))) ;; P2SH scriptSig

        (let [#_"int" n (Script'decode-from-op-n (:opcode (nth (:chunks this) (- (count (:chunks this)) 2))))]
            (loop-when [#_"int" i 0] (< i n) => (throw (IllegalStateException. (str "Could not find matching key " key " in script " this)))
                (if (Arrays/equals (:data (nth (:chunks this) (inc i))), (ECKey''get-pub-key key))
                    i
                    (recur (inc i))
                )
            )
        )
    )

    ;;;
     ; Returns a list of the keys required by this script, assuming a multi-sig script.
     ;
     ; @throws ScriptException if the script type is not understood or is pay to address or is P2SH (run this method on the "Redeem script" instead).
     ;;
    #_method
    (defn #_"List<ECKey>" Script''get-pub-keys [#_"Script" this]
        (when-not (Script''is-sent-to-multi-sig this)
            (throw+ (ScriptException'new :ScriptError'UNKNOWN_ERROR, "Only usable for multisig scripts."))
        )

        (let [#_"List<ECKey>" keys (ArrayList.)]
            (dotimes [#_"int" i (Script'decode-from-op-n (:opcode (nth (:chunks this) (- (count (:chunks this)) 2))))]
                (ยง ass keys (.add keys, (ECKey'from-public-only-bytes (:data (nth (:chunks this) (inc i))))))
            )
            keys
        )
    )

    #_method
    (defn- #_"int" Script''find-sig-in-redeem [#_"Script" this, #_"byte[]" bytes, #_"Sha256Hash" hash]
        (assert-argument (ScriptChunk''is-op-code (nth (:chunks this) 0))) ;; P2SH scriptSig

        (let [#_"int" n (Script'decode-from-op-n (:opcode (nth (:chunks this) (- (count (:chunks this)) 2))))
              #_"TransactionSignature" signature (TransactionSignature'decode-from-bitcoin bytes, true, false)]
            (loop-when [#_"int" i 0] (< i n) => (throw (IllegalStateException. (str "Could not find matching key for signature on " hash " sig " (Base16'encode bytes))))
                (if (ECKey''verify-3s (ECKey'from-public-only-bytes (:data (nth (:chunks this) (inc i)))), hash, signature)
                    i
                    (recur (inc i))
                )
            )
        )
    )

    #_throws #_[ "ScriptException" ]
    (defn- #_"int" Script'get-sig-op-count-2 [#_"ScriptChunk*" chunks, #_"boolean" accurate?]
        (loop-when [#_"int" ops 0 #_"int" prior Script'OP_INVALIDOPCODE chunks chunks] (seq chunks) => ops
            (let [#_"ScriptChunk" chunk (first chunks)
                  [ops prior]
                    (when (ScriptChunk''is-op-code chunk) => [ops prior]
                        (let [ops
                                (condp =? (:opcode chunk)
                                    [Script'OP_CHECKSIG Script'OP_CHECKSIGVERIFY]
                                        (inc ops)
                                    [Script'OP_CHECKMULTISIG Script'OP_CHECKMULTISIGVERIFY]
                                        (if (and accurate? (<= Script'OP_1 prior Script'OP_16))
                                            (+ ops (Script'decode-from-op-n prior))
                                            (+ ops 20)
                                        )
                                    ops
                                )]
                            [ops (:opcode chunk)]
                        )
                    )]
                (recur ops prior (next chunks))
            )
        )
    )

    (defn #_"int" Script'decode-from-op-n [#_"int" opcode]
        (assert-argument (or (= opcode Script'OP_0) (= opcode Script'OP_1NEGATE) (<= Script'OP_1 opcode Script'OP_16)), "decodeFromOpN called on non OP_N opcode")
        (condp = opcode Script'OP_0 0 Script'OP_1NEGATE -1 (- (inc opcode) Script'OP_1))
    )

    (defn #_"int" Script'encode-to-op-n [#_"int" value]
        (assert-argument (<= -1 value 16), (str "encodeToOpN called for " value " which we cannot encode in an opcode"))
        (condp = value 0 Script'OP_0 -1 Script'OP_1NEGATE (+ (dec value) Script'OP_1))
    )

    ;;;
     ; Gets the count of regular SigOps in the script program (counting multisig ops as 20).
     ;;
    #_throws #_[ "ScriptException" ]
    (defn #_"int" Script'get-sig-op-count-1 [#_"byte[]" prog]
        (let [#_"Script" script
                (try+
                    (Script'parse prog)
                    (ยง catch ScriptException _
                        ;; Ignore errors and count up to the parse-able length.
                        (ยง nil script)
                    )
                )]
            (Script'get-sig-op-count-2 (:chunks script), false)
        )
    )

    ;;;
     ; Gets the count of P2SH Sig Ops in the Script scriptSig.
     ;;
    #_throws #_[ "ScriptException" ]
    (defn #_"int" Script'get-p2sh-sig-op-count [#_"byte[]" sig]
        (let [#_"Script" script
                (try+
                    (Script'parse sig)
                    (ยง catch ScriptException _
                        ;; Ignore errors and count up to the parse-able length.
                        (ยง nil script)
                    )
                )]
            (let-when [#_"ScriptChunk" chunk (first (remove ScriptChunk''is-op-code (reverse (:chunks script))))] (some? chunk) => 0
                (-> (Script'parse (:data chunk)) :chunks (Script'get-sig-op-count-2 true))
            )
        )
    )

    ;;;
     ; Returns number of signatures required to satisfy this script.
     ;;
    #_method
    (defn #_"int" Script''get-number-of-signatures-required-to-spend [#_"Script" this]
        (cond
            ;; For N of M CHECKMULTISIG script we will need N signatures to spend.
            (Script''is-sent-to-multi-sig this)
                (Script'decode-from-op-n (:opcode (nth (:chunks this) 0)))
            ;; pay-to-address and pay-to-pubkey require single sig
            (or (Script''is-sent-to-address this) (Script''is-sent-to-raw-pub-key this))
                1
            (Script''is-pay-to-script-hash this)
                (throw (IllegalStateException. "For P2SH number of signatures depends on redeem script"))
            :else
                (throw (IllegalStateException. "Unsupported script type"))
        )
    )

    ;;;
     ; Returns number of bytes required to spend this script.  It accepts optional ECKey and redeemScript
     ; that may be required for certain types of script to estimate target size.
     ;;
    #_method
    (defn #_"int" Script''get-number-of-bytes-required-to-spend [#_"Script" this, #_"ECKey" __pubKey, #_"Script" redeem]
        (cond
            (Script''is-pay-to-script-hash this)  ;; scriptSig: <sig> [sig] [sig...] <redeemscript>
            (do
                (assert-argument (some? redeem), "P2SH script requires redeemScript to be spent")
                (+ (* (Script''get-number-of-signatures-required-to-spend redeem) Script'SIG_SIZE) (count (Script''to-bytes redeem)))
            )
            (Script''is-sent-to-multi-sig this)   ;; scriptSig: OP_0 <sig> [sig] [sig...]
            (do
                (inc (* (Script''get-number-of-signatures-required-to-spend this) Script'SIG_SIZE))
            )
            (Script''is-sent-to-raw-pub-key this) ;; scriptSig: <sig>
            (do
                Script'SIG_SIZE
            )
            (Script''is-sent-to-address this)     ;; scriptSig: <sig> <pubkey>
            (do
                (+ Script'SIG_SIZE (if (some? __pubKey) (count (ECKey''get-pub-key __pubKey)) 65))
            )
            :else
            (do
                (throw (IllegalStateException. "Unsupported script type"))
            )
        )
    )

    ;;;
     ; Whether or not this is a scriptPubKey representing a pay-to-script-hash output.  In such outputs, the logic
     ; that controls reclamation is not actually in the output at all.  Instead there's just a hash, and it's up to the
     ; spending input to provide a program matching that hash.  This rule is "soft enforced" by the network as it does
     ; not exist in Bitcoin Core.  It means blocks containing P2SH transactions that don't match
     ; correctly are considered valid, but won't be mined upon, so they'll be rapidly re-orgd out of the chain.  This
     ; logic is defined by <a href="https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki">BIP 16</a>.
     ;
     ; bitcoinj does not support creation of P2SH transactions today.  The goal of P2SH is to allow short addresses
     ; even for complex scripts (e.g. multi-sig outputs) so they are convenient to work with in things like QRcodes or
     ; with copy/paste, and also to minimize the size of the unspent output set (which improves performance of the
     ; Bitcoin system).
     ;;
    #_method
    (defn #_"boolean" Script''is-pay-to-script-hash [#_"Script" this]
        ;; We have to check against the serialized form because BIP16 defines a P2SH output using an exact byte
        ;; template, not the logical program structure.  Thus you can have two programs that look identical when
        ;; printed out but one is a P2SH script and the other isn't! :( ;; )
        (let [#_"byte[]" prog (Script''to-bytes this)]
            (and (= (count prog) 23)
                 (= (& 0xff (nth prog 0)) Script'OP_HASH160)
                 (= (& 0xff (nth prog 1)) 0x14)
                 (= (& 0xff (nth prog 22)) Script'OP_EQUAL))
        )
    )

    ;;;
     ; Returns whether this script matches the format used for multisig outputs: [n] [keys...] [m] CHECKMULTISIG.
     ;;
    #_method
    (defn #_"boolean" Script''is-sent-to-multi-sig [#_"Script" this]
        (let [#_"[ScriptChunk]" chunks (:chunks this) #_"int" m (count chunks)]
            (and (<= 4 m)
                (let [#_"ScriptChunk" c1 (nth chunks (dec m))]
                    ;; Must end in OP_CHECKMULTISIG[VERIFY].
                    (and (ScriptChunk''is-op-code c1)
                        (or (ScriptChunk''equals-op-code c1, Script'OP_CHECKMULTISIG)
                            (ScriptChunk''equals-op-code c1, Script'OP_CHECKMULTISIGVERIFY))
                        (try
                            ;; Second to last chunk must be an OP_N opcode and there should be that many data chunks (keys).
                            (let [#_"ScriptChunk" c2 (nth chunks (- m 2))]
                                (and (ScriptChunk''is-op-code c2)
                                    (let [#_"int" n (Script'decode-from-op-n (:opcode c2))]
                                        (and (<= 1 n) (= (+ n 3) m)
                                            (loop-when [#_"int" i 1] (< i (- m 2)) => true
                                                (if (ScriptChunk''is-op-code (nth chunks i))
                                                    false
                                                    (recur (inc i))
                                                )
                                            )
                                            ;; First chunk must be an OP_N opcode too.
                                            (<= 1 (Script'decode-from-op-n (:opcode (nth chunks 0))))
                                        )
                                    )
                                )
                            )
                            (catch IllegalStateException _
                                false ;; Not an OP_N opcode.
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (defn #_"boolean" Script''is-sent-to-cltv-payment-channel [#_"Script" this]
        ;; Check that opcodes match the pre-determined format.
        ;; chunk[1] = recipient pubkey
        ;; chunk[4] = locktime
        ;; chunk[8] = sender pubkey
        (let [#_"[ScriptChunk]" chunks (:chunks this)]
            (and (= (count chunks) 10)
                (ScriptChunk''equals-op-code (nth chunks 0), Script'OP_IF)
                (ScriptChunk''equals-op-code (nth chunks 2), Script'OP_CHECKSIGVERIFY)
                (ScriptChunk''equals-op-code (nth chunks 3), Script'OP_ELSE)
                (ScriptChunk''equals-op-code (nth chunks 5), Script'OP_CHECKLOCKTIMEVERIFY)
                (ScriptChunk''equals-op-code (nth chunks 6), Script'OP_DROP)
                (ScriptChunk''equals-op-code (nth chunks 7), Script'OP_ENDIF)
                (ScriptChunk''equals-op-code (nth chunks 9), Script'OP_CHECKSIG))
        )
    )

    (defn- #_"boolean" Script'equals-range [#_"byte[]" a, #_"int" start, #_"byte[]" b]
        (and (<= (+ start (count b)) (count a))
            (loop-when [#_"int" i 0] (< i (count b)) => true
                (recur-if (= (nth a (+ i start)) (nth b i)) [(inc i)] => false)
            )
        )
    )

    ;;;
     ; Returns the script bytes of inputScript with all instances of the specified script object removed.
     ;;
    (defn #_"byte[]" Script'remove-all-instances-of [#_"byte[]" script, #_"byte[]" chunk]
        ;; We usually don't end up removing anything.
        (let [#_"ByteArrayOutputStream" baos (ByteArrayOutputStream. (count script))]
            (loop-when [#_"int" i 0] (< i (count script))
                (let [#_"boolean" skip? (Script'equals-range script, i, chunk)
                      #_"int" opcode (& 0xff (nth script i)) i (inc i)
                      #_"int" m
                        (cond
                            (<= 0 opcode (dec Script'OP_PUSHDATA1))
                                opcode
                            (= opcode Script'OP_PUSHDATA1)
                                (inc (& 0xff (nth script i)))
                            (= opcode Script'OP_PUSHDATA2)
                                (+ (| (& 0xff (nth script i))
                                  (<< (& 0xff (nth script (inc i))) 8)) 2)
                            (= opcode Script'OP_PUSHDATA4)
                                (+ (| (& 0xff (nth script i))
                                  (<< (& 0xff (nth script (inc i))) 8)
                                  (<< (& 0xff (nth script (inc i))) 16)
                                  (<< (& 0xff (nth script (inc i))) 24)) 4)
                            :else
                                0
                        )]
                    (when-not skip?
                        (.write baos, opcode)
                        (.write baos, (Arrays/copyOfRange script, i, (+ i m)))
                    )
                    (recur (+ i m))
                )
            )
            (.toByteArray baos)
        )
    )

    ;;;
     ; Returns the script bytes of inputScript with all instances of the given op code removed.
     ;;
    (defn #_"byte[]" Script'remove-all-instances-of-op [#_"byte[]" script, #_"int" opcode]
        (Script'remove-all-instances-of script, (byte-array [ (byte opcode) ]))
    )

    (defn- #_"boolean" Script'cast-to-bool [#_"byte[]" data]
        (loop-when [#_"int" i 0] (< i (count data)) => false
            ;; "Can be negative zero" - Bitcoin Core (see OpenSSL's BN_bn2mpi)
            (recur-if (zero? (nth data i)) [(inc i)] => (or (not= i (dec (count data))) (not= (& 0xff (nth data i)) 0x80)))
        )
    )

    ;;;
     ; Cast a script chunk to a BigInteger.
     ;
     ; @see #castToBigInteger(byte[], int) for values with different maximum sizes.
     ; @throws ScriptException if the chunk is longer than 4 bytes.
     ;;
    #_throws #_[ "ScriptException" ]
    (defn- #_"BigInteger" Script'cast-to-big-integer-2 [#_"byte[]" chunk, #_"boolean" __requireMinimal]
        (Script'cast-to-big-integer-3 chunk, 4, __requireMinimal)
    )

    ;;;
     ; Cast a script chunk to a BigInteger.  Normally you would want {@link #castToBigInteger(byte[])} instead, this
     ; is only for cases where the normal maximum length does not apply (i.e. CHECKLOCKTIMEVERIFY, CHECKSEQUENCEVERIFY).
     ;
     ; @param maxLength The maximum length in bytes.
     ; @param requireMinimal Check if the number is encoded with the minimum possible number of bytes.
     ; @throws ScriptException if the chunk is longer than the specified maximum.
     ;;
    #_throws #_[ "ScriptException" ]
    (defn- #_"BigInteger" Script'cast-to-big-integer-3 [#_"byte[]" chunk, #_"int" __maxLength, #_"boolean" __requireMinimal]
        (when (< __maxLength (count chunk))
            (throw+ (ScriptException'new :ScriptError'UNKNOWN_ERROR, (str "Script attempted to use an integer larger than " __maxLength " bytes")))
        )

        (when (and __requireMinimal (< 0 (count chunk)))
            ;; Check that the number is encoded with the minimum possible number of bytes.
            ;;
            ;; If the most-significant-byte - excluding the sign bit - is zero, then we're not minimal.
            ;; Note how this test also rejects the negative-zero encoding, 0x80.
            (when (zero? (& 0x7f (nth chunk (dec (count chunk)))))
                ;; One exception: if there's more than one byte and the most significant bit
                ;; of the second-most-significant-byte is set, it would conflict with the sign bit.
                ;; An example of this case is +-255, which encode to 0xff00 and 0xff80 respectively.
                ;; (big-endian)
                (when (or (<= (count chunk) 1) (zero? (& 0x80 (nth chunk (- (count chunk) 2)))))
                    (throw+ (ScriptException'new :ScriptError'UNKNOWN_ERROR, "non-minimally encoded script number"))
                )
            )
        )

        (Wire'decode-mpi (Wire'reverse-bytes chunk), false)
    )

    #_method
    (defn #_"boolean" Script''is-op-return [#_"Script" this]
        (and (seq (:chunks this)) (ScriptChunk''equals-op-code (first (:chunks this)), Script'OP_RETURN))
    )

    ;;;
     ; Exposes the script interpreter.  Normally you should not use this directly, instead use
     ; {@link TransactionInput#verify(TransactionOutput)} or {@link Script#correctlySpends(Transaction, long, Script)}.
     ; This method is useful if you need more precise control or access to the final state of the stack.
     ; This interface is very likely to change in future.
     ;;
    #_throws #_[ "ScriptException" ]
    (defn #_"void" Script'execute-script-5 [#_"Transaction" tx, #_"long" index, #_"Script" script, #_"LinkedList<byte[]>" stack, #_"{ScriptVerifyFlag}" flags]
        (let [#_"LinkedList<byte[]>" altstack (LinkedList.) #_"LinkedList<Boolean>" ifstack (LinkedList.)]

            (loop-when [#_"int" __opCount 0 #_"ScriptChunk*" chunks (:chunks script)] (seq chunks)
                (let [#_"ScriptChunk" chunk (first chunks)]

                    ;; Check stack element size.
                    (when (and (some? (:data chunk)) (< Script'MAX_SCRIPT_ELEMENT_SIZE (count (:data chunk))))
                        (throw+ (ScriptException'new :ScriptError'PUSH_SIZE, "Attempted to push a data string larger than 520 bytes"))
                    )

                    (let [#_"int" opcode (:opcode chunk)
                          __opCount
                            ;; Note how OP_RESERVED does not count towards the opcode limit.
                            (when (< Script'OP_16 opcode) => __opCount
                                (when-not (< __opCount Script'MAX_OPS_PER_SCRIPT)
                                    (throw+ (ScriptException'new :ScriptError'OP_COUNT, "More script operations than is allowed"))
                                )
                                (inc __opCount)
                            )]

                        ;; Disabled opcodes.
                        (when (any = opcode Script'OP_CAT Script'OP_SUBSTR Script'OP_LEFT Script'OP_RIGHT Script'OP_INVERT Script'OP_AND Script'OP_OR Script'OP_XOR Script'OP_2MUL Script'OP_2DIV Script'OP_MUL Script'OP_DIV Script'OP_MOD Script'OP_LSHIFT Script'OP_RSHIFT)
                            (throw+ (ScriptException'new :ScriptError'DISABLED_OPCODE, "Script included a disabled Script Op."))
                        )

                        (let [#_"boolean" exec? (not (.contains ifstack, false))
                              _ (cond (and exec? (<= Script'OP_0 opcode Script'OP_PUSHDATA4))
                                    (do
                                        ;; Check minimal push.
                                        (when (and (contains? flags :ScriptVerifyFlag'MINIMALDATA) (not (ScriptChunk''is-shortest-possible-push-data chunk)))
                                            (throw+ (ScriptException'new :ScriptError'MINIMALDATA, "Script included a not minimal push operation."))
                                        )
                                        (ยง ass stack (.add stack, (if (= opcode Script'OP_0) (byte-array 0) (:data chunk))))
                                        nil
                                    )
                                    (or exec? (<= Script'OP_IF opcode Script'OP_ENDIF))
                                    (do
                                        (condp =? opcode
                                            Script'OP_IF
                                                (do
                                                    (when exec? => (ยง ass ifstack (.add ifstack, false))
                                                        (when (< (count stack) 1)
                                                            (throw+ (ScriptException'new :ScriptError'UNBALANCED_CONDITIONAL, "Attempted OP_IF on an empty stack"))
                                                        )
                                                        (ยง ass ifstack (.add ifstack, (Script'cast-to-bool (.pollLast stack))))
                                                    )
                                                    nil
                                                )
                                            Script'OP_NOTIF
                                                (do
                                                    (when exec? => (ยง ass ifstack (.add ifstack, false))
                                                        (when (< (count stack) 1)
                                                            (throw+ (ScriptException'new :ScriptError'UNBALANCED_CONDITIONAL, "Attempted OP_NOTIF on an empty stack"))
                                                        )
                                                        (ยง ass ifstack (.add ifstack, (not (Script'cast-to-bool (.pollLast stack)))))
                                                    )
                                                    nil
                                                )
                                            Script'OP_ELSE
                                                (do
                                                    (when (empty? ifstack)
                                                        (throw+ (ScriptException'new :ScriptError'UNBALANCED_CONDITIONAL, "Attempted OP_ELSE without OP_IF/NOTIF"))
                                                    )
                                                    (ยง ass ifstack (.add ifstack, (not (.pollLast ifstack))))
                                                    nil
                                                )
                                            Script'OP_ENDIF
                                                (do
                                                    (when (empty? ifstack)
                                                        (throw+ (ScriptException'new :ScriptError'UNBALANCED_CONDITIONAL, "Attempted OP_ENDIF without OP_IF/NOTIF"))
                                                    )
                                                    (.pollLast ifstack)
                                                    nil
                                                )

                                            ;; OP_0 is no opcode
                                            Script'OP_1NEGATE
                                                (do
                                                    (ยง ass stack (.add stack, (Wire'reverse-bytes (Wire'encode-mpi (.negate BigInteger/ONE), false))))
                                                    nil
                                                )
                                           [Script'OP_1
                                            Script'OP_2
                                            Script'OP_3
                                            Script'OP_4
                                            Script'OP_5
                                            Script'OP_6
                                            Script'OP_7
                                            Script'OP_8
                                            Script'OP_9
                                            Script'OP_10
                                            Script'OP_11
                                            Script'OP_12
                                            Script'OP_13
                                            Script'OP_14
                                            Script'OP_15
                                            Script'OP_16]
                                                (do
                                                    (ยง ass stack (.add stack, (Wire'reverse-bytes (Wire'encode-mpi (BigInteger/valueOf (Script'decode-from-op-n opcode)), false))))
                                                    nil
                                                )

                                            Script'OP_NOP
                                                (do
                                                    nil
                                                )

                                            Script'OP_VERIFY
                                                (do
                                                    (when (< (count stack) 1)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_VERIFY on an empty stack"))
                                                    )
                                                    (when-not (Script'cast-to-bool (.pollLast stack))
                                                        (throw+ (ScriptException'new :ScriptError'VERIFY, "OP_VERIFY failed"))
                                                    )
                                                    nil
                                                )

                                            Script'OP_RETURN
                                                (throw+ (ScriptException'new :ScriptError'OP_RETURN, "Script called OP_RETURN"))

                                            Script'OP_TOALTSTACK
                                                (do
                                                    (when (< (count stack) 1)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_TOALTSTACK on an empty stack"))
                                                    )
                                                    (ยง ass altstack (.add altstack, (.pollLast stack)))
                                                    nil
                                                )
                                            Script'OP_FROMALTSTACK
                                                (do
                                                    (when (< (count altstack) 1)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_ALTSTACK_OPERATION, "Attempted OP_FROMALTSTACK on an empty altstack"))
                                                    )
                                                    (ยง ass stack (.add stack, (.pollLast altstack)))
                                                    nil
                                                )

                                            Script'OP_2DROP
                                                (do
                                                    (when (< (count stack) 2)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_2DROP on a stack with size < 2"))
                                                    )
                                                    (.pollLast stack)
                                                    (.pollLast stack)
                                                    nil
                                                )
                                            Script'OP_2DUP
                                                (do
                                                    (when (< (count stack) 2)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_2DUP on a stack with size < 2"))
                                                    )
                                                    (let [#_"Iterator<byte[]>" it (.descendingIterator stack) #_"byte[]" data2 (.next it)]
                                                        (ยง ass stack (.add stack, (.next it)))
                                                        (ยง ass stack (.add stack, data2))
                                                    )
                                                    nil
                                                )
                                            Script'OP_3DUP
                                                (do
                                                    (when (< (count stack) 3)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_3DUP on a stack with size < 3"))
                                                    )
                                                    (let [#_"Iterator<byte[]>" it (.descendingIterator stack) #_"byte[]" data3 (.next it) #_"byte[]" data2 (.next it)]
                                                        (ยง ass stack (.add stack, (.next it)))
                                                        (ยง ass stack (.add stack, data2))
                                                        (ยง ass stack (.add stack, data3))
                                                    )
                                                    nil
                                                )
                                            Script'OP_2OVER
                                                (do
                                                    (when (< (count stack) 4)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_2OVER on a stack with size < 4"))
                                                    )
                                                    (let [#_"Iterator<byte[]>" it (.descendingIterator stack)]
                                                        (.next it)
                                                        (.next it)
                                                        (let [#_"byte[]" data2 (.next it)]
                                                            (ยง ass stack (.add stack, (.next it)))
                                                            (ยง ass stack (.add stack, data2))
                                                        )
                                                    )
                                                    nil
                                                )
                                            Script'OP_2ROT
                                                (do
                                                    (when (< (count stack) 6)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_2ROT on a stack with size < 6"))
                                                    )
                                                    (let [#_"byte[]" data6 (.pollLast stack)
                                                          #_"byte[]" data5 (.pollLast stack)
                                                          #_"byte[]" data4 (.pollLast stack)
                                                          #_"byte[]" data3 (.pollLast stack)
                                                          #_"byte[]" data2 (.pollLast stack)
                                                          #_"byte[]" data1 (.pollLast stack)]
                                                        (ยง ass stack (.add stack, data3))
                                                        (ยง ass stack (.add stack, data4))
                                                        (ยง ass stack (.add stack, data5))
                                                        (ยง ass stack (.add stack, data6))
                                                        (ยง ass stack (.add stack, data1))
                                                        (ยง ass stack (.add stack, data2))
                                                    )
                                                    nil
                                                )
                                            Script'OP_2SWAP
                                                (do
                                                    (when (< (count stack) 4)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_2SWAP on a stack with size < 4"))
                                                    )
                                                    (let [#_"byte[]" data4 (.pollLast stack)
                                                          #_"byte[]" data3 (.pollLast stack)
                                                          #_"byte[]" data2 (.pollLast stack)
                                                          #_"byte[]" data1 (.pollLast stack)]
                                                        (ยง ass stack (.add stack, data3))
                                                        (ยง ass stack (.add stack, data4))
                                                        (ยง ass stack (.add stack, data1))
                                                        (ยง ass stack (.add stack, data2))
                                                    )
                                                    nil
                                                )

                                            Script'OP_IFDUP
                                                (do
                                                    (when (< (count stack) 1)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_IFDUP on an empty stack"))
                                                    )
                                                    (when (Script'cast-to-bool (.getLast stack))
                                                        (ยง ass stack (.add stack, (.getLast stack)))
                                                    )
                                                    nil
                                                )

                                            Script'OP_DEPTH
                                                (do
                                                    (ยง ass stack (.add stack, (Wire'reverse-bytes (Wire'encode-mpi (BigInteger/valueOf (count stack)), false))))
                                                    nil
                                                )

                                            Script'OP_DROP
                                                (do
                                                    (when (< (count stack) 1)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_DROP on an empty stack"))
                                                    )
                                                    (.pollLast stack)
                                                    nil
                                                )
                                            Script'OP_DUP
                                                (do
                                                    (when (< (count stack) 1)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_DUP on an empty stack"))
                                                    )
                                                    (ยง ass stack (.add stack, (.getLast stack)))
                                                    nil
                                                )
                                            Script'OP_NIP
                                                (do
                                                    (when (< (count stack) 2)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_NIP on a stack with size < 2"))
                                                    )
                                                    (let [#_"byte[]" data (.pollLast stack)]
                                                        (.pollLast stack)
                                                        (ยง ass stack (.add stack, data))
                                                    )
                                                    nil
                                                )
                                            Script'OP_OVER
                                                (do
                                                    (when (< (count stack) 2)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_OVER on a stack with size < 2"))
                                                    )
                                                    (let [#_"Iterator<byte[]>" it (.descendingIterator stack)]
                                                        (.next it)
                                                        (ยง ass stack (.add stack, (.next it)))
                                                    )
                                                    nil
                                                )
                                           [Script'OP_PICK
                                            Script'OP_ROLL]
                                                (do
                                                    (when (< (count stack) 1)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_PICK/OP_ROLL on an empty stack"))
                                                    )
                                                    (let [#_"long" n (.longValue (Script'cast-to-big-integer-2 (.pollLast stack), (contains? flags :ScriptVerifyFlag'MINIMALDATA)))]
                                                        (when-not (< -1 n (count stack))
                                                            (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "OP_PICK/OP_ROLL attempted to get data deeper than stack size"))
                                                        )
                                                        (let [#_"Iterator<byte[]>" it (.descendingIterator stack)]
                                                            (dotimes [_ n]
                                                                (.next it)
                                                            )
                                                            (let [#_"byte[]" data (.next it)]
                                                                (when (= opcode Script'OP_ROLL)
                                                                    (.remove it)
                                                                )
                                                                (ยง ass stack (.add stack, data))
                                                            )
                                                        )
                                                    )
                                                    nil
                                                )
                                            Script'OP_ROT
                                                (do
                                                    (when (< (count stack) 3)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_ROT on a stack with size < 3"))
                                                    )
                                                    (let [#_"byte[]" data3 (.pollLast stack)
                                                          #_"byte[]" data2 (.pollLast stack)
                                                          #_"byte[]" data1 (.pollLast stack)]
                                                        (ยง ass stack (.add stack, data2))
                                                        (ยง ass stack (.add stack, data3))
                                                        (ยง ass stack (.add stack, data1))
                                                    )
                                                    nil
                                                )
                                           [Script'OP_SWAP
                                            Script'OP_TUCK]
                                                (do
                                                    (when (< (count stack) 2)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_SWAP on a stack with size < 2"))
                                                    )
                                                    (let [#_"byte[]" data2 (.pollLast stack) #_"byte[]" data1 (.pollLast stack)]
                                                        (ยง ass stack (.add stack, data2))
                                                        (ยง ass stack (.add stack, data1))
                                                        (when (= opcode Script'OP_TUCK)
                                                            (ยง ass stack (.add stack, data2))
                                                        )
                                                    )
                                                    nil
                                                )

                                            Script'OP_SIZE
                                                (do
                                                    (when (< (count stack) 1)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_SIZE on an empty stack"))
                                                    )
                                                    (ยง ass stack (.add stack, (Wire'reverse-bytes (Wire'encode-mpi (BigInteger/valueOf (count (.getLast stack))), false))))
                                                    nil
                                                )
                                            Script'OP_EQUAL
                                                (do
                                                    (when (< (count stack) 2)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_EQUAL on a stack with size < 2"))
                                                    )
                                                    (ยง ass stack (.add stack, (if (Arrays/equals (.pollLast stack), (.pollLast stack)) (byte-array [ 1 ]) (byte-array 0))))
                                                    nil
                                                )
                                            Script'OP_EQUALVERIFY
                                                (do
                                                    (when (< (count stack) 2)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_EQUALVERIFY on a stack with size < 2"))
                                                    )
                                                    (when-not (Arrays/equals (.pollLast stack), (.pollLast stack))
                                                        (throw+ (ScriptException'new :ScriptError'EQUALVERIFY, "OP_EQUALVERIFY: non-equal data"))
                                                    )
                                                    nil
                                                )

                                           [Script'OP_1ADD
                                            Script'OP_1SUB
                                            Script'OP_NEGATE
                                            Script'OP_ABS
                                            Script'OP_NOT
                                            Script'OP_0NOTEQUAL]
                                                (do
                                                    (when (< (count stack) 1)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted a numeric op on an empty stack"))
                                                    )
                                                    (let [#_"BigInteger" n (Script'cast-to-big-integer-2 (.pollLast stack), (contains? flags :ScriptVerifyFlag'MINIMALDATA))
                                                          n (condp = opcode
                                                                Script'OP_1ADD      (.add n, BigInteger/ONE)
                                                                Script'OP_1SUB      (.subtract n, BigInteger/ONE)
                                                                Script'OP_NEGATE    (.negate n)
                                                                Script'OP_ABS       (if (neg? (.signum n)) (.negate n) n)
                                                                Script'OP_NOT       (if (= n BigInteger/ZERO) BigInteger/ONE BigInteger/ZERO)
                                                                Script'OP_0NOTEQUAL (if (= n BigInteger/ZERO) BigInteger/ZERO BigInteger/ONE)
                                                            )]
                                                        (ยง ass stack (.add stack, (Wire'reverse-bytes (Wire'encode-mpi n, false))))
                                                    )
                                                    nil
                                                )
                                           [Script'OP_ADD
                                            Script'OP_SUB
                                            Script'OP_BOOLAND
                                            Script'OP_BOOLOR
                                            Script'OP_NUMEQUAL
                                            Script'OP_NUMNOTEQUAL
                                            Script'OP_LESSTHAN
                                            Script'OP_GREATERTHAN
                                            Script'OP_LESSTHANOREQUAL
                                            Script'OP_GREATERTHANOREQUAL
                                            Script'OP_MIN
                                            Script'OP_MAX]
                                                (do
                                                    (when (< (count stack) 2)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted a numeric op on a stack with size < 2"))
                                                    )
                                                    (let [#_"BigInteger" n2 (Script'cast-to-big-integer-2 (.pollLast stack), (contains? flags :ScriptVerifyFlag'MINIMALDATA))
                                                          #_"BigInteger" n1 (Script'cast-to-big-integer-2 (.pollLast stack), (contains? flags :ScriptVerifyFlag'MINIMALDATA))
                                                          #_"BigInteger" n
                                                            (condp = opcode
                                                                Script'OP_ADD                (.add n1, n2)
                                                                Script'OP_SUB                (.subtract n1, n2)
                                                                Script'OP_BOOLAND            (if (and (not= n1 BigInteger/ZERO) (not= n2 BigInteger/ZERO)) BigInteger/ONE BigInteger/ZERO)
                                                                Script'OP_BOOLOR             (if (or (not= n1 BigInteger/ZERO) (not= n2 BigInteger/ZERO)) BigInteger/ONE BigInteger/ZERO)
                                                                Script'OP_NUMEQUAL           (if (= n1 n2) BigInteger/ONE BigInteger/ZERO)
                                                                Script'OP_NUMNOTEQUAL        (if (not= n1 n2) BigInteger/ONE BigInteger/ZERO)
                                                                Script'OP_LESSTHAN           (if (< n1 n2) BigInteger/ONE BigInteger/ZERO)
                                                                Script'OP_GREATERTHAN        (if (> n1 n2) BigInteger/ONE BigInteger/ZERO)
                                                                Script'OP_LESSTHANOREQUAL    (if (<= n1 n2) BigInteger/ONE BigInteger/ZERO)
                                                                Script'OP_GREATERTHANOREQUAL (if (>= n1 n2) BigInteger/ONE BigInteger/ZERO)
                                                                Script'OP_MIN                (if (< n1 n2) n1 n2)
                                                                Script'OP_MAX                (if (> n1 n2) n1 n2)
                                                                (throw (RuntimeException. "Opcode switched at runtime?"))
                                                            )]
                                                        (ยง ass stack (.add stack, (Wire'reverse-bytes (Wire'encode-mpi n, false))))
                                                    )
                                                    nil
                                                )

                                            Script'OP_NUMEQUALVERIFY
                                                (do
                                                    (when (< (count stack) 2)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_NUMEQUALVERIFY on a stack with size < 2"))
                                                    )
                                                    (let [#_"BigInteger" n2 (Script'cast-to-big-integer-2 (.pollLast stack), (contains? flags :ScriptVerifyFlag'MINIMALDATA))
                                                          #_"BigInteger" n1 (Script'cast-to-big-integer-2 (.pollLast stack), (contains? flags :ScriptVerifyFlag'MINIMALDATA))]

                                                        (when-not (= n1 n2)
                                                            (throw+ (ScriptException'new :ScriptError'NUMEQUALVERIFY, "OP_NUMEQUALVERIFY failed"))
                                                        )
                                                    )
                                                    nil
                                                )

                                            Script'OP_WITHIN
                                                (do
                                                    (when (< (count stack) 3)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_WITHIN on a stack with size < 3"))
                                                    )
                                                    (let [#_"BigInteger" n3 (Script'cast-to-big-integer-2 (.pollLast stack), (contains? flags :ScriptVerifyFlag'MINIMALDATA))
                                                          #_"BigInteger" n2 (Script'cast-to-big-integer-2 (.pollLast stack), (contains? flags :ScriptVerifyFlag'MINIMALDATA))
                                                          #_"BigInteger" n1 (Script'cast-to-big-integer-2 (.pollLast stack), (contains? flags :ScriptVerifyFlag'MINIMALDATA))]
                                                        (if (and (<= n2 n1) (< n1 n3))
                                                            (ยง ass stack (.add stack, (Wire'reverse-bytes (Wire'encode-mpi BigInteger/ONE, false))))
                                                            (ยง ass stack (.add stack, (Wire'reverse-bytes (Wire'encode-mpi BigInteger/ZERO, false))))
                                                        )
                                                    )
                                                    nil
                                                )

                                            Script'OP_RIPEMD160
                                                (do
                                                    (when (< (count stack) 1)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_RIPEMD160 on an empty stack"))
                                                    )
                                                    (let [#_"RIPEMD160Digest" digest (RIPEMD160Digest.) #_"byte[]" data (.pollLast stack)]
                                                        (.update digest, data, 0, (count data))
                                                        (let [#_"byte[]" hash (byte-array 20)]
                                                            (.doFinal digest, hash, 0)
                                                            (ยง ass stack (.add stack, hash))
                                                        )
                                                    )
                                                    nil
                                                )
                                            Script'OP_SHA1
                                                (do
                                                    (when (< (count stack) 1)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_SHA1 on an empty stack"))
                                                    )
                                                    (try
                                                        (ยง ass stack (.add stack, (.digest (MessageDigest/getInstance "SHA-1"), (.pollLast stack))))
                                                        (catch NoSuchAlgorithmException e
                                                            (throw (RuntimeException. e)) ;; Cannot happen.
                                                        )
                                                    )
                                                    nil
                                                )
                                            Script'OP_SHA256
                                                (do
                                                    (when (< (count stack) 1)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_SHA256 on an empty stack"))
                                                    )
                                                    (ยง ass stack (.add stack, (Sha256Hash'hash (.pollLast stack))))
                                                    nil
                                                )
                                            Script'OP_HASH160
                                                (do
                                                    (when (< (count stack) 1)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_HASH160 on an empty stack"))
                                                    )
                                                    (ยง ass stack (.add stack, (Utils'sha256hash160 (.pollLast stack))))
                                                    nil
                                                )
                                            Script'OP_HASH256
                                                (do
                                                    (when (< (count stack) 1)
                                                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_SHA256 on an empty stack"))
                                                    )
                                                    (ยง ass stack (.add stack, (Sha256Hash'hash-twice (.pollLast stack))))
                                                    nil
                                                )

                                           [Script'OP_CHECKSIG
                                            Script'OP_CHECKSIGVERIFY]
                                                (do
                                                    (when (nil? tx)
                                                        (throw (IllegalStateException. "Script attempted signature check but no tx was provided"))
                                                    )
                                                    (Script'execute-check-sig tx, (int index), script, stack, opcode, flags)
                                                    nil
                                                )
                                           [Script'OP_CHECKMULTISIG
                                            Script'OP_CHECKMULTISIGVERIFY]
                                                (do
                                                    (when (nil? tx)
                                                        (throw (IllegalStateException. "Script attempted signature check but no tx was provided"))
                                                    )
                                                    [(Script'execute-multi-sig tx, (int index), script, stack, __opCount, opcode, flags)]
                                                )
                                            Script'OP_CHECKLOCKTIMEVERIFY
                                                (do
                                                    (if (not (contains? flags :ScriptVerifyFlag'CHECKLOCKTIMEVERIFY))
                                                        ;; not enabled; treat as a NOP2
                                                        (when (contains? flags :ScriptVerifyFlag'DISCOURAGE_UPGRADABLE_NOPS)
                                                            (throw+ (ScriptException'new :ScriptError'DISCOURAGE_UPGRADABLE_NOPS, (str "Script used a reserved opcode " opcode)))
                                                        )
                                                        (Script'execute-check-lock-time-verify tx, (int index), stack, flags)
                                                    )
                                                    nil
                                                )
                                            Script'OP_CHECKSEQUENCEVERIFY
                                                (do
                                                    (if (not (contains? flags :ScriptVerifyFlag'CHECKSEQUENCEVERIFY))
                                                        ;; not enabled; treat as a NOP3
                                                        (when (contains? flags :ScriptVerifyFlag'DISCOURAGE_UPGRADABLE_NOPS)
                                                            (throw+ (ScriptException'new :ScriptError'DISCOURAGE_UPGRADABLE_NOPS, (str "Script used a reserved opcode " opcode)))
                                                        )
                                                        (Script'execute-check-sequence-verify tx, (int index), stack, flags)
                                                    )
                                                    nil
                                                )

                                           [Script'OP_NOP1
                                            Script'OP_NOP4
                                            Script'OP_NOP5
                                            Script'OP_NOP6
                                            Script'OP_NOP7
                                            Script'OP_NOP8
                                            Script'OP_NOP9
                                            Script'OP_NOP10]
                                                (do
                                                    (when (contains? flags :ScriptVerifyFlag'DISCOURAGE_UPGRADABLE_NOPS)
                                                        (throw+ (ScriptException'new :ScriptError'DISCOURAGE_UPGRADABLE_NOPS, (str "Script used a reserved opcode " opcode)))
                                                    )
                                                    nil
                                                )

                                            (throw+ (ScriptException'new :ScriptError'BAD_OPCODE, (str "Script used a reserved or disabled opcode: " opcode)))
                                        )
                                    )
                                )
                              [__opCount] (or _ [__opCount])]

                            (when-not (<= 0 (+ (count stack) (count altstack)) Script'MAX_STACK_SIZE)
                                (throw+ (ScriptException'new :ScriptError'STACK_SIZE, "Stack size exceeded range"))
                            )

                            (recur __opCount (next chunks))
                        )
                    )
                )
            )

            (when (seq ifstack)
                (throw+ (ScriptException'new :ScriptError'UNBALANCED_CONDITIONAL, "OP_IF/OP_NOTIF without OP_ENDIF"))
            )
        )
        nil
    )

    ;; This is more or less a direct translation of the code in Bitcoin Core.
    #_throws #_[ "ScriptException" ]
    (defn- #_"void" Script'execute-check-lock-time-verify [#_"Transaction" tx, #_"int" index, #_"LinkedList<byte[]>" stack, #_"{ScriptVerifyFlag}" flags]
        (when (< (count stack) 1)
            (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_CHECKLOCKTIMEVERIFY on a stack with size < 1"))
        )
        ;; Thus as a special case we tell CScriptNum to accept up to 5-byte bignums to avoid year 2038 issue.
        (let [#_"BigInteger" time (Script'cast-to-big-integer-3 (.getLast stack), 5, (contains? flags :ScriptVerifyFlag'MINIMALDATA))]
            (cond
                (< time BigInteger/ZERO)
                    (throw+ (ScriptException'new :ScriptError'NEGATIVE_LOCKTIME, "Negative locktime"))

                ;; There are two kinds of nLockTime, need to ensure we're comparing apples-to-apples.
                (let [#_"boolean" a? (< (:lock-time tx) Transaction'LOCKTIME_THRESHOLD) #_"boolean" b? (< time Transaction'LOCKTIME_THRESHOLD_BIG)]
                        (not (or (and a? b?) (and (not a?) (not b?)))))
                    (throw+ (ScriptException'new :ScriptError'UNSATISFIED_LOCKTIME, "Locktime requirement type mismatch"))

                ;; Now that we know we're comparing apples-to-apples, the comparison is a simple numeric one.
                (< (BigInteger/valueOf (:lock-time tx)) time)
                    (throw+ (ScriptException'new :ScriptError'UNSATISFIED_LOCKTIME, "Locktime requirement not satisfied"))

                ;; Finally the nLockTime feature can be disabled and thus CHECKLOCKTIMEVERIFY bypassed if every txin has been
                ;; finalized by setting nSequence to maxint.  The transaction would be allowed into the blockchain, making
                ;; the opcode ineffective.
                ;;
                ;; Testing if this vin is not final is sufficient to prevent this condition.  Alternatively we could test all
                ;; inputs, but testing just this input minimizes the data required to prove correct CHECKLOCKTIMEVERIFY execution.
                (not (TransactionInput''has-sequence (nth (:inputs tx) index)))
                    (throw+ (ScriptException'new :ScriptError'UNSATISFIED_LOCKTIME, "Transaction contains a final transaction input for a CHECKLOCKTIMEVERIFY script."))
            )
        )
        nil
    )

    #_throws #_[ "ScriptException" ]
    (defn- #_"void" Script'execute-check-sequence-verify [#_"Transaction" tx, #_"int" index, #_"LinkedList<byte[]>" stack, #_"{ScriptVerifyFlag}" flags]
        (if (< (count stack) 1)
            (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_CHECKSEQUENCEVERIFY on a stack with size < 1"))
            ;; Note that elsewhere numeric opcodes are limited to operands in the range -2**31+1 to 2**31-1,
            ;; however it is legal for opcodes to produce results exceeding that range.  This limitation is
            ;; implemented by CScriptNum's default 4-byte limit.
            ;;
            ;; Thus as a special case we tell CScriptNum to accept up to 5-byte bignums, which are good until
            ;; 2**39-1, well beyond the 2**32-1 limit of the nSequence field itself.
            (let [#_"long" n (.longValue (Script'cast-to-big-integer-3 (.getLast stack), 5, (contains? flags :ScriptVerifyFlag'MINIMALDATA)))]
                (cond
                    ;; In the rare event that the argument may be < 0 due to some arithmetic being done first,
                    ;; you can always use 0 MAX CHECKSEQUENCEVERIFY.
                    (neg? n)
                        (throw+ (ScriptException'new :ScriptError'NEGATIVE_LOCKTIME, "Negative sequence"))

                    ;; To provide for future soft-fork extensibility, if the operand has the disabled lock-time
                    ;; flag set, CHECKSEQUENCEVERIFY behaves as a NOP.
                    (not= (& n Transaction'SEQUENCE_LOCKTIME_DISABLE_FLAG) 0)
                        nil

                    ;; Compare the specified sequence number with the input.
                    (not (Script'check-sequence n, tx, index))
                        (throw+ (ScriptException'new :ScriptError'UNSATISFIED_LOCKTIME, "Unsatisfied CHECKLOCKTIMEVERIFY lock time"))
                )
            )
        )
        nil
    )

    (defn- #_"boolean" Script'check-sequence [#_"long" __nSeq, #_"Transaction" tx, #_"int" index]
        ;; Relative lock times are supported by comparing the passed in operand to the sequence number of the input.
        (let [#_"long" __tSeq (:sequence (nth (:inputs tx) index))]
            (and
                ;; Fail if the transaction's version number is not set high enough to trigger BIP 68 rules.
                (<= 2 (:version tx))

                ;; Sequence numbers with their most significant bit set are not consensus constrained.  Testing
                ;; that the transaction's sequence number do not have this bit set prevents using this property
                ;; to get around a CHECKSEQUENCEVERIFY check.
                (zero? (& __tSeq Transaction'SEQUENCE_LOCKTIME_DISABLE_FLAG))

                ;; Mask off any bits that do not have consensus-enforced meaning before doing the integer comparisons.
                (let [#_"long" mask (| Transaction'SEQUENCE_LOCKTIME_TYPE_FLAG Transaction'SEQUENCE_LOCKTIME_MASK)
                      #_"long" __tSeq' (& __tSeq mask)
                      #_"long" __nSeq' (& __nSeq mask)]
                    (and
                        ;; There are two kinds of nSequence: lock-by-blockheight and lock-by-blocktime, distinguished by
                        ;; whether nSequenceMasked < CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.
                        ;;
                        ;; We want to compare apples to apples, so fail the script unless the type of nSequenceMasked
                        ;; being tested is the same as the nSequenceMasked in the transaction.
                        (or (and (< __tSeq' Transaction'SEQUENCE_LOCKTIME_TYPE_FLAG) (< __nSeq' Transaction'SEQUENCE_LOCKTIME_TYPE_FLAG))
                            (and (<= Transaction'SEQUENCE_LOCKTIME_TYPE_FLAG __tSeq') (<= Transaction'SEQUENCE_LOCKTIME_TYPE_FLAG __nSeq')))

                        ;; Now that we know we're comparing apples-to-apples, the comparison is a simple numeric one.
                        (<= __nSeq' __tSeq')
                    )
                )
            )
        )
    )

    #_throws #_[ "ScriptException" ]
    (defn- #_"void" Script'execute-check-sig [#_"Transaction" tx, #_"int" index, #_"Script" script, #_"LinkedList<byte[]>" stack, #_"int" opcode, #_"{ScriptVerifyFlag}" flags]
        (let [#_"boolean" canon? (or (contains? flags :ScriptVerifyFlag'STRICTENC) (contains? flags :ScriptVerifyFlag'DERSIG) (contains? flags :ScriptVerifyFlag'LOW_S))]
            (when (< (count stack) 2)
                (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_CHECKSIG(VERIFY) on a stack with size < 2"))
            )

            (let [#_"byte[]" __pubKey (.pollLast stack) #_"byte[]" __sigBytes (.pollLast stack)
                  rem- #(let [#_"ByteArrayOutputStream" baos (ByteArrayOutputStream. (inc (count %2))) _ (Script'write-bytes baos, %2)]
                            (Script'remove-all-instances-of %1, (.toByteArray baos))
                        )
                  #_"byte[]" prog (Script''to-bytes script)
                  #_"byte[]" __connectedScript (rem- (Arrays/copyOfRange prog, 0, (count prog)), __sigBytes)
                  ;; TODO: Use int for indexes everywhere, we can't have that many inputs/outputs.
                  #_"boolean" valid?
                    (try
                        (let [#_"TransactionSignature" sig (TransactionSignature'decode-from-bitcoin __sigBytes, canon?, (contains? flags :ScriptVerifyFlag'LOW_S))
                              ;; TODO: Should check hash type is known.
                              #_"Sha256Hash" hash (Transaction''hash-for-signature-4b tx, index, __connectedScript, (byte (:sighash-flags sig)))]
                            (ECKey'verify-3e (:hash-bytes hash), sig, __pubKey)
                        )
                        (catch Exception e
                            ;; There is (at least) one exception that could be hit here (EOFException, if the sig is too short).
                            ;; Because I can't verify there aren't more, we use a very generic Exception catch.

                            ;; This RuntimeException occurs when signing as we run partial/invalid scripts to see if they need more
                            ;; signing work to be done inside LocalTransactionSigner.signInputs().
                            (when-not (.contains (.getMessage e), "Reached past end of ASN.1 stream")
                                (log/warn e, "Signature checking failed!")
                            )
                            false
                        )
                    )]

                (cond (= opcode Script'OP_CHECKSIG)
                    (do
                        (ยง ass stack (.add stack, (if valid? (byte-array [ 1 ]) (byte-array 0))))
                    )
                    (and (= opcode Script'OP_CHECKSIGVERIFY) (not valid?))
                    (do
                        (throw+ (ScriptException'new :ScriptError'CHECKSIGVERIFY, "Script failed OP_CHECKSIGVERIFY"))
                    )
                )
            )
        )
        nil
    )

    #_throws #_[ "ScriptException" ]
    (defn- #_"int" Script'execute-multi-sig [#_"Transaction" tx, #_"int" index, #_"Script" script, #_"LinkedList<byte[]>" stack, #_"int" __opCount, #_"int" opcode, #_"{ScriptVerifyFlag}" flags]
        (let [#_"boolean" canon? (or (contains? flags :ScriptVerifyFlag'STRICTENC) (contains? flags :ScriptVerifyFlag'DERSIG) (contains? flags :ScriptVerifyFlag'LOW_S))]
            (when (< (count stack) 1)
                (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size < 1"))
            )

            (let [#_"int" __pubKeyCount (.intValue (Script'cast-to-big-integer-2 (.pollLast stack), (contains? flags :ScriptVerifyFlag'MINIMALDATA)))]
                (when-not (<= 0 __pubKeyCount Script'MAX_PUBKEYS_PER_MULTISIG)
                    (throw+ (ScriptException'new :ScriptError'PUBKEY_COUNT, "OP_CHECKMULTISIG(VERIFY) with pubkey count out of range"))
                )

                (let [__opCount (+ __opCount __pubKeyCount)]
                    (when (< Script'MAX_OPS_PER_SCRIPT __opCount)
                        (throw+ (ScriptException'new :ScriptError'OP_COUNT, "Total op count > 201 during OP_CHECKMULTISIG(VERIFY)"))
                    )
                    (when (< (count stack) (inc __pubKeyCount))
                        (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size < num_of_pubkeys + 2"))
                    )

                    (let [#_"LinkedList<byte[]>" pubkeys (LinkedList.) _ (dotimes [_ __pubKeyCount] (ยง ass pubkeys (.add pubkeys, (.pollLast stack))))
                          #_"int" __sigCount (.intValue (Script'cast-to-big-integer-2 (.pollLast stack), (contains? flags :ScriptVerifyFlag'MINIMALDATA)))]
                        (when-not (<= 0 __sigCount __pubKeyCount)
                            (throw+ (ScriptException'new :ScriptError'SIG_COUNT, "OP_CHECKMULTISIG(VERIFY) with sig count out of range"))
                        )
                        (when (< (count stack) (inc __sigCount))
                            (throw+ (ScriptException'new :ScriptError'INVALID_STACK_OPERATION, "Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size < num_of_pubkeys + num_of_signatures + 3"))
                        )

                        (let [#_"LinkedList<byte[]>" sigs (LinkedList.) _ (dotimes [_ __sigCount] (ยง ass sigs (.add sigs, (.pollLast stack))))
                              rem- #(let [#_"ByteArrayOutputStream" baos (ByteArrayOutputStream. (inc (count %2))) _ (Script'write-bytes baos, %2)]
                                        (Script'remove-all-instances-of %1, (.toByteArray baos))
                                    )
                              #_"byte[]" prog (Script''to-bytes script)
                              #_"byte[]" __connectedScript (reduce rem- (Arrays/copyOfRange prog, 0, (count prog)) sigs)
                              #_"boolean" valid?
                                (loop-when [] (seq sigs) => true
                                    (let [#_"byte[]" __pubKey (.pollFirst pubkeys)]
                                        ;; We could reasonably move this out of the loop, but because signature verification is significantly
                                        ;; more expensive than hashing, its not a big deal.
                                        (try
                                            (let [#_"TransactionSignature" sig (TransactionSignature'decode-from-bitcoin (.getFirst sigs), canon?, false)
                                                  #_"Sha256Hash" hash (Transaction''hash-for-signature-4b tx, index, __connectedScript, (byte (:sighash-flags sig)))]
                                                (when (ECKey'verify-3e (:hash-bytes hash), sig, __pubKey)
                                                    (.pollFirst sigs)
                                                )
                                            )
                                            (catch Exception _
                                                ;; There is (at least) one exception that could be hit here (EOFException, if the sig is too short).
                                                ;; Because I can't verify there aren't more, we use a very generic Exception catch.
                                            )
                                        )
                                        (recur-if (<= (count sigs) (count pubkeys)) [] => false)
                                    )
                                )
                              ;; We uselessly remove a stack object to emulate a Bitcoin Core bug.
                              #_"byte[]" __nullDummy (.pollLast stack)]
                            (when (and (contains? flags :ScriptVerifyFlag'NULLDUMMY) (pos? (count __nullDummy)))
                                (throw+ (ScriptException'new :ScriptError'SIG_NULLFAIL, (str "OP_CHECKMULTISIG(VERIFY) with non-null nulldummy: " (vec __nullDummy))))
                            )

                            (cond (= opcode Script'OP_CHECKMULTISIG)
                                (do
                                    (ยง ass stack (.add stack, (if valid? (byte-array [ 1 ]) (byte-array 0))))
                                )
                                (and (= opcode Script'OP_CHECKMULTISIGVERIFY) (not valid?))
                                (do
                                    (throw+ (ScriptException'new :ScriptError'SIG_NULLFAIL, "Script failed OP_CHECKMULTISIGVERIFY"))
                                )
                            )

                            __opCount
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey.
     ;
     ; @param txContainingThis The transaction in which this input scriptSig resides.
     ;                         Accessing txContainingThis from another thread while this method runs results in undefined behavior.
     ; @param scriptSigIndex The index in txContainingThis of the scriptSig (note: NOT the index of the scriptPubKey).
     ; @param scriptPubKey The connected scriptPubKey containing the conditions needed to claim the value.
     ; @param verifyFlags Each flag enables one validation rule.  If in doubt, use ALL_VERIFY_FLAGS.
     ;;
    #_throws #_[ "ProtocolException", "ScriptException" ]
    #_method
    (defn #_"void" Script''correctly-spends [#_"Script" this, #_"Transaction" tx, #_"long" index, #_"Script" __scriptPubKey, #_"{ScriptVerifyFlag}" flags]
        ;; Clone the transaction because executing the script involves editing it, and if we die, we'll leave
        ;; the tx half broken (also it's not so thread safe to work on it directly).
        (let [tx (Transaction'from-wire (:ledger tx), (ByteBuffer/wrap (Message''to-bytes tx, Transaction''to-wire)))]
            (when (or (< Script'MAX_SCRIPT_SIZE (count (Script''to-bytes this))) (< Script'MAX_SCRIPT_SIZE (count (Script''to-bytes __scriptPubKey))))
                (throw+ (ScriptException'new :ScriptError'SCRIPT_SIZE, "Script larger than 10,000 bytes"))
            )

            (let [#_"LinkedList<byte[]>" stack (LinkedList.)]
                (Script'execute-script-5 tx, index, this, stack, flags)

                (let [#_"LinkedList<byte[]>" __p2shStack (when (contains? flags :ScriptVerifyFlag'P2SH) (LinkedList. stack))]
                    (Script'execute-script-5 tx, index, __scriptPubKey, stack, flags)

                    (when (zero? (count stack))
                        (throw+ (ScriptException'new :ScriptError'EVAL_FALSE, "Stack empty at end of script execution."))
                    )
                    (when-not (Script'cast-to-bool (.pollLast stack))
                        (throw+ (ScriptException'new :ScriptError'EVAL_FALSE, (str "Script resulted in a non-true stack: " stack)))
                    )

                    ;; P2SH is pay to script hash.  It means that the scriptPubKey has a special form which is a valid
                    ;; program but it has "useless" form that if evaluated as a normal program always returns true.
                    ;; Instead, miners recognize it as special based on its template - it provides a hash of the real scriptPubKey
                    ;; and that must be provided by the input.  The goal of this bizarre arrangement is twofold:
                    ;;
                    ;; (1) You can sum up a large, complex script (like a CHECKMULTISIG script) with an address that's the same
                    ;;     size as a regular address.  This means it doesn't overload scannable QR codes/NFC tags or become
                    ;;     un-wieldy to copy/paste.
                    ;; (2) It allows the working set to be smaller: nodes perform best when they can store as many unspent outputs
                    ;;     in RAM as possible, so if the outputs are made smaller and the inputs get bigger, then it's better for
                    ;;     overall scalability and performance.

                    ;; TODO: Check if we can take out enforceP2SH if there's a checkpoint at the enforcement block.
                    (when (and (contains? flags :ScriptVerifyFlag'P2SH) (Script''is-pay-to-script-hash __scriptPubKey))
                        (doseq [#_"ScriptChunk" chunk (:chunks this)]
                            (when (and (ScriptChunk''is-op-code chunk) (< Script'OP_16 (:opcode chunk)))
                                (throw+ (ScriptException'new :ScriptError'SIG_PUSHONLY, "Attempted to spend a P2SH scriptPubKey with a script that contained script ops"))
                            )
                        )

                        (Script'execute-script-5 tx, index, (Script'parse (.pollLast __p2shStack)), __p2shStack, flags)

                        (when (zero? (count __p2shStack))
                            (throw+ (ScriptException'new :ScriptError'EVAL_FALSE, "P2SH stack empty at end of script execution."))
                        )
                        (when-not (Script'cast-to-bool (.pollLast __p2shStack))
                            (throw+ (ScriptException'new :ScriptError'EVAL_FALSE, "P2SH script execution resulted in a non-true stack"))
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Get the {@link Script.ScriptType}.
     ;
     ; @return The script type.
     ;;
    #_method
    (defn #_"ScriptType" Script''get-script-type [#_"Script" this]
        (cond
            (Script''is-sent-to-address this)     :ScriptType'P2PKH
            (Script''is-sent-to-raw-pub-key this) :ScriptType'PUB_KEY
            (Script''is-pay-to-script-hash this)  :ScriptType'P2SH
            :else                                 :ScriptType'NO_TYPE
        )
    )

    ;; Utility that doesn't copy for internal use.
    #_method
    (defn- #_"byte[]" Script''get-quick-program [#_"Script" this]
        (or (:program this) (Script''to-bytes this))
    )

    #_foreign
    #_override
    (defn #_"boolean" Object'''equals [#_"Script" this, #_"Object" o]
        (cond
            (= this o) true
            (or (nil? o) (not= (.getClass this) (.getClass o))) false
            :else (Arrays/equals (Script''get-quick-program this), (Script''get-quick-program (cast' Script o)))
        )
    )

    #_foreign
    #_override
    (defn #_"int" Object'''hashCode [#_"Script" this]
        (Arrays/hashCode (Script''get-quick-program this))
    )

    ;;;
     ; Returns the program opcodes as a string, for example "[1234] DUP HASH160".
     ;;
    #_method
    (defn #_"String" Script''to-string [#_"Script" this]
        (apply str (interpose " " (:chunks this)))
    )
)

(ยง ns bitclojn.signers
    (:refer-clojure :exclude [ensure subvec sync vec vector vector-of when when-not])
    (:use [bitclojn slang])
)

;;;
 ; Implementations of this interface are intended to sign inputs of the given transaction.
 ; Given transaction may already be partially signed or somehow altered by other signers.
 ;
 ; To make use of the signer, you need to add it into the wallet by calling
 ; {@link Wallet#addTransactionSigner(TransactionSigner)}.
 ; Signer will be serialized along with the wallet data.  In order for a wallet to recreate
 ; signer after deserialization, each signer should have no-args constructor.
 ;;
(defprotocol TransactionSigner
    ;;;
     ; Signs given transaction's inputs.
     ; Returns true if signer is compatible with given transaction (can do something meaningful with it).
     ; Otherwise this method returns false.
     ;;
    #_abstract
    (#_"boolean" TransactionSigner'''sign-inputs [#_"TransactionSigner" this, #_"ProposedTransaction" __propTx, #_"KeyBag" bag])
)

#_unused
(class-ns SignatureAndKey
    (defn #_"SignatureAndKey" SignatureAndKey'new [#_"ECDSASignature" sig, #_"ECKey" key]
        (hash-map
            #_"ECDSASignature" :sig sig
            #_"ECKey" :pub-key key
        )
    )
)

;;;
 ; This signer may be used as a template for creating custom multisig transaction signers.
 ;
 ; Concrete implementations have to implement {@link #getSignature(Sha256Hash, java.util.List)}
 ; method returning a signature and a public key of the keypair used to created that signature.
 ; It's up to custom implementation where to locate signatures: it may be a network connection,
 ; some local API or something else.
 ;;
#_unused
#_abstract
(class-ns CustomTransactionSigner (ยง implements TransactionSigner)
    (defn #_"CustomTransactionSigner" CustomTransactionSigner'new []
        (hash-map)
    )

    #_override
    (defn #_"boolean" TransactionSigner'''sign-inputs [#_"CustomTransactionSigner" this, #_"ProposedTransaction" __propTx, #_"KeyBag" bag]
        (let [#_"Transaction" tx (:partial-tx __propTx) #_"int" n (count (:inputs tx))]
            (loop-when [#_"int" i 0] (< i n) => true
                (let [#_"TransactionInput" in (nth (:inputs tx) i) #_"TransactionOutput" out (TransactionInput''get-connected-output in)]
                    (when (some? out) => (recur (inc i))
                        (let [#_"Script" __outKey (TransactionOutput''parse-script-pub-key out)]
                            (if (Script''is-pay-to-script-hash __outKey)
                                (let [#_"Script" __inSig (ensure some? (TransactionInput''get-script-sig in))]
                                    (try+
                                        ;; We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                                        ;; we sign missing pieces (to check this would require either assuming any signatures are signing
                                        ;; standard output types or a way to get processed signatures out of script execution).
                                        (Script''correctly-spends __inSig, tx, i, __outKey, Script'ALL_VERIFY_FLAGS)
                                        (log/warn "Input" i "already correctly spends output, assuming SIGHASH type used will be safe and skipping signing.")
                                        (ยง catch ScriptException _
                                            (let [#_"RedeemData" data (TransactionOutPoint''get-connected-redeem-data (:outpoint in), bag)]
                                                (when (some? data) => (log/warn (str "No redeem data found for input " i))
                                                    (let [#_"Sha256Hash" hash (Transaction''hash-for-signature-5s tx, i, (:redeem-script data), SigHash'ALL, false)
                                                          #_"SignatureAndKey" sig+key (CustomTransactionSigner'''get-signature this, hash, (get (:key-paths __propTx) __outKey))]
                                                        (ยง ass in (TransactionInput''set-script-sig in, (Script''get-script-sig-with-signature __outKey, __inSig, (TransactionSignature''encode-to-bitcoin (TransactionSignature'from-ecdsa (:sig sig+key), SigHash'ALL, false)), (Script''get-sig-insertion-index __inSig, hash, (:pub-key sig+key)))))
                                                    )
                                                )
                                            )
                                        )
                                    )
                                    (recur (inc i))
                                )
                                (do
                                    (log/warn "CustomTransactionSigner works only with P2SH transactions")
                                    false
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    #_abstract
    (defn #_"SignatureAndKey" CustomTransactionSigner'''get-signature [#_"CustomTransactionSigner" this, #_"Sha256Hash" hash, #_"[ChildNumber]" path])
)

;;;
 ; {@link TransactionSigner} implementation for signing inputs using keys from provided {@link KeyBag}.
 ;
 ; This signer doesn't create input scripts for tx inputs.  Instead it expects inputs to contain scripts with
 ; empty sigs and replaces one of the empty sigs with calculated signature.
 ;
 ; This signer is always implicitly added into every wallet and it is the first signer to be executed during tx
 ; completion.  As the first signer to create a signature, it stores derivation path of the signing key in a given
 ; {@link ProposedTransaction} object that will be also passed then to the next signer in chain.  This allows other
 ; signers to use correct signing key for P2SH inputs, because all the keys involved in a single P2SH address have
 ; the same derivation path.
 ;
 ; This signer always uses {@link Transaction.SigHash#ALL} signing mode.
 ;;
(class-ns LocalTransactionSigner (ยง implements TransactionSigner)
    (defn #_"LocalTransactionSigner" LocalTransactionSigner'new []
        (hash-map)
    )

    ;;;
     ; Verify flags that are safe to use when testing if an input is already signed.
     ;;
    (def- #_"{ScriptVerifyFlag}" LocalTransactionSigner'MINIMUM_VERIFY_FLAGS (hash-set :ScriptVerifyFlag'P2SH :ScriptVerifyFlag'NULLDUMMY))

    #_override
    (defn #_"boolean" TransactionSigner'''sign-inputs [#_"LocalTransactionSigner" this, #_"ProposedTransaction" __propTx, #_"KeyBag" bag]
        (let [#_"Transaction" tx (:partial-tx __propTx)]
            (dotimes [#_"int" i (count (:inputs tx))]
                (let [#_"TransactionInput" in (nth (:inputs tx) i) #_"TransactionOutput" out (TransactionInput''get-connected-output in)]
                    (when (some? out) => (log/warn (str "Missing connected output, assuming input " i " is already signed."))
                        (let [#_"Script" __inSig (TransactionInput''get-script-sig in) #_"Script" __outKey (TransactionOutput''parse-script-pub-key out)]
                            (try+
                                ;; We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                                ;; we sign missing pieces (to check this would require either assuming any signatures are signing
                                ;; standard output types or a way to get processed signatures out of script execution).
                                (Script''correctly-spends __inSig, tx, i, __outKey, LocalTransactionSigner'MINIMUM_VERIFY_FLAGS)
                                (log/warn (str "Input " i " already correctly spends output, assuming SIGHASH type used will be safe and skipping signing."))
                                (ยง catch ScriptException _
                                    (let [#_"RedeemData" redeem (TransactionOutPoint''get-connected-redeem-data (:outpoint in), bag)
                                          ;; For P2SH inputs we need to share derivation path of the signing key with other signers,
                                          ;; so that they use correct key to calculate their signatures.
                                          ;; Married keys all have the same derivation path, so we can safely just take first one here.
                                          #_"ECKey" __pubKey (first (:redeem-keys redeem))]
                                        (when (ยง instance? DeterministicKey __pubKey)
                                            (ยง ass __propTx (update __propTx :key-paths assoc __outKey (:child-number-path (cast' DeterministicKey __pubKey))))
                                        )
                                        ;; Locate private key in redeem data.  For pay-to-address and pay-to-key inputs RedeemData will always contain
                                        ;; only one key (with private bytes).  For P2SH inputs RedeemData will contain multiple keys, one of which MAY
                                        ;; have private bytes.
                                        (let-when [#_"ECKey" key (RedeemData''get-full-key redeem)] (some? key) => (log/warn (str "No local key found for input " i))
                                            ;; script here would be either a standard CHECKSIG program for pay-to-address or pay-to-pubkey inputs or
                                            ;; a CHECKMULTISIG program for P2SH inputs.
                                            (let [#_"byte[]" script (Script''to-bytes (:redeem-script redeem))]
                                                ;; At this point we have incomplete inputScript with OP_0 in place of one or more signatures.  We already
                                                ;; have calculated the signature using the local key and now need to insert it in the correct place
                                                ;; within inputScript.  For pay-to-address and pay-to-key script there is only one signature and it always
                                                ;; goes first in an inputScript (sigIndex = 0).  In P2SH input scripts we need to figure out our relative
                                                ;; position relative to other signers.  Since we don't have that information at this point, and since
                                                ;; we always run first, we have to depend on the other signers rearranging the signatures as needed.
                                                ;; Therefore, always place as first signature.
                                                (try+
                                                    (let [#_"TransactionSignature" sig (Transaction''calculate-signature-b tx, i, key, script, SigHash'ALL, false)]
                                                        (ยง ass in (TransactionInput''set-script-sig in, (Script''get-script-sig-with-signature __outKey, __inSig, (TransactionSignature''encode-to-bitcoin sig), 0)))
                                                    )
                                                    (ยง catch MissingPrivateKeyException _
                                                        (log/warn (str "No private key in keypair for input " i))
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
            true
        )
    )
)

;;;
 ; This transaction signer resolves missing signatures in accordance with the given {@link Wallet.MissingSigsMode}.
 ; If missingSigsMode is USE_OP_ZERO this signer does nothing assuming missing signatures are already presented in scriptSigs as OP_0.
 ; In MissingSigsMode.THROW mode this signer will throw an exception.  It would be MissingSignatureException
 ; for P2SH or MissingPrivateKeyException for other transaction types.
 ;;
(class-ns MissingSigResolutionSigner (ยง implements TransactionSigner)
    (defn #_"MissingSigResolutionSigner" MissingSigResolutionSigner'new [#_"MissingSigsMode" mode]
        (hash-map
            #_"MissingSigsMode" :missing-sigs-mode mode
        )
    )

    #_override
    (defn #_"boolean" TransactionSigner'''sign-inputs [#_"MissingSigResolutionSigner" this, #_"ProposedTransaction" __propTx, #_"KeyBag" bag]
        (when-not (= (:missing-sigs-mode this) :MissingSigsMode'USE_OP_ZERO)
            (let [#_"Transaction" tx (:partial-tx __propTx)
                  #_"byte[]" dummy (TransactionSignature''encode-to-bitcoin (TransactionSignature'dummy))]
                (dotimes [#_"int" i (count (:inputs tx))]
                    (let [#_"TransactionInput" in (nth (:inputs tx) i) #_"TransactionOutput" out (TransactionInput''get-connected-output in)]
                        (if (nil? out)
                            (log/warn (str "Missing connected output, assuming input " i " is already signed."))
                            (let [#_"Script" __inSig (TransactionInput''get-script-sig in) #_"Script" __outKey (TransactionOutput''parse-script-pub-key out)]
                                (if (or (Script''is-pay-to-script-hash __outKey) (Script''is-sent-to-multi-sig __outKey))
                                    (let [#_"int" x (if (Script''is-pay-to-script-hash __outKey) 1 0) #_"int" n (count (:chunks __inSig))]
                                        ;; All chunks except the first one (OP_0) and the last (redeem script) are signatures.
                                        (loop-when-recur [#_"int" j 1] (< j (- n x)) [(inc j)]
                                            (when (ScriptChunk''equals-op-code (nth (:chunks __inSig) j), 0)
                                                (condp = (:missing-sigs-mode this)
                                                    :MissingSigsMode'THROW
                                                        (throw+ (MissingSignatureException'new))
                                                    :MissingSigsMode'USE_DUMMY_SIG
                                                        (ยง ass in (TransactionInput''set-script-sig in, (Script''get-script-sig-with-signature __outKey, __inSig, dummy, (dec j))))
                                                    nil
                                                )
                                            )
                                        )
                                    )
                                    (when (ScriptChunk''equals-op-code (nth (:chunks __inSig) 0), 0)
                                        (condp = (:missing-sigs-mode this)
                                            :MissingSigsMode'THROW
                                                (throw+ (MissingPrivateKeyException'new))
                                            :MissingSigsMode'USE_DUMMY_SIG
                                                (ยง ass in (TransactionInput''set-script-sig in, (Script''get-script-sig-with-signature __outKey, __inSig, dummy, 0)))
                                            nil
                                        )
                                    )
                                )
                                ;; TODO: Handle non-P2SH multisig.
                            )
                        )
                    )
                )
            )
        )
        true
    )
)

;;;
 ; This class wraps transaction proposed to complete keeping a metadata that may be updated, used and effectively
 ; shared by transaction signers.
 ;;
(class-ns ProposedTransaction
    (defn #_"ProposedTransaction" ProposedTransaction'new [#_"Transaction" __partialTx]
        (hash-map
            #_"Transaction" :partial-tx __partialTx
            ;;;
             ; HD key paths used for each input to derive a signing key.  It's useful for multisig inputs only.
             ; The keys used to create a single P2SH address have the same derivation path, so to use a correct key each signer
             ; has to know a derivation path of signing keys used by previous signers.  For each input signers will use the
             ; same derivation path and we need to store only one key path per input.  As TransactionInput is mutable, inputs
             ; are identified by their scriptPubKeys (keys in this map).
             ;;
            #_"{Script [ChildNumber]}" :key-paths (hash-map)
        )
    )
)

(class-ns MissingSignatureException (ยง extends RuntimeException)
    (defn #_"MissingSignatureException" MissingSignatureException'new []
        (RuntimeException'new)
    )
)

(ยง ns bitclojn.store
    (:refer-clojure :exclude [ensure subvec sync vec vector vector-of when when-not])
    (:use [bitclojn slang])
)

;;;
 ; An implementor of BlockStore saves StoredBlock objects to disk.  Different implementations store them in
 ; different ways.  An in-memory implementation (MemoryBlockStore) exists for unit testing but real apps will
 ; want to use implementations that save to disk.
 ;
 ; A BlockStore is a map of hashes to StoredBlock.  The hash is the double digest of the Bitcoin serialization
 ; of the block header, <b>not</b> the header with the extra data as well.
 ;
 ; BlockStores are thread safe.
 ;;
(defprotocol BlockStore
    ;;;
     ; Saves the given block header+extra data.  The key isn't specified explicitly as it can be calculated
     ; from the StoredBlock directly.  Can throw if there is a problem with the underlying storage layer such
     ; as running out of disk space.
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (#_"BlockStore" BlockStore'''put [#_"BlockStore" this, #_"StoredBlock" block])

    ;;;
     ; Returns the StoredBlock given a hash.  The returned values block.getHash() method will be equal to the
     ; parameter. If no such block is found, returns null.
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (#_"StoredBlock" BlockStore'''get [#_"BlockStore" this, #_"Sha256Hash" hash])

    ;;;
     ; Returns the {@link StoredBlock} that represents the top of the chain of greatest total work.  Note that
     ; this can be arbitrarily expensive, you probably should use {@link SPVBlockChain#getChainHead()}
     ; or perhaps {@link SPVBlockChain#getBestChainHeight()} which will run in constant time and
     ; not take any heavyweight locks.
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (#_"StoredBlock" BlockStore'''get-chain-head [#_"BlockStore" this])

    ;;;
     ; Sets the {@link StoredBlock} that represents the top of the chain of greatest total work.
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (#_"BlockStore" BlockStore'''set-chain-head [#_"BlockStore" this, #_"StoredBlock" head])

    ;;; Closes the store. ;;
    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (#_"BlockStore" BlockStore'''close [#_"BlockStore" this])
)

;;;
 ; Thrown when something goes wrong with storing a block.  Examples: out of disk space.
 ;;
(class-ns BlockStoreException (ยง extends RuntimeException)
    (defn #_"BlockStoreException" BlockStoreException'new
        ([] (BlockStoreException'new nil))
        ([#_"String" message]
            (RuntimeException'new message)
        )
    )
)

;;;
 ; Thrown by {@link SPVBlockStore} when the process cannot gain exclusive access to the chain file.
 ;;
(class-ns ChainFileLockedException (ยง extends BlockStoreException)
    (defn #_"ChainFileLockedException" ChainFileLockedException'new [#_"String" message]
        (BlockStoreException'new message)
    )
)

;;;
 ; An implementor of FullPrunedBlockStore saves StoredBlock objects to some storage mechanism.
 ;
 ; In addition to keeping track of a chain using {@link StoredBlock}s, it should also keep track of
 ; a second copy of the chain which holds {@link StoredUndoableBlock}s.  In this way, an application can
 ; perform a headers-only initial sync and then use that information to more efficiently download a locally
 ; verified full copy of the block chain.
 ;
 ; A FullPrunedBlockStore should function well as a standard {@link BlockStore} and then be able to
 ; trivially switch to being used as a FullPrunedBlockStore.
 ;
 ; It should store the {@link StoredUndoableBlock}s of a number of recent blocks before verifiedHead.height
 ; and all those after verifiedHead.height.
 ; It is advisable to store any {@link StoredUndoableBlock} which has a height > verifiedHead.height - N.
 ; Because N determines the memory usage, it is recommended that N be customizable.  N should be chosen such
 ; that re-orgs beyond that point are vanishingly unlikely, e.g. a few thousand blocks is a reasonable choice.
 ;
 ; It must store the {@link StoredBlock} of all blocks.
 ;
 ; A FullPrunedBlockStore contains a map of hashes to [Full]StoredBlock.  The hash is the double digest of
 ; the Bitcoin serialization of the block header, <b>not</b> the header with the extra data as well.
 ;
 ; A FullPrunedBlockStore also contains a map of hash+index to UTXO.  Again, the hash is
 ; a standard Bitcoin double-SHA256 hash of the transaction.
 ;
 ; FullPrunedBlockStores are thread safe.
 ;;
(defprotocol FullPrunedBlockStore #_(ยง extends BlockStore)
    ;;;
     ; Saves the given {@link StoredUndoableBlock} and {@link StoredBlock}.  Calculates keys from the {@link StoredBlock}.
     ;
     ; Though not required for proper function of a FullPrunedBlockStore, any user of a FullPrunedBlockStore should ensure
     ; that a StoredUndoableBlock for each block up to the fully verified chain head has been added to this block store using
     ; this function (not put(StoredBlock)), so that the ability to perform reorgs is maintained.
     ;
     ; @throws BlockStoreException if there is a problem with the underlying storage layer, such as running out of disk space.
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (#_"FullPrunedBlockStore" FullPrunedBlockStore'''put-3 [#_"FullPrunedBlockStore" this, #_"StoredBlock" stored, #_"StoredUndoableBlock" undoable])

    ;;;
     ; Returns the StoredBlock that was added as a StoredUndoableBlock given a hash.  The returned values block.getHash()
     ; method will be equal to the parameter.  If no such block is found, returns null.
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (#_"StoredBlock" FullPrunedBlockStore'''get-once-undoable-stored-block [#_"FullPrunedBlockStore" this, #_"Sha256Hash" hash])

    ;;;
     ; Returns a {@link StoredUndoableBlock} whose block.getHash() method will be equal to the parameter.  If no such
     ; block is found, returns null.  Note that this may return null more often than get(Sha256Hash hash) as not all
     ; {@link StoredBlock}s have a {@link StoredUndoableBlock} copy stored as well.
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (#_"StoredUndoableBlock" FullPrunedBlockStore'''get-undo-block [#_"FullPrunedBlockStore" this, #_"Sha256Hash" hash])

    ;;;
     ; Gets a {@link UTXO} with the given hash and index, or null if none is found.
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (#_"UTXO" FullPrunedBlockStore'''get-transaction-output [#_"FullPrunedBlockStore" this, #_"Sha256Hash" hash, #_"long" index])

    ;;;
     ; Adds a {@link UTXO} to the list of unspent TransactionOutputs.
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (#_"void" FullPrunedBlockStore'''add-unspent-transaction-output [#_"FullPrunedBlockStore" this, #_"UTXO" out])

    ;;;
     ; Removes a {@link UTXO} from the list of unspent TransactionOutputs.
     ; Note that the coinbase of the genesis block should NEVER be spendable and thus never in the list.
     ;
     ; @throws BlockStoreException if there is an underlying storage issue, or out was not in the list.
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (#_"void" FullPrunedBlockStore'''remove-unspent-transaction-output [#_"FullPrunedBlockStore" this, #_"UTXO" out])

    ;;;
     ; True if this store has any unspent outputs from a transaction with a hash equal to the first parameter.
     ;
     ; @param numOutputs The number of outputs the given transaction has.
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (#_"boolean" FullPrunedBlockStore'''has-unspent-outputs [#_"FullPrunedBlockStore" this, #_"Sha256Hash" hash, #_"int" __numOutputs])

    ;;;
     ; Returns the {@link StoredBlock} that represents the top of the chain of greatest total work that has
     ; been fully verified and the point in the chain at which the unspent transaction output set in this
     ; store represents.
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (#_"StoredBlock" FullPrunedBlockStore'''get-verified-chain-head [#_"FullPrunedBlockStore" this])

    ;;;
     ; Sets the {@link StoredBlock} that represents the top of the chain of greatest total work that has been
     ; fully verified.  It should generally be set after a batch of updates to the transaction unspent output set,
     ; before a call to commitDatabaseBatchWrite.
     ;
     ; If chainHead has a greater height than the non-verified chain head (i.e. that set with
     ; {@link BlockStore#setChainHead}) the non-verified chain head should be set to the one set here.
     ; In this way a class using a FullPrunedBlockStore only in full-verification mode can ignore the regular
     ; {@link BlockStore} functions implemented as a part of a FullPrunedBlockStore.
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (#_"FullPrunedBlockStore" FullPrunedBlockStore'''set-verified-chain-head [#_"FullPrunedBlockStore" this, #_"StoredBlock" head])

    ;;;
     ; Begins/Commits/Aborts a database transaction.
     ;
     ; If abortDatabaseBatchWrite() is called by the same thread that called beginDatabaseBatchWrite(),
     ; any data writes between this call and abortDatabaseBatchWrite() made by the same thread
     ; should be discarded.
     ;
     ; Furthermore, any data written after a call to beginDatabaseBatchWrite() should not be readable
     ; by any other threads until commitDatabaseBatchWrite() has been called by this thread.
     ; Multiple calls to beginDatabaseBatchWrite() in any given thread should be ignored and treated as one call.
     ;;
    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (#_"void" FullPrunedBlockStore'''begin-database-batch-write [#_"FullPrunedBlockStore" this])

    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (#_"void" FullPrunedBlockStore'''commit-database-batch-write [#_"FullPrunedBlockStore" this])

    #_throws #_[ "BlockStoreException" ]
    #_abstract
    (#_"void" FullPrunedBlockStore'''abort-database-batch-write [#_"FullPrunedBlockStore" this])
)

;;;
 ; Keeps {@link StoredBlock}s in memory.
 ;;
(class-ns MemoryBlockStore (ยง implements BlockStore)
    (defn #_"MemoryBlockStore" MemoryBlockStore'new [#_"Ledger" ledger]
        (let [this
                (hash-map
                    #_"Ledger" :ledger ledger
                    #_"LinkedHashMap<Sha256Hash, StoredBlock>" :block-map
                        (proxy [LinkedHashMap #_"<Sha256Hash, StoredBlock>"] []
                            #_foreign
                            #_override
                            (#_"boolean" removeEldestEntry [#_"LinkedHashMap" #_this, #_"Map.Entry<Sha256Hash, StoredBlock>" _eldest]
                                (< 5000 (.size this))
                            )
                        )
                    #_"StoredBlock" :chain-head nil
                )
              ;; Insert the genesis block.
              #_"Block" header (Block''clone-as-header (:genesis-block ledger))
              #_"StoredBlock" genesis (StoredBlock'new header, (Block''get-work header), 0)]

            (-> this (BlockStore'''put genesis) (BlockStore'''set-chain-head genesis))
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"MemoryBlockStore" BlockStore'''put [#_"MemoryBlockStore" this, #_"StoredBlock" block]
        (sync this
            (when (nil? (:block-map this))
                (throw+ (BlockStoreException'new "MemoryBlockStore is closed"))
            )

            (let [#_"Sha256Hash" hash (Block''get-hash (:stored-header block))]
                (ยง ass this (update this :block-map assoc hash block))
                this
            )
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"StoredBlock" BlockStore'''get [#_"MemoryBlockStore" this, #_"Sha256Hash" hash]
        (sync this
            (when (nil? (:block-map this))
                (throw+ (BlockStoreException'new "MemoryBlockStore is closed"))
            )

            (get (:block-map this) hash)
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"StoredBlock" BlockStore'''get-chain-head [#_"MemoryBlockStore" this]
        (when (nil? (:block-map this))
            (throw+ (BlockStoreException'new "MemoryBlockStore is closed"))
        )

        (:chain-head this)
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"MemoryBlockStore" BlockStore'''set-chain-head [#_"MemoryBlockStore" this, #_"StoredBlock" head]
        (when (nil? (:block-map this))
            (throw+ (BlockStoreException'new "MemoryBlockStore is closed"))
        )

        (assoc this :chain-head head)
    )

    #_override
    (defn #_"MemoryBlockStore" BlockStore'''close [#_"MemoryBlockStore" this]
        (assoc this :block-map nil)
    )
)

;;;
 ; Used as a key for memory map (to avoid having to think about the {@link Ledger},
 ; which is required for {@link TransactionOutPoint}.
 ;;
(class-ns StoredTransactionOutPoint
    (defn #_"StoredTransactionOutPoint" StoredTransactionOutPoint'new [#_"Sha256Hash" hash, #_"long" index]
        (hash-map
            ;;; Hash of the transaction to which we refer. ;;
            #_"Sha256Hash" :hash hash
            ;;; Which output of that transaction we are talking about. ;;
            #_"long" :index index
        )
    )
)

;;;
 ; A HashMap<KeyType, ValueType> that is DB transaction-aware.
 ; This class is not thread-safe.
 ;;
(class-ns TransactionalHashMap #_"<KeyType, ValueType>"
    (defn #_"TransactionalHashMap" TransactionalHashMap'new []
        (hash-map
            #_"ThreadLocal<HashMap<KeyType, ValueType>>" :temp-map (ThreadLocal.)
            #_"ThreadLocal<HashSet<KeyType>>" :temp-set-removed (ThreadLocal.)
            #_"ThreadLocal<Boolean>" :in-transaction (ThreadLocal.)

            #_"HashMap<KeyType, ValueType>" :map (HashMap.)
        )
    )

    #_method
    (defn #_"void" TransactionalHashMap''begin-database-batch-write [#_"TransactionalHashMap" this]
        (.set (:in-transaction this), true)
        nil
    )

    #_method
    (defn #_"void" TransactionalHashMap''commit-database-batch-write [#_"TransactionalHashMap" this]
        (when-let [#_"HashSet<KeyType>" s (.get (:temp-set-removed this))]
            (doseq [#_"KeyType" key s]
                (ยง ass this (update this :map .remove key))
            )
        )
        (when-let [#_"HashMap<KeyType, ValueType>" m (.get (:temp-map this))]
            (doseq [#_"Map.Entry<KeyType, ValueType>" entry (.entrySet m)]
                (ยง ass this (update this :map assoc (.getKey entry) (.getValue entry)))
            )
        )
        (TransactionalHashMap''abort-database-batch-write this)
        nil
    )

    #_method
    (defn #_"void" TransactionalHashMap''abort-database-batch-write [#_"TransactionalHashMap" this]
        (.set (:in-transaction this), false)
        (.remove (:temp-set-removed this))
        (.remove (:temp-map this))
        nil
    )

    #_method
    (defn #_"ValueType" TransactionalHashMap''get [#_"TransactionalHashMap" this, #_"KeyType" key]
        (when (.get (:in-transaction this)) => (get (:map this) key)
            (or
                (when-let [#_"HashMap<KeyType, ValueType>" m (.get (:temp-map this))]
                    (get m key)
                )
                (let-when [#_"HashSet<KeyType>" s (.get (:temp-set-removed this))] (and (some? s) (contains? s key)) => (get (:map this) key)
                    nil
                )
            )
        )
    )

    #_method
    (defn #_"List<ValueType>" TransactionalHashMap''values [#_"TransactionalHashMap" this]
        (let [#_"List<ValueType>" values (ArrayList.)]
            (doseq [#_"KeyType" key (.keySet (:map this))]
                (ยง ass values (.add values, (TransactionalHashMap''get this, key)))
            )
            values
        )
    )

    #_method
    (defn #_"void" TransactionalHashMap''put [#_"TransactionalHashMap" this, #_"KeyType" key, #_"ValueType" value]
        (when (.get (:in-transaction this)) => (ยง ass this (update this :map assoc key value))
            (when-let [#_"HashSet<KeyType>" s (.get (:temp-set-removed this))]
                (ยง ass s (.remove s, key))
            )
            (when (nil? (.get (:temp-map this)))
                (.set (:temp-map this), (HashMap. #_"<KeyType, ValueType>"))
            )
            (ยง ass (.get (:temp-map this)) (assoc (.get (:temp-map this)) key value))
        )
        nil
    )

    #_method
    (defn #_"ValueType" TransactionalHashMap''remove [#_"TransactionalHashMap" this, #_"KeyType" key]
        (when (.get (:in-transaction this)) => (ยง ass this (update this :map .remove key))
            (let [#_"ValueType" value (get (:map this) key)]
                (when (some? value)
                    (when (nil? (.get (:temp-set-removed this)))
                        (.set (:temp-set-removed this), (HashSet. #_"<KeyType>"))
                    )
                    (ยง ass (.get (:temp-set-removed this)) (.add (.get (:temp-set-removed this)), key))
                )
                (if (some? (.get (:temp-map this)))
                    (or (ยง ass (.get (:temp-map this)) (.remove (.get (:temp-map this)), key)) value)
                    value
                )
            )
        )
    )
)

;;;
 ; A Map with multiple key types that is DB per-thread-transaction-aware.
 ; However, this class is not thread-safe.
 ;
 ; @param <UniqueKeyType> Is a key that must be unique per object.
 ; @param <MultiKeyType> Is a key that can have multiple values.
 ;;
(class-ns TransactionalMultiKeyHashMap #_"<UniqueKeyType, MultiKeyType, ValueType>"
    (defn #_"TransactionalMultiKeyHashMap" TransactionalMultiKeyHashMap'new []
        (hash-map
            #_"TransactionalHashMap<UniqueKeyType, ValueType>" :map-values (TransactionalHashMap'new)
            #_"HashMap<MultiKeyType, Set<UniqueKeyType>>" :map-keys (HashMap.)
        )
    )

    #_method
    (defn #_"void" TransactionalMultiKeyHashMap''begin-transaction [#_"TransactionalMultiKeyHashMap" this]
        (TransactionalHashMap''begin-database-batch-write (:map-values this))
        nil
    )

    #_method
    (defn #_"void" TransactionalMultiKeyHashMap''commit-transaction [#_"TransactionalMultiKeyHashMap" this]
        (TransactionalHashMap''commit-database-batch-write (:map-values this))
        nil
    )

    #_method
    (defn #_"void" TransactionalMultiKeyHashMap''abort-transaction [#_"TransactionalMultiKeyHashMap" this]
        (TransactionalHashMap''abort-database-batch-write (:map-values this))
        nil
    )

    #_method
    (defn #_"ValueType" TransactionalMultiKeyHashMap''get [#_"TransactionalMultiKeyHashMap" this, #_"UniqueKeyType" key]
        (TransactionalHashMap''get (:map-values this) key)
    )

    #_method
    (defn #_"void" TransactionalMultiKeyHashMap''put [#_"TransactionalMultiKeyHashMap" this, #_"UniqueKeyType" unique, #_"MultiKeyType" multi, #_"ValueType" value]
        (TransactionalHashMap''put (:map-values this), unique, value)
        (let [#_"Set<UniqueKeyType>" set (get (:map-keys this) multi)]
            (when (nil? set) => (ยง ass set (.add set, unique))
                (let [set (HashSet.)]
                    (ยง ass set (.add set, unique))
                    (ยง ass this (update this :map-keys assoc multi set))
                )
            )
        )
        nil
    )

    #_method
    (defn #_"ValueType" TransactionalMultiKeyHashMap''remove-by-unique-key [#_"TransactionalMultiKeyHashMap" this, #_"UniqueKeyType" key]
        (TransactionalHashMap''remove (:map-values this), key)
    )

    #_method
    (defn #_"void" TransactionalMultiKeyHashMap''remove-by-multi-key [#_"TransactionalMultiKeyHashMap" this, #_"MultiKeyType" key]
        (let [#_"Set<UniqueKeyType>" set (ยง ass this (update this :map-keys .remove key))]
            (when (some? set)
                (doseq [#_"UniqueKeyType" unique set]
                    (TransactionalMultiKeyHashMap''remove-by-unique-key this, unique)
                )
            )
        )
        nil
    )
)

(class-ns StoredBlockAndWasUndoableFlag
    (defn #_"StoredBlockAndWasUndoableFlag" StoredBlockAndWasUndoableFlag'new [#_"StoredBlock" block, #_"boolean" undoable?]
        (hash-map
            #_"StoredBlock" :block block
            #_"boolean" :was-undoable undoable?
        )
    )
)

;;;
 ; Keeps {@link StoredBlock}s, {@link StoredUndoableBlock}s and {@link UTXO}s in memory.
 ;;
(class-ns MemoryFullPrunedBlockStore (ยง implements FullPrunedBlockStore)
    ;;;
     ; Set up the MemoryFullPrunedBlockStore.
     ;
     ; @param ledger The network parameters of this block store - used to get genesis block.
     ; @param fullStoreDepth The depth of blocks to keep FullStoredBlocks instead of StoredBlocks.
     ;;
    (defn #_"MemoryFullPrunedBlockStore" MemoryFullPrunedBlockStore'new [#_"Ledger" ledger, #_"int" depth]
        (let [this
                (hash-map
                    #_"Ledger" :ledger ledger
                    #_"int" :full-store-depth (max 1 depth)
                    #_"TransactionalHashMap<Sha256Hash, StoredBlockAndWasUndoableFlag>" :block-map (TransactionalHashMap'new)
                    #_"TransactionalMultiKeyHashMap<Sha256Hash, Integer, StoredUndoableBlock>" :full-block-map (TransactionalMultiKeyHashMap'new)
                    ;; TODO: Use something more suited to remove-heavy use?
                    #_"TransactionalHashMap<StoredTransactionOutPoint, UTXO>" :transaction-output-map (TransactionalHashMap'new)
                    #_"StoredBlock" :chain-head nil
                    #_"StoredBlock" :verified-chain-head nil
                )

              ;; Insert the genesis block.
              #_"StoredBlock" header (StoredBlock'new (Block''clone-as-header (:genesis-block ledger)), (Block''get-work (:genesis-block ledger)), 0)
              ;; The coinbase in the genesis block is not spendable.
              #_"StoredUndoableBlock" genesis (StoredUndoableBlock'from-transactions (Block''get-hash (:genesis-block ledger)), (LinkedList.))

              this (FullPrunedBlockStore'''put-3 this, header, genesis)
              this (BlockStore'''set-chain-head this, header)
              this (FullPrunedBlockStore'''set-verified-chain-head this, header)]
            this
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"MemoryFullPrunedBlockStore" BlockStore'''put [#_"MemoryFullPrunedBlockStore" this, #_"StoredBlock" stored]
        (sync this
            (ensure some? (:block-map this), "MemoryFullPrunedBlockStore is closed")
            (let [#_"Sha256Hash" hash (Block''get-hash (:stored-header stored))]
                (TransactionalHashMap''put (:block-map this), hash, (StoredBlockAndWasUndoableFlag'new stored, false))
                this
            )
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"MemoryFullPrunedBlockStore" FullPrunedBlockStore'''put-3 [#_"MemoryFullPrunedBlockStore" this, #_"StoredBlock" stored, #_"StoredUndoableBlock" undoable]
        (sync this
            (ensure some? (:block-map this), "MemoryFullPrunedBlockStore is closed")
            (let [#_"Sha256Hash" hash (Block''get-hash (:stored-header stored))]
                (TransactionalMultiKeyHashMap''put (:full-block-map this), hash, (:stored-height stored), undoable)
                (TransactionalHashMap''put (:block-map this), hash, (StoredBlockAndWasUndoableFlag'new stored, true))
                this
            )
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"StoredBlock" BlockStore'''get [#_"MemoryFullPrunedBlockStore" this, #_"Sha256Hash" hash]
        (sync this
            (ensure some? (:block-map this), "MemoryFullPrunedBlockStore is closed")
            (let [#_"StoredBlockAndWasUndoableFlag" stored (TransactionalHashMap''get (:block-map this) hash)]
                (when (some? stored) (:block stored))
            )
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"StoredBlock" FullPrunedBlockStore'''get-once-undoable-stored-block [#_"MemoryFullPrunedBlockStore" this, #_"Sha256Hash" hash]
        (sync this
            (ensure some? (:block-map this), "MemoryFullPrunedBlockStore is closed")
            (let [#_"StoredBlockAndWasUndoableFlag" stored (TransactionalHashMap''get (:block-map this) hash)]
                (when (and (some? stored) (:was-undoable stored)) (:block stored))
            )
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"StoredUndoableBlock" FullPrunedBlockStore'''get-undo-block [#_"MemoryFullPrunedBlockStore" this, #_"Sha256Hash" hash]
        (sync this
            (ensure some? (:full-block-map this), "MemoryFullPrunedBlockStore is closed")
            (TransactionalMultiKeyHashMap''get (:full-block-map this) hash)
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"StoredBlock" BlockStore'''get-chain-head [#_"MemoryFullPrunedBlockStore" this]
        (sync this
            (ensure some? (:block-map this), "MemoryFullPrunedBlockStore is closed")
            (:chain-head this)
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"MemoryFullPrunedBlockStore" BlockStore'''set-chain-head [#_"MemoryFullPrunedBlockStore" this, #_"StoredBlock" head]
        (sync this
            (ensure some? (:block-map this), "MemoryFullPrunedBlockStore is closed")
            (assoc this :chain-head head)
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"StoredBlock" FullPrunedBlockStore'''get-verified-chain-head [#_"MemoryFullPrunedBlockStore" this]
        (sync this
            (ensure some? (:block-map this), "MemoryFullPrunedBlockStore is closed")
            (:verified-chain-head this)
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"MemoryFullPrunedBlockStore" FullPrunedBlockStore'''set-verified-chain-head [#_"MemoryFullPrunedBlockStore" this, #_"StoredBlock" head]
        (sync this
            (ensure some? (:block-map this), "MemoryFullPrunedBlockStore is closed")
            (let [this (assoc this :verified-chain-head head)
                  this
                    (when (< (:stored-height (:chain-head this)) (:stored-height head)) => this
                        (BlockStore'''set-chain-head this, head)
                    )]
                ;; Potential leak here if not all blocks get setChainHead'd.
                ;; Though the FullPrunedBlockStore allows for this, the current BlockChain will not do it.
                (TransactionalMultiKeyHashMap''remove-by-multi-key (:full-block-map this), (- (:stored-height head) (:full-store-depth this)))
                this
            )
        )
    )

    #_override
    (defn #_"MemoryFullPrunedBlockStore" BlockStore'''close [#_"MemoryFullPrunedBlockStore" this]
        (assoc this :block-map nil, :full-block-map nil, :transaction-output-map nil)
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"UTXO" FullPrunedBlockStore'''get-transaction-output [#_"MemoryFullPrunedBlockStore" this, #_"Sha256Hash" hash, #_"long" index]
        (sync this
            (ensure some? (:transaction-output-map this), "MemoryFullPrunedBlockStore is closed")
            (TransactionalHashMap''get (:transaction-output-map this) (StoredTransactionOutPoint'new hash, index))
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"void" FullPrunedBlockStore'''add-unspent-transaction-output [#_"MemoryFullPrunedBlockStore" this, #_"UTXO" out]
        (sync this
            (ensure some? (:transaction-output-map this), "MemoryFullPrunedBlockStore is closed")
            (TransactionalHashMap''put (:transaction-output-map this), (StoredTransactionOutPoint'new (:utxo-hash out), (:utxo-index out)), out)
        )
        nil
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"void" FullPrunedBlockStore'''remove-unspent-transaction-output [#_"MemoryFullPrunedBlockStore" this, #_"UTXO" out]
        (sync this
            (ensure some? (:transaction-output-map this), "MemoryFullPrunedBlockStore is closed")
            (when (nil? (TransactionalHashMap''remove (:transaction-output-map this), (StoredTransactionOutPoint'new (:utxo-hash out), (:utxo-index out))))
                (throw+ (BlockStoreException'new "Tried to remove a UTXO from MemoryFullPrunedBlockStore that it didn't have!"))
            )
        )
        nil
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"void" FullPrunedBlockStore'''begin-database-batch-write [#_"MemoryFullPrunedBlockStore" this]
        (sync this
            (TransactionalHashMap''begin-database-batch-write (:block-map this))
            (TransactionalMultiKeyHashMap''begin-transaction (:full-block-map this))
            (TransactionalHashMap''begin-database-batch-write (:transaction-output-map this))
        )
        nil
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"void" FullPrunedBlockStore'''commit-database-batch-write [#_"MemoryFullPrunedBlockStore" this]
        (sync this
            (TransactionalHashMap''commit-database-batch-write (:block-map this))
            (TransactionalMultiKeyHashMap''commit-transaction (:full-block-map this))
            (TransactionalHashMap''commit-database-batch-write (:transaction-output-map this))
        )
        nil
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"void" FullPrunedBlockStore'''abort-database-batch-write [#_"MemoryFullPrunedBlockStore" this]
        (sync this
            (TransactionalHashMap''abort-database-batch-write (:block-map this))
            (TransactionalMultiKeyHashMap''abort-transaction (:full-block-map this))
            (TransactionalHashMap''abort-database-batch-write (:transaction-output-map this))
        )
        nil
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"boolean" FullPrunedBlockStore'''has-unspent-outputs [#_"MemoryFullPrunedBlockStore" this, #_"Sha256Hash" hash, #_"int" n]
        (sync this
            (loop-when [#_"int" i 0] (< i n) => false
                (or (some? (FullPrunedBlockStore'''get-transaction-output this, hash, i)) (recur (inc i)))
            )
        )
    )
)

;;;
 ; An SPVBlockStore holds a limited number of block headers in a memory mapped ring buffer.  With such a store,
 ; you may not be able to process very deep re-orgs and could be disconnected from the chain (requiring a replay),
 ; but as they are virtually unheard of this is not a significant risk.
 ;;
(class-ns SPVBlockStore (ยง implements BlockStore)
    ;;; The default number of headers that will be stored in the ring buffer. ;;
    (def #_"int" SPVBlockStore'DEFAULT_CAPACITY 5000)
    (def #_"String" SPVBlockStore'HEADER_MAGIC "SPVB")

    ;; Use a separate cache to track get() misses.  This is to efficiently handle the case of an unconnected block
    ;; during chain download.  Each new block will do a get() on the unconnected block so if we haven't seen it yet
    ;; we must efficiently respond.
    ;;
    ;; We don't care about the value in this cache.  It is always notFoundMarker.  Unfortunately LinkedHashSet does
    ;; not provide the removeEldestEntry control.
    (def- #_"Object" SPVBlockStore'NOT_FOUND_MARKER (Object.))

    #_throws #_[ "BlockStoreException" ]
    #_method
    (defn- #_"SPVBlockStore" SPVBlockStore''init-store [#_"SPVBlockStore" this, #_"File" file]
        (try
            (let [#_"boolean" exists? (.exists file) #_"RandomAccessFile" raf (RandomAccessFile. file, "rw")
                  #_"long" size (SPVBlockStore'get-file-size (:capacity this))]
                (if (not exists?)
                    (do
                        (log/info (str "Creating new SPV block chain file " file))
                        (.setLength raf, size)
                    )
                    (when-not (= (.length raf) size)
                        (throw+ (BlockStoreException'new (str "File size on disk does not match expected size: " (.length raf) " vs " size)))
                    )
                )

                (let [this (assoc this :random-access-file raf) #_"FileChannel" channel (.getChannel raf)
                      this (assoc this :file-lock (.tryLock channel))]
                    (when (nil? (:file-lock this))
                        (throw+ (ChainFileLockedException'new "Store file is already locked by another process"))
                    )

                    ;; Map it into memory read/write.  The kernel will take care of flushing writes to disk at the most
                    ;; efficient times, which may mean that until the map is deallocated the data on disk is randomly
                    ;; inconsistent.  However the only process accessing it is us, via this mapping, so our own view will
                    ;; always be correct.  Once we establish the mmap the underlying file and channel can go away.  Note
                    ;; that the details of mmapping vary between platforms.
                    (let [this (assoc this :buffer (.map channel, FileChannel$MapMode/READ_WRITE, 0, size))]

                        ;; Check or initialize the header bytes to ensure we don't try to open some random file.
                        (if exists?
                            (let [#_"byte[]" magic (byte-array 4) _ (.get (:buffer this), magic)]
                                (when-not (= (String. magic, Charset'US-ASCII) SPVBlockStore'HEADER_MAGIC)
                                    (throw+ (BlockStoreException'new (str "Magic bytes do not match " SPVBlockStore'HEADER_MAGIC)))
                                )
                                this
                            )
                            (do
                                (.put (:buffer this), (.getBytes SPVBlockStore'HEADER_MAGIC, Charset'US-ASCII))
                                ;; Insert the genesis block.
                                (sync (:blockstore-lock this)
                                    (SPVBlockStore''set-ring-cursor this, (:buffer this), SPVBlockStore'FILE_PROLOGUE_BYTES)
                                )
                                (let [#_"Block" header (Block''clone-as-header (:genesis-block (:ledger this)))
                                      #_"StoredBlock" genesis (StoredBlock'new header, (Block''get-work header), 0)]

                                    (-> this (BlockStore'''put genesis) (BlockStore'''set-chain-head genesis))
                                )
                            )
                        )
                    )
                )
            )
            (catch Exception e
                (try
                    (when (some? (:random-access-file this))
                        (.close (:random-access-file this))
                    )
                    (catch IOException e'
                        (throw+ (BlockStoreException'new) e')
                    )
                )
                (throw+ (BlockStoreException'new) e)
            )
        )
    )

    ;;;
     ; Creates and initializes an SPV block store that can hold a given amount of blocks.
     ; Will create the given file if it's missing.  This operation will block on disk.
     ;
     ; @param file File to use for the block store.
     ; @param capacity Custom capacity.
     ; @throws BlockStoreException if something goes wrong.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (defn #_"SPVBlockStore" SPVBlockStore'new
        ([#_"Ledger" ledger, #_"File" file] (SPVBlockStore'new ledger, file, SPVBlockStore'DEFAULT_CAPACITY))
        ([#_"Ledger" ledger, #_"File" file, #_"int" capacity]
            (ensure some? ledger)
            (ensure some? file)
            (assert-argument (< 0 capacity))

            (let [this
                    (hash-map
                        #_"Ledger" :ledger ledger
                        #_"int" :capacity capacity

                        #_volatile
                        #_"MappedByteBuffer" :buffer nil

                        #_"Object" :blockstore-lock (Object.)

                        ;; The entire ring-buffer is mmapped and accessing it should be as fast as accessing regular memory once it's
                        ;; faulted in.  Unfortunately, in theory practice and theory are the same.  In practice they aren't.
                        ;;
                        ;; MMapping a file in Java does not give us a byte[] as you may expect but rather a ByteBuffer, and whilst on
                        ;; the OpenJDK/Oracle JVM calls into the get() methods are compiled down to inlined native code on Android each
                        ;; get() call is actually a full-blown JNI method under the hood, meaning it's unbelievably slow.  The caches
                        ;; below let us stay in the JIT-compiled Java world without expensive JNI transitions and make a 10x difference!
                        #_"LinkedHashMap<Sha256Hash, StoredBlock>" :block-cache
                            (proxy [LinkedHashMap #_"<Sha256Hash, StoredBlock>"] []
                                #_foreign
                                #_override
                                (#_"boolean" removeEldestEntry [#_"LinkedHashMap" #_this, #_"Map.Entry<Sha256Hash, StoredBlock>" _eldest]
                                    (< 2050 (.size this)) ;; Slightly more than the difficulty transition period.
                                )
                            )

                        #_"LinkedHashMap<Sha256Hash, Object>" :not-found-cache
                            (proxy [LinkedHashMap #_"<Sha256Hash, Object>"] []
                                #_foreign
                                #_override
                                (#_"boolean" removeEldestEntry [#_"LinkedHashMap" #_this, #_"Map.Entry<Sha256Hash, Object>" _eldest]
                                    (< 100 (.size this)) ;; This was chosen arbitrarily.
                                )
                            )

                        ;; Used to stop other applications/processes from opening the store.
                        #_"FileLock" :file-lock nil
                        #_"RandomAccessFile" :random-access-file nil

                        #_"StoredBlock" :last-chain-head nil
                    )]

                (SPVBlockStore''init-store this, file)
            )
        )
    )

    ;;; Returns the size in bytes of the file that is used to store the chain with the current parameters. ;;
    (defn #_"int" SPVBlockStore'get-file-size [#_"int" capacity]
        (+ (* SPVBlockStore'RECORD_SIZE capacity) SPVBlockStore'FILE_PROLOGUE_BYTES) ;; extra kilobyte for stuff
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"SPVBlockStore" BlockStore'''put [#_"SPVBlockStore" this, #_"StoredBlock" block]
        (let-when [#_"MappedByteBuffer" buffer (:buffer this)] (some? buffer) => (throw+ (BlockStoreException'new "Store closed"))
            (sync (:blockstore-lock this)
                (let [#_"int" i (SPVBlockStore''get-ring-cursor this, buffer)
                      ;; Probably wrapped around.
                      i (if (= i (SPVBlockStore'get-file-size (:capacity this))) SPVBlockStore'FILE_PROLOGUE_BYTES i)]
                    (.position buffer, i)
                    (let [#_"Sha256Hash" hash (Block''get-hash (:stored-header block))]
                        (ยง ass this (update this :not-found-cache .remove hash))
                        (.put buffer, (:hash-bytes hash))
                        (StoredBlock''serialize-compact block, buffer)
                        (SPVBlockStore''set-ring-cursor this, buffer, (.position buffer))
                        (ยง ass this (update this :block-cache assoc hash block))
                        this
                    )
                )
            )
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"StoredBlock" BlockStore'''get [#_"SPVBlockStore" this, #_"Sha256Hash" hash]
        (let-when [#_"MappedByteBuffer" buffer (:buffer this)] (some? buffer) => (throw+ (BlockStoreException'new "Store closed"))
            (sync (:blockstore-lock this)
                (let [#_"StoredBlock" cached (get (:block-cache this) hash)]
                    (cond
                        (some? cached)
                            cached
                        (some? (get (:not-found-cache this) hash))
                            nil
                        :else
                            ;; Starting from the current tip of the ring work backwards until we have either
                            ;; found the block or wrapped around.
                            (let [#_"int" i0 (SPVBlockStore''get-ring-cursor this, buffer) #_"int" size (SPVBlockStore'get-file-size (:capacity this))
                                  #_"byte[]" target (:hash-bytes hash) #_"byte[]" scratch (byte-array 32)
                                  #_"StoredBlock" stored
                                    (loop [#_"int" i i0]
                                        (let [i (- i SPVBlockStore'RECORD_SIZE)
                                              ;; When hit the start, wrap around.
                                              i (if (< i SPVBlockStore'FILE_PROLOGUE_BYTES) (- size SPVBlockStore'RECORD_SIZE) i)]
                                            ;; Cursor is now at the start of the next record to check, so read the hash and compare it.
                                            (.position buffer, i)
                                            (.get buffer, scratch)
                                            (when (Arrays/equals scratch, target) => (recur-if (not= i i0) i => nil)
                                                ;; Found the target.
                                                (StoredBlock'deserialize-compact (:ledger this), buffer)
                                            )
                                        )
                                    )]
                                (if (some? stored)
                                    (ยง ass this (update this :block-cache assoc hash stored))
                                    (ยง ass this (update this :not-found-cache assoc hash SPVBlockStore'NOT_FOUND_MARKER))
                                )
                                stored
                            )
                    )
                )
            )
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"StoredBlock" BlockStore'''get-chain-head [#_"SPVBlockStore" this]
        (let-when [#_"MappedByteBuffer" buffer (:buffer this)] (some? buffer) => (throw+ (BlockStoreException'new "Store closed"))
            (sync (:blockstore-lock this)
                (when (nil? (:last-chain-head this))
                    (let [#_"byte[]" bytes (byte-array 32)]
                        (.position buffer, 8)
                        (.get buffer, bytes)
                        (let [#_"Sha256Hash" hash (Sha256Hash'wrap bytes)
                              #_"StoredBlock" block (BlockStore'''get this, hash)]
                            (when (nil? block)
                                (throw+ (BlockStoreException'new (str "Corrupted block store: could not find chain head: " hash)))
                            )

                            (ยง ass this (assoc this :last-chain-head block))
                        )
                    )
                )
                (:last-chain-head this)
            )
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"SPVBlockStore" BlockStore'''set-chain-head [#_"SPVBlockStore" this, #_"StoredBlock" head]
        (let-when [#_"MappedByteBuffer" buffer (:buffer this)] (some? buffer) => (throw+ (BlockStoreException'new "Store closed"))
            (sync (:blockstore-lock this)
                (let [this (assoc this :last-chain-head head)]
                    (.position buffer, 8)
                    (.put buffer, (:hash-bytes (Block''get-hash (:stored-header head))))
                    this
                )
            )
        )
    )

    #_throws #_[ "BlockStoreException" ]
    #_override
    (defn #_"SPVBlockStore" BlockStore'''close [#_"SPVBlockStore" this]
        (try
            (.force (:buffer this))
            (let [this (assoc this :buffer nil)] ;; Allow it to be GCd and the underlying file mapping to go away.
                (.close (:random-access-file this))
                this
            )
            (catch IOException e
                (throw+ (BlockStoreException'new) e)
            )
        )
    )

    (def #_"int" SPVBlockStore'RECORD_SIZE (+ 32 StoredBlock'COMPACT_SERIALIZED_SIZE)) ;; hash

    ;; File format:
    ;;   4 header bytes = "SPVB"
    ;;   4 cursor bytes, which indicate the offset from the first kb where the next block header should be written
    ;;   32 bytes for the hash of the chain head
    ;;
    ;; For each header (128 bytes)
    ;;   32 bytes hash of the header
    ;;   12 bytes of chain work
    ;;    4 bytes of height
    ;;   80 bytes of block header data
    (def #_"int" SPVBlockStore'FILE_PROLOGUE_BYTES 1024)

    ;;; Returns the offset from the file start where the latest block should be written (end of prev block). ;;
    #_method
    (defn- #_"int" SPVBlockStore''get-ring-cursor [#_"SPVBlockStore" this, #_"ByteBuffer" buffer]
        (let [#_"int" cursor (.getInt buffer, 4)]
            (assert-state (<= SPVBlockStore'FILE_PROLOGUE_BYTES cursor), "Integer overflow")
            cursor
        )
    )

    #_method
    (defn- #_"void" SPVBlockStore''set-ring-cursor [#_"SPVBlockStore" this, #_"ByteBuffer" buffer, #_"int" cursor]
        (assert-argument (<= 0 cursor))
        (.putInt buffer, 4, cursor)
        nil
    )
)

(ยง ns bitclojn.utils
    (:refer-clojure :exclude [ensure subvec sync vec vector vector-of when when-not])
    (:use [bitclojn slang])
)

;;;
 ; Thread factory whose threads are marked as daemon and won't prevent process exit.
 ;;
(class-ns DaemonThreadFactory (ยง implements ThreadFactory)
    (defn #_"DaemonThreadFactory" DaemonThreadFactory'new [#_"String" name]
        (hash-map
            #_"String" :name name
        )
    )

    #_foreign
    #_override
    (defn #_"Thread" ThreadFactory'''newThread [#_"DaemonThreadFactory" this, #_"Runnable" runnable]
        (let [#_"Thread" thread (.newThread (Executors/defaultThreadFactory), runnable)]
            (.setDaemon thread, true)
            (when (some? (:name this))
                (.setName thread, (:name this))
            )
            thread
        )
    )
)

;;;
 ; An exchange rate is expressed as a ratio of a {@link Coin} and a {@link Fiat} amount.
 ;;
(class-ns ExchangeRate
    ;;;
     ; Construct exchange rate.
     ;;
    (defn #_"ExchangeRate" ExchangeRate'new
        ;; One coin is worth this amount of fiat.
        ([#_"Fiat" fiat]
            (ExchangeRate'new Coin'COIN, fiat))
        ;; This amount of coin is worth that amount of fiat.
        ([#_"Coin" coin, #_"Fiat" fiat]
            (assert-argument (Coin''positive? coin))
            (assert-argument (Fiat''positive? fiat))
            (assert-argument (some? (:code fiat)), "currency code required")

            (hash-map
                #_"Coin" :coin coin
                #_"Fiat" :fiat fiat
            )
        )
    )

    ;;;
     ; Convert a coin amount to a fiat amount using this exchange rate.
     ;
     ; @throws ArithmeticException if the converted fiat amount is too high or too low.
     ;;
    #_method
    (defn #_"Fiat" ExchangeRate''coin-to-fiat [#_"ExchangeRate" this, #_"Coin" coin]
        ;; Use BigInteger because it's much easier to maintain full precision without overflowing.
        (let [#_"BigInteger" converted (.divide (.multiply (BigInteger/valueOf (:value coin)), (BigInteger/valueOf (-> this :fiat :value))), (BigInteger/valueOf (-> this :coin :value)))]

            (when-not (<= (BigInteger/valueOf Long/MIN_VALUE) converted (BigInteger/valueOf Long/MAX_VALUE))
                (throw (ArithmeticException. "Overflow"))
            )

            (Fiat'new (-> this :fiat :code), (.longValue converted))
        )
    )

    ;;;
     ; Convert a fiat amount to a coin amount using this exchange rate.
     ;
     ; @throws ArithmeticException if the converted coin amount is too high or too low.
     ;;
    #_method
    (defn #_"Coin" ExchangeRate''fiat-to-coin [#_"ExchangeRate" this, #_"Fiat" fiat]
        (assert-argument (= (:code fiat) (-> this :fiat :code)), (str "Currency mismatch: " (:code fiat) " vs " (-> this :fiat :code)))

        ;; Use BigInteger because it's much easier to maintain full precision without overflowing.
        (let [#_"BigInteger" converted (.divide (.multiply (BigInteger/valueOf (:value fiat)), (BigInteger/valueOf (-> this :coin :value))), (BigInteger/valueOf (-> this :fiat :value)))]

            (when-not (<= (BigInteger/valueOf Long/MIN_VALUE) converted (BigInteger/valueOf Long/MAX_VALUE))
                (throw (ArithmeticException. "Overflow"))
            )

            (Coin'new (.longValue converted))
        )
    )
)

(class-ns BackoffParams
    (defn #_"BackoffParams" BackoffParams'new
        "Parameters to configure a particular kind of exponential backoff."
        ([] (BackoffParams'new 100, 1.1, (* 30 1000)))

        ([#_"long" initial, #_"float" multiplier, #_"long" maximum]
            (assert-argument (< 1.0 multiplier), "multiplier must be greater than 1.0")
            (assert-argument (<= initial maximum), "maximum must not be less than initial")

            (hash-map
                ;;; The initial interval to wait, in milliseconds. ;;
                #_"float" :initial initial
                ;;; The multiplier to apply on each failure. ;;
                #_"float" :multiplier multiplier
                ;;; The maximum interval to wait, in milliseconds. ;;
                #_"float" :maximum maximum
            )
        )
    )
)

;;;
 ; Tracks successes and failures and calculates a time to retry the operation.
 ;
 ; The retries are exponentially backed off, up to a maximum interval.  On success the back off interval is reset.
 ;;
(class-ns ExponentialBackoff
    (defn #_"ExponentialBackoff" ExponentialBackoff'new [#_"BackoffParams" params]
        (let [this
                (hash-map
                    #_"BackoffParams" :params params
                    #_"float" :backoff 0.0
                    ;;; The next time to retry, in milliseconds since the epoch. ;;
                    #_"long" :retry-time 0
                )]
            (ExponentialBackoff''track-success this)
        )
    )

    ;;; Track a success - reset back off interval to the initial value. ;;
    #_method
    (defn #_"ExponentialBackoff" ExponentialBackoff''track-success [#_"ExponentialBackoff" this]
        (assoc this :backoff (-> this :params :initial), :retry-time (Time'now))
    )

    ;;; Track a failure - multiply the back off interval by the multiplier. ;;
    #_method
    (defn #_"ExponentialBackoff" ExponentialBackoff''track-failure [#_"ExponentialBackoff" this]
        (let [this (assoc this :retry-time (+ (Time'now) (long (:backoff this))))]
            (update this :backoff #(min (* % (-> this :params :multiplier)) (-> this :params :maximum)))
        )
    )

    (defn #_"int" ExponentialBackoff'compare [#_"ExponentialBackoff" this, #_"ExponentialBackoff" that]
        ;; Note that in this implementation compareTo() is not consistent with equals().
        (compare (:retry-time this) (:retry-time that))
    )
)

(class-ns UserThread (ยง extends Thread) (ยง implements Executor)
    ;; 10,000 pending tasks is entirely arbitrary and may or may not be appropriate for the device we're running on.
    (def #_"int" UserThread'WARNING_THRESHOLD 10000)

    (defn #_"UserThread" UserThread'new []
        (let [this
                (merge (ยง super Thread'new "bitcoinj user thread")
                    (hash-map
                        #_"LinkedBlockingQueue<Runnable>" :tasks (LinkedBlockingQueue.)
                    )
                )]
            (.setDaemon this, true)
            (.start this)
            this
        )
    )

    #_foreign
    #_override
    (defn #_"void" Runnable'''run [#_"UserThread" this]
        (while true
            (let [#_"Runnable" task (Uninterruptibles/takeUninterruptibly (:tasks this))]
                (try
                    (.run task)
                    (catch Throwable t
                        (log/warn t, "Exception in user thread")
                    )
                )
            )
        )
        nil
    )

    #_foreign
    #_override
    (defn #_"void" Executor'''execute [#_"UserThread" this, #_"Runnable" runnable]
        (let [#_"int" size (count (:tasks this))]
            (when (= size UserThread'WARNING_THRESHOLD)
                (log/warn (str "User thread has " size " pending tasks, memory exhaustion may occur.\n"
                               "If you see this message, check your memory consumption and see if it's problematic or excessively spikey.\n"
                               "If it is, check for deadlocked or slow event handlers. If it isn't, try adjusting the constant \n"
                               "UserThread.WARNING_THRESHOLD upwards until it's a suitable level for your app, or Integer.MAX_VALUE to disable."))
            )
            (Uninterruptibles/putUninterruptibly (:tasks this), runnable)
        )
        nil
    )
)

;;;
 ; Various threading related utilities.  Provides a wrapper around explicit lock creation that lets you control whether
 ; bitcoinj performs cycle detection or not.  Cycle detection is useful to detect bugs but comes with a small cost.
 ; Also provides a worker thread that is designed for event listeners to be dispatched on.
 ;;
#_stateless
(class-ns Threading
    ;;;
     ; An executor with one thread that is intended for running event listeners on.  This ensures all event listener
     ; code runs without any locks being held.  It's intended for the API user to run things on.  Callbacks registered
     ; by bitcoinj internally shouldn't normally run here, although currently there are a few exceptions.
     ;;
    (ยง def #_"Executor" Threading'USER_THREAD (UserThread'new))

    ;;;
     ; A dummy executor that just invokes the runnable immediately.  Use this over
     ; {@link com.google.common.util.concurrent.MoreExecutors#sameThreadExecutor()} because the latter creates
     ; a new object each time in order to implement the more complex {@link ExecutorService} interface, which is
     ; overkill for our needs.
     ;;
    (def #_"Executor" Threading'SAME_THREAD
        (reify Executor
            #_foreign
            #_override
            (#_"void" execute [#_"Executor" __, #_"Runnable" runnable]
                (.run runnable)
                nil
            )
        )
    )

    ;;;
     ; Put a dummy task into the queue and wait for it to be run.  Because it's single threaded, this means all
     ; tasks submitted before this point are now completed.  Usually you won't want to use this method - it's a
     ; convenience primarily used in unit testing.  If you want to wait for an event to be called the right thing
     ; to do is usually to create a {@link com.google.common.util.concurrent.SettableFuture} and then call set
     ; on it.  You can then either block on that future, compose it, add listeners to it and so on.
     ;;
    (defn #_"void" Threading'wait-for-user-code []
        (let [#_"CountDownLatch" latch (CountDownLatch. 1)]
            (.execute Threading'USER_THREAD, #(.countDown latch))
            (Uninterruptibles/awaitUninterruptibly latch)
        )
        nil
    )

    ;;; A caching thread pool that creates daemon threads, which won't keep the JVM alive waiting for more work. ;;
    (def #_"ListeningExecutorService" Threading'THREAD_POOL (MoreExecutors/listeningDecorator (Executors/newCachedThreadPool
        (reify ThreadFactory
            #_foreign
            #_override
            (#_"Thread" newThread [#_"ThreadFactory" __, #_"Runnable" r]
                (let [#_"Thread" t (Thread. r)]
                    (.setName t, "Threading.THREAD_POOL worker")
                    (.setDaemon t, true)
                    t
                )
            )
        )))
    )
)

;;;
 ; Caching counter for block versions within a moving window.
 ; NOT thread safe as there's risk of getting versions out of sequence.
 ;
 ; @see Ledger#getMajorityWindow()
 ;;
(class-ns VersionTally
    (defn #_"VersionTally" VersionTally'new [#_"Ledger" ledger]
        (hash-map
            ;;;
             ; Number of versions to be accumulated.  Until it matches the size of
             ; the version window, we do not have sufficient data to return values.
             ;;
            #_"int" :capacity (:majority-window ledger)
            ;;;
             ; Cache of version numbers.
             ;;
            #_"[long]" :version-window (vector-of :long)
        )
    )

    ;;;
     ; Add a new block version to the tally.
     ;;
    #_method
    (defn #_"VersionTally" VersionTally''add [#_"VersionTally" this, #_"long" version]
        (update this :version-window #(conj (if (< (count %) (:capacity this)) % (subvec % 1)) version))
    )

    ;;;
     ; Create a version tally for a block store.  Note this does not search backwards past
     ; the start of the block store, so if starting from a checkpoint, this may not fill the window.
     ;
     ; @param store Block store to load blocks from.
     ; @param block Chain head.
     ;;
    #_throws #_[ "BlockStoreException" ]
    (defn #_"VersionTally" VersionTally'from-store [#_"Ledger" ledger, #_"BlockStore" store, #_"StoredBlock" block]
        (let [#_"VersionTally" this (VersionTally'new ledger)
              ;; We don't know how many blocks back we can go, so load what we can first.
              #_"(long)" stack
                (->>
                    (iterate #(StoredBlock''get-prev %, store) block)
                    (take-while some?)
                    (take (:capacity this))
                    (map #(:version (:stored-header %)))
                    (reduce conj (list))
                )]
            ;; Replay the versions into the tally.
            (reduce VersionTally''add this stack)
        )
    )

    ;;;
     ; Count the blocks at or above the given version within the window, or null if the window is not yet full.
     ;
     ; @param version The block version to query.
     ;;
    #_method
    (defn #_"Integer" VersionTally''get-count-at-or-above [#_"VersionTally" this, #_"long" version]
        (let-when [#_"long*" window (:version-window this)] (<= (:capacity this) (count window))
            (count (filter #(<= version %) window))
        )
    )
)

(ยง ns bitclojn.wallet-listeners
    (:refer-clojure :exclude [ensure subvec sync vec vector vector-of when when-not])
    (:use [bitclojn slang])
)

(defprotocol KeyChainEventListener
    ;;;
     ; Called whenever a new key is added to the key chain, whether that be via an explicit addition or due to some
     ; other automatic derivation.  See the documentation for your {@link KeyChain} implementation for details on
     ; what can trigger this event.
     ;;
    #_abstract
    (#_"void" KeyChainEventListener'''on-keys-added [#_"KeyChainEventListener" this, #_"List<ECKey>" keys])
)

;;;
 ; Implementors are called when the contents of the wallet changes, for instance due to receiving/sending money
 ; or a block chain re-organize.
 ;;
(defprotocol WalletChangeEventListener
    ;;;
     ; Designed for GUI applications to refresh their transaction lists.  This callback is invoked in the following
     ; situations:
     ;
     ; <ol>
     ;     <li>A new block is received (and thus building transactions got more confidence).</li>
     ;     <li>A pending transaction is received.</li>
     ;     <li>A pending transaction changes confidence due to some non-new-block related event,
     ;     such as being announced by more peers or by  a double-spend conflict being observed.</li>
     ;     <li>A re-organize occurs. Call occurs only if the re-org modified any of our transactions.</li>
     ;     <li>A new spend is committed to the wallet.</li>
     ;     <li>The wallet is reset and all transactions removed.<li>
     ; </ol>
     ;
     ; When this is called you can refresh the UI contents from the wallet contents.  It's more efficient to use
     ; this rather than onTransactionConfidenceChanged() + onReorganize() because you only get one callback per block
     ; rather than one per transaction per block.  Note that this is <b>not</b> called when a key is added.
     ;;
    #_abstract
    (#_"void" WalletChangeEventListener'''on-wallet-changed [#_"WalletChangeEventListener" this, #_"Wallet" wallet])
)

;;;
 ; Implementors are called when the contents of the wallet changes, for instance due to receiving/sending money
 ; or a block chain re-organize.
 ;;
(defprotocol WalletCoinsReceivedEventListener
    ;;;
     ; This is called when a transaction is seen that sends coins <b>to</b> this wallet, either because it was
     ; broadcast across the network or because a block was received.  If a transaction is seen when it was broadcast,
     ; onCoinsReceived won't be called again when a block containing it is received.  If you want to know when such
     ; a transaction receives its first confirmation, register a {@link TransactionConfidence} event listener using
     ; the object retrieved via {@link Transaction#getConfidence()}.  It's safe to modify the
     ; wallet in this callback, for example, by spending the transaction just received.
     ;
     ; @param wallet The wallet object that received the coins.
     ; @param tx The transaction which sent us the coins.
     ; @param prevBalance Balance before the coins were received.
     ; @param newBalance This is the 'estimated' balance.
     ;;
    #_abstract
    (#_"void" WalletCoinsReceivedEventListener'''on-coins-received [#_"WalletCoinsReceivedEventListener" this, #_"Wallet" wallet, #_"Transaction" tx, #_"Coin" before, #_"Coin" after])
)

;;;
 ; Implementors are called when the contents of the wallet changes, for instance due to receiving/sending money
 ; or a block chain re-organize.
 ;;
(defprotocol WalletCoinsSentEventListener
    ;;;
     ; This is called when a transaction is seen that sends coins <b>from</b> this wallet, either because it
     ; was broadcast across the network or because a block was received.  This may at first glance seem useless,
     ; because in the common case you already know about such transactions because you created them with the
     ; Wallets createSend/sendCoins methods.  However when you have a wallet containing only keys, and you wish
     ; to replay the block chain to fill it with transactions, it's useful to find out when a transaction is
     ; discovered that sends coins from the wallet.
     ;
     ; It's safe to modify the wallet from inside this callback, but if you're replaying the block chain you should
     ; be careful to avoid such modifications.  Otherwise your changes may be overridden by new data from the chain.
     ;
     ; @param wallet The wallet object that this callback relates to (that sent the coins).
     ; @param tx The transaction that sent the coins to someone else.
     ; @param prevBalance The wallets balance before this transaction was seen.
     ; @param newBalance The wallets balance after this transaction was seen.  This is the 'estimated' balance.
     ;;
    #_abstract
    (#_"void" WalletCoinsSentEventListener'''on-coins-sent [#_"WalletCoinsSentEventListener" this, #_"Wallet" wallet, #_"Transaction" tx, #_"Coin" before, #_"Coin" after])
)

;;;
 ; Implementors are called when the wallet is reorganized.
 ;;
(defprotocol WalletReorganizeEventListener
    ;; TODO: Finish onReorganize to be more useful.
    ;;;
     ; This is called when a block is received that triggers a block chain re-organization.
     ;
     ; A re-organize means that the consensus (chain) of the network has diverged and now changed from
     ; what we believed it was previously.  Usually this won't matter because the new consensus will include
     ; all our old transactions assuming we are playing by the rules.  However it's theoretically possible
     ; for our balance to change in arbitrary ways, most likely, we could lose some money we thought we had.
     ;
     ; It is safe to use methods of wallet whilst inside this callback.
     ;;
    #_abstract
    (#_"void" WalletReorganizeEventListener'''on-reorganize [#_"WalletReorganizeEventListener" this, #_"Wallet" wallet])
)

(ยง ns bitclojn.wallet
    (:refer-clojure :exclude [ensure subvec sync vec vector vector-of when when-not])
    (:use [bitclojn slang])
)

;;;
 ; A KeyChain is a class that stores a collection of keys for a {@link Wallet}.  Key chains are expected
 ; to be able to look up keys given a hash (i.e. address) or pubkey bytes, and provide keys on request
 ; for a given purpose.  They can inform event listeners about new keys being added.
 ;;

;;;
 ; Whether this basic key chain is empty, full of regular (usable for signing) keys, or full of watching keys.
 ;;
(def KeyChainState'enum-set
    (hash-set
        :KeyChainState'EMPTY
        :KeyChainState'WATCHING
        :KeyChainState'REGULAR
    )
)

;;;
 ; A {@link KeyChain} that implements the simplest model possible: it can have keys imported into it, and just
 ; acts as a dumb bag of keys.  It will, left to its own devices, always return the same key for usage by the wallet,
 ; although it will automatically add one to itself if it's empty or if encryption is requested.
 ;;
(class-ns BasicKeyChain
    (defn #_"BasicKeyChain" BasicKeyChain'new []
        (hash-map
            #_"Object" :b-keychain-lock (Object.)

            ;; Maps used to let us quickly look up a key given data we find in transcations or the block chain.
            #_"LinkedHashMap<ByteString, ECKey>" :hash-to-keys (LinkedHashMap.)
            #_"LinkedHashMap<ByteString, ECKey>" :pubkey-to-keys (LinkedHashMap.)
            #_"boolean" :is-watching false

            #_"[KeyChainEventListener]" :key-chain-listeners (vector)
        )
    )

    ;;;
     ; Returns a copy of the list of keys that this chain is managing.
     ;;
    #_method
    (defn #_"List<ECKey>" BasicKeyChain''get-keys [#_"BasicKeyChain" this]
        (sync (:b-keychain-lock this)
            (ArrayList. (.values (:hash-to-keys this)))
        )
    )

    #_method
    (defn- #_"BasicKeyChain" BasicKeyChain''import-key-locked [#_"BasicKeyChain" this, #_"ECKey" key]
        (let [#_"boolean" watching? (ECKey''is-watching key)
              this
                (cond
                    (empty? (:hash-to-keys this))             (assoc this :is-watching watching?)
                    (and watching? (not (:is-watching this))) (throw (IllegalArgumentException. "Key is watching but chain is not"))
                    (and (not watching?) (:is-watching this)) (throw (IllegalArgumentException. "Key is not watching but chain is"))
                    :else                                     this
                )]
            (let [#_"ECKey" prior (ยง ass this (update this :pubkey-to-keys assoc (ยง ByteString/copyFrom (ECKey''get-pub-key key)) key))]
                (ยง ass this (update this :hash-to-keys assoc (ยง ByteString/copyFrom (ECKey''calculate-pub-key-hash160 key)) key))
                (assert-state (nil? prior))
            )
            this
        )
    )

    #_method
    (defn- #_"void" BasicKeyChain''queue-on-keys-added [#_"BasicKeyChain" this, #_"List<ECKey>" keys]
        (assert-state (.isHeldByCurrentThread (:b-keychain-lock this)))

        (doseq [#_"KeyChainEventListener" l (:key-chain-listeners this)]
            (ยง async?
                (KeyChainEventListener'''on-keys-added l, keys)
            )
        )
        nil
    )

    ;;;
     ; Imports a key to the key chain.  If key is present in the key chain, ignore it.
     ;;
    #_method
    (defn #_"BasicKeyChain" BasicKeyChain''import-key [#_"BasicKeyChain" this, #_"ECKey" key]
        (sync (:b-keychain-lock this)
            (when-not (BasicKeyChain''has-key this, key) => this
                (let [this (BasicKeyChain''import-key-locked this, key)]
                    (BasicKeyChain''queue-on-keys-added this, (ImmutableList/of key))
                    this
                )
            )
        )
    )

    #_method
    (defn #_"int" BasicKeyChain''import-keys [#_"BasicKeyChain" this, #_"List<ECKey>" keys]
        (sync (:b-keychain-lock this)
            (let [#_"List<ECKey>" added (ArrayList. (count keys))]
                (doseq [#_"ECKey" key keys]
                    (when-not (BasicKeyChain''has-key this, key)
                        (ยง ass added (.add added, key))
                        (ยง ass this (BasicKeyChain''import-key-locked this, key))
                    )
                )
                (when (seq added)
                    (BasicKeyChain''queue-on-keys-added this, added)
                )
                (count added)
            )
        )
    )

    #_method
    (defn #_"ECKey" BasicKeyChain''find-key-from-pub-hash [#_"BasicKeyChain" this, #_"byte[]" hash]
        (sync (:b-keychain-lock this)
            (get (:hash-to-keys this) (ยง ByteString/copyFrom hash))
        )
    )

    #_method
    (defn #_"ECKey" BasicKeyChain''find-key-from-pub-key [#_"BasicKeyChain" this, #_"byte[]" pubkey]
        (sync (:b-keychain-lock this)
            (get (:pubkey-to-keys this) (ยง ByteString/copyFrom pubkey))
        )
    )

    ;;;
     ; Returns true if the given key is in the chain.
     ;;
    #_method
    (defn #_"boolean" BasicKeyChain''has-key [#_"BasicKeyChain" this, #_"ECKey" key]
        (some? (BasicKeyChain''find-key-from-pub-key this, (ECKey''get-pub-key key)))
    )

    ;;;
     ; Returns the number of keys this key chain manages.
     ;;
    #_method
    (defn #_"int" BasicKeyChain''num-keys [#_"BasicKeyChain" this]
        (count (:pubkey-to-keys this))
    )

    ;;;
     ; Returns whether this chain consists of pubkey only (watching) keys, regular keys (usable for signing),
     ; or has no keys in it yet at all (thus we cannot tell).
     ;;
    #_method
    (defn #_"KeyChainState" BasicKeyChain''is-watching [#_"BasicKeyChain" this]
        (sync (:b-keychain-lock this)
            (cond (empty? (:hash-to-keys this)) :KeyChainState'EMPTY (:is-watching this) :KeyChainState'WATCHING :else :KeyChainState'REGULAR)
        )
    )

    ;;;
     ; Adds a listener for events that are run when keys are added, on the given executor.
     ;;
    #_method
    (defn #_"BasicKeyChain" BasicKeyChain''add-event-listener [#_"BasicKeyChain" this, #_"KeyChainEventListener" listener]
        (append* this :key-chain-listeners listener)
    )

    ;;;
     ; Removes a listener for events that are run when keys are added.
     ;;
    #_method
    (defn #_"BasicKeyChain" BasicKeyChain''remove-event-listener [#_"BasicKeyChain" this, #_"KeyChainEventListener" listener]
        (remove* this :key-chain-listeners = listener)
    )

    ;;;
     ; Gets a bloom filter that contains all of the public keys from this chain, and which will provide the given
     ; false-positive rate if it has size elements.  Keep in mind that you will get 2 elements in the bloom filter for
     ; each key in the key chain, for the public key and the hash of the public key (address form).  For this reason
     ; size should be <i>at least</i> 2x the result of {@link #numKeys()}.
     ;
     ; This is used to generate a {@link BloomFilter} which can be {@link BloomFilter#merge(BloomFilter)}d with
     ; another.  It could also be used if you have a specific target for the filter's size.
     ;
     ; See the docs for {@link BloomFilter#BloomFilter(int, double, long)} for a brief
     ; explanation of anonymity when using bloom filters, and for the meaning of these parameters.
     ;;
    #_method
    (defn #_"BloomFilter" BasicKeyChain''create-bloom-filter [#_"BasicKeyChain" this, #_"int" size, #_"double" rate, #_"long" tweak]
        (sync (:b-keychain-lock this)
            (let [#_"BloomFilter" filter (BloomFilter'new nil, size, rate, tweak, :BloomUpdate'UPDATE_P2PUBKEY_ONLY)]
                (reduce BloomFilter''insert-key filter (.values (:hash-to-keys this)))
            )
        )
    )
)

;;;
 ; A deterministic key chain is a {@link KeyChain} that uses the
 ; <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP 32 standard</a>, as implemented by
 ; {@link DeterministicHierarchy}, to derive all the keys in the keychain from a master seed.
 ; This type of wallet is extremely convenient and flexible.  Although backing up full wallet files is always a good
 ; idea, to recover money only the root seed needs to be preserved and that is a number small enough that it can be
 ; written down on paper or, when represented using a BIP 39 {@link MnemonicCode},
 ; dictated over the phone (possibly even memorized).
 ;
 ; Deterministic key chains have other advantages: parts of the key tree can be selectively revealed to allow
 ; for auditing, and new public keys can be generated without access to the private keys, yielding a highly secure
 ; configuration for web servers which can accept payments into a wallet but not spend from them.  This does not work
 ; quite how you would expect due to a quirk of elliptic curve mathematics and the techniques used to deal with it.
 ; A watching wallet is not instantiated using the public part of the master key as you may imagine.  Instead, you
 ; need to take the account key (first child of the master key) and provide the public part of that to the watching
 ; wallet instead.  You can do this by calling {@link #getWatchingKey()} and then serializing it with
 ; {@link DeterministicKey#serializePubB58(Ledger)}.  The resulting "xpub..." string encodes sufficient information
 ; about the account key to create a watching chain via
 ; {@link DeterministicKey#deserializeB58(DeterministicKey, String, Ledger)}
 ; (with null as the first parameter) and then
 ; {@link DeterministicKeyChain#DeterministicKeyChain(DeterministicKey)}.
 ;
 ; This class builds on {@link DeterministicHierarchy} and {@link DeterministicKey}
 ; by adding support for serialization to and from protobufs, and encryption of parts of the key tree.  Internally it
 ; arranges itself as per the BIP 32 spec, with the seed being used to derive a master key, which is then used to derive
 ; an account key, the account key is used to derive two child keys called the <i>internal</i> and <i>external</i> parent
 ; keys (for change and handing out addresses respectively) and finally the actual leaf keys that users use hanging off
 ; the end.  The leaf keys are special in that they don't internally store the private part at all, instead choosing to
 ; rederive the private key from the parent when needed for signing.  This simplifies the design for encrypted key chains.
 ;
 ; The key chain manages a <i>lookahead zone</i>.  This zone is required because when scanning the chain, you don't
 ; know exactly which keys might receive payments.  The user may have handed out several addresses and received payments
 ; on them, but for latency reasons the block chain is requested from remote peers in bulk, meaning you must
 ; "look ahead" when calculating keys to put in the Bloom filter.  The default lookahead zone is 100 keys, meaning
 ; if the user hands out more than 100 addresses and receives payment on them before the chain is next scanned, some
 ; transactions might be missed.  100 is a reasonable choice for consumer wallets running on CPU constrained devices.
 ; For industrial wallets that are receiving keys all the time, a higher value is more appropriate.  Ideally DKC and
 ; the wallet would know how to adjust this value automatically, but that's not implemented at the moment.
 ;
 ; In fact the real size of the lookahead zone is larger than requested, by default, it's one third larger.  This
 ; is because the act of deriving new keys means recalculating the Bloom filters and this is an expensive operation.
 ; Thus, to ensure we don't have to recalculate on every single new key/address requested or seen we add more buffer
 ; space and only extend the lookahead zone when that buffer is exhausted.  For example with a lookahead zone of 100
 ; keys, you can request 33 keys before more keys will be calculated and the Bloom filter rebuilt and rebroadcast.
 ; But even when you are requesting the 33rd key, you will still be looking 100 keys ahead.
 ;
 ; @author Andreas Schildbach
 ;;
(class-ns DeterministicKeyChain
    (def #_"String" DeterministicKeyChain'DEFAULT_PASSPHRASE_FOR_MNEMONIC "")

    ;; Paths through the key tree.  External keys are ones that are communicated to other parties.  Internal keys are
    ;; keys created for change addresses, coinbases, mixing, etc - anything that isn't communicated.  The distinction
    ;; is somewhat arbitrary but can be useful for audits.  The first number is the "account number" but we don't use
    ;; that feature yet.  In future we might hand out different accounts for cases where we wish to hand payers
    ;; a payment request that can generate lots of addresses independently.
    ;; The account path may be overridden by subclasses.
    (def #_"[ChildNumber]" DeterministicKeyChain'ACCOUNT_ZERO_PATH (vector ChildNumber'ZERO_HARDENED))
    (def #_"[ChildNumber]" DeterministicKeyChain'EXTERNAL_SUBPATH (vector ChildNumber'ZERO))
    (def #_"[ChildNumber]" DeterministicKeyChain'INTERNAL_SUBPATH (vector ChildNumber'ONE))
    (def #_"[ChildNumber]" DeterministicKeyChain'EXTERNAL_PATH (catvec DeterministicKeyChain'ACCOUNT_ZERO_PATH DeterministicKeyChain'EXTERNAL_SUBPATH))
    (def #_"[ChildNumber]" DeterministicKeyChain'INTERNAL_PATH (catvec DeterministicKeyChain'ACCOUNT_ZERO_PATH DeterministicKeyChain'INTERNAL_SUBPATH))
    ;; m / 44' / 0' / 0'
    (def #_"[ChildNumber]" DeterministicKeyChain'BIP44_ACCOUNT_ZERO_PATH (vector (ChildNumber'compose 44, true) ChildNumber'ZERO_HARDENED ChildNumber'ZERO_HARDENED))

    (defn- #_"DeterministicKeyChain" DeterministicKeyChain'init []
        (hash-map
            #_"Object" :d-keychain-lock (Object.)

            #_"DeterministicHierarchy" :hierarchy nil
            #_"DeterministicKey" :root-key nil
            #_"DeterministicSeed" :seed nil

            ;;;
             ; The number of public keys we should pre-generate on each path before they are requested by the app.  This is
             ; required so that when scanning through the chain given only a seed, we can give enough keys to the remote node
             ; via the Bloom filter such that we see transactions that are "from the future", for example transactions created
             ; by a different app that's sharing the same seed, or transactions we made before but we're replaying the chain
             ; given just the seed. The default is 100.
             ;;
            #_"int" :lookahead-size 100
            ;; The lookahead threshold causes us to batch up creation of new keys to minimize the frequency of Bloom filter
            ;; regenerations, which are expensive and will (in future) trigger chain download stalls/retries.  One third is
            ;; an efficiency tradeoff.
            #_"int" :lookahead-threshold (DeterministicKeyChain''calc-default-lookahead-threshold (ยง this))

            ;; The parent keys for external keys (handed out to other people) and internal keys (used for change addresses).
            #_"DeterministicKey" :external-parent-key nil
            #_"DeterministicKey" :internal-parent-key nil
            ;; How many keys on each path have actually been used.  This may be fewer than the number that have been
            ;; deserialized or held in memory, because of the lookahead zone.
            ;;;
             ; The number of keys used on external path.  This may be fewer than the number that have been deserialized
             ; or held in memory, because of the lookahead zone.
             ;;
            #_"int" :issued-external-keys 0
            ;;;
             ; The number of keys used on internal path.  This may be fewer than the number that have been deserialized
             ; or held in memory, because of the lookahead zone.
             ;;
            #_"int" :issued-internal-keys 0
            ;; A counter that is incremented each time a key in the lookahead threshold zone is marked as used and lookahead
            ;; is triggered.  The Wallet/KCG reads these counters and combines them so it can tell the Peer whether to throw
            ;; away the current block (and any future blocks in the same download batch) and restart chain sync once a new filter
            ;; has been calculated.  This field isn't persisted to the wallet as it's only relevant within a network session.
            ;;;
             ; Returns a counter that is incremented each time new keys are generated due to lookahead.
             ; Used by the network code to learn whether to discard the current block and await calculation of a new filter.
             ;;
            #_"int" :key-lookahead-epoch 0

            ;; We simplify by wrapping a basic key chain and that way we get some functionality like key lookup and event
            ;; listeners "for free".  All keys in the key tree appear here, even if they aren't meant to be used for
            ;; receiving money.
            #_"BasicKeyChain" :basic-key-chain nil

            ;; If set, this chain is following another chain in a married KeyChainGroup.
            #_"boolean" :is-following false

            ;; Holds the number of signatures required to spend.
            ;; It's the N from N-of-M CHECKMULTISIG script for P2SH transactions and always 1 for other transaction types.
            #_"int" :sigs-required-to-spend 1
        )
    )

    #_method
    (defn- #_"int" DeterministicKeyChain''calc-default-lookahead-threshold [#_"DeterministicKeyChain" this]
        (quot (:lookahead-size this) 3)
    )

    ;;;
     ; Generates a new key chain with entropy selected randomly from the given {@link java.security.SecureRandom}
     ; object and of the requested size in bits.  The derived seed is further protected with a user selected passphrase
     ; (see BIP 39).
     ;;
    (defn #_"DeterministicKeyChain" DeterministicKeyChain'from-random
        ([#_"SecureRandom" random]
            (DeterministicKeyChain'from-random random, DeterministicSeed'DEFAULT_SEED_ENTROPY_BITS))
        ([#_"SecureRandom" random, #_"int" bits]
            (DeterministicKeyChain'from-random random, bits, DeterministicKeyChain'DEFAULT_PASSPHRASE_FOR_MNEMONIC, (Time'seconds)))
        ([#_"SecureRandom" random, #_"int" bits, #_"String" passphrase, #_"long" secs]
            (DeterministicKeyChain'from-seed (DeterministicSeed'from-random random, bits, passphrase, secs))
        )
    )

    ;;;
     ; Creates a deterministic key chain starting from the given entropy.  All keys yielded by this chain will be the
     ; same if the starting seed is the same.  You should provide the creation time in seconds since the UNIX epoch
     ; for the seed: this lets us know from what part of the chain we can expect to see derived keys appear.
     ;;
    (defn #_"DeterministicKeyChain" DeterministicKeyChain'from-entropy [#_"byte[]" entropy, #_"String" passphrase, #_"long" secs]
        (DeterministicKeyChain'from-seed (DeterministicSeed'from-entropy entropy, passphrase, secs))
    )

    ;; Derives the account path keys and inserts them into the basic key chain.
    ;; This is important to preserve their order for serialization, amongst other things.
    #_method
    (defn- #_"DeterministicKeyChain" DeterministicKeyChain''initialize-hierarchy [#_"DeterministicKeyChain" this]
        (let [#_"[ChildNumber]" path DeterministicKeyChain'ACCOUNT_ZERO_PATH
              this (assoc this :external-parent-key (DeterministicHierarchy''derive-child-5 (:hierarchy this), path, false, false, ChildNumber'ZERO))
              this (assoc this :internal-parent-key (DeterministicHierarchy''derive-child-5 (:hierarchy this), path, false, false, ChildNumber'ONE))
              this (update this :basic-key-chain BasicKeyChain''import-key (:external-parent-key this))
              this (update this :basic-key-chain BasicKeyChain''import-key (:internal-parent-key this))]
            this
        )
    )

    ;;;
     ; Creates a deterministic key chain that watches the given (public only) root key.  You can use this to calculate
     ; balances and generally follow along, but spending is not possible with such a chain.  Currently you can't use
     ; this method to watch an arbitrary fragment of some other tree, this limitation may be removed in future.
     ;
     ; If <code>following?</code> flag is set, then this keychain follows some other keychain.  In a married wallet
     ; following keychain represents "spouse's" keychain.  Watch key has to be an account key.
     ;;
    (defn #_"DeterministicKeyChain" DeterministicKeyChain'watch
        ([#_"DeterministicKey" key] (DeterministicKeyChain'watch key, false))
        ([#_"DeterministicKey" key, #_"boolean" following?]
            (assert-argument (ECKey'''is-pub-key-only key), "Private subtrees are not supported yet: do .dropPrivate().dropParent() at first.")

            (let [this (DeterministicKeyChain'init)]
                (assert-argument (= (count (:child-number-path key)) (count DeterministicKeyChain'ACCOUNT_ZERO_PATH)), "You can only watch an account key currently")

                (let [this (assoc this :basic-key-chain (BasicKeyChain'new))
                      this (assoc this :seed nil)
                      this (assoc this :root-key nil)
                      this (update this :basic-key-chain BasicKeyChain''import-key key)
                      this (assoc this :hierarchy (DeterministicHierarchy'new key))
                      this (DeterministicKeyChain''initialize-hierarchy this)]
                    (assoc this :is-following following?)
                )
            )
        )
    )

    ;;;
     ; Creates a deterministic key chain with the given watch key and that follows some other keychain.
     ; In a married wallet following keychain represents "spouse".
     ; Watch key has to be an account key.
     ;;
    (defn #_"DeterministicKeyChain" DeterministicKeyChain'watch-and-follow [#_"DeterministicKey" key]
        (DeterministicKeyChain'watch key, true)
    )

    ;;;
     ; Creates a deterministic key chain starting from the given seed.  All keys yielded by this chain will be
     ; the same if the starting seed is the same.
     ;;
    (defn #_"DeterministicKeyChain" DeterministicKeyChain'from-seed [#_"DeterministicSeed" seed]
        (let [this (DeterministicKeyChain'init)
              this (assoc this :seed seed)
              this (assoc this :root-key (HDKeyDerivation'create-master-private-key (:seed-bytes seed)))
              this (update this :root-key DeterministicKey''set-creation-time-seconds (:creation-time-seconds seed))
              this (assoc this :basic-key-chain (BasicKeyChain'new))
              this (update this :basic-key-chain BasicKeyChain''import-key (:root-key this))
              this (assoc this :hierarchy (DeterministicHierarchy'new (:root-key this)))
              #_"[ChildNumber]" path DeterministicKeyChain'ACCOUNT_ZERO_PATH]
            (dotimes [#_"int" i (count path)]
                (ยง ass this (update this :basic-key-chain BasicKeyChain''import-key (DeterministicHierarchy''get-4 (:hierarchy this), (subvec path 0 (inc i)), false, true)))
            )
            (DeterministicKeyChain''initialize-hierarchy this)
        )
    )

    ;;;
     ; Returns a freshly derived key that has not been returned by this method before.
     ;;
    #_method
    (defn #_"DeterministicKey" DeterministicKeyChain''get-key [#_"DeterministicKeyChain" this, #_"KeyPurpose" purpose]
        (first (DeterministicKeyChain''get-keys this, purpose, 1))
    )

    ;;;
     ; Returns freshly derived key/s that have not been returned by this method before.
     ;;
    #_method
    (defn #_"List<DeterministicKey>" DeterministicKeyChain''get-keys [#_"DeterministicKeyChain" this, #_"KeyPurpose" purpose, #_"int" __numberOfKeys]
        (assert-argument (pos? __numberOfKeys))

        (sync (:d-keychain-lock this)
            ;; Map both REFUND and RECEIVE_KEYS to the same branch for now.  Refunds are a feature of the BIP 70
            ;; payment protocol.  Later we may wish to map it to a different branch (in a new wallet version?).
            ;; This would allow a watching wallet to only be able to see inbound payments, but not change
            ;; (i.e. spends) or refunds.  Might be useful for auditing ...
            (let [[#_"int" index #_"DeterministicKey" __parentKey]
                    (condp =? purpose
                        [:KeyPurpose'RECEIVE_FUNDS :KeyPurpose'REFUND]
                            (do
                                (ยง ass this (update this :issued-external-keys + __numberOfKeys))
                                [(:issued-external-keys this) (:external-parent-key this)]
                            )
                        [:KeyPurpose'AUTHENTICATION :KeyPurpose'CHANGE]
                            (do
                                (ยง ass this (update this :issued-internal-keys + __numberOfKeys))
                                [(:issued-internal-keys this) (:internal-parent-key this)]
                            )
                        (throw (UnsupportedOperationException.))
                    )]
                ;; Optimization: potentially do a very quick key generation for just the number of keys we need if we
                ;; didn't already create them, ignoring the configured lookahead size.  This ensures we'll be able to
                ;; retrieve the keys in the following loop, but if we're totally fresh and didn't get a chance to
                ;; calculate the lookahead keys yet, this will not block waiting to calculate 100+ EC point multiplies.
                ;; On slow/crappy Android phones looking ahead 100 keys can take ~5 seconds but the OS will kill us
                ;; if we block for just one second on the UI thread.  Because UI threads may need an address in order
                ;; to render the screen, we need getKeys to be fast even if the wallet is totally brand new and lookahead
                ;; didn't happen yet.
                ;;
                ;; It's safe to do this because when a network thread tries to calculate a Bloom filter, we'll go ahead
                ;; and calculate the full lookahead zone there, so network requests will always use the right amount.
                (let [#_"List<DeterministicKey>" lookahead (DeterministicKeyChain''maybe-look-ahead-5 this, __parentKey, index, 0, 0)]
                    (BasicKeyChain''import-keys (:basic-key-chain this), lookahead)
                    (let [#_"List<DeterministicKey>" keys (ArrayList. __numberOfKeys)]
                        (dotimes [#_"int" i __numberOfKeys]
                            (let [#_"[ChildNumber]" path (conj (:child-number-path __parentKey) (ChildNumber'compose (+ (- index __numberOfKeys) i), false))
                                  #_"DeterministicKey" key (DeterministicHierarchy''get-4 (:hierarchy this), path, false, false)]
                                ;; Just a last minute sanity check before we hand the key out to the app for usage.  This isn't
                                ;; inspired by any real problem reports from bitcoinj users, but I've heard of cases via the grapevine
                                ;; of places that lost money due to bitflips causing addresses to not match keys.  Of course in an
                                ;; environment with flaky RAM there's no real way to always win: bitflips could be introduced at any
                                ;; other layer.  But as we're potentially retrieving from long term storage here, check anyway.
                                (DeterministicKeyChain''check-for-bit-flip this, key)
                                (ยง ass keys (.add keys, key))
                            )
                        )
                        keys
                    )
                )
            )
        )
    )

    #_method
    (defn- #_"void" DeterministicKeyChain''check-for-bit-flip [#_"DeterministicKeyChain" this, #_"DeterministicKey" key]
        (let [#_"DeterministicKey" parent (ensure some? (:parent-key key))
              #_"byte[]" rederived (:key-bytes (HDKeyDerivation'derive-child-key-bytes-from-public parent, (DeterministicKey''get-child-number key), :PublicDerivationMode'WITH_INVERSION))
              #_"byte[]" actual (ECKey''get-pub-key key)]
            (when-not (Arrays/equals rederived, actual)
                (throw (IllegalStateException. (str "Bit-flip check failed: " (vec rederived) " vs " (vec actual))))
            )
        )
        nil
    )

    ;;;
     ; Mark the DeterministicKey as used.
     ; Also correct the issued{Internal|External}Keys counter, because all lower children seem to be requested already.
     ; If the counter was updated, we also might trigger lookahead.
     ;;
    #_method
    (defn #_"DeterministicKeyChain" DeterministicKeyChain''mark-key-as-used [#_"DeterministicKeyChain" this, #_"DeterministicKey" key]
        (let [#_"int" n (inc (ChildNumber''i (DeterministicKey''get-child-number key)))]
            (condp = (:parent-key key)
                (:internal-parent-key this)
                    (when (< (:issued-internal-keys this) n) => this
                        (-> this (assoc :issued-internal-keys n) (DeterministicKeyChain''maybe-look-ahead-1))
                    )
                (:external-parent-key this)
                    (when (< (:issued-external-keys this) n) => this
                        (-> this (assoc :issued-external-keys n) (DeterministicKeyChain''maybe-look-ahead-1))
                    )
                this
            )
        )
    )

    #_method
    (defn #_"DeterministicKey" DeterministicKeyChain''find-key-from-pub-hash [#_"DeterministicKeyChain" this, #_"byte[]" hash]
        (sync (:d-keychain-lock this)
            (cast' DeterministicKey (BasicKeyChain''find-key-from-pub-hash (:basic-key-chain this), hash))
        )
    )

    #_method
    (defn #_"DeterministicKey" DeterministicKeyChain''find-key-from-pub-key [#_"DeterministicKeyChain" this, #_"byte[]" pubkey]
        (sync (:d-keychain-lock this)
            (cast' DeterministicKey (BasicKeyChain''find-key-from-pub-key (:basic-key-chain this), pubkey))
        )
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkeyHash.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_method
    (defn #_"DeterministicKey" DeterministicKeyChain''mark-pub-hash-as-used [#_"DeterministicKeyChain" this, #_"byte[]" hash]
        (sync (:d-keychain-lock this)
            (let [#_"DeterministicKey" key (cast' DeterministicKey (BasicKeyChain''find-key-from-pub-hash (:basic-key-chain this), hash))]
                (when (some? key)
                    (ยง ass this (DeterministicKeyChain''mark-key-as-used this, key))
                )
                key
            )
        )
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkey.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_method
    (defn #_"DeterministicKey" DeterministicKeyChain''mark-pub-key-as-used [#_"DeterministicKeyChain" this, #_"byte[]" pubkey]
        (sync (:d-keychain-lock this)
            (let [#_"DeterministicKey" key (cast' DeterministicKey (BasicKeyChain''find-key-from-pub-key (:basic-key-chain this), pubkey))]
                (when (some? key)
                    (ยง ass this (DeterministicKeyChain''mark-key-as-used this, key))
                )
                key
            )
        )
    )

    ;;;
     ; Returns true if the given key is in the chain.
     ;;
    #_method
    (defn #_"boolean" DeterministicKeyChain''has-key [#_"DeterministicKeyChain" this, #_"ECKey" key]
        (sync (:d-keychain-lock this)
            (BasicKeyChain''has-key (:basic-key-chain this), key)
        )
    )

    ;;;
     ; Returns the deterministic key for the given absolute path in the hierarchy.
     ;;
    #_method
    (defn #_"DeterministicKey" DeterministicKeyChain''get-key-by-path-2 [#_"DeterministicKeyChain" this, #_"[ChildNumber]" path]
        (DeterministicKeyChain''get-key-by-path-3 this, path, false)
    )

    ;;;
     ; Returns the deterministic key for the given absolute path in the hierarchy, optionally creating it.
     ;;
    #_method
    (defn #_"DeterministicKey" DeterministicKeyChain''get-key-by-path-3 [#_"DeterministicKeyChain" this, #_"[ChildNumber]" path, #_"boolean" create?]
        (DeterministicHierarchy''get-4 (:hierarchy this), path, false, create?)
    )

    ;;;
     ; An alias for <code>getKeyByPath(getAccountPath())</code>.
     ;
     ; Use this when you would like to create a watching key chain that follows this one, but can't spend money from it.
     ; The returned key can be serialized and then passed into {@link #watch(DeterministicKey)}
     ; on another system to watch the hierarchy.
     ;
     ; Note that the returned key is not pubkey only unless this key chain already is: the returned key can still
     ; be used for signing etc if the private key bytes are available.
     ;;
    #_method
    (defn #_"DeterministicKey" DeterministicKeyChain''get-watching-key [#_"DeterministicKeyChain" this]
        (DeterministicKeyChain''get-key-by-path-2 this, DeterministicKeyChain'ACCOUNT_ZERO_PATH)
    )

    ;;; Returns true if this chain is watch only, meaning it has public keys but no private key. ;;
    #_method
    (defn #_"boolean" DeterministicKeyChain''is-watching [#_"DeterministicKeyChain" this]
        (ECKey''is-watching (DeterministicKeyChain''get-watching-key this))
    )

    ;;;
     ; Returns the number of keys this key chain manages.
     ;;
    #_method
    (defn #_"int" DeterministicKeyChain''num-keys [#_"DeterministicKeyChain" this]
        ;; We need to return here the total number of keys including the lookahead zone, not the number
        ;; of keys we have issued via getKey/freshReceiveKey.
        (sync (:d-keychain-lock this)
            (ยง ass this (DeterministicKeyChain''maybe-look-ahead-1 this))
            (BasicKeyChain''num-keys (:basic-key-chain this))
        )
    )

    ;;;
     ; Returns number of leaf keys used including both internal and external paths.  This may be fewer
     ; than the number that have been deserialized or held in memory, because of the lookahead zone.
     ;;
    #_method
    (defn #_"int" DeterministicKeyChain''num-leaf-keys-issued [#_"DeterministicKeyChain" this]
        (sync (:d-keychain-lock this)
            (+ (:issued-external-keys this) (:issued-internal-keys this))
        )
    )

    ;;;
     ; Returns the earliest creation time of keys in this chain, in seconds since the epoch.  This can return
     ; zero if at least one key does not have that data (was created before key timestamping was implemented).
     ; If there are no keys in the wallet, {@link Long#MAX_VALUE} is returned.
     ;;
    #_method
    (defn #_"long" DeterministicKeyChain''get-earliest-key-creation-time [#_"DeterministicKeyChain" this]
        (if (some? (:seed this)) (:creation-time-seconds (:seed this)) (ECKey'''get-creation-time-seconds (DeterministicKeyChain''get-watching-key this)))
    )

    ;;;
     ; Adds a listener for events that are run when keys are added, on the given executor.
     ;;
    #_method
    (defn #_"DeterministicKeyChain" DeterministicKeyChain''add-event-listener [#_"DeterministicKeyChain" this, #_"KeyChainEventListener" listener]
        (ยง ass this (update this :basic-key-chain BasicKeyChain''add-event-listener listener))
        this
    )

    ;;;
     ; Removes a listener for events that are run when keys are added.
     ;;
    #_method
    (defn #_"DeterministicKeyChain" DeterministicKeyChain''remove-event-listener [#_"DeterministicKeyChain" this, #_"KeyChainEventListener" listener]
        (ยง ass this (update this :basic-key-chain BasicKeyChain''remove-event-listener listener))
        this
    )

    ;;;
     ; Returns a list of words that represent the seed or null if this chain is a watching chain.
     ;;
    #_method
    (defn #_"String*" DeterministicKeyChain''get-mnemonic-code [#_"DeterministicKeyChain" this]
        (sync (:d-keychain-lock this)
            (:mnemonic-code (:seed this))
        )
    )

    ;;;
     ; Returns the number of elements this chain wishes to insert into the Bloom filter.
     ; The size passed to {@link #getFilter(int, double, long)} should be at least this large.
     ;;
    #_abstract
    (defn #_"int" DeterministicKeyChain'''count-bloom-filter-elements [#_"DeterministicKeyChain" this]
        (* (DeterministicKeyChain''num-keys this) 2)
    )

    ;;;
     ; Gets a bloom filter that contains all of the public keys from this chain, and which will provide the given
     ; false-positive rate if it has size elements.  Keep in mind that you will get 2 elements in the bloom filter for
     ; each key in the key chain, for the public key and the hash of the public key (address form).  For this reason
     ; size should be <i>at least</i> 2x the result of {@link #numKeys()}.
     ;
     ; This is used to generate a {@link BloomFilter} which can be {@link BloomFilter#merge(BloomFilter)}d with
     ; another.  It could also be used if you have a specific target for the filter's size.
     ;
     ; See the docs for {@link BloomFilter#BloomFilter(int, double, long)} for a brief
     ; explanation of anonymity when using bloom filters, and for the meaning of these parameters.
     ;;
    #_abstract
    (defn #_"BloomFilter" DeterministicKeyChain'''create-bloom-filter [#_"DeterministicKeyChain" this, #_"int" size, #_"double" rate, #_"long" tweak]
        (sync (:d-keychain-lock this)
            (assert-argument (<= (DeterministicKeyChain'''count-bloom-filter-elements this) size))
            (ยง ass this (DeterministicKeyChain''maybe-look-ahead-1 this))
            (BasicKeyChain''create-bloom-filter (:basic-key-chain this), size, rate, tweak)
        )
    )

    ;;;
     ; Sets a new lookahead size.  See {@link #getLookaheadSize()} for details on what this is.  Setting a new size
     ; that's larger than the current size will return immediately and the new size will only take effect next time
     ; a fresh filter is requested (e.g. due to a new peer being connected).  So you should set this before starting
     ; to sync the chain, if you want to modify it.  If you haven't modified the lookahead threshold manually then
     ; it will be automatically set to be a third of the new size.
     ;;
    #_abstract
    (defn #_"DeterministicKeyChain" DeterministicKeyChain'''set-lookahead-size [#_"DeterministicKeyChain" this, #_"int" size]
        (sync (:d-keychain-lock this)
            (let [#_"boolean" readjust? (= (:lookahead-threshold this) (DeterministicKeyChain''calc-default-lookahead-threshold this))
                  this (assoc this :lookahead-size size)]
                (when readjust? => this
                    (assoc this :lookahead-threshold (DeterministicKeyChain''calc-default-lookahead-threshold this))
                )
            )
        )
    )

    ;;;
     ; Sets the threshold for the key pre-generation.  This is used to avoid adding new keys and thus re-calculating
     ; Bloom filters every time a new key is calculated.  Without a lookahead threshold, every time we received
     ; a relevant transaction, we'd extend the lookahead zone and generate a new filter, which is inefficient.
     ;;
    #_method
    (defn #_"DeterministicKeyChain" DeterministicKeyChain''set-lookahead-threshold [#_"DeterministicKeyChain" this, #_"int" n]
        (sync (:d-keychain-lock this)
            (when (<= (:lookahead-size this) n)
                (throw (IllegalArgumentException. "Threshold larger or equal to the lookaheadSize"))
            )
            (assoc this :lookahead-threshold n)
        )
    )

    ;;;
     ; Gets the threshold for the key pre-generation.  See {@link #setLookaheadThreshold(int)} for details on what
     ; this is.  The default is a third of the lookahead size (100 / 3 == 33).  If you don't modify it explicitly,
     ; then this value will always be one third of the lookahead size.
     ;;
    #_method
    (defn #_"int" DeterministicKeyChain''get-lookahead-threshold [#_"DeterministicKeyChain" this]
        (sync (:d-keychain-lock this)
            (if (< (:lookahead-threshold this) (:lookahead-size this)) (:lookahead-threshold this) 0)
        )
    )

    ;;;
     ; Pre-generate enough keys to reach the lookahead size.  You can call this if you need to explicitly invoke
     ; the lookahead procedure, but it's normally unnecessary as it will be done automatically when needed.
     ;;
    #_method
    (defn #_"DeterministicKeyChain" DeterministicKeyChain''maybe-look-ahead-1 [#_"DeterministicKeyChain" this]
        (sync (:d-keychain-lock this)
            (let [#_"List<DeterministicKey>" keys (DeterministicKeyChain''maybe-look-ahead-3 this, (:external-parent-key this), (:issued-external-keys this))]
                (ยง ass keys (.addAll keys, (DeterministicKeyChain''maybe-look-ahead-3 this, (:internal-parent-key this), (:issued-internal-keys this))))
                (when (seq keys) => this
                    (let [this (update this :key-lookahead-epoch inc)]
                        ;; Batch add all keys at once so there's only one event listener invocation, as this will be listened to
                        ;; by the wallet and used to rebuild/broadcast the Bloom filter.  That's expensive so we don't want to do
                        ;; it more often than necessary.
                        (BasicKeyChain''import-keys (:basic-key-chain this), keys)
                        this
                    )
                )
            )
        )
    )

    #_method
    (defn- #_"List<DeterministicKey>" DeterministicKeyChain''maybe-look-ahead-3 [#_"DeterministicKeyChain" this, #_"DeterministicKey" parent, #_"int" issued]
        (assert-state (.isHeldByCurrentThread (:d-keychain-lock this)))

        (DeterministicKeyChain''maybe-look-ahead-5 this, parent, issued, (:lookahead-size this), (DeterministicKeyChain''get-lookahead-threshold this))
    )

    ;;;
     ; Pre-generate enough keys to reach the lookahead size, but only if there are more than the lookaheadThreshold
     ; to be generated, so that the Bloom filter does not have to be regenerated that often.
     ;
     ; The returned mutable list of keys must be inserted into the basic key chain.
     ;;
    #_method
    (defn- #_"List<DeterministicKey>" DeterministicKeyChain''maybe-look-ahead-5 [#_"DeterministicKeyChain" this, #_"DeterministicKey" parent, #_"int" issued, #_"int" __lookaheadSize, #_"int" __lookaheadThreshold]
        (assert-state (.isHeldByCurrentThread (:d-keychain-lock this)))

        (let [#_"int" m (DeterministicHierarchy''get-num-children (:hierarchy this), (:child-number-path parent))
              #_"int" needed (- (+ issued __lookaheadSize __lookaheadThreshold) m)]

            (when (< __lookaheadThreshold needed) => (ArrayList.)
                (log/info (str needed " keys needed for " (DeterministicKey''get-path-as-string parent) " = " issued " issued + " __lookaheadSize " lookahead size + " __lookaheadThreshold " lookahead threshold - " m " num children"))

                (let [#_"List<DeterministicKey>" keys (ArrayList. needed)
                      #_"Stopwatch" watch (Stopwatch/createStarted)]
                    (loop-when [#_"int" n m #_"int" i 0] (< i needed)
                        (let [#_"DeterministicKey" key (DeterministicKey''drop-private-bytes (HDKeyDerivation'derive-this-or-next-child-key parent, n))]
                            (DeterministicHierarchy''put-key (:hierarchy this), key)
                            (ยง ass keys (.add keys, key))
                            (recur (inc (ChildNumber''num (DeterministicKey''get-child-number key))) (inc i))
                        )
                    )
                    (.stop watch)
                    (log/info (str "Took " watch))
                    keys
                )
            )
        )
    )

    ;;;
     ; Housekeeping call to call when lookahead might be needed.  Normally called automatically by KeychainGroup.
     ;;
    #_abstract
    (defn #_"DeterministicKeyChain" DeterministicKeyChain'''maybe-look-ahead-scripts [#_"DeterministicKeyChain" __]
        nil
    )

    ;;;
     ; Returns the seed or null if this chain is a watching chain.
     ;;
    #_method
    (defn #_"DeterministicSeed" DeterministicKeyChain''get-seed [#_"DeterministicKeyChain" this]
        (sync (:d-keychain-lock this)
            (:seed this)
        )
    )

    ;; For internal usage only.
    #_method
    (defn #_"List<ECKey>" DeterministicKeyChain''get-keys-3b [#_"DeterministicKeyChain" this, #_"boolean" lookahead?, #_"boolean" parents?]
        (let [#_"List<ECKey>" keys (BasicKeyChain''get-keys (:basic-key-chain this))]
            (when-not lookahead? => keys
                (let [#_"int" size (count (:child-number-path (:internal-parent-key this))) #_"List<ECKey>" __issuedKeys (LinkedList.)]
                    (doseq [#_"ECKey" key keys]
                        (let [#_"DeterministicKey" detkey (cast' DeterministicKey key) #_"DeterministicKey" parent (:parent-key detkey)]
                            (let-when [i (ChildNumber''i (DeterministicKey''get-child-number detkey))]
                                (and
                                    (or parents? (some? parent))
                                    (or parents? (< size (count (:child-number-path detkey))))
                                    (or (not (.equals (:internal-parent-key this), parent)) (< i (:issued-internal-keys this)))
                                    (or (not (.equals (:external-parent-key this), parent)) (< i (:issued-external-keys this)))
                                )
                                (ยง ass __issuedKeys (.add __issuedKeys, detkey))
                            )
                        )
                    )
                    __issuedKeys
                )
            )
        )
    )

    ;;;
     ; Returns only the external keys that have been issued by this chain, lookahead not included.
     ;;
    #_method
    (defn #_"List<ECKey>" DeterministicKeyChain''get-issued-receive-keys [#_"DeterministicKeyChain" this]
        (let [#_"List<ECKey>" keys (ArrayList. (DeterministicKeyChain''get-keys-3b this, false, false))]
            (loop-when-recur [#_"Iterator<ECKey>" it (.iterator keys)] (.hasNext it) [it]
                (let [#_"DeterministicKey" parent (:parent-key (cast' DeterministicKey (.next it)))]
                    (when (or (nil? parent) (not (.equals (:external-parent-key this), parent)))
                        (.remove it)
                    )
                )
            )
            keys
        )
    )

    ;;;
     ; Returns leaf keys issued by this chain (including lookahead zone).
     ;;
    #_method
    (defn #_"List<DeterministicKey>" DeterministicKeyChain''get-leaf-keys [#_"DeterministicKeyChain" this]
        (let [#_"ImmutableList.Builder<DeterministicKey>" keys (ImmutableList/builder)]
            (doseq [#_"ECKey" key (DeterministicKeyChain''get-keys-3b this, true, false)]
                (let [#_"DeterministicKey" __dKey (cast' DeterministicKey key)]
                    (when (= (count (:child-number-path __dKey)) (+ (count DeterministicKeyChain'ACCOUNT_ZERO_PATH) 2))
                        (ยง ass keys (.add keys, __dKey))
                    )
                )
            )
            (.build keys)
        )
    )

    ;;;
     ; Whether the keychain is married.  A keychain is married when it vends P2SH addresses from
     ; multiple keychains in a multisig relationship.
     ;
     ; @see MarriedKeyChain
     ;;
    #_abstract
    (defn #_"boolean" DeterministicKeyChain'''is-married [#_"DeterministicKeyChain" __]
        false
    )

    ;;;
     ; Get redeem data for a key.  Only applicable to married keychains.
     ;;
    #_abstract
    (defn #_"RedeemData" DeterministicKeyChain'''get-redeem-data [#_"DeterministicKeyChain" __, #_"DeterministicKey" followed]
        (throw (UnsupportedOperationException.))
    )

    ;;;
     ; Create a new key and return the matching output script.  Only applicable to married keychains.
     ;;
    #_abstract
    (defn #_"Script" DeterministicKeyChain'''fresh-output-script [#_"DeterministicKeyChain" __, #_"KeyPurpose" purpose]
        (throw (UnsupportedOperationException.))
    )

    #_method
    (defn #_"String" DeterministicKeyChain''to-string [#_"DeterministicKeyChain" this, #_"Ledger" ledger]
        (let [#_"DeterministicKey" key (DeterministicKeyChain''get-watching-key this)
              #_"StringBuilder" sb (StringBuilder. (<< 1 8))]
            (if (some? (:seed this))
                (let [#_"long" secs (:creation-time-seconds (:seed this))]
                    (.. sb (append "Seed birthday: ") (append secs) (append "  [") (append (Time'format-seconds secs)) (append "]\n"))
                )
                (let [#_"long" secs (ECKey'''get-creation-time-seconds key)]
                    (.. sb (append "Key birthday:  ") (append secs) (append "  [") (append (Time'format-seconds secs)) (append "]\n"))
                )
            )
            (.. sb (append "Key to watch:  ") (append (DeterministicKey''serialize-pub-base58 key, ledger)) (append "\n"))
            (DeterministicKeyChain'''format-addresses this, ledger, sb)
            (.toString sb)
        )
    )

    #_abstract
    (defn #_"void" DeterministicKeyChain'''format-addresses [#_"DeterministicKeyChain" this, #_"Ledger" ledger, #_"StringBuilder" sb]
        (doseq [#_"ECKey" key (DeterministicKeyChain''get-keys-3b this, false, true)]
            (ECKey'''format-key-with-address key, ledger, sb)
        )
        nil
    )

    ;;;
     ; Returns the redeem script by its hash or null if this keychain did not generate the script.
     ;;
    #_abstract
    (defn #_"RedeemData" DeterministicKeyChain'''find-redeem-data-by-script-hash [#_"DeterministicKeyChain" __, #_"ByteString" bytes]
        nil
    )
)

;;;
 ; Represents the results of a {@link CoinSelector#select(Coin, java.util.List)} operation.
 ; A coin selection represents a list of spendable transaction outputs that sum together to give valueGathered.
 ; Different coin selections could be produced by different coin selectors from the same input set, according
 ; to their varying policies.
 ;;
(class-ns CoinSelection
    (defn #_"CoinSelection" CoinSelection'new [#_"Coin" value, #_"Collection<TransactionOutput>" gathered]
        (hash-map
            #_"Coin" :value-gathered value
            #_"Collection<TransactionOutput>" :gathered gathered
        )
    )
)

;;;
 ; A CoinSelector is responsible for picking some outputs to spend, from the list of all possible outputs.
 ; It allows you to customize the policies for creation of transactions to suit your needs.  The select operation
 ; may return a {@link CoinSelection} that has a valueGathered lower than the requested target, if there's not
 ; enough money in the wallet.
 ;;
(defprotocol CoinSelector
    ;;;
     ; Creates a CoinSelection that tries to meet the target amount of value.  The candidates list is given to
     ; this call and can be edited freely.  See the docs for CoinSelection to learn more, or look a the implementation
     ; of {@link DefaultCoinSelector}.
     ;;
    #_abstract
    (#_"CoinSelection" CoinSelector'''select [#_"CoinSelector" this, #_"Coin" target, #_"List<TransactionOutput>" candidates])
)

;;;
 ; This class implements a {@link CoinSelector} which attempts to get the highest priority possible.
 ; This means that the transaction is the most likely to get confirmed.  Note that this means we may end up
 ; "spending" more priority than would be required to get the transaction we are creating confirmed.
 ;;
(class-ns DefaultCoinSelector (ยง implements CoinSelector)
    (defn #_"DefaultCoinSelector" DefaultCoinSelector'new []
        (hash-map)
    )

    #_testing
    (defn #_"List<TransactionOutput>" DefaultCoinSelector'sort-outputs [#_"List<TransactionOutput>" outputs]
        (Collections/sort outputs,
            (#_"int" fn [#_"TransactionOutput" a, #_"TransactionOutput" b]
                (let [#_"int" prior1 (TransactionOutput''get-parent-transaction-depth-in-blocks a)
                      #_"int" prior2 (TransactionOutput''get-parent-transaction-depth-in-blocks b)
                      #_"Coin" coin1 (:coin-value a)
                      #_"Coin" coin2 (:coin-value b)
                      #_"BigInteger" depth1 (.multiply (BigInteger/valueOf (:value coin1)), (BigInteger/valueOf prior1))
                      #_"BigInteger" depth2 (.multiply (BigInteger/valueOf (:value coin2)), (BigInteger/valueOf prior2))
                      #_"int" c1 (compare depth2 depth1)]
                    (when (= c1 0) => c1
                        ;; The "coin * days" destroyed are equal, sort by value alone to get the lowest transaction size.
                        (let [#_"int" c2 (Coin'compare coin2, coin1)]
                            (when (= c2 0) => c2
                                ;; They are entirely equivalent (possibly pending) so sort by hash to ensure a total ordering.
                                (let [#_"BigInteger" hash1 (Sha256Hash''to-big-integer (TransactionOutput''get-parent-transaction-hash a))
                                      #_"BigInteger" hash2 (Sha256Hash''to-big-integer (TransactionOutput''get-parent-transaction-hash b))]
                                    (compare hash1 hash2)
                                )
                            )
                        )
                    )
                )
            )
        )
        outputs
    )

    (defn #_"boolean" DefaultCoinSelector'is-selectable [#_"Transaction" tx]
        ;; Only pick chain-included transactions, or transactions that are ours and pending.
        (let [#_"TransactionConfidence" confidence (Transaction''get-confidence tx)
              #_"ConfidenceType" type (:confidence-type confidence)]
            ;; TODO: The value 1 below dates from a time when transactions we broadcast *to* were counted, set to 0.
            (or (= type :ConfidenceType'BUILDING)
                (and (= type :ConfidenceType'PENDING)
                     (= (:confidence-source confidence) :ConfidenceSource'SELF)
                     (< 1 (count (:broadcast-by confidence)))))
        )
    )

    ;;;
     ; Sub-classes can override this to just customize whether transactions are usable, but keep age sorting.
     ;;
    #_method
    (defn #_"boolean" DefaultCoinSelector''should-select [#_"DefaultCoinSelector" __, #_"Transaction" tx]
        (or (nil? tx) (DefaultCoinSelector'is-selectable tx))
    )

    #_override
    (defn #_"CoinSelection" CoinSelector'''select [#_"DefaultCoinSelector" this, #_"Coin" target, #_"List<TransactionOutput>" candidates]
        ;; Sort the inputs by age * value, so we get the highest "coindays" spent.
        ;; TODO: Consider changing the wallets internal format to track just outputs and keep them ordered.
        (let [#_"List<TransactionOutput>" sorted (ArrayList. candidates)]
            ;; When calculating the wallet balance, we may be asked to select all possible coins, if so, avoid
            ;; sorting them in order to improve performance.
            ;; TODO: Take in network parameters when instantiated, and then test against the current network.
            ;; Or just have a boolean parameter for "give me everything".
            (when-not (= target Ledger'MAX_MONEY)
                (ยง ass sorted (DefaultCoinSelector'sort-outputs sorted))
            )
            ;; Now iterate over the sorted outputs until we have got as close to the target as possible or
            ;; a little bit over (excessive value will be change).
            (let [#_"List<TransactionOutput>" selected (ArrayList.)
                  #_"long" total
                    (loop-when [total 0 sorted sorted] (seq sorted) => total
                        (let [#_"TransactionOutput" output (first sorted)]
                            (when (< total (:value target)) => total
                                ;; Only pick chain-included transactions, or transactions that are ours and pending.
                                (let [total
                                        (when (DefaultCoinSelector''should-select this, (:parent-tx output)) => total
                                            (ยง ass selected (.add selected, output))
                                            (+ total (-> output :coin-value :value))
                                        )]
                                    (recur total (next sorted))
                                )
                            )
                        )
                    )]
                ;; Total may be lower than the target here if the given candidates were insufficient to create
                ;; the requested transaction.
                (CoinSelection'new (Coin'new total), selected)
            )
        )
    )
)

(def RiskAnalysisResult'enum-set
    (hash-set
        :RiskAnalysisResult'OK
        :RiskAnalysisResult'NON_FINAL
        :RiskAnalysisResult'NON_STANDARD
    )
)

;;;
 ; The reason a transaction is considered non-standard, returned by {@link #isStandard(Transaction)}.
 ;;
(def RuleViolation'enum-set
    (hash-set
        :RuleViolation'NONE
        :RuleViolation'VERSION
        :RuleViolation'DUST
        :RuleViolation'SHORTEST_POSSIBLE_PUSHDATA
        :RuleViolation'NONEMPTY_STACK ;; Not yet implemented (for post 0.12)
        :RuleViolation'SIGNATURE_CANONICAL_ENCODING
    )
)

;;;
 ; A RiskAnalysis represents an analysis of how likely it is that a transaction (and its dependencies)
 ; represents a possible double spending attack.  The wallet will create these to decide whether or not to accept
 ; a pending transaction.
 ;
 ; The intention here is that implementing classes can expose more information and detail about the result,
 ; for app developers.  The core code needs only to know whether it's OK or not.
 ;
 ; Currently, it only is concerned with whether a tx/dependency is non-final or not,
 ; and whether a tx/dependency violates the dust rules.  Outside of specialised protocols you should not encounter
 ; non-final transactions.
 ;;
(class-ns RiskAnalysis
    ;;;
     ; Any standard output smaller than this value (in satoshis) will be considered risky, as it's most likely
     ; be rejected by the network.  This is usually the same as {@link Transaction#MIN_NONDUST_OUTPUT} but can
     ; be different when the fee is about to change in Bitcoin Core.
     ;;
    (def #_"Coin" RiskAnalysis'MIN_ANALYSIS_NONDUST_OUTPUT Transaction'MIN_NONDUST_OUTPUT)

    (defn- #_"RiskAnalysis" RiskAnalysis'new [#_"Wallet" wallet, #_"Transaction" tx, #_"List<Transaction>" dependencies]
        (hash-map
            #_"Transaction" :tx tx
            #_"List<Transaction>" :dependencies dependencies
            #_"Wallet" :wallet wallet

            #_"Transaction" :non-standard nil
            #_"Transaction" :non-final nil
            #_"boolean" :analyzed false
        )
    )

    #_method
    (defn #_"RiskAnalysisResult" RiskAnalysis''analyze [#_"RiskAnalysis" this]
        (assert-state (not (:analyzed this)))
        (ยง ass this (assoc this :analyzed true))

        (let [#_"RiskAnalysisResult" result (RiskAnalysis''analyze-is-final this)]
            (if (and (some? result) (not= result :RiskAnalysisResult'OK)) result (RiskAnalysis''analyze-is-standard this))
        )
    )

    #_method
    (defn- #_"RiskAnalysisResult" RiskAnalysis''analyze-is-final [#_"RiskAnalysis" this]
        (or
            ;; Transactions we create ourselves are, by definition, not at risk of double spending against us.
            (when (= (:confidence-source (Transaction''get-confidence (:tx this))) :ConfidenceSource'SELF)
                :RiskAnalysisResult'OK
            )
            ;; We consider transactions that opt into replace-by-fee at risk of double spending.
            (when (Transaction''is-opt-in-full-rbf (:tx this))
                (ยง ass this (assoc this :non-final (:tx this)))
                :RiskAnalysisResult'NON_FINAL
            )
            (when (some? (:wallet this))
                (let [#_"int" height (:last-block-seen-height (:wallet this))
                      #_"long" time (:last-block-seen-time-secs (:wallet this))
                      ;; If the transaction has a lock time specified in blocks, we consider that if the tx would
                      ;; become final in the next block, it is not risky (as it would confirm normally).
                      #_"int" __adjustedHeight (inc height)]
                    (or
                        (when-not (Transaction''is-final (:tx this), __adjustedHeight, time)
                            (ยง ass this (assoc this :non-final (:tx this)))
                            :RiskAnalysisResult'NON_FINAL
                        )
                        (when-let [#_"Transaction" tx (first (remove #(Transaction''is-final %, __adjustedHeight, time) (:dependencies this)))]
                            (ยง ass this (assoc this :non-final tx))
                            :RiskAnalysisResult'NON_FINAL
                        )
                        :RiskAnalysisResult'OK
                    )
                )
            )
        )
    )

    ;;;
     ; Checks if a transaction is considered "standard" by Bitcoin Core's IsStandardTx and AreInputsStandard functions.
     ;
     ; Note that this method currently only implements a minimum of checks.  More to be added later.
     ;;
    (defn #_"RuleViolation" RiskAnalysis'is-standard [#_"Transaction" tx]
        (or
            (let-when [#_"long" version (:version tx)] (not (<= 1 version 1))
                (log/warn (str "TX considered non-standard due to unknown version number " version))
                :RuleViolation'VERSION
            )
            (let [#_"List<TransactionOutput>" outputs (:outputs tx)]
                (loop-when [#_"int" i 0] (< i (count outputs))
                    (let [#_"TransactionOutput" output (nth outputs i) #_"RuleViolation" violation (RiskAnalysis'is-output-standard output)]
                        (when-not (= violation :RuleViolation'NONE) => (recur (inc i))
                            (log/warn (str "TX considered non-standard due to output " i " violating rule " violation))
                            violation
                        )
                    )
                )
            )
            (let [#_"List<TransactionInput>" inputs (:inputs tx)]
                (loop-when [#_"int" i 0] (< i (count inputs))
                    (let [#_"TransactionInput" input (nth inputs i) #_"RuleViolation" violation (RiskAnalysis'is-input-standard input)]
                        (when-not (= violation :RuleViolation'NONE) => (recur (inc i))
                            (log/warn (str "TX considered non-standard due to input " i " violating rule " violation))
                            violation
                        )
                    )
                )
            )
            :RuleViolation'NONE
        )
    )

    ;;;
     ; Checks the output to see if the script violates a standardness rule.  Not complete.
     ;;
    (defn #_"RuleViolation" RiskAnalysis'is-output-standard [#_"TransactionOutput" output]
        (or
            (when (Coin''less-than? (:coin-value output), RiskAnalysis'MIN_ANALYSIS_NONDUST_OUTPUT)
                :RuleViolation'DUST
            )
            (when (some #(and (ScriptChunk''is-push-data %) (not (ScriptChunk''is-shortest-possible-push-data %))) (:chunks (TransactionOutput''parse-script-pub-key output)))
                :RuleViolation'SHORTEST_POSSIBLE_PUSHDATA
            )
            :RuleViolation'NONE
        )
    )

    ;;;
     ; Checks if the given input passes some of the AreInputsStandard checks.  Not complete.
     ;;
    (defn #_"RuleViolation" RiskAnalysis'is-input-standard [#_"TransactionInput" input]
        (loop-when [#_"ScriptChunk*" chunks (:chunks (TransactionInput''get-script-sig input))] (seq chunks) => :RuleViolation'NONE
            (let [#_"ScriptChunk" chunk (first chunks)]
                (or
                    (when (and (some? (:data chunk)) (not (ScriptChunk''is-shortest-possible-push-data chunk)))
                        :RuleViolation'SHORTEST_POSSIBLE_PUSHDATA
                    )
                    (when (ScriptChunk''is-push-data chunk)
                        (let [#_"ECDSASignature" signature
                                (try
                                    (ECDSASignature'decode-from-der (:data chunk))
                                    (catch IllegalArgumentException _
                                        ;; Doesn't look like a signature.
                                        nil
                                    )
                                )]
                            (when (some? signature)
                                (when-not (TransactionSignature'is-encoding-canonical (:data chunk))
                                    :RuleViolation'SIGNATURE_CANONICAL_ENCODING
                                )
                                (when-not (ECDSASignature''is-canonical signature)
                                    :RuleViolation'SIGNATURE_CANONICAL_ENCODING
                                )
                            )
                        )
                    )
                    (recur (next chunks))
                )
            )
        )
    )

    #_method
    (defn- #_"RiskAnalysisResult" RiskAnalysis''analyze-is-standard [#_"RiskAnalysis" this]
        ;; The IsStandard rules don't apply on testnet, because they're just a safety mechanism
        ;; and we don't want to crush innovation with valueless test coins.
        (or
            (when (and (some? (:wallet this)) (-> this :wallet :ledger :is-test))
                :RiskAnalysisResult'OK
            )
            (when-not (= (RiskAnalysis'is-standard (:tx this)) :RuleViolation'NONE)
                (ยง ass this (assoc this :non-standard (:tx this)))
                :RiskAnalysisResult'NON_STANDARD
            )
            (when-let [#_"Transaction" tx (first (remove #(= (RiskAnalysis'is-standard %) :RuleViolation'NONE) (:dependencies this)))]
                (ยง ass this (assoc this :non-standard tx))
                :RiskAnalysisResult'NON_STANDARD
            )
            :RiskAnalysisResult'OK
        )
    )

    #_method
    (defn #_"String" RiskAnalysis''to-string [#_"RiskAnalysis" this]
        (cond
            (not (:analyzed this)) (str "Pending risk analysis for " (Transaction''get-hash (:tx this)))
            (some? (:non-final this)) (str "Risky due to non-finality of " (Transaction''get-hash (:non-final this)))
            (some? (:non-standard this)) (str "Risky due to non-standard tx " (Transaction''get-hash (:non-standard this)))
            :else "Non-risky"
        )
    )
)

;;;
 ; Holds the seed bytes for the BIP32 deterministic wallet algorithm, inside a {@link DeterministicKeyChain}.
 ; The purpose of this wrapper is to simplify the encryption code.
 ;;
(class-ns DeterministicSeed
    ;; It would take more than 10^12 years to brute-force a 128 bit seed using $1B worth of computing equipment.
    (def #_"int" DeterministicSeed'DEFAULT_SEED_ENTROPY_BITS 128)
    (def #_"int" DeterministicSeed'MAX_SEED_ENTROPY_BITS 512)

    ;;;
     ; Constructs a seed from a BIP 39 mnemonic code.
     ; See {@link MnemonicCode} for more details on this scheme.
     ;
     ; @param mnemonic A list of words.
     ; @param passphrase A user supplied passphrase, or an empty string if there is no passphrase.
     ; @param creationTimeSeconds When the seed was originally created, UNIX time.
     ;;
    (defn #_"DeterministicSeed" DeterministicSeed'new [#_"String*" mnemonic, #_"String" passphrase, #_"long" secs]
        (hash-map
            #_"String*" :mnemonic-code (ensure some? mnemonic)
            #_"byte[]" :seed-bytes (MnemonicCode'to-seed mnemonic, (ensure some? passphrase))
            #_"long" :creation-time-seconds secs
        )
    )

    ;;;
     ; Constructs a seed from a BIP 39 mnemonic code.
     ; See {@link MnemonicCode} for more details on this scheme.
     ;
     ; @param entropy Entropy bits, length must be divisible by 32.
     ; @param passphrase A user supplied passphrase, or an empty string if there is no passphrase.
     ; @param creationTimeSeconds When the seed was originally created, UNIX time.
     ;;
    (defn #_"DeterministicSeed" DeterministicSeed'from-entropy [#_"byte[]" entropy, #_"String" passphrase, #_"long" secs]
        (assert-argument (zero? (rem (count entropy) 4)), "entropy size in bits not divisible by 32")
        (assert-argument (<= DeterministicSeed'DEFAULT_SEED_ENTROPY_BITS (* (count entropy) 8)), "entropy size too small")

        (DeterministicSeed'new (MnemonicCode''to-mnemonic MnemonicCode'INSTANCE, entropy), passphrase, secs)
    )

    (defn- #_"byte[]" DeterministicSeed'next-entropy [#_"SecureRandom" random, #_"int" bits]
        (assert-argument (<= bits DeterministicSeed'MAX_SEED_ENTROPY_BITS), "requested entropy size too large")

        (let [#_"byte[]" seed (byte-array (quot bits 8))]
            (.nextBytes random, seed)
            seed
        )
    )

    ;;;
     ; Constructs a seed from a BIP 39 mnemonic code.
     ; See {@link MnemonicCode} for more details on this scheme.
     ;
     ; @param random Entropy source.
     ; @param bits Number of bits, must be divisible by 32.
     ; @param passphrase A user supplied passphrase, or an empty string if there is no passphrase.
     ; @param creationTimeSeconds When the seed was originally created, UNIX time.
     ;;
    (defn #_"DeterministicSeed" DeterministicSeed'from-random [#_"SecureRandom" random, #_"int" bits, #_"String" passphrase, #_"long" secs]
        (DeterministicSeed'from-entropy (DeterministicSeed'next-entropy random, bits), (ensure some? passphrase), secs)
    )

    #_method
    (defn #_"String" DeterministicSeed''to-base16 [#_"DeterministicSeed" this]
        (Base16'encode (:seed-bytes this))
    )

    #_method
    (defn #_"String" DeterministicSeed''to-string [#_"DeterministicSeed" this]
        (apply str "DeterministicSeed " (DeterministicSeed''to-base16 this) " " (interpose " " (:mnemonic-code this)))
    )
)

;;;
 ; A filtering coin selector delegates to another coin selector, but won't select outputs spent by the given transactions.
 ;;
(class-ns FilteringCoinSelector (ยง implements CoinSelector)
    (defn #_"FilteringCoinSelector" FilteringCoinSelector'new [#_"CoinSelector" delegate]
        (hash-map
            #_"CoinSelector" :delegate delegate
            #_"HashSet<TransactionOutPoint>" :spent (HashSet.)
        )
    )

    #_method
    (defn #_"void" FilteringCoinSelector''exclude-outputs-spent-by [#_"FilteringCoinSelector" this, #_"Transaction" tx]
        (doseq [#_"TransactionInput" input (:inputs tx)]
            (ยง ass this (update this :spent .add (:outpoint input)))
        )
        nil
    )

    #_override
    (defn #_"CoinSelection" CoinSelector'''select [#_"FilteringCoinSelector" this, #_"Coin" target, #_"List<TransactionOutput>" candidates]
        (loop-when-recur [#_"Iterator<TransactionOutput>" it (.iterator candidates)] (.hasNext it) [it]
            (let [#_"TransactionOutput" output (.next it)]
                (when (contains? (:spent this) (TransactionOutput''get-outpoint-for output))
                    (.remove it)
                )
            )
        )
        (CoinSelector'''select (:delegate this), target, candidates)
    )
)

;;;
 ; A KeyBag is simply an object that can map public keys, their 160-bit hashes and script hashes to ECKey
 ; and {@link RedeemData} objects.
 ;;
(defprotocol KeyBag
    ;;;
     ; Locates a keypair from the keychain given the hash of the public key.  This is needed when finding out
     ; which key we need to use to redeem a transaction output.
     ;
     ; @return ECKey object or null if no such key was found.
     ;;
    #_abstract
    (#_"ECKey" KeyBag'''find-key-from-pub-hash [#_"KeyBag" this, #_"byte[]" hash])

    ;;;
     ; Locates a keypair from the keychain given the raw public key bytes.
     ;
     ; @return ECKey or null if no such key was found.
     ;;
    #_abstract
    (#_"ECKey" KeyBag'''find-key-from-pub-key [#_"KeyBag" this, #_"byte[]" pubkey])

    ;;;
     ; Locates a redeem data (redeem script and keys) from the keychain given the hash of the script.
     ; This is needed when finding out which key and script we need to use to locally sign a P2SH transaction input.
     ; It is assumed that wallet should not have more than one private key for a single P2SH tx for security reasons.
     ;
     ; @return RedeemData object or null if no such data was found.
     ;;
    #_abstract
    (#_"RedeemData" KeyBag'''find-redeem-data-from-script-hash [#_"KeyBag" this, #_"byte[]" hash])
)

(def KeyPurpose'enum-set
    (hash-set
        :KeyPurpose'RECEIVE_FUNDS
        :KeyPurpose'CHANGE
        :KeyPurpose'REFUND
        :KeyPurpose'AUTHENTICATION
    )
)

;;;
 ; A KeyChainGroup is used by the {@link Wallet} and manages: a {@link BasicKeyChain} object
 ; (which will normally be empty), and zero or more {@link DeterministicKeyChain}s.  A deterministic key chain will be
 ; created lazily/on demand when a fresh or current key is requested, possibly being initialized from the private key
 ; bytes of the earliest non rotating key in the basic key chain if one is available, or from a fresh random seed if not.
 ;
 ; If a key rotation time is set, it may be necessary to add a new DeterministicKeyChain with a fresh seed and
 ; also preserve the old one, so funds can be swept from the rotating keys.  In this case, there may be more than
 ; one deterministic chain.  The latest chain is called the active chain and is where new keys are served from.
 ;
 ; The wallet delegates most key management tasks to this class.  It is <b>not</b> thread safe and requires external
 ; locking, i.e. by the wallet lock.  The group then in turn delegates most operations to the key chain objects,
 ; combining their responses together when necessary.
 ;
 ; Deterministic key chains have a concept of a lookahead size and threshold.  Please see the discussion in the
 ; class docs for {@link DeterministicKeyChain} for more information on this topic.
 ;;
(class-ns KeyChainGroup (ยง implements KeyBag)
    (defn #_"KeyChainGroup" KeyChainGroup'new
        ([#_"Ledger" ledger] (KeyChainGroup'new ledger, (ArrayList. #_"<DeterministicKeyChain>" 1)))
        ([#_"Ledger" ledger, #_"List<DeterministicKeyChain>" chains]
            (let [this
                    (hash-map
                        #_"Ledger" :ledger ledger
                        #_"LinkedList<DeterministicKeyChain>" :chains (LinkedList. (ensure some? chains))
                        ;; :current-keys is used for normal, non-multisig/married wallets.
                        #_"{KeyPurpose DeterministicKey}" :current-keys (hash-map)
                        ;; :current-addresses is used when we're handing out P2SH addresses.
                        #_"{KeyPurpose Address}" :current-addresses (hash-map)
                        ;; They're mutually exclusive.

                        #_"int" :lookahead-size -1
                        #_"int" :lookahead-threshold -1
                    )]

                (KeyChainGroup''maybe-lookahead-scripts this)

                (when (KeyChainGroup''is-married this)
                    (doseq [#_"Map.Entry<KeyPurpose, DeterministicKey>" entry (.entrySet (:current-keys this))]
                        (let [#_"Address" address (Script''get-to-address-2 (KeyChainGroup''make-p2sh-output-script this, (.getValue entry), (KeyChainGroup''get-active-key-chain this)), ledger)]
                            (ยง ass this (update this :current-addresses assoc (.getKey entry) address))
                        )
                    )
                )
                this
            )
        )
    )

    ;;;
     ; Creates a keychain group with no basic chain, and an HD chain initialized from the given seed.
     ;;
    (defn #_"KeyChainGroup" KeyChainGroup'from-seed [#_"Ledger" ledger, #_"DeterministicSeed" seed]
        (KeyChainGroup'new ledger, (ImmutableList/of (DeterministicKeyChain'from-seed seed)))
    )

    ;;;
     ; Creates a keychain group with no basic chain, and an HD chain that is watching the given watching key.
     ; This HAS to be an account key as returned by {@link DeterministicKeyChain#getWatchingKey()}.
     ;;
    (defn #_"KeyChainGroup" KeyChainGroup'watch [#_"Ledger" ledger, #_"DeterministicKey" key]
        (KeyChainGroup'new ledger, (ImmutableList/of (DeterministicKeyChain'watch key)))
    )

    ;; This keeps married redeem data in sync with the number of keys issued.
    #_method
    (defn- #_"void" KeyChainGroup''maybe-lookahead-scripts [#_"KeyChainGroup" this]
        (doseq [#_"DeterministicKeyChain" chain (:chains this)]
            (ยง ass chain (DeterministicKeyChain'''maybe-look-ahead-scripts chain))
        )
        nil
    )

    ;;;
     ; Adds a new HD chain to the chains list, and make it the default chain (from which keys are issued).
     ;;
    #_method
    (defn #_"KeyChainGroup" KeyChainGroup''create-and-activate-new-hd-chain [#_"KeyChainGroup" this]
        ;; We can't do auto upgrade here because we don't know the rotation time, if any.
        (let [#_"DeterministicKeyChain" chain (DeterministicKeyChain'from-random (SecureRandom.))]
            (KeyChainGroup''add-and-activate-hd-chain this, chain)
        )
    )

    ;;;
     ; Adds an HD chain to the chains list, and make it the default chain (from which keys are issued).
     ; Useful for adding a complex pre-configured keychain, such as a married wallet.
     ;;
    #_method
    (defn #_"KeyChainGroup" KeyChainGroup''add-and-activate-hd-chain [#_"KeyChainGroup" this, #_"DeterministicKeyChain" chain]
        (log/info (str "Creating and activating a new HD chain: " chain))
        (when (<= 0 (:lookahead-size this))
            (ยง ass chain (DeterministicKeyChain'''set-lookahead-size chain, (:lookahead-size this)))
        )
        (when (<= 0 (:lookahead-threshold this))
            (ยง ass chain (DeterministicKeyChain''set-lookahead-threshold chain, (:lookahead-threshold this)))
        )
        (append* this :chains chain)
    )

    ;;;
     ; Returns a key that hasn't been seen in a transaction yet, and which is suitable for displaying in a wallet
     ; user interface as "a convenient key to receive funds on" when the purpose parameter is
     ; {@link KeyPurpose#RECEIVE_FUNDS}.  The returned key is stable until it's actually seen in a pending
     ; or confirmed transaction, at which point this method will start returning a different key (for each purpose
     ; independently).
     ;
     ; This method is not supposed to be used for married keychains and will throw UnsupportedOperationException
     ; if the active chain is married.
     ; For married keychains use {@link #currentAddress(KeyPurpose)} to get a proper P2SH address.
     ;;
    #_method
    (defn #_"DeterministicKey" KeyChainGroup''current-key [#_"KeyChainGroup" this, #_"KeyPurpose" purpose]
        (let [#_"DeterministicKeyChain" chain (KeyChainGroup''get-active-key-chain this)]
            (if (DeterministicKeyChain'''is-married chain)
                (throw (UnsupportedOperationException. "Key is not suitable to receive coins for married keychains.  Use freshAddress to get P2SH address instead."))
                (let-when [#_"DeterministicKey" key (get (:current-keys this) purpose)] (nil? key) => key
                    (let [key (KeyChainGroup''fresh-key this, purpose)]
                        (ยง ass this (update this :current-keys assoc purpose key))
                        key
                    )
                )
            )
        )
    )

    ;;;
     ; Returns address for a {@link #currentKey(KeyPurpose)}.
     ;;
    #_method
    (defn #_"Address" KeyChainGroup''current-address [#_"KeyChainGroup" this, #_"KeyPurpose" purpose]
        (let [#_"DeterministicKeyChain" chain (KeyChainGroup''get-active-key-chain this)]
            (if (DeterministicKeyChain'''is-married chain)
                (let-when [#_"Address" addr (get (:current-addresses this) purpose)] (nil? addr) => addr
                    (let [addr (KeyChainGroup''fresh-address this, purpose)]
                        (ยง ass this (update this :current-addresses assoc purpose addr))
                        addr
                    )
                )
                (ECKey''to-address (KeyChainGroup''current-key this, purpose), (:ledger this))
            )
        )
    )

    ;;;
     ; Returns a key that has not been returned by this method before (fresh).  You can think of this as being a newly
     ; created key, although the notion of "create" is not really valid for a {@link DeterministicKeyChain}.  When the
     ; parameter is {@link KeyPurpose#RECEIVE_FUNDS}, the returned key is suitable for being put into a receive
     ; coins wizard type UI.  You should use this when the user is definitely going to hand this key out to someone who
     ; wishes to send money.
     ;
     ; This method is not supposed to be used for married keychains and will throw UnsupportedOperationException if
     ; the active chain is married.
     ; For married keychains use {@link #freshAddress(KeyPurpose)} to get a proper P2SH address.
     ;;
    #_method
    (defn #_"DeterministicKey" KeyChainGroup''fresh-key [#_"KeyChainGroup" this, #_"KeyPurpose" purpose]
        (nth (KeyChainGroup''fresh-keys this, purpose, 1) 0)
    )

    ;;;
     ; Returns a key/s that have not been returned by this method before (fresh).  You can think of this as being newly
     ; created key/s, although the notion of "create" is not really valid for a {@link DeterministicKeyChain}.  When the
     ; parameter is {@link KeyPurpose#RECEIVE_FUNDS}, the returned key is suitable for being put into a receive
     ; coins wizard type UI.  You should use this when the user is definitely going to hand this key out to someone who
     ; wishes to send money.
     ;
     ; This method is not supposed to be used for married keychains and will throw UnsupportedOperationException if
     ; the active chain is married.
     ; For married keychains use {@link #freshAddress(KeyPurpose)} to get a proper P2SH address.
     ;;
    #_method
    (defn #_"List<DeterministicKey>" KeyChainGroup''fresh-keys [#_"KeyChainGroup" this, #_"KeyPurpose" purpose, #_"int" n]
        (let [#_"DeterministicKeyChain" chain (KeyChainGroup''get-active-key-chain this)]
            (when (DeterministicKeyChain'''is-married chain)
                (throw (UnsupportedOperationException. "Key is not suitable to receive coins for married keychains.  Use freshAddress to get P2SH address instead."))
            )

            (DeterministicKeyChain''get-keys chain, purpose, n) ;; Always returns the next key along the key chain.
        )
    )

    ;;;
     ; Returns address for a {@link #freshKey(KeyPurpose)}.
     ;;
    #_method
    (defn #_"Address" KeyChainGroup''fresh-address [#_"KeyChainGroup" this, #_"KeyPurpose" purpose]
        (let [#_"DeterministicKeyChain" chain (KeyChainGroup''get-active-key-chain this)]
            (if (DeterministicKeyChain'''is-married chain)
                (let [#_"Script" output (DeterministicKeyChain'''fresh-output-script chain, purpose)]
                    (assert-state (Script''is-pay-to-script-hash output)) ;; Only handle P2SH for now.

                    (let [#_"Address" fresh (Address'from-p2sh-script (:ledger this), output)]
                        (KeyChainGroup''maybe-lookahead-scripts this)
                        (ยง ass this (update this :current-addresses assoc purpose fresh))
                        fresh
                    )
                )
                (ECKey''to-address (KeyChainGroup''fresh-key this, purpose), (:ledger this))
            )
        )
    )

    ;;;
     ; Returns the key chain that's used for generation of fresh/current keys.  This is always the newest HD chain.
     ;;
    #_method
    (defn #_"DeterministicKeyChain" KeyChainGroup''get-active-key-chain [#_"KeyChainGroup" this]
        (when (empty? (:chains this))
            ;; We have no HD chains: we are a new born!  So a random seed is fine.
            (ยง ass this (KeyChainGroup''create-and-activate-new-hd-chain this))
        )
        (nth (:chains this) (dec (count (:chains this))))
    )

    ;;;
     ; Sets the lookahead buffer size for ALL deterministic key chains as well as for following key chains if any exist.
     ; See {@link DeterministicKeyChain#setLookaheadSize(int)} for more information.
     ;;
    #_method
    (defn #_"KeyChainGroup" KeyChainGroup''set-lookahead-size [#_"KeyChainGroup" this, #_"int" size]
        (let [this (assoc this :lookahead-size size)]
            (doseq [#_"DeterministicKeyChain" chain (:chains this)]
                (ยง ass chain (DeterministicKeyChain'''set-lookahead-size chain, size))
            )
            this
        )
    )

    ;;;
     ; Gets the current lookahead size being used for ALL deterministic key chains.
     ; See {@link DeterministicKeyChain#setLookaheadSize(int)} for more information.
     ;;
    #_method
    (defn #_"int" KeyChainGroup''get-lookahead-size [#_"KeyChainGroup" this]
        (if (= (:lookahead-size this) -1) (:lookahead-size (KeyChainGroup''get-active-key-chain this)) (:lookahead-size this))
    )

    ;;;
     ; Sets the lookahead buffer threshold for ALL deterministic key chains.
     ; See {@link DeterministicKeyChain#setLookaheadThreshold(int)} for more information.
     ;;
    #_method
    (defn #_"KeyChainGroup" KeyChainGroup''set-lookahead-threshold [#_"KeyChainGroup" this, #_"int" num]
        (doseq [#_"DeterministicKeyChain" chain (:chains this)]
            (ยง ass chain (DeterministicKeyChain''set-lookahead-threshold chain, num))
        )
        this
    )

    ;;;
     ; Gets the current lookahead threshold being used for ALL deterministic key chains.
     ; See {@link DeterministicKeyChain#setLookaheadThreshold(int)} for more information.
     ;;
    #_method
    (defn #_"int" KeyChainGroup''get-lookahead-threshold [#_"KeyChainGroup" this]
        (if (= (:lookahead-threshold this) -1) (DeterministicKeyChain''get-lookahead-threshold (KeyChainGroup''get-active-key-chain this)) (:lookahead-threshold this))
    )

    #_override
    (defn #_"RedeemData" KeyBag'''find-redeem-data-from-script-hash [#_"KeyChainGroup" this, #_"byte[]" hash]
        ;; Iterate in reverse order, since the active keychain is the one most likely to have the hit.
        (loop-when [#_"Iterator<DeterministicKeyChain>" it (.descendingIterator (:chains this))] (.hasNext it)
            (let [#_"RedeemData" redeem (DeterministicKeyChain'''find-redeem-data-by-script-hash (.next it), (ยง ByteString/copyFrom hash))]
                (or redeem (recur it))
            )
        )
    )

    #_method
    (defn #_"KeyChainGroup" KeyChainGroup''mark-p2sh-address-as-used [#_"KeyChainGroup" this, #_"Address" address]
        (assert-argument (Address''is-p2sh-address address))

        (let [#_"RedeemData" data (KeyBag'''find-redeem-data-from-script-hash this, (:addr-bytes address))]
            (when (some? data) ;; Else not our P2SH address.
                (doseq [#_"ECKey" key (:redeem-keys data) #_"DeterministicKeyChain" chain (:chains this)]
                    (let [#_"DeterministicKey" k (DeterministicKeyChain''find-key-from-pub-key chain, (ECKey''get-pub-key key))]
                        (when (some? k)
                            (ยง ass chain (DeterministicKeyChain''mark-key-as-used chain, k))
                            (KeyChainGroup''maybe-mark-current-address-as-used this, address)
                        )
                    )
                )
            )
        )
        this
    )

    #_override
    (defn #_"ECKey" KeyBag'''find-key-from-pub-hash [#_"KeyChainGroup" this, #_"byte[]" hash]
        (some #(DeterministicKeyChain''find-key-from-pub-hash %, hash) (:chains this))
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkeyHash.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_method
    (defn #_"void" KeyChainGroup''mark-pub-key-hash-as-used [#_"KeyChainGroup" this, #_"byte[]" hash]
        (let [#_"DeterministicKey" key (some #(DeterministicKeyChain''mark-pub-hash-as-used %, hash) (:chains this))]
            (when (some? key)
                (KeyChainGroup''maybe-mark-current-key-as-used this, key)
            )
        )
        nil
    )

    ;;; If the given P2SH address is "current", advance it to a new one. ;;
    #_method
    (defn- #_"void" KeyChainGroup''maybe-mark-current-address-as-used [#_"KeyChainGroup" this, #_"Address" address]
        (assert-argument (Address''is-p2sh-address address))

        (when-let [#_"Map.Entry<KeyPurpose, Address>" entry (first (filter #(and (some? (.getValue %)) (.equals (.getValue %), address)) (.entrySet (:current-addresses this))))]
            (log/info (str "Marking P2SH address as used: " address))
            (ยง ass this (update this :current-addresses assoc (.getKey entry) (KeyChainGroup''fresh-address this, (.getKey entry))))
        )
        nil
    )

    ;;; If the given key is "current", advance the current key to a new one. ;;
    #_method
    (defn- #_"void" KeyChainGroup''maybe-mark-current-key-as-used [#_"KeyChainGroup" this, #_"DeterministicKey" key]
        ;; It's OK for :current-keys to be empty here: it means we're a married wallet and the key may be a part of a rotating chain.
        (when-let [#_"Map.Entry<KeyPurpose, DeterministicKey>" entry (first (filter #(and (some? (.getValue %)) (.equals (.getValue %), key)) (.entrySet (:current-keys this))))]
            (log/info (str "Marking key as used: " key))
            (ยง ass this (update this :current-keys assoc (.getKey entry) (KeyChainGroup''fresh-key this, (.getKey entry))))
        )
        nil
    )

    #_method
    (defn #_"boolean" KeyChainGroup''has-key [#_"KeyChainGroup" this, #_"ECKey" key]
        (some #(DeterministicKeyChain''has-key %, key) (:chains this))
    )

    #_override
    (defn #_"ECKey" KeyBag'''find-key-from-pub-key [#_"KeyChainGroup" this, #_"byte[]" pubkey]
        (some #(DeterministicKeyChain''find-key-from-pub-key %, pubkey) (:chains this))
    )

    ;;;
     ; Mark the DeterministicKeys as used, if they match the pubkey.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_method
    (defn #_"void" KeyChainGroup''mark-pub-key-as-used [#_"KeyChainGroup" this, #_"byte[]" pubkey]
        (let [#_"DeterministicKey" key (some #(DeterministicKeyChain''mark-pub-key-as-used %, pubkey) (:chains this))]
            (when (some? key)
                (KeyChainGroup''maybe-mark-current-key-as-used this, key)
            )
        )
        nil
    )

    ;;;
     ; Returns the number of keys managed by this group, including the lookahead buffers.
     ;;
    #_method
    (defn #_"int" KeyChainGroup''num-keys [#_"KeyChainGroup" this]
        (reduce + (map DeterministicKeyChain''num-keys (:chains this)))
    )

    ;;;
     ; Whether the active keychain is married.  A keychain is married when it vends P2SH addresses
     ; from multiple keychains in a multisig relationship.
     ;
     ; @see MarriedKeyChain
     ;;
    #_method
    (defn #_"boolean" KeyChainGroup''is-married [#_"KeyChainGroup" this]
        (and (seq (:chains this)) (DeterministicKeyChain'''is-married (KeyChainGroup''get-active-key-chain this)))
    )

    ;;;
     ; Returns whether this chain has only watching keys (unencrypted keys with no private part).
     ; Mixed chains are forbidden.
     ;
     ; @throws IllegalStateException if there are no keys, or if there is a mix between watching and non-watching keys.
     ;;
    #_method
    (defn #_"boolean" KeyChainGroup''is-watching [#_"KeyChainGroup" this]
        (let [#_"KeyChainState" active
                (cond
                    (empty? (:chains this))                                                         :KeyChainState'EMPTY
                    (DeterministicKeyChain''is-watching (KeyChainGroup''get-active-key-chain this)) :KeyChainState'WATCHING
                    :else                                                                           :KeyChainState'REGULAR
                )]
            (when (= active :KeyChainState'EMPTY) => (= active :KeyChainState'WATCHING)
                (throw (IllegalStateException. "Empty key chain group: cannot answer isWatching() query"))
            )
        )
    )

    #_method
    (defn #_"long" KeyChainGroup''get-earliest-key-creation-time [#_"KeyChainGroup" this]
        (reduce min Long/MAX_VALUE (map DeterministicKeyChain''get-earliest-key-creation-time (:chains this)))
    )

    #_method
    (defn #_"int" KeyChainGroup''count-bloom-filter-elements [#_"KeyChainGroup" this]
        (reduce + (map DeterministicKeyChain'''count-bloom-filter-elements (:chains this)))
    )

    #_method
    (defn #_"BloomFilter" KeyChainGroup''create-bloom-filter [#_"KeyChainGroup" this, #_"int" size, #_"double" rate, #_"long" tweak]
        (let [#_"BloomFilter" filter (BloomFilter'new (:ledger this), size, rate, tweak, :BloomUpdate'UPDATE_P2PUBKEY_ONLY)]
            (reduce BloomFilter''merge filter (map #(DeterministicKeyChain'''create-bloom-filter %, size, rate, tweak) (:chains this)))
        )
    )

    #_method
    (defn- #_"Script" KeyChainGroup''make-p2sh-output-script [#_"KeyChainGroup" this, #_"DeterministicKey" followed, #_"DeterministicKeyChain" chain]
        (Script'create-p2sh-output-script-1 (:redeem-script (DeterministicKeyChain'''get-redeem-data chain, followed)))
    )

    ;;;
     ; Adds a listener for events that are run when keys are added, on the given executor.
     ;;
    #_method
    (defn #_"KeyChainGroup" KeyChainGroup''add-event-listener [#_"KeyChainGroup" this, #_"KeyChainEventListener" listener]
        (doseq [#_"DeterministicKeyChain" chain (:chains this)]
            (ยง ass chain (DeterministicKeyChain''add-event-listener chain, listener))
        )
        this
    )

    ;;;
     ; Removes a listener for events that are run when keys are added.
     ;;
    #_method
    (defn #_"KeyChainGroup" KeyChainGroup''remove-event-listener [#_"KeyChainGroup" this, #_"KeyChainEventListener" listener]
        (doseq [#_"DeterministicKeyChain" chain (:chains this)]
            (ยง ass chain (DeterministicKeyChain''remove-event-listener chain, listener))
        )
        this
    )

    (defn- #_"{KeyPurpose DeterministicKey}" KeyChainGroup'create-current-keys-map [#_"List<DeterministicKeyChain>" chains]
        (let [#_"DeterministicKeyChain" active (nth chains (dec (count chains)))
              #_"{KeyPurpose DeterministicKey}" keys (hash-map)
              ;; Assuming that only RECEIVE and CHANGE keys are being used at the moment, we will treat the latest issued
              ;; external key as current RECEIVE key and latest issued internal key as CHANGE key.  This should be changed
              ;; as soon as other kinds of KeyPurpose are introduced.
              keys
                (let-when [#_"int" n (:issued-external-keys active)] (pos? n) => keys
                    (let [#_"DeterministicKey" key (DeterministicKeyChain''get-key-by-path-2 active, (conj (catvec DeterministicKeyChain'ACCOUNT_ZERO_PATH DeterministicKeyChain'EXTERNAL_SUBPATH) (ChildNumber'new (dec n))))]
                        (assoc keys :KeyPurpose'RECEIVE_FUNDS key)
                    )
                )
              keys
                (let-when [#_"int" n (:issued-internal-keys active)] (pos? n) => keys
                    (let [#_"DeterministicKey" key (DeterministicKeyChain''get-key-by-path-2 active, (conj (catvec DeterministicKeyChain'ACCOUNT_ZERO_PATH DeterministicKeyChain'INTERNAL_SUBPATH) (ChildNumber'new (dec n))))]
                        (assoc keys :KeyPurpose'CHANGE key)
                    )
                )]
            keys
        )
    )

    (defn- #_"void" KeyChainGroup'extract-following-keychains [#_"List<DeterministicKeyChain>" chains]
        ;; Look for following key chains and map them to the watch keys of followed keychains.
        (let [#_"List<DeterministicKeyChain>" __followingChains (ArrayList.)]
            (loop-when-recur [#_"Iterator<DeterministicKeyChain>" it (.iterator chains)] (.hasNext it) [it]
                (let [#_"DeterministicKeyChain" chain (.next it)]
                    (cond (:is-following chain)
                        (do
                            (ยง ass __followingChains (.add __followingChains, chain))
                            (.remove it)
                        )
                        (seq __followingChains)
                        (do
                            (when-not (ยง instance? MarriedKeyChain chain)
                                (throw (IllegalStateException.))
                            )

                            (ยง ass (cast' MarriedKeyChain chain) (MarriedKeyChain''set-following-key-chains (cast' MarriedKeyChain chain), __followingChains))
                            (ยง ass __followingChains (empty __followingChains))
                        )
                    )
                )
            )
        )
        nil
    )

    ;;;
     ; Returns a counter that increases (by an arbitrary amount) each time new keys have been calculated
     ; due to lookahead and thus the Bloom filter that was previously calculated has become stale.
     ;;
    #_method
    (defn #_"int" KeyChainGroup''get-combined-key-lookahead-epochs [#_"KeyChainGroup" this]
        (reduce + (map :key-lookahead-epoch (:chains this)))
    )

    #_method
    (defn #_"String" KeyChainGroup''to-string [#_"KeyChainGroup" this]
        (let [#_"StringBuilder" sb (StringBuilder. (<< 1 8))]
            (doseq [#_"DeterministicKeyChain" chain (:chains this)]
                (.. sb (append (DeterministicKeyChain''to-string chain, (:ledger this))) (append "\n"))
            )
            (.toString sb)
        )
    )
)

;;;
 ; A coin selector that takes all coins assigned to keys created before the given timestamp.
 ; Used as part of the implementation of {@link Wallet#setKeyRotationTime(java.util.Date)}.
 ;;
(class-ns KeyTimeCoinSelector (ยง implements CoinSelector)
    ;;;
     ; A number of inputs chosen to avoid hitting {@link Transaction#MAX_STANDARD_TX_SIZE}.
     ;;
    (def #_"int" KeyTimeCoinSelector'MAX_SIMULTANEOUS_INPUTS 600)

    (defn #_"KeyTimeCoinSelector" KeyTimeCoinSelector'new [#_"Wallet" wallet, #_"long" secs, #_"boolean" __ignorePending]
        (hash-map
            #_"long" :unix-time-seconds secs
            #_"Wallet" :wallet wallet
            #_"boolean" :ignore-pending __ignorePending
        )
    )

    #_override
    (defn #_"CoinSelection" CoinSelector'''select [#_"KeyTimeCoinSelector" this, #_"Coin" target, #_"List<TransactionOutput>" candidates]
        (let [#_"LinkedList<TransactionOutput>" gathered (LinkedList.)
              #_"Coin" value
                (loop-when [value Coin'ZERO candidates candidates] (seq candidates) => value
                    (let [#_"TransactionOutput" output (first candidates)]
                        (when (or (not (:ignore-pending this)) (KeyTimeCoinSelector''is-confirmed this, output)) => (recur value (next candidates))
                            ;; Find the key that controls output, assuming it's a regular pay-to-pubkey or pay-to-address output.
                            ;; We ignore any other kind of exotic output on the assumption we can't spend it ourselves.
                            (let [#_"Script" script (TransactionOutput''parse-script-pub-key output)
                                  [#_"boolean" skip? #_"ECKey" key]
                                    (cond
                                        (Script''is-sent-to-raw-pub-key script)
                                            [false (KeyBag'''find-key-from-pub-key (:wallet this), (Script''get-pub-key script))]
                                        (Script''is-sent-to-address script)
                                            [false (KeyBag'''find-key-from-pub-hash (:wallet this), (Script''get-pub-key-hash script))]
                                        :else
                                            [true (log/info (str "Skipping tx output " output " because it's not of simple form."))]
                                    )]
                                (when-not skip? => (recur value (next candidates))
                                    (ensure some? key, "Coin selector given output as candidate for which we lack the key")

                                    (when (< (ECKey'''get-creation-time-seconds key) (:unix-time-seconds this)) => (recur value (next candidates))
                                        ;; It's older than the cutoff time, so select it.
                                        (let [value (Coin''add value, (:coin-value output))]
                                            (.push gathered, output)
                                            (when (<= KeyTimeCoinSelector'MAX_SIMULTANEOUS_INPUTS (count gathered)) => (recur value (next candidates))
                                                (log/warn (str "Reached " (count gathered) " inputs, going further would yield a tx that is too large, stopping here."))
                                                value
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )]
            (CoinSelection'new value, gathered)
        )
    )

    #_method
    (defn- #_"boolean" KeyTimeCoinSelector''is-confirmed [#_"KeyTimeCoinSelector" this, #_"TransactionOutput" output]
        (= (:confidence-type (Transaction''get-confidence (:parent-tx output))) :ConfidenceType'BUILDING)
    )
)

;;;
 ; A multi-signature keychain using synchronized HD keys (a.k.a HDM).
 ;
 ; This keychain keeps track of following keychains that follow the account key of this keychain.  You can get P2SH
 ; addresses to receive coins to from this chain.  The threshold - sigsRequiredToSpend specifies how many signatures
 ; required to spend transactions for this married keychain.  This value should not exceed the total number of keys
 ; involved (one followed key plus number of following keys), otherwise IllegalArgumentException will be thrown.
 ;
 ; IMPORTANT: As of Bitcoin Core 0.9 all multisig transactions which require more than 3 public keys are non-standard and
 ; such spends won't be processed by peers with default settings, essentially making such transactions almost nonspendable.
 ;
 ; This method will throw an IllegalStateException, if the keychain is already married or already has leaf keys issued.
 ;;
(class-ns MarriedKeyChain (ยง extends DeterministicKeyChain)
    (defn- #_"MarriedKeyChain" MarriedKeyChain'init []
        (hash-map
            ;; The map holds P2SH redeem script and corresponding ECKeys issued by this KeyChainGroup (including lookahead)
            ;; mapped to redeem script hashes.
            #_"LinkedHashMap<ByteString, RedeemData>" :married-keys-redeem-data (LinkedHashMap.)

            #_"List<DeterministicKeyChain>" :following-key-chains nil
        )
    )

    ;; Protobuf deserialization constructors.
    (defn #_"MarriedKeyChain" MarriedKeyChain'watch [#_"DeterministicKey" key]
        (merge (DeterministicKeyChain'watch key) (MarriedKeyChain'init))
    )

    (defn #_"MarriedKeyChain" MarriedKeyChain'from-seed [#_"DeterministicSeed" seed]
        (merge (DeterministicKeyChain'from-seed seed) (MarriedKeyChain'init))
    )

    ;; Builder constructors.
    (defn- #_"MarriedKeyChain" MarriedKeyChain'from-random [#_"SecureRandom" random, #_"int" bits, #_"String" passphrase, #_"long" secs]
        (merge (DeterministicKeyChain'from-random random, bits, passphrase, secs) (MarriedKeyChain'init))
    )

    (defn- #_"MarriedKeyChain" MarriedKeyChain'from-entropy [#_"byte[]" entropy, #_"String" passphrase, #_"long" secs]
        (merge (DeterministicKeyChain'from-entropy entropy, passphrase, secs) (MarriedKeyChain'init))
    )

    #_method
    (defn #_"MarriedKeyChain" MarriedKeyChain''set-following-key-chains [#_"MarriedKeyChain" this, #_"List<DeterministicKeyChain>" chains]
        (assert-argument (seq chains))

        (assoc this :following-key-chains chains)
    )

    #_override
    (defn #_"boolean" DeterministicKeyChain'''is-married [#_"MarriedKeyChain" __]
        true
    )

    ;;;
     ; Create a new married key and return the matching output script.
     ;;
    #_override
    (defn #_"Script" DeterministicKeyChain'''fresh-output-script [#_"MarriedKeyChain" this, #_"KeyPurpose" purpose]
        (let [#_"DeterministicKey" followed (DeterministicKeyChain''get-key this, purpose)
              #_"ImmutableList.Builder<ECKey>" keys (.add (ImmutableList/builder #_"List<ECKey>"), followed)]
            (doseq [#_"DeterministicKeyChain" chain (:following-key-chains this)]
                (let [#_"DeterministicKey" following (DeterministicKeyChain''get-key chain, purpose)]
                    (assert-state (= (DeterministicKey''get-child-number followed) (DeterministicKey''get-child-number following)), "Following keychains should be in sync")
                    (ยง ass keys (.add keys, following))
                )
            )
            (let [#_"List<ECKey>" __marriedKeys (.build keys)
                  #_"Script" redeem (Script'create-redeem-script (:sigs-required-to-spend this), __marriedKeys)]
                (Script'create-p2sh-output-script-1 redeem)
            )
        )
    )

    #_method
    (defn- #_"List<ECKey>" MarriedKeyChain''get-married-keys-with-followed [#_"MarriedKeyChain" this, #_"DeterministicKey" followed]
        (let [#_"ImmutableList.Builder<ECKey>" keys (ImmutableList/builder)]
            (doseq [#_"DeterministicKeyChain" chain (:following-key-chains this)]
                (ยง ass chain (DeterministicKeyChain''maybe-look-ahead-1 chain))
                (ยง ass keys (.add keys, (DeterministicKeyChain''get-key-by-path-2 chain, (:child-number-path followed))))
            )
            (ยง ass keys (.add keys, followed))
            (.build keys)
        )
    )

    ;;; Get the redeem data for a key in this married chain. ;;
    #_override
    (defn #_"RedeemData" DeterministicKeyChain'''get-redeem-data [#_"MarriedKeyChain" this, #_"DeterministicKey" followed]
        (let [#_"List<ECKey>" __marriedKeys (MarriedKeyChain''get-married-keys-with-followed this, followed)
              #_"Script" redeem (Script'create-redeem-script (:sigs-required-to-spend this), __marriedKeys)]
            (RedeemData'new redeem, __marriedKeys)
        )
    )

    #_method
    (defn- #_"MarriedKeyChain" MarriedKeyChain''add-following-account-keys [#_"MarriedKeyChain" this, #_"List<DeterministicKey>" __followingAccountKeys, #_"int" __sigsRequiredToSpend]
        (assert-argument (<= __sigsRequiredToSpend (inc (count __followingAccountKeys))), "Multisig threshold can't exceed total number of keys")
        (assert-state (zero? (DeterministicKeyChain''num-leaf-keys-issued this)), "Active keychain already has keys in use")
        (assert-state (nil? (:following-key-chains this)))

        (let [#_"List<DeterministicKeyChain>" __followingKeyChains (ArrayList.)]

            (doseq [#_"DeterministicKey" key __followingAccountKeys]
                (assert-argument (= (count (:child-number-path key)) (count DeterministicKeyChain'ACCOUNT_ZERO_PATH)), "Following keys have to be account keys")

                (let [#_"DeterministicKeyChain" chain (DeterministicKeyChain'watch-and-follow key)]
                    (when (<= 0 (:lookahead-size this))
                        (ยง ass chain (DeterministicKeyChain'''set-lookahead-size chain, (:lookahead-size this)))
                    )
                    (when (<= 0 (:lookahead-threshold this))
                        (ยง ass chain (DeterministicKeyChain''set-lookahead-threshold chain, (:lookahead-threshold this)))
                    )
                    (ยง ass __followingKeyChains (.add __followingKeyChains, chain))
                )
            )

            (assoc this :sigs-required-to-spend __sigsRequiredToSpend, :following-key-chains __followingKeyChains)
        )
    )

    #_override
    (defn #_"MarriedKeyChain" DeterministicKeyChain'''set-lookahead-size [#_"MarriedKeyChain" this, #_"int" size]
        (sync (:d-keychain-lock this)
            (let [this (DeterministicKeyChain'''set-lookahead-size (ยง this super), size)]
                (when (some? (:following-key-chains this))
                    (doseq [#_"DeterministicKeyChain" chain (:following-key-chains this)]
                        (ยง ass chain (DeterministicKeyChain'''set-lookahead-size chain, size))
                    )
                )
                this
            )
        )
    )

    #_override
    (defn #_"void" DeterministicKeyChain'''format-addresses [#_"MarriedKeyChain" this, #_"Ledger" ledger, #_"StringBuilder" sb]
        (doseq [#_"DeterministicKeyChain" chain (:following-key-chains this)]
            (.. sb (append "Following chain:  ") (append (DeterministicKey''serialize-pub-base58 (DeterministicKeyChain''get-watching-key chain), ledger)) (append "\n"))
        )
        (.. sb (append "\n"))
        (doseq [#_"RedeemData" redeem (.values (:married-keys-redeem-data this))]
            (let [#_"Script" script (Script'create-p2sh-output-script-1 (:redeem-script redeem))]
                (.. sb (append "  addr:") (append (Script''get-to-address-2 script, ledger)))
                (.. sb (append "  hash160:") (append (Base16'encode (Script''get-pub-key-hash script))))
                (.. sb (append "\n"))
            )
        )
        nil
    )

    #_override
    (defn #_"MarriedKeyChain" DeterministicKeyChain'''maybe-look-ahead-scripts [#_"MarriedKeyChain" this]
        (let [this (DeterministicKeyChain'''maybe-look-ahead-scripts (ยง this super))
              #_"int" n (count (DeterministicKeyChain''get-leaf-keys this))]
            (assert-state (<= (count (:married-keys-redeem-data this)) n), "Number of scripts is greater than number of leaf keys")

            (when-not (= (count (:married-keys-redeem-data this)) n) => this
                (let [this (DeterministicKeyChain''maybe-look-ahead-1 this)]
                    (doseq [#_"DeterministicKey" leaf (DeterministicKeyChain''get-leaf-keys this)]
                        (let [#_"RedeemData" redeem (DeterministicKeyChain'''get-redeem-data this, leaf)
                              #_"Script" script (Script'create-p2sh-output-script-1 (:redeem-script redeem))]
                            (ยง ass this (update this :married-keys-redeem-data assoc (ยง ByteString/copyFrom (Script''get-pub-key-hash script)) redeem))
                        )
                    )
                    this
                )
            )
        )
    )

    #_override
    (defn #_"RedeemData" DeterministicKeyChain'''find-redeem-data-by-script-hash [#_"MarriedKeyChain" this, #_"ByteString" bytes]
        (get (:married-keys-redeem-data this) bytes)
    )

    #_override
    (defn #_"BloomFilter" DeterministicKeyChain'''create-bloom-filter [#_"MarriedKeyChain" this, #_"int" size, #_"double" rate, #_"long" tweak]
        (sync (:d-keychain-lock this)
            (let [#_"BloomFilter" filter (BloomFilter'new nil, size, rate, tweak, :BloomUpdate'UPDATE_P2PUBKEY_ONLY)]
                (doseq [#_"Map.Entry<ByteString, RedeemData>" entry (.entrySet (:married-keys-redeem-data this))]
                    (ยง ass filter (BloomFilter''insert-data filter, (.toByteArray (.getKey entry))))
                    (ยง ass filter (BloomFilter''insert-data filter, (Script''to-bytes (:redeem-script (.getValue entry)))))
                )
                filter
            )
        )
    )

    #_override
    (defn #_"int" DeterministicKeyChain'''count-bloom-filter-elements [#_"MarriedKeyChain" this]
        (ยง ass this (DeterministicKeyChain''maybe-look-ahead-1 this))
        (* (count (DeterministicKeyChain''get-leaf-keys this)) 2)
    )
)

;;;
 ; This class aggregates data required to spend transaction output.
 ;
 ; For pay-to-address and pay-to-pubkey transactions it will have only a single key and CHECKSIG program as redeemScript.
 ; For multisignature transactions there will be multiple keys one of which will be a full key and the rest are watch only,
 ; redeem script will be a CHECKMULTISIG program.  Keys will be sorted in the same order they appear in
 ; a program (lexicographical order).
 ;;
(class-ns RedeemData
    (defn #_"RedeemData" RedeemData'new [#_"Script" script, #_"List<ECKey>" keys]
        (hash-map
            #_"Script" :redeem-script script
            #_"ECKey*" :redeem-keys (sort ECKey'compare-by-pub-key keys)
        )
    )

    ;;;
     ; Creates RedeemData for pay-to-address or pay-to-pubkey input.  Provided key is a single private key
     ; needed to spend such inputs and provided program should be a proper CHECKSIG program.
     ;;
    (defn #_"RedeemData" RedeemData'of [#_"Script" script, #_"ECKey" key]
        (assert-argument (or (Script''is-sent-to-address script) (Script''is-sent-to-raw-pub-key script)))

        (when (some? key) (RedeemData'new script, (list key)))
    )

    ;;;
     ; Returns the first key that has private bytes.
     ;;
    #_method
    (defn #_"ECKey" RedeemData''get-full-key [#_"RedeemData" this]
        (first (filter ECKey'''has-priv-key (:redeem-keys this)))
    )
)

;;;
 ; A SendRequest gives the wallet information about precisely how to send money to a recipient or set of recipients.
 ; Static methods are provided to help you create SendRequests and there are a few helper methods on the wallet that
 ; just simplify the most common use cases.  You may wish to customize a SendRequest if you want to attach a fee or
 ; modify the change address.
 ;;
(class-ns SendRequest
    (defn- #_"SendRequest" SendRequest'new []
        (hash-map
            ;;;
             ; A transaction, probably incomplete, that describes the outline of what you want to do.  This typically
             ; will mean it has some outputs to the intended destinations, but no inputs or change address (and therefore
             ; no fees) - the wallet will calculate all that for you and update tx later.
             ;
             ; Be careful when adding outputs that you check the min output value
             ; ({@link TransactionOutput#getMinNonDustValue(Coin)}) to avoid the whole transaction being rejected
             ; because one output is dust.
             ;
             ; If there are already inputs to the transaction, make sure their out point has a connected output,
             ; otherwise their value will be added to fee.  Also ensure they are either signed or are spendable by
             ; a wallet key, otherwise the behavior of {@link Wallet#completeTx(Wallet.SendRequest)} is undefined
             ; (likely RuntimeException).
             ;;
            #_"Transaction" :tx nil

            ;;;
             ; When emptyWallet is set, all coins selected by the coin selector are sent to the first output in tx
             ; (its value is ignored and set to {@link Wallet#getBalance()} - the fees required
             ; for the transaction).  Any additional outputs are removed.
             ;;
            #_"boolean" :empty-wallet false

            ;;;
             ; "Change" means the difference between the value gathered by a transactions inputs (the size of which you
             ; don't really control as it depends on who sent you money), and the value being sent somewhere else.  The
             ; change address should be selected from this wallet, normally.  <b>If null this will be chosen for you.</b>
             ;;
            #_"Address" :change-address nil

            ;;;
             ; A transaction can have a fee attached, which is defined as the difference between the input values
             ; and output values.  Any value taken in that is not provided to an output can be claimed by a miner.  This
             ; is how mining is incentivized in later years of the Bitcoin system when inflation drops.  It also provides
             ; a way for people to prioritize their transactions over others and is used as a way to make denial of service
             ; attacks expensive.
             ;
             ; This is a dynamic fee (in satoshis) which will be added to the transaction for each kilobyte in size
             ; including the first.  This is useful as as miners usually sort pending transactions by their fee per unit size
             ; when choosing which transactions to add to a block.  Note that, to keep this equivalent to Bitcoin Core
             ; definition, a kilobyte is defined as 1000 bytes, not 1024.
             ;;
            #_"Coin" :fee-per-kb Transaction'DEFAULT_TX_FEE

            ;;;
             ; Requires that there be enough fee for a default Bitcoin Core to at least relay the transaction.
             ; (i.e. ensure the transaction will not be outright rejected by the network).  Defaults to true,
             ; you should only set this to false if you know what you're doing.
             ;
             ; Note that this does not enforce certain fee rules that only apply to transactions which are larger
             ; than 26,000 bytes.  If you get a transaction which is that large, you should set a feePerKb of at least
             ; {@link Transaction#REFERENCE_DEFAULT_MIN_TX_FEE}.
             ;;
            #_"boolean" :ensure-min-required-fee true

            ;;;
             ; If true (the default), the inputs will be signed.
             ;;
            #_"boolean" :sign-inputs true

            ;;;
             ; If not null, the {@link CoinSelector} to use instead of the wallets default.
             ; Coin selectors are responsible for choosing which transaction outputs (coins) in a wallet to use given
             ; the desired send value amount.
             ;;
            #_"CoinSelector" :coin-selector nil

            ;;;
             ; If true (the default), the outputs will be shuffled during completion to randomize the location
             ; of the change output, if any.  This is normally what you want for privacy reasons but in unit tests
             ; it can be annoying, so it can be disabled here.
             ;;
            #_"boolean" :shuffle-outputs true

            ;;;
             ; Specifies what to do with missing signatures left after completing this request.  Default strategy is
             ; to throw an exception on missing signature ({@link MissingSigsMode#THROW}).
             ;
             ; @see MissingSigsMode
             ;;
            #_"MissingSigsMode" :missing-sigs-mode :MissingSigsMode'THROW

            ;;;
             ; If not null, this exchange rate is recorded with the transaction during completion.
             ;;
            #_"ExchangeRate" :exchange-rate nil

            ;;;
             ; If not null, this memo is recorded with the transaction during completion.  It can be used to record
             ; the memo of the payment request that initiated the transaction.
             ;;
            #_"String" :memo nil

            ;;;
             ; If false (default value), tx fee is paid by the sender.  If true, tx fee is paid by the recipient/s.
             ; If there is more than one recipient, the tx fee is split equally between them regardless of output
             ; value and size.
             ;;
            #_"boolean" :recipients-pay-fees false

            ;; Tracks if this has been passed to wallet.completeTx already: just a safety check.
            #_"boolean" :completed false
        )
    )

    ;;;
     ; Simply wraps a pre-built incomplete transaction provided by you.
     ;;
    (defn #_"SendRequest" SendRequest'for-tx [#_"Transaction" tx]
        (assoc (SendRequest'new) :tx tx)
    )

    ;;;
     ; Creates a new SendRequest to the given address for the given value.
     ;
     ; Be very careful when value is smaller than {@link Transaction#MIN_NONDUST_OUTPUT} as the transaction
     ; will likely be rejected by the network in this case.
     ;;
    (defn #_"SendRequest" SendRequest'to-address [#_"Address" destination, #_"Coin" value]
        (let [#_"Ledger" ledger (ensure some? (:ledger destination), "Address is for an unknown network")
              #_"Transaction" tx (Transaction'new ledger)]
            (Transaction''add-output-ca tx, value, destination)
            (SendRequest'for-tx tx)
        )
    )

    (defn #_"SendRequest" SendRequest'empty-wallet [#_"Address" destination]
        (assoc (SendRequest'to-address destination, Coin'ZERO) :empty-wallet true)
    )

    ;;;
     ; Creates a new SendRequest to the given pubkey for the given value.
     ;
     ; Be careful to check the output's value is reasonable using
     ; {@link TransactionOutput#getMinNonDustValue(Coin)} afterwards or you risk having the transaction
     ; rejected by the network.  Note that using {@link SendRequest#to(Address, Coin)} will result
     ; in a smaller output, and thus the ability to use a smaller output value without rejection.
     ;;
    (defn #_"SendRequest" SendRequest'to-pubkey [#_"Ledger" ledger, #_"ECKey" destination, #_"Coin" value]
        (let [#_"Transaction" tx (Transaction'new ledger)]
            (Transaction''add-output-ce tx, value, destination)
            (SendRequest'for-tx tx)
        )
    )

    ;;;
     ; Construct a SendRequest for a CPFP (child-pays-for-parent) transaction.  The resulting transaction is
     ; already completed, so you should directly proceed to signing and broadcasting/committing the transaction.
     ; CPFP is currently only supported by a few miners, so use with care.
     ;;
    (defn #_"SendRequest" SendRequest'child-pays-for-parent [#_"Wallet" wallet, #_"Transaction" parent, #_"Coin" __feeRaise]
        (let [#_"TransactionOutput" output
                (->> (:outputs parent)
                     (filter #(and (TransactionOutput''is-mine %, wallet)
                                   (TransactionOutput''is-available-for-spending %)
                                   (Coin''greater-than? (:coin-value %), __feeRaise)))
                     (first)
                )]
            ;; TODO: Spend another confirmed output of own wallet if needed.
            (ensure some? output, "Can't find adequately sized output that spends to us")

            (let [#_"Transaction" tx (Transaction'new (:ledger parent))]
                (Transaction''add-input-o tx, output)
                (Transaction''add-output-ca tx, (Coin''subtract (:coin-value output), __feeRaise), (Wallet''fresh-address wallet, :KeyPurpose'CHANGE))
                (let [tx (assoc tx :purpose :TransactionPurpose'RAISE_FEE)]
                    (assoc (SendRequest'for-tx tx) :completed true)
                )
            )
        )
    )

    (defn #_"SendRequest" SendRequest'to-cltv-payment-channel-5d [#_"Ledger" ledger, #_"Date" date, #_"ECKey" from, #_"ECKey" to, #_"Coin" value]
        (let [#_"long" time (quot (.getTime date) 1000)]
            (assert-argument (<= Transaction'LOCKTIME_THRESHOLD time), "Release time was too small")

            (SendRequest'to-cltv-payment-channel-5bi ledger, (BigInteger/valueOf time), from, to, value)
        )
    )

    (defn #_"SendRequest" SendRequest'to-cltv-payment-channel-5i [#_"Ledger" ledger, #_"int" time, #_"ECKey" from, #_"ECKey" to, #_"Coin" value]
        (assert-argument (< -1 time Transaction'LOCKTIME_THRESHOLD), "Block number was too large")

        (SendRequest'to-cltv-payment-channel-5bi ledger, (BigInteger/valueOf time), from, to, value)
    )

    (defn #_"SendRequest" SendRequest'to-cltv-payment-channel-5bi [#_"Ledger" ledger, #_"BigInteger" time, #_"ECKey" from, #_"ECKey" to, #_"Coin" value]
        (let [#_"Transaction" tx (Transaction'new ledger)]
            (Transaction''add-output-cs tx, value, (Script'create-cltv-payment-channel-output time, from, to))
            (SendRequest'for-tx tx)
        )
    )

    #_method
    (defn #_"String" SendRequest''to-string [#_"SendRequest" this]
        ;; Print only the user-settable fields.
        (let [#_"StringBuilder" sb (StringBuilder. (<< 1 7))]
            (.. sb (append "{ "))
            (do
                (.. sb               (append "emptyWallet")          (append "=") (append (:empty-wallet this)))
                (when (some? (:change-address this))
                    (.. sb (append ", ") (append "changeAddress")    (append "=") (append (:change-address this)))
                )
                (.. sb (append ", ") (append "feePerKb")             (append "=") (append (:fee-per-kb this)))
                (.. sb (append ", ") (append "ensureMinRequiredFee") (append "=") (append (:ensure-min-required-fee this)))
                (.. sb (append ", ") (append "signInputs")           (append "=") (append (:sign-inputs this)))
                (when (some? (:coin-selector this))
                    (.. sb (append ", ") (append "coinSelector")     (append "=") (append (:coin-selector this)))
                )
                (.. sb (append ", ") (append "shuffleOutputs")       (append "=") (append (:shuffle-outputs this)))
                (.. sb (append ", ") (append "recipientsPayFees")    (append "=") (append (:recipients-pay-fees this)))
            )
            (.. sb (append " }"))
            (.toString sb)
        )
    )
)

;; To do list:
;;
;; - Take all wallet-relevant data out of Transaction and put it into WalletTransaction.  Make Transaction immutable.
;; - Only store relevant transaction outputs, don't bother storing the rest of the data.  Big RAM saving.
;; - Split block chain and tx output tracking into a superclass that doesn't have any key or spending related code.
;; - Simplify how transactions are tracked and stored: in particular, have the wallet maintain positioning information
;;   for transactions independent of the transactions themselves, so the timeline can be walked without having to
;;   process and sort every single transaction.
;; - Split data persistence out into a backend class and make the wallet transactional, so we can store a wallet
;;   in a database not just in RAM.
;; - Make clearing of transactions able to only rewind the wallet a certain distance instead of all blocks.
;; - Make it scale:
;;     - eliminate all the algorithms with quadratic complexity (or worse).
;;     - don't require everything to be held in RAM at once.
;;     - consider allowing eviction of no longer re-orgable transactions or keys that were used up.
;;
;; Finally, find more ways to break the class up and decompose it.  Currently every time we move code out, other code
;; fills up the lines saved!

(def PoolType'enum-set
    (hash-set
        :PoolType'UNSPENT ;; unspent in best chain
        :PoolType'SPENT ;; spent in best chain
        :PoolType'DEAD ;; double-spend in alt chain
        :PoolType'PENDING ;; a pending tx we would like to go into the best chain
    )
)

;;;
 ; It's possible to calculate a wallets balance from multiple points of view.  This enum selects which
 ; {@link #getBalance(BalanceType)} should use.
 ;
 ; Consider a real-world example: you buy a snack costing $5 but you only have a $10 bill.  At the start
 ; you have $10 viewed from every possible angle.  After you order the snack you hand over your $10 bill.
 ; From the perspective of your wallet you have zero dollars (AVAILABLE).  But you know in a few seconds the
 ; shopkeeper will give you back $5 change so most people in practice would say they have $5 (ESTIMATED).
 ;
 ; The fact that the wallet can track transactions which are not spendable by itself ("watching wallets")
 ; adds another type of balance to the mix.  Although the wallet won't do this by default, advanced use cases
 ; that override the relevancy checks can end up with a mix of spendable and unspendable transactions.
 ;;
(def BalanceType'enum-set
    (hash-set
        ;;;
         ; Balance calculated assuming all pending transactions are in fact included into the best chain by miners.
         ; This includes the value of immature coinbase transactions.
         ;;
        :BalanceType'ESTIMATED
        ;;;
         ; Balance that could be safely used to create new spends, if we had all the needed private keys.  This is
         ; whatever the default coin selector would make available, which by default means transaction outputs with at
         ; least 1 confirmation and pending transactions created by our own wallet which have been propagated across
         ; the network.  Whether we <i>actually</i> have the private keys or not is irrelevant for this balance type.
         ;;
        :BalanceType'AVAILABLE
        ;;;
         ; Same as ESTIMATED but only for outputs we have the private keys for and can sign ourselves.
         ;;
        :BalanceType'ESTIMATED_SPENDABLE
        ;;;
         ; Same as AVAILABLE but only for outputs we have the private keys for and can sign ourselves.
         ;;
        :BalanceType'AVAILABLE_SPENDABLE
    )
)

;;;
 ; Enumerates possible resolutions for missing signatures.
 ;;
(def MissingSigsMode'enum-set
    (hash-set
        ;;;
         ; Input script will have OP_0 instead of missing signatures.
         ;;
        :MissingSigsMode'USE_OP_ZERO
        ;;;
         ; Missing signatures will be replaced by dummy sigs.  This is useful when you'd like to know the
         ; fee for a transaction without knowing the user's password, as fee depends on size.
         ;;
        :MissingSigsMode'USE_DUMMY_SIG
        ;;;
         ; If signature is missing, {@link TransactionSigner.MissingSignatureException}
         ; will be thrown for P2SH and {@link ECKey.MissingPrivateKeyException} for other tx types.
         ;;
        :MissingSigsMode'THROW
    )
)

(class-ns BalanceFutureRequest
    (defn- #_"BalanceFutureRequest" BalanceFutureRequest'new [#_"SettableFuture<Coin>" future, #_"Coin" value, #_"BalanceType" type]
        (hash-map
            #_"SettableFuture<Coin>" :future future
            #_"Coin" :balance-value value
            #_"BalanceType" :balance-type type
        )
    )
)

;;;
 ; A SendResult is returned to you as part of sending coins to a recipient.
 ;;
(class-ns SendResult
    (defn- #_"SendResult" SendResult'new [#_"Transaction" tx]
        (hash-map
            ;;;
             ; The Bitcoin transaction message that moves the money.
             ;;
            #_"Transaction" :tx tx
            ;;;
             ; A future that will complete once the tx message has been successfully broadcast to the network.
             ; This is just the result of calling broadcast.future().
             ;;
            #_"ListenableFuture<Transaction>" :broadcast-complete nil
            ;;;
             ; The broadcast object returned by the linked TransactionBroadcaster.
             ;;
            #_"TransactionBroadcast" :broadcast nil
        )
    )
)

 ;;;
  ; Class of exceptions thrown in {@link Wallet#completeTx(SendRequest)}.
  ;;
(class-ns CompletionException (ยง extends RuntimeException)
    (defn #_"CompletionException" CompletionException'new []
        (RuntimeException'new)
    )
)

 ;;;
  ; Thrown if the resultant transaction would violate the dust rules (an output that's too small to be worthwhile).
  ;;
(class-ns DustySendRequested (ยง extends CompletionException)
    (defn #_"DustySendRequested" DustySendRequested'new []
        (CompletionException'new)
    )
)

 ;;;
  ; Thrown if there is more than one OP_RETURN output for the resultant transaction.
  ;;
(class-ns MultipleOpReturnRequested (ยง extends CompletionException)
    (defn #_"MultipleOpReturnRequested" MultipleOpReturnRequested'new []
        (CompletionException'new)
    )
)

 ;;;
  ; Thrown when we were trying to empty the wallet, and the total amount of money we were trying to empty after
  ; being reduced for the fee was smaller than the min payment.
  ; Note that the missing field will be null in this case.
  ;;
(class-ns CouldNotAdjustDownwards (ยง extends CompletionException)
    (defn #_"CouldNotAdjustDownwards" CouldNotAdjustDownwards'new []
        (CompletionException'new)
    )
)

 ;;;
  ; Thrown if the resultant transaction is too big for Bitcoin to process.  Try breaking up the amounts of value.
  ;;
(class-ns ExceededMaxTransactionSize (ยง extends CompletionException)
    (defn #_"ExceededMaxTransactionSize" ExceededMaxTransactionSize'new []
        (CompletionException'new)
    )
)

(class-ns TxOffsetPair
    (defn- #_"TxOffsetPair" TxOffsetPair'new [#_"Transaction" tx, #_"int" offset]
        (hash-map
            #_"Transaction" :tx tx
            #_"int" :offset offset
        )
    )

    (defn #_"int" TxOffsetPair'compare [#_"TxOffsetPair" this, #_"TxOffsetPair" that]
        ;; Note that in this implementation compareTo() is not consistent with equals().
        (compare (:offset this) (:offset that))
    )
)

(class-ns FeeCalculation
    (defn- #_"FeeCalculation" FeeCalculation'new []
        (hash-map
            ;; Selected UTXOs to spend.
            #_"CoinSelection" :best-coin-selection nil
            ;; Change output (may be null if no change).
            #_"TransactionOutput" :best-change-output nil
            ;; List of output values adjusted downwards when recipients pay fees (may be null if no adjustment needed).
            #_"List<Coin>" :updated-output-values nil
        )
    )
)

;;;
 ; A Wallet stores keys and a record of transactions that send and receive value from those keys.  Using these,
 ; it is able to create new transactions that spend the recorded transactions, and this is the fundamental operation
 ; of the Bitcoin protocol.
 ;
 ; To learn more about this class, read <b><a href="https://bitcoinj.github.io/working-with-the-wallet">working with the wallet.</a></b>
 ;
 ; To fill up a Wallet with transactions, you need to use it in combination with a {@link SPVBlockChain} and various
 ; other objects, see the <a href="https://bitcoinj.github.io/getting-started">Getting started</a> tutorial
 ; on the website to learn more about how to set everything up.
 ;
 ; Wallets can be serialized using protocol buffers.  You need to save the wallet whenever it changes, there is an
 ; auto-save feature that simplifies this for you although you're still responsible for manually triggering a save when
 ; your app is about to quit because the auto-save feature waits a moment before actually committing to disk to avoid IO
 ; thrashing when the wallet is changing very fast (e.g. due to a block chain sync).
 ;;
(class-ns Wallet (ยง implements NewBestBlockListener, TransactionReceivedInBlockListener, KeyBag, ReorganizeListener)
    (def #_"int" Wallet'DEFAULT_EVENT_HORIZON 100)

    ;;;
     ; Creates a new, empty wallet with a randomly chosen seed and no transactions.
     ; Make sure to provide for sufficient backup!  Any keys will be derived from the seed.
     ;;
    (defn #_"Wallet" Wallet'new
        ([#_"Ledger" ledger] (Wallet'new ledger, nil))
        ([#_"Ledger" ledger, #_"KeyChainGroup" group]
            (let [this
                    (hash-map
                        #_"Ledger" :ledger ledger

                        ;; The key chain group is not thread safe, and generally the whole hierarchy of objects should not be mutated
                        ;; outside the wallet lock.  So don't expose this object directly via any accessors!
                        #_"KeyChainGroup" :key-chain-group (or group (KeyChainGroup'new ledger))

                        ;; Ordering: lock > keyChainGroupLock.  KeyChainGroup is protected separately to allow fast querying of current receive
                        ;; address even if the wallet itself is busy e.g. saving or processing a big reorg.  Useful for reducing UI latency.
                        #_"Object" :wallet-lock (Object.)
                        #_"Object" :keychaingroup-lock (Object.)

                        ;; The various pools below give quick access to wallet-relevant transactions by the state they're in:
                        ;;
                        ;; Pending:  Transactions that didn't make it into the best chain yet.  Pending transactions can be killed if a
                        ;;           double spend against them appears in the best chain, in which case they move to the dead pool.
                        ;;           If a double spend appears in the pending state as well, we update the confidence type
                        ;;           of all txns in conflict to IN_CONFLICT and wait for the miners to resolve the race.
                        ;; Unspent:  Transactions that appeared in the best chain and have outputs we can spend.  Note that we store the
                        ;;           entire transaction in memory even though for spending purposes we only really need the outputs, the
                        ;;           reason being that this simplifies handling of re-orgs.  It would be worth fixing this in future.
                        ;; Spent:    Transactions that appeared in the best chain but don't have any spendable outputs.  They're stored
                        ;;           here for history browsing/auditing reasons only and in future will probably be flushed out to some
                        ;;           other kind of cold storage or just removed.
                        ;; Dead:     Transactions that we believe will never confirm get moved here, out of pending.  Note that Bitcoin
                        ;;           Core has no notion of dead-ness: the assumption is that double spends won't happen so there's no
                        ;;           need to notify the user about them.  We take a more pessimistic approach and try to track the fact
                        ;;           that transactions have been double spent so applications can do something intelligent (cancel orders,
                        ;;           show to the user in the UI, etc).  A transaction can leave dead and move into spent/unspent if there
                        ;;           is a re-org to a chain that doesn't include the double spend.
                        #_"Map<Sha256Hash, Transaction>" :pending (HashMap.)
                        #_"Map<Sha256Hash, Transaction>" :unspent (HashMap.)
                        #_"Map<Sha256Hash, Transaction>" :spent (HashMap.)
                        #_"Map<Sha256Hash, Transaction>" :dead (HashMap.)

                        ;; All transactions together.
                        #_"Map<Sha256Hash, Transaction>" :transactions (HashMap.)

                        ;; All the TransactionOutput objects that we could spend (ignoring whether we have the private key or not).
                        ;; Used to speed up various calculations.
                        #_"HashSet<TransactionOutput>" :my-unspents (HashSet.)

                        ;; Transactions that were dropped by the risk analysis system.  These are not in any pools and not serialized
                        ;; to disk.  We have to keep them around because if we ignore a tx because we think it will never confirm, but
                        ;; then it actually does confirm and does so within the same network session, remote peers will not resend us
                        ;; the tx data along with the Bloom filtered block, as they know we already received it once before
                        ;; (so it would be wasteful to repeat).  Thus we keep them around here for a while.  If we drop our network
                        ;; connections then the remote peers will forget that we were sent the tx data previously and send it again
                        ;; when relaying a filtered merkleblock.
                        #_"LinkedHashMap<Sha256Hash, Transaction>" :risk-dropped
                            (proxy [LinkedHashMap #_"<Sha256Hash, Transaction>"] []
                                #_foreign
                                #_override
                                (#_"boolean" removeEldestEntry [#_"LinkedHashMap" #_this, #_"Map.Entry<Sha256Hash, Transaction>" _eldest]
                                    (< 1000 (.size this))
                                )
                            )

                        #_"Sha256Hash" :last-block-seen-hash nil
                        ;;;
                         ; The height of the last seen best-chain block.  Can be 0 if a wallet is brand new or -1 if the wallet is old
                         ; and doesn't have that data.
                         ;;
                        #_"int" :last-block-seen-height 0
                        ;;;
                         ; The UNIX time in seconds since the epoch extracted from the last best seen block header.  This timestamp is
                         ; <b>not</b> the local time at which the block was first observed by this application but rather what the block
                         ; (i.e. miner) self declares.  It is allowed to have some significant drift from the real time at which the block
                         ; was found, although most miners do use accurate times.  If this wallet is old and does not have a recorded
                         ; time then this method returns zero.
                         ;;
                        #_"long" :last-block-seen-time-secs 0

                        #_"[WalletChangeEventListener]" :change-listeners (vector)
                        #_"[WalletCoinsReceivedEventListener]" :coins-received-listeners (vector)
                        #_"[WalletCoinsSentEventListener]" :coins-sent-listeners (vector)
                        #_"[WalletReorganizeEventListener]" :wallet-reorganize-listeners (vector)
                        #_"[TransactionConfidenceEventListener]" :transaction-confidence-listeners (vector)

                        ;; A listener that relays confidence changes from the transaction confidence object to the wallet event listener,
                        ;; as a convenience to API users so they don't have to register on every transaction themselves.
                        #_"TransactionConfidenceListener" :tx-confidence-listener nil

                        ;; If a TX hash appears in this set then notifyNewBestBlock will ignore it, as its confidence was already set up
                        ;; in receive() via Transaction.setBlockAppearance().  As the SPVBlockChain always calls notifyNewBestBlock even if
                        ;; it sent transactions to the wallet, without this we'd double count.
                        #_"HashSet<Sha256Hash>" :ignore-next-new-block nil
                        ;; Whether or not to ignore pending transactions that are considered risky by the configured risk analyzer.
                        ;;;
                         ; Whether or not the wallet will ignore pending transactions that fail the selected {@link RiskAnalysis}.
                         ; By default, if a transaction is considered risky then it won't enter the wallet and won't trigger any event
                         ; listeners.  If you set this property to true, then all transactions will be allowed in regardless of risk.
                         ; For example, the default {@link RiskAnalysis} checks for non-finality of transactions.
                         ;
                         ; Note that this property is not serialized.  You have to set it each time a Wallet object is constructed,
                         ; even if it's loaded from a protocol buffer.
                         ;;
                        #_"boolean" :accept-risky-transactions false

                        ;; Stuff for notifying transaction objects that we changed their confidences.  The purpose of this is to avoid
                        ;; spuriously sending lots of repeated notifications to listeners that API users aren't really interested in as
                        ;; a side effect of how the code is written (e.g. during re-orgs confidence data gets adjusted multiple times).
                        #_"int" :on-wallet-changed-suppressions 0
                        #_"boolean" :inside-reorg false
                        ;; Use a linked hash map to ensure ordering of event listeners is correct.
                        #_"Map<Transaction, ConfidenceChangeReason>" :confidence-changed (LinkedHashMap.)
                        ;; Object that is used to send transactions asynchronously when the wallet requires it.
                        #_volatile
                        #_"TransactionBroadcaster" :v-transaction-broadcaster nil
                        ;; UNIX time in seconds.  Money controlled by keys created before this time will be automatically respent
                        ;; to a key that was created after it.  Useful when you believe some keys have been compromised.
                        #_volatile
                        #_"long" :v-key-rotation-timestamp 0

                        #_"CoinSelector" :coin-selector (DefaultCoinSelector'new)

                        ;; Objects that perform transaction signing.  Applied subsequently one after another.
                        #_"List<TransactionSigner>" :signers (ArrayList.)

                        ;; Whether to do a saveNow or saveLater when we are notified of the next best block.
                        #_"boolean" :hard-save-on-next-block false

                        #_"List<BalanceFutureRequest>" :balance-future-requests (LinkedList.)

                        ;;;
                         ; The event horizon is the number of blocks after which the wallet consider a transaction to be so confirmed,
                         ; that it's safe to delete data.  Re-orgs larger than the event horizon will not be correctly processed,
                         ; so the default value is high (100).
                         ;;
                        #_"int" :event-horizon Wallet'DEFAULT_EVENT_HORIZON
                    )]

                ;; If this keyChainGroup was created fresh just now (new wallet), make HD so a backup can be made immediately
                ;; without having to call current/freshReceiveKey.  If there are already keys in the chain of any kind then
                ;; we're probably being deserialized so leave things alone: the API user can upgrade later.
                (let [this
                        (when (zero? (KeyChainGroup''num-keys (:key-chain-group this))) => this
                            (update this :key-chain-group KeyChainGroup''create-and-activate-new-hd-chain)
                        )]
                    (ยง ass this (Wallet''add-transaction-signer this, (LocalTransactionSigner'new)))
                    (Wallet''create-transient-state this)
                )
            )
        )
    )

    (defn #_"Wallet" Wallet'from-seed [#_"Ledger" ledger, #_"DeterministicSeed" seed]
        (Wallet'new ledger, (KeyChainGroup'from-seed ledger, seed))
    )

    ;;;
     ; Creates a wallet that tracks payments to and from the HD key hierarchy rooted by the given watching key.
     ; A watching key corresponds to account zero in the recommended BIP32 key hierarchy.
     ;;
    (defn #_"Wallet" Wallet'from-watching-key [#_"Ledger" ledger, #_"DeterministicKey" key]
        (Wallet'new ledger, (KeyChainGroup'watch ledger, key))
    )

    ;;;
     ; Creates a wallet that tracks payments to and from the HD key hierarchy rooted by the given watching key.
     ; A watching key corresponds to account zero in the recommended BIP32 key hierarchy.  The key is specified
     ; in base58 notation and the creation time of the key.  If you don't know the creation time, you can pass
     ; {@link DeterministicHierarchy#BIP32_STANDARDISATION_TIME_SECS}.
     ;;
    (defn #_"Wallet" Wallet'from-watching-key-base58 [#_"Ledger" ledger, #_"String" __watchKeyB58, #_"long" secs]
        (let [#_"DeterministicKey" key (DeterministicKey'deserialize-base58-3 nil, __watchKeyB58, ledger)
              key (DeterministicKey''set-creation-time-seconds key, secs)]
            (Wallet'from-watching-key ledger, key)
        )
    )

    #_method
    (defn- #_"Wallet" Wallet''create-transient-state [#_"Wallet" this]
        (let [this (assoc this :ignore-next-new-block (HashSet.))
              this
                (assoc this :tx-confidence-listener
                    (reify TransactionConfidenceListener
                        #_override
                        (#_"void" TransactionConfidenceListener'''on-confidence-changed [#_"TransactionConfidenceListener" __, #_"TransactionConfidence" confidence, #_"ConfidenceChangeReason" reason]
                            ;; This will run on the user code thread so we shouldn't do anything too complicated here.
                            ;; We only want to queue a wallet changed event and auto-save if the number of peers announcing
                            ;; the transaction has changed, as that confidence change is made by the networking code which
                            ;; doesn't necessarily know at that point which wallets contain which transactions, so it's up
                            ;; to us to listen for that.  Other types of confidence changes (type, etc.) are triggered by us,
                            ;; so we'll queue up a wallet change event in other parts of the code.
                            (when (= reason :ConfidenceChangeReason'SEEN_PEERS)
                                (sync (:wallet-lock this)
                                    (Wallet''check-balance-futures-locked this)
                                    (let [#_"Transaction" tx (Wallet''get-transaction this, (:transaction-hash confidence))]
                                        (Wallet''queue-on-transaction-confidence-changed this, tx)
                                        (Wallet''maybe-queue-on-wallet-changed this)
                                    )
                                )
                            )
                            nil
                        )
                    )
                )]
            (assoc this :accept-risky-transactions false)
        )
    )

    ;;;
     ; Gets the active keychain via {@link KeyChainGroup#getActiveKeyChain()}.
     ;;
    #_method
    (defn #_"DeterministicKeyChain" Wallet''get-active-key-chain [#_"Wallet" this]
        (KeyChainGroup''get-active-key-chain (:key-chain-group this))
    )

    ;;;
     ; Adds given transaction signer to the list of signers.  It will be added to the end of the signers list,
     ; so if this wallet already has some signers added, given signer will be executed after all of them.
     ;
     ; Transaction signer should be fully initialized before adding to the wallet, otherwise
     ; {@link IllegalStateException} will be thrown.
     ;;
    #_method
    (defn #_"Wallet" Wallet''add-transaction-signer [#_"Wallet" this, #_"TransactionSigner" signer]
        (sync (:wallet-lock this)
            (ยง ass this (update this :signers .add signer))
        )
        this
    )

    #_method
    (defn #_"List<TransactionSigner>" Wallet''get-transaction-signers [#_"Wallet" this]
        (sync (:wallet-lock this)
            (:signers this)
        )
    )

    ;;;
     ; Returns a key that hasn't been seen in a transaction yet, and which is suitable for displaying
     ; in a wallet user interface as "a convenient key to receive funds on" when the purpose parameter
     ; is {@link KeyPurpose#RECEIVE_FUNDS}.  The returned key is stable
     ; until it's actually seen in a pending or confirmed transaction, at which point this method will
     ; start returning a different key (for each purpose independently).
     ;;
    #_method
    (defn #_"DeterministicKey" Wallet''current-key [#_"Wallet" this, #_"KeyPurpose" purpose]
        (sync (:keychaingroup-lock this)
            (KeyChainGroup''current-key (:key-chain-group this), purpose)
        )
    )

    #_method
    (defn #_"DeterministicKey" Wallet''current-receive-key [#_"Wallet" this]
        (Wallet''current-key this, :KeyPurpose'RECEIVE_FUNDS)
    )

    ;;;
     ; Returns address for a {@link #currentKey(KeyPurpose)}.
     ;;
    #_method
    (defn #_"Address" Wallet''current-address [#_"Wallet" this, #_"KeyPurpose" purpose]
        (sync (:keychaingroup-lock this)
            (KeyChainGroup''current-address (:key-chain-group this), purpose)
        )
    )

    #_method
    (defn #_"Address" Wallet''current-receive-address [#_"Wallet" this]
        (Wallet''current-address this, :KeyPurpose'RECEIVE_FUNDS)
    )

    ;;;
     ; Returns a key that has not been returned by this method before (fresh).  You can think of this
     ; as being a newly created key, although the notion of "create" is not really valid for a
     ; {@link DeterministicKeyChain}.  When the parameter is {@link KeyPurpose#RECEIVE_FUNDS}
     ; the returned key is suitable for being put into a receive coins wizard type UI.  You should use
     ; this when the user is definitely going to hand this key out to someone who wishes to send money.
     ;;
    #_method
    (defn #_"DeterministicKey" Wallet''fresh-key [#_"Wallet" this, #_"KeyPurpose" purpose]
        (nth (Wallet''fresh-keys this, purpose, 1) 0)
    )

    ;;;
     ; Returns a key/s that has not been returned by this method before (fresh).  You can think of this
     ; as being a newly created key/s, although the notion of "create" is not really valid for a
     ; {@link DeterministicKeyChain}.  When the parameter is {@link KeyPurpose#RECEIVE_FUNDS}
     ; the returned key is suitable for being put into a receive coins wizard type UI. You should use
     ; this when the user is definitely going to hand this key/s out to someone who wishes to send money.
     ;;
    #_method
    (defn #_"List<DeterministicKey>" Wallet''fresh-keys [#_"Wallet" this, #_"KeyPurpose" purpose, #_"int" n]
        (let [#_"List<DeterministicKey>" keys
                (sync (:keychaingroup-lock this)
                    (KeyChainGroup''fresh-keys (:key-chain-group this), purpose, n)
                )]
            ;; Do we really need an immediate hard save?  Arguably all this is doing is saving the 'current' key
            ;; and that's not quite so important, so we could coalesce for more performance.
            (Wallet''save-now this)
            keys
        )
    )

    #_method
    (defn #_"DeterministicKey" Wallet''fresh-receive-key [#_"Wallet" this]
        (Wallet''fresh-key this, :KeyPurpose'RECEIVE_FUNDS)
    )

    ;;;
     ; Returns address for a {@link #freshKey(KeyPurpose)}.
     ;;
    #_method
    (defn #_"Address" Wallet''fresh-address [#_"Wallet" this, #_"KeyPurpose" purpose]
        (let [#_"Address" key
                (sync (:keychaingroup-lock this)
                    (KeyChainGroup''fresh-address (:key-chain-group this), purpose)
                )]
            (Wallet''save-now this)
            key
        )
    )

    #_method
    (defn #_"Address" Wallet''fresh-receive-address [#_"Wallet" this]
        (Wallet''fresh-address this, :KeyPurpose'RECEIVE_FUNDS)
    )

    ;;;
     ; Returns only the keys that have been issued by {@link #freshReceiveKey()}, {@link #freshReceiveAddress()},
     ; {@link #currentReceiveKey()} or {@link #currentReceiveAddress()}.
     ;;
    #_method
    (defn #_"List<ECKey>" Wallet''get-issued-receive-keys [#_"Wallet" this]
        (sync (:keychaingroup-lock this)
            (DeterministicKeyChain''get-issued-receive-keys (KeyChainGroup''get-active-key-chain (:key-chain-group this)))
        )
    )

    ;;;
     ; Returns only the addresses that have been issued by {@link #freshReceiveKey()}, {@link #freshReceiveAddress()},
     ; {@link #currentReceiveKey()} or {@link #currentReceiveAddress()}.
     ;;
    #_method
    (defn #_"List<Address>" Wallet''get-issued-receive-addresses [#_"Wallet" this]
        (let [#_"List<ECKey>" keys (Wallet''get-issued-receive-keys this)
              #_"List<Address>" addresses (ArrayList. (count keys))]
            (doseq [#_"ECKey" key keys]
                (ยง ass addresses (.add addresses, (ECKey''to-address key, (:ledger this))))
            )
            addresses
        )
    )

    ;;;
     ; Returns the number of keys in the key chain group, including lookahead keys.
     ;;
    #_method
    (defn #_"int" Wallet''get-key-chain-group-size [#_"Wallet" this]
        (sync (:keychaingroup-lock this)
            (KeyChainGroup''num-keys (:key-chain-group this))
        )
    )

    #_testing
    #_method
    (defn #_"int" Wallet''get-key-chain-group-combined-key-lookahead-epochs [#_"Wallet" this]
        (sync (:keychaingroup-lock this)
            (KeyChainGroup''get-combined-key-lookahead-epochs (:key-chain-group this))
        )
    )

    ;;;
     ; Returns the address used for change outputs.  Note: this will probably go away in future.
     ;;
    #_method
    (defn #_"Address" Wallet''current-change-address [#_"Wallet" this]
        (Wallet''current-address this, :KeyPurpose'CHANGE)
    )

    ;;;
     ; Add a pre-configured keychain to the wallet.  Useful for setting up a complex keychain,
     ; such as for a married wallet.  For example:
     ;
     ; <pre>
     ; MarriedKeyChain chain = MarriedKeyChain.builder()
     ;     .random(SecureRandom.())
     ;     .followingKeys(followingKeys)
     ;     .threshold(2).build();
     ; wallet.addAndActivateHDChain(chain);
     ; </pre>
     ;;
    #_method
    (defn #_"Wallet" Wallet''add-and-activate-hd-chain [#_"Wallet" this, #_"DeterministicKeyChain" chain]
        (sync (:keychaingroup-lock this)
            (update this :key-chain-group KeyChainGroup''add-and-activate-hd-chain chain)
        )
    )

    #_method
    (defn #_"Wallet" Wallet''set-key-chain-group-lookahead-size [#_"Wallet" this, #_"int" size]
        (sync (:keychaingroup-lock this)
            (update this :key-chain-group KeyChainGroup''set-lookahead-size size)
        )
    )

    #_method
    (defn #_"int" Wallet''get-key-chain-group-lookahead-size [#_"Wallet" this]
        (sync (:keychaingroup-lock this)
            (KeyChainGroup''get-lookahead-size (:key-chain-group this))
        )
    )

    #_method
    (defn #_"Wallet" Wallet''set-key-chain-group-lookahead-threshold [#_"Wallet" this, #_"int" num]
        (sync (:keychaingroup-lock this)
            (update this :key-chain-group KeyChainGroup''set-lookahead-threshold num)
        )
    )

    #_method
    (defn #_"int" Wallet''get-key-chain-group-lookahead-threshold [#_"Wallet" this]
        (sync (:keychaingroup-lock this)
            (KeyChainGroup''get-lookahead-threshold (:key-chain-group this))
        )
    )

    ;;;
     ; Returns a public-only DeterministicKey that can be used to set up a watching wallet: that is, a wallet that
     ; can import transactions from the block chain just as the normal wallet can, but which cannot spend.  Watching
     ; wallets are very useful for things like web servers that accept payments.  This key corresponds to the account
     ; zero key in the recommended BIP32 hierarchy.
     ;;
    #_method
    (defn #_"DeterministicKey" Wallet''get-watching-key [#_"Wallet" this]
        (sync (:keychaingroup-lock this)
            (DeterministicKeyChain''get-watching-key (KeyChainGroup''get-active-key-chain (:key-chain-group this)))
        )
    )

    ;;;
     ; Returns whether this wallet consists entirely of watching keys (unencrypted keys with no private part).
     ; Mixed wallets are forbidden.
     ;
     ; @throws IllegalStateException if there are no keys, or if there is a mix between watching and non-watching keys.
     ;;
    #_method
    (defn #_"boolean" Wallet''is-watching [#_"Wallet" this]
        (sync (:keychaingroup-lock this)
            (KeyChainGroup''is-watching (:key-chain-group this))
        )
    )

    ;;;
     ; Locates a keypair from the basicKeyChain given the hash of the public key.  This is needed when finding out
     ; which key we need to use to redeem a transaction output.
     ;
     ; @return ECKey object or null if no such key was found.
     ;;
    #_override
    (defn #_"ECKey" KeyBag'''find-key-from-pub-hash [#_"Wallet" this, #_"byte[]" hash]
        (sync (:keychaingroup-lock this)
            (KeyBag'''find-key-from-pub-hash (:key-chain-group this), hash)
        )
    )

    ;;;
     ; Returns true if the given key is in the wallet, false otherwise.  Currently an O(N) operation.
     ;;
    #_method
    (defn #_"boolean" Wallet''has-key [#_"Wallet" this, #_"ECKey" key]
        (sync (:keychaingroup-lock this)
            (KeyChainGroup''has-key (:key-chain-group this), key)
        )
    )

    ;;;
     ; Returns true if this wallet contains a public key which hashes to the given hash.
     ;;
    #_method
    (defn #_"boolean" Wallet''is-pub-key-hash-mine [#_"Wallet" this, #_"byte[]" hash]
        (some? (KeyBag'''find-key-from-pub-hash this, hash))
    )

    ;;;
     ; Locates a keypair from the basicKeyChain given the raw public key bytes.
     ;
     ; @return ECKey or null if no such key was found.
     ;;
    #_override
    (defn #_"ECKey" KeyBag'''find-key-from-pub-key [#_"Wallet" this, #_"byte[]" pubkey]
        (sync (:keychaingroup-lock this)
            (KeyBag'''find-key-from-pub-key (:key-chain-group this), pubkey)
        )
    )

    ;;;
     ; Returns true if this wallet contains a keypair with the given public key.
     ;;
    #_method
    (defn #_"boolean" Wallet''is-pub-key-mine [#_"Wallet" this, #_"byte[]" pubkey]
        (some? (KeyBag'''find-key-from-pub-key this, pubkey))
    )

    ;;;
     ; Locates a redeem data (redeem script and keys) from the keyChainGroup given the hash of the script.
     ;
     ; @return RedeemData object or null if no such data was found.
     ;;
    #_override
    (defn #_"RedeemData" KeyBag'''find-redeem-data-from-script-hash [#_"Wallet" this, #_"byte[]" hash]
        (sync (:keychaingroup-lock this)
            (KeyBag'''find-redeem-data-from-script-hash (:key-chain-group this), hash)
        )
    )

    ;;;
     ; Returns true if this wallet knows the script corresponding to the given hash.
     ;;
    #_method
    (defn #_"boolean" Wallet''is-pay-to-script-hash-mine [#_"Wallet" this, #_"byte[]" hash]
        (some? (KeyBag'''find-redeem-data-from-script-hash this, hash))
    )

    ;;;
     ; Marks all keys used in the transaction output as used in the wallet.
     ; See {@link DeterministicKeyChain#markKeyAsUsed(DeterministicKey)} for more info on this.
     ;;
    #_method
    (defn- #_"Wallet" Wallet''mark-keys-as-used [#_"Wallet" this, #_"Transaction" tx]
        (sync (:keychaingroup-lock this)
            (doseq [#_"TransactionOutput" output (:outputs tx)]
                (try+
                    (let [#_"Script" script (TransactionOutput''parse-script-pub-key output)]
                        (cond
                            (Script''is-sent-to-raw-pub-key script)
                                (let [#_"byte[]" pubkey (Script''get-pub-key script)]
                                    (KeyChainGroup''mark-pub-key-as-used (:key-chain-group this), pubkey)
                                )
                            (Script''is-sent-to-address script)
                                (let [#_"byte[]" hash (Script''get-pub-key-hash script)]
                                    (KeyChainGroup''mark-pub-key-hash-as-used (:key-chain-group this), hash)
                                )
                            (Script''is-pay-to-script-hash script)
                                (let [#_"Address" addr (Address'from-p2sh-script (:ledger tx), script)]
                                    (ยง ass this (update this :key-chain-group KeyChainGroup''mark-p2sh-address-as-used addr))
                                )
                        )
                    )
                    (ยง catch ScriptException e
                        ;; Just means we didn't understand the output of this transaction: ignore it.
                        (log/warn e, "Could not parse tx output script")
                    )
                )
            )
            this
        )
    )

    ;;;
     ; Returns the immutable seed for the current active HD chain.
     ;
     ; @throws ECKey.MissingPrivateKeyException if the seed is unavailable (watching wallet).
     ;;
    #_method
    (defn #_"DeterministicSeed" Wallet''get-key-chain-seed [#_"Wallet" this]
        (sync (:keychaingroup-lock this)
            (let [#_"DeterministicSeed" seed (DeterministicKeyChain''get-seed (KeyChainGroup''get-active-key-chain (:key-chain-group this)))]
                (or seed (throw+ (MissingPrivateKeyException'new)))
            )
        )
    )

    ;;;
     ; Returns a key for the given HD path, assuming it's already been derived.  You normally shouldn't use this:
     ; use currentReceiveKey/freshReceiveKey instead.
     ;;
    #_method
    (defn #_"DeterministicKey" Wallet''get-key-by-path-2 [#_"Wallet" this, #_"[ChildNumber]" path]
        (sync (:keychaingroup-lock this)
            (DeterministicKeyChain''get-key-by-path-3 (KeyChainGroup''get-active-key-chain (:key-chain-group this)), path, false)
        )
    )

    #_throws #_[ "IOException" ]
    #_method
    (defn #_"void" Wallet''save [#_"Wallet" __]
        nil
    )

    ;;;
     ; Requests an asynchronous save on a background thread.
     ;;
    #_method
    (defn #_"void" Wallet''save-later [#_"Wallet" __]
        nil
    )

    ;;;
     ; If auto saving is enabled, do an immediate sync write to disk ignoring any delays.
     ;;
    #_method
    (defn #_"void" Wallet''save-now [#_"Wallet" __]
        nil
    )

    ;;;
     ; Returns if this wallet is structurally consistent, so e.g. no duplicate transactions.
     ; First inconsistency and a dump of the wallet will be logged.
     ;;
    #_method
    (defn #_"boolean" Wallet''is-consistent [#_"Wallet" this]
        (try
            (Wallet''is-consistent-or-throw this)
            true
            (catch IllegalStateException e
                (log/error (.getMessage e))
                (try
                    (log/error this)
                    (catch RuntimeException e'
                        (log/error e', "Printing inconsistent wallet failed")
                    )
                )
                false
            )
        )
    )

    ;;;
     ; Variant of {@link Wallet#isConsistent()} that throws an {@link IllegalStateException} describing
     ; the first inconsistency.
     ;;
    #_throws #_[ "IllegalStateException" ]
    #_method
    (defn #_"void" Wallet''is-consistent-or-throw [#_"Wallet" this]
        (sync (:wallet-lock this)
            (let [#_"Set<Transaction>" transactions (Wallet''get-transactions this, true) #_"Set<Sha256Hash>" hashes (HashSet.)]
                (doseq [#_"Transaction" tx transactions]
                    (ยง ass hashes (.add hashes, (Transaction''get-hash tx)))
                )

                (let [#_"int" size1 (count transactions)]
                    (when-not (= size1 (count hashes))
                        (throw (IllegalStateException. "Two transactions with same hash"))
                    )

                    (let [#_"int" size2 (+ (count (:unspent this)) (count (:spent this)) (count (:pending this)) (count (:dead this)))]
                        (when-not (= size1 size2)
                            (throw (IllegalStateException. (str "Inconsistent wallet sizes: " size1 ", " size2)))
                        )

                        (doseq [#_"Transaction" tx (.values (:unspent this))]
                            (when-not (Wallet''is-tx-consistent this, tx, false)
                                (throw (IllegalStateException. (str "Inconsistent unspent tx: " (Transaction''get-hash tx))))
                            )
                        )

                        (doseq [#_"Transaction" tx (.values (:spent this))]
                            (when-not (Wallet''is-tx-consistent this, tx, true)
                                (throw (IllegalStateException. (str "Inconsistent spent tx: " (Transaction''get-hash tx))))
                            )
                        )
                    )
                )
            )
        )
        nil
    )

    ;; If isSpent, check that all my outputs spent, otherwise check that there at least one unspent.
    #_testing
    #_method
    (defn #_"boolean" Wallet''is-tx-consistent [#_"Wallet" this, #_"Transaction" tx, #_"boolean" spent?]
        (loop-when [#_"boolean" actually? true #_"TransactionOutput*" outputs (:outputs tx)] (seq outputs) => (= actually? spent?)
            (let [#_"TransactionOutput" output (first outputs)
                  actually?
                    (if (TransactionOutput''is-available-for-spending output)
                        (let [actually?
                                (when (TransactionOutput''is-mine output, this) => actually?
                                    false
                                )]
                            (when-not (some? (:spent-by output))
                                actually?
                            )
                        )
                        (when (some? (:spent-by output))
                            actually?
                        )
                    )]
                (recur-if (some? actually?) [actually? (next outputs)] => (do (log/error "isAvailableForSpending != spentBy") false))
            )
        )
    )

    ;;;
     ; Called by the {@link SPVBlockChain} when we receive a new filtered block that contains a transactions previously
     ; received by a call to {@link #receivePending}.
     ;
     ; This is necessary for the internal book-keeping Wallet does.  When a transaction is received that sends us
     ; coins it is added to a pool so we can use it later to create spends.  When a transaction is received that
     ; consumes outputs they are marked as spent so they won't be used in future.
     ;
     ; A transaction that spends our own coins can be received either because a spend we created was accepted by
     ; the network and thus made it into a block, or because our keys are being shared between multiple instances
     ; and some other node spent the coins instead.  We still have to know about that to avoid accidentally trying
     ; to double spend.
     ;
     ; A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.  We must still record these transactions and the blocks they appear in because a future
     ; block might change which chain is best causing a reorganize.  A re-org can totally change our balance!
     ;;
    #_throws #_[ "VerificationException" ]
    #_override
    (defn #_"boolean" TransactionReceivedInBlockListener'''notify-transaction-is-in-block [#_"Wallet" this, #_"Sha256Hash" hash, #_"StoredBlock" block, #_"NewBlockType" type, #_"int" offset]
        (sync (:wallet-lock this)
            (let [#_"Transaction" tx
                    (or (get (:transactions this) hash)
                        (let [tx (get (:risk-dropped this) hash)]
                            (when (some? tx)
                                ;; If this happens our risk analysis is probably wrong and should be improved.
                                (log/info (str "Risk analysis dropped tx " (Transaction''get-hash tx) " but was included in block anyway"))
                                ;; Else false positive that was broadcast to us and ignored by us because it was irrelevant to our keys.
                            )
                            tx
                        )
                    )]
                (when (some? tx) => false
                    (ยง ass this (Wallet''receive this, tx, block, type, offset))
                    true
                )
            )
        )
    )

    ;;;
     ; Called when we have found a transaction (via network broadcast or otherwise) that is relevant to this wallet
     ; and want to record it.  Note that we <b>cannot verify these transactions at all</b>, they may spend fictional
     ; coins or be otherwise invalid.  They are useful to inform the user about coins they can expect to receive soon,
     ; and if you trust the sender of the transaction you can choose to assume they are in fact valid and will not
     ; be double spent as an optimization.
     ;
     ; This is the same as {@link Wallet#receivePending(Transaction, java.util.List)} but allows you to override the
     ; {@link Wallet#isPendingTransactionRelevant(Transaction)} sanity-check to keep track of transactions that are not
     ; spendable or spend our coins.  This can be useful when you want to keep track of transaction confidence on
     ; arbitrary transactions.  Note that transactions added in this way will still be relayed to peers and appear in
     ; transaction lists like any other pending transaction (even when not relevant).
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn #_"void" Wallet''receive-pending-4 [#_"Wallet" this, #_"Transaction" tx, #_"List<Transaction>" dependencies, #_"boolean" relevant?]
        ;; Can run in a peer thread.  This method will only be called if a prior call to isPendingTransactionRelevant returned true,
        ;; so we already know by this point that it sends coins to or from our wallet, or is a double spend against one of our
        ;; other pending transactions.
        (sync (:wallet-lock this)
            (Transaction''verify tx)
            ;; Ignore it if we already know about this transaction.  Receiving a pending transaction never moves it between pools.
            (if (seq (Wallet''get-containing-pools this, tx))
                (log/debug (str "Received tx we already saw in a block or created ourselves: " (Transaction''get-hash tx)))
                ;; Repeat the check of relevancy here, even though the caller may have already done so - this is to avoid
                ;; race conditions where receivePending may be being called in parallel.
                (when (or relevant? (Wallet''is-pending-transaction-relevant this, tx))
                    (if (and (Wallet''is-transaction-risky this, tx, dependencies) (not (:accept-risky-transactions this)))
                        (do
                            ;; isTransactionRisky already logged the reason.
                            (ยง ass this (update this :risk-dropped assoc (Transaction''get-hash tx) tx))
                            (log/warn (str "There are now " (count (:risk-dropped this)) " risk dropped transactions being kept in memory"))
                        )
                        (let [#_"Coin" earned (Transaction''get-value-sent-to-me tx, this) #_"Coin" spent (Transaction''get-value-sent-from-me tx, this)]
                            (log/info (str "Received a pending transaction " (Transaction''get-hash tx) " that spends " (Coin''to-friendly-string spent) " from our own wallet, and sends us " (Coin''to-friendly-string earned)))
                            (when (= (:confidence-source (Transaction''get-confidence tx)) :ConfidenceSource'UNKNOWN)
                                (log/warn "Wallet received transaction with an unknown source.  Consider tagging it!")
                            )
                            ;; If this tx spends any of our unspent outputs, mark them as spent now, then add to the pending pool.
                            ;; This ensures that if some other client that has our keys broadcasts a spend we stay in sync.
                            ;; Also updates the timestamp on the transaction and registers/runs event listeners.
                            (ยง ass [this tx] (Wallet''commit-tx this, tx))
                        )
                    )
                )
            )
        )
        ;; maybeRotateKeys() will ignore pending transactions, so we don't bother calling it here (see the comments
        ;; in that function for an explanation of why).
        nil
    )

    ;;;
     ; Given a transaction and an optional list of dependencies (recursive/flattened), returns true if the given
     ; transaction would be rejected by the analyzer, or false otherwise.  The result of this call is independent
     ; of the value of {@link #isAcceptRiskyTransactions()}.  Risky transactions yield a logged warning.  If you
     ; want to know the reason why a transaction is risky, create an instance of {@link RiskAnalysis} yourself
     ; and use it directly.
     ;;
    #_method
    (defn #_"boolean" Wallet''is-transaction-risky [#_"Wallet" this, #_"Transaction" tx, #_"List<Transaction>" dependencies]
        (sync (:wallet-lock this)
            (let [#_"RiskAnalysis" analysis (RiskAnalysis'new this, tx, (or dependencies (ImmutableList/of)))]
                (when-not (= (RiskAnalysis''analyze analysis) :RiskAnalysisResult'OK) => false
                    (log/warn (str "Pending transaction was considered risky: " analysis "\n" tx))
                    true
                )
            )
        )
    )

    ;;;
     ; Called when we have found a transaction (via network broadcast or otherwise) that is relevant to this wallet
     ; and want to record it.  Note that we <b>cannot verify these transactions at all</b>, they may spend fictional
     ; coins or be otherwise invalid.  They are useful to inform the user about coins they can expect to receive soon,
     ; and if you trust the sender of the transaction you can choose to assume they are in fact valid and will not
     ; be double spent as an optimization.
     ;
     ; Before this method is called, {@link Wallet#isPendingTransactionRelevant(Transaction)} should have been
     ; called to decide whether the wallet cares about the transaction - if it does, then this method expects the
     ; transaction and any dependencies it has which are still in the memory pool.
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn #_"void" Wallet''receive-pending-3 [#_"Wallet" this, #_"Transaction" tx, #_"List<Transaction>" dependencies]
        (Wallet''receive-pending-4 this, tx, dependencies, false)
        nil
    )

    ;;;
     ; This method is used by a {@link Peer} to find out if a transaction that has been announced is interesting,
     ; that is, whether we should bother downloading its dependencies and exploring the transaction to decide how
     ; risky it is.  If this method returns true then {@link Wallet#receivePending(Transaction, java.util.List)}
     ; will soon be called with the transactions dependencies as well.
     ;;
    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"boolean" Wallet''is-pending-transaction-relevant [#_"Wallet" this, #_"Transaction" tx]
        (sync (:wallet-lock this)
            ;; Ignore it if we already know about this transaction.  Receiving a pending transaction never moves it between pools.
            (cond
                (seq (Wallet''get-containing-pools this, tx))
                    (do
                        (log/debug (str "Received tx we already saw in a block or created ourselves: " (Transaction''get-hash tx)))
                        false
                    )
                ;; We only care about transactions that:
                ;;   - Send us coins.
                ;;   - Spend our coins.
                ;;   - Double spend a tx in our wallet.
                (not (Wallet''is-transaction-relevant this, tx))
                    (do
                        (log/debug "Received tx that isn't relevant to this wallet, discarding.")
                        false
                    )
                :else
                    true
            )
        )
    )

    ;;;
     ; Returns true if the given transaction sends coins to any of our keys, or has inputs spending any of our outputs,
     ; and also returns true if tx has inputs that are spending outputs which are
     ; not ours but which are spent by pending transactions.
     ;
     ; Note that if the tx has inputs containing one of our keys, but the connected transaction is not in the wallet,
     ; it will not be considered relevant.
     ;;
    #_throws #_[ "ScriptException" ]
    #_method
    (defn #_"boolean" Wallet''is-transaction-relevant [#_"Wallet" this, #_"Transaction" tx]
        (sync (:wallet-lock this)
            (or (Coin''positive? (Transaction''get-value-sent-from-me tx, this))
                (Coin''positive? (Transaction''get-value-sent-to-me tx, this))
                (seq (Wallet''find-double-spends-against this, tx, (:transactions this))))
        )
    )

    ;;;
     ; Finds transactions in the specified candidates that double spend "tx".  Not a general check, but it can work even
     ; if the double spent inputs are not ours.
     ;
     ; @return the set of transactions that double spend "tx".
     ;;
    #_method
    (defn- #_"Set<Transaction>" Wallet''find-double-spends-against [#_"Wallet" this, #_"Transaction" tx, #_"Map<Sha256Hash, Transaction>" candidates]
        (assert-state (.isHeldByCurrentThread (:wallet-lock this)))

        (if (Transaction''is-coin-base tx)
            (HashSet.)

            ;; Compile a set of outpoints that are spent by tx.
            (let [#_"HashSet<TransactionOutPoint>" outpoints (HashSet.)]
                (doseq [#_"TransactionInput" input (:inputs tx)]
                    (ยง ass outpoints (.add outpoints, (:outpoint input)))
                )

                ;; Now for each pending transaction, see if it shares any outpoints with this tx.
                (let [#_"Set<Transaction>" __doubleSpendTxns (HashSet.)]
                    (doseq [#_"Transaction" ty (.values candidates)]
                        (when-not (.equals ty, tx)
                            (doseq [#_"TransactionInput" input (:inputs ty)]
                                ;; This relies on the fact that TransactionOutPoint equality is defined at the protocol, not object
                                ;; level - outpoints from two different inputs that point to the same output compare the same.
                                (let [#_"TransactionOutPoint" outpoint (:outpoint input)]
                                    ;; If does, it's a double spend against the candidates, which makes it relevant.
                                    (when (contains? outpoints outpoint)
                                        (ยง ass __doubleSpendTxns (.add __doubleSpendTxns, ty))
                                    )
                                )
                            )
                        )
                    )
                    __doubleSpendTxns
                )
            )
        )
    )

    ;;;
     ; Adds to txSet all the txns in txPool spending outputs of txns in txSet,
     ; and all txns spending the outputs of those txns, recursively.
     ;;
    #_method
    (defn #_"Wallet" Wallet''add-transactions-depending-on [#_"Wallet" this, #_"Set<Transaction>" __txSet, #_"Set<Transaction>" pool]
        (let [#_"Map<Sha256Hash, Transaction>" queue (LinkedHashMap.)]
            (doseq [#_"Transaction" tx __txSet]
                (ยง ass queue (assoc queue (Transaction''get-hash tx) tx))
            )
            (while (seq queue)
                (let [#_"Transaction" tx (ยง ass queue (.remove queue, (.next (.iterator (.keySet queue)))))]
                    (doseq [#_"Transaction" ty pool]
                        (when-not (.equals ty, tx)
                            (doseq [#_"TransactionInput" input (:inputs ty)]
                                (when (= (:from-tx-hash (:outpoint input)) (Transaction''get-hash tx))
                                    (let-when [#_"Sha256Hash" hy (Transaction''get-hash ty)] (nil? (get queue hy))
                                        (ยง ass queue (assoc queue hy ty))
                                        (ยง ass __txSet (.add __txSet, ty))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
        this
    )

    ;;;
     ; Called by the {@link SPVBlockChain} when we receive a new block that sends coins to one of our addresses or
     ; spends coins from one of our addresses (note that a single transaction can do both).
     ;
     ; This is necessary for the internal book-keeping Wallet does.  When a transaction is received that sends us
     ; coins it is added to a pool so we can use it later to create spends.  When a transaction is received that
     ; consumes outputs they are marked as spent so they won't be used in future.
     ;
     ; A transaction that spends our own coins can be received either because a spend we created was accepted by
     ; the network and thus made it into a block, or because our keys are being shared between multiple instances
     ; and some other node spent the coins instead.  We still have to know about that to avoid accidentally trying
     ; to double spend.
     ;
     ; A transaction may be received multiple times if is included into blocks in parallel chains.  The blockType
     ; parameter describes whether the containing block is on the main/best chain or whether it's on a presently
     ; inactive side chain.  We must still record these transactions and the blocks they appear in because a future
     ; block might change which chain is best causing a reorganize.  A re-org can totally change our balance!
     ;;
    #_throws #_[ "VerificationException" ]
    #_override
    (defn #_"Wallet" TransactionReceivedInBlockListener'''receive-from-block [#_"Wallet" this, #_"Transaction" tx, #_"StoredBlock" block, #_"NewBlockType" type, #_"int" offset]
        (sync (:wallet-lock this)
            (when (Wallet''is-transaction-relevant this, tx) => this
                (Wallet''receive this, tx, block, type, offset)
            )
        )
    )

    #_throws #_[ "VerificationException" ]
    #_method
    (defn- #_"Wallet" Wallet''receive [#_"Wallet" this, #_"Transaction" tx, #_"StoredBlock" block, #_"NewBlockType" type, #_"int" offset]
        ;; Runs in a peer thread.
        (assert-state (.isHeldByCurrentThread (:wallet-lock this)))

        (let [#_"Coin" before (Wallet''get-balance-2t this, :BalanceType'AVAILABLE)
              #_"Sha256Hash" __txHash (Transaction''get-hash tx)
              #_"boolean" best? (= type :NewBlockType'BEST_CHAIN)
              #_"boolean" side? (= type :NewBlockType'SIDE_CHAIN)
              #_"Coin" spent (Transaction''get-value-sent-from-me tx, this)
              #_"Coin" earned (Transaction''get-value-sent-to-me tx, this)
              #_"Coin" difference (Coin''subtract earned, spent)]

            (log/info (str "Received tx" (if side? " on a side chain" "") " for " (Coin''to-friendly-string difference) ": " __txHash " [" offset "] in block " (if (some? block) (Block''get-hash (:stored-header block)) "(unit test)")))

            ;; Inform the key chains that the issued keys were observed in a transaction, so they know to
            ;; calculate more keys for the next Bloom filters.
            (let [this (Wallet''mark-keys-as-used this, tx)
                  this (update this :on-wallet-changed-suppressions inc)
                  ;; If this transaction is already in the wallet, we may need to move it into a different pool.
                  ;; At the very least we need to ensure we're manipulating the canonical object rather than a duplicate.
                  tx (or (get (:transactions this) __txHash) tx)
                  #_"boolean" pending? (some? (ยง ass this (update this :pending .remove __txHash)))]
                (when pending?
                    (log/info "  <-pending")
                )

                (let [this
                        (cond best?
                            (let [#_"boolean" dead? (some? (ยง ass this (update this :dead .remove __txHash)))]
                                (when dead?
                                    (log/info "  <-dead")
                                )
                                (when pending?
                                    ;; Was pending and is now confirmed.  Disconnect the outputs in case we spent any already:
                                    ;; they will be re-connected by processTxFromBestChain below.
                                    (doseq [#_"TransactionOutput" output (:outputs tx)]
                                        (when-let [#_"TransactionInput" __spentBy (:spent-by output)]
                                            (let [#_"boolean" added? (ยง ass this (update this :my-unspents .add output))]
                                                (assert-state added?)
                                                (TransactionInput''disconnect __spentBy)
                                            )
                                        )
                                    )
                                )
                                (Wallet''process-tx-from-best-chain this, tx, (or pending? dead?))
                            )
                            :else
                            (do
                                (assert-state side?)
                                ;; Transactions that appear in a side chain will have that appearance recorded below - we assume
                                ;; that some miners are also trying to include the transaction into the current best chain too,
                                ;; so let's treat it as pending, except we don't need to do any risk analysis on it.
                                (if pending?
                                    (do
                                        ;; Just put it back in without touching the connections or confidence.
                                        (ยง ass this (Wallet''add-wallet-transaction this, :PoolType'PENDING, tx))
                                        (log/info "  ->pending")
                                    )
                                    ;; Ignore the case where a tx appears on a side chain at the same time as the best chain
                                    ;; (this is quite normal and expected).
                                    (let [#_"Sha256Hash" hash (Transaction''get-hash tx)]
                                        (when-not (or (contains? (:unspent this) hash) (contains? (:spent this) hash) (contains? (:dead this) hash))
                                            ;; Otherwise put it (possibly back) into pending.
                                            ;; Committing it updates the spent flags and inserts into the pool as well.
                                            (ยง ass [this tx] (Wallet''commit-tx this, tx))
                                        )
                                    )
                                )
                                this
                            )
                        )
                      this
                        (when (some? block) => this
                            ;; Mark the tx as appearing in this block so we can find it later after a re-org.  This also tells
                            ;; the tx confidence object about the block and sets its depth appropriately.
                            (ยง ass tx (Transaction''set-block-appearance tx, block, best?, offset))
                            (when best?
                                ;; Don't notify this tx of work done in notifyNewBestBlock which will be called immediately
                                ;; after this method has been called by SPVBlockChain for all relevant transactions.  Otherwise
                                ;; we'd double count.
                                (ยง ass this (update this :ignore-next-new-block .add __txHash))

                                ;; When a tx is received from the best chain, if other txns that spend this tx are IN_CONFLICT,
                                ;; change its confidence to PENDING (Unless they are also spending other txns IN_CONFLICT).
                                ;; Consider dependency chains.
                                (let [#_"Set<Transaction>" deps (HashSet. (Collections/singleton tx))]
                                    (ยง ass this (Wallet''add-transactions-depending-on this, deps, (Wallet''get-transactions this, true)))
                                    (ยง ass deps (.remove deps, tx))
                                    (doseq [#_"Transaction" dep (Wallet''sort-txns-by-dependency this, deps)]
                                        (when (and (= (:confidence-type (Transaction''get-confidence dep)) :ConfidenceType'IN_CONFLICT)
                                              (not (Wallet''is-spending-txns-in-confidence-type this, dep, :ConfidenceType'IN_CONFLICT)))
                                            (ยง ass (Transaction''get-confidence dep) (TransactionConfidence''set-confidence-type (Transaction''get-confidence dep), :ConfidenceType'PENDING))
                                            (ยง ass this (update this :confidence-changed assoc dep :ConfidenceChangeReason'TYPE))
                                        )
                                    )
                                )
                            )
                            this
                        )
                      this (update this :on-wallet-changed-suppressions dec)]

                    ;; Side chains don't affect confidence.
                    (if best?
                        ;; notifyNewBestBlock will be invoked next and will then call maybeQueueOnWalletChanged for us.
                        (ยง ass this (update this :confidence-changed assoc tx :ConfidenceChangeReason'TYPE))
                        (Wallet''maybe-queue-on-wallet-changed this)
                    )

                    ;; Inform anyone interested that we have received or sent coins but only if:
                    ;;  - This is not due to a re-org.
                    ;;  - The coins appeared on the best chain.
                    ;;  - We did in fact receive some new money.
                    ;;  - We have not already informed the user about the coins when we received the tx broadcast,
                    ;;    or for our own spends.  If users want to know when a broadcast tx becomes confirmed,
                    ;;    they need to use tx confidence listeners.
                    (when (and (not (:inside-reorg this)) best?)
                        (let [#_"Coin" after (Wallet''get-balance-2t this, :BalanceType'AVAILABLE)] ;; This is slow.
                            (log/info (str "Balance is now: " (Coin''to-friendly-string after)))
                            (when-not pending?
                                ;; We pick one callback based on the value difference, though a tx can of course both
                                ;; send and receive coins from the wallet.
                                (cond
                                    (Coin''positive? difference) (Wallet''queue-on-coins-received this, tx, before, after)
                                    (Coin''negative? difference) (Wallet''queue-on-coins-sent this, tx, before, after)
                                )
                            )
                            (Wallet''check-balance-futures-locked this)
                        )
                    )

                    (Wallet''inform-confidence-listeners-if-not-reorganizing this)
                    (Wallet''is-consistent-or-throw this)
                    ;; Optimization for the case where a block has tons of relevant transactions.
                    (Wallet''save-later this)
                    (assoc this :hard-save-on-next-block true)
                )
            )
        )
    )

    ;;;
     ; Finds if tx is spending other txns which are in the specified confidence type.
     ;;
    #_method
    (defn- #_"boolean" Wallet''is-spending-txns-in-confidence-type [#_"Wallet" this, #_"Transaction" tx, #_"ConfidenceType" type]
        (->> (:inputs tx)
             (map #(Wallet''get-transaction this, (:from-tx-hash (:outpoint %))))
             (some #(and (some? %) (= (:confidence-type (Transaction''get-confidence %)), type)))
        )
    )

    ;;;
     ; Creates and returns a new List with the same txns as inputSet, but txns are sorted by depencency
     ; (a topological sort).  If tx B spends tx A, then tx A should be before tx B on the returned List.
     ; Several invocations to this method with the same inputSet could result in lists with txns in different
     ; order, as there is no guarantee on the order of the returned txns besides what was already stated.
     ;;
    #_method
    (defn #_"List<Transaction>" Wallet''sort-txns-by-dependency [#_"Wallet" this, #_"Set<Transaction>" txns]
        (let [#_"List<Transaction>" result (ArrayList. txns)]
            (loop-when-recur [#_"int" i 0] (< (inc i) (count result)) [(inc i)]
                (loop []
                    (let [#_"boolean" spends?
                            (loop-when [#_"int" j (inc i)] (< j (count result)) => false
                                (when (Wallet''spends this, (nth result i), (nth result j)) => (recur (inc j))
                                    (ยง ass result (.add result, j, (ยง ass result (.remove result, i))))
                                    true
                                )
                            )]
                        (recur-if spends? [])
                    )
                )
            )
            result
        )
    )

    ;;; Finds whether txA spends txB. ;;
    #_method
    (defn #_"boolean" Wallet''spends [#_"Wallet" __, #_"Transaction" a, #_"Transaction" b]
        (boolean (some #(= (:from-tx-hash (:outpoint %)) (Transaction''get-hash b)) (:inputs a)))
    )

    #_method
    (defn- #_"void" Wallet''inform-confidence-listeners-if-not-reorganizing [#_"Wallet" this]
        (when-not (:inside-reorg this)
            (doseq [#_"Map.Entry<Transaction, ConfidenceChangeReason>" entry (.entrySet (:confidence-changed this))]
                (let [#_"Transaction" tx (.getKey entry)]
                    (TransactionConfidence''queue-listeners (Transaction''get-confidence tx), (.getValue entry))
                    (Wallet''queue-on-transaction-confidence-changed this, tx)
                )
            )
            (ยง ass this (update this :confidence-changed empty))
        )
        nil
    )

    ;;;
     ; Called by the {@link SPVBlockChain} when a new block on the best chain is seen, AFTER relevant wallet
     ; transactions are extracted and sent to us UNLESS the new block caused a re-org, in which case this will
     ; not be called (the {@link Wallet#reorganize(StoredBlock, java.util.List, java.util.List)} method will
     ; call this one in that case).
     ;
     ; Used to update confidence data in each transaction and last seen block hash.  Triggers auto saving.
     ; Invokes the onWalletChanged event listener if there were any affected transactions.
     ;;
    #_throws #_[ "VerificationException" ]
    #_override
    (defn #_"Wallet" NewBestBlockListener'''notify-new-best-block [#_"Wallet" this, #_"StoredBlock" block]
        ;; Check to see if this block has been seen before.
        (let [#_"Sha256Hash" __newBlockHash (Block''get-hash (:stored-header block))]
            (when-not (= __newBlockHash (Wallet''get-last-block-seen-hash this)) => this
                (sync (:wallet-lock this)
                    ;; Store the new block hash.
                    (let [this (assoc this :last-block-seen-hash __newBlockHash)
                          this (assoc this :last-block-seen-height (:stored-height block))
                          this (assoc this :last-block-seen-time-secs (:time-seconds (:stored-header block)))]

                        ;; Notify all the BUILDING transactions of the new block.
                        ;; This is so that they can update their depth.
                        (doseq [#_"Transaction" tx (Wallet''get-transactions this, true)]
                            (cond (contains? (:ignore-next-new-block this) (Transaction''get-hash tx))
                                    ;; tx was already processed in receive() due to it appearing in this block, so we don't want
                                    ;; to increment the tx confidence depth twice, it'd result in miscounting.
                                    (ยง ass this (update this :ignore-next-new-block .remove (Transaction''get-hash tx)))
                                :else
                                (let [#_"TransactionConfidence" confidence (Transaction''get-confidence tx)]
                                    (when (= (:confidence-type confidence) :ConfidenceType'BUILDING)
                                        ;; Erase the set of seen peers once the tx is so deep that it seems unlikely to ever go
                                        ;; pending again.  We could clear this data the moment a tx is seen in the block chain,
                                        ;; but in cases where the chain re-orgs, this would mean that wallets would perceive a
                                        ;; newly pending tx has zero confidence at all, which would not be right: we expect it to
                                        ;; be included once again.  We could have a separate was-in-chain-and-now-isn't confidence
                                        ;; type, but this way is backwards compatible with existing software, and the new state
                                        ;; probably wouldn't mean anything different to just remembering peers anyway.
                                        (ยง ass confidence (update confidence :depth-in-blocks inc))
                                        (when (< (:event-horizon this) (:depth-in-blocks confidence))
                                            (ยง ass confidence (TransactionConfidence''clear-broadcast-by confidence))
                                        )
                                        (ยง ass this (update this :confidence-changed assoc tx :ConfidenceChangeReason'DEPTH))
                                    )
                                )
                            )
                        )

                        (Wallet''inform-confidence-listeners-if-not-reorganizing this)
                        (Wallet''maybe-queue-on-wallet-changed this)

                        (if (:hard-save-on-next-block this)
                            (do
                                (Wallet''save-now this)
                                (assoc this :hard-save-on-next-block false)
                            )
                            (do
                                ;; Coalesce writes to avoid throttling on disk access when catching up with the chain.
                                (Wallet''save-later this)
                                this
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Handle when a transaction becomes newly active on the best chain, either due to receiving a new block or a
     ; re-org.  Places the tx into the right pool, handles coinbase transactions, handles double-spends and so on.
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn- #_"Wallet" Wallet''process-tx-from-best-chain [#_"Wallet" this, #_"Transaction" tx, #_"boolean" force?]
        (assert-state (.isHeldByCurrentThread (:wallet-lock this)))
        (assert-state (not (contains? (:pending this) (Transaction''get-hash tx))))

        ;; This TX may spend our existing outputs even though it was not pending.  This can happen in unit tests,
        ;; if keys are moved between wallets, if we're catching up to the chain given only a set of keys,
        ;; or if a dead coinbase transaction has moved back onto the main chain.
        (when (and (Transaction''is-coin-base tx) (contains? (:dead this) (Transaction''get-hash tx)))
            ;; There is a dead coinbase tx being received on the best chain.  A coinbase tx is made dead when it moves
            ;; to a side chain but it can be switched back on a reorg and resurrected back to spent or unspent.
            ;; So take it out of the dead pool.  Note that we don't resurrect dependent transactions here, even though
            ;; we could.  Bitcoin Core nodes on the network have deleted the dependent transactions from their mempools
            ;; entirely by this point.  We could and maybe should rebroadcast them so the network remembers and tries
            ;; to confirm them again.  But this is a deeply unusual edge case that due to the maturity rule should never
            ;; happen in practice, thus for simplicities sake we ignore it here.
            (log/info (str "  coinbase tx " (Transaction''get-hash tx) " <-dead: confidence " (:confidence-type (Transaction''get-confidence tx))))
            (ยง ass this (update this :dead .remove (Transaction''get-hash tx)))
        )

        ;; Update tx and other unspent/pending transactions by connecting inputs/outputs.
        (Wallet''update-for-spends this, tx, true)

        ;; Now make sure it ends up in the right pool.  Also, handle the case where this TX is double-spending
        ;; against our pending transactions.  Note that a tx may double spend our pending transactions and also
        ;; send us money/spend our money.
        (let [#_"boolean" __hasOutputsToMe (Coin''positive? (Transaction''get-value-sent-to-me tx, this))
              #_"boolean" __hasOutputsFromMe
                (cond __hasOutputsToMe
                    (let [#_"boolean" spent? (Transaction''is-every-owned-output-spent tx, this)]
                        ;; Needs to go into either unspent or spent (if the outputs were already spent by a pending tx).
                        (log/info (str "  tx " (Transaction''get-hash tx) (if spent? " ->spent (by pending)" " ->unspent")))
                        (ยง ass this (Wallet''add-wallet-transaction this, (if spent? :PoolType'SPENT :PoolType'UNSPENT), tx))
                        false
                    )
                    (Coin''positive? (Transaction''get-value-sent-from-me tx, this))
                    (do
                        ;; Didn't send us any money, but did spend some.  Keep it around for record keeping purposes.
                        (log/info (str "  tx " (Transaction''get-hash tx) " ->spent"))
                        (ยง ass this (Wallet''add-wallet-transaction this, :PoolType'SPENT, tx))
                        true
                    )
                    force?
                    (do
                        ;; Was manually added to pending, so we should keep it to notify the user of confidence information.
                        (log/info (str "  tx " (Transaction''get-hash tx) " ->spent (manually added)"))
                        (ยง ass this (Wallet''add-wallet-transaction this, :PoolType'SPENT, tx))
                        false
                    )
                    :else
                    (do
                        false
                    )
                )]

            ;; Kill txns in conflict with this tx.
            (let [#_"Set<Transaction>" __doubleSpendTxns (Wallet''find-double-spends-against this, tx, (:pending this))
                  this
                    (when (seq __doubleSpendTxns) => this
                        ;; No need to addTransactionsDependingOn(doubleSpendTxns), because killTxns() already kills dependencies.
                        (Wallet''kill-txns this, __doubleSpendTxns, tx)
                    )]
                (when (and (not __hasOutputsToMe) (not __hasOutputsFromMe) (not force?) (seq (Wallet''find-double-spends-against this, tx, (:transactions this))))
                    ;; Disconnect irrelevant inputs (otherwise might cause protobuf serialization issue).
                    (doseq [#_"TransactionInput" input (:inputs tx)]
                        (let [#_"TransactionOutput" output (TransactionInput''get-connected-output input)]
                            (when (and (some? output) (not (TransactionOutput''is-mine output, this)))
                                (TransactionInput''disconnect input)
                            )
                        )
                    )
                )
                this
            )
        )
    )

    ;;;
     ; Updates the wallet by checking if this TX spends any of our outputs, and marking them as spent if so.
     ; If fromChain is true, also checks to see if any pending transaction spends outputs of this transaction and marks
     ; the spent flags appropriately.
     ;
     ; It can be called in two contexts.  One is when we receive a transaction on the best chain but it wasn't pending,
     ; this most commonly happens when we have a set of keys but the wallet transactions were wiped and we are catching
     ; up with the block chain.  It can also happen if a block includes a transaction we never saw at broadcast time.
     ; If this tx double spends, it takes precedence over our pending transactions and the pending tx goes dead.
     ;
     ; The other context it can be called is from {@link Wallet#receivePending(Transaction, java.util.List)},
     ; i.e. we saw a tx be broadcast or one was submitted directly that spends our own coins.  If this tx double spends,
     ; it does NOT take precedence because the winner will be resolved by the miners - we assume that our version will
     ; win, if we are wrong then when a block appears the tx will go dead.
     ;
     ; @param tx The transaction which is being updated.
     ; @param fromChain If true, the tx appeared on the current best chain, if false it was pending.
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn- #_"Wallet" Wallet''update-for-spends [#_"Wallet" this, #_"Transaction" tx, #_"boolean" __fromChain]
        (assert-state (.isHeldByCurrentThread (:wallet-lock this)))
        (when __fromChain
            (assert-state (not (contains? (:pending this) (Transaction''get-hash tx))))
        )

        (doseq [#_"TransactionInput" input (:inputs tx)]
            (let [#_"ConnectionResult" result (TransactionInput''connect-3m input, (:unspent this), :ConnectionMode'ABORT_ON_CONFLICT)
                  result ;; Not found in the unspent map.  Try again with the spent map.
                    (when (= result :ConnectionResult'NO_SUCH_TX) => result
                        (TransactionInput''connect-3m input, (:spent this), :ConnectionMode'ABORT_ON_CONFLICT)
                    )
                  result ;; Not found in the unspent and spent maps.  Try again with the pending map.
                    (when (= result :ConnectionResult'NO_SUCH_TX) => result
                        (TransactionInput''connect-3m input, (:pending this), :ConnectionMode'ABORT_ON_CONFLICT)
                    )]
                (when-not (= result :ConnectionResult'NO_SUCH_TX) ;; Else doesn't spend any of our outputs or is coinbase.
                    (let [#_"TransactionOutput" output (ensure some? (TransactionInput''get-connected-output input))]
                        (cond (= result :ConnectionResult'ALREADY_SPENT)
                            (if __fromChain
                                (do
                                    ;; Can be:
                                    ;; (1) We already marked this output as spent when we saw the pending transaction (most likely).
                                    ;;     Now it's being confirmed of course, we cannot mark it as spent again.
                                    ;; (2) A double spend from chain: this will be handled later by findDoubleSpendsAgainst()/killTxns().
                                    ;;
                                    ;; In any case, nothing to do here.
                                )
                                (do
                                    ;; We saw two pending transactions that double spend each other.  We don't know which will win.
                                    ;; This can happen in the case of bad network nodes that mutate transactions.  Do a hex dump
                                    ;; so the exact nature of the mutation can be examined.
                                    (log/warn "Saw two pending transactions double spend each other")
                                    (log/warn (str "  offending input is input " (.indexOf (:inputs tx), input)))
                                    (log/warn (str (Transaction''get-hash tx) ": " (Base16'encode (Message''to-bytes tx, Transaction''to-wire))))
                                    (let [#_"Transaction" ty (:parent-tx (:spent-by output))]
                                        (log/warn (str (Transaction''get-hash ty) ": " (Base16'encode (Message''to-bytes ty, Transaction''to-wire))))
                                    )
                                )
                            )
                            (= result :ConnectionResult'SUCCESS)
                            (do
                                ;; Otherwise we saw a transaction spend our coins, but we didn't try and spend them ourselves yet.
                                ;; The outputs are already marked as spent by the connect call above, so check if there are any more for
                                ;; us to use.  Move if not.
                                (let [#_"Transaction" connected (ensure some? (TransactionInput''get-connected-transaction input))]
                                    (log/info (str "  marked " (:outpoint input) " as spent by " (Transaction''get-hash tx)))
                                    (ยง ass this (Wallet''maybe-move-pool this, connected, "prevtx"))
                                    ;; Just because it's connected, doesn't mean it's actually ours: sometimes we have total visibility.
                                    (when (TransactionOutput''is-mine output, this)
                                        (assert-state (ยง ass this (update this :my-unspents .remove output)))
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )

        ;; Now check each output and see if there is a pending transaction which spends it.  This shouldn't normally
        ;; ever occur because we expect transactions to arrive in temporal order, but this assumption can be violated
        ;; when we receive a pending transaction from the mempool that is relevant to us, which spends coins that we
        ;; didn't see arrive on the best chain yet.  For instance, because of a chain replay or because of our keys were
        ;; used by another wallet somewhere else.  Also, unconfirmed transactions can arrive from the mempool in more
        ;; or less random order.
        (doseq [#_"Transaction" pending (.values (:pending this)) #_"TransactionInput" input (:inputs pending)]
            (let [#_"ConnectionResult" result (TransactionInput''connect-3t input, tx, :ConnectionMode'ABORT_ON_CONFLICT)]
                (when __fromChain
                    ;; This TX is supposed to have just appeared on the best chain, so its outputs should not be marked
                    ;; as spent yet.  If they are, it means something is happening out of order.
                    (assert-state (not= result :ConnectionResult'ALREADY_SPENT))
                )
                (when (= result :ConnectionResult'SUCCESS)
                    (log/info (str "Connected pending tx input " (Transaction''get-hash pending) ":" (.indexOf (:inputs pending), input)))
                    ;; The unspents map might not have it if we never saw this tx until it was included in the chain
                    ;; and thus becomes spent the moment we become aware of it.
                    (let-when [#_"TransactionOutput" output (TransactionInput''get-connected-output input)] (ยง ass this (update this :my-unspents .remove output))
                        (log/info (str "Removed from UNSPENTS: " output))
                    )
                )
            )
        )

        ;; If the transactions outputs are now all spent,
        ;; it will be moved into the spent pool by the processTxFromBestChain method.
        (when-not __fromChain => this
            (Wallet''maybe-move-pool this, tx, "pendingtx")
        )
    )

    ;; Updates the wallet when a double spend occurs.  overridingTx can be null for the case of coinbases.
    #_method
    (defn- #_"Wallet" Wallet''kill-txns [#_"Wallet" this, #_"Set<Transaction>" __txnsToKill, #_"Transaction" __overridingTx]
        (let [#_"LinkedList<Transaction>" work (LinkedList. __txnsToKill)]
            (while (seq work)
                (let [#_"Transaction" dead (.poll work) #_"Sha256Hash" hash (Transaction''get-hash dead)]
                    (log/warn (str "TX " hash " killed" (if (some? __overridingTx) (str " by " (Transaction''get-hash __overridingTx)) "")))
                    (log/warn "Disconnecting each input and moving connected transactions.")
                    ;; TX could be pending (finney attack), or in unspent/spent (coinbase killed by reorg).
                    (ยง ass this (update this :pending .remove hash))
                    (ยง ass this (update this :unspent .remove hash))
                    (ยง ass this (update this :spent .remove hash))
                    (ยง ass this (Wallet''add-wallet-transaction this, :PoolType'DEAD, dead))
                    (doseq [#_"TransactionInput" input (:inputs dead)]
                        (when-let [#_"Transaction" zombie (TransactionInput''get-connected-transaction input)]
                            (when-not (= (:confidence-type (Transaction''get-confidence zombie)) :ConfidenceType'DEAD)
                                (let [#_"TransactionOutput" output (TransactionInput''get-connected-output input)]
                                    (when (and (some? (:spent-by output)) (.equals (:spent-by output), input))
                                        (assert-state (ยง ass this (update this :my-unspents .add output)))
                                        (log/info (str "Added to UNSPENTS: " output " in " (Transaction''get-hash (:parent-tx output))))
                                    )
                                )
                            )
                            (TransactionInput''disconnect input)
                            (ยง ass this (Wallet''maybe-move-pool this, zombie, "kill"))
                        )
                    )
                    (ยง ass (Transaction''get-confidence dead) (TransactionConfidence''set-overriding-transaction (Transaction''get-confidence dead), __overridingTx))
                    (ยง ass this (update this :confidence-changed assoc dead :ConfidenceChangeReason'TYPE))
                    ;; Now kill any transactions we have that depended on this one.
                    (doseq [#_"TransactionOutput" output (:outputs dead)]
                        (when (ยง ass this (update this :my-unspents .remove output))
                            (log/info (str "Removed from UNSPENTS: " output))
                        )
                        (when-let [#_"TransactionInput" input (:spent-by output)]
                            (log/info (str "This death invalidated dependent tx " (Transaction''get-hash (:parent-tx input))))
                            (.push work, (:parent-tx input))
                        )
                    )
                )
            )
            (when (some? __overridingTx) => this
                (log/warn "Now attempting to connect the inputs of the overriding transaction.")
                (doseq [#_"TransactionInput" input (:inputs __overridingTx)]
                    (let [#_"ConnectionResult" result (TransactionInput''connect-3m input, (:unspent this), :ConnectionMode'DISCONNECT_ON_CONFLICT)]
                        (if (= result :ConnectionResult'SUCCESS)
                            (let [#_"TransactionOutput" output (TransactionInput''get-connected-output input)]
                                (ยง ass this (Wallet''maybe-move-pool this, (TransactionInput''get-connected-transaction input), "kill"))
                                (ยง ass this (update this :my-unspents .remove output))
                                (log/info (str "Removing from UNSPENTS: " output))
                            )
                            (let [result (TransactionInput''connect-3m input, (:spent this), :ConnectionMode'DISCONNECT_ON_CONFLICT)]
                                (when (= result :ConnectionResult'SUCCESS)
                                    (let [#_"TransactionOutput" output (TransactionInput''get-connected-output input)]
                                        (ยง ass this (Wallet''maybe-move-pool this, (TransactionInput''get-connected-transaction input), "kill"))
                                        (ยง ass this (update this :my-unspents .remove output))
                                        (log/info (str "Removing from UNSPENTS: " output))
                                    )
                                )
                            )
                        )
                    )
                )
                this
            )
        )
    )

    ;;;
     ; If the transactions outputs are all marked as spent, and it's in the unspent map, move it.
     ; If the owned transactions outputs are not all marked as spent, and it's in the spent map, move it.
     ;;
    #_method
    (defn- #_"Wallet" Wallet''maybe-move-pool [#_"Wallet" this, #_"Transaction" tx, #_"String" context]
        (assert-state (.isHeldByCurrentThread (:wallet-lock this)))

        (let [#_"Sha256Hash" hash (Transaction''get-hash tx)]
            (if (Transaction''is-every-owned-output-spent tx, this)
                ;; There's nothing left I can spend in this transaction.
                (when (some? (ยง ass this (update this :unspent .remove hash)))
                    (log/info (str "  " hash " " context " <-unspent ->spent"))
                    (ยง ass this (update this :spent assoc hash tx))
                )
                (when (some? (ยง ass this (update this :spent .remove hash)))
                    (log/info (str "  " hash " " context " <-spent ->unspent"))
                    (ยง ass this (update this :unspent assoc hash tx))
                )
            )
            this
        )
    )

    ;;;
     ; Calls {@link Wallet#commitTx} if tx is not already in the pending pool.
     ;
     ; @return true if the tx was added to the wallet, or false if it was already in the pending pool.
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn #_"[Wallet Transaction boolean]" Wallet''maybe-commit-tx [#_"Wallet" this, #_"Transaction" tx]
        (Transaction''verify tx)
        (sync (:wallet-lock this)
            (let-when [#_"Sha256Hash" hash (Transaction''get-hash tx)] (not (contains? (:pending this) hash)) => [this tx false]
                (log/info (str "commitTx of " hash))
                (let [#_"Coin" balance (Wallet''get-balance-2t this, :BalanceType'AVAILABLE)
                      tx (assoc tx :update-time (Time'now))
                      ;; Put any outputs that are sending money back to us into the unspents map, and calculate their total value.
                      #_"Coin" earned (reduce #(if (TransactionOutput''is-mine %2, this) (Coin''add %1, (:coin-value %2)) %1) Coin'ZERO (:outputs tx))]
                    ;; Mark the outputs we're spending as spent so we won't try and use them in future creations.  This will also move
                    ;; any transactions that are now fully spent to the spent map so we can skip them when creating future spends.
                    (Wallet''update-for-spends this, tx, false)

                    (let [#_"Set<Transaction>" __doublePending (Wallet''find-double-spends-against this, tx, (:pending this))
                          #_"Set<Transaction>" __doubleUnspent (Wallet''find-double-spends-against this, tx, (:unspent this))
                          #_"Set<Transaction>" __doubleSpent (Wallet''find-double-spends-against this, tx, (:spent this))]

                        (cond (or (seq __doubleUnspent) (seq __doubleSpent) (Wallet''is-spending-txns-in-confidence-type this, tx, :ConfidenceType'DEAD))
                            (do
                                ;; tx is a double spend against a tx already in the best chain or spends outputs of a DEAD tx.
                                ;; Add tx to the dead pool and schedule confidence listener notifications.
                                (log/info (str "->dead: " hash))
                                (ยง ass (Transaction''get-confidence tx) (TransactionConfidence''set-confidence-type (Transaction''get-confidence tx), :ConfidenceType'DEAD))
                                (ยง ass this (update this :confidence-changed assoc tx :ConfidenceChangeReason'TYPE))
                                (ยง ass this (Wallet''add-wallet-transaction this, :PoolType'DEAD, tx))
                            )
                            (or (seq __doublePending) (Wallet''is-spending-txns-in-confidence-type this, tx, :ConfidenceType'IN_CONFLICT))
                            (do
                                ;; tx is a double spend against a pending tx or spends outputs of a tx already IN_CONFLICT.
                                ;; Add tx to the pending pool.  Update the confidence type of tx, the txns in conflict with tx
                                ;; and all their dependencies to IN_CONFLICT and schedule confidence listener notifications.
                                (log/info (str "->pending (IN_CONFLICT): " hash))
                                (ยง ass this (Wallet''add-wallet-transaction this, :PoolType'PENDING, tx))
                                (ยง ass __doublePending (.add __doublePending, tx))
                                (ยง ass this (Wallet''add-transactions-depending-on this, __doublePending, (Wallet''get-transactions this, true)))
                                (doseq [#_"Transaction" __doubleSpendTx __doublePending]
                                    (ยง ass (Transaction''get-confidence __doubleSpendTx) (TransactionConfidence''set-confidence-type (Transaction''get-confidence __doubleSpendTx), :ConfidenceType'IN_CONFLICT))
                                    (ยง ass this (update this :confidence-changed assoc __doubleSpendTx :ConfidenceChangeReason'TYPE))
                                )
                            )
                            :else
                            (do
                                ;; No conflict detected.
                                ;; Add to the pending pool and schedule confidence listener notifications.
                                (log/info (str "->pending: " hash))
                                (ยง ass (Transaction''get-confidence tx) (TransactionConfidence''set-confidence-type (Transaction''get-confidence tx), :ConfidenceType'PENDING))
                                (ยง ass this (update this :confidence-changed assoc tx :ConfidenceChangeReason'TYPE))
                                (ยง ass this (Wallet''add-wallet-transaction this, :PoolType'PENDING, tx))
                            )
                        )
                        (log/info (str "Estimated balance is now: " (Coin''to-friendly-string (Wallet''get-balance-2t this, :BalanceType'ESTIMATED))))

                        ;; Mark any keys used in the outputs as "used", this allows wallet UI's to auto-advance
                        ;; the current key they are showing to the user in qr codes etc.
                        (let [this (Wallet''mark-keys-as-used this, tx)
                              #_"Coin" spent (Transaction''get-value-sent-from-me tx, this)
                              #_"Coin" after (Coin''subtract (Coin''add balance, earned), spent)]
                            (when (Coin''positive? earned)
                                (Wallet''check-balance-futures-locked this)
                                (Wallet''queue-on-coins-received this, tx, balance, after)
                            )
                            (when (Coin''positive? spent)
                                (Wallet''queue-on-coins-sent this, tx, balance, after)
                            )
                            (Wallet''maybe-queue-on-wallet-changed this)

                            (Wallet''is-consistent-or-throw this)
                            (Wallet''inform-confidence-listeners-if-not-reorganizing this)
                            (Wallet''save-now this)
                            [this tx true]
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Updates the wallet with the given transaction: puts it into the pending pool, sets the spent flags
     ; and runs the onCoinsSent/onCoinsReceived event listener.  Used in two situations:
     ;
     ; - When we have just successfully transmitted the tx we created to the network.
     ; - When we receive a pending transaction that didn't appear in the chain yet, and we did not create it.
     ;
     ; Triggers an auto save.
     ;;
    #_throws #_[ "VerificationException" ]
    #_method
    (defn #_"[Wallet Transaction]" Wallet''commit-tx [#_"Wallet" this, #_"Transaction" tx]
        (let [[this tx success?] (Wallet''maybe-commit-tx this, tx)]
            (assert-argument success?, "commitTx called on the same transaction twice")
        )
        [this tx]
    )

    #_method
    (defn #_"Wallet" Wallet''add-change-event-listener [#_"Wallet" this, #_"WalletChangeEventListener" listener]
        (append* this :change-listeners listener)
    )

    #_method
    (defn #_"Wallet" Wallet''add-coins-received-event-listener [#_"Wallet" this, #_"WalletCoinsReceivedEventListener" listener]
        (append* this :coins-received-listeners listener)
    )

    #_method
    (defn #_"Wallet" Wallet''add-coins-sent-event-listener [#_"Wallet" this, #_"WalletCoinsSentEventListener" listener]
        (append* this :coins-sent-listeners listener)
    )

    #_method
    (defn #_"Wallet" Wallet''add-key-chain-event-listener [#_"Wallet" this, #_"KeyChainEventListener" listener]
        (update this :key-chain-group KeyChainGroup''add-event-listener listener)
    )

    #_method
    (defn #_"Wallet" Wallet''add-reorganize-event-listener [#_"Wallet" this, #_"WalletReorganizeEventListener" listener]
        (append* this :wallet-reorganize-listeners listener)
    )

    #_method
    (defn #_"Wallet" Wallet''add-transaction-confidence-event-listener [#_"Wallet" this, #_"TransactionConfidenceEventListener" listener]
        (append* this :transaction-confidence-listeners listener)
    )

    #_method
    (defn #_"Wallet" Wallet''remove-change-event-listener [#_"Wallet" this, #_"WalletChangeEventListener" listener]
        (remove* this :change-listeners = listener)
    )

    #_method
    (defn #_"Wallet" Wallet''remove-coins-received-event-listener [#_"Wallet" this, #_"WalletCoinsReceivedEventListener" listener]
        (remove* this :coins-received-listeners = listener)
    )

    #_method
    (defn #_"Wallet" Wallet''remove-coins-sent-event-listener [#_"Wallet" this, #_"WalletCoinsSentEventListener" listener]
        (remove* this :coins-sent-listeners = listener)
    )

    #_method
    (defn #_"Wallet" Wallet''remove-key-chain-event-listener [#_"Wallet" this, #_"KeyChainEventListener" listener]
        (update this :key-chain-group KeyChainGroup''remove-event-listener listener)
    )

    #_method
    (defn #_"Wallet" Wallet''remove-reorganize-event-listener [#_"Wallet" this, #_"WalletReorganizeEventListener" listener]
        (remove* this :wallet-reorganize-listeners = listener)
    )

    #_method
    (defn #_"Wallet" Wallet''remove-transaction-confidence-event-listener [#_"Wallet" this, #_"TransactionConfidenceEventListener" listener]
        (remove* this :transaction-confidence-listeners = listener)
    )

    #_method
    (defn- #_"void" Wallet''queue-on-transaction-confidence-changed [#_"Wallet" this, #_"Transaction" tx]
        (assert-state (.isHeldByCurrentThread (:wallet-lock this)))

        (doseq [#_"TransactionConfidenceEventListener" l (:transaction-confidence-listeners this)]
            (ยง async?
                (TransactionConfidenceEventListener'''on-transaction-confidence-changed l, this, tx)
            )
        )
        nil
    )

    #_method
    (defn #_"void" Wallet''maybe-queue-on-wallet-changed [#_"Wallet" this]
        ;; Don't invoke the callback in some circumstances, e.g. whilst we are re-organizing or fiddling
        ;; with transactions due to a new block arriving.  It will be called later instead.
        (assert-state (.isHeldByCurrentThread (:wallet-lock this)))
        (assert-state (<= 0 (:on-wallet-changed-suppressions this)))

        (when-not (< 0 (:on-wallet-changed-suppressions this))
            (doseq [#_"WalletChangeEventListener" l (:change-listeners this)]
                (ยง async?
                    (WalletChangeEventListener'''on-wallet-changed l, this)
                )
            )
        )
        nil
    )

    #_method
    (defn #_"void" Wallet''queue-on-coins-received [#_"Wallet" this, #_"Transaction" tx, #_"Coin" before, #_"Coin" after]
        (assert-state (.isHeldByCurrentThread (:wallet-lock this)))

        (doseq [#_"WalletCoinsReceivedEventListener" l (:coins-received-listeners this)]
            (ยง async?
                (WalletCoinsReceivedEventListener'''on-coins-received l, this, tx, before, after)
            )
        )
        nil
    )

    #_method
    (defn #_"void" Wallet''queue-on-coins-sent [#_"Wallet" this, #_"Transaction" tx, #_"Coin" before, #_"Coin" after]
        (assert-state (.isHeldByCurrentThread (:wallet-lock this)))

        (doseq [#_"WalletCoinsSentEventListener" l (:coins-sent-listeners this)]
            (ยง async?
                (WalletCoinsSentEventListener'''on-coins-sent l, this, tx, before, after)
            )
        )
        nil
    )

    #_method
    (defn #_"void" Wallet''queue-on-reorganize [#_"Wallet" this]
        (assert-state (.isHeldByCurrentThread (:wallet-lock this)))
        (assert-state (:inside-reorg this))

        (doseq [#_"WalletReorganizeEventListener" l (:wallet-reorganize-listeners this)]
            (ยง async?
                (WalletReorganizeEventListener'''on-reorganize l, this)
            )
        )
        nil
    )

    ;;;
     ; Returns a set of all transactions in the wallet.
     ;
     ; @param includeDead If true, transactions that were overridden by a double spend are included.
     ;;
    #_method
    (defn #_"Set<Transaction>" Wallet''get-transactions [#_"Wallet" this, #_"boolean" dead?]
        (sync (:wallet-lock this)
            (let [#_"Set<Transaction>" all (HashSet.)]
                (ยง ass all (.addAll all, (.values (:unspent this))))
                (ยง ass all (.addAll all, (.values (:spent this))))
                (ยง ass all (.addAll all, (.values (:pending this))))
                (when dead?
                    (ยง ass all (.addAll all, (.values (:dead this))))
                )
                all
            )
        )
    )

    ;;;
     ; Adds the given transaction to the given pools and registers a confidence change listener on it.
     ;;
    #_method
    (defn- #_"Wallet" Wallet''add-wallet-transaction [#_"Wallet" this, #_"PoolType" pool, #_"Transaction" tx]
        (assert-state (.isHeldByCurrentThread (:wallet-lock this)))

        (let [#_"Sha256Hash" hash (Transaction''get-hash tx)]
            (ยง ass this (update this :transactions assoc hash tx))
            (condp = pool
                :PoolType'UNSPENT (assert-state (nil? (ยง ass this (update this :unspent assoc hash tx))))
                :PoolType'SPENT   (assert-state (nil? (ยง ass this (update this :spent assoc hash tx))))
                :PoolType'PENDING (assert-state (nil? (ยง ass this (update this :pending assoc hash tx))))
                :PoolType'DEAD    (assert-state (nil? (ยง ass this (update this :dead assoc hash tx))))
                (throw (RuntimeException. (str "Unknown wallet transaction type " pool)))
            )

            (when (any = pool :PoolType'UNSPENT :PoolType'PENDING)
                (doseq [#_"TransactionOutput" output (:outputs tx)]
                    (when (and (TransactionOutput''is-available-for-spending output) (TransactionOutput''is-mine output, this))
                        (ยง ass this (update this :my-unspents .add output))
                    )
                )
            )
            ;; This is safe even if the listener has been added before, as TransactionConfidence ignores duplicate
            ;; registration requests.  That makes the code in the wallet simpler.
            (ยง ass (Transaction''get-confidence tx) (TransactionConfidence''add-event-listener (Transaction''get-confidence tx), (:tx-confidence-listener this)))
        )
        this
    )

    ;;;
     ; Returns all non-dead, active transactions ordered by recency.
     ;;
    #_method
    (defn #_"List<Transaction>" Wallet''get-transactions-by-time [#_"Wallet" this]
        (Wallet''get-recent-transactions this, 0, false)
    )

    ;;;
     ; Returns an list of N transactions, ordered by increasing age.  Transactions on side chains are not included.
     ; Dead transactions (overridden by double spends) are optionally included.
     ;
     ; Note: the current implementation is O(num transactions in wallet).  Regardless of how many transactions are
     ; requested, the cost is always the same.  In future, requesting smaller numbers of transactions may be faster
     ; depending on how the wallet is implemented (e.g. if backed by a database).
     ;;
    #_method
    (defn #_"List<Transaction>" Wallet''get-recent-transactions [#_"Wallet" this, #_"int" n, #_"boolean" dead?]
        (assert-argument (<= 0 n))

        (sync (:wallet-lock this)
            (let [#_"int" size (+ (count (:unspent this)) (count (:spent this)) (count (:pending this)))
                  n (if (or (< size n) (= n 0)) size n)
                  #_"List<Transaction>" all (ArrayList. (sort Transaction'compare-by-update-time (Wallet''get-transactions this, dead?)))]
                (let-when [#_"int" m (count all)] (< n m)
                    (ยง ass (.subList all, n, m) (.clear (.subList all, n, m)))
                )
                all
            )
        )
    )

    ;;;
     ; Returns a transaction object given its hash, if it exists in this wallet, or null otherwise.
     ;;
    #_method
    (defn #_"Transaction" Wallet''get-transaction [#_"Wallet" this, #_"Sha256Hash" hash]
        (sync (:wallet-lock this)
            (get (:transactions this) hash)
        )
    )

    ;;;
     ; Returns transactions from a specific pool.
     ;;
    #_method
    (defn #_"Map<Sha256Hash, Transaction>" Wallet''get-transaction-pool [#_"Wallet" this, #_"PoolType" pool]
        (sync (:wallet-lock this)
            (condp = pool
                :PoolType'UNSPENT (:unspent this)
                :PoolType'SPENT   (:spent this)
                :PoolType'PENDING (:pending this)
                :PoolType'DEAD    (:dead this)
                (throw (RuntimeException. (str "Unknown wallet transaction type " pool)))
            )
        )
    )

    ;;;
     ; Prepares the wallet for a blockchain replay.  Removes all transactions (as they would
     ; get in the way of the replay) and makes the wallet think it has never seen a block.
     ;;
    #_method
    (defn #_"Wallet" Wallet''reset [#_"Wallet" this]
        (sync (:wallet-lock this)
            (let [this (Wallet''clear-transactions-1 this)
                  this (assoc this :last-block-seen-hash nil)
                  this (assoc this :last-block-seen-height -1) ;; Magic value for 'never'.
                  this (assoc this :last-block-seen-time-secs 0)]
                (Wallet''save-later this)
                (Wallet''maybe-queue-on-wallet-changed this)
                this
            )
        )
    )

    ;;;
     ; Deletes transactions which appeared above the given block height from the wallet, but does not touch the keys.
     ; This is useful if you have some keys and wish to replay the block chain into the wallet in order to pick them up.
     ; Triggers auto saving.
     ;;
    #_method
    (defn #_"Wallet" Wallet''clear-transactions-2 [#_"Wallet" this, #_"int" __fromHeight]
        (sync (:wallet-lock this)
            (when (zero? __fromHeight) => (throw (UnsupportedOperationException.))
                (let [this (Wallet''clear-transactions-1 this)]
                    (Wallet''save-later this)
                    this
                )
            )
        )
    )

    #_method
    (defn- #_"Wallet" Wallet''clear-transactions-1 [#_"Wallet" this]
        (-> this
            (update :unspent empty)
            (update :spent empty)
            (update :pending empty)
            (update :dead empty)
            (update :transactions empty)
            (update :my-unspents empty)
        )
    )

    ;;;
     ; Clean up the wallet.  Currently, it only removes risky pending transaction from the wallet and only
     ; if their outputs have not been spent.
     ;;
    #_method
    (defn #_"void" Wallet''cleanup [#_"Wallet" this]
        (sync (:wallet-lock this)
            (let [#_"Iterator<Transaction>" it (.iterator (.values (:pending this)))
                  #_"int" n
                    (loop-when [n 0] (.hasNext it) => n
                        (let [#_"Transaction" tx (.next it) #_"Sha256Hash" hash (Transaction''get-hash tx)]
                            (when (and (Wallet''is-transaction-risky this, tx, nil) (not (:accept-risky-transactions this))) => (recur n)
                                (log/debug (str "Found risky transaction " hash " in wallet during cleanup."))
                                (if (Transaction''is-any-output-spent tx)
                                    (do
                                        (log/info (str "Cannot remove transaction " hash " from pending pool during cleanup, as it's already spent partially."))
                                        (recur n)
                                    )
                                    (do
                                        ;; Sync myUnspents with the change.
                                        (doseq [#_"TransactionInput" input (:inputs tx)]
                                            (when-let [#_"TransactionOutput" output (TransactionInput''get-connected-output input)]
                                                (when (TransactionOutput''is-mine output, this)
                                                    (assert-state (ยง ass this (update this :my-unspents .add output)))
                                                )
                                                (TransactionInput''disconnect input)
                                            )
                                        )
                                        (doseq [#_"TransactionOutput" output (:outputs tx)]
                                            (ยง ass this (update this :my-unspents .remove output))
                                        )

                                        (.remove it)
                                        (ยง ass this (update this :transactions .remove hash))
                                        (log/info (str "Removed transaction " hash " from pending pool during cleanup."))
                                        (recur (inc n))
                                    )
                                )
                            )
                        )
                    )]
                (when (pos? n)
                    (Wallet''is-consistent-or-throw this)
                    (Wallet''save-later this)
                    (log/info (str "Estimated balance is now: " (Coin''to-friendly-string (Wallet''get-balance-2t this, :BalanceType'ESTIMATED))))
                )
            )
        )
        nil
    )

    #_method
    (defn #_"{PoolType}" Wallet''get-containing-pools [#_"Wallet" this, #_"Transaction" tx]
        (sync (:wallet-lock this)
            (let [#_"Sha256Hash" hash (Transaction''get-hash tx)
                  add- #(if (contains? (%2 this), hash) (conj %1 %3) %1)]
                (-> (hash-set)
                    (add- :unspent :PoolType'UNSPENT)
                    (add- :spent   :PoolType'SPENT)
                    (add- :pending :PoolType'PENDING)
                    (add- :dead    :PoolType'DEAD)
                )
            )
        )
    )

    ;;;
     ; Returns a copy of the internal unspent outputs list.
     ;;
    #_method
    (defn #_"List<TransactionOutput>" Wallet''get-unspents [#_"Wallet" this]
        (sync (:wallet-lock this)
            (ArrayList. (:my-unspents this))
        )
    )

    ;;;
     ; Returns an immutable view of the transactions currently waiting for network confirmations.
     ;;
    #_method
    (defn #_"Collection<Transaction>" Wallet''get-pending-transactions [#_"Wallet" this]
        (sync (:wallet-lock this)
            (.values (:pending this))
        )
    )

    ;;;
     ; Returns the hash of the last seen best-chain block, or null if the wallet is too old to store this data.
     ;;
    #_method
    (defn #_"Sha256Hash" Wallet''get-last-block-seen-hash [#_"Wallet" this]
        (sync (:wallet-lock this)
            (:last-block-seen-hash this)
        )
    )

    ;;;
     ; Returns a {@link Date} representing the time extracted from the last best seen block header.  This timestamp
     ; is <b>not</b> the local time at which the block was first observed by this application but rather what the block
     ; (i.e. miner) self declares.  It is allowed to have some significant drift from the real time at which the block
     ; was found, although most miners do use accurate times.  If this wallet is old and does not have a recorded
     ; time then this method returns null.
     ;;
    #_method
    (defn #_"Date" Wallet''get-last-block-seen-time [#_"Wallet" this]
        (let [#_"long" secs (:last-block-seen-time-secs this)]
            (if (zero? secs) nil (Date. (* secs 1000)))
        )
    )

    ;;;
     ; Returns the balance of this wallet as calculated by the provided balanceType.
     ;;
    #_method
    (defn #_"Coin" Wallet''get-balance-2t [#_"Wallet" this, #_"BalanceType" type]
        (sync (:wallet-lock this)
            (case type
                (:BalanceType'AVAILABLE :BalanceType'AVAILABLE_SPENDABLE)
                    (let [#_"List<TransactionOutput>" all (Wallet''calculate-all-spend-candidates-3 this, true, (= type :BalanceType'AVAILABLE_SPENDABLE))
                          #_"CoinSelection" selection (CoinSelector'''select (:coin-selector this), Ledger'MAX_MONEY, all)]
                        (:value-gathered selection)
                    )
                (:BalanceType'ESTIMATED :BalanceType'ESTIMATED_SPENDABLE)
                    (let [#_"List<TransactionOutput>" all (Wallet''calculate-all-spend-candidates-3 this, false, (= type :BalanceType'ESTIMATED_SPENDABLE))]
                        (reduce Coin''add Coin'ZERO (map :coin-value all))
                    )
            )
        )
    )

    ;;;
     ; Returns the balance that would be considered spendable by the given coin selector, including watched outputs
     ; (i.e. balance includes outputs we don't have the private keys for).  Just asks it to select as many coins as
     ; possible and returns the total.
     ;;
    #_method
    (defn #_"Coin" Wallet''get-balance-2s [#_"Wallet" this, #_"CoinSelector" selector]
        (ensure some? selector)

        (sync (:wallet-lock this)
            (let [#_"List<TransactionOutput>" candidates (Wallet''calculate-all-spend-candidates-3 this, true, false)
                  #_"CoinSelection" selection (CoinSelector'''select selector, (Ledger''get-max-money (:ledger this)), candidates)]
                (:value-gathered selection)
            )
        )
    )

    ;;;
     ; Returns a future that will complete when the balance of the given type has become equal or larger to the
     ; given value.  If the wallet already has a large enough balance the future is returned in a pre-completed state.
     ; Note that this method is not blocking, if you want to actually wait immediately, you have to call .get() on
     ; the result.
     ;
     ; Also note that by the time the future completes, the wallet may have changed yet again if something else
     ; is going on in parallel, so you should treat the returned balance as advisory and be prepared for sending
     ; money to fail!  Finally please be aware that any listeners on the future will run either on the calling thread
     ; if it completes immediately, or eventually on a background thread if the balance is not yet at the right
     ; level.  If you do something that means you know the balance should be sufficient to trigger the future,
     ; you can use {@link Threading#waitForUserCode()} to block until the future had a
     ; chance to be updated.
     ;;
    #_method
    (defn #_"ListenableFuture<Coin>" Wallet''get-balance-future [#_"Wallet" this, #_"Coin" value, #_"BalanceType" type]
        (sync (:wallet-lock this)
            (let [#_"SettableFuture<Coin>" future (SettableFuture/create)
                  #_"Coin" balance (Wallet''get-balance-2t this, type)]
                (if (<= 0 (Coin'compare balance, value))
                    ;; Already have enough.
                    (.set future, balance)
                    ;; Will be checked later in checkBalanceFutures.  We don't just add an event listener for ourselves
                    ;; here so that running getBalanceFuture().get() in the user code thread works - generally we must
                    ;; avoid giving the user back futures that require the user code thread to be free.
                    (ยง ass this (update this :balance-future-requests .add (BalanceFutureRequest'new future, value, type)))
                )
                future
            )
        )
    )

    ;; Runs any balance futures in the user code thread.
    #_method
    (defn- #_"void" Wallet''check-balance-futures-locked [#_"Wallet" this]
        (assert-state (.isHeldByCurrentThread (:wallet-lock this)))

        (loop-when-recur [#_"ListIterator<BalanceFutureRequest>" it (.listIterator (:balance-future-requests this))] (.hasNext it) [it]
            (let [#_"BalanceFutureRequest" req (.next it)
                  #_"Coin" balance (Wallet''get-balance-2t this, (:balance-type req))] ;; This could be slow for lots of futures.
                (when (<= 0 (Coin'compare balance, (:balance-value req)))
                    ;; Found one that's finished.
                    (.remove it)
                    ;; Don't run any user-provided future listeners with our lock held.
                    (.execute Threading'USER_THREAD, #(.set (:future req), balance))
                )
            )
        )
        nil
    )

    ;;;
     ; Returns the amount of bitcoin ever received via output.  <b>This is not the balance!</b>  If an output
     ; spends from a transaction whose inputs are also to our wallet, the input amounts are deducted from the
     ; outputs contribution, with a minimum of zero contribution.  The idea behind this is we avoid double
     ; counting money sent to us.
     ;
     ; @return the total amount of satoshis received, regardless of whether it was spent or not.
     ;;
    #_method
    (defn #_"Coin" Wallet''get-total-received [#_"Wallet" this]
        (letfn [#_"Coin" (sum- [#_"Transaction" tx]
                    ;; Include outputs to us if they were not just change outputs,
                    ;; i.e. the inputs to us summed to less than the outputs to us.
                    (let [#_"Coin" sum Coin'ZERO
                          sum (->> (:outputs tx)
                                (filter #(TransactionOutput''is-mine %, this))
                                (map :coin-value)
                                (reduce Coin''add sum))
                          sum (->> (:inputs tx)
                                (map TransactionInput''get-connected-output)
                                (filter #(and (some? %) (TransactionOutput''is-mine %, this)))
                                (map :coin-value)
                                (reduce Coin''subtract sum))]
                        sum
                    )
                )]
            (->> (.values (:transactions this)) (map sum-) (filter Coin''positive?) (reduce Coin''add Coin'ZERO))
        )
    )

    ;;;
     ; Returns the amount of bitcoin ever sent via output.  If an output is sent to our own wallet, because of
     ; change or rotating keys or whatever, we do not count it.  If the wallet was involved in a shared transaction,
     ; i.e. there is some input to the transaction that we don't have the key for, then we multiply the sum of
     ; the output values by the proportion of satoshi coming in to our inputs.  Essentially we treat inputs as
     ; pooling into the transaction, becoming fungible and being equally distributed to all outputs.
     ;
     ; @return the total amount of satoshis sent by us.
     ;;
    #_method
    (defn #_"Coin" Wallet''get-total-sent [#_"Wallet" this]
        (letfn [#_"Coin" (sumo- [#_"Transaction" tx]
                    (->> (:outputs tx)
                            (remove #(TransactionOutput''is-mine %, this))
                            (map :coin-value)
                            (reduce Coin''add Coin'ZERO))
                )
                #_"Coin" (sumi- [#_"Transaction" tx]
                    (->> (:inputs tx)
                            (map TransactionInput''get-connected-output)
                            (filter #(and (some? %) (TransactionOutput''is-mine %, this)))
                            (map :coin-value)
                            (reduce Coin''add Coin'ZERO))
                )
                #_"Coin" (sum- [#_"Transaction" tx]
                    ;; Count spent outputs only if were not to us, thus we don't count change outputs.
                    ;; Count input values to us, possibly not from us, i.e. in a shared transaction.
                    (let [#_"Coin" sumo (sumo- tx) #_"Coin" sumi (sumi- tx) #_"Coin" sumi' (Transaction''get-input-sum tx)]
                        (when-not (= sumi sumi') => sumo
                            ;; Multiply our output sum by the appropriate proportion to account for the inputs that we don't own.
                            (let [#_"BigInteger" i (.divide (.multiply (BigInteger. (Coin''to-string sumo)), (BigInteger. (Coin''to-string sumi))), (BigInteger. (Coin''to-string sumi')))]
                                (Coin'new (.longValue i))
                            )
                        )
                    )
                )]
            (->> (.values (:transactions this)) (map sum-) (reduce Coin''add Coin'ZERO))
        )
    )

    ;;;
     ; Statelessly creates a transaction that sends the given value to address.  The change is sent to
     ; {@link Wallet#currentChangeAddress()}, so you must have added at least one key.
     ;
     ; If you just want to send money quickly, you probably want
     ; {@link Wallet#sendCoins(TransactionBroadcaster, Address, Coin)} instead.  That will create the sending
     ; transaction, commit to the wallet and broadcast it to the network all in one go.  This method is lower
     ; level and lets you see the proposed transaction before anything is done with it.
     ;
     ; This is a helper method that is equivalent to using {@link SendRequest#to(Address, Coin)}
     ; followed by {@link Wallet#completeTx(Wallet.SendRequest)} and returning the requests transaction object.
     ; Note that this means a fee may be automatically added if required, if you want more control over the process,
     ; just do those two steps yourself.
     ;
     ; IMPORTANT: This method does NOT update the wallet.  If you call createSend again you may get two transactions
     ; that spend the same coins.  You have to call {@link Wallet#commitTx(Transaction)} on the created transaction to
     ; prevent this, but that should only occur once the transaction has been accepted by the network.  This implies
     ; you cannot have more than one outstanding sending tx at once.
     ;
     ; You MUST ensure that the value is not smaller than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction
     ; will almost certainly be rejected by the network as dust.
     ;
     ; @param address The Bitcoin address to send the money to.
     ; @param value How much currency to send.
     ; @return either the created Transaction or null if there are insufficient coins.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_throws #_[ "InsufficientMoneyException" ]
    #_method
    (defn #_"Transaction" Wallet''create-send [#_"Wallet" this, #_"Address" address, #_"Coin" value]
        (let [#_"SendRequest" request (SendRequest'to-address address, value)]
            (ยง ass [this request] (Wallet''complete-tx this, request))
            (:tx request)
        )
    )

    ;;;
     ; Sends coins to the given address but does not broadcast the resulting pending transaction.  It is still
     ; stored in the wallet, so when the wallet is added to a {@link PeerGroup} or {@link Peer} the transaction
     ; will be announced to the network.  The given {@link SendRequest} is completed first using
     ; {@link Wallet#completeTx(Wallet.SendRequest)} to make it valid.
     ;
     ; @return the Transaction that was created.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_throws #_[ "InsufficientMoneyException" ]
    #_method
    (defn #_"Transaction" Wallet''send-coins-offline [#_"Wallet" this, #_"SendRequest" request]
        (sync (:wallet-lock this)
            (ยง ass [this request] (Wallet''complete-tx this, request))
            (ยง ass [this (:tx request)] (Wallet''commit-tx this, (:tx request)))
            (:tx request)
        )
    )

    ;;;
     ; Sends coins to the given address, via the given {@link PeerGroup}.  Change is returned to
     ; {@link Wallet#currentChangeAddress()}.  Note that a fee may be automatically added if one may be required
     ; for the transaction to be confirmed.
     ;
     ; The returned object provides both the transaction, and a future that can be used to learn when the broadcast
     ; is complete.  Complete means, if the PeerGroup is limited to only one connection, when it was written out to
     ; the socket.  Otherwise when the transaction is written out and we heard it back from a different peer.
     ;
     ; Note that the sending transaction is committed to the wallet immediately, not when the transaction is
     ; successfully broadcast.  This means that even if the network hasn't heard about your transaction you won't be
     ; able to spend those same coins again.
     ;
     ; You MUST ensure that value is not smaller than {@link Transaction#MIN_NONDUST_OUTPUT} or the transaction will
     ; almost certainly be rejected by the network as dust.
     ;
     ; @param broadcaster A {@link TransactionBroadcaster} to use to send the transactions out.
     ; @param to Which address to send coins to.
     ; @param value How much value to send.
     ; @return an object containing the transaction that was created, and a future for the broadcast of it.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_throws #_[ "InsufficientMoneyException" ]
    #_method
    (defn #_"SendResult" Wallet''send-coins-4 [#_"Wallet" this, #_"TransactionBroadcaster" broadcaster, #_"Address" to, #_"Coin" value]
        (let [#_"SendRequest" request (SendRequest'to-address to, value)]
            (Wallet''send-coins-3b this, broadcaster, request)
        )
    )

    ;;;
     ; Sends coins according to the given request, via the given {@link TransactionBroadcaster}.
     ;
     ; The returned object provides both the transaction, and a future that can be used to learn when the broadcast
     ; is complete.  Complete means, if the PeerGroup is limited to only one connection, when it was written out to
     ; the socket.  Otherwise when the transaction is written out and we heard it back from a different peer.
     ;
     ; Note that the sending transaction is committed to the wallet immediately, not when the transaction is
     ; successfully broadcast.  This means that even if the network hasn't heard about your transaction you won't be
     ; able to spend those same coins again.
     ;
     ; @param broadcaster The target to use for broadcast.
     ; @param request The SendRequest that describes what to do, get one using static methods on SendRequest itself.
     ; @return an object containing the transaction that was created, and a future for the broadcast of it.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_throws #_[ "InsufficientMoneyException" ]
    #_method
    (defn #_"SendResult" Wallet''send-coins-3b [#_"Wallet" this, #_"TransactionBroadcaster" broadcaster, #_"SendRequest" request]
        ;; Should not be locked here, as we're going to call into the broadcaster and that might want to hold its
        ;; own lock.  sendCoinsOffline handles everything that needs to be locked.
        (assert-state (not (.isHeldByCurrentThread (:wallet-lock this))))

        ;; Commit the TX to the wallet immediately so the spent coins won't be reused.
        ;; TODO: We should probably allow the request to specify tx commit only after the network has accepted it.
        (let [#_"Transaction" tx (Wallet''send-coins-offline this, request)
              #_"TransactionBroadcast" broadcast (TransactionBroadcaster'''broadcast-transaction-2 broadcaster, tx)]
            ;; The tx has been committed to the pending pool by this point (via sendCoinsOffline -> commitTx), so it has
            ;; a txConfidenceListener registered.  Once the tx is broadcast the peers will update the memory pool with the
            ;; count of seen peers, the memory pool will update the transaction confidence object, that will invoke the
            ;; txConfidenceListener which will in turn invoke the wallets event listener onTransactionConfidenceChanged
            ;; method.
            (assoc (SendResult'new tx) :broadcast broadcast, :broadcast-complete (:future broadcast))
        )
    )

    ;;;
     ; Satisfies the given {@link SendRequest} using the default transaction broadcaster configured either via
     ; {@link PeerGroup#addWallet(Wallet)} or directly with {@link #setTransactionBroadcaster(TransactionBroadcaster)}.
     ;
     ; @param request The SendRequest that describes what to do, get one using static methods on SendRequest itself.
     ; @return an object containing the transaction that was created, and a future for the broadcast of it.
     ; @throws IllegalStateException if no transaction broadcaster has been configured.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_throws #_[ "InsufficientMoneyException" ]
    #_method
    (defn #_"SendResult" Wallet''send-coins-2 [#_"Wallet" this, #_"SendRequest" request]
        (let [#_"TransactionBroadcaster" broadcaster (:v-transaction-broadcaster this)]
            (assert-state (some? broadcaster), "No transaction broadcaster is configured")
            (Wallet''send-coins-3b this, broadcaster, request)
        )
    )

    ;;;
     ; Sends coins to the given address, via the given {@link Peer}.  Change is returned to {@link Wallet#currentChangeAddress()}.
     ; If an exception is thrown by {@link Peer#sendMessage(Message)} the transaction is still committed, so the pending
     ; transaction must be broadcast <b>by you</b> at some other time.  Note that a fee may be automatically added
     ; if one may be required for the transaction to be confirmed.
     ;
     ; @return the {@link Transaction} that was created or null if there was insufficient balance to send the coins.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_throws #_[ "InsufficientMoneyException" ]
    #_method
    (defn #_"[Peer Transaction]" Wallet''send-coins-3p [#_"Wallet" this, #_"Peer" peer, #_"SendRequest" request]
        (let [#_"Transaction" tx (Wallet''send-coins-offline this, request)]
            [(Peer''send-message peer, tx, Transaction''to-wire) tx]
        )
    )

    ;;;
     ; Given a spend request containing an incomplete transaction, makes it valid by adding outputs and signed inputs
     ; according to the instructions in the request.  The transaction in the request is modified by this method.
     ;
     ; @param req A SendRequest that contains the incomplete transaction and details for how to make it valid.
     ; @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
     ; @throws IllegalArgumentException if you try and complete the same SendRequest twice.
     ; @throws DustySendRequested if the resultant transaction would violate the dust rules.
     ; @throws CouldNotAdjustDownwards if emptying the wallet was requested and the output can't be shrunk for fees without violating a protocol rule.
     ; @throws ExceededMaxTransactionSize if the resultant transaction is too big for Bitcoin to process.
     ; @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
     ;;
    #_throws #_[ "InsufficientMoneyException" ]
    #_method
    (defn #_"[Wallet SendRequest]" Wallet''complete-tx [#_"Wallet" this, #_"SendRequest" req]
        (sync (:wallet-lock this)
            (assert-argument (not (:completed req)), "Given SendRequest has already been completed.")

            ;; Calculate the amount of value we need to import.
            (let [#_"List<TransactionOutput>" outputs (:outputs (:tx req))
                  #_"Coin" value (reduce Coin''add Coin'ZERO (map :coin-value outputs))]

                (log/info (str "Completing send tx with " (count outputs) " outputs totalling " (Coin''to-friendly-string value) " and a fee of " (Coin''to-friendly-string (:fee-per-kb req)) "/kB"))

                ;; If any inputs have already been added, we don't need to get their value from wallet.
                (let [#_"Coin" sum
                        (->> (:inputs (:tx req))
                            (map TransactionInput''get-connected-output)
                            (filter #(or (some? %) (do (log/warn "SendRequest tx already has inputs, but we don't know how much they are worth - will be added to fee.") false)))
                            (map :coin-value)
                            (reduce Coin''add Coin'ZERO)
                        )
                      value (Coin''subtract value, sum)]

                    ;; Check for dusty sends and the OP_RETURN limit.
                    (when (and (:ensure-min-required-fee req) (not (:empty-wallet req))) ;; Min fee checking is handled later for emptyWallet.
                        (let [#_"int" n
                                (->> outputs
                                    (filter #(if (TransactionOutput''is-dust %) (throw+ (DustySendRequested'new)) (Script''is-op-return (TransactionOutput''parse-script-pub-key %))))
                                    (count)
                                )]
                            (when (< 1 n) ;; Only 1 OP_RETURN per transaction allowed.
                                (throw+ (MultipleOpReturnRequested'new))
                            )
                        )
                    )

                    ;; Calculate a list of ALL potential candidates for spending and then ask a coin selector to provide us
                    ;; with the actual outputs that'll be used to gather the required amount of value.  In this way, users
                    ;; can customize coin selection policies.  The call below will ignore immature coinbases and outputs
                    ;; we don't have the keys for.
                    (let [#_"List<TransactionOutput>" candidates (Wallet''calculate-all-spend-candidates-3 this, true, (= (:missing-sigs-mode req) :MissingSigsMode'THROW))
                          [candidates #_"CoinSelection" __bestCoinSelection #_"TransactionOutput" __bestChangeOutput #_"List<Coin>" __updatedOutputValues]
                            (if-not (:empty-wallet req)
                                ;; This can throw InsufficientMoneyException.
                                (let [#_"FeeCalculation" calc (Wallet''calculate-fee this, req, value, (:ensure-min-required-fee req), candidates)]
                                    [candidates (:best-coin-selection calc) (:best-change-output calc) (:updated-output-values calc)]
                                )
                                ;; We're being asked to empty the wallet.  What this means is ensuring "tx" has only a single output
                                ;; of the total value we can currently spend as determined by the selector, and then subtracting the fee.
                                (do (assert-state (= (count outputs) 1), "Empty wallet TX must have a single output only.")

                                    (let [#_"CoinSelector" selector (or (:coin-selector req) (:coin-selector this))
                                          __bestCoinSelection (CoinSelector'''select selector, (Ledger''get-max-money (:ledger this)), candidates)]
                                        (ยง ass (nth (:outputs (:tx req)) 0) (TransactionOutput''set-value (nth (:outputs (:tx req)) 0), (:value-gathered __bestCoinSelection)))
                                        (log/info (str "  emptying " (Coin''to-friendly-string (:value-gathered __bestCoinSelection))))
                                        ;; Selector took ownership and might have changed candidates.  Don't access again.
                                        [nil __bestCoinSelection nil nil]
                                    )
                                )
                            )]

                        (doseq [#_"TransactionOutput" output (:gathered __bestCoinSelection)]
                            (Transaction''add-input-o (:tx req), output)
                        )

                        (when (:empty-wallet req)
                            (let [#_"Coin" __feePerKb (or (:fee-per-kb req) Coin'ZERO)]
                                (when-not (Wallet''adjust-output-downwards-for-fee this, (:tx req), __bestCoinSelection, __feePerKb, (:ensure-min-required-fee req))
                                    (throw+ (CouldNotAdjustDownwards'new))
                                )
                            )
                        )

                        (when (some? __updatedOutputValues)
                            (dotimes [#_"int" i (count __updatedOutputValues)]
                                (ยง ass (nth (:outputs (:tx req)) i) (TransactionOutput''set-value (nth (:outputs (:tx req)) i), (nth __updatedOutputValues i)))
                            )
                        )

                        (when (some? __bestChangeOutput)
                            (Transaction''add-output (:tx req), __bestChangeOutput)
                            (log/info (str "  with " (Coin''to-friendly-string (:coin-value __bestChangeOutput)) " change"))
                        )

                        ;; Now shuffle the outputs to obfuscate which is the change.
                        (let [req (if (:shuffle-outputs req) (update req :tx Transaction''shuffle-outputs) req)
                              ;; Now sign the inputs, thus proving that we are entitled to redeem the connected outputs.
                              this (if (:sign-inputs req) (Wallet''sign-transaction this, req) this)]
                            ;; Check size.
                            (when (< Transaction'MAX_STANDARD_TX_SIZE (count (Message''to-bytes (:tx req), Transaction''to-wire)))
                                (throw+ (ExceededMaxTransactionSize'new))
                            )

                            ;; Label the transaction as being self created.  We can use this later to spend its change output even before
                            ;; the transaction is confirmed.  We deliberately won't bother notifying listeners here as there's not much
                            ;; point - the user isn't interested in a confidence transition they made themselves.
                            (ยง ass (Transaction''get-confidence (:tx req)) (assoc (Transaction''get-confidence (:tx req)) :confidence-source :ConfidenceSource'SELF))
                            ;; Label the transaction as being a user requested payment.  This can be used to render GUI wallet
                            ;; transaction lists more appropriately, especially when the wallet starts to generate transactions itself
                            ;; for internal purposes.
                            (let [req (assoc-in req [:tx :purpose] :TransactionPurpose'USER_PAYMENT)
                                  ;; Record the exchange rate that was valid when the transaction was completed.
                                  req (assoc-in req [:tx :exchange-rate] (:exchange-rate req))
                                  req (assoc-in req [:tx :memo] (:memo req))
                                  req (assoc req :completed true)]
                                (log/info (str "  completed: " (:tx req)))
                                [this req]
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Given a send request containing transaction, attempts to sign it's inputs.  This method expects
     ; the transaction to have all necessary inputs connected or they will be ignored.
     ;
     ; Actual signing is done by pluggable {@link #signers} and it's not guaranteed that
     ; the transaction will be complete in the end.
     ;;
    #_method
    (defn #_"Wallet" Wallet''sign-transaction [#_"Wallet" this, #_"SendRequest" req]
        (sync (:wallet-lock this)
            (let [#_"Transaction" tx (:tx req) #_"List<TransactionInput>" inputs (:inputs tx) #_"List<TransactionOutput>" outputs (:outputs tx)]
                (assert-state (and (seq inputs) (seq outputs)))

                (dotimes [#_"int" i (count inputs)]
                    (let [#_"TransactionInput" input (nth (:inputs tx) i) #_"TransactionOutput" output (TransactionInput''get-connected-output input)]
                        (when (some? output) ;; Else missing connected output, assuming already signed.
                            (let [#_"Script" __inSig (TransactionInput''get-script-sig input) #_"Script" __outKey (TransactionOutput''parse-script-pub-key output)]
                                (try+
                                    ;; We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                                    ;; we sign missing pieces (to check this would require either assuming any signatures are signing
                                    ;; standard output types or a way to get processed signatures out of script execution).
                                    (Script''correctly-spends __inSig, tx, i, __outKey, Script'ALL_VERIFY_FLAGS)
                                    (log/warn (str "Input " i " already correctly spends output, assuming SIGHASH type used will be safe and skipping signing."))
                                    (ยง catch ScriptException e
                                        (log/debug e, "Input contained an incorrect signature")
                                        (let [#_"RedeemData" data (TransactionOutPoint''get-connected-redeem-data (:outpoint input), this)]
                                            (ensure some? data, (str "Transaction exists in wallet that we cannot redeem: " (:from-tx-hash (:outpoint input))))
                                            (ยง ass input (TransactionInput''set-script-sig input, (Script''create-empty-input-script __outKey, (first (:redeem-keys data)), (:redeem-script data))))
                                        )
                                    )
                                )
                            )
                        )
                    )
                )

                (let [#_"ProposedTransaction" proposal (ProposedTransaction'new tx)]
                    (doseq [#_"TransactionSigner" signer (:signers this)]
                        (when-not (TransactionSigner'''sign-inputs signer, proposal, this)
                            (log/info (str (.getName (.getClass signer)) " returned false for the tx"))
                        )
                    )
                    ;; Resolve missing sigs if any.
                    (TransactionSigner'''sign-inputs (MissingSigResolutionSigner'new (:missing-sigs-mode req)), proposal, this)
                )
            )
        )
        this
    )

    ;;;
     ; Reduce the value of the first output of a transaction to pay the given feePerKb as appropriate for its size.
     ;;
    #_method
    (defn- #_"boolean" Wallet''adjust-output-downwards-for-fee [#_"Wallet" this, #_"Transaction" tx, #_"CoinSelection" selection, #_"Coin" __feePerKb, #_"boolean" quantum?]
        (let [#_"int" size (+ (count (Message''to-bytes tx, Transaction''to-wire)) (Wallet''estimate-bytes-for-signing this, selection))
              #_"Coin" fee (Coin''divide (Coin''multiply __feePerKb, size), 1000)
              fee (if (and quantum? (Coin''less-than? fee, Transaction'REFERENCE_DEFAULT_MIN_TX_FEE)) Transaction'REFERENCE_DEFAULT_MIN_TX_FEE fee)
              #_"TransactionOutput" output (nth (:outputs tx) 0)]
            (ยง ass output (TransactionOutput''set-value output, (Coin''subtract (:coin-value output), fee)))
            (not (TransactionOutput''is-dust output))
        )
    )

    ;;;
     ; Returns a list of the outputs that can potentially be spent, i.e. that we have the keys for and are unspent
     ; according to our knowledge of the block chain.
     ;;
    #_method
    (defn #_"List<TransactionOutput>" Wallet''calculate-all-spend-candidates-1 [#_"Wallet" this]
        (Wallet''calculate-all-spend-candidates-3 this, true, true)
    )

    ;;;
     ; Returns a list of all outputs that are being tracked by this wallet taking into account the flags.
     ;
     ; @param excludeImmatureCoinbases Whether to ignore coinbase outputs that we will be able to spend in future once they mature.
     ; @param excludeUnsignable Whether to ignore outputs that we are tracking but don't have the keys to sign for.
     ;;
    #_method
    (defn #_"List<TransactionOutput>" Wallet''calculate-all-spend-candidates-3 [#_"Wallet" this, #_"boolean" -immature?, #_"boolean" -unsignable?]
        (sync (:wallet-lock this)
            (let [#_"List<TransactionOutput>" candidates (ArrayList. (count (:my-unspents this)))]
                (doseq [#_"TransactionOutput" output (:my-unspents this)]
                    (when (or (not -unsignable?) (Wallet''can-sign-for this, (TransactionOutput''parse-script-pub-key output)))
                        (let [#_"Transaction" tx (ensure some? (:parent-tx output))]
                            (when (or (not -immature?) (Transaction''is-mature tx))
                                (ยง ass candidates (.add candidates, output))
                            )
                        )
                    )
                )
                candidates
            )
        )
    )

    ;;;
     ; Returns true if this wallet has at least one of the private keys needed to sign for this scriptPubKey.
     ; Returns false if the form of the script is not known or if the script is OP_RETURN.
     ;;
    #_method
    (defn #_"boolean" Wallet''can-sign-for [#_"Wallet" this, #_"Script" script]
        (cond
            (Script''is-sent-to-raw-pub-key script)
                (let [#_"ECKey" key (KeyBag'''find-key-from-pub-key this, (Script''get-pub-key script))]
                    (and (some? key) (ECKey'''has-priv-key key))
                )
            (Script''is-pay-to-script-hash script)
                (let [#_"RedeemData" data (KeyBag'''find-redeem-data-from-script-hash this, (Script''get-pub-key-hash script))]
                    (and (some? data) (Wallet''can-sign-for this, (:redeem-script data)))
                )
            (Script''is-sent-to-address script)
                (let [#_"ECKey" key (KeyBag'''find-key-from-pub-hash this, (Script''get-pub-key-hash script))]
                    (and (some? key) (ECKey'''has-priv-key key))
                )
            (Script''is-sent-to-multi-sig script)
                (->> (Script''get-pub-keys script)
                    (map #(KeyBag'''find-key-from-pub-key this, (ECKey''get-pub-key %)))
                    (some #(and (some? %) (ECKey'''has-priv-key %)))
                )
            (Script''is-sent-to-cltv-payment-channel script)
                ;; Any script for which we are the recipient or sender counts.
                (let [#_"byte[]" sender (Script''get-cltv-payment-channel-sender-pub-key script)
                      #_"ECKey" __senderKey (KeyBag'''find-key-from-pub-key this, sender)]
                    (or (and (some? __senderKey) (ECKey'''has-priv-key __senderKey))
                        (let [#_"byte[]" recipient (Script''get-cltv-payment-channel-recipient-pub-key script)
                              #_"ECKey" __recipientKey (KeyBag'''find-key-from-pub-key this, recipient)]
                            (and (some? __recipientKey) (ECKey'''has-priv-key __recipientKey))
                        )
                    )
                )
            :else
                false
        )
    )

    ;;;
     ; Returns the {@link CoinSelector} object which controls which outputs can be spent by this wallet.
     ;;
    #_method
    (defn #_"CoinSelector" Wallet''get-coin-selector [#_"Wallet" this]
        (sync (:wallet-lock this)
            (:coin-selector this)
        )
    )

    ;;;
     ; A coin selector is responsible for choosing which outputs to spend when creating transactions.  The default
     ; selector implements a policy of spending transactions that appeared in the best chain and pending transactions
     ; that were created by this wallet, but not others.  You can override the coin selector for any given send
     ; operation by changing {@link SendRequest#coinSelector}.
     ;;
    #_method
    (defn #_"Wallet" Wallet''set-coin-selector [#_"Wallet" this, #_"CoinSelector" selector]
        (sync (:wallet-lock this)
            (assoc this :coin-selector (ensure some? selector))
        )
    )

    ;;;
     ; Don't call this directly.  It's not intended for API users.
     ;
     ; Called by the {@link SPVBlockChain} when the best chain (representing total work done) has changed.
     ; This can cause the number of confirmations of a transaction to go higher, lower, drop to zero and
     ; can even result in a transaction going dead (will never confirm) due to a double spend.
     ;
     ; The oldBlocks/newBlocks lists are ordered height-wise from top first to bottom last.
     ;;
    #_throws #_[ "VerificationException" ]
    #_override
    (defn #_"Wallet" ReorganizeListener'''reorganize [#_"Wallet" this, #_"StoredBlock" __splitPoint, #_"List<StoredBlock>" __oldBlocks, #_"List<StoredBlock>" __newBlocks]
        (sync (:wallet-lock this)
            ;; This runs on any peer thread with the block chain locked.
            ;;
            ;; The reorganize functionality of the wallet is tested in ChainSplitTest.java
            ;;
            ;; receive() has been called on the block that is triggering the re-org before this is called,
            ;; with type of SIDE_CHAIN.
            ;;
            ;; Note that this code assumes blocks are not invalid - if blocks contain duplicated transactions,
            ;; transactions that double spend etc then we can calculate the incorrect result.  This could open up
            ;; obscure DoS attacks if someone successfully mines a throwaway invalid block and feeds it to us, just
            ;; to try and corrupt the internal data structures.  We should try harder to avoid this but it's tricky
            ;; because there are so many ways the block can be invalid.

            ;; Avoid spuriously informing the user of wallet/tx confidence changes whilst we're re-organizing.
            (let [_ (assert-state (zero? (count (:confidence-changed this))))
                  _ (assert-state (not (:inside-reorg this)))
                  this (assoc this :inside-reorg true)
                  _ (assert-state (zero? (:on-wallet-changed-suppressions this)))
                  this (update this :on-wallet-changed-suppressions inc)]

                ;; Map block hash to transactions that appear in it.  We ensure that the map values are sorted according
                ;; to their relative position within those blocks.
                (let [#_"ArrayListMultimap<Sha256Hash, TxOffsetPair>" __mapBlockTx (ArrayListMultimap/create)]
                    (doseq [#_"Transaction" tx (Wallet''get-transactions this, true)]
                        (when-let [#_"Map<Sha256Hash, Integer>" __appearsIn (:appears-in-hashes tx)] ;; Else pending.
                            (doseq [#_"Map.Entry<Sha256Hash, Integer>" e (.entrySet __appearsIn)]
                                (ยง ass __mapBlockTx (assoc __mapBlockTx (.getKey e) (TxOffsetPair'new tx, (.getValue e))))
                            )
                        )
                    )
                    (doseq [#_"Sha256Hash" __blockHash (.keySet __mapBlockTx)]
                        (ยง ass (get __mapBlockTx __blockHash) (sort TxOffsetPair'compare (get __mapBlockTx __blockHash)))
                    )

                    (let [#_"List<Sha256Hash>" __oldBlockHashes (ArrayList. (count __oldBlocks))]
                        (log/info "Old part of chain (top to bottom):")
                        (doseq [#_"StoredBlock" b __oldBlocks]
                            (log/info (str "  " (Block''get-hash (:stored-header b))))
                            (ยง ass __oldBlockHashes (.add __oldBlockHashes, (Block''get-hash (:stored-header b))))
                        )
                        (log/info "New part of chain (top to bottom):")
                        (doseq [#_"StoredBlock" b __newBlocks]
                            (log/info (str "  " (Block''get-hash (:stored-header b))))
                        )

                        (Collections/reverse __newBlocks) ;; Need bottom-to-top but we get top-to-bottom.

                        ;; For each block in the old chain, disconnect the transactions in reverse order.
                        (let [#_"LinkedList<Transaction>" __oldChainTxns (LinkedList.)]
                            (doseq [#_"Sha256Hash" __blockHash __oldBlockHashes #_"TxOffsetPair" pair (get __mapBlockTx __blockHash)]
                                (let [#_"Transaction" tx (:tx pair) #_"Sha256Hash" __txHash (Transaction''get-hash tx)]
                                    (cond (Transaction''is-coin-base tx)
                                        (do
                                            ;; All the transactions that we have in our wallet which spent this coinbase are now invalid
                                            ;; and will never confirm.  Hopefully this should never happen - that's the point of the maturity
                                            ;; rule that forbids spending of coinbase transactions for 100 blocks.
                                            ;;
                                            ;; This could be recursive, although of course because we don't have the full transaction
                                            ;; graph we can never reliably kill all transactions we might have that were rooted in
                                            ;; this coinbase tx.  Some can just go pending forever, like the Bitcoin Core.  However we
                                            ;; can do our best.
                                            (log/warn (str "Coinbase killed by re-org: " __txHash))
                                            (ยง ass this (Wallet''kill-txns this, (ImmutableSet/of tx), nil))
                                        )
                                        :else
                                        (do
                                            (doseq [#_"TransactionOutput" output (:outputs tx)]
                                                (when-let [#_"TransactionInput" input (:spent-by output)]
                                                    (when (TransactionOutput''is-mine output, this)
                                                        (assert-state (ยง ass this (update this :my-unspents .add output)))
                                                    )
                                                    (TransactionInput''disconnect input)
                                                )
                                            )
                                            (ยง ass __oldChainTxns (.add __oldChainTxns, tx))
                                            (ยง ass this (update this :unspent .remove __txHash))
                                            (ยง ass this (update this :spent .remove __txHash))
                                            (assert-state (not (contains? (:pending this) __txHash)))
                                            (assert-state (not (contains? (:dead this) __txHash)))
                                        )
                                    )
                                )
                            )

                            ;; Put all the disconnected transactions back into the pending pool and re-connect them.
                            (doseq [#_"Transaction" tx __oldChainTxns]
                                ;; Coinbase transactions on the old part of the chain are dead for good and won't come back unless
                                ;; there's another re-org.
                                (when-not (Transaction''is-coin-base tx)
                                    (log/info (str "  ->pending " (Transaction''get-hash tx)))

                                    ;; Wipe height/depth/work data.
                                    (ยง ass (Transaction''get-confidence tx) (TransactionConfidence''set-confidence-type (Transaction''get-confidence tx), :ConfidenceType'PENDING))

                                    (ยง ass this (update this :confidence-changed assoc tx :ConfidenceChangeReason'TYPE))
                                    (ยง ass this (Wallet''add-wallet-transaction this, :PoolType'PENDING, tx))
                                    (Wallet''update-for-spends this, tx, false)
                                )
                            )

                            ;; Note that dead transactions stay dead.  Consider a chain that Finney attacks T1 and replaces it
                            ;; with T2, so we move T1 into the dead pool.  If there's now a re-org to a chain that doesn't include
                            ;; T2, it doesn't matter - the miners deleted T1 from their mempool, will resurrect T2 and put that
                            ;; into the mempool and so T1 is still seen as a losing double spend.

                            ;; The old blocks have contributed to the depth for all the transactions in the wallet
                            ;; that are in blocks up to and including the chain split block.
                            ;; The total depth is calculated here and then subtracted from the appropriate transactions.
                            (let [this
                                    (let [#_"int" n (count __oldBlocks)]
                                        (log/info (str "depthToSubtract = " n))
                                        ;; Remove depthToSubtract from all transactions in the wallet except for pending.
                                        (let [this (Wallet''subtract-depth this, n, (.values (:spent this)))
                                              this (Wallet''subtract-depth this, n, (.values (:unspent this)))
                                              this (Wallet''subtract-depth this, n, (.values (:dead this)))]
                                            this
                                        )
                                    )
                                  ;; The effective last seen block is now the split point so set the lastSeenBlockHash.
                                  this (assoc this :last-block-seen-hash (Block''get-hash (:stored-header __splitPoint)))]

                                ;; For each block in the new chain, work forwards calling receive() and notifyNewBestBlock().
                                ;; This will pull them back out of the pending pool, or if the tx didn't appear in the old chain
                                ;; and does appear in the new chain, will treat it as such and possibly kill pending transactions
                                ;; that conflict.
                                (doseq [#_"StoredBlock" block __newBlocks]
                                    (log/info (str "Replaying block " (Block''get-hash (:stored-header block))))
                                    (doseq [#_"TxOffsetPair" pair (get __mapBlockTx (Block''get-hash (:stored-header block)))]
                                        (log/info (str "  tx " (Transaction''get-hash (:tx pair))))
                                        (ยง ass this (Wallet''receive this, (:tx pair), block, :NewBlockType'BEST_CHAIN, (:offset pair)))
                                    )
                                    (ยง ass this (NewBestBlockListener'''notify-new-best-block this, block))
                                )

                                (Wallet''is-consistent-or-throw this)

                                (let [#_"Coin" balance (Wallet''get-balance-2t this, :BalanceType'AVAILABLE)]
                                    (log/info (str "post-reorg balance is " (Coin''to-friendly-string balance)))
                                    ;; Inform event listeners that a re-org took place.
                                    (Wallet''queue-on-reorganize this)
                                    (let [this (assoc this :inside-reorg false)
                                        this (update this :on-wallet-changed-suppressions dec)]
                                        (Wallet''maybe-queue-on-wallet-changed this)
                                        (Wallet''check-balance-futures-locked this)
                                        (Wallet''inform-confidence-listeners-if-not-reorganizing this)
                                        (Wallet''save-later this)
                                        this
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    ;;;
     ; Subtract the supplied depth from the given transactions.
     ;;
    #_method
    (defn- #_"Wallet" Wallet''subtract-depth [#_"Wallet" this, #_"int" depth, #_"Collection<Transaction>" transactions]
        (doseq [#_"Transaction" tx transactions]
            (let-when [#_"TransactionConfidence" confidence (Transaction''get-confidence tx)] (= (:confidence-type confidence) :ConfidenceType'BUILDING)
                (ยง ass confidence (update confidence :depth-in-blocks - depth))
                (ยง ass this (update this :confidence-changed assoc tx :ConfidenceChangeReason'DEPTH))
            )
        )
        this
    )

    ;;;
     ; PeerFilterProvider is a protocol providing the information required to properly filter data downloaded from Peers.
     ; Note that an implementer is responsible for calling {@link PeerGroup#recalculateFastCatchupAndFilter(PeerGroup.FilterRecalculateMode)}
     ; whenever a change occurs which effects the data provided via this interface.
     ;;

    ;;;
     ; Returns the earliest timestamp (seconds since epoch) for which full/bloom-filtered blocks must be downloaded.
     ; Blocks with timestamps before this time will only have headers downloaded.  0 requires that all blocks be
     ; downloaded, and thus this should default to {@link System#currentTimeMillis()}/1000.
     ;;
    ;;;
     ; Returns the earliest creation time of keys or watched scripts in this wallet, in seconds since the epoch,
     ; i.e. the min of {@link ECKey#getCreationTimeSeconds()}.  This can return zero if at least
     ; one key does not have that data (was created before key timestamping was implemented).
     ;
     ; This method is most often used in conjunction with {@link PeerGroup#setFastCatchupTimeSecs(long)} in order to
     ; optimize chain download for new users of wallet apps.  Backwards compatibility notice: if you get zero from this
     ; method, you can instead use the time of the first release of your software, as it's guaranteed no users will
     ; have wallets pre-dating this time.
     ;
     ; If there are no keys in the wallet, the current time is returned.
     ;;
    #_method
    (defn #_"long" Wallet''get-earliest-key-creation-time [#_"Wallet" this]
        (sync (:keychaingroup-lock this)
            (let [#_"long" earliest (KeyChainGroup''get-earliest-key-creation-time (:key-chain-group this))]
                (if (= earliest Long/MAX_VALUE) (Time'seconds) earliest)
            )
        )
    )

    ;;;
     ; Called on all registered filter providers before getBloomFilterElementCount and getBloomFilter are called.
     ; Once called, the provider should ensure that the items it will want to insert into the filter don't change.
     ; The reason is that all providers will have their element counts queried, and then a filter big enough for
     ; all of them will be specified.  So the provider must use consistent state.  There is guaranteed to be
     ; a matching call to endBloomFilterCalculation that can be used to e.g. unlock a lock.
     ;;
    #_method
    (defn #_"void" Wallet''lock-bloom-filter-calculation [#_"Wallet" this]
        (.lock (:wallet-lock this))
        (.lock (:keychaingroup-lock this))
        nil
    )

    #_method
    (defn #_"TransactionOutPoint*" Wallet''bloom-filter-outpoints-locked [#_"Wallet" this]
        (assert-state (.isHeldByCurrentThread (:wallet-lock this)))
        (assert-state (.isHeldByCurrentThread (:keychaingroup-lock this)))

        (for [#_"Transaction" tx (Wallet''get-transactions this, false) #_"TransactionOutput" output (:outputs tx) :when (Wallet''is-tx-output-bloom-filterable this, output)]
            (TransactionOutput''get-outpoint-for output)
        )
    )

    #_method
    (defn #_"void" Wallet''unlock-bloom-filter-calculation [#_"Wallet" this]
        (.unlock (:keychaingroup-lock this))
        (.unlock (:wallet-lock this))
        nil
    )

    ;;;
     ; Gets a bloom filter that contains all the necessary elements for the listener to receive relevant transactions.
     ; Default value should be an empty bloom filter with the given size, falsePositiveRate, and nTweak.
     ;;
    ;;;
     ; Gets a bloom filter that contains all of the public keys from this wallet, and which will provide the given
     ; false-positive rate if it has size elements.  Keep in mind that you will get 2 elements in the bloom filter for
     ; each key in the wallet, for the public key and the hash of the public key (address form).
     ;
     ; This is used to generate a BloomFilter which can be {@link BloomFilter#merge(BloomFilter)}d with another.
     ; It could also be used if you have a specific target for the filter's size.
     ;
     ; See the docs for {@link BloomFilter(int, double)} for a brief explanation of anonymity when using bloom filters.
     ;;
    #_method
    (defn #_"BloomFilter" Wallet''create-bloom-filter-locked [#_"Wallet" this, #_"int" size, #_"double" rate, #_"long" tweak]
        (assert-state (.isHeldByCurrentThread (:wallet-lock this)))
        (assert-state (.isHeldByCurrentThread (:keychaingroup-lock this)))

        (let [#_"TransactionOutPoint*" outpoints (Wallet''bloom-filter-outpoints-locked this)
              size (or size (+ (KeyChainGroup''count-bloom-filter-elements (:key-chain-group this)) (count outpoints)))
              #_"BloomFilter" filter (KeyChainGroup''create-bloom-filter (:key-chain-group this), size, rate, tweak)]
            (reduce BloomFilter''insert-data filter (map #(Message''to-bytes %, TransactionOutPoint''to-wire) outpoints))
        )
    )

    ;;;
     ; Gets a bloom filter that contains all of the public keys from this wallet, and which will provide the given
     ; false-positive rate.  See the docs for {@link BloomFilter} for a brief explanation of anonymity when using filters.
     ;;
    #_method
    (defn #_"BloomFilter" Wallet''create-bloom-filter [#_"Wallet" this, #_"double" rate]
        (Wallet''lock-bloom-filter-calculation this)
        (try
            (Wallet''create-bloom-filter-locked this, nil, rate, (long (* (Math/random) Long/MAX_VALUE)))
            (finally
                (Wallet''unlock-bloom-filter-calculation this)
            )
        )
    )

    ;; Returns true if the output is one that won't be selected by a data element matching in the scriptSig.
    #_method
    (defn- #_"boolean" Wallet''is-tx-output-bloom-filterable [#_"Wallet" this, #_"TransactionOutput" output]
        (let [#_"Script" script (TransactionOutput''parse-script-pub-key output)
              #_"boolean" supported? (or (Script''is-sent-to-raw-pub-key script) (Script''is-pay-to-script-hash script))]
            (and supported? (contains? (:my-unspents this) output))
        )
    )

    ;;;
     ; Used by {@link Peer} to decide whether or not to discard this block and any blocks building upon it, in case
     ; the Bloom filter used to request them may be exhausted, that is, not have sufficient keys in the deterministic
     ; sequence within it to reliably find relevant transactions.
     ;;
    #_method
    (defn #_"boolean" Wallet''check-for-filter-exhaustion [#_"Wallet" this, #_"FilteredBlock" block]
        (sync (:keychaingroup-lock this)
            (let [#_"int" epoch (KeyChainGroup''get-combined-key-lookahead-epochs (:key-chain-group this))]
                (doseq [#_"Transaction" tx (.values (:associated-transactions block))]
                    (ยง ass this (Wallet''mark-keys-as-used this, tx))
                )
                (let [#_"int" epoch' (KeyChainGroup''get-combined-key-lookahead-epochs (:key-chain-group this))]
                    (assert-state (<= epoch epoch'))
                    ;; If the key lookahead epoch has advanced, there was a call to importKeys and the PeerGroup already has a
                    ;; pending request to recalculate the filter queued up on another thread.  The calling Peer should abandon
                    ;; block at this point and await a new filter before restarting the download.
                    (< epoch epoch')
                )
            )
        )
    )

    #_throws #_[ "InsufficientMoneyException" ]
    #_method
    (defn- #_"FeeCalculation" Wallet''calculate-fee [#_"Wallet" this, #_"SendRequest" req, #_"Coin" value, #_"boolean" quantum?, #_"List<TransactionOutput>" candidates]
        (assert-state (.isHeldByCurrentThread (:wallet-lock this)))

        (loop [#_"Coin" fee Coin'ZERO]
            (let [#_"FeeCalculation" calc (FeeCalculation'new) #_"Transaction" tx (Transaction'new (:ledger this))]
                (Wallet''add-supplied-inputs this, tx, (:inputs (:tx req)))

                (let [#_"Coin" __valueNeeded (if (:recipients-pay-fees req) value (Coin''add value, fee))
                      calc (if (:recipients-pay-fees req) (assoc calc :updated-output-values (ArrayList. #_"<Coin>")) calc)
                      #_"List<TransactionOutput>" outputs (:outputs (:tx req))]

                    (loop-when-recur [#_"int" i 0] (< i (count outputs)) [(inc i)]
                        (let [#_"TransactionOutput" output (TransactionOutput'from-wire (:ledger this), (ByteBuffer/wrap (Message''to-bytes (nth outputs i), TransactionOutput''to-wire)), tx)]
                            (when (:recipients-pay-fees req)
                                ;; Subtract fee equally from each selected recipient.
                                (ยง ass output (TransactionOutput''set-value output, (Coin''subtract (:coin-value output), (Coin''divide fee, (count outputs)))))
                                ;; First receiver pays the remainder not divisible by output count.
                                (when (zero? i)
                                    ;; Subtract fee equally from each selected recipient.
                                    (ยง ass output (TransactionOutput''set-value output, (Coin''subtract (:coin-value output), (Coin''remainder fee, (count outputs)))))
                                )
                                (ยง ass (:updated-output-values calc) (.add (:updated-output-values calc), (:coin-value output)))
                                (when (Coin''greater-than? (TransactionOutput''get-min-non-dust-value-1 output), (:coin-value output))
                                    (throw+ (CouldNotAdjustDownwards'new))
                                )
                            )
                            (Transaction''add-output tx, output)
                        )
                    )

                    (let [#_"CoinSelector" selector (or (:coin-selector req) (:coin-selector this))
                          ;; selector is allowed to modify candidates list.
                          #_"CoinSelection" selection (CoinSelector'''select selector, __valueNeeded, (LinkedList. candidates))
                          calc (assoc calc :best-coin-selection selection)]
                        ;; Can we afford this?
                        (when (Coin''less-than? (:value-gathered selection), __valueNeeded)
                            (let [#_"Coin" missing (Coin''subtract __valueNeeded, (:value-gathered selection))]
                                (throw+ (InsufficientMoneyException'new missing))
                            )
                        )

                        (let [#_"Coin" change (Coin''subtract (:value-gathered selection), __valueNeeded)
                              [fee calc]
                                (when (Coin''positive? change) => [fee calc]
                                    ;; The value of the inputs is greater than what we want to send.  Just like in real life then,
                                    ;; we need to take back some coins ... this is called "change".  Add another output that sends the change
                                    ;; back to us.  The address comes either from the request or currentChangeAddress() as a default.
                                    (let [#_"Address" __changeAddress (or (:change-address req) (Wallet''current-change-address this))
                                          #_"TransactionOutput" __changeOutput (TransactionOutput'for-address (:ledger this), tx, change, __changeAddress)]
                                        (when (and (:recipients-pay-fees req) (TransactionOutput''is-dust __changeOutput))
                                            ;; We do not move dust-change to fees, because the sender would end up paying more than requested.
                                            ;; This would be against the purpose of the all-inclusive feature.
                                            ;; So instead we raise the change and deduct from the first recipient.
                                            (let [#_"Coin" __missingToNotBeDust (Coin''subtract (TransactionOutput''get-min-non-dust-value-1 __changeOutput), (:coin-value __changeOutput))]
                                                (ยง ass __changeOutput (TransactionOutput''set-value __changeOutput, (Coin''add (:coin-value __changeOutput), __missingToNotBeDust)))
                                                (let [#_"TransactionOutput" __firstOutput (nth (:outputs tx) 0)]
                                                    (ยง ass __firstOutput (TransactionOutput''set-value __firstOutput, (Coin''subtract (:coin-value __firstOutput), __missingToNotBeDust)))
                                                    (.set (:updated-output-values calc), 0, (:coin-value __firstOutput))
                                                    (when (TransactionOutput''is-dust __firstOutput)
                                                        (throw+ (CouldNotAdjustDownwards'new))
                                                    )
                                                )
                                            )
                                        )

                                        (cond (TransactionOutput''is-dust __changeOutput)
                                            (do
                                                ;; Never create dust outputs; if we would, just add the dust to the fee.
                                                ;; Oscar comment: This seems like a way to make the condition below "if (!fee.isLessThan(feeNeeded))" to become true.
                                                ;; This is a non-easy to understand way to do that.
                                                ;; Maybe there are other effects I am missing.
                                                [(Coin''add fee, (:coin-value __changeOutput)) calc]
                                            )
                                            :else
                                            (do
                                                (Transaction''add-output tx, __changeOutput)
                                                [fee (assoc calc :best-change-output __changeOutput)]
                                            )
                                        )
                                    )
                                )]

                            (doseq [#_"TransactionOutput" __selectedOutput (:gathered selection)]
                                (let [#_"TransactionInput" input (Transaction''add-input-o tx, __selectedOutput)]
                                    ;; If the scriptBytes don't default to none, our size calculations will be thrown off.
                                    (assert-state (zero? (count (:script-bytes input))))
                                )
                            )

                            (let [#_"int" size (+ (count (Message''to-bytes tx, Transaction''to-wire)) (Wallet''estimate-bytes-for-signing this, selection))
                                  #_"Coin" __feePerKb (:fee-per-kb req)
                                  __feePerKb (if (and quantum? (Coin''less-than? __feePerKb, Transaction'REFERENCE_DEFAULT_MIN_TX_FEE))
                                        Transaction'REFERENCE_DEFAULT_MIN_TX_FEE
                                        __feePerKb
                                    )
                                  #_"Coin" __feeNeeded (Coin''divide (Coin''multiply __feePerKb, size), 1000)]

                                ;; Include more fee and try again.  ;; Done, enough fee included.
                                (recur-if (Coin''less-than? fee, __feeNeeded) __feeNeeded => calc)
                            )
                        )
                    )
                )
            )
        )
    )

    #_method
    (defn- #_"void" Wallet''add-supplied-inputs [#_"Wallet" this, #_"Transaction" tx, #_"List<TransactionInput>" inputs]
        (doseq [#_"TransactionInput" input inputs]
            (Transaction''add-input tx, (TransactionInput'new-unconnected (:ledger this), tx, (Message''to-bytes input, TransactionInput''to-wire)))
        )
        nil
    )

    #_method
    (defn- #_"int" Wallet''estimate-bytes-for-signing [#_"Wallet" this, #_"CoinSelection" selection]
        (letfn [#_"int" (size- [#_"TransactionOutput" output]
                    (try+
                        (let [#_"Script" script (TransactionOutput''parse-script-pub-key output)
                              [#_"ECKey" key #_"Script" redeem]
                                (cond
                                    (Script''is-sent-to-address script)
                                    (let [key (KeyBag'''find-key-from-pub-hash this, (Script''get-pub-key-hash script))]
                                        [(ensure some? key, "Coin selection includes unspendable outputs") nil]
                                    )
                                    (Script''is-pay-to-script-hash script)
                                    (let [redeem (:redeem-script (KeyBag'''find-redeem-data-from-script-hash this, (Script''get-pub-key-hash script)))]
                                        [nil (ensure some? redeem, "Coin selection includes unspendable outputs")]
                                    )
                                )]
                            (Script''get-number-of-bytes-required-to-spend script, key, redeem)
                        )
                        (ยง catch ScriptException e
                            ;; If this happens it means an output script in a wallet tx could not be understood.  That
                            ;; should never happen, if it does it means the wallet has got into an inconsistent state.
                            (throw (IllegalStateException. e))
                        )
                    )
                )]
            (reduce + (map size- (:gathered selection)))
        )
    )

    ;; Wallet maintenance transactions.  These transactions may not be directly connected to a payment the user is
    ;; making.  They may be instead key rotation transactions for when old keys are suspected to be compromised,
    ;; de/re-fragmentation transactions for when our output sizes are inappropriate or suboptimal, privacy transactions
    ;; and so on.  Because these transactions may require user intervention in some way (e.g. entering their password)
    ;; the wallet application is expected to poll the Wallet class to get SendRequests.  Ideally security systems like
    ;; hardware wallets or risk analysis providers are programmed to auto-approve transactions that send from our own
    ;; keys back to our own keys.

    ;;;
     ; Specifies that the given {@link TransactionBroadcaster}, typically a {@link PeerGroup}, should be used for
     ; sending transactions to the Bitcoin network by default.  Some sendCoins methods let you specify a broadcaster
     ; explicitly, in that case, they don't use this broadcaster.  If null is specified then the wallet won't attempt
     ; to broadcast transactions itself.
     ;
     ; You don't normally need to call this.  A {@link PeerGroup} will automatically set itself as the wallets
     ; broadcaster when you use {@link PeerGroup#addWallet(Wallet)}.  A wallet can use the broadcaster when you ask
     ; it to send money, but in future also at other times to implement various features that may require asynchronous
     ; re-organisation of the wallet contents on the block chain.  For instance, in future the wallet may choose to
     ; optimise itself to reduce fees or improve privacy.
     ;;
    #_method
    (defn #_"Wallet" Wallet''set-transaction-broadcaster [#_"Wallet" this, #_"TransactionBroadcaster" broadcaster]
        (let-when [[this #_"Transaction*" __toBroadcast]
                (sync (:wallet-lock this)
                    (when-not (= (:v-transaction-broadcaster this) broadcaster) => [this nil]
                        (let [this (assoc this :v-transaction-broadcaster broadcaster)]
                            (when (some? broadcaster) => [this nil]
                                [this (vals (:pending this))]
                            )
                        )
                    )
                )] (some? __toBroadcast) => this

            ;; Now use it to upload any pending transactions we have that are marked as not being seen by any peers yet.
            ;; Don't hold the wallet lock whilst doing this, so if the broadcaster accesses the wallet at some point there
            ;; is no inversion.
            (doseq [#_"Transaction" tx __toBroadcast]
                (let [#_"ConfidenceType" type (:confidence-type (Transaction''get-confidence tx))]
                    (assert-state (any = type :ConfidenceType'PENDING :ConfidenceType'IN_CONFLICT), (str "Expected PENDING or IN_CONFLICT, was " type "."))
                    ;; Re-broadcast even if it's marked as already seen for two reasons:
                    ;; 1. Old wallets may have transactions marked as broadcast by 1 peer when
                    ;;    in reality the network never saw it, due to bugs.
                    ;; 2. It can't really hurt.
                    (log/info (str "New broadcaster so uploading waiting tx " (Transaction''get-hash tx)))
                    (TransactionBroadcaster'''broadcast-transaction-2 broadcaster, tx)
                )
            )
            this
        )
    )

    ;;;
     ; When a key rotation time is set, and money controlled by keys created before the given timestamp T will be
     ; automatically respent to any key that was created after T.  This can be used to recover from a situation where
     ; a set of keys is believed to be compromised.  Once the time is set transactions will be created and broadcast
     ; immediately.  New coins that come in after calling this method will be automatically respent immediately.
     ; The rotation time is persisted to the wallet. You can stop key rotation by calling this method again with zero
     ; as the argument.
     ;;
    #_method
    (defn #_"Wallet" Wallet''set-key-rotation-time-d [#_"Wallet" this, #_"Date" time]
        (Wallet''set-key-rotation-time-l this, (quot (.getTime time) 1000))
    )

    ;;;
     ; Returns the key rotation time, or null if unconfigured.
     ; See {@link #setKeyRotationTime(Date)} for a description of the field.
     ;;
    #_method
    (defn #_"Date" Wallet''get-key-rotation-time [#_"Wallet" this]
        (let [#_"long" time (:v-key-rotation-timestamp this)]
            (when-not (zero? time) (Date. (* time 1000)))
        )
    )

    ;;;
     ; When a key rotation time is set, any money controlled by keys created before the given timestamp T will be
     ; automatically respent to any key that was created after T.  This can be used to recover from a situation where
     ; a set of keys is believed to be compromised.  You can stop key rotation by calling this method again with zero
     ; as the argument.  Once set up, calling {@link #doMaintenance(boolean)} will create and possibly send rotation
     ; transactions: but it won't be done automatically (because you might have to ask for the users password).
     ;
     ; The given time cannot be in the future.
     ;;
    #_method
    (defn #_"Wallet" Wallet''set-key-rotation-time-l [#_"Wallet" this, #_"long" secs]
        (assert-argument (<= secs (Time'seconds)), (str "Given time (" (Time'format-seconds secs) ") cannot be in the future."))

        (let [this (assoc this :v-key-rotation-timestamp secs)]
            (Wallet''save-now this)
            this
        )
    )

    ;;; Returns whether the keys creation time is before the key rotation time, if one was set. ;;
    #_method
    (defn #_"boolean" Wallet''is-key-rotating [#_"Wallet" this, #_"ECKey" key]
        (let [#_"long" time (:v-key-rotation-timestamp this)]
            (and (not= time 0) (< (ECKey'''get-creation-time-seconds key) time))
        )
    )

    ;;;
     ; A wallet app should call this from time to time in order to let the wallet craft and send transactions needed
     ; to re-organise coins internally.  A good time to call this would be after receiving coins for an unencrypted
     ; wallet, or after sending money for an encrypted wallet.  If you have an encrypted wallet and just want to know
     ; if some maintenance needs doing, call this method with andSend set to false and look at the returned list of
     ; transactions.  Maintenance might also include internal changes that involve some processing or work but
     ; which don't require making transactions - these will happen automatically unless the password is required
     ; in which case an exception will be thrown.
     ;
     ; @param signAndSend If true, send the transactions via the tx broadcaster and return them, if false just return them.
     ; @return a list of transactions that the wallet just made/will make for internal maintenance.  Might be empty.
     ;;
    #_method
    (defn #_"ListenableFuture<List<Transaction>>" Wallet''do-maintenance [#_"Wallet" this, #_"boolean" sign?]
        (let [#_"List<Transaction>" txns
                (sync (:wallet-lock this)
                    (sync (:keychaingroup-lock this)
                        (Wallet''maybe-rotate-keys this, sign?)
                    )
                )]
            (when sign? => (Futures/immediateFuture txns)
                (assert-state (not (.isHeldByCurrentThread (:wallet-lock this))))

                (let [#_"ArrayList<ListenableFuture<Transaction>>" futures (ArrayList. (count txns))
                      #_"TransactionBroadcaster" broadcaster (:v-transaction-broadcaster this)]
                    (doseq [#_"Transaction" tx txns]
                        (try
                            (let [#_"ListenableFuture<Transaction>" future (:future (TransactionBroadcaster'''broadcast-transaction-2 broadcaster, tx))]
                                (ยง ass futures (.add futures, future))
                                (Futures/addCallback future,
                                    (reify FutureCallback #_"<Transaction>"
                                        #_foreign
                                        #_override
                                        (#_"void" onSuccess [#_"FutureCallback" __, #_"Transaction" tx]
                                            (log/info (str "Successfully broadcast key rotation tx: " tx))
                                            nil
                                        )

                                        #_foreign
                                        #_override
                                        (#_"void" onFailure [#_"FutureCallback" __, #_"Throwable" th]
                                            (log/error th, "Failed to broadcast key rotation tx")
                                            nil
                                        )
                                    )
                                )
                            )
                            (catch Exception e
                                (log/error e, "Failed to broadcast rekey tx")
                            )
                        )
                    )
                    (Futures/allAsList futures)
                )
            )
        )
    )

    #_method
    (defn- #_"Transaction" Wallet''rekey-one-batch [#_"Wallet" this, #_"long" secs, #_"List<Transaction>" others, #_"boolean" sign?]
        (sync (:wallet-lock this)
            ;; Build the transaction using some custom logic for our special needs.  Last parameter to
            ;; KeyTimeCoinSelector is whether to ignore pending transactions or not.
            ;;
            ;; We ignore pending outputs because trying to rotate these is basically racing an attacker, and
            ;; we're quite likely to lose and create stuck double spends.  Also, some users who have 0.9 wallets
            ;; have already got stuck double spends in their wallet due to the Bloom-filtering block reordering
            ;; bug that was fixed in 0.10, thus, making a re-key transaction depend on those would cause it to
            ;; never confirm at all.
            (let [#_"FilteringCoinSelector" selector (FilteringCoinSelector'new (KeyTimeCoinSelector'new this, secs, true))]
                (doseq [#_"Transaction" other others]
                    (FilteringCoinSelector''exclude-outputs-spent-by selector, other)
                )
                ;; TODO: Make this use the standard SendRequest.
                (let [#_"CoinSelection" __toMove (CoinSelector'''select selector, Coin'ZERO, (Wallet''calculate-all-spend-candidates-1 this))]
                    (when-not (Coin''zero? (:value-gathered __toMove)) => nil ;; Nothing to do.
                        (let [#_"Transaction" tx (Transaction'new (:ledger this))]
                            (doseq [#_"TransactionOutput" output (:gathered __toMove)]
                                (Transaction''add-input-o tx, output)
                            )
                            ;; When not signing, don't waste addresses.
                            (Transaction''add-output-ca tx, (:value-gathered __toMove), (if sign? (Wallet''fresh-receive-address this) (Wallet''current-receive-address this)))
                            (cond (Wallet''adjust-output-downwards-for-fee this, tx, __toMove, Transaction'DEFAULT_TX_FEE, true)
                                (do
                                    (ยง ass (Transaction''get-confidence tx) (assoc (Transaction''get-confidence tx) :confidence-source :ConfidenceSource'SELF))
                                    (ยง ass tx (assoc tx :purpose :TransactionPurpose'KEY_ROTATION))
                                    (let [#_"SendRequest" req (SendRequest'for-tx tx)]
                                        (when sign?
                                            (ยง ass this (Wallet''sign-transaction this, req))
                                        )
                                        ;; KeyTimeCoinSelector should never select enough inputs to push us oversize.
                                        (assert-state (< (count (Message''to-bytes tx, Transaction''to-wire)) Transaction'MAX_STANDARD_TX_SIZE))
                                        tx
                                    )
                                )
                                :else
                                (do
                                    (log/error "Failed to adjust rekey tx for fees.")
                                    nil
                                )
                            )
                        )
                    )
                )
            )
        )
    )

    ;; Checks to see if any coins are controlled by rotating keys and if so, spends them.
    #_method
    (defn- #_"List<Transaction>" Wallet''maybe-rotate-keys [#_"Wallet" this, #_"boolean" sign?]
        (assert-state (.isHeldByCurrentThread (:wallet-lock this)))
        (assert-state (.isHeldByCurrentThread (:keychaingroup-lock this)))

        (let [#_"List<Transaction>" results (LinkedList.)
              ;; TODO: Handle chain replays here.
              #_"long" stamp (:v-key-rotation-timestamp this)]
            (when-not (zero? stamp) => results ;; Nothing to do.
                ;; We might have to create a new HD hierarchy if the previous ones are now rotating.
                (when-not (some #(<= stamp (DeterministicKeyChain''get-earliest-key-creation-time %)) (:chains (:key-chain-group this)))
                    (log/info "All HD chains are currently rotating, creating fresh HD chain ...")
                    (ยง ass this (update this :key-chain-group KeyChainGroup''create-and-activate-new-hd-chain))
                    (Wallet''save-now this)
                )
                ;; Because transactions are size limited, we might not be able to re-key the entire wallet in one go.  So loop
                ;; around here until we no longer produce transactions with the max number of inputs.  That means we're fully
                ;; done, at least for now (we may still get more transactions later and this method will be reinvoked).
                (loop []
                    (when-let [#_"Transaction" tx (Wallet''rekey-one-batch this, stamp, results, sign?)]
                        (ยง ass results (.add results, tx))
                        (recur-if (= (count (:inputs tx)) KeyTimeCoinSelector'MAX_SIMULTANEOUS_INPUTS) [])
                    )
                )
                results
            )
        )
    )

    #_method
    (defn- #_"void" Wallet''to-string-helper [#_"Wallet" this, #_"Map<Sha256Hash, Transaction>" pool, #_"Comparator<Transaction>" order, #_"BlockChain" chain, #_"StringBuilder" sb]
        (assert-state (.isHeldByCurrentThread (:wallet-lock this)))

        (let [#_"Collection<Transaction>" txns
                (when (some? order) => (.values pool)
                    (let [txns (TreeSet. order)]
                        (ยง ass txns (.addAll txns, (.values pool)))
                        txns
                    )
                )]

            (doseq [#_"Transaction" tx txns]
                (try+
                    (.. sb (append (Coin''to-friendly-string (Transaction''get-value tx, this))))
                    (.. sb (append " total value (sends "))
                    (.. sb (append (Coin''to-friendly-string (Transaction''get-value-sent-from-me tx, this))))
                    (.. sb (append " and receives "))
                    (.. sb (append (Coin''to-friendly-string (Transaction''get-value-sent-to-me tx, this))))
                    (.. sb (append ")\n"))
                    (ยง catch ScriptException _
                        ;; Ignore and don't print this line.
                    )
                )
                (when (Transaction''has-confidence tx)
                    (.. sb (append "  confidence: ") (append (Transaction''get-confidence tx)) (append "\n"))
                )
                (.. sb (append (Transaction''to-string tx, chain)))
            )
        )
        nil
    )

    ;;;
     ; Formats the wallet as a human readable piece of text.  Intended for debugging, the format is
     ; not meant to be stable or human readable.
     ;
     ; @param includePrivateKeys Whether raw private key data should be included.
     ; @param includeTransactions Whether to print transaction data.
     ; @param chain If set, will be used to estimate lock times for block timelocked transactions.
     ;;
    #_method
    (defn #_"String" Wallet''to-string
        ([#_"Wallet" this] (Wallet''to-string this, true, nil))
        ([#_"Wallet" this, #_"boolean" txns?, #_"BlockChain" chain]
            (sync (:wallet-lock this)
                (sync (:keychaingroup-lock this)
                    (let [#_"StringBuilder" sb (StringBuilder. (<< 1 8))
                          #_"Coin" estimated (Wallet''get-balance-2t this, :BalanceType'ESTIMATED)
                          #_"Coin" available (Wallet''get-balance-2t this, :BalanceType'AVAILABLE_SPENDABLE)]
                        (.. sb (append "Wallet containing ") (append (Coin''to-friendly-string estimated)) (append " (spendable: ") (append (Coin''to-friendly-string available)) (append ") in:\n"))
                        (.. sb (append "  ") (append (count (:pending this))) (append " pending transactions\n"))
                        (.. sb (append "  ") (append (count (:unspent this))) (append " unspent transactions\n"))
                        (.. sb (append "  ") (append (count (:spent this))) (append " spent transactions\n"))
                        (.. sb (append "  ") (append (count (:dead this))) (append " dead transactions\n"))
                        (let [#_"Date" date (Wallet''get-last-block-seen-time this)]
                            (.. sb (append "Last seen best block: ") (append (:last-block-seen-height this)) (append " (") (append (if (some? date) (Time'format (.getTime date)) "time unknown")) (append "): ") (append (Wallet''get-last-block-seen-hash this)) (append "\n"))
                        )
                        (when (Wallet''is-watching this)
                            (.. sb (append "Wallet is watching.\n"))
                        )
                        ;; Do the keys.
                        (.. sb (append "\nKeys:\n"))
                        (.. sb (append "Earliest creation time: ") (append (Time'format-seconds (Wallet''get-earliest-key-creation-time this))) (append "\n"))
                        (when-let [#_"Date" date (Wallet''get-key-rotation-time this)]
                            (.. sb (append "Key rotation time:      ") (append (Time'format (.getTime date))) (append "\n"))
                        )
                        (.. sb (append (KeyChainGroup''to-string (:key-chain-group this))))
                        (when txns?
                            ;; Print the transactions themselves.
                            (when (seq (:pending this))
                                (.. sb (append "\n>>> PENDING:\n"))
                                (Wallet''to-string-helper this, (:pending this), Transaction'compare-by-update-time, chain, sb)
                            )
                            (when (seq (:unspent this))
                                (.. sb (append "\n>>> UNSPENT:\n"))
                                (Wallet''to-string-helper this, (:unspent this), Transaction'compare-by-chain-height, chain, sb)
                            )
                            (when (seq (:spent this))
                                (.. sb (append "\n>>> SPENT:\n"))
                                (Wallet''to-string-helper this, (:spent this), Transaction'compare-by-chain-height, chain, sb)
                            )
                            (when (seq (:dead this))
                                (.. sb (append "\n>>> DEAD:\n"))
                                (Wallet''to-string-helper this, (:dead this), Transaction'compare-by-update-time, chain, sb)
                            )
                        )
                        (.toString sb)
                    )
                )
            )
        )
    )
)

(ยง ns bitclojn.core
    (:refer-clojure :exclude [ensure subvec sync vec vector vector-of when when-not])
    (:use [bitclojn slang])
)

(defn -main [& args]
    )
